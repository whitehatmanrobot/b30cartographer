is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdPosX, &avPosX);
        BackupAttrValue (*ppAA, ppdPosY, &avPosY);
        BackupAttrValue (*ppAA, ppdBackgroundRepeat, &avRepeat);
        BackupAttrValue (*ppAA, ppdBackgroundImage, &avImage);
        BackupAttrValue (*ppAA, ppdBackgroundAttachment, &avAttachment);
        BackupAttrValue (*ppAA, ppdBackgroundColor, &avColor);
    }


    if ( !pcszBGString )
        pcszBGString = _T("");

    pszCopy = pszNextToken = pszString = new(Mt(ParseBackgroundProperty_pszCopy)) TCHAR [_tcslen( pcszBGString ) + 1 ];

    if ( !pszCopy )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy( pszCopy, pcszBGString );

    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = NextParenthesizedToken( pszString );

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        hr = ppdBackgroundRepeat->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );

        if ( hr != S_OK )
        {
            hr = ppdBackgroundAttachment->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );

            if ( hr != S_OK )
            {
                if ( ValidStyleUrl( pszString ) > 0 || !_tcsicmp( pszString, _T("none") ) )
                {
                    hr = ppdBackgroundImage->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
                    fSeenBGImage = TRUE;
                }
                else
                {   // Try it as a color
                    hr = ppdBackgroundColor->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
                    if ( hr == S_OK )
                    {   // We decided this was a color.
                        fSeenBGColor = TRUE;
                        continue;
                    }
                    else    // Not a color.
                    {   // First see if it's a measurement string
                        BOOL fTriedOneWay = FALSE;

                        // If two numeric values given, horizontal comes first (CSS spec).  If keywords
                        // are used ("top", "left" etc), order is irrelevant.
                        if ( !fSeenXPos )
                        {
TryAsX:
                            hr = ppdPosX->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
                            if ( hr == S_OK )
                            {
                                fSeenXPos = TRUE;
                                if ( pszLastXToken && !fSeenYPos )
                                {
                                    if ( ppdPosY->TryLoadFromString (
                                            dwOpCode, pszLastXToken, pObject, ppAA ) == S_OK )
                                        fSeenYPos = TRUE;
                                }

                                pszLastXToken = pszString;
                                continue;
                            }
                            else if ( !fTriedOneWay )
                            {
                                fTriedOneWay = TRUE;
                                goto TryAsY;
                            }
                        }

                        if ( !fSeenYPos )
                        {
TryAsY:
                            hr = ppdPosY->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
                            if ( hr == S_OK )
                            {
                                fSeenYPos = TRUE;
                                continue;
                            }
                            else if ( !fTriedOneWay )
                            {
                                fTriedOneWay = TRUE;
                                goto TryAsX;
                            }
                        }
                    }

                    // The string could not be recognized as a valid background spec. We bail out in
                    // strict css1 mode
                    if (fIsStrictCSS1) 
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                    
                    // Not a background string... return if we're in validate mode.
                    if ( bValidate )
                    {
                        hr = E_INVALIDARG;
                        break;
                    }
                } // end if else test for color
            } // end if test for background-attachment failure
            else
                fSeenBGAttachment = TRUE;
        } // end if test for background-repeat failure
        else
            fSeenBGRepeat = TRUE;
    } // end for next token
    if ( fSeenXPos ^ fSeenYPos )
    {   // If only one set, must set the other to "50%" as per the CSS spec.
        pPropertyDesc = fSeenXPos ? ppdPosY : ppdPosX;

#ifdef WIN16
        hr = (pPropertyDesc->pfnHandleProperty)( pPropertyDesc, (dwOpCode|(PROPTYPE_LPWSTR<<16)),
                            (CVoid *)_T("50%"), pObject, (CVoid *) ppAA );
#else
        hr = CALL_METHOD( pPropertyDesc, pPropertyDesc->pfnHandleProperty, ( (dwOpCode|(PROPTYPE_LPWSTR<<16)),
                            (CVoid *)_T("50%"), pObject, (CVoid *) ppAA ));
#endif
    }

    if ( !fSeenXPos && !fSeenYPos )
    {
        ppdPosX->TryLoadFromString ( dwOpCode, _T("0%"), pObject, ppAA );
        ppdPosY->TryLoadFromString ( dwOpCode, _T("0%"), pObject, ppAA );
    }

    if ( !fSeenBGImage )
        ppdBackgroundImage->TryLoadFromString ( dwOpCode, _T("none"), pObject, ppAA );
    if ( !fSeenBGColor )
        ppdBackgroundColor->TryLoadFromString ( dwOpCode, _T("transparent"), pObject, ppAA );
    if ( !fSeenBGRepeat )
        ppdBackgroundRepeat->TryLoadFromString ( dwOpCode, _T("repeat"), pObject, ppAA );
    if ( !fSeenBGAttachment )
        ppdBackgroundAttachment->TryLoadFromString ( dwOpCode, _T("scroll"), pObject, ppAA );

Cleanup:
    if (hr == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdPosX, &avPosX);
                RestoreAttrArray(*ppAA, ppdPosY, &avPosY);
                RestoreAttrArray(*ppAA, ppdBackgroundAttachment, &avAttachment);
                RestoreAttrArray(*ppAA, ppdBackgroundColor, &avColor);
                RestoreAttrArray(*ppAA, ppdBackgroundImage, &avImage);
                RestoreAttrArray(*ppAA, ppdBackgroundRepeat, &avRepeat);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // Clean up the temporary attribute backups
        avPosX.Free();
        avPosY.Free();
        avAttachment.Free();
        avColor.Free();
        avImage.Free();
        avRepeat.Free();
    }

    delete[] pszCopy ;
    RRETURN1( hr, E_INVALIDARG);
}

typedef struct {
    const TCHAR *szName;
    Esysfont eType;
} SystemFontName;

const SystemFontName asSystemFontNames[] =
{
    { _T("caption"), sysfont_caption },
    { _T("icon"), sysfont_icon },
    { _T("menu"), sysfont_menu },
    { _T("message-box"), sysfont_messagebox },
    { _T("messagebox"), sysfont_messagebox },
    { _T("small-caption"), sysfont_smallcaption },
    { _T("smallcaption"), sysfont_smallcaption },
    { _T("status-bar"), sysfont_statusbar },
    { _T("statusbar"), sysfont_statusbar }
};

int RTCCONV
CompareSysFontPairsByName( const void * pv1, const void * pv2 )
{
    return StrCmpIC( ((SystemFontName *)pv1)->szName,
                     ((SystemFontName *)pv2)->szName );
}

Esysfont FindSystemFontByName( const TCHAR * szString )
{
    SystemFontName sPotentialSysFont;

    sPotentialSysFont.szName = szString;

    SystemFontName *pFont = (SystemFontName *)bsearch( &sPotentialSysFont,
                                              asSystemFontNames,
                                              ARRAY_SIZE(asSystemFontNames),
                                              sizeof(SystemFontName),
                                              CompareSysFontPairsByName );
    if ( pFont )
        return pFont->eType;
    return sysfont_non_system;
}


//+------------------------------------------------------------------------
//
//  Function:     ::ParseFontProperty
//
//  Synopsis:
//      This function reads an aggregate font property string from the given
//  data string, setting the internal data of the CAttrArray to reflect any
//  font weight, style, variant, size, line-height, or families set by the string.
//-------------------------------------------------------------------------
HRESULT ParseFontProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszFontString )
{
    LPTSTR pszString, pszCopy;
    LPTSTR  pszNextToken;
    HRESULT hResult = S_OK;
    TCHAR chTerminator;
    BOOL fFontWeight  = FALSE;
    BOOL fFontStyle   = FALSE;
    BOOL fFontVariant = FALSE;

    PROPERTYDESC* ppdWeight     = (PROPERTYDESC*)&s_propdescCStylefontWeight.a;
    PROPERTYDESC* ppdStyle      = (PROPERTYDESC*)&s_propdescCStylefontStyle.a;
    PROPERTYDESC* ppdVariant    = (PROPERTYDESC*)&s_propdescCStylefontVariant.a;
    PROPERTYDESC* ppdSize       = (PROPERTYDESC*)&s_propdescCStylefontSize.a;
    PROPERTYDESC* ppdLineHeight = (PROPERTYDESC*)&s_propdescCStylelineHeight.a;
    PROPERTYDESC* ppdFamily     = (PROPERTYDESC*)&s_propdescCStylefontFamily.a;

    // The following variables are needed for backing up the attributes. They are used for restoring in error cases in strict CSS1 mode
    CAttrValue avWeight, avStyle, avSize, avVariant, avLineHeight, avFamily;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdWeight, &avWeight);
        BackupAttrValue (*ppAA, ppdStyle, &avStyle);
        BackupAttrValue (*ppAA, ppdVariant, &avVariant);
        BackupAttrValue (*ppAA, ppdSize, &avSize);
        BackupAttrValue (*ppAA, ppdLineHeight, &avLineHeight);
        BackupAttrValue (*ppAA, ppdFamily, &avFamily);
    }

    if ( !pcszFontString || !*pcszFontString )
        return E_INVALIDARG;

    pszCopy = pszNextToken = pszString = new(Mt(ParseFontProperty_pszCopy)) TCHAR [_tcslen( pcszFontString ) + 1 ];
    if ( !pszString )
    {
        hResult = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy( pszCopy, pcszFontString );

    // Peel off (and handle) any font weight, style, or variant strings at the beginning
    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = pszString;

        while ( *pszNextToken && !_istspace( *pszNextToken ) )
            pszNextToken++;

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        // Try font weight handler first
        hResult = ppdWeight->TryLoadFromString( dwOpCode, pszString, pObject, ppAA );
        if ( hResult == S_OK )
        {
            if (fIsStrictCSS1 && fFontWeight && fFontStyle && fFontVariant)
            {
                hResult = E_INVALIDARG;
                goto Cleanup;
            }
            fFontWeight = TRUE;
            continue;   // token was a font weight - go on to next token
        }

        // Try font style handler next
        hResult = ppdStyle->TryLoadFromString( dwOpCode, pszString, pObject, ppAA );
        if ( hResult == S_OK )
        {
            if (fIsStrictCSS1 && fFontWeight && fFontStyle && fFontVariant)
            {
                hResult = E_INVALIDARG;
                goto Cleanup;
            }
            fFontStyle = TRUE;
            continue;   // token was a font style - go on to next token
        }

        // Try font variant handler last
        hResult = ppdVariant->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
        if ( hResult == S_OK )
        {
            if (fIsStrictCSS1 && fFontWeight && fFontStyle && fFontVariant)
            {
                hResult = E_INVALIDARG;
                goto Cleanup;
            }
            fFontVariant = TRUE;
            continue;   // token was a font variant - go on to next token
        }

        break;  // String was unrecognized; must be a font-size.
    }

    if ( !*pszString )
    {
        hResult = E_INVALIDARG;
        goto Cleanup;
    }

    if ( *pszNextToken )    // If we replaced a space with a NULL, unreplace it.
        *(pszNextToken - 1) = _T(' ');

    pszNextToken = NextSize( pszString, &s_propdescCStylefontSize.b);

    if ( !pszNextToken )
    {
        hResult = E_INVALIDARG;
        goto Cleanup;
    }

    chTerminator = *pszNextToken;
    *pszNextToken = _T('\0');

    hResult = ppdSize->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
    if ( hResult != S_OK )
        goto Cleanup;

    *pszNextToken = chTerminator;
    while ( _istspace( *pszNextToken ) )
        pszNextToken++;

    if ( *pszNextToken == _T('/') )
    {   // There is a line-height value present
        pszString = ++pszNextToken;
        pszNextToken = fIsStrictCSS1 ? NextParenthesizedToken ( pszString ) : NextSize( pszString, &s_propdescCStylelineHeight.b );

        if ( !pszNextToken )
        {
            hResult = E_INVALIDARG;
            if (fIsStrictCSS1)
                goto Cleanup;
            else
                goto SetDefaults;
        }

        chTerminator = *pszNextToken;
        *pszNextToken = _T('\0');

        hResult = ppdLineHeight->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
        if ( hResult != S_OK )
        {
            if (fIsStrictCSS1)
                goto Cleanup;
            else
                goto SetDefaults;
        }

        *pszNextToken = chTerminator;
        while ( _istspace( *pszNextToken ) )
            pszNextToken++;
    }
    else
    {
        hResult = ppdLineHeight->TryLoadFromString ( dwOpCode, _T("normal"), pObject, ppAA );
        if ( hResult != S_OK )
            if (fIsStrictCSS1)
                goto Cleanup;
            else
                goto SetDefaults;
    }

    if ( !*pszNextToken )
    {
        hResult = E_INVALIDARG;
        if (fIsStrictCSS1)
            goto Cleanup;
        else
            goto SetDefaults;
    }

    if ( OPCODE(dwOpCode) == HANDLEPROP_AUTOMATION )
    {
        BSTR bstr;

        hResult = FormsAllocString( pszNextToken, &bstr );
        if ( hResult )
            goto SetDefaults;

        hResult = s_propdescCStylefontFamily.b.SetStringProperty( bstr, pObject, (CVoid *)ppAA );

        FormsFreeString( bstr );

        if ( hResult )
            goto SetDefaults;
    }
    else
    {
        hResult = ppdFamily->TryLoadFromString ( dwOpCode, pszNextToken, pObject, ppAA );
        if (hResult && fIsStrictCSS1)
            goto Cleanup; // in strict
    }

SetDefaults:
    // Set the default font weight
    if ( !fFontWeight )
        ppdWeight->TryLoadFromString ( dwOpCode, _T("normal"), pObject, ppAA );

    // Set the default font style
    if ( !fFontStyle )
        ppdStyle->TryLoadFromString ( dwOpCode, _T("normal"), pObject, ppAA );

    // Set the default font variant
    if ( !fFontVariant )
        ppdVariant->TryLoadFromString ( dwOpCode, _T("normal"), pObject, ppAA );

Cleanup:
    if (hResult == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdWeight, &avWeight);
                RestoreAttrArray(*ppAA, ppdStyle, &avStyle);
                RestoreAttrArray(*ppAA, ppdVariant, &avVariant);
                RestoreAttrArray(*ppAA, ppdSize, &avSize);
                RestoreAttrArray(*ppAA, ppdLineHeight, &avLineHeight);
                RestoreAttrArray(*ppAA, ppdFamily, &avFamily);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avWeight.Free();
        avStyle.Free();
        avVariant.Free();
        avSize.Free();
        avLineHeight.Free();
        avFamily.Free();
    }
  
    delete[] pszCopy;

    RRETURN1( hResult, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Function:     ::ParseLayoutGridProperty
//
//  Synopsis:
//      This function reads an aggregate layout-grid property string from the given
//  data string, setting the internal data of the CAttrArray to reflect any
//  layout grid values set by the string.
//-------------------------------------------------------------------------
HRESULT ParseLayoutGridProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszGridString )
{
    LPTSTR  pszString;
    LPTSTR  pszNextToken;
    HRESULT hResult = S_OK;
    TCHAR chTerminator = _T('\0');
    BOOL fGridMode = FALSE;
    BOOL fGridType = FALSE;
    BOOL fGridChar = FALSE;
    BOOL fGridLine = FALSE;
    PROPERTYDESC* ppdGridMode = (PROPERTYDESC*)&s_propdescCStylelayoutGridMode.a;
    PROPERTYDESC* ppdGridType = (PROPERTYDESC*)&s_propdescCStylelayoutGridType.a;
    PROPERTYDESC* ppdGridLine = (PROPERTYDESC*)&s_propdescCStylelayoutGridLine.a;
    PROPERTYDESC* ppdGridChar = (PROPERTYDESC*)&s_propdescCStylelayoutGridChar.a;

    // The following variables are needed for backing up the attributes. They are used for restoring in error cases in strict CSS1 mode
    CAttrValue avGridMode, avGridType, avGridLine, avGridChar;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdGridMode, &avGridMode);
        BackupAttrValue (*ppAA, ppdGridType, &avGridType);
        BackupAttrValue (*ppAA, ppdGridLine, &avGridLine);
        BackupAttrValue (*ppAA, ppdGridChar, &avGridChar);
    }

    

    if ( !pcszGridString || !*pcszGridString )
        goto SetDefaults;

    pszString = (LPTSTR)pcszGridString;

    if ( !*pszString )
        goto SetDefaults;

    // Read in the grid mode
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = pszString;
        while ( *pszNextToken && !_istspace( *pszNextToken ) )
            pszNextToken++;
        if ( *pszNextToken )
        {
            chTerminator = *pszNextToken;
            *pszNextToken++ = _T('\0');
        }

        hResult = ppdGridMode->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
        if ( hResult == S_OK )
        {
            fGridMode = TRUE;
            pszString = pszNextToken;
        }
        if ( *pszNextToken )    // If we replaced a space with a NULL, unreplace it.
            *(pszNextToken - 1) = chTerminator;
    }

    if ( !*pszString )
        goto SetDefaults;

    // Read in the grid type
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = pszString;
        while ( *pszNextToken && !_istspace( *pszNextToken ) )
            pszNextToken++;
        if ( *pszNextToken )
        {
            chTerminator = *pszNextToken;
            *pszNextToken++ = _T('\0');
        }

        hResult = ppdGridType->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
        if ( hResult == S_OK )
        {
            fGridType = TRUE;
            pszString = pszNextToken;
        }
        if ( *pszNextToken )    // If we replaced a space with a NULL, unreplace it.
            *(pszNextToken - 1) = chTerminator;
    }

    if ( !*pszString )
        goto SetDefaults;

    // Read in the grid line size
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = fIsStrictCSS1 ? NextParenthesizedToken ( pszString ) : NextSize( pszString, &s_propdescCStylelayoutGridLine.b);

        if ( pszNextToken )
        {
            if ( *pszNextToken )
            {
                chTerminator = *pszNextToken;
                *pszNextToken++ = _T('\0');
            }

            hResult = ppdGridLine->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
            if ( hResult == S_OK )
            {
                fGridLine = TRUE;
                pszString = pszNextToken;
            }
            if ( *pszNextToken )    // If we replaced a space with a NULL, unreplace it.
                *(pszNextToken - 1) = chTerminator;
        }
        else
            hResult = E_INVALIDARG;
    }

    if ( !*pszString )
        goto SetDefaults;

    // Read in the grid char size
    if ( hResult == S_OK )
    {

        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = 
            fIsStrictCSS1 ? NextParenthesizedToken ( pszString ) : NextSize( pszString, &s_propdescCStylelayoutGridChar.b);

        if ( pszNextToken )
        {
            if ( *pszNextToken )
            {
                chTerminator = *pszNextToken;
                *pszNextToken++ = _T('\0');
            }

            hResult = ppdGridChar->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
            if ( hResult == S_OK )
            {
                fGridChar = TRUE;
                pszString = pszNextToken;
            }
            if ( *pszNextToken )    // If we replaced a space with a NULL, unreplace it.
                *(pszNextToken - 1) = chTerminator;
        }
        else
            hResult = E_INVALIDARG;
    }

    if (fIsStrictCSS1)
    { // check if there is coming something after the last token. In strict css1 mode we need to fail then.
        while (_istspace(*pszNextToken))
            pszNextToken++;
        if (*pszNextToken)
            hResult = E_INVALIDARG;
    }

SetDefaults:
    // Set the default layout grid mode
    if ( !fGridMode )
        ppdGridMode->TryLoadFromString ( dwOpCode, _T("both"), pObject, ppAA );
    // Set the default layout grid type
    if ( !fGridType )
        ppdGridType->TryLoadFromString ( dwOpCode, _T("loose"), pObject, ppAA );
    // Set the default layout grid line
    if ( !fGridLine )
        ppdGridLine->TryLoadFromString ( dwOpCode, _T("none"), pObject, ppAA );
    // Set the default layout grid char
    if ( !fGridChar )
        ppdGridChar->TryLoadFromString ( dwOpCode, _T("none"), pObject, ppAA );

    if (hResult == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdGridMode, &avGridMode);
                RestoreAttrArray(*ppAA, ppdGridType, &avGridType);
                RestoreAttrArray(*ppAA, ppdGridLine, &avGridLine);
                RestoreAttrArray(*ppAA, ppdGridChar, &avGridChar);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avGridMode.Free();
        avGridType.Free();
        avGridLine.Free();
        avGridChar.Free();
    }


    RRETURN1( hResult, E_INVALIDARG );
}


HRESULT GetExpandingPropdescs( DWORD dwDispId, PROPERTYDESC **pppdTop, PROPERTYDESC **pppdRight,
                               PROPERTYDESC **pppdBottom, PROPERTYDESC **pppdLeft )
{
    switch ( dwDispId )
    {
    case DISPID_A_PADDING:
        *pppdTop = (PROPERTYDESC *)&s_propdescCStylepaddingTop.a;
        *pppdRight = (PROPERTYDESC *)&s_propdescCStylepaddingRight.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStylepaddingBottom.a;
        *pppdLeft = (PROPERTYDESC *)&s_propdescCStylepaddingLeft.a;
        break;
    case DISPID_A_MARGIN:
        *pppdTop = (PROPERTYDESC *)&s_propdescCStylemarginTop.a;
        *pppdRight = (PROPERTYDESC *)&s_propdescCStylemarginRight.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStylemarginBottom.a;
        *pppdLeft = (PROPERTYDESC *)&s_propdescCStylemarginLeft.a;
        break;
    case DISPID_A_BORDERCOLOR:
        *pppdTop = (PROPERTYDESC *)&s_propdescCStyleborderTopColor.a;
        *pppdRight = (PROPERTYDESC *)&s_propdescCStyleborderRightColor.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStyleborderBottomColor.a;
        *pppdLeft = (PROPERTYDESC *)&s_propdescCStyleborderLeftColor.a;
        break;
    case DISPID_A_BORDERWIDTH:
        *pppdTop = (PROPERTYDESC *)&s_propdescCStyleborderTopWidth.a;
        *pppdRight = (PROPERTYDESC *)&s_propdescCStyleborderRightWidth.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStyleborderBottomWidth.a;
        *pppdLeft = (PROPERTYDESC *)&s_propdescCStyleborderLeftWidth.a;
        break;
    case DISPID_A_BORDERSTYLE:
        *pppdTop = (PROPERTYDESC *)&s_propdescCStyleborderTopStyle.a;
        *pppdRight = (PROPERTYDESC *)&s_propdescCStyleborderRightStyle.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStyleborderBottomStyle.a;
        *pppdLeft = (PROPERTYDESC *)&s_propdescCStyleborderLeftStyle.a;
        break;
    case DISPID_A_CLIP:
        *pppdTop    = (PROPERTYDESC *)&s_propdescCStyleclipTop.a;
        *pppdRight  = (PROPERTYDESC *)&s_propdescCStyleclipRight.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStyleclipBottom.a;
        *pppdLeft   = (PROPERTYDESC *)&s_propdescCStyleclipLeft.a;
        break;

    default:
        Assert( "Unrecognized expansion property!" && FALSE );
        return S_FALSE;
    }
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function:     ::ParseExpandProperty
//
//  Synopsis:
//      This function reads a "margin" or "padding" property value from the
//  given data string, setting the internal data of the CAttrArray to reflect
//  any given margins or padding.  This function handles expansion of the
//  margin or padding values if less than four values are present.
//-------------------------------------------------------------------------
HRESULT ParseExpandProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszBGString, DWORD dwDispId, BOOL fIsMeasurements )
{
    LPTSTR  pszCopy;
    LPTSTR  pszTop, pszRight, pszBottom, pszLeft, pszEnd;
    HRESULT hr = S_OK;
    CUnitValue cuv;
    PROPERTYDESC *ppdTop;
    PROPERTYDESC *ppdRight;
    PROPERTYDESC *ppdBottom;
    PROPERTYDESC *ppdLeft;

    // The following variables are needed for backing up the attributes. They are used for restoring in error cases in strict CSS1 mode
    CAttrValue avTop, avRight, avLeft, avBottom;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if ( THR( GetExpandingPropdescs( dwDispId, &ppdTop, &ppdRight, &ppdBottom, &ppdLeft ) ) )
        return S_FALSE;

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdTop, &avTop);
        BackupAttrValue (*ppAA, ppdRight, &avRight);
        BackupAttrValue (*ppAA, ppdLeft, &avLeft);
        BackupAttrValue (*ppAA, ppdBottom, &avBottom);
    }

    if ( !pcszBGString )
        pcszBGString = _T("");

    pszTop = pszRight = pszBottom = pszLeft = pszCopy = new(Mt(ParseExpandProperty_pszCopy)) TCHAR [_tcslen( pcszBGString ) + 1 ];
    if ( !pszTop )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy( pszCopy, pcszBGString );


    // (gschneid) 
    // NextParenthizedToken parses two kinds of tokens: simple ones like "100px" from whitespace to whitespace and the functional
    // notation "rgb(...)", but not "100 px" because there's a space between "100" and "px". NextSize parses only measurements and
    // also takes care of spaces between number and unit specifier like in "100 px". I.e. given the input "100 px" NextParenthizedToken 
    // will return the tokens "100" and "px" and NextSize will return "100 px" as the next token. Depending on the value of fIsMeasurements
    // either the function NextSize or NextParenthizedToken is called. 
    // In strict CSS1 "100 px" is not a valid specifiaction of a measure because of the space between number and unit specifier. This means
    // it is sufficient to use NextParenthizedToken for tokenizing the input. But this is equivalent to set fIsMeasurement to FALSE.

    if (fIsStrictCSS1)
        fIsMeasurements = FALSE;

    if ( *pszCopy )
    {
        while ( _istspace( *pszTop ) )
            pszTop++;       // Skip any leading whitespace
        if ( !fIsMeasurements )
            pszRight = NextParenthesizedToken( pszTop );
        else
            pszRight = NextSize( pszTop, (NUMPROPPARAMS *)(ppdTop + 1) );

        if ( pszRight && !*pszRight )
            pszRight = NULL;

        if ( pszRight )
        {
            *pszRight++ = _T('\0');
        }

        if ( fIsMeasurements )
        {
            // In strict css1 mode fIsMeasurements is always set to FALSE, i.e. a this branch of the if statement can never be executed.
            Assert(!fIsStrictCSS1);
            hr = THR( cuv.FromString( pszTop, ppdTop, FALSE ) );
        }
        if ( hr )
            goto Cleanup;

        if ( pszRight )
        {
            // Got the top value - let's check for the right value.
            while ( _istspace( *pszRight ) )
                pszRight++;       // Skip any leading whitespace
            if ( !fIsMeasurements )
                pszBottom = NextParenthesizedToken( pszRight );
            else
                pszBottom = NextSize( pszRight, (NUMPROPPARAMS *)(ppdRight + 1) );

            if ( pszBottom && !*pszBottom )
                pszBottom = NULL;

            if ( pszBottom )
            {
                *pszBottom++ = _T('\0');
            }

            if ( fIsMeasurements )
            {
                // In strict css1 mode fIsMeasurements is always set to FALSE, i.e. a this branch of the if statement can never be executed.
                Assert(!fIsStrictCSS1);
                hr = THR( cuv.FromString( pszRight, ppdRight, FALSE) );
            }
            if ( hr == S_OK )
            {
                pszLeft = pszRight;

                if ( pszBottom )
                {
                    // Got the right value - let's check for the bottom value.
                    while ( _istspace( *pszBottom ) )
                        pszBottom++;       // Skip any leading whitespace
                    if ( !fIsMeasurements )
                        pszLeft = NextParenthesizedToken( pszBottom );
                    else
                        pszLeft = NextSize( pszBottom, (NUMPROPPARAMS *)(ppdBottom + 1) );

                    if ( pszLeft && !*pszLeft )
                        pszLeft = NULL;

                    if ( pszLeft )
                    {
                        *pszLeft++ = _T('\0');

                        while ( _istspace( *pszLeft ) )
                            pszLeft++;       // Skip any leading whitespace
                        if ( pszLeft && !*pszLeft )
                            pszLeft = NULL;
                    }

                    if ( fIsMeasurements )
                    {
                        // In strict css1 mode fIsMeasurements is always set to FALSE, i.e. a this branch of the if statement can never be executed.
                        Assert(!fIsStrictCSS1);
                        hr = THR( cuv.FromString( pszBottom, ppdBottom, FALSE) );
                    }
                    if ( hr == S_OK )
                    {
                        if ( pszLeft )
                        {
                            if ( !fIsMeasurements )
                                pszEnd = NextParenthesizedToken( pszLeft );
                            else
                                pszEnd = NextSize( pszLeft, (NUMPROPPARAMS *)(ppdLeft + 1) );

                            if ( pszEnd && !*pszEnd )
                                pszEnd = NULL;

                            if ( pszEnd )
                                *pszEnd = _T('\0');

                            // Got the bottom value - let's check for the left value.
                            if ( fIsMeasurements )
                            {
                                // In strict css1 mode fIsMeasurements is always set to FALSE, i.e. a this branch of the if statement can never be executed.
                                Assert(!fIsStrictCSS1);
                                hr = THR( cuv.FromString( pszLeft, ppdLeft, FALSE) );
                            }
                            if ( hr != S_OK )
                                pszLeft = pszRight; // Failed to get left value
                        }
                        else    // No left value present
                            pszLeft = pszRight;
                    }
                    else    // Failed to get bottom value
                        pszBottom = pszTop;
                }
                else    // No bottom or left value present
                    pszBottom = pszTop;
            }
            else    // Failed to get right value
                pszRight = pszTop;
        }
        else    // Only one margin present
            pszRight = pszTop;
    }
    else
    {   // Empty string should still clear the properties.
        pszTop = pszRight = pszBottom = pszLeft = pszCopy;
    }

    hr =  ppdTop->TryLoadFromString ( dwOpCode, pszTop, pObject, ppAA );
    if ( hr )
        goto Cleanup;
    hr =  ppdRight->TryLoadFromString ( dwOpCode, pszRight, pObject, ppAA );
    if ( hr )
        goto Cleanup;
    hr =  ppdBottom->TryLoadFromString ( dwOpCode, pszBottom, pObject, ppAA );
    if ( hr )
        goto Cleanup;
    hr =  ppdLeft->TryLoadFromString ( dwOpCode, pszLeft, pObject, ppAA );

    if (fIsStrictCSS1) 
    {   // In strict CSS1 only a max of 4 margin/padding spezifiers are allowed
        // Either bottom or left must be the most right
        if (pszLeft > pszBottom) {
            pszEnd = pszLeft;
        }
        else
        {
            pszEnd = pszBottom;
        }
        // Advance to the end of the last specification in the incoming string
        while (*pszEnd) pszEnd++;
        // If we are not at the end of the incoming string go one more
        if (pcszBGString[pszEnd-pszCopy])
            pszEnd++;
        // Now lets skip white spaces
        while ( _istspace( *pszEnd ) )
            pszEnd++;
        if (*pszEnd) 
            hr = E_INVALIDARG;      
    }
    

Cleanup:

    if (hr == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdTop, &avTop);
                RestoreAttrArray(*ppAA, ppdRight, &avRight);
                RestoreAttrArray(*ppAA, ppdLeft, &avLeft);
                RestoreAttrArray(*ppAA, ppdBottom, &avBottom);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avTop.Free();
        avRight.Free();
        avLeft.Free();
        avBottom.Free();
    }

    delete[] pszCopy ;
    RRETURN1( hr, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Function:     ::ParseBorderProperty
//
//  Synopsis:
//      This function reads an aggregate border property string from the given
//  data string, setting the internal data of the CAttrArray to reflect any
//  border styles, widths, or colors set by the string.
//-------------------------------------------------------------------------
HRESULT ParseBorderProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszBorderString )
{
    HRESULT hr = S_OK;


    hr = s_propdescCStyleborderTop.a.TryLoadFromString ( dwOpCode, pcszBorderString,pObject, ppAA );
    if ( hr != S_OK && hr != E_INVALIDARG )
        return hr;

    hr = s_propdescCStyleborderRight.a.TryLoadFromString ( dwOpCode, pcszBorderString,pObject, ppAA );
    if ( hr != S_OK && hr != E_INVALIDARG )
        return hr;

    hr = s_propdescCStyleborderBottom.a.TryLoadFromString ( dwOpCode, pcszBorderString,pObject, ppAA );
    if ( hr != S_OK && hr != E_INVALIDARG )
        return hr;

    hr = s_propdescCStyleborderLeft.a.TryLoadFromString ( dwOpCode, pcszBorderString,pObject, ppAA );

    return hr;
}

HRESULT GetBorderSidePropdescs( DWORD dwDispId, PROPERTYDESC **pppdStyle,
                               PROPERTYDESC **pppdColor, PROPERTYDESC **pppdWidth )
{
    Assert( "Must have PD pointers!" && pppdStyle && pppdColor && pppdWidth );

    PROPERTYDESC *borderpropdescs[3][4] =
    { { (PROPERTYDESC *)&s_propdescCStyleborderTopStyle.a,
        (PROPERTYDESC *)&s_propdescCStyleborderRightStyle.a,
        (PROPERTYDESC *)&s_propdescCStyleborderBottomStyle.a,
        (PROPERTYDESC *)&s_propdescCStyleborderLeftStyle.a },
      { (PROPERTYDESC *)&s_propdescCStyleborderTopColor.a,
        (PROPERTYDESC *)&s_propdescCStyleborderRightColor.a,
        (PROPERTYDESC *)&s_propdescCStyleborderBottomColor.a,
        (PROPERTYDESC *)&s_propdescCStyleborderLeftColor.a },
      { (PROPERTYDESC *)&s_propdescCStyleborderTopWidth.a,
        (PROPERTYDESC *)&s_propdescCStyleborderRightWidth.a,
        (PROPERTYDESC *)&s_propdescCStyleborderBottomWidth.a,
        (PROPERTYDESC *)&s_propdescCStyleborderLeftWidth.a } };

    switch ( dwDispId )
    {
    case DISPID_A_BORDERTOP:
        *pppdStyle = borderpropdescs[0][0];
        *pppdColor = borderpropdescs[1][0];
        *pppdWidth = borderpropdescs[2][0];
        break;
    case DISPID_A_BORDERRIGHT:
         *pppdStyle = borderpropdescs[0][1];
        *pppdColor = borderpropdescs[1][1];
        *pppdWidth = borderpropdescs[2][1];
        break;
    case DISPID_A_BORDERBOTTOM:
        *pppdStyle = borderpropdescs[0][2];
        *pppdColor = borderpropdescs[1][2];
        *pppdWidth = borderpropdescs[2][2];
        break;
    case DISPID_A_BORDERLEFT:
        *pppdStyle = borderpropdescs[0][3];
        *pppdColor = borderpropdescs[1][3];
        *pppdWidth = borderpropdescs[2][3];
        break;
    default:
        Assert( "Not a DISPID for a valid border property!" );
        return S_FALSE;
    }
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function:     ::ParseAndExpandBorderSideProperty
//
//  Synopsis:
//      This function takes an aggregate border side property string (e.g. the
//  string for "border-top") and sets the internal data of the CAttrArray to
//  reflect any border style, width or color set by the string.
//-------------------------------------------------------------------------
HRESULT ParseAndExpandBorderSideProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszBorderString, DWORD dwDispId )
{
    LPTSTR          pszString, pszCopy, pszNextToken;
    HRESULT         hr = S_OK;
    PROPERTYDESC  * ppdStyle;
    PROPERTYDESC  * ppdColor;
    PROPERTYDESC  * ppdWidth;
    int             nSeenStyle = 0;
    int             nSeenWidth = 0;
    int             nSeenColor = 0;
    
    // The following variables are needed for backing up the attributes. They are used for restoring in error cases in strict CSS1 mode
    CAttrValue      avColor, avWidth, avStyle;
    
    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if ( S_FALSE == GetBorderSidePropdescs( dwDispId, &ppdStyle, &ppdColor, &ppdWidth ) )
        return S_FALSE;

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdColor, &avColor);
        BackupAttrValue (*ppAA, ppdWidth, &avWidth);
        BackupAttrValue (*ppAA, ppdStyle, &avStyle);
    }

    if ( !pcszBorderString )
        pcszBorderString = _T("");

    pszCopy = pszNextToken = pszString = new(Mt(ParseAndExpandBorderSideProperty_pszCopy)) TCHAR [_tcslen( pcszBorderString ) + 1 ];
    if ( !pszCopy )
    {
        return E_OUTOFMEMORY;
    }
    _tcscpy( pszCopy, pcszBorderString );

    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = NextParenthesizedToken( pszString );

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        hr = ppdStyle->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA);

        if ( hr != S_OK )
        {   // Let's see if it's a measurement string
            hr = ppdWidth->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
            if ( hr != S_OK )
            {   // Try it as a color
                hr = ppdColor->TryLoadFromString( dwOpCode, pszString, pObject, ppAA);
                if ( hr != S_OK )
                {   // Not a valid border string token
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                else
                    nSeenColor++;
            }
            else
                nSeenWidth++;
        }
        else
            nSeenStyle++;
    }

Cleanup:
    if (hr == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdColor, &avColor);
                RestoreAttrArray(*ppAA, ppdWidth, &avWidth);
                RestoreAttrArray(*ppAA, ppdStyle, &avStyle);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avColor.Free();
        avWidth.Free();
        avStyle.Free();
    }   

    if (!fIsStrictCSS1 && !hr) 
    {
        if (nSeenStyle == 0)
            ppdStyle->TryLoadFromString ( dwOpCode, _T("none"), pObject, ppAA );
        if (nSeenWidth == 0)
            ppdWidth->TryLoadFromString ( dwOpCode, _T("medium"), pObject, ppAA );
        if (nSeenColor == 0)
        {
            DWORD dwVal;
            if ( *ppAA )
                (*ppAA)->FindSimpleInt4AndDelete( ppdColor->GetBasicPropParams()->dispid, &dwVal, CAttrValue::AA_StyleAttribute );
        }
    }

    if(!hr && (nSeenStyle > 1 || nSeenWidth > 1 || nSeenColor > 1))
        hr = E_INVALIDARG;

    delete[] pszCopy ;

    RRETURN1( hr, E_INVALIDARG );

}

CAttrArray **CStyle::GetAttrArray ( void ) const
{
    CAttrArray **ppAA;
    
    if (!TestFlag(STYLE_SEPARATEFROMELEM))
    {
        CAttrArray **ppAASrc = const_cast<CAttrArray **>(&_pAA);
        ppAA = _pElem->CreateStyleAttrArray(_dispIDAA);
        if (ppAA)
            *ppAASrc = *ppAA;
        return ppAA;
    }

    ppAA = const_cast<CAttrArray **>(&_pAA);
    if (*ppAA)
        return ppAA;
        
    *ppAA = new CAttrArray;
    return ppAA;
}


//+------------------------------------------------------------------------
//
//  Function:   ::ParseTextDecorationProperty
//
//  Synopsis:   Parses a text-decoration string in CSS format and sets the
//              appropriate sub-properties.
//
//-------------------------------------------------------------------------
HRESULT ParseTextDecorationProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszTextDecoration, WORD wFlags )
{
    TCHAR *pszString;
    TCHAR *pszCopy = NULL;
    TCHAR *pszNextToken;
    HRESULT hr = S_OK;
    BOOL fInvalidValues = FALSE;
    BOOL fInsideParens;
    VARIANT v;
    CVariant varOld;
    BOOL fTreeSync=FALSE;

    Assert( ppAA && "No (CAttrArray*) pointer!" );

    PROPERTYDESC *ppdTextDecoration  = (PROPERTYDESC*)&s_propdescCStyletextDecoration.a;

    CAttrValue avTextDecoration;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.
        BackupAttrValue (*ppAA, ppdTextDecoration, &avTextDecoration);
    }

#ifndef NO_EDIT
    if (pObject)
    {
        BOOL fCreateUndo = pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if ( fCreateUndo || fTreeSync )
        {

            V_VT(&varOld) = VT_BSTR;
            WriteTextDecorationToBSTR( *ppAA, &(V_BSTR(&varOld)) );

            if( fTreeSync )
            {
                VARIANT    varNew;

                V_VT( &varNew ) = VT_LPWSTR;
                varNew.byref = (void*)pcszTextDecoration;
    
                pObject->LogAttributeChange( DISPID_A_TEXTDECORATION, &varOld, &varNew );
            }
        
            if( fCreateUndo )
            {
                hr = THR(pObject->CreatePropChangeUndo(DISPID_A_TEXTDECORATION, &varOld, NULL));
                if (hr)
                    goto Cleanup;
            }
            // Else CVariant destructor cleans up varOld
        }
    }
#endif // NO_EDIT

    if ( !pcszTextDecoration )
        pcszTextDecoration = _T("");

    v.vt = VT_I4;
    v.lVal = 0;

    pszCopy = pszNextToken = pszString = new(Mt(ParseTextDecorationProperty_pszCopy)) TCHAR [_tcslen(  pcszTextDecoration ) + 1 ];
    if ( !pszCopy )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy( pszCopy,  pcszTextDecoration );

    // Loop through the tokens in the string (parenthesis parsing is for future
    // text-decoration values that might have parameters).
    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        fInsideParens = FALSE;
        while ( _istspace( *pszString ) )
            pszString++;

        while ( *pszNextToken && ( fInsideParens || !_istspace( *pszNextToken ) ) )
        {
            if ( *pszNextToken == _T('(') )
                fInsideParens = TRUE;
            if ( *pszNextToken == _T(')') )
                fInsideParens = FALSE;
            pszNextToken++;
        }

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        if ( !StrCmpIC( pszString, _T("none") ) )
            v.lVal = TD_NONE;   // "none" clears all the other properties (unlike the other properties)
        else if ( !StrCmpIC( pszString, _T("underline") ) )
            v.lVal |= TD_UNDERLINE;
        else if ( !StrCmpIC( pszString, _T("overline") ) )
            v.lVal |= TD_OVERLINE;
        else if ( !StrCmpIC( pszString, _T("line-through") ) )
            v.lVal |= TD_LINETHROUGH;
        else if ( !StrCmpIC( pszString, _T("blink") ) )
            v.lVal |= TD_BLINK;
        else
        {
            fInvalidValues = TRUE;
            if (fIsStrictCSS1)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }
    }

    hr = CAttrArray::Set( ppAA, DISPID_A_TEXTDECORATION, &v,
                    (PROPERTYDESC *)&s_propdescCStyletextDecoration, CAttrValue::AA_StyleAttribute, wFlags );

Cleanup:
    if (hr == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdTextDecoration, &avTextDecoration);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avTextDecoration.Free();    
    }

    delete[] pszCopy;
    RRETURN1( fInvalidValues ? (hr?hr:E_INVALIDARG) : hr, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Function:   ::ParseTextAutospaceProperty
//
//  Synopsis:   Parses a text-autospace string in CSS format and sets the
//              appropriate sub-properties.
//
//-------------------------------------------------------------------------
HRESULT ParseTextAutospaceProperty( CAttrArray **ppAA, LPCTSTR pcszTextAutospace, DWORD dwOpCode, WORD wFlags )
{
    TCHAR *pszTokenBegin;
    TCHAR *pszCopy;
    TCHAR *pszTokenEnd;
    HRESULT hr = S_OK;
    BOOL fInvalidValues = FALSE;
    VARIANT v;
    

    Assert( ppAA && "No (CAttrArray*) pointer!" );

    if ( !pcszTextAutospace )
        pcszTextAutospace = _T("");

    v.vt = VT_I4;
    v.lVal = 0;

    pszCopy = pszTokenBegin = pszTokenEnd = new(Mt(ParseTextAutospaceProperty_pszCopy)) TCHAR [_tcslen(  pcszTextAutospace ) + 1 ];
    if ( !pszCopy )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy( pszCopy,  pcszTextAutospace );

    for ( pszTokenBegin = pszTokenEnd = pszCopy;
          pszTokenBegin && *pszTokenBegin; 
          pszTokenBegin = pszTokenEnd )
    {
        while ( _istspace( *pszTokenBegin ) )
            pszTokenBegin++;

        pszTokenEnd = pszTokenBegin;
        
        while ( *pszTokenEnd && !_istspace( *pszTokenEnd ) )
            pszTokenEnd++;

        if(*pszTokenEnd)
            *pszTokenEnd++ = _T('\0');

        if( StrCmpIC(pszTokenBegin, _T("ideograph-numeric")) == 0 )
        {
            v.lVal |= TEXTAUTOSPACE_NUMERIC;
        }
        else if( StrCmpIC(pszTokenBegin, _T("ideograph-space")) == 0 )
        {
            v.lVal |= TEXTAUTOSPACE_SPACE;
        }
        else if( StrCmpIC(pszTokenBegin, _T("ideograph-alpha")) == 0 )
        {
            v.lVal |= TEXTAUTOSPACE_ALPHA;
        }
        else if( StrCmpIC(pszTokenBegin, _T("ideograph-parenthesis")) == 0 )
        {
            v.lVal |= TEXTAUTOSPACE_PARENTHESIS;
        }
        else if( StrCmpIC(pszTokenBegin, _T("none")) == 0 )
        {
            v.lVal = TEXTAUTOSPACE_NONE;
        }
        else
        {
            fInvalidValues = TRUE;
            if (dwOpCode & HANDLEPROP_STRICTCSS1)
                // In strict CSS1 mode we skip the whole property value.
                goto Cleanup;
        }
    }

    hr = CAttrArray::Set( ppAA, DISPID_A_TEXTAUTOSPACE, &v,
                    (PROPERTYDESC *)&s_propdescCStyletextAutospace, CAttrValue::AA_StyleAttribute, wFlags );

Cleanup:
    delete[] pszCopy;
    RRETURN1( fInvalidValues ? (hr?hr:E_INVALIDARG) : hr, E_INVALIDARG );
}


//+------------------------------------------------------------------------
//
//  Function:   ::ParseListStyleProperty
//
//  Synopsis:   Parses a list-style string in CSS format and sets the
//              appropriate sub-properties.
//
//-------------------------------------------------------------------------
HRESULT ParseListStyleProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszListStyle )
{
    TCHAR *pszString;
    TCHAR *pszCopy;
    TCHAR *pszNextToken;
    HRESULT hrResult = S_OK;
    BOOL fInsideParens;
    BOOL fNone;
    BOOL fTypeDone = FALSE;
    TCHAR achNone[] = _T("none");
    TCHAR *pchNone;
    TCHAR chCurr;
    TCHAR chNone;

    PROPERTYDESC *ppdType  = (PROPERTYDESC*)&s_propdescCStylelistStyleType.a;
    PROPERTYDESC *ppdPos   = (PROPERTYDESC*)&s_propdescCStylelistStylePosition.a; 
    PROPERTYDESC *ppdImage = (PROPERTYDESC*)&s_propdescCStylelistStyleImage.a; 

    CAttrValue avType, avPos, avImage;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdPos, &avPos);
        BackupAttrValue (*ppAA, ppdType, &avType);
        BackupAttrValue (*ppAA, ppdImage, &avImage);
    }

    if ( !pcszListStyle || !*pcszListStyle )
    {
        if ( *ppAA )
        {
            (*ppAA)->FindSimpleAndDelete( DISPID_A_LISTSTYLETYPE, CAttrValue::AA_StyleAttribute );
            (*ppAA)->FindSimpleAndDelete( DISPID_A_LISTSTYLEPOSITION, CAttrValue::AA_StyleAttribute );
            (*ppAA)->FindSimpleAndDelete( DISPID_A_LISTSTYLEIMAGE, CAttrValue::AA_StyleAttribute );
        }
        return S_OK;
    }

    pszCopy = pszNextToken = pszString = new(Mt(ParseListStyleProperty_pszCopy)) TCHAR [_tcslen(  pcszListStyle ) + 1 ];
    if ( !pszCopy )
    {
        hrResult = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _tcscpy( pszCopy,  pcszListStyle );

    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        fNone = TRUE;
        fInsideParens = FALSE;
        pchNone = achNone;
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = pszString;
        while ( *pszNextToken && ( fInsideParens || !_istspace( *pszNextToken ) ) )
        {
            if ( *pszNextToken == _T('(') )
                fInsideParens = TRUE;
            if ( *pszNextToken == _T(')') )
                fInsideParens = FALSE;

            if (fNone && !fInsideParens)
            {
                chCurr = *pszNextToken++ ;
                chNone = *pchNone++;
                if ((chCurr != chNone) && (chCurr != (chNone - _T('a') + _T('A'))))
                    fNone = FALSE;
            }
            else
            {
                fNone = FALSE;
                pszNextToken++;
            }
        }

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        // Try type
        if ((fNone && fTypeDone) || ppdType->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA ) )
        {   // Failed: try position
            if ( ppdPos->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA ) )
            {   // Failed: try image
                if ( ppdImage->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA ) )
                {
                    hrResult = E_INVALIDARG;
                    if (fIsStrictCSS1)
                        goto Cleanup;
                }
            }
        }
        else
            fTypeDone = TRUE;
    }

Cleanup:
    
    if (hrResult == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdPos, &avPos);
                RestoreAttrArray(*ppAA, ppdType, &avType);
                RestoreAttrArray(*ppAA, ppdImage, &avImage);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avPos.Free();
        avType.Free();
        avImage.Free();
    }


    delete[] pszCopy;
    RRETURN1( hrResult, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteFontToBSTR
//
//  Synopsis:   Cooks up a BSTR of all the font properties in CSS format.
//              We will only build a non-empty string and return it if
//              there are the minimum set of font properties (if the font
//              string is valid according to the CSS spec, which requires
//              at least a size and a font-family).
//
//-------------------------------------------------------------------------
HRESULT WriteFontToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrFont;
    BSTR bstr = NULL;
    BOOL fIsValid = TRUE;
    VARIANT v;
    HRESULT hr=S_OK;

    Assert( pbstr != NULL );
    VariantInit( &v );

    if ( S_OK == s_propdescCStylefontWeight.b.GetEnumStringProperty( &bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("normal") ) )
        {
            hr = cstrFont.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrFont.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    FormsFreeString( bstr );
    bstr = NULL;

    if ( S_OK == s_propdescCStylefontStyle.b.GetEnumStringProperty( &bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("normal") ) )
        {
            hr = cstrFont.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrFont.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    FormsFreeString( bstr );
    bstr = NULL;

    if ( S_OK == s_propdescCStylefontVariant.b.GetEnumStringProperty( &bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("normal") ) )
        {
            hr = cstrFont.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrFont.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    FormsFreeString( bstr );
    bstr = NULL;

    if ( S_OK == s_propdescCStylefontSize.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v, NULL, (CVoid *)&pAA  ) && ( v.vt == VT_BSTR && (LPTSTR)v.byref && *(LPTSTR)v.byref ) )
    {
        hr = cstrFont.Append( (LPTSTR)v.byref );
        if (hr != S_OK)
            goto Cleanup;
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    VariantClear(&v);

    if ( S_OK == s_propdescCStylelineHeight.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v, NULL, (CVoid *)&pAA ) && ( v.vt == VT_BSTR && (LPTSTR)v.byref && *(LPTSTR)v.byref ) )
    {
        if ( _tcsicmp( (LPTSTR)v.byref, _T("normal") ) )
        {
            hr = cstrFont.Append( _T("/") );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrFont.Append( (LPTSTR)v.byref );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }
    hr = cstrFont.Append( _T(" ") );
    if (hr != S_OK)
        goto Cleanup;

    bstr = NULL;
    if ( S_OK == s_propdescCStylefontFamily.b.GetStringProperty(&bstr, NULL, (CVoid *)&pAA ) &&
         bstr && *bstr )
    {
        hr = cstrFont.Append( (TCHAR *)bstr );
        if (hr != S_OK)
            goto Cleanup;
    }
    else
        fIsValid = FALSE;

Cleanup:
    FormsFreeString(bstr);
    VariantClear(&v);
    if (hr == S_OK)
    {
        if ( !fIsValid )
        {
            hr = cstrFont.Set( _T("") );
            if (hr != S_OK)
                return hr;
        }
        return cstrFont.AllocBSTR( pbstr );
    }
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteLayoutGridToBSTR
//
//  Synopsis:
//
//-------------------------------------------------------------------------
HRESULT WriteLayoutGridToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrLayoutGrid;
    BSTR bstrMode = NULL;
    BSTR bstrType = NULL;
    BOOL fIsValid = TRUE;
    CVariant v1, v2;
    HRESULT hr = S_OK;

    Assert( pbstr != NULL );

    if ( S_OK == s_propdescCStylelayoutGridMode.b.GetEnumStringProperty( &bstrMode, NULL, (CVoid *)&pAA ) && bstrMode && *bstrMode )
    {
        if ( _tcsicmp( bstrMode, _T("both") ) )
        {
            hr = cstrLayoutGrid.Append( (TCHAR *)bstrMode );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    if ( S_OK == s_propdescCStylelayoutGridType.b.GetEnumStringProperty( &bstrType, NULL, (CVoid *)&pAA ) && bstrType && *bstrType )
    {
        if ( _tcsicmp( bstrType, _T("loose") ) )
        {
            hr = cstrLayoutGrid.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrLayoutGrid.Append( (TCHAR *)bstrType );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    if ( S_OK == s_propdescCStylelayoutGridLine.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v1, NULL, (CVoid *)&pAA  ) && ( v1.vt == VT_BSTR && v1.bstrVal && *v1.bstrVal ) )
    {
        hr = cstrLayoutGrid.Append( _T(" ") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrLayoutGrid.Append( (TCHAR *)v1.bstrVal );
        if (hr != S_OK)
            goto Cleanup;
        fIsValid = TRUE;
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    if ( S_OK == s_propdescCStylelayoutGridChar.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v2, NULL, (CVoid *)&pAA ) && ( v2.vt == VT_BSTR && v2.bstrVal && *v2.bstrVal ) )
    {
        hr = cstrLayoutGrid.Append( _T(" ") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrLayoutGrid.Append( (TCHAR *)v2.bstrVal );
        if (hr != S_OK)
            goto Cleanup;
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

Cleanup:
    FormsFreeString(bstrMode);
    FormsFreeString(bstrType);

    if (hr == S_OK)
    {
        if (!fIsValid)
        {
            hr = cstrLayoutGrid.Set(_T(""));
            if (hr != S_OK)
                return hr;
        }
        else if (!cstrLayoutGrid.Length())  // Set all defaults
        {
            hr = cstrLayoutGrid.Set(_T("both loose none none"));
            if (hr != S_OK)
                return hr;
        }
        
        return cstrLayoutGrid.AllocBSTR(pbstr);
    }
    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   ::WriteTextDecorationToBSTR
//
//  Synopsis:   Cooks up a BSTR of all the text-decoration properties in CSS format.
//
//-------------------------------------------------------------------------
HRESULT WriteTextDecorationToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrTextDecoration;
    CAttrValue *pAV;
    HRESULT hr=S_OK;

    Assert( pbstr != NULL );
    if ( !pAA )
        return S_FALSE;

    pAV = pAA->Find( DISPID_A_TEXTDECORATION, CAttrValue::AA_Attribute );
    if ( pAV )
    {   // We've got one!
        if ( hr == S_OK && pAV->GetLong() & TD_NONE )
            hr = cstrTextDecoration.Append( _T("none ") );
        if ( hr == S_OK && pAV->GetLong() & TD_UNDERLINE )
            hr = cstrTextDecoration.Append( _T("underline ") );
        if ( hr == S_OK && pAV->GetLong() & TD_OVERLINE )
            hr = cstrTextDecoration.Append( _T("overline ") );
        if ( hr == S_OK && pAV->GetLong() & TD_LINETHROUGH )
            hr = cstrTextDecoration.Append( _T("line-through ") );
        if ( hr == S_OK && pAV->GetLong() & TD_BLINK )
            hr = cstrTextDecoration.Append( _T("blink ") );
        cstrTextDecoration.TrimTrailingWhitespace();
    }

    if (hr != S_OK)
        RRETURN(hr);
    RRETURN( cstrTextDecoration.AllocBSTR( pbstr ) );
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteTextAutospaceToBSTR
//
//  Synopsis:   Cooks up a BSTR of all the text-autospace properties in CSS format.
//
//-------------------------------------------------------------------------
HRESULT WriteTextAutospaceToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrTextAutospace;
    CAttrValue *pAV;
    HRESULT hr=S_OK;

    Assert( pbstr != NULL );
    if ( !pAA )
        return S_FALSE;

    pAV = pAA->Find( DISPID_A_TEXTAUTOSPACE, CAttrValue::AA_Attribute );
    if ( pAV )
    {
        hr = WriteTextAutospaceFromLongToBSTR( pAV->GetLong(), pbstr, FALSE );
    }
    else
    {
        hr = cstrTextAutospace.Set( _T("") );
        if (hr == S_OK)
            hr = cstrTextAutospace.AllocBSTR( pbstr );
    }

    RRETURN( hr );
}


//+----------------------------------------------------------------
//
//  static function : WriteTextAutospaceFromLongToBSTR
//
//  Synopsis : given the current textAutospace property, this
//             will write it out to a string
//
//+----------------------------------------------------------------

HRESULT
WriteTextAutospaceFromLongToBSTR(LONG lTextAutospace, BSTR * pbstr, BOOL fWriteNone)
{
    CStr cstrTA;
    HRESULT hr=S_OK;

    if(!lTextAutospace)
    {
        if(fWriteNone)
            hr = cstrTA.Set(_T("none"));
        else
            hr = cstrTA.Set(_T(""));
    }
    else
    {
        if(hr == S_OK && lTextAutospace & TEXTAUTOSPACE_ALPHA)
        {
            hr = cstrTA.Append(_T("ideograph-alpha "));
        }
        if(hr == S_OK && lTextAutospace & TEXTAUTOSPACE_NUMERIC)
        {
            hr = cstrTA.Append(_T("ideograph-numeric "));
        }
        if(hr == S_OK && lTextAutospace & TEXTAUTOSPACE_SPACE)
        {
            hr = cstrTA.Append(_T("ideograph-space "));
        }
        if(hr == S_OK && lTextAutospace & TEXTAUTOSPACE_PARENTHESIS)
        {
            hr = cstrTA.Append(_T("ideograph-parenthesis"));
        }
        if (hr == S_OK)
            cstrTA.TrimTrailingWhitespace();
    }

    if (hr == S_OK)
        hr = cstrTA.AllocBSTR(pbstr);
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteBorderToBSTR
//
//  Synopsis:   Cooks up a BSTR of the border properties in CSS format.
//
//-------------------------------------------------------------------------

// NOTE: This function could be more efficient by doing all the Find()s itself
// and collapsing the values directly. - CWilso
HRESULT WriteBorderToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrBorder;
    BSTR bstrTemp = NULL;
    HRESULT hr = S_OK;

    Assert( pbstr != NULL );
    hr = WriteExpandedPropertyToBSTR( DISPID_A_BORDERCOLOR, pAA, &bstrTemp );
    if ( ( hr == S_OK ) && bstrTemp )
    {
        if ( !_tcschr( bstrTemp, _T(' ') ) )
        {
            hr = cstrBorder.Append( (TCHAR *)bstrTemp );
        }
        else
            hr = S_FALSE;
        FormsFreeString( bstrTemp );
        bstrTemp = NULL;
    }
    if ( hr != S_OK )
        goto Cleanup;

    hr = WriteExpandedPropertyToBSTR( DISPID_A_BORDERWIDTH, pAA, &bstrTemp );
    if ( hr == S_OK )
    {
        if ( !_tcschr( bstrTemp, _T(' ') ) )
        {
            if ( StrCmpC( (TCHAR *)bstrTemp, _T("medium") ) )
            {
                if ( cstrBorder.Length() )
                {
                    hr = cstrBorder.Append( _T(" ") );
                    if (hr != S_OK)
                        goto Cleanup;
                }
                hr = cstrBorder.Append( (TCHAR *)bstrTemp );
            }
        }
        else
            hr = S_FALSE;
        FormsFreeString( bstrTemp );
        bstrTemp = NULL;
    }
    if ( hr != S_OK )
        goto Cleanup;

    hr = WriteExpandedPropertyToBSTR( DISPID_A_BORDERSTYLE, pAA, &bstrTemp );
    if ( hr == S_OK )
    {
        if ( !_tcschr( bstrTemp, _T(' ') ) )
        {
            if ( StrCmpC( (TCHAR *)bstrTemp, _T("none") ) )
            {
                if ( cstrBorder.Length() )
                {
                    hr = cstrBorder.Append( _T(" ") );
                    if (hr != S_OK)
                        goto Cleanup;
                }
                hr = cstrBorder.Append( (TCHAR *)bstrTemp );
                if (hr != S_OK)
                    goto Cleanup;
            }
        }
        else
            hr = S_FALSE;
        FormsFreeString( bstrTemp );
        bstrTemp = NULL;
    }

Cleanup:
    FormsFreeString( bstrTemp );
    if ( hr == S_FALSE )
        hr = cstrBorder.Set( _T("") );
    if (hr == S_OK)
        return cstrBorder.AllocBSTR( pbstr );
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteExpandedPropertyToBSTR
//
//  Synopsis:   Cooks up a BSTR of an aggregate expanded property (e.g.
//              margin, padding, etc.) if the aggregate can be built.  Will
//              accomplish minization (e.g. "10px 10px 10px 10px" will be
//              written as "10px").
//
//-------------------------------------------------------------------------
HRESULT WriteExpandedPropertyToBSTR( DWORD dwDispId, CAttrArray *pAA, BSTR *pbstr )
{
    PROPERTYDESC *ppdTop;
    PROPERTYDESC *ppdRight;
    PROPERTYDESC *ppdBottom;
    PROPERTYDESC *ppdLeft;
    LPTSTR pszTop = NULL;
    LPTSTR pszRight = NULL;
    LPTSTR pszBottom = NULL;
    LPTSTR pszLeft = NULL;
    VARIANT v;
    CStr cstrRetVal;
    BOOL fWriteRightLeft = FALSE;
    BOOL fWriteBottom    = FALSE;
    BOOL fWriteLeft      = FALSE;
    BOOL fTopInAA, fRightInAA, fBottomInAA, fLeftInAA;
    HRESULT hr = S_OK;

    Assert( pbstr != NULL );
    Assert( pAA && "Must have AttrArray!");
    if ( !pAA )
        goto Error;

    if ( THR( GetExpandingPropdescs( dwDispId, &ppdTop, &ppdRight, &ppdBottom, &ppdLeft ) ) )
        goto Error;

    fTopInAA =    NULL != pAA->Find( ppdTop->GetDispid() );
    fRightInAA =  NULL != pAA->Find( ppdRight->GetDispid() );
    fBottomInAA = NULL != pAA->Find( ppdBottom->GetDispid() );
    fLeftInAA =   NULL != pAA->Find( ppdLeft->GetDispid() );

    if ( !fTopInAA || !fRightInAA || !fBottomInAA || !fLeftInAA )
    {
        if ( ( dwDispId == DISPID_A_BORDERCOLOR ) &&
             !fTopInAA && !fRightInAA && !fBottomInAA && !fLeftInAA )
            goto Cleanup;
        else
            goto Error; // Need all four sides to cook up expanded property.
    }

#ifdef WIN16
    if ( (ppdTop->pfnHandleProperty)( ppdTop, HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) )
#else
    if ( CALL_METHOD( ppdTop, ppdTop->pfnHandleProperty, ( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) ))
#endif
        goto Error;
    pszTop = (LPTSTR)v.byref;

#ifdef WIN16
    if ( (ppdRight->pfnHandleProperty)( ppdRight, HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) )
#else
    if ( CALL_METHOD( ppdRight, ppdRight->pfnHandleProperty, ( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) ))
#endif
        goto Error;
    pszRight = (LPTSTR)v.byref;

#ifdef WIN16
    if ( (ppdBottom->pfnHandleProperty)( ppdBottom, HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) )
#else
    if ( CALL_METHOD( ppdBottom, ppdBottom->pfnHandleProperty, ( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) ))
#endif
        goto Error;
    pszBottom = (LPTSTR)v.byref;

#ifdef WIN16
    if ( (ppdLeft->pfnHandleProperty)( ppdLeft, HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) )
#else
    if ( CALL_METHOD( ppdLeft, ppdLeft->pfnHandleProperty, ( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) ))
#endif
        goto Error;
    pszLeft = (LPTSTR)v.byref;

    if ( !pszTop || !pszRight || !pszBottom || !pszLeft )
        goto Error;

    hr = cstrRetVal.Append( pszTop );    // We always have the top string
    if (hr != S_OK)
        goto Cleanup;
    if ( _tcsicmp( pszRight, pszLeft ) )
    {   // Right and left don't match - write out everything.
        fWriteRightLeft = TRUE;
        fWriteBottom = TRUE;
        fWriteLeft = TRUE;
    }
    else
    {
        if ( _tcsicmp( pszTop, pszBottom ) )
        {
            fWriteBottom = TRUE;     // Top and bottom don't match
            fWriteRightLeft = TRUE;
        }
        else if ( _tcsicmp( pszTop, pszRight ) )
            fWriteRightLeft = TRUE;
    }

    if ( fWriteRightLeft )
    {
        hr = cstrRetVal.Append( _T(" ") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrRetVal.Append( pszRight );    // Write out the right string (may be left also)
        if (hr != S_OK)
            goto Cleanup;
    }
    if ( fWriteBottom )
    {
        hr = cstrRetVal.Append( _T(" ") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrRetVal.Append( pszBottom );    // Write out the bottom string
        if (hr != S_OK)
            goto Cleanup;
    }
    if ( fWriteLeft )
    {
        hr = cstrRetVal.Append( _T(" ") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrRetVal.Append( pszLeft );    // Write out the left string
        if (hr != S_OK)
            goto Cleanup;
    }

Cleanup:
    if (pszLeft)
        FormsFreeString(pszLeft);
    if (pszRight)
        FormsFreeString(pszRight);
    if (pszTop)
        FormsFreeString(pszTop);
    if (pszBottom)
        FormsFreeString(pszBottom);

    if (hr == S_OK)
        hr = THR(cstrRetVal.AllocBSTR( pbstr ));

    RRETURN1(hr, S_FALSE);

Error:
    hr = S_FALSE;
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteListStyleToBSTR
//
//  Synopsis:   Cooks up a BSTR of the list item properties in CSS format.
//
//-------------------------------------------------------------------------
HRESULT WriteListStyleToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    HRESULT hr = S_FALSE;
    CStr cstrListStyle;
    BSTR bstr = NULL;

    Assert( pbstr != NULL );
    s_propdescCStylelistStyleType.b.GetEnumStringProperty(&bstr, NULL, (CVoid *)&pAA );
    if ( bstr && *bstr )
    {
        hr = cstrListStyle.Append( (TCHAR *)bstr );
        if (hr != S_OK)
            goto Cleanup;
    }

    FormsFreeString(bstr);
    bstr = NULL;

    if ( S_OK == s_propdescCStylelistStyleImage.b.GetStyleComponentProperty(&bstr, NULL, (CVoid *)&pAA ) )
    {
        if ( bstr && *bstr )
        {
            if ( hr == S_OK )
            {
                hr = cstrListStyle.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrListStyle.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }

    FormsFreeString(bstr);
    bstr = NULL;

    s_propdescCStylelistStylePosition.b.GetEnumStringProperty(&bstr, NULL, (CVoid *)&pAA );
    if ( bstr && *bstr )
    {
        if ( hr == S_OK )
        {
            hr = cstrListStyle.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
        }
        hr = cstrListStyle.Append( (TCHAR *)bstr );
        if (hr != S_OK)
            goto Cleanup;
    }
    if ( hr == S_OK )
        hr = cstrListStyle.AllocBSTR( pbstr );

    FormsFreeString(bstr);

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteBorderSidePropertyToBSTR
//
//  Synopsis:   Cooks up a BSTR of all the border properties applied to a
//              particular side in CSS format.
//
//-------------------------------------------------------------------------
HRESULT WriteBorderSidePropertyToBSTR( DWORD dispid, CAttrArray *pAA, BSTR *pbstr )
{
    PROPERTYDESC *ppdStyle;
    PROPERTYDESC *ppdColor;
    PROPERTYDESC *ppdWidth;
    CStr cstrBorder;
    BSTR bstr = NULL;
    HRESULT hr = S_OK;
    VARIANT v;

    Assert( pbstr != NULL );
    VariantInit( &v );

    if ( S_FALSE == GetBorderSidePropdescs( dispid, &ppdStyle, &ppdColor, &ppdWidth ) )
        return S_FALSE;

    hr = ((PROPERTYDESC_BASIC *)ppdColor)->b.GetColor( (CVoid *)&pAA, &cstrBorder );
    if ( hr != S_OK )
        goto Cleanup;

    hr = ppdWidth->HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v, NULL, (CVoid *)&pAA  );
    if ( ( hr == S_OK ) && ( v.vt == VT_BSTR ) && v.byref )
    {
        if ( _tcsicmp( (LPTSTR)v.byref, _T("medium") ) )
        {
            if ( cstrBorder.Length() )
            {
                hr = cstrBorder.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrBorder.Append( (LPTSTR)v.byref );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        hr = cstrBorder.Set( _T("") );
        goto Cleanup;
    }

    hr = ((PROPERTYDESC_NUMPROP *)ppdStyle)->b.GetEnumStringProperty(&bstr, NULL, (CVoid *)&pAA );
    if ( hr != S_OK )
        goto Cleanup;
    if ( bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("none") ) )
        {
            if ( cstrBorder.Length() )
            {
                hr = cstrBorder.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrBorder.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        hr = cstrBorder.Set( _T("") );
        goto Cleanup;
    }


    if ( !cstrBorder.Length() )    // All defaults
        hr = cstrBorder.Set( _T("medium none") );
    if(hr != S_OK)
        goto Cleanup;

Cleanup:
    VariantClear(&v);
    FormsFreeString(bstr);
    if ( hr == S_OK )
        hr = cstrBorder.AllocBSTR( pbstr );
    RRETURN1( hr, S_FALSE );
}

//+------------------------------------------------------------------------
//
//  Function:   ::ParseBackgroundPositionProperty
//
//  Synopsis:   Parses a background-position string in CSS format and sets
//              the appropriate sub-properties.
//
//-------------------------------------------------------------------------
HRESULT ParseBackgroundPositionProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszBackgroundPosition )
{
    TCHAR *pszString;
    TCHAR *pszCopy;
    TCHAR *pszNextToken;
    BOOL fInsideParens;
    BOOL fXIsSet = FALSE;
    BOOL fYIsSet = FALSE;
    PROPERTYDESC *pPropertyDesc;
    TCHAR *pszLastXToken = NULL;
    HRESULT hr = S_OK;
    

    PROPERTYDESC *ppdPosX = (PROPERTYDESC*)&s_propdescCStylebackgroundPositionX.a;
    PROPERTYDESC *ppdPosY = (PROPERTYDESC*)&s_propdescCStylebackgroundPositionY.a;

    CAttrValue avPosX, avPosY;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.
        BackupAttrValue (*ppAA, ppdPosX, &avPosX);
        BackupAttrValue (*ppAA, ppdPosY, &avPosY);
    }


    if( !pcszBackgroundPosition || !(*pcszBackgroundPosition))
    {
        // Empty value must set the properties to 0%
        ppdPosX->TryLoadFromString ( dwOpCode, _T("0%"), pObject, ppAA );
        ppdPosY->TryLoadFromString ( dwOpCode, _T("0%"), pObject, ppAA );
        return S_OK;
    }


    pszCopy = pszNextToken = pszString = new(Mt(ParseBackgroundPositionProperty_pszCopy)) TCHAR [_tcslen( pcszBackgroundPosition ) + 1 ];
    if ( !pszCopy )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _tcscpy( pszCopy, pcszBackgroundPosition );

    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        fInsideParens = FALSE;
        while ( _istspace( *pszString ) )
            pszString++;

        // (gschneid) We need to eat white spaces first because otherwise we do not proceed, i.e. pszNextToken is
        // not advanced.
        while ( *pszNextToken && _istspace( *pszNextToken ))
            pszNextToken++;

        while ( *pszNextToken && ( fInsideParens || !_istspace( *pszNextToken ) ) )
        {
            if ( *pszNextToken == _T('(') )
                fInsideParens = TRUE;
            if ( *pszNextToken == _T(')') )
                fInsideParens = FALSE;
            pszNextToken++;
        }

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        if ( fXIsSet && !fYIsSet )
            pPropertyDesc = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionY;
        else    // If X and Y have both either been set or both not set or just Y set, then try X first.
            pPropertyDesc = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionX;

        if ( pPropertyDesc->TryLoadFromString ( dwOpCode,pszString, pObject, ppAA ) )
        {   // Failed: try the other propdesc, it might be a enum in that direction
            if ( fXIsSet && !fYIsSet )
                pPropertyDesc = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionX;
            else
                pPropertyDesc = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionY;

            if ( S_OK == pPropertyDesc->TryLoadFromString( dwOpCode,
                        pszString, pObject, ppAA ) )
            {
                if ( fXIsSet && !fYIsSet )
                {
                    fXIsSet = TRUE;
                    if ( S_OK == ppdPosY->TryLoadFromString( dwOpCode, pszLastXToken, pObject, ppAA ) )
                        fYIsSet = TRUE;
                }
                else
                    fYIsSet = TRUE;
            }
            else
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }
        else
        {
            if ( fXIsSet && !fYIsSet )
                fYIsSet = TRUE;
            else
            {
                fXIsSet = TRUE;
                pszLastXToken = pszString;
            }
        }
        if ( fXIsSet && fYIsSet )
        {
            if (fIsStrictCSS1 && (*pszNextToken))
                hr = E_INVALIDARG;
            goto Cleanup;   // We're done - we've set both values.
        }
    }

    if ( !fXIsSet )
        ppdPosX->TryLoadFromString ( dwOpCode, _T("50%"), pObject, ppAA );

    if ( !fYIsSet )
        ppdPosY->TryLoadFromString ( dwOpCode, _T("50%"), pObject, ppAA );

Cleanup:
    if (hr == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdPosX, &avPosX);
                RestoreAttrArray(*ppAA, ppdPosY, &avPosY);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avPosX.Free();
        avPosY.Free();
    }


    delete[] pszCopy;
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteBackgroundPositionToBSTR
//
//  Synopsis:   Cooks up a BSTR of the background position.
//
//-------------------------------------------------------------------------
HRESULT WriteBackgroundPositionToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrBGPos;
    VARIANT v;
    HRESULT hr=S_OK;

    Assert( pbstr != NULL );
    VariantInit( &v );

    if ( pAA->Find( DISPID_A_BACKGROUNDPOSX, CAttrValue::AA_Attribute ) ||
        pAA->Find( DISPID_A_BACKGROUNDPOSY, CAttrValue::AA_Attribute ) )
    {
        if ( S_OK == s_propdescCStylebackgroundPositionX.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                            &v, NULL, (CVoid *)&pAA  ) )
        {
            hr = cstrBGPos.Append( (LPTSTR)v.byref );
            if (hr != S_OK)
                goto Cleanup;
            VariantClear(&v);

            if ( S_OK == s_propdescCStylebackgroundPositionY.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *)&pAA ) )
            {
                hr = cstrBGPos.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
                hr = cstrBGPos.Append( (LPTSTR)v.byref );
                if (hr != S_OK)
                    goto Cleanup;
                VariantClear(&v);
            }
        }
    }

Cleanup:
    VariantClear(&v);
    if (hr != S_OK)
        RRETURN(hr);
    RRETURN( cstrBGPos.AllocBSTR( pbstr ) );
}

//+------------------------------------------------------------------------
//
//  Function:   ::ParseClipProperty
//
//  Synopsis:   Parses a "clip" string in CSS format (from the positioning
//              specification) and sets the appropriate sub-properties.
//
//-------------------------------------------------------------------------
HRESULT ParseClipProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszClip )
{
    HRESULT hr = E_INVALIDARG;
    size_t nLen = pcszClip ? _tcslen(pcszClip) : 0;

    if ( !pcszClip )
        return S_OK;

    if ( ( nLen > 6 ) &&
         !_tcsnicmp(pcszClip, 4, _T("rect"), 4 )  &&
         ( pcszClip[nLen-1] == _T(')') ) )
    {
        // skip the "rect"
        LPCTSTR pcszProps = pcszClip + 4;

        // Terminate the string
        ((TCHAR *)pcszClip)[nLen-1] = 0;

        // skip any whitespace
        while(*pcszProps && *pcszProps == _T(' '))
            pcszProps++;

        // there better be a string, a '('
        if (*pcszProps != _T('('))
            goto Cleanup;

        // skip the '('
        pcszProps++;

        // (gschneid) Synopsis says that this is parsing the clip in css format. That's not exactly true.
        // Passing as last argument TRUE allows measure specs like "100 px". These are not allowed according
        // to CSS1 (should be "100px"; without space). I don't change anything here because this would break
        // the compatibility mode. In strict css1 mode it's taken care of this in ParseAndExpand property.
        hr = THR_NOTRACE(ParseExpandProperty( ppAA,
                                pObject,
                                dwOpCode,
                                pcszProps,
                                DISPID_A_CLIP,
                                TRUE ));

        // Restore the string
        ((TCHAR *)pcszClip)[nLen-1] = _T(')');
    }

Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteClipToBSTR
//
//  Synopsis:   Cooks up a BSTR of the "clip" region property.
//
//-------------------------------------------------------------------------
HRESULT WriteClipToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrClip;
    VARIANT v;
    HRESULT hr;

    Assert( pbstr != NULL );
    VariantInit( &v );
    hr = s_propdescCStyleclipTop.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v, NULL, (CVoid *)&pAA  );
    if ( hr == S_OK && v.byref )
    {
        hr = cstrClip.Append( _T("rect(") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrClip.Append( (LPTSTR)v.byref );
        if (hr != S_OK)
            goto Cleanup;
        VariantClear(&v);
        hr = s_propdescCStyleclipRight.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                            &v, NULL, (CVoid *)&pAA  );
        if ( hr == S_OK && v.byref )
        {
            hr = cstrClip.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrClip.Append( (LPTSTR)v.byref );
            if (hr != S_OK)
                goto Cleanup;
            VariantClear(&v);
            hr = s_propdescCStyleclipBottom.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *)&pAA  );
            if ( hr == S_OK && v.byref )
            {
                hr = cstrClip.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
                hr = cstrClip.Append( (LPTSTR)v.byref );
                if (hr != S_OK)
                    goto Cleanup;
                VariantClear(&v);
                hr = s_propdescCStyleclipLeft.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                    &v, NULL, (CVoid *)&pAA  );
                if ( hr == S_OK && v.byref )
                {
                    hr = cstrClip.Append( _T(" ") );
                    if (hr != S_OK)
                        goto Cleanup;
                    hr = cstrClip.Append( (LPTSTR)v.byref );
                    if (hr != S_OK)
                        goto Cleanup;
                    hr = cstrClip.Append( _T(")") );
                    if (hr != S_OK)
                        goto Cleanup;
                    VariantClear(&v);
                    RRETURN( cstrClip.AllocBSTR( pbstr ) );
                }
            }
        }
    }

    // Fancy way to pass a NULL pointer back?? -
    // We'll ONLY get here in the error case
Cleanup:
    VariantClear(&v);
    cstrClip.Free();
    if (hr != S_OK)
        RRETURN(hr);
    RRETURN(cstrClip.AllocBSTR( pbstr ) );
}


// All putters/getters must not have a pointer into the element attrArray is it could move.
// Use the below macros to guarantee we're pointing to a local variable which is pointing to the
// style sheet attrArray and not pointing to the attrValue on the element attrArray which can
// move if the elements attrArray has attrValues added to or deleted from.
#define GETATTR_ARRAY   \
    CAttrArray *pTempStyleAA;                       \
    CAttrArray **ppTempStyleAA = GetAttrArray();    \
    if (!ppTempStyleAA)                             \
        RRETURN(SetErrorInfo(E_OUTOFMEMORY));       \
    pTempStyleAA = *ppTempStyleAA;

#define USEATTR_ARRAY   \
    &pTempStyleAA
    

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 

STDMETHODIMP
CStyle::put_StyleComponent(BSTR v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_StyleComponentHelper(v, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CStyle::put_Url(BSTR v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_UrlHelper(v, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CStyle::put_String(BSTR v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_StringHelper(v, pPropDesc, USEATTR_ARRAY, (DISPID_INTERNAL_RUNTIMESTYLEAA == _dispIDAA));
}

STDMETHODIMP
CStyle::put_Long(long v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_LongHelper(v, pPropDesc, USEATTR_ARRAY, (DISPID_INTERNAL_RUNTIMESTYLEAA == _dispIDAA));
}


STDMETHODIMP
CStyle::put_Bool(VARIANT_BOOL v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_BoolHelper(v, pPropDesc, USEATTR_ARRAY, (DISPID_INTERNAL_RUNTIMESTYLEAA == _dispIDAA));
}

STDMETHODIMP
CStyle::put_Variant(VARIANT var)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY

#if DBG == 1
    {
        HRESULT     hr2;
        CVariant    varStr;

        hr2 = THR_NOTRACE(VariantChangeTypeSpecial(&varStr, &var, VT_BSTR));

        TraceTag((
            tagStyleInlinePutVariant,
            "put_Variant, tag: %ls, id: %ls, sn: %ld    name: %ls  type: %ld, str: %ls",
            _pElem->TagName(), STRVAL(_pElem->GetAAid()),
            _pElem->SN(),
            STRVAL(pPropDesc->pstrExposedName),
            V_VT(&var),
            S_OK == hr2 ? STRVAL(V_BSTR(&varStr)) : _T("<unknown>")));
    }
#endif

    // Allow runtimestyle default property values to be set
    return put_VariantHelper(var, pPropDesc, USEATTR_ARRAY, (DISPID_INTERNAL_RUNTIMESTYLEAA == _dispIDAA));
}

STDMETHODIMP
CStyle::put_DataEvent(VARIANT v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_DataEventHelper(v, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CStyle::get_Url(BSTR * pbstr)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY

    if (NeedToDelegateGet(pPropDesc->GetDispid()))
    {
        return DelegateGet(pPropDesc->GetDispid(), VT_BSTR, pbstr);
    }

    return get_UrlHelper(pbstr, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CStyle::get_StyleComponent(BSTR * pbstr)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY

    if (NeedToDelegateGet(pPropDesc->GetDispid()))
    {
        return DelegateGet(pPropDesc->GetDispid(), VT_BSTR, pbstr);
    }

    return get_StyleComponentHelper(pbstr, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CStyle::get_Property(void * pv)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY

    if (NeedToDelegateGet(pPropDesc->GetDispid()))
    {
        return DelegateGet(pPropDesc->GetDispid(), VT_VARIANT, pv);
    }

    return get_PropertyHelper(pv, pPropDesc, USEATTR_ARRAY);
}


#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\table\ltable.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltable.cxx
//
//  Contents:   CTableLayout basic methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx" // CTreePosList in CTableLayout::Notify
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include "detail.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"  // DB stuff in Notify
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif


MtDefine(CTableLayoutBlock, Layout, "CTableLayoutBlock")
MtDefine(CTableLayout, Layout, "CTableLayout")
MtDefine(CTableLayout_aryRows_pv, CTableLayout, "CTableLayout::_aryRows::_pv")
MtDefine(CTableLayout_aryBodys_pv, CTableLayout, "CTableLayout::_aryBodys::_pv")
MtDefine(CTableLayout_aryCols_pv, CTableLayout, "CTableLayout::_aryCols::_pv")
MtDefine(CTableLayout_aryColGroups_pv, CTableLayout, "CTableLayout::_aryColGroups::_pv")
MtDefine(CTableLayout_aryColCalcs_pv, CTableLayout, "CTableLayout::_aryColCalcs::_pv")
MtDefine(CTableLayout_aryCaptions_pv, CTableLayout, "CTableLayout::_aryCaptions::_pv")
MtDefine(CreateTableLayoutCache, PerfPigs, "CTableLayout::CreateTableLayoutCache")
MtDefine(CTableLayout_paryCurrentRowSpans, CTableLayout, "CTableLayout::_paryCurrentRowSpans")
MtDefine(CTableLayout_paryCurrentRowSpans_pv, CTableLayout, "CTableLayout::_paryCurrentRowSpans::_pv")
MtDefine(CTableLayout_pAbsolutePositionCells_pv, CTableLayout, "CTableLayout::_pAbsolutePositionCells::_pv")
MtDefine(CTableLayout_Notify_aryRects_pv, Locals, "CTableLayout::Notify aryRects::_pv")
MtDefine(CTableLayoutBreak_pv, ViewChain, "CTableLayoutBreak_pv");
ExternTag(tagLayoutTasks);

DeclareTag(tagTLCDirty, "Tables", "trace TLC dirty bit");

ExternTag(tagCalcSize);


extern void __cdecl WriteHelp(HANDLE hFile, TCHAR *format, ...);
extern void WriteString(HANDLE hFile, TCHAR *pszStr);

const CLayout::LAYOUTDESC CTableLayoutBlock::s_layoutdesc =
{
    LAYOUTDESC_TABLELAYOUT,         // _dwFlags
};

const CLayout::LAYOUTDESC CTableLayout::s_layoutdesc =
{
    LAYOUTDESC_TABLELAYOUT,         // _dwFlags
};

//+---------------------------------------------------------------------
//
// CTableLayoutBlock implementation
//
//+---------------------------------------------------------------------
//+------------------------------------------------------------------------
//
//  Member:     CTableLayoutBlock::constructor
//
//-------------------------------------------------------------------------
CTableLayoutBlock::CTableLayoutBlock(CElement * pElement, CLayoutContext *pLayoutContext) 
    : CLayout(pElement, pLayoutContext)
{
    _sizeParent.cx  = -1;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableLayoutBlock::destructor
//
//-------------------------------------------------------------------------
CTableLayoutBlock::~CTableLayoutBlock()
{
    if (_pTableBorderRenderer)
        _pTableBorderRenderer->Release();
}

//+---------------------------------------------------------------------
//
// Function:    CTableLayoutBlock::GetCaptionDispNode 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
CDispContainer * 
CTableLayoutBlock::GetCaptionDispNode()
{
    Assert(_fHasCaptionDispNode);
    return DYNCAST(CDispContainer, GetElementDispNode());
}

//+---------------------------------------------------------------------
//
// Function:    CTableLayoutBlock::GetTableInnerDispNode 
//
//  Synopsis:   Find and return the CDispNode which contains TBODY cells
//
//+---------------------------------------------------------------------
CDispContainer * 
CTableLayoutBlock::GetTableInnerDispNode()
{
    // TODO (112594, olego): Table inner / outer disp node work needs to be finished. 
    // There are many comments and code that is supposed to distinguish between inner 
    // and outer table dispnode. Though this work has not been finished and double 
    // set of table dispnode function effectively have the same implementation. 
    // We need to investigate and either role everything back to use single function 
    // set or truly implement inner / outer dispnodes functionality. 

    // Not done yet...assume all THEAD/TFOOT/TBODY cells live under the same display node (brendand)
    return GetTableOuterDispNode();
}

//+---------------------------------------------------------------------
//
// Function:    CTableLayoutBlock::GetTableOuterDispNode  
//
//  Synopsis:   Find and return the CDispNode which contains THEAD/TFOOT cells
//
//+---------------------------------------------------------------------
CDispContainer * 
CTableLayoutBlock::GetTableOuterDispNode()
{
    CDispContainer *    pDispNodeTableOuter;

    if (_fHasCaptionDispNode)
    {
        Assert(GetElementDispNode());

        for (CDispNode* pDispNode = GetElementDispNode()->GetFirstFlowChildNode();
                        pDispNode;
                        pDispNode = pDispNode->GetNextFlowNode())
        {
            if (!pDispNode->IsOwned())
                break;
        }

        Assert(pDispNode && pDispNode->IsFlowNode());

        pDispNodeTableOuter = CDispContainer::Cast(pDispNode);
    }
    else
    {
        pDispNodeTableOuter = CDispContainer::Cast(GetElementDispNode());
    }

    return pDispNodeTableOuter;
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::EnsureTableDispNode 
//
//  Synopsis:   Manage the lifetime of the table layout display node
//
//  Arugments:  pci   - Current CTableCalcInfo
//              fForce - Forcibly update the display node(s)
//
//  Returns:    S_OK    if successful
//              S_FALSE if nodes were created/destroyed
//              E_FAIL  otherwise
//
//+---------------------------------------------------------------------
HRESULT
CTableLayoutBlock::EnsureTableDispNode(
    CCalcInfo *         pci,
    BOOL                fForce)
{
    CDispContainer *    pDispNode;
    CDispNode *         pDispNodeElement;
    CDispContainer *    pDispNodeTableOuter;
    CTableLayout *      pTableLayoutCache;
    CDispNodeInfo       dni;
    HRESULT             hr = S_OK;

    Assert(pci);

    pTableLayoutCache = Table()->TableLayoutCache();
    Assert(pTableLayoutCache);

    //
    //  Get display node attributes
    //

    GetDispNodeInfo(&dni, pci, TRUE);
    Assert(!dni.IsScroller());
    Assert(!dni.IsRTLScroller());

    //
    //  Locate the display node that anchors cells
    //  (If a separate CAPTIONs display node exists, the display node for cells
    //   will be the only unowned node in the flow layer)
    //

    pDispNodeElement    = GetElementDispNode();
    pDispNodeTableOuter = GetTableOuterDispNode();
    
    //  Assert for print view positioned elements pagination support 
    Assert(!pci->_fCloneDispNode || (pDispNodeElement && pDispNodeTableOuter)); 
    Assert(!pci->_fCloneDispNode || (!pTableLayoutCache->HasCaptions() == !_fHasCaptionDispNode));

    //
    //  If a display node is needed to hold CAPTIONs and TCs, ensure one exists
    //

    if (    pTableLayoutCache->HasCaptions()
        &&  (   !_fHasCaptionDispNode
            ||  fForce
            ||  pci->_fCloneDispNode 
            ||  dni.HasUserClip() != pDispNodeElement->HasUserClip()))
    {
        DWORD extras = 0;

        if(dni.HasUserClip())
            extras |= DISPEX_USERCLIP;
        if(dni.HasUserTransform())
            extras |= DISPEX_USERTRANSFORM;
        
        pDispNode = CDispContainer::New(this, extras);
        if (!pDispNode)
            goto Error;

        pDispNode->SetOwned();
        pDispNode->SetAffectsScrollBounds(!ElementOwner()->IsRelative());

        if (dni.HasUserClip())
            pDispNode->SetUserClip(CRect(CRect::CRECT_EMPTY));

        EnsureDispNodeLayer(dni, pDispNode);

        //
        // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
        // TODO - At some point the edit team may want to provide
        // a better UI-level way of selecting nested "thin" tables
        //
        //
        // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
        //        pTableLayoutCache->EnsureTableFatHitTest( pDispNode );
        
        if (pDispNodeElement)
        {
            if (_fHasCaptionDispNode)
            {
                if (pci->_fCloneDispNode)
                {
                    Assert(pci->GetLayoutContext());
                    AddDispNodeToArray(pDispNode); 
                }
                else 
                {
                    pDispNode->ReplaceNode(pDispNodeElement);
                }
            }
            else
            {
                pDispNodeElement->InsertParent(pDispNode);
                pDispNodeElement->SetOwned(FALSE);
                pDispNodeElement->SetAffectsScrollBounds(TRUE);
                pDispNodeElement->SetLayerFlow();
            }
        }

        if (_pDispNode == pDispNodeElement)
        {
            _pDispNode = pDispNode;
        }

        pDispNodeElement     = pDispNode;
        _fHasCaptionDispNode = TRUE;

        hr = S_FALSE;
    }

    //
    //  Otherwise, if a CAPTION/TC node exists and is not needed, remove it
    //  (The display node which anchors the table cells is the only unowned
    //   node within the flow layer)
    //

    else if (   !pTableLayoutCache->HasCaptions()
            &&  _fHasCaptionDispNode)
    {
        Assert(!pci->_fCloneDispNode);

        pDispNodeTableOuter->ReplaceParent();

        pDispNodeElement =
        _pDispNode = pDispNodeTableOuter;

        _pDispNode->SetOwned();
        _pDispNode->SetAffectsScrollBounds(!ElementOwner()->IsRelative());

        _fHasCaptionDispNode = FALSE;

        //
        // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
        // TODO - At some point the edit team may want to provide
        // a better UI-level way of selecting nested "thin" tables
        //
        //
        // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
        //
        
        pTableLayoutCache->EnsureTableFatHitTest( _pDispNode );

        hr = S_FALSE;
    }

    //
    //  If no display node for the cells exist or if an interesting property has changed, create a display node
    //
    Assert(!dni.IsScroller());
    Assert(!dni.IsRTLScroller());

    if (    !pDispNodeTableOuter
        ||  fForce
        ||  pci->_fCloneDispNode 
        ||  dni.GetBorderType() != pDispNodeTableOuter->GetBorderType()
        ||  (   !_fHasCaptionDispNode
            &&  dni.HasUserClip() != pDispNodeTableOuter->HasUserClip())

    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //
    //
    // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
    //
        ||  pTableLayoutCache->GetFatHitTest()     != pDispNodeTableOuter->IsFatHitTest() )
    {
        DWORD extras = 0;
        if (dni.HasUserClip() && !_fHasCaptionDispNode)
            extras = DISPEX_USERCLIP;
        if (dni.GetBorderType() == DISPNODEBORDER_SIMPLE)
            extras |= DISPEX_SIMPLEBORDER;
        else if (dni.GetBorderType() == DISPNODEBORDER_COMPLEX)
            extras |= DISPEX_COMPLEXBORDER;
        if (!_fHasCaptionDispNode && dni.HasUserTransform())
            extras |= DISPEX_USERTRANSFORM;
        
        pDispNode = CDispContainer::New(this, extras);

        if (!pDispNode)
            goto Error;

        pDispNode->SetOwned(!_fHasCaptionDispNode);

        if (dni.HasUserClip())
            pDispNode->SetUserClip(CRect(CRect::CRECT_EMPTY));

        if (_fHasCaptionDispNode)
        {
            pDispNode->SetLayerFlow();
        }
        else
        {
            EnsureDispNodeLayer(dni, pDispNode);
            pDispNode->SetAffectsScrollBounds(!ElementOwner()->IsRelative());
        }

        EnsureDispNodeBackground(dni, pDispNode);
        EnsureDispNodeVisibility(dni.GetVisibility(), ElementOwner(), pDispNode);


        pTableLayoutCache->EnsureTableFatHitTest( pDispNode );

        if (pci->_fCloneDispNode)
        {
            Assert(pDispNodeTableOuter);

            if (_fHasCaptionDispNode)
            {
                Assert(pDispNodeElement);
                DYNCAST(CDispContainer, pDispNodeElement)->InsertChildInFlow(pDispNode);
            }
            else 
            {
                Assert(pci->GetLayoutContext());
                AddDispNodeToArray(pDispNode); 
            }
        }
        else 
        {
            if (pDispNodeTableOuter)
            {
                pDispNode->ReplaceNode(pDispNodeTableOuter);
            }
            else if (_fHasCaptionDispNode)
            {
                Assert(pDispNodeElement);
                DYNCAST(CDispContainer, pDispNodeElement)->InsertChildInFlow(pDispNode);
            }
        }

        if ( !_fHasCaptionDispNode 
            && _pDispNode == pDispNodeElement)
        {
            _pDispNode = pDispNode;
        }

        hr = S_FALSE;
    }

    return hr;

Error:
    if (pDispNode)
    {
        pDispNode->Destroy();
    }

    if (pDispNodeElement)
    {
        pDispNodeElement->Destroy();
    }

    _pDispNode = NULL;
    _fHasCaptionDispNode = FALSE;
    return E_FAIL;
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::Init
//
// Synopsis:     
//
//+---------------------------------------------------------------------
HRESULT
CTableLayoutBlock::Init()
{
    HRESULT hr = super::Init();

    // Tables are breakable if their markup's master is a layoutrect
    SetElementAsBreakable();

    return hr;
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::CalcSize 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
DWORD 
CTableLayoutBlock::CalcSizeVirtual(CCalcInfo * pci, SIZE * psize, SIZE * psizeDefault)
{
    Assert(Table()->HasLayoutAry());
    return Table()->TableLayoutCache()->CalcSizeVirtual(pci, psize, psizeDefault);
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::Draw 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
void 
CTableLayoutBlock::Draw(CFormDrawInfo *pDI, CDispNode * pDispNode)
{
    Assert(Table()->HasLayoutAry());
    Table()->TableLayoutCache()->Draw(pDI, pDispNode);
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::Notify 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
void 
CTableLayoutBlock::Notify(CNotification * pnf)
{
    Assert(!pnf->IsReceived(_snLast));

    CTableLayout * pTableLayoutCache = Table()->TableLayoutCache();

    Assert(Table()->HasLayoutAry() == (this != (CTableLayoutBlock *)pTableLayoutCache));

    BOOL fCanRecalc = pTableLayoutCache->CanRecalc();
    BOOL fHandle = TRUE;

    //
    //  Respond to the notification if:
    //      a) The table is not sizing (if sizing ignore the notification),
    //      b) The notification is not handled yet (ignore if it is already handled),
    //      c) The table is capable of recalcing.
    //

    if (pnf->IsTextChange() && !pnf->IsFlagSet(NFLAGS_PARSER_TEXTCHANGE))
    {
        pTableLayoutCache->_fDontSaveHistory = TRUE;
        Table()->ClearHistory();                // don't use history

        // commented the code below since it will happened during hadnling the Text Changes bellow
        //if (_fUsingHistory)                   // if we are already using History
        //{
        //    Assert (CanRecalc());
        //    pTableLayout->Resize();           // then, ensure full resize
        //}
    }

    if (   !fCanRecalc
        && !pnf->IsHandled()
        && IsPositionNotification(pnf)
        && !ElementOwner()->IsZParent())
    {
        fHandle = FALSE;
    }

    if (    fCanRecalc
        &&  !pnf->IsHandled()
        &&  (   !TestLock(CElement::ELEMENTLOCK_SIZING)
            ||  IsPositionNotification(pnf)))
    {
        //
        //  First, handle z-change and position change notifications
        //

        if (IsPositionNotification(pnf))
        {
            fHandle = HandlePositionNotification(pnf);
        }

        //
        //  Next, handle resize requests
        //

        else if (pnf->IsType(NTYPE_ELEMENT_RESIZE))
        {
            Assert(pnf->Element() != ElementOwner() || LayoutContext());

            //  In print view there are several layout blocks existing for the element. 
            //  Notification is distributed to every block. Due to specific of NTYPE_ELEMENT_RESIZE
            //  (changing of pnf->_pElement) we may want to proceed it only once
            if (pnf->Element() != ElementOwner())
            {

                //
                //  Always "dirty" the layout associated with the element
                //

                pnf->Element()->DirtyLayout(pnf->LayoutFlags());

                //
                //  Handle absolute elements by noting that one is dirty
                //

                if (pnf->Element()->IsAbsolute())
                {
                    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                                "Layout Request: Queuing RF_MEASURE on ly=0x%x [e=0x%x,%S sn=%d] by CTableLayout::Notify() [n=%S srcelem=0x%x,%S]",
                                this,
                                _pElementOwner,
                                _pElementOwner->TagName(),
                                _pElementOwner->_nSerialNumber,
                                pnf->Name(),
                                pnf->Element(),
                                pnf->Element() ? pnf->Element()->TagName() : _T("")));
                    QueueRequest(CRequest::RF_MEASURE, pnf->Element());

                    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                                "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CTableLayout::Notify() [n=%S srcelem=0x%x,%S] [abs desc need sizing]",
                                this,
                                _pElementOwner,
                                _pElementOwner->TagName(),
                                _pElementOwner->_nSerialNumber,
                                pnf->Name(),
                                pnf->Element(),
                                pnf->Element() ? pnf->Element()->TagName() : _T("")));
                    PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);
                }

                //
                //  Handle non-absolute elements by
                //      a) Marking the table dirty
                //      b) Resizing the table
                //

                else
                {
                    Assert(pnf->IsType(NTYPE_ELEMENT_RESIZE));
                    Assert(pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED));

                    if (    pTableLayoutCache->IsFullyCalced() 
                        || (pTableLayoutCache->IsRepeating() && !pTableLayoutCache->IsFixed() && !pTableLayoutCache->IsGenerationInProgress()) )
                    {
                        pTableLayoutCache->ResetMinMax();
                    }

                    // any (non-databound) changes to a databound table while
                    // generation is in progress should turn off incremental recalc
                    if (pTableLayoutCache->IsRepeating() && 
                        // TODO (112595) :  There is a dozen places all other in Trident where check 
                        // for element / layout type is done through call to Tag() and comparing to 
                        // ETAG_TD / ETAG_TH. This is a potential source of bugs since sometimes only 
                        // one condition is compared. Switching to IsTableCell should be placed in such cases. 
                        (pnf->Element()->Tag() == ETAG_TD || pnf->Element()->Tag() == ETAG_TH) &&
                        DYNCAST(CTableCell, pnf->Element())->Row()->_iRow < 
                            pTableLayoutCache->_iLastRowIncremental )
                    {
                        pTableLayoutCache->_fDirtyBeforeLastRowIncremental = TRUE;
                    }

                    fHandle = FALSE;        // stealing notification
                    pnf->SetElement(ElementOwner()); // parent of the table will handle the request
                }
            }
            else 
            {
                fHandle = FALSE;        // stealing notification
            }
        }

        //
        //  If remeasuring or a descendent is changing their min/max,
        //  resize the table and clear its min/max
        //

        else if (   pnf->IsType(NTYPE_ELEMENT_REMEASURE) 
                ||  pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE)   //  <- bug # 107654 
                ||  pnf->IsType(NTYPE_ELEMENT_MINMAX)   )
        {
            Assert(     pnf->Element() == ElementOwner()
                    ||  pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED));    // Necessary to allow ChangeTo below

            pTableLayoutCache->ResetMinMax();

            //
            //  Mark forced layout if requested
            //

            // Remember REMEASUREALLCONTENTS implies FORCE.  Bug #89131,
            // table sections don't morph remeasure notifies.
            if (pnf->LayoutFlags() & LAYOUT_FORCE)
            {
                // In PPV this is the only chance to make layout blocks dirty
                //_fForceLayout = TRUE;
                ElementOwner()->DirtyLayout(pnf->LayoutFlags());
            }

            fHandle = FALSE;
            pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
        }

        //
        //  Interpret "text" changes immediately beneath the table as invalidating
        //  the row/cells collection(s)
        //

        else if (pnf->IsTextChange() && pTableLayoutCache->IsCompleted())
        {
            if (pTableLayoutCache->IsRepeating())
            {
                if (pTableLayoutCache->_nDirtyRows && pTableLayoutCache->_cDirtyRows >= pTableLayoutCache->_nDirtyRows)  // we are in chanking mode
                {
                    if (pTableLayoutCache->_nDirtyRows < 100)
                        pTableLayoutCache->_nDirtyRows += 10;  // increment chunk size for resize
                    pTableLayoutCache->_cDirtyRows = 0;        // reset the dirty row counter for future chunk of rows resize
                    pTableLayoutCache->_fDirty     = TRUE;
                    pTableLayoutCache->Resize();
                }
            }
            else
            {
                Assert(pnf->Element() != ElementOwner());
                if (!pTableLayoutCache->_fTableOM)
                {
                    pTableLayoutCache->MarkTableLayoutCacheDirty();
                    pTableLayoutCache->Resize();
                }
            }
        }

        //
        //  Handle translated ranges
        //

        else if (pnf->IsType(NTYPE_TRANSLATED_RANGE))
        {
            Assert(pnf->IsDataValid());
            HandleTranslatedRange(pnf->DataAsSize());
        }

        //
        //  Handle changes to CSS display and visibility
        //

        else if (   pnf->IsType(NTYPE_DISPLAY_CHANGE)
                ||  pnf->IsType(NTYPE_VISIBILITY_CHANGE))
        {
            HandleVisibleChange(pnf->IsType(NTYPE_VISIBILITY_CHANGE));
        }
        else if ( pnf->IsType(NTYPE_ZERO_GRAY_CHANGE ))
        {
            HandleZeroGrayChange( pnf );
        }

        //
        //  Handle z-parent changes
        //

        else if (pnf->IsType(NTYPE_ZPARENT_CHANGE))
        {
            if (!ElementOwner()->IsPositionStatic())
            {
                ElementOwner()->ZChangeElement();
            }

            else if (_fContainsRelative)
            {
                ZChangeRelDispNodes();
            }
        }

        //
        //  Insert adornments as needed
        //

        else if (pnf->IsType(NTYPE_ELEMENT_ADD_ADORNER))
        {
            fHandle = HandleAddAdornerNotification(pnf);
        }

        //
        //  Handle invalidations
        //

        else if (IsInvalidationNotification(pnf))
        {
            //
            // Invalidations of table parent elements
            //

            if (    ElementOwner() == pnf->Element() 
                ||  pnf->IsFlagSet(NFLAGS_DESCENDENTS)  )
            {
                Invalidate();
            }

            //
            // Invalidations of table child elements
            //

            else if (pnf->Element())
            {
                RECT rcBound = g_Zero.rc;
                CDataAry<RECT> aryRects(Mt(CTableLayout_Notify_aryRects_pv));

                RegionFromElement(pnf->Element(), &aryRects, &rcBound, 0);

                if (!IsRectEmpty(&rcBound))
                {
                    Invalidate(&rcBound);
                }
            }
        }
    }

#ifndef NO_DATABINDING
    if (pTableLayoutCache->_pDetailGenerator)
    {
        if (pnf->IsType(NTYPE_STOP_1) ||
            pnf->IsType(NTYPE_MARKUP_UNLOAD_1))
        {
            pnf->SetSecondChanceRequested();
        }
        else if (pnf->IsType(NTYPE_STOP_2) ||
                 pnf->IsType(NTYPE_MARKUP_UNLOAD_2))
        {
            pTableLayoutCache->_pDetailGenerator->StopGeneration();
        }
    }
#endif

    if (pnf->IsType(NTYPE_ELEMENT_ENSURERECALC))
    {

        //if the notification is for this element, just pass it to parent so it will 
        // calc us if we got in its background recalc/dirty range.
        if (pnf->Element() == ElementOwner())
        {
            fHandle = FALSE;
        }

        //
        //  Otherwise, request the parent layout to measure up through this element
        //  In other words, fire NTYPE_ELEMENT_ENSURERECALC from this element - it will 
        // first come to us (see line above), then to parent and parent will hopefully continue 
        // until all is recalced up the tree. Then we return from 
        // SendNotification(NTYPE_ELEMENT_ENSURERECALC) and process requests (if any) for 
        // the element we've got this notification in the first place.
        //
        else
        {
            CView * pView = Doc()->GetView();

            if(pView->IsActive() && fCanRecalc)
            {
                CView::CEnsureDisplayTree   edt(pView);

                ElementOwner()->SendNotification(NTYPE_ELEMENT_ENSURERECALC);

                if (!pTableLayoutCache->IsFullyCalced())
                {
                    ProcessRequest(pnf->Element());
                }
            }
        }
    }

    //
    //  Handle the notification (unless its been changed)
    //

    if (fHandle && pnf->IsFlagSet(NFLAGS_ANCESTORS))
    {
        pnf->SetHandler(ElementOwner());
    }

#if DBG==1
    // Update _snLast unless this is a self-only notification. Self-only
    // notification are an anachronism and delivered immediately, thus
    // breaking the usual order of notifications.
    if (!pnf->SendToSelfOnly() && pnf->SerialNumber() != (DWORD)-1)
    {
        _snLast = pnf->SerialNumber();
    }
#endif
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::IsDirty 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
BOOL
CTableLayoutBlock::IsDirty()
{
    Assert(Table()->HasLayoutAry());
    return Table()->TableLayoutCache()->IsDirty();
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::OnFormatsChange 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
HRESULT 
CTableLayoutBlock::OnFormatsChange(DWORD dwFlags)
{
    Assert(Table()->HasLayoutAry());
    return Table()->TableLayoutCache()->OnFormatsChange(dwFlags);
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::GetClientPainterInfo
//
// Synopsis:     
//
//+---------------------------------------------------------------------
DWORD 
CTableLayoutBlock::GetClientPainterInfo(
                                CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
{
    if (GetTableOuterDispNode() != pDispNodeFor) 
    {                                            // if draw request is for dispNode other then 
        return 0;                                // primary then no drawing at all the dispNode
    }

    Assert(Table()->HasLayoutAry());
    return Table()->TableLayoutCache()->GetPeerPainterInfo(pAryClientInfo);
}

//+---------------------------------------------------------------------
//
// CTableLayout implementation
//
//+---------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::constructor
//
//-------------------------------------------------------------------------

CTableLayout::CTableLayout(CElement * pElement, CLayoutContext *pLayoutContext)
    : CTableLayoutBlock(pElement, pLayoutContext),
        _aryRows(Mt(CTableLayout_aryRows_pv)),
        _aryBodys(Mt(CTableLayout_aryBodys_pv)),
        _aryCols(Mt(CTableLayout_aryCols_pv)),
        _aryColGroups(Mt(CTableLayout_aryColGroups_pv)),
        _aryColCalcs(Mt(CTableLayout_aryColCalcs_pv)),
        _aryCaptions(Mt(CTableLayout_aryCaptions_pv))
{
    // no Init(); function

    _fDirty         = TRUE;
    _fAllRowsSameShape = TRUE;
    _sizeMin.cx     = -1;
    _sizeMax.cx     = -1;
    _cNestedLevel   = -1;
    _iInsertRowAt   = -1;
    _cyHeaderHeight = -1;
    _cyFooterHeight = -1;
}


//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::destructor
//
//  Note:       The borderinfo cache must be deleted in the destructor
//
//-------------------------------------------------------------------------

CTableLayout::~CTableLayout()
{
    if (_pBorderInfoCellDefault)
        delete _pBorderInfoCellDefault;

    ClearRowSpanVector();

    if (_pAbsolutePositionCells)
    {
        int i;

        for (i = _pAbsolutePositionCells->Size()-1; i>=0; i--)
        {
            _pAbsolutePositionCells->Item(i)->SubRelease();
        }

        _pAbsolutePositionCells->SetSize(0);
        delete _pAbsolutePositionCells;
        _pAbsolutePositionCells = NULL;
    }
}


//+---------------------------------------------------------------
//
//  Member:     CTableLayout::Detach
//
//  Synopsis:   Disconnects everything
//
//  Notes:      Call this method before releasing the site.  As a container
//              site we are expected to release all contained sites.
//
//---------------------------------------------------------------

void
CTableLayout::Detach()
{
#ifndef NO_DATABINDING
    // note the order of the detachment is important,
    // we need to detach the detail generator before we touch the aryBodys.
    if (_pDetailGenerator)
    {
        _pDetailGenerator->Detach();
        delete _pDetailGenerator;
        _pDetailGenerator = NULL;
    }
#endif

    ClearTopTableLayoutCache();

    // We just wiped out our table layout cache.  Mark it dirty in case
    // UNDO resurrects the table.
    MarkTableLayoutCacheDirty();

    DestroyFlowDispNodes();

    super::Detach();
}


//+----------------------------------------------------------------------------
//
// Member:   CTableLayout::VoidCachedFormats
//
// Synopsis: Clear all the format cache information in colgroups, tbodys, cols
//           and any header and footer.
//
//-----------------------------------------------------------------------------

void
CTableLayout::VoidCachedFormats()
{
    CTableCol     **ppCol;
    CTableCol     **ppColGroup;
    int             iCol;
    int             iColGroup;

    // NOTE: clear cached format on rows/cells/sections is done by ClearRunChaches.
    //       but we need to do it for Cols and ColGroups since you can not get to
    //       them from the runs.

    // clear cached format info for table cols collection
    for (ppCol = _aryCols, iCol = _aryCols.Size();
         iCol > 0;
         iCol--, ppCol++)
    {
        if (   *ppCol 
            && (*ppCol)->GetFirstBranch())
        {
            (*ppCol)->GetFirstBranch()->VoidCachedInfo();
        }
    }

    // clear cached format info for table colGroups collection
    for (ppColGroup = _aryColGroups, iColGroup = _aryColGroups.Size();
         iColGroup > 0;
         iColGroup--, ppColGroup++)
    {
        if (   *ppColGroup
            && (*ppColGroup)->GetFirstBranch())
        {
            (*ppColGroup)->GetFirstBranch()->VoidCachedInfo();
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CreateTableLayoutCache
//
//  Synopsis:   Walks a table, restoring the table layout cache.
//
//+----------------------------------------------------------------------------

static ELEMENT_TAG   atagSkip[] = { ETAG_TD, ETAG_TH, ETAG_CAPTION, ETAG_TC, ETAG_TABLE };
static ELEMENT_TAG   atagChildren[] = { ETAG_TD, ETAG_TH, ETAG_CAPTION, ETAG_TC, ETAG_TR, ETAG_TBODY, ETAG_THEAD, ETAG_TFOOT, ETAG_COL, ETAG_COLGROUP };

HRESULT
CTableLayout::CreateTableLayoutCache()
{
    HRESULT         hr = S_OK;
    CTreeNode *     pNode = NULL;
    CTable *        pTable = Table();
    CChildIterator  iter(pTable, NULL, CHILDITERATOR_USETAGS, atagSkip, ARRAY_SIZE(atagSkip), atagChildren, ARRAY_SIZE(atagChildren));
    CTableRow     * pRow = NULL;
    CTableSection * pSection = NULL;
    CTableCol     * pColGroup = NULL;
    CTableCell    * pCell = NULL;
    CElement      * pElementScope;
    ELEMENT_TAG     etag;
    BOOL            fFirstRow = TRUE;

    FlushGrid();

    MtAdd(Mt(CreateTableLayoutCache), +1, 0);

    _fEnsuringTableLayoutCache = TRUE;
    _fAllRowsSameShape = TRUE;
    _cRowsParsed = 0;

#if NEED_A_SOURCE_ORDER_ITERATOR
    _iHeadRowSourceIndex = 0;
    _iFootRowSourceIndex = 0;
#endif

    for (pNode = iter.NextChild();
         pNode;
         pNode = iter.NextChild())
    {
        pElementScope = pNode->Element();

        // do not include elements that are exiting tree 
        if (pElementScope->_fExittreePending) 
            continue;

        etag = pElementScope->Tag();

        switch ( etag )
        {
        case ETAG_TBODY :
        case ETAG_TFOOT :
        case ETAG_THEAD :

            pSection = DYNCAST( CTableSection, pElementScope );
            hr = THR( AddSection( pSection ) );
            if (hr)
                goto Cleanup;

            break;

        case ETAG_TR:

            if (pSection)
            {
                pRow = DYNCAST( CTableRow, pElementScope );
                if (pSection == pRow->Section())
                {

                    if (!fFirstRow && _fAllRowsSameShape && _cCols != _cTotalColSpan)
                    {
                        _fAllRowsSameShape = FALSE;
                    }
                    fFirstRow = FALSE;

                    _cRowsParsed++;
                    hr = THR( AddRow( pRow ) );
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    pRow = NULL;    // blocking cells from coming into a table's cache
                }
            }
            else
            {
                pRow = DYNCAST( CTableRow, pElementScope );
                pRow->_iRow = -1;
                pRow = NULL;        // blocking cells from coming into a table's cache
            }

            break;

        case ETAG_COL :

            if (pColGroup)
            {
                hr = THR( AddCol( DYNCAST( CTableCol, pElementScope ) ) );
                if (hr)
                    goto Cleanup;
            }
            
            break;

        case ETAG_COLGROUP :

            pColGroup = DYNCAST(CTableCol, pElementScope);
            hr = THR( AddColGroup( pColGroup ) );
            if (hr)
                goto Cleanup;

            break;

        case ETAG_TD :
        case ETAG_TH :

            if (pRow)
            {
                pCell = DYNCAST( CTableCell, pElementScope );
                if (pRow == pCell->Row())
                {
                    hr = THR( pRow->RowLayoutCache()->AddCell(pCell) );
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    pRow = NULL;
                }
            }

            break;

        case ETAG_CAPTION :
        case ETAG_TC :
            {
                CTableCaption * pCaption = DYNCAST( CTableCaption, pElementScope );

                pCaption->_uLocation = pCaption->IsCaptionOnBottom()
                                       ? CTableCaption::CAPTION_BOTTOM
                                       : CTableCaption::CAPTION_TOP;

                hr = THR( AddCaption( pCaption ) );
                if (hr)
                    goto Cleanup;

                break;
            }
        }
    }

    EnsureColsFormatCacheChange();

    hr = EnsureCells();

Cleanup:
    _fEnsuringTableLayoutCache = FALSE;
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     AddRow
//
//  Synopsis:   Add a row to the table
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::AddRow(CTableRow * pRow, BOOL fNewRow)
{
    Assert(pRow);

    CTableRowLayout *   pRowLayout = pRow->RowLayoutCache();
    int                 iSection;
    int                 iRow;
    CTableSection *     pSection;
    CTableSection **    ppSection;
    HRESULT             hr = S_OK;

    pSection = pRow->Section();
    Assert(pSection);

    // insert the row at the end of the section
    if (!_fTableOM)
    {
        iRow = pRow->_iRow = pSection->_iRow + pSection->_cRows;
    }
    else
    {
        iRow = pRow->_iRow = _iInsertRowAt;
        Assert (iRow >= pSection->_iRow && iRow <= pSection->_iRow + pSection->_cRows);
    }

    hr = AddRowElement(iRow, pRow);
    if (hr)
        goto Cleanup;

    if (IsRepeating() && iRow < _iLastRowIncremental) 
    {
        _fDirtyBeforeLastRowIncremental = TRUE;
    }

    // Need to clear the array of cells because in the new lazy table
    // layout cache (TLC), we always have to create the caches down to
    // the table cell level since we don't know anymore what caused the
    // TLC to be invalid (e.g. TOM, DB, ...).
    if (_fTLCDirty)
    {
        pRowLayout->ClearRowLayoutCache();
    }

    if (!fNewRow)
    {
        EnsureCols(pRowLayout->_aryCells.Size());
    }

    // Ensure the cells in the row according to the number of columns
    hr = pRowLayout->EnsureCells(GetCols());
    if (hr)
        goto Cleanup;

    pSection->_cRows++;

    if (fNewRow)
    {
        // copy the row-spanned cells down from previous rows...
        if (iRow > pSection->_iRow && _cCurrentRowSpans)
        {
            int         iCol;
            CTableCell *pRowSpannedCell = NULL;
            int         cColSpan = 0;

            Assert (_paryCurrentRowSpans && _paryCurrentRowSpans->Size());

            pRow->_fCrossingRowSpan = TRUE;

            for (iCol = 0; _cCurrentRowSpans && iCol < _paryCurrentRowSpans->Size(); iCol++)
            {
                int iRemainingRowsSpan = (*_paryCurrentRowSpans)[iCol];
                if (iRemainingRowsSpan > 0)
                {
                    if ( (--(*_paryCurrentRowSpans)[iCol]) == 0 )
                    {
                        // row spaned cells ends in this row
                        Assert (_cCurrentRowSpans > 0);
                        _cCurrentRowSpans--;
                    }   // else: row spanned cells crossing this row
                    pRowSpannedCell = Cell(_aryRows[iRow - 1]->RowLayoutCache()->_aryCells[iCol]);
                    cColSpan = pRowSpannedCell->ColSpan();
                    for (int i = 0; i < cColSpan; i++)
                    {
                        pRowLayout->SetCell(i+iCol, MarkSpanned(pRowSpannedCell));
                    }
                }
            }
        }

        pRowLayout->_cRealCells = 0;
        pRow->_fHaveRowSpanCells = FALSE;
    }

    // Adjust the row index held by each row in the array following the insertion point
    for (iRow = GetRows()-1; iRow > pRow->_iRow; iRow--)
    {
        GetRow(iRow)->_iRow++;
        Assert(GetRow(iRow)->_iRow == iRow);
    }

    Assert (iRow == pRowLayout->RowPosition()); // sanity check

    // If the row is for a THEAD and the TFOOT is already present, advance the TFOOT row
    // (THEADs never need advancing since their rows are always first in the row array)
    if (_pFoot                   &&
        !pSection->_fBodySection &&
        pSection->Tag() == ETAG_THEAD)
    {
        _pFoot->_iRow++;
        Assert(_pFoot->_iRow < GetRows());
    }

    // Lastly, advance the row indexes of any sections which follow the inserted row
    // (Since TBODYs are inserted in source order, only the insertion of a THEAD or TFOOT
    //  can cause the advancement of the rows owned by a body)
    if (!pSection->_fBodySection || _pSectionInsertBefore)
    {
        Assert (!pSection->_fBodySection || _fPastingRows);
        Assert(iRow == pRowLayout->RowPosition());
        for (ppSection = _aryBodys, iSection = _aryBodys.Size();
             iSection > 0;
             iSection--, ppSection++)
        {
            if((*ppSection)->_iRow >= iRow && (*ppSection) != pSection)
            {
                (*ppSection)->_iRow++;
                Assert((*ppSection)->_iRow + (*ppSection)->_cRows <= GetRows());
            }
        }
    }

    _cTotalColSpan = 0;       // set it up for the this row

    ConsiderResizingFixedTable(pRow);

Cleanup:
    RRETURN(hr);
}


// Helper function called on exit tree for row
void
CTableLayout::RowExitTree(int iRow, CTableSection *pCurSection)
{
    CTableRow       *pRow;
    CTableSection   *pSection;
    int              i, cRows;

    if (!pCurSection || !(pCurSection->_cRows > 0 && iRow >= pCurSection->_iRow && iRow < pCurSection->_iRow + pCurSection->_cRows))
        return;

    if (_aryRows.Size() <= iRow)
    {
        Assert (iRow==0 || !IsTableLayoutCacheCurrent());
        return;
    }

    // 1. delete row from the cache
    DeleteRowElement(iRow);

    // 2. update counter of rows in the current section
    pCurSection->_cRows--;

    // 3. adjust row index for the following rows
    cRows = _aryRows.Size();
    for (i = iRow; i < cRows; i++)
    {
        pRow = _aryRows[i];
        pRow->_iRow = i;          // adjust row index
        pSection = pRow->Section();
        if (pSection != pCurSection && pSection->_cRows)
        {
            // 4. adjust row index for the following sections
            Assert (pSection->_iRow >= iRow);
            pSection->_iRow--;
            pCurSection = pSection;
        }
    }
}

MtDefine( FixedResize, LayoutMetrics, "ResizeElement in ConsiderResizingFixedTable" );

void
CTableLayout::ConsiderResizingFixedTable(CTableRow * pRow)
{
    CheckSz(    !ElementOwner()->GetFirstBranch()->GetFancyFormat()->_bTableLayout 
            ||  IsFixed(), 
            "CTableLayout::ConsiderResizingFixedTable : CFancyFormat::TableLayoutFixed != CTableLayout::TableLayoutFixed");

    // Let fixed-sized tables know if a new row arrived.
    if (!_fCompleted            &&  // if we have not completed the parsing of the table ,
        IsFixedBehaviour()      &&  // and the table-layout is fixed (or has a history)
        !Table()->IsDatabound())    // and we are not a databound table,
    {
        // Issue an incremental recalc/rendering request.
        const int iGoodNumberOfRows4IncRecalc = 10;
        DWORD dwCurrentTime = GetTickCount();

        Assert (pRow);
        CTableSection * pSection = pRow->Section();

        // and we are not parsing header/footer, then
        if (!pSection || pSection == _pFoot)
            return;

        Assert(_cRowsParsed > _cCalcedRows);

        // Fire an incremental resize in an interval of numberofResizes*1 sec (1000 ticks) and not less then for 10 new rows.
        if (_cRowsParsed - _cCalcedRows > iGoodNumberOfRows4IncRecalc &&
           (dwCurrentTime - _dwTimeEndLastRecalc >_dwTimeBetweenRecalc))
        {
#if DBG==1
            _pDocDbg->_fUsingTableIncRecalc = TRUE;
#endif 
            _fIncrementalRecalc = TRUE;
            ElementOwner()->ResizeElement();
            MtAdd(Mt(FixedResize), 1, 0);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     ClearTopTableLayoutCache
//
//  Synopsis:   Clears the table layout cache (TLC).
//              Does NOT Drill down to table row layout cache (TRLC).
//
//----------------------------------------------------------------------------
void
CTableLayout::ClearTopTableLayoutCache()
{
    ClearAllRowElements();         // row elements array
    ClearAllColGroups();           // col groups array
    _aryBodys.DeleteAll();
    ClearAllCaptions();            // captions array

    _pHead = NULL;
    _pFoot = NULL;


    Assert (!_aryRows.Size());
    Assert (!_aryCaptions.Size());
    Assert (!_aryBodys.Size());
    Assert (!_pFoot);
    Assert (!_pHead);

    _cCols = 0;                    // max # of cells in a row
    _aryCols.DeleteAll();          // col array
}

//+---------------------------------------------------------------------------
//
//  Member:     ClearTableLayoutCache - formerly ReleaseRowsAndSections
//
//  Synopsis:   Clears the table layout cache (TLC).  Drills down to table
//              row layout cache (TRLC).
//
//----------------------------------------------------------------------------

void
CTableLayout::ClearTableLayoutCache()
{
    BOOL fEnsuringTLC = _fEnsuringTableLayoutCache;
    _fEnsuringTableLayoutCache = TRUE;

    ReleaseRowsAndSections(TRUE, FALSE);    // fReleaseHeaderFooter = TRUE, fReleaseTCs = FALSE

    ClearAllCaptions();

    Assert (!_aryRows.Size());
    Assert (!_aryCaptions.Size());
    Assert (!_aryBodys.Size());
    Assert (!_pFoot);
    Assert (!_pHead);

    _cCols = 0;                     // max # of cells in a row
    _aryCols.DeleteAll();          // col array
    ClearAllColGroups();           // col groups array

    _fEnsuringTableLayoutCache = fEnsuringTLC;

    ClearRowSpanVector();
    if (_pAbsolutePositionCells)
    {
        int i;

        for (i = _pAbsolutePositionCells->Size()-1; i>=0; i--)
        {
            _pAbsolutePositionCells->Item(i)->SubRelease();
        }

        _pAbsolutePositionCells->SetSize(0);
        delete _pAbsolutePositionCells;
        _pAbsolutePositionCells = NULL;
    }
}


void
CTableLayout::ReleaseRowsAndSections(BOOL fReleaseHeaderFooter, BOOL fReleaseTCs)
{
    CTableSection **    ppSection;
    int                 iSection;
    int                 cR;
    CTableRow     **    ppRow;
    int                 iHeadFootRows = fReleaseHeaderFooter? 0 : GetHeadFootRows();
    int                 idx = 0;
    CTableRow      *    pRow;
    BOOL                fParentOfTCs = FALSE;

    // for every row, clear the row's layout caches
    for (cR = GetRows() - iHeadFootRows, ppRow = fReleaseHeaderFooter? _aryRows : &_aryRows[_aryBodys[0]->_iRow];
        cR > 0;
        cR--, ppRow++)
    {
        pRow = *ppRow;
        fParentOfTCs |= fReleaseTCs && pRow->_fParentOfTC;
        CTableRowLayout *pRowLayout = pRow->RowLayoutCache();
        if (pRowLayout)
        {
            pRowLayout->ClearRowLayoutCache();
            pRow->_iRow = -1;
        }
    }

    for (ppSection = _aryBodys, iSection = _aryBodys.Size();
         iSection > 0;
         iSection--, ppSection++)
    {
        (*ppSection)->_iRow = 0;
        (*ppSection)->_cRows = 0;
    }

    if (!iHeadFootRows)
    {
        ClearAllRowElements();
    }
    else
    {
        for (cR = GetRows() - iHeadFootRows, idx = _aryRows.Size() - 1;
            cR > 0;
            cR--, idx--)
        {
            DeleteRowElement(idx);
        }
    }
    if (fReleaseHeaderFooter)
    {
        _pHead = NULL;
        _pFoot = NULL;
    }

    fParentOfTCs |= fReleaseTCs && _fBodyParentOfTC;

    if (fParentOfTCs)
        ReleaseTCs();
    _aryBodys.DeleteAll();

    return;
}

void
CTableLayout::ReleaseBodysAndTheirRows(int iBodyStart, int iBodyFinish)
{
    CTableRow       *pRow;
    CTableRowLayout *pRowLayout;
    CTableSection   *pSection;
    int             iRow, cRows, iBody, cBodys;
    int             nReleasedRows = 0;
    BOOL            fParentOfTCs = FALSE;

    Assert (iBodyFinish >= iBodyStart && iBodyFinish < _aryBodys.Size() && iBodyStart >= 0);

    iRow = _aryBodys[iBodyStart]->_iRow;

    if (IsRepeating() && iRow < _iLastRowIncremental) 
    {
        _fDirtyBeforeLastRowIncremental = TRUE;
    }

    for (cBodys = iBodyFinish - iBodyStart + 1; cBodys; cBodys--)
    {
        pSection = _aryBodys[iBodyStart];
        for (cRows = pSection->_cRows; cRows; cRows--)
        {
            pRow = _aryRows[iRow];
            pRowLayout = pRow->RowLayoutCache();
            pRowLayout->ClearRowLayoutCache();
            pRow->_iRow = 0;
            fParentOfTCs |= pRow->_fParentOfTC;
            DeleteRowElement(iRow);
            nReleasedRows++;
        }
        pSection->_cRows = 0;
        fParentOfTCs |= pSection->_fParentOfTC;
        _aryBodys.Delete(iBodyStart);
    }

    for (iBody = iBodyStart; iBody < _aryBodys.Size(); iBody++)
    {
        pSection = _aryBodys[iBody];
        pSection->_iRow -= nReleasedRows;
        for (iRow = pSection->_iRow, cRows = pSection->_cRows;
             cRows;
             cRows--, iRow++)
        {
            _aryRows[iRow]->_iRow -= nReleasedRows;
        }
    }

    if (fParentOfTCs)
        ReleaseTCs();
}

void
CTableLayout::ReleaseTCs()
{
    int             ic, cC;
    CTableCaption  *pCaption;
    CTableCaption **ppCaption;
    CTreeNode      *pNode;

    for (cC = _aryCaptions.Size(), ic = 0, ppCaption = _aryCaptions;
         cC > 0;
         cC--, ppCaption++, ic++)
    {
        pCaption = *ppCaption;
        if (pCaption->Tag() == ETAG_TC)
        {
            pNode = pCaption->GetFirstBranch(); // pNode == 0 means it was already removed from the tree
            if (!pNode)
            {
                DeleteCaption(ic);
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     AddCaption
//
//  Synopsis:   Add caption to the table
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::AddCaption(CTableCaption * pCaption)
{
    HRESULT hr;
    CElement *pParent = NULL;

    Assert(pCaption);

    hr = AppendCaption(pCaption);
    if (!hr)
    {
        if (pCaption->Tag() == ETAG_TC)
        {
            pParent = pCaption->GetFirstBranch()->Parent()->Element();

            while ( pParent )
            {
                switch (pParent->Tag())
                {
                case ETAG_TBODY:
                case ETAG_THEAD:
                case ETAG_TFOOT:
                    DYNCAST(CTableSection, pParent)->_fParentOfTC = TRUE;
                    _fBodyParentOfTC = TRUE;
                    goto Cleanup;
                case ETAG_TR:
                    DYNCAST(CTableRow, pParent)->_fParentOfTC = TRUE;
                    goto Cleanup;
                case ETAG_TABLE:
                    goto Cleanup;
                default:
                    pParent = pParent->GetFirstBranch()->Parent()->Element();
                }
            }

            AssertSz( FALSE, "TCs should always at least be in a TABLE -- should never walk up to a root" );
        }
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     AddSection
//
//  Synopsis:   Add a section to the table
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::AddSection(CTableSection * pSection)
{
    int     iRow = 0;
    int     iSections = 0;
    HRESULT hr = S_OK;

    Assert(pSection);

    pSection->_fBodySection = TRUE;

    switch(pSection->Tag())
    {
    case ETAG_THEAD:
        if (!_pHead)
        {
            pSection->_fBodySection = FALSE;
            _pHead = pSection;
            iRow = 0;
#if NEED_A_SOURCE_ORDER_ITERATOR
            _iHeadRowSourceIndex = _aryRows.Size();
#endif
        }
        break;

    case ETAG_TFOOT:
        if (!_pFoot)
        {
            pSection->_fBodySection = FALSE;
            _pFoot = pSection;
            iRow = _pHead
                        ? _pHead->_cRows
                        : 0;
#if NEED_A_SOURCE_ORDER_ITERATOR
            _iFootRowSourceIndex = _aryRows.Size();
#endif
        }
        break;

    case ETAG_TBODY:
        break;

    default:
        Assert(FALSE);
    }

    if (pSection->_fBodySection)
    {
        iSections = _aryBodys.Size();
        if (_pSectionInsertBefore)
        {
            Assert (iSections);
            for (int i = 0; i < _aryBodys.Size(); i++)
            {
                if (_aryBodys[i] == _pSectionInsertBefore)
                {
                    hr = _aryBodys.Insert(i, pSection);
                    iRow = _pSectionInsertBefore->_iRow;
                    break;
                }
            }
        }
        else
        {
            hr = _aryBodys.Append(pSection);
            iRow = GetRows();
        }
        if (hr)
            goto Cleanup;

        iSections++;

        Assert (iSections == _aryBodys.Size());
    }

    pSection->_iRow = iRow;
    pSection->_cRows = 0;   // have to do it, since it is called on old rows as well

    // nuke the row span vector for the new section
    ClearRowSpanVector();

Cleanup:

    RRETURN(hr);
}


void
CTableLayout::BodyExitTree(CTableSection *pSection)
{
    if (pSection == _pHead)
    {
        _pHead = NULL;
    }
    else if (pSection == _pFoot)
    {
        _pFoot = NULL;
    }
    else
    {
        for (int i = 0; i < _aryBodys.Size(); i++)
        {
            if (_aryBodys[i] == pSection)
            {
                _aryBodys.Delete(i);
                break;
            }
        }
    }
    return;
}

#if NEED_A_SOURCE_ORDER_ITERATOR
CTableRow *
CTableLayout::GetRowInSourceOrder(int iS)
{
    int  iRow = iS;
    BOOL fHaveTHead = _pHead && _pHead->_cRows;
    BOOL fHaveTFoot = _pFoot && _pFoot->_cRows;

    // Optimization.
    if (!fHaveTHead && !fHaveTFoot)
        goto Cleanup;

    // Case 1: row is in header
    if (fHaveTHead && iS >= _iHeadRowSourceIndex && iS < _iHeadRowSourceIndex + _pHead->_cRows)
    {
        iRow = iS - _iHeadRowSourceIndex;
        goto Cleanup;
    }

    // Case 2: row is in footer
    if (fHaveTFoot && iS >= _iFootRowSourceIndex && iS < _iFootRowSourceIndex + _pFoot->_cRows)
    {
        iRow = iS - _iFootRowSourceIndex + (fHaveTHead?_pHead->_cRows:0);
        goto Cleanup;
    }

    // Case 3: row is in front of header
    if (fHaveTHead && iS < _iHeadRowSourceIndex)
    {
        iRow += _pHead->_cRows;
    }

    // Case 4: row is in front of footer
    if (fHaveTFoot && iS < _iFootRowSourceIndex)
    {
        iRow += _pFoot->_cRows;
    }

Cleanup:
    return _aryRows[iRow];
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     AddColGroup
//
//  Synopsis:   Add a column group to the table
//
//----------------------------------------------------------------------------
HRESULT
CTableLayout::AddColGroup(CTableCol * pColGroup)
{
    HRESULT hr;
    int cColSpan;
    int iAt;

    Assert(pColGroup->GetFirstBranch()->Ancestor(ETAG_TABLE)->Element() == Table());

    cColSpan = pColGroup->Cols();

    Assert(cColSpan >= 0);

    iAt = _aryColGroups.Size();

    hr = _aryCols.EnsureSize(iAt);
    if (hr)
        goto Cleanup;

    hr = _aryColGroups.EnsureSize(iAt + cColSpan);
    if (hr)
        goto Cleanup;

    pColGroup->_iCol = iAt;
    pColGroup->_cCols = cColSpan;

    while (_aryCols.Size() < iAt)
    {
        _aryCols.Append(NULL);
    }
    EnsureCols(_aryCols.Size());

    while(_aryColGroups.Size() < iAt + cColSpan)
    {
        if (S_OK == _aryColGroups.Append(pColGroup))
            pColGroup->SubAddRef();
    }

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     AddCol
//
//  Synopsis:   Add a column group to the table
//
//----------------------------------------------------------------------------
HRESULT
CTableLayout::AddCol(CTableCol * pCol)
{
    HRESULT hr = S_OK;
    CTableCol * pColGroup;
    int cColSpan;
    int iAt;

    Assert(pCol->GetFirstBranch()->Ancestor(ETAG_TABLE)->Element() == Table());

    Verify(pColGroup = pCol->ColGroup());
    
    if (!pColGroup)
    {
        pCol->_iCol = -1;
        pCol->_cCols = 0;
        goto Cleanup;
    }

    cColSpan = pCol->Cols();

    Assert(cColSpan >= 0);

    iAt = _aryCols.Size();
    Assert(_aryColGroups.Size() >= iAt);
    Assert(_aryColGroups.Size() <= iAt || _aryColGroups[iAt] == pColGroup);

    // HTML 3 Table Model: if COLGROUP contains one or more COLS the span attribute of the COLGROUP is ignored
    if (iAt == pColGroup->_iCol && pColGroup->_cCols == pColGroup->Cols())
    {
        pColGroup->_cCols = 0;  // ignore SPAN for colGroup
    }

    hr = _aryCols.EnsureSize(iAt + cColSpan);
    if (hr)
        goto Cleanup;

    hr = _aryColGroups.EnsureSize(iAt + cColSpan);
    if (hr)
        goto Cleanup;

    pCol->_iCol = iAt;
    pCol->_cCols = cColSpan;
    pColGroup->_cCols += cColSpan;

    while (_aryCols.Size() < iAt + cColSpan)
    {
        _aryCols.Append(pCol);
    }
    EnsureCols(_aryCols.Size());

    // Per ftp://ds.internic.net/rfc/rfc1942.txt:
    // If COLGROUPS contains COLs, ignore SPAN of COLGROUP.
    while (_aryColGroups.Size() > iAt + cColSpan)
    {
        _aryColGroups[_aryColGroups.Size()-1]->SubRelease();
        _aryColGroups.Delete(_aryColGroups.Size()-1);
    }

    while(_aryColGroups.Size() < iAt + cColSpan)
    {
        if (S_OK ==_aryColGroups.Append(pColGroup))
            pColGroup->SubAddRef();
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureCols
//
//  Synopsis:   Take note of no. of cols in a row
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::EnsureCols(int cCols)
{
    if (_cCols < cCols)
        _cCols = cCols;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     EnsureCells
//
//  Synopsis:   Make sure that there are at least cCols cells in the
//              table in every row
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::EnsureCells()
{
    HRESULT hr = S_OK;
    CTableRow ** ppRow;
    CTableRow * pRow;
    int cCols;
    int cR;

    Assert(IsTableLayoutCacheCurrent());

    cCols = GetCols();

    // make sure rows have enough cells...
    for (cR = GetRows(), ppRow = _aryRows;
        cR > 0;
        cR--, ppRow++)
    {
        pRow = *ppRow;

        if (pRow->RowLayoutCache()->GetCells() < cCols)
        {
            hr = pRow->RowLayoutCache()->EnsureCells(cCols);
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     CheckTable
//
//  Synopsis:   Checks table state
//
//-----------------------------------------------------------------------------
#if DBG == 1
void CTableLayout::CheckTable()
{
    CTableRow * pRow;
    CTableRowLayout * pRowLayout;
    CTableSection * pSection;
    CTableCell * pCell;
    int i, j;
    int c;

    Assert(IsTableLayoutCacheCurrent());

    for (i = 0; i < _aryRows.Size(); i++)
    {
        pRow = _aryRows[i];
        pRowLayout = pRow->RowLayoutCache();

        Assert(pRowLayout->RowPosition() == i);
        pSection = pRow->Section();
        Assert(pSection->_cGeneratedRows ||
               (i >= pSection->_iRow && i < pSection->_iRow + pSection->_cRows));
        for (j = 0; j < pRowLayout->_aryCells.Size(); j++)
        {
            pCell = pRowLayout->_aryCells[j];
            if (!IsEmpty(pCell))
            {
                if (IsReal(pCell))
                {
                    pCell = Cell(pCell);
                    Assert(pCell->RowIndex() == i);
                    Assert(pCell->ColIndex() == j);
                    Assert(pCell->Row() == pRow);
                }
                else
                {
                    pCell = Cell(pCell);
                    Assert(i < pCell->RowIndex() + pCell->RowSpan());
                    Assert(j < pCell->ColIndex() + pCell->ColSpan());
                    Assert(pCell->Row()->_iRow < pCell->RowIndex() + pCell->RowSpan());
                    Assert(pCell->Layout()->Col()->_iCol < pCell->ColIndex() + pCell->ColSpan());
                }
            }
        }
    }
    c = 0;
    if (_pHead)
    {
        Assert(_pHead->_iRow == c);
        c += _pHead->_cRows;
    }
    if (_pFoot && (!_aryBodys.Size() || _pFoot->_iRow <= _aryBodys[0]->_iRow))
    {
        Assert(_pFoot->_iRow == c);
        c += _pFoot->_cRows;
    }
    for (i = 0; i < _aryBodys.Size(); i++)
    {
        pSection = _aryBodys[i];
#ifndef NO_DATABINDING
        if (!IsRepeating())
#endif
        {
            // the following assert checks if the section starts with the
            // correct _iRow or it could of being an empty TBODY section that
            // appeared before the THEAD section.
            Assert(pSection->_iRow == c || !pSection->_cRows);
            c += pSection->_cRows;
        }
#ifndef NO_DATABINDING
        else
        {
            c+= pSection->_cGeneratedRows;
        }
#endif
    }
    if (_pFoot && (_aryBodys.Size() && _pFoot->_iRow > _aryBodys[0]->_iRow))
    {
        Assert(_pFoot->_iRow == c);
        c += _pFoot->_cRows;
    }
    Assert(c == _aryRows.Size());  // for now until Caption added
}


static TCHAR g_achTabs[] = _T("\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t");
#define PRINTLN(f) WriteHelp(pF, _T("<0s>")_T(##f)_T("\n"), &g_achTabs[ARRAY_SIZE(g_achTabs) - iTabs]


void
CTableCellLayout::Print(HANDLE pF, int iTabs)
{
    TCHAR           achBuf[30];
    const TCHAR *   psz;
    CUnitValue      uvWidth = GetFirstBranch()->GetCascadedwidth();
    CUnitValue      uvHeight = GetFirstBranch()->GetCascadedheight();

    PRINTLN("\n*** CELL ***\n") );
    psz = TableCell()->GetAAid();
    if (psz)
        PRINTLN("ID: <1s>"), psz);
    psz = TableCell()->GetAAname();
    if (psz)
        PRINTLN("NAME: <1s>"), psz);
    PRINTLN("_iRow: <1d>"), TableCell()->RowIndex());
    PRINTLN("_iCol: <1d>"), ColIndex());
    PRINTLN("_ptProposed: <1d> <2d>"), GetXProposed(), GetYProposed());
    PRINTLN("_xMin: <1d>"), _sizeMin.cu);
    PRINTLN("_xMax: <1d>"), _sizeMax.cu);
    PRINTLN("_sizeCell: <1d> <2d>"), _sizeCell.cx, _sizeCell.cy);
    uvWidth.FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTableCellwidth.a);
    PRINTLN("WIDTH = <1s>"), achBuf);
    uvHeight.FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTableCellheight.a);
    PRINTLN("HEIGHT = <1s>"), achBuf);
}


void
CTableRowLayout::Print(HANDLE pF, int iTabs)
{
    CTableCell **   ppCell;
    const TCHAR *   psz;
    int             cC;

    PRINTLN("\n*** ROW ***\n") );
    psz = TableRow()->GetAAid();
    if (psz)
        PRINTLN("ID: <1s>"), psz);
    psz = TableRow()->GetAAname();
    if (psz)
        PRINTLN("NAME: <1s>"), psz);
    PRINTLN("_iRow: <1d>"), RowPosition());
    PRINTLN("_ptProposed: <1d> <2d>"), GetXProposed(), GetYProposed());

    for (cC = _aryCells.Size(), ppCell = _aryCells; cC > 0; cC--, ppCell++)
    {
        if (IsReal(*ppCell))
            Cell(*ppCell)->Layout()->Print(pF, iTabs+1);
    }
}


void
CTableLayout::Print(HANDLE pF, int iTabs)
{
    TCHAR           achBuf[30];
    const TCHAR *   psz;
    CUnitValue      uvWidth = GetFirstBranch()->GetCascadedwidth();
    CUnitValue      uvHeight = GetFirstBranch()->GetCascadedheight();

    Assert(IsTableLayoutCacheCurrent());

    PRINTLN("\n*** TABLE ***\n"));
    psz = Table()->GetAAid();
    if (psz)
        PRINTLN("ID: <1s>"), psz);
    psz = Table()->GetAAname();
    if (psz)
        PRINTLN("NAME: <1s>"), psz);
    PRINTLN("_ptProposed: <1d> <2d>"), GetXProposed(), GetYProposed());
    PRINTLN("_sizeMin: <1d> <2d>"), _sizeMin.cx, _sizeMin.cy);
    PRINTLN("_sizeMax: <1d> <2d>"), _sizeMax.cx, _sizeMax.cy);
    PRINTLN("_sizeParent: <1d> <2d>"), _sizeParent.cx, _sizeParent.cy);

    uvWidth.FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTablewidth.a);
    PRINTLN("WIDTH = <1s>"), achBuf);
    uvHeight.FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTableheight.a);
    PRINTLN("HEIGHT = <1s>"), achBuf);

    CTableCol ** ppCol;
    int cC;

    for (cC = _aryCols.Size(), ppCol = _aryCols; cC > 0; cC--, ppCol++)
    {
        (*ppCol)->Print(pF, iTabs+1);
    }

    CTableRow ** ppRow;
    int cR;

    for (cR = _aryRows.Size(), ppRow = _aryRows; cR > 0; cR--, ppRow++)
    {
        (*ppRow)->RowLayoutCache()->Print(pF, iTabs+1);
    }
}

void
CTableLayout::DumpTable(const TCHAR * pch)
{
    HANDLE pF = CreateFile(
            _T("c:\\tt."),
            GENERIC_WRITE | GENERIC_READ,
            FILE_SHARE_WRITE | FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (pF == INVALID_HANDLE_VALUE)
        return;

    SetFilePointer( pF, GetFileSize( pF, 0 ), 0, 0 );

    WriteHelp(pF, _T("\nDumpTable: <0s> -------------------------------------------------------------------")_T("\n"), pch);

    Print(pF, 0);

    CloseHandle(pF);
}

//+---------------------------------------------------------------------------
//
//  Member:     HandleMessage
//
//  Synopsis:   Handle messages bubbling when the passed site is non null
//
//  Arguments:  [pMessage]  -- message
//              [pChild]    -- pointer to child when bubbling allowed
//
//  Returns:    Returns S_OK if keystroke processed, S_FALSE if not.
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CTableLayout::HandleMessage(CMessage * pMessage)
{
    switch(pMessage->message)
    {
    case WM_SYSKEYDOWN:
        if (pMessage->wParam == VK_F12 && !(pMessage->lParam & SYS_PREVKEYSTATE))
        {
            DumpTable(_T("F12"));
            return S_OK;
        }
    }
    return super::HandleMessage(pMessage);
}
#endif // DBG == 1


//+----------------------------------------------------------
//
// Member : GetChildElementTopLeft
//
//  Synopsis : csite virtual override, this returns the top and the left of non-site
//      elements that have the Table as their site parent.
//
//-------------------------------------------------------------------------

HRESULT
CTableLayout::GetChildElementTopLeft(POINT & pt, CElement * pChild)
{
    HRESULT hr = S_OK;

    Assert(pChild && !pChild->GetUpdatedLayout());

    hr = EnsureTableLayoutCache();
    if (hr)
        RRETURN(hr);

    pt = g_Zero.pt;

    // if we get here, it means that someone wants the
    // top leff of an element of whose parent site is
    // the table, this means THead, TBody,TSection
    switch (pChild->Tag())
    {
    case ETAG_THEAD :
        if (_pHead && _pHead->_cRows && (_pHead->_iRow < _aryRows.Size() ) && _pHead==pChild)
        {
            // the row is a site, so get its unparked position
            hr = THR(_aryRows[ _pHead->_iRow ] ->GetElementTopLeft(pt));
        }
        break;
    case ETAG_TFOOT :
        if (_pFoot && _pFoot->_cRows && (_pFoot->_iRow < _aryRows.Size() ) && _pFoot == pChild)
        {
            // the row is a site, so get its unparked position
            hr = THR(_aryRows[ _pFoot->_iRow ] ->GetElementTopLeft(pt));
        }
        break;

    case ETAG_TBODY :
        {
            CTableSection * pSection;
            long i;

            for (i = 0; i < _aryBodys.Size(); i++)
            {
                pSection = _aryBodys[i];
#ifndef NO_DATABINDING
                if (!IsRepeating())
#endif
                {
                    if (pSection  == pChild && pSection->_cRows)
                    {
                        hr = THR(_aryRows[ pSection->_iRow ] ->GetElementTopLeft(pt));
                        break;
                    }
                }
            }
            break;
        }
    }

    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Member :    FlushGrid
//
//  Synopsis :  This function should be called when the new
//              row/cell is inserted/deleted or when changing
//              rowSpan/colSpan attributes of the cells.
//
//-------------------------------------------------------------------------

void
CTableLayout::FlushGrid()
{
    BOOL fEnsuringTableLayoutCache = _fEnsuringTableLayoutCache;
    _fEnsuringTableLayoutCache = TRUE;
    _fZeroWidth = FALSE;            // set to 1 if table is empty (0 width).
    _fHavePercentageRow = FALSE;    // one or more rows have heights which are a percent
    _fHavePercentageCol = FALSE;    // one or more cols have widths which are a percent
    _fHavePercentageInset = FALSE;
    _fForceMinMaxOnResize = FALSE;
    _fCols = FALSE;                 // column widths are fixed
    _fAlwaysMinMaxCells = FALSE;    // calculate min/max for all cells
    _fAllRowsSameShape = TRUE;      // assume all the rows have the same shape

    _cSizedCols = 0;                // Number of sized columns

    ResetMinMax();

    // We should clear the TLC, so that we don't burn our fingers on dead cells or rows later.
    ClearTableLayoutCache();

    _aryColCalcs.DeleteAll();       // calculated columns array
    _cDirtyRows = 0;                // how many resize req's I've ignored
    _nDirtyRows = 0;                // how many resize req's to ignore

    _iLastNonVirtualCol = 0;        // last non virtual column in the table
    _cNonVirtualCols = 0;           // number of non virtual columns

    _fUsingHistory = FALSE;
    _fDontSaveHistory = TRUE;

    _fEnsuringTableLayoutCache = fEnsuringTableLayoutCache;
    
    _iLastRowIncremental = 0;       // reset incremental recalc state
    _fDatabindingRecentlyFinished = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member :    Fixup
//
//  Synopsis :  After insert/delete operation we need to fixup table
//
//-------------------------------------------------------------------------

HRESULT
CTableLayout::Fixup(BOOL fIncrementalUpdatePossible)
{
    HRESULT     hr      = S_OK;
    CTable *    pTable  = Table();

    // Assert( GetMarkup()->Doc()->IsLoading() );

    if (fIncrementalUpdatePossible)
    {
        ResetMinMax();
        _iCollectionVersion++;                  // this will invalidate table's collections
        MarkTableLayoutCacheCurrent();
    }
    else
    {
        // Make sure we dirty the TLC.
        MarkTableLayoutCacheDirty();

        // Several of the TOM functions (e.g. createTHead) try to use the table
        // layout cache (TLC) immediately after TOM operations, so ensure the TLC.
        hr = EnsureTableLayoutCache();

    }
    pTable->ResizeElement();

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetFirstCaption
//
//  Synopsis:   helper function to get the first caption
//
//----------------------------------------------------------------------------

CTableCaption *
CTableLayout::GetFirstCaption()
{
    CTableCaption * pCaption = NULL;
    CTableCaption **ppCaption;
    int             cC;

    Assert(AssertTableLayoutCacheCurrent());

    for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
         cC > 0;
         cC--, ppCaption++)
    {
        if ((*ppCaption)->Tag() == ETAG_CAPTION)
        {
            pCaption = *ppCaption;
            break;
        }
    }

    return pCaption;
}


// Have to include whether the table has percent sized rows in it, in order
// to determine if it is percent sized.
BOOL CTableLayout::PercentSize()
{
    return (_fHavePercentageRow || super::PercentSize());
}
BOOL CTableLayout::PercentHeight()
{
    return (_fHavePercentageRow || super::PercentHeight());
}


#ifdef NEVER_USED_CODE

//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::GetCellFromRowCol
//
//  Synopsis:   Returns the cell located at table grid position (iRow,iCol)
//
//  Arguments:  iRow [in]         -- visual row index
//              iCol [in]         -- visual col index
//              ppTableCell [out] -- table cell at (iRow,iCol)
//
//  Returns:    Returns S_OK with pointer to table cell.  The pointer will
//              be NULL when the cell at the specified position doesn't exist
//              or is a non-real cell part of another cell's row- or columnspan.
//
//  Note:       When the CTableSection version is called, the rows and column
//              indices are relative to the section origin (section-top, section-left).
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::GetCellFromRowCol(int iRow, int iCol, CTableCell **ppTableCell)
{
    CTableRow * pTableRow;
    CTableCell *pTableCell;
    HRESULT     hr = S_OK;

    if (!ppTableCell)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppTableCell = NULL;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (iRow < 0 || iRow >= GetRows() || iCol < 0 || iCol >= GetCols())
        goto Cleanup;

    // Obtain row from iRow.
    iRow = VisualRow2Index(iRow);
    pTableRow = _aryRows[iRow];
    Assert(pTableRow && !"NULL row in legal range");

    // Obtain col from iCol.
    pTableCell = pTableRow->RowLayoutCache()->_aryCells[iCol];

    if (IsReal(pTableCell))
        *ppTableCell = pTableCell;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::GetCellsFromRowColRange
//
//  Synopsis:   Returns an array of the cells located in the inclusive range
//              spanned by (iRowTop,iColLeft)-(iRowBottom,iColRight)
//
//  Arguments:  iRowTop    [in]     -- visual top row index
//              iColLeft   [in]     -- visual left col index
//              iRowBottom [in]     -- visual row index
//              iColRight  [in]     -- visual col index
//              paryCells  [in,out] -- array of table cells in range (allocated
//                                     by caller)
//
//  Returns:    Returns S_OK with array of table cells.
//
//  Note:       When the CTableSection version is called, the rows and column
//              indices are relative to the section origin (section-top, section-left).
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::GetCellsFromRowColRange(int iRowTop, int iColLeft, int iRowBottom, int iColRight, CPtrAry<CTableCell *> *paryCells)
{
    CTableRow *    pTableRow;
    CTableCell *   pTableCell;
    int            cRows, iRow, iCol;
    HRESULT        hr;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    iRowTop = max(0, iRowTop);
    iRowBottom = min(GetRows()-1, iRowBottom);
    iColLeft = max(0, iColLeft);
    iColRight = min(GetCols()-1, iColRight);
    cRows = iRowBottom - iRowTop + 1;

    if (!paryCells || cRows <= 0 || iColLeft > iColRight)
    {
        hr = paryCells ? S_OK : E_POINTER;
        goto Cleanup;
    }

    // Loop from top row to bottom row.
    for (iRow = VisualRow2Index(iRowTop) ; cRows ; cRows--, iRow = GetNextRow(iRow))
    {
        pTableRow = _aryRows[iRow];
        Assert(pTableRow && "NULL row in legal range");

        // Loop from left col to right col.
        for (iCol = iColLeft ; iCol <= iColRight ; iCol++)
        {
            pTableCell = pTableRow->RowLayoutCache()->_aryCells[iCol];
            if (IsReal(pTableCell))
            {
                // Add cell to array.
                paryCells->Append(pTableCell);
            }
        }
    }

Cleanup:
    RRETURN(hr);
}
#endif 

//+----------------------------------------------------------------------------
//
//  Member:     DoLayout
//
//  Synopsis:   Initiate a re-layout of the table
//
//  Arguments:  grfFlags - LAYOUT_xxxx flags
//
//-----------------------------------------------------------------------------
void
CTableLayoutBlock::DoLayout(
    DWORD   grfLayout)
{
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    TraceTagEx( (   tagCalcSize, 
                    TAG_NONAME|TAG_INDENT, 
                    "(CTableLayoutBlock::DoLayout L(0x%x, %S) grfLayout(0x%x)", 
                    this, 
                    ElementOwner()->TagName(), 
                    grfLayout ) );

    CTable *pTable = Table();
    CTableLayout *pTableLayoutCache = pTable->TableLayoutCache();

    Assert(pTableLayoutCache);

    // hidden layouts are measured when they are unhidden
    if (pTableLayoutCache->CanRecalc() && !IsDisplayNone())
    {
        CTableCalcInfo  tci(pTable, this);
        CSize           size;

        tci._grfLayout |= grfLayout;

        //  Init available height for PPV 
        if (    tci.GetLayoutContext()
            &&  tci.GetLayoutContext()->ViewChain() 
            &&  ElementCanBeBroken()  )
        {
            CLayoutBreak *pLayoutBreak;
            tci.GetLayoutContext()->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreak);
            Assert(pLayoutBreak);

            if (pLayoutBreak)
            {
                tci._cyAvail = pLayoutBreak->AvailHeight();
            }
        }

        //
        //  If requested, measure
        //

        if (grfLayout & LAYOUT_MEASURE)
        {
            if (_fForceLayout)
            {
                tci._grfLayout |= LAYOUT_FORCE;
            }

            tci.SizeToParent(&_sizeParent);
            if (!tci._pTableLayout)
                tci._pTableLayout = this;

            CalculateLayout(&tci, &size, FALSE, FALSE);

            pTableLayoutCache->Reset(FALSE);
        }
        _fForceLayout = FALSE;

        //
        //  Process outstanding layout requests (e.g., sizing positioned elements, adding adorners)
        //

        if (HasRequestQueue())
        {
            ProcessRequests(&tci, size);
        }

        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
    }
    else
    {
        pTableLayoutCache->Reset(TRUE);
    }

    TraceTagEx( (   tagCalcSize, 
                    TAG_NONAME|TAG_OUTDENT, 
                    ")CTableLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", 
                    this, 
                    ElementOwner()->TagName(), 
                    grfLayout ));
}

void
CTableLayout::Resize()
{
    CElement *    pElement = ElementOwner();
    CMarkup *     pMarkup = pElement->GetMarkup();

    Assert (pElement);
    if (!pMarkup->_fTemplate)   // don't resize tables that are in the template markup (generated tables for data-binding).
    {
        if (! (IsRepeating() && !_fDatabindingRecentlyFinished && IsGenerationInProgress()) )
        {
            ResetMinMax();
        }       
        // else optimize databinding recalcing of the table during CTableLayout::CalculateLayout
        // ... but first reset incremental recalc members (bug # 105017)
        ResetIncrementalRecalc();
        pElement->ResizeElement();
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::OnFormatsChange
//
//  Synopsis:   Handle formats change notification
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::OnFormatsChange(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    // clear's formats on cols and colspans
    VoidCachedFormats();

    // (bug # 104204) If formats are changed table must do min max pass again
    ResetMinMax();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     EnsureRowSpanVector
//
//  Synopsis:   Make sure there are at least cCells number of slots in the row span vector
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::EnsureRowSpanVector(int cCells)
{
    HRESULT hr = S_OK;
    int     c = 0;

    if (!_paryCurrentRowSpans)
    {
        _paryCurrentRowSpans = new(Mt(CTableLayout_paryCurrentRowSpans)) CDataAry<int>(Mt(CTableLayout_paryCurrentRowSpans_pv));
        if (!_paryCurrentRowSpans)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    c = _paryCurrentRowSpans->Size();
    if (c >= cCells)
        goto Cleanup;

    hr = _paryCurrentRowSpans->EnsureSize(cCells);
    if (hr)
        goto Cleanup;

    Assert(c <= cCells);

    _paryCurrentRowSpans->SetSize(cCells);

    while (cCells-- > c)
    {
        (*_paryCurrentRowSpans)[cCells] = 0;    // set the previous cells as not rows spanned (row span == 1)
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     ClearRowSpanVector
//
//  Synopsis:   Delete the row span vector (if any)
//
//----------------------------------------------------------------------------

void
CTableLayout::ClearRowSpanVector()
{
    _cCurrentRowSpans = 0;
    delete _paryCurrentRowSpans;
    _paryCurrentRowSpans = NULL;
}


VOID
CTableLayout::ShowSelected( CTreePos* ptpStart, CTreePos* ptpEnd, BOOL fSelected, BOOL fLayoutCompletelyEnclosed )
{
    CDispNode * pDispNode = GetElementDispNode(ElementOwner());

    // if the table is filtered, we need to invalidate so that the filter
    // will redraw its input with the correct selection feedback (bug 107750)
    if (pDispNode && pDispNode->IsDrawnExternally())
    {
        pDispNode->Invalidate();
    }
}

// just to indicate that user width is specified
// to indicate that it is a 0-width
#define HISTORY_WIDTH_SPECIFIED (101)   
#define HISTORY_ZERO_PERCENT    (102)   
#define HISTORY_SPECIAL_LAST_VALUE (102)
//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::SaveHistoryValue()
//
//  Synopsis:   save history:
//                              - value
//                              - _fTextChanged
//                              - scroll position
//
//-------------------------------------------------------------------------

HRESULT
CTableLayout::SaveHistoryValue(CHistorySaveCtx *phsc)
{
    CDataStream ds;
    HRESULT     hr      = S_OK;
    IStream *   pStream = NULL;
    CStr        cstrVal;
    CTable *    pTable = Table();
    int         iP;
    int         cC, cCols, cColsSave;
    CTableColCalc *pColCalc;

    Assert(phsc);
    if (!phsc)
        goto Cleanup;

    hr = THR(phsc->BeginSaveStream(pTable->GetSourceIndex(), 
                                   pTable->HistoryCode(), 
                                   &pStream));
    if (hr)
        goto Cleanup;

    ds.Init(pStream);

    // save number of columns
    cColsSave = cCols = _aryColCalcs.Size();
    if (_fCols)
    {
        Assert (cCols >= 0);
        cColsSave = 0 - cCols;
    }
    hr = THR(ds.SaveDword(cColsSave));
    if (hr)
        goto Cleanup;

    hr = THR(ds.SaveDword(_cNonVirtualCols));
    if (hr)
        goto Cleanup;

    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, pColCalc++)
    {
        hr = THR(ds.SaveDword(pColCalc->_xMin));
        if (hr)
            goto Cleanup;
        hr = THR(ds.SaveDword(pColCalc->_xMax));
        if (hr)
            goto Cleanup;
        if (pColCalc->_fVirtualSpan)
        {
            pColCalc->_xWidth = - pColCalc->_xWidth;
        }
        hr = THR(ds.SaveDword(pColCalc->_xWidth));
        if (hr)
            goto Cleanup;
        iP = 0;
        if (pColCalc->IsWidthSpecified())
        {
            if (pColCalc->IsWidthSpecifiedInPercent())
            {
                iP = pColCalc->GetPercentWidth();
                Assert (iP <= 100);
                if (iP == 0)
                    iP = HISTORY_ZERO_PERCENT;   // we need to trnaslate this value back as 0%
            }
            else
            {
                iP = HISTORY_WIDTH_SPECIFIED;   // just to indicate that user width is specified
            }
        }
        hr = THR(ds.SaveDword(iP));
        if (hr)
            goto Cleanup;
    }


    hr = THR(phsc->EndSaveStream());
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStream);
    RRETURN(hr);
}


HRESULT
CTableLayout::LoadHistory(IStream *   pStreamHistory, CCalcInfo * pci)
{
    HRESULT hr = S_OK;
    CStr    cstrVal;
    int     cC, cCols;
    int     iP;
    CTableColCalc *pColCalc;

    Assert (pStreamHistory);

    CDataStream ds(pStreamHistory);

    THREADSTATE * pts = GetThreadState();
    CMarkup *pMarkup = ElementOwner()->GetMarkup();

    if (   !pMarkup
        || !pMarkup->_fSafeToUseCalcSizeHistory
        || (pMarkup->GetFontHistoryIndex() != pts->_iFontHistoryVersion))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(ds.LoadDword((DWORD *)&cCols));
    if (hr)
        goto Cleanup;

    _fCols = FALSE;
    if (cCols < 0)
    {   // _fCols flag was saved
        cCols = 0 - cCols;
        _fCols = TRUE;
    }

    if (cCols != GetCols())
    {
        // NOTE (carled): we can't have this assert anymore.  The reason is 
        // simply that we do not yet have a unique-numeric ID for each element
        // (hopefully we'll get this for IE5.X).  This affects history since
        // DHTML pages can cause the historyindex (currently the srcIndex) of a 
        // table to be different at save time than it is at load time, and thus
        // we can potentially get the wrong history stream loaded for this element.
        // this is a generic history bug, but this is the only history assert and 
        // it has been hit on some DHTML pages.  Once we have a unique ID, then we
        // can use that for the historyIdx, and this assert can be re-enabled.
//        Assert (FALSE && "this is a serious history bug");
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(ds.LoadDword((DWORD *)&_cNonVirtualCols));
    if (hr)
        goto Cleanup;

    // reset column values
    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, pColCalc++)
    {
        // pColCalc->Clear();   // Don't clear it (since we have already Cleared it in CalculateMinMax,
                                // and also have set _fDisplayNone flag on it).
        hr = THR(ds.LoadDword((DWORD *)&pColCalc->_xMin));
        if (hr)
            goto Cleanup;
        hr = THR(ds.LoadDword((DWORD *)&pColCalc->_xMax));
        if (hr)
            goto Cleanup;
        hr = THR(ds.LoadDword((DWORD *)&pColCalc->_xWidth));
        if (hr)
            goto Cleanup;
        if (pColCalc->_xWidth < 0)
        {
            pColCalc->_fVirtualSpan = TRUE;
            pColCalc->_xWidth = - pColCalc->_xWidth;
        }
        hr = THR(ds.LoadDword((DWORD *)&iP));
        if (hr)
            goto Cleanup;
        Assert (iP >=0 && iP <= HISTORY_SPECIAL_LAST_VALUE);
        if (iP)
        {
            switch (iP)
            {
                case HISTORY_WIDTH_SPECIFIED:
                    pColCalc->SetPixelWidth(pci, pColCalc->_xWidth);    // user width is specified
                    break;
                case HISTORY_ZERO_PERCENT:
                    iP = 0;                         // fall through
                default:
                    pColCalc->SetPercentWidth(iP);  // percent width specified
                    break;
            }
        }
    }

Cleanup:
    _fUsingHistory = (hr == S_OK);
    RRETURN(hr);
}


int
CTableLayout::GetNextRowSafe(int iRow)
{
    // iRow can be in range [-1, GetRows()-1]
    Assert(AssertTableLayoutCacheCurrent() && iRow >= -1 && iRow < GetRows());

    // If iRow is -1, return first row.
    if (iRow < 0)
        return GetFirstRow();

    // If iRow is last row, return row index outside range.
    if (iRow == GetLastRow())
        return GetRows();

    return GetNextRow(iRow);
}

int
CTableLayout::GetPreviousRowSafe(int iRow)
{
    // iRow can be in range [0, GetRows() (!! not GetRows()-1) ]
    Assert(AssertTableLayoutCacheCurrent() && iRow >= 0 && iRow <= GetRows());

    // If iRow is outside row range, return index last row.
    if (iRow >= GetRows())
        return GetLastRow();

    return GetPreviousRow(iRow);
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayout::EnsureTableLayoutCache
//
// Synopsis:     Support for lazy table layout cache (TLC) maintenance.
//               The document tree version serves as the baseline.
//
//+---------------------------------------------------------------------

HRESULT
CTableLayout::EnsureTableLayoutCache()
{
    HRESULT hr;

    if (IsTableLayoutCacheCurrent())
        return S_OK;

    if (!GetFirstBranch())
    {
        Assert(!"Must have a first branch, i.e. table must be in the tree in order to retrieve the table layout cache");
        RRETURN(E_FAIL);
    }

    hr = THR(CreateTableLayoutCache());

    // FUTURE: In the future, we need to be able to deal with inconsistent tree scenarios and
    // we have to deal with situations in which the table layout cache cannot be retrieved.
    // This will have to be tunnelled up to CalcSize and Draw.
    Assert(hr == S_OK && "EnsureTableLayoutCache failed");
    if (!hr)
    {
        MarkTableLayoutCacheCurrent();
    }

    RRETURN(hr);
}


HRESULT
CTableLayout::AddAbsolutePositionCell(CTableCell *pCell)
{
    HRESULT hr;
    if (!_pAbsolutePositionCells)
    {
        _pAbsolutePositionCells = new  (Mt(CTableLayout_pAbsolutePositionCells_pv)) CPtrAry<CTableCell *> (Mt(CTableLayout_pAbsolutePositionCells_pv));
        if (!_pAbsolutePositionCells)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    hr = _pAbsolutePositionCells->Append(pCell);
    if (hr==S_OK)
        pCell->SubAddRef();

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     GetElementDispNode
//
//  Synopsis:   Return the display node for the pElement
//
//  Arguments:  pElement   - CElement whose display node is to obtained
//
//  Returns:    Pointer to the element CDispNode if one exists, NULL otherwise
//
//-----------------------------------------------------------------------------
CDispNode *
CTableLayout::GetElementDispNode(CElement *  pElement) const
{
    return (    !pElement
            ||  pElement == ElementOwner()
                    ? super::GetElementDispNode(pElement)
//                    : pElement->Tag() == ETAG_THEAD || pElement->Tag() == ETAG_TFOOT
//                        ? GetTableOuterDispNode()
                        : NULL);
}


void CTableLayout::EnsureColsFormatCacheChange()
{
    if (_aryCols.Size() == 0)
        return; 

    CTableRow ** ppRow;
    int          cR;

    for (ppRow = _aryRows, cR = GetRows(); 
        cR > 0; 
        cR--, ppRow++)
    {
        CTableRowLayout *   pRowLayoutCache;
        CTableCell **       ppCell;
        int                 cC;

        pRowLayoutCache = (*ppRow)->RowLayoutCache();
        Assert(pRowLayoutCache);
    
        if (pRowLayoutCache->_aryCells.Size())
        {
            Assert(_aryCols.Size() <= pRowLayoutCache->_aryCells.Size());
            cC = min(_aryCols.Size(), pRowLayoutCache->_aryCells.Size());

            for (ppCell = pRowLayoutCache->_aryCells; 
                cC > 0; 
                cC--, ppCell++)
            {
                CTableCell *pCell = Cell(*ppCell);
                if (pCell)
                {
                    pCell->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
                }
            }
        }
    }
}

#if DBG==1

void CTableLayout::TraceTLCDirty(BOOL fDirty)
{
    if (!fDirty != !_fTLCDirty)
    {
        TraceTag((tagTLCDirty, "TLC for table %ld marked %s",
            Table()->_nSerialNumber, fDirty ? "dirty" : "clean"));
        TraceCallers(tagTLCDirty, 1, 10);
    }
}

#endif

//+---------------------------------------------------------------------
//
// CTableLayoutBreak implementation
//
//+---------------------------------------------------------------------
//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBreak::~CTableLayoutBreak 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
CTableLayoutBreak::~CTableLayoutBreak()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\table\ltablekb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltablekb.cxx
//
//  Contents:   CTableLayout keyboard methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif


MtDefine(CTableRowLayoutPageBreak_aCellChoices_pv, Locals, "CTableRowLayout::PageBreak aCellChoices::_pv")

ExternTag(tagPaginate);

//+-------------------------------------------------------------------------
//
//  Method:     GetCellFromPos
//
//  Synopsis:   Retrun the Cell in the table that is closest to the position.
//
//  Arguments:  [ptPosition] - coordinates of the position
//
//  Returns:    table cell, or NULL if the table is empty or the point is
//              outside of the table
//
//--------------------------------------------------------------------------

CTableCell *
CTableLayout::GetCellFromPos(POINT * pptPosition)
{
    CTableCell  *       pCell = NULL;
    CTableCaption   *   pCaption;
    CTableCaption   **  ppCaption;
    int                 yTop, yBottom;
    int                 xLeft, xRight;
    BOOL                fCaptions;
    BOOL                fBelowRows = FALSE;
    CDispNode         * pDispNode;
    int                 cC;
    int                 x, y;
    CTableRowLayout   * pRowLayout = NULL;
    CPoint              pt;
    
    pDispNode = GetTableInnerDispNode();
    if (!pDispNode)
        return NULL;

    pDispNode->TransformPoint((CPoint&) *pptPosition, COORDSYS_GLOBAL, &pt, COORDSYS_BOX);
    if (pt.y >= 0)
    {
        yTop    =
        yBottom = 0;
        pRowLayout = GetRowLayoutFromPos(pt.y, &yTop, &yBottom, &fBelowRows);
    }
    else
    {
        // may be in the top captions
        pDispNode = GetTableOuterDispNode();
        pDispNode->TransformPoint((CPoint&) *pptPosition, COORDSYS_GLOBAL, &pt, COORDSYS_BOX);
    }
    
    y = pt.y;
    x = pt.x;

    if (pRowLayout)
    {
        int iCol = GetColExtentFromPos(x, &xLeft, &xRight);
        if (iCol >= 0)
        {
            pCell = Cell(pRowLayout->_aryCells[iCol]);
        }
    }
    else
    {
        fCaptions = _aryCaptions.Size();
        if (fCaptions)
        {
            // note: the BOTTOM/TOP captions are mixed in the array of captions
            // but the captions are sorted Y position wise
            for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
                 cC > 0;
                 cC--, ppCaption++)
            {
                pCaption = (*ppCaption);
                if ((fBelowRows && pCaption->_uLocation == CTableCaption::CAPTION_BOTTOM) ||
                    (!fBelowRows && pCaption->_uLocation == CTableCaption::CAPTION_TOP))
                {
                    pCell = pCaption;
                    pDispNode = pCaption->Layout()->GetElementDispNode();
                    if (pDispNode)
                    { 
                        RECT rcBound;
                        pDispNode->GetBounds(&rcBound);
                        if (y < rcBound.bottom)
                        {
                            break;  // we found the caption
                        }
                    }
                }
            }
        }

    }
    return pCell;
}


//+----------------------------------------------------------------------------
//
//  Member:     CTableLayout::RegionFromElement
//
//  Synopsis:   Return the bounding rectangle for a table element, if the element is
//              this instance's owner. The RECT returned is in client coordinates.
//
//  Arguments:  pElement - pointer to the element
//              CDataAry<RECT> *  - rectangle array to contain
//              dwflags - flags define the type of changes required
//              (CLEARFORMATS) etc.
//
//-----------------------------------------------------------------------------
void
CTableLayoutBlock::RegionFromElement(CElement      * pElement,
                                    CDataAry<RECT> * paryRects,
                                    RECT           * prcBound,
                                    DWORD            dwFlags)
{
    CLayoutContext *pLayoutContext    = LayoutContext();
    CTableLayout   *pTableLayoutCache = Table()->TableLayoutCache();
    CRect           rcBound;

    Assert( pElement && paryRects);

    if (!pElement || !paryRects)
        return;

    // Clear the array before filling it.
    paryRects->SetSize(0);

    if(!prcBound)
    {
        prcBound = &rcBound;
    }

    *prcBound = g_Zero.rc;

    // If the element passed is the element that owns this instance, let CLayout handle it.
    if (_pElementOwner == pElement)
    {
        super::RegionFromElement(pElement, paryRects, prcBound, dwFlags);
        return;
    }

    CLayout   * pLayout   = pElement->CurrentlyHasLayoutInContext(pLayoutContext) ? pElement->GetUpdatedLayout(pLayoutContext) : NULL;
    CDispNode * pDispNode = pLayout ? pLayout->GetElementDispNode() : NULL;
    CDispNode * pGridNode = GetTableInnerDispNode();

    if (!pGridNode)
        return;

    if (!pTableLayoutCache->IsTableLayoutCacheCurrent())   // if we are in the middle of modifying the table (and not recacled yet), return
        return;

    // If the element has a displaynode of its own, let it answer itself.
    if (pDispNode)
    {
        pDispNode->GetClientRect(prcBound, CLIENTRECT_CONTENT);
        goto Done;
    }

    // As a start, set the bounding rect to the table grid content area.
    pGridNode->GetClientRect(prcBound, CLIENTRECT_CONTENT);

    switch (pElement->Tag())
    {
    case ETAG_TR:
    {
        AssertSz(pLayout, "Layout MUST exist in the layout context.");

        //  No layout in the context.
        if (!pLayout)
            return;

        CTableRowLayoutBlock * pRowLayout = DYNCAST(CTableRowLayoutBlock, pLayout);
        int yTop = 0, yBottom = 0;
        Assert(pRowLayout);

        Verify(pTableLayoutCache->GetRowTopBottom(pRowLayout->RowPosition(), &yTop, &yBottom));
        prcBound->top = yTop;
        prcBound->bottom = yBottom;
        break;
    }
    case ETAG_THEAD:
    case ETAG_TFOOT:
    case ETAG_TBODY:
    {
        CTableSection * pSection = DYNCAST(CTableSection, pElement);
        int yTop = 0, yBottom = 0;
        Assert(pSection);

        if (!pSection->_cRows)
        {
            *prcBound = g_Zero.rc;
            break;
        }

        Verify(pTableLayoutCache->GetRowTopBottom(pSection->_iRow, &yTop, &yBottom));
        prcBound->top = yTop;

        Verify(pTableLayoutCache->GetRowTopBottom(pSection->_iRow + pSection->_cRows - 1, &yTop, &yBottom));
        prcBound->bottom = yBottom;
        break;
    }
    case ETAG_COLGROUP:
    case ETAG_COL:
    {
        CTableCol * pCol = DYNCAST(CTableCol, pElement);
        int xLeft = 0, xRight = 0;
        Assert(pCol);

        if (!pCol->_cCols || pTableLayoutCache->GetCols() == 0 || pTableLayoutCache->_aryColCalcs.Size() == 0)
        {
            *prcBound = g_Zero.rc;
            break;
        }

        pTableLayoutCache->GetColLeftRight(pCol->_iCol, &xLeft, &xRight);
        prcBound->left = xLeft;
        prcBound->right = xRight;

        // if it is not a spanned column, we are done
        if (pCol->_cCols > 1)
        {
            // if it is a spanned column, get the right coordinate for the last column
            pTableLayoutCache->GetColLeftRight(pCol->_iCol + pCol->_cCols - 1, &xLeft, &xRight);
            prcBound->right = xRight;
        }
        break;
    }
    default:
        // Any other elements return empty rect.
        *prcBound = g_Zero.rc;
        break;
    }

    if (_fHasCaptionDispNode)
        pGridNode->TransformRect((CRect&)*prcBound, COORDSYS_FLOWCONTENT, (CRect *)prcBound, COORDSYS_PARENT);

Done:

    if (dwFlags & RFE_SCREENCOORD)
    {
        TransformRect(prcBound, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
    }

    if (!IsRectEmpty(prcBound))
        paryRects->AppendIndirect(prcBound);
}


//+-------------------------------------------------------------------------
//
//  Method:     CTableLayout::GetRowTopBottom
//
//  Synopsis:   Obtain the row's y-extent.
//
//  Arguments:  [iRowLocate]  - IN:  index of row to be located
//              [pyRowTop]    - OUT: yTop of row
//              [pyRowBottom] - OUT: yBottom of row
//
//  Note:       Cellspacing is considered OUTSIDE the row.
//
//  Returns:    TRUE if row found.
//
//--------------------------------------------------------------------------

BOOL
CTableLayout::GetRowTopBottom(int iRowLocate, int * pyRowTop, int * pyRowBottom)
{
    CTableRowLayout * pRowLayout;
    int               iRow, cRows = GetRows(), iRowLast;

    Assert(pyRowTop && pyRowBottom);

    if (iRowLocate < 0 || iRowLocate >= cRows)
    {
        *pyRowTop = *pyRowBottom = 0;
        return FALSE;
    }

    Assert(_aryRows[iRowLocate]->RowLayoutCache());

    iRow = GetFirstRow();
    iRowLast = GetLastRow();
    pRowLayout = _aryRows[iRow]->RowLayoutCache();
    *pyRowTop = _yCellSpacing;
    *pyRowBottom = pRowLayout->_yHeight + _yCellSpacing;

    while (iRowLocate != iRow && iRow != iRowLast)
    {
        iRow = GetNextRowSafe(iRow);
        pRowLayout = _aryRows[iRow]->RowLayoutCache();
        *pyRowTop = *pyRowBottom + _yCellSpacing;
        *pyRowBottom += pRowLayout->_yHeight + _yCellSpacing;
    }

    Assert(iRowLocate == iRow);

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTableLayout::GetColLeftRight
//
//  Synopsis:   Obtain the column's x-extent.
//
//  Arguments:  [iColLocate] - IN:  index of col to be located
//              [pxColLeft]  - OUT: xLeft of col
//              [pxColRight] - OUT: xRight of col
//
//  Note:       Cellspacing is considered OUTSIDE the column.
//
//  Returns:    TRUE if column found.
//
//--------------------------------------------------------------------------

BOOL
CTableLayout::GetColLeftRight(int iColLocate, int * pxColLeft, int * pxColRight)
{
    int iCol = 0, cCols = GetCols(), xWidth;

    Assert (pxColLeft  && pxColRight);

    *pxColLeft = *pxColRight = 0;

    if (_aryColCalcs.Size() != cCols) 
    {
        Assert (FALSE && "we should not reach this code, since we have to be calced at this point");
        return FALSE;
    }

    if (iColLocate < 0 || iColLocate >= cCols)
    {
        return FALSE;
    }

    // NOTE: This code works for RTL as well.
    *pxColLeft  = _xCellSpacing;
    *pxColRight = _aryColCalcs[0]._xWidth + _xCellSpacing;

    while (iColLocate != iCol && iCol < cCols-1)
    {
        xWidth = _aryColCalcs[++iCol]._xWidth;
        *pxColLeft = *pxColRight + _xCellSpacing;
        *pxColRight += xWidth + _xCellSpacing;
    }

    Assert(iColLocate == iCol);

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTableLayout::GetRowLayoutFromPos
//
//  Synopsis:   Returns the row layout in the table at the y-position and its
//              y-extent.
//
//  Arguments:  [y]           - IN:  y-coordinate of the position
//              [pyRowTop]    - OUT: yTop of row
//              [pyRowBottom] - OUT: yBottom of row
//              [pLayoutContext] - IN: layout context we're searching in
//
//  Returns:    Table row layout, or NULL if the table is empty or y-position
//              is outside the table.  Bottom cellspacing is considered part of
//              the row (i.e. the top cellspacing corresponds to no row).
//
//--------------------------------------------------------------------------

CTableRowLayout *
CTableLayout::GetRowLayoutFromPos(int y, int * pyRowTop, int * pyRowBottom, BOOL *pfBelowRows, CLayoutContext *pLayoutContext /*=NULL*/)
{
    // We have two "row layout"-type ptrs.  We use the "block" internally
    // in this fn because in cases w/ context, the blocks have the height info.
    // However, we always need to return a full CTableRowLayout because callers
    // often expect a real row layout (i.e. one with an _aryCells).
    CTableRowLayoutBlock * pRowLayoutBlock = NULL;
    CTableRowLayout      * pRowLayoutReturned = NULL;
    int                 iRow, cRows = GetRows(), iRowLast;

    Assert(pyRowTop && pyRowBottom);

    *pyRowTop = 0;
    *pyRowBottom = 0;

    if (pfBelowRows)
    {
        *pfBelowRows = FALSE;
    }

    if (!cRows || y<0)
        goto Cleanup;

    iRow          = GetFirstRow();
    iRowLast      = GetLastRow();

    if ( pLayoutContext )
    {
        // If we have context, then we're a layout block that almost certainly
        // doesn't contain all the rows in the table.  Find the first row that
        // exists in this context.
        CTableRow *pTR = _aryRows[iRow];
        while ( iRow <= iRowLast && !pTR->CurrentlyHasLayoutInContext( pLayoutContext ))
        {
            iRow = GetNextRowSafe(iRow);
            pTR = _aryRows[iRow];
        }

        // Either we found a row w/ context, or we ran out of rows.
        // If we found a row w/ context, we're 'successful' and want to continue processing.
        // If we ran out of rows while looking, then bail.

        if ( iRow > iRowLast )
        {
            // Failed to find any rows in this context
            goto Cleanup;
        }
    }

    AssertSz( _aryRows[iRow]->CurrentlyHasLayoutInContext( pLayoutContext ), "Row must have some kind of layout at this point" );

    pRowLayoutReturned = _aryRows[iRow]->RowLayoutCache();
    pRowLayoutBlock = DYNCAST(CTableRowLayoutBlock, _aryRows[iRow]->GetUpdatedLayout(pLayoutContext));

    Assert( !pLayoutContext ? pRowLayoutReturned == pRowLayoutBlock : TRUE );

    *pyRowTop    += _yCellSpacing;
    *pyRowBottom += pRowLayoutBlock->_yHeight + 2*_yCellSpacing; // two cellspacings for first row: above AND below

    while (y >= *pyRowBottom && iRow != iRowLast && ( pLayoutContext ? _aryRows[iRow]->CurrentlyHasLayoutInContext( pLayoutContext ) : TRUE ))
    {
        iRow = GetNextRowSafe(iRow);

        pRowLayoutReturned = _aryRows[iRow]->RowLayoutCache();
        pRowLayoutBlock = DYNCAST(CTableRowLayoutBlock, _aryRows[iRow]->GetUpdatedLayout(pLayoutContext));
        Assert( !pLayoutContext ? pRowLayoutReturned == pRowLayoutBlock : TRUE );

        *pyRowTop = *pyRowBottom;
        *pyRowBottom += pRowLayoutBlock->_yHeight + _yCellSpacing;
    }

    if (pfBelowRows)
    {
        *pfBelowRows = TRUE;
    }

Cleanup:

    return pRowLayoutReturned;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTableLayout::GetColExtentFromPos
//
//  Synopsis:   Returns the x-extent of the column in the table at the
//              specified x-position.
//
//  Arguments:  [x]          - IN:  x-coordinate of the position
//              [pxColLead]  - OUT: xLead of column (side on which column begins - 
//                                  left for Left To Right and right for Right To Left)
//              [pyColTrail] - OUT: xTrail of column (side on which column ends -
//                                  right for Left To Right and left for Right To Left)
//              [fRightToLeft] - IN: the table is layed out RTL (origin it top/right)
//
//  Returns:    Column index found located between [*pxColLeft,*pxColRight).
//              Else returns -1.  Uses colcalcs.
//
//--------------------------------------------------------------------------

int
CTableLayout::GetColExtentFromPos(int x, int * pxColLead, int * pxColTrail, BOOL fRightToLeft)
{
    int iCol = 0, cCols = GetCols(), xWidth;

    if (!cCols || (!fRightToLeft ? x<0 : x>0))
        return -1;

    *pxColLead  = _xCellSpacing;

    if(!fRightToLeft)
    {
        *pxColTrail = _aryColCalcs[0]._xWidth + 2*_xCellSpacing;

        while (x >= *pxColTrail && iCol < cCols-1)
        {
            xWidth = _aryColCalcs[++iCol]._xWidth;
            *pxColLead = *pxColTrail;
            *pxColTrail += xWidth + _xCellSpacing;
        }
    }
    else
    {
        *pxColTrail = - _aryColCalcs[0]._xWidth - 2*_xCellSpacing;
        
        while (x <= *pxColTrail && iCol < cCols-1)
        {
            xWidth = _aryColCalcs[++iCol]._xWidth;
            *pxColLead = *pxColTrail;
            *pxColTrail -= xWidth + _xCellSpacing;
        }
    }

    return iCol;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTableLayout::GetHeaderFooterRects
//
//  Synopsis:   Retrieves the global rect of THEAD and TFOOT.
//
//  Arguments:  [prcTableHeader] - OUT: global rect of header
//              [prcTableFooter] - OUT: global rect of footer
//
//  Returns:    Rects if header and footer exist AND are supposed to be
//              repeated.  Empty rects otherwise.
//
//--------------------------------------------------------------------------

void
CTableLayout::GetHeaderFooterRects(RECT * prcTableHeader, RECT * prcTableFooter)
{
    CDispNode * pElemDispNode = GetElementDispNode();
    CDispNode * pDispNode = GetTableInnerDispNode();
    CTableRowLayout * pRowLayout;
    CRect rc, rcInner;
    int iRow;

    if (!pDispNode)
        return;

    Assert(prcTableHeader && prcTableFooter);
    memset(prcTableHeader, 0, sizeof(RECT));
    memset(prcTableFooter, 0, sizeof(RECT));

    // GetBounds returns coordinates in PARENT system.
    pElemDispNode->GetBounds(&rc);
    pElemDispNode->TransformRect(rc, COORDSYS_PARENT, &rc, COORDSYS_GLOBAL);
    rc.left = 0;

    pDispNode->GetClientRect(&rcInner, CLIENTRECT_CONTENT);
    pDispNode->TransformRect(rcInner, COORDSYS_FLOWCONTENT, &rcInner, COORDSYS_GLOBAL);

    if (_pHead && _pHead->_cRows)
    {
        CTreeNode * pNode = _pHead->GetFirstBranch();
        const CFancyFormat * pFF = pNode ? pNode->GetFancyFormat() : NULL;

        // If repeating of table headers is set on THEAD, calculate the rect.
        if (pFF && pFF->_bDisplay == styleDisplayTableHeaderGroup)
        {
            *prcTableHeader = rc;
            prcTableHeader->top = rcInner.top + _yCellSpacing;
            prcTableHeader->bottom = prcTableHeader->top;

            for ( iRow = _pHead->_iRow ; iRow < _pHead->_iRow + _pHead->_cRows ; iRow++ )
            {
                pRowLayout = GetRow(iRow)->RowLayoutCache();
                Assert(pRowLayout);

                prcTableHeader->bottom += _yCellSpacing;
                prcTableHeader->bottom += pRowLayout->_yHeight;
            }
        }
    }

    if (_pFoot && _pFoot->_cRows)
    {
        CTreeNode * pNode = _pFoot->GetFirstBranch();
        const CFancyFormat * pFF = pNode ? pNode->GetFancyFormat() : NULL;

        // If repeating of table footers is set on TFOOT, calculate the rect.
        if (pFF && pFF->_bDisplay == styleDisplayTableFooterGroup)
        {
            *prcTableFooter = rc;
            prcTableFooter->bottom = rcInner.bottom - _yCellSpacing;
            prcTableFooter->top = prcTableFooter->bottom;

            for ( iRow = _pFoot->_iRow ; iRow < _pFoot->_iRow + _pFoot->_cRows ; iRow++ )
            {
                pRowLayout = GetRow(iRow)->RowLayoutCache();
                Assert(pRowLayout);

                prcTableFooter->top -= pRowLayout->_yHeight;
                prcTableFooter->top -= _yCellSpacing;
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     GetNextFlowLayout
//
//  Synopsis:   Retrun a cell (if it exists) in the direction specified by
//              iDir.
//
//  Arguments:  [iDir]:       The direction to search in
//              [ptPosition]: The point from where to start looking for a cell
//              [pElementLayout]: The child site from where this call came and to which
//                            the point belongs.
//              [pcp]:        The cp in the new txt site
//              [pfCaretNotAtBOL]: Is the caret at BOL?
//              [pfAtLogicalBOL] : Is the caret at logical BOL?
//
//  Returns:    The txtsite in the direction specified if one exists,
//              NULL otherwise.
//
//--------------------------------------------------------------------------

CFlowLayout *
CTableLayout::GetNextFlowLayout(NAVIGATE_DIRECTION iDir, POINT ptPosition, CElement *pElementLayout, LONG *pcp,
                                BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    CFlowLayout *pFlowLayout;

    if (IsCaption(pElementLayout->Tag()))
    {
        pFlowLayout = GetNextFlowLayoutFromCaption(iDir, ptPosition, DYNCAST(CTableCaption, pElementLayout));
    }
    else
    {
        CTableCell *pCell = DYNCAST(CTableCell, pElementLayout);
        int iCol = pCell->ColIndex();
        int iRow = pCell->RowIndex();

        if (iDir == NAVIGATE_UP || iDir == NAVIGATE_DOWN)
        {
            iCol += pCell->ColSpan() - 1;    // if cell is spanned
            if (iDir == NAVIGATE_DOWN)
                iRow += pCell->RowSpan() - 1;
        }

        pFlowLayout = GetNextFlowLayoutFromCell(iDir, ptPosition, iRow, iCol);
    }

    // If we find a table cell then lets find the position we want to be at
    // in that table cell. If we did not find a cell, then pass this call
    // to our parent.
    return pFlowLayout
            ? pFlowLayout->GetPositionInFlowLayout(iDir, ptPosition, pcp, pfCaretNotAtBOL, pfAtLogicalBOL)
            : GetUpdatedParentLayout()->GetNextFlowLayout(iDir, ptPosition, Table(), pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
}


//+-------------------------------------------------------------------------
//
//  Method:     GetNextFlowLayout
//
//  Synopsis:   Retrun a cell (if it exists) in the direction specified by
//              iDir.
//
//  Arguments:  [iDir]:       The direction to search in
//              [ptPosition]: The point from where to start looking for a cell
//              [pElementLayout]: The child element (with layout) from where this
//                            call came and to which the point belongs.
//              [pcp]:        The cp in the new txt site
//              [pfCaretNotAtBOL]: Is the caret at BOL?
//              [pfAtLogicalBOL] : Is the caret at logical BOL?
//
//  Returns:    The txtsite in the direction specified if one exists,
//              NULL otherwise.
//
//  Note:       This method just routes the call straight up to the table and
//              passes the incoming child as the child rather than itself.
//
//--------------------------------------------------------------------------

CFlowLayout *
CTableRowLayout::GetNextFlowLayout(NAVIGATE_DIRECTION iDir, POINT ptPosition, CElement *pElementLayout, LONG *pcp,
                                   BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    return TableLayoutCache()->GetNextFlowLayout(iDir, ptPosition, pElementLayout, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
}


//+----------------------------------------------------------------------------
//
//  Member:     GetNextFlowLayoutFromCell
//
//  Synopsis:   Get next text site in the specified direction from the
//              specified position
//
//  Arguments:  [iDir]       -  UP/DOWN/LEFT/RIGHT
//              [ptPosition] -  position in the current txt site
//              [iRow]       -  (current) cell's row number
//              [iCol]       -  (current) cell's column number
//
//-----------------------------------------------------------------------------

CFlowLayout *
CTableLayout::GetNextFlowLayoutFromCell(NAVIGATE_DIRECTION iDir, POINT ptPosition, int iRow, int iCol)
{
    CPoint ptContent(ptPosition);
    TransformPoint(&ptContent, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
    
    if (ptContent.x < 0 && (iDir == NAVIGATE_UP || iDir == NAVIGATE_DOWN))
    {
        ptContent.x = 0;
    }

    int                 x = ptContent.x;
    CTableCaption   *   pCaption;
    CTableCaption   **  ppCaption;
    int                 cC;
    int                 cRows;
    int                 cCols;
    BOOL                fGoingUp = FALSE;
    CFlowLayout     *   pFlowLayout = NULL;
    CTableCell      *   pCell = NULL;

    if (EnsureTableLayoutCache())
        return NULL;

    
    cRows = GetRows();
    cCols = GetCols();

    //  Note:       iRow could be outside of the _AryRows range by +/-1
    //              iCol could be outside of the _aryColumns range by +/-1
    Assert (iRow >= -1 && iRow <= cRows);
    Assert (iCol >= -1 && iCol <= cCols);

    switch (iDir)
    {
    case NAVIGATE_LEFT:
        while (iRow >= 0 && !pCell)
        {
            while (--iCol >= 0 && !pCell)
            {
                // go to the cell on the left
                pCell = GetCellBy(iRow, iCol);
            }
            // go to the right most cell of the previous row
            iRow = GetPreviousRowSafe(iRow);
            iCol = cCols;
        }
        fGoingUp = TRUE;
        break;

    case NAVIGATE_RIGHT:
        while (iRow < cRows && !pCell)
        {
            while (++iCol < cCols && !pCell)
            {
                // go to the cell on the right
                pCell = GetCellBy(iRow, iCol);

                // If we ended up in the middle of a colspan, walk out of that cell in next iteration.
                // This case is taken care of inside GetCellBy.
            }
            // go to the left most cell of the next row
            iRow = GetNextRowSafe(iRow);
            iCol = -1;
        }
        break;

    case NAVIGATE_UP:
        while ((iRow = GetPreviousRowSafe(iRow)) >= 0 && !pCell)
        {
            AssertSz (IsReal(pCell), "We found a row/colspan");
            pCell = GetCellBy(iRow, iCol, x);
        }
        fGoingUp = TRUE;
        break;

    case NAVIGATE_DOWN:
        while ((iRow = GetNextRowSafe(iRow)) < cRows && !pCell)
        {
            AssertSz (IsReal(pCell), "We found a row/colspan");
            pCell = GetCellBy(iRow, iCol, x);

            // If we ended up in the middle of a rowspan, walk out of that cell in next iteration.
            if (pCell && pCell->RowSpan() > 1 && iRow > pCell->RowIndex())
            {
                Assert(pCell->RowIndex() + pCell->RowSpan() - 1 >= iRow);
                iRow = pCell->RowIndex() + pCell->RowSpan() - 1;
                pCell = NULL;
            }
        }
        break;

    }

    // Get the layout of the real cell.
    if (pCell)
    {
        AssertSz(IsReal(pCell), "We need to have a real cell");
        pFlowLayout = pCell->Layout();
    }

    if (!pFlowLayout && _aryCaptions.Size())
    {
        // note: the BOTTOM/TOP captions are mixed in the array of captions
        // but the captions are sorted Y position wise
        for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
             cC > 0;
             cC--, ppCaption++)
        {
            pCaption = (*ppCaption);
            if (!pCaption->Layout()->NoContent())
            {
                if (fGoingUp)
                {
                    // So we need to take last TOP caption
                    if (pCaption->_uLocation == CTableCaption::CAPTION_TOP)
                    {
                        pFlowLayout = DYNCAST(CFlowLayout, pCaption->GetUpdatedLayout());
                    }
                }
                else
                {
                    // So we need to take first BOTTOM caption
                    if (pCaption->_uLocation == CTableCaption::CAPTION_BOTTOM)
                    {
                        pFlowLayout = DYNCAST(CFlowLayout, pCaption->GetUpdatedLayout());
                        break;
                    }
                }
            }
        }
    }

    return pFlowLayout;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetNextFlowLayoutFromCaption
//
//  Synopsis:   Get next text site in the specified direction from the
//              specified position
//
//  Arguments:  [iDir]       -  UP/DOWN/LEFT/RIGHT
//              [ptPosition] -  position in the current txt site
//              [pCaption]   -  current caption
//
//-----------------------------------------------------------------------------

CFlowLayout *
CTableLayout::GetNextFlowLayoutFromCaption(NAVIGATE_DIRECTION iDir, POINT ptPosition, CTableCaption *pCaption)
{
    unsigned    uLocation = pCaption->_uLocation;   // Caption placing (TOP/BOTTOM)
    int         i, cC, iC;

    if( EnsureTableLayoutCache() )
        return NULL;

    cC = _aryCaptions.Size();
    iC = _aryCaptions.Find(pCaption);
    Assert (iC >=0 && iC < cC);

    switch (iDir)
    {
    case NAVIGATE_LEFT:
    case NAVIGATE_UP:
        for (i = iC - 1; i >= 0; i--)
        {
            pCaption = _aryCaptions[i];
            if (!pCaption->Layout()->NoContent())
            {
                if (pCaption->_uLocation == uLocation)
                {
                    return DYNCAST(CFlowLayout, pCaption->GetUpdatedLayout());
                }
            }
        }
        if (uLocation == CTableCaption::CAPTION_BOTTOM)
        {
            return GetNextFlowLayoutFromCell(iDir, ptPosition, GetRows(), 0);
        }
        break;
    case NAVIGATE_RIGHT:
    case NAVIGATE_DOWN:
        for (i = iC + 1; i < cC; i++)
        {
            pCaption = _aryCaptions[i];
            if (!pCaption->Layout()->NoContent())
            {
                if (pCaption->_uLocation == uLocation)
                {
                    return DYNCAST(CFlowLayout, pCaption->GetUpdatedLayout());
                }
            }
        }
        if (uLocation == CTableCaption::CAPTION_TOP)
        {
            return GetNextFlowLayoutFromCell(iDir, ptPosition, -1, GetCols());
        }
        break;

    }

    return NULL;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetCellBy
//
//  Synopsis:   get the cell from the specified row and from the specified column
//              that is positioned under the specified X-position.
//
//  Arguments:  iRow     - row
//              iCol     - column
//              X        - x position
//
//-----------------------------------------------------------------------------

CTableCell *
CTableLayout::GetCellBy(int iRow, int iCol, int x)
{
    CTableCell  *pCell = NULL;
    CTableRow   *pRow;

    Assert(IsTableLayoutCacheCurrent());

    int xLeft, xRight;
    iCol = GetColExtentFromPos(x, &xLeft, &xRight);

    while (iCol >= 0)
    {
        pRow = _aryRows[iRow];
        pCell = pRow->RowLayoutCache()->_aryCells[iCol];
        if (pCell)
        {
            break;
        }
        // go to the cell on the left
        iCol--; // colSpan case
    }
    return Cell(pCell);
}


//+----------------------------------------------------------------------------
//
//  Member:     GetCellBy
//
//  Synopsis:   get the cell from the specified row and from the specified column
//
//  Arguments:  iRow     - row
//              iCol     - column
//
//-----------------------------------------------------------------------------

inline CTableCell *
CTableLayout::GetCellBy(int iRow, int iCol)
{
    Assert(IsTableLayoutCacheCurrent());
    CTableRow *pRow = _aryRows[iRow];
    return Cell(pRow->RowLayoutCache()->_aryCells[iCol]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\tokenz.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TOKENZ_HXX_
#define X_TOKENZ_HXX_
#include "tokenz.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#define ISDIGIT(ch) (((unsigned)((ch) - _T('0'))) <= _T('9') - _T('0'))
#define ISHEXAL(ch) (((unsigned)((ch) & ~(_T('a') ^ _T('A'))) - _T('A')) <= _T('F')-_T('A'))
#define ISHEX(ch)   (ISDIGIT(ch) || ISHEXAL(ch))

#ifndef NO_UTF16
typedef DWORD XCHAR;
#else
typedef TCHAR XCHAR;
#endif

extern XCHAR EntityChFromHex(TCHAR *pch, ULONG cch);

Tokenizer::Tokenizer ()
{
	_pCharacterStream = 0;
	_cCharacterStream = 0;
    _currChar = '\0';

    _currToken = TT_Unknown;

    _currTokOffset = 0;
    _nextTokOffset = 0;
    _pStartOffset = 0;
    _pEndOffset = 0;

    _pStartTokenValueOffset = 0;
    _pEndTokenValueOffset = 0;

    _pEscStart = NULL;
    _pEscBuffer = &_tokenValue;
    _fEscSeq = FALSE;
    _fEatenComment = FALSE;
}

    
Tokenizer::TOKEN_TYPE
Tokenizer::NextToken(BOOL fNeedRightParen, BOOL fIgnoreStringToken, BOOL fIgnoreEsc)
{
    Tokenizer::TOKEN_TYPE tt = TT_Unknown;

    if (_currToken == TT_LParen && fNeedRightParen)
    {
        while (CDOToken() && NextChar())
            NextNonSpaceChar();

        TCHAR chPeek = PeekNextNonSpaceChar();
        if (chPeek == CHAR_SINGLE ||
            chPeek == CHAR_DOUBLE)
        {
            TCHAR chStrDelim = chPeek;

            NextChar();

            // Don't include the beginning quote in string value.
            _pStartOffset = _pCharacterStream + _nextTokOffset - 1;

            FetchString(chStrDelim, fIgnoreEsc);

            // Point at RParen.
            NextChar();             // Skip pass the end quote
        }
        else
        {
            // Don't include the beginning LParen in the value.
            _pStartOffset = _pCharacterStream + _nextTokOffset - 1;

            // Pull out the url that inside of ( ) that isn't a quoted string.
            // e.g., url(file.css)
            FetchString(CHAR_RIGHT_PAREN, fIgnoreEsc);
            if (CurrentChar() == CHAR_RIGHT_PAREN)
                tt = TT_RParen;
        }

        if (tt != TT_RParen)
        {
            do
            {
                NextNonSpaceChar();
            }
            while (CDOToken() && NextChar());

            if (CurrentChar() == CHAR_RIGHT_PAREN)
                tt = TT_RParen;
        }
    }
    else if (CurrentChar())
    {
        _pStartOffset = _pCharacterStream + _nextTokOffset - 1;
        
        if (CurrentChar() == CHAR_ESCAPE && PeekNextChar(0) == CHAR_COLON)
        {
            NextChar();
            tt = TT_EscColon;
        }
        // Identifier?
        else if (_istalnum(CurrentChar()) ||
                 (CurrentChar() >= CSS_UNICODE_MIN && CurrentChar() <= CSS_UNICODE_MAX) ||
                 CurrentChar() == CHAR_ESCAPE)
        {
            // Fetch the rest of the identifier.
            tt = FetchIdentifier();
            while (CDOToken())
            {
                NextChar();
                Assert(IsIdentifier(tt));
            }

            goto Done;
        }
/*
        else if ((CurrentChar() >= '0' && CurrentChar() <= '9'))
        {
            tt = FetchNumber();
            goto Done;
        }
*/
        else
        {
            switch (CurrentChar())
            {
            case CHAR_HASH : 
                tt = TT_Hash;
                break;

            case CHAR_AT : 
                tt = TT_At;
                break;

            case CHAR_SINGLE : 
            case CHAR_DOUBLE : 
                {
                    if (fIgnoreStringToken)
                    {
                        tt = TT_Unknown;
                        break;
                    }

                    TCHAR chStrDelim = CurrentChar();

                    NextChar();

                    // Don't include the beginning quote in string value.
                    _pStartOffset = _pCharacterStream + _nextTokOffset - 1;

                    FetchString(chStrDelim);
                    tt = TT_String;
                    break;
                }

            case CHAR_EQUAL : 
                tt = TT_Equal;
                break;
            
            case CHAR_COLON : 
                tt = TT_Colon;
                break;

            case CHAR_LEFT_CURLY : 
                tt = TT_LCurly;
                break;

            case CHAR_RIGHT_CURLY : 
                tt = TT_RCurly;
                break;

            case CHAR_SEMI : 
                tt = TT_Semi;
                break;

            case CHAR_DOT : 
                tt = TT_Dot;
                break;

            case CHAR_COMMA : 
                tt = TT_Comma;
                break;

            case CHAR_ASTERISK : 
                tt = TT_Asterisk;
                while (PeekNextChar(0) == CHAR_FORWARDSLASH && PeekNextChar(1) == CHAR_ASTERISK)
                {
                    NextChar();
                    Verify(CDOToken());
                    Assert(tt == TT_Asterisk);
                }
                break;

            case CHAR_LEFT_PAREN : 
                tt = TT_LParen;
                break;

            case CHAR_RIGHT_PAREN : 
                tt = TT_RParen;
                break;

            case CHAR_BANG : 
                tt = TT_Bang;
                break;

            case CHAR_LBRACKET : 
            case CHAR_HYPHEN : 
                // <!--  or -->
                tt = GetIE5CompatToken();
                break;

            default: 
                // /* ?
                if (CDOToken())
                {
                    // find and return comment token.
                    tt = TT_Comment;
                }
                else
                    tt = TT_Unknown;

                break;
            }
        }
    }
    else    // Done parsing EOF hit.
    {
        tt = TT_EOF;
    }

    _currTokOffset = _nextTokOffset;

    NextChar();

Done:
    if (tt != TT_Hash && tt != TT_At)
    {
        if (tt != TT_Colon && tt != TT_Dot)
            NextNonSpaceChar();
        else
        {
            Assert(tt == TT_Dot || tt == TT_Colon);
            while (CDOToken())
            {
                NextChar();
                Assert(tt == TT_Dot || tt == TT_Colon);
            }
        }
    }

    _currToken = tt;

    return tt;
}

Tokenizer::TOKEN_TYPE

Tokenizer::FetchIdentifier()
{
    BOOL   fEscSeq = FALSE;
    BOOL  *pfEscSeq = _pEscStart ? &_fEscSeq : &fEscSeq;
    // Flag is true iff the identifier we are going to fetch is a standard compliant identifier.
    // See definition of CSSIdentifier[First]?Char to see what is a standard compliant character.
    BOOL   fCSSCompliant = TRUE;
    BOOL   fFirstCharacter = TRUE;
    BOOL   fIsCSSIdentifierChar = CSSIdentifierChar(CurrentChar()); // Performance tuning. By doing this we avoid call
                                                                    // CSSIdentifierChar twice in the following while loop.
 
    while (fIsCSSIdentifierChar ||  // Performance tuning. See end of while loop.
           NonCSSIdentifierChar(CurrentChar()) ||
           CurrentChar() == CHAR_ESCAPE)
    {
        if (CurrentChar() == CHAR_ESCAPE)
        {
            if (!_pEscStart && (PeekNextChar(0) == CHAR_COLON))
                break;

            if (!*pfEscSeq)
            {
                *pfEscSeq = TRUE;
                Assert(_pEscBuffer && (_pEscStart || _pEscBuffer == &_tokenValue));
                if (_pEscStart && !_fEatenComment)
                    _pEscBuffer->Clear();
                else
                    _pEscBuffer->Set(_pStartOffset, (_pCharacterStream + _nextTokOffset - 1) - _pStartOffset);
            }

            ProcessEscSequence();
            fFirstCharacter = FALSE;
        }
        else
        {
            if (*pfEscSeq && !_pEscStart)
                _pEscBuffer->Append(CurrentChar());

            if (fFirstCharacter)
            {
                fCSSCompliant = fCSSCompliant && CSSIdentifierFirstChar(CurrentChar());
                fFirstCharacter = FALSE;
            }
            else
            {
                fCSSCompliant = fCSSCompliant && fIsCSSIdentifierChar;   
            }
        }

        NextChar();
        fIsCSSIdentifierChar = CSSIdentifierChar(CurrentChar());
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

    if (!_pEscStart)
    {
        Assert(_pEscBuffer == &_tokenValue);
        _pStartTokenValueOffset = (*pfEscSeq) ? (LPTSTR)_tokenValue : _pStartOffset;
        _pEndTokenValueOffset = (*pfEscSeq) ? _pStartTokenValueOffset + _pEscBuffer->Length() : _pEndOffset;
    }

    return fCSSCompliant ? TT_CSSIdentifier : TT_Identifier;
}


Tokenizer::TOKEN_TYPE
Tokenizer::FetchNumber()
{
    // digit = 0..9
    // number = digit* | [digit + '.' [+ digit*]]

    while (CurrentChar() >= '0' && CurrentChar() <= '9') 
    {
        NextChar();
    }

    if (CurrentChar() == CHAR_DOT)
    {
        NextChar();
        if (CurrentChar() >= '0' && CurrentChar() <= '9')
        {
            while (CurrentChar() >= '0' && CurrentChar() <= '9')
                NextChar();
        }
        else
        {
            return TT_Unknown;
        }
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;
/*
NOTE: Need to support 36pt above 2 lines does that.
    if (isspace(CurrentChar()))
    {
        _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

        return TT_Number;
    }
    else
    {
        return TT_Unknown;
    }
*/
    _pStartTokenValueOffset = _pStartOffset;
    _pEndTokenValueOffset = _pEndOffset;

    return TT_Number;
}


// Looking for /* and 
BOOL
Tokenizer::CDOToken()
{
    if (CurrentChar() == CHAR_FORWARDSLASH &&
        PeekNextChar(0) == CHAR_ASTERISK)
    {
        if (_pEscStart)
        {
            if (!_fEscSeq && !_fEatenComment)
                _pEscBuffer->Set(_pEscStart, (_pCharacterStream + _nextTokOffset) - _pEscStart - 1);
            else
                _pEscBuffer->Append(_pEscStart, (_pCharacterStream + _nextTokOffset) - _pEscStart - 1);

            _fEatenComment = TRUE;
        }
        // skip the /*
        NextChar();
        NextChar();

        while (CurrentChar() &&
               (CurrentChar() != CHAR_ASTERISK ||
                PeekNextChar(0) != CHAR_FORWARDSLASH))
        {
            NextChar();
        }

        // skip the */
        if (CurrentChar())
        {
            // Only advance one char here as there will be one more in NextToken(), after this.
            NextChar();
        }

        _pEndOffset = _pCharacterStream + _nextTokOffset;

        if (_pEscStart)
            _pEscStart = _pEndOffset;

        return TRUE;
    }

    return FALSE;
}

void Tokenizer::StopSequence(LPTSTR *ppchSequence)
{
    Assert(_pEscStart);

    _pEndTokenValueOffset = _pCharacterStream + _currTokOffset - 1;

    if (_pEscBuffer != &_tokenValue)
    {
        if (!_fEscSeq && !_fEatenComment)
        {
            // fill in the buffer, if passed in to startSequence(), & if not esc sequence
            _pEscBuffer->Set(GetStartToken(), GetTokenLength());
        }
        else if (_pEndTokenValueOffset > _pEscStart)
        {
            // fill in the rest of the escape sequence
            _pEscBuffer->Append(_pEscStart, _pEndTokenValueOffset - _pEscStart);
        }

        _pEscBuffer = &_tokenValue;
        Assert(!ppchSequence);
    }
    else if (_fEscSeq || _fEatenComment)
    {
        // fill in the rest of the escape sequence
        _tokenValue.Append(_pEscStart, _pEndTokenValueOffset - _pEscStart);
        _pStartTokenValueOffset = (LPTSTR)_tokenValue;
        _pEndTokenValueOffset = _pStartTokenValueOffset + _pEscBuffer->Length();
        if (ppchSequence)
        {
            _tokenValue.TrimTrailingWhitespace();
            *ppchSequence = _pStartTokenValueOffset;
        }
    }
    else if (ppchSequence)
    {
        _tokenValue.Set(GetStartToken(), GetTokenLength());
        _tokenValue.TrimTrailingWhitespace();
        *ppchSequence = (LPTSTR)_tokenValue;
    }

    _pEscStart = NULL;
    if (_fEscSeq)
        _fEscSeq = FALSE;
    if (_fEatenComment)
        _fEatenComment = FALSE;
}

void Tokenizer::ProcessEscSequence()
{
    TCHAR *pchWord = _pCharacterStream + _nextTokOffset;
    TCHAR *pchCurr = pchWord;
    XCHAR chEnt;
    _currChar = *pchCurr;

    while (_currChar && (pchCurr - pchWord < 6) && ISHEX(_currChar))
        _currChar = *(++pchCurr);

    chEnt = (pchCurr == pchWord) ? (isspace(_currChar) ? 0 : _currChar)
                                 : EntityChFromHex(pchWord, pchCurr - pchWord);
    
    if (chEnt)
    {
        if (_pEscStart)
        {
            _pEscBuffer->Append(_pEscStart, pchWord - _pEscStart - 1);
            _pEscStart = pchCurr + ((pchCurr == pchWord) ? 1 : 0);
        }

        if (chEnt < 0x10000)
        {
            _pEscBuffer->Append(chEnt);
        }
        else
        {
            _pEscBuffer->Append(HighSurrogateCharFromUcs4(chEnt));
            _pEscBuffer->Append(LowSurrogateCharFromUcs4(chEnt));
        }
    }

    if (pchCurr == pchWord)
        _nextTokOffset++;
    else if (!isspace(_currChar))
    {
        _nextTokOffset += (ULONG)(pchCurr - pchWord);
        _currChar = *(_pCharacterStream + _nextTokOffset - 1);
    }
    else
    {
        _nextTokOffset += (ULONG)(pchCurr - pchWord + 1);
        if (_pEscStart)
            _pEscStart++;
    }
    
    Assert(_currChar == *(_pCharacterStream + _nextTokOffset - 1));
}

BOOL
Tokenizer::FetchString(TCHAR chDelim, BOOL fIgnoreEsc)
{
    BOOL   fResult;
    BOOL   fEscSeq = FALSE;
    BOOL  *pfEscSeq = _pEscStart ? &_fEscSeq : &fEscSeq;

    while (CurrentChar() && CurrentChar() != chDelim)
    {
        if (CHAR_RIGHT_PAREN == chDelim && !fIgnoreEsc && isspace(CurrentChar()))
            break;

        if (CurrentChar() == CHAR_ESCAPE && !fIgnoreEsc)
        {
            if (!*pfEscSeq)
            {
                *pfEscSeq = TRUE;
                Assert(_pEscBuffer && (_pEscStart || _pEscBuffer == &_tokenValue));
                if (_pEscStart && !_fEatenComment)
                    _pEscBuffer->Clear();
                else
                    _pEscBuffer->Set(_pStartOffset, (_pCharacterStream + _nextTokOffset - 1) - _pStartOffset);
            }

            ProcessEscSequence();
        }
        else if (*pfEscSeq && !_pEscStart)
            _pEscBuffer->Append(CurrentChar());

        NextChar();
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

    // Was end string delimiter found ' or " depending on how the string started?
    fResult = !!CurrentChar();

    if (!_pEscStart)
    {
        Assert(_pEscBuffer == &_tokenValue);
        _pStartTokenValueOffset = (*pfEscSeq) ? (LPTSTR)_tokenValue : _pStartOffset;
        _pEndTokenValueOffset = (*pfEscSeq) ? _pStartTokenValueOffset + _pEscBuffer->Length() : _pEndOffset;
    }

    return fResult;
}

Tokenizer::TOKEN_TYPE
Tokenizer::GetIE5CompatToken()
{
    TCHAR chCurrent = CurrentChar();
    Tokenizer::TOKEN_TYPE tt = TT_Unknown;

    Assert(chCurrent == CHAR_LBRACKET || chCurrent == CHAR_HYPHEN);

    if (_currTokOffset && !isspace(PrevChar()))
        return tt;

    switch (PeekNextChar(0))
    {
    // <!-- ?
    case CHAR_BANG :

        if (chCurrent == CHAR_LBRACKET && 
            PeekNextChar(1) == CHAR_HYPHEN &&
            PeekNextChar(2) == CHAR_HYPHEN)
        {
            AdvanceChars(3);
            tt = TT_BeginHTMLComment;
        }
        
        break;

    // --> ?
    case CHAR_HYPHEN :
        
        if (chCurrent == CHAR_HYPHEN &&
            PeekNextChar(1) == CHAR_RBRACKET) 
        {
            AdvanceChars(2);
            tt = TT_EndHTMLComment;
        }

        break;

    default:
        tt = TT_Unknown;
        break;
    }

    return tt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\table\ltcalc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltcalc.cxx
//
//  Contents:   CTableLayout calculating layout methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LSM_HXX
#define X_LSM_HXX
#include "lsm.hxx"
#endif

//#define TABLE_PERF 1
#ifdef TABLE_PERF
#include "icapexp.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif  

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

MtDefine(CTableLayoutCalculateMinMax_aryReducedSpannedCells_pv, Locals, "CTableLayout::CalculateMinMax aryReducedSpannedCells::_pv")
MtDefine(CalculateLayout, PerfPigs, "CTableLayout::CalculateLayout")

MtDefine(UsingFixedBehaviour, LayoutMetrics, "Using CTable FixedBehaviour")
MtDefine(UsingFixedBehaviour1, UsingFixedBehaviour, "EnsureCells")
MtDefine(UsingFixedBehaviour2, UsingFixedBehaviour, "AdjustHeight")
MtDefine(UsingFixedBehaviour3, UsingFixedBehaviour, "Enable FORCE")

MtDefine(NotUsingFixedBehaviour, LayoutMetrics, "NOT Using CTable FixedBehaviour")

DeclareTag(tagTableRecalc,        "TableRecalc",  "Allow incremental recalc")
DeclareTag(tagTableChunk,         "TableChunk",   "Trace table chunking behavior")
DeclareTag(tagTableCalc,          "TableCalc",    "Trace Table/Cell CalcSize calls")
DeclareTag(tagTableDump,          "TableDump",    "Dump table sizes after CalcSize")
DeclareTag(tagTableSize,          "TableSize",    "Check min cell size two ways")
DeclareTag(tagTableMinAssert,     "TableMinAssert", "Assert if SIZEMODE_MINWIDTH is used")
DeclareTag(tagTableCellSizeCheck, "TableCellCheck",  "Check table cell size against min size")

DeclareTag(tagTableLayoutBlock,   "TableLayoutBlock", "PPV CalcSize fns");

ExternTag(tagCalcSize);

PerfTag(tagTableMinMax, "TableMinMax", "CTable::CalculateMinMax")
PerfTag(tagTableLayout, "TableLayout", "CTable::CalculateLayout")
PerfTag(tagTableColumn, "TableColumn", "CTable::CalculateColumns")
PerfTag(tagTableRow,    "TableRow",    "CTable::CalculateRow")
PerfTag(tagTableSet,    "TableCell",   "CTable::SetCellPositions")

// Wrappers to make is easier to profile table cell size calcs.
void CalculateCellMinMax (CTableCellLayout *pCellLayout,
                          CTableCalcInfo * ptci,
                          SIZE *psize)
{
    pCellLayout->CalcSize(ptci, psize);
}

void CalculateCellMin (CTableCellLayout *pCellLayout,
                       CTableCalcInfo * ptci,
                       SIZE *psize)
{
    pCellLayout->_fMinMaxValid = FALSE;
    ptci->_smMode = SIZEMODE_MINWIDTH;
    pCellLayout->CalcSize(ptci, psize);
    ptci->_smMode = SIZEMODE_MMWIDTH;
    pCellLayout->_fMinMaxValid = TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CalculateMinMax
//
//  Synopsis:   Calculate min/max width of table
//
//  Return:     sizeMin.cx, sizeMax,cx, if they are < 0 it means CalcMinMax
//              have failed during incremental recalc to load history
//
//--------------------------------------------------------------------------

MtDefine( TableHistoryUsed, Metrics, "Table History Used");

void
CTableLayout::CalculateMinMax(CTableCalcInfo * ptci, BOOL fIncrementalMinMax)
{
    SIZEMODE        smMode = ptci->_smMode; // save
    int             cR, cC;
    CTableColCalc * pColCalc = NULL;
    CTableColCalc * pSizedColCalc;
    int             cCols = GetCols();
    CTableRow **    ppRow;
    CTableRowLayout * pRowLayout;
    int             cRows = GetRows();
    CTableCell **   ppCell;
    CTableCell *    pCell;
    CTableCellLayout * pCellLayout;
    CTableCaption **ppCaption;
    int             cColSpan, cRowSpan;
    SIZE            size;
    long            xTablePadding = 0;
    int             cSpanned = 0;   // number of cells with colSpan > 1
    long            xMin=0, xMax=0;
    long            cxWidth, dxRemainder;
    int             cUnsizedCols, cSizedColSpan;
    BOOL            fMinMaxCell;
    const CWidthUnitValue * puvWidth = NULL;
    BOOL            fTableWidthSpecifiedInPercent;
    long            xTableWidth = GetSpecifiedPixelWidth(ptci, &fTableWidthSpecifiedInPercent);
    CTableColCalc * pColLastNonVirtual = NULL;  // last non virtual column
    int             cReducedSpannedCells;
    CTableColCalc * pColCalcSpanned;
    int             i, iCS;
    CPtrAry<CTableCell *>   aryReducedSpannedCells(Mt(CTableLayoutCalculateMinMax_aryReducedSpannedCells_pv));
    int             iPixelWidth;
    CTable        * pTable = Table();
    CTreeNode     * pNode;
    BOOL            fRowDisplayNone;
    BOOL            fAlwaysMinMaxCells = _fAlwaysMinMaxCells;
    
    //  This flag is TRUE if layout should be calculated in CSS1 strict mode. 
    //  If user specified size in the layout in CSS1 strict mode this size should 
    //  correspond to content size and should not include padding and border. 
    BOOL fStrictCSS1Document =      pTable->HasMarkupPtr() 
                                &&  pTable->GetMarkupPtr()->IsStrictCSS1Document();

    BOOL            fCookUpEmbeddedTableWidthForNetscapeCompatibility = (xTableWidth == 0 &&
                        !fTableWidthSpecifiedInPercent && !pTable->IsAligned());

    if (fCookUpEmbeddedTableWidthForNetscapeCompatibility)
    {
        CLayout * pParentLayout = _cNestedLevel == 0 ? NULL : GetUpdatedParentLayout(ptci->GetLayoutContext());

        if (pParentLayout 
            && (   pParentLayout->Tag() == ETAG_TD 
                || pParentLayout->Tag() == ETAG_TH
                || pParentLayout->Tag() == ETAG_CAPTION))
        {
            pCellLayout = DYNCAST(CTableCellLayout, pParentLayout);

            // Only apply Nav compatibility width when there is nothing
            // else aligned to this table.
            if (!pCellLayout->_fAlignedLayouts)
            {
                // Table is always horizontal => fVerticalLayoutFlow = FALSE
                xTableWidth = pCellLayout->GetSpecifiedPixelWidth(ptci, FALSE);
            }
        }
        fCookUpEmbeddedTableWidthForNetscapeCompatibility = (xTableWidth != 0);
    }

#if 0
    int xRowMin, xRowMax;
#endif

    PerfLog(tagTableMinMax, this, "+CalculateMinMax");

    ptci->_smMode = SIZEMODE_MMWIDTH;

    // Calc and cache border and other values
    CalculateBorderAndSpacing(ptci);

    _sizeMin.cx = 0;
    _sizeMax.cx = 0;

    size.cx = 0;
    size.cy = 0;

    _cNonVirtualCols = 0;
    _cSizedCols  = min(cCols, pTable->GetAAcols());
    cUnsizedCols = cCols - _cSizedCols;
    _fCols = !cUnsizedCols;
    fAlwaysMinMaxCells |=  ((ptci->_grfLayout & LAYOUT_FORCE) && _cSizedCols);


    if (fIncrementalMinMax)
    {
        Assert (_iLastRowIncremental);
        cR = (cRows - GetFooterRows()) - _cCalcedRows;
        i = GetNextRow(_iLastRowIncremental);
        ppRow  = &_aryRows[i];
        goto   IncrementalMinMaxEntry;
    }

    // ensure columns

    if (_aryColCalcs.Size() < cCols)
    {
        _aryColCalcs.EnsureSize(cCols);
        _aryColCalcs.SetSize(cCols);
    }

    // reset column values
    for (i = 0, pColCalc = _aryColCalcs; i < cCols; i++, pColCalc++)
    {
        pColCalc->Clear();
        CTableCol *pCol = GetCol(i);
        if (pCol && pCol->IsDisplayNone())
        {
            pColCalc->_fDisplayNone = TRUE;
        }
    }

    if (IsHistoryAvailable())
    {
        LoadHistory(pTable->_pStreamHistory, ptci);

        ClearInterface(&pTable->_pStreamHistory);

        if (_fUsingHistory)
        {
            if (cCols)
                pColLastNonVirtual = &_aryColCalcs[cCols - 1];

            MtAdd(Mt(TableHistoryUsed), +1, 0);

            goto endMinMax;
        }
        else
        {
            // load history have failed (_fUsingHistory == FALSE)
            if (_fIncrementalRecalc)
            {
                // if we are in the middle of the incremental recalc, stop it right here
                _fIncrementalRecalc = FALSE;
                if (!_fCompleted)
                {
                    // if we are not completed Ensure full MinMax path 
                    // (table will request resize at the compleetion, so we don't need to do it here).
                    _sizeMin.cx = -1;
                    _sizeMax.cx = -1;
                    goto EmergencyExit;
                }   // if we are completed then do full MinMax path now
            }
        }
    }
    else
    {
        _fUsingHistory = FALSE;
    }

    if (IsFixed())
    {
        // Set Columns Width
        CTableCol   *pCol;
        int         iSpecMinSum  = 0;
        int         iSpecedCols  = 0;
        int         iDisplayNoneCols  = 0;
        int         iBigNumber   = INT_MAX/2;
        int         iColumnWidth = 1;
        int         iColSpan;
        int         iFirstRow = GetFirstRow();
        BOOL        fSpecifiedColWidth;
        pRowLayout = _aryRows.Size()? _aryRows[iFirstRow]->RowLayoutCache(): NULL;
        int         ip;
        BOOL        fCellSpecifiedWidth;
        int         iSpan;

        if (pRowLayout && (pRowLayout->GetCells() < cCols))
        {
            pRowLayout->EnsureCells(cCols);
        }

        // go through specified columns and set the colCalcs accordingly
        for (int i = 0; i < _aryColCalcs.Size(); i++)
        {
            fCellSpecifiedWidth = FALSE;

            pCol = i < _aryCols.Size()? _aryCols[i] : NULL;
            if (pCol && pCol->IsDisplayNone())
            {
                iDisplayNoneCols++;
                continue;
            }
            if (pCol && !pCol->IsDisplayNone())
            {
                Assert(pCol->_iCol  == i);  // sanity check
                iColSpan = pCol->Cols();
                Assert (iColSpan >= 1);
                pNode = pCol->GetFirstBranch();
                // Get col's width (table is always horizontal => physical width)
                puvWidth = (const CWidthUnitValue *)&pNode->GetFancyFormat()->GetWidth();
                fSpecifiedColWidth = puvWidth->IsSpecified();
            }
            else
            {
                iColSpan = 1;
                fSpecifiedColWidth = FALSE;
            }

            if (   !fSpecifiedColWidth 
                && ((pCol && iColSpan == 1) || !pCol)
                && pRowLayout 
                && IsReal(pRowLayout->_aryCells[i]))
            {
                pCell = Cell(pRowLayout->_aryCells[i]);
                Assert (pCell);
                pNode = pCell->GetFirstBranch();
                // Get cell's width in table coordinate system (table is always horizontal => physical width)
                puvWidth = (const CWidthUnitValue *)&pNode->GetFancyFormat()->GetWidth();
                fSpecifiedColWidth = puvWidth->IsSpecified();
                if (fSpecifiedColWidth)
                {
                    iColSpan = pCell->ColSpan();
                    fCellSpecifiedWidth = TRUE;
                }
            }
            if (fSpecifiedColWidth)
            {
                if (puvWidth->IsSpecifiedInPixel())
                {
                    iPixelWidth = puvWidth->GetPixelWidth(ptci, pTable); 
                    if (    fStrictCSS1Document 
                        &&  IsReal(pRowLayout->_aryCells[i])    )
                    {
                        pCellLayout = Cell(pRowLayout->_aryCells[i])->Layout(ptci->GetLayoutContext());
                        
                        // Table is always horizontal => fVerticalLayoutFlow = FALSE
                        iPixelWidth += pCellLayout->GetBorderAndPaddingWidth(ptci, FALSE);
                    }
                }
                else
                {
                    ip = puvWidth->GetPercent();
                    iPixelWidth = _sizeParent.cx*ip/100;
                }
                iColumnWidth = iPixelWidth;

                if (fCellSpecifiedWidth)
                {
                    iColumnWidth /= iColSpan;
                    iSpan = iColSpan;
                }
                else
                {
                    iSpan = 1;
                }

                for (int j = 0 ; j < iColSpan; j++)
                {
                    pColCalc = &_aryColCalcs[i + j];
                    // if it is a cell specified width with the colSpan > 1 and it is the last column, then
                    if (fCellSpecifiedWidth && iColSpan > 1 && j == iColSpan - 1)
                    {
                        // this is the size of the last column
                        iColumnWidth = iPixelWidth - (iColSpan - 1)*iColumnWidth;
                    }
                    pColCalc->AdjustForCol(puvWidth, iColumnWidth, ptci, iSpan);
                    iSpecedCols++;
                }
                iSpecMinSum += iPixelWidth;

            }
            _fCols = _fCols && fSpecifiedColWidth;

            i += iColSpan - 1;
        }

        // If any columns didn't specify a width, set their min to 1 (almost zero) and
        // their max to infinity (sums maximally add up to INT_MAX/2).  These values
        // make CTableLayout::CalculateColumns distribute any available width equally
        // among the unspecified columns.
        if (cCols - iSpecedCols - iDisplayNoneCols)
        {
            Assert (iSpecedCols < cCols);

            iColumnWidth = max(1, (iBigNumber - iSpecMinSum)/(cCols - iSpecedCols));

            for (cC = cCols, pColCalc = _aryColCalcs;
                cC > 0;
                cC--, pColCalc++)
            {
                if (pColCalc->_fDisplayNone)
                    continue;
                if (!pColCalc->IsWidthSpecified())
                {
                    pColCalc->_xMin = 1;
                    pColCalc->_xMax = iColumnWidth;
                }
            }
        }

        if (cCols)
            pColLastNonVirtual = &_aryColCalcs[cCols - 1];

        goto endMinMax;
    }


    // this variables are set for the case of non incremental MinMax calculation.
    cR = cRows;
    ppRow = _aryRows;

IncrementalMinMaxEntry:
    if (_cNestedLevel > SECURE_NESTED_LEVEL)
    {
        if (cCols)
            pColLastNonVirtual = &_aryColCalcs[cCols - 1];
        goto endMinMax;
    }

    //
    // Determine the number of fixed size columns (if any)
    // (If the COLS attribute is specified, assume the user intended
    //  for it to work and disregard any differences between the
    //  the number of columns specified through it and those
    //  actually in the table)
    //

    // collect min/max information for all the cells and columns
    // (it is safe to directly walk the row array since the order in which
    //  header/body/footer rows are encountered makes no difference)

    _fZeroWidth  = TRUE;

    for ( ;     // cR and ppRow must be set (look above for the comment)
        cR > 0;
        cR--, ppRow++)
    {
        pRowLayout = (*ppRow)->RowLayoutCache();

        // Ensure the row contains an entry for all columns
        // (It will not if subsequent rows have more cells)
        if (pRowLayout->GetCells() < cCols)
        {
            pRowLayout->EnsureCells(cCols);
        }

        pRowLayout->_uvHeight.SetNull();

        Assert(pRowLayout->GetCells() == cCols);
        ppCell = pRowLayout->_aryCells;

        fRowDisplayNone = pRowLayout->GetFirstBranch()->IsDisplayNone();

        //  (bug #110409) This is a fix for crash in CFlowLayout::CalcSozeCore() .
        //  Generally in minmax mode we do not calc percent size of children. 
        //  But if APE is nested and has percent height we'd better have 
        //  CTableCalcInfo members initialized : 
        ptci->_pRow = *ppRow;
        ptci->_pFFRow = (*ppRow)->GetFirstBranch()->GetFancyFormat();
        ptci->_pRowLayout = (CTableRowLayoutBlock *)(*ppRow)->GetUpdatedLayout(ptci->GetLayoutContext());

        for (cC = cCols, pColCalc = _aryColCalcs ;
             cC > 0;
             cC -= cColSpan, ppCell += cColSpan, pColCalc += cColSpan)
        {
            if (pColCalc->IsDisplayNone())
            {
                cColSpan = 1;
                continue;
            }
            pCell = Cell(*ppCell);

            if (IsReal(*ppCell))
            {
                pCellLayout = pCell->Layout(ptci->GetLayoutContext());
                if (pColCalc > pColLastNonVirtual)
                {
                    pColLastNonVirtual = pColCalc;
                }

                cColSpan = pCell->ColSpan();

                // if row style is display==none, don't calculate min-max for it's cells
                if (fRowDisplayNone)
                    continue;

                cRowSpan = pCell->RowSpan();
                pNode = pCell->GetFirstBranch();
                // Table is always horizontal => fVerticalLayoutFlow = FALSE
                iPixelWidth = pCellLayout->GetSpecifiedPixelWidth(ptci, FALSE);
                // Get cell's width in table coordinate system (table is always horizontal => physical width)
                puvWidth = (const CWidthUnitValue *)&pNode->GetFancyFormat()->GetWidth();

                if (cR == cRows)
                {
                    pColCalc->_fWidthInFirstRow = puvWidth->IsSpecified();

                    for (iCS = 1, pColCalcSpanned = pColCalc + 1;
                         iCS < cColSpan;
                         iCS++, pColCalcSpanned++)
                    {
                        pColCalcSpanned->_fWidthInFirstRow = pColCalc->_fWidthInFirstRow;
                    }
                }

                fMinMaxCell        = (cC <= cUnsizedCols           ||
                                      !pColCalc->_fWidthInFirstRow ||
                                      (cR == cRows && puvWidth->IsSpecifiedInPercent()));
                _fCols = _fCols && !fMinMaxCell;

                //
                // For fixed size columns, use the supplied width for their min/max
                // (But ensure it is no less than that needed to display borders)
                //

                if (!fMinMaxCell)
                {
                    if (cR == cRows)
                    {
                        // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingModeUsed = FALSE
                        xMin =
                        xMax = puvWidth->GetPixelWidth(ptci, pTable, 0) + pCellLayout->GetBorderAndPaddingWidth(ptci, FALSE);
                    }
                    else
                    {
                        xMin =
                        xMax = pColCalc->_xMax;
                    }
                }

                //
                // For non-fixed size columns, determine their min/max values
                //

                if (fMinMaxCell || fAlwaysMinMaxCells)
                {
                    WHEN_DBG ( BOOL fNeededMinWidth = FALSE; )

                    //
                    // Attempt to get min/max in a single pass
                    //

                    if (   fAlwaysMinMaxCells 
                        || (   (_fHavePercentageInset || (_fForceMinMaxOnResize && pCellLayout->_fForceMinMaxOnResize))  
                            && pCellLayout->_fMinMaxValid) )
                    {
                        pCellLayout->_sizeMax.SetSize(-1, -1);
                        pCellLayout->_sizeMin.SetSize(-1, -1);
                        pCellLayout->_fMinMaxValid = FALSE;
                    }
                    CalculateCellMinMax(pCellLayout, ptci, &size);
                    if (_fZeroWidth && !pCellLayout->NoContent())
                        _fZeroWidth = FALSE;

                    // if cell has a space followed by <br>, if we would have used history the text would create an extra 
                    // line for that <br>, since we would give the text exact width and it breaks after the space and then
                    // creates another line when it encounters <br> 
                    // ( it doesn't do look aside for <br> to catch this situation). bug #49599
                    if (pCellLayout->GetDisplay()->GetNavHackPossible())
                    {
                        _fDontSaveHistory = TRUE;
                        // _fForceMinMaxOnResize = TRUE;  // set it only during NATURAL calc, since we don't want to do minmax more then once.
                        pCellLayout->_fForceMinMaxOnResize = TRUE;  
                    }
                    else
                    {
                        pCellLayout->_fForceMinMaxOnResize = FALSE;
                    }


                    //
                    // If minimum width could not be reliably calculated, request it again
                    //

                    if (    pCellLayout->_fAlignedLayouts 
#if DBG == 1
                        ||  IsTagEnabled(tagTableSize)
#endif
                       )
                    {
                        SIZE sizeMin;
                        sizeMin.cx = sizeMin.cy = 0;

                        WHEN_DBG ( fNeededMinWidth = TRUE; )
                        CalculateCellMin(pCellLayout, ptci, &sizeMin);
#if DBG == 1
                        Assert(!IsTagEnabled(tagTableSize) || sizeMin.cx == size.cy);
                        Assert(!IsTagEnabled(tagTableMinAssert));
#endif

                        size.cy = max(sizeMin.cx, size.cy);
                        // we need to set correct value for _sizeMin, so next time FlowLayout returns correct min value
                        if (pCellLayout->_sizeMin.cu != size.cy)
                            pCellLayout->_sizeMin.SetSize(size.cy, -1);
                    }

                    //
                    // For normal min/max cases, use the returned value
                    //

                    if (fMinMaxCell)
                    {
                        xMax = size.cx;
                        xMin = size.cy;
                        Assert (fNeededMinWidth || xMax >= xMin);

//                        if (pCellLayout->IsWhiteSpacesOnly())
//                        {
//                            xMin = 0;
//                        }

                        // If a user set value exists, set the cell's maximum value
                        if (cC <= cUnsizedCols && puvWidth->IsSpecified() && puvWidth->IsSpecifiedInPixel() && iPixelWidth)
                        {
                            xMax = iPixelWidth;
                            // Ensure supplied width is not less than that of the minimum content width
                        }
                        if (xMax < xMin)
                        {
                            xMax = xMin;
                        }
                    }

                    //
                    // For fixed size cells, increase the min/max only
                    // if the calculated min is greater
                    //

                    else
                    {
                        Assert(cC > cUnsizedCols);
                        xMin =
                        xMax = max((long)xMax, size.cy);
                    }
                }


                //
                // For non-spanned cells, move the min/max (and possibly the
                // specified width) into the column structure
                //

                if (cColSpan == 1)
                {
                    pColCalc->AdjustForCell(this, iPixelWidth, puvWidth,
                                        (cC <= cUnsizedCols || !pColCalc->_fWidthInFirstRow),
                                        cR == cRows, ptci, xMin, xMax);
                }

                //
                // For spanned cells, distribute the width over the affected cells
                //

                else
                {

                    // if the spanned cell is exactly at the end of the table, then it is a potential
                    // case gor ignoring colSpans
                    if (cCols - cC == _iLastNonVirtualCol)
                    {
                        aryReducedSpannedCells.Append(pCell);
                    }

                    // Netscape compatibility (garantee for 1 + _xCellSpacing pixels per column)
                    int iMakeMeLikeNetscape = (cColSpan - 1)*(_xCellSpacing + 1);
                    if (iMakeMeLikeNetscape > pCellLayout->_sizeMin.cu)
                    {
                        pCellLayout->_sizeMax.SetSize(pCellLayout->_sizeMax.cu + iMakeMeLikeNetscape - pCellLayout->_sizeMin.cu, -1);
                        pCellLayout->_sizeMin.SetSize(iMakeMeLikeNetscape, -1);
                    }

                    //
                    // For non-fixed size spanned cells, simply note that the cell spans
                    // (The distribution cannot take place until after all cells in the
                    //  all the rows are have their min/max values determined)
                    //

                    if (    (   cC <= cUnsizedCols
                            || (    fMinMaxCell
                                &&  cR == cRows))
                        ||  (   (fAlwaysMinMaxCells)
                            &&  cR != cRows))
                    {
                        cSpanned++;
                        Assert (!pCellLayout->GetFirstBranch()->IsDisplayNone());
                        Assert(pCellLayout->_fMinMaxValid);
                        // NETSCAPE: uses special algorithm for calculating min/max of virtual columns
                        for (iCS = 0, pColCalcSpanned = pColCalc; iCS < cColSpan; iCS++, pColCalcSpanned++)
                        {
                            pColCalcSpanned->_cVirtualSpan++;
                        }
                    }

                    //
                    // For fixed size cells, distribute the space immediately
                    // (Fixed size cells whose widths are either unspecified or are
                    //  a percentage will have their widths set during CalculateColumns)
                    //

                    else if (!fMinMaxCell && cR == cRows)
                    {
                        Assert(cC > cUnsizedCols);

                        cxWidth       = xMax;
                        cSizedColSpan = min(cColSpan, _cSizedCols - (cCols - cC));

                        //
                        // Divide the user width over the affected columns
                        //

                        dxRemainder  = cxWidth - ((cSizedColSpan - 1) * _xCellSpacing);
                        cxWidth      = dxRemainder / cSizedColSpan;
                        dxRemainder -= cxWidth * cSizedColSpan;

                        //
                        // Set the min/max and width of the affected columns
                        //

                        Assert(cSizedColSpan <= (_aryColCalcs.Size() - (pColCalc - (CTableColCalc *)&_aryColCalcs[0])));
                        pSizedColCalc = pColCalc;

                        do
                        {

                            pSizedColCalc->Set(cxWidth + (dxRemainder > 0
                                                            ? 1
                                                            : 0));
                            if (pSizedColCalc > pColLastNonVirtual)
                            {
                                pColLastNonVirtual = pSizedColCalc;
                            }
                            pSizedColCalc++;
                            cSizedColSpan--;
                            dxRemainder--;

                        } while (cSizedColSpan);
                    }
                }

                if (!fStrictCSS1Document && cRowSpan == 1)
                {
                    pRowLayout->AdjustHeight(pNode, ptci, pTable);
                }
            }
            else
            {
                cColSpan = 1;
            }
            Assert(pColCalc->_xMin <= pColCalc->_xMax);
        }
    }

    //
    // If cells were spanned, check them again now
    //

    if (cSpanned)
    {
        cReducedSpannedCells = 0;
        for (int i=0; i < aryReducedSpannedCells.Size(); i++)
        {
            pCell = aryReducedSpannedCells[i];
            pCellLayout = pCell->Layout(ptci->GetLayoutContext());

            pColCalc = _aryColCalcs;
            pColCalc += pCell->ColIndex();
            cColSpan = pCell->ColSpan();
            BOOL fIgnoreSpan = TRUE;
            if (pColCalc->_cVirtualSpan != 1)
            {
                CTableColCalc *pColCalcSpannedPrev = pColCalc;
                pColCalcSpanned = pColCalc + 1;
                for (iCS = 1; iCS < cColSpan; iCS++, pColCalcSpanned++)
                {
                    Assert (pColCalcSpanned->_cVirtualSpan <= pColCalcSpannedPrev->_cVirtualSpan);
                    if (pColCalcSpanned->_cVirtualSpan !=
                        pColCalcSpannedPrev->_cVirtualSpan)
                    {
                        fIgnoreSpan = FALSE;
                        pColLastNonVirtual = pColCalcSpanned;
                    }
                    pColCalcSpannedPrev = pColCalcSpanned;
                }
            } // else we can ignore the SPAN
            if (fIgnoreSpan)
            {
                // Table is always horizontal => fVerticalLayoutFlow = FALSE
                iPixelWidth = pCellLayout->GetSpecifiedPixelWidth(ptci, FALSE);
                // Get cell's width in table coordinate system (table is always horizontal => physical width)
                puvWidth = (const CWidthUnitValue *)&pCell->GetFirstBranch()->GetFancyFormat()->GetWidth();
                pColCalc->AdjustForCell(this, iPixelWidth, puvWidth, TRUE, TRUE, ptci, pCellLayout->_sizeMin.cu, pCellLayout->_sizeMax.cu);
                cReducedSpannedCells++;
            }
        }
        if (cSpanned - cReducedSpannedCells)
        {
            AdjustForColSpan(ptci, pColLastNonVirtual, fIncrementalMinMax);
        }
    }

    if (   (_fCompleted && _fCalcedOnce)    // if min max path was more then once,
        || ptci->_fDontSaveHistory)         // or there are still not loaded images
    {
        _fDontSaveHistory = TRUE;           // then don't save the history.
    }

endMinMax:

    if (_pAbsolutePositionCells)
    {
        CTableCellLayout *pCellLayout;
        CTableCell      **ppCell;
        int               cCells;
        for (cCells = _pAbsolutePositionCells->Size(), ppCell = *_pAbsolutePositionCells ;  cCells > 0; cCells--, ppCell++)
        {
            pCellLayout = (*ppCell)->Layout(ptci->GetLayoutContext());
            CalculateCellMinMax(pCellLayout, ptci, &size);
        }
    }

    // calculate min/max table width and height

    xMin = xMax = 0;

    // sum up columns and check width

    if (cCols)
    {
        for (pColCalc = _aryColCalcs; pColCalc <= pColLastNonVirtual; pColCalc++)
        {
            xMin += pColCalc->_xMin;
            xMax += pColCalc->_xMax;
            if (!_fUsingHistory && !pColCalc->_fVirtualSpan && !pColCalc->IsDisplayNone())
            {
                _cNonVirtualCols++;
            }
        }
    }

    if (_sizeMin.cx < xMin)
    {
        _sizeMin.cx = xMin;
    }
    if (_sizeMax.cx < xMax)
    {
        _sizeMax.cx = xMax;
    }

    // add border space and padding

    if (_sizeMin.cx != 0 || _sizeMax.cx != 0)
    {
        // NETSCAPE: doesn't add the border or spacing if the table is empty.

        xTablePadding = _aiBorderWidths[SIDE_RIGHT] + _aiBorderWidths[SIDE_LEFT] + _cNonVirtualCols * _xCellSpacing + _xCellSpacing;
        _sizeMin.cx += xTablePadding;
        _sizeMax.cx += xTablePadding;
    }

    if (fCookUpEmbeddedTableWidthForNetscapeCompatibility)
    {
        if ( _sizeMax.cx < xTableWidth ||
             (_cNonVirtualCols == 1 && !(--pColCalc)->IsWidthSpecifiedInPixel()))
        {
            xTableWidth = 0;    //  DON'T CookUpEmbeddedTableWidthForNetscapeCompatibility
        }
    }

    // check if caption forces bigger width

    // NOTE:   NETSCAPE: does not grow the table width to match that of the caption, yet
    //         we do. If this becomes a problem, we can alter the table code to maintain
    //         a larger RECT which includes both the caption and table while the table
    //         itself is rendered within that RECT to its normal size. I've avoided adding
    //         this for now since it is not trivial. (brendand)

    for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
         cC > 0;
         cC--, ppCaption++)
    {
        CTableCellLayout *pCaptionLayout = (*ppCaption)->Layout(ptci->GetLayoutContext());

        // Captions don't always have/need layout (replacing the above call w/ GetUpdatedLayout() doesn't
        // necessarily result in a layout ptr).  Added if() check; bug #75543.
        if ( pCaptionLayout )
        {
            pCaptionLayout->CalcSize(ptci, &size);

            if (_fZeroWidth && !pCaptionLayout->NoContent())
                _fZeroWidth = FALSE;

            if (_sizeMin.cx < size.cy)
            {
                _sizeMin.cx = size.cy;
            }

            // NETSCAPE: Ensure the table is wide enough for the minimum CAPTION width only
            //           (see above comments) (brendand)
            if (_sizeMax.cx < size.cy)
            {
                _sizeMax.cx = size.cy;

            }

            // If the table contains only a CAPTION, then use its maximum width for the table
            if (!GetRows() && _sizeMax.cx < size.cx)
            {
                _sizeMax.cx = size.cx;
            }

            /*
            _sizeMin.cy += size.cy;
            _sizeMax.cy += size.cy;
            */
        }
    }


    // If user specified the width of the table, we want to restrict max to the
    // specified width.
    // NS/IE compatibility, any value <= 0 is treated as <not present>
    if (xTableWidth)
    {
        if (xTableWidth > _sizeMin.cx)
        {
            _sizeMin.cx =
            _sizeMax.cx = xTableWidth;
        }
    }

    Assert(_sizeMin.cx <= _sizeMax.cx);

EmergencyExit:
    ptci->_smMode = smMode; // restore

    PerfLog(tagTableMinMax, this, "-CalculateMinMax");
}


//+-------------------------------------------------------------------------
//
//  Method:     AdjustForColSpan
//
//  Synopsis:
//
//--------------------------------------------------------------------------

void
CTableLayout::AdjustForColSpan(CTableCalcInfo * ptci, CTableColCalc *pColLastNonVirtual, BOOL fIncrementalMinMax)
{
    int             cR, cC;
    int             iCS;
    CTableColCalc * pColCalc=0;
    CTableColCalc * pColCalcLast=0;
    CTableColCalc * pColCalcBase;
    int             cCols = GetCols();
    CTableRow **    ppRow;
    CTableRowLayout * pRowLayout;
    int             cRows = GetRows();
    CTableCell **   ppCell;
    CTableCell *    pCell;
    CTableCellLayout * pCellLayout;
    int             cColSpan, cRowSpan;
    int             xMin, xMax;
    int             cUnsizedCols;
    const CWidthUnitValue * puvWidth = NULL;
    CTable      *   pTable = ptci->Table();
    BOOL            fAlwaysMinMaxCells =  _fAlwaysMinMaxCells || ((ptci->_grfLayout & LAYOUT_FORCE) && _cSizedCols);

    cUnsizedCols = cCols - _cSizedCols;

    //
    // have to run through again and check column widths for spanned cells
    // if the sum of widths of the spanned columns are smaller then the
    // width of the cell we have to distribute the extra width
    // amongst the columns to make sure the cell will fit
    // (it is safe to directly walk the row array since the order in which
    //  header/body/footer rows are encountered makes no difference)
    //

    if (fIncrementalMinMax)
    {
        Assert (_iLastRowIncremental);
        cR = (cRows - GetFooterRows()) - _cCalcedRows;
        int i = GetNextRow(_iLastRowIncremental);
        ppRow  = &_aryRows[i];
    }
    else
    {
        cR = cRows;
        ppRow = _aryRows;
    }
    for ( ; cR > 0; cR--, ppRow++)
    {
        pRowLayout = (*ppRow)->RowLayoutCache();
        Assert(pRowLayout);

        if (pRowLayout->IsDisplayNone())
            continue;

        Assert(pRowLayout->GetCells() == cCols);
        ppCell = pRowLayout->_aryCells;

        for (cC = cCols, pColCalcBase = _aryColCalcs;
            cC > 0;
            cC -= cColSpan, ppCell += cColSpan, pColCalcBase += cColSpan)
        {
            if (pColCalcBase->IsDisplayNone())
            {
                cColSpan = 1;
                continue;
            }
            pCell = Cell(*ppCell);

            if (!IsReal(*ppCell))
            {
                cColSpan = 1;
            }
            else
            {
                pCellLayout = pCell->Layout(ptci->GetLayoutContext());
                cColSpan = pCell->ColSpan();
                cRowSpan = pCell->RowSpan();

                // if the cell spans across multiple columns
                Assert (pColCalcBase <= pColLastNonVirtual);
                if (cColSpan > 1 &&
                    (fAlwaysMinMaxCells || cC <= cUnsizedCols) &&
                    pColCalcBase < pColLastNonVirtual)
                {
                    //
                    // cell is spanned, get min and max size and distribute it amongst columns
                    //

                    int iWidth = 0;     // Width (user specified) of this cell
                    int iWidthMin = 0;  // Min width of all the columns spanned accross this cell
                    int iWidthMax = 0;  // Max width of all the columns spanned accross this cell

                    int iUser = 0;      // Width of the pixel's (user) specified columns spanned accross this cell
                    int iUserMin = 0;   // Min width of those columns
                    int iUserMax = 0;   // Max width of those columns
                    int cUser = 0;      // Number of spanned columns that specified pixel's width

                    int iPercent = 0;   // %% width of the %% specified columns spanned accross this cell
                    int iPercentMin = 0;// Min width of those columns
                    int iPercentMax = 0;// Max width of those columns
                    int cPercent = 0;   // Number of columns scpecified with %%

                    int iMax = 0;       // Max width of normal columns (no width were scpecifed)
                    int cMax = 0;       // Number of columns that need Max distribution (normal column, no width specified)

                    int iMinMaxDelta = 0; // the delta between iWidthMax and iWidthMin (all the columns)

                    int xAdjust;        // adjustment to the width of this cell to account
                                        // cell spacing
                    int iMinSum;        // calculated actual Min sum of all the columns
                    int xDistribute;    // Width to distribute between normal columns.
                    int iOriginalColMin;
                    int iOriginalColMax;
                    int cRealColSpan = cColSpan;    // colSpan which doesn't include virtual columns
                    int  cVirtualSpan = 0;    // number of virtual columns
                    BOOL fColWidthSpecified;// set if there is a width spec on column
                    BOOL fColWidthSpecifiedInPercent; // set if there is a width spec in %% on column
                    BOOL fDoNormalMax;      // Do normal Max distribution
                    BOOL fDoNormalMin;      // Do normal Min distribution
                    int  iColMinWidthAdjust;// Adjust the coulmn min by
                    int  iColMaxWidthAdjust;// Adjust the coulmn max by
                    int  iCellPercent = 0;  // the specified %% of the spanned cell
                    int  iColPercent = 0;   // the calculated %% of the column
                    int  iColsPercent = 0;  // total sum of %% for all the columns
                    int  iNormalMin = 0;    // delta between the cell's Min and all the columns Min
                    int  iNormalMax = 0;    // delta between the cell's Max and all the columns Max
                    int  iNormalMaxForPercentColumns = 0;
                    int  iNormalMinForPercentColumns = 0;
                    int  xDistributeMax;
                    int  xDistributeMin;
                    int  xPercent;
                    int  iExtraMax = 0;
                    int  iNewPercentMax = 0;
                    int  cNewPercent = 0;

                    Assert(!pCellLayout->GetFirstBranch()->IsDisplayNone());
                    Assert(pCellLayout->_fMinMaxValid);

                    //
                    // sum up percent and user width columns for later distribution
                    //

                    for (iCS = 0; iCS < cColSpan; iCS++)
                    {
                        pColCalc = pColCalcBase + iCS;  // pColCalc is the column that this Cell is spanned accross

                        if (pColCalc->IsDisplayNone())
                        {
                            cRealColSpan--;
                            continue;
                        }

                        if (pColCalc->IsWidthSpecified())
                        {   // if the size of the coulumn is set, then
                            if (pColCalc->IsWidthSpecifiedInPercent())
                            {
                                iPercent += pColCalc->GetPercentWidth();
                                iPercentMin += pColCalc->_xMin;
                                iPercentMax += pColCalc->_xMax;
                                cPercent++;
                            }
                            else
                            {
                                iUser += pColCalc->GetPixelWidth(ptci, pTable);
                                iUserMin += pColCalc->_xMin;
                                iUserMax += pColCalc->_xMax;
                                cUser++;
                            }
                        }

                        if (pColCalc->_xMax)
                        {
                            iWidthMin += pColCalc->_xMin;
                            iWidthMax += pColCalc->_xMax;
                            if (pColCalc->_fVirtualSpan)
                            {
                                // NETSCAPE: we need to account for the virtual columns
                                cVirtualSpan++;
                            }
                        }
                        else
                        {
                            if (pColCalc <= pColLastNonVirtual)
                            {
                                // NETSCAPE: we need to account for the virtual columns
                                cVirtualSpan++;
                                // NETSCAPE: For each virtual column (due to the colSpan)
                                // they give extra 1 + cellSpacing pixels
                                pColCalc->_xMin =
                                pColCalc->_xMax = _xCellSpacing + 1;
                                iWidthMin += pColCalc->_xMin;
                                iWidthMax += pColCalc->_xMax;
                            }
                            else
                            {
                                // Don't count virtual columns at the end of the table
                                // when distributing.
                                cRealColSpan--;
                            }
                        }
                    }
                    iColsPercent = iPercent;
                    iCellPercent = (cRealColSpan == cPercent) ? iColsPercent : 100;

                    // don't take cell spacing into account
                    xAdjust = (cRealColSpan - cVirtualSpan - 1) * _xCellSpacing;
                    if (xAdjust < 0)
                    {
                        xAdjust = 0;
                    }

                    xMax = pCellLayout->_sizeMax.cu;    // max width of this cell

                    // Get cell's width in table coordinate system (table is always horizontal => physical width)
                    puvWidth = (const CWidthUnitValue *)&pCell->GetFirstBranch()->GetFancyFormat()->GetWidth();

                    // use user set value if set
                    if (puvWidth->IsSpecified() && puvWidth->IsSpecifiedInPixel())
                    {
                        iWidth = puvWidth->GetPixelWidth(ptci, pTable);
                        if (iWidth < 0)
                        {
                            iWidth = 0;
                        }

                        if(xMax < iWidth)
                        {
                            xMax = iWidth;
                        }
                    }
                    xMin = pCellLayout->_sizeMin.cu;    // min width of this cell

                    Assert(xMax >= 0);
                    Assert(xMin >= 0);

                    if (xMax < xMin)
                    {
                        xMax = xMin;
                    }

                    cMax = cRealColSpan - cPercent - cUser;
                    iMax = iWidthMax - iPercentMax - iUserMax;

                    xDistribute = xMax;

                    //
                    // Now check if the cell width is specified by the user
                    //
                    if (puvWidth->IsSpecified())
                    {
                        if (puvWidth->IsSpecifiedInPercent())
                        {
                            // if there is percentage over distribute it
                            // amongst the non-percent columns
                            iCellPercent = puvWidth->GetPercent();
                            iPercent = iCellPercent - iColsPercent;
                            if (iPercent < 0)
                            {
                                iPercent = 0;
                            }
                            iUser = 0;
                        }
                        else
                        {
                            // if there is width over the user set widths and the percentage
                            // distribute it amongst the normal columns
                            iUser =  iWidth - MulDivQuick(iWidth, iPercent, iCellPercent) - iUser;
                            if (iUser < 0)
                            {
                                iUser = 0;
                            }
                            iPercent = 0;
                            xDistribute = iWidth;
                        }
                    }
                    else
                    {
                        iUser = 0;
                        iPercent = 0;
                    }

                    //---------------------------------------------
                    // 1. DO MIN and %% DISTRIBUTION
                    //---------------------------------------------
                    if (cPercent)
                    {
                        if (iCellPercent < iColsPercent)
                        {
                            iCellPercent = iColsPercent;
                        }
                        if (xDistribute - xAdjust - iWidthMax > 0)
                        {
                            iNormalMaxForPercentColumns = MulDivQuick(xDistribute - xAdjust, iColsPercent, iCellPercent) - iPercentMax;
                            if (iNormalMaxForPercentColumns < 0)
                            {
                                iNormalMaxForPercentColumns = 0;
                            }
                            iNormalMax = MulDivQuick(xDistribute - xAdjust, iCellPercent - iColsPercent, iCellPercent) - (iWidthMax - iPercentMax);
                            if (iNormalMax < 0)
                            {
                                iNormalMax = 0;
                            }
                        }
                        if (xMin - xAdjust - iWidthMin > 0)
                        {
                            iNormalMinForPercentColumns = MulDivQuick(xMin - xAdjust, iColsPercent, iCellPercent) - iPercentMin;
                            if (iNormalMinForPercentColumns < 0)
                            {
                                iNormalMinForPercentColumns = 0;
                            }
                            iNormalMin = MulDivQuick(xMin - xAdjust, iCellPercent - iColsPercent, iCellPercent) - (iWidthMin - iPercentMin);
                            if (iNormalMin < 0)
                            {
                                iNormalMin = 0;
                            }
                        }
                    }
                    else
                    {
                        Assert (iPercentMin == 0 && iPercentMax == 0);

                        // if the spanned cell min width is greater then width of the spanned columns, then set the iNormalMin
                        if (xMin - xAdjust - iWidthMin > 0)
                        {
                            iNormalMin = xMin - xAdjust - iWidthMin;
                        }

                        // only adjust max if there is a normal column without the width set
                        if (xDistribute - xAdjust - iWidthMax > 0)
                        {
                            iNormalMax = xDistribute - xAdjust - iWidthMax;
                        }
                    }

                    iMinMaxDelta = (iWidthMax - iPercentMax) - (iWidthMin - iPercentMin);
                    if (iMinMaxDelta < 0)
                    {
                        iMinMaxDelta = 0;
                    }

                    //
                    // go thru the columns and adjust the widths
                    //
                    iMinSum = 0;
                    for (iCS = 0; iCS < cRealColSpan; iCS++)
                    {
                        iColMinWidthAdjust = 0; // Adjust the coulmn min by
                        iColMaxWidthAdjust = 0; // Adjust the coulmn max by

                        pColCalc = pColCalcBase + iCS;
                        if (pColCalc->IsDisplayNone())
                        {
                            continue;
                        }
                        fColWidthSpecified = pColCalc->IsWidthSpecified();
                        fColWidthSpecifiedInPercent = pColCalc->IsWidthSpecifiedInPercent();
                        fDoNormalMax = fColWidthSpecifiedInPercent? (iNormalMaxForPercentColumns != 0)
                                                                  : (iNormalMax != 0);      // Do normal Max distribution
                        fDoNormalMin = fColWidthSpecifiedInPercent? (iNormalMinForPercentColumns != 0)
                                                                  : (iNormalMin != 0);      // Do normal Min distribution
                        iOriginalColMin = pColCalc->_xMin;
                        iOriginalColMax = pColCalc->_xMax;

                        if ((iPercent && !fColWidthSpecifiedInPercent) || fColWidthSpecifiedInPercent)
                        {
                            // Do distribution of Min Max for %% columns
                            if (fColWidthSpecifiedInPercent)
                            {
                                iColPercent = pColCalc->GetPercentWidth();
                                xDistributeMax = iNormalMaxForPercentColumns + iPercentMax;
                                xDistributeMin = iNormalMinForPercentColumns + iPercentMin;
                                xPercent = iColsPercent;
                            }
                            else
                            {
                                // set percent if overall is percent width
                                Assert (cRealColSpan - cPercent > 0);
                                iColPercent =
                                    iWidthMax - iPercentMax
                                        ? MulDivQuick(iOriginalColMax, iPercent, iWidthMax - iPercentMax)
                                        : MulDivQuick(iPercent, 1, cRealColSpan - cPercent); // use MulDivQuick to round up...
                                pColCalc->SetPercentWidth(iColPercent);
                                xDistributeMax = iNormalMax + iWidthMax - iPercentMax;
                                xDistributeMin = iNormalMin + iWidthMin - iPercentMin;
                                xPercent = iPercent;
                            }

                            if (fDoNormalMax)
                            {
                                Assert (xPercent);
                                int iNewColMax = MulDivQuick(xDistributeMax, iColPercent, xPercent);
                                if (iNewColMax > pColCalc->_xMax)
                                {
                                    pColCalc->_xMax = iNewColMax;
                                }
                                fDoNormalMax = FALSE;
                            }
                            if (fDoNormalMin)
                            {
                                int iNewColMin = MulDivQuick(xDistributeMin, iColPercent, xPercent);
                                if (iNewColMin > pColCalc->_xMin)
                                {
                                    pColCalc->_xMin = iNewColMin;
                                }
                                fDoNormalMin = FALSE;
                            }
                            if (pColCalc->_xMin > pColCalc->_xMax)
                            {
                                pColCalc->_xMax = pColCalc->_xMin;
                            }
                            iNewPercentMax += pColCalc->_xMax;
                            cNewPercent++;
                        }

                        if (fDoNormalMin)
                        {
                            iColMinWidthAdjust =
                                fDoNormalMax
                                ? MulDivQuick(iOriginalColMax, iNormalMin, iWidthMax - iPercentMax)
                                : iMinMaxDelta
                                    ? MulDivQuick(iOriginalColMax - iOriginalColMin, iNormalMin, iMinMaxDelta)
                                    : iWidthMin - iPercentMin
                                        ? MulDivQuick(iOriginalColMin, iNormalMin, iWidthMin - iPercentMin)
                                        : MulDivQuick(iNormalMin, 1, cRealColSpan - cPercent); // use MulDivQuick to round up...
                        }

                        //if (!pColCalc->_fVirtualSpan)
                        //{
                            if (iCS > cRealColSpan - cVirtualSpan)
                            {
                                // Note: the first virtual column is not cet as being VirtualSpan
                                // Netscape: virtual columns min/max is calculated only once!
                                pColCalc->_fVirtualSpan = TRUE;
                                pColCalc->_pCell = pCell;
                            }
                            pColCalc->_xMin += iColMinWidthAdjust;
                        //}
                        if (pColCalc->_xMin > pColCalc->_xMax)
                        {
                            // make sure that by distrubuting extra into columns _xMin we didn't exeed _xMax
                            pColCalc->_xMax = pColCalc->_xMin;

                            //NETSCAPE: if the new MAX is greater and the column width was set from the cell,
                            //          don't propagate the user's width to the column.
                            if (pColCalc->_fWidthFromCell && pColCalc->IsWidthSpecifiedInPixel() && !puvWidth->IsSpecified())
                            {
                                // reset the column uvWidth
                                pColCalc->_fDontSetWidthFromCell = TRUE;
                                pColCalc->ResetWidth();
                            }
                            iExtraMax += pColCalc->_xMax - iOriginalColMax;
                        }
                        iMinSum += pColCalc->_xMin;
                    }

                    Assert (pColCalc->_xMin >=0 && pColCalc->_xMax >= 0);

                    // if the sum of all the column's Mins is less then the cell's min then
                    // adjust all the  columns...
                    if ((iMinSum -= xMin - xAdjust) < 0)
                    {
                        pColCalc->_xMin -= iMinSum; // adjust min of last column
                        // this will adjust col max to user setting
                        if (pColCalc->_xMin > pColCalc->_xMax)
                        {
                            iExtraMax += pColCalc->_xMin - pColCalc->_xMax;
                            pColCalc->_xMax = pColCalc->_xMin;
                        }
                    }
                    Assert (pColCalc->_xMin >=0 && pColCalc->_xMax >= 0);

                    pColCalcLast = pColCalc;
                    //---------------------------------------------
                    // 2. DO MAX DISTRIBUTION
                    //---------------------------------------------
                    // only adjust max if there is a normal column without the width set
                    iNormalMax = xDistribute - xAdjust - (iWidthMax + iExtraMax + iNewPercentMax - iPercentMax);
                    if (iNormalMax > 0)
                    {
                        //
                        // go thru the columns and adjust the widths
                        //
                        iMinSum = 0;    // just reusing variable, in this context it means the sum of adjustments
                        for (iCS = 0; iCS < cRealColSpan; iCS++)
                        {
                            iColMaxWidthAdjust = 0; // Adjust the coulmn max by

                            pColCalc = pColCalcBase + iCS;
                            if (pColCalc->IsDisplayNone())
                                continue;
                            fColWidthSpecified = pColCalc->IsWidthSpecified();
                            fColWidthSpecifiedInPercent = pColCalc->IsWidthSpecifiedInPercent();
                            fDoNormalMax = !fColWidthSpecifiedInPercent;
                            iOriginalColMax = pColCalc->_xMax;

                            if (fDoNormalMax)
                            {
                                // adjust pColCalc max later because it can effect min calculation down here...
                                iColMaxWidthAdjust =
                                  iWidthMax + iExtraMax - iPercentMax
                                    ? MulDivQuick(iOriginalColMax, iNormalMax, iWidthMax + iExtraMax - iPercentMax)
                                    : MulDivQuick(iNormalMax, 1, cRealColSpan - cNewPercent); // use MulDivQuick to round up...

                                // if (!pColCalc->_fVirtualSpan) // || pColCalc->_pCell == pCell)
                                // {
                                    pColCalc->_xMax += iColMaxWidthAdjust;
                                    iMinSum += iColMaxWidthAdjust;
                                    pColCalcLast = pColCalc;

                                    //NETSCAPE: if the new MAX is greater and the column width was set from the cell,
                                    //          don't propagate the user's width to the column.
                                    if (pColCalc->_fWidthFromCell && pColCalc->IsWidthSpecifiedInPixel() && !puvWidth->IsSpecified() && iColMaxWidthAdjust)
                                    {
                                        // reset the column uvWidth
                                        pColCalc->_fDontSetWidthFromCell = TRUE;
                                        pColCalc->ResetWidth();
                                    }
                                // }
                            }
                        }
                        if (iMinSum < iNormalMax && pColCalcLast)
                        {
                            // adjust last column
                            pColCalcLast->_xMax += iNormalMax - iMinSum;
                        }
                    }
                }
            }
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     SetCellPositions
//
//  Synopsis:   Set the final cell positions for the row
//
//--------------------------------------------------------------------------

void
CTableLayout::SetCellPositions(
    CTableCalcInfo * ptci,
    long        xTableWidth, 
    BOOL        fPositionSpannedCell, 
    BOOL        fSizeSpannedCell)
{
    Assert(ptci->GetLayoutContext() || (!fPositionSpannedCell && !fSizeSpannedCell));

    CTableRow * pRow = ptci->_pRow;
    Assert(pRow);

    if (pRow->GetFirstBranch()->IsDisplayNone())
    {
        // (olego: bug IE6 #27391) if the row has "display: none" set, there is nothing to do here
        return;
    }

    SIZEMODE        smMode = ptci->_smMode;
    int             cyAvailSafe   = ptci->_cyAvail;
    int             yConsumedSafe = ptci->_yConsumed;
    DWORD           grfLayoutSafe = ptci->_grfLayout;
    CTableCell **   ppCell;
    CTableCell *    pCell;
    CTableCellLayout * pCellLayout;
    CDispNode *     pDispNode;
    int             cC;
    int             cCols = GetCols();
    CSize           sizeCell;
    int             iCellRowIndex;
    int             cCellRowSpan;
    CTableColCalc * pColCalc;
    CTable      *   pTable = ptci->_pTable;
    BOOL            fRTL = pTable->GetFirstBranch()->GetParaFormat()->HasRTL(TRUE);
    BOOL            fSetCellPositionOld;
    BOOL            fGlobalNormalCalcOld = ptci->_fGlobalNormalCalc;
    BOOL            fGlobalSetCalcOld = ptci->_fGlobalSetCalc;
    BOOL            fPositionParentTableGrid = IsGridAndMainDisplayNodeTheSame();
    BOOL            fStrictCSS1Document =   pTable->HasMarkupPtr() 
                                        &&  pTable->GetMarkupPtr()->IsStrictCSS1Document();
    CPoint          ptRow;

    CTableRowLayoutBlock * pRowLayout = ptci->_pRowLayout;
    CTableRowLayout * pRowLayoutCache = pRow->RowLayoutCache();
    Assert(pRowLayout && pRowLayoutCache);

    // This check tells us that in browse-mode the rowLayout is the same as the rowCache.
    // when paginating a table this is not true.
    Check((ptci->GetLayoutContext() == NULL) == (pRowLayout == pRowLayoutCache));
 
    Assert(TestLock(CElement::ELEMENTLOCK_SIZING));

    PerfLog(tagTableSet, this, "+SetCellPositions");

    ptci->_smMode = SIZEMODE_SET;

    if (fStrictCSS1Document)
    {
        // During set cell position turn LAYOUT_FORCE flag OFF 
        ptci->_grfLayout &= (DWORD)(~LAYOUT_FORCE);
    }
    
    ptRow.x = pRowLayout->GetXProposed();
    ptRow.y = pRowLayout->GetYProposed();

    if (ptci->_pFFRow->_fPositioned)
    {
        if(   ptci->_pFFRow->_bPositionType == stylePositionrelative 
           && fPositionParentTableGrid)
        {
            // Note if the relatively positioned row will be positioned by the table grid display node,
            // then we need to subtract the border width, if the row will be positioned by the table node
            // which has a caption dsiplay node inside and the table grid node, then we are fine (since
            // border is included by the table grid node).
            if(!fRTL)
                ptRow.x -= _aiBorderWidths[SIDE_LEFT];
            else
                ptRow.x += _aiBorderWidths[SIDE_RIGHT];

            ptRow.y -= _aiBorderWidths[SIDE_TOP];
        }
        
        pRow->ZChangeElement(0, &ptRow, ptci->GetLayoutContext());     
                                             // relative rows will be positioned under the MAIN table display node 
                                             // absolute rows will be positioned under the "BODY" display node 
    }

    ptci->_fIgnorePercentChild =    !fStrictCSS1Document 
                                // Next four lines check for PPV case. In PPV nothing should be ignored since 
                                // in this case no proper break info is generated as well as flags set to pci. 
                                &&  (   !ElementCanBeBroken() 
                                    ||  !ptci->GetLayoutContext() 
                                    ||  !ptci->GetLayoutContext()->ViewChain() 
                                    ||  ptci->GetLayoutContext() == GetContentMarkup()->GetCompatibleLayoutContext()    )
                                &&  !ptci->_fTableHasUserHeight
    //  Row contains the summary of height information set to row and/or any of cells belonging to it. 
    //  If the row isn't provided with height information we want to prohibit child(ren) with percentage 
    //  height to be CalcSize'd.
                                &&  !pRowLayoutCache->IsHeightSpecified() 
    //  This check is "against" CSS spec, but is needed for backward compatibility with IE 5.0 (bugs #109130; #109202)
                                &&  !ptci->_pFFRow->IsHeightPercent();


    if (!ptci->_cGlobalNestedCalcs)
    {
        //  If the table is topmost initialize global state 
        ptci->_fGlobalSetCalc = TRUE;
    }

    //  _fGlobalNormalCalc should be turned OFF 
    ptci->_fGlobalNormalCalc = FALSE;


    ppCell = pRowLayoutCache->_aryCells;
    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, ppCell++, pColCalc++)
    {
        if (pColCalc->IsDisplayNone())
            continue;
        pCell = Cell(*ppCell);
        if (pCell)
        {
            pCellLayout = pCell->Layout(ptci->GetLayoutContext()); 

            cCellRowSpan =  pCell->RowSpan();
            
            if (IsSpanned(*ppCell))
            {
                iCellRowIndex = pCell->RowIndex();
                
                // if ends in this row and this is the first column of the cell
                if ((  iCellRowIndex + cCellRowSpan - 1 == pRowLayoutCache->RowPosition() || fSizeSpannedCell)
                    && pCell->ColIndex() == cCols - cC)
                {
                    CTreeNode *pNode = pCell->GetFirstBranch();
                    const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(ptci->GetLayoutContext()));
                    const CCharFormat  *pCF = pNode->GetCharFormat(LC_TO_FC(pti->GetLayoutContext()));
                    const CUnitValue &cuvHeight = pFF->GetLogicalHeight(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                    BOOL fIgnorePercentChildSafe = ptci->_fIgnorePercentChild;

                    pCellLayout->GetApparentSize(&sizeCell);
                    sizeCell.cy = ptRow.y + pRowLayout->_yHeight - pCellLayout->GetYProposed();

                    fSetCellPositionOld = ptci->_fSetCellPosition;

                    ptci->_fSetCellPosition = TRUE;
                    if (ptci->GetLayoutContext())
                    {
                        ptci->_cyAvail = cyAvailSafe - (pCellLayout->GetYProposed() + _cyFooterHeight + _yCellSpacing + _aiBorderWidths[SIDE_BOTTOM]);
                        ptci->_yConsumed = 0;
                    }

                    //  For a row-spanned cell get height specified information directly from fancy format...
                    ptci->_fIgnorePercentChild = !ptci->_fTableHasUserHeight && !pFF->IsHeightPercent() && cuvHeight.IsNullOrEnum();

                    pCellLayout->CalcSizeAtUserWidth(ptci, &sizeCell);
                    ptci->_fSetCellPosition = fSetCellPositionOld;

#if DBG==1
                    {
                        BOOL fValidWidth = !pCellLayout->GetDisplay();
                        if (!fValidWidth)
                        {
                            BOOL fLayoutFlowChanged = pCellLayout->GetFirstBranch()->GetFancyFormat()->_fLayoutFlowChanged;
                            LONG lWidth = fLayoutFlowChanged ? pCellLayout->GetClientHeight() : pCellLayout->GetClientWidth();
                            // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingModeUsed = FALSE
                            lWidth += pCellLayout->GetBorderAndPaddingWidth(ptci, FALSE, TRUE);
                            fValidWidth =    (sizeCell.cx == lWidth) 
                                          || (  (lWidth - sizeCell.cx == 1)// Allow for rounding error on print scaling.
                                             && pCellLayout->ElementOwner()->GetMarkup()->IsPrintMedia());
                        }
                        Check( (pCellLayout->ContainsVertPercentAttr()) 
                            ||  pCellLayout->IsDisplayNone()
                            ||  fValidWidth);
                    }
#endif
                    ptci->_fIgnorePercentChild = fIgnorePercentChildSafe;
                }
            }

            if (!IsSpanned(*ppCell) || fPositionSpannedCell)
            {
                if (ptci->_pFFRow->_fPositioned)
                {
                    // need to position cell relative to the row
                    // Note positioned row is including cell spacing, therefore we need to adjust Y position of the
                    // cell by vertical spacing
                    pCellLayout->SetYProposed(0 + _yCellSpacing);   // 0 - means relative to the row
                }
                else
                {
                    pCellLayout->SetYProposed(ptRow.y);
                }
                if (    cCellRowSpan == 1 
                    //  (bug # 100284)
                    ||  fSizeSpannedCell)
                {
                    pCellLayout->GetApparentSize(&sizeCell);

                    if (    sizeCell.cy != pRowLayout->_yHeight
                        ||  pCellLayout->ContainsVertPercentAttr() 
                        ||  pCell->GetFirstBranch()->GetParaFormat()->_bTableVAlignment == htmlCellVAlignBaseline  )
                    {
                        sizeCell.cy = pRowLayout->_yHeight;

                        fSetCellPositionOld = ptci->_fSetCellPosition;

                        ptci->_fSetCellPosition = TRUE;
                        if (ptci->GetLayoutContext())
                        {
                            ptci->_cyAvail = cyAvailSafe - (ptRow.y + _cyFooterHeight + _yCellSpacing + _aiBorderWidths[SIDE_BOTTOM]);
                            ptci->_yConsumed = 0;
                        }
                        pCellLayout->CalcSizeAtUserWidth(ptci, &sizeCell);
                        ptci->_fSetCellPosition = fSetCellPositionOld;

#if DBG==1
                        {
                            BOOL fValidWidth = !pCellLayout->GetDisplay();
                            if (!fValidWidth)
                            {
                                BOOL fLayoutFlowChanged = pCellLayout->GetFirstBranch()->GetFancyFormat()->_fLayoutFlowChanged;
                                LONG lWidth = fLayoutFlowChanged ? pCellLayout->GetClientHeight() : pCellLayout->GetClientWidth();
                                // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingModeUsed = FALSE
                                lWidth += pCellLayout->GetBorderAndPaddingWidth(ptci, FALSE, TRUE);
                                fValidWidth =    (sizeCell.cx == lWidth)
                                                 // Allow for rounding error on print scaling.
                                              || (   (  (lWidth - sizeCell.cx == 1)
                                                     // in paginated tables GetClient*() incorrectly returns g_Zero.size because only 1 dim is set.
                                                     || (sizeCell.cx == (fLayoutFlowChanged 
                                                                        ? pCellLayout->GetHeight() 
                                                                        : pCellLayout->GetWidth())))
                                                  && pCellLayout->ElementOwner()->GetMarkup()->IsPrintMedia());
                            }
                            Check( (pCellLayout->ContainsVertPercentAttr()) 
                                ||  _cNestedLevel > SECURE_NESTED_LEVEL
                                ||  pRowLayout->IsDisplayNone()
                                ||  fValidWidth);
                        }
#endif
                    }
                }

                if (IsNaturalMode(smMode))
                {
                    const CFancyFormat * pFF = pCellLayout->GetFirstBranch()->GetFancyFormat();
                    CPoint               pt;

                    // Note: NOT POSITIONED cells located in the display tree under the table's GRID node 
                    // or under the rows
                    // Note: RELATIVELY positioned cells live in the display tree outside the table's grdi display node or
                    // under the rows if they are positioned

                    pt.x = pCellLayout->GetXProposed();
                    pt.y = pCellLayout->GetYProposed();
                    
                    // adjust the proposed position if the cell is not positioned
                    // or it is positioned and the row is not positioned and cell is directly 
                    // under the grid node.
                    // or if cell is relatively positioned and the row is also positioned
                    if (   !pFF->_fPositioned  
                        || (!ptci->_pFFRow->_fPositioned && fPositionParentTableGrid)
                        || ptci->_pFFRow->_fPositioned  )
                    {
                        if(!fRTL)
                            pt.x -= _aiBorderWidths[SIDE_LEFT];
                        else
                            pt.x += _aiBorderWidths[SIDE_RIGHT];

                        if (!ptci->_pFFRow->_fPositioned)
                            pt.y -= (_aiBorderWidths[SIDE_TOP] + ptci->TableLayout()->_yTableTop);
                    }

                    if(fRTL)
                    {
                        pt.x = xTableWidth + pt.x
                             - _aiBorderWidths[SIDE_RIGHT]
                             - _aiBorderWidths[SIDE_LEFT];

                        // If an RTL cell has "overflow:visible", it should actually be 
                        // positioned further to the left (unlike LTR)
                        if (pFF->GetOverflowX() == styleOverflowVisible)
                        {
                            pt.x -= pCellLayout->GetDisplay()->GetRTLOverflow();
                        }
                    }
                            
                    if (pFF->_fPositioned)
                    {
                        // relative cells will be positioned outside the table's grid display node (if the row is not positioned)
                        Assert (pFF->_bPositionType == stylePositionrelative);
                        pCell->ZChangeElement(0, &pt, ptci->GetLayoutContext());
                    }
                    else
                    {
                        pDispNode = pCellLayout->GetElementDispNode();
                        if (pDispNode)
                        {
                            // NOTE:   We need some table-calc scratch space so that we don't have to use _ptProposed as the holder
                            //         of the suggested x/y (which is finalized with this call) (brendand)
                            //         Also, the scratch space needs to operate using the coordinates within the table borders since
                            //         the display tree translates taking borders into account (brendand)
                            pCellLayout->SetPosition(pt, TRUE);
                        }
                    }
                }
            }
        }
    }

    ptci->_grfLayout = grfLayoutSafe;
    ptci->_smMode    = smMode;
    ptci->_yConsumed = yConsumedSafe;
    ptci->_cyAvail   = cyAvailSafe;
    ptci->_fIgnorePercentChild = FALSE;

    ptci->_fGlobalNormalCalc = fGlobalNormalCalcOld; 
    ptci->_fGlobalSetCalc = fGlobalSetCalcOld; 

    PerfLog(tagTableSet, this, "-SetCellPositions");
}


//+----------------------------------------------------------------------------
//
//  Member:     SizeAndPositionCaption
//
//  Synopsis:   Size and position a CAPTION
//
//  Arguments:  ptci      - Current CCalcInfo
//              pCaption - CTableCaption to position
//              pt       - Point at which to position the caption
//
//-----------------------------------------------------------------------------
void
CTableLayout::SizeAndPositionCaption(
    CTableCalcInfo *ptci,
    CSize *         psize,
    CLayout **      ppLayoutSibling,
    CDispNode *     pDispNodeSibling,
    CTableCaption * pCaption,
    POINT *         ppt, 
    BOOL            fCaptionCanBeBroken)
{
    Assert(ptci->GetLayoutContext() || !fCaptionCanBeBroken);

    CTableCellLayout *  pCaptionLayout = pCaption->Layout(ptci->GetLayoutContext());

    Assert(psize);
    Assert(pDispNodeSibling);

    if ( pCaptionLayout )
    {
        pCaptionLayout->SetXProposed(ppt->x);

        if (!pCaptionLayout->NoContent() || (pCaptionLayout->_fContainsRelative || pCaptionLayout->_fAutoBelow))
        {
            SIZE    sizeCaption;
            int     cyAvailSafe = ptci->_cyAvail;
            int     yConsumedSafe = ptci->_yConsumed;

            if (ptci->GetLayoutContext())
            {
                ptci->_cyAvail  -= ptci->_yConsumed;
                ptci->_yConsumed = 0;

                if (!fCaptionCanBeBroken)
                {
                    pCaptionLayout->SetElementCanBeBroken(FALSE);
                }
            }

            sizeCaption.cx = psize->cx;
            sizeCaption.cy = 1;
            pCaptionLayout->CalcSize(ptci, &sizeCaption);

            ptci->_cyAvail = cyAvailSafe;
            ptci->_yConsumed = yConsumedSafe;

            pCaptionLayout->SetYProposed(ppt->y);
            psize->cy += sizeCaption.cy;

            if (ptci->IsNaturalMode())
            {
                HRESULT hr;

                hr = AddLayoutDispNode(ptci,
                                       pCaptionLayout,
                                       NULL,
                                       pDispNodeSibling,
                                       ppt,
                                       (pCaption->_uLocation == CTableCaption::CAPTION_TOP));

                if (    hr == S_OK
                    &&  ppLayoutSibling)
                {
                    *ppLayoutSibling = pCaptionLayout;
                }
            }

            ppt->y           += sizeCaption.cy;
        }
        else
        {
            pCaptionLayout->_sizeCell.cx     = psize->cx;
            pCaptionLayout->_sizeCell.cy     = 0;
            pCaptionLayout->SetYProposed(0);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     AdjustRowHeights
//
//  Synopsis:   Distribute any extra height of a rowspan'd cell over the
//              spanned rows
//
//  NOTE: This routine will adjust the _sizeProposed for the table along
//        with the heights and sizes of the affected rows. However, it
//        depends upon the caller of this routine (e.g., CalculateRow) to
//        increase _sizeProposed by that of the last affected row.
//
//--------------------------------------------------------------------------

void
CTableLayout::AdjustRowHeights(
    CTableCalcInfo *ptci,
    CSize *         psize,
    CTableCell *    pCell)
{
    CSize       sizeCell;
    int         iRow  = pCell->RowIndex();
    int         cRows = pCell->RowSpan();
    int         cyRows;
    int         iRowCurrent;
    int         iRowLast;
    long        cyRowsActual;
    long        cyCell;
    CTable     *pTable = ptci->Table();
    CTableRowLayoutBlock   * pRowLayout = NULL;
    const CHeightUnitValue * puvHeight;
    BOOL                    fViewChain = (   ptci->GetLayoutContext()
                                          && ptci->GetLayoutContext()->ViewChain() != NULL
                                          && ElementCanBeBroken());
    CLayoutContext         * pLayoutContext = ptci->GetLayoutContext();

    Assert(cRows > 1);
    iRowLast = iRow + cRows - 1;

    // First, determine the height of the rowspan'd cell
    //--------------------------------------------------------------------
    pCell->Layout(pLayoutContext)->GetApparentSize(&sizeCell);


    if (fViewChain)
    {
        long cyCellHeightInLastRow = sizeCell.cy;

        for (iRowCurrent = iRow; iRowCurrent < iRowLast; iRowCurrent++)
        {
            CTableRow *pTableRow = GetRow(iRowCurrent);
            Assert(pTableRow);

            if (!pTableRow->CurrentlyHasLayoutInContext(pLayoutContext))
                continue;

            pRowLayout = DYNCAST(CTableRowLayoutBlock, pTableRow->GetUpdatedLayout(pLayoutContext));
            cyCellHeightInLastRow -= pRowLayout->_yHeight;
        }

        Assert(ptci->_pRowLayout == DYNCAST(CTableRowLayoutBlock, GetRow(iRowLast)->GetUpdatedLayout(pLayoutContext)));

        if (ptci->_pRowLayout->_yHeight < cyCellHeightInLastRow)
        {
            ptci->_pRowLayout->_yHeight = cyCellHeightInLastRow;
        }
        return;
    }

    // Get cell's height in table coordinate system (table is always horizontal => physical height)
    //---------------------------------------------------------------------------------------------
    puvHeight = (const CHeightUnitValue *)&pCell->GetFirstBranch()->GetFancyFormat()->GetHeight();
    cyCell    = (!puvHeight->IsSpecified() || puvHeight->IsSpecifiedInPercent()
                        ? 0
                        : puvHeight->GetPixelHeight(ptci, pTable));
    cyRows    = max(sizeCell.cy, cyCell);


    // Next, determine the height of the spanned rows, based on the compatible/default layout
    //---------------------------------------------------------------------------------------
    pRowLayout   = DYNCAST(CTableRowLayoutBlock, GetRow(iRowLast)->GetUpdatedLayout(pLayoutContext));
    cyRowsActual = (pRowLayout->GetYProposed() + pRowLayout->_yHeight) 
                    - GetRow(iRow)->GetUpdatedLayout(pLayoutContext)->GetYProposed();


    // Last, if the cell height is greater, distribute the difference over the spanned rows
    //--------------------------------------------------------------------
    if (   cyRows > cyRowsActual 
        && cyRowsActual)
    {
        long    dyProposed = 0;
        long    dyHeight   = (cyRows - cyRowsActual);
        long    dyRow = 0;

        // Distribute the difference proportionately across affected rows
        for (iRowCurrent = iRow; iRowCurrent <= iRowLast; iRowCurrent++)
        {
            pRowLayout = DYNCAST(CTableRowLayoutBlock, GetRow(iRowCurrent)->GetUpdatedLayout(pLayoutContext));
            pRowLayout->SetYProposed(pRowLayout->GetYProposed() + dyProposed);

            if (dyProposed < dyHeight)
            {
                dyRow = MulDivQuick(pRowLayout->_yHeight, dyHeight, cyRowsActual);

                dyRow = min(dyRow, dyHeight - dyProposed);

                pRowLayout->_yHeight         += dyRow;
                dyProposed                   += dyRow;
            }
            else 
            {
                dyRow = 0;
            }
        }

        // pRowLayout is now the last layout the rowspan covers
        //
        // If the total height differs (due to round-off error),use the last 
        // row to make up the difference
        // NETSCAPE: Navigator always uses the last row, even if it has zero height
        cyRowsActual = (pRowLayout->GetYProposed() + pRowLayout->_yHeight) 
                       - GetRow(iRow)->GetUpdatedLayout(pLayoutContext)->GetYProposed();

        Assert(0 <= (cyRows - cyRowsActual));

        pRowLayout->_yHeight += cyRows - cyRowsActual;
        dyRow                += cyRows - cyRowsActual;

        // Adjust total table height
        // (The last row is excluded since the caller of this routine adds its height to the table)
        psize->cy += dyHeight - dyRow;

        // the heights are usually different when we are paginiating the rows in print preview
        Assert(   psize->cy == pRowLayout->GetYProposed() 
               || (   pLayoutContext
                   && ElementOwner()->IsPrintMedia()));
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CalculateRow
//
//  Synopsis:   Calculate the cell heights and the row height
//
//  Returns:    TRUE if a did not fit in the determined column width
//              FALSE otherwise
//
//--------------------------------------------------------------------------

BOOL
CTableLayout::CalculateRow(
    CTableCalcInfo *    ptci,
    CSize *             psize,
    CLayout **          ppLayoutSibling,
    CDispContainer *    pDispNode, 
    BOOL                fRowCanBeBroken,
    BOOL                fAdjustVertSpannedCell, 
    int                 yRowFromTop)
{
    SIZEMODE        smMode    = ptci->_smMode;
    DWORD           grfLayout = ptci->_grfLayout;
    CTableCell **   ppCell;
    CTableCell *    pCell;
    CTableCellLayout * pCellLayout;
    CTableColCalc * pColCalc;
    int             cC, cColSpan, iCS;
    long            iWidth = 0;
    SIZE            sizeCell;
    int             cUnsizedCols;
    int             cCols = GetCols();
    BOOL            fCellSizeTooLarge  = FALSE;
    BOOL            fAdjustForRowspan  = FALSE;
    CTable      *   pTable = ptci->_pTable;

    Assert (pTable == Table());

    BOOL            fRTL = pTable->GetFirstBranch()->GetParaFormat()->HasRTL(TRUE);
    int             cCellRowSpan;
    int             iCellRowIndex;
    CLayout *       pLayoutSiblingCell = *ppLayoutSibling;
    BOOL            fSetNewSiblingCell = TRUE;
    BOOL            fGlobalNormalCalcOld = ptci->_fGlobalNormalCalc;
    BOOL            fGlobalSetCalcOld = ptci->_fGlobalSetCalc;
    CTableRow *     pRow = ptci->_pRow;

    Assert(pRow);

    CTableRowLayoutBlock * pRowLayout = ptci->_pRowLayout;
    CTableRowLayout * pRowLayoutCache = pRow->RowLayoutCache();

    Assert(pRowLayout && pRowLayoutCache);

    CLayoutContext *  pLayoutContext  = ptci->GetLayoutContext();

    BOOL            fRowDisplayNone = pRowLayout->GetFirstBranch()->IsDisplayNone();
    BOOL            fViewChain      = pLayoutContext && pLayoutContext->ViewChain();

    AssertSz(fViewChain || (fRowCanBeBroken == FALSE && fAdjustVertSpannedCell == FALSE && yRowFromTop == 0), 
        "Illegal usage of PPV parameters in browse mode.");
    
    //  This flag is TRUE if layout should be calculated in CSS1 strict mode. 
    //  If user specified size in the layout in CSS1 strict mode this size should 
    //  correspond to content size and should not include padding and border. 
    BOOL fStrictCSS1Document =      pTable->HasMarkupPtr() 
                                &&  pTable->GetMarkupPtr()->IsStrictCSS1Document();

    // current offset in the row
    long            iLeft = 0;
    long            xPos;
    int             cyAvailSafe   = ptci->_cyAvail;
    int             yConsumedSafe = ptci->_yConsumed;

    if (fViewChain)
    {
        ptci->_cyAvail  -= ptci->_yConsumed;
        CheckSz(ptci->_cyAvail >= 0, "Negative available height in CalculateRow()");

        ptci->_yConsumed = 0; 

        Assert(ptci->_pFFRow->_bPositionType != stylePositionabsolute || !fRowCanBeBroken);

        if (!fRowCanBeBroken)
        {
            pRowLayout->SetElementCanBeBroken(FALSE);
        }
        else if (ptci->_cyAvail <= 0)
        {
            ptci->_fLayoutOverflow = TRUE;
        }
    }
                              
    PerfLog(tagTableRow, this, "+CalculateRow");

    CElement::CLock   Lock(pTable, CElement::ELEMENTLOCK_SIZING);

    ptci->_smMode    = SIZEMODE_NATURAL;
    ptci->_grfLayout = ptci->_grfLayout & (LAYOUT_TASKFLAGS | LAYOUT_FORCE);

    //
    // Determine the number of sized columns (if any)
    //

    cUnsizedCols = cCols - _cSizedCols;

    // to calc baseline
    pRowLayout->_yBaseLine = -1;

    pRowLayout->_yHeight  = 0;
    // int iff = pRow->GetFirstBranch()->GetFancyFormatIndex();    // ensure compute format on the row.

    if (fRowDisplayNone)
        goto ExtractFromTree;

    if (ptci->_pFFRow->_fPositioned)
    {
        HRESULT hr = pRowLayout->EnsureDispNode(ptci, TRUE);
        if (!FAILED(hr))
        {
            // all the cells will be parented to the row's disp node container
            pDispNode = DYNCAST(CDispContainer, pRowLayout->GetElementDispNode());
            fSetNewSiblingCell = FALSE;
            pLayoutSiblingCell = NULL;
        }
    }


    if (IsFixedBehaviour())
    {
        if (pRowLayoutCache->GetCells() < cCols)
        {
            MtAdd( Mt(UsingFixedBehaviour1), 1, 0 );
            pRowLayoutCache->EnsureCells(cCols);
        }
    }

    Assert(pRowLayoutCache->GetCells() == cCols);

    if (!fStrictCSS1Document)
    {
        if (IsFixedBehaviour() || _cSizedCols)
        {   // if we have rowspan cells we can not be sure that the final rowSpan value is not 1, therefore we have to loop

            // clear caches only for fixed layout tables and tables after navigation (bug # 14950). 
            if (IsFixedBehaviour())
            {
                pRowLayoutCache->_uvHeight.SetNull();
                pRowLayoutCache->AdjustHeight(pRow->GetFirstBranch(), ptci, pTable); 
            
                if (IsFixed())
                {
                    //  For fixed layout tables also adjust for minHeight
                    pRowLayoutCache->AdjustMinHeight(pRow->GetFirstBranch(), ptci, pTable); 
                }
            }

            ppCell = pRowLayoutCache->_aryCells;
            for (cC = 0; cC < cCols; cC++, ppCell++)
            {
                if (IsReal(*ppCell))
                {
                    Assert(Cell(*ppCell));
                    pCell = Cell(*ppCell);

                    if (pCell->RowSpan() == 1)
                    {
                        CTreeNode *pCellTreeNode = pCell->GetFirstBranch();

                        // adjust height of the row for specified height of the cell
                        MtAdd( Mt(UsingFixedBehaviour2), 1, 0 );
                        pRowLayoutCache->AdjustHeight(pCellTreeNode, ptci, pTable); 
                    
                        if (IsFixed())
                        {
                            //  For fixed layout tables also adjust for minHeight
                            pRowLayoutCache->AdjustMinHeight(pCellTreeNode, ptci, pTable); 
                        }
                    }
                }
            }
        }
        if (pRowLayoutCache->IsHeightSpecified())
        {
            if (!pRowLayoutCache->IsHeightSpecifiedInPercent())
            {
                pRowLayout->_yHeight = pRowLayoutCache->GetPixelHeight(ptci);
                // In PPV we want to correct the height.
                if (fViewChain)
                {
                    //  This is how much space is available to fill
                    int cyAvail = ptci->_cyAvail - ptci->_yConsumed;
                    
                    // if the row is broken yRowFromTop is the previously comsumed height. 
                    pRowLayout->_yHeight -= yRowFromTop;

                    //  if the row height is still more than available height correct it
                    if (cyAvail < pRowLayout->_yHeight)
                    {
                        pRowLayout->_yHeight = cyAvail;
                    }

                    //  defencive code 
                    if (pRowLayout->_yHeight < 0)
                    {
                        pRowLayout->_yHeight = 0;
                    }
                }
            }
        }
    }
    else 
    {
        CTreeNode *pNodeRow     = pRow->GetFirstBranch();
        const CCharFormat *pCF  = pNodeRow->GetCharFormat(LC_TO_FC(ptci->LayoutContext()));
        if (pCF->_fUseUserHeight)
        {
            CHeightUnitValue uvHeight = ptci->_pFFRow->GetHeight();
            pRowLayout->_yHeight = uvHeight.YGetPixelValue(ptci, _sizeProposed.cy, 
                pNodeRow->GetFontHeightInTwips(&uvHeight)); 

            // In PPV we want to correct the height.
            if (fViewChain)
            {
                //  This is how much space is available to fill
                int cyAvail = ptci->_cyAvail - ptci->_yConsumed;
                
                // if the row is broken yRowFromTop is the previously comsumed height. 
                pRowLayout->_yHeight -= yRowFromTop;

                //  if the row height is still more than available height correct it
                if (cyAvail < pRowLayout->_yHeight)
                {
                    pRowLayout->_yHeight = cyAvail;
                }

                //  defencive code 
                if (pRowLayout->_yHeight < 0)
                {
                    pRowLayout->_yHeight = 0;
                }
            }
        }
    }

    if(!fRTL)
        xPos = _aiBorderWidths[SIDE_LEFT] + _xCellSpacing;
    else
        xPos = -(_aiBorderWidths[SIDE_RIGHT] + _xCellSpacing);

    pRowLayout->SetXProposed(xPos);
    pRowLayout->SetYProposed(fSetNewSiblingCell? 
                              psize->cy : 
                              psize->cy - _yCellSpacing);   // positioned rows include horsizontal and vertical cellSpacing

ExtractFromTree:

    if (!ptci->_cGlobalNestedCalcs)
    {
        //  If the table is topmost initialize global state 
        ptci->_fGlobalNormalCalc = TRUE;
    }

    //  _fGlobalSetCalc should be turned OFF 
    ptci->_fGlobalSetCalc = FALSE;

    ppCell = pRowLayoutCache->_aryCells;

    for (cC = 0, pColCalc = _aryColCalcs;
         cC < cCols;
         cC++, ppCell++, pColCalc++)
    {
        if (!IsEmpty(*ppCell))
        {
            pCell = Cell(*ppCell);
            pCellLayout = pCell->Layout(pLayoutContext);

            if (pColCalc->IsDisplayNone() || fRowDisplayNone)
            {
                CDispNode *pDispNodeOld = pCellLayout->GetElementDispNode();
                if (!IsSpanned(*ppCell) && pDispNodeOld)
                {
                    GetView()->ExtractDispNode(pDispNodeOld);
                }
                continue;
            }

            cCellRowSpan = pCell->RowSpan();
            iCellRowIndex = pCell->RowIndex();

            if (IsSpanned(*ppCell))
            {
                // if cell ends in this row adjust row height
                if (    iCellRowIndex + cCellRowSpan - 1 == pRowLayoutCache->RowPosition() 
                    &&  pCell->ColIndex() == cC )
                {
                    //
                    // Skip the cell if it begins in this row
                    // (Since its size is applied when it is first encountered)
                    //

                    if (iCellRowIndex != pRowLayoutCache->RowPosition())
                    {
                        fAdjustForRowspan = TRUE;
                    }
#if DBG==1
                    //
                    // This must have been a COLSPAN'd cell, ROWSPAN should be equal to one
                    //

                    else
                    {
                        Assert(cCellRowSpan == 1);
                    }
#endif
                    if (fViewChain)
                    {
                        Assert(pLayoutContext);

                        //  If spanned cell is broken we must inform table about it
                        CLayoutBreak *pLayoutBreak; 

                        pLayoutContext->GetEndingLayoutBreak(pCell, &pLayoutBreak); 
                        if (    pLayoutBreak 
                            &&  pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW  )
                        {
                            ptci->_fLayoutOverflow = TRUE;
                        }
                    }
                }

            }

            if (    !IsSpanned(*ppCell) 
                ||  (   fAdjustVertSpannedCell
                    &&  cCellRowSpan > 1 
                    //  (bug #95332)
                    &&  pCell->ColIndex() == cC )   )
            {
                // Track if we run into a COLS at this table nesting level.
                BOOL fTableContainsCols = ptci->_fTableContainsCols;
                ptci->_fTableContainsCols = FALSE;

                cColSpan = pCell->ColSpan();

                // calc cell width
                iWidth = pColCalc->_xWidth;
                CTableColCalc *pColCalcTemp;

                for (iCS = 1; iCS < cColSpan; iCS++)
                {
                    pColCalcTemp = pColCalc + iCS;
                    if (pColCalcTemp->_xWidth)
                    {
                        iWidth  += pColCalcTemp->_xWidth;
                        if (!pColCalcTemp->_fVirtualSpan)
                        {
                            iWidth  += _xCellSpacing;
                        }
                    } // else pure virtual (cell was already adjusted for it).
                }

                //
                // If this is a fixed size cell, set its min/max values
                // (Since CalcSize(SIZEMODE_MMWIDTH) is not invoked on fixed size cells,
                //  these values may not have been set)
                //


                if (cC < _cSizedCols && !pCellLayout->_fMinMaxValid)
                {
                    pCellLayout->_sizeMin.SetSize(iWidth, -1);
                    pCellLayout->_sizeMax.SetSize(iWidth, -1);
                    pCellLayout->_fMinMaxValid = TRUE;
                }

                // get cell height
                sizeCell.cx = iWidth;
                sizeCell.cy = 0;
                pCellLayout->_fContentsAffectSize = TRUE;
                pCellLayout->SetElementCanBeBroken(pCellLayout->ElementCanBeBroken() && fRowCanBeBroken);

                pCellLayout->CalcSizeAtUserWidth(ptci, &sizeCell);
                
                if (pCellLayout->_fForceMinMaxOnResize)
                {
                    _fForceMinMaxOnResize = TRUE;   // need to force min max on resize; bug #66432
                }

                //
                // If the sized cell is larger than the supplied width and it was
                // not min/max calculated, note the fact for our caller
                // (This can occur since sized columns take their width from user supplied
                //  values rather than the content of the cell)
                //

                // Cell overflow should only occur if we are dealing with fixed sized cells,
                // either at this level or in an embedded table.
                if ((ptci->_fTableContainsCols || cC < _cSizedCols) && sizeCell.cx > iWidth && !_fAlwaysMinMaxCells)
                {
                    pCellLayout->ResetMinMax();
                    fCellSizeTooLarge = TRUE;
                }

                // Restore potential table sibling's _fTableContainsCols.
                ptci->_fTableContainsCols |= fTableContainsCols || cC < _cSizedCols;

                //
                // 1. _yBaseLine on the row is used only for the cells with the specified baseline
                //    alignment.
                // 2. NETSCAPE: Baseline is taken from ALL the cells in the row
                //

                if (pCellLayout->_yBaseLine > pRowLayout->_yBaseLine)
                {
                    pRowLayout->_yBaseLine = pCellLayout->_yBaseLine;
                }


#if DBG == 1
                if (IsTagEnabled(tagTableCellSizeCheck))
                {
                    BOOL fLayoutFlowChanged = pCellLayout->GetFirstBranch()->GetFancyFormat()->_fLayoutFlowChanged;
                    LONG lWidth = fLayoutFlowChanged ? pCellLayout->GetDisplay()->GetHeight() : pCellLayout->GetDisplay()->GetWidth();
                    // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingMode = FALSE
                    Assert(iWidth >= lWidth + pCellLayout->GetBorderAndPaddingWidth(ptci, FALSE, TRUE));
                }
#endif

                {
                    const CFancyFormat *pFFCell = pCell->GetFirstBranch()->GetFancyFormat();

                    if (    IsNaturalMode(smMode)
                        &&  !pFFCell->_fPositioned  )
                    {
                        pLayoutSiblingCell = AddLayoutDispNode(ptci, pCellLayout, pDispNode, pLayoutSiblingCell);
                    }

                    if(!fRTL)
                        xPos = pRowLayout->GetXProposed() + iLeft;
                    else
                        xPos = pRowLayout->GetXProposed() - iLeft - iWidth;

                    pCellLayout->SetXProposed(xPos);

                    pCellLayout->SetYProposed(pRowLayout->GetYProposed());

                    // if not spanned beyond this row use this height
                    if (    (   cCellRowSpan == 1 
                            ||  (fViewChain && (iCellRowIndex + cCellRowSpan - 1 == pRowLayoutCache->RowPosition()))    ) 
                        &&  sizeCell.cy > pRowLayout->_yHeight
                        // (bug # 104206) To prevent content clipping in fixed broken rows in print view. 
                        // NOTE : code in CTableCellLayout::CalcSizeCore makes sure that this part of broken row 
                        // less or equal to the row height in compatible layout context.
                        &&  (   fViewChain 
                            ||  fStrictCSS1Document
                            ||  !(  IsFixed()
                            &&  pRowLayoutCache->IsHeightSpecifiedInPixel() 
                            &&  pFFCell->GetMinHeight().IsNullOrEnum()  )   )   )
                    {
                        pRowLayout->_yHeight = sizeCell.cy;
                    }
                }
            }
        }

        if (pColCalc->_xWidth)
        {
            iLeft  += pColCalc->_xWidth;

            if (!pColCalc->_fVirtualSpan)
            {
                iLeft  += _xCellSpacing;
            }
        }
    }

    //
    // If any cells were too large, exit immediately
    // (The row will be re-sized again with the proper widths)
    //

    if (fCellSizeTooLarge)
        goto Cleanup;

    // NETSCAPE: In Navigator, empty rows are 1 pixel high
    if (!pRowLayout->_yHeight && !fRowDisplayNone)
    {
        pRowLayout->_yHeight = ptci->DeviceFromDocPixelsX(1);
    }

    // NOTE: if there is baseline alignment in the row we DON'T NEED to recalculate the row height
    // since
    // NETSCAPE: NEVER grows the cells based on baseline alignment
    // If any rowspan'd cells ended in this row, adjust the row heights.
    //

    if (fAdjustForRowspan)
    {
        for (cC = 0, ppCell = pRowLayoutCache->_aryCells;
             cC < cCols;
             cC++, ppCell++)
        {
            if (!IsEmpty(*ppCell))
            {
                if (IsSpanned(*ppCell))
                {
                    pCell = Cell(*ppCell);
                    pCellLayout = pCell->Layout(ptci->GetLayoutContext());
                    cCellRowSpan = pCell->RowSpan();
                    iCellRowIndex = pCell->RowIndex();

                    if (   iCellRowIndex != pRowLayoutCache->RowPosition()    // the cell starts in one of the previous rows, AND
                        && iCellRowIndex +  cCellRowSpan - 1 == pRowLayoutCache->RowPosition()   // ends in this row, AND
                        && pCellLayout->ColIndex() == cC)              // it is a first column of the spanned cell
                    {
                        AdjustRowHeights(ptci, psize, pCell);
                    }
                }
            }
        }
    }

    pRowLayout->SetSizeThis( FALSE );

    ptci->_smMode    = smMode;
    ptci->_grfLayout = grfLayout;

    if (fRowDisplayNone)
        goto Cleanup;

    if (    !fStrictCSS1Document
        &&  pRowLayout->PercentHeight())
    {
        _fHavePercentageRow = TRUE;
    }

    if ( pRowLayout->_fAutoBelow && !pRowLayout->ElementOwner()->IsZParent() )
    {
         _fAutoBelow = TRUE;
    }

    if (fSetNewSiblingCell)
    {
        *ppLayoutSibling = pLayoutSiblingCell;
    }
    else
    {
        // need to set the size on the display node of the row
        CSize  sz(psize->cx - _aiBorderWidths[SIDE_RIGHT] - _aiBorderWidths[SIDE_LEFT], 
                  pRowLayout->_yHeight + _yCellSpacing + _yCellSpacing);
        if (pRow->IsDisplayNone())
            sz.cy = 0;
        pDispNode->SetSize(sz, NULL, FALSE);
        xPos = pRowLayout->GetXProposed();
        pRowLayout->SetXProposed(xPos - _xCellSpacing);
    }

Cleanup:
    ptci->_fGlobalNormalCalc = fGlobalNormalCalcOld; 
    ptci->_fGlobalSetCalc = fGlobalSetCalcOld; 

    ptci->_yConsumed = yConsumedSafe;
    ptci->_cyAvail   = cyAvailSafe;

    PerfLog(tagTableRow, this, "-CalculateRow");
    return fCellSizeTooLarge;
}


//+-------------------------------------------------------------------------
//
//  Method:     CalculateRows
//
//  Synopsis:   Calculate the row heights and table height
//
//--------------------------------------------------------------------------

void
CTableLayout::CalculateRows(
    CTableCalcInfo * ptci,
    CSize *     psize)
{
    CTableLayoutBlock * pTableLayout = ptci->TableLayout();
    CTableRowLayoutBlock *pRowLayoutBlock;
    CTableRowLayout * pRowLayoutCache;
    CTableRow       * pRow;
    CTable          * pTable = ptci->Table();
    int             cR, cRows = GetRows();
    int             iRow;
    int             iPercent, iP;
    long            iMul, iDiv;
    int             iDelta;
    long            iNormalMin, iUserMin;
    long            iNormal, iUser;
    long            yHeight, yDelta;
    long            yTableHeight;
    int             yTablePadding;
    int             cAdjust;
    BOOL            fUseAllRows;
    long            iExtra;
#if DBG == 1
    int             cLoop;
#endif
    int             cOutRows = 0;

    Assert(pTableLayout);

    yTablePadding = 2 * _yBorder + cRows * _yCellSpacing + _yCellSpacing;

    // calc sum known % and known width

    iPercent = 0;
    iMul = 0;
    iDiv = 1;
    iUserMin = 0;
    iNormalMin = 0;

    for (cR = cRows, iRow = GetFirstRow();
        cR > 0;
        cR--, iRow = GetNextRow(iRow))
    {
        pRow = _aryRows[iRow];
        if (!pRow->_fCompleted)
        {
            Assert (!_fCompleted && IsFixedBehaviour());  // if row is not completed, table also should not be completed
            yTablePadding -= _yCellSpacing;
            cOutRows++;
            continue;
        }
        ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
        if ((pRow->IsDisplayNone()  || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
        {
            yTablePadding -= _yCellSpacing;
            cOutRows++;
            continue;
        }
        pRowLayoutCache = pRow->RowLayoutCache();
        Assert(pRowLayoutCache);

        yHeight = ((CTableRowLayoutBlock *)pRow->GetUpdatedLayout(ptci->GetLayoutContext()))->_yHeight;
        if (pRowLayoutCache->IsHeightSpecified())
        {
            if (pRowLayoutCache->IsHeightSpecifiedInPercent())
            {
                iP = pRowLayoutCache->GetPercentHeight();

                // remember max height/% ratio
                if (iP)
                {
                    if (yHeight * iDiv > iP * iMul)
                    {
                        iMul = yHeight;
                        iDiv = iP;
                    }
                }

                if (iPercent + iP > 100)
                {
                    iP = 100 - iPercent;
                    iPercent = 100;
                    pRowLayoutCache->SetPercentHeight(iP);
                }
                else
                {
                    iPercent += iP;
                }
            }
            else
            {
                Assert(yHeight >= pRowLayoutCache->GetPixelHeight(ptci));
                iUserMin += yHeight;
            }
        }
        else
        {
            iNormalMin += yHeight;
        }
    }

    iP = 100 - iPercent;
    if (iP < 0)
    {
        iP = 0;
    }

    // Table is always horizontal => physical height
    CHeightUnitValue uvHeight = GetFirstBranch()->GetFancyFormat()->GetHeight();

    // if we are calculating min/max and percent is set ignore user setting
    if (uvHeight.IsSpecified() && !(uvHeight.IsSpecifiedInPercent() &&
        (  ptci->_smMode == SIZEMODE_MMWIDTH
        || ptci->_smMode == SIZEMODE_MINWIDTH
        )))
    {
        yTableHeight = uvHeight.GetPercentSpecifiedHeightInPixel(ptci, pTable, pTableLayout->_sizeParent.cy) - yTablePadding;
    }
    else
    {
        // if user height is not given back calculate it from the max height/% ratio
        if (iPercent)
        {
            // check if the remaining user and normal columns are requiring bigger percentage
            if (iP)
            {
                if ((iUserMin + iNormalMin) * iDiv > iP * iMul)
                {
                    iMul = iUserMin + iNormalMin;
                    iDiv = iP;
                }
            }
            yTableHeight = MulDivQuick(100, iMul, iDiv);
        }
        else
        {
            yTableHeight = iUserMin + iNormalMin;
        }
    }

    // if current height is already bigger we cannot do anything...
    if (psize->cy - pTableLayout->_yTableTop >= yTableHeight + yTablePadding)
    {
        return;
    }

    // cache width remaining for normal and user columns
    yHeight = MulDivQuick(iP, yTableHeight, 100);

    // distribute remaining percentage amongst normal and user rows
    if (iUserMin)
    {
        iUser = iUserMin;
        if (iNormalMin)
        {
            iNormal = iNormalMin;
            if (iUser + iNormal < yHeight)
            {
                iNormal = yHeight - iUser;
            }
        }
        else
        {
            iNormal = 0;
            if (iUser < yHeight)
            {
                iUser = yHeight;
            }
        }
    }
    else
    {
        iUser = 0;
        if (iNormalMin)
        {
            iNormal = iNormalMin;
            if (iNormal < yHeight)
            {
                iNormal = yHeight;
            }
        }
        else
        {
            iNormal = 0;
        }
    }

    iP = MulDivQuick(100, yTableHeight - iUser - iNormal, yTableHeight);

    psize->cy = pTableLayout->_yTableTop + _aiBorderWidths[SIDE_TOP] + _yCellSpacing;

    // distribute extra height
    iNormal -= iNormalMin;
    iUser   -= iUserMin;

    // remember how many can be adjusted
    cAdjust = 0;

    for (cR = cRows, iRow = GetFirstRow();
        cR > 0;
        cR--, iRow = GetNextRow(iRow))
    {
        pRow = _aryRows[iRow];
        pRowLayoutCache = pRow->RowLayoutCache();
        pRowLayoutBlock = (CTableRowLayoutBlock *)(pRow->GetUpdatedLayout(ptci->GetLayoutContext()));
        Assert(pRowLayoutBlock && pRowLayoutCache);

        ptci->_pRow = pRow;
        ptci->_pRowLayout = pRowLayoutBlock;
        ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();

        if (!pRow->_fCompleted)
        {
            Assert (!_fCompleted && IsFixedBehaviour());  // if row is not completed, table also should not be completed
            continue;
        }
        if ((pRow->IsDisplayNone()  || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
            continue;
        
        if (!pRowLayoutCache->IsHeightSpecified() && iNormalMin)
        {
            yHeight = pRowLayoutBlock->_yHeight + MulDivQuick(iNormal, pRowLayoutBlock->_yHeight, iNormalMin);
        }
        else if (pRowLayoutCache->IsHeightSpecifiedInPercent())
        {
            yHeight = iPercent
                        ? MulDivQuick(yTableHeight,
                                    MulDivQuick(iP, pRowLayoutCache->GetPercentHeight(), iPercent),
                                    100)
                        : 0;
            if (yHeight < pRowLayoutBlock->_yHeight)
            {
                yHeight = pRowLayoutBlock->_yHeight;
            }
        }
        else if (iUserMin)
        {
            yHeight = pRowLayoutBlock->_yHeight + MulDivQuick(iUser, pRowLayoutBlock->_yHeight, iUserMin);
        }
        pRowLayoutBlock->_yHeightOld = pRowLayoutBlock->_yHeight;
        pRowLayoutBlock->_yHeight    = yHeight;

        if (ptci->_pFFRow->_bPositionType == stylePositionrelative)
        {
            CDispContainer *pDispNode = DYNCAST(CDispContainer, pRowLayoutBlock->GetElementDispNode());
            Assert (pDispNode);
            CSize  sz(psize->cx - _aiBorderWidths[SIDE_RIGHT] - _aiBorderWidths[SIDE_LEFT], 
                      yHeight + _yCellSpacing + _yCellSpacing);
            pRowLayoutBlock->SetYProposed(psize->cy - _yCellSpacing);
            pDispNode->SetSize(sz, NULL, FALSE);
        }
        else
        {
            pRowLayoutBlock->SetYProposed(psize->cy);
        }
        SetCellPositions(ptci, psize->cx);

        psize->cy += yHeight + _yCellSpacing;
        // we can adjust this row since it is more than min height
        if (yHeight > pRowLayoutBlock->_yHeightOld)
        {
            cAdjust++;
        }
    }

    // adjust for table border

    psize->cy += _aiBorderWidths[SIDE_BOTTOM];
#if DBG == 1
    cLoop = 0;
#endif

    // this is used to keep track of extra adjustment couldn't be applied
    iExtra = 0;

    if (cRows - cOutRows)
    {
      while ((yDelta = yTableHeight + yTablePadding - (psize->cy - pTableLayout->_yTableTop)) != 0)
      {
        fUseAllRows = FALSE;
        if (yDelta > 0)
        {
            if (cAdjust == 0)
            {
                // use all the rows if we add...
                cAdjust = cRows - cOutRows;
                fUseAllRows = TRUE;
            }
        }
        
        // distribute rounding error
        if(!cAdjust)
            break;

        iMul = yDelta / cAdjust;
        iDiv = yDelta % cAdjust;
        iDelta = iDiv > 0 ? 1 : iDiv < 0 ? -1 : 0;

        psize->cy = pTableLayout->_yTableTop + _aiBorderWidths[SIDE_TOP] + _yCellSpacing;

        // recalc cAdjust again
        cAdjust = 0;

        for (cR = cRows, iRow = GetFirstRow();
            cR > 0;
            cR--, iRow = GetNextRow(iRow))
        {
            pRow = _aryRows[iRow];
            pRowLayoutCache = pRow->RowLayoutCache();
            pRowLayoutBlock = (CTableRowLayoutBlock *)(pRow->GetUpdatedLayout(ptci->GetLayoutContext()));
            Assert(pRowLayoutBlock && pRowLayoutCache);

            ptci->_pRow = pRow;
            ptci->_pRowLayout = pRowLayoutBlock;
            ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();

            if (!pRow->_fCompleted)
            {
                Assert (!_fCompleted && IsFixedBehaviour());  // if row is not completed, table also should not be completed
                continue;
            }
            if ((pRow->IsDisplayNone()  || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
                continue;

            yHeight = pRowLayoutBlock->_yHeight;
            if (    yHeight > pRowLayoutBlock->_yHeightOld
                ||  (   yDelta > 0
                    &&  fUseAllRows))
            {
                yHeight += iMul + iDelta + iExtra;

                // if we went below min we have to adjust back...
                if (yHeight <= pRowLayoutBlock->_yHeightOld)
                {
                    iExtra  = yHeight - pRowLayoutBlock->_yHeightOld;
                    yHeight = pRowLayoutBlock->_yHeightOld;
                }
                else
                {
                    cAdjust++;
                    iExtra = 0;
                }

                iDiv -= iDelta;
                if (!iDiv)
                {
                    iDelta = 0;
                }
            }
            pRowLayoutBlock->_yHeightOld = pRowLayoutBlock->_yHeight;
            pRowLayoutBlock->_yHeight    = yHeight;

            if (ptci->_pFFRow->_bPositionType == stylePositionrelative)
            {
                CDispContainer *pDispNode = DYNCAST(CDispContainer, pRowLayoutBlock->GetElementDispNode());
                Assert (pDispNode);
                CSize  sz(psize->cx - _aiBorderWidths[SIDE_RIGHT] - _aiBorderWidths[SIDE_LEFT], 
                          yHeight + _yCellSpacing + _yCellSpacing);
                pRowLayoutBlock->SetYProposed(psize->cy - _yCellSpacing);
                pDispNode->SetSize(sz, NULL, FALSE);
            }
            else
            {
                pRowLayoutBlock->SetYProposed(psize->cy);
            }

            SetCellPositions(ptci, psize->cx);

            psize->cy += yHeight + _yCellSpacing;
        }

        // adjust for table border
        psize->cy += _aiBorderWidths[SIDE_BOTTOM];

#if DBG == 1
        cLoop++;
        Assert(cLoop < 5);
#endif
      }   // end of (while) loop
      

    }
    else
    {
        psize->cy += yTableHeight;
    }// end of if (cRows)

    Assert(iExtra == 0);
    Assert(psize->cy - pTableLayout->_yTableTop == yTableHeight + yTablePadding);
}


//+-------------------------------------------------------------------------
//
//  Method:     CalculateColumns
//
//  Synopsis:   Calculate column widths and table width
//
//--------------------------------------------------------------------------

void
CTableLayout::CalculateColumns(
    CTableCalcInfo * ptci,
    CSize *     psize)
{
    CTableColCalc * pColCalc;
    int     cC, cCols = GetCols();
    int     iPercentColumn, iPercent, iP;
    long    iMul, iDiv, iDelta;
    int     iPercentMin;
    long    iUserMin, iUserMax;
    long    iMin, iMax;
    long    iWidth;
    long    iNormal, iUser;
    BOOL    fUseMax = FALSE, fUseMin = FALSE, fUseMaxMax = FALSE;
    BOOL    fUseUserMax = FALSE, fUseUserMin = FALSE, fUseUserMaxMax = FALSE;
    BOOL    fSubtract = FALSE, fUserSubtract = FALSE;
    long    xTableWidth, xTablePadding;
    int     cAdjust;
    long    iExtra;
    BOOL    fUseAllColumns;
    CTable * pTable = ptci->Table();
    CTableLayoutBlock *pTableLayout = ptci->TableLayout();
    int     cDisplayNoneCols = 0;

#if DBG == 1
    int cLoop;
#endif

    PerfLog(tagTableColumn, this, "+CalculateColumns");

    xTablePadding = _aiBorderWidths[SIDE_RIGHT] + _aiBorderWidths[SIDE_LEFT] + _cNonVirtualCols * _xCellSpacing + _xCellSpacing;

    //
    // first calc sum known percent, user set and 'normal' widths up
    //
    iPercent = 0;
    iPercentMin = 0;
    iUserMin = iUserMax = 0;
    iMin = iMax = 0;

    //
    // we also keep track of the minimum width-% ratio necessary to
    // display the table with the columns at max width and the right
    // percent value
    //
    iMul = 0;
    iDiv = 1;

    //
    // Keep track of the first column which introduces a percentage width
    //

    iPercentColumn = INT_MAX;
    _fHavePercentageCol = FALSE;

    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, pColCalc++)
    {
        if (pColCalc->IsDisplayNone())
        {
            cDisplayNoneCols++;
            continue;
        }
        if (pColCalc->IsWidthSpecified())
        {
            if (pColCalc->IsWidthSpecifiedInPercent())
            {
                _fHavePercentageCol = TRUE;
                if (iPercentColumn > (cCols - cC))
                {
                    iPercentColumn = cCols - cC;
                }

                iP = pColCalc->GetPercentWidth();

                if (iP < 0)
                {
                    iP = 0;
                }
                // if we are over 100%, cut it back
                if (iPercent + iP > 100)
                {
                    iP = 100 - iPercent;
                    iPercent = 100;
                    pColCalc->SetPercentWidth(iP);
                }
                else
                {
                    iPercent += iP;
                }

                // remember max width/% ratio
                if (iP == 0)
                {
                    iP = 1; // at least non empty cell should get 1%
                }
                if (pColCalc->_xMax * iDiv > iP * iMul)
                {
                    iMul = pColCalc->_xMax;
                    iDiv = iP;
                }

                iPercentMin += pColCalc->_xMin;
            }
            else
            {
                iUserMax += pColCalc->_xMax;
                iUserMin += pColCalc->_xMin;
            }
        }
        else
        {
            Assert (pColCalc->_xMax >= 0 && pColCalc->_xMin >=0 );
            iMax += pColCalc->_xMax;
            iMin += pColCalc->_xMin;
        }
    }

    // iP is what remained left from the 100%
    iP = 100 - iPercent;
    Assert (iP >= 0);

    // Table is always horizontal => physical width
    CWidthUnitValue uvWidth = GetFirstBranch()->GetFancyFormat()->GetWidth();

    //
    // If COLS was specified and there one or more columns percentage sized columns,
    // then default the table width to 100%
    // (When all columns are of fixed size, their sizes take precedence over any
    //  explicitly specified table width. Additionally, normal table sizing should
    //  be used if the only non-fixed size columns are those outside the range
    //  specified by COLS.)
    //

    if (!uvWidth.IsSpecified() && _cSizedCols > iPercentColumn)
    {
        uvWidth.SetPercent(100);
    }

    //
    // NS/IE compatibility, any value <= 0 is treated as <not present>
    //

    if (uvWidth.GetUnitValue() <= 0)
    {
        uvWidth.SetNull();
    }

    //
    // if uvWidth is set we use that value except when we are being called to
    // calculate for min/max and the width is percent since the parent information
    // is bogus then
    //
    if (uvWidth.IsSpecified() && !(uvWidth.IsSpecifiedInPercent() &&
        (  ptci->_smMode == SIZEMODE_MMWIDTH
        || ptci->_smMode == SIZEMODE_MINWIDTH
        )))
    {
        xTableWidth = uvWidth.GetPercentSpecifiedWidthInPixel(ptci, pTable, pTableLayout->_sizeParent.cx);
        if (xTableWidth < _sizeMin.cx)
        {
            xTableWidth = _sizeMin.cx;
        }
        // if we want to limit the tabble width, then
        //        if (xTableWidth > MAX_TABLE_WIDTH)
        //        {
        //            xTableWidth = MAX_TABLE_WIDTH;
        //        }
    }
    else
    {
        //
        // pTableLayout->_sizeParent.cx can be set to 0 in the following cases:
        //     1) user specified 0 as width/height for the parent element,
        //        in this case ptci->_sizeParentForVert.cx is also set to 0.
        //     2) table is sized in NATURALMIN mode. In this mode 
        //        _sizeParent.cx is set to 0 inside CTableLayout::CalculateLayout, 
        //        but we keep original value in _sizeParentForVert.cx, so use it 
        //        in column width calculations.
        //     3) table is contained in something with a specified width of 0 (or 1!)
        // It will prevent to size table differently in case of NATURALMIN and NATURAL mode.
        //
        LONG lParentWidth = pTableLayout->_sizeParent.cx;
        if (lParentWidth == 0 && ptci->_sizeParent.cx == 0)
            lParentWidth = ptci->_sizeParentForVert.cx;

        // if user width is not given back calculate it from the max width/% ratio
        if (iPercent)
        {
            // check if the remaining user and normal columns are requiring bigger ratio
            if (iP)
            {
                if ((iUserMax + iMax) * iDiv> iP * iMul)
                {
                    iMul = iUserMax + iMax;
                    iDiv = iP;
                }
            }

            //
            // if there is percentage left or there are only percentage columns use the ratio
            // to back-calculate the table width
            //
            if (iP || (iUserMax + iMax) == 0)
            {
                // iP > 0 means the total percent specified columns = 100 - iP

                // TODO (112603, olego) (bug #108425).
                // Problem,
                // Given:   iMul = INT_MAX/2;       // came from pColCalc->_xMax
                //          iDiv = 50;              // percent value
                // Find:    xTableWidth using equation below.
                //
                // xTableWidth = MulDivQuick(100, iMul, iDiv) + xTablePadding;
                //
                // Answer:  due to numerical overflow xTableWidth becomes negative and 
                //          subsequent check (see code below) will return wrong result, 
                //          (found in hi-res mode). 
                //
                // I don't think this is a great idea to mix floating point with integer 
                // arithmetic so it's needed to be improved.

                // xTableWidth = MulDivQuick(100, iMul, iDiv) + xTablePadding;
                double dTableWidth = double(iMul) 
                                   * 100.0 
                                   / double(iDiv) 
                                   + double(xTablePadding); 

                if (dTableWidth > double(INT_MAX/2)) 
                {
                    xTableWidth = INT_MAX/2;
                }
                else 
                {
                    xTableWidth = IntNear(dTableWidth);
                }

                if (xTableWidth > lParentWidth)
                {
                    xTableWidth = lParentWidth;
                }
            }
            else
            {
                // otherwise use parent width
                xTableWidth = lParentWidth;
            }
            if (xTableWidth < _sizeMin.cx)
            {
                xTableWidth = _sizeMin.cx;
            }
        }
        else
        {
            if (_sizeMax.cx < lParentWidth)
            {
                // use max value if that smaller the parent size
                xTableWidth = _sizeMax.cx;
            }
            else if (_sizeMin.cx > lParentWidth)
            {
                // have to use min if that is bigger the parent
                xTableWidth = _sizeMin.cx;
            }
            else
            {
                // use parent between min and max
                xTableWidth = lParentWidth;
            }
        }
    }

    // if there are no columns, set proposed and return
    if (!cCols)
    {
        psize->cx = xTableWidth;
        return;
    }

    //
    // If all columns are of fixed size, set the table width to the sum and return
    //

    if (_fCols &&
        (!uvWidth.IsSpecified() || (xTableWidth <= (iUserMin + iMin + xTablePadding))))
    {
        Assert(iPercent == 0);
        Assert(iMax == iMin);
        Assert(iUserMax == iUserMin);
        // set the width of the columns
        for (cC = cCols, pColCalc = _aryColCalcs;
            cC > 0;
            cC--, pColCalc++)
        {
            pColCalc->_xWidth = pColCalc->_xMin;
        }
        psize->cx = iUserMin + iMin + xTablePadding;
        return;
    }

    // subtract padding width which contains border and cellspacing
    if (xTableWidth >= xTablePadding)
    {
        xTableWidth -= xTablePadding;
    }

    if (iMax + iUserMax)
    {
        // cache width remaining for normal and user columns over percent columns (iWidth)
        iWidth = MulDivQuick(iP, xTableWidth, 100);
        if (iWidth < iUserMin + iMin)
        {
            iWidth = iUserMin + iMin;
        }
        if (iWidth > xTableWidth - iPercentMin)
        {
            iWidth = xTableWidth - iPercentMin;
        }
    }
    else
    {
        // all widths is for percent columns
        iWidth = 0;
    }

    //
    // distribute remaining width amongst normal and user columns
    // first try to use max width for user columns and normal columns
    //
    if (iUserMax)
    {
        iUser = iUserMax;
        if (iUser > iWidth)
        {
            iUser = iWidth;
        }
        if (iMax)
        {
            iNormal = iMin;
            if (iUser + iNormal <= iWidth)
            {
                iNormal = iWidth - iUser;
            }
            else
            {
                iUser = iUserMin;
                if (iUser + iNormal <= iWidth)
                {
                    iUser = iWidth - iNormal;
                }
            }
        }
        else
        {
            iNormal = 0;
            if (iUser < iWidth)
            {
                iUser = iWidth;
            }
        }
    }
    else
    {
        iUser = 0;
        if (iMax)
        {
            iNormal = iMin;
            if (iNormal < iWidth)
            {
                iNormal = iWidth;
            }
        }
        else
        {
            iNormal = 0;
        }
    }

    if (iNormal > iMax)
    {
        fUseMaxMax = TRUE;
    }
    else if (iNormal == iMax)
    {
        fUseMax = TRUE;
    }
    else if (iNormal == iMin)
    {
        fUseMin = TRUE;
    }
    else if (iNormal < iMax)
    {
        fSubtract = TRUE;
    }

    if (iUser > iUserMax)
    {
        fUseUserMaxMax = TRUE;
    }
    else if (iUser == iUserMax)
    {
        fUseUserMax = TRUE;
    }
    else if (iUser == iUserMin)
    {
        fUseUserMin = TRUE;
    }
    else if (iUser < iUserMax)
    {
        fUserSubtract = TRUE;
    }

    // calculate real percentage of percent columns in the table now using the final widths
    iP = xTableWidth ? MulDivQuick(100, xTableWidth - iUser - iNormal, xTableWidth)
                     : 0;

    // start with the padding
    psize->cx = xTablePadding;

    // remember how many columns can be adjusted
    cAdjust = 0;

    //
    // now go and calculate column widths by distributing the extra width over
    // the min width or subtracting the extra width from max
    //
    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, pColCalc++)
    {
        if (pColCalc->IsDisplayNone())
            continue;

        if (!pColCalc->IsWidthSpecified())
        {
            // adjust normal column by adding to min or subtracting from max
            pColCalc->_xWidth =
                fSubtract ?
                    pColCalc->_xMax - MulDivQuick(pColCalc->_xMax - pColCalc->_xMin,
                        iMax - iNormal,
                        iMax - iMin) :
                fUseMaxMax?
                    pColCalc->_xMax + MulDivQuick(pColCalc->_xMax, iNormal - iMax, iMax) :
                fUseMax ?
                    pColCalc->_xMax :
                fUseMin ?
                    pColCalc->_xMin :
                iMax ?
                    pColCalc->_xMin +
                    MulDivQuick(pColCalc->_xMax, iNormal - iMin, iMax) :
                    0;
        }
        else if (pColCalc->IsWidthSpecifiedInPercent())
        {
            //
            // if percent first calculate the width from the percent
            //
            iWidth = iPercent ?
                MulDivQuick(xTableWidth,
                    MulDivQuick(iP, pColCalc->GetPercentWidth(), iPercent),
                    100) :
                0;
            //
            // make sure it is over the min width
            //
            iWidth -= pColCalc->_xMin;
            if (iWidth < 0)
            {
                iWidth = 0;
            }
            pColCalc->_xWidth = pColCalc->_xMin + iWidth;
        }
        else
        {
            // adjust user column by adding to min or subtracting from max
            pColCalc->_xWidth =
                fUserSubtract   // table needs to be (iUserMax - iUser) pixels shorter, so subtract pixels
                                // from columns proportionally to (pColCalc->_xMax - pColCalc->_xMin)
                    ? pColCalc->_xMax - MulDivQuick(pColCalc->_xMax - pColCalc->_xMin,
                                                    iUserMax - iUser,
                                                    iUserMax - iUserMin)
                    :
                fUseUserMaxMax
                    ? pColCalc->_xMax + MulDivQuick(pColCalc->_xMax, iUser - iUserMax, iUserMax)
                    :
                fUseUserMax
                    ? pColCalc->_xMax
                    :
                fUseUserMin
                    ? pColCalc->_xMin
                    :
                iUserMax
                    ? pColCalc->_xMin + MulDivQuick(pColCalc->_xMax,
                                                    iUser - iUserMin,
                                                    iUserMax)
                    : 0;
        }
        Assert(pColCalc->_xWidth >= pColCalc->_xMin);

        // we can adjust this col since it is more than min width
        if (pColCalc->_xWidth > pColCalc->_xMin)
        {
            cAdjust++;
        }
        psize->cx += pColCalc->_xWidth;
    }

    // this is used to keep track of extra adjustment couldn't be applied
    iExtra = 0;

    // distribute rounding error

#if DBG == 1
    cLoop = 0;
#endif

    while (xTableWidth && (iWidth = xTableWidth + xTablePadding - psize->cx) != 0)
    {
        fUseAllColumns = FALSE;
        if (iWidth > 0)
        {
            if (cAdjust == 0)
            {
                // use all the cols if we add...
                cAdjust = cCols - cDisplayNoneCols;
                if (!cAdjust)
                    break;
                fUseAllColumns = TRUE;
            }
        }

        // the above protection for cAdjust doesn't happen if iWidth is neg.
        if (cAdjust==0)
            break;

        iMul = iWidth / cAdjust;                    // iMul is the adjustment for every column
        iDiv = iWidth % cAdjust;                    // left-over adjustment for all the columns
        iDelta = iDiv > 0 ? 1 : iDiv < 0 ? -1 : 0;  // is the +/- 1 pixel that is added to every column
        iExtra = 0;

        // start with the padding
        psize->cx = xTablePadding;

        // recalc cAdjust again
        cAdjust = 0;

        for (cC = cCols, pColCalc = _aryColCalcs;
            cC > 0;
            cC--, pColCalc++)
        {
            if (pColCalc->IsDisplayNone())
                continue;

            if (pColCalc->_xWidth > pColCalc->_xMin || (iWidth > 0 && fUseAllColumns))
            {
                pColCalc->_xWidth += iMul + iDelta + iExtra;
                // if we went below min we have to adjust back...

                if (pColCalc->_xWidth <= pColCalc->_xMin)
                {
                    iExtra = pColCalc->_xWidth - pColCalc->_xMin;
                    pColCalc->_xWidth = pColCalc->_xMin;
                }
                else
                {
                    iExtra = 0;
                    cAdjust++;
                }

                iDiv -= iDelta;
                if (!iDiv)
                {
                    iDelta = 0; // now left-over for every column is 0
                }
            }
            psize->cx += pColCalc->_xWidth;
        }
#if DBG == 1
        cLoop++;
        Assert(cLoop < 5);
#endif
    }

    Assert(!xTableWidth || (xTableWidth + xTablePadding == psize->cx) || (cCols == cDisplayNoneCols));
    PerfLog(tagTableColumn, this, "-CalculateColumns");
}

//+-------------------------------------------------------------------------
//
//  Method:     CalculateHeadersOrFootersRows
//
//  Synopsis:   
//
//--------------------------------------------------------------------------
void 
CTableLayoutBlock::CalculateHeadersOrFootersRows(
    BOOL                fHeaders,
    CTableCalcInfo *    ptci, 
    CSize *             psize, 
    CDispContainer *    pDispNodeTableInner)
{
    Assert(ptci);
    Assert(psize);

    CTableLayout *  pTableLayoutCache = ptci->TableLayoutCache();
    CTableRow *     pRow;
    CLayout *       pLayoutSiblingCell = NULL;
    int             iR, cR;
    BOOL            fRedoMinMax;

    Assert(pTableLayoutCache);

    cR = fHeaders ? pTableLayoutCache->GetHeaderRows() : pTableLayoutCache->GetFooterRows();

    if (cR > 0)
    {
        for (iR = fHeaders ? pTableLayoutCache->GetFirstHeaderRow() : pTableLayoutCache->GetFirstFooterRow(); 
            cR > 0; 
            cR--, iR = pTableLayoutCache->GetNextRow(iR))
        {
            pRow = pTableLayoutCache->_aryRows[iR];

            Assert(pRow->_fCompleted && !pTableLayoutCache->IsGenerated(iR) && !pRow->_fNeedDataTransfer);

            ptci->_pRow = pRow;
            ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(ptci->GetLayoutContext());
            ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();

            fRedoMinMax = pTableLayoutCache->CalculateRow(ptci, psize, &pLayoutSiblingCell, pDispNodeTableInner);
            Assert(!fRedoMinMax);

            if ((pRow->IsDisplayNone()  || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
                continue;

            //  if table has percent height the real row height may be bigger when calculated. 
            //  do correnction using compatible layout
            int cyHeightCompat = ((CTableRowLayoutBlock *)pRow->GetUpdatedLayout(GetContentMarkup()->GetCompatibleLayoutContext()))->_yHeight;
            if (ptci->_pRowLayout->_yHeight < cyHeightCompat)
            {
                Assert(ptci->_pRowLayout->PercentHeight());
                ptci->_pRowLayout->_yHeight = cyHeightCompat;
            }

            psize->cy += ptci->_pRowLayout->_yHeight + pTableLayoutCache->_yCellSpacing;
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CalculateLayout
//
//  Synopsis:   Calculate cell layout in the table
//
//--------------------------------------------------------------------------

void
CTableLayoutBlock::CalculateLayout(
    CTableCalcInfo * ptci,
    CSize *     psize,
    BOOL        fWidthChanged,
    BOOL        fHeightChanged)
{
    // Should be here only if print view
    Assert(!Table()->HasLayoutPtr() && Table()->HasLayoutAry());

    // Should have layout context
    Assert(ptci->GetLayoutContext());

    CTable         * pTable = ptci->Table();
    CTableLayout   * pTableLayoutCache = ptci->TableLayoutCache();

    // This should not be incremental recalc :
    Assert(fWidthChanged || fHeightChanged || IsSizeThis() || (!pTableLayoutCache->IsFixedBehaviour() && !pTableLayoutCache->IsRepeating()));

    SIZEMODE         smMode = ptci->_smMode;
    CSize            sizeTable;
    CTableCaption ** ppCaption;
    CDispContainer * pDispNodeTableOuter;
    CDispContainer * pDispNodeTableInner;
    CLayout        * pLayoutSiblingCell;
    int              cR, cRowsCalced, iR, iRowFirst;
    int              cC, iC;
    BOOL             fRedoMinMax    = FALSE;
    CTableRow      * pRow = NULL;
    int              cRows = pTableLayoutCache->GetRows();
    BOOL             fForceMinMax    = fWidthChanged && (pTableLayoutCache->_fHavePercentageInset || pTableLayoutCache->_fForceMinMaxOnResize);
    int              yTopInvalidRegion = 0;
    int              yCellSpacing;
    CLayoutBreak *          pLayoutBreak;
    CTableLayoutBreak *     pTableBreakStart = NULL; 
    CLayoutContext *        pLayoutContext = ptci->GetLayoutContext();
    BOOL                    fViewChain = (pLayoutContext->ViewChain() != NULL && ElementCanBeBroken());
    BOOL                    fCompatCalc = !fViewChain && pLayoutContext == GetContentMarkup()->GetCompatibleLayoutContext();
    int                     aiRowStart[TABLE_BREAKTYPE_MAX]; 
    int                     iRowBreak = -1;
    int                     yFromTop = 0;
    TABLE_BREAKTYPE         breakTypePrev = TABLE_BREAKTYPE_UNDEFINED; 
    TABLE_BREAKTYPE         breakTypeCurr = TABLE_BREAKTYPE_UNDEFINED; 
    LAYOUT_OVERFLOWTYPE     overflowTypePrev = LAYOUT_OVERFLOWTYPE_OVERFLOW; 
    LAYOUT_OVERFLOWTYPE     overflowTypeCurr = LAYOUT_OVERFLOWTYPE_OVERFLOW; 
    BOOL                    fRepeatHeaders = FALSE;
    BOOL                    fRepeatFooters = FALSE;
    BOOL                    fDoNotPositionRows = FALSE;
    BOOL                    fNoCompatPass = !pTableLayoutCache->_aryColCalcs.Size();
    CPeerHolder           * pPH = ElementOwner()->GetLayoutPeerHolder();

    TraceTagEx((tagTableLayoutBlock, TAG_NONAME|TAG_INDENT,
                "(CTableLayoutBlock: CalculateLayout %S pass - this=0x%x, e=[0x%x,%d]",
                fCompatCalc ? TEXT("COMPAT") : TEXT("BLOCK"), this, ElementOwner(), ElementOwner()->SN() ));

    CElement::CLock   Lock(pTable, CElement::ELEMENTLOCK_SIZING);

    Assert(pTableLayoutCache->CanRecalc());

    Assert(ptci->_yConsumed == 0 
        && "Improper CCalcInfo members handling ???");

#ifdef  TABLE_PERF
    ::StartCAP();
#endif

    PerfLog(tagTableLayout, this, "+CalculateLayout");

    if (!pTableLayoutCache->HasCaptions() && !cRows) // if the table is empty
    {
        pTableLayoutCache->_sizeMax =  g_Zero.size;
        pTableLayoutCache->_sizeMin =  g_Zero.size;
        *psize   =  g_Zero.size;
        sizeTable = g_Zero.size;
        pTableLayoutCache->_fZeroWidth = TRUE;
    }
    else
    {
        iRowFirst = -1;
        cRowsCalced = 0;

        aiRowStart[TABLE_BREAKTYPE_TCS]            = 0;
        aiRowStart[TABLE_BREAKTYPE_TOPCAPTIONS]    = 0;
        aiRowStart[TABLE_BREAKTYPE_ROWS]           = -1;
        aiRowStart[TABLE_BREAKTYPE_BOTTOMCAPTIONS] = 0;
        _fLayoutBreakType = LAYOUT_BREAKTYPE_LAYOUTCOMPLETE;

        // retrieve break info 
        if (fViewChain)
        {
            pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreak);

            if (pLayoutBreak)
            {
                if (pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LAYOUTCOMPLETE)
                {
                    pLayoutBreak = pLayoutContext->CreateBreakForLayout(this);
                    if (pLayoutBreak)
                    {
                        pLayoutBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LAYOUTCOMPLETE, LAYOUT_OVERFLOWTYPE_UNDEFINED);
                        pLayoutContext->SetLayoutBreak(ElementOwner(), pLayoutBreak);
                    }
                    GetSize(psize); // return original size (bug fix #71810)
                    return;
                }
                else 
                {
                    Assert(pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW);

                    pTableBreakStart = DYNCAST(CTableLayoutBreak, pLayoutBreak);
                    breakTypePrev    = pTableBreakStart->TableBreakType();
                    overflowTypePrev = pTableBreakStart->OverflowType();
                    aiRowStart[breakTypePrev] = pTableBreakStart->Row();
                    fRepeatHeaders   = pTableBreakStart->RepeatHeaders();
                    fRepeatFooters   = pTableBreakStart->RepeatFooters();
                }

                TraceTagEx((tagTableLayoutBlock, TAG_NONAME,
                            "* CTableLayoutBlock: Got starting break info : %d row of %S",
                            pTableBreakStart->Row(), 
                            (breakTypePrev == TABLE_BREAKTYPE_UNDEFINED)
                            ? TEXT("Undefined")
                            : (breakTypePrev == TABLE_BREAKTYPE_TCS) 
                                ? TEXT("Tc's")
                                : (breakTypePrev == TABLE_BREAKTYPE_TOPCAPTIONS) 
                                    ? TEXT("Top captions")
                                    : (breakTypePrev == TABLE_BREAKTYPE_ROWS) 
                                        ? TEXT("Rows") 
                                        : (breakTypePrev == TABLE_BREAKTYPE_BOTTOMCAPTIONS) 
                                            ? TEXT("Bottom captions")
                                            : TEXT("[ERROR : prohibited value !!!]"))
                            
                           );
            }
            else 
            {
                //  retrieve values for repeated headers / footers 
                if (pTableLayoutCache->GetHeaderRows())
                {
                    CTreeNode * pNode = pTableLayoutCache->_pHead->GetFirstBranch();
                    const CFancyFormat * pFF = pNode ? pNode->GetFancyFormat() : NULL;
                    fRepeatHeaders = (pFF != NULL && pFF->_bDisplay == styleDisplayTableHeaderGroup);
                }

                if (pTableLayoutCache->GetFooterRows())
                {
                    CTreeNode * pNode = pTableLayoutCache->_pFoot->GetFirstBranch();
                    const CFancyFormat * pFF = pNode ? pNode->GetFancyFormat() : NULL;
                    fRepeatFooters = (pFF != NULL && pFF->_bDisplay == styleDisplayTableFooterGroup);
                }

                TraceTagEx((tagTableLayoutBlock, TAG_NONAME,
                            "* CTableLayoutBlock: Got starting break info : from the beginning") );
            }
        }

        ptci->_fTableHasUserHeight = !GetFirstBranch()->GetFancyFormat()->GetHeight().IsNull();

        // reset perentage based rows
        pTableLayoutCache->_fHavePercentageRow = FALSE;

        // Create measurer.
        CLSMeasurer me;

        ptci->_pme = &me;

        //
        // Determine the cell widths/heights and row heights
        //

        do
        {
            //
            //  MIN MAX CALCULATION
            //  

            // calculate min/max only if that information is dirty or forced to do it
            // NOTE:   It would be better if tables, rows, and cells all individually tracked
            //         their min/max dirty state through a flag (as cells do now). This would
            //         allow CalculateMinMax to be more selective in the rows/cells it
            //         processed. (brendand)

            //  If this is view chain case we should have min max calc'ed in compatible calc phase
            //  but, if it wasn't done we better do it now to prevent crashes
            if (   (  !fViewChain
                    || fNoCompatPass)
                && (pTableLayoutCache->_sizeMin.cx <= 0 
                    ||  pTableLayoutCache->_sizeMax.cx <= 0 
                    || (ptci->_grfLayout & LAYOUT_FORCE) 
                    || fRedoMinMax 
                    || fForceMinMax))
            {
                TraceTag((tagTableCalc, "CTableLayout::CalculateLayout - calling CalculateMinMax (0x%x)", pTable));
                pTableLayoutCache->_fAlwaysMinMaxCells = pTableLayoutCache->_fAlwaysMinMaxCells || fRedoMinMax;
                pTableLayoutCache->CalculateMinMax(ptci, FALSE /* incremental min max*/);

                if (pTableLayoutCache->_sizeMin.cx < 0)
                {
                    return; // it means that we have failed incremental recalc, 
                            // because we have failed to load history
                }
            }

            Check(  pTableLayoutCache->IsFixed() 
                ||  (pTableLayoutCache->_sizeMin.cx != -1 && pTableLayoutCache->_sizeMax.cx != -1));

            pTableLayoutCache->_fForceMinMaxOnResize = FALSE;   // initialize to FALSE; (TRUE - means need to force min max on resize; bug #66432)

            //
            // Ensure display tree nodes exist
            // (Only do this the first time through the loop)
            //

            if (!fRedoMinMax)
            {
                EnsureTableDispNode(ptci, (ptci->_grfLayout & LAYOUT_FORCE));
            }

            pDispNodeTableOuter  = GetTableOuterDispNode();
            pDispNodeTableInner  = GetTableInnerDispNode();
            pLayoutSiblingCell = NULL;

            // Force is only needed during min/max calculations; or if there were no MinMax calc performed
            if (    !pTableLayoutCache->IsFixed() 
                // When cloning disp nodes need to make sure that all disp nodes are re-created 
                // thus forcing layout. 
                &&  !ptci->_fCloneDispNode   )
            {
                MtAdd( Mt(UsingFixedBehaviour3), 1, 0 );
                ptci->_grfLayout = (ptci->_grfLayout & ~LAYOUT_FORCE);
            }

            psize->cy = 0;

            //
            //  COLUMNs CALCULATION
            //  

            //  If this is view chain case we should have columns calc'ed in compatible calc phase
            if (   !fViewChain
                || fNoCompatPass)

            {
                psize->cx = 0;

                //
                // first calc columns and table width
                // the table layout is defined by the columns widths and row heights which in
                // turn will finalize the cell widths and heights
                //

                pTableLayoutCache->CalculateColumns(ptci, psize);
            }
            else
            {
                // restore width from cache _sizeIncremental
                psize->cx = pTableLayoutCache->_sizeIncremental.cx;
            }

            yCellSpacing = pTableLayoutCache->_yCellSpacing;

            CPoint  pt(0, 0);

            //
            //  TCs CALCULATION
            //  

            // do tc only if it is needed so
            if (breakTypePrev <= TABLE_BREAKTYPE_TCS) 
            {
                //
                // Size top CAPTIONs and TCs
                // NOTE: Position TCs on top of all CAPTIONs
                //

                ptci->_smMode = SIZEMODE_NATURAL;

                for (iC = aiRowStart[TABLE_BREAKTYPE_TCS], 
                        cC = pTableLayoutCache->_aryCaptions.Size(), 
                        ppCaption = &pTableLayoutCache->_aryCaptions[aiRowStart[TABLE_BREAKTYPE_TCS]]; 
                    iC < cC;
                    iC++, ppCaption++)
                {
                    if ((*ppCaption)->Tag() == ETAG_TC)
                    {
                        Assert((*ppCaption)->_uLocation == CTableCaption::CAPTION_TOP);
                        ptci->_pRowLayout = NULL;
                        pTableLayoutCache->SizeAndPositionCaption(ptci, psize, pDispNodeTableOuter, *ppCaption, &pt, fViewChain);

                        Assert(psize->cy == pt.y);

                        if (fViewChain)
                        {
                            if (ptci->_fLayoutOverflow || ptci->_cyAvail <= pt.y)
                            {
                                breakTypeCurr = TABLE_BREAKTYPE_TCS; 
                                iRowBreak = iC; 

                                if (!ptci->_fLayoutOverflow)
                                {
                                    //  restore hieght only if the whole row doesn't fit
                                    pt.y = psize->cy = ptci->_yConsumed; 
                                }
                                //  save width for next time calculations 
                                pTableLayoutCache->_sizeIncremental.cx = psize->cx;
                                break;
                            }
                            //  save height of the columns which fit 
                            ptci->_yConsumed = pt.y;
                        }
                    }
                }

                ptci->_smMode = smMode;
            }

            //
            //  TOP CAPTIONs CALCULATION
            //  

            if (breakTypePrev <= TABLE_BREAKTYPE_TOPCAPTIONS && breakTypeCurr == TABLE_BREAKTYPE_UNDEFINED) 
            {
                ptci->_smMode = SIZEMODE_NATURAL;

                for (iC = aiRowStart[TABLE_BREAKTYPE_TOPCAPTIONS], 
                        cC = pTableLayoutCache->_aryCaptions.Size(), 
                        ppCaption = &pTableLayoutCache->_aryCaptions[aiRowStart[TABLE_BREAKTYPE_TOPCAPTIONS]];
                     iC < cC;
                     iC++, ppCaption++)
                {
                    if (    (*ppCaption)->Tag() != ETAG_TC
                        &&  (*ppCaption)->_uLocation == CTableCaption::CAPTION_TOP)
                    {
                        ptci->_pRowLayout = NULL;
                        pTableLayoutCache->SizeAndPositionCaption(ptci, psize, pDispNodeTableOuter, *ppCaption, &pt, fViewChain);

                        Assert(psize->cy == pt.y);

                        if (fViewChain)
                        {

                            if (ptci->_fLayoutOverflow || ptci->_cyAvail <= pt.y)
                            {
                                breakTypeCurr = TABLE_BREAKTYPE_TOPCAPTIONS;
                                iRowBreak = iC; 

                                if (!ptci->_fLayoutOverflow)
                                {
                                    //  restore hieght only if the whole row doesn't fit
                                    pt.y = psize->cy = ptci->_yConsumed; 
                                }
                                //  save width for next time calculations 
                                pTableLayoutCache->_sizeIncremental.cx = psize->cx;
                                break;
                            }
                            //  save height of the columns which fit 
                            ptci->_yConsumed = pt.y;
                        }
                    }
                }

                ptci->_smMode = smMode;
            }

            // set _sizeParent in ptci
            ptci->SizeToParent(psize);

            // remember table top 
            _yTableTop = psize->cy;

            //
            //  ROWs CALCULATION
            //  

            //
            // Initialize the table height to just below the captions and top border
            //
            psize->cy += pTableLayoutCache->_aiBorderWidths[SIDE_TOP] + yCellSpacing;

            if (fViewChain)
            {
                ptci->_yConsumed = psize->cy;
            }

            Assert(pTableLayoutCache->AssertTableLayoutCacheCurrent()); 

            //
            // Calculate natural cell/row sizes
            // NOTE: Since the COLS attribute assigns column widths without examining every cell
            //       of every row, it is possible that a cell will contain content which cannot
            //       fit within the assigned size. If that occurs, all rows/cells before that
            //       point must be sized again to the larger width to prevent overflow.
            //

            if (breakTypePrev <= TABLE_BREAKTYPE_ROWS && breakTypeCurr == TABLE_BREAKTYPE_UNDEFINED)
            {
                Assert(!fViewChain
                    || (   pTableLayoutCache->_cyHeaderHeight != -1 
                        && pTableLayoutCache->_cyHeaderHeight != -1));

                Assert(!fRepeatHeaders 
                    || aiRowStart[TABLE_BREAKTYPE_ROWS] == -1
                    || !pTableLayoutCache->IsHeaderRow(aiRowStart[TABLE_BREAKTYPE_ROWS]));

                Assert(!fRepeatFooters
                    || aiRowStart[TABLE_BREAKTYPE_ROWS] == -1 
                    || !pTableLayoutCache->IsFooterRow(aiRowStart[TABLE_BREAKTYPE_ROWS]));

                if (fViewChain)
                {
                    if (!fRepeatHeaders)
                    {
                        pTableLayoutCache->_cyHeaderHeight = 0;
                    }

                    if (!fRepeatFooters)
                    {
                        pTableLayoutCache->_cyFooterHeight = 0;
                    }

                    //  recognize emergency case :- there is no enough from for our headers
                    if (   (fRepeatHeaders || fRepeatFooters)
                        && (ptci->_cyAvail 
                        // TODO (112605, olego) : current way to determind if we need to push 
                        // to the next page if headers and / or footers are repeated is not 
                        // consistent. We need to think about more reasonable value (or logic) 
                        // instead of just using yCellSpacing * 2. It will probably give awful 
                        // reasult if yCellSpacing is zero or too big. 
                        - (ptci->_yConsumed + yCellSpacing * 2)
                        - pTableLayoutCache->_cyHeaderHeight
                        - pTableLayoutCache->_cyFooterHeight) <= 0)
                    {
                        // if this is the first page - break to the next page 
                        if (breakTypePrev < TABLE_BREAKTYPE_ROWS)
                        {
                            breakTypeCurr = TABLE_BREAKTYPE_ROWS;
                            fDoNotPositionRows = TRUE;
                            break;
                        }
                        else 
                        {
                            Assert(breakTypePrev == TABLE_BREAKTYPE_ROWS);

                            // this is at least second page and there is no space 
                            // for headers and/or footers - do not respect CSS attributes 
                            fRepeatHeaders = 
                            fRepeatFooters = FALSE;

                            pTableLayoutCache->_cyHeaderHeight = 
                            pTableLayoutCache->_cyFooterHeight = 0;
                        }
                    }
                }

                iRowFirst = iR = aiRowStart[TABLE_BREAKTYPE_ROWS] != -1 
                    ? aiRowStart[TABLE_BREAKTYPE_ROWS] 
                        : pTableLayoutCache->GetFirstRow(fRepeatHeaders, fRepeatFooters);

                cR = (  cRows 
                    &&  iR < pTableLayoutCache->GetRows() 
                    &&  (cRows - (fRepeatHeaders ? pTableLayoutCache->GetHeaderRows() : 0) 
                               - (fRepeatFooters ? pTableLayoutCache->GetFooterRows() : 0) > 0) )
                        ? pTableLayoutCache->GetRemainingRows(iR, fRepeatHeaders, fRepeatFooters) : 0;

                //  NOTE : every time CalculateHeadersOrFootersRows() produce the same layout 
                //  it needs more omptimization here. 
                if (fRepeatHeaders)
                {
                    //  Should get here only if view chain
                    Assert(fViewChain);
                    CalculateHeadersOrFootersRows(TRUE, ptci, psize, pDispNodeTableInner);
                }

                if (fViewChain)
                {
                    ptci->_yConsumed =  psize->cy 
                                    +   pTableLayoutCache->_cyFooterHeight 
                                    +   yCellSpacing 
                                    +   pTableLayoutCache->_aiBorderWidths[SIDE_BOTTOM];
                }

                for (cRowsCalced = 0; cR > 0; cRowsCalced++, cR--, iR = pTableLayoutCache->GetNextRow(iR))
                {
                    pRow = pTableLayoutCache->_aryRows[iR];

                    //  in print view we don't deal with these cases yet 
                    Assert(pRow->_fCompleted && !pTableLayoutCache->IsGenerated(iR) && !pRow->_fNeedDataTransfer);

                    ptci->_pRow = pRow;
                    ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                    ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(pLayoutContext);

                    if (fViewChain) 
                    {
                        //  page-break-before support
                        if (    pTableLayoutCache->RowHasPageBreakBefore(ptci) 
                            && (   breakTypePrev    != TABLE_BREAKTYPE_ROWS
                                || iR != iRowFirst) 
                        )
                        {
                            breakTypeCurr    = TABLE_BREAKTYPE_ROWS;
                            overflowTypeCurr = LAYOUT_OVERFLOWTYPE_PAGEBREAKBEFORE;
                            iRowBreak        = iR;
                        
                            Assert(iRowBreak <= pTableLayoutCache->GetLastRow());
                        
                            break;
                        }
                        //  if there is no available height for the row
                        else if (   ptci->_cyAvail <= ptci->_yConsumed
                                // do not break if the first row AND no other content 
                                // on the page (preventing infinite pagination) 
                                &&  (iR != iRowFirst || ptci->_fHasContent) )   
                        {
                            breakTypeCurr    = TABLE_BREAKTYPE_ROWS;
                            overflowTypeCurr = LAYOUT_OVERFLOWTYPE_OVERFLOW;
                            iRowBreak        = iR;

                            break;
                        }
                    }

                    fRedoMinMax = pTableLayoutCache->CalculateRow(ptci, psize, &pLayoutSiblingCell, 
                                                pDispNodeTableInner, 
                                                fViewChain && ptci->_pFFRow->_bPositionType != stylePositionabsolute, 
                                                fViewChain && iR == iRowFirst, 
                                                (fViewChain && iR == iRowFirst && pTableBreakStart) 
                                                ? pTableBreakStart->YFromTop(iR) : 0)
                                &&  !pTableLayoutCache->_fAlwaysMinMaxCells;

                    // stop calculating rows when need to redo MinMax (since the cell in the row was too large to fit).
                    if (fRedoMinMax)
                    {
                        break;
                    }

                    Assert (ptci->_pRow == pRow);

                    if ((pRow->IsDisplayNone() || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
                        continue;

                    if (fViewChain)
                    {
                        //  if table has percent height the real row height may be bigger when calculated. 
                        //  do correnction using compatible layout
                        CTableRowLayoutBlock *pRowLayoutCompat;
                        LAYOUT_OVERFLOWTYPE   overflowType;

                        pRowLayoutCompat = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(GetContentMarkup()->GetCompatibleLayoutContext());
                        Assert(pRowLayoutCompat);

                        int cyHeightCompat = pRowLayoutCompat->_yHeight - 
                            (pTableBreakStart ? pTableBreakStart->YFromTop(iR) : 0);

                        if (ptci->_pRowLayout->_yHeight < cyHeightCompat)
                        {
                            int cyAvail = ptci->_cyAvail - ptci->_yConsumed;

                            CheckSz(ptci->_pRowLayout->_yHeight <= min(cyHeightCompat, cyAvail), 
                                "Descreasing the row height ???");

                            if (cyAvail < cyHeightCompat)
                            {
                                ptci->_pRowLayout->_yHeight = cyAvail;

                                // if we use calculated available height to set row height this means that 
                                // the row doesn't fit into the current page and layout overflow flag should be raised. 
                                // (in most cases _fLayoutOverflow is already set by table cell calc size code ,
                                // but for example if table cell has little content and big height value specified 
                                // content fit and _fLayoutOverflow will be FALSE, we still need to break though - bug #106158).
                                if (pRow->RowLayoutCache()->IsHeightSpecified()) 
                                {
                                    ptci->_fLayoutOverflow = TRUE;
                                }
                            }
                            else 
                            {
                                ptci->_pRowLayout->_yHeight = cyHeightCompat;
                            }

                            if (ptci->_pFFRow->_bPositionType == stylePositionrelative) 
                            {
                                //  if the row is relative update its disp node size.
                                CDispNode *pDispNode = ptci->_pRowLayout->GetElementDispNode();
                                Assert(pDispNode);

                                if (pDispNode)
                                {
                                    CSize size = pDispNode->GetSize();
                                    size.cy = ptci->_pRowLayout->_yHeight + yCellSpacing + yCellSpacing;
                                    pDispNode->SetSize(size, NULL, FALSE);
                                }
                            }
                        }

                        psize->cy        += ptci->_pRowLayout->_yHeight;
                        ptci->_yConsumed += ptci->_pRowLayout->_yHeight;

                        if (
                            // overflow condition
                                (   overflowType = LAYOUT_OVERFLOWTYPE_OVERFLOW, 
                                    ptci->_fLayoutOverflow 
                                || (ptci->_cyAvail <= ptci->_yConsumed)) 
                            // page-break-after support 
                            || (    overflowType = LAYOUT_OVERFLOWTYPE_PAGEBREAKAFTER, 
                                    pTableLayoutCache->RowHasPageBreakAfter(ptci)))
                        {
                            breakTypeCurr    = TABLE_BREAKTYPE_ROWS;
                            overflowTypeCurr = overflowType;
                            iRowBreak        = iR;

                            yFromTop = ptci->_pRowLayout->_yHeight + (pTableBreakStart ? pTableBreakStart->YFromTop(iR) : 0);

                            if (!ptci->_fLayoutOverflow)
                            {
                                if (cR == 1)
                                {
                                    // if this is the last row to calc 
                                    // clear the break 
                                    breakTypeCurr    = TABLE_BREAKTYPE_UNDEFINED; 
                                    overflowTypeCurr = LAYOUT_OVERFLOWTYPE_OVERFLOW; 
                                    iRowBreak        = -1; 
                                    yFromTop         = 0;
                                }
                                else 
                                {
                                    iRowBreak        = pTableLayoutCache->GetNextRow(iR);
                                    yFromTop         = 0;
                                }
                            }

                            Assert(iRowBreak < pTableLayoutCache->GetRows() && 
                                "Wrong break conditions !");

                            cRowsCalced++;
                            break;
                        }

                        psize->cy        += yCellSpacing;
                        ptci->_yConsumed += yCellSpacing;

                    }
                    else 
                    {
                        psize->cy += ptci->_pRowLayout->_yHeight + yCellSpacing;
                    }
                }

                //  NOTE : every time CalculateHeadersOrFootersRows() produce the same layout 
                //  it needs more omptimization here. 
                if (fRepeatFooters)
                {
                    //  Should get here only if view chain
                    Assert(fViewChain);
                    CalculateHeadersOrFootersRows(FALSE, ptci, psize, pDispNodeTableInner);
                }
            }

            AssertSz(!fRedoMinMax || fCompatCalc,
                "Redo mix max calculation in print view should only occur during compat calc.");

            //
            // If any cells proved too large for the pre-determined size,
            // force a min/max recalculation
            // NOTE: This should only occur when the COLS attribute has been specified
            //

            Assert(!fRedoMinMax || pTableLayoutCache->_cSizedCols || ptci->_fTableContainsCols);

        //
        // If a cell within a row returned a width greater than its minimum,
        // force a min/max pass over all cells (if not previously forced)
        // (When COLS is specified, not all cells are min/max'd - If the page author
        //  included content which does not fit in the specified width, this path
        //  is taken to correct the table)
        //

        } while (fRedoMinMax);

        pTableLayoutCache->_sizeIncremental = *psize;

        // set the positions of all cells
        if (   !fDoNotPositionRows 
            && breakTypePrev <= TABLE_BREAKTYPE_ROWS 
            && breakTypeCurr != TABLE_BREAKTYPE_TCS 
            && breakTypeCurr != TABLE_BREAKTYPE_TOPCAPTIONS)
        {
            if (fRepeatHeaders && (cR = pTableLayoutCache->GetHeaderRows()) > 0)
            {
                //  Should get here only if view chain
                Assert(fViewChain);

                for (iR = pTableLayoutCache->GetFirstHeaderRow(); 
                    cR > 0; 
                    cR--, iR = pTableLayoutCache->GetNextRow(iR))
                {
                    pRow = pTableLayoutCache->_aryRows[iR];

                    //  in print view we don't deal with these cases yet 
                    Assert(pRow->_fCompleted && !pTableLayoutCache->IsGenerated(iR) && !pRow->_fNeedDataTransfer);

                    ptci->_pRow = pRow;
                    ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(pLayoutContext);
                    ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                    pTableLayoutCache->SetCellPositions(ptci, psize->cx);
                }
            }

            for (iR = iRowFirst, cR = cRowsCalced; 
                cR > 0; 
                cR--, iR = pTableLayoutCache->GetNextRow(iR))
            {
                pRow = pTableLayoutCache->_aryRows[iR];

                //  in print view we don't deal with these cases yet 
                Assert(pRow->_fCompleted && !pTableLayoutCache->IsGenerated(iR) && !pRow->_fNeedDataTransfer);

                ptci->_pRow = pRow;
                ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(pLayoutContext);
                ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                pTableLayoutCache->SetCellPositions(ptci, psize->cx, fViewChain && iR == iRowFirst, fViewChain && cR == 1);
            }

            if (fRepeatFooters && (cR = pTableLayoutCache->GetFooterRows()) > 0)
            {
                //  Should get here only if view chain
                Assert(fViewChain);

                for (iR = pTableLayoutCache->GetFirstFooterRow(); 
                    cR > 0; 
                    cR--, iR = pTableLayoutCache->GetNextRow(iR))
                {
                    pRow = pTableLayoutCache->_aryRows[iR];

                    //  in print view we don't deal with these cases yet 
                    Assert(pRow->_fCompleted && !pTableLayoutCache->IsGenerated(iR) && !pRow->_fNeedDataTransfer);

                    ptci->_pRow = pRow;
                    ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(pLayoutContext);
                    ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                    pTableLayoutCache->SetCellPositions(ptci, psize->cx);
                }
            }
        }

        // adjust for table border

        psize->cy += pTableLayoutCache->_aiBorderWidths[SIDE_BOTTOM];

        // adjust table height if necessary (if view chain this should be done during compatible calc)
        if (!fViewChain)
        {
            if (    ElementOwner()->HasMarkupPtr() 
                &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
            {
                if (GetFirstBranch()->GetCharFormat()->_fUseUserHeight)
                {
                    pTableLayoutCache->CalculateRows(ptci, psize);
                }
            }
            else 
            {
                if (    !GetFirstBranch()->GetFancyFormat()->GetHeight().IsNull() 
                    ||  pTableLayoutCache->_fHavePercentageRow   )
                {
                    pTableLayoutCache->CalculateRows(ptci, psize);
                }
            }
        }

        // At this point rows are calc'ed so save headers / footers height if needed 
        if (fCompatCalc)
        {
            pTableLayoutCache->_cyHeaderHeight = 
            pTableLayoutCache->_cyFooterHeight = 0;

            for (iR = 0; iR < cRows; ++iR)
            {
                int *cyRows;

                if (pTableLayoutCache->IsHeaderRow(iR))
                {
                    cyRows = &(pTableLayoutCache->_cyHeaderHeight);
                }
                else if (pTableLayoutCache->IsFooterRow(iR))
                {
                    cyRows = &(pTableLayoutCache->_cyFooterHeight);
                }
                else 
                {
                    // headers / footers rows are first rows in the array, so as soon as current 
                    // row is body row we may stop.
                    break;
                }

                (*cyRows) += ((CTableRowLayoutBlock *)
                    ((pTableLayoutCache->_aryRows[iR])->GetUpdatedLayout(pLayoutContext)))->_yHeight + yCellSpacing;
            }
        }

        //
        // Save the size of the table (excluding CAPTIONs)
        //

        sizeTable.cx = psize->cx;
        sizeTable.cy = (breakTypeCurr == TABLE_BREAKTYPE_TCS 
            || breakTypeCurr == TABLE_BREAKTYPE_TOPCAPTIONS 
            || (breakTypeCurr == TABLE_BREAKTYPE_ROWS && fDoNotPositionRows)
            || breakTypePrev == TABLE_BREAKTYPE_BOTTOMCAPTIONS) ? 0
            : psize->cy - _yTableTop;

        //
        // Position the display node which holds the cells
        //

        if (_fHasCaptionDispNode)
        {
            pDispNodeTableOuter->SetPosition(CPoint(0, _yTableTop));
        }

        //
        // Size bottom CAPTIONs
        //

        if (breakTypeCurr == TABLE_BREAKTYPE_UNDEFINED)
        {
            CPoint          pt(0, psize->cy);
            BOOL            fInsertedBottomCaption = FALSE;
            CLayout *       pLayoutSiblingCaption = NULL;

            if (fViewChain)
            {
                ptci->_yConsumed = pt.y;
            }
            ptci->_smMode = SIZEMODE_NATURAL;

            for (iC = aiRowStart[TABLE_BREAKTYPE_BOTTOMCAPTIONS], 
                    cC = pTableLayoutCache->_aryCaptions.Size(), 
                    ppCaption = &(pTableLayoutCache->_aryCaptions[aiRowStart[TABLE_BREAKTYPE_BOTTOMCAPTIONS]]);
                 iC < cC;
                 iC++, ppCaption++)
            {
                if ((*ppCaption)->_uLocation == CTableCaption::CAPTION_BOTTOM)
                {
                    Assert((*ppCaption)->Tag() != ETAG_TC);

                    ptci->_pRowLayout = NULL;

                    if (fViewChain && ptci->_cyAvail <= ptci->_yConsumed)
                    {
                        breakTypeCurr = TABLE_BREAKTYPE_BOTTOMCAPTIONS;
                        iRowBreak     = 0; 
                        break;
                    }

                    if (fInsertedBottomCaption)
                    {
                        pTableLayoutCache->SizeAndPositionCaption(ptci, psize, &pLayoutSiblingCaption, *ppCaption, &pt, fViewChain);
                    }
                    else
                    {
                        pTableLayoutCache->SizeAndPositionCaption(ptci, psize, &pLayoutSiblingCaption, pDispNodeTableOuter, *ppCaption, &pt);
                        fInsertedBottomCaption = pLayoutSiblingCaption != NULL;
                    }

                    Assert(psize->cy == pt.y);

                    if (fViewChain)
                    {
                        if (ptci->_fLayoutOverflow || ptci->_cyAvail <= pt.y)
                        {
                            breakTypeCurr = TABLE_BREAKTYPE_BOTTOMCAPTIONS; 
                            iRowBreak = iC; 

                            if (!ptci->_fLayoutOverflow)
                            {
                                //  restore hieght only if the whole row doesn't fit
                                pt.y = psize->cy = ptci->_yConsumed; 
                            }
                            //  save width for next time calculations 
                            pTableLayoutCache->_sizeIncremental.cx = psize->cx;
                            break; 
                        }
                        ptci->_yConsumed = pt.y;
                    }
                }
            }
            ptci->_smMode = smMode;
        }

        if (pTableLayoutCache->_pAbsolutePositionCells)
        {
            int               cCells;
            CTableCell      **ppCell;
            CPoint          pt(0,0);
            int             yConsumedSafe = ptci->_yConsumed;

            ptci->_yConsumed = 0; // each layout should start with _yConsumed == 0 (#22575)

            for (cCells = pTableLayoutCache->_pAbsolutePositionCells->Size(), ppCell = *pTableLayoutCache->_pAbsolutePositionCells ;  
                cCells > 0; 
                cCells--, ppCell++)
            {
                pTableLayoutCache->CalcAbsolutePosCell(ptci, (*ppCell));
                (*ppCell)->ZChangeElement(0, &pt, pLayoutContext);
            }

            ptci->_yConsumed = yConsumedSafe;
        }

        if (fViewChain)
        {
            if (breakTypeCurr != TABLE_BREAKTYPE_UNDEFINED)
            {
                //  table has no more room to fill so put break info 
                pLayoutBreak = pLayoutContext->CreateBreakForLayout(this);
                pLayoutBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LINKEDOVERFLOW, overflowTypeCurr);
                DYNCAST(CTableLayoutBreak, pLayoutBreak)->SetTableLayoutBreak(breakTypeCurr, 
                    iRowBreak, yFromTop, fRepeatHeaders, fRepeatFooters);
            }
            else
            {
                //  table fits entirely 
                pLayoutBreak = pLayoutContext->CreateBreakForLayout(this);
                pLayoutBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LAYOUTCOMPLETE, LAYOUT_OVERFLOWTYPE_UNDEFINED);
            }

            if (pLayoutBreak)
            {
                pLayoutContext->SetLayoutBreak(ElementOwner(), pLayoutBreak);
                _fLayoutBreakType = pLayoutBreak->LayoutBreakType();
            }
        }
    }

    //
    // Size the display nodes
    //

    if (   pTableLayoutCache->_aryColCalcs.Size() == 0  // set the size to 0, if there is no real content
        && pTableLayoutCache->_aryCaptions.Size() == 0) // (there are no real cells nor captions)
    {
        sizeTable.cy = psize->cy = 0;  // NETSCAPE: doesn't add the border or spacing or height if the table is empty.
    }


    // at this point the size has been computed, so try to delegate 
    if (   pPH 
        && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
    {
        POINT pt;
        CDispContainer *pDispNodeTableOuter = NULL;
        pt.x = pt.y = 0;

        DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL, pPH, ptci, *psize, &pt, psize);

        // this will do table invalidation
        pTableLayoutCache->SizeTableDispNode(ptci, *psize, sizeTable, yTopInvalidRegion); 

        pDispNodeTableOuter= pTableLayoutCache->GetTableOuterDispNode();
        if (   pDispNodeTableOuter
            && (pt.x !=0 || pt.y !=0))
        {
            CSize sizeInsetTemp(pt.x, pt.y);
            pDispNodeTableOuter->SetInset(sizeInsetTemp);
        }
    }
    else
    {
        // this will do table invalidation
        pTableLayoutCache->SizeTableDispNode(ptci, *psize, sizeTable, yTopInvalidRegion); 
    }

    if (ElementOwner()->IsAbsolute())
    {
        ElementOwner()->SendNotification(NTYPE_ELEMENT_SIZECHANGED);
    }

    //
    // Make sure we have a display node to render cellborder if we need one
    // (only collapsed borders, rules or frame)
    //

    if (psize->cx || psize->cy)
    {
        pTableLayoutCache->EnsureTableBorderDispNode(ptci);
    }

#ifdef PERFMETER
    if (pTableLayoutCache->_fCalcedOnce)
    {
        MtAdd(Mt(CalculateLayout), +1, 0);
    }
#endif
    pTableLayoutCache->_fCalcedOnce = TRUE;

    PerfLog(tagTableLayout, this, "-CalculateLayout");

    TraceTagEx((tagTableLayoutBlock, TAG_NONAME|TAG_OUTDENT,
                ")CTableLayoutBlock: CalculateLayout %S pass - this=0x%x, e=[0x%x,%d]",
                fCompatCalc ? TEXT("COMPAT") : TEXT("BLOCK"), this, ElementOwner(), ElementOwner()->SN() ));

#ifdef  TABLE_PERF
    ::StopCAP();
#endif
}


//+-------------------------------------------------------------------------
//
//  Method:     CalculateLayout
//
//  Synopsis:   Calculate cell layout in the table
//
//--------------------------------------------------------------------------

void
CTableLayout::CalculateLayout(
    CTableCalcInfo * ptci,
    CSize *     psize,
    BOOL        fWidthChanged,
    BOOL        fHeightChanged)
{
    Assert(Table()->HasLayoutPtr() && !Table()->HasLayoutAry());

    SIZEMODE         smMode = ptci->_smMode;
    CSize            sizeTable;
    CTableCaption ** ppCaption;
    CDispContainer * pDispNodeTableOuter;
    CDispContainer * pDispNodeTableInner;
    CLayout *        pLayoutSiblingCell;
    int              cR, iR;
    int              cC;
    int              yCaption;
    BOOL             fRedoMinMax    = FALSE;
    BOOL             fTopCaption    = FALSE;

    BOOL             fIncrementalRecalc = !fWidthChanged && !fHeightChanged &&
                                        !_fDirtyBeforeLastRowIncremental &&
                                        (IsFixedBehaviour() || IsRepeating());
    CTableRow      * pRow = NULL;
    int              cRows = GetRows();
    int              cRowsIncomplete = 0;
    CTable         * pTable = ptci->Table();
    BOOL             fForceMinMax    = fWidthChanged && (_fHavePercentageInset || _fForceMinMaxOnResize);
    int              iLastRowIncremental = _iLastRowIncremental;
    BOOL             fIncrementalMinMax = FALSE;
    int              yTopInvalidRegion = 0;
    BOOL             fNeedDataTransfer;
    BOOL             fFooterRow;
    CPeerHolder    * pPH = ElementOwner()->GetLayoutPeerHolder();

    //  Rough check to make sure we are not out of rows limits while calc'ing incrementaly
    Assert(!fIncrementalRecalc || !iLastRowIncremental || iLastRowIncremental < cRows);

    CElement::CLock   Lock(pTable, CElement::ELEMENTLOCK_SIZING);

    Assert (CanRecalc());

    _fBottomCaption = FALSE;

    if (fIncrementalRecalc)
    {
        if (IsRepeating())
        {
            fIncrementalRecalc =   IsGenerationInProgress();
            // Check if readyState have changed from interactive to complete
            if (_fDatabindingRecentlyFinished)
            {
                fIncrementalRecalc = TRUE;  // last chunk of data have arived; we still can do incremental recalc
            }
            fIncrementalMinMax = _iLastRowIncremental && !IsFixedBehaviour();
            Assert (!fIncrementalMinMax || _cCalcedRows); // if we do incremental min max _cCalcedRows should not be 0
        }
        else
        {
            // do incremental recalc only when loading is not complete and there are new rows
            fIncrementalRecalc = _cCalcedRows != (cRows - (_pFoot? _pFoot->_cRows : 0));
            if (!fIncrementalRecalc)
            {
                // if it is a fixed style table and there are no new rows to claculate, just return
                GetSize(psize); // return original size (bug fix #71810)
                return;
            }
        }
    }

    _fDatabindingRecentlyFinished = FALSE;

#ifdef  TABLE_PERF
    ::StartCAP();
#endif

    PerfLog(tagTableLayout, this, "+CalculateLayout");

    if (!_aryCaptions.Size() && !cRows) // if the table is empty
    {
        _sizeMax =  g_Zero.size;
        _sizeMin =  g_Zero.size;
        *psize   =  g_Zero.size;
        sizeTable = g_Zero.size;
        _fZeroWidth = TRUE;
    }
    else
    {    
        ptci->_fTableHasUserHeight = !GetFirstBranch()->GetFancyFormat()->GetHeight().IsNull();

        // reset perentage based rows
        _fHavePercentageRow = FALSE;

        // Create measurer.
        CLSMeasurer me;

        ptci->_pme = &me;

        //
        // Determine the cell widths/heights and row heights
        //--------------------------------------------------------------------------------------
        do
        {
            // calculate min/max only if that information is dirty or forced to do it
            // NOTE:   It would be better if tables, rows, and cells all individually tracked
            //         their min/max dirty state through a flag (as cells do now). This would
            //         allow CalculateMinMax to be more selective in the rows/cells it
            //         processed. (brendand)
            if (_sizeMin.cx <= 0 || _sizeMax.cx <= 0 || (ptci->_grfLayout & LAYOUT_FORCE) || fRedoMinMax || fForceMinMax || fIncrementalMinMax)
            {
                TraceTag((tagTableCalc, "CTableLayout::CalculateLayout - calling CalculateMinMax (0x%x)", pTable));
                _fAlwaysMinMaxCells = _fAlwaysMinMaxCells || fRedoMinMax;

                // if it is an incremental recal, do min max calculation only for the first time or when table is growing
                if (!fIncrementalRecalc || (_cCalcedRows == 0) || fRedoMinMax || fIncrementalMinMax)
                {
                    // do min max
                    int xSizeMinOld = _sizeMin.cx;
                    int xSizeMaxOld = _sizeMax.cx;

                    CalculateMinMax(ptci, fIncrementalMinMax);
                    if (_sizeMin.cx < 0)
                    {
                        return; // it means that we have failed incremental recalc, 
                                // because we have failed to load history
                    }

                    if (!fIncrementalMinMax || xSizeMinOld != _sizeMin.cx || xSizeMaxOld != _sizeMax.cx)
                    {
                        // reset incremental recalc variables
                        // this will force CalculateColumns and recalc all the rows.
                        _cCalcedRows = 
                        iLastRowIncremental = 
                        _iLastRowIncremental = 0;   
                    }
                }
            }

            _fForceMinMaxOnResize = FALSE;   // initialize to FALSE; (TRUE - means need to force min max on resize; bug #66432)

            //
            // Ensure display tree nodes exist
            // (Only do this the first time through the loop)
            //

            if (!fRedoMinMax)
            {
                EnsureTableDispNode(ptci, (ptci->_grfLayout & LAYOUT_FORCE));
            }

            pDispNodeTableOuter  = GetTableOuterDispNode();
            pDispNodeTableInner  = GetTableInnerDispNode();
            pLayoutSiblingCell = NULL;


            // Force is only needed during min/max calculations; or if there were no MinMax calc performed
            if (!IsFixed())
            {
                MtAdd( Mt(NotUsingFixedBehaviour), 1, 0 );
                ptci->_grfLayout = (ptci->_grfLayout & ~LAYOUT_FORCE);
            }

            psize->cy = 0;

            // if it is an incremental recal, calculate columns only for the first time
            if (!fIncrementalRecalc  || (_cCalcedRows == 0))
            {
                CPoint  pt(0, 0);

                psize->cx = 0;

                //
                // first calc columns and table width
                // the table layout is defined by the columns widths and row heights which in
                // turn will finalize the cell widths and heights
                //

                CalculateColumns(ptci, psize);

                iLastRowIncremental = 
                _iLastRowIncremental = 0;

                //
                // Size top CAPTIONs and TCs
                // NOTE: Position TCs on top of all CAPTIONs
                //

                ptci->_smMode = SIZEMODE_NATURAL;

                for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
                     cC > 0;
                     cC--, ppCaption++)
                {
                    if ((*ppCaption)->Tag() == ETAG_TC)
                    {
                        Assert((*ppCaption)->_uLocation == CTableCaption::CAPTION_TOP);
                        ptci->_pRowLayout = NULL;
                        SizeAndPositionCaption(ptci, psize, pDispNodeTableOuter, *ppCaption, &pt);
                    }
                    else
                    {
                        if ((*ppCaption)->_uLocation == CTableCaption::CAPTION_TOP)
                        {
                            fTopCaption = TRUE;
                        }
                        else
                        {
                            _fBottomCaption = TRUE;
                        }
                    }
                }

                yCaption = pt.y;

                if (fTopCaption)
                {
                    for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
                         cC > 0;
                         cC--, ppCaption++)
                    {
                        CPoint  pt(0, yCaption);

                        if (    (*ppCaption)->Tag() != ETAG_TC
                            &&  (*ppCaption)->_uLocation == CTableCaption::CAPTION_TOP)
                        {
                            ptci->_pRowLayout = NULL;
                            SizeAndPositionCaption(ptci, psize, pDispNodeTableOuter, *ppCaption, &pt);
                        }

                        yCaption = pt.y;
                    }
                }
                ptci->_smMode = smMode;

                // set _sizeParent in tci

                ptci->SizeToParent(psize);

                // remember table top

                _yTableTop = psize->cy;

                //
                // Initialize the table height to just below the captions and top border
                //

                psize->cy += _aiBorderWidths[SIDE_TOP] + _yCellSpacing;

                cR = cRows;
                iR = GetFirstRow();

            }
            else
            {
                // in case of the incremenatl recalc
                cR = cRows - _cCalcedRows;
                iR = GetNextRow(iLastRowIncremental);
                *psize = _sizeIncremental;
                yTopInvalidRegion = psize->cy;
            }

            //
            // Calculate natural cell/row sizes
            // NOTE: Since the COLS attribute assigns column widths without examining every cell
            //       of every row, it is possible that a cell will contain content which cannot
            //       fit within the assigned size. If that occurs, all rows/cells before that
            //       point must be sized again to the larger width to prevent overflow.
            //

            fNeedDataTransfer = FALSE;
            for (; cR > 0; cR--, iR = GetNextRow(iR))
            {
                pRow = _aryRows[iR];
                if (!pRow->_fCompleted)
                {
                    Assert (!_fCompleted && IsFixedBehaviour());  // if row is not completed, table also should not be completed
                    continue;
                }
                if (IsGenerated(iR) && pRow->_fNeedDataTransfer)
                {
                    fNeedDataTransfer = TRUE;
                    continue;
                }

                fFooterRow = IsFooterRow(iR);
                if (fNeedDataTransfer && !fFooterRow)
                {
                    // this is a case where data-bound template consists of multiple rows and not all of them
                    // participate in data transfer
                    continue;
                }

                ptci->_pRow = pRow;
                ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout();
                ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                if (!fIncrementalRecalc || iR >= _cCalcedRows || fFooterRow)
                {
                    // calculate row (in case of incremental recalc - calculate only new rows)
                    fRedoMinMax = CalculateRow(ptci, psize, &pLayoutSiblingCell, pDispNodeTableInner)
                                &&  !_fAlwaysMinMaxCells;

                    // stop calculating rows when need to redo MinMax (since the cell in the row was too large to fit).
                    if (fRedoMinMax)
                        break;
                }

                Assert (ptci->_pRow == pRow);

                if ((pRow->IsDisplayNone()  || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
                    continue;

                psize->cy += ptci->_pRowLayout->_yHeight + _yCellSpacing;

                if (!fFooterRow)
                {
                    // data was not transfered
                    _iLastRowIncremental = iR;
                    _sizeIncremental = *psize;
                }
            }

            //
            // If any cells proved too large for the pre-determined size,
            // force a min/max recalculation
            // NOTE: This should only occur when the COLS attribute has been specified
            //

            Assert(!fRedoMinMax || _cSizedCols || ptci->_fTableContainsCols);

        //
        // If a cell within a row returned a width greater than its minimum,
        // force a min/max pass over all cells (if not previously forced)
        // (When COLS is specified, not all cells are min/max'd - If the page author
        //  included content which does not fit in the specified width, this path
        //  is taken to correct the table)
        //

        } while (fRedoMinMax);

        // set the positions of all cells
        if (!fIncrementalRecalc  || (_cCalcedRows == 0))
        {
            cR = cRows;
            iR = GetFirstRow();
        }
        else
        {
            // in case of the incremenatl recalc
            cR = cRows - _cCalcedRows;
            iR = GetNextRow(iLastRowIncremental);
        }

        fNeedDataTransfer = FALSE;
        for (;
             cR > 0;
             cR--, iR = GetNextRow(iR))
        {
            pRow = _aryRows[iR];
            if (!pRow->_fCompleted)
            {
                Assert (!_fCompleted && IsFixedBehaviour());    // if row is not completed, table also should not be completed
                Assert ( cR == 1 + (_pFoot? _pFoot->_cRows: 0) );   // last row
                cRowsIncomplete++;
                continue;
            }
            if (IsGenerated(iR) && pRow->_fNeedDataTransfer)
            {
                cRowsIncomplete++;
                fNeedDataTransfer = TRUE;
                continue;
            }

            fFooterRow = IsFooterRow(iR);
            if (fNeedDataTransfer && !fFooterRow)
            {
                // this is a case where data-bound template consists of multiple rows and not all of them
                // participate in data transfer. However if a row is added to the middle of a table, then
                // all following rows are not calculated
                cRowsIncomplete++;
                continue;
            }
            if (!fIncrementalRecalc || iR >= _cCalcedRows || fFooterRow)
            {
                ptci->_pRow = pRow;
                ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout();
                ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                SetCellPositions(ptci, psize->cx);
            }
        }

        // adjust for table border

        psize->cy += _aiBorderWidths[SIDE_BOTTOM];

        // adjust table height if necessary
        // Table is always horizontal => physical height
        if (    ElementOwner()->HasMarkupPtr() 
            &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
        {
            if (GetFirstBranch()->GetCharFormat()->_fUseUserHeight)
            {
                CalculateRows(ptci, psize);
            }
        }
        else 
        {
            if (    !GetFirstBranch()->GetFancyFormat()->GetHeight().IsNull() 
                ||  _fHavePercentageRow )
            {
                CalculateRows(ptci, psize);
            }
        }

        //
        // Save the size of the table (excluding CAPTIONs)
        //

        sizeTable.cx = psize->cx;
        sizeTable.cy = psize->cy - _yTableTop;

        //
        // Position the display node which holds the cells
        //

        if (_fHasCaptionDispNode)
        {
            pDispNodeTableOuter->SetPosition(CPoint(0, _yTableTop));
        }

        //
        // Size bottom CAPTIONs
        //

        if (_fBottomCaption)
        {
            CPoint          pt(0, psize->cy);
            BOOL            fInsertedBottomCaption = FALSE;
            CLayout *       pLayoutSiblingCaption = NULL;

            ptci->_smMode = SIZEMODE_NATURAL;

            for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
                 cC > 0;
                 cC--, ppCaption++)
            {
                if ((*ppCaption)->_uLocation == CTableCaption::CAPTION_BOTTOM)
                {
                    Assert((*ppCaption)->Tag() != ETAG_TC);

                    ptci->_pRowLayout = NULL;
                    if (fInsertedBottomCaption)
                    {
                        SizeAndPositionCaption(ptci, psize, &pLayoutSiblingCaption, *ppCaption, &pt);
                    }
                    else
                    {
                        SizeAndPositionCaption(ptci, psize, &pLayoutSiblingCaption, pDispNodeTableOuter, *ppCaption, &pt);
                        fInsertedBottomCaption = pLayoutSiblingCaption != NULL;
                    }
                }
            }
            ptci->_smMode = smMode;
        }

        if (_pAbsolutePositionCells)
        {
            int               cCells;
            CTableCell      **ppCell;
            CPoint          pt(0,0);
            for (cCells = _pAbsolutePositionCells->Size(), ppCell = *_pAbsolutePositionCells ;  cCells > 0; cCells--, ppCell++)
            {
                CalcAbsolutePosCell(ptci, (*ppCell));
                (*ppCell)->ZChangeElement(0, &pt);
            }
        }
    }

    // cache sizing/recalc data
    _cDirtyRows = 0;
    _cCalcedRows = cRows - cRowsIncomplete; // cache the number of rows that were calculated (needed for incremental recalc)
    if (_pFoot)
    {
        _cCalcedRows -= _pFoot->_cRows;     // _cCalcedRows excludes foot rows
        Assert (_cCalcedRows >=0);
    }

    //
    // Size the display nodes
    //

    if (   _aryColCalcs.Size() == 0  // set the size to 0, if there is no real content
        && _aryCaptions.Size() == 0) // (there are no real cells nor captions)
    {
        sizeTable.cy = psize->cy = 0;  // NETSCAPE: doesn't add the border or spacing or height if the table is empty.
    }


    // at this point the size has been computed, so try to delegate
    if (   pPH 
        && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
    {
        POINT pt;
        CDispContainer *pDispNodeTableOuter = NULL;
        pt.x = pt.y = 0;

        DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL, pPH, ptci, *psize, &pt, psize);

        // this will do table invalidation
        SizeTableDispNode(ptci, *psize, sizeTable, yTopInvalidRegion); 

        pDispNodeTableOuter = GetTableOuterDispNode();
        if (   pDispNodeTableOuter
            && (pt.x !=0 || pt.y !=0))
        {
            CSize sizeInsetTemp(pt.x, pt.y);
            pDispNodeTableOuter->SetInset(sizeInsetTemp);
        }
    }
    else
    {
        // this will do table invalidation
        SizeTableDispNode(ptci, *psize, sizeTable, yTopInvalidRegion); 
    }

    if (ElementOwner()->IsAbsolute())
    {
        ElementOwner()->SendNotification(NTYPE_ELEMENT_SIZECHANGED);
    }

    //
    // Make sure we have a display node to render cellborder if we need one
    // (only collapsed borders, rules or frame)
    //

    if (psize->cx || psize->cy)
        EnsureTableBorderDispNode(ptci);

#ifdef PERFMETER
    if (!_fIncrementalRecalc && _fCalcedOnce )
    {
        MtAdd(Mt(CalculateLayout), +1, 0);
    }
#endif

    _fIncrementalRecalc = FALSE;

    _fCalcedOnce = TRUE;

    _fDirtyBeforeLastRowIncremental = FALSE;

    PerfLog(tagTableLayout, this, "-CalculateLayout");


#ifdef  TABLE_PERF
    ::StopCAP();
#endif
}

void
CTableLayout::CalcAbsolutePosCell(CTableCalcInfo *ptci, CTableCell *pCell)
{
    CSize              sizeCell;
    CTableCellLayout * pCellLayout;
    CTable           * pTable = ptci->Table();
    const CHeightUnitValue * puvHeight;

    Assert(pCell);

    // Get cell's height in table coordinate system (table is always horizontal => physical height)
    puvHeight = (const CHeightUnitValue *)&pCell->GetFirstBranch()->GetFancyFormat()->GetHeight();

    pCellLayout = pCell->Layout(ptci->GetLayoutContext());
    pCellLayout->_fContentsAffectSize = TRUE;
    // Table is always horizontal => fVerticalLayoutFlow = FALSE
    sizeCell.cx = (int)pCellLayout->GetSpecifiedPixelWidth(ptci, FALSE);
    if (sizeCell.cx <= 0)
    {
        // NOTE(SujalP): If something changed in an abs pos'd cell, then
        // this function does not redo the min-max.
        // It uses the old max value and calls CalcSizeAtUserWidth. The new
        // width might be greater because of the changes, and we will size the
        // cell incorrectly in some cases. The right fix is for the table
        // to do a min-max pass on the cell over here to correctly get its max size.

        // If this is ppv case _sizeMax should be picked up from the corresponding 
        // cell in compatible layout context... (#22349)
        if (    ptci->GetLayoutContext() 
            &&  ptci->GetLayoutContext()->ViewChain()   )
        {
            CTableCellLayout * pCellLayoutCompat = (CTableCellLayout *)pCell->Layout(GetContentMarkup()->GetCompatibleLayoutContext());
            Assert(pCellLayoutCompat);

            sizeCell.cx = (int)pCellLayoutCompat->_sizeMax.cu;
        }
        else 
        {
            sizeCell.cx = (int)pCellLayout->_sizeMax.cu;
        }
    }
    
    sizeCell.cy = 0;
    pCellLayout->CalcSizeAtUserWidth(ptci, &sizeCell);
    
    // if the height of the cell is specified, take it.
    if (puvHeight->IsSpecified())
    {
        int iPixelHeight = puvHeight->GetPixelHeight(ptci, pTable);
        if (iPixelHeight > sizeCell.cy)
        {
            sizeCell.cy = iPixelHeight;
            pCellLayout->SizeDispNode(ptci, sizeCell);
        }
    }

    pCellLayout->SetYProposed(0);
    pCellLayout->SetXProposed(0);

    return;
}

//+--------------------------------------------------------------------------------------
//
// Layout methods overriding CLayout
//
//---------------------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CalcSizeVirtual, CTableLayout
//
//  Synopsis:   Calculate the size of the table
//
//              note, layoutBehaviors are now used for filters and so need to apply to tables.
//              this is threaded through this function only where size is actually calculated.
//
//--------------------------------------------------------------------------

DWORD
CTableLayout::CalcSizeVirtual( CCalcInfo * pci,
                               SIZE *      psize,
                               SIZE *      psizeDefault)
{
    Assert(pci);
    Assert(psize);
    Assert(pci->_smMode != SIZEMODE_SET);
    Assert(ElementOwner());

    AssertSz(  pci->GetLayoutContext() == NULL 
            || (!IsSizeThis() && !_fForceLayout), 
            "In PPV Table Layout Cache _fSizeThis and _fForceLayout should NOT be used !");

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CTableLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    CScopeFlag      csfCalcing(this);
    DWORD           grfReturn = (pci->_grfLayout & LAYOUT_FORCE);
    CTable        * pTable    = Table();
    CTableLayoutBlock * pTableLayout = pci->GetLayoutContext() == NULL ? this  
        : (CTableLayoutBlock *)pTable->GetUpdatedLayout(pci->GetLayoutContext());
    CPeerHolder   * pPH       = ElementOwner()->GetLayoutPeerHolder();
    BOOL    fViewChain        =   pci->GetLayoutContext() 
                               && pci->GetLayoutContext()->ViewChain();

    // Ignore requests on incomplete tables
#if DBG == 1
    if (!IsTagEnabled(tagTableRecalc))
#endif
    if (!CanRecalc() && !IsCalced())
    {
        psize->cx =
        psize->cy = 0;

        if (pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN)
            pTableLayout->SetSizeThis(FALSE);

        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CTableLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

        return grfReturn;
    }

    else if (TestLock(CElement::ELEMENTLOCK_BLOCKCALC) || !CanRecalc())
    {
        switch (pci->_smMode)
        {
        case SIZEMODE_NATURAL:
        case SIZEMODE_NATURALMIN:
            pTableLayout->SetSizeThis(FALSE);

        case SIZEMODE_SET:
        case SIZEMODE_FULLSIZE:
            pTableLayout->GetSize(psize);
            break;

        case SIZEMODE_MMWIDTH:
            psize->cx = _sizeMax.cx;
            psize->cy = _sizeMin.cx;
            break;

        case SIZEMODE_MINWIDTH:
            *psize = _sizeMin;
            break;
        }

        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CTableLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

        return grfReturn;
    }

    TraceTag((tagTableCalc, "CTableLayout::CalcSize - Enter (0x%x), smMode = %x, grfLayout = %x", pTable, pci->_smMode, pci->_grfLayout));

    CTableCalcInfo tci(pci, pTable, this);
    Assert(pTableLayout == tci.TableLayout());

    CSize sizeOriginal = g_Zero.size;

    if (pTableLayout->_fForceLayout)
    {
        pTableLayout->_fForceLayout   = FALSE;
        tci._grfLayout |= LAYOUT_FORCE;
        grfReturn      |= LAYOUT_FORCE;
    }

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        _fAutoBelow   = FALSE;
        _fPositionSet = FALSE;
    }

    EnsureTableLayoutCache();

    _cNestedLevel = tci._cNestedCalcs;

    // Table is always horizontal => physical width and height
    CTreeNode *         pNode = GetFirstBranch();
    const CFancyFormat * pFF  = pNode->GetFancyFormat();
    CWidthUnitValue  uvWidth  = pFF->GetWidth();
    CHeightUnitValue uvHeight = pFF->GetHeight();

    // For NS/IE compatibility, treat negative values as not present
    if (uvWidth.GetUnitValue() <= 0)
        uvWidth.SetNull();
    if (uvHeight.GetUnitValue() <= 0)
        uvHeight.SetNull();

    if (tci._smMode == SIZEMODE_NATURAL || tci._smMode == SIZEMODE_NATURALMIN)
    {
        long    cxParent;
        BOOL    fWidthChanged;
        BOOL    fHeightChanged;

        if (tci._smMode == SIZEMODE_NATURALMIN)
        {
            //
            // In NATURALMIN mode (TABLE inside TD) _sizeParent.cx or _sizeParent.cx
            // is set to lMaximumWidth. 
            // In this mode we want to get real table size, but in case of %width or 
            // %height, we use _sizeParent to get this information. But because of
            // lMaximumWidth we are returning wrong value, so in case of NATURALMIN 
            // mode set parent size to 0, to ignore sizes and get real table size.
            // NOTE: we will do the right thing in NATURAL mode.
            //
            tci.SizeToParent(0, 0);
        }

        pTableLayout->GetSize(&sizeOriginal);

        //
        // Determine the appropriate parent width
        // (If width is a percentage, use the full parent size as the parent width;
        //  otherwise, use the available size as the parent width)
        //

        cxParent = (uvWidth.IsSpecified() && PercentWidth()
                            ? tci._sizeParent.cx
                            : psize->cx);

        // 
        // Calculate propsed size 
        // 
        if (    ElementOwner()->HasMarkupPtr() 
            &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
        {
            const CCharFormat * pCF = pNode->GetCharFormat();

            //  _sizeProposed.cx does not matter since 
            //  1) table code already handles calculation of table width properly 
            //  2) table's width does not directly participate in table's children 
            //     width computantions
            _sizeProposed.cx = 0;
            
            if (pCF->_fUseUserHeight)
            {
                _sizeProposed.cy = uvHeight.YGetPixelValue(pci, pci->_sizeParent.cy, 
                    pNode->GetFontHeightInTwips(&uvHeight));
            }
            else 
            {
                _sizeProposed.cy = 0;
            }
        }

        // 
        //  (bug IE6 # 18002) this is a hack: 
        //  1. to prevent unnecessary calculation of table during percent second calc pass. 
        //  2. to preserve layout engine rendering as mush as possible in Trident compat 
        //     rendering mode. 
        // 
        //  If the table has a percent width and this is a percent second calc 
        //  (pci->_fPercentSecondPass == TRUE) lets compare new parent width with 
        //  our original width, because if the table defines the width of its parent, 
        //  parent size at percent second pass is equal to what the table returned 
        //  the first time (original width) 
        // 

        if (    ElementOwner()->HasMarkupPtr()
            &&  !ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document() 
            &&  pci->_fPercentSecondPass
            &&  PercentWidth()  )
        {
            fWidthChanged =     (tci._grfLayout & LAYOUT_FORCE)
                            ||  _sizeMax.cx < 0
                            ||  (   (_fHavePercentageCol || _fHavePercentageInset || _fForceMinMaxOnResize || PercentWidth())
                                &&  cxParent != sizeOriginal.cx)
                            ||  (   cxParent < sizeOriginal.cx
                                &&  sizeOriginal.cx > _sizeMin.cx)
                            ||  (   cxParent > sizeOriginal.cx
                                &&  sizeOriginal.cx < _sizeMax.cx);
        }
        else 
        {
            //
            // Table width changes if
            //  a) Forced to re-examine
            //  b) Min/max values are dirty
            //  c) Width  is a percentage and parent width has changed
            //  d) Width  is not specified and the available space has changed
            //  d) Parent is smaller/equal to table minimum and table is greater than minimum
            //  e) Parent is greater/equal to table maximum and table is less than maximum
            //

            fWidthChanged =     (tci._grfLayout & LAYOUT_FORCE)
                            ||  _sizeMax.cx < 0
                            ||  (   (_fHavePercentageCol || _fHavePercentageInset || _fForceMinMaxOnResize || PercentWidth())
                                &&  cxParent != pTableLayout->_sizeParent.cx)
                            ||  (   cxParent < pTableLayout->_sizeParent.cx
                                &&  sizeOriginal.cx > _sizeMin.cx)
                            ||  (   cxParent > pTableLayout->_sizeParent.cx
                                &&  sizeOriginal.cx < _sizeMax.cx);
        }

        fHeightChanged = (PercentHeight() && tci._sizeParent.cy != pTableLayout->_sizeParent.cy);

        //
        // Calculate a new size if
        //  a) The table is dirty
        //  b) Table width changed
        //  c) Height is a percentage and parent height has changed
        //  d) Not completed loading (table size is always dirty while loading)
        //

        pTableLayout->SetSizeThis(  pTableLayout->IsSizeThis()  
                                ||  fWidthChanged 
                                ||  fHeightChanged
                                ||  !_fCompleted );

        //
        // If the table needs it, recalculate its size
        //

        if ( pTableLayout->IsSizeThis() )
        {
            CSize   size = g_Zero.size;
            BOOL    fIncrementalRecalc = _fIncrementalRecalc;

            // Cache parent size
            pTableLayout->_sizeParent.cx = cxParent;
            pTableLayout->_sizeParent.cy = tci._sizeParent.cy;

            //
            // If There is a peer that wants full_delegation of the sizing...        
            //-------------------------------------------------------------------
            if (   pPH 
                && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
            {
                POINT pt;
                pt.x = pt.y = 0;

                DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION, pPH, &tci, *psize, &pt, psize);

                SizeTableDispNode(&tci, *psize, *psize, 0); 
            }
            else
            {
                if (fViewChain)
                {
                    //  If table is absolute positioned prohibit breaking 
                    if (pTable->IsAbsolute())
                    {
                        pTableLayout->SetElementCanBeBroken(FALSE);
                    }

                    // 
                    //  Defensive code if there is no available height to fill prohibit breaking 
                    //
                    if (pci->_cyAvail <= 0)
                    {
                        pTableLayout->SetElementCanBeBroken(FALSE);
                    }
                }

                //
                //  if this is top table and this is print view mode do compatible calc pass.
                //                              //  do calculations in working layout context if 
                if (_cNestedLevel == 0          // 1. we are top level table (otherwise we should be called from top level)
                    && fViewChain               // 2. there is a view chain
                    && pTableLayout->ElementCanBeBroken()   //  3. we are allowed to break
                   )
                {
                    //  NOTE (olego): here is the assumpion has been made that the page where table 
                    //  is starting is called to calc size _first_. if this is not true a wrong property 
                    //  will be set to compatible layout context.

                    CLayoutBreak *pLayoutBreak;

                    pci->GetLayoutContext()->GetLayoutBreak(ElementOwner(), &pLayoutBreak);
                    if (pLayoutBreak == NULL)
                    {
                        CLayoutContext *pLayoutContextCompat;

                        Assert(pTableLayout->GetContentMarkup());
                        pLayoutContextCompat = pTableLayout->GetContentMarkup()->GetUpdatedCompatibleLayoutContext(pci->GetLayoutContext());
                        Assert(pLayoutContextCompat);

                        CTableCalcInfo      TCI(pci, pTable, this);
                        CTableLayoutBlock  *pTableLayoutCompat = (CTableLayoutBlock *)pTable->GetUpdatedLayout(pLayoutContextCompat);
                        Assert(pTableLayoutCompat);

                        TCI.SetLayoutContext(pLayoutContextCompat);
                        TCI._pTableLayout = pTableLayoutCompat;

                        // Cache parent size
                        pTableLayoutCompat->_sizeParent.cx = cxParent;
                        pTableLayoutCompat->_sizeParent.cy = tci._sizeParent.cy;

                        pTableLayoutCompat->CalculateLayout(&TCI, &size, fWidthChanged, fHeightChanged);
                    }
                }

                pTableLayout->CalculateLayout(&tci, &size, fWidthChanged, fHeightChanged);
            }

            *psize      = size;

            pTableLayout->SetSizeThis( FALSE );
            grfReturn  |= LAYOUT_THIS |
                          (size.cx != sizeOriginal.cx
                                ? LAYOUT_HRESIZE
                                : 0)  |
                          (size.cy != sizeOriginal.cy
                                ? LAYOUT_VRESIZE
                                : 0);

            if (fIncrementalRecalc)
            {
                 _dwTimeEndLastRecalc = GetTickCount();
                 _dwTimeBetweenRecalc += 1000;  // increase the interval between the incremental reaclcs by 1 sec.
            }

#if DBG == 1
            if (IsTagEnabled(tagTableDump))
            {
                DumpTable(_T("CalcSize(SIZEMODE_NATURAL)"));
            }
#endif
        }
        else
        {
            // Otherwise, propagate the request through default handling
            *psize = sizeOriginal;
        }

        if(HasMapSizePeer())
            GetApparentSize(psize);
        
    }
    else if (  tci._smMode == SIZEMODE_MMWIDTH
            || tci._smMode == SIZEMODE_MINWIDTH
            )
    {
        // If There is a peer that wants full_delegation of the sizing...        
        //-------------------------------------------------------------------
        if (   pPH 
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
        {
            CElement::CLock   Lock(pTable, CElement::ELEMENTLOCK_SIZING);
            POINT             pt;

            pt.x = pt.y = 0;

            // Delegate to the layoutBehavior
            pTableLayout->DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION, 
                                           pPH, 
                                           pci, 
                                           *psize, 
                                           &pt, 
                                           psize);
        }
        else 
        {
            if (_sizeMax.cx < 0 || (tci._grfLayout & LAYOUT_FORCE))
            {
                CElement::CLock   Lock(pTable, CElement::ELEMENTLOCK_SIZING);

                CalculateBorderAndSpacing(&tci);
                CalculateMinMax(&tci);

                pTableLayout->SetSizeThis( TRUE );

                //
                // If an explicit width exists, then use that width (or the minimum
                // width of the table when the specified width is too narrow) for
                // both the minimum and maximum
                //

                if (    uvWidth.IsSpecified()
                    &&  !uvWidth.IsSpecifiedInPercent())
                {
                    long    cxWidth = uvWidth.GetPixelWidth(&tci, pTable);

                    if (cxWidth < _sizeMin.cx)
                    {
                        cxWidth = _sizeMin.cx;
                    }
                    else if (cxWidth > _sizeMin.cx)
                    {
                        _sizeMin.cx = cxWidth;
                    }

                    if (cxWidth < _sizeMax.cx)
                    {
                        _sizeMax.cx = cxWidth;
                    }
                }
            }

            if (tci._smMode == SIZEMODE_MMWIDTH)
            {
                psize->cx = _sizeMax.cx;
                psize->cy = _sizeMin.cx;
            }
            else
            {
                *psize = _sizeMin;
            }

            // at this point the MM size has been computed, so try to delegate 
            if (   pPH 
                && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
            {
                POINT pt;

                pt.x = pt.y = 0;
                pTableLayout->DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                                               pPH, 
                                               pci, 
                                               *psize, 
                                               &pt, 
                                                psize);
            }
        }

        //  At this point we want to update psize with a new information accounting filter 
        //  for MIN MAX Pass inside table cell.
        if (HasMapSizePeer())
        {
            // DelegateMapSize doesn't work when cy is 0. Trick it.
            if (tci._smMode == SIZEMODE_MINWIDTH)
                psize->cy = psize->cx;

            //  At this point we want to update psize with a new information accounting filter 
            CRect rectMapped(CRect::CRECT_EMPTY);
            // Get the possibly changed size from the peer
            if(DelegateMapSize(*psize, &rectMapped, pci))
            {
                psize->cy = psize->cx = rectMapped.Width();
            }

            if (tci._smMode == SIZEMODE_MINWIDTH)
                psize->cy = 0;
        }
      
    }
    else
    {
        // super properly handles layoutBehavior delegation
        grfReturn = super::CalcSizeVirtual(&tci, psize, NULL);
    }

    TraceTag((tagTableCalc, "CTableLayout::CalcSize - Exit (0x%x)", pTable));


    // If this table is nested, propagate out _fTableContainsCols, if set.
    if (pci->_fTableCalcInfo && tci._fTableContainsCols)
        ((CTableCalcInfo *) pci)->_fTableContainsCols = TRUE;


    if (pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN)
    {
        //
        //  Reset dirty state and remove posted layout request
        //

        _fDirty = FALSE;

        //
        // If any absolutely positioned sites need sizing, do so now
        //

        if (HasRequestQueue())
        {
            //
            //  To resize absolutely positioned sites, do MEASURE tasks.  Set that task flag now.
            //  If the call stack we are now on was instantiated from a WaitForRecalc, we may not have layout task flags set.
            //  There are two places to set them: here, or on the CDisplay::WaitForRecalc call.
            //  This has been placed in CalcSize for CTableLayout, C1DLayout, CFlowLayout, CInputLayout
            //  See bugs 69335, 72059, et. al. (greglett)
            //
            CTableCalcInfo  TCI(pci, pTable, this);
            TCI._grfLayout |= LAYOUT_MEASURE;
            ProcessRequests(&TCI, sizeOriginal);
        }

        Reset(FALSE);
        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
    }

    if (pci->_fTableCalcInfo && tci._fDontSaveHistory)
    {
        ((CTableCalcInfo *)pci)->_fDontSaveHistory = TRUE;  // propagate save history flag up.
    }

    if (fViewChain)
    {
        pci->_fLayoutOverflow = (pTableLayout->_fLayoutBreakType == LAYOUT_BREAKTYPE_LINKEDOVERFLOW);
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CTableLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}


//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::GetSpecifiedPixelWidth
//
//  Synopsis:   get user width
//
//  Returns:    returns user's specified width of the table (0 if not set or
//              if specified in %%)
//              if user set's width <= 0 it will be ignored
//-------------------------------------------------------------------------

long
CTableLayout::GetSpecifiedPixelWidth(CTableCalcInfo * ptci, BOOL *pfSpecifiedInPercent)
{
    // Table is always horizontal => physical width
    CWidthUnitValue uvWidth = GetFirstBranch()->GetFancyFormat()->GetWidth();

    long     xTableWidth = 0;
    BOOL     fSpecifiedInPercent = FALSE;
    CTable * pTable = ptci->Table();

    // NS/IE compatibility, any value <= 0 is treated as <not present>
    if ( uvWidth.GetUnitValue() <= 0 )
    {
        uvWidth.SetNull();
    }

    if (uvWidth.IsSpecified())
    {
        if (uvWidth.IsSpecifiedInPixel())
        {
            xTableWidth = uvWidth.GetPixelWidth(ptci, pTable);
        }
        else
        {
            fSpecifiedInPercent = TRUE;
        }
    }

    if (pfSpecifiedInPercent)
    {
        *pfSpecifiedInPercent = fSpecifiedInPercent;
    }

    return xTableWidth;
}


BOOL CTableLayout::IsGenerationInProgress()
{
    
    Assert (IsRepeating());

    BOOL             fNotFirstChunkOfData = _cCalcedRows > (_pHead? _pHead->_cRows: 0);
    BOOL             fIncrementalRecalc = FALSE;

    if (fNotFirstChunkOfData)
    {
        CTable          *pTable = Table();

        // do incremental recalc only when in a process of fetching rows and populating the table
            // or at the completion of the data set if it is not the first chunk of data.
        fIncrementalRecalc =   pTable->_readyStateTable == READYSTATE_INTERACTIVE;
    }
    return fIncrementalRecalc;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::RowHasPageBreakBefore
//
//  Synopsis:   checks if the row passed thru ptci or any of row's cells 
//              has page-break-before set. 
//              Also sets CCalcInfo::_fPageBreakLeft/Right
//
//-------------------------------------------------------------------------
BOOL 
CTableLayout::RowHasPageBreakBefore(CTableCalcInfo * ptci)
{
    Assert(ptci->_pRow);

    CTableCell **       ppCell;
    CTableCell *        pCell;
    CTableColCalc *     pColCalc;
    int                 cC;
    int                 cCols;
    CTreeNode *         pNode;
    const CFancyFormat* pFF;

    pNode = ptci->_pRow->GetFirstBranch();
    pFF   = pNode ? pNode->GetFancyFormat(LC_TO_FC(ptci->LayoutContext())) : NULL;

    if (pFF && !!GET_PGBRK_BEFORE(pFF->_bPageBreaks))
    {
        ptci->_fPageBreakLeft  |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft);
        ptci->_fPageBreakRight |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight);
        return TRUE;
    }

    Assert(ptci->_pRow->RowLayoutCache());

    ppCell = ptci->_pRow->RowLayoutCache()->_aryCells;
    cCols = GetCols();
    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, ppCell++, pColCalc++)
    {
        if (pColCalc->IsDisplayNone() || IsSpanned(*ppCell))
        {
            continue;
        }

        pCell = Cell(*ppCell);
        if (pCell)
        {
            pNode = pCell->GetFirstBranch();
            pFF   = pNode ? pNode->GetFancyFormat(LC_TO_FC(ptci->LayoutContext())) : NULL;

            if (pFF && !!GET_PGBRK_BEFORE(pFF->_bPageBreaks))
            {
                ptci->_fPageBreakLeft  |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft);
                ptci->_fPageBreakRight |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight);
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::RowHasPageBreakAfter 
//
//  Synopsis:   checks if the row passed thru ptci or any of row's cells 
//              has page-break-after set. 
//              Also sets CCalcInfo::_fPageBreakLeft/Right
//
//-------------------------------------------------------------------------
BOOL 
CTableLayout::RowHasPageBreakAfter (CTableCalcInfo * ptci)
{
    Assert(ptci->_pRow);

    CTableCell **       ppCell;
    CTableCell *        pCell;
    CTableColCalc *     pColCalc;
    CTableRowLayout *   pRowLayoutCache;
    int                 cC;
    int                 cCols;
    CTreeNode *         pNode;
    const   CFancyFormat* pFF;
    BOOL                fPageBreakAfterFound;

    pNode = ptci->_pRow->GetFirstBranch();
    pFF   = pNode ? pNode->GetFancyFormat(LC_TO_FC(ptci->LayoutContext())) : NULL;

    if (pFF && !!GET_PGBRK_AFTER(pFF->_bPageBreaks))
    {
        ptci->_fPageBreakLeft  |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft);
        ptci->_fPageBreakRight |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight);
        return TRUE;
    }

    pRowLayoutCache = ptci->_pRow->RowLayoutCache();
    Assert(pRowLayoutCache);

    ppCell = pRowLayoutCache->_aryCells;
    cCols = GetCols();
    fPageBreakAfterFound = FALSE;
    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, ppCell++, pColCalc++)
    {
        if (pColCalc->IsDisplayNone())
        {
            continue;
        }

        pCell = Cell(*ppCell);
        if (pCell)
        {
            pNode = pCell->GetFirstBranch();
            pFF   = pNode ? pNode->GetFancyFormat(LC_TO_FC(ptci->LayoutContext())) : NULL;

            if (pFF && !!GET_PGBRK_AFTER(pFF->_bPageBreaks))
            {
                int cCellRowSpan = pCell->RowSpan();

                if (IsSpanned(*ppCell))
                {
                    int iCellRowIndex = pCell->RowIndex();

                    // if ends in this row and this is the first column of the cell
                    if ((  iCellRowIndex + cCellRowSpan - 1 == pRowLayoutCache->RowPosition())
                        && pCell->ColIndex() == cCols - cC)
                    {
                        fPageBreakAfterFound = TRUE;
                    }
                }
                else if (cCellRowSpan == 1)
                {
                    fPageBreakAfterFound = TRUE;
                }

                if (fPageBreakAfterFound)
                {
                    ptci->_fPageBreakLeft  |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft);
                    ptci->_fPageBreakRight |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight);
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::ResetRowMinMax 
//
//  Synopsis:   resets minmax valid on all cells belonging to given row
//
//-------------------------------------------------------------------------
void 
CTableLayout::ResetRowMinMax(CTableRowLayout *pRowLayoutCache)
{
    CTableCell **       ppCell;
    CTableCell *        pCell;
    CTableCellLayout *  pCellLayout;
    CTableColCalc *     pColCalc;
    int                 cC;
    CMarkup *           pMarkup;
    CLayoutContext *    pLayoutContextCompat;

    if (_fTLCDirty || !pRowLayoutCache)
        return;

    // its ok to be dirty, because we are just resetting anyhow
    WHEN_DBG( BOOL fDisableTLCAssert = _fDisableTLCAssert; _fDisableTLCAssert = TRUE; )

    cC = GetCols();

    WHEN_DBG( _fDisableTLCAssert = fDisableTLCAssert; )

    if (_aryColCalcs.Size() < cC)
    {
        //  We are not ready yet
        return;
    }

    pMarkup = GetContentMarkup();
    pLayoutContextCompat = (pMarkup && pMarkup->HasCompatibleLayoutContext()) 
        ? pMarkup->GetCompatibleLayoutContext() : NULL;

    ppCell = pRowLayoutCache->_aryCells;
    for (pColCalc = _aryColCalcs;
        cC > 0;
        cC--, ppCell++, pColCalc++)
    {
        if (pColCalc->IsDisplayNone())
        {
            continue;
        }

        pCell = Cell(*ppCell);
        if (pCell)
        {
            pCellLayout = (CTableCellLayout *)pCell->GetUpdatedLayout(pLayoutContextCompat);
            Assert(pCellLayout);

            pCellLayout->ResetMinMax();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\table\ltableom.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltableom.cxx
//
//  Contents:   CTableLayout object model methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx" // CTreePosList
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif


#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::createTHead
//
//  Synopsis:   Table Layout OM method helper
//
//  Arguments:  ppHead - return value
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::createTHead(IDispatch** ppHead)
{
    HRESULT               hr;
    CElement  *           pAdjacentElement = NULL;
    CElement::Where       where;
    CElement  *           pElement = NULL;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (!_pHead)
    {
        hr = Doc()->CreateElement(ETAG_THEAD, &pElement);
        if (hr)
            goto Cleanup;

        Assert (pElement);

        hr = ensureTBody();
        if (hr)
            goto Cleanup;

        pAdjacentElement = _pFoot? _pFoot : _aryBodys[0];    // insert right before 1st body, or before the footer
        where = CElement::BeforeBegin;

        hr = insertElement(pAdjacentElement, pElement, where, TRUE);

        if (hr)
            goto Cleanup;
        
        Assert (pElement == _pHead);
    }
    
    if (ppHead)
    {
        hr = _pHead->QueryInterface(IID_IHTMLTableSection, (void **)ppHead);
    }

Cleanup:

    CElement::ReleasePtr(pElement);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::deleteTHead
//
//  Synopsis:   Table Layout OM method helper
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::deleteTHead()
{
    HRESULT hr = EnsureTableLayoutCache();

    if (hr)
        goto Cleanup;

    if (_pHead)
    {
        hr = deleteElement(_pHead);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::createTFoot
//
//  Synopsis:   Table Layout OM method helper
//
//  Arguments:  ppHead - return value
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::createTFoot(IDispatch** ppFoot)
{
    HRESULT               hr;
    CElement  *           pAdjacentElement = NULL;
    CElement::Where       where;
    CElement  *           pElement = NULL;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (!_pFoot)
    {
        hr = Doc()->CreateElement(ETAG_TFOOT, &pElement);
        if (hr)
            goto Cleanup;

        Assert (pElement);
        hr = ensureTBody();
        if (hr)
            goto Cleanup;

        pAdjacentElement = _aryBodys[0];    // insert right before the first body
        where = CElement::BeforeBegin;

        hr = insertElement(pAdjacentElement, pElement, where, TRUE);

        if (hr)
            goto Cleanup;
        
        Assert (pElement == _pFoot);
    }
    
    if (ppFoot)
    {
        hr = _pFoot->QueryInterface(IID_IHTMLTableSection, (void **)ppFoot);
    }

Cleanup:

    CElement::ReleasePtr(pElement);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::ensureTBody
//
//  Synopsis:   Table Layout OM method helper
//
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::ensureTBody()
{
    HRESULT               hr = S_OK;
    CElement  *           pAdjacentElement = NULL;
    CElement::Where       where;
    CElement  *           pElement = NULL;

    if (!_aryBodys.Size())
    {
        hr = Doc()->CreateElement(ETAG_TBODY, &pElement);
        if (!hr)
        {
            Assert (pElement);
            pAdjacentElement = Table();    // insert right before the end of table
            where = CElement::BeforeEnd;
            _fEnsureTBody = TRUE;
            hr = insertElement(pAdjacentElement, pElement, where, TRUE);
            _fEnsureTBody = FALSE;
        }
    }
    
    CElement::ReleasePtr(pElement);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::deleteTFoot
//
//  Synopsis:   Table Layout OM method helper
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::deleteTFoot()
{
    HRESULT hr = EnsureTableLayoutCache();

    if (hr)
        goto Cleanup;

    if (_pFoot)
    {
        hr = deleteElement(_pFoot);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::createCaption
//
//  Synopsis:   Table Layout OM method helper
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::createCaption(IHTMLTableCaption** ppCaption)
{
    HRESULT         hr;
    CElement      * pNewElement = NULL;
    CTableCaption * pCaption;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    pCaption = GetFirstCaption();
    if (!pCaption)
    {
        hr = Doc()->CreateElement(ETAG_CAPTION, &pNewElement);
        if (hr)
            goto Cleanup;

        Assert (pNewElement);

        // If there are no captions then insert right after the beginning of the table.
        hr = insertElement(ElementOwner(), pNewElement, CElement::AfterBegin, TRUE);

        if (hr)
            goto Cleanup;

        Assert (pNewElement == _aryCaptions[0]);

        pCaption = DYNCAST(CTableCaption, pNewElement);
    }
    
    if (ppCaption)
    {
        hr = pCaption->QueryInterface(IID_IHTMLTableCaption, (void **)ppCaption);
    }

Cleanup:
    CElement::ReleasePtr(pNewElement);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::deleteCaption
//
//  Synopsis:   Table Layout OM method helper
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::deleteCaption()
{
    CTableCaption * pCaption;
    HRESULT         hr;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    pCaption = GetFirstCaption();

    if (pCaption)
    {
        hr = deleteElement(pCaption);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     VisualRow2Index (helper function)
//
//  Synopsis:   converts visual row index to an index into an _aryRows.
//
//----------------------------------------------------------------------------

int
CTableLayout::VisualRow2Index(int iRow)
{
    int cRowsFoot = _pFoot? _pFoot->_cRows : 0;

    Assert(IsTableLayoutCacheCurrent());

    if (cRowsFoot)
    {
        int cRowsHead = _pHead? _pHead->_cRows : 0;
        if (iRow >= cRowsHead)
        {
            int cRowsTotal= GetRows();
            if (iRow >= cRowsTotal - cRowsFoot)
            {
                // it is a footer row
                iRow += _pFoot->_iRow - (cRowsTotal - cRowsFoot);
            }
            else
            {
                // it is a body row
                iRow += cRowsFoot;
            }
        }
        // else it is a header row
    }// else there is nothing to do

    return iRow;
}


HRESULT
CTableLayout::insertElement(CElement *pAdjacentElement, 
                            CElement *pInsertElement, 
                            CElement::Where where, 
                            BOOL fIncrementalUpdatePossible)
{
    HRESULT     hr;
    CDoc* pDoc = Doc();
    CParentUndo pu( pDoc  );

    Assert (pAdjacentElement);
    Assert (pInsertElement);

    if( IsEditable() )
    {
        pu.Start( IDS_UNDONEWCTRL );
        hr = THR( pDoc->BeginSelectionUndo());
    }
    
    _fTableOM = fIncrementalUpdatePossible;
    hr = pAdjacentElement->InsertAdjacent(where, pInsertElement);
    _fTableOM = FALSE;
    
    if (!hr)
    {
        ///////////////////////////////////////////////////////////////////////////////////
        // winse 25479 a-naande 9-3-2002
        // it isn't necessary to call this when fIncrementalUpdatePossible is FALSE, since
        // it will repeat actions done elsewhere and causes a performance hit
        // when TRUE it is necessary and the performance hit is minimal
        if(fIncrementalUpdatePossible)Fixup(fIncrementalUpdatePossible);

        // VID wants us to save out end tags to elements inserted via the TOM (IE5, 23789).
        pInsertElement->_fExplicitEndTag = TRUE;
    }

    if ( IsEditable() )
    {
        hr = THR( pDoc->EndSelectionUndo() );
        pu.Finish( hr );        
    }

    RRETURN (hr);
}


HRESULT
CTableLayout::deleteElement(CElement *pDeleteElement, 
                            BOOL fIncrementalUpdatePossible)
{
    HRESULT     hr;
    BOOL        fInBrowseMode = !IsEditable();
    CDoc* pDoc = Doc();
    CParentUndo pu( pDoc );
    
    Assert (pDeleteElement);

  
    if( !fInBrowseMode )
    {
        pu.Start( IDS_UNDODELETE );   
        hr = THR( pDoc->BeginSelectionUndo() );
    }

    _fTableOM = fIncrementalUpdatePossible;
    hr = pDeleteElement->RemoveOuter();
    _fTableOM = FALSE;
    if (!hr)
    {
        Fixup(fIncrementalUpdatePossible);
    }

    if( !fInBrowseMode )
    {
        hr = THR( pDoc->EndSelectionUndo() );
        pu.Finish( hr );        
    }        


    RRETURN (hr);
}


HRESULT
CTableLayout::moveElement( IMarkupServices * pMarkupServices,
                           IMarkupPointer  * pmpBegin,
                           IMarkupPointer  * pmpEnd,
                           IMarkupPointer  * pmpTarget )
{
    HRESULT     hr;
    CDoc* pDoc = Doc();
    CParentUndo pu( pDoc );

    Assert(pMarkupServices && pmpBegin && pmpEnd && pmpTarget);

    if( IsEditable() )
    {
        pu.Start( IDS_UNDONEWCTRL );
        hr = THR( pDoc->BeginSelectionUndo());
    }

    hr = THR(pMarkupServices->Move(pmpBegin, pmpEnd, pmpTarget));
    if (!hr)
    {
        Fixup();
    }

    if ( IsEditable() )
    {
        hr = THR( pDoc->EndSelectionUndo());
        pu.Finish( hr );        
    }
    
    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\table\ltcell.cxx ===
//  Microsoft Forms
    //  Copyright (C) Microsoft Corporation, 1994-1996
    //
    //  File:       ltcell.cxx
    //
    //  Contents:   Implementation of CTableCellLayout and related classes.
    //
    //----------------------------------------------------------------------------
    
    #include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
    
    #ifndef X_LTABLE_HXX_
    #define X_LTABLE_HXX_
    #include "ltable.hxx"
    #endif
    
    #ifndef X_LTCELL_HXX_
    #define X_LTCELL_HXX_
    #include "ltcell.hxx"
    #endif
    
    #ifndef X_LTROW_HXX_
    #define X_LTROW_HXX_
    #include "ltrow.hxx"
    #endif
    
    #ifndef X_DISPDEFS_HXX_
    #define X_DISPDEFS_HXX_
    #include "dispdefs.hxx"
    #endif
    
    #ifndef X_DISPNODE_HXX_
    #define X_DISPNODE_HXX_
    #include "dispnode.hxx"
    #endif
    
    ExternTag(tagTableRecalc);
    ExternTag(tagTableCalc);
    ExternTag(tagLayoutTasks);
    ExternTag(tagCalcSize);
    ExternTag(tagTableBorder);
    
    extern const WORD s_awEdgesFromTableFrame[htmlFrameborder+1];
    extern const WORD s_awEdgesFromTableRules[htmlRulesall+1];
    
    MtDefine(CTableCellLayout, Layout, "CTableCellLayout")
    MtDefine(CTableCellLayoutBreak_pv, ViewChain, "CTableLayoutBreak_pv");
    
    const CLayout::LAYOUTDESC CTableCellLayout::s_layoutdesc =
    {
        LAYOUTDESC_TABLECELL    |
        LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
    };
    
    
    //+------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::GetAutoSize, CTxtEdit
    //
    //  Synopsis:   Return if autosize
    //
    //  Returns:    TRUE if autosize
    //
    //-------------------------------------------------------------------------
    
    BOOL
    CTableCellLayout::GetAutoSize() const
    {
        return _fContentsAffectSize;
    }
    
    //-----------------------------------------------------------------------------
    //
    //  Member:     Notify
    //
    //  Synopsis:   Respond to a tree notification
    //
    //  Arguments:  pnf - Pointer to the tree notification
    //
    //-----------------------------------------------------------------------------
    void
    CTableCellLayout::Notify(
        CNotification * pnf)
    {
        if (Tag() == ETAG_CAPTION && pnf->IsType(NTYPE_ZERO_GRAY_CHANGE))
               return ;
    
        Assert(!pnf->IsReceived(_snLast));
    
        // ignore focus notifications
        Assert(pnf->Element() != ElementOwner()         ||
               (LayoutContext() && pnf->IsType(NTYPE_ELEMENT_RESIZE))   ||  //  Due to changing of nf type in PPV
               ElementOwner()->HasSlavePtr()            ||
               pnf->IsType(NTYPE_ELEMENT_REMEASURE)     ||
               pnf->IsType(NTYPE_DISPLAY_CHANGE)        ||
               pnf->IsType(NTYPE_VISIBILITY_CHANGE)     ||
               pnf->IsType(NTYPE_ELEMENT_MINMAX)        ||
               pnf->IsType(NTYPE_ELEMENT_ENSURERECALC)  || 
               pnf->IsType(NTYPE_ELEMENT_ADD_ADORNER)   ||      // TODO (112607, michaelw) remove this when ADORNERS is turned off
               IsInvalidationNotification(pnf));
    
        if (    pnf->Element() == ElementOwner()
            &&  pnf->IsType(NTYPE_ELEMENT_RESIZE)   )
        {
            Assert(LayoutContext());
            return ;
        }

        BOOL            fWasDirty = IsDirty() || IsSizeThis();
        CTable *        pTable    = Table();
        CTableLayout *  pTableLayout   = pTable
                                        ? pTable->TableLayoutCache()
                                        : NULL;
    
        //
        //  Stand-alone cells behave like normal text containers
        //
    
        if (!pTable)
        {
            super::Notify(pnf);
            return;
        }
    
        if (pnf->IsType(NTYPE_ELEMENT_MINMAX))
        {
            if (pTableLayout)
                pTableLayout->_fDontSaveHistory = TRUE;
        }
        //
        //  First, start with default handling
        //  (But prevent posting a layout request)
        //
    
        if (    (   pTableLayout
                &&  pTableLayout->CanRecalc())
            ||  (   !pnf->IsType(NTYPE_ELEMENT_ENSURERECALC)
                &&  !pnf->IsType(NTYPE_RANGE_ENSURERECALC)))
        {
            CSaveNotifyFlags    snf(pnf);
    
            pnf->SetFlag(NFLAGS_DONOTLAYOUT);
            super::Notify(pnf);
            if (   IsEditable()
                && (     pnf->IsTextChange()
                     ||  pnf->IsType(NTYPE_ELEMENT_REMEASURE)
                     ||  pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE)
                     ||  pnf->IsType(NTYPE_CHARS_RESIZE)))
            {
                pTableLayout->ResetMinMax();
            }
        }
    
        if ( pnf->IsType(NTYPE_DISPLAY_CHANGE) )
        {
            CElement *pElem = pnf->Element();
            if (   pElem == ElementOwner()
                || pElem->IsRoot())             // this case covers disply change on the style sheet. (bug #77806)
                                                // TODO (112607) : what we should really check here is if the style sheet display changes
                                                // and this is a cell's style, then call HandlePositionDisplayChnage()
            {
                HandlePositionDisplayChange();
            }
        }
        //
        //  Resize the cell if content has changed
        //
        //  (If the notification is not being forwarded, then take it over;
        //   otherwise, post a new, resize notification)
        //
        //  TODO (112607, brendand) : We could do better than this for "fixed" tables
        //
        if (   IsDirty()
            ||  (   pnf->IsType(NTYPE_ELEMENT_MINMAX)   // inside of me there is an element who needs to be min-maxed
                &&  !TestLock(CElement::ELEMENTLOCK_SIZING)
                &&  !pnf->Node()->IsAbsolute()))
        {
            Assert(!TestLock(CElement::ELEMENTLOCK_SIZING));
    
            if (!fWasDirty)
            {
                Assert(!IsSizeThis());
    
                if (    pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED)
                    &&  pnf->IsHandled())
                {
                    pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
                }
                else
                {
                    ElementOwner()->ResizeElement();
                }
            }
            // In databinding, if a row is added into the middle of a table, then it is not calced right away.
            // Instead it is left _fSizeThis (but with no layoutTask) and not included in the table height.
            // after the bind Event (and text injection) DataTransferServiced() allows the table to now calculate
            // the row but now we need a layout task to initiate the process.  Since the cell WAS dirty, most
            // notification code assumes that a task is alreay posted.  Here we need to do otherwise.
            // see bug 88896.  PERF - becarful here.
            else if (   pnf->IsTextChange()
                     && !pnf->Node()->IsAbsolute()
                     && !TestLock(CElement::ELEMENTLOCK_SIZING)
                     && IsDirty()
                     && pTableLayout 
                     && pTableLayout->CanRecalc()
    #ifndef NO_DATABINDING
                     && IsGenerated()
    #endif
                    )
            {
                ElementOwner()->SendNotification(NTYPE_ELEMENT_RESIZE);
            }
        }
    
    }
    
    
    //+------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::HandlePositionDisplayChange
    //
    //  Synopsis:   Process position/display property changes on the cell
    //
    //-------------------------------------------------------------------------
    
    void
    CTableCellLayout::HandlePositionDisplayChange()
    {
        CTable *pTable = Table();
        CTableLayout *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    
        if (pTableLayout)
        {
            BOOL fDoRowSpans = pTableLayout->IsTableLayoutCacheCurrent();
            // the reason I have introduced fDoRowSpans is to be able to do this function regardless if 
            // the layout cache state is current or not (think of the case where Column display attr is changed, 
            // and this function will be called for all the cells in this column (so all the rows will be covered anyway)).
            if (Tag() == ETAG_TD || Tag() == ETAG_TH)
            {
                CTableRow *pRow = Row();
                int iRowSpan = fDoRowSpans? TableCell()->RowSpan() : 1;
                Assert (iRowSpan >=1);
                while (pRow)
                {
                    // neigboring cells in the row need to update their caches
                    CTableRowLayout *pRowLayout = pRow->RowLayoutCache();
                    Assert (pRowLayout);
                    for (int i= ColIndex(); i < pRowLayout->_aryCells.Size(); i++)
                    {
                        CTableCell *pCell = pRowLayout->_aryCells[i];
                        if (IsReal(pCell))
                        {
                            if (fDoRowSpans)
                                iRowSpan = max(iRowSpan, pCell->RowSpan());
                            pCell->EnsureFormatCacheChange (ELEMCHNG_CLEARCACHES);
                        }
                    }
                    --iRowSpan;
                    if (iRowSpan)
                    {
                        Assert (fDoRowSpans);
                        pRow = pTableLayout->_aryRows[pTableLayout->GetNextRow(pRowLayout->RowPosition())];
                    }
                    else
                    {
                        pRow = NULL;
                    }
                }
            }
            pTableLayout->MarkTableLayoutCacheDirty();
            SetSizeThis( TRUE ); // all we want is to enusre disp node (ensure correct layer ordering).
            pTableLayout->Resize();
        }
        
        return;
    }
    
    
    //+-------------------------------------------------------------------------
    //
    //  Method:     CTableCellLayout::CalcSizeCore, CTableCellLayout
    //
    //  Synopsis:   Calculate the size of the object
    //
    //--------------------------------------------------------------------------
    DWORD
    CTableCellLayout::CalcSizeCore(CCalcInfo * pci, 
                                   SIZE      * psize, 
                                   SIZE      * psizeDefault)
    {
        if (    ElementOwner()->HasMarkupPtr() 
            &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
        {
            return (CalcSizeCoreCSS1Strict(pci, psize, psizeDefault));
        }

        return (CalcSizeCoreCompat(pci, psize, psizeDefault));
    }
    
    DWORD
    CTableCellLayout::CalcSizeCoreCompat(CCalcInfo * pci, 
                                   SIZE      * psize, 
                                   SIZE      * psizeDefault)
    {
        TraceTagEx((tagCalcSize, TAG_NONAME, "+(CTableCellLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

        WHEN_DBG(SIZE psizeIn = *psize);
        WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

        CSaveCalcInfo   sci(pci, this);
        CScopeFlag      csfCalcing(this);
        DWORD           grfReturn;
        int             cx = psize->cx;
        CTable        * pTable;
        CTableLayout  * pTableLayout;
        CDisplay      * pdp = GetDisplay();
        CTreeNode     * pNodeSelf = GetFirstBranch();
        const CCharFormat * pCF   = pNodeSelf->GetCharFormat(LC_TO_FC(LayoutContext()));
        const CFancyFormat * pFF  = pNodeSelf->GetFancyFormat(LC_TO_FC(LayoutContext()));
        ELEMENT_TAG     etag = Tag();
        BOOL            fIgnoreZeroWidth = FALSE;
        BOOL            fFixedSizeCell = FALSE;
        CTableCell    * pCell;
        BOOL            fSetSize = FALSE;
        BOOL            fSetCellPosition = FALSE;
        CLayoutContext * pLayoutContext = pci->GetLayoutContext();
        CTableCalcInfo * ptci = NULL;
        BOOL             fViewChain;
        CTableCellLayout * pCellLayoutCompatible = NULL;

        if (pci->_fTableCalcInfo)
        {
            ptci = (CTableCalcInfo *) pci;
            
            pTable       = ptci->Table();
            pTableLayout = ptci->TableLayoutCache();
            fSetCellPosition = ptci->_fSetCellPosition;
        }
        else
        {
            pTable = Table();
            if (pTable)
                pTableLayout = pTable->TableLayoutCache();
            else
            {
                // this cell is not in the table (therefore it is a most likely DOM created homeless cell).
                *psize    =
                _sizeCell = g_Zero.size;
                TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
                return pci->_grfLayout;
            }
        }
    
        fViewChain = (ElementCanBeBroken() && pLayoutContext != NULL && pLayoutContext->ViewChain() != NULL);
    
        if (_fForceLayout)
        {
            pci->_grfLayout |= LAYOUT_FORCE;
            _fForceLayout = FALSE;
        }
    
        TraceTag((tagTableCalc, "CTableCellLayout::CalcSize - Enter (0x%x), Table = 0x%x, smMode = %x, grfLayout = %x", this, pTable, pci->_smMode, pci->_grfLayout));
    
        Assert (pdp);
        pdp->SetWordWrap(!pCF->HasNoBreak(TRUE));
    
        // NOTE: Alex disagrees with this. (OliverSe)
        // pdp->SetCaretWidth(0);  // NOTE: for cells we don't adjust the width of the cells for the caret (_dxCaret = 0).
    
        pCell = TableCell();
    
        Assert(pci);
        Assert(psize);
        Assert(   pci->_smMode == SIZEMODE_MMWIDTH 
               || (pTable && pTable->TestLock(CElement::ELEMENTLOCK_SIZING)) 
               || pCell->IsPositioned()
               || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
        Assert(pTableLayout && pTableLayout->IsCalced());
    
        //  Check that table cell is absolute or relative and it is called 
        //  directly from CLayout::HandlePostitionRequest to clone its disp node.
        Assert(ptci || !pci->_fCloneDispNode || (pLayoutContext && pCell->IsPositioned()));
        
        grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);
    
        if (pci->_grfLayout & LAYOUT_FORCE)
        {
            SetSizeThis( TRUE );
            _fAutoBelow        = FALSE;
            _fPositionSet      = FALSE;
            _fContainsRelative = FALSE;
        }
    
        Assert (pTableLayout && pTableLayout->_cNestedLevel != -1);
        if (!pTableLayout || pNodeSelf->IsDisplayNone() || pTableLayout->_cNestedLevel > SECURE_NESTED_LEVEL)
        {
            *psize    =
            _sizeCell = g_Zero.size;
            TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
            return grfReturn;
        }
    
    
        if (    fViewChain 
            &&  !IsCaption(etag)
            //  This piece of code is for insets support in broken cells but 
            //  it doesn't make sense if the cell is vertical (bug # 99917).
            &&  !pCell->HasVerticalLayoutFlow()   )
        {
            Assert(pLayoutContext != GetContentMarkup()->GetCompatibleLayoutContext());

            CLayoutBreak *     pLayoutBreakBeg;
            CDispNode *        pDispNodeCompatible;
            int                yFromTop;

            pCellLayoutCompatible = (CTableCellLayout *)pCell->Layout(GetContentMarkup()->GetCompatibleLayoutContext());
            Assert(pCellLayoutCompatible);

            pDispNodeCompatible = pCellLayoutCompatible->_pDispNode;

            if (pDispNodeCompatible && pDispNodeCompatible->HasInset())
            {
                yFromTop = 0;

                pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreakBeg);

                if (pLayoutBreakBeg)
                {
                    yFromTop = DYNCAST(CTableCellLayoutBreak, pLayoutBreakBeg)->YFromTop();
                }

                if (yFromTop < pDispNodeCompatible->GetInset().cy)
                {
                    pci->_cyAvail -= pDispNodeCompatible->GetInset().cy - yFromTop;
                    if (pci->_cyAvail < 1) 
                    {
                        pci->_cyAvail = 1;
                    }
                }
            }

            //  ask pre-calced cell if it has content
            _fElementHasContent = !pCellLayoutCompatible->NoContent();
        }

    #if DBG == 1
        if (pci->_smMode == SIZEMODE_NATURAL)
        {
            pci->_yBaseLine = -1;
        }
    #endif   

        grfReturn = super::CalcSizeCore(pci, psize, psizeDefault);

        if (    pci->IsNaturalMode()
            &&  !(grfReturn & (LAYOUT_THIS | LAYOUT_HRESIZE | LAYOUT_VRESIZE))   )
        {
            *psize = _sizeCell;
        }


        if (fViewChain && !IsCaption(etag))
        {
            if (    fSetCellPosition
                //  or if cell is called to clone disp node directly
                ||  (!ptci && pci->_fCloneDispNode)  )
            {
                //  do adjustment only during set cell position pass
                CLayoutBreak * pLayoutBreakBeg, *pLayoutBreakEnd;
                int yFromTop;

                if (ptci)
                {
                    Assert( ptci->_pRowLayout 
                        &&  (   pCell->RowSpan() > 1 
                            ||  ptci->_pRowLayout == (CTableRowLayoutBlock *)(pCell->Row()->GetUpdatedLayout(pLayoutContext)))  );
                    yFromTop = ptci->_pRowLayout->_yHeight;
                }
                else 
                {
                    yFromTop = ((CTableRowLayoutBlock *)(pCell->Row()->GetUpdatedLayout(pLayoutContext)))->_yHeight; 
                }

                pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreakEnd); 

                if (pLayoutBreakEnd)
                {
                    pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreakBeg);

                    if (pLayoutBreakBeg)
                    {
                        yFromTop += DYNCAST(CTableCellLayoutBreak, pLayoutBreakBeg)->YFromTop();
                    }

                    BOOL fFlowBroken = GetDisplay()->LineCount() 
                                        && (pLayoutBreakEnd->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW);
                    DYNCAST(CTableCellLayoutBreak, pLayoutBreakEnd)->SetTableCellLayoutBreak(yFromTop, fFlowBroken);
                }
            }
            else if (pci->_fLayoutOverflow && ptci)
            {
                // but in non-Set passes, we need to determine if there is a rowspan, and 
                // if so, don't allow a SetEndOfRect to bubble up.  If this happens and the 
                // rowspan would cause a pagebreak, the row dispnode will clip at the content 
                // height of the other cells and not the available height, thus clipping this cell.

                // the comment above is true when row spanned cell does not end in this row 
                int cCellRowSpan = pCell->RowSpan();

                if (    cCellRowSpan > 1
                    &&  (pCell->RowIndex() + cCellRowSpan - 1) != ptci->_pRow->_iRow    )
                {
                    pci->_fLayoutOverflow = FALSE;
                }
            }
        }
    
        if (pTableLayout->IsFixed() && !IsCaption(etag))
        {
            // For the fixed style tables, regardless to the MIN width we might clip the content of the cell
            CTableRowLayout *pRowLayoutCache = Row()->RowLayoutCache();

            if (psize->cx > cx)
            {
                // Check if we need to clip the content of the cell
                if (pFF->GetLogicalOverflowX(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed) != styleOverflowVisible)
                {
                    // we need to clip the content of the cell
                    EnsureDispNodeIsContainer();
                    fSetSize = TRUE;
                }
            }
            if (pci->_smMode != SIZEMODE_NATURALMIN)
            {
                _sizeCell.cx = psize->cx = cx;
            }
            
            if (    pRowLayoutCache->IsHeightSpecifiedInPixel() 
                &&  pFF->GetMinHeight().IsNullOrEnum()  )
            {
                if (pCell->RowSpan() == 1)
                {
                    long yRowHeight  = ((CTableRowLayoutBlock *)Row()->GetUpdatedLayout(pLayoutContext))->_yHeight;

                    // (bug # 104206) To prevent content clipping in fixed broken rows in print view. 
                    // NOTE : This code makes sure that this part of broken row 
                    // less or equal to the row height in compatible layout context.
                    if (fViewChain && pCellLayoutCompatible)
                    {
                        _sizeCell.cy     = min(psize->cy, pCellLayoutCompatible->_sizeCell.cy);
                    }
                    else 
                    {
                        _sizeCell.cy     = min(psize->cy, yRowHeight);
                        psize->cy        = yRowHeight;
                    }
                }
                else
                {
                    if (!fSetCellPosition)  // don't reset _sizeCell during set cell position (bug #47838)
                    {
                        _sizeCell.cy = psize->cy;
                    }
                }
                fFixedSizeCell = TRUE;
                CDispNode * pDispNode = GetElementDispNode();
                pDispNode->SetSize(*psize, NULL, FALSE);
                fIgnoreZeroWidth = TRUE;
            }
        }
    
        if (   pci->_smMode == SIZEMODE_NATURAL 
            || pci->_smMode == SIZEMODE_NATURALMIN
            || pci->_smMode == SIZEMODE_SET)
        {
            if (grfReturn & LAYOUT_THIS)
            {
                CBorderInfo bi(FALSE); // no init
    
                if (pci->_smMode != SIZEMODE_SET)
                {
    
                    // If the cell is empty, set its height to zero.
                    if ((NoContent() && !fIgnoreZeroWidth) && (!pTable->IsDatabound() || pTableLayout->IsRepeating()))
                    {
                        // Null out cy size component.
                        psize->cy = 0;
                        fSetSize  = TRUE;
                    }
    
                    // If the cell has no height, but does have borders
                    // Then ensure enough space for the horizontal borders
                    if (    psize->cy == 0
                        &&  GetCellBorderInfo(pci, &bi, FALSE, FALSE, 0, pTable, pTableLayout))
                    {
                        Assert(pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN);
                        psize->cy += bi.aiWidths[SIDE_TOP] + bi.aiWidths[SIDE_BOTTOM];
                        fSetSize   = TRUE;
                    }
                    
                    // At this point, we should have a display node.
                    if (fSetSize)
                    {
                        Assert(GetElementDispNode());
                        SizeDispNode(pci, *psize);
                    }
    
                    Assert(   pTable->TestLock(CElement::ELEMENTLOCK_SIZING) 
                           || pTableLayout->IsFixedBehaviour() 
                           || pCell->IsAbsolute()
                           || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
                }
    
                Assert(pci->_yBaseLine != -1);
                _yBaseLine = pci->_yBaseLine;
    
                //
                // Save the true height of the cell (which may differ from the height of the containing
                // row and thus the value kept in _sizeProposed); However, only cache this value when
                // responding to a NATURAL size request or if the cell contains children whose
                // heights are a percentage of the cell (since even during a SET operation those can
                // change in size thus affecting the cell size).
    
                if (!fFixedSizeCell)
                {
                    if (   pci->_smMode == SIZEMODE_NATURAL
                        || pci->_smMode == SIZEMODE_NATURALMIN
                        || ContainsVertPercentAttr())
                    {
                        _sizeCell = *psize;
                    }
                    //
                    // In case of SET mode and changed layout flow get true size of the cell from 
                    // the display. 
                    // Need this value to vertical align cell's contents. In SET mode we don't modify 
                    // _sizeCell, but it might change in case of sizing for differing layout flows - 
                    // in this case update _sizeCell.
                    //
                    else if (pFF->_fLayoutFlowChanged)
                    {
                        CRect rcBorders;
                        _pDispNode->GetBorderWidths(&rcBorders);

                        GetDisplay()->GetSize(&_sizeCell);
                        _sizeCell.cx += rcBorders.left + rcBorders.right;
                        _sizeCell.cy += rcBorders.top + rcBorders.bottom;
                    }
                }
                Assert(   pTable->TestLock(CElement::ELEMENTLOCK_SIZING) 
                       || pCell->IsAbsolute()
                       || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
    
                if (   (    (_fContainsRelative || _fAutoBelow)
                         && !ElementOwner()->IsZParent() )  
                    || pFF->_fPositioned)
                {
                    CLayout *pLayout = GetUpdatedParentLayout(pLayoutContext);
                    pLayout->_fAutoBelow = TRUE;
                }
            }
    
    #ifdef NO_DATABINDING
            // Assert(_fMinMaxValid || pTableLayout->IsFixedBehaviour());
    #else
            // TODO, track bug 13696): 70458, need to investigate further why the MinMax is invalid.
            // Assert(_fMinMaxValid || IsGenerated() || pTableLayout->IsFixedBehaviour() || pCell->IsAbsolute());
    #endif
            // TODO, track bug 13696): alexa: the following assert breaks Final96 page (manual DRT), need to investigate.
            // Assert(_xMin <= _sizeCell.cx);
    
            pci->_yBaseLine = _yBaseLine;
        }
    
        else if (  pci->_smMode == SIZEMODE_MMWIDTH
                || pci->_smMode == SIZEMODE_MINWIDTH)
        {
            //
            // NETSCAPE: If NOWRAP was specified along with a fixed WIDTH,
            //           use the fixed WIDTH as a min/max (if not smaller than the content)
            //
    
            if (pFF->_fHasNoWrap)
            {
                const CUnitValue & cuvWidth = pFF->GetLogicalWidth(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                if (!cuvWidth.IsNullOrEnum() && !cuvWidth.IsPercent())
                {
                    psize->cx =
                    psize->cy = max((long)_sizeMin.cu,
                                    cuvWidth.XGetPixelValue(pci, 0,
                                              pNodeSelf->GetFontHeightInTwips(&cuvWidth)));
                    _sizeMin.SetSize(psize->cx, -1);
                    _sizeMax.SetSize(psize->cx, -1);
                }
            }
    
        }
    
        TraceTag((tagTableCalc, "CTableCell::CalcSize - Exit (0x%x)", this));
        TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
        return grfReturn;
    }
    

    DWORD
    CTableCellLayout::CalcSizeCoreCSS1Strict(CCalcInfo * pci, 
                                   SIZE      * psize, 
                                   SIZE      * psizeDefault)
    {
        TraceTagEx((tagCalcSize, TAG_NONAME, "+(CTableCellLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

        WHEN_DBG(SIZE psizeIn = *psize);
        WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

        CSaveCalcInfo   sci(pci, this);
        CScopeFlag      csfCalcing(this);
        LONG            cx = psize->cx;
        DWORD           grfReturn;
        CTable        * pTable;
        CTableLayout  * pTableLayout;
        CDisplay      * pdp = GetDisplay();
        CTreeNode     * pNodeSelf = GetFirstBranch();
        const CCharFormat * pCF   = pNodeSelf->GetCharFormat(LC_TO_FC(LayoutContext()));
        const CFancyFormat * pFF  = pNodeSelf->GetFancyFormat(LC_TO_FC(LayoutContext()));
        ELEMENT_TAG     etag = Tag();
        CTableCell    * pCell;
        BOOL            fSetSize = FALSE;
        BOOL            fSetCellPosition = FALSE;
        CLayoutContext * pLayoutContext = pci->GetLayoutContext();
        CTableCalcInfo * ptci = NULL;
        BOOL             fViewChain;
        CTableCellLayout * pCellLayoutCompatible = NULL;

        if (pci->_fTableCalcInfo)
        {
            ptci = (CTableCalcInfo *) pci;
            
            pTable       = ptci->Table();
            pTableLayout = ptci->TableLayoutCache();
            fSetCellPosition = ptci->_fSetCellPosition;
        }
        else
        {
            pTable = Table();
            if (pTable)
                pTableLayout = pTable->TableLayoutCache();
            else
            {
                // this cell is not in the table (therefore it is a most likely DOM created homeless cell).
                *psize    =
                _sizeCell = g_Zero.size;
                TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
                return pci->_grfLayout;
            }
        }
    
        fViewChain = (ElementCanBeBroken() && pLayoutContext != NULL && pLayoutContext->ViewChain() != NULL);
    
        if (_fForceLayout)
        {
            pci->_grfLayout |= LAYOUT_FORCE;
            _fForceLayout = FALSE;
        }
    
        TraceTag((tagTableCalc, "CTableCellLayout::CalcSize - Enter (0x%x), Table = 0x%x, smMode = %x, grfLayout = %x", this, pTable, pci->_smMode, pci->_grfLayout));
    
        Assert (pdp);
        pdp->SetWordWrap(!pCF->HasNoBreak(TRUE));
    
        // NOTE: Alex disagrees with this. (OliverSe)
        // pdp->SetCaretWidth(0);  // NOTE: for cells we don't adjust the width of the cells for the caret (_dxCaret = 0).
    
        pCell = TableCell();
    
        Assert(pci);
        Assert(psize);
        Assert(   pci->_smMode == SIZEMODE_MMWIDTH 
               || (pTable && pTable->TestLock(CElement::ELEMENTLOCK_SIZING)) 
               || pCell->IsPositioned()
               || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
        Assert(pTableLayout && pTableLayout->IsCalced());
    
        //  Check that table cell is absolute or relative and it is called 
        //  directly from CLayout::HandlePostitionRequest to clone its disp node.
        Assert(ptci || !pci->_fCloneDispNode || (pLayoutContext && pCell->IsPositioned()));
        
        grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);
    
        if (pci->_grfLayout & LAYOUT_FORCE)
        {
            SetSizeThis( TRUE );
            _fAutoBelow        = FALSE;
            _fPositionSet      = FALSE;
            _fContainsRelative = FALSE;
        }
    
        Assert (pTableLayout && pTableLayout->_cNestedLevel != -1);
        if (!pTableLayout || pNodeSelf->IsDisplayNone() || pTableLayout->_cNestedLevel > SECURE_NESTED_LEVEL)
        {
            *psize    =
            _sizeCell = g_Zero.size;
            TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
            return grfReturn;
        }
    
    
        if (    fViewChain 
            &&  !IsCaption(etag)
            //  This piece of code is for insets support in broken cells but 
            //  it doesn't make sense if the cell is vertical (bug # 99917).
            &&  !pCell->HasVerticalLayoutFlow()   )
        {
            Assert(pLayoutContext != GetContentMarkup()->GetCompatibleLayoutContext());

            CLayoutBreak *     pLayoutBreakBeg;
            CDispNode *        pDispNodeCompatible;
            int                yFromTop;

            pCellLayoutCompatible = (CTableCellLayout *)pCell->Layout(GetContentMarkup()->GetCompatibleLayoutContext());
            Assert(pCellLayoutCompatible);

            pDispNodeCompatible = pCellLayoutCompatible->_pDispNode;

            if (pDispNodeCompatible && pDispNodeCompatible->HasInset())
            {
                yFromTop = 0;

                pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreakBeg);

                if (pLayoutBreakBeg)
                {
                    yFromTop = DYNCAST(CTableCellLayoutBreak, pLayoutBreakBeg)->YFromTop();
                }

                if (yFromTop < pDispNodeCompatible->GetInset().cy)
                {
                    pci->_cyAvail -= pDispNodeCompatible->GetInset().cy - yFromTop;
                    if (pci->_cyAvail < 1) 
                    {
                        pci->_cyAvail = 1;
                    }
                }
            }

            //  ask pre-calced cell if it has content
            _fElementHasContent = !pCellLayoutCompatible->NoContent();
        }

    #if DBG == 1
        if (pci->_smMode == SIZEMODE_NATURAL)
        {
            pci->_yBaseLine = -1;
        }
    #endif   

        //
        // Calculate proposed size
        //

        // psize->cx is adjusted (if necessary in CalcSizeAtUserWidth, so we can use it here)
        _sizeProposed.cx = psize->cx - GetBorderAndPaddingWidth(pci, FALSE); 

        if (pCF->_fUseUserHeight)
        {
            CHeightUnitValue uvHeight = pFF->GetHeight();

            _sizeProposed.cy = uvHeight.YGetPixelValue(pci, pTableLayout->_sizeProposed.cy, 
                pNodeSelf->GetFontHeightInTwips(&uvHeight));
        }
        else 
        {
            _sizeProposed.cy = 0;
        }

        grfReturn = super::CalcSizeCore(pci, psize, psizeDefault);

        if (fViewChain && !IsCaption(etag))
        {
            if (    fSetCellPosition
                //  or if cell is called to clone disp node directly
                ||  (!ptci && pci->_fCloneDispNode)  )
            {
                //  do adjustment only during set cell position pass
                CLayoutBreak * pLayoutBreakBeg, *pLayoutBreakEnd;
                int yFromTop;

                if (ptci)
                {
                    Assert( ptci->_pRowLayout 
                        &&  (   pCell->RowSpan() > 1 
                            ||  ptci->_pRowLayout == (CTableRowLayoutBlock *)(pCell->Row()->GetUpdatedLayout(pLayoutContext)))  );
                    yFromTop = ptci->_pRowLayout->_yHeight;
                }
                else 
                {
                    yFromTop = ((CTableRowLayoutBlock *)(pCell->Row()->GetUpdatedLayout(pLayoutContext)))->_yHeight; 
                }

                pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreakEnd); 

                if (pLayoutBreakEnd)
                {
                    pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreakBeg);

                    if (pLayoutBreakBeg)
                    {
                        yFromTop += DYNCAST(CTableCellLayoutBreak, pLayoutBreakBeg)->YFromTop();
                    }

                    BOOL fFlowBroken = GetDisplay()->LineCount() 
                                        && (pLayoutBreakEnd->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW);
                    DYNCAST(CTableCellLayoutBreak, pLayoutBreakEnd)->SetTableCellLayoutBreak(yFromTop, fFlowBroken);
                }
            }
            else if (pci->_fLayoutOverflow && ptci)
            {
                // but in non-Set passes, we need to determine if there is a rowspan, and 
                // if so, don't allow a SetEndOfRect to bubble up.  If this happens and the 
                // rowspan would cause a pagebreak, the row dispnode will clip at the content 
                // height of the other cells and not the available height, thus clipping this cell.

                // the comment above is true when row spanned cell does not end in this row 
                int cCellRowSpan = pCell->RowSpan();

                if (    cCellRowSpan > 1
                    &&  (pCell->RowIndex() + cCellRowSpan - 1) != ptci->_pRow->_iRow    )
                {
                    pci->_fLayoutOverflow = FALSE;
                }
            }
        }
    
        if (pTableLayout->IsFixed() && !IsCaption(etag))
        {
            // For the fixed style tables, regardless to the MIN width we might clip the content of the cell
            if (psize->cx > cx)
            {
                // Check if we need to clip the content of the cell
                if (pFF->GetLogicalOverflowX(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed) != styleOverflowVisible)
                {
                    // we need to clip the content of the cell
                    EnsureDispNodeIsContainer();
                    fSetSize = TRUE;
                }
            }
            if (pci->_smMode != SIZEMODE_NATURALMIN)
            {
                _sizeCell.cx = psize->cx = cx;
            }
        }
    
        if (   pci->_smMode == SIZEMODE_NATURAL 
            || pci->_smMode == SIZEMODE_NATURALMIN
            || pci->_smMode == SIZEMODE_SET)
        {
            if (grfReturn & LAYOUT_THIS)
            {
                if (pci->_smMode != SIZEMODE_SET)
                {
                    // If the cell is empty -- reset its height.
                    if (    NoContent() 
                        && (!pTable->IsDatabound() || pTableLayout->IsRepeating())  )
                    {
                        psize->cy = pCF->_fUseUserHeight ? _sizeProposed.cy : 0;

                        // 
                        // Save cell content size 
                        // 
                        _sizeCell = *psize;

                        fSetSize  = TRUE;
                    }
                    else 
                    {
                        // 
                        // Save cell content size 
                        // 
                        _sizeCell = *psize;

                        // 
                        // Adjust cell height
                        //
                        long  yBorderAndPaddingHeight = GetBorderAndPaddingHeight(pci, FALSE); 

                        if (psize->cy < (_sizeProposed.cy + yBorderAndPaddingHeight))
                        {
                            psize->cy = _sizeProposed.cy + yBorderAndPaddingHeight;
                            fSetSize  = TRUE;
                        }
                    }
                    
                    // At this point, we should have a display node.
                    if (fSetSize)
                    {
                        Assert(GetElementDispNode());
                        SizeDispNode(pci, *psize);
                    }
    
                    Assert(   pTable->TestLock(CElement::ELEMENTLOCK_SIZING) 
                           || pTableLayout->IsFixedBehaviour() 
                           || pCell->IsAbsolute()
                           || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
                }
                //
                // In case of SET mode and changed layout flow get true size of the cell from 
                // the display. 
                // Need this value to vertical align cell's contents. In SET mode we don't modify 
                // _sizeCell, but it might change in case of sizing for differing layout flows - 
                // in this case update _sizeCell.
                //
                else if (pFF->_fLayoutFlowChanged)
                {
                    CRect rcBorders;
                    _pDispNode->GetBorderWidths(&rcBorders);

                    GetDisplay()->GetSize(&_sizeCell);
                    _sizeCell.cx += rcBorders.left + rcBorders.right;
                    _sizeCell.cy += rcBorders.top + rcBorders.bottom;
                }

                Assert(   pTable->TestLock(CElement::ELEMENTLOCK_SIZING) 
                       || pCell->IsAbsolute()
                       || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
    
                if (   (    (_fContainsRelative || _fAutoBelow)
                         && !ElementOwner()->IsZParent() )  
                    || pFF->_fPositioned)
                {
                    CLayout *pLayout = GetUpdatedParentLayout(pLayoutContext);
                    pLayout->_fAutoBelow = TRUE;
                }

                Assert(pci->_yBaseLine != -1);
                _yBaseLine = pci->_yBaseLine;
            }
    
            pci->_yBaseLine = _yBaseLine;
        }
    
        else if (  pci->_smMode == SIZEMODE_MMWIDTH
                || pci->_smMode == SIZEMODE_MINWIDTH)
        {
            //
            // NETSCAPE: If NOWRAP was specified along with a fixed WIDTH,
            //           use the fixed WIDTH as a min/max (if not smaller than the content)
            //
    
            if (pFF->_fHasNoWrap)
            {
                const CUnitValue & cuvWidth = pFF->GetLogicalWidth(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                if (!cuvWidth.IsNullOrEnum() && !cuvWidth.IsPercent())
                {
                    psize->cx =
                    psize->cy = max((long)_sizeMin.cu,
                                    cuvWidth.XGetPixelValue(pci, 0,
                                              pNodeSelf->GetFontHeightInTwips(&cuvWidth)));
                    _sizeMin.SetSize(psize->cx, -1);
                    _sizeMax.SetSize(psize->cx, -1);
                }
            }
    
        }
    
        TraceTag((tagTableCalc, "CTableCell::CalcSize - Exit (0x%x)", this));
        TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
        return grfReturn;
    }
    
    //+-------------------------------------------------------------------------
    //
    //  Method:     CTableCellLayout::GetBorderAndPaddingCore
    //
    //  Synopsis:   Calculate the size of the horizontal/vertical left border, right
    //              border, and paddings for this cell.
    //
    //--------------------------------------------------------------------------
    int CTableCellLayout::GetBorderAndPaddingCore(BOOL fWidth, CDocInfo const *pdci, BOOL fVertical, BOOL fOnlyBorder)
    {
        CBorderInfo     borderinfo(FALSE);
        CTable *        pTable = Table();
        CTableLayout *  pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;
        int             acc = 0;
        CTreeNode *     pTreeNode = ElementOwner()->GetFirstBranch();
    
        if (!fOnlyBorder)
        {
            const CFancyFormat * pFF = pTreeNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
            const CCharFormat  * pCF = pTreeNode->GetCharFormat(LC_TO_FC(LayoutContext()));
            if (fWidth)
            {
                acc = pFF->GetLogicalPadding(SIDE_LEFT, fVertical, pCF->_fWritingModeUsed).XGetPixelValue(pdci, 0, pTreeNode->GetFontHeightInTwips((CUnitValue*)this))
                    + pFF->GetLogicalPadding(SIDE_RIGHT, fVertical, pCF->_fWritingModeUsed).XGetPixelValue(pdci, 0, pTreeNode->GetFontHeightInTwips((CUnitValue*)this));
            }
            else
            {
                acc = pFF->GetLogicalPadding(SIDE_TOP, fVertical, pCF->_fWritingModeUsed).YGetPixelValue(pdci, 0, pTreeNode->GetFontHeightInTwips((CUnitValue*)this))
                    + pFF->GetLogicalPadding(SIDE_BOTTOM, fVertical, pCF->_fWritingModeUsed).YGetPixelValue(pdci, 0, pTreeNode->GetFontHeightInTwips((CUnitValue*)this));
            }
        }
    
        if (GetCellBorderInfo(pdci, &borderinfo, FALSE, FALSE, 0, pTable, pTableLayout))
        {
            // Writing mode useage does not matter, since the table will always be horizontal, and if the
            // cell is vertical, then we always want to flip.
            BOOL    fFlip = pTreeNode->GetCharFormat()->HasVerticalLayoutFlow() ^ (!!fVertical);
            P_SIDE  borderOne, borderTwo;
    
            if (fWidth ^ fFlip)
            {
                borderOne = SIDE_LEFT;
                borderTwo = SIDE_RIGHT;
            }
            else
            {
                borderOne = SIDE_TOP;
                borderTwo = SIDE_BOTTOM;
            }

            acc += borderinfo.aiWidths[borderOne] + borderinfo.aiWidths[borderTwo];
        }
    
        return acc;
    }
    
    //+-------------------------------------------------------------------------
    //
    //  Method:     CTableCellLayout::CalcSizeAtUserWidth
    //
    //  Synopsis:   Calculate the size of the object based applying the user's
    //              specified width. This function is invented to match Netscape
    //              behaviour, who are respecting the user width for laying out
    //              the text (line braking is done on the user's specified width)
    //              regardless to the calculated size of the cell.
    //
    //--------------------------------------------------------------------------
    
    DWORD
    CTableCellLayout::CalcSizeAtUserWidth(CCalcInfo * pci, SIZE * psize)
    {

        WHEN_DBG(SIZE psizeIn = *psize);
        WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0
        
        int     cx          = psize->cx;
        // Table is always horizontal => fVerticalLayoutFlow = FALSE
        int     cxUserWidth = GetSpecifiedPixelWidth(pci, FALSE);
        BOOL    fAdjustView = FALSE;
        CTableLayout * pTableLayout = NULL;
        DWORD   grfReturn;
    #if DBG == 1
        int     cxMin;
    #endif
    
        if (pci->_fTableCalcInfo)
        {
            CTableCalcInfo * ptci = (CTableCalcInfo *) pci;
            
            pTableLayout = ptci->TableLayoutCache();
        }
        else
        {
            if (Table())
                pTableLayout = Table()->TableLayoutCache();
        }
    
        //
        // If a non-inherited user set value exists, respect the User's size and calculate
        // the cell with that size, but set the different view for the cell.
        // NOTE: This is only applys to cells in columns without a fixed
        //       size (that is, covered by the COLS attribute)
        //
    
        if (    pTableLayout
            &&  ColIndex() >= pTableLayout->_cSizedCols
            &&  cxUserWidth
            &&  !TableCell()->_fInheritedWidth
            &&  cxUserWidth < cx)
        {
            // We should not try to render the cell in a view less then insets of the cell + 1 pixel
    
    #if DBG==1
            // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingModeUsed = FALSE
            cxMin = GetBorderAndPaddingWidth(pci, FALSE) + 1;
            Assert (cxMin <= cxUserWidth);
    #endif
            psize->cx   = cxUserWidth;
            fAdjustView = TRUE;
        }
    
        // Recursive call to non-virtual CalcSize; this is a known safe exception
        // to the "don't call CalcSize recursively" rule.  We need to call the
        // non-virtual CalcSize because we needs its vertical layout logic.
        grfReturn = CalcSize(pci, psize, NULL);
    
        //
        // Re-adjust the view width if necessary
        //
    
        if (fAdjustView)
        {
            CTreeNode * pNodeSelf    = GetFirstBranch();
            const CFancyFormat * pFF = pNodeSelf->GetFancyFormat(LC_TO_FC(LayoutContext()));
    
            if (pTableLayout->IsFixed() && !IsCaption(Tag()))
            {
                // For the fixed style tables, regardless to the MIN width we might clip the content of the cell
                // Check if we need to clip the content of the cell
    
                // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingModeUsed = FALSE
                if (pFF->GetLogicalOverflowX(FALSE, FALSE) == styleOverflowVisible)
                {
                    CSize sizeCell;
                    GetApparentSize(&sizeCell);
                    if (sizeCell.cx >= cx)
                    {
                        fAdjustView = FALSE;
                    }
                }
            }
            psize->cx = cx;
            if (fAdjustView)
            {
                if (pFF->_fLayoutFlowChanged)
                {
                    ((CSize *)psize)->Flip();
                    SizeDispNode(pci, *psize);
                    ((CSize *)psize)->Flip();
                }
                else
                    SizeDispNode(pci, *psize);
    
                SizeContentDispNode(CSize(GetDisplay()->GetMaxWidth(), GetDisplay()->GetHeight()));
            }
        }
    
        return grfReturn;
    }
    
    
    //+---------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::Resize
    //
    //  Synopsis:   request to resize cell layout
    //
    //----------------------------------------------------------------------------
    
    void
    CTableCellLayout::Resize()
    {
    #if DBG == 1
        if (!IsTagEnabled(tagTableRecalc))
    #endif
        if (TableLayout() && 
            !TableLayout()->_fCompleted)
            return;
    
        ElementOwner()->ResizeElement();
    }
    
    
    //+---------------------------------------------------------------------------
    //
    //  Member:     CLayout::DrawClientBorder
    //
    //  Synopsis:   Draw the border
    //
    //  Arguments:  prcBounds       bounding rect of display leaf
    //              prcRedraw       rect to be redrawn
    //              pSurface        surface to render into
    //              pDispNode       pointer to display node
    //              pClientData     client-dependent data for drawing pass
    //              dwFlags         flags for optimization
    //
    //  Notes:
    //
    //----------------------------------------------------------------------------
    
    void
    CTableCellLayout::DrawClientBorder(const RECT * prcBounds, const RECT * prcRedraw, CDispSurface * pDispSurface, CDispNode * pDispNode, void * pClientData, DWORD dwFlags)
    {
        CElement * pElement;
        CTreeNode * pNode;
        const CFancyFormat * pFF;
    
        if (NoContent())
            return;
    
        pElement = ElementOwner();
    
        if (pElement->Tag() != ETAG_CAPTION)
        {
            pNode = pElement->GetFirstBranch();
            if (!pNode)
                return;
    
            pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
    
            if (pFF->_bDisplay == styleDisplayNone)
                return;
    
            if (   pFF->_bPositionType != stylePositionabsolute
                && pFF->_bPositionType != stylePositionrelative)
            {
                CTableLayout * pTableLayout = NULL;
    
                if (Table())
                    pTableLayout = Table()->TableLayoutCache();

                if (   pTableLayout
                    && (   pTableLayout->_fCollapse 
                        || pTableLayout->_fRuleOrFrameAffectBorders))
                    return;
            }
        }
    
        super::DrawClientBorder(prcBounds, prcRedraw, pDispSurface, pDispNode, pClientData, dwFlags);
    }
    
    //+---------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::DrawBorderHelper
    //
    //  Synopsis:   Paint the table cell's border if it has one.  Called from
    //              CTableCellLayout::Draw.
    //
    //----------------------------------------------------------------------------
    
    #define BorderFlag(border) \
       ((border == SIDE_LEFT) ? BF_LEFT : \
       ((border == SIDE_TOP) ? BF_TOP : \
       ((border == SIDE_RIGHT) ? BF_RIGHT : BF_BOTTOM)))
    #define BorderOrientation(border) ((border == SIDE_LEFT || border == SIDE_TOP)?1:-1)
    #define TopLeft(border) (border == SIDE_LEFT || border == SIDE_TOP)
    #define TopRight(border) (border == SIDE_RIGHT || border == SIDE_TOP)
    
    void
    CTableCellLayout::DrawBorderHelper(CFormDrawInfo *pDI, BOOL * pfShrunkDCClipRegion)
    {
        CTable *        pTable = Table();
        CTableLayout *  pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;
        htmlRules       trRules = pTable ? pTable->GetAArules() : htmlRulesNotSet;
        CBorderInfo     borderinfo(FALSE);  // no init
        CRect           rcInset;
        CRect           rcBorder;
        RECT            rcBorderVisible;
        WORD            grfBorderCollapseAdjustment = 0;
        ELEMENT_TAG     etag = Tag();
        CDispNode *     pDispNode = GetElementDispNode();
        BOOL            fRTLTable = (pTableLayout && pTableLayout->IsRightToLeft());
        // The following two variables are used for correcting border connections in right to left tables
        // This is a cascading hack that precipitates from the way borders are drawn. If the cell connects
        // to the table's border on either the left or right side, the flag will be set to alert us to
        // do the adjustment just before we draw.
        BOOL            fRTLLeftAdjust = FALSE, fRTLRightAdjust = FALSE;
    
        Assert(pTableLayout && (pTableLayout->_fCollapse || pTableLayout->_fRuleOrFrameAffectBorders));
        Assert(pfShrunkDCClipRegion);
    
        if (!pDispNode)
        {
            return;
        }
    
        pDispNode->GetApparentBounds(&rcInset);
    
        rcBorder = rcInset;

        TraceTag((tagTableBorder, "init rcBorder = (%d,%d, %d,%d)",
            rcBorder.top, rcBorder.bottom,  rcBorder.left, rcBorder.right));

        GetCellBorderInfo(pDI, &borderinfo, TRUE, TRUE, pDI->GetDC(), pTable, pTableLayout, pfShrunkDCClipRegion);
    
        if (   pTableLayout 
            && pTableLayout->_fCollapse 
            && !IsCaption(etag))
        {
            int border;
            int widthBorderHalfInset;
            LONG *pnInsetSide, *pnBorderSide;
    
            for (border = SIDE_TOP ; border <= SIDE_LEFT ; border++)
            {
                BOOL fCellBorderAtTableBorder = FALSE;
    
                // Set up current border for generic processing.
                switch (border)
                {
                case SIDE_LEFT:
                    pnInsetSide = &(rcInset.left);
                    pnBorderSide = &(rcBorder.left);
                    if(!fRTLTable)
                        fCellBorderAtTableBorder = (ColIndex() == 0);
                    else
                        fRTLLeftAdjust = fCellBorderAtTableBorder = (ColIndex()+TableCell()->ColSpan() == pTableLayout->_cCols);
                    break;
                case SIDE_TOP:
                    pnInsetSide = &(rcInset.top);
                    pnBorderSide = &(rcBorder.top);
                    fCellBorderAtTableBorder = (Row()->RowLayoutCache()->RowPosition() == 0);
                    break;
                case SIDE_RIGHT:
                    pnInsetSide = &(rcInset.right);
                    pnBorderSide = &(rcBorder.right);
                    if(!fRTLTable)
                        fCellBorderAtTableBorder = (ColIndex()+TableCell()->ColSpan() == pTableLayout->_cCols);
                    else
                        fRTLRightAdjust = fCellBorderAtTableBorder = (ColIndex() == 0);
                    break;
                default: // case SIDE_BOTTOM:
                    pnInsetSide = &(rcInset.bottom);
                    pnBorderSide = &(rcBorder.bottom);
                    fCellBorderAtTableBorder = (Row()->_iRow+TableCell()->RowSpan()-1 == pTableLayout->GetLastRow());
                    break;
                }
    
                // If the cell border coincides with the table border, no
                // collapsing takes place because the table border takes
                // precedence over cell borders.
                if (fCellBorderAtTableBorder)
                {
                    if (!borderinfo.aiWidths[border])
                    {
                        grfBorderCollapseAdjustment |= BorderFlag(border);
                    }
                    *pnInsetSide += borderinfo.aiWidths[border] * BorderOrientation(border); // * +/-1
                    continue;
                }
    
                // Half the border width (signed) is what we are going to modify the rects by.
                widthBorderHalfInset = ((borderinfo.aiWidths[border]+(!fRTLTable ? (TopLeft(border)?1:0) : (TopRight(border)?1:0)))>>1) * BorderOrientation(border); // * +/-1
    
                // The inset rect shrinks only by half the width because our neighbor
                // accomodates the other half.
                *pnInsetSide += widthBorderHalfInset;
    
                // If we are rendering our own border along this border...
                if (borderinfo.wEdges & BorderFlag(border))
                {
                    // The rcBorder grows by half the width so we can draw outside our rect.
                    *pnBorderSide -= ((borderinfo.aiWidths[border]+(!fRTLTable ? (TopLeft(border)?0:1) : (TopRight(border)?0:1)))>>1) * BorderOrientation(border); // * +/-1
                }
                else
                {
                    // The rcBorder shrinks (just like the inset rect) by half to let the
                    // neighbor draw half of its border in this space.
                    *pnBorderSide += widthBorderHalfInset;
    
                    // Make sure border rendering code doesn't get confused by neighbor's
                    // measurements.
                    borderinfo.aiWidths[border] = 0;
                    grfBorderCollapseAdjustment |= BorderFlag(border);
                }
            }
        }
        else
        {
            if (pTableLayout && pTableLayout->_fCollapse)
            {
                Assert(IsCaption(etag));
                int border = (DYNCAST(CTableCaption, TableCell())->IsCaptionOnBottom()) ? SIDE_TOP : SIDE_BOTTOM;
    
                if (!borderinfo.aiWidths[border])
                    grfBorderCollapseAdjustment |= BorderFlag(border);
            }
    
            rcInset.left   += borderinfo.aiWidths[SIDE_LEFT];
            rcInset.top    += borderinfo.aiWidths[SIDE_TOP];
            rcInset.right  -= borderinfo.aiWidths[SIDE_RIGHT];
            rcInset.bottom -= borderinfo.aiWidths[SIDE_BOTTOM];
        }
    
        //
        // Determine the RECT for and, if necessary, draw borders
        //
    
        if (trRules != htmlRulesNotSet && pTableLayout)
        {
            if (!(borderinfo.wEdges & BF_TOP))
                rcBorder.top -= pTableLayout->CellSpacingY();
            if (!(borderinfo.wEdges & BF_BOTTOM))
                rcBorder.bottom += pTableLayout->CellSpacingY();
            if (!(borderinfo.wEdges & BF_LEFT))
                rcBorder.left -= pTableLayout->CellSpacingX();
            if (!(borderinfo.wEdges & BF_RIGHT))
                rcBorder.right += pTableLayout->CellSpacingX();
        }
    
        //
        // Render the border if visible.
        //

        TraceTag((tagTableBorder, "visible rcBorder = (%d,%d, %d,%d)  rcInset = (%d,%d, %d,%d)",
            rcBorder.top, rcBorder.bottom,  rcBorder.left, rcBorder.right,
            rcInset.top, rcInset.bottom,  rcInset.left, rcInset.right));
    
        rcBorderVisible = rcBorder;
    
        if (rcBorderVisible.left < rcBorderVisible.right  &&
            rcBorderVisible.top  < rcBorderVisible.bottom &&
            (rcBorderVisible.left   < rcInset.left  ||
             rcBorderVisible.top    < rcInset.top   ||
             rcBorderVisible.right  > rcInset.right ||
             rcBorderVisible.bottom > rcInset.bottom ))
        {
            // Adjust for collapsed pixels on all edges drawn by
            // neighbors (or the table border).  We have to do this,
            // so that the border drawing code properly attaches our
            // own borders with the neighbors' borders.  This has to
            // happen after the clipping above.
            if (grfBorderCollapseAdjustment)
            {
                if (grfBorderCollapseAdjustment & BF_LEFT)
                    rcBorder.left -= (fRTLLeftAdjust?0:1);
                if (grfBorderCollapseAdjustment & BF_TOP)
                    rcBorder.top--;
                if (grfBorderCollapseAdjustment & BF_RIGHT)
                    rcBorder.right += (fRTLRightAdjust?2:1);
                if (grfBorderCollapseAdjustment & BF_BOTTOM)
                    rcBorder.bottom++;
            }

            if (LayoutContext())
            {
                AdjustBordersForBreaking(&borderinfo);
            }

            TraceTag((tagTableBorder, "draw rcBorder = (%d,%d, %d,%d)",
                rcBorder.top, rcBorder.bottom,  rcBorder.left, rcBorder.right));
    
            ::DrawBorder(pDI, &rcBorder, &borderinfo);
        }
    }
    
    //+------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::PaintSelectionFeedback
    //
    //  Synopsis:   Paints the object's selection feedback, if it exists and
    //              painting it is appropriate
    //
    //  Arguments:  hdc         HDC to draw on.
    //              prc         Rect to draw in
    //              dwSelInfo   Additional info about the selection
    //
    //-------------------------------------------------------------------------
    
    void
    CTableCellLayout::PaintSelectionFeedback(CFormDrawInfo *pDI, RECT *prc, DWORD dwSelInfo)
    {
        // no selection feedback on table cells
    }
    
    //+------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::GetSpecifiedPixelWidth
    //  
    //  Synopsis:   get user specified pixel width
    //
    //  Returns:    returns user's width of the cell (0 if not set or
    //              specified in %%)
    //              if user set's width <= 0 it will be ignored
    //-------------------------------------------------------------------------
    
    int
    CTableCellLayout::GetSpecifiedPixelWidth(CDocInfo const * pdci, BOOL fVerticalLayoutFlow)
    {
        int iUserWidth = 0;
    
        // If a user set value exists, respect the User's size and calculate
        // the cell with that size, but set the different view for the cell.
    
        CTableCell *pCell = TableCell();
        CTreeNode *pNode = pCell->GetFirstBranch();
    
        const CWidthUnitValue *punit = (CWidthUnitValue *)&pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->GetLogicalWidth(fVerticalLayoutFlow, pNode->GetCharFormat()->_fWritingModeUsed);
    
        if (punit->IsSpecified() && punit->IsSpecifiedInPixel())
        {
            iUserWidth = punit->GetPixelWidth(pdci, pCell);
            if (iUserWidth <= 0)    // ignore 0-width
            {
                iUserWidth = 0;
            }
            else
            {
                iUserWidth += GetBorderAndPaddingWidth(pdci, fVerticalLayoutFlow);
            }
        }
    
        return iUserWidth;
    }
    
    #ifndef NO_DATABINDING
    BOOL CTableCellLayout::IsGenerated()
    {
        ELEMENT_TAG etag = Tag();
        return etag != ETAG_CAPTION && 
               etag != ETAG_TC && 
               TableLayout() && 
               TableLayout()->IsGenerated(TableCell()->RowIndex());
    }
    #endif
    
    DWORD
    CTableCellLayout::CalcSizeVirtual(CCalcInfo * pci,
                                      SIZE      * psize,
                                      SIZE      * psizeDefault)
    {
        DWORD dwRet = super::CalcSizeVirtual(pci, psize, psizeDefault);
    
        WHEN_DBG(SIZE psizeIn = *psize);    // this is more interesting than saving psize before calling super
        WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0
        
        //
        // NOTE: VAlign code (below) has been moved from CTableCellLayout::CalcSizeCore
        // because sizes calculated in CFlowLayout::CalcSizeEx are needed to VAling
        // properly.
        // CTableCellLayout::CalcSizeCore is to early in the call stack to get it done right.
        //
    
        CDispNode * pDispNode = GetElementDispNode();
        if (pci->IsNaturalMode() &&  pDispNode)
        {
            CTreeNode * pNode = GetFirstBranch();
            const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
    
            //
            // Set the inset offset for the display node content
            //
            if (pDispNode->HasInset())
            {
                styleVerticalAlign  va;
                htmlCellVAlign      cellVAlign;
                long                cy;
                ELEMENT_TAG         etag;
    
                CLayoutContext * pLayoutContext = pci->GetLayoutContext();
                const CParaFormat * pPF = pNode->GetParaFormat(LC_TO_FC(LayoutContext()));
    
                cellVAlign  = (htmlCellVAlign)pPF->_bTableVAlignment;
                etag        = Tag();
    
                if (   cellVAlign != htmlCellVAlignBaseline
                    || etag == ETAG_CAPTION)
                {
                    va = (cellVAlign == htmlCellVAlignMiddle
                                ? styleVerticalAlignMiddle
                                : cellVAlign == htmlCellVAlignBottom
                                        ? styleVerticalAlignBottom
                                        : styleVerticalAlignTop);
                    cy = _sizeCell.cy;
                }
                else
                {
                    int yBaselineRow = ((CTableRowLayoutBlock *)Row()->GetUpdatedLayout(pLayoutContext))->_yBaseLine;
    
                    if (_yBaseLine != -1 && yBaselineRow != -1)
                    {
                        va = styleVerticalAlignBaseline;
    
                        cy = yBaselineRow - _yBaseLine;
                        if (cy + _sizeCell.cy > psize->cy)
                        {
                            cy = psize->cy - _sizeCell.cy;
                        }
                    }
                    else
                    {
                        va = styleVerticalAlignTop;
                        cy = _sizeCell.cy;
                    }
                }
    
                CTableCalcInfo * ptci = NULL;
                if (pci->_fTableCalcInfo)
                    ptci = (CTableCalcInfo *) pci;
    
                if (    pLayoutContext
                    &&  pLayoutContext->ViewChain()
                    &&  !IsCaption(etag)
                        //  do adjustment only during set cell position pass
                    &&  (   (ptci && ptci->_fSetCellPosition) 
                        //  or if cell is called directly to clone disp node
                        ||  (!ptci && pci->_fCloneDispNode)) )
                {
                    CLayoutBreak * pLayoutBreakBeg, *pLayoutBreakEnd;
                    BOOL fFlowBrokenBeg = FALSE;
                    BOOL fFlowBrokenEnd = FALSE;
    
                    pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreakBeg);
                    if (pLayoutBreakBeg)
                    {
                        fFlowBrokenBeg = DYNCAST(CTableCellLayoutBreak, pLayoutBreakBeg)->IsFlowBroken();
                    }
    
                    pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreakEnd); 
                    if (pLayoutBreakEnd)
                    {
                        fFlowBrokenEnd = DYNCAST(CTableCellLayoutBreak, pLayoutBreakEnd)->IsFlowBroken();
                    }
    
                    if (va == styleVerticalAlignMiddle)
                    {
                        if (fFlowBrokenBeg != fFlowBrokenEnd)
                        {
                            va = fFlowBrokenEnd ? styleVerticalAlignBottom : styleVerticalAlignTop;
                        }
                    }
                    else if (va == styleVerticalAlignBaseline && fFlowBrokenBeg)
                    {
                        va = styleVerticalAlignTop;
                        cy = _sizeCell.cy;
                    }
                }
    
                SizeDispNodeInsets(va, cy, pDispNode);
            }
            //
            // Update cy value to display node height, in case of changed layout flow
            //
            if (   pFF->_fLayoutFlowChanged
                && (pci->_smMode == SIZEMODE_NATURALMIN || pci->_smMode == SIZEMODE_NATURAL))
            {
                psize->cy = max(psize->cy, pDispNode->GetSize().cy);
            }
        }
    
        return dwRet;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\table\ltpos.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltpos.cxx
//
//  Contents:   CTableLayout positioning methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include <mshtmdid.h>
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif


ExternTag(tagTableRecalc);
ExternTag(tagLayout);


//+----------------------------------------------------------------------------
//
//  Member:     GetPositionInFlow
//
//  Synopsis:   Return the position of a layout derived from its position within
//              the document text flow
//
//  Arguments:  pLayout - Layout to position
//              ppt     - Returned top/left (in parent content relative coordinates)
//
//-----------------------------------------------------------------------------

void
CTableLayoutBlock::GetPositionInFlow(CElement *pElement, CPoint  *ppt)
{
    Assert(ppt);

    CLayoutContext  *pLayoutContext = LayoutContext();
    Assert(pElement->CurrentlyHasLayoutInContext(pLayoutContext) && "Layout MUST exist in the layout context.");

    CLayout *pLayout = pElement->CurrentlyHasLayoutInContext(pLayoutContext) ? pElement->GetUpdatedLayout(pLayoutContext) : NULL;
    Assert(pLayout && "We are in deep trouble if the element passed in doesn't have a layout");

    if (!pLayout)
    {
        *ppt = g_Zero.pt;
        return;
    }

    BOOL fRTL = IsRightToLeft();

    //
    // Locate the layout within the document
    //

    ppt->x = pLayout->GetXProposed();
    ppt->y = pLayout->GetYProposed();

    if(fRTL)
    {
        CTableLayout *pTableLayoutCache = Table()->TableLayoutCache();
        Assert(pTableLayoutCache);

        // TODO RTL 112514: this is close, but not exactly same as in SetCellPositions
        int xTableWidth = GetWidth();
        
        ppt->x = xTableWidth + ppt->x
               - pTableLayoutCache->_aiBorderWidths[SIDE_LEFT];

        // TODO RTL 112514: this looks like a total hack, and it is.
        //                  there shouldn't be any RTL-specific code for Y, 
        //                  but the result is wrong unless we do this, and we don't ever get here
        //                  in LTR case, so there is no way to check if the standard calculation 
        //                  is correct
        ppt->y -= pTableLayoutCache->_aiBorderWidths[SIDE_TOP];

    }
    else if (pElement->Tag() != ETAG_TR)
    {
        // this code should be in sync with CTableLayout::SetCellPositions()
        CTableCell *pTableCell      = DYNCAST(CTableCell, pElement);
        BOOL        fPositionedRow  = pTableCell->Row()->IsPositioned(); 

        // adjust the proposed position if the cell is not positioned
        // or it is positioned and the row is not positioned and cell is directly 
        // under the grid node.
        // or if cell is relatively positioned and the row is also positioned
        if (   !pTableCell->IsPositioned() 
            || (!fPositionedRow && IsGridAndMainDisplayNodeTheSame())
            || fPositionedRow  )
        {
            CTableLayout * pTableLayoutCache = Table()->TableLayoutCache();
            Assert(pTableLayoutCache);

            ppt->x -= pTableLayoutCache->_aiBorderWidths[SIDE_LEFT];

            if (!fPositionedRow)
                ppt->y -= (pTableLayoutCache->_aiBorderWidths[SIDE_TOP] + _yTableTop);
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     AddLayoutDispNode
//
//  Synopsis:   Add the display node of passed layout
//
//  Arguments:  pci            - CalcInfo (used for retrieving layout context) 
//              pLayout        - Layout whose display node is to be added
//              pDispContainer - CDispNode which should contain the display node
//              pDispSibling   - Left-hand sibling display node
//              ppt            - Pointer to POINT with position or NULL
//              fBefore        - FALSE to add as next sibling, TRUE to add as previous sibling
//
//              NOTE: Either pDispContainer or pDispSibling must be supplied, the
//                    other may be NULL
//
//  Returns:    S_OK if added, S_FALSE if ignored, E_FAIL otherwise
//-----------------------------------------------------------------------------
HRESULT
CTableLayout::AddLayoutDispNode(
    CTableCalcInfo *    ptci,
    CLayout *           pLayout,
    CDispContainer *    pDispContainer,
    CDispNode *         pDispNodeSibling,
    const POINT *       ppt,
    BOOL                fBefore)
 {
    CDispNode * pDispNode;
    HRESULT     hr = S_OK;
    CPoint      ptTopRight = g_Zero.pt;

    Assert(pLayout);
    Assert(pLayout != this);
    Assert(pDispContainer || pDispNodeSibling);

    if (ptci->TableLayout()->_pDispNode == NULL)
    {
        goto Error;
    }

    pDispNode = pLayout->GetElementDispNode();

    if (!pDispNode)
        goto Error;

    Assert(pDispNode != pDispNodeSibling);
    Assert(pDispNode->IsOwned());
    Assert(pDispNode->IsFlowNode());

    if (!pLayout->IsDisplayNone())
    {
        if (ppt)
        {
            pLayout->SetPosition(*ppt, TRUE);
        }

        if (pDispNodeSibling)
        {
            pDispNodeSibling->InsertSiblingNode(pDispNode, (CDispNode::BeforeAfterEnum)fBefore);

        }
        else
        {
            pDispContainer->InsertFirstChildInFlow(pDispNode);
        }

    }
    else
    {
        GetView()->ExtractDispNode(pDispNode);
        hr = S_FALSE;
    }

    return hr;

Error:
    return E_FAIL;
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureTableBorderDispNode
//
//  Synopsis:   Manage the lifetime of the table border display node during measuring
//
//  Arugments:  pdci   - Current CDocInfo
//              fForce - Forcibly update the display node(s)
//
//  Returns:    S_OK    if successful
//              S_FALSE if nodes were created/destroyed
//              E_FAIL  otherwise
//
//-----------------------------------------------------------------------------

HRESULT
CTableLayout::EnsureTableBorderDispNode(CTableCalcInfo * ptci)
{
    CDispContainer *    pDispNodeTableGrid;
    CTableLayoutBlock * pTableLayoutBlock = ptci->TableLayout();
    CTableBorderRenderer *pTableBorderRenderer = pTableLayoutBlock->GetTableBorderRenderer();
    HRESULT hr = S_OK;

    Assert(pTableLayoutBlock->_pDispNode != NULL);

    // Locate the display node that anchors all cells.  This will be the
    // parent of the border display node if one is needed.
    pDispNodeTableGrid = pTableLayoutBlock->GetTableOuterDispNode();

    Assert(pDispNodeTableGrid);

    if ((_fCollapse || _fRuleOrFrameAffectBorders) && GetRows())
    {
        CDispLeafNode * pDispLeafNew = NULL;
        CDispLeafNode * pDispLeafCurrent = NULL;
        CRect   rcClientRect;
        SIZE    size;

        if ( !pTableBorderRenderer )
        {
            pTableBorderRenderer = new CTableBorderRenderer(pTableLayoutBlock);
            if (!pTableBorderRenderer)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pTableLayoutBlock->SetTableBorderRenderer( pTableBorderRenderer );
        }
        else
        {
            if( pTableBorderRenderer->_pDispNode )
                pDispLeafCurrent = DYNCAST(CDispLeafNode, pTableBorderRenderer->_pDispNode);
        }

        // if we don't have a disp node, or are changing directions, create a new node
        if ( !pTableBorderRenderer->_pDispNode )
        {
            // Create display leaf node (this border dispnode has no border of
            // its own)
            pDispLeafNew = CDispLeafNode::New(pTableBorderRenderer);

            if (!pDispLeafNew)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Assert(!pDispLeafNew->IsOwned());
            // The border display node is in the flow layer (highest z-order among flow display nodes).
            pDispLeafNew->SetLayerFlow();

            Assert(!pDispLeafCurrent);  // thise could only happen when we replaced 
                                        // disp nodes on direction change

            pDispNodeTableGrid->InsertChildInFlow(pDispLeafNew);

            pTableBorderRenderer->_pDispNode = pDispLeafNew;
        }
        else
        {
            pDispLeafNew = DYNCAST(CDispLeafNode, pTableBorderRenderer->_pDispNode);
            // Make sure border display node is last in list (highest z order among display node FLOW layers).

            // If we have a "next" (right) sibling, reinsert the border display node in the last position
            if (pDispLeafNew->GetNextFlowNode())
            {
                GetView()->ExtractDispNode(pDispLeafNew);
                pDispNodeTableGrid->InsertChildInFlow(pDispLeafNew);
            }
        }

        Assert(pDispLeafNew);

        // Make sure the border display node has the right size.
        // Size should always be adjusted for table borders since we
        // just finished a layout.
        pDispNodeTableGrid->GetClientRect(&rcClientRect, CLIENTRECT_CONTENT);
        rcClientRect.GetSize(&size);
        pDispLeafNew->SetSize(size, NULL, FALSE);
    }
    else if ( pTableBorderRenderer )
    {
        CDispNode * pDispNode = pTableBorderRenderer->_pDispNode;

        if (pDispNode)
        {
            pDispNode->Destroy();
            pTableBorderRenderer->_pDispNode = NULL;
        }

        pTableBorderRenderer->Release();
        pTableLayoutBlock->SetTableBorderRenderer(NULL);
    }

Cleanup:

    RRETURN(hr);
}


void
CTableLayoutBlock::EnsureContentVisibility(
    CDispNode * pDispNode,
    BOOL        fVisible)
{
    // take care of visibility of collapsed border display node
    if (    pDispNode == GetElementDispNode())
    {
        // first handle collapsed and frame borders
        if (   (   Table()->TableLayoutCache()->_fCollapse
                ||  Table()->TableLayoutCache()->_fRuleOrFrameAffectBorders)
            &&  _pTableBorderRenderer
            &&  _pTableBorderRenderer->_pDispNode)
        {
            _pTableBorderRenderer->_pDispNode->SetVisible(fVisible);
        }

        // now handle caption dispNode
        if (   _fHasCaptionDispNode
            && GetCaptionDispNode())
        {
            GetTableOuterDispNode()->SetVisible(fVisible);
        }
    }
}

//+====================================================================================
//
// Method: EnsureTableFatHitTest
//
// Synopsis: Ensure the FatHit Test bit on the DispNode is set appropriately. 
//
//------------------------------------------------------------------------------------

//
// FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
// TODO - At some point the edit team may want to provide
// a better UI-level way of selecting nested "thin" tables
//
//
// TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
//

HRESULT             
CTableLayout::EnsureTableFatHitTest(CDispNode* pDispNode)
{
    pDispNode->SetFatHitTest( GetFatHitTest() );

    RRETURN( S_OK );
}

//+====================================================================================
//
// Method: GetFatHitTest
//
// Synopsis: Get whether this table layout requires "fat" hit testing.
//
//------------------------------------------------------------------------------------

//
// FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
// TODO - At some point the edit team may want to provide
// a better UI-level way of selecting nested "thin" tables
//
//
// TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
//

BOOL
CTableLayout::GetFatHitTest()
{
    return ( IsEditable() &&
             CellSpacingX() == 0 && 
             CellSpacingY() == 0 &&
             BorderX() <= 1 && 
             BorderY() <= 1 ) ;
}

#ifdef NEVER 
//+----------------------------------------------------------------------------
//
//  Member:     GetTableSize
//
//  Synopsis:   Return the current width/height of the table
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------
void
CTableLayout::GetTableSize(
    CSize * psize)
{
    CDispNode * pDispNode;

    Assert(psize);

    pDispNode = GetTableOuterDispNode();

    if (pDispNode)
    {
        *psize = pDispNode->GetSize();
    }
    else
    {
        *psize = g_Zero.size;
    }
}
#endif // NEVER 


//+----------------------------------------------------------------------------
//
//  Member:     SizeDispNode
//
//  Synopsis:   Adjust the size of the table layout display node
//
//  Arugments:  pci       - Current CCalcInfo
//              size      - Size including CAPTIONs
//              sizeTable - Size excluding CAPTIONs
//
//-----------------------------------------------------------------------------
void
CTableLayout::SizeTableDispNode(
    CTableCalcInfo *ptci,
    const SIZE &    size,
    const SIZE &    sizeTable,
    int             yTopInvalidRegion)

{
    CElement *          pElement = ElementOwner();
    CDispContainer *    pDispNodeTableOuter;
    CDispNode *         pDispNodeElement;
    BOOL                fInvalidateAll;
    DISPNODEBORDER      dnb;
    CSize               sizeOriginal;
    CDoc *              pDoc;
    CTableLayoutBlock * pTableLayout;
    CRect               rcpMapped;
    CRect *             prcpMappedElement = NULL;
    CRect *             prcpMappedOuter = NULL;

    Assert(ptci);

    pTableLayout = ptci->TableLayout();

    if (pTableLayout->_pDispNode == NULL)
    {
        goto Cleanup;
    }

    //
    //  Locate the display node that anchors all cells
    //  (If a separate CAPTIONs display node exists, the display node for cells
    //   will be the only unowned node in the flow layer)
    //

    pDispNodeElement    = pTableLayout->GetElementDispNode();
    pDispNodeTableOuter = pTableLayout->GetTableOuterDispNode();

    //
    // Invalidate the entire table area if its size has changed.
    //

    sizeOriginal = pDispNodeElement->GetSize();

    fInvalidateAll = sizeOriginal != sizeTable;

    //
    //  Set the border size (if any)
    //  NOTE: These are set before the size because a change in border widths
    //        forces a full invalidation of the display node. If a full
    //        invalidation is necessary, less code is executed when the
    //        display node's size is set.
    //

    dnb            = pDispNodeTableOuter->GetBorderType();
    pDoc           = Doc();

    if (dnb != DISPNODEBORDER_NONE)
    {
        CRect       rcBorderWidths;
        CRect       rc;
        CBorderInfo bi;

        pDispNodeTableOuter->GetBorderWidths(&rcBorderWidths);

        pElement->GetBorderInfo(ptci, &bi, FALSE, FALSE);

        rc.left   = bi.aiWidths[SIDE_LEFT];
        rc.top    = bi.aiWidths[SIDE_TOP];
        rc.right  = bi.aiWidths[SIDE_RIGHT];
        rc.bottom = bi.aiWidths[SIDE_BOTTOM];

        if (rc != rcBorderWidths)
        {
            if (dnb == DISPNODEBORDER_SIMPLE)
            {
                pDispNodeTableOuter->SetBorderWidths(rc.top);
            }
            else
            {
                pDispNodeTableOuter->SetBorderWidths(rc);
            }

            fInvalidateAll = TRUE;
        }
    }

    //
    //  Determine if a full invalidation is necessary
    //  (A full invalidation is necessary only when there is a fixed
    //   background located at a percentage of the width/height)
    //

    if (    !fInvalidateAll
        &&  pDispNodeTableOuter->HasBackground()
        &&  pDispNodeTableOuter->IsScroller()
        &&  pDispNodeTableOuter->HasFixedBackground())
    {
        const CFancyFormat *    pFF = GetFirstBranch()->GetFancyFormat();

        // Logical/Physical does not matter when we get bg pos here because
        // 1) Tables are always horizontal
        // 2) We are checking both X and Y here
        fInvalidateAll =    pFF->_lImgCtxCookie
                    &&  (   pFF->GetBgPosX().GetUnitType() == CUnitValue::UNIT_PERCENT
                        ||  pFF->GetBgPosY().GetUnitType() == CUnitValue::UNIT_PERCENT);
    }

    //
    //  If there are any behaviors that want to map the size, find out the details
    //  now so we can tell the disp node.
    //

    if (DelegateMapSize(size, &rcpMapped, static_cast<CCalcInfo *>(ptci)))
    {
        if (pTableLayout->_fHasCaptionDispNode)
        {
            prcpMappedElement = &rcpMapped;
        }
        else
        {
            prcpMappedOuter = &rcpMapped;
        }
    }

    //
    //  Size the table node
    //

    if (yTopInvalidRegion)
    {
        // invalidate only the part of the table, starting from the yTopInvalidRegion till the bottom
        CRect rcInvalid;

        Assert (yTopInvalidRegion <= sizeTable.cy);
        rcInvalid.left =0;
        rcInvalid.right = sizeTable.cx;
        rcInvalid.top = yTopInvalidRegion;
        rcInvalid.bottom =  sizeTable.cy;
        fInvalidateAll = FALSE;
        pDispNodeTableOuter->SetSize(sizeTable, prcpMappedOuter, fInvalidateAll);
        pDispNodeTableOuter->Invalidate(rcInvalid, COORDSYS_PARENT);
    }
    else
    {
        pDispNodeTableOuter->SetSize(sizeTable, prcpMappedOuter, fInvalidateAll);
    }

    //
    //  Finally, if CAPTIONs exist, size that node as well
    //

    if (pTableLayout->_fHasCaptionDispNode)
    {
        pDispNodeElement->SetSize(size, prcpMappedElement, fInvalidateAll);
    }

    //
    //  If the display node has an explicit user transformation, set details
    //

    if (pDispNodeElement->HasUserTransform())
    {
        SizeDispNodeUserTransform(ptci, size, pDispNodeElement);
    }

    //
    //  If the display node has an explicit user clip, size it
    //

    if (pDispNodeElement->HasUserClip())
    {
        SizeDispNodeUserClip(ptci, size, pDispNodeElement);
    }

    //
    //  Fire related events
    //

    if (    (CSize &)size != sizeOriginal
        &&  !IsDisplayNone()
        &&  pDoc->_state >= OS_INPLACE
        &&  pElement->GetMarkup()->Window()
        &&  pElement->GetMarkup()->Window()->_fFiredOnLoad)
    {
        pDoc->GetView()->AddEventTask(pElement, DISPID_EVMETH_ONRESIZE);
    }

    if (pElement->ShouldFireEvents())
    {
        if (size.cx != sizeOriginal.cx)
        {
            pElement->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETWIDTH);
            pElement->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTWIDTH);
        }

        if (size.cy != sizeOriginal.cy)
        {
            pElement->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETHEIGHT);
            pElement->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTHEIGHT);
        }
    }
Cleanup:
    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     DestroyFlowDispNodes
//
//  Synopsis:   Destroy any created flow nodes
//
//-----------------------------------------------------------------------------
void
CTableLayout::DestroyFlowDispNodes()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\table\ltdata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltdata.cxx
//
//  Contents:   CTableLayout databinding methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx" // CTreePosList in CTableLayout::Notify
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include "detail.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_SAVER_HXX_
#define X_SAVER_HXX_
#include "saver.hxx"
#endif

// DB support

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"  // DB stuff in Notify
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include <rowbind.hxx>
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

//+----------------------------------------------------------------------------------------------
//  Databind support methods
//-----------------------------------------------------------------------------------------------

#ifndef NO_DATABINDING
//+---------------------------------------------------------------------------
//
//  Member:     Populate
//
//  Synopsis:   Populate the table with repeated rows if the DataSrc property is
//              specified.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::Populate()
{
    HRESULT                     hr;
    int                         cInsertNewRowAt;
    CDataLayerCursor            *pdlcCursor;

    // Don't generate or remove rows when a table is not in the tree
    if (!Table()->_fEnableDatabinding)
        return S_OK;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    cInsertNewRowAt = GetHeadFootRows();

    Assert ((_fRefresh && _pDetailGenerator) || (!_fRefresh && !_pDetailGenerator));
    Assert(Table()->GetDBMembers());
    Assert(Table()->GetDBMembers()->GetBinder(ID_DBIND_DEFAULT));

    // get the DLCursor from the binder
    hr = Table()->GetDBMembers()->GetBinder(ID_DBIND_DEFAULT)->GetDLCursor(&pdlcCursor);
    if (hr)
        goto Cleanup;

    if (!_fRefresh)
    {
        _pDetailGenerator = new CDetailGenerator();    // expanded table
        if (!_pDetailGenerator)
            goto MemoryError;

        Doc()->_fBroadcastStop = TRUE;

        _pDetailGenerator->SetTemplateCount(GetRows() - cInsertNewRowAt);
    }

    hr = _pDetailGenerator->Init (pdlcCursor, Table(), cInsertNewRowAt,
                                  Table()->GetAAdataPageSize());
    if (hr)
        goto Error;

    if (!_fRefresh)
    {
        hr = _pDetailGenerator->PrepareForCloning();
        if (hr)
            goto Cleanup;

        // Remove the templates from _aryRows
        RemoveTemplate();

        if ( THR(EnsureTableLayoutCache()) )
            goto Error;

        Assert (GetRows() == cInsertNewRowAt);
    }
    hr = _pDetailGenerator->Generate ();

Cleanup:

    _fRefresh = FALSE;

    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    if (_pDetailGenerator)
    {
        _pDetailGenerator->Detach();
        delete _pDetailGenerator;
        _pDetailGenerator = NULL;
    }

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     Refresh (regenerate)
//
//  Synopsis:   Populate the table with repeated rows when setting the new
//              RepeatSrc property.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CTableLayout::refresh()
{
    HRESULT hr = S_OK;

#ifndef NO_DATABINDING
    if (_pDetailGenerator)
    {
        hr = DeleteGeneratedRows();
        if (hr)
            goto Cleanup;

        hr = Populate();
        if (hr)
            goto Cleanup;
    }

Cleanup:
#endif

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     GetTemplate
//
//  Synopsis:   create the template for repeating rows.
//
//-----------------------------------------------------------------------------

HRESULT
CTableLayout::GetTemplate(BSTR * pbstr)
{
    HRESULT    hr = E_FAIL;
    int i;

    if (ElementOwner()->IsInMarkup())
    {
        IStream * pstm;

        hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
        if (hr)
            goto Cleanup;

        {
            CStreamWriteBuff swb(pstm, CP_UCS_2);

            hr = THR( swb.Init() );
            if( hr )
                goto Cleanup;

            swb.SetFlags(WBF_ENTITYREF|WBF_DATABIND_MODE);

            hr = EnsureTableLayoutCache();
            if (hr)
                goto Cleanup;

            // append each TBODY to the template
            for (i=0; i<_aryBodys.Size(); ++i)
            {
                CTreeSaver ts(_aryBodys[i], &swb);
                
                swb.SetElementContext(_aryBodys[i]);

                // if the body is synthesized, ts.Save won't write out its begin
                // and end tags.  But we want them in the template, so write
                // them out explicitly.  One reason we want them:  setting
                // borders=groups will write borders between each template
                // instance.
                _aryBodys[i]->WriteTag(&swb, FALSE, TRUE);
                ts.Save();
                _aryBodys[i]->WriteTag(&swb, TRUE, TRUE);
            }

            swb.Terminate();
        }

        hr = GetBStrFromStream(pstm, pbstr, TRUE);

        ReleaseInterface(pstm);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     DeleteGeneratedRows (private)
//
//  Synopsis:   Remove the generated rows, preparing for refresh
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::DeleteGeneratedRows()
{
    HRESULT hr = S_OK;

    if (_pDetailGenerator)
    {
        _fRefresh = TRUE;

        // delete all the generated rows

        _pDetailGenerator->ReleaseGeneratedRows();   // need to delete Xfer thunks, before deleting rows

        RemoveTemplate();
    }

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     RemoveRowsAndTheirSections
//
//  Synopsis:   Removes all rows in the given range and their sectionsw.
//              Can't remove header/footer.
//
//-----------------------------------------------------------------------------

HRESULT
CTableLayout::RemoveRowsAndTheirSections ( int iRowStart, int iRowFinish )
{
    // Don't generate or remove rows when a table is not in the tree
    if (!Table()->_fEnableDatabinding)
        return S_OK;
    {
        HRESULT         hr;
        CTableSection * pSection = NULL;
        int             iBodyStart = 0;
        int             iBodyFinish = 0;
        int             i;

        // This function should only be called to remove rows that make up one
        // or more complete template instances.  In particular, it shouldn't be
        // called for tables that aren't databound.  A general RemoveRows would
        // have to deal with row spans and other issues that don't arise in
        // databound tables.
        
        Assert(IsRepeating());
        
        //
        // Are there any rows to remove?
        //
        
        Assert(GetHeadFootRows() <= iRowStart  &&  iRowFinish < GetRows());
        
        if (iRowStart > iRowFinish)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        //
        // Delete the rows by deleting spans of consecutive runs.
        // The runs owned by the given rows may be non-consecutive, so be careful.
        // We delete the rows back-to-front, because each call to RemoveRuns
        // blows away and rebuilds _aryRows (via monster walk).
        //
        
        for (i=0; i < _aryBodys.Size(); i++)
        {
            pSection = _aryBodys[i];
            if (iRowStart >= pSection->_iRow && iRowStart < pSection->_iRow + pSection->_cRows)
            {
                iBodyStart = i;
            }
            if (iRowFinish >= pSection->_iRow && iRowFinish < pSection->_iRow + pSection->_cRows)
            {
                iBodyFinish = i;
                break;
            }
        }

        Assert (iBodyFinish >= iBodyStart);

        hr = RemoveBodys(iBodyStart, iBodyFinish);

    Cleanup:
        RRETURN( hr );
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     RemoveBodys
//
//  Synopsis:   Removes all bodys in the given range.  Can't remove header/footer.
//
//-----------------------------------------------------------------------------

HRESULT
CTableLayout::RemoveBodys (int iBodyStart, int iBodyFinish)
{
    HRESULT         hr = S_OK;

    // Don't generate or remove rows when a table is not in the tree
    if (!Table()->_fEnableDatabinding)
        goto Cleanup;

    {
        CMarkupPointer pStart( Doc() ), pEnd( Doc() );
        
        BOOL            fRemoveAll;
        int             iBodyFinishNext;

        _fRemovingRows = TRUE;

        Verify(OpenView());

        // This function should only be called to remove bodys that make up one
        // or more complete template instances.  In particular, it shouldn't be
        // called for tables that aren't databound.  A general RemoveBodys would
        // have to deal with row spans and other issues that don't arise in
        // databound tables.
        Assert(IsRepeating());
        
        //
        // Are there any bodys to remove?
        //
        Assert(0 <= iBodyStart  &&  iBodyFinish < _aryBodys.Size());
        if (iBodyStart > iBodyFinish)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        
        fRemoveAll = iBodyStart == 0 && iBodyFinish == GetBodys() - 1;

        //
        // Delete the bodys by deleting spans of consecutive runs.
        // The bodys may be non-consecutive, so be careful.
        // We delete the bodys back-to-front.
        //
        
        iBodyFinishNext = iBodyFinish;
        while (iBodyStart <= iBodyFinishNext)
        {
            int iBodyFinishDelete = iBodyFinishNext;

            // set gaps to surround the last body

            hr = THR( pStart.MoveAdjacentToElement( _aryBodys[iBodyFinishNext], ELEM_ADJ_BeforeBegin ) );

            if (hr)
                goto Cleanup;
            
            hr = THR( pEnd.MoveAdjacentToElement( _aryBodys[iBodyFinishNext], ELEM_ADJ_AfterEnd ) );

            if (hr)
                goto Cleanup;
            
            // augment the span as long as the bodys are consecutive
            while (iBodyStart <= --iBodyFinishNext)
            {
                CMarkupPointer pNextEnd ( Doc() );

                hr = THR( pNextEnd.MoveAdjacentToElement( _aryBodys[iBodyFinishNext], ELEM_ADJ_AfterEnd ) );

                if (hr)
                    goto Cleanup;
                
                if (pNextEnd.IsEqualTo( & pStart ))
                {
                    hr = THR( pStart.MoveAdjacentToElement( _aryBodys[iBodyFinishNext], ELEM_ADJ_BeforeBegin ) );

                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    break;
                }
            }

            // This is one of the few places where a table is modified.
            // Mark the TLC dirty now.
            Table()->InvalidateCollections();

            if (fRemoveAll && iBodyFinishNext<iBodyStart && iBodyFinishDelete==iBodyFinish)
            {
                ReleaseRowsAndSections(FALSE, TRUE);  // fReleaseHeaderFooter = FALSE, fReleaseTCs = TRUE
            }
            else
            {
                ReleaseBodysAndTheirRows(iBodyFinishNext + 1, iBodyFinishDelete);
            }

            // remove the consecutive bodys
            hr = THR( Doc()->Remove( & pStart, & pEnd ) );

            if (hr)
                goto Cleanup;

            _fRemovingRows = FALSE;

        }

        Resize();
    }

Cleanup:
    _fRemovingRows = FALSE;     // in case of goto (error condition) we want to restore the flag
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     RowIndex2RecordNumber
//
//  Synopsis:   find the database position of a given row
//
//  Arguments:  iRow        index of desired row
//
//  Returns:    index of corresponding database record
//
//-----------------------------------------------------------------------------

long
CTableLayout::RowIndex2RecordNumber(int iRow)
{
    Assert(IsRepeating());
    return _pDetailGenerator->RowIndex2RecordNumber(iRow);
}
#endif // NO_DATABINDING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\table\ltdraw.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltdraw.cxx
//
//  Contents:   CTableLayout drawing methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif


MtDefine(CTableLayoutDrawSiteList_aryElements_pv, Locals, "CTableLayout::DrawSiteList aryElements::_pv")
MtDefine(CTableLayout_pBorderInfoCellDefault, CTableLayout, "CTableLayout::_pBorderInfoCellDefault")
MtDefine(CTableLayout_pTableBorderRenderer, CTableLayout, "CTableLayout::_pTableBorderRenderer")

extern const WORD s_awEdgesFromTableFrame[htmlFrameborder+1];
extern const WORD s_awEdgesFromTableRules[htmlRulesall+1];

ExternTag(tagTableRecalc);
DeclareTag(tagNoExcludeClip, "Tables", "Don't exclude cliprects in GetCellBorderInfo")
DeclareTag(tagNoExcludeClipCorners, "Tables", "Don't exclude corner cliprects in GetCellBorderInfo")
DeclareTag(tagNoInflateRect, "Tables", "Don't inflate invalid rect in collapsed tables")
DeclareTag(tagNoBorderInfoCache, "Tables", "Don't use the tablewide borderinfo cache")
DeclareTag(tagDontComeOnIn, "Tables", "Rule out no-border cells for corner rendering")
DeclareTag(tagClipInsetRect, "Tables", "Clip corner out from inset rect")
DeclareTag(tagNoCollapsedBorders, "Tables", "Disable rendering of collapsed borders")
DeclareTag(tagRedCollapsedBorders, "Tables", "Render collapsed borders in red")
DeclareTag(tagTableBorder, "Tables", "Trace border drawing")


//+--------------------------------------------------------------------------------------
//
// Drawing methods overriding CLayout
//
//---------------------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CTableCell::GetCellBorderInfoDefault
//
//  Synopsis:   Retrieves a single table cell's borderinfo.
//
//  Arguments:  pdci [in]         Docinfo
//              pborderinfo [out] Pointer to borderinfo structure to be filled
//              fRender [in]      Is this borderinfo needed for rendering or
//                                layout? (render retrieves more info, e.g. colors)
//
//  Returns:    TRUE if the cell has at least one border.  FALSE otherwise.
//
//  Note:       This routine makes use of a tablewide cell-border default cache
//              to retrieve normal cell borderinfos faster (memcpy).  If the cache
//              doesn't exist, it creates it as a side-effect once we encounter
//              the first cell with default border settings.
//
//              We retrieve border settings by first inheriting defaults from the
//              table, and then relying on CElement::GetBorderInfo() to override
//              the defaults.
//
//-------------------------------------------------------------------------

DWORD
CTableCellLayout::GetCellBorderInfoDefault(
    CDocInfo const *pdci,
    CBorderInfo *   pborderinfo,
    BOOL            fRender,
    BOOL            fAllPhysical,                                           
    CTable *        pTable,
    CTableLayout *  pTableLayout
    FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    CTableCell *    pCell        = TableCell();
    BOOL            fNotCaption  = !IsCaption(pCell->Tag());
    CTreeNode *     pCellNode    = pCell->GetFirstBranch();
    BOOL            fOverrideTablewideBorderSettings = pCellNode->GetCascadedborderOverride();

    BOOL            fUseBorderCache = !fOverrideTablewideBorderSettings   WHEN_DBG( && !IsTagEnabled(tagNoBorderInfoCache) )
                                    && pTableLayout 
                                    && (pTableLayout->CanRecalc() && pTableLayout->_sizeMax.cx != -1)
                                    && !pTableLayout->_fRuleOrFrameAffectBorders
                                    && fNotCaption
                                    && !pCell->HasVerticalLayoutFlow();
    
    if (!pTableLayout || (!pTableLayout->_fBorder && fUseBorderCache) || pCellNode->IsDisplayNone())
    {
        memset(pborderinfo, 0, sizeof(CBorderInfo));
        goto Done;
    }

    if (pTableLayout->_fBorderInfoCellDefaultCached && fUseBorderCache)
    {
        Assert(pTableLayout->_pBorderInfoCellDefault && "CTableLayout::_fBorderInfoCellDefaultCached should imply CTableLayout::_pBorderInfoCellDefault");
        memcpy(pborderinfo, pTableLayout->_pBorderInfoCellDefault, sizeof(CBorderInfo));
        goto Done;
    }

    // Make sure we are retrieving everything everything if we are going to cache this guy.
    fRender |= fUseBorderCache;

    // Initialize border info.
    pborderinfo->Init();

    // Inherit default settings from table.
    if (pTableLayout->_fBorder && fNotCaption)
    {
        int                  xBorder = pTableLayout->BorderX() ? 1 : 0;
        int                  yBorder = pTableLayout->BorderY() ? 1 : 0;
        WORD                 wEdges;
        WORD                 wFrameEdges;
        htmlRules            trRules = htmlRulesNotSet;
        htmlFrame            hf = htmlFrameNotSet;

        wFrameEdges = s_awEdgesFromTableFrame[hf];
        wEdges      = s_awEdgesFromTableRules[trRules];

        if ( pTableLayout->EnsureTableLayoutCache() )
            return FALSE;

        if (pTableLayout->_fRuleOrFrameAffectBorders)
        {

            htmlRules trRules = pTable->GetAArules();
            htmlFrame hf = pTable->GetAAframe();

            Assert(htmlFrameNotSet == 0);
            Assert(hf < ARRAY_SIZE(s_awEdgesFromTableFrame));
            Assert(htmlRulesNotSet == 0);
            Assert(trRules < ARRAY_SIZE(s_awEdgesFromTableRules));

            wFrameEdges = s_awEdgesFromTableFrame[hf];
            wEdges      = s_awEdgesFromTableRules[trRules];


            if (trRules == htmlRulesgroups)
            {
                CTableCol * pColGroup;
                CTableSection * pSection;

                pColGroup = pTableLayout->GetColGroup(ColIndex());

                if (pColGroup)
                {
                    if (pColGroup->_iCol == ColIndex())
                    {
                        wEdges |= BF_LEFT;
                    }
                    if (pColGroup->_iCol + pColGroup->_cCols == (ColIndex() + pCell->ColSpan()))
                    {
                        wEdges |= BF_RIGHT;
                    }
                }

                pSection = Row()->Section();
                if (pSection->_iRow == pCell->RowIndex())
                {
                    wEdges |= BF_TOP;
                }
                if (pSection->_iRow + pSection->_cRows == (pCell->RowIndex() + pCell->RowSpan()))
                {
                    wEdges |= BF_BOTTOM;
                }
            }
        }

        //
        // Adjust edges of perimeter cells to match the FRAME/BORDER setting
        //

        if ( ColIndex() == 0 )
        {
            if ( wFrameEdges & BF_LEFT )
                wEdges |= BF_LEFT;
            else
                wEdges &= ~BF_LEFT;
        }
        if ( ColIndex()+pCell->ColSpan() == pTableLayout->GetCols() )
        {
            if ( wFrameEdges & BF_RIGHT )
                wEdges |= BF_RIGHT;
            else
                wEdges &= ~BF_RIGHT;
        }
        if ( pCell->RowIndex() == pTableLayout->GetFirstRow() )
        {
            if ( wFrameEdges & BF_TOP )
                wEdges |= BF_TOP;
            else
                wEdges &= ~BF_TOP;
        }
        if ( pCell->RowIndex() + pCell->RowSpan() - 1 == pTableLayout->GetLastRow() )   // NOTE (alexa): potential problem going across the section
        {
            if ( wFrameEdges & BF_BOTTOM )
                wEdges |= BF_BOTTOM;
            else
                wEdges &= ~BF_BOTTOM;
        }

        if (wEdges & BF_TOP)
        {
            pborderinfo->aiWidths[SIDE_TOP]    = yBorder;
            pborderinfo->abStyles[SIDE_TOP]    = fmBorderStyleSunkenMono;
        }

        if (wEdges & BF_BOTTOM)
        {
            pborderinfo->aiWidths[SIDE_BOTTOM] = yBorder;
            pborderinfo->abStyles[SIDE_BOTTOM] = fmBorderStyleSunkenMono;
        }

        if (wEdges & BF_LEFT)
        {
            pborderinfo->aiWidths[SIDE_LEFT]   = xBorder;
            pborderinfo->abStyles[SIDE_LEFT]   = fmBorderStyleSunkenMono;
        }

        if (wEdges & BF_RIGHT)
        {
            pborderinfo->aiWidths[SIDE_RIGHT]  = xBorder;
            pborderinfo->abStyles[SIDE_RIGHT]  = fmBorderStyleSunkenMono;
        }
    }

    pCell->CElement::GetBorderInfo( (CDocInfo *)pdci, pborderinfo, fRender, fAllPhysical FCCOMMA FCPARAM);   //  This will scale the borders.

    // If this is a default cell, it means we have no cache since we got here, so
    // create the cache.
    if (fUseBorderCache)
    {
        Assert(fRender && "Caching an incomplete borderinfo");
        Assert(!pTableLayout->_fBorderInfoCellDefaultCached);
        Assert(pTableLayout->_fBorder);

        if (!pTableLayout->_pBorderInfoCellDefault)
            pTableLayout->_pBorderInfoCellDefault = (CBorderInfo *)MemAlloc(Mt(CTableLayout_pBorderInfoCellDefault), sizeof(CBorderInfo));

        if (pTableLayout->_pBorderInfoCellDefault)
        {
            memcpy(pTableLayout->_pBorderInfoCellDefault, pborderinfo, sizeof(CBorderInfo));
            pTableLayout->_fBorderInfoCellDefaultCached = TRUE;
        }
    }

Done:
    if (    pborderinfo->wEdges )
    {
        return (    pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_BOTTOM]
                &&  pborderinfo->aiWidths[SIDE_LEFT] == pborderinfo->aiWidths[SIDE_RIGHT]
                &&  pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_LEFT]
                        ? DISPNODEBORDER_SIMPLE
                        : DISPNODEBORDER_COMPLEX);
    }
    return DISPNODEBORDER_NONE;
}


//+------------------------------------------------------------------------
//
//  Macros:     Some useful macros for accessing table cell neighbors.
//
//  Synopsis:   Retrieve adjacent borders.  These macros are useful
//              because they facilitate keeping the code border-independent,
//              i.e. avoiding the replication of common code four times.
//
//              Used by CTableCell::GetCellBorderInfo() below to resolve
//              collapsed border precendence.
//
//  Description:  Opposite:       Retrieves the border on the other side, e.g. left -> right
//                NextBorder:     Next border in clockwise direction, e.g. top -> right
//                PreviousBorder: Previous, counterclockwise border, e.g.: top -> left
//                TopLeft:        Is border top or left as opposed to bottom or right?
//                TopBottom:      Does border have vertical neighbor?
//                LeftRight:      Does border have horizontal neighbor?
//                TopRight:       Is border top or right?
//                LeftBottom:     Is border left or bottom?
//                RightBottom:    Is border right or bottom?
//                BorderFlag:     Retrieves borderflag corresponding to border.
//
//+------------------------------------------------------------------------

#define Opposite(border) ((border + 2) % 4)
#define NextBorder(border) ((border + 1) % 4)
#define PreviousBorder(border) ((border + 3) % 4)
#define TopLeft(border) (border == SIDE_LEFT || border == SIDE_TOP)
#define TopBottom(border) (border == SIDE_TOP || border == SIDE_BOTTOM)
#define LeftRight(border) (border == SIDE_LEFT || border == SIDE_RIGHT)
#define TopRight(border) (border == SIDE_TOP || border == SIDE_RIGHT)
#define LeftBottom(border) (border == SIDE_LEFT || border == SIDE_BOTTOM)
#define RightBottom(border) (border == SIDE_RIGHT || border == SIDE_BOTTOM)
#define BorderFlag(border) \
   ((border == SIDE_LEFT) ? BF_LEFT : \
   ((border == SIDE_TOP) ? BF_TOP : \
   ((border == SIDE_RIGHT) ? BF_RIGHT : BF_BOTTOM)))


//+------------------------------------------------------------------------
//
//  Member:     CTableCellLayout::GetCellBorderInfo
//
//  Synopsis:   Retrieves a table cell's borderinfo.  For normal (non-collapsed)
//              tables, simply calls GetCellBorderInfoDefault.  For collapsed
//              borders, also calls GetCellBorderInfoDefault on cell neighbors
//              to resolve collapse border precedence.
//
//  Arguments:  pdci [in]         Docinfo
//              pborderinfo [out] Pointer to borderinfo structure to be filled
//              fRender [in]      Is this borderinfo needed for rendering or
//                                layout? (render retrieves more info, e.g. colors)
//              hdc [in]          When rendering, can provide device context for
//                                clipping out spanned neighbors and border corners.
//              pfShrunkDCClipRegion [out] Set if the clipregion of hdc is shrunk.
//
//  Returns:    TRUE if this cell is responsible for at least one border.
//              FALSE otherwise.
//
//  Note:       For normal borders (non-collapsed), this routine simply calls
//              GetCellBorderInfoDefault() and returns.
//
//              Collapsed borders: During layout (fRender==FALSE), we allocate
//              space for half the cell borders, retrieving borderinfos from
//              neighbors and resolving border precedence.  During rendering,
//              we also indicate in the borderinfo which borders this cell
//              is responsible for drawing and clip out cellspan-neighbor borders
//              and border corners where necessary.
//
//-------------------------------------------------------------------------

DWORD
CTableCellLayout::GetCellBorderInfo(
    CDocInfo const *pdci,
    CBorderInfo *   pborderinfo,
    BOOL            fRender,
    BOOL            fAllPhysical,                                    
    XHDC            hdc,
    CTable *        pTable,
    CTableLayout *  pTableLayout,
    BOOL *          pfShrunkDCClipRegion
    FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD           dnbDefault;
    CDocInfo        DI;
    CTableCell    * pCell = NULL;
    CTreeNode     * pNode;
    const CFancyFormat * pFF;

    if (!pTable)       pTable = Table();
    if (!pTableLayout) pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    BOOL               fRTLTable = pTable? pTable->GetFirstBranch()->GetParaFormat(FCPARAM)->HasRTL(TRUE) : FALSE;

    if (!pdci)
    {
        DI.Init(ElementOwner());
        pdci = &DI;
    }

    dnbDefault = GetCellBorderInfoDefault(pdci, pborderinfo, fRender, TRUE, pTable, pTableLayout);

    pCell = TableCell();
    pNode = pCell->GetFirstBranch();
    if (!pNode)
        goto Done;
    
    if (!pTableLayout || !pTableLayout->_fCollapse)
        goto Done;

    pFF = pNode->GetFancyFormat();
    if (   pFF->_bPositionType == stylePositionabsolute
        || pFF->_bPositionType == stylePositionrelative)
        goto Done;

    Assert(IsCaption(Tag()) || !fRender || pfShrunkDCClipRegion);

    // Deal with collapsed borders.
    if (!IsCaption(Tag()))
    {
        CTableRow * pRow = Row();
        CTableRowLayout * pRowLayout = pRow->RowLayoutCache();
        int         colspan=pCell->ColSpan(), rowspan=pCell->RowSpan();
        int         border;
        int         aryCornerBorderWidths[/*8*/] = {0, 0, 0, 0, 0, 0, 0, 0};

        if ( pTableLayout->EnsureTableLayoutCache() )
            return FALSE;

        for (border = SIDE_TOP ; border <= SIDE_LEFT ; border++)
        {
            int     iCol;
            if(!fRTLTable)
                iCol = ColIndex() + ((border == SIDE_RIGHT) ? colspan : ((border == SIDE_LEFT) ? -1 : 0));
            else
                iCol = ColIndex() + ((border == SIDE_LEFT) ? colspan : ((border == SIDE_RIGHT) ? -1 : 0));
            int     iRow = pRow->_iRow;
            BOOL    fOwnBorder = TRUE, fCellAtTableBorder = FALSE, fOwnBorderPartially = FALSE, fFirstSweep = TRUE;
            BOOL    fTopLeft = TopLeft(border);
            BOOL    fTopRight = TopRight(border);
            int     widthMax = pborderinfo->aiWidths[border];
            long    widthMaxMin = MAXLONG, widthSegment;

            // Compute visually next or previous row.
            if (border == SIDE_BOTTOM)
            {
                //do
                {
                    iRow = pTableLayout->GetNextRowSafe(iRow+rowspan-1);
                }
                // Skip over incomplete rows.
                //while (iRow < pTableLayout->GetRows() && !pTableLayout->_aryRows[iRow]->_fCompleted);
            }
            else if (border == SIDE_TOP)
                iRow = pTableLayout->GetPreviousRow(iRow);

            do
            {
                if (iCol < 0 || iCol >= pTableLayout->_cCols || iRow < 0 || iRow >= pTableLayout->GetRows())
                {
                    fCellAtTableBorder = TRUE;
                    break;
                }

                CTableCell       *pNeighborCell   = Cell(pTableLayout->_aryRows[iRow]->RowLayoutCache()->_aryCells[iCol]);
                CTableCellLayout *pNeighborLayout = (pNeighborCell) 
                                                        ? pNeighborCell->Layout(((CDocInfo*)pdci)->GetLayoutContext()) 
                                                        : NULL;
                CBorderInfo biNeighbor(FALSE);  // no init
                BOOL fNeighborHasBorders = pNeighborLayout && pNeighborLayout->GetCellBorderInfoDefault(pdci, &biNeighbor, FALSE, TRUE, pTable, pTableLayout);
                BOOL fNeighborHasOppositeBorder = fNeighborHasBorders && (biNeighbor.aiWidths[Opposite(border)]);

                if (fNeighborHasOppositeBorder)
                {
                    pNode = pNeighborCell->GetFirstBranch();
                    Assert(pNode);
                    pFF = pNode->GetFancyFormat();
                    if (pFF->_bPositionType != stylePositionrelative && pFF->_bPositionType != stylePositionabsolute)
                    {
                        // Make sure that this cell and neighbor each have a border.
                        if (widthMax < biNeighbor.aiWidths[Opposite(border)] + (fOwnBorder && (!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0)))
                        {
                            widthMax = biNeighbor.aiWidths[Opposite(border)];
                            fOwnBorder = FALSE;
                        }
                        else if (pborderinfo->aiWidths[border] >= biNeighbor.aiWidths[Opposite(border)] + (!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0))
                        {
                            fOwnBorderPartially = TRUE;
                        }
                    }
                }

                widthSegment = (!fNeighborHasOppositeBorder || pborderinfo->aiWidths[border] >= biNeighbor.aiWidths[Opposite(border)])
                            ? pborderinfo->aiWidths[border] : biNeighbor.aiWidths[Opposite(border)];

                if (widthSegment < widthMaxMin)
                    widthMaxMin = widthSegment;

                // If rendering, set up cliprect (and information for cliprect).
                if (fRender)
                {
                    if ( fNeighborHasOppositeBorder && (colspan>1 || rowspan>1) && WHEN_DBG( !IsTagEnabled(tagNoExcludeClip) && )
                         (pborderinfo->aiWidths[border] < biNeighbor.aiWidths[Opposite(border)] + (!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0)) )
                    {
                        CRect   rcNeighbor, rcBorder;

                        // Exclude clip rect (ignore if fails).
                        Assert(GetElementDispNode());

                        // Get Rect without subtracting inset.
                        pNeighborLayout->GetRect(&rcNeighbor, fAllPhysical ? COORDSYS_TRANSFORMED : COORDSYS_PARENT);

                        // If we are RTLTable we need to offset for off by one error
                        if(fRTLTable)
                            rcNeighbor.OffsetX(-1);

                        rcBorder.left   = ((biNeighbor.aiWidths[SIDE_LEFT]+1)>>1);
                        rcBorder.top    = ((biNeighbor.aiWidths[SIDE_TOP]+1)>>1);
                        rcBorder.right  = (biNeighbor.aiWidths[SIDE_RIGHT]>>1);
                        rcBorder.bottom = (biNeighbor.aiWidths[SIDE_BOTTOM]>>1);

                        Verify(ExcludeClipRect(hdc,
                                               rcNeighbor.left   - rcBorder.left,
                                               rcNeighbor.top    - rcBorder.top,
                                               rcNeighbor.right  + rcBorder.right,
                                               rcNeighbor.bottom + rcBorder.bottom));


                        Assert(pfShrunkDCClipRegion);
                        *pfShrunkDCClipRegion = TRUE;
                    }

                    if (fFirstSweep || !fRTLTable ? LeftBottom(border) : RightBottom(border))
                        aryCornerBorderWidths[(2*border+7)%8] = biNeighbor.aiWidths[PreviousBorder(border)];
                    if (fFirstSweep || !fRTLTable ? TopRight(border) : TopLeft(border))
                        aryCornerBorderWidths[2*border] = biNeighbor.aiWidths[NextBorder(border)];
                }

                if (TopBottom(border))
                    iCol++;
                else
                    iRow++;

                fFirstSweep = FALSE;
            } while (   (TopBottom(border) 
                     && iCol- ColIndex()<colspan) 
                     || (LeftRight(border) 
                     && iRow-pRowLayout->RowPosition() < rowspan));

            if (fCellAtTableBorder)
            {
                CBorderInfo biTable;

                // If the table has borders, don't reserve any space for collapsed cell borders.
                if (pTableLayout->GetTableBorderInfo((CDocInfo *) pdci, &biTable, FALSE, FALSE)
                    && (biTable.wEdges & BorderFlag(border)))
                {
                    pborderinfo->wEdges &= ~BorderFlag(border);
                    pborderinfo->aiWidths[border] = 0;
                }
                // else change nothing: Cell borders are laid out and rendered in full
                // and uncollapsed.
            }
            else if (fOwnBorder || (fOwnBorderPartially && fRender))
            {
                // This cell is responsible for drawing borders along the entire edge.
                // If we are in the rendering mode (fRender), we return the full
                // width (no change necessary).
                Assert(widthMax == pborderinfo->aiWidths[border] || (fOwnBorderPartially && fRender));

                if (!fRender)
                {
                    // Because neighboring cells each provide half the space for
                    // collapsed borders, we divide the border width by 2 during
                    // layout (!fRender).  We round up for bottom and right borders.
                    pborderinfo->aiWidths[border] = (pborderinfo->aiWidths[border]+(!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0))>>1;
                }
            }
            else
            {
                // One of the neighbors is responsible for drawing borders along at least
                // part of the edge because its border is wider.
                Assert(widthMax + (!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0) > pborderinfo->aiWidths[border]);

                // If we are in render mode, clear the border edge since our neighbor
                // is drawing the edge.  During layout, we budget for half the neighbor's
                // space. We round up for bottom and right borders.
                if (fRender)
                {
                    pborderinfo->wEdges &= ~BorderFlag(border);

                    // Return border width, even though it is not drawn so that caller
                    // can set up cliprects correctly.
                    pborderinfo->aiWidths[border] = widthMaxMin;

                    // If space is needed for neighbor's border, mark wEdges for adjustment.
                    if (pborderinfo->aiWidths[border])
                        pborderinfo->wEdges |= BF_ADJUST;
                }
                else
                {
                    pborderinfo->aiWidths[border] = (widthMaxMin+(!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0))>>1;

                    // During layout, make sure the bit in wEdges is set when we need to make
                    // space for a neighbor's edge.
                    if (pborderinfo->aiWidths[border])
                    {
                        Assert(!fRender && "Only set wEdges for neighbor's borders when we are not rendering");
                        pborderinfo->wEdges |= BorderFlag(border);
                    }
                }
            }

            // Cache maximal bottom and trail width encountered.
            if (border == SIDE_BOTTOM && pRowLayout->_yWidestCollapsedBorder < widthMax)
                pRowLayout->_yWidestCollapsedBorder = widthMax;
            else if (!fRTLTable ? border == SIDE_RIGHT && pTableLayout->_xWidestCollapsedBorder < widthMax
                                : border == SIDE_LEFT && pTableLayout->_xWidestCollapsedBorder < widthMax)
                pTableLayout->_xWidestCollapsedBorder = widthMax;
        }

        // Border corners: If we are in rendering mode, make sure the border corners
        // have no overlap.  For corners we apply the same precedence rules as for edges.
        if (fRender)
        {
            for (border = SIDE_TOP ; border <= SIDE_LEFT ; border++)
            {
                int     iCol;
                if(!fRTLTable)
                    iCol = ColIndex() + ((NextBorder(border) == SIDE_RIGHT) ? colspan : ((NextBorder(border) == SIDE_LEFT) ? -1 : 0))
                                  + ((border == SIDE_RIGHT) ? colspan : ((border == SIDE_LEFT) ? -1 : 0));
                else
                    iCol = ColIndex() + ((NextBorder(border) == SIDE_LEFT) ? colspan : ((NextBorder(border) == SIDE_RIGHT) ? -1 : 0))
                                  + ((border == SIDE_LEFT) ? colspan : ((border == SIDE_RIGHT) ? -1 : 0));

                int     iRow = pRowLayout->RowPosition();

                // If we don't render any edge touching this corner, we don't need to clip.
                if (!(pborderinfo->wEdges & BorderFlag(border)) && !(pborderinfo->wEdges & BorderFlag(NextBorder(border))))
                    continue;

                // Compute visually next or previous row.
                if (border == SIDE_BOTTOM || NextBorder(border) == SIDE_BOTTOM)
                    iRow = pTableLayout->GetNextRowSafe(iRow+rowspan-1);
                else if (border == SIDE_TOP || NextBorder(border) == SIDE_TOP)
                    iRow = pTableLayout->GetPreviousRow(iRow);


                // Cell at table border?
                if (iCol < 0 || iCol >= pTableLayout->_cCols || iRow < 0 || iRow >= pTableLayout->GetRows())
                    continue;

                CTableCell *pNeighborCell = pTableLayout->_aryRows[iRow]->RowLayoutCache()->_aryCells[iCol];
                BOOL fReject = !IsReal(pNeighborCell);
                pNeighborCell = Cell(pNeighborCell);

                if (!pNeighborCell)
                    continue;

                CTableCellLayout * pNeighborLayout = pNeighborCell->Layout(((CDocInfo*)pdci)->GetLayoutContext());
                int colspanN = pNeighborCell->ColSpan(),
                    rowspanN = pNeighborCell->RowSpan();


                int borderRTLSensitive = !fRTLTable ? border : (3 - border);

                // Reject certain col/rowspans.
                switch(borderRTLSensitive)
                {
                case SIDE_TOP:
                    // Reject rowspans in top-right corner because there is no corner problem.
                    if (!fReject && rowspanN > 1)
                    {
                        fReject = TRUE;
                        break;
                    }

                    // Reject only if not last cell of rowspan (using assumption
                    // that rowspans don't cross sections).
                    if (fReject && colspanN == 1)
                        fReject = (iRow - pNeighborCell->Row()->_iRow + 1 != rowspanN);
                    break;
                case SIDE_RIGHT:
                    // In bottom-right corner, no colspans or rowspans cause a corner problem.
                    Assert(!fReject || colspanN>1 || rowspanN>1);
                    break;
                case SIDE_BOTTOM:
                    // Reject colspans in bottom-left corner because there is no corner problem.
                    if (!fReject && colspanN > 1)
                    {
                        fReject = TRUE;
                        break;
                    }

                    // Reject only if not last cell of colspan.
                    if (fReject && rowspanN == 1)
                        fReject = (iCol - pNeighborLayout->ColIndex() + 1 != colspanN);
                    break;
                case SIDE_LEFT:
                    // In top-left corner, no colspans or rowspans cause a corner problem.
                    if (!fReject && (colspanN > 1 || rowspanN > 1))
                    {
                        fReject = TRUE;
                        break;
                    }

                    // Reject only if not last cell of rowspan (using assumption
                    // that rowspans don't cross sections).
                    if (fReject)
                        fReject = (iRow - pNeighborCell->Row()->_iRow + 1 != rowspanN)
                               || (iCol - pNeighborLayout->ColIndex() + 1 != colspanN);
                    break;
                }

                if (fReject)
                    continue;

                Assert(pNeighborCell);

                CBorderInfo biNeighbor(FALSE); // No init
                pNeighborLayout->GetCellBorderInfoDefault(pdci, &biNeighbor, FALSE, TRUE, pTable, pTableLayout);

                // 1. Find the competing opposite candidate width.
                int widthWinnerX = 0,
                    widthWinnerY = 0;
                CRect rcNeighbor;

                // When table have fixed layout, some cells might not be calc'ed yet, and thus might
                // not have a display node yet.  In that case, don't address corner rendering problem.
                // This is also possible when tables are page-broken (printing).
                if (!pNeighborLayout->_pDispNode)
                {
                    Assert(  ( pNeighborLayout->IsSizeThis() && pTableLayout->IsFixedBehaviour() )
                           || ((CDocInfo*)pdci)->GetLayoutContext() );
                    continue;
                }

                pNeighborLayout->GetRect(&rcNeighbor, fAllPhysical ? COORDSYS_TRANSFORMED : COORDSYS_PARENT);

                // If we are RTLTable we need to offset for off by one error
                if(fRTLTable)
                    rcNeighbor.OffsetX(-1);

                WHEN_DBG( if (!IsTagEnabled(tagDontComeOnIn)) )
                {
                    int xOppositeWidth = aryCornerBorderWidths[2*border];
                    int yOppositeWidth = aryCornerBorderWidths[2*border+1];
                    BOOL fWinnerX, fWinnerY;
                    BOOL fTopLeft = TopLeft(border), fTopLeftNext = TopLeft(NextBorder(border));
                    BOOL fTopRight = TopRight(border), fTopRightNext = TopRight(NextBorder(border));

                    // Round 1: Have the two borders of the corner neighbor compete against the
                    // borders of the two direct neighbors.
                    if (xOppositeWidth < biNeighbor.aiWidths[Opposite(NextBorder(border))])
                        xOppositeWidth = biNeighbor.aiWidths[Opposite(NextBorder(border))];
                    if (yOppositeWidth < biNeighbor.aiWidths[Opposite(border)])
                        yOppositeWidth = biNeighbor.aiWidths[Opposite(border)];

                    // Round 2: Have the borders of this cell compete against the winner of
                    // round 1.
                    fWinnerX = pborderinfo->aiWidths[NextBorder(border)] >= xOppositeWidth;
                    fWinnerY = pborderinfo->aiWidths[border] >= yOppositeWidth;

                    // Set the width to the winners of round 2.
                    widthWinnerX = fWinnerX ? (-((pborderinfo->aiWidths[NextBorder(border)]+(!fRTLTable ? (fTopLeftNext?0:1) : (fTopRightNext?0:1)))>>1))
                                            : ((xOppositeWidth+(!fRTLTable ? (fTopLeftNext?0:1) : (fTopRightNext?0:1)))>>1);
                    widthWinnerY = fWinnerY ? (-((pborderinfo->aiWidths[border]+(!fRTLTable ? (fTopLeft?0:1) : (fTopRight?0:1)))>>1))
                                            : ((yOppositeWidth+(!fRTLTable ? (fTopLeft?0:1) : (fTopRight?0:1)))>>1);

                    if (fWinnerX || fWinnerY)
                    {
#if DBG == 1
                    // If both edges are winning, avoid the inset rect.
                    // Note: This condition assumes that wider borders win.  This will no longer be the case
                    // when we implement borders on other table elements such as rows which always win over
                    // table cell border in IE5, BETA2.  Then two winners doesn't necessarily mean we are
                    // cutting into our neighbor's inset rect.
                        if (IsTagEnabled(tagClipInsetRect) && fWinnerX && fWinnerY)
                        {
                            widthWinnerX = -((xOppositeWidth+(!fRTLTable ? (fTopLeftNext?0:1) : (fTopRightNext?0:1)))>>1);
                            widthWinnerY = -((yOppositeWidth+(!fRTLTable ? (fTopLeft?0:1) : (fTopRight?0:1)))>>1);
                        }
                        else
#endif // DBG==1
                            continue;
                    }
                }

                // 2. Make room for winning edge or inset.

                switch (border)
                {
                case SIDE_TOP:
                    rcNeighbor.left   -= widthWinnerX;
                    rcNeighbor.bottom += widthWinnerY;
                    break;
                case SIDE_RIGHT:
                    rcNeighbor.top    -= widthWinnerX;
                    rcNeighbor.left   -= widthWinnerY;
                    break;
                case SIDE_BOTTOM:
                    rcNeighbor.right  += widthWinnerX;
                    rcNeighbor.top    -= widthWinnerY;
                    break;
                case SIDE_LEFT:
                    rcNeighbor.bottom += widthWinnerX;
                    rcNeighbor.right  += widthWinnerY;
                    break;
                }

                // Actually exclude winning or inset rect of neighbor.
                if ( WHEN_DBG(!IsTagEnabled(tagNoExcludeClipCorners) &&) !IsRectEmpty(&rcNeighbor))
                {
                    // Exclude clip rect (ignore if fails).
                    Verify(ExcludeClipRect(hdc, rcNeighbor.left, rcNeighbor.top, rcNeighbor.right, rcNeighbor.bottom));
                    Assert(pfShrunkDCClipRegion);
                    *pfShrunkDCClipRegion = TRUE;
                }

            }
        }
    }
    else if (dnbDefault != DISPNODEBORDER_NONE)
    {
        // Collapse caption.
        Assert(IsCaption(Tag()));
        CBorderInfo biTable;

        // If the table has borders, we need to zero out the touching caption border.
        if (pTableLayout->GetTableBorderInfo((CDocInfo *) pdci, &biTable, FALSE, FALSE))
        {
            int border = (DYNCAST(CTableCaption, pCell)->IsCaptionOnBottom()) ? SIDE_TOP : SIDE_BOTTOM;

            // If the table has a border on the corresponding side, zero out caption border.
            if (biTable.wEdges & BorderFlag(Opposite(border)))
            {
                pborderinfo->wEdges &= ~BorderFlag(border);
                pborderinfo->aiWidths[border] = 0;
            }
        }

    }

    // We should only finish this way, if we had to collapse borders.
    Assert(pTableLayout->_fCollapse);

Done:

    // If we are asked to compute logical borderinfo, then we will still compute the
    // physical borderinfo in the code above and then switch it here. This way we
    // do not have to redo the code above for logical props (whew!)
    if (   !fAllPhysical
        && pCell
        && pCell->HasVerticalLayoutFlow()
       )
    {
        pborderinfo->FlipBorderInfo();
    }
    
    if ( pborderinfo->wEdges )
    {
        return (    pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_BOTTOM]
                &&  pborderinfo->aiWidths[SIDE_LEFT] == pborderinfo->aiWidths[SIDE_RIGHT]
                &&  pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_LEFT]
                        ? DISPNODEBORDER_SIMPLE
                        : DISPNODEBORDER_COMPLEX);
    }
    return DISPNODEBORDER_NONE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::GetTableBorderInfo
//
//  Synopsis:   fill out border information
//
//----------------------------------------------------------------------------

DWORD
CTableLayout::GetTableBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fRender, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    htmlFrame   hf = Table()->GetAAframe();
    WORD        wEdges;
    DWORD       wRet;
    
    if ( _xBorder || _yBorder )
    {
        Assert(htmlFrameNotSet == 0);
        Assert(hf < ARRAY_SIZE(s_awEdgesFromTableFrame));
        wEdges = s_awEdgesFromTableFrame[hf];

        if (wEdges & BF_TOP)
        {
            pborderinfo->aiWidths[SIDE_TOP]    = _yBorder;
            pborderinfo->abStyles[SIDE_TOP]    = fmBorderStyleRaisedMono;
        }

        if (wEdges & BF_BOTTOM)
        {
            pborderinfo->aiWidths[SIDE_BOTTOM] = _yBorder;
            pborderinfo->abStyles[SIDE_BOTTOM] = fmBorderStyleRaisedMono;
        }

        if (wEdges & BF_LEFT)
        {
            pborderinfo->aiWidths[SIDE_LEFT]   = _xBorder;
            pborderinfo->abStyles[SIDE_LEFT]   = fmBorderStyleRaisedMono;
        }

        if (wEdges & BF_RIGHT)
        {
            pborderinfo->aiWidths[SIDE_RIGHT]  = _xBorder;
            pborderinfo->abStyles[SIDE_RIGHT]  = fmBorderStyleRaisedMono;
        }
    }

    wRet = Table()->CElement::GetBorderInfo( pdci, pborderinfo, fRender, fAllPhysical FCCOMMA FCPARAM);

    return  (   hf != htmlFrameNotSet
            &&  wRet == DISPNODEBORDER_NONE)
        ?   DISPNODEBORDER_COMPLEX
        :   wRet;
}


//+-------------------------------------------------------------------------
//
//  Method:     CalculateBorderAndSpacing
//
//  Synopsis:   Calculate and cache border, cellspacing, cellpadding
//
//--------------------------------------------------------------------------

void
CTableLayout::CalculateBorderAndSpacing(CDocInfo * pdci)
{
    CTable    * pTable = Table();
    CUnitValue  cuv;
    CUnitValue  uvDefaultborder;
    CBorderInfo borderinfo;
    CTreeNode * pNodeSelf = GetFirstBranch();
    htmlRules   trRules = pTable->GetAArules();
    htmlFrame   hf  = pTable->GetAAframe();

    // TODO (112612, olego):  we should have gereric mechanism to provide min/max limitation for 
    // different resolutions !!!

    // max allowed border space
    long xMaxBorderSpaceInScreenPixels = MAX_BORDER_SPACE;
    long yMaxBorderSpaceInScreenPixels = MAX_BORDER_SPACE;
    // max allowed cell spacing
    long xMaxCellSpacingInScreenPixels = MAX_CELL_SPACING;
    long yMaxCellSpacingInScreenPixels = MAX_CELL_SPACING;
    CLayoutContext *pLayoutContext = pdci->GetLayoutContext();

    _fRuleOrFrameAffectBorders =
        (trRules != htmlRulesNotSet && trRules != htmlRulesall) ||  // only when there are no groups/rows/cols rules
        (hf != htmlFrameNotSet);                                    // only when FRAME attribute is not set on table

    cuv = pTable->GetAAborder();

    if (cuv.IsNull())
    {
        _xBorder = 0;
        _yBorder = 0;

        Assert(hf < ARRAY_SIZE(s_awEdgesFromTableFrame));
        WORD wFrameEdges = s_awEdgesFromTableFrame[hf];

        if (trRules != htmlRulesNotSet || hf != htmlFrameNotSet)
        {
            uvDefaultborder.SetValue(1, CUnitValue::UNIT_PIXELS);
            switch(trRules)
            {
                case htmlRulesrows:
                    _yBorder = 1;
                    break;

                case htmlRulesgroups:
                case htmlRulesall:
                    _yBorder = 1;
                    // fall through
                case htmlRulescols:
                    _xBorder = 1;
                    break;
            }

            if ( _xBorder == 0 && ((wFrameEdges & BF_LEFT) || (wFrameEdges & BF_RIGHT)) )
                _xBorder = 1;

            if ( _yBorder == 0 && ((wFrameEdges & BF_TOP) || (wFrameEdges & BF_BOTTOM)) )
                _yBorder = 1;
        }
    }
    else
    {
        // get border space
        long lFontHeight = pNodeSelf->GetFontHeightInTwips(&cuv);

        _xBorder = cuv.XGetPixelValue(NULL, 0, lFontHeight);    //  NULL to prevent transformation to device.
        _yBorder = cuv.YGetPixelValue(NULL, 0, lFontHeight);

        // use 1 if negative and restrict it .. use TagNotAssignedDefault for 1
        if (_xBorder < 0)
        {
            uvDefaultborder.SetValue ( 1,CUnitValue::UNIT_PIXELS );

            _xBorder = 1;
            _yBorder = 1;
        }

        if (pLayoutContext && pLayoutContext->GetMedia() != mediaTypeNotSet)
        {
            //  Since introduction of hi-res mode checks for min/max became less trivial...
            xMaxBorderSpaceInScreenPixels = pdci->DeviceFromDocPixelsX(MAX_BORDER_SPACE);
            yMaxBorderSpaceInScreenPixels = pdci->DeviceFromDocPixelsY(MAX_BORDER_SPACE);
        }

        if (_xBorder > xMaxBorderSpaceInScreenPixels)
        {
            _xBorder = xMaxBorderSpaceInScreenPixels;
        }
        if (_yBorder > yMaxBorderSpaceInScreenPixels)
        {
            _yBorder = yMaxBorderSpaceInScreenPixels;
        }
    }


    _fBorder = ( _yBorder != 0 ) || ( _xBorder != 0 );


    GetTableBorderInfo(pdci, &borderinfo, FALSE, FALSE);
    memcpy(_aiBorderWidths, borderinfo.aiWidths, 4*sizeof(int));

    cuv = pTable->GetAAcellSpacing();

    if (cuv.IsNull())
    {
        CUnitValue uvDefaultCellSpacing;
        uvDefaultCellSpacing.SetValue (_fCollapse?0:2, CUnitValue::UNIT_PIXELS);
        _xCellSpacing = uvDefaultCellSpacing.XGetPixelValue(pdci, 0, 1);
        _yCellSpacing = uvDefaultCellSpacing.YGetPixelValue(pdci, 0, 1);
    }
    else
    {
        long SpaceFontHeight = pNodeSelf->GetFontHeightInTwips(&cuv);

        _xCellSpacing = max(0L,cuv.XGetPixelValue(pdci, 0, SpaceFontHeight));
        _yCellSpacing = max(0L,cuv.YGetPixelValue(pdci, 0, SpaceFontHeight));

        if (pLayoutContext && pLayoutContext->GetMedia() != mediaTypeNotSet)
        {
            //  Since introduction of hi-res mode checks for min/max became less trivial...
            xMaxCellSpacingInScreenPixels = pdci->DeviceFromDocPixelsX(MAX_CELL_SPACING);
            yMaxCellSpacingInScreenPixels = pdci->DeviceFromDocPixelsY(MAX_CELL_SPACING);
        }

        if (_xCellSpacing > xMaxCellSpacingInScreenPixels)
        {
            _xCellSpacing = xMaxCellSpacingInScreenPixels;
        }
        if (_yCellSpacing > yMaxCellSpacingInScreenPixels)
        {
            _yCellSpacing = yMaxCellSpacingInScreenPixels;
        }
    }

    _xCellPadding =
    _yCellPadding = 0;
}


//+------------------------------------------------------------------------
//
//  Member:     GetFirstLayout
//
//  Synopsis:   Enumeration method to loop thru children (start)
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    pSite (if found), NULL otherwise
//
//  NOTE:       This routine and GetNextLayout walk through the captions
//              and rows on the table. Negative cookies represent
//              CAPTIONs rendered at the top. Cookies in the range 0 to
//              one less than the number of rows represent rows. Positive
//              cookies greater than or equal to the number of rows
//              represent CAPTIONs rendered at the bottom. Since all the
//              CAPTIONs are kept in a single array, regardless where they
//              are rendered, the cookie may skip by more then one when
//              walking through the CAPTIONs. The cookie end-points are:
//
//                  Top-most CAPTION    - (-1 - _aryCaptions.Size())
//                  Top-most ROW        - (-1)
//                  Bottom-most ROW     - (GetRows())
//                  Bottom-most CAPTION - (GetRows() + _aryCaptions.Size())
//
//              If you change the way the cookie is implemented, then
//              please also change the GetCookieForSite funciton.
//
//-------------------------------------------------------------------------

CLayout *
CTableLayout::GetFirstLayout ( DWORD_PTR * pdw, BOOL fBack, BOOL fRaw )
{
    // NOTE: This routine always walks the actual array (after ensuring
    //       it is in-sync with the current state of the tree)

    Assert(!fRaw);

    {
        if ( EnsureTableLayoutCache() )
            return NULL;
    }

    *pdw = fBack
            ? DWORD( GetRows() ) + DWORD( _aryCaptions.Size() )
            : DWORD( -1 ) - DWORD( _aryCaptions.Size() );

    return CTableLayout::GetNextLayout( pdw, fBack, fRaw );
}


//+------------------------------------------------------------------------
//
//  Member:     GetNextLayout
//
//  Synopsis:   Enumeration method to loop thru children
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    site
//
//  Note:       See comment on GetFirstLayout
//
//-------------------------------------------------------------------------

CLayout *
CTableLayout::GetNextLayout ( DWORD_PTR * pdw, BOOL fBack, BOOL fRaw )
{
    int i, cRows, cCaptions;

    // NOTE: This routine always walks the actual array (after ensuring
    //       it is in-sync with the current state of the tree)

    Assert(!fRaw);

    {
        if ( EnsureTableLayoutCache() )
            return NULL;
    }

    i         = *pdw;
    cRows     = GetRows();
    cCaptions = _aryCaptions.Size();

    Assert(i >= (-1 - _aryCaptions.Size()));
    Assert(i <= (GetRows() + _aryCaptions.Size()));

    if (fBack)
    {
        i--;

        // While the cookie is past the end of the row array,
        // look for a caption which renders at the bottom
        for ( ; i >= cRows; i--)
        {
            if (_aryCaptions[i-cRows]->_uLocation == CTableCaption::CAPTION_BOTTOM)
            {
                *pdw = (DWORD)i;
                return _aryCaptions[i-cRows]->GetUpdatedLayout(LayoutContext());
            }
        }

        // While the cookie is before the rows,
        // look for a caption which renders at the top
        if (i < 0)
        {
            for ( ; (cCaptions+i) >= 0; i--)
            {
                if (_aryCaptions[cCaptions+i]->_uLocation == CTableCaption::CAPTION_TOP)
                {
                    *pdw = (DWORD)i;
                    return _aryCaptions[cCaptions+i]->GetUpdatedLayout(LayoutContext());
                }
            }

            return NULL;
        }

        // Otherwise, fall through and return the row
    }

    else
    {
        i++;

        // While the cookie is before the rows,
        // look for a caption which renders at the top
        for ( ; i < 0; i++)
        {
            if (_aryCaptions[cCaptions+i]->_uLocation == CTableCaption::CAPTION_TOP)
            {
                *pdw = (DWORD)i;
                return _aryCaptions[cCaptions+i]->GetUpdatedLayout(LayoutContext());
            }
        }

        // While the cookie is past the end of the row array,
        // look for a caption which renders at the bottom
        if (i >= cRows)
        {
            for ( ; i < (cRows+cCaptions); i++)
            {
                if (_aryCaptions[i-cRows]->_uLocation == CTableCaption::CAPTION_BOTTOM)
                {
                    *pdw = (DWORD)i;
                    return _aryCaptions[i-cRows]->GetUpdatedLayout(LayoutContext());
                }
            }

            return NULL;
        }

        // Otherwise, fall through and return the row
    }

    Assert( i >= 0 && i < GetRows());
    *pdw = (DWORD)i;
    return _aryRows[i]->GetUpdatedLayout(LayoutContext());
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::Draw
//
//  Synopsis:   Paint the table
//
//----------------------------------------------------------------------------

void
CTableLayout::Draw(CFormDrawInfo *pDI, CDispNode * pDispNode)
{
    if ( EnsureTableLayoutCache() )
        return;

#if DBG == 1
    if (!IsTagEnabled(tagTableRecalc))
#endif
    if (!IsCalced())    // return if table is not calculated
        return;

    super::Draw(pDI, pDispNode);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableBorderRenderer::QueryInterface, IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CTableBorderRenderer::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if(riid == IID_IUnknown)
    {
        *ppv = this;
    }

    if(*ppv == NULL)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        ((LPUNKNOWN)* ppv)->AddRef();
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableBorderRenderer::DrawClient
//
//  Synopsis:   Draws collapsed, ruled, or framed table cell borders
//
//  Arguments:  prcBounds       bounding rect of display leaf node
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CTableBorderRenderer::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;

    Assert(pDI);
    Assert(pDispNode->IsFlowNode());
    Assert(_pTableLayoutBlock);

    AssertSz(!pDI->GetLayoutContext(), "Currently we shouldn't be getting a context passed in this way" );

    // DrawCellBorders needs to know what context it's drawing in,
    // so it can draw the right subset of rows/cells.
    pDI->SetLayoutContext( _pTableLayoutBlock->LayoutContext() );

    TableLayoutCache()->DrawCellBorders(
        pDI,
        prcBounds,
        prcRedraw,
        pDispSurface,
        pDispNode,
        cookie,
        pClientData,
        dwFlags);

    pDI->SetLayoutContext( NULL );
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CTableBorderRenderer::DumpDebugInfo
//
//  Synopsis:   Dump display tree debug information
//
//----------------------------------------------------------------------------

void
CTableBorderRenderer::DumpDebugInfo(
    HANDLE           hFile,
    long             level,
    long             childNumber,
    CDispNode const* pDispNode,
    void *           cookie)
{
    WriteString(hFile, _T("<tag>Table Border Renderer</tag>\r\n"));
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::DrawCellBorders
//
//  Synopsis:   Draws collapsed, ruled, or framed table cell borders
//
//  Arguments:  pTLB            CTableLayoutBlock for which we're drawing borders.
//                               pTLB == this for cases w/o context (non-print).
//              prcBounds       bounding rect of display leaf node
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
// NOTE (paulnel) - 'lead' refers to left in left to right (LTR) and right in 
//                         right to left (RTL)
//                  'trail' refers to right in LTR and left in RTL
//----------------------------------------------------------------------------

WHEN_DBG(COLORREF g_crRotate = 255;)

void
CTableLayout::DrawCellBorders(
    CFormDrawInfo * pDI,
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
    XHDC            hdc = pDI->GetDC(TRUE);
    CTableRowLayout * pRowLayout;
    int iRow, iRowTop, iRowBottom, iRowPrevious, iRowNext;
    int iCol, iColLead, iColTrail;
    int yRowTop, yRowBottom, xColLead, xColTrail;

    // TODO RTL 112514 PERF: this version of IsRightToLeft is expensive - it goes to the element;
    //                       there is no such flag on table layout. Need to look at profile to see
    //                       if it should be cached on CTableLayout.
    BOOL fRightToLeft = IsRightToLeft();
    Assert(!fRightToLeft || !IsTagEnabled(tagDebugRTL)); 
    
    CRect rcDraw((CRect)*prcRedraw);

    HRGN hrgnClipOriginal;

    CLayoutContext *pLayoutContext = pDI->GetLayoutContext();

    if (!IsTableLayoutCacheCurrent())
        return;

    // If the table has no rows, we are done.
    if (!GetRows())
        return;

    // if there is no calculated columns. (the right fix would be to remove all the display nodes from the tree on FlushGrid, bug #64931)
    if (!_aryColCalcs.Size())
        return;

    // Remember the original clip rect
    hrgnClipOriginal = CreateRectRgn(0,0,1,1);
    // NOTE (greglett) GetHackDC is what it sounds like - a hack.  See definition for more info.
    if (hrgnClipOriginal)
        GetClipRgn(hdc.GetHackDC(), hrgnClipOriginal);

#if DBG==1
    COLORREF crOld = 0x0;

    if (IsTagEnabled(tagNoCollapsedBorders))
        return;

    if (_pBorderInfoCellDefault && IsTagEnabled(tagRedCollapsedBorders))
    {
        crOld = _pBorderInfoCellDefault->acrColors[0][0];

        _pBorderInfoCellDefault->acrColors[0][0] = _pBorderInfoCellDefault->acrColors[0][1] = _pBorderInfoCellDefault->acrColors[0][2] =
        _pBorderInfoCellDefault->acrColors[1][0] = _pBorderInfoCellDefault->acrColors[1][1] = _pBorderInfoCellDefault->acrColors[1][2] =
        _pBorderInfoCellDefault->acrColors[2][0] = _pBorderInfoCellDefault->acrColors[2][1] = _pBorderInfoCellDefault->acrColors[2][2] =
        _pBorderInfoCellDefault->acrColors[3][0] = _pBorderInfoCellDefault->acrColors[3][1] = _pBorderInfoCellDefault->acrColors[3][2] = g_crRotate;

        g_crRotate = (g_crRotate << 8);
        if (!g_crRotate)
            g_crRotate = 255;
    }
#endif // DBG==1

    //
    // Obtain subgrid of table borders to be rendered.
    // (If we are collapsing borders, make sure the invalid rect is
    // large enough to include neighboring borders so that collapsed
    // neighbors get a chance to draw their borders.)
    //

    //
    // iRowTop.
    //

    yRowTop    =
    yRowBottom = 0;
    pRowLayout = GetRowLayoutFromPos(rcDraw.top, &yRowTop, &yRowBottom, NULL, pLayoutContext);
    iRowTop = pRowLayout ? pRowLayout->RowPosition() : GetFirstRow();
    if (iRowTop != GetFirstRow())
    {
        iRowPrevious = GetPreviousRowSafe(iRowTop);
        Assert(iRowPrevious >= 0);

        // Only expand when redraw rect infringes on maximum border area.
        if (_fCollapse && rcDraw.top < yRowTop + ((_aryRows[iRowPrevious]->RowLayoutCache()->_yWidestCollapsedBorder+1)>>1)
            WHEN_DBG( && !IsTagEnabled(tagNoInflateRect) ) )
        {
            iRowTop = iRowPrevious;
        }
    }

    //
    // iRowBottom.
    //

    // Note that the bottom, right coordinates are outside the clip-rect (subtract 1).
    yRowTop    =
    yRowBottom = 0;
    pRowLayout = GetRowLayoutFromPos(rcDraw.bottom-1, &yRowTop, &yRowBottom, NULL, pLayoutContext);
    iRowBottom = pRowLayout ? pRowLayout->RowPosition() : GetLastRow();
    if (iRowBottom != GetLastRow())
    {
        iRowNext = GetNextRowSafe(iRowBottom);
        Assert(iRowNext < GetRows());

        // Only expand when cliprect infringes on maximum border area.
        if (_fCollapse && rcDraw.bottom >= yRowBottom - ((pRowLayout->_yWidestCollapsedBorder)>>1)
            WHEN_DBG( && !IsTagEnabled(tagNoInflateRect) ) )
        {
            iRowBottom = iRowNext;
        }
    }

    //
    // iColLead.
    //

    iColLead = GetColExtentFromPos(!fRightToLeft ? rcDraw.left: rcDraw.right, &xColLead, &xColTrail, fRightToLeft);
    if (iColLead == -1)
        iColLead = 0;

    // Only expand when cliprect infringes on maximum border area.
    if (   _fCollapse
        && iColLead > 0
        && (!fRightToLeft 
            ? rcDraw.left < xColLead + ((_xWidestCollapsedBorder+1)>>1)
            : rcDraw.right > xColLead - (_xWidestCollapsedBorder>>1))
        WHEN_DBG( && !IsTagEnabled(tagNoInflateRect) ) )
    {
        iColLead--;
    }

    //
    // iColTrail.
    //

    // Note that the bottom, right coordinates are outside the clip-rect (subtract 1).
    iColTrail = GetColExtentFromPos(!fRightToLeft ? rcDraw.right-1 : rcDraw.left+1, &xColLead, &xColTrail, fRightToLeft);
    if (iColTrail == -1)
        iColTrail = GetCols()-1;

    // Only expand when cliprect infringes on maximum border area.
    if (   _fCollapse
        && iColTrail < GetCols()-1
        && (!fRightToLeft
            ? rcDraw.right >= xColTrail - (_xWidestCollapsedBorder>>1)
            : rcDraw.left <= xColTrail + ((_xWidestCollapsedBorder+1)>>1))
        WHEN_DBG( && !IsTagEnabled(tagNoInflateRect) ) )
    {
        iColTrail++;
    }

    TraceTag((tagTableBorder, "rcDraw: (%ld,%ld, %ld,%ld)  rcCells: (%d,%d, %d,%d), cells: (%d,%d, %d,%d)",
                rcDraw.top, rcDraw.bottom,  rcDraw.left, rcDraw.right,
                yRowTop, yRowBottom,  xColLead, xColTrail,
                iRowTop, iRowBottom,  iColLead, iColTrail));

    Assert(iRowTop    >= 0 && iRowTop    < GetRows());
    Assert(iRowBottom >= 0 && iRowBottom < GetRows());
    Assert(iColLead   >= 0 && iColLead   < GetCols());
    Assert(iColTrail  >= 0 && iColTrail  < GetCols());

    for ( iRow = iRowTop ; ; iRow = GetNextRowSafe(iRow) )
    {
        CTableRow *pTRow = GetRow(iRow);
        if(!pTRow)
            continue;
        CTableRowLayout * pRowLayout = pTRow->RowLayoutCache();
        int iColSpan;
        Assert(pRowLayout);

        for ( iCol = iColLead ; iCol <= iColTrail ; iCol += iColSpan )
        {
            CTableCell * pCell = Cell(pRowLayout->_aryCells[iCol]);
            if (pCell)
            {
                AssertSz( pRowLayout->LayoutContext() == NULL, "Since pRowLayout is the row cache, it shouldn't have context" );
                if ( pLayoutContext && !pCell->CurrentlyHasLayoutInContext( pLayoutContext ) )
                {
                    iColSpan = 1;
                    continue;
                }

                CTableCellLayout * pCellLayout = pCell->Layout(pLayoutContext);
                const CFancyFormat * pFF = pCell->GetFirstBranch()->GetFancyFormat();
                if (!pFF->_fPositioned)
                {
                    BOOL fShrunkDCClipRegion = FALSE;

                    pCellLayout->DrawBorderHelper(pDI, &fShrunkDCClipRegion);
                
                    // If the clip region was modified, restore the original one.
                    // NOTE (greglett) GetHackDC is what it sounds like - a hack.  See definition for more info.
                    if (fShrunkDCClipRegion)
                        SelectClipRgn(hdc.GetHackDC(), hrgnClipOriginal);

                }
                iColSpan = pCell->ColSpan() - ( iCol - pCellLayout->ColIndex() );
            }
            else
            {
                iColSpan = 1;
            }
        }

        // Finished last row?
        if (iRow == iRowBottom)
            break;
    }

#if DBG==1
    if (_pBorderInfoCellDefault && IsTagEnabled(tagRedCollapsedBorders) )
    {
        _pBorderInfoCellDefault->acrColors[0][0] =
        _pBorderInfoCellDefault->acrColors[0][1] =
        _pBorderInfoCellDefault->acrColors[0][2] =
        _pBorderInfoCellDefault->acrColors[1][0] =
        _pBorderInfoCellDefault->acrColors[1][1] =
        _pBorderInfoCellDefault->acrColors[1][2] =
        _pBorderInfoCellDefault->acrColors[2][0] =
        _pBorderInfoCellDefault->acrColors[2][1] =
        _pBorderInfoCellDefault->acrColors[2][2] =
        _pBorderInfoCellDefault->acrColors[3][0] =
        _pBorderInfoCellDefault->acrColors[3][1] =
        _pBorderInfoCellDefault->acrColors[3][2] = crOld;
    }
#endif // DBG==1

    // Cleanup:
    if (hrgnClipOriginal)
        DeleteObject(hrgnClipOriginal);
}

//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetClientPainterInfo
//
//-----------------------------------------------------------------------------

DWORD
CTableLayout::GetClientPainterInfo(
                                CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
{
    if (GetElementDispNode() != pDispNodeFor)       // if draw request is for dispNode other then primary
        return 0;                                   // then no drawing at all the dispNode

    return GetPeerPainterInfo(pAryClientInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\caret.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       caret.cpp
//
//  Contents:   Implementation of the caret manipulation for the
//              CTextSelectionRecord class.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CARET_HXX_
#define X_CARET_HXX_
#include "caret.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X__IME_H_
#define X__IME_H_
#include "_ime.h"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_DISPSERV_HXX_
#define X_DISPSERV_HXX_
#include "dispserv.hxx"
#endif

MtDefine(CCaret, Edit, "CCaret");
MtDefine(CCaretUpdateScreenCaret_aryCaretBitMap_pv, Locals, "CCaret::UpdateScreenCaret aryCaretBitMap::_pv")
MtDefine(CCaretCreateCSCaret_aryCaretBitMap_pv, Locals, "CCaret::CreateCSCaret aryCaretBitMap::_pv")
MtDefine(CCaretCreateCSCaret_aryCaretVertBitMap_pv, Locals, "CCaret::CreateCSCaret::aryCaretVertBitMap::_pv")

const LONG CCaret::_xInvisiblePos = -32000;
const LONG CCaret::_yInvisiblePos = -32000;
const UINT CCaret::_HeightInvisible = 1;
const UINT CCaret::_xCSCaretShift = 2; // COMPLEXSCRIPT Number of pixels to shift bitmap caret to properly align

#if DBG ==1
static const LPCTSTR strCaretName = _T(" Physical Caret");
#endif

// Begin a-thkesa


#ifndef SPI_GETCARETWIDTH
#define SPI_GETCARETWIDTH                   0x2006
#endif

//End



//////////////////////////////////////////////////////////////////////////
//
//  CCaret's Constructor, Destructor
//
//////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------
//    Method:       CCaret::CCaret
//
//    Parameters:   CDoc*           pDoc        Document that owns caret
//
//    Synopsis:     Constructs the CCaret object, sets the caret's associated
//                  document.
//+-----------------------------------------------------------------------

CCaret::CCaret( CDoc * pDoc )
    : _pDoc( pDoc )
{
    _cRef = 0;
    _fVisible = FALSE;
    _fMoveForward = TRUE;
    _fPainting = 0;
    _Location.x = 0;
    _Location.y = 0;
	
	   // Before doing anything .. first make sure we have
    // correct width.. by doing the following.
    // Begin a-thkesa
    // Get the current system setting for cursor.
    // See windows Bug:491261
    DWORD dwWidth = 1 ;
    BOOL bRet = ::SystemParametersInfo(
                  SPI_GETCARETWIDTH,// system parameter to retrieve or set
                  0,                // depends on action to be taken
                  &dwWidth,         // depends on action to be taken
                  0                 // user profile update option
                  );

    if( bRet && dwWidth>0 )
    {
      _width = dwWidth; 
    }
    else
    {
     _width = 1 ;
    }
    //End.
				_height = 0;
    _dx = 0;
    _dy = 0;
    _dh = 0;
    _fCanPostDeferred = TRUE;
}


//+-----------------------------------------------------------------------
//    Method:        CCaret::~CCaret
//
//    Parameters:    None
//
//    Synopsis:     Destroys the CCaret object, sets the caret's associated
//                  document to null, releases the markup pointer.
//+-----------------------------------------------------------------------

CCaret::~CCaret()
{
    //
    // Remove any pending updates
    //
    _fCanPostDeferred = FALSE; // I'm dying here...
    GWKillMethodCall( this, ONCALL_METHOD( CCaret, DeferredUpdateCaret, deferredupdatecaret ), 0 );
    GWKillMethodCall( this, ONCALL_METHOD( CCaret, DeferredUpdateCaretScroll, deferredupdatecaretscroll ), 0 );

    if ( _fVisible )
    {
        ::DestroyCaret();
    }        
    delete _pDPCaret;
}


//+-----------------------------------------------------------------------
//    Method:        CCaret::Init
//
//    Parameters:    None
//
//    Synopsis:     This method initalizes the caret object. It will create 
//                  the caret's mu pointer in the main tree of the document.
//                  Note that after initializing the caret, you must position
//                  and make the caret visible explicitly.
//+-----------------------------------------------------------------------

HRESULT
CCaret::Init()
{
    HRESULT hr = S_OK;

    _pDPCaret = new CDisplayPointer( _pDoc );
    if( _pDPCaret == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
        
    hr = THR( _pDPCaret->SetPointerGravity(POINTER_GRAVITY_Right) );
    if (FAILED(hr))
        goto Cleanup;

    hr = THR( _pDPCaret->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    
#if DBG == 1
    _pDPCaret->SetDebugName(strCaretName);
#endif

Cleanup:

    RRETURN( hr );
}



//////////////////////////////////////////////////////////////////////////
//
//  Public Interface CCaret::IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CCaret::AddRef( void )
{
    return( ++_cRef );
}


STDMETHODIMP_(ULONG)
CCaret::Release( void )
{
    --_cRef;

    if( 0 == _cRef )
    {
        delete this;
        return 0;
    }

    return _cRef;
}


STDMETHODIMP
CCaret::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppv )
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;
    
    switch(iid.Data1)
    {
        QI_INHERITS( this , IUnknown )
        QI_INHERITS( this , IHTMLCaret )
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
    
}



//////////////////////////////////////////////////////////////////////////
//
//  Public Interface CCaret::IHTMLCaret's Implementation
//
//////////////////////////////////////////////////////////////////////////

//+-----------------------------------------------------------------------
//    Method:       CCaret::MoveCaretToPointer
//
//    Parameters:   
//          pPointer        -   Pointer to move caret to the left of
//          fAtEOL          -   Is the caret after the EOL character?
//
//    Synopsis:     Moves the caret to the specified location.
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::MoveCaretToPointer( 
    IDisplayPointer*    pDispPointer,
    BOOL                fScrollIntoView,
    CARET_DIRECTION     eDir )
{
    HRESULT hr = S_OK ;

    Assert( _pDPCaret );

    switch (eDir)
    {
    case CARET_DIRECTION_INDETERMINATE:
    {
        HRESULT hr;
        BOOL fEqual;
        BOOL fLeft;
        DISPLAY_GRAVITY dispGravityPointer;
        DISPLAY_GRAVITY dispGravityCaret;

        //
        // NOTE: IsBetweenLines doesn't work properly in some cases, so if
        // display gravity is different, skip the perf optimization.
        //

        hr = THR(_pDPCaret->GetDisplayGravity(&dispGravityCaret) );
        if (FAILED(hr))
            goto Cleanup;

        hr = THR(pDispPointer->GetDisplayGravity(&dispGravityPointer) );
        if (FAILED(hr))
            goto Cleanup;

        if (dispGravityCaret == dispGravityPointer)
        {
            hr = THR(_pDPCaret->IsEqualTo(pDispPointer, &fEqual));
            if (FAILED(hr))
                goto Cleanup;

            if (fEqual)
            {
                if (fScrollIntoView && _fVisible)
                {
                    hr = THR( pDispPointer->ScrollIntoView() );
                    if (FAILED(hr))
                        goto Cleanup;

                    hr = S_OK;
                }

                goto Cleanup;
            }
        }

        hr = THR(_pDPCaret->IsLeftOf(pDispPointer, &fLeft));
        if (SUCCEEDED(hr))
        {
            _fMoveForward = fLeft;
        }
        break;
    }
    case CARET_DIRECTION_SAME:
        break;
    case CARET_DIRECTION_BACKWARD:
    case CARET_DIRECTION_FORWARD:
        _fMoveForward = (eDir == CARET_DIRECTION_FORWARD);
        break;
#if DBG==1
    default:
        Assert(FALSE);
#endif
    }

    hr = THR( _pDPCaret->MoveToPointer( pDispPointer ));
    if( hr )
        goto Cleanup;

    DeferUpdateCaret( _fVisible && fScrollIntoView ); // Only scroll on move if visible
    
Cleanup:
    Assert(hr == S_OK);
    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::MoveCaretToPointerEx
//
//    Parameters:   
//          pPointer        -   Pointer to move caret to the left of
//          fAtEOL          -   Is the caret after the EOL character?
//
//    Synopsis:     Moves the caret to the specified location and set
//                  some common attributes. This should cut down on the
//                  number of times we calc the caret's location
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::MoveCaretToPointerEx( 
    IDisplayPointer*    pDispPointer,
    BOOL                fVisible,
    BOOL                fScrollIntoView,
    CARET_DIRECTION     eDir )
{
    HRESULT     hr;
    BOOL        fOldVisible;
    
    hr = THR( MoveCaretToPointer( pDispPointer, fScrollIntoView, eDir ));
    fOldVisible = _fVisible;
    _fVisible = fVisible;

    //  If we moved the caret and the caret is becoming visible, make it visible.
    if (!fOldVisible && _fVisible)
    {
        DeferUpdateCaret( fScrollIntoView ); // Only scroll on move if visible
    }

    RRETURN ( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::MoveMarkupPointerToCaret
//
//    Parameters:   IMarkupPointer *    Pointer to move to the right of the 
//                                      caret
//
//    Synopsis:     Moves the pointer to the right of the caret's location.
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::MoveMarkupPointerToCaret( 
    IMarkupPointer *    pPointer )
{
    HRESULT hr = S_OK ;
    Assert( _pDPCaret );
    hr = THR( _pDPCaret->PositionMarkupPointer(pPointer) );
    RRETURN( hr );
}

//+-----------------------------------------------------------------------
//    Method:       CCaret::MoveDisplayPointerToCaret
//
//    Parameters:   IDisplayPointer *  Pointer to move to the right of the 
//                                      caret
//
//    Synopsis:     Moves the pointer to the right of the caret's location.
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::MoveDisplayPointerToCaret( 
    IDisplayPointer *pDispPointer )
{
    HRESULT hr = S_OK ;
    Assert( _pDPCaret );
    hr = THR( pDispPointer->MoveToPointer(_pDPCaret) );
    RRETURN( hr );
}

//+-----------------------------------------------------------------------
//    Method:       CCaret::IsVisible
//
//    Parameters:   BOOL *  True if the caret is visible.
//
//    Synopsis:     The caret is visible if Show() has been called. NOTE that
//                  this does not tell you if the caret is on the screen.
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::IsVisible(
    BOOL *              pIsVisible)
{
    
    *pIsVisible = !!_fVisible;
  
    return S_OK;
}

BOOL
CCaret::IsPositioned()
{
    BOOL fPositioned = FALSE;

    IGNORE_HR( _pDPCaret->IsPositioned( & fPositioned ));

    return fPositioned;
}

//+-----------------------------------------------------------------------
//    Method:       CCaret::Show
//
//    Parameters:   None
//
//    Synopsis:     Un-hides the caret. It will display wherever it is 
//                  currently located.
//+-----------------------------------------------------------------------

STDMETHODIMP
CCaret::Show(
    BOOL        fScrollIntoView )
{
    HRESULT hr = S_OK;
    _fVisible = TRUE;
    DeferUpdateCaret( fScrollIntoView );
    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::Hide
//
//    Parameters:   None
//
//    Synopsis:     Makes the caret invisible.
//+-----------------------------------------------------------------------

STDMETHODIMP
CCaret::Hide()
{
    HRESULT hr = S_OK;
    _fVisible = FALSE;
    
    if( _pDoc && _pDoc->_pInPlace && _pDoc->_pInPlace->_hwnd )
    {
        ::HideCaret( _pDoc->_pInPlace->_hwnd );
    }
    
    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::InsertText
//
//    Parameters:   OLECHAR *           The text to insert
//
//    Synopsis:     Inserts text to the left of cursor's current location.
//+-----------------------------------------------------------------------

STDMETHODIMP
CCaret::InsertText( 
    OLECHAR *           pText,
    LONG                lLen )
{
    Assert( _pDPCaret );
    
    HRESULT hr = S_OK ;
    LONG lActualLen = lLen;
    CTreeNode* pNode = NULL;
    BOOL fPositioned;
    CMarkupPointer mp(_pDoc);

    if (!_pDPCaret)
    {
	hr = E_FAIL;
	goto Cleanup;
    }

    hr = THR(_pDPCaret->IsPositioned(&fPositioned) );
    if (hr)
        goto Cleanup;
    
    if (!fPositioned)
    {
        hr= E_FAIL;
        goto Cleanup;
    }                

    //
    // marka - being EXTRA CAREFUL to fix a Stress failure.
    //
    pNode = GetNodeContainer(MPTR_SHOWSLAVE);
    if ( !pNode )
    {
        hr = E_FAIL;
        goto Cleanup;
    }        

    if (ETAG_INPUT == pNode->Element()->GetMasterIfSlave()->Tag())
    {
        CFlowLayout * pLayout = GetFlowLayout();
        Assert( pLayout );
        if ( ! pLayout )
        {
            hr = E_FAIL;
            goto Cleanup;
        }
   
        if( lActualLen < 0 )
            lActualLen = pText ? _tcslen( pText ) : 0;
            
        LONG lMaxLen = pLayout->GetMaxLength();
        LONG lContentLen = pLayout->GetContentTextLength();
        LONG lCharsAllowed = lMaxLen - lContentLen;

        if( lActualLen > lCharsAllowed )
        {
            lActualLen = lCharsAllowed;
        }

        if( lActualLen <= 0 )
            goto Cleanup;
          
    }

    _fTyping = TRUE;

    hr = THR( _pDPCaret->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    if (hr)
        goto Cleanup;

    hr = THR( _pDPCaret->PositionMarkupPointer(&mp) );
    if (hr)
        goto Cleanup;
        
    hr = _pDoc->InsertText( &mp, pText, lActualLen );
    if( hr )
        goto Cleanup;
    
Cleanup:
    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::InsertMarkkup
//
//    Parameters:   OLECHAR *           The markup to insert
//
//    Synopsis:     Inserts html to the left of cursor's current location.
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::InsertMarkup( 
    OLECHAR *           pMarkup )
{
    return E_NOTIMPL;
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::ScrollIntoView
//
//    Parameters:   None
//
//    Synopsis:     Scrolls the current cursor location into view.
//                  NOTE: _Location may not be updated (_Location
//                  is only computed in CalcScreenCaretPos, called
//                  only from UpdateScreenCaret)
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::ScrollIntoView()
{
    DeferUpdateCaret( TRUE );
    return S_OK; // we can allways post a deferred update
}

//+-----------------------------------------------------------------------
//    Method:       CCaret::GetElementContainer
//
//    Parameters:   IHTMLElement **     The containing element.
//
//    Synopsis:     Returns the parent element at the cursor's current 
//                  location.
//+-----------------------------------------------------------------------

STDMETHODIMP
CCaret::GetElementContainer( 
    IHTMLElement **     ppElement )
{
    HRESULT         hr = S_OK ;
    CMarkupPointer  mp(_pDoc);

    hr = THR( _pDPCaret->PositionMarkupPointer(&mp) );
    if (hr) 
        goto Cleanup;
        
    hr = THR( mp.CurrentScope( ppElement ));

Cleanup:
    RRETURN( hr );
}


CTreeNode *
CCaret::GetNodeContainer(DWORD dwFlags)
{  
    HRESULT         hr;
    CMarkupPointer  mp(_pDoc);
    CTreeNode *     pNode       = NULL;

    if (!_pDPCaret)
        goto Error;

    hr = THR( _pDPCaret->PositionMarkupPointer(&mp) );
    if (hr)
        goto Error;
            
    pNode = mp.CurrentScope(dwFlags);
    if (!pNode)
    {
        pNode = mp.Markup()->Root()->GetFirstBranch();
        Assert(pNode);
    }

Error:    
    return pNode;
}


STDMETHODIMP
CCaret::GetLocation(
    POINT *             pPoint,
    BOOL                fTranslate )
{
    HRESULT       hr = S_OK;
    
    if( fTranslate )
    {
        CFlowLayout * pLayout = GetFlowLayout();
        if( pLayout == NULL )
            RRETURN( E_FAIL );
            
        CPoint t( _Location );
        pLayout->TransformPoint(  &t, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL );
        pPoint->x = t.x;
        pPoint->y = t.y;
    }
    else
    {
        pPoint->x = _Location.x;
        pPoint->y = _Location.y;
    }

    g_uiDisplay.DocPixelsFromDevice(pPoint);

    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::UpdateCaret
//
//    Parameters:   none
//
//    Synopsis:     Allow the client of an IHTMLCaret to ask us to update
//                  our current location when we get around to it.
//+-----------------------------------------------------------------------

STDMETHODIMP
CCaret::UpdateCaret()
{
    DeferUpdateCaret( FALSE );
    return( S_OK );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::UpdateCaret
//
//    Parameters:   
//                  fScrollIntoView -   If TRUE, scroll caret into view if 
//                                      we have focus or if not and 
//                                      selection isn't hidden
//                  fForceScroll    -   Force the caret to scroll no
//                                      matter what
//                  pdci            -   CDocInfo. Not used and may be null
//
//    Synopsis:     Allow the internal client of an IHTMLCaret to ask us 
//                  to update our current location when we get around to it. 
//                  Also allows internal (mshtml) clients to control if we 
//                  scroll.
//
//+-----------------------------------------------------------------------

HRESULT
CCaret::UpdateCaret(
    BOOL        fScrollIntoView, 
    BOOL        fForceScroll,
    CDocInfo *  pdci )
{
    DeferUpdateCaret( ( fScrollIntoView || fForceScroll ));
    return( S_OK );
}



//+-----------------------------------------------------------------------
//    Method:       CCaret::GetCaretDirection
//
//    Parameters:   
//                  peDir    -  return current Caret Direction. It is either
//                              backward or forward
//
//    Synopsis:     Allow the internal client of an IHTMLCaret to query for
//                  the caret direction.
//
//+-----------------------------------------------------------------------
STDMETHODIMP
CCaret::GetCaretDirection(
            CARET_DIRECTION *peDir
            )
{
    Assert (peDir);
    if (peDir)
    {
        *peDir = (_fMoveForward) ? CARET_DIRECTION_FORWARD:CARET_DIRECTION_BACKWARD;
        return (S_OK);
    }
    else
    {
        return (E_INVALIDARG);
    }
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::SetCaretDirection
//
//    Parameters:   
//                  eDir    -   Caret Direction
//
//    Synopsis:     Allow the internal client of an IHTMLCaret to set caret
//                  direction without having to resort to other approaches.
//
//+-----------------------------------------------------------------------
STDMETHODIMP
CCaret::SetCaretDirection(
            CARET_DIRECTION eDir
            )
{

    HRESULT hr = S_OK;
    switch (eDir)
    {
        case CARET_DIRECTION_FORWARD:
            _fMoveForward = TRUE;
            break;
            
        case CARET_DIRECTION_BACKWARD:
            _fMoveForward = FALSE;
            break;

        default:
            hr = S_FALSE;
            break;
    }

    RRETURN(hr);
}



HRESULT
CCaret::BeginPaint()
{
    _fPainting ++ ;

    if( _fPainting == 1 )
    {
        _fUpdateEndPaint = FALSE;
        _fUpdateScrollEndPaint = FALSE;
    
        if( _fVisible )
        {
            Assert( _pDoc && _pDoc->_pInPlace && _pDoc->_pInPlace->_hwnd );
            ::HideCaret( _pDoc->_pInPlace->_hwnd );
        }
    }
    
    return S_OK;
}


HRESULT
CCaret::EndPaint()
{
    HRESULT hr = S_OK;
    
    _fPainting -- ;

    //
    // if we recieved a deferred update of any flavor,
    // we want to post another update to compensate for
    // the loss.
    //

    if( _fPainting == 0 )
    {
        if( _fUpdateScrollEndPaint )
        {
            DeferUpdateCaret( TRUE );
        }
        else if( _fUpdateEndPaint )
        {
            DeferUpdateCaret( FALSE );
        }
        else if( _fVisible )
        {
            Assert( _pDoc && _pDoc->_pInPlace && _pDoc->_pInPlace->_hwnd );
            ::ShowCaret( _pDoc->_pInPlace->_hwnd );
        }
        
        //
        // handled, even if there were nested paints...
        //

        _fUpdateEndPaint = FALSE;
        _fUpdateScrollEndPaint = FALSE;
    }

    return hr;
}


HRESULT
CCaret::LoseFocus()
{
//    ::DestroyCaret();
    if( _pDoc && _pDoc->_pInPlace && _pDoc->_pInPlace->_hwnd )
        ::HideCaret( _pDoc->_pInPlace->_hwnd );

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//  Private Utility functions
//
//////////////////////////////////////////////////////////////////////////

CFlowLayout *
CCaret::GetFlowLayout()
{
    CFlowLayout *   pFlowLayout;
    CTreeNode *     pNode;
    
    pNode = GetNodeContainer(MPTR_SHOWSLAVE);
    if( pNode == NULL )
        return NULL;
        
    pFlowLayout = pNode->GetFlowLayout();

    
    return pFlowLayout;
}

//+-----------------------------------------------------------------------
//    CCaret::UpdateScreenCaret
//    PRIVATE
//
//    Parameters:   None
//
//    Synopsis:     Something moved us, so we have to update the position of 
//                  the screen caret.
//
//    NOTE:   There are various things that affect caret. 
//            g_fComplextScript && fRTLFlow  -- affect caret shape
//            fVerticalFlow                  -- affects caret shape
//            _fMoveForward                  -- affects caret affinity
//
//+-----------------------------------------------------------------------

HRESULT
CCaret::UpdateScreenCaret( BOOL fScrollIntoView, BOOL fIsIME )
{
    HRESULT             hr = S_OK;
    POINT               ptGlobal;
    POINT               ptClient;
    CFlowLayout *       pFlowLayout;
    LCID                curKbd = LOWORD(GetKeyboardLayout(0));
    long                yDescent = 0;
    CTreeNode *         pNode = NULL;
    CCharFormat const * pCharFormat = NULL;
    LONG                cp;
    CCalcInfo           CI;
    BOOL                fIsPositioned;
    DISPLAY_GRAVITY     eDispGravity;
    BOOL                fComplexLine = FALSE;
    BOOL                fRTLFlow     = FALSE;
    BOOL                fVerticalFlow= FALSE;
    LONG                xAdjust = 0;
    LONG                xDelta  = 0;
    BOOL                fDeferredCreateCaret = FALSE;

    // Before doing anything .. first make sure we have
    // correct width.. by doing the following.
    // Begin a-thkesa
    // Get the current system setting for cursor.
    // See windows Bug:491261
    DWORD dwWidth = 1;
    BOOL bRet = ::SystemParametersInfo(
                  SPI_GETCARETWIDTH,// system parameter to retrieve or set
                  0,                // depends on action to be taken
                  &dwWidth,         // depends on action to be taken
                  0                 // user profile update option
                  );

    if( bRet && dwWidth>0 )
    {
      _width = dwWidth; 
    }
    else
    {
     _width = 1 ;
    }
    //End.
    
				// Prepare to update the caret
    //

    Assert( _pDoc != NULL );
    if( _pDoc == NULL )
    {
        return FALSE;
    }

    // If any of the following are true, we have no work to do
    if(     _pDPCaret == NULL || 
            _pDoc->_state < OS_INPLACE || 
            _pDoc->_pInPlace == NULL ||
            _pDoc->_pInPlace->_hwnd == NULL ||
            _pDoc->TestLock( SERVERLOCK_BLOCKPAINT ) ||
            _pDoc->_fPageTransitionLockPaint)
    {
        return FALSE;
    }

    IGNORE_HR( _pDoc->NotifySelection( EDITOR_NOTIFY_UPDATE_CARET, NULL) );

    hr = THR( _pDPCaret->IsPositioned(&fIsPositioned) );
    if( !fIsPositioned )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
        
    pNode = GetNodeContainer(MPTR_SHOWSLAVE);
    if( pNode == NULL )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    
    pFlowLayout = pNode->GetFlowLayout();
    if( pFlowLayout == NULL )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //If caret was set in the GENERIC element that later has got a view slave as a result of
    // some script action (from HTC script for example) , we should bail from here until caret
    // will be moved to some legit place as a result of user action. IE6 bug 4915.
    {
        CElement *pElement = pNode->Element();
        if(    pElement->Tag() == ETAG_GENERIC
            && pFlowLayout->ElementOwner() == pElement
            && pElement->HasSlavePtr())
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }
    }
    
    cp = _pDPCaret->GetCp();
    pFlowLayout->WaitForRecalc( cp, -1 );


    pCharFormat = pNode->GetCharFormat();

    CI.Init(pFlowLayout);

    hr = THR(_pDPCaret->GetDisplayGravity(&eDispGravity) );
    if (FAILED(hr))
        goto Cleanup;

    if (-1 == pFlowLayout->PointFromTp( cp, NULL, eDispGravity == DISPLAY_GRAVITY_PreviousLine, _fMoveForward, ptClient, NULL, TA_BASELINE, 
                                        &CI, &fComplexLine, &fRTLFlow))
    {
        hr = OLE_E_BLANK;
        goto Cleanup;
    }

    Assert( pNode->Element() != _pDoc->PrimaryRoot() );

    //
    // Get the text height
    //

    if( ! _fVisible || _fPainting > 0 )
    {
        _height = 1;
    }
    else
    {
        long lNewHeight;
        
        // Start with springloader
        extern long GetSpringLoadedHeight(IMarkupPointer *, CFlowLayout *, long *);    

        lNewHeight = GetSpringLoadedHeight(NULL, pFlowLayout, &yDescent);
        
        if( lNewHeight != -1 )
        {
            BOOL fDefer;
            
            // Reflow, and we will want to defer our caret
            // update until the line remeasures
            SetHeightAndReflow( lNewHeight, &fDefer );

            if( fDefer )
            {
                DeferUpdateCaret( fScrollIntoView );
                goto Cleanup;
            }
        }
        else
        {
            // if springloader fails, get the text height from the format cache
            CCcs     ccs;
            const CBaseCcs *pBaseCcs;
            
            if (!fc().GetCcs(&ccs, CI._hdc, &CI, pCharFormat))
                goto Cleanup;

            pBaseCcs = ccs.GetBaseCcs();
            
            _height = pBaseCcs->_yHeight;
            
            yDescent = pBaseCcs->_yDescent;
            ccs.Release();
        }
    }

    if(_hbmpCaret)
    {
        if (fRTLFlow)
        {
            // the -1 at the end is an off by one adjustment needed for RTL
            xAdjust += (_xCSCaretShift + 1);
        }
        else
        {
            xAdjust += _xCSCaretShift;
        }
    }

    _Location.x = ptClient.x -  xAdjust;
    _Location.y = ptClient.y - ( _height - yDescent ) ;

#if 0
    //
    // Clip x to flow layout.  In general, the location returned from PointFromTp can be outside
    // the dimensions of the flow layout.
    //
    // For example: <DIV style="height:100">foo {caret}</DIV>
    //
    // The space will not contribute to the width of the DIV but will influence PointFromTp.  So
    // the caret will not be visible.
    //

    RECT rc;

    pFlowLayout->GetRect(&rc, COORDSYS_FLOWCONTENT);

    if (_Location.x >= rc.right)
    {
        _Location.x = rc.right-1;
    }
#endif
    
    //
    // Render the caret in the proper location
    //

    Assert( _fPainting == 0 );

    if( DocHasFocus() ||
      ( _pDoc->_pDragDropTargetInfo != NULL ) ) // We can update caret if we don't have focus during drag & drop
    {
        //
        // We need to caret vertical caret differently
        //
        fVerticalFlow = pFlowLayout->ElementOwner()->HasVerticalLayoutFlow();

    
        if( !fIsIME && g_fComplexScriptInput)
        {
            fDeferredCreateCaret = TRUE;
        }
        else
        {
            if( _hbmpCaret != NULL )
            {
                DestroyCaret();
                DeleteObject((void*)_hbmpCaret);
                _hbmpCaret = NULL;
            }
        }

        
        if( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if (fRTLFlow)
        {
            // consider the case for RTL with RTL flow 
            // the caret is located on the left side
            // of the typed in character, so the above
            // adjustment no longer satisfies the "adjust
            // into character" nature. So we want to
            // adjust the rectangle a little bit bigger
            //
            xDelta += _xCSCaretShift;
        }
        
        if( _pDoc->_state > OS_INPLACE )
        {

            ::HideCaret( _pDoc->_pInPlace->_hwnd );

            // if we have been requested to scroll, scroll the caret location into view
            if( fScrollIntoView && _fVisible && _fPainting == 0 )
            {
                // 
                // Here we want to consider both left-scrolling and right-scrolling cases
                // since caret position has been adjusted, we have to adjust the width of 
                // the caret rectangle too. 
                //
                //
                CRect rcLocal(  _Location.x + _dx , 
                                _Location.y + _dy , 
                                _Location.x + _dx + xAdjust + _width + xDelta,
                                _Location.y + _dy + _height + _dh );
                                
                pFlowLayout->ScrollRectIntoView( rcLocal, fVerticalFlow?SP_TYPINGSCROLL:SP_MINIMAL , fVerticalFlow?SP_MINIMAL:SP_TYPINGSCROLL );
            }

            // Translate our coordinates into window coordinates
            hr = THR( GetLocation( &ptGlobal , TRUE ) );
            g_uiDisplay.DeviceFromDocPixels(&ptGlobal);
            
            CRect rcGlobal;
            INT   yOffTop, yOffBottom;

            if (!fVerticalFlow)
            {
                rcGlobal.SetRect(   ptGlobal.x + _dx, 
                                    ptGlobal.y + _dy, 
                                    ptGlobal.x + _dx + xAdjust + _width, 
                                    ptGlobal.y + _dy + _height + _dh );
            }
            else
            {
                rcGlobal.SetRect(   ptGlobal.x - _dy - _dh - _height,
                                    ptGlobal.y + _dx, 
                                    ptGlobal.x - _dy, 
                                    ptGlobal.y + _dx + xAdjust + _width );
            }                                    

            // Calculate the visible caret after clipping to the layout in global
            // window coordinates
            CRect rcLayout;
            pFlowLayout->GetClippedClientRect( &rcLayout, CLIENTRECT_CONTENT );
            pFlowLayout->TransformRect( &rcLayout, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL );

            //
            // Do the clipping manually instead of letting Windows
            // handle it in bitmap caret case
            //
            if (fDeferredCreateCaret)  
            {
                if (!fVerticalFlow)
                {
                    if (rcGlobal.top >= rcLayout.bottom || rcGlobal.top + _height <= rcLayout.top)
                    {
                        // completely invisible
                        yOffTop     = _height;
                        yOffBottom  = 0;
                    }
                    else if (rcGlobal.top >= rcLayout.top && rcGlobal.top + _height <= rcLayout.bottom)
                    {
                        // completely visible
                        yOffTop     = 0;
                        yOffBottom  = 0;
                    }
                    else 
                    {
                        // partially visible
                        if (rcLayout.top >= rcGlobal.top)
                        {
                            yOffTop    = rcLayout.top - rcGlobal.top;
                            yOffBottom = _height - yOffTop - rcLayout.Height();
                            if (yOffBottom < 0)  yOffBottom = 0;
                        }
                        else
                        {
                            Assert (rcLayout.top <= rcLayout.bottom);
                            yOffTop     = 0;
                            yOffBottom  = _height - (rcLayout.bottom - rcGlobal.top);
                            if (yOffBottom > _height) yOffBottom = _height;
                        }
                        Assert (yOffTop >=0 && yOffTop <= _height);
                        Assert (yOffBottom >= 0 && yOffBottom <= _height);
                    }
                }
                else
                {
                    if ( rcGlobal.right <= rcLayout.left || rcGlobal.right - _height >= rcLayout.right)
                    {
                        // completely invisible
                        yOffTop    =  _height;
                        yOffBottom =  0;
                    }
                    else if (rcGlobal.right <= rcLayout.right && rcGlobal.right - _height >= rcLayout.left)
                    {
                        // completely visible
                        yOffTop     = 0;
                        yOffBottom  = 0;
                    }
                    else
                    {
                        // partially visible
                        if (rcLayout.right <= rcGlobal.right)
                        {
                            yOffTop    = rcGlobal.right - rcLayout.right;
                            yOffBottom = _height - yOffTop - rcLayout.Width();
                            if (yOffBottom < 0) yOffBottom = 0;
                        }
                        else
                        {
                            Assert (rcGlobal.right >= rcLayout.left);
                            yOffTop    = 0;
                            yOffBottom = _height - (rcGlobal.right - rcLayout.left);
                            if (yOffBottom > _height)  yOffBottom = _height;
                        }
                        Assert (yOffTop >=0 && yOffTop <= _height);
                        Assert (yOffBottom >= 0 && yOffBottom <= _height);
                    }
                }
                CreateCSCaret(curKbd, fVerticalFlow, yOffTop, yOffBottom);
            }
            
            rcGlobal.IntersectRect( rcLayout );            
            INT iW = rcGlobal.Width();
            INT iH = rcGlobal.Height();
            
            ::CreateCaret(  _pDoc->_pInPlace->_hwnd,
                            _hbmpCaret,
                            iW,
                            iH );

            if (!fVerticalFlow)
            {
                ::SetCaretPos( rcGlobal.left, rcGlobal.top );
            }
            else
            {
                ::SetCaretPos( rcGlobal.left + _dh, rcGlobal.top );
            }

            if( _fVisible && _fPainting == 0 && iW > 0  && iH > 0 )
            {
                if (::GetFocus() == _pDoc->_pInPlace->_hwnd)
                {
                    ::ShowCaret( _pDoc->_pInPlace->_hwnd );
                }
            }
        }
    }

Cleanup:
    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//  PRIVATE
//  CCaret::CreateCSCaret
//  COMPLEXSCRIPT
//
//  Parameters: 
//              LCID        curKbd              Current Keyboard script
//              BOOL        fVerticalFlow       vertical/horizontal caret?
//              INT         yOffTop             number of top part pixels clipped
//              INT         yOffBottom          number of bottom part pixels clipped
//
//  Synopsis:   creates bitmap caret for complex scripts...like Arabic, 
//              Hebrew, Thai, etc.
//
//  NOTE:       we only clip on the y direction. 
//
//+-----------------------------------------------------------------------

void 
CCaret::CreateCSCaret(LCID curKbd, BOOL fVerticalFlow, INT yOffTop, INT yOffBottom)
{
    // array for creating the caret bitmap if needed
    CStackDataAry<WORD, 128> aryCaretBitMap( Mt( CCaretCreateCSCaret_aryCaretBitMap_pv ));

    // A new caret will be created. Destroy the caret bitmap if it existed
    if(_hbmpCaret != NULL)
    {
        DestroyCaret();
        DeleteObject((void*)_hbmpCaret);
        _hbmpCaret = NULL;
    }

    int i;
    int iClippedHeight;
    Assert( _height >= 0 );
    Assert( yOffTop >= 0 && yOffTop <= _height);
    Assert( yOffBottom >= 0 && yOffBottom <= _height);

    iClippedHeight = _height - yOffTop - yOffBottom;
    Assert( iClippedHeight >= 0);
    if (iClippedHeight <= 0) return;    // no need to create caret

     // dynamically allocate more memory for the cursor so that
     // the bmp can be created to the correct size
     aryCaretBitMap.Grow( iClippedHeight );

     // draw the vertical stem from top to bottom
     for(i = 0; i < iClippedHeight; i++)
     {
         aryCaretBitMap[i] = 0x0020;
     }

    if(PRIMARYLANGID(LANGIDFROMLCID(curKbd)) == LANG_THAI)
    {
        // when Thai keyboard is active we need to create the cursor which
        // users are accustomed to

        // change the bottom row to the tail
        if (yOffBottom <= 0)        
        {
            aryCaretBitMap[iClippedHeight - 1] = 0x0038;
        }

    }
    else if(g_fBidiSupport)
    {

        // on a Bidi system we need to create the directional cursor which
        // users are accustomed to

        // get the current keyboard direction and draw the flag
        if(IsRtlLCID(curKbd))
        {
            if (yOffTop <= 1)
            {
                if (yOffTop <= 0)
                {
                    aryCaretBitMap[0] = 0x00E0;
                    aryCaretBitMap[1] = 0x0060;
                }
                else
                {
                    aryCaretBitMap[0] = 0x0060;
                }
            }
        }
        else
        {
            if (yOffTop <= 1)
            {
                if (yOffTop <= 0)
                {
                    aryCaretBitMap[0] = 0x0038;
                    aryCaretBitMap[1] = 0x0030;
                }
                else 
                {
                    aryCaretBitMap[0] = 0x0030;
                }
            }
        }

    }

    if (!fVerticalFlow)
    {
        // create the bitmap
        _hbmpCaret = (HBITMAP)CreateBitmap(5, iClippedHeight, 1, 1, (void*) aryCaretBitMap);
    }
    else
    {
        // create the bitmap
        CStackDataAry<WORD, 128> aryCaretVertBitMap( Mt( CCaretCreateCSCaret_aryCaretVertBitMap_pv ));
        aryCaretVertBitMap.Grow( (iClippedHeight % 16 == 0 ? iClippedHeight : iClippedHeight  + 16) / 16 * 5 );
        RotateCaretBitmap((BYTE *)((void *)aryCaretBitMap), 
                          5, 
                          iClippedHeight,
                          (BYTE *)((void *)aryCaretVertBitMap)
                          );
        _hbmpCaret = (HBITMAP)CreateBitmap(iClippedHeight, 5, 1, 1, (void*) aryCaretVertBitMap);
    }
}


////////////////////////////////////////////////////////////////////////////////////////
//  PRIVATE:
//  CCaret::RotateCaretBitmap
//  COMPLEXSCRIPT  VERTICAL
//
// 
//  Create a vertical caret bitmap out of horizontal one. Note this is an ad hoc 
//  function used for the caret only. In the future we can consider calling 
//  general purpose rotation functions in xgdi.cxx  
//
//  Rotate 90 degree to the right
//  Given  pbmSrcBits with width iW, and height iH, x [0..iW-1] y [0..iH-1]
//  Transform:  
//         (x, y)  --->  (iH - 1 - y, x)
//
//  Return number of bytes in the destination bitmap
//
//  [zhenbinx]
//
////////////////////////////////////////////////////////////////////////////////////////
int
CCaret::RotateCaretBitmap(BYTE *pbmSrcBits, int iW, int iH, BYTE *pbmDestBits)
{
    Assert (iW > 0);
    Assert (iH > 0);
    Assert (pbmDestBits);
    Assert (pbmSrcBits);
    Assert (sizeof(WORD) == sizeof(BYTE) + sizeof(BYTE));

    //
    // Dest: (x, y)      --> located at y * iH + x 
    // Src : (y, iH - x) --> located at (iH - 1 - x)*iW + y
    //
    int  nDestBase        = 0;
    int  nSrcBase         = (iH - 1) * iW;
    BYTE maskBit          = 0x80;
    int  nBytesPerSrcLine = ((iW + 16) / 16) * 2;
    BOOL fDestNeedPadding = (iH % 16) == 0 ? FALSE : TRUE;
    BOOL fOneBytePadding  = ((iH + 8 ) / 8) % 2 == 0 ? FALSE : TRUE;
    BYTE *pDestByte       = pbmDestBits;
    BYTE *pSrcByte;       
    for (int y = 0; y < iW; y++)        // destBits height -- iW
    {
        int nDestLoc = nDestBase;
        int nSrcLoc  = nSrcBase;
        pSrcByte   = pbmSrcBits + (nSrcLoc/iW) * nBytesPerSrcLine + (nSrcLoc % iW)/8;
        for (int x = 0; x < iH; x++)    // destBits width -- iH
        {
            Assert ( nDestLoc >= 0 && nDestLoc <= iW * iH - 1);
            Assert ( nSrcLoc  >= 0 && nSrcLoc  <= iH * iW - 1);
            
            int  nSrcShift;
            int  nDestShift;
            BYTE byteSrc;

            if (0 == x%8)
            {
                if (x)  // do not advance the first byte
                {
                    pDestByte++;          // advance one byte
                }
                *pDestByte = '\0';    // zero out it first
            }
            //
            // Cacluate dest pixel location
            //
            nDestShift = x % 8;
            //
            // Cacluate src pixel location -- this should be optimized away in the future 
            //
            nSrcShift  = (nSrcLoc % iW) % 8;

            //
            // Copy src pixel into dest pixel
            //
            byteSrc   = (*pSrcByte) & (maskBit >> nSrcShift);
            *pDestByte |=  ((byteSrc << nSrcShift) >>  nDestShift);

            // 
            // advance destination pixel
            // Dest: (x + 1, y)      --> located at [(y * iH) + x] + 1
            // Src : (y, iH - x - 1) --> located at [(iH-1-x)*iW + y] - iW;
            //
            nDestLoc ++;
            nSrcLoc  -= iW;
            pSrcByte -= nBytesPerSrcLine;   // this is hacky 
        }
        
        //
        // Padding to word boundary so that we can go to next scan line
        //
        if (fDestNeedPadding && fOneBytePadding)
        {
            *(++pDestByte) = '\0';
        }

        //
        // Start a new scan line for the destination buffer
        //
        pDestByte++;
        
        //
        // advance to destination line
        // Dest: (x, y + 1)   --> located at [(y * iH + x)] + iH;
        // Src : (y+1, iH-x)   --> located at [(iH-1-x) * iW + y] + 1;
        //
        nDestBase += iH;
        nSrcBase  += 1;
    }

    Assert( (int)((iH % 16 == 0 ? iH : iH + 16) / 16 * 2 * 5)  == (int) (pDestByte - pbmDestBits) );
    return (int)(pDestByte - pbmDestBits);
}

//+-------------------------------------------------------------------------
//
//  Method:     DeferUpdateCaret
//
//  Synopsis:   Deferes the call to update caret
//
//  Returns:    None
//
//--------------------------------------------------------------------------
void
CCaret::DeferUpdateCaret( BOOL fScroll )
{
    if( _fCanPostDeferred )
    {
        // Kill pending calls if any
        GWKillMethodCall(this, ONCALL_METHOD(CCaret, DeferredUpdateCaret, deferredupdatecaret), 0);
        
        if( fScroll || _fTyping )
        {
            if( _fTyping )
            {
                _fTyping = FALSE;
            }
            
            // Kill pending scrolling calls if any
            GWKillMethodCall(this, ONCALL_METHOD(CCaret, DeferredUpdateCaretScroll, deferredupdatecaretscroll), 0);
            // Defer the update caret scroll call
            IGNORE_HR(GWPostMethodCall(this,
                                       ONCALL_METHOD(CCaret, DeferredUpdateCaretScroll, deferredupdatecaretscroll),
                                       (DWORD_PTR)_pDoc, FALSE, "CCaret::DeferredUpdateCaretScroll")); // There can be only one caret per cdoc
        }
        else
        {
            // Defer the update caret call
            IGNORE_HR(GWPostMethodCall(this,
                                       ONCALL_METHOD(CCaret, DeferredUpdateCaret, deferredupdatecaret),
                                       (DWORD_PTR)_pDoc, FALSE, "CCaret::DeferredUpdateCaret")); // There can be only one caret per cdoc
        }
    }
}


void
CCaret::DeferredUpdateCaret( DWORD_PTR dwContext )
{
    DWORD_PTR dwDoc = (DWORD_PTR)_pDoc;
    CDoc * pInDoc = (CDoc *) dwContext;

    if( _fPainting > 0 )
    {
        _fUpdateEndPaint = TRUE;
    }
    else if( dwDoc == dwContext && pInDoc->_state >= OS_INPLACE )
    {
        UpdateScreenCaret( FALSE , FALSE );
    }
}


void
CCaret::DeferredUpdateCaretScroll( DWORD_PTR dwContext )
{
    DWORD_PTR dwDoc = (DWORD_PTR)_pDoc;
    CDoc * pInDoc = (CDoc *) dwContext;

    if( _fPainting > 0 )
    {
        _fUpdateScrollEndPaint = TRUE;
    }
    else if( dwDoc == dwContext && pInDoc->_state >= OS_INPLACE )
    {
        UpdateScreenCaret( TRUE, FALSE );
    }
}


BOOL
CCaret::DocHasFocus()
{
    
    BOOL fOut = FALSE;
    HWND hwHasFocus = GetFocus();
    fOut = ( _pDoc->_pInPlace != NULL                   && 
             _pDoc->_pInPlace->_hwnd != NULL            && 
             hwHasFocus != NULL && 
             _pDoc->_pInPlace->_hwnd == hwHasFocus );

    return fOut;
}


LONG
CCaret::GetCp(CMarkup *pMarkup)
{
    HRESULT  hr;
    LONG     cp = 0;
    BOOL     fPositioned;

    hr = THR( _pDPCaret->IsPositioned(&fPositioned) );

    if (SUCCEEDED(hr) && fPositioned)
    {
        cp = _pDPCaret->GetCp();
        if (pMarkup && pMarkup != _pDPCaret->Markup() )
        {
            //
            // Walk up the parent chain
            // to get the correct CP
            //
            CMarkup         *pSlaveMarkup;

            pSlaveMarkup = _pDPCaret->Markup();
            while (pSlaveMarkup)
            {
                if (pMarkup == pSlaveMarkup->GetParentMarkup())
                {
                    CElement        *pElem;
                    CTreePos        *pStPos;

                    pElem = pSlaveMarkup->Root();
                    if (pElem && pElem->HasMasterPtr())
                    {
                        pElem = pElem->GetMasterPtr();
                        Assert(pElem);
                        if (pElem)
                        {
                            pElem->GetTreeExtent(&pStPos, NULL);
                            Assert(pStPos);
                            if (pStPos)
                            {
                                cp = pStPos->GetCp();
                            }
                        }
                    }
                    break;
                }
                else
                {
                    pSlaveMarkup = pSlaveMarkup->GetParentMarkup();
                }
            }
        }
    }

    return cp;
}

CMarkup *
CCaret::GetMarkup()
{
    HRESULT  hr;
    CMarkup *pMarkup = NULL;
    BOOL     fPositioned;

    hr = THR( _pDPCaret->IsPositioned(&fPositioned) );

    if (SUCCEEDED(hr) && fPositioned)
    {
        pMarkup = _pDPCaret->Markup();
    }

    return pMarkup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCaret::SetHeightAndReflow
//
//  Synopsis:   Sets the height of the caret, and determines if the line
//              where the caret is at needs to be re-measured.  This also
//              determines whether or not the caret display needs to be
//              deferred.
//
//  Arguments:  lHeight = new height of caret
//              pfDefer = Should the caret display be deferred?
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void
CCaret::SetHeightAndReflow(LONG lHeight, BOOL *pfDefer)
{
    CTreeNode       *pNode = NULL;
    CFlowLayout     *pFlowLayout = NULL;
    CNotification   nf;
    BOOL            fDefer = FALSE;

    Assert( pfDefer );

    // See if the height has changed
    if( lHeight != _height )
    {
        CMarkupPointer mp(_pDoc);
        
        _height = lHeight;

        if (SUCCEEDED(_pDPCaret->PositionMarkupPointer(&mp)))
        {
            pNode = mp.CurrentScope(MPTR_SHOWSLAVE);
            Assert( pNode );

            pFlowLayout = pNode->GetFlowLayout();
            Assert( pFlowLayout );

            // Create the notification, we need to remeasure our line
            nf.CharsResize( GetCp(NULL), 1, pNode );
            pFlowLayout->GetContentMarkup()->Notify( nf );

            // Don't display the caret yet, let the line remeasure first
            fDefer = TRUE;
        }
    }       

    *pfDefer = fDefer;
}

//+---------------------------------------------------------------------------
//
//  Member:     IsInsideElement
//
//  Synopsis: Is the caret positioned inside a given element ?
//
//----------------------------------------------------------------------------


HRESULT
CCaret::IsInsideElement( CElement* pElement )
{
    HRESULT hr = S_OK;
    CMarkupPointer* pMPCaret = NULL;
    CMarkupPointer* pMPElement = NULL ;
    CTreeNode* pMasterNode = NULL ;
    
    if ( ! IsPositioned() )
    {
        hr = S_FALSE;
        goto Cleanup;
    }        

    hr = THR( _pDoc->CreateMarkupPointer( & pMPCaret ));
    if ( hr )
        goto Cleanup;
        
    if ( _pDPCaret->Markup() != pElement->GetMarkup() )
    {
        pMasterNode = GetNodeContainer(0)->GetNodeInMarkup( pElement->GetMarkup() ); 
        if ( pMasterNode )
        {
            pElement = pMasterNode->Element();
        }            

        hr = THR( pMPCaret->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeBegin));
        if ( hr )
            goto Cleanup;
    }
    else
    {
        hr = THR( _pDPCaret->PositionMarkupPointer( pMPCaret) );
        if ( hr )
            goto Cleanup;
    }

    hr = THR( _pDoc->CreateMarkupPointer( & pMPElement ));
    if ( hr )
        goto Cleanup;

    hr = THR( pMPElement->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeBegin ));
    if ( hr )
        goto Cleanup;

    if ( pMPCaret->IsRightOfOrEqualTo( pMPElement ) )
    {
        hr = THR( pMPElement->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd ));
        if ( hr )
            goto Cleanup;

        if ( pMPCaret->IsLeftOfOrEqualTo( pMPElement ) )
        {
            hr = S_OK;
        }
        else
            hr = S_FALSE;
        
    }
    else
        hr = S_FALSE;
            
Cleanup:
    ReleaseInterface( pMPCaret );
    ReleaseInterface( pMPElement );

    RRETURN1( hr, S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\table\ltrowcol.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltrow.cxx
//
//  Contents:   Implementation of CTableCellLayout and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

MtDefine(CTableRowLayoutBlock, Layout, "CTableRowLayoutBlock");
MtDefine(CTableRowLayout, Layout, "CTableRowLayout");
MtDefine(CTableRowLayout_aryCells_pv, CTableRowLayout, "CTableRowLayout::_aryCells::_pv");
MtDefine(CTableRowLayout_pDisplayNoneCells_pv, CTableRowLayout, "CTableRowLayout::_pDisplayNoneCells::_pv");

const CLayout::LAYOUTDESC CTableRowLayoutBlock::s_layoutdesc =
{
    0,                              // _dwFlags
};

const CLayout::LAYOUTDESC CTableRowLayout::s_layoutdesc =
{
    0,                              // _dwFlags
};


//+------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::~CTableRowLayoutBlock
//
//  Synopsis:   
//
//-------------------------------------------------------------------------
CTableRowLayoutBlock::~CTableRowLayoutBlock()
{
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::Init
//
// Synopsis:     
//
//+---------------------------------------------------------------------
HRESULT
CTableRowLayoutBlock::Init()
{
    HRESULT hr = super::Init();

    // Table rows are breakable if their markup's master is a layoutrect
    SetElementAsBreakable();

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::GetPositionInFlow
//
//  Synopsis:   Return the in-flow position of a site
//
//-------------------------------------------------------------------------

void
CTableRowLayoutBlock::GetPositionInFlow(CElement * pElement, CPoint * ppt)
{
    CTableLayout * pTableLayout;

    Assert(GetFirstBranch()->GetUpdatedParentLayoutElement() == Table());

    pTableLayout = TableLayoutCache();
    if (pTableLayout)
    {
        pTableLayout->GetPositionInFlow(pElement, ppt);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::Draw
//
//  Synopsis:   Paint the background
//
//----------------------------------------------------------------------------

void
CTableRowLayoutBlock::Draw(CFormDrawInfo *, CDispNode *)
{
    AssertSz(FALSE, "Table row doesn't draw itself");
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::Notify
//
//  Synopsis:   Notification handler.
//
//----------------------------------------------------------------------------

void
CTableRowLayoutBlock::Notify(CNotification * pnf)
{
    Assert(!pnf->IsReceived(_snLast));

    if (pnf->IsType(NTYPE_ELEMENT_MINMAX))
    {
        Assert(     pnf->Element() == ElementOwner()
                ||  pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED));    // Necessary to allow ChangeTo below

        CTable *        pTable = Table();
        CTableLayout *  pTableLayoutCache =   pTable
                                            ? pTable->TableLayoutCache()
                                            : NULL;

        if (    pTableLayoutCache 
            &&  pTableLayoutCache->CanRecalc() 
            &&  !pTableLayoutCache->TestLock(CElement::ELEMENTLOCK_SIZING)   )
        {
            pTableLayoutCache->_fDontSaveHistory = TRUE;
            pTableLayoutCache->ResetRowMinMax(RowLayoutCache());
        }

        pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
    }
    else if (   !IsInvalidationNotification(pnf)
            ||  ElementOwner() != pnf->Element()
            ||  GetElementDispNode())
    {
        super::Notify(pnf);
    }

#if DBG==1
    // Update _snLast unless this is a self-only notification. Self-only
    // notification are an anachronism and delivered immediately, thus
    // breaking the usual order of notifications.
    if (!pnf->SendToSelfOnly() && pnf->SerialNumber() != (DWORD)-1)
    {
        _snLast = pnf->SerialNumber();
    }
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::RegionFromElement
//
//  Synopsis:   Return the bounding rectangle for an element, if the element is
//              this instance's owner. The RECT returned is in client coordinates.
//
//  Arguments:  pElement - pointer to the element
//              CDataAry<RECT> *  - rectangle array to contain
//              dwflags - flags define the type of changes required
//              (CLEARFORMATS) etc.
//
//-----------------------------------------------------------------------------
void
CTableRowLayoutBlock::RegionFromElement(
    CElement *          pElement,
    CDataAry<RECT> *    paryRects,
    RECT *              prcBound,
    DWORD               dwFlags)
{
    CTableLayout *pTableLayout = TableLayoutCache();

    if (pTableLayout)
    {
        pTableLayout->RegionFromElement(pElement, paryRects, prcBound, dwFlags);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::ShowSelected
//
//  Synopsis:   Show the selected range.
//
//----------------------------------------------------------------------------

void 
CTableRowLayoutBlock::ShowSelected(
            CTreePos* ptpStart, 
            CTreePos* ptpEnd, 
            BOOL fSelected, 
            BOOL fLayoutCompletelyEnclosed )           
{
    CTableLayout * pTableLayout = TableLayoutCache();

    if (pTableLayout)
    {
        pTableLayout->ShowSelected(ptpStart, ptpEnd, fSelected, fLayoutCompletelyEnclosed );
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CTableRowLayout::destructor
//
//  Note:       The display none cache must be deleted in the destructor
//
//-------------------------------------------------------------------------

CTableRowLayout::~CTableRowLayout()
{
    ClearRowLayoutCache();
}

//+------------------------------------------------------------------------
//
//  Member:     GetFirstLayout
//
//  Synopsis:   Enumeration method to loop thru children (start)
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    site
//
//  Note:       If you change the way the cookie is implemented, then
//              please also change the GetCookieForSite funciton.
//
//-------------------------------------------------------------------------

CLayout *
CTableRowLayout::GetFirstLayout(DWORD_PTR * pdw, BOOL fBack, BOOL fRaw)
{
    // TODO (dmitryt, tracking bug IE6/13701) fRaw is always FALSE, never actually used. Can be removed.
    *pdw = fBack ? (DWORD)_aryCells.Size() : (DWORD)-1;
    return CTableRowLayout::GetNextLayout(pdw, fBack);
}


//+------------------------------------------------------------------------
//
//  Member:     GetNextLayout
//
//  Synopsis:   Enumeration method to loop thru children
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    site
//
//-------------------------------------------------------------------------

CLayout *
CTableRowLayout::GetNextLayout(DWORD_PTR * pdw, BOOL fBack, BOOL fRaw)
{
    // TODO (dmitryt, tracking bug IE6/13701) fRaw is always FALSE, never actually used. Can be removed.
    int i;
    CTableCell * pCell;

    for (;;)
    {
        i = (int)*pdw;
        if (fBack)
        {
            if (i > 0)
            {
                i--;
            }
            else
            {
                return NULL;
            }
        }
        else
        {
            if (i < _aryCells.Size() - 1)
            {
                i++;
            }
            else
            {
                return NULL;
            }
        }
        *pdw = (DWORD)i;
        pCell = _aryCells[i];
        if (IsReal(pCell))
        {
            return pCell->GetUpdatedLayout();
        }
    }
}

CDispNode *
CTableRowLayout::GetElementDispNode(CElement *  pElement) const
{
    return (    !pElement
            ||  pElement == ElementOwner()
                    ? super::GetElementDispNode(pElement)
                        : NULL);
}


//
// virtual: helper function to calculate absolutely positioned child layout
//
void        
CTableRowLayoutBlock::CalcAbsolutePosChild(CCalcInfo *pci, CLayout *pLayout)
{
    CTable *            pTable = Table();
    CTableLayout *      pTableLayoutCache = pTable ? pTable->TableLayoutCache() : NULL;
    CTableLayoutBlock * pTableLayoutBlock = pTable 
        ? (CTableLayoutBlock *)pTable->GetUpdatedLayout(pci->GetLayoutContext()) : NULL;

    //  NOTE (greglett)  Originally, the ETAG_TD and ETAG_TH check below was simply an assert.  A tree stress bug
    //  created a situation where a DIV was the child - the ptr casting was causing a crash.  I don't think it should
    //  ever occur in a real document situation.  Since it isn't valid, and shouldn't happen, just exit. (#71211)

    if ((pLayout->Tag() == ETAG_TD || pLayout->Tag() == ETAG_TH) && pTableLayoutCache)
    {
        Assert(pTableLayoutBlock);

        CTableCalcInfo tci(pTable, pTableLayoutBlock);
        pTableLayoutCache->CalcAbsolutePosCell(&tci, (CTableCell *)pLayout->ElementOwner());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     AddCell
//
//  Synopsis:   Add a cell to the row
//
//----------------------------------------------------------------------------

HRESULT
CTableRowLayout::AddCell(CTableCell * pCell)
{
    HRESULT         hr = S_OK;
    CTableLayout  * pTableLayout = TableLayoutCache();
    int             cCols = _aryCells.Size();
    CTableRow     * pRow = TableRow();

    Assert(pCell);

    int             cColSpan = pCell->ColSpan();
    int             cRowSpan = 1;
    int             iAt = 0;
    CTableCell *    pCellOverlap = NULL;
    BOOL            fAbsolutePositionedRow = FALSE;
    BOOL            fDisplayNoneRow = FALSE;
    BOOL            fDisplayNoneCell = FALSE;

    // fill first empty cell

    while (iAt < cCols && !IsEmpty(_aryCells[iAt]))
        iAt++;

    // tell cell where it is
    pCell->_iCol = iAt;

    CTreeNode *pNode = pCell->GetFirstBranch();
    const CFancyFormat * pFF = pNode->GetFancyFormat();
    const CParaFormat * pPF = pNode->GetParaFormat();
    const CCharFormat * pCF = pNode->GetCharFormat();
    BOOL fCellVertical = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

    if (!pTableLayout)
        goto Cleanup;

    // WHINING: we should set this flag based on _dp._fContainsHorzPercentAttr, but it doesn't work correctly
    pTableLayout->_fHavePercentageInset |= (   pFF->GetLogicalPadding(SIDE_LEFT, fCellVertical, fWritingModeUsed).IsPercent()
                                            || pFF->GetLogicalPadding(SIDE_RIGHT, fCellVertical, fWritingModeUsed).IsPercent()
                                            || pPF->_cuvTextIndent.IsPercent());

    cRowSpan = pCell->GetAArowSpan();
    Assert (cRowSpan >= 1);
    if (cRowSpan > 1)
    {
        pRow->_fHaveRowSpanCells = TRUE;
        const CFancyFormat * pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
        if (pFFRow->_bPositionType == stylePositionabsolute)
            fAbsolutePositionedRow = TRUE;
        if (pFFRow->_bDisplay == styleDisplayNone)
            fDisplayNoneRow = TRUE;
    }

    fDisplayNoneCell = pFF->_bDisplay == styleDisplayNone;
    
    if (   fDisplayNoneRow 
        || fAbsolutePositionedRow 
        || fDisplayNoneCell)
    {
        hr = AddDisplayNoneCell(pCell);
        if (hr)
            goto Cleanup;
        goto Done;
    }

    if (pFF->_bPositionType == stylePositionabsolute)
    {
        hr = AddDisplayNoneCell(pCell);
        if (hr)
            goto Cleanup;
        hr = pTableLayout->AddAbsolutePositionCell(pCell);
        if (hr)
            goto Cleanup;
        goto Done;
    }

    // expand row

    if (cCols < iAt + cColSpan)
    {
        hr = EnsureCells(iAt + cColSpan);
        if (hr)
            goto Cleanup;

        hr = pTableLayout->EnsureCols(iAt + cColSpan);
        if (hr)
            goto Cleanup;

        EnsureCells(iAt + cColSpan);
    }

    pTableLayout->SetLastNonVirtualCol(iAt);

    Assert(IsEmpty(_aryCells[iAt]));
    SetCell(iAt, pCell);

    if (cRowSpan != 1)
    {
        hr = pTableLayout->EnsureRowSpanVector(iAt + cColSpan);
        if (hr)
            goto Cleanup;
        pTableLayout->AddRowSpanCell(iAt, cRowSpan);

        // 71720: Turn off _fAllRowsSameShape optimization when we run into rowspanned cells.
        // Note we are not using RowSpan() because we haven't seen the next row yet to see if it is in the same section.
        pTableLayout->_fAllRowsSameShape = FALSE;
    }

    pTableLayout->_cTotalColSpan += cColSpan;   // total number of col spans for this row

    cColSpan--;

    while (cColSpan--)
    {
        ++iAt;
        if (!IsEmpty(_aryCells[iAt]))
        {
            pCellOverlap = Cell(_aryCells[iAt]);
            if (pCellOverlap->ColIndex() == iAt)
            {
                // overlapped cell is always spanned
                SetCell(iAt, MarkSpannedAndOverlapped(pCellOverlap));
            }
        }
        else
        {
            SetCell(iAt, MarkSpanned(pCell));
        }
    }

Done:
    // increment the number of real cells
    _cRealCells++;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     AddDisplayNoneCell
//
//  Synopsis:   Add a display-none cell to the row
//
//----------------------------------------------------------------------------

HRESULT
CTableRowLayout::AddDisplayNoneCell(CTableCell * pCell)
{
    HRESULT hr;
    CDispNode * pDispNode = NULL;

    Assert (pCell);

    CTableCellLayout *pCellLayout = pCell->Layout();
    Assert (pCellLayout);

    if (!_pDisplayNoneCells)
    {
        _pDisplayNoneCells = new  (Mt(CTableRowLayout_pDisplayNoneCells_pv)) CPtrAry<CTableCell *> (Mt(CTableRowLayout_pDisplayNoneCells_pv));
        if (!_pDisplayNoneCells)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    hr = _pDisplayNoneCells->Append(pCell);
    if (!hr)
        pCell->AddRef();

    pDispNode = pCellLayout->GetElementDispNode();
    if (pDispNode)
    {
        GetView()->ExtractDispNode(pDispNode);
    }

    pCellLayout->_fDisplayNoneCell = TRUE;

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureCells
//
//  Synopsis:   Make sure there are at least cCells number of slots in the row
//
//----------------------------------------------------------------------------

HRESULT
CTableRowLayout::EnsureCells(int cCells)
{
    int c = _aryCells.Size();
    HRESULT hr = _aryCells.EnsureSize(cCells);
    if (hr)
        goto Cleanup;

    Assert(c <= cCells);
    _aryCells.SetSize(cCells);
    while (cCells-- > c)
    {
        // don't go through the SetCell call here because MarkEmpty is a 
        // special value that should not be addref'd
        _aryCells[cCells] = ::MarkEmpty();
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     ClearRowLayoutCache
//
//  Synopsis:   Empty the array of cells.
//
//----------------------------------------------------------------------------

void
CTableRowLayout::ClearRowLayoutCache()
{
    // don't allow access to this array after this call
    if (TableRow())
        TableRow()->InvalidateCollections();

    ReleaseAllCells();
    _cRealCells = 0;
    if (_pDisplayNoneCells)
    {
        _pDisplayNoneCells->ReleaseAll();
        _pDisplayNoneCells->DeleteAll();
        delete _pDisplayNoneCells;

        _pDisplayNoneCells = NULL;
    }

}


//+------------------------------------------------------------------------
//
//  Member:     AdjustHeightCore
//
//  Synopsis:   adjust height of the row for specified height / minHeight (puvHeight)
//
//-------------------------------------------------------------------------
void 
CTableRowLayout::AdjustHeightCore(
                    const CHeightUnitValue  *puvHeight,     //  height to adjust to 
                    CCalcInfo               *pci, 
                    CTable                  *pTable 
                    )
{
    Assert(puvHeight && puvHeight->IsSpecified() && pci && pTable);

    // set row unit height if not set or smaller then the cell height
    if (!IsHeightSpecified())
    {
        goto Adjustment;
    }
    else if (puvHeight->IsSpecifiedInPercent())
    {
        // set if smaller
        if (IsHeightSpecifiedInPercent())
        {
            if (GetHeightUnitValue() < puvHeight->GetUnitValue())
            {
                goto Adjustment;
            }
        }
        else
        {
            // percent has precedence over normal height
            goto Adjustment;
        }
    }
    else if (!IsHeightSpecifiedInPercent())
    {
        // set if smaller
        if (GetPixelHeight(pci) < puvHeight->GetPixelHeight(pci, pTable))
        {
            goto Adjustment;
        }
    }
    return;

Adjustment:
    _uvHeight = *puvHeight;
    return;
}

//+------------------------------------------------------------------------
//
//  Member:     AdjustHeight
//
//  Synopsis:   adjust height of the row for specified height of the node
//
//-------------------------------------------------------------------------
void 
CTableRowLayout::AdjustHeight(CTreeNode *pNode, CCalcInfo *pci, CTable *pTable)
{
    Assert(pNode);

    // Get cell's height in table coordinate system (table is always horizontal => physical height)
    const CHeightUnitValue * puvHeight = (const CHeightUnitValue *)&pNode->GetFancyFormat()->GetHeight();
    if (puvHeight->IsSpecified())
    {
        AdjustHeightCore(puvHeight, pci, pTable); 
    }
}

//+------------------------------------------------------------------------
//
//  Member:     AdjustMinHeight
//
//  Synopsis:   adjust height of the row for specified minHeight of the node
//
//-------------------------------------------------------------------------
void 
CTableRowLayout::AdjustMinHeight(CTreeNode *pNode, CCalcInfo *pci, CTable *pTable)
{
    Assert(TableLayoutCache() && TableLayoutCache()->IsFixed());    //  This adjustment is for fixed layout tables only
    Assert(pNode);

    // Get cell's height in table coordinate system (table is always horizontal => physical height)
    const CHeightUnitValue * puvMinHeight = (const CHeightUnitValue *)&pNode->GetFancyFormat()->GetMinHeight();
    if (puvMinHeight->IsSpecified())
    {
        AdjustHeightCore(puvMinHeight, pci, pTable); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\disp.cxx ===
/*
 *  DISP.CXX
 *
 *  Purpose:
 *      CDisplay class
 *
 *  Owner:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_DOCPRINT_HXX_
#define X_DOCPRINT_HXX_
#include "docprint.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_RCLCLPTR_HXX_
#define X_RCLCLPTR_HXX_
#include "rclclptr.hxx"
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_REGION_HXX_
#define X_REGION_HXX_
#include "region.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

EXTERN_C const GUID CLSID_HTMLCheckboxElement;
EXTERN_C const GUID CLSID_HTMLRadioElement;

// Timer tick counts for background task
#define cmsecBgndInterval   300
#define cmsecBgndBusy       100

// Lines ahead
const LONG g_cExtraBeforeLazy = 10;

PerfDbgTag(tagRecalc, "Layout Recalc Engine", "Layout recalcEngine");
DeclareTag(tagPositionObjects, "PositionObjects", "PositionObjects");
DeclareTag(tagRenderingRect, "Rendering rect", "Rendering rect");
DeclareTag(tagRelDispNodeCache, "Relative disp node cache", "Trace changes to disp node cache");
DeclareTag(tagTableCalcDontReuseMeasurer, "Tables", "Disable measurer reuse across Table cells");
DeclareTag(tagDebugRTL, "RTL:DebugBreaks", "Enable RTL Debug Breaks");
DeclareTag(tagRenderLines, "Lines", "Trace line rendering");
DeclareTag(tagDisableBackground, "Layout", "Disable Background Calc");
PerfDbgExtern(tagPaintWait);

MtDefine(CRecalcTask, Layout, "CRecalcTask")
MtDefine(CDisplay, Layout, "CDisplay")
MtDefine(CDisplay_aryRegionCollection_pv, CDisplay, "CDisplay::_aryRegionCollection::_pv")
MtDefine(CRelDispNodeCache, CDisplay, "CRelDispNodeCache::_pv")
MtDefine(CDisplayUpdateView_aryInvalRects_pv, Locals, "CDisplay::UpdateView aryInvalRects::_pv")
MtDefine(CDisplayDrawBackgroundAndBorder_aryRects_pv, Locals, "CDisplay::DrawBackgroundAndBorder aryRects::_pv")
MtDefine(CDisplayDrawBackgroundAndBorder_aryNodesWithBgOrBorder_pv, Locals, "CDisplay::DrawBackgroundAndBorder aryNodesWithBgOrBorder::_pv")

ExternTag(tagCalcSize);

//
// This function does exactly what IntersectRect does, except that
// if one of the rects is empty, it still returns TRUE if the rect
// is located inside the other rect. [ IntersectRect rect in such
// case returns FALSE. ]
//

BOOL
IntersectRectE (RECT * prRes, const RECT * pr1, const RECT * pr2)
{
    // nAdjust is used to control what statement do we use in conditional
    // expressions: a < b or a <= b. nAdjust can be 0 or 1;
    // when (nAdjust == 0): (a - nAdjust < b) <==> (a <  b)  (*)
    // when (nAdjust == 1): (a - nAdjust < b) <==> (a <= b)  (**)
    // When at least one of rects to intersect is empty, and the empty
    // rect lies on boundary of the other, then we consider that the
    // rects DO intersect - in this case nAdjust == 0 and we use (*).
    // If both rects are not empty, and rects touch, then we should
    // consider that they DO NOT intersect and in that case nAdjust is
    // 1 and we use (**).
    //
    int nAdjust;

    Assert (prRes && pr1 && pr2);
    Assert (pr1->left <= pr1->right && pr1->top <= pr1->bottom &&
            pr2->left <= pr2->right && pr2->top <= pr2->bottom);

    prRes->left  = max (pr1->left,  pr2->left);
    prRes->right = min (pr1->right, pr2->right);
    nAdjust = (int) ( (pr1->left != pr1->right) && (pr2->left != pr2->right) );
    if (prRes->right - nAdjust < prRes->left)
        goto NoIntersect;

    prRes->top    = max (pr1->top,  pr2->top);
    prRes->bottom = min (pr1->bottom, pr2->bottom);
    nAdjust = (int) ( (pr1->top != pr1->bottom) && (pr2->top != pr2->bottom) );
    if (prRes->bottom - nAdjust < prRes->top)
        goto NoIntersect;

    return TRUE;

NoIntersect:
    SetRect (prRes, 0,0,0,0);
    return FALSE;
}

#if DBG == 1
//
// because IntersectRectE is quite fragile on boundary cases and these
// cases are not obvious, and also because bugs on these boundary cases
// would manifest in a way difficult to debug, we use this function to
// assert (in debug build only) that the function returns results we
// expect.
//
void
AssertIntersectRectE ()
{
    struct  ASSERTSTRUCT
    {
        RECT    r1;
        RECT    r2;
        RECT    rResExpected;
        BOOL    fResExpected;
    };

    ASSERTSTRUCT ts [] =
    {
        //  r1                  r2                  rResExpected      fResExpected
        // 1st non-empty, no intersect
        { {  0,  2, 99,  8 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },
        { {  0, 22, 99, 28 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },
        // 1st non-empty, intersect
        { {  0,  2, 99, 18 }, {  0, 10, 99, 20 }, {  0, 10, 99, 18 }, TRUE  },
        { {  0, 12, 99, 28 }, {  0, 10, 99, 20 }, {  0, 12, 99, 20 }, TRUE  },
        { {  0, 12, 99, 18 }, {  0, 10, 99, 20 }, {  0, 12, 99, 18 }, TRUE  },
        { {  0,  2, 99, 28 }, {  0, 10, 99, 20 }, {  0, 10, 99, 20 }, TRUE  },
        // 1st non-empty, touch
        { {  0,  2, 99, 10 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },
        { {  0, 20, 99, 28 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },

        // 1st empty, no intersect
        { {  0,  2, 99,  2 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },
        { {  0, 28, 99, 28 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },
        // 1st empty, intersect
        { {  0, 12, 99, 12 }, {  0, 10, 99, 20 }, {  0, 12, 99, 12 }, TRUE  },
        // 1st empty, touch
        { {  0, 10, 99, 10 }, {  0, 10, 99, 20 }, {  0, 10, 99, 10 }, TRUE  },
        { {  0, 20, 99, 20 }, {  0, 10, 99, 20 }, {  0, 20, 99, 20 }, TRUE  },

        // both empty
        { {  0, 10, 99, 10 }, {  0, 10, 99, 10 }, {  0, 10, 99, 10 }, TRUE  }
    };

    ASSERTSTRUCT *  pts;
    RECT            r1;
    RECT            r2;
    RECT            rResActual;
    RECT            rResExpected;
    BOOL            fResActual;
    int             c;

    for (
        c = ARRAY_SIZE(ts), pts = &ts[0];
        c;
        c--, pts++)
    {
        // test
        fResActual = IntersectRectE(&rResActual, &pts->r1, &pts->r2);
        if (!EqualRect(&rResActual, &pts->rResExpected) || fResActual != pts->fResExpected)
            goto Failed;

        // now swap rects and test
        fResActual = IntersectRectE(&rResActual, &pts->r2, &pts->r1);
        if (!EqualRect(&rResActual, &pts->rResExpected) || fResActual != pts->fResExpected)
            goto Failed;

        // now swap left<->top and right<->bottom
        //   swapped left         top           right           bottom
        SetRect (&r1, pts->r1.top, pts->r1.left, pts->r1.bottom, pts->r1.right);
        SetRect (&r2, pts->r2.top, pts->r2.left, pts->r2.bottom, pts->r2.right);
        SetRect (&rResExpected, pts->rResExpected.top, pts->rResExpected.left, pts->rResExpected.bottom, pts->rResExpected.right);

        // test
        fResActual = IntersectRectE(&rResActual, &r1, &r2);
        if (!EqualRect(&rResActual, &rResExpected) || fResActual != pts->fResExpected)
            goto Failed;

        // now swap rects and test
        fResActual = IntersectRectE(&rResActual, &r2, &r1);
        if (!EqualRect(&rResActual, &rResExpected) || fResActual != pts->fResExpected)
            goto Failed;

    }

    return;

Failed:
    Assert (0 && "IntersectRectE returns an unexpected result");
}
#endif

// ===========================  CLed  =====================================================


void CLed::SetNoMatch()
{
    _cpMatchNew  = _cpMatchOld  =
    _iliMatchNew = _iliMatchOld =
    _yMatchNew   = _yMatchOld   = MAXLONG;
}


//-------------------- Start: Code to implement background recalc in lightwt tasks

class CRecalcTask : public CTask
{
public:

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CRecalcTask))

    CRecalcTask (CDisplay *pdp, DWORD grfLayout)
    {
        _pdp = pdp ;
        _grfLayout = grfLayout;
    }

    virtual void OnRun (DWORD dwTimeOut)
    {
        _pdp->StepBackgroundRecalc (dwTimeOut, _grfLayout) ;
    }

    virtual void OnTerminate () {}

private:
    CDisplay *_pdp ;
    DWORD     _grfLayout;
} ;

//-------------------- End: Code to implement background recalc in lightwt tasks


// ===========================  CDisplay  =====================================================

CDisplay::~CDisplay()
{
    // The recalc task should have disappeared during the detach!
    Assert (!HasBgRecalcInfo() && !RecalcTask());
}

CElement *
CDisplay::GetFlowLayoutElement() const
{
    return GetFlowLayout()->ElementContent();
}

CMarkup * CDisplay::GetMarkup() const
{
    return GetFlowLayout()->GetContentMarkup();
}

CDisplay::CDisplay ()
{
#if DBG==1
    _pFL = CONTAINING_RECORD(this, CFlowLayout, _dp);
#endif

    _fRecalcDone = TRUE;

#if DBG == 1
    AssertIntersectRectE ();
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDisplay::Init
//
//  Synopsis:   Initializes CDisplay
//
//  Returns:    TRUE - initialization succeeded
//              FALSE - initalization failed
//
//+----------------------------------------------------------------------------
BOOL CDisplay::Init()
{
    CFlowLayout * pFL = GetFlowLayout();

    Assert( _yCalcMax     == 0 );        // Verify allocation zeroed memory out
    Assert( _xWidth       == 0 );
    Assert( _yHeight      == 0 );
    Assert( RecalcTask()  == NULL );

    SetWordWrap(pFL->GetWordWrap());

    _xWidthView = 0;

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Do stuff before dying
//
//-------------------------------------------------------------------------
void
CDisplay::Detach()
{
    // If there's a timer on, get rid of it before we detach the
    // object. This prevents us from trying to recalc the lines
    // after the CTxtSite has gone away.
    FlushRecalc();
}

/*
 *  CDisplay::GetFirstCp
 *
 *  @mfunc
 *      Return the first cp
 */
LONG
CDisplay::GetFirstCp() const
{
    return GetFlowLayout()->GetContentFirstCp();
}

/*
 *  CDisplay::GetLastCp
 *
 *  @mfunc
 *      Return the last cp
 */
LONG
CDisplay::GetLastCp() const
{
    return GetFlowLayout()->GetContentLastCp();
}

/*
 *  CDisplay::GetMaxCpCalced
 *
 *  @mfunc
 *      Return the last cp calc'ed. Note that this is
 *      relative to the start of the site, not the story.
 */
LONG
CDisplay::GetMaxCpCalced() const
{
    return GetFlowLayout()->GetContentFirstCp() + _dcpCalcMax;
}


inline BOOL
CDisplay::AllowBackgroundRecalc(CCalcInfo * pci, BOOL fBackground)
{
    CFlowLayout * pFL = GetFlowLayout();

#ifdef SWITCHES_ENABLED
    if (IsSwitchNoBgRecalc())
        return(FALSE);
#endif

#if DBG == 1
    if(IsTagEnabled(tagDisableBackground))
        return FALSE;
#endif

    // Allow background recalc when:
    //  a) Not currently calcing in the background
    //  b) It is a SIZEMODE_NATURAL request
    //  c) The CTxtSite does not size to its contents
    //  d) The site is not part of a print document
    //  e) The site allows background recalc
    //  f) This is handled by an external layout.
    //  g) Needs background recalc (see. NeedBackgroundRecalc).
    if (    !fBackground
        && (pci->_smMode == SIZEMODE_NATURAL)
        && !(pci->_grfLayout & LAYOUT_NOBACKGROUND)
        && !pFL->_fContentsAffectSize
        && !pFL->GetAutoSize()
        && !(   pFL->_fHasMarkupPtr
             && pFL->GetOwnerMarkup()->IsPrintMedia())
        && !pFL->TestClassFlag(CElement::ELEMENTDESC_NOBKGRDRECALC) )
    {
        CTreeNode           * pNode = pFL->GetFirstBranch(); 
        const CFancyFormat  * pFF   = pNode->GetFancyFormat();
        const CCharFormat   * pCF   = pNode->GetCharFormat(); 

        return (
        // (olego IEv60 bug 30250) CalcSizeEx for vertical layouts initiates calc with 
        // LAYOUT_FORCE, this may cause infinite loop if backgorund recalc is allowed:
        //
        //         +--> background calc --> element resize --+
        //         |                                         |
        //         +------ calc size with LAYOUT_FORCE <-----+ 
        // 
                    !pCF->HasVerticalLayoutFlow() 
                &&  !(pCF->_fHasBgImage && pFF->GetBgPosY().IsPercent())    );
    }
    return FALSE;
}


/*
 *  CDisplay::FlushRecalc()
 *
 *  @mfunc
 *      Destroys the line array, therefore ensure a full recalc next time
 *      RecalcView or UpdateView is called.
 *
 */
void CDisplay::FlushRecalc()
{
    CFlowLayout * pFL = GetFlowLayout();

    StopBackgroundRecalc();
    ClearStoredRFEs();

    if (LineCount())
    {
        Forget();
        Remove(0, -1, AF_KEEPMEM);          // Remove all old lines from *this
    }

    TraceTag((tagRelDispNodeCache, "SN: (%d) FlushRecalc:: invalidating rel line cache",
                                GetFlowLayout()->SN()));

    pFL->_fContainsRelative   = FALSE;
    pFL->CancelChanges();

    VoidRelDispNodeCache();
    DestroyFlowDispNodes();

    _fRecalcDone = FALSE;
    _yCalcMax   = 0;                        // Set both maxes to start of text
    _dcpCalcMax = 0;                        // Relative to the start cp of site.
    _xWidth     = 0;
    _yHeight    = 0;
    _yHeightMax = 0;

    _fLastLineAligned = 
    _fContainsHorzPercentAttr =
    _fContainsVertPercentAttr =
    _fNavHackPossible      =
    _fHasLongLine =
    _fHasMultipleTextNodes = FALSE;
    _fHasNegBlockMargins = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     NoteMost
//
//  Purpose:    Notes if the line has anything which will need us to compute
//              information for negative lines/absolute or relative divs
//
//----------------------------------------------------------------------------
void
CDisplay::NoteMost(CLineFull *pli)
{
    Assert (pli);

    if (   !_fRecalcMost
        && (   pli->GetYMostTop() < 0
            || pli->GetYHeightBottomOff() > 0
            || pli->_fHasAbsoluteElt
           )
       )
    {
        _fRecalcMost = TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     RecalcMost
//
//  Purpose:    Calculates the most negative line and most positive/negative
//              positioned site from scratch.
//
//  NOTE (sujalp): We initially had an incremental way of computing both the
//  negative line hts info AND +/- positioned site info. However, this logic was
//  incorrect for consecutive lines with -ve line height. So we changed it so
//  that we compute this AND +/- info always. If this becomes a performance issue
//  we could go back for incremental computation for div's easily -- but would
//  have to maintain extra state information. For negative line heights we could
//  also do some incremental stuff, but it would be much much more complicated
//  than what we have now.
//
//----------------------------------------------------------------------------
void
CDisplay::RecalcMost()
{

    if (_fRecalcMost)
    {
        LONG ili;

        long yNegOffset = 0;        // offset at which the current line is drawn
                                    // as a result of a series of lines with negative
                                    // height
        long yPosOffset = 0;

        long yBottomOffset = 0;     // offset by which the current lines contents
                                    // extend beyond the yHeight of the line.
        long yTopOffset = 0;        // offset by which the current lines contents
                                    // extend before the current y position

        _yMostNeg = 0;
        _yMostPos = 0;

        for (ili = 0; ili < LineCount(); ili++)
        {
            CLineCore *pli = Elem(ili);
            CLineOtherInfo *ploi = pli->oi();
            LONG yLineBottomOffset = pli->GetYHeightBottomOff(ploi);

            // top offset of the current line
            yTopOffset = pli->GetYMostTop(ploi) + yNegOffset;

            yBottomOffset = yLineBottomOffset + yPosOffset;

            // update the most negative value if the line has negative before space
            // or line height < actual extent
            if(yTopOffset < 0 && _yMostNeg > yTopOffset)
            {
                _yMostNeg = yTopOffset;
            }

            if (yBottomOffset > 0 && _yMostPos < yBottomOffset)
            {
                _yMostPos = yBottomOffset;
            }

            // if the current line forces a new line and has negative height
            // update the negative offset at which the next line is drawn.
            if(pli->_fForceNewLine)
            {
                if(pli->_yHeight < 0)
                {
                    yNegOffset += pli->_yHeight;
                }
                else
                {
                    yNegOffset = 0;
                }

                if (yLineBottomOffset > 0)
                {
                    yPosOffset += yLineBottomOffset;
                }
                else
                {
                    yPosOffset = 0;
                }
            }
        }

        _fRecalcMost = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     RecalcPlainTextSingleLine
//
//  Purpose:    A high-performance substitute for RecalcView. Does not go
//              through Line Services. Can only be used to measure a single
//              line of plain text (i.e. no HTML).
//
//----------------------------------------------------------------------------

BOOL
CDisplay::RecalcPlainTextSingleLine(CCalcInfo * pci)
{
    CFlowLayout *       pFlowLayout = GetFlowLayout();
    CTreeNode *         pNode       = pFlowLayout->GetFirstBranch();
    TCHAR               chPassword  = pFlowLayout->GetPasswordCh();
    long                cch         = pFlowLayout->GetContentTextLength();
    const CCharFormat * pCF         = pNode->GetCharFormat(LC_TO_FC(pci->GetLayoutContext()));
    const CParaFormat * pPF         = pNode->GetParaFormat(LC_TO_FC(pci->GetLayoutContext()));
    CCcs                ccs;
    const CBaseCcs *    pBaseCcs = NULL;
    long                lWidth;
    long                lCharWidth;
    long                xShift;
    long                xWidth, yHeight;
    long                lPadding[SIDE_MAX];
    BOOL                fViewChanged = FALSE;
    CLineFull           lif;
    CLineCore *         pli;
    UINT                uJustified;
    long                xDummy, yBottomMarginOld = _yBottomMargin;

    //There is no difference between MMWIDTH or MINWIDTH - they are the same
    //and even the max width == min width because there are no line breaks.
    //(for plain text, single line case that we are dealing with) 
    BOOL                fMinMax = (   pci->_smMode == SIZEMODE_MMWIDTH 
                                   || pci->_smMode == SIZEMODE_MINWIDTH
                                  );  

    Assert(pPF);
    Assert(pCF);
    Assert(pci);
    Assert(cch >= 0);

    if (!pPF || !pCF || !pci || cch < 0)
        return FALSE;

    // Bail out if there is anything special in the format that can not be done here
    if (    pCF->IsTextTransformNeeded()
        ||  !pCF->_cuvLineHeight.IsNullOrEnum()
        ||  !pCF->_cuvLetterSpacing.IsNullOrEnum()
        ||  !pCF->_cuvWordSpacing.IsNullOrEnum()
        ||  pCF->_fRTL)
    {
        goto HardCase;
    }


    if (!fc().GetCcs(&ccs, pci->_hdc, pci, pCF))
        return FALSE;
    pBaseCcs = ccs.GetBaseCcs();
    
    lWidth = 0;

    if (cch)
    {
        if (chPassword)
        {
            if (!ccs.Include(chPassword, lCharWidth) )
            {
                Assert(0 && "Char not in font!");
            }
            lWidth = cch * lCharWidth;
        }
        else
        {
            CTxtPtr     tp(GetMarkup(), pFlowLayout->GetContentFirstCp());
            LONG        cchValid;
            LONG        cchRemaining = cch;

            for (;;)
            {
                const TCHAR * pchText = tp.GetPch(cchValid);
                LONG i = min(cchRemaining, cchValid);

                while (i--)
                {
                    const TCHAR ch = *pchText++;

                    // Bail out if not a simple ASCII char

                    if (!InRange( ch, 32, 127 ))
                        goto HardCase;

                    if (!ccs.Include(ch, lCharWidth))
                    {
                        Assert(0 && "Char not in font!");
                    }
                    lWidth += lCharWidth;
                }

                if (cchRemaining <= cchValid)
                {
                    break;
                }
                else
                {
                    cchRemaining -= cchValid;
                    tp.AdvanceCp(cchValid);
                }
            }
        }
    }

    GetPadding(pci, lPadding, fMinMax);
    FlushRecalc();

    pli = Add(1, NULL);
    if (!pli)
        return FALSE;

    lif.Init();
    lif._cch               = cch;
    lif._xWidth            = lWidth;
    lif._yTxtDescent       = pBaseCcs->_yDescent;
    lif._yDescent          = pBaseCcs->_yDescent;
    lif._xLineOverhang     = pBaseCcs->_xOverhang;
    lif._yExtent           = pBaseCcs->_yHeight;
    lif._yBeforeSpace      = lPadding[SIDE_TOP];
    lif._yHeight           = pBaseCcs->_yHeight + lif._yBeforeSpace;
    lif._xLeft             = lPadding[SIDE_LEFT];
    lif._xRight            = lPadding[SIDE_RIGHT];
    lif._xLeftMargin       = 0;
    lif._xRightMargin      = 0;
    lif._fForceNewLine     = TRUE;
    lif._fFirstInPara      = TRUE;
    lif._fFirstFragInLine  = TRUE;
    lif._fCanBlastToScreen = !chPassword && !pCF->_fDisabled;

    _yBottomMargin  = lPadding[SIDE_BOTTOM];
    _dcpCalcMax     = cch;

    yHeight          = lif._yHeight;
    xWidth           = lif.CalcLineWidth();

    xShift = ComputeLineShift(
                        (htmlAlign)pPF->GetBlockAlign(TRUE),
                        IsRTLDisplay(),
                        pPF->HasRTL(TRUE),
                        fMinMax,
                        _xWidthView,
                        xWidth + GetCaret(),
                        &uJustified,
                        &xDummy);

    lif._fJustified = uJustified;
    
    lif._xLeft  += xShift;
    xWidth      += xShift;

    // In RTL display, save shift if it is negative (that won't happen in LTR)
    if (IsRTLDisplay() && xShift < 0)
        lif._xNegativeShiftRTL = xShift;

    lif._xLineWidth = max(xWidth, _xWidthView);

    pli->AssignLine(lif);
    
    if(yHeight + yBottomMarginOld != _yHeight + _yBottomMargin || xWidth != _xWidth)
        fViewChanged = TRUE;

    _yCalcMax       =
    _yHeightMax     =
    _yHeight        = yHeight;
    _xWidth         = xWidth;
    _fRecalcDone    = TRUE;
    _fMinMaxCalced  = TRUE;
    _xMinWidth      =
    _xMaxWidth      = _xWidth + GetCaret();

    if ((   pci->_smMode == SIZEMODE_NATURAL 
         || pci->_smMode == SIZEMODE_NATURALMIN
        )
        && fViewChanged
       )
    {
        pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));

        //This function is only used to calc text inside INPUT tag and 
        //only when full calc is invoked. In this case, we have to request
        //resize in parent, if parent is not calcing us at the moment 
        //(this check is inside CElement::ResizeElement()).
        //This is needed when INPUT got a change in something like font-size
        //and therefore its default size changed. this causes INPUT layout to 
        //be queued for measurement and it will receive DoLayout() call.
        //If this will cause full text recalc, we'll get here and request recalc 
        //in parent. IE6 bug 2823.
        Assert(pFlowLayout->ElementOwner()->Tag() == ETAG_INPUT);
        ElementResize(pFlowLayout, TRUE);

        pFlowLayout->NotifyMeasuredRange(pFlowLayout->GetContentFirstCp(),
                                         GetMaxCpCalced());
    }

    ccs.Release();

    return TRUE;

HardCase:

    ccs.Release();

    // Just do it the hard way
    return RecalcLines(pci);
}

#if 0
//+---------------------------------------------------------------------------
//
//  Member:     RecalcPlainTextSingleLine
//
//  Purpose:    A high-performance substitute for RecalcView. Does not go
//              through Line Services. Can only be used to measure a single
//              line of plain text (i.e. no HTML).
//
//----------------------------------------------------------------------------
BOOL
CDisplay::RecalcPlainTextSingleLineEx(CCalcInfo * pci)
{
    CFlowLayout *       pFlowLayout = GetFlowLayout();
    CTreeNode *         pNode       = pFlowLayout->GetFirstBranch();
    TCHAR               chPassword  = pFlowLayout->GetPasswordCh();
    long                cch         = pFlowLayout->GetContentTextLength();
    const CCharFormat * pCF         = pNode->GetCharFormat(LC_TO_FC(pci->GetLayoutContext()));
    const CParaFormat * pPF         = pNode->GetParaFormat(LC_TO_FC(pci->GetLayoutContext()));
    CCcs                ccs;
    const CBaseCcs *    pBaseCcs = NULL;
    long                lWidth;
    long                lCharWidth;
    long                xShift;
    long                xWidth, yHeight;
    long                lPadding[SIDE_MAX];
    BOOL                fViewChanged = FALSE;
    CLineFull           lif;
    CLineCore *         pli;
    UINT                uJustified;
    long                xDummy, yBottomMarginOld = _yBottomMargin;
    LONG                xWidthView = GetAvailableWidth();
    
    //There is no difference between MMWIDTH or MINWIDTH - they are the same
    //and even the max width == min width because there are no line breaks.
    //(for plain text, single line case that we are dealing with) 
    BOOL                fMinMax = (   pci->_smMode == SIZEMODE_MMWIDTH 
                                   || pci->_smMode == SIZEMODE_MINWIDTH
                                  );  

    Assert(pPF);
    Assert(pCF);
    Assert(pci);
    Assert(cch >= 0);

    if (!pPF || !pCF || !pci || cch < 0)
        return FALSE;

    // Bail out if there is anything special in the format that can not be done here
    if (    pCF->IsTextTransformNeeded()
        ||  !pCF->_cuvLineHeight.IsNullOrEnum()
        ||  !pCF->_cuvLetterSpacing.IsNullOrEnum()
        ||  pCF->_fRTL)
    {
        goto HardCase;
    }


    if (!fc().GetCcs(&ccs, pci->_hdc, pci, pCF))
        return FALSE;
    pBaseCcs = ccs.GetBaseCcs();

    lWidth = 0;

    if (cch)
    {
        if (chPassword)
        {
            if (!ccs.Include(chPassword, lCharWidth) )
            {
                Assert(0 && "Char not in font!");
            }
            lWidth = cch * lCharWidth;
        }
        else
        {
            CTxtPtr     tp(GetMarkup(), pFlowLayout->GetContentFirstCp());
            LONG        cchValid;
            LONG        cchRemaining = cch;
            GetTreeExtent
            for (;;)
            {
                const TCHAR * pchText = tp.GetPch(cchValid);
                LONG i = min(cchRemaining, cchValid);

                while (i--)
                {
                    const TCHAR ch = *pchText++;

                    // Bail out if not a simple ASCII char

                    if (!InRange( ch, 32, 127 ))
                        goto HardCase;

                    if (!ccs.Include(ch, lCharWidth))
                    {
                        Assert(0 && "Char not in font!");
                    }
                    lWidth += lCharWidth;
                    if (lWidth > xWidthView)
                        goto HardCase;
                }

                if (cchRemaining <= cchValid)
                {
                    break;
                }
                else
                {
                    cchRemaining -= cchValid;
                    tp.AdvanceCp(cchValid);
                }
            }
        }
    }

    GetPadding(pci, lPadding, fMinMax);
    FlushRecalc();

    pli = Add(1, NULL);
    if (!pli)
        return FALSE;

    lif.Init();
    lif._cch               = cch;
    lif._xWidth            = lWidth;
    lif._yTxtDescent       = pBaseCcs->_yDescent;
    lif._yDescent          = pBaseCcs->_yDescent;
    lif._xLineOverhang     = pBaseCcs->_xOverhang;
    lif._yExtent           = pBaseCcs->_yHeight;
    lif._yBeforeSpace      = lPadding[SIDE_TOP];
    lif._yHeight           = pBaseCcs->_yHeight + lif._yBeforeSpace;
    lif._xLeft             = lPadding[SIDE_LEFT];
    lif._xRight            = lPadding[SIDE_RIGHT];
    lif._xLeftMargin       = 0;
    lif._xRightMargin      = 0;
    lif._fForceNewLine     = TRUE;
    lif._fFirstInPara      = TRUE;
    lif._fFirstFragInLine  = TRUE;
    lif._fCanBlastToScreen = !chPassword && !pCF->_fDisabled;

    _yBottomMargin  = lPadding[SIDE_BOTTOM];
    _dcpCalcMax     = cch;

    yHeight          = lif._yHeight;
    xWidth           = lif.CalcLineWidth();

    xShift = ComputeLineShift(
                              (htmlAlign)pPF->GetBlockAlign(TRUE),
                              IsRTLDisplay(),
                              pPF->HasRTL(TRUE),
                              fMinMax,
                              _xWidthView,
                              xWidth + GetCaret(),
                              &uJustified,
                              &xDummy);

    lif._fJustified = uJustified;

    lif._xLeft  += xShift;
    xWidth      += xShift;

    // In RTL display, save shift if it is negative (that won't happen in LTR)
    if (IsRTLDisplay() && xShift < 0)
        lif._xNegativeShiftRTL = xShift;

    lif._xLineWidth = max(xWidth, _xWidthView);

    pli->AssignLine(lif);

    if(yHeight + yBottomMarginOld != _yHeight + _yBottomMargin || xWidth != _xWidth)
        fViewChanged = TRUE;

    _yCalcMax       =
    _yHeightMax     =
    _yHeight        = yHeight;
    _xWidth         = xWidth;
    _fRecalcDone    = TRUE;
    _fMinMaxCalced  = TRUE;
    _xMinWidth      =
    _xMaxWidth      = _xWidth + GetCaret();

    if ((   pci->_smMode == SIZEMODE_NATURAL 
         || pci->_smMode == SIZEMODE_NATURALMIN
        )
        && fViewChanged
       )
    {
        pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));

        //This function is only used to calc text inside INPUT tag and 
        //only when full calc is invoked. In this case, we have to request
        //resize in parent, if parent is not calcing us at the moment 
        //(this check is inside CElement::ResizeElement()).
        //This is needed when INPUT got a change in something like font-size
        //and therefore its default size changed. this causes INPUT layout to 
        //be queued for measurement and it will receive DoLayout() call.
        //If this will cause full text recalc, we'll get here and request recalc 
        //in parent. IE6 bug 2823.
        Assert(pFlowLayout->ElementOwner()->Tag() == ETAG_INPUT);
        ElementResize(pFlowLayout, TRUE);

        pFlowLayout->NotifyMeasuredRange(pFlowLayout->GetContentFirstCp(),
                                         GetMaxCpCalced());
    }

    ccs.Release();

    return TRUE;

HardCase:

    ccs.Release();

    // Just do it the hard way
    return RecalcLines(pci);
}
#endif

/*
 *  CDisplay::RecalcLines()
 *
 *  @mfunc
 *      Recalc all line breaks.
 *      This method does a lazy calc after the last visible line
 *      except for a bottomless control
 *
 *  @rdesc
 *      TRUE if success
 */

BOOL CDisplay::RecalcLines(CCalcInfo * pci)
{
#ifdef SWITCHES_ENABLED
    if (IsSwitchNoRecalcLines())
        return FALSE;
#endif

    SwitchesBegTimer(SWITCHES_TIMER_RECALCLINES);

    BOOL fRet;

    if (GetFlowLayout()->ElementOwner()->IsInMarkup())
    {
        if (        pci->_fTableCalcInfo
                    && ((CTableCalcInfo *) pci)->_pme
          WHEN_DBG( && !IsTagEnabled(tagTableCalcDontReuseMeasurer) ) )
        {
            // Save calcinfo's measurer.
            CTableCalcInfo * ptci = (CTableCalcInfo *) pci;
            CLSMeasurer * pme = ptci->_pme;

            // Reinitialize the measurer.
            pme->Reinit(this, ptci);

            // Make sure noone else uses this measurer.
            ptci->_pme = NULL;

            // Do actual RecalcLines work with this measurer.
            fRet = RecalcLinesWithMeasurer(ptci, pme);

            // Restore TableCalcInfo measurer.
            ptci->_pme = pme;
        }
        else
        {
            // Cook up measurer on the stack.
            CLSMeasurer me(this, pci);

            fRet = RecalcLinesWithMeasurer(pci, &me);
        }

        //
        // Update descent of the layout (descent of the last text line)
        //
        if (GetFlowLayout()->Tag() != ETAG_IFRAME)
        {
            LONG yLayoutDescent = 0;
            for (LONG i = Count() - 1; i >= 0; i--)
            {
                CLineCore * pli = Elem(i);

                // need to test the pli && OI() calls to prevent stress crash
                if (pli && pli->IsTextLine())
                {

                    yLayoutDescent = pli->oi() ? pli->oi()->_yDescent : 0;
                    break;
                }
            }
            GetFlowLayout()->_yDescent = yLayoutDescent;
        }
        else
        {
            GetFlowLayout()->_yDescent = 0;
        }
    }
    else
        fRet = FALSE;

    SwitchesEndTimer(SWITCHES_TIMER_RECALCLINES);

    return fRet;
}

/*
 *  CDisplay::RecalcLines()
 *
 *  @mfunc
 *      Recalc all line breaks.
 *      This method does a lazy calc after the last visible line
 *      except for a bottomless control
 *
 *  @rdesc
 *      TRUE if success
 */

BOOL CDisplay::RecalcLinesWithMeasurer(CCalcInfo * pci, CLSMeasurer * pme)
{
#ifdef SWITCHES_ENABLED
    if (IsSwitchNoRecalcLines())
        return FALSE;
#endif

    CFlowLayout * pFlowLayout = GetFlowLayout();
    CElement    * pElementFL  = pFlowLayout->ElementOwner();
    CElement::CLock     Lock(pElementFL, CElement::ELEMENTLOCK_RECALC);

    CRecalcLinePtr  RecalcLinePtr(this, pci);
    CLineCore *     pliNew    = NULL;
    int             iLine     = -1;
    int             iLinePrev = -1;
    long            yHeightPrev;
    UINT            uiMode;
    UINT            uiFlags;
    BOOL            fDone                   = TRUE;
    BOOL            fFirstInPara            = TRUE;
    BOOL            fWaitForCpToBeCalcedTo  = TRUE;
    LONG            cpToBeCalcedTo          = 0;
    BOOL            fAllowBackgroundRecalc;
    LONG            yHeight         = 0;
    LONG            yAlignDescent   = 0;
    LONG            yHeightView     = GetViewHeight();
    LONG            xMinLineWidth   = 0;
    LONG *          pxMinLineWidth  = NULL;
    LONG            xMaxLineWidth   = 0;
    LONG            yHeightDisplay  = 0;     // to keep track of line with top negative margins
    LONG            yHeightOld      = _yHeight;
    LONG            yHeightMaxOld   = _yHeightMax;
    LONG            xWidthOld       = _xWidth;
    LONG            yBottomMarginOld= _yBottomMargin;
    BOOL            fViewChanged    = FALSE;
    BOOL            fNormalMode     = pci->IsNaturalMode();
    CDispNode *     pDNBefore;
    long            lPadding[SIDE_MAX];
    CLayoutContext * pLayoutContext = pci->GetLayoutContext();
    BOOL             fDoBreaking =  pLayoutContext                      // tells if breaking should be applied.
                                &&  pLayoutContext->ViewChain() 
                                &&  pFlowLayout->ElementCanBeBroken() 
                                &&  pci->_smMode != SIZEMODE_MMWIDTH 
                                &&  pci->_smMode != SIZEMODE_NATURALMIN;

    // we should not be measuring hidden stuff.
    Assert(!pElementFL->IsDisplayNone(LC_TO_FC(pci->GetLayoutContext())));

    Assert(pElementFL->Tag() != ETAG_ROOT);

    if (!pme->_pLS)
        return FALSE;

    if (!pElementFL->IsInMarkup())
    {
        return TRUE;
    }

    ClearStoredRFEs();

    //  TODO: (olego, tracking bug 111963) in print preview we should take into 
    //  acount top margin only for the first page and never do so for bottom margin
    GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);
    _yBottomMargin = lPadding[SIDE_BOTTOM];

    // Set up the CCalcInfo to the correct mode and parent size
    if (pci->_smMode == SIZEMODE_SET)
    {
        pci->_smMode = SIZEMODE_NATURAL;
    }

    // Determine the mode
    uiMode = MEASURE_BREAKATWORD;

    Assert (pci);

    switch(pci->_smMode)
    {
    case SIZEMODE_MMWIDTH:
    case SIZEMODE_NATURALMIN:
        uiMode |= MEASURE_MAXWIDTH;
        _xMinWidth = 0;
        pxMinLineWidth = &xMinLineWidth;
        break;
    case SIZEMODE_MINWIDTH:
        uiMode |= MEASURE_MINWIDTH;
        pme->AdvanceToNextAlignedObject();
        break;
    }

    uiFlags = uiMode;

    // Determine if background recalc is allowed
    // (And if it is, do not calc past the visible portion)
    fAllowBackgroundRecalc = AllowBackgroundRecalc(pci);

    if (fAllowBackgroundRecalc)
    {
        cpToBeCalcedTo = max(GetFirstVisibleCp(), CPWait());
    }
    
    // Flush all old lines
    FlushRecalc();

    pme->_pDispNodePrev = NULL;

    if (fAllowBackgroundRecalc)
    {
        if (!SUCCEEDED(EnsureBgRecalcInfo()))
        {
            fAllowBackgroundRecalc = FALSE;
            AssertSz(FALSE, "CDisplay::RecalcLinesWithMeasurer - Could not create BgRecalcInfo");
        }
    }

    RecalcLinePtr.Init((CLineArray *)this, 0, NULL);

    // recalculate margins
    RecalcLinePtr.RecalcMargins(0, 0, yHeight, 0);

    if (pElementFL->IsDisplayNone(LC_TO_FC(pci->GetLayoutContext())))
    {
        pliNew = RecalcLinePtr.AddLine();
        if (!pliNew)
        {
            Assert(FALSE);
            goto err;
        }
        pme->NewLine(uiFlags & MEASURE_FIRSTINPARA);
        pme->_li._cch = pElementFL->GetElementCch();

        // Finally copy the line over
        pliNew->AssignLine(pme->_li);
    }
    else
    {
        // MULTI_LAYOUT - Determine if this element has been partially measured
        LONG             cpCur   = 0;
        LONG             cpStart = -1;     // starting cp for current layout rect. May be -1 which means 
                                           // all content has been calculated previously and line loop should 
                                           // be skipped
        int             cyAvail = pci->_cyAvail - _yBottomMargin;
        BOOL            fHasContent = 0;

        LONG            xPadLeftCur = 0;
        LONG            xPadRightCur = 0;

        LAYOUT_OVERFLOWTYPE   overflowTypePrev = LAYOUT_OVERFLOWTYPE_OVERFLOW; // break type for previous break
        LAYOUT_OVERFLOWTYPE   overflowTypeCurr; // break type for current break

        CFlowLayoutBreak * pEndingBreak = NULL; //  ending (resulting) break for the calculations
        CElement         * pElementCausedPageBreakBefore = NULL;

        AssertSz(pci->_yConsumed == 0, "Improper CCalcInfo members handling ???");
        AssertSz(CHK_CALCINFO_PPV(pci), "PPV members of CCalcInfo should stay untouched in browse mode !");

        //  fDoBreaking == TRUE means that this layout is slave and is a part of a chain and is breakable. 
        //  So we need to do partial measurement.

        if (fDoBreaking)
        {
            CLayoutBreak *  pLayoutBreak; 

            // Create the ending entry and put it into break table to make it available during 
            // calculation. (RecalcLinePtr code needs it to save floating and aligned object)
            pEndingBreak = DYNCAST(CFlowLayoutBreak, pLayoutContext->CreateBreakForLayout(pFlowLayout));
            Assert(pEndingBreak && "Could not create a break !!!");

            if (pEndingBreak)
            {
                //  By default make it layout complete entry. 
                //  If we reach layout overflow we'll change it.
                pEndingBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LAYOUTCOMPLETE, LAYOUT_OVERFLOWTYPE_UNDEFINED);
                pLayoutContext->SetLayoutBreak(pElementFL, pEndingBreak);
            }

            // We need to know where to pick up measurement; GetBreak actually fetches the break entry
            // for the layout rect _before_ us (hence letting us know whether anyone before us has measured
            // part of this element already).
            //  if pLayoutBreak == NULL this is the very first container. 
            pLayoutContext->GetLayoutBreak(pElementFL, &pLayoutBreak);

            if (pLayoutBreak == NULL)
            {
                cpStart          = pme->GetCp();
                overflowTypePrev = LAYOUT_OVERFLOWTYPE_OVERFLOW;
            }
            else if (pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
            {
                //  retrieve starting position for this container.
                CFlowLayoutBreak *pFlowLayoutBreak = DYNCAST(CFlowLayoutBreak, pLayoutBreak);

                cpStart = pFlowLayoutBreak->GetMarkupPointer()->GetCp();
                pme->Advance(cpStart - pFlowLayout->GetContentFirstCp());
                overflowTypePrev = pLayoutBreak->OverflowType();
                pElementCausedPageBreakBefore = pFlowLayoutBreak->_pElementPBB;

                RecalcLinePtr._xPadLeft  = pFlowLayoutBreak->GetPadLeft();
                RecalcLinePtr._xPadRight = pFlowLayoutBreak->GetPadRight();

                if (   !pFlowLayoutBreak->HasSiteTasks()
                    && RecalcLinePtr._marginInfo._xLeftMargin < pFlowLayoutBreak->GetLeftMargin()  )
                {
                    RecalcLinePtr._marginInfo._xLeftMargin = pFlowLayoutBreak->GetLeftMargin();
                    RecalcLinePtr._marginInfo._yLeftMargin = 1;
                    RecalcLinePtr._marginInfo._yBottomLeftMargin = 0;
                }

                if (   !pFlowLayoutBreak->HasSiteTasks()
                    && RecalcLinePtr._marginInfo._xRightMargin < pFlowLayoutBreak->GetRightMargin()  )
                {
                    RecalcLinePtr._marginInfo._xRightMargin = pFlowLayoutBreak->GetRightMargin();
                    RecalcLinePtr._marginInfo._yRightMargin = 1;
                    RecalcLinePtr._marginInfo._yBottomRightMargin = 0;
                }
            }

            //  cpStart == -1 only if content has been calculated already
            Assert(   cpStart != -1 
                   || (pLayoutBreak && pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LAYOUTCOMPLETE));
        }

        if (!fDoBreaking || -1 < cpStart)
        // The following loop generates new lines
        do
        {
            // Add one new line
            if (fDoBreaking && pEndingBreak)
            {
                // pci->_yConsumed is used by the breaking code to determine the available height in the 
                // parent in order to determine where to break;
                // yHeight : accumulates the height of the currently measured lines
                // _yBottomMargin  : is unusable space so count it as part of the current Height
                //
                pci->_yConsumed = yHeight + _yBottomMargin;

                // remember current cp
                cpCur = pme->GetCp();

                // and padding 
                xPadLeftCur  = RecalcLinePtr._xPadLeft;
                xPadRightCur = RecalcLinePtr._xPadRight;

                //  and if there is a content
                fHasContent = pci->_fHasContent;
            }

            pliNew = RecalcLinePtr.AddLine();
            if (!pliNew)
            {
                Assert(FALSE);
                goto err;
            }

            uiFlags &= ~MEASURE_FIRSTINPARA;
            uiFlags |= (fFirstInPara ? MEASURE_FIRSTINPARA : 0);

            PerfDbgLog1(tagRecalc, this, "Measuring new line from cp = %d", pme->GetCp());

            iLine = LineCount() - 1;

            if (long(pme->GetCp()) == pme->GetLastCp())
            {
                uiFlags |= MEASURE_EMPTYLASTLINE;
            }

            //
            // Cache the previous dispnode to insert a new content node
            // if the next line measured has negative margins(offset) which
            // causes the next line on top of the previous lines.
            //
            pDNBefore = pme->_pDispNodePrev;
            iLinePrev = iLine;
            yHeightPrev = yHeight;

            if(!RecalcLinePtr.MeasureLine(*pme, uiFlags,
                                            &iLine, &yHeight, &yAlignDescent,
                                            pxMinLineWidth, &xMaxLineWidth))
            {
                goto err;
            }

            //
            // iLine returned is the last text line inserted. There may be
            // aligned lines and clear lines added before and after the
            // text line
            //
            pliNew = iLine >=0 ? RecalcLinePtr[iLine] : NULL;
            Assert(pliNew ? pme->_li == *pliNew : TRUE);
            _fHasLongLine |= pliNew && (pliNew->_xWidth > SHRT_MAX);

            if (fDoBreaking && pEndingBreak)
            {
                ////////////////////////////////////////////////////////////////////////////
                // a-naande winse 25520 9-17-2002
                // if there's content, there must be height
                // add the height on so page breaks can be properly calculated
                if(yHeight == 0 && fHasContent && pme)
                {
                    yHeight += pme->_li._yHeight;
                }
                /////////////////////////////////////////////////////////////////////////////

                if (
                    // page-break-before condition
                       (overflowTypeCurr = LAYOUT_OVERFLOWTYPE_PAGEBREAKBEFORE, 
                           pliNew
                        && pliNew->_fPageBreakBefore
                        && pElementCausedPageBreakBefore != pEndingBreak->_pElementPBB 
                        )
                    // overflow condition
                    || (overflowTypeCurr = LAYOUT_OVERFLOWTYPE_OVERFLOW, 
                        //  TODO: (olego,tracking bug 111963) : what is our vertical restriction here ? 
                        //  In CFlowLayout::MeasureSize CDisplay::GetViewWidthAndHeightForChild 
                        //  counts top and bottom padding while calc height available for child. 
                        //  If the whole _yHeightView counts here so available height for child 
                        //  in MeasureSite could be negative !!! 
                        //  Should we count top and bottom padding's for very first and very 
                        //  last layout rect only ???
                       yHeight > cyAvail 
                        //  Do break only if there is at least one line in this rect.
                       && fHasContent 
                        //  this means our child consumed all available height
                       || pci->_fLayoutOverflow)
                    // page-break-after condition
                    || (overflowTypeCurr = LAYOUT_OVERFLOWTYPE_PAGEBREAKAFTER, 
                           pliNew
                        && pliNew->_fPageBreakAfter
                        //  (bug #100239)
                        /*&& pme->GetCp() < pme->GetLastCp()*/)
                    )
                {   
                    //
                    // We have finished with this block, do breaking here
                    //
                    {
                        Assert(pEndingBreak && "Ending break must be created at this point !!!");

                        CMarkupPointer  * pmkpPtr;
                        // Create a new markup pointer at this cp.
                        pmkpPtr = new CMarkupPointer(GetFlowLayout()->Doc());
                        if (pmkpPtr)
                        {
                            pEndingBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LINKEDOVERFLOW, overflowTypeCurr);
                            
                            if (overflowTypeCurr == LAYOUT_OVERFLOWTYPE_PAGEBREAKAFTER)
                            {
                                pmkpPtr->MoveToCp(pme->GetCp(), GetMarkup());
                                pEndingBreak->SetFlowLayoutBreak(pmkpPtr, 0, 0, 
                                    RecalcLinePtr._xPadLeft, RecalcLinePtr._xPadRight);
                            }
                            else 
                            {
                                pmkpPtr->MoveToCp(cpCur, GetMarkup());
                                pEndingBreak->SetFlowLayoutBreak(pmkpPtr, 
                                    cpCur == cpStart ? 0 : RecalcLinePtr._marginInfo._xLeftMargin, 
                                    cpCur == cpStart ? 0 : RecalcLinePtr._marginInfo._xRightMargin, 
                                    xPadLeftCur, 
                                    xPadRightCur);

                                if (    0 < iLinePrev 
                                    &&  pEndingBreak->HasSiteTasks()    ) 
                                {
                                    Assert(Elem(iLinePrev - 1));
                                    CLineCore *pLine = Elem(iLinePrev - 1);

                                    if (pLine->IsClear())
                                    {
                                        CLineOtherInfo *ploi = pLine->oi(); 

                                        pEndingBreak->_fClearLeft   = ploi->_fClearLeft;
                                        pEndingBreak->_fClearRight  = ploi->_fClearRight;
                                        pEndingBreak->_fAutoClear   = ploi->_fAutoClear;
                                    }
                                }
                            }
                        }
                    }

                    if (    overflowTypeCurr != LAYOUT_OVERFLOWTYPE_PAGEBREAKAFTER 
                        //  this means our child consumed all available height
                        && (    overflowTypeCurr != LAYOUT_OVERFLOWTYPE_OVERFLOW 
                            || !pci->_fLayoutOverflow)   )
                    {
                        // TODO: (olego, text team, tracking bug 111968): Make RecalcLine transactional
                        // This is kind of HACK because of CRecalcLinePtr::MeasureLine also adds 
                        // current line into array by default.
                        // This means we need to undo the effects of measuring that
                        // line, and remove it from the line array so when the next
                        // layout measures it, it will be the only one referring to
                        // this content.
                        UndoMeasure( pci->GetLayoutContext(), cpCur, pme->GetCp() );
                        pme->_pDispNodePrev = pDNBefore;

                        // iLinePrev contains the starting line's index from 
                        // which lines should be removed from the array
                        while (iLine >= iLinePrev)
                        {
                            Assert(Elem(iLine));
                            Forget(iLine, 1);
                            Remove(iLine, 1, AF_DELETEMEM);
                            --iLine;
                        }
                        Assert(iLine == (iLinePrev - 1));
                        Assert(iLine >= 0 || LineCount() == 0);

                        yHeight = yHeightPrev;

                        pme->Advance(cpCur - pme->GetCp());

                        if (LineCount() == 0)
                        {
                            // if there is no lines in the array set _fNoContent
                            _fNoContent = TRUE;
                            pliNew      = NULL;
                        }
                        else 
                        {
                            pliNew = Elem(iLine);
                        }
                    }
                    else 
                    {
                        pci->_fHasContent = TRUE;
                    }

                    pci->_fLayoutOverflow = TRUE;
                    break;
                }
                //  TODO: (olego, tracking bug 111984) the check below should be placed out of the loop. 
                //  But because of measurer implementation if a layout has a child and child did break 
                //  (which means only part of content was calced) we will return with 
                //  pme->GetCp() == pme->GetLastCp(). 
                else if (pme->GetCp() == pme->GetLastCp())
                {
                    Assert(pEndingBreak && "Ending break must be created at this point !!!");
                    if (pEndingBreak->HasSiteTasks())
                    {
                        //  We do not have our own content but there are site tasks (floating objets)
                        CMarkupPointer  * pmkpPtr;
                        // Create a new markup pointer at this cp.
                        pmkpPtr = new CMarkupPointer(GetFlowLayout()->Doc());
                        if (pmkpPtr)
                        {
                            // Set the markup to point to this cp:
                            pmkpPtr->MoveToCp(pme->GetCp(), GetMarkup());

                            pEndingBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LINKEDOVERFLOW, LAYOUT_OVERFLOWTYPE_OVERFLOW);
                            pEndingBreak->SetFlowLayoutBreak(pmkpPtr, 0, 0, 0, 0);
                        }

                        pci->_fLayoutOverflow = TRUE;
                    }
                }

                //  only layouts that are allowed to break may set this flag
                pci->_fHasContent = TRUE;
            }
            // end MULTI_LAYOUT - break determination

            // fix for bug 16519 (srinib)
            // Keep track of the line that contributes to the max height, ex: if the
            // last lines top margin is negative.
            if(yHeightDisplay < yHeight)
                yHeightDisplay = yHeight;

            fFirstInPara = (iLine >= 0)
                                ? pme->_li.IsNextLineFirstInPara()
                                : TRUE;

            if (fNormalMode && iLine >= 0)
            {
                HandleNegativelyPositionedContent(&pme->_li, pme, pDNBefore, iLinePrev, yHeightPrev);
            }

            if (fAllowBackgroundRecalc)
            {
                Assert(HasBgRecalcInfo());

                if (fWaitForCpToBeCalcedTo)
                {
                    if ((LONG)pme->GetCp() > cpToBeCalcedTo)
                    {
                        BgRecalcInfo()->_yWait  = yHeight + yHeightView;
                        fWaitForCpToBeCalcedTo = FALSE;
                    }
                }

                else if (yHeightDisplay > YWait())
                {
                    fDone = FALSE;
                    break;
                }
            }

            // When doing a full min pass, just calculate the islands around aligned
            // objects. Note that this still calc's the lines around right aligned
            // images, which isn't really necessary because they are willing to
            // overlap text. Fix it next time.
            if ((uiMode & MEASURE_MINWIDTH) &&
                !RecalcLinePtr._marginInfo._xLeftMargin &&
                !RecalcLinePtr._marginInfo._xRightMargin )
                pme->AdvanceToNextAlignedObject();

        } while( pme->GetCp() < pme->GetLastCp());
    }

    _fRecalcDone = fDone;

    if(fDone && pliNew)
    {
        // This assert doesn't hold when page breaking so avoid it in that case.
        Assert(fDoBreaking ||  pme->_li == *pliNew);

        if (   GetFlowLayout()->IsEditable() // if we are in design mode
            && (   pme->_li._fHasEOP
                || pme->_li._fHasBreak
                || pme->_li._fSingleSite
               )
           )
        {
            Assert(pliNew == RecalcLinePtr[iLine]);
            CreateEmptyLine(pme, &RecalcLinePtr, &yHeight, pme->_li._fHasEOP );

            // Creating the line could have reallocated the memory to which pliNew points,
            // so we need to refresh the pointer just in case.
            pliNew = RecalcLinePtr[iLine];
        }

        // fix for bug 16519
        // Keep track of the line that contributes to the max height, ex: if the
        // last lines top margin is negative.
        if(yHeightDisplay < yHeight)
            yHeightDisplay = yHeight;

        // In table cells, Netscape actually adds the interparagraph spacing
        // for any closed tags to the height of the table cell.
        // NOTE: This actually applies the spacing to all nested text containers, not just
        //         table cells. Is this correct? (brendand).
        // It's not correct to add the spacing at all, but given that Netscape
        // has done so, and that they will probably do so for floating block
        // elements. Arye.
        else if (!pLayoutContext)   //  check for !pLayoutContext added (bug # 91086; # 102747) 
                                    //  Do Netscape compatibility dances only in browse mode. 
        {
            int iLineLast = iLine;
            
            // we need to force scrolling when bottom-margin is set on the last block tag
            // in body. (20400)

            while (iLineLast-- > 0 &&   // Lines available
                   !pliNew->_fForceNewLine)   // Just a dummy line.
                --pliNew;
            if (iLineLast > 0 || pliNew->_fForceNewLine)
                _yBottomMargin += RecalcLinePtr.NetscapeBottomMargin(pme);
        }
    }

    if (!(uiMode & MEASURE_MAXWIDTH))
    {
        xMaxLineWidth = CalcDisplayWidth();
    }

    _dcpCalcMax = (LONG)pme->GetCp() - GetFirstCp();
    _yCalcMax   = 
    _yHeight    = yHeightDisplay;
    _yHeightMax = max(yHeightDisplay, yAlignDescent);
    _xWidth     = xMaxLineWidth;

    //
    // Fire a resize notification if the content size changed
    //  
    // fix for 52305, change to margin bottom affects the content size,
    // so we should fire a resize.
    //
    if(     _yHeight    != yHeightOld
        ||  _yHeightMax + _yBottomMargin != yHeightMaxOld + yBottomMarginOld
        ||  _xWidth     != xWidthOld)
    {
        fViewChanged = TRUE;
    }

    {
        BOOL fAlignedLayouts =    RecalcLinePtr._cLeftAlignedLayouts
                               || (RecalcLinePtr._cRightAlignedLayouts > 1);
        if(pxMinLineWidth)
        {
            // We don't need min pass during calcsize in case of vertical layout flow.
            pFlowLayout->MarkHasAlignedLayouts(fAlignedLayouts && !GetFlowLayout()->GetFirstBranch()->GetCharFormat()->HasVerticalLayoutFlow());
        }
        if (fAlignedLayouts)
            _fNoContent = FALSE;
    }

    // If the view or size changed, re-size or update scrollbars as appropriate
    if ( fViewChanged || _fHasMultipleTextNodes || pci->_fNeedToSizeContentDispNode)
    {
        if (pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN)
        {
            pci->_fNeedToSizeContentDispNode = FALSE;
            pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));

            // If our contents affects our size, ask our parent to initiate a re-size
            if ( fViewChanged )
                ElementResize(pFlowLayout, FALSE);
        }
        else if ( pci->_smMode == SIZEMODE_MMWIDTH )
        {
            // We don't resize dispnodes in minmax mode, but we want to
            // do it next time, so light up a flag (ugh..).  (IE6 #73601)
            // (dmitryt): this hack actually workarounds the fact that CFlowLayout::CalcTextSize
            // sets the display width (calling SetViewSize) but sometimes skips to update the
            // size of content dispnode - if it choose the codepath with RecalcLineShift.
            // This was happening when after minmax pass (no optimization, go through RecalcLines)
            // we failed to update dispnode on normal pass (optimization, just call to 
            // RecalcLineShift) so someone invented this flag in pci to trigger updating on the 
            // next Normal pass. How it should be done: we should update content dispnode in 
            // the end of CalcTextSize instead of in text calc code and also after each 
            // CDisplay::SetViewSize()/Recalc...() pair. then this falg can be thrown away.
            // Not doing this before shipping Whistler because of risk involved.
            pci->_fNeedToSizeContentDispNode = TRUE;
        }
    }

    if (fNormalMode)
    {
        // Update display nodes for affected relative positioned lines
        if (pFlowLayout->_fContainsRelative)
            UpdateRelDispNodeCache(NULL);

        pFlowLayout->NotifyMeasuredRange(GetFlowLayoutElement()->GetFirstCp(), GetMaxCpCalced());
    }

    if (    !pci->_fCloneDispNode 
        ||  fNormalMode )
    {
        AdjustDispNodes(NULL /*pdnLastUnchanged*/, pme->_pDispNodePrev, NULL/*pled*/);
    }

    PerfDbgLog1(tagRecalc, this, "CDisplay::RecalcLine() - Done. Recalced down to line #%d", LineCount());

    if(!fDone)                      // if not done, do rest in background
    {
        StartBackgroundRecalc(pci->_grfLayout);
    }
    else if (fAllowBackgroundRecalc)
    {
        Assert((!CanHaveBgRecalcInfo() || BgRecalcInfo()) && "Should have a BgRecalcInfo");
        if (HasBgRecalcInfo())
        {
            CBgRecalcInfo * pBgRecalcInfo = BgRecalcInfo();
            pBgRecalcInfo->_yWait = -1;
            pBgRecalcInfo->_cpWait = -1;
        }
#if DBG==1
        if (!(uiMode & MEASURE_MINWIDTH))
            CheckLineArray();
#endif
        _fLineRecalcErr = FALSE;

        RecalcMost();
    }

    // cache min/max only if there are no sites inside !
    if (pxMinLineWidth)
    {
        Assert(!!pme->_fHasNestedLayouts == !!pFlowLayout->ContainsNonHiddenChildLayout());
        if (!pme->_fHasNestedLayouts)
        {
            _xMaxWidth      = _xWidth + GetCaret();
            _fMinMaxCalced  = TRUE;
        }
    }

    // adjust for caret only when are calculating for MMWIDTH or MINWIDTH
    if (pci->_smMode == SIZEMODE_MMWIDTH || pci->_smMode == SIZEMODE_MINWIDTH)
    {
        if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            _xMinWidth = max(_xMinWidth, RecalcLinePtr._xMaxRightAlign);
            _xWidth = max(_xWidth, RecalcLinePtr._xMaxRightAlign);
        }
        _xMinWidth      += GetCaret();  // adjust for caret only when are calculating for MMWIDTH
    }

    // NETSCAPE: If there is no text or special characters, treat the site as
    //           empty. For example, with an empty BLOCKQUOTE tag, _xWidth will
    //           not be zero while the site should be considered empty.
    if(_fNoContent)
    {
        _xWidth =
        _xMinWidth = lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT];
    }

    return TRUE;

err:
    TraceTag((tagError, "CDisplay::RecalcLines() failed"));

    if(!_fLineRecalcErr)
    {
        _dcpCalcMax   = pme->GetCp() - GetFirstCp();
        _yCalcMax = yHeightDisplay;
    }

    return FALSE;
}

/*
 *  CDisplay::RecalcLines(cpFirst, cchOld, cchNew, fBackground, pled)
 *
 *  @mfunc
 *      Recompute line breaks after text modification
 *
 *  @rdesc
 *      TRUE if success
 */


BOOL CDisplay::RecalcLines (
    CCalcInfo * pci,
    LONG cpFirst,               //@parm Where change happened
    LONG cchOld,                //@parm Count of chars deleted
    LONG cchNew,                //@parm Count of chars added
    BOOL fBackground,           //@parm This method called as background process
    CLed *pled,                 //@parm Records & returns impact of edit on lines (can be NULL)
    BOOL fHack)                 //@parm This comes from WaitForRecalc ... don't mess with BgRecalcInfo
{
#ifdef SWITCHES_ENABLED
    if (IsSwitchNoRecalcLines())
        return FALSE;
#endif

    AssertSz(   pci->GetLayoutContext() == NULL 
            ||  pci->GetLayoutContext()->ViewChain() == NULL
            ||  !GetFlowLayout()->ElementCanBeBroken(), 
        "This function should not be called for pagination");

    CSaveCalcInfo       sci(pci);
    CElement::CLock     Lock(GetFlowLayoutElement(), CElement::ELEMENTLOCK_RECALC);

    CFlowLayout * pFlowLayout = GetFlowLayout();
    CElement    * pElementContent  = pFlowLayout->ElementContent();

    LONG        cchEdit;
    LONG        cchSkip = 0;
    INT         cliBackedUp = 0;
    LONG        cliWait = g_cExtraBeforeLazy;
    BOOL        fDone = TRUE;
    BOOL        fFirstInPara = TRUE;
    BOOL        fAllowBackgroundRecalc;
    CLed        led;
    LONG        lT = 0;         // long Temporary
    
    CLineCore * pliNew;
    CLinePtr    rpOld(this);
    CLineCore * pliCur;
    
    LONG        xWidth;
    LONG        yHeight, yAlignDescent=0;
    LONG        cpLast = GetLastCp();
    long        cpLayoutFirst = GetFirstCp();
    UINT        uiFlags = MEASURE_BREAKATWORD;
    BOOL        fReplaceResult = TRUE;
    BOOL        fTryForMatch = TRUE;
    BOOL        fNeedToBackUp = TRUE;
    int         diNonBlankLine = -1;
    int         iOldLine;
    int         iNewLine;
    int         iLinePrev = -1;
    int         iMinimumLinesToRecalc = 4;   // Guarantee some progress
    LONG        yHeightDisplay = 0;
    LONG        yHeightMax;
    CLineArray  aryNewLines;
    CDispNode * pDNBefore;
    CDispNode * pdnLastUnchanged = NULL;
    long        yHeightPrev;
    long        yBottomMarginOld = _yBottomMargin;
    BOOL        fLayoutDescentChanged = FALSE;
    BOOL        yLayoutDescent;

#if DBG==1
    LONG        cp;
#endif

    if (!pFlowLayout->ElementOwner()->IsInMarkup())
    {
        return TRUE;
    }

    SwitchesBegTimer(SWITCHES_TIMER_RECALCLINES);

    // we should not be measuring hidden stuff.
    Assert(!pFlowLayout->ElementOwner()->IsDisplayNone(LC_TO_FC(pci->GetLayoutContext())));

    // If no lines, this routine should not be called
    // Call the other RecalcLines above instead !
    Assert(LineCount() > 0);

    ClearStoredRFEs();

    // Set up the CCalcInfo to the correct mode and parent size
    if (pci->_smMode == SIZEMODE_SET)
    {
        pci->_smMode = SIZEMODE_NATURAL;
    }

    // Init measurer at cpFirst
    CLSMeasurer     me(this, cpFirst, pci);

    CRecalcLinePtr  RecalcLinePtr(this, pci);

    if (!me._pLS)
        goto err;

    if (!pled)
        pled = &led;

#if DBG==1
    if(cpFirst > GetMaxCpCalced())
        TraceTag((tagError, "cpFirst %ld, CalcMax %ld", cpFirst, GetMaxCpCalced()));

    AssertSz(cpFirst <= GetMaxCpCalced(),
        "CDisplay::RecalcLines Caller didn't setup RecalcLines()");
#endif

    // Determine if background recalc is allowed
    fAllowBackgroundRecalc = AllowBackgroundRecalc(pci, fBackground);

    Assert(!fBackground || HasBgRecalcInfo());
    if (    !fBackground
        &&  !fHack
        &&  fAllowBackgroundRecalc)
    {
        if (SUCCEEDED(EnsureBgRecalcInfo()))
        {
            BgRecalcInfo()->_yWait  = pFlowLayout->GetClientBottom();
            BgRecalcInfo()->_cpWait = -1;
        }
        else
        {
            fAllowBackgroundRecalc = FALSE;
            AssertSz(FALSE, "CDisplay::RecalcLines - Could not create BgRecalcInfo");
        }
    }

    // Init line pointer on old CLineArray
    rpOld.RpSetCp(cpFirst, FALSE, FALSE);

    pliCur = rpOld.CurLine();

    while(pliCur->IsClear() ||
          (pliCur->IsFrame() && !pliCur->_fFrameBeforeText))
    {
        if(!rpOld.AdjustBackward())
            break;

        pliCur = rpOld.CurLine();
    }

    // If the current line has single site
    if(pliCur->_fSingleSite)
    {
        // If we are in the middle of the current line (some thing changed
        // in a table cell or 1d-div, or marquee)
        if(rpOld.RpGetIch() && rpOld.GetCchRemaining() != 0)
        {
            // we dont need to back up
            if(rpOld > 0 && rpOld[-1]._fForceNewLine)
            {
                fNeedToBackUp = FALSE;
                cchSkip = rpOld.RpGetIch();
            }
        }
    }

    iOldLine = rpOld;

    if(fNeedToBackUp)
    {
        if(!rpOld->IsBlankLine())
        {
            cchSkip = rpOld.RpGetIch();
            if(cchSkip)
                rpOld.RpAdvanceCp(-cchSkip);
        }

        // find the first previous non blank line, if the first non blank line
        // is a single site line or a line with EOP, we don't need to skip.
        while(rpOld + diNonBlankLine >= 0 &&
                rpOld[diNonBlankLine].IsBlankLine())
            diNonBlankLine--;

        // (srinib) - if the non text line does not have a line break or EOP, or
        // a force newline or is single site line and the cp at which the characters changed is
        // ambiguous, we need to back up.

        // if the single site line does not force a new line, we do need to
        // back up. (bug #44346)
        while(fNeedToBackUp)
        {
            LONG rpAtStartOfLoop;
            
            if (rpOld + diNonBlankLine >= 0)
            {
                pliCur = &rpOld[diNonBlankLine];
                if(!pliCur->_fSingleSite || !pliCur->_fForceNewLine || cchSkip == 0)
                {
                    // Skip past all the non text lines
                    while(diNonBlankLine++ < 0)
                        rpOld.AdjustBackward();

                    //TODO: (dmitryt, tracking bug 111969) 
                    //This whole loop should be cleaned up sometimes.
                    //The purpose of it is to go back as needed to find a point where to start
                    //recalc. It menas to skip all aligned sites, blank lines etc until we 
                    //find a normal text line. The code here is mostly historic and needs to
                    //be cleaned significantly (after 5.5)
                    
                    while(rpOld->IsClear() ||
                          (rpOld->IsFrame() && !rpOld->_fFrameBeforeText))
                    {
                        if(!rpOld.AdjustBackward())
                            break;
                    }

                    //Skip to the begining of the line
                    //(dmitryt) Check for 0 because RpAdvanceCp gets confused on Frame lines when cch==0
                    //that happens because it tries to skip those Frame lines but tries to guess
                    //direction of skipping looking at sign of cch, and this is ambiguous when cch==0
                    //and plain wrong here. 
                    cchSkip += rpOld.RpGetIch();
                    if(cchSkip != 0)    
                        rpOld.RpAdvanceCp(-rpOld.RpGetIch());
                    
                    rpAtStartOfLoop = rpOld;

                    // we want to skip all the lines that do not force a
                    // newline, so find the last line that does not force a new line.

                    //
                    // Also, back up in the following case:
                    // If we have moved the bullet down from the previous lines, then
                    // we should go calc those lines since they will cause us to have
                    // a bullet. (Bullets are transferred via a bit on the
                    // recalclineptr, so if we do not calc the previous lines then
                    // we will not light up the bit). Also, all the lines which
                    // transmitted the bullet bit down have to have the trasmit bit on.
                    //
                    long diTmpLine = -1;
                    long cchSkipTemp = 0;
                    while(   rpOld + diTmpLine >=0
                          && ((pliCur = &rpOld[diTmpLine]) != 0)
                          && (  !pliCur->_fForceNewLine
                              || pliCur->_fHasTransmittedLI
                             )
                         )
                    {
                        if(  !pliCur->IsBlankLine()
                           || pliCur->_fHasTransmittedLI
                          )
                        {
                            cchSkipTemp += pliCur->_cch;
                        }
                        diTmpLine--;
                    }

                    if(cchSkipTemp)
                    {
                        cchSkip += cchSkipTemp;
                        rpOld.RpAdvanceCp(-cchSkipTemp);
                    }
                }
                else
                    rpAtStartOfLoop = rpOld;
            }
            else
                rpAtStartOfLoop = rpOld;

            // back up further if the previous lines are either frames inserted
            // by aligned sites at the beginning of the line or auto clear lines
            while(   rpOld
                  && ((pliCur = &rpOld[-1]) != 0)
                  && (   pliCur->_fClearBefore          // frame line before the actual text or
                      || (   pliCur->IsFrame()
                          && pliCur->_fFrameBeforeText
                         )
                     )
                  && rpOld.AdjustBackward()
                 );

            // Setup ourselvs for the next pass thru this.
            diNonBlankLine = -1;
            fNeedToBackUp = rpAtStartOfLoop > rpOld;
        }
    }

    cliBackedUp = iOldLine - rpOld;

    // Need to get a running start.
    me.Advance(-cchSkip);
    RecalcLinePtr.InitPrevAfter(&me._fLastWasBreak, rpOld);

    cchEdit = cchNew + cchSkip;         // Number of chars affected by edit

    Assert(cchEdit <= GetLastCp() - long(me.GetCp()) );
    if (cchEdit > GetLastCp() - long(me.GetCp()))
    {
        // NOTE: (istvanc) this of course shouldn't happen (see assert above)!!!!!!!!
        cchEdit = GetLastCp() - me.GetCp();
    }

    // Determine whether we're on first line of paragraph
    if(rpOld > 0)
    {
        int iLastNonFrame = -1;

        // frames do not hold any info, so go back past all frames.
        while(rpOld + iLastNonFrame && (rpOld[iLastNonFrame].IsFrame() || rpOld[iLastNonFrame].IsClear()))
            iLastNonFrame--;
        if(rpOld + iLastNonFrame >= 0)
        {
            CLineCore *pliNew = &rpOld[iLastNonFrame];

            fFirstInPara = pliNew->IsNextLineFirstInPara();
        }
        else
        {
            // we are at the Beginning of a document
            fFirstInPara = TRUE;
        }
    }

    yHeight = YposFromLine(pci, rpOld, &yHeightDisplay);
    yAlignDescent = 0;

    // Update first-affected and pre-edit-match lines in pled
    pled->_iliFirst = rpOld;
    pled->_cpFirst  = pled->_cpMatchOld = me.GetCp();
    pled->_yFirst   = pled->_yMatchOld  = yHeight;

    //
    // In the presence of negative margins and negative line heights, its no
    // longer possible to verify the following statement (bug 28255).
    // I have also verified that it being negative does not cause any other
    // problems in the code that utilizes its value (SujalP).
    //
    // AssertSz(pled->_yFirst >= 0, "CDisplay::RecalcLines _yFirst < 0");

    PerfDbgLog2(tagRecalc, this, "Start recalcing from line #%d, cp=%d",
              pled->_iliFirst, pled->_cpFirst);

    // In case of error, set both maxes to where we are now
    _yCalcMax   = yHeight;
    _dcpCalcMax = me.GetCp() - cpLayoutFirst;

    //
    // find the display node the corresponds to cpStart
    //
    me._pDispNodePrev = pled->_iliFirst
                            ? GetPreviousDispNode(pled->_cpFirst, pled->_iliFirst)
                            : 0;
    pdnLastUnchanged = me._pDispNodePrev;


    // If we are past the requested area to recalc and background recalc is
    // allowed, then just go directly to background recalc.
    if (    fAllowBackgroundRecalc
        &&  yHeight > YWait()
        &&  (LONG) me.GetCp() > CPWait())
    {
        // Remove all old lines from here on
        Forget(rpOld.GetIRun(), -1);
        rpOld.RemoveRel(-1, AF_KEEPMEM);

        // Start up the background recalc
        StartBackgroundRecalc(pci->_grfLayout);
        pled->SetNoMatch();

        // Update the relative line cache.
        if (pFlowLayout->_fContainsRelative)
            UpdateRelDispNodeCache(NULL);

        // Adjust display nodes
        AdjustDispNodes(pdnLastUnchanged, me._pDispNodePrev, pled);

        goto cleanup;
    }

    aryNewLines.Forget();
    aryNewLines.Clear(AF_KEEPMEM);
    pliNew = NULL;

    iOldLine = rpOld;
    RecalcLinePtr.Init((CLineArray *)this, iOldLine, &aryNewLines);

    // recalculate margins
    RecalcLinePtr.RecalcMargins(iOldLine, iOldLine, yHeight, 0);

    Assert ( cchEdit <= GetLastCp() - long(me.GetCp()) );

    if(iOldLine)
        RecalcLinePtr.SetupMeasurerForBeforeSpace(&me, yHeight);

    // The following loop generates new lines for each line we backed
    // up over and for lines directly affected by edit
    while(cchEdit > 0)
    {
        LONG iTLine;
        LONG cpTemp;
        pliNew = RecalcLinePtr.AddLine();       // Add one new line
        if (!pliNew)
        {
            Assert(FALSE);
            goto err;
        }

        // Stuff text into new line
        uiFlags &= ~MEASURE_FIRSTINPARA;
        uiFlags |= (fFirstInPara ? MEASURE_FIRSTINPARA : 0);

        PerfDbgLog1(tagRecalc, this, "Measuring new line from cp = %d", me.GetCp());

        // measure can add lines for aligned sites
        iNewLine = iOldLine + aryNewLines.Count() - 1;

        // save the index of the new line to added
        iTLine = iNewLine;

#if DBG==1
        {
            // Just so we can see the  text.
            const TCHAR *pch;
            long cchInStory = (long)GetFlowLayout()->GetContentTextLength();
            long cp = (long)me.GetCp();
            long cchRemaining =  cchInStory - cp;
            CTxtPtr tp(GetMarkup(), cp);
            pch = tp.GetPch(cchRemaining);
#endif

        cpTemp = me.GetCp();

        if (cpTemp == pFlowLayout->GetContentLastCp() - 1)
        {
            uiFlags |= MEASURE_EMPTYLASTLINE;
        }

        //
        // Cache the previous dispnode to insert a new content node
        // if the next line measured has negative margins(offset) which
        // causes the next line on top of the previous lines.
        //
        pDNBefore = me._pDispNodePrev;
        iLinePrev = iNewLine;
        yHeightPrev = yHeight;

        if (!RecalcLinePtr.MeasureLine(me, uiFlags,
                                       &iNewLine, &yHeight, &yAlignDescent,
                                       NULL, NULL
                                       ))
        {
            goto err;
        }

        //
        // iNewLine returned is the last text line inserted. There ay be
        // aligned lines and clear lines added before and after the
        // text line
        //
        pliNew = iNewLine >=0 ? RecalcLinePtr[iNewLine] : NULL;
        Assert(me._li == *pliNew);
        fFirstInPara = (iNewLine >= 0)
                            ? me._li.IsNextLineFirstInPara()
                            : TRUE;
        _fHasLongLine |= pliNew && (pliNew->_xWidth > SHRT_MAX);

#if DBG==1
        }
#endif
        // fix for bug 16519 (srinib)
        // Keep track of the line that contributes to the max height, ex: if the
        // last lines top margin is negative.
        if(yHeightDisplay < yHeight)
            yHeightDisplay = yHeight;

        if (iNewLine >= 0)
        {
            HandleNegativelyPositionedContent(&me._li, &me, pDNBefore, iLinePrev, yHeightPrev);
        }

        // If we have added any clear lines, iNewLine points to a textline
        // which could be < iTLine
        if(iNewLine >= iTLine)
            cchEdit -= me.GetCp() - cpTemp;

        if(cchEdit <= 0)
            break;

        --iMinimumLinesToRecalc;
        if(iMinimumLinesToRecalc < 0 &&
           fBackground && (GetTickCount() >= BgndTickMax())) // GetQueueStatus(QS_ALLEVENTS))
        {
            fDone = FALSE;                      // took too long, stop for now
            goto no_match;
        }

        if (    fAllowBackgroundRecalc
            &&  yHeight > YWait()
            &&  (LONG) me.GetCp() > CPWait()
            &&  cliWait-- <= 0)
        {
            // Not really done, just past region we're waiting for
            // so let background recalc take it from here
            fDone = FALSE;
            goto no_match;
        }
    }                                           // while(cchEdit > 0) { }

    PerfDbgLog1(tagRecalc, this, "Done recalcing edited text. Created %d new lines", aryNewLines.Count());

    // Edit lines have been exhausted.  Continue breaking lines,
    // but try to match new & old breaks

    while( (LONG) me.GetCp() < cpLast )
    {
        // Assume there are no matches to try for
        BOOL frpOldValid = FALSE;
        BOOL fChangedLineSpacing = FALSE;

        // If we run out of runs, then there is not match possible. Therefore,
        // we only try for a match as long as we have runs.
        if (fTryForMatch)
        {
            // We are trying for a match so assume that there
            // is a match after all
            frpOldValid = TRUE;

            // Look for match in old line break CArray
            lT = me.GetCp() - cchNew + cchOld;
            while (rpOld.IsValid() && pled->_cpMatchOld < lT)
            {
                if(rpOld->_fForceNewLine)
                    pled->_yMatchOld += rpOld->_yHeight;
                pled->_cpMatchOld += rpOld->_cch;

                BOOL fDone=FALSE;
                BOOL fSuccess = TRUE;
                while (!fDone)
                {
                    if( !rpOld.NextLine(FALSE,FALSE) )     // NextRun()
                    {
                        // No more line array entries so we can give up on
                        // trying to match for good.
                        fTryForMatch = FALSE;
                        frpOldValid = FALSE;
                        fDone = TRUE;
                        fSuccess = FALSE;
                    }
                    if (!rpOld->IsFrame() ||
                            (rpOld->IsFrame() && rpOld->_fFrameBeforeText))
                        fDone = TRUE;
                }
                if (!fSuccess)
                    break;
            }
        }

        // skip frame in old line array
        if (rpOld->IsFrame() && !rpOld->_fFrameBeforeText)
        {
            BOOL fDone=FALSE;
            while (!fDone)
            {
                if (!rpOld.NextLine(FALSE,FALSE))
                {
                    // No more line array entries so we can give up on
                    // trying to match for good.
                    fTryForMatch = FALSE;
                    frpOldValid = FALSE;
                    fDone = TRUE;
                }
                if (!rpOld->IsFrame())
                    fDone = TRUE;
            }
        }

        pliNew = aryNewLines.Count() > 0 ? aryNewLines.Elem(aryNewLines.Count() - 1) : NULL;

        // If perfect match, stop
        if(   frpOldValid
           && rpOld.IsValid()
           && pled->_cpMatchOld == lT
           && rpOld->_cch != 0
           && (   !rpOld->_fPartOfRelChunk  // lines do not match if they are a part of
               || rpOld->_fFirstFragInLine  // the previous relchunk (bug 48513 SujalP)
              )
           && pliNew
           && (pliNew->_fForceNewLine || pliNew->_fDummyLine)
           && (yHeight - pliNew->_yHeight > RecalcLinePtr._marginInfo._yBottomLeftMargin)
           && (yHeight - pliNew->_yHeight > RecalcLinePtr._marginInfo._yBottomRightMargin)
           && !RecalcLinePtr._fMoveBulletToNextLine
          )
        {
            BOOL fFoundMatch = TRUE;

            if(rpOld.oi()->_xLeftMargin || rpOld.oi()->_xRightMargin)
            {
                // we might have found a match based on cp, but if an
                // aligned site is resized to a smaller size. There might
                // be lines that used to be aligned to the aligned site
                // which are not longer aligned to it. If so, recalc those lines.
                RecalcLinePtr.RecalcMargins(iOldLine, iOldLine + aryNewLines.Count(), yHeight,
                                                rpOld.oi()->_yBeforeSpace);
                if(RecalcLinePtr._marginInfo._xLeftMargin != rpOld.oi()->_xLeftMargin ||
                    (rpOld.oi()->_xLeftMargin + rpOld->_xLineWidth +
                        RecalcLinePtr._marginInfo._xRightMargin) < pFlowLayout->GetMaxLineWidth())
                {
                    fFoundMatch = FALSE;
                }
            }

            // There are cases where we've matched characters, but want to continue
            // to recalc anyways. This requires us to instantiate a new measurer.
            if (   fFoundMatch 
                && !fChangedLineSpacing 
                && rpOld < LineCount() 
                && (   rpOld->_fFirstInPara 
                    || pliNew->_fHasEOP
                   )
               )
            {
                BOOL                  fInner;
                const CParaFormat *   pPF;
                CLSMeasurer           tme(this, me.GetCp(), pci);

                if (!tme._pLS)
                    goto err;

                if(pliNew->_fHasEOP)
                {
                    rpOld->_fFirstInPara = TRUE;
                }
                else
                {
                    rpOld->_fFirstInPara = FALSE;
                    rpOld->_fHasBulletOrNum = FALSE;
                }

                // If we've got a <DL COMPACT> <DT> line. For now just check to see if
                // we're under the DL.

                pPF = tme.CurrBranch()->GetParaFormat();

                fInner = SameScope(tme.CurrBranch(), pElementContent);

                if (pPF->HasCompactDL(fInner))
                {
                    // If the line is a DT and it's the end of the paragraph, and the COMPACT
                    // attribute is set.
                    fChangedLineSpacing = TRUE;
                }

                // Check to see if the line height is the same. This is necessary
                // because there are a number of block operations that can
                // change the prespacing of the next line.
                else
                {
                    UINT uiFlags = 0;
                    CSaveRLP saveRLP(&RecalcLinePtr);
                    
                    // We'd better not be looking at a frame here.
                    Assert (!rpOld->IsFrame());

                    // Make it possible to check the line space of the
                    // current line.
                    tme.InitLineSpace (&me, rpOld);

                    RecalcLinePtr.CalcInterParaSpace (&tme,
                            pled->_iliFirst + aryNewLines.Count() - 1, &uiFlags);

                    if (   rpOld.oi()->_yBeforeSpace != tme._li._yBeforeSpace
                        || rpOld->_fHasBulletOrNum != tme._li._fHasBulletOrNum
                       )
                    {
                        rpOld->_fHasBulletOrNum = tme._li._fHasBulletOrNum;

                        fChangedLineSpacing = TRUE;
                    }
                    tme.PseudoLineDisable();
                }
            }
            else
                fChangedLineSpacing = FALSE;


            if (fFoundMatch && !fChangedLineSpacing)
            {
                PerfDbgLog1(tagRecalc, this, "Found match with old line #%d", rpOld.GetLineIndex());
                pled->_iliMatchOld = rpOld;

                // Replace old lines by new ones
                lT = rpOld - pled->_iliFirst;
                rpOld = pled->_iliFirst;

                fReplaceResult = rpOld.Replace(lT, &aryNewLines);
                if (!fReplaceResult)
                {
                    Assert(FALSE);
                    goto err;
                }

                frpOldValid =
                    rpOld.SetRun( rpOld.GetIRun() + aryNewLines.Count(), 0 );

                aryNewLines.Forget();
                aryNewLines.Clear(AF_DELETEMEM);           // Clear aux array
                iOldLine = rpOld;

                // Remember information about match after editing
                Assert((cp = rpOld.GetCp() + cpLayoutFirst) == (LONG) me.GetCp());
                pled->_yMatchNew = yHeight;
                pled->_iliMatchNew = rpOld;
                pled->_cpMatchNew = me.GetCp();

                _dcpCalcMax = me.GetCp() - cpLayoutFirst;

                // Compute height and cp after all matches
                if( frpOldValid && rpOld.IsValid() )
                {
                    do
                    {
                        if(rpOld->_fForceNewLine)
                        {
                            yHeight += rpOld->_yHeight;
                            // fix for bug 16519
                            // Keep track of the line that contributes to the max height, ex: if the
                            // last lines top margin is negative.
                            if(yHeightDisplay < yHeight)
                                yHeightDisplay = yHeight;
                        }
                        else if(rpOld->IsFrame())
                        {
                            yAlignDescent = yHeight + rpOld->_yHeight;
                        }


                        _dcpCalcMax += rpOld->_cch;
                    }
                    // AlexPf:  This continues on far beyond the end of the page!
                    // We should bail out and insert a BREAK in the break table,
                    // And mark the rest of the pages dirty.
                    while( rpOld.NextLine(FALSE,FALSE) ); // NextRun()
                }

                // Make sure _dcpCalcMax is sane after the above update
                AssertSz(GetMaxCpCalced() <= cpLast,
                    "CDisplay::RecalcLines match extends beyond EOF");

                // We stop calculating here.Note that if _dcpCalcMax < size
                // of text, this means a background recalc is in progress.
                // We will let that background recalc get the arrays
                // fully in sync.
                AssertSz(GetMaxCpCalced() <= cpLast,
                        "CDisplay::Match less but no background recalc");

                if (GetMaxCpCalced() != cpLast)
                {
                    // This is going to be finished by the background recalc
                    // so set the done flag appropriately.
                    fDone = FALSE;
                }

                goto match;
            }
        }

        // Add a new line
        pliNew = RecalcLinePtr.AddLine();
        if (!pliNew)
        {
            Assert(FALSE);
            goto err;
        }

        PerfDbgLog1(tagRecalc, this, "Measuring new line from cp = %d", me.GetCp());

        // measure can add lines for aligned sites
        iNewLine = iOldLine + aryNewLines.Count() - 1;

        uiFlags = MEASURE_BREAKATWORD |
                    (yHeight == 0 ? MEASURE_FIRSTLINE : 0) |
                    (fFirstInPara ? MEASURE_FIRSTINPARA : 0);

        if (long(me.GetCp()) == pFlowLayout->GetContentLastCp() - 1)
        {
            uiFlags |= MEASURE_EMPTYLASTLINE;
        }

        //
        // Cache the previous dispnode to insert a new content node
        // if the next line measured has negative margins(offset) which
        // causes the next line on top of the previous lines.
        //
        pDNBefore = me._pDispNodePrev;
        iLinePrev = iNewLine;
        yHeightPrev = yHeight;

        if (!RecalcLinePtr.MeasureLine(me, uiFlags,
                                 &iNewLine, &yHeight, &yAlignDescent,
                                 NULL, NULL
                                 ))
        {
            goto err;
        }

        // fix for bug 16519
        // Keep track of the line that contributes to the max height, ex: if the
        // last lines top margin is negative.
        if(yHeightDisplay < yHeight)
            yHeightDisplay = yHeight;

        //
        // iNewLine returned is the last text line inserted. There ay be
        // aligned lines and clear lines added before and after the
        // text line
        //
        pliNew = iNewLine >=0 ? RecalcLinePtr[iNewLine] : NULL;
        Assert(me._li == *pliNew); 
        fFirstInPara = (iNewLine >= 0)
                            ? me._li.IsNextLineFirstInPara()
                            : TRUE;
        _fHasLongLine |= pliNew && (pliNew->_xWidth > SHRT_MAX);
        if (iNewLine >= 0)
        {
            HandleNegativelyPositionedContent(&me._li, &me, pDNBefore, iLinePrev, yHeightPrev);
        }

        --iMinimumLinesToRecalc;
        if(iMinimumLinesToRecalc < 0 &&
           fBackground &&  (GetTickCount() >= (DWORD)BgndTickMax())) // GetQueueStatus(QS_ALLEVENTS))
        {
            fDone = FALSE;          // Took too long, stop for now
            break;
        }

        if (    fAllowBackgroundRecalc
            &&  yHeight > YWait()
            &&  (LONG) me.GetCp() > CPWait()
            &&  cliWait-- <= 0)
        {                           // Not really done, just past region we're
            fDone = FALSE;          //  waiting for so let background recalc
            break;                  //  take it from here
        }
    }                               // while(me < cpLast ...

no_match:
    // Didn't find match: whole line array from _iliFirst needs to be changed
    // Indicate no match
    pled->SetNoMatch();

    // Update old match position with previous total height of the document so
    // that UpdateView can decide whether to invalidate past the end of the
    // document or not
    pled->_iliMatchOld = LineCount();
    pled->_cpMatchOld  = cpLast + cchOld - cchNew;
    pled->_yMatchOld   = _yHeightMax;

    // Update last recalced cp
    _dcpCalcMax = me.GetCp() - cpLayoutFirst;

    // Replace old lines by new ones
    rpOld = pled->_iliFirst;

    // We store the result from the replace because although it can fail the
    // fields used for first visible must be set to something sensible whether
    // the replace fails or not. Further, the setting up of the first visible
    // fields must happen after the Replace because the lines could have
    // changed in length which in turns means that the first visible position
    // has failed.
    fReplaceResult = rpOld.Replace(-1, &aryNewLines);
    if (!fReplaceResult)
    {
        Assert(FALSE);
        goto err;
    }
    aryNewLines.Forget();
    aryNewLines.Clear(AF_DELETEMEM);           // Clear aux array

    // Adjust first affected line if this line is gone
    // after replacing by new lines

    if(pled->_iliFirst >= LineCount() && LineCount() > 0)
    {
        Assert(pled->_iliFirst == LineCount());
        pled->_iliFirst = LineCount() - 1;
        Assert(!Elem(pled->_iliFirst)->IsFrame());
        pled->_yFirst -= Elem(pled->_iliFirst)->_yHeight;

        //
        // See comment before as to why its legal for this to be possible
        //
        //AssertSz(pled->_yFirst >= 0, "CDisplay::RecalcLines _yFirst < 0");
        pled->_cpFirst -= Elem(pled->_iliFirst)->_cch;
    }

match:
    
    pled->_yExtentAdjust = max(abs(_yMostNeg), abs(_yMostPos));

    // If there is a background on the paragraph, we have to make sure to redraw the
    // lines to the end of the paragraph.
    for (;pled->_iliMatchNew < LineCount();)
    {
        pliNew = Elem(pled->_iliMatchNew);
        if (pliNew)
        {
            if (!pliNew->_fHasBackground)
                break;

            pled->_iliMatchOld++;
            pled->_iliMatchNew++;
            pled->_cpMatchOld += pliNew->_cch;
            pled->_cpMatchNew += pliNew->_cch;
            me.Advance(pliNew->_cch);
            if (pliNew->_fForceNewLine)
            {
                pled->_yMatchOld +=  pliNew->_yHeight;
                pled->_yMatchNew +=  pliNew->_yHeight;
            }
            if (pliNew->_fHasEOP)
                break;
        }
        else
            break;
    }

    _fRecalcDone = fDone;
    _yCalcMax = yHeightDisplay;

    PerfDbgLog1(tagRecalc, this, "CDisplay::RecalcLine(tpFirst, ...) - Done. Recalced down to line #%d", LineCount() - 1);

    if (HasBgRecalcInfo())
    {
        CBgRecalcInfo * pBgRecalcInfo = BgRecalcInfo();
        // Clear wait fields since we want caller's to set them up.
        pBgRecalcInfo->_yWait = -1;
        pBgRecalcInfo->_cpWait = -1;
    }

    // We've measured the last line in the document. Do we want an empty lne?
    if ((LONG)me.GetCp() == cpLast)
    {
        LONG ili = LineCount() - 1;
        long lPadding[SIDE_MAX];

        //
        // Update the padding once we measure the last line
        //
        GetPadding(pci, lPadding);
        _yBottomMargin = lPadding[SIDE_BOTTOM];

        // If we haven't measured any lines (deleted an empty paragraph),
        // we need to get a pointer to the last line rather than using the
        // last line measured.
        while (ili >= 0)
        {
            pliNew = Elem(ili);
            if(pliNew->IsTextLine())
                break;
            else
                ili--;
        }

        // If the last line has a paragraph break or we don't have any
        // line any more, we need to create a empty line only if we are in design mode
        if (    LineCount() == 0
            ||  (   GetFlowLayout()->IsEditable()
                &&  pliNew
                &&  (   pliNew->_fHasEOP
                    ||  pliNew->_fHasBreak
                    ||  pliNew->_fSingleSite)))
        {
            // Only create an empty line after a table (at the end
            // of the document) if the table is completely loaded.
            if (pliNew == NULL ||
                !pliNew->_fSingleSite ||
                me._pRunOwner->Tag() != ETAG_TABLE ||
                DYNCAST(CTableLayout, me._pRunOwner)->IsCompleted())
            {
                RecalcLinePtr.Init((CLineArray *)this, 0, NULL);
                CreateEmptyLine(&me, &RecalcLinePtr, &yHeight,
                                pliNew ? pliNew->_fHasEOP : TRUE);
                // fix for bug 16519
                // Keep track of the line that contributes to the max height, ex: if the
                // last lines top margin is negative.
                if(yHeightDisplay < yHeight)
                    yHeightDisplay = yHeight;
            }
        }

        // In table cells, Netscape actually adds the interparagraph spacing
        // for any closed tags to the height of the table cell.
        // NOTE: This actually applies the spacing to all nested text containers, not just
        //         table cells. Is this correct? (brendand)
        // It's not correct to add the spacing at all, but given that Netscape
        // has done so, and that they will probably do so for floating block
        // elements. Arye.
        else
        {
            int iLineLast = ili;
            
            // we need to force scrolling when bottom-margin is set on the last block tag
            // in body. (bug 20400)

            // Only do this if we're the last line in the text site.
            // This means that the last line is a text line.
            if (iLineLast == LineCount() - 1)
            {
                while (iLineLast-- > 0 &&   // Lines available
                       !pliNew->_fForceNewLine)   // Just a dummy line.
                    --pliNew;
            }
            if (iLineLast > 0 || pliNew->_fForceNewLine)
            {
                _yBottomMargin += RecalcLinePtr.NetscapeBottomMargin(&me);
            }
        }
    }

    if (fDone)
    {
        RecalcMost();

        if(fBackground)
        {
            StopBackgroundRecalc();
        }
    }

    //
    // Update descent of the layout (descent of the last text line)
    //
    if (fDone)
    {
        if (    pFlowLayout->Tag() != ETAG_IFRAME
            && !pFlowLayout->ElementOwner()->TestClassFlag(CElement::ELEMENTDESC_HASDEFDESCENT))
        {
            yLayoutDescent = 0;
            for (LONG i = Count() - 1; i >= 0; i--)
            {
                CLineCore * pli = Elem(i);
                if (pli && pli->IsTextLine())
                {
                    yLayoutDescent = pli->oi() ? pli->oi()->_yDescent : 0;
                    break;
                }
            }
            if (pFlowLayout->_yDescent != yLayoutDescent)
            {
                pFlowLayout->_yDescent = yLayoutDescent;
                fLayoutDescentChanged = TRUE;
            }
        }
        else
        {
            pFlowLayout->_yDescent = 0;
        }
    }

    xWidth = CalcDisplayWidth();
    yHeightMax = max(yHeightDisplay, yAlignDescent);

    Assert (pled);

    // If the size changed, re-size or update scrollbars as appropriate
    //
    // Fire a resize notification if the content size changed
    //  
    // fix for 52305, change to margin bottom affects the content size,
    // so we should fire a resize.
    //
    if (    yHeightMax + yBottomMarginOld != _yHeightMax + _yBottomMargin
        ||  yHeightDisplay != _yHeight
        ||  xWidth != _xWidth
        ||  fLayoutDescentChanged)
    {
        _xWidth       = xWidth;
        _yHeight      = yHeightDisplay;
        _yHeightMax   = yHeightMax;

        pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));

        // If our contents affects our size, ask our parent to initiate a re-size
        ElementResize(pFlowLayout, fLayoutDescentChanged);
    }
    else if (_fHasMultipleTextNodes)
    {
        pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));
    }

    // Update the relative line cache.
    if (pFlowLayout->_fContainsRelative)
        UpdateRelDispNodeCache(pled);

    // Adjust display nodes
    AdjustDispNodes(pdnLastUnchanged, me._pDispNodePrev, pled); 

    pFlowLayout->NotifyMeasuredRange(pled->_cpFirst, me.GetCp());

    if (pled->_cpMatchNew != MAXLONG && (pled->_yMatchNew - pled->_yMatchOld))
    {
        CSize size(0, pled->_yMatchNew - pled->_yMatchOld);

        pFlowLayout->NotifyTranslatedRange(size, pled->_cpMatchNew, cpLayoutFirst + _dcpCalcMax);
    }

    // If not done, do the rest in background
    if(!fDone && !fBackground)
        StartBackgroundRecalc(pci->_grfLayout);

    if(fDone)
    {
        CheckLineArray();
        _fLineRecalcErr = FALSE;
    }

cleanup:

    SwitchesEndTimer(SWITCHES_TIMER_RECALCLINES);

    return TRUE;

err:
    if(!_fLineRecalcErr)
    {
        _dcpCalcMax = me.GetCp() - cpLayoutFirst;
        _yCalcMax   = yHeightDisplay;
        _fLineRecalcErr = FALSE;            //  fix up CArray & bail
    }

    TraceTag((tagError, "CDisplay::RecalcLines() failed"));

    pled->SetNoMatch();

    if(!fReplaceResult)
    {
        FlushRecalc();
    }

    // Update the relative line cache.
    if (pFlowLayout->_fContainsRelative)
        UpdateRelDispNodeCache(pled);

    // Adjust display nodes
    AdjustDispNodes(pdnLastUnchanged, me._pDispNodePrev, pled);

    return FALSE;
}

/*
 *  CDisplay::UpdateView(&tpFirst, cchOld, cchNew, fRecalc)
 *
 *  @mfunc
 *      Recalc lines and update the visible part of the display
 *      (the "view") on the screen.
 *
 *  @devnote
 *      --- Use when in-place active only ---
 *
 *  @rdesc
 *      TRUE if success
 */
BOOL CDisplay::UpdateView(
    CCalcInfo * pci,
    LONG cpFirst,   //@parm Text ptr where change happened
    LONG cchOld,    //@parm Count of chars deleted
    LONG cchNew)   //@parm No recalc need (only rendering change) = FALSE
{
    BOOL            fReturn = TRUE;
    BOOL            fNeedViewChange = FALSE;
    RECT            rcView;
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    CRect           rc;
    long            xWidthParent;
    long            yHeightParent;

    BOOL fInvalAll = FALSE;
    CStackDataAry < RECT, 10 > aryInvalRects(Mt(CDisplayUpdateView_aryInvalRects_pv));

    Assert(pci);

    if (_fNoUpdateView)
        return fReturn;

    // If we have no width, don't even try to recalc, it causes
    // crashes in the scrollbar code, and is just a waste of
    // time, anyway.
    // However, since we're not sized, request sizing from the parent
    // of the ped (this will leave the necessary bread-crumb chain
    // to ensure we get sized later) - without this, not all containers
    // of text sites (e.g., 2D sites) will know to size the ped.
    // (This is easier than attempting to propagate back out that sizing
    //  did not occur.)

    if (    GetViewWidth() <= 0
        && !pFlowLayout->_fContentsAffectSize)
    {
        FlushRecalc();
        return TRUE;
    }


    pFlowLayout->GetClientRect((CRect *)&rcView);

    GetViewWidthAndHeightForChild(pci, &xWidthParent, &yHeightParent);

    pci->SizeToParent(xWidthParent, yHeightParent);

    if (!LineCount())
    {
        // No line yet, recalc everything
        RecalcView(pci, TRUE);

        // Invalidate entire view rect
        fInvalAll = TRUE;
        fNeedViewChange = TRUE;
    }
    else
    {
        CLed            led;

        if( cpFirst > GetMaxCpCalced())
        {
            // we haven't even calc'ed this far, so don't bother with updating
            // here.  Background recalc will eventually catch up to us.
            return TRUE;
        }

        AssertSz(cpFirst <= GetMaxCpCalced(),
                 "CDisplay::UpdateView(...) - cpFirst > GetMaxCpCalced()");

        if (!RecalcLines(pci, cpFirst, cchOld, cchNew, FALSE, &led))
        {
            // we're in deep trouble now, the recalc failed
            // let's try to get out of this with our head still mostly attached
            fReturn = FALSE;
            fInvalAll = TRUE;
            fNeedViewChange = TRUE;
        }

        if (!fInvalAll)
        {
            // Invalidate all the individual rectangles necessary to work around
            // any embedded images. Also, remember if this was a simple or a complex
            // operation so that we can avoid scrolling in difficult places.
            CLineCore * pLine;
            CLineOtherInfo * ploi;
            int     iLine, iLineLast;
            long    xLineLeft, xLineRight, yLineTop, yLineBottom;
            long    yTop;
            long    dy = led._yMatchNew - led._yMatchOld;
            BOOL    fNextToALeftAlignedLine = FALSE;
            BOOL    fNextToARightAlignedLine = FALSE;

            // Start out with a zero area rectangle.
            // NOTE(SujalP): _yFirst can legally be less than 0. Its OK, because
            // the rect we are constructing here is going to be used for inval purposes
            // only and that is going to clip it to the content rect of the flowlayout.
            yTop      =
            rc.bottom =
            rc.top    = led._yFirst;
            rc.left   = MAXLONG;
            rc.right  = 0;

            // Need this to adjust for negative line heights.
            // Note that this also initializes the counter for the
            // for loop just below.
            iLine = led._iliFirst;

            // Accumulate rectangles of lines and invalidate them.
            iLineLast = min(led._iliMatchNew, LineCount());

            // Invalidate only the lines that have been touched by the recalc
            for (; iLine < iLineLast; iLine++)
            {
                pLine = Elem(iLine);
                ploi = pLine->oi();
                
                if (pLine == NULL || ploi == NULL)
                    break;

                if (ploi->_xLeftMargin == 0)
                    fNextToALeftAlignedLine = FALSE;
                if (ploi->_xRightMargin == 0)
                    fNextToARightAlignedLine = FALSE;

                // Get the left and right edges of the line.
                xLineLeft  = fNextToALeftAlignedLine ? ploi->_xLeft : ploi->_xLeftMargin;
                xLineRight = xLineLeft + pLine->_xLineWidth 
                                + (fNextToALeftAlignedLine ? ploi->_xLeftMargin : 0)
                                + (fNextToARightAlignedLine ? ploi->_xRightMargin : 0);

                // Get the top and bottom edges of the line
                yLineTop    = yTop + pLine->GetYLineTop(ploi) - led._yExtentAdjust;
                yLineBottom = yTop + pLine->GetYLineBottom(ploi) + led._yExtentAdjust;

                if (pLine->IsFrame())
                {
                    //
                    // If a left algined line is in the invalidation region then the lines
                    // next to it should invalidate the left margin also, since the left
                    // aligned image could be shorter than the lines next to it. Also this
                    // is no more expensive since we do this only if the aligned line is
                    // invl'd ... i.e. if the line were next to an inval line, we will
                    // inval an already invalidated region. If the line next to the aligned
                    // image were tall and hence part of it was next to the empty space
                    // below the aligned object, then this code will serve to inval that
                    // region -- which would be the right thing to do. Note that we do not
                    // inval the margin region if the aligned line was not inval'd. Note
                    // we cleanup the flag once we are passed all align objects (when
                    // _xLeftMargin goes to 0. (See bug 101624).
                    // 
                    if (pLine->_fLeftAligned)
                        fNextToALeftAlignedLine = TRUE;
                    else if (pLine->_fRightAligned)
                        fNextToARightAlignedLine = TRUE;

                    //
                    // NOTE: (SujalP) This is necessary only if height kerning is turned on.
                    // What happens is that the line for the floated character could get shorter
                    // (character 'A' is replaced by character 'a') causing us to not invalidate
                    // enough height to erase the 'A'. This is not a problem when there are floated
                    // images which reduce in height, since *they* are smart enough to inval 
                    // their before rect. In the current scheme of things, the display never 
                    // does *any* invalidation based on their previous heights. Hence, we inval
                    // the full height of he display over here. The correct height to inval is
                    // just the pre-kerned height, but that is needlessly complex at this point.
                    //
                    if (ploi->_fHasFloatedFL)
                    {
                        yLineBottom = rcView.bottom;
                    }
                }
                
                // First line of a new rectangle
                if (rc.right < rc.left)
                {
                    rc.left  = xLineLeft;
                    rc.right = xLineRight;
                }

                // Different margins, output the old one and restart.
                else if (rc.left != xLineLeft || rc.right != xLineRight)
                {
                    // if we have multiple chunks in the same line
                    if( rc.right  == xLineLeft &&
                        rc.top    == yLineTop  &&
                        rc.bottom == yLineBottom )
                    {
                        rc.right = xLineRight;
                    }
                    else
                    {
                        IGNORE_HR(aryInvalRects.AppendIndirect(&rc));

                        fNeedViewChange = TRUE;

                        // Zero height.
                        rc.top    =
                        rc.bottom = yTop;

                        // Just the width of the given line.
                        rc.left  = xLineLeft;
                        rc.right = xLineRight;
                    }
                }

                // Negative line height.
                rc.top = min(rc.top, yLineTop);

                rc.bottom = max(rc.bottom, yLineBottom);

                // Otherwise just accumulate the height.
                if(pLine->_fForceNewLine)
                {
                    yTop  += pLine->_yHeight;

                    // Stop when reaching the bottom of the visible area
                    if (rc.bottom > rcView.bottom)
                        break;
                }
            }

// BUBUG (srinib) - This is a temporary hack to handle the
// scrolling case until the display tree provides the functionality
// to scroll an rc in view. If the new content height changed then
// scroll the content below the change by the dy. For now we are just
// to the end of the view.
            if(dy)
            {
                rc.left   = rcView.left;
                rc.right  = rcView.right;
                rc.bottom = rcView.bottom;
            }

            // Get the last one.
            if (rc.right > rc.left && rc.bottom > rc.top)
            {
                IGNORE_HR(aryInvalRects.AppendIndirect(&rc));
                fNeedViewChange = TRUE;
            }

            // There might be more stuff which has to be
            // invalidated because of lists (numbers might change etc)
            if (UpdateViewForLists(&rcView,   cpFirst,
                                   iLineLast, rc.bottom, &rc))
            {
                IGNORE_HR(aryInvalRects.AppendIndirect(&rc));
                fNeedViewChange = TRUE;
            }

            if (    led._yFirst >= rcView.top
                &&  (   led._yMatchNew <= rcView.bottom
                    ||  led._yMatchOld <= rcView.bottom))
            {
                WaitForRecalcView(pci);
            }
        }
    }

    {
        // Now do the invals
        if (fInvalAll)
        {
            pFlowLayout->Invalidate();
        }
        else
        {
            pFlowLayout->Invalidate(&aryInvalRects[0], aryInvalRects.Size());
        }
    }

    if (fNeedViewChange)
    {
        pFlowLayout->ViewChange(FALSE);
    }

    CheckView();

#ifdef DBCS
    UpdateIMEWindow();
#endif

    return fReturn;
}

/*
 *  CDisplay::CalcDisplayWidth()
 *
 *  @mfunc
 *      Computes and returns width of this display by walking line
 *      CArray and returning the widest line.  Used for
 *      horizontal scroll bar routines
 *
 *  @todo
 *      This should be done by a background thread
 */

LONG CDisplay::CalcDisplayWidth ()
{
    LONG    ili = LineCount();
    CLineCore * pli;
    CLineOtherInfo *ploi;
    LONG    xWidth = 0;
    CLineInfoCache *pLineCache = TLS(_pLineInfoCache);
    
    if(ili)
    {
        // Note: pli++ breaks array encapsulation (pli = &(*this)[ili] doesn't)
        pli = Elem(0);
        for(xWidth = 0; ili--; pli++)
        {
            ploi = pli->oi(pLineCache);
            
            // calc line width based on the direction
            LONG cx = pli->GetTextRight(ploi, ili == 0) + pli->_xRight;

            if(IsRTLDisplay())
            {
                // Negative shift means overflow. 
                // Remove the saved shift to get line's desired width.
                cx -= ploi->_xNegativeShiftRTL;
            }
            
            xWidth = max(xWidth, cx);
        }
    }

    return xWidth;
}


/*
 *  CDisplay::StartBackgroundRecalc()
 *
 *  @mfunc
 *      Starts background line recalc (at _dcpCalcMax position)
 *
 *  @todo
 *      ??? CF - Should use an idle thread
 */
void CDisplay::StartBackgroundRecalc(DWORD grfLayout)
{
    // We better be in the middle of the job here.
    Assert (LineCount() > 0);

    Assert(CanHaveBgRecalcInfo());

    // StopBack.. kills the recalc task, *if it exists*
    StopBackgroundRecalc () ;

    EnsureBgRecalcInfo();

#if DBG == 1
    _pFL->_pDocDbg->_fUsingBckgrnRecalc = TRUE;
#endif

    if(!RecalcTask() && GetMaxCpCalced() < GetLastCp())
    {
        BgRecalcInfo()->_pRecalcTask = new CRecalcTask (this, grfLayout) ;
        if (RecalcTask())
        {
            _fRecalcDone = FALSE;
        }
        // TODO: (sujalp, tracking bug 111982): what to do if we fail on mem allocation?
    }
}


/*
 *  CDisplay::StepBackgroundRecalc()
 *
 *  @mfunc
 *      Steps background line recalc (at _dcpCalcMax position)
 *      Called by timer proc
 *
 *  @todo
 *      ??? CF - Should use an idle thread
 */
VOID CDisplay::StepBackgroundRecalc (DWORD dwTimeOut, DWORD grfLayout)
{
    LONG cch = GetLastCp() - (GetMaxCpCalced());

    // don't try recalc when processing OOM or had an error doing recalc or
    // if we are asserting.
    if(_fInBkgndRecalc || _fLineRecalcErr || GetFlowLayout()->IsDirty())
    {
#if DBG==1
        if(_fInBkgndRecalc)
            PerfDbgLog(tagRecalc, this, "avoiding reentrant background recalc");
        else if (_fLineRecalcErr)
            PerfDbgLog(tagRecalc, this, "OOM: not stepping recalc");
#endif
        return;
    }

    _fInBkgndRecalc = TRUE;

    // Background recalc is over if no more characters or we are no longer
    // active.
    if(cch <= 0)
    {
        if (RecalcTask())
        {
            StopBackgroundRecalc();
        }

        CheckLineArray();

        goto Cleanup;
    }

    {
        CFlowLayout *   pFlowLayout = GetFlowLayout();
        CElement    *   pElementFL = pFlowLayout->ElementOwner();
        LONG            cp = GetMaxCpCalced();

        if (!pElementFL->IsDisplayNone(LC_TO_FC(pFlowLayout->LayoutContext())))
        {
            CFlowLayout::CScopeFlag  csfCalcing(pFlowLayout);

            CCalcInfo   CI;
            CLed        led;
            long        xParentWidth;
            long        yParentHeight;

            pFlowLayout->OpenView();

            // Setup the amount of time we have this time around
            Assert(BgRecalcInfo() && "Supposed to have a recalc info in stepbackgroundrecalc");
            BgRecalcInfo()->_dwBgndTickMax = dwTimeOut ;

            CI.Init(pFlowLayout);
            GetViewWidthAndHeightForChild(
                &CI,
                &xParentWidth,
                &yParentHeight,
                CI._smMode == SIZEMODE_MMWIDTH);
            CI.SizeToParent(xParentWidth, yParentHeight);

            CI._grfLayout = grfLayout;

            RecalcLines(&CI, cp, cch, cch, TRUE, &led);

#ifndef NO_ETW_TRACING
            // Send event to ETW if it is enabled by the shell.
            if (    g_pHtmPerfCtl 
                &&  (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONEVENT)) 
            {
                g_pHtmPerfCtl->pfnCall(EVENT_TRACE_TYPE_BROWSE_LAYOUTTASK,
                                       (TCHAR *)pFlowLayout->Doc()->GetPrimaryUrl());
            }
#endif

        }
        else
        {
            CNotification  nf;

            // Kill background recalc, if the layout is hidden
            StopBackgroundRecalc();

            // calc the rest by accumulating a dirty range.
            nf.CharsResize(GetMaxCpCalced(), cch, pElementFL->GetFirstBranch());
            GetMarkup()->Notify(&nf);
        }
    }

Cleanup:
    _fInBkgndRecalc = FALSE;

    return;
}


/*
 *  CDisplay::StopBackgroundRecalc()
 *
 *  @mfunc
 *      Steps background line recalc (at _dcpCalcMax position)
 *      Called by timer proc
 *
 */
VOID CDisplay::StopBackgroundRecalc()
{
    if (HasBgRecalcInfo())
    {
        if (RecalcTask())
        {
            RecalcTask()->Terminate () ;
            RecalcTask()->Release () ;
            _fRecalcDone = TRUE;
        }
        DeleteBgRecalcInfo();
    }
}

/*
 *  CDisplay::WaitForRecalc(cpMax, yMax, pDI)
 *
 *  @mfunc
 *      Ensures that lines are recalced until a specific character
 *      position or ypos.
 *
 *  @rdesc
 *      success
 */
BOOL CDisplay::WaitForRecalc(
    LONG cpMax,     //@parm Position recalc up to (-1 to ignore)
    LONG yMax,      //@parm ypos to recalc up to (-1 to ignore)
    CCalcInfo * pci) // @parm can be NULL.

{
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    BOOL            fReturn = TRUE;
    LONG            cch;
    CCalcInfo       CI;
 
    Assert(cpMax < 0 || (cpMax >= GetFirstCp() && cpMax <= GetLastCp()));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CDisplay::WaitForRecalc cpMax=%d yMax=%d pci=%d,%d", cpMax, yMax, pci ? pci->_sizeParent.cx : 0, pci ? pci->_sizeParent.cy : 0 ));

    CFlowLayout::CScopeFlag  csfCalcing(pFlowLayout);

    //
    //  Return immediately if hidden, already measured up to the correct point, or currently measuring
    //  or if there is no dispnode (ie haven't been CalcSize'd yet)

    if (pFlowLayout->IsDisplayNone())
    {
        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::WaitForRecalc - no work done because display:none"));
        return fReturn;
    }

    if ( !pFlowLayout->GetElementDispNode() )
    {
        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::WaitForRecalc - no work done because display:none"));
        return FALSE;
    }

    if (    yMax < 0
        &&  cpMax >= 0
        &&  cpMax <= GetMaxCpCalced()
        &&  (  !pFlowLayout->IsDirty()
            ||  pFlowLayout->IsRangeBeforeDirty(cpMax - pFlowLayout->GetContentFirstCp(), 0) ))
    {
        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::WaitForRecalc - no work necessary"));
        return fReturn;
    }

    if (    pFlowLayout->TestLock(CElement::ELEMENTLOCK_RECALC)
        ||  pFlowLayout->TestLock(CElement::ELEMENTLOCK_PROCESSREQUESTS))
    {
        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::WaitForRecalc - aborting in middle of recalc/process reqs"));
        return FALSE;
    }

    //
    //  Calculate up through the request location
    //

    if(!pci)
    {
        CI.Init(pFlowLayout);
        pci = &CI;
    }

    pFlowLayout->CommitChanges(pci);

    if (    (   yMax < 0
            ||  yMax >= _yCalcMax)
        &&  (   cpMax < 0
            ||  cpMax > GetMaxCpCalced()))
    {
        cch = GetLastCp() - GetMaxCpCalced();
        if(cch > 0 || LineCount() == 0)
        {

            HCURSOR     hcur = NULL;
            CDoc *      pDoc = pFlowLayout->Doc();

            if (EnsureBgRecalcInfo() == S_OK)
            {
                CBgRecalcInfo * pBgRecalcInfo = BgRecalcInfo();
                Assert(pBgRecalcInfo && "Should have a BgRecalcInfo");
                pBgRecalcInfo->_cpWait = cpMax;
                pBgRecalcInfo->_yWait  = yMax;
            }

            if (pDoc && pDoc->State() >= OS_INPLACE)
            {
                hcur = SetCursorIDC(IDC_WAIT);
            }
            TraceTag((tagWarning, "Lazy recalc"));

            if(GetMaxCpCalced() == GetFirstCp() )
            {
                fReturn = RecalcLines(pci);
            }
            else
            {
                CLed led;

                fReturn = RecalcLines(pci, GetMaxCpCalced(), cch, cch, FALSE, &led, TRUE);
            }

            // Either we were not waiting for a cp or if we were, then we have been calcd to that cp
            Assert(cpMax < 0 || GetMaxCpCalced() >= cpMax);

            SetCursor(hcur);
        }
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::WaitForRecalc"));
    return fReturn;
}

/*
 *  CDisplay::WaitForRecalcIli
 *
 *  @mfunc
 *      Wait until line array is recalculated up to line <p ili>
 *
 *  @rdesc
 *      Returns TRUE if lines were recalc'd up to ili
 */


#pragma warning(disable:4702)   //  Ureachable code

BOOL CDisplay::WaitForRecalcIli (
    LONG ili,       //@parm Line index to recalculate line array up to
    CCalcInfo * pci)
{
    // TODO: (istvanc, dmitryt, track bug 111987) remove this function. 
    // It is used in 2 places to check if line index is less then line count (so no need
    // for actual calculation, it's a leftover)

    return ili < LineCount();
#if 0
    LONG cchGuess;

    while(!_fRecalcDone && ili >= LineCount())
    {
        cchGuess = 5 * (ili - LineCount() + 1) * Elem(0)->_cch;
        if(!WaitForRecalc(GetMaxCpCalced() + cchGuess, -1, pci))
            return FALSE;
    }
    return ili < LineCount();
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     WaitForRecalcView
//
//  Synopsis:   Calculate up through the bottom of the visible content
//
//  Arguments:  pci - CCalcInfo to use
//
//  Returns:    TRUE if all Ok, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL
CDisplay::WaitForRecalcView(CCalcInfo * pci)
{
    return WaitForRecalc(-1, GetFlowLayout()->GetClientBottom(), pci);
}


#pragma warning(default:4702)   //  re-enable unreachable code

//===================================  View Updating  ===================================


/*
 *  CDisplay::SetViewSize(rcView)
 *
 *  Purpose:
 *      Set the view size 
 */
void CDisplay::SetViewSize(const RECT &rcView)
{
    _xWidthView  = rcView.right  - rcView.left;
    _yHeightView = rcView.bottom - rcView.top;
}

/*
 *  CDisplay::RecalcView
 *
 *  Sysnopsis:  Recalc view and update first visible line
 *
 *  Arguments:
 *      fFullRecalc - TRUE if recalc from first line needed, FALSE if enough
 *                    to start from _dcpCalcMax
 *
 *  Returns:
 *      TRUE if success
 */
BOOL CDisplay::RecalcView(CCalcInfo * pci, BOOL fFullRecalc)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CDisplay::RecalcView P(%d,%d) full=%d", pci->_sizeParent.cx, pci->_sizeParent.cy, fFullRecalc ));

    CFlowLayout * pFlowLayout = GetFlowLayout();
    BOOL          fAllowBackgroundRecalc;

    // If we have no width, don't even try to recalc, it causes
    // crashes in the scrollbar code, and is just a waste of time
    if (GetViewWidth() <= 0 && !pFlowLayout->_fContentsAffectSize)
    {
        FlushRecalc();
        return TRUE;
    }

    fAllowBackgroundRecalc = AllowBackgroundRecalc(pci);

    // If a full recalc (from first line) is not needed
    // go from current _dcpCalcMax on
    if (!fFullRecalc)
    {
        return (fAllowBackgroundRecalc
                        ? WaitForRecalcView(pci)
                        : WaitForRecalc(GetLastCp(), -1, pci));
    }

    // Else do full recalc
    BOOL  fRet = TRUE;

    // If all that the element is likely to have is a single line of plain text,
    // use a faster mechanism to compute the lines. This is great for perf
    // of <INPUT>
    if (pFlowLayout->Tag() == ETAG_INPUT)
    {
        fRet = RecalcPlainTextSingleLine(pci);
    }
    else
    {
        // full recalc lines
        if(!RecalcLines(pci))
        {
            // we're in deep trouble now, the recalc failed
            // let's try to get out of this with our head still mostly attached
            fRet = FALSE;
            goto Done;
        }
    }
    CheckView();

Done:
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::RecalcView P(%d,%d) full=", pci->_sizeParent.cx, pci->_sizeParent.cy, fFullRecalc ));
    return fRet;
}

//+---------------------------------------------------------------
//
//  Member:     CDisplay::RecalcLineShift
//
//  Synopsis:   Run thru line array and adjust line shift
//
//---------------------------------------------------------------


void CDisplay::RecalcLineShift(CCalcInfo * pci, DWORD grfLayout)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CDisplay::RecalcLineShift P(%d,%d)", pci->_sizeParent.cx, pci->_sizeParent.cy ));

    CFlowLayout * pFlowLayout = GetFlowLayout();
    LONG        lCount = LineCount();
    LONG        ili;
    LONG        iliFirstChunk = 0;
    BOOL        fChunks = FALSE;
    CLineCore * pli;
    const CLineOtherInfo *ploi;
    CLineOtherInfo loi;
    long        xWidthMax = GetViewWidth();
    
    Assert (pFlowLayout->_fSizeToContent ||
            (_fMinMaxCalced && !pFlowLayout->ContainsNonHiddenChildLayout()));


    for(ili = 0, pli = Elem(0); ili < lCount; ili++, pli++)
    {
        ploi = pli->oi();
        
        // if the current line does not force a new line, then
        // find a line that forces the new line and distribute
        // width.

        if(!fChunks && !pli->_fForceNewLine && !pli->IsFrame())
        {
            iliFirstChunk = ili;
            fChunks = TRUE;
        }

        if(pli->_fForceNewLine)
        {
            long xShift = 0;
            long xNegativeShiftRTL = ploi->_xNegativeShiftRTL;

            if(!fChunks)
                iliFirstChunk = ili;
            else
                fChunks = FALSE;

            // calc shift if line is justified or if it is RTL 
            // (for RTL, we need to adjust _xRight and left overflow)
            long xRemainder = pli->_xRight;
            if (pli->_fJustified || pli->_fRTLLn)
            {
                // WARNING: Duplicate of the logic in ComputeLineShift.
                //          Make it a function if it gets any more complex than this!
                // NOTE: We do not want to include the width of the caret in justification
                // computation, else we will place text in the place reserved for the
                // caret. This was shown by bug #80765
                long xWidth = ploi->_xLeftMargin + CLineFull::CalcLineWidth(pli, ploi) 
                            + ploi->_xRightMargin /*+ GetCaret()*/;

                if(pli->_fJustified && long(pli->_fJustified) != JUSTIFY_FULL )
                {
                    // for pre whitespace is already include in _xWidth
                    xShift = xWidthMax - xWidth;

                    xShift = max(xShift, 0L);   // Don't allow alignment to go < 0 (unless RTL, see below)

                    if(long(pli->_fJustified) == JUSTIFY_CENTER)
                        xShift /= 2;
                }

                // In RTL display, negative shift occurs when a line is wider than display
                if (IsRTLDisplay())
                {
                    // If this line still doesn't fit, calcluate new negative shift
                    if (xWidthMax < xWidth)
                    {
                        // xShift is the different of desired effective shift and current shift
                        xShift = (xWidthMax - xWidth) - ploi->_xNegativeShiftRTL;

                        // New negative shift to be saved (it must be zero if it is not negative)
                        xNegativeShiftRTL = min(0L, xNegativeShiftRTL + xShift);
                    }
                    else if (xNegativeShiftRTL < 0)
                    {
                        // This line used to be too wide for the display, but now it fits.
                        // Increase the shift to remove current negative shift.
                        xShift -= xNegativeShiftRTL;
                        xNegativeShiftRTL = 0;
                    }
                }

                Assert((xNegativeShiftRTL == 0) || IsRTLDisplay()); //in LTR, this shift is always 0

                xRemainder = max(0L, pli->_xRight + xWidthMax - xWidth - xShift - xNegativeShiftRTL);
            }

            Assert(iliFirstChunk <= ili);
            
            while(iliFirstChunk <= ili)
            {
                pli = Elem(iliFirstChunk++);
                loi = *pli->oi();

                if (xShift)
                {
                    pli->ReleaseOtherInfo();
                    loi._xLeft += xShift;
                    loi._xNegativeShiftRTL = xNegativeShiftRTL;
                    pli->CacheOtherInfo(loi);
                }

                pli->_xRight = xRemainder;
                pli->_xLineWidth = CLineFull::CalcLineWidth(pli, &loi);
            }

            // line width will be at least xWidthMax
            if (pli->_xLineWidth < xWidthMax)
                pli->_xLineWidth = xWidthMax;
        }
    }

    // Update relative display nodes
    if (pFlowLayout->_fContainsRelative)
    {
        VoidRelDispNodeCache();
        UpdateRelDispNodeCache(NULL);
    }

    //
    // Nested layouts need to be repositioned, to account for lineshift.
    //
    if (pFlowLayout->_fSizeToContent)
    {
        RecalcLineShiftForNestedLayouts();
    }

    if ( pci->_fNeedToSizeContentDispNode )
    {
        pci->_fNeedToSizeContentDispNode = FALSE;
        pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));
    }

    //
    // NOTE(SujalP): Ideally I would like to do the NMR in all cases. However, that causes a misc perf
    // regession of about 2% on pages with a lot of small table cells. To avoid that problem I am doing
    // this only for edit mode. If you have other needs then add those cases to the if condition.
    // 
    if (pFlowLayout->IsEditable())
        pFlowLayout->NotifyMeasuredRange(GetFlowLayoutElement()->GetFirstCp(), GetMaxCpCalced());

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::RecalcLineShift P(%d,%d)", pci->_sizeParent.cx, pci->_sizeParent.cy ));
}

void
CDisplay::RecalcLineShiftForNestedLayouts()
{
    CLayout     * pLayout;
    CFlowLayout * pFL = GetFlowLayout();
    CDispNode   * pDispNode = pFL->GetFirstContentDispNode();

    if (pFL->_fAutoBelow)
    {
        DWORD_PTR dw;

        for (pLayout = pFL->GetFirstLayout(&dw); pLayout; pLayout = pFL->GetNextLayout(&dw))
        {
            CElement * pElement = pLayout->ElementOwner();
            CTreeNode * pNode   = pElement->GetFirstBranch();
            const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(pLayout->LayoutContext()));

            if (    !pFF->IsAligned()
                &&  (   pFF->IsAutoPositioned()
                    ||  pNode->GetCharFormat(LC_TO_FC(pLayout->LayoutContext()))->IsRelative(FALSE)))
            {
                pElement->ZChangeElement(0, NULL, pFL->LayoutContext());
            }
        }
        pFL->ClearLayoutIterator(dw);
    }

    if (pDispNode == NULL)
        return;
    
    pDispNode = pDispNode->GetNextFlowNode();
    
    if (pDispNode)
    {
        CLinePtr rp(this);
        CLineOtherInfo *ploi;
        
        do
        {
            // if the current disp node is not a text node
            if (pDispNode->GetDispClient() != pFL)
            {
                void * pvOwner;

                pDispNode->GetDispClient()->GetOwner(pDispNode, &pvOwner);

                if (pvOwner)
                {
                    CElement * pElement = DYNCAST(CElement, (CElement *)pvOwner);

                    //
                    // aligned layouts are not affected by text-align
                    //
                    if (!pElement->IsAligned())
                    {
                        //TODO (dmitryt, track bug 111990) this can hurt perf - RpSetCp is slow.
                        //we could have a bit on CDisplay that tells us that at least 
                        //one line was RTL or right- or center-aligned. 
                        //If not, we shouldn't bother checking this.
                        BOOL fCpFound = rp.RpSetCp(pElement->GetFirstCp(), FALSE, TRUE);

                        htmlAlign  atAlign  = (htmlAlign)pElement->GetFirstBranch()->
                                                    GetParaFormat()->_bBlockAlign;

                        if (fCpFound && 
                                (    atAlign == htmlAlignRight 
                                 ||  atAlign == htmlAlignCenter 
                                 ||  rp->IsRTLLine()
                                )
                           )
                        {
                            // NOTE: (KTam) There's an assumption here that the pElement we've gotten
                            // to is in fact within this CDisplay.  I'm going to assert this.
                            Assert( pElement->GetFirstCp() >= GetFirstCp() && "Found an element beginning outside our display -- can't determine context!" );
                            Assert( pElement->GetLastCp() <= GetLastCp() && "Found an element ending outside our display -- can't determine context!" );

                            pLayout = pElement->GetUpdatedLayout( LayoutContext() );
                            Assert(pLayout);

                            ploi = rp->oi();
                            LONG lNewXPos;

                            if(!rp->IsRTLLine())
                            {
                                lNewXPos = ploi->GetTextLeft() + pLayout->GetXProposed();
                            }
                            else
                            {
                                lNewXPos =    GetViewWidth()
                                            - pLayout->GetXProposed() 
                                            - pLayout->GetApparentWidth()
                                            - ploi->_xRightMargin 
                                            - rp->_xRight;
                            }

                            pLayout->SetPosition(lNewXPos,
                                                 pLayout->GetPositionTop(), 
                                                 TRUE); // notify auto
                        }
                    }
                }
            }
            pDispNode = pDispNode->GetNextFlowNode();
        }
        while (pDispNode);
    }
}

/*
 *  CDisplay::CreateEmptyLine()
 *
 *  @mfunc
 *      Create an empty line
 *
 *  @rdesc
 *      TRUE - worked <nl>
 *      FALSE - failed
 *
 */
BOOL CDisplay::CreateEmptyLine(CLSMeasurer * pMe,
    CRecalcLinePtr * pRecalcLinePtr,
    LONG * pyHeight, BOOL fHasEOP )
{
    UINT uiFlags;
    LONG yAlignDescent;
    INT  iNewLine;

    // Make sure that this is being called appropriately
    AssertSz(!pMe || GetLastCp() == long(pMe->GetCp()),
        "CDisplay::CreateEmptyLine called inappropriately");

    // Assume failure
    BOOL    fResult = FALSE;

    // Add one new line
    CLineCore *pliNew = pRecalcLinePtr->AddLine();

    if (!pliNew)
    {
        Assert(FALSE);
        goto err;
    }

    iNewLine = pRecalcLinePtr->Count() - 1;

    Assert (iNewLine >= 0);

    uiFlags = fHasEOP ? MEASURE_BREAKATWORD |
                        MEASURE_FIRSTINPARA :
                        MEASURE_BREAKATWORD;

    uiFlags |= MEASURE_EMPTYLASTLINE;

    // If this is the first line in the document.
    if (*pyHeight == 0)
        uiFlags |= MEASURE_FIRSTLINE;

    if (!pRecalcLinePtr->MeasureLine(*pMe, uiFlags,
                                   &iNewLine, pyHeight, &yAlignDescent,
                                   NULL, NULL))
    {
        goto err;
    }

    // If we made it to here, everything worked.
    fResult = TRUE;

err:

    return fResult;
}


//====================================  Rendering  =======================================


/*
 *  CDisplay::Render(rcView, rcRender)
 *
 *  @mfunc
 *      Searches paragraph boundaries around a range
 *
 *  returns: the lowest yPos
 */
void
CDisplay::Render (
    CFormDrawInfo * pDI,
    const RECT &rcView,     // View RECT
    const RECT &rcRender,   // RECT to render (must be container in
    CDispNode * pDispNode)
{
#ifdef SWITCHES_ENABLED
    if (IsSwitchNoRenderLines())
        return;
#endif
    CFlowLayout * pFlowLayout = GetFlowLayout();
    CElement    * pElementFL  = pFlowLayout->ElementOwner();
    LONG    ili;
    LONG    iliBgDrawn = -1;
    LONG    iliForFloatedFL = LONG_MIN;
    POINT   pt;
    LONG    cp;
    LONG    yLine;
    LONG    yLi = 0;
    WHEN_DBG( long lLinesRendered = 0; )
    long    lCount;
    CLineFull lif;
    RECT    rcClip;
    BOOL    fLineIsPositioned;
    CRect   rcLocal;
    long    iliStart  = -1;
    long    iliFinish = -1;
    CPoint  ptOffset;
    CPoint* pptOffset = NULL;

#if DBG == 1
    LONG    cpLi;
#endif

    AssertSz(!pFlowLayout->IsDirty(), "Rendering when layout is dirty -- not a measurer/renderer problem!");

    if (    !pFlowLayout->ElementOwner()->IsInMarkup()
        || (!pFlowLayout->IsEditable() && pFlowLayout->IsDisplayNone())
        ||   pFlowLayout->IsDirty())   // Prevent us from crashing when we do get here in retail mode.
    {
        return;
    }

    // Create renderer
    CLSRenderer lsre(this, pDI);

    if (!lsre._pLS)
        return;

    Assert(pDI->_rc == rcView);
    Assert(((CRect&)(pDI->_rcClip)) == rcRender);

    // Calculate line and cp to start the display at
    rcLocal = rcRender;
    rcLocal.OffsetRect(-((CRect&)rcView).TopLeft().AsSize());

    //
    // if the current layout has multiple text nodes then
    // compute the range of lines the belong to the disp node
    // being rendered.
    //
    if (_fHasMultipleTextNodes && pDispNode)
    {
        GetFlowLayout()->GetTextNodeRange(pDispNode, &iliStart, &iliFinish);

        Assert(iliStart < iliFinish);

        //
        // For backgrounds, RegionFromElement is going to return the
        // rects relative to the layout. So, when we have multiple text
        // nodes pass the (0, -top) as the offset to make the rects
        // text node relative
        //
        pptOffset    = &ptOffset;
        pptOffset->x = 0;
        pptOffset->y = -pDispNode->GetPosition().y;
    }

    //
    // For multiple text node, we want to search for the point only
    // in the lines owned by the text node.
    //
    ili = LineFromPos(rcLocal, &yLine, &cp, 0, iliStart, iliFinish);

    lCount = iliFinish < 0 ? LineCount() : iliFinish;

    if(lCount <= 0 || ili < 0)
        return;

    rcClip = rcRender;

    // Prepare renderer

    if(!lsre.StartRender(rcView, rcRender, ili, cp))
        return;

    // If we're just painting the inset, don't check all the lines.
    if (rcRender.right <= rcView.left ||
        rcRender.left >= rcView.right ||
        rcRender.bottom <= rcView.top ||
        rcRender.top >= rcView.bottom)
        return;

    
    // Calculate the point where the text will start being displayed
    pt = ((CRect &)rcView).TopLeft();
    pt.y += yLine;

    // Init renderer at the start of the first line to render
    lsre.SetCurPoint(pt);
    lsre.SetCp(cp, NULL);

    WHEN_DBG(cpLi = long(lsre.GetCp());)

    yLi = pt.y;

    // Check if this line begins BEFORE the previous line ended ...
    // Would happen with negative line heights:
    //
    //           ----------------------- <-----+---------- Line 1
    //                                         |
    //           ======================= <-----|-----+---- Line 2
    //  yBeforeSpace__________^                |     |
    //                        |                |     |
    //  yLi ---> -------------+--------- <-----+     |
    //                                               |
    //                                               |
    //           ======================= <-----------+
    //
    RecalcMost();

    // Render each line in the update rectangle

    for (; ili < lCount; ili++)
    {
        // current line
        lif = *Elem(ili);
        
        // if the most negative line is out off the view from the current
        // yOffset, don't look any further, we have rendered all the lines
        // in the inval'ed region
        if (yLi + min(long(0), lif.GetYTop()) + _yMostNeg >= rcClip.bottom)
        {
            break;
        }

        fLineIsPositioned = FALSE;

        //
        // if the current line is interesting (ignore aligned, clear,
        // hidden and blank lines).
        //
        if(lif._cch && !lif._fHidden)
        {
            //
            // if the current line is relative get its y offset and
            // zIndex
            //
            if(lif._fRelative)
            {
                fLineIsPositioned = TRUE;
            }
        }

        //
        // now check to see if the current line is in view
        //
        if(   ((yLi + min(long(0), lif.GetYLineTop()))    > rcClip.bottom)
           || ((yLi + max(long(0), lif.GetYLineBottom())) < rcClip.top   )
          )
        {
            //
            // line is not in view, so skip it
            //
            lsre.SkipCurLine(&lif);
        }
        else
        {
            //
            // current line is in view, so render it
            //
            // Note: we have to render the background on a relative line,
            // the parent of the relative element might have background.(srinib)
            // fix for #51465
            //
            // if the paragraph has background or borders then compute the bounding rect
            // for the paragraph and draw the background and/or border
            if(iliBgDrawn < ili &&
               (lif._fHasParaBorder || // if we need to draw borders
                (   lif._fHasBackground 

                    && pElementFL->GetMarkupPtr()->PaintBackground())))
            {
                DrawBackgroundAndBorder(lsre.GetDrawInfo(), lsre.GetCp(), ili, lCount,
                                        &iliBgDrawn, yLi, &rcView, &rcClip, pptOffset);

                //
                // N.B. (johnv) Lines can be added by as
                // DrawBackgroundAndBorders (more precisely,
                // RegionFromElement, which it calls) waits for a
                // background recalc.  Recompute our cached line pointer.
                //
                lif = *Elem(ili);
            }

            if (   (   lif._fHasFirstLine
                    || lif._fHasFloatedFL
                   )
                && lif._fHasBackground
                && !lif.IsFrame()
                && pElementFL->GetMarkupPtr()->PaintBackground()
               )
            {
                if (lif._fHasFirstLetter && lif._fHasFloatedFL)
                    iliForFloatedFL = ili + 1;
                
                if (   (   lif._fHasFirstLetter
                        && lif._fHasFloatedFL
                       )
                    || (   lif._fHasFirstLine
                        && iliForFloatedFL + 1 != ili
                       )
                   )
                {
                    DrawBackgroundForFirstLine(lsre.GetDrawInfo(), lsre.GetCp(), ili,
                                               &rcView, &rcClip, pptOffset);
                    //
                    // N.B. (johnv) Lines can be added by as
                    // DrawBackgroundAndBorders (more precisely,
                    // RegionFromElement, which it calls) waits for a
                    // background recalc.  Recompute our cached line pointer.
                    //
                    lif = *Elem(ili);
                }
            }
            
            // if the current line has is positioned it will be taken care
            // of through the SiteDrawList and we shouldn't draw it here.
            //
            if (fLineIsPositioned)
            {
                lsre.SkipCurLine(&lif);
            }
            else
            {
                //
                // Finally, render the current line
                //
                lsre.RenderLine(lif);
                WHEN_DBG( ++ lLinesRendered; )
            }
        }

        Assert(lif == *Elem(ili));

        //
        // update the yOffset for the next line
        //
        if(lif._fForceNewLine)
            yLi += lif._yHeight;

        WHEN_DBG( cpLi += lif._cch; )

        AssertSz( long(lsre.GetCp()) == cpLi,
                  "CDisplay::Render() - cp out of sync. with line table");
        AssertSz( lsre.GetCurPoint().y == yLi,
                  "CDisplay::Render() - y out of sync. with line table");

    }

    TraceTag((tagRenderLines, "rendered %ld of %ld lines for %x (%ls %ld) at (%d %d %d %d) clip (%d %d %d %d)",
                lLinesRendered, lCount,
                pFlowLayout, pElementFL->TagName(), pElementFL->SN(),
                rcView.top, rcView.bottom, rcView.left, rcView.right,
                rcRender.top, rcRender.bottom, rcRender.left, rcRender.right
                ));

    if (lsre._lastTextOutBy != CLSRenderer::DB_LINESERV)
    {
        lsre._lastTextOutBy = CLSRenderer::DB_NONE;
        SetTextAlign(lsre._hdc, TA_TOP | TA_LEFT);
    }
}


//+---------------------------------------------------------------------------
//
// Member:      DrawBackgroundAndBorders()
//
// Purpose:     Draw background and borders for elements on the current line,
//              and all the consecutive lines that have background.
//
//----------------------------------------------------------------------------
void
CDisplay::DrawBackgroundAndBorder(
     CFormDrawInfo * pDI,
     long            cpIn,
     LONG            ili,
     LONG            lCount,
     LONG          * piliDrawn,
     LONG            yLi,
     const RECT    * prcView,
     const RECT    * prcClip,
     const CPoint  * pptOffset)
{

    const CCharFormat  * pCF;
    const CFancyFormat * pFF;
    const CParaFormat  * pPF;
    CStackPtrAry < CTreeNode *, 8 > aryNodesWithBgOrBorder(Mt(CDisplayDrawBackgroundAndBorder_aryNodesWithBgOrBorder_pv));
    CDataAry <RECT> aryRects(Mt(CDisplayDrawBackgroundAndBorder_aryRects_pv));
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    CElement    *   pElementFL  = pFlowLayout->ElementContent();
    CMarkup     *   pMarkup = pFlowLayout->GetContentMarkup();
    BOOL            fPaintBackground = pMarkup->PaintBackground();
    CTreeNode *     pNodeCurrBranch;
    CTreeNode *     pNode;
    CTreePos  *     ptp;
    long            ich;
    long            cpClip = cpIn;
    long            cp;
    long            lSize;


    // find the consecutive set of lines that have background
    while (ili < lCount && yLi + _yMostNeg < prcClip->bottom)
    {
        CLineCore * pli = Elem(ili++);

        // if the current line has borders or background then
        // continue otherwise return.
        if (!(pli->_fHasBackground && fPaintBackground) &&
            !pli->_fHasParaBorder)
        {
            break;
        }

        if (pli->_fForceNewLine)
        {
            yLi += pli->_yHeight;
        }

        cpClip += pli->_cch;
    }

    if(cpIn != cpClip)
        *piliDrawn = ili - 1;

    // initialize the tree pos that corresponds to the begin cp of the
    // current line
    ptp = pMarkup->TreePosAtCp(cpIn, &ich, TRUE);

    cp = cpIn - ich;

    // first draw any backgrounds extending into the current region
    // from the previous line.

    pNodeCurrBranch = ptp->GetBranch();

    if(    DifferentScope(pNodeCurrBranch, pElementFL)
           && ( pElementFL->IsOverlapped() ?
                pElementFL->GetFirstCp() < pNodeCurrBranch->Element()->GetFirstCp() :
                TRUE
              ) // protect against weird overlapping (#99003)
      )
    {
        pNode = pNodeCurrBranch;

        // run up the current branch and find the ancestors with background
        // or border
        while(pNode && !SameScope(pNode, pElementFL))
        {
            if (!pNode->ShouldHaveLayout())
            {
                // push this element on to the stack
                aryNodesWithBgOrBorder.Append(pNode);
            }
#if DBG==1
            else
            {
                Assert(pNode == pNodeCurrBranch);
            }
#endif
            pNode = pNode->Parent();
        }

        Assert(pNode);

        // now that we have all the elements with background or borders
        // for the current branch render them.
        for(lSize = aryNodesWithBgOrBorder.Size(); lSize > 0; lSize--)
        {
            CTreeNode * pNode = aryNodesWithBgOrBorder[lSize - 1];

            //
            // In design mode relative elements are drawn in flow (they are treated
            // as if they are not relative). Relative elements draw their own
            // background and their children's background. So, draw only the
            // background of ancestor's if any. (#25583)
            //
            if(pNode->IsRelative() )
            {
                pNodeCurrBranch = pNode;
                break;
            }
            else
            {
                pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                pFF = pNode->GetFancyFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                pPF = pNode->GetParaFormat(LC_TO_FC(pFlowLayout->LayoutContext()));

                if (!pCF->IsVisibilityHidden() && !pCF->IsDisplayNone())
                {
                    BOOL fDrawBorder = pCF->_fPadBord  && pFF->_fBlockNess;
                    BOOL fDrawBackground = fPaintBackground &&
                                           pFF->_fBlockNess &&
                                           (pFF->_lImgCtxCookie ||
                                            pFF->_ccvBackColor.IsDefined());

                    if (fDrawBackground || fDrawBorder)
                    {

                        DrawElemBgAndBorder(
                                            pNode->Element(), &aryRects,
                                            prcView, prcClip,
                                            pDI, pptOffset,
                                            fDrawBackground, fDrawBorder,
                                            cpIn, -1, !pCF->_cuvLineHeight.IsNull());
                    }
                }
            }
        }


        //
        // In design mode relative elements are drawn in flow (they are treated
        // as if they are not relative).
        //
        if(pNodeCurrBranch->ShouldHaveLayout() || pNode->IsRelative())
        {
            CTreePos * ptpBegin;

            pNodeCurrBranch->Element()->GetTreeExtent(&ptpBegin, &ptp);

            cp = ptp->GetCp();
        }

        cp += ptp->GetCch();
        ptp = ptp->NextTreePos();
    }

    // now draw the background of all the elements comming into scope of
    // in the cpRange
    while(ptp && cpClip >= cp)
    {
        if(ptp->IsBeginElementScope())
        {
            pNode = ptp->Branch();
            pCF   = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));

            // Background and border for a relative element or an element
            // with layout are drawn when the element is hit with a draw.
            if(pNode->ShouldHaveLayout() || pCF->_fRelative)
            {
                if(DifferentScope(pNode, pElementFL))
                {
                    CTreePos * ptpBegin;

                    pNode->Element()->GetTreeExtent(&ptpBegin, &ptp);
                    cp = ptp->GetCp();
                }
            }
            else
            {
                pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                pFF = pNode->GetFancyFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                pPF = pNode->GetParaFormat(LC_TO_FC(pFlowLayout->LayoutContext()));

                if (!pCF->IsVisibilityHidden() && !pCF->IsDisplayNone())
                {
                    BOOL fDrawBorder = pCF->_fPadBord  && pFF->_fBlockNess;
                    BOOL fDrawBackground = fPaintBackground &&
                                           pFF->_fBlockNess &&
                                           (pFF->_lImgCtxCookie ||
                                            pFF->_ccvBackColor.IsDefined());

                    if (fDrawBackground || fDrawBorder)
                    {
                        DrawElemBgAndBorder(
                                            pNode->Element(), &aryRects,
                                            prcView, prcClip,
                                            pDI, pptOffset,
                                            fDrawBackground, fDrawBorder,
                                            cp, -1, !pCF->_cuvLineHeight.IsNull());
                    }
                }
            }
        }

        cp += ptp->GetCch();
        ptp = ptp->NextTreePos();
    }

}

//+---------------------------------------------------------------------------
//
// Member:      DrawBackgroundAndBorders()
//
// Purpose:     Draw background and borders for elements on the current line,
//              and all the consecutive lines that have background.
//
//----------------------------------------------------------------------------
void
CDisplay::DrawBackgroundForFirstLine(
    CFormDrawInfo * pDI,
    long            cpIn,
    LONG            ili,
    const RECT    * prcView,
    const RECT    * prcClip,
    const CPoint  * pptOffset)
{
    CStackPtrAry < CTreeNode *, 8 > aryNodesWithBgOrBorder(Mt(CDisplayDrawBackgroundAndBorder_aryNodesWithBgOrBorder_pv));
    CDataAry <RECT> aryRects(Mt(CDisplayDrawBackgroundAndBorder_aryRects_pv));
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    CElement    *   pElementFL  = pFlowLayout->ElementContent();
    CMarkup     *   pMarkup = pFlowLayout->GetContentMarkup();
    BOOL            fPaintBackground = pMarkup->PaintBackground();
    CTreeNode *     pNodeCurrBranch;
    CTreePos  *     ptp;
    long            ich;
    long            cchPreChars = 0;
    long            cchPreCharsInLine;
    
    Assert(cpIn == CpFromLine(ili));

    if (Elem(ili)->_fPartOfRelChunk)
        goto Cleanup;

    FormattingNodeForLine(FNFL_NONE, cpIn, NULL, Elem(ili)->_cch, &cchPreChars, NULL, NULL);
    
    cpIn += cchPreChars;
    cchPreCharsInLine = cchPreChars;
    
    // initialize the tree pos that corresponds to the begin cp of the
    // current line
    ptp = pMarkup->TreePosAtCp(cpIn, &ich, TRUE);

    // first draw any backgrounds extending into the current region
    // from the previous line.
    pNodeCurrBranch = ptp->GetBranch();

    if(    DifferentScope(pNodeCurrBranch, pElementFL)
        && ( pElementFL->IsOverlapped() ?
              pElementFL->GetFirstCp() < pNodeCurrBranch->Element()->GetFirstCp() :
              TRUE
           ) // protect against weird overlapping (#99003)
      )
    {
        {
            CTreeNode *pNode = pNodeCurrBranch;

            // run up the current branch and find the ancestors with background
            // or border
            while(pNode && !SameScope(pNode, pElementFL))
            {
                if (!pNode->ShouldHaveLayout())
                {
                    // push this element on to the stack
                    aryNodesWithBgOrBorder.Append(pNode);
                }
                pNode = pNode->Parent();
            }

            Assert(pNode);
        }
        
        // now that we have all the elements with background or borders
        // for the current branch render them.
        for(long lSize = aryNodesWithBgOrBorder.Size() - 1; lSize >= 0; lSize--)
        {
            CTreeNode * pNode = aryNodesWithBgOrBorder[lSize];

            const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
            const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
            const CParaFormat  * pPF = pNode->GetParaFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
            if (!pCF->IsVisibilityHidden() && !pCF->IsDisplayNone())
            {
                CLSMeasurer me(this);
                CLinePtr rp(this);
                LONG cpLayoutStart = GetFirstCp();
                LONG cpStart;
                LONG cpStop = 0;

                rp.RpSetCp(cpIn, FALSE, TRUE, TRUE);

                cchPreCharsInLine = cchPreChars;
                if (rp->oi()->_fHasFloatedFL)
                {
                    rp.RpSetCp(cpIn - cchPreCharsInLine + rp->_cch, FALSE, TRUE, TRUE);
                    cchPreCharsInLine = 0;
                }
                
                if (pFF->_fHasFirstLine)
                {
                    LONG cpElemFirst = pNode->Element()->GetFirstCp();

                    if (cpElemFirst < (long)rp.GetCp() + cpLayoutStart + rp->_cch - cchPreCharsInLine)
                    {
                        me.PseudoLineEnable(pNode);
                        cpStart = rp.GetCp() + cpLayoutStart - cchPreCharsInLine;
                        cpStop = cpStart + rp->_cch;
                        if (rp->_cch != 0)
                            cpStop--;
                        
                        pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                        pPF = pNode->GetParaFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                        pFF = pNode->GetFancyFormat(LC_TO_FC(pFlowLayout->LayoutContext()));

                        BOOL fHasPseudoBg = FALSE;
                        if (pFF->_iPEI != -1)
                        {
                            const CPseudoElementInfo* pPEI = GetPseudoElementInfoEx(pFF->_iPEI);
                            fHasPseudoBg = pPEI->_lImgCtxCookie || pPEI->_ccvBackColor.IsDefined();
                        }

                        BOOL fDrawBackground =    fPaintBackground
                                               && pFF->_fBlockNess
                                               && fHasPseudoBg;

                        if (fDrawBackground)
                        {
                            DrawElemBgAndBorder(
                                pNode->Element(), &aryRects,
                                prcView, prcClip,
                                pDI, pptOffset,
                                TRUE, FALSE,
                                cpStart, cpStop, fHasPseudoBg || !pCF->_cuvLineHeight.IsNull(), FALSE, fHasPseudoBg);
                        }

                        me.PseudoLineDisable();

                        pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                        pPF = pNode->GetParaFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                        pFF = pNode->GetFancyFormat(LC_TO_FC(pFlowLayout->LayoutContext()));

                        BOOL fDrawBorder = pCF->_fPadBord  && pFF->_fBlockNess;
                        if (fDrawBorder)
                        {
                            DrawElemBgAndBorder(
                                                pNode->Element(), &aryRects,
                                                prcView, prcClip,
                                                pDI, pptOffset,
                                                FALSE, TRUE,
                                                cpIn - cchPreChars, -1, !pCF->_cuvLineHeight.IsNull());
                        }
                    }
                }
            } // if visibility ...
        } // outer for loop
    } // if different scope...

Cleanup:
    return;
}


    
//+----------------------------------------------------------------------------
//
// Function:    BoundingRectForAnArrayOfRectsWithEmptyOnes
//
// Synopsis:    Find the bounding rect that contains a given set of rectangles
//              It does not ignore the rectangles that have left=right, top=bottom
//              or both. It still ignores the rects that have left=right=top=bottom=0
//
//-----------------------------------------------------------------------------

void
BoundingRectForAnArrayOfRectsWithEmptyOnes(RECT *prcBound, CDataAry<RECT> * paryRects)
{
    RECT *  prc;
    LONG    iRect;
    LONG    lSize = paryRects->Size();
    BOOL    fFirst = TRUE;

    SetRectEmpty(prcBound);

    for(iRect = 0, prc = *paryRects; iRect < lSize; iRect++, prc++)
    {
        if((prc->left <= prc->right && prc->top <= prc->bottom) &&
            (prc->left != 0 || prc->right != 0 || prc->top != 0 || prc->bottom != 0) )
        {
            if(fFirst)
            {
                *prcBound = *prc;
                fFirst = FALSE;
            }
            else
            {
                if(prcBound->left > prc->left) prcBound->left = prc->left;
                if(prcBound->top > prc->top) prcBound->top = prc->top;
                if(prcBound->right < prc->right) prcBound->right = prc->right;
                if(prcBound->bottom < prc->bottom) prcBound->bottom = prc->bottom;
            }
        }
    }
}


//+----------------------------------------------------------------------------
//
// Function:    BoundingRectForAnArrayOfRects
//
// Synopsis:    Find the bounding rect that contains a given set of rectangles
//
//-----------------------------------------------------------------------------

void
BoundingRectForAnArrayOfRects(RECT *prcBound, CDataAry<RECT> * paryRects)
{
    RECT *  prc;
    LONG    iRect;
    LONG    lSize = paryRects->Size();

    SetRectEmpty(prcBound);

    for(iRect = 0, prc = *paryRects; iRect < lSize; iRect++, prc++)
    {
        if(!IsRectEmpty(prc))
        {
            UnionRect(prcBound, prcBound, prc);
        }
    }
}


//+----------------------------------------------------------------------------
//
// Member:      DrawElementBackground
//
// Synopsis:    Draw the background for a an element, given the region it
//              occupies in the display
//
//-----------------------------------------------------------------------------

void
CDisplay::DrawElementBackground(CTreeNode * pNodeContext,
                                CDataAry <RECT> * paryRects, RECT * prcBound,
                                const RECT * prcView, const RECT * prcClip,
                                CFormDrawInfo * pDI, BOOL fPseudo)
{
    RECT    rcDraw;
    RECT    rcBound = { 0 };
    RECT *  prc;
    LONG    lSize;
    LONG    iRect;
    SIZE    sizeImg;
    CPoint  ptBackOrg;
    CBackgroundInfo bginfo;
    CColorValue    ccvBackColor;
    const CFancyFormat * pFF = pNodeContext->GetFancyFormat(LC_TO_FC(GetFlowLayout()->LayoutContext()));
    BOOL  fBlockElement = pNodeContext->Element()->IsBlockElement();

    Assert(pFF->_lImgCtxCookie || pFF->_ccvBackColor.IsDefined() || fPseudo);

    CDoc *    pDoc    = GetFlowLayout()->Doc();
    CImgCtx * pImgCtx;
    LONG lImgCtxCookie;
    
    if (fPseudo)
    {
        Assert(pFF->_iPEI >= 0);
        const CPseudoElementInfo* pPEI = GetPseudoElementInfoEx(pFF->_iPEI);
        lImgCtxCookie = pPEI->_lImgCtxCookie;
        ccvBackColor = pPEI->_ccvBackColor;
    }
    else
    {
        lImgCtxCookie = pFF->_lImgCtxCookie;
        ccvBackColor = pFF->_ccvBackColor;
    }
    
    pImgCtx = lImgCtxCookie ? pDoc->GetUrlImgCtx(lImgCtxCookie) : 0;

    if (pImgCtx && !(pImgCtx->GetState(FALSE, &sizeImg) & IMGLOAD_COMPLETE))
        pImgCtx = NULL;

    // if the background image is not loaded yet and there is no background color
    // return (we dont have anything to draw)
    if(!pImgCtx && !ccvBackColor.IsDefined())
        return;

    // now given the rects for a given element
    // draw its background

    // if we have a background image, we need to compute its origin

    lSize = paryRects->Size();

    if(lSize == 0)
        return;

    memset(&bginfo, 0, sizeof(bginfo));

    bginfo.pImgCtx       = pImgCtx;
    bginfo.lImgCtxCookie = lImgCtxCookie;
    bginfo.crTrans       = COLORREF_NONE;
    bginfo.crBack        = ccvBackColor.IsDefined()
        ? ccvBackColor.GetColorRef()
        : COLORREF_NONE;

    if (pImgCtx || fBlockElement)
    {
        if(!prcBound)
        {
            // compute the bounding rect for the element.
            BoundingRectForAnArrayOfRects(&rcBound, paryRects);
        }
        else
            rcBound = *prcBound;
    }

    if (pImgCtx)
    {
        if(!IsRectEmpty(&rcBound))
        {
            SIZE sizeBound;

            sizeBound.cx = rcBound.right - rcBound.left;
            sizeBound.cy = rcBound.bottom - rcBound.top;

            GetBgImgSettings(pFF, &bginfo);
            CalcBgImgRect(pNodeContext, pDI, &sizeBound, &sizeImg, &ptBackOrg, &bginfo);

            OffsetRect(&bginfo.rcImg, rcBound.left, rcBound.top);

            ptBackOrg.x += rcBound.left - prcView->left;
            ptBackOrg.y += rcBound.top - prcView->top;

            bginfo.ptBackOrg = ptBackOrg;
        }
    }

    prc = *paryRects;
    rcDraw = *prc++;

    //
    // Background for block element needs to extend for the
    // left to right of rcBound.
    //
    if (fBlockElement)
    {
        rcDraw.left  = rcBound.left;
        rcDraw.right = rcBound.right;
    }

    for(iRect = 1; iRect <= lSize; iRect++, prc++)
    {
        if(iRect == lSize || !IsRectEmpty(prc))
        {
            if (iRect != lSize)
            {
                if (fBlockElement)
                {
                    if (prc->top < rcDraw.top)
                        rcDraw.top = prc->top;
                    if (prc->bottom > rcDraw.bottom)
                        rcDraw.bottom = prc->bottom;
                    continue;
                }
                else if (   prc->left == rcDraw.left
                        &&  prc->right == rcDraw.right
                        &&  prc->top == rcDraw.bottom)
                {
                    // add the current rect
                    rcDraw.bottom = prc->bottom;
                    continue;
                }
            }

            {
                IntersectRect(&rcDraw, prcClip, &rcDraw);

                if(!IsRectEmpty(&rcDraw))
                {
                    IntersectRect(&bginfo.rcImg, &bginfo.rcImg, &rcDraw);
                    GetFlowLayout()->DrawBackground(pDI, &bginfo, &rcDraw);
                }

                if(iRect != lSize)
                    rcDraw = *prc;
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:    DrawElementBorder
//
// Synopsis:    Find the bounding rect that contains a given set of rectangles
//
//-----------------------------------------------------------------------------

void
CDisplay::DrawElementBorder(CTreeNode * pNodeContext,
                                CDataAry <RECT> * paryRects, RECT * prcBound,
                                const RECT * prcView, const RECT * prcClip,
                                CFormDrawInfo * pDI)
{
    CBorderInfo borderInfo;
    CElement *  pElement = pNodeContext->Element();

    if (pNodeContext->GetCharFormat(LC_TO_FC(GetFlowLayout()->LayoutContext()))->IsVisibilityHidden())
        return;

    if ( !pElement->_fDefinitelyNoBorders &&
         FALSE == (pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper(pNodeContext, pDI, &borderInfo, GBIH_ALL ) ) )
    {
        RECT rcBound;

        if(!prcBound)
        {
            if(paryRects->Size() == 0)
                return;

            // compute the bounding rect for the element.
            BoundingRectForAnArrayOfRects(&rcBound, paryRects);
        }
        else
            rcBound = *prcBound;

        // If we're a broken layout, we may only be displaying part of
        // pElement, so we might not want to draw the top or bottom border.
        CFlowLayout *pFL = GetFlowLayout();
        if ( pFL->LayoutContext() )
        {
            // We're a broken layout.
            // Does pElement begin before us?
            if ( pElement->GetFirstCp() < pFL->GetContentFirstCpForBrokenLayout() )
                borderInfo.wEdges &= ~BF_TOP; // yes, turn off top border if it's on.

            // Does pElement end after us?
            if ( pElement->GetLastCp() > pFL->GetContentLastCpForBrokenLayout() )
                borderInfo.wEdges &= ~BF_BOTTOM; // yes, turn off bottom border if it's on.
        }

        DrawBorder(pDI, &rcBound, &borderInfo);
    }
}


// =============================  Misc  ===========================================

//+--------------------------------------------------------------------------------
//
// Synopsis: return true if this is the last text line in the line array
//---------------------------------------------------------------------------------
BOOL
CDisplay::IsLastTextLine(LONG ili)
{
    Assert(ili >= 0 && ili < LineCount());
    if (LineCount() == 0)
        return TRUE;
    
    for(LONG iliT = ili + 1; iliT < LineCount(); iliT++)
    {
        if(Elem(iliT)->IsTextLine())
            return FALSE;
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     FormattingNodeForLine
//
//  Purpose:    Returns the node which controls the formatting at the BOL. This
//              is needed because the first char on the line may not necessarily
//              be the first char in the paragraph.
//
//----------------------------------------------------------------------------
CTreeNode *
CDisplay::FormattingNodeForLine(
    DWORD        dwFlags,                   // IN
    LONG         cpForLine,                 // IN
    CTreePos    *ptp,                       // IN
    LONG         cchLine,                   // IN
    LONG        *pcch,                      // OUT
    CTreePos   **pptp,                      // OUT
    BOOL        *pfMeasureFromStart) const  // OUT
{
    CFlowLayout  *pFlowLayout = GetFlowLayout();
    BOOL          fIsEditable = pFlowLayout->IsEditable();
    CMarkup      *pMarkup     = pFlowLayout->GetContentMarkup();
    CTreeNode    *pNode       = NULL;
    CElement     *pElement;
    LONG          lNotNeeded;
    LONG          cch = cchLine;
    BOOL          fSawOpenLI  = FALSE;
    BOOL          fSeenAbsolute = FALSE;
    BOOL          fSeenBeginBlockTag = FALSE;
    BOOL          fStopAtGlyph = dwFlags & FNFL_STOPATGLYPH ? TRUE : FALSE;
    BOOL          fContinueLooking = TRUE;
    
    // AssertSz(!pFlowLayout->IsDirty(), "Called when line array dirty -- not a measurer/renderer problem!");

    AssertSz(!fStopAtGlyph || pfMeasureFromStart == NULL,
             "Cannot do both -- stopping at glyph and measuring from the start!");
    
    if (!ptp)
    {
        ptp = pMarkup->TreePosAtCp(cpForLine, &lNotNeeded, TRUE);
        Assert(ptp);
    }
    else
    {
        Assert(ptp->GetCp() <= cpForLine);
        Assert(ptp->GetCp() + ptp->GetCch() >= cpForLine);
    }
    if (pfMeasureFromStart)
        *pfMeasureFromStart = FALSE;
    while(fContinueLooking && cch > 0 && ptp) // check this in before end of milestone && ptp)
    {
        const CCharFormat *pCF;

        if (ptp->IsPointer())
        {
            ptp = ptp->NextTreePos();
            continue;
        }

        if (ptp->IsText())
        {
            if (ptp->Cch())
                break;
            else
            {
                ptp = ptp->NextTreePos();
                continue;
            }
        }

        if (   fStopAtGlyph
            && ptp->ShowTreePos()
           )
        {
            break;
        }
        
        Assert(ptp->IsNode());

        pNode = ptp->Branch();
        pElement = pNode->Element();
        pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        
        if (pfMeasureFromStart)
        {
            if (   (fIsEditable && ptp->IsNode() && ptp->ShowTreePos())
                || pNode->HasInlineMBP(LC_TO_FC(LayoutContext()))
                || (   !pFlowLayout->IsElementBlockInContext(pElement)
                    && pCF->_fHasInlineBg
                   )
               )
            {
                *pfMeasureFromStart = TRUE;
            }
        }
        
        if (ptp->IsBeginElementScope())
        {
            if (fSeenAbsolute)
                break;
            
            if (pCF->IsDisplayNone())
            {
                cch -= pFlowLayout->GetNestedElementCch(pElement, &ptp);
                cch += ptp->GetCch();
                pNode = pNode->Parent();
            }
            else if (pNode->ShouldHaveLayout(LC_TO_FC(LayoutContext())))
            {
                if (pNode->IsAbsolute(LC_TO_FC(LayoutContext())))
                {
                    cch -= pFlowLayout->GetNestedElementCch(pElement, &ptp);
                    cch += ptp->GetCch();
                    pNode = pNode->Parent();
                    fSeenAbsolute = TRUE;
                }
                else
                {
                    break;
                }
            }
            else if (pElement->Tag() == ETAG_BR)
            {
                break;
            }
            else if (   pElement->IsFlagAndBlock(TAGDESC_LIST)
                     && fSawOpenLI)
            {
                CTreePos * ptpT = ptp;

                do
                {
                    ptpT = ptpT->PreviousTreePos();
                } while (ptpT->GetCch() == 0);

                pNode = ptpT->Branch();

                break;
            }                        
            else if (pElement->IsTagAndBlock(ETAG_LI))
            {
                fSawOpenLI = TRUE;
            }
            else if (pFlowLayout->IsElementBlockInContext(pElement))
            {
                fSeenBeginBlockTag = TRUE;
                if (pCF->HasPadBord(FALSE))
                {
                    CDoc *pDoc = pFlowLayout->Doc();
                    const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
                    BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
                    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
                    LONG lFontHeight = pCF->GetHeightInTwips(pDoc);
                    CCalcInfo ci(pFlowLayout);
                    
                    if (!pElement->_fDefinitelyNoBorders)
                    {
                        CBorderInfo borderinfo;

                        pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper( pNode, &ci, &borderinfo, GBIH_NONE );
                        if (   !pElement->_fDefinitelyNoBorders
                            && borderinfo.aiWidths[SIDE_TOP]
                           )
                        {
                            fContinueLooking = FALSE;
                        }
                    }

                    LONG yPadTop = pFF->GetLogicalPadding(SIDE_TOP, fNodeVertical, fWritingModeUsed).YGetPixelValue(
                                                    &ci,
                                                    ci._sizeParent.cx, 
                                                    lFontHeight);
                    if (yPadTop)
                    {
                        fContinueLooking = FALSE;
                    }
                }
            }
        }
        else if (ptp->IsEndNode())
        {
            if (fSeenAbsolute)
                break;
            
            //
            // If we encounter a break on empty block end tag, then we should
            // give vertical space otherwise a <X*></X> where X is a block element
            // will not produce any vertical space. (Bug 45291).
            //
            if (   fSeenBeginBlockTag 
                && pElement->_fBreakOnEmpty
                && pFlowLayout->IsElementBlockInContext(pElement)
               )
            {
                break;
            }
            
            if (   fSawOpenLI                       // Skip over the close LI, unless we saw an open LI,
                && ptp->IsEdgeScope()               // which would imply that we have an empty LI.  An
                && pElement->IsTagAndBlock(ETAG_LI) // empty LI gets a bullet, so we need to break.
               )
                break;
            pNode = pNode->Parent();
        }

        cch -= ptp->NodeCch();
        ptp = ptp->NextTreePos();

        Assert(ptp && "Null TreePos, crash protected but invalid measureing/rendering will occur");
    }

    if (pcch)
    {
        *pcch = cchLine - cch;
    }

    if (pptp)
    {
        *pptp = ptp;
    }

    if (!pNode && ptp)
    {
        pNode = ptp->GetBranch();
        if (ptp->IsEndNode())
            pNode = pNode->Parent();
    }

    return pNode;
}

//+---------------------------------------------------------------------------
//
//  Member:     EndNodeForLine
//
//  Purpose:    Returns the first node which ends this line. If the line ends
//              because of insufficient width, then the node is the node
//              above the last character in the line, else it is the node
//              which causes the line to end (like /p).
//
//----------------------------------------------------------------------------
CTreeNode *
CDisplay::EndNodeForLine(
    LONG         cpEndForLine,              // IN
    CTreePos    *ptp,                       // IN
    CCalcInfo   *pci,                       // IN
    LONG        *pcch,                      // OUT
    CTreePos   **pptp,                      // OUT
    CTreeNode  **ppNodeForAfterSpace) const // OUT
{
    CFlowLayout  *pFlowLayout = GetFlowLayout();
    BOOL          fIsEditable = pFlowLayout->IsEditable();
    CTreePos     *ptpStart, *ptpStop;
    CTreePos     *ptpNext = ptp;
    CTreePos     *ptpOriginal = ptp;
    CTreeNode    *pNode;
    CElement     *pElement;
    CTreeNode    *pNodeForAfterSpace = NULL;
    CCalcInfo     ci;
    BOOL          fSeenBlockElement = FALSE;
    BOOL          fSeenPadBord = FALSE;
    
    //
    // If we are in the middle of a text run then we do not need to
    // do anything, since this line will not be getting any para spacing
    //
    if (   ptpNext->IsText()
        && ptpNext->GetCp() < cpEndForLine
       )
        goto Cleanup;

    //
    // Construct a calc info if we do not have one already.
    //
    if (pci == NULL)
    {
        ci.Init(pFlowLayout);
        pci = &ci;
    }
    
    pFlowLayout->GetContentTreeExtent(&ptpStart, &ptpStop);

    //
    // We should never be here if we start measuring at the beginning
    // of the layout.
    //
    Assert(ptp != ptpStart);

    ptpStart = ptpStart->NextTreePos();
    while (ptp != ptpStart)
    {
        ptpNext = ptp;
        ptp = ptp->PreviousTreePos();

        if (ptp->IsPointer())
            continue;

        if (ptp->IsNode())
        {
            if (fIsEditable && ptp->ShowTreePos())
                break;

            pNode = ptp->Branch();
            pElement = pNode->Element();
            if (ptp->IsEndElementScope())
            {
                const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                if (pCF->IsDisplayNone())
                {
                    pElement->GetTreeExtent(&ptp, NULL);
                }
                else if (pNode->ShouldHaveLayout(LC_TO_FC(pFlowLayout->LayoutContext())))
                {
                    // We need to collect after space info from the nodes which
                    // have layouts.
                    if (pElement->IsOwnLineElement(pFlowLayout))
                    {
                        pNodeForAfterSpace = pNode;
                    }
                    break;
                }
                else if (pElement->Tag() == ETAG_BR)
                    break;
                else if (pFlowLayout->IsElementBlockInContext(pElement))
                {
                    if (fSeenPadBord)
                        break;
                    else
                    {
                        const CFancyFormat *pFF = pNode->GetFancyFormat();
                        const CCharFormat  *pCF = pNode->GetCharFormat();
                        LONG lFontHeight = pCF->GetHeightInTwips(pElement->Doc());
    
                        if (pFF->GetLogicalPadding(SIDE_BOTTOM, pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed).YGetPixelValue(pci,
                                                                  pci->_sizeParent.cx, 
                                                                  lFontHeight))
                        {
                            fSeenPadBord = TRUE;
                            if (fSeenBlockElement)
                                break;
                        }

                        if (!pElement->_fDefinitelyNoBorders)
                        {
                            CBorderInfo borderinfo;

                            pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper( pNode, pci, &borderinfo, GBIH_NONE );
                            if (   !pElement->_fDefinitelyNoBorders
                                && borderinfo.aiWidths[SIDE_BOTTOM]
                               )
                            {
                                fSeenPadBord = TRUE;
                                if (fSeenBlockElement)
                                    break;
                            }
                        }
                    }
                    fSeenBlockElement = TRUE;
                }
            }
            else if (ptp->IsBeginElementScope())
            {
                if (    pFlowLayout->IsElementBlockInContext(pElement)
                    ||  !pNode->Element()->IsNoScope())
                    break;
                else if (   pElement->_fBreakOnEmpty
                         && pFlowLayout->IsElementBlockInContext(pElement)
                        )
                    break;
            }
        }
        else
        {
            Assert(ptp->IsText());
            if (ptp->Cch())
                break;
        }
    }

    Assert(ptpNext);
    
Cleanup:
    if (pptp)
        *pptp = ptpNext;
    if (pcch)
    {
        if (ptpNext == ptpOriginal)
            *pcch = 0;
        else
            *pcch = cpEndForLine - ptpNext->GetCp();
    }
    if (ppNodeForAfterSpace)
        *ppNodeForAfterSpace = pNodeForAfterSpace;
    
    return ptpNext->GetBranch();
}

long
ComputeLineShift(htmlAlign  atAlign,
                 BOOL       fRTLDisplay,
                 BOOL       fRTLLine,
                 BOOL       fMinMax,
                 long       xWidthMax,
                 long       xWidth,
                 UINT *     puJustified,
                 long *     pdxRemainder)
{
    long xShift = 0;
    long xRemainder = 0;

    switch(atAlign)
    {
    case htmlAlignNotSet:
        if(!fRTLLine)
            *puJustified = JUSTIFY_LEAD;
        else
            *puJustified = JUSTIFY_TRAIL;
        break;

    case htmlAlignLeft:
        *puJustified = JUSTIFY_LEAD;
        break;

    case htmlAlignRight:
        *puJustified = JUSTIFY_TRAIL;
        break;

    case htmlAlignCenter:
        *puJustified = JUSTIFY_CENTER;
        break;

    case htmlBlockAlignJustify:
        // This test is required so that final lines of RTL paragraphs
        // align to the correct side. We have lied to LineServices that
        // the paragraph is LSKALIGN is left. We handle measurements
        // ourselves instead of letting LS do this for us.
        if(!fRTLLine)
            *puJustified = JUSTIFY_FULL;
        else
            *puJustified = JUSTIFY_TRAIL;
        break;

    default:
        AssertSz(FALSE, "Did we introduce new type of alignment");
        break;
    }

    if (!fMinMax)
    {
        // WARNING: Duplicate of the logic in RecalcLineShift.
        //          Make it a function if it gets any more complex than this!
        if (*puJustified != JUSTIFY_FULL)
        {
            if (*puJustified != JUSTIFY_LEAD)
            {
                // for pre whitespace is already include in _xWidth
                xShift = xWidthMax - xWidth;
                xShift = max(xShift, 0L);           // Don't allow alignment to go < 0
                                                    // (need this for overflow lines)
                if (*puJustified == JUSTIFY_CENTER)
                {
                    Assert(atAlign == htmlAlignCenter);
                    xShift /= 2;
                }
            }
            xRemainder = xWidthMax - xWidth - xShift;
        } 
        
        // In RTL display, overflow lines must stretch to the left, with negative xShift
        if (fRTLDisplay && xWidthMax < xWidth)
        {
            xShift = xWidthMax - xWidth;
        }
    }

    Assert(pdxRemainder != NULL);
    *pdxRemainder = xRemainder;

    return xShift;
}

extern CDispNode * EnsureContentNode(CDispNode * pDispContainer);

HRESULT
CDisplay::InsertNewContentDispNode(CDispNode *  pDNBefore,
                                   CDispNode ** ppDispContent,
                                   long         iLine,
                                   long         yHeight)
{
    HRESULT       hr  = S_OK;
    CFlowLayout * pFlowLayout     = GetFlowLayout();
    CDispNode   * pDispContainer  = pFlowLayout->GetElementDispNode(); 
    CDispNode   * pDispNewContent = NULL;

    if (!pDispContainer)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // if a content node is not created yet, ensure that we have a content node.
    //
    if (!pDNBefore)
    {
        pDispContainer = pFlowLayout->EnsureDispNodeIsContainer();
        if (!pDispContainer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        EnsureContentNode(pDispContainer);

        pDNBefore = pFlowLayout->GetFirstContentDispNode();

        Assert(pDNBefore);

        if (!pDNBefore)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        *ppDispContent = pDNBefore;
    }

    Assert(pDispContainer->IsContainer());

    //
    // Create a new content dispNode and size the previous dispNode
    //

    pDispNewContent = CDispLeafNode::New(pFlowLayout, DISPEX_EXTRACOOKIE);

    if (!pDispNewContent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pDispNewContent->SetPosition(CPoint(0, yHeight));
    pDispNewContent->SetSize(CSize(_xWidthView, 1), NULL, FALSE);

    pDispNewContent->SetVisible(pDispContainer->IsVisible());
    pDispNewContent->SetExtraCookie((void *)(DWORD_PTR)(iLine));
    pDispNewContent->SetLayerFlow();

    pDNBefore->InsertSiblingNode(pDispNewContent, CDispNode::after);

    *ppDispContent = pDispNewContent;
    
Cleanup:
    RRETURN(hr);
}

HRESULT
CDisplay::HandleNegativelyPositionedContent(CLineFull   * pliNew,
                                            CLSMeasurer * pme,
                                            CDispNode   * pDNBefore,
                                            long          iLinePrev,
                                            long          yHeight)
{
    HRESULT     hr = S_OK;
    CDispNode * pDNContent = NULL;

    Assert(pliNew);

    NoteMost(pliNew);

    if (iLinePrev > 0)
    {
        long yLineTop = pliNew->GetYTop();

        //
        // Create and insert a new content disp node, if we have negatively
        // positioned content.
        //
        
        // NOTE(SujalP): Changed from GetYTop to _yBeforeSpace. The reasons are
        // outlined in IE5 bug 62737.
        if (pliNew->_yBeforeSpace < 0 && !pliNew->_fDummyLine)
        {
            hr = InsertNewContentDispNode(pDNBefore, &pDNContent, iLinePrev, yHeight + yLineTop);
            if (hr)
                goto Cleanup;

            _fHasMultipleTextNodes = TRUE;

            if (pDNBefore == pme->_pDispNodePrev)
                pme->_pDispNodePrev = pDNContent;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------------
//
//  Member : ElementResize
//
//  Synopsis : CDisplay helper function to resize the element when the text content
//      has been remeasured and the container needs to be resized
//
//--------------------------------------------------------------------------------
void
CDisplay::ElementResize(CFlowLayout * pFlowLayout, BOOL fForceResize)
{
    if (!pFlowLayout)
        return;

    // If our contents affects our size, ask our parent to initiate a re-size
    if (    pFlowLayout->GetAutoSize()
        ||  pFlowLayout->_fContentsAffectSize
        ||  fForceResize)
    {
        pFlowLayout->ElementOwner()->ResizeElement();
    }
}

//+-------------------------------------------------------------------------------
//
//  Member : UndoMeasure
//
//--------------------------------------------------------------------------------

// TODO: (KTam, track bug 111968): 
// Currently this is really pretty much a hack; undoing measuring
// a line is a thoroughly involved process that requires rolling back state
// maintained in CLSMeasurer, CRecalcLinePtr, cached values like the rel
// dispnode cache a yMostNeg etc.  For B2, we're only going to solve the most
// problematic of measurement side-effects, which is layout/dispnode creation.

#if DBG
static BOOL
ElementHasExpectedLayouts( CLayoutContext *pLayoutContext, CElement *pElement, CMarkup *pMarkup )
{
    // CAUTION: Do not do anything in this function that causes data changes
    // (e.g. creation of layouts!).

    // Most elements needing layout who've just had their first
    // line measured should have 1 layout, but some may have 2
    // if they needed to be measured in a compatible context first.
    // (tables, % sizing).

    int nLayouts = pElement->GetLayoutAry()->Size();
    Assert(nLayouts == 1 || nLayouts == 2);

    // Should never be called with a compatible context as a param; that
    // implies we were doing line breaking in compatible mode.
    if ( pMarkup->HasCompatibleLayoutContext() )
        Assert( pMarkup->GetCompatibleLayoutContext() != pLayoutContext );

    // If an element has 2 layouts at this point, 1 of them
    // better be in the compatible context!
    if ( nLayouts == 2 )
    {
        Assert( pMarkup->HasCompatibleLayoutContext() );
        Assert( pElement->CurrentlyHasLayoutInContext( pMarkup->GetCompatibleLayoutContext() ) );
    }

    // The element better have a layout in the current context
    Assert( pElement->CurrentlyHasLayoutInContext( pLayoutContext ) );

    return TRUE;
}
#endif

void
CDisplay::UndoMeasure( CLayoutContext *pLayoutContext, long cpStart, long cpEnd )
{
    CTreePos *ptp;
    long      lOffset;
    long      cpCur;
    CTreeNode *pNode;
    CElement  *pElement;
    CLayout   *pLayout;

    Assert(pLayoutContext && "Illegal to call UndoMeasure for NULL layout context !!!");

    CMarkup *pMarkup = GetMarkup();

    cpCur = cpStart;
    ptp   = pMarkup->TreePosAtCp( cpStart, &lOffset, TRUE /* fAdjustForward */ );

    while ( cpCur < cpEnd )
    {
        if ( ptp->IsBeginElementScope() )
        {
            pNode = ptp->Branch();
            Assert( pNode );
            pElement = pNode->Element();
            Assert( !pElement->HasLayoutPtr() ); // we should only be here for paginated content, which must be measured w/in a context, so we can't have a standalone layout
            if ( pElement->HasLayoutAry() )
            {
                CLayoutAry *   pLA = pElement->GetLayoutAry();

#if DBG == 1
                // 
                //  Here we should be VERY careful. We are allowed to destroy only layouts 
                //  that are beginnings of their elements. (Destroying layout from the 
                //  middle of layout view chain is a very bad thing.) 
                //
                CLayoutBreak *pLayoutBreak;
                pLayoutContext->GetLayoutBreak(pElement, &pLayoutBreak);
                Assert(!pLayoutBreak && "Attempt to destroy layout from the middle of layout's view chain!!!");
#endif 

                // remove the layout in this context
                pLayout = pLA->RemoveLayoutWithContext( pLayoutContext );
                if (pLayout)
                {
                    // before removing layout itself destroy break entry that this layout might create
                    pLayoutContext->RemoveLayoutBreak(pElement);

                    Assert( pLA->Size() <= 1 );  // size should be 0 or 1
                    pLayout->Detach();
                    pLayout->Release();
                }

                // If the element also has a layout in the compatible context,
                // we don't want to get rid of it or the array. otherwise pLA
                // should be empty and we can toss it.
                if (!pLA->Size())
                {
                    pElement->DelLayoutAry(FALSE); // will take care of detaching/releasing its layouts
                }
            }
        }

        ptp = ptp->NextTreePos();
        if (!ptp)
            break;

        cpCur = ptp->GetCp();
    }
}


//============================================================================
//
//  CFlowLayoutBreak methods
//
//============================================================================
//----------------------------------------------------------------------------
//
//  Member: ~CFlowLayoutBreak
//
//  Note:   
//
//----------------------------------------------------------------------------
CFlowLayoutBreak::~CFlowLayoutBreak()
{
    if (_pMarkupPointer)
    {
        delete _pMarkupPointer;
        _pMarkupPointer = NULL;
    }
    
    _xLeftMargin    = 
    _xRightMargin   = 0;
}

#if DBG==1
LONG
CElement::GetLineCount()
{
    LONG lc = 0;
    CFlowLayout *pFL = GetFlowLayout();
    if (pFL)
    {
        lc = pFL->GetLineCount();
    }
    return lc;
}

HRESULT
CElement::GetFonts(long iLine, BSTR * pbstrFonts)
{
    HRESULT hr = E_UNEXPECTED;
    
    CFlowLayout *pFL = GetFlowLayout();
    if (pFL)
    {
        hr = THR(pFL->GetFonts(iLine, pbstrFonts));
    }
    else
    {
        CStr temp;
        temp.Set(_T("none"));
        hr = THR(temp.AllocBSTR(pbstrFonts));
    }
    RRETURN(hr);
}

HRESULT
CDisplay::GetFonts(long iLine, BSTR * pbstrFonts)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (iLine < 0l || iLine >= (long)Count())
    {
        _cstrFonts.Set(_T("none"));
    }
    else
    {
        LONG cpLine, yLine;
        POINT pt;
        CLinePtr rp(this);

        _cstrFonts.Set(_T(";"));
        rp.RpSet(iLine, 0);
        _fBuildFontList = TRUE;
        cpLine = CpFromLine(iLine, &yLine);
        pt.y = yLine;
        pt.x = rp.oi()->GetTextLeft() + 1;
        CpFromPointEx(iLine, yLine, cpLine, pt, NULL, NULL, NULL, CFP_IGNOREBEFOREAFTERSPACE,
                      NULL, NULL, NULL, NULL, NULL, NULL);
    }
    hr = THR(_cstrFonts.AllocBSTR(pbstrFonts));
    
    _fBuildFontList = FALSE;
    _cstrFonts.Free();
    RRETURN(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\ctlrange.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       txtsrang.cxx
//
//  Contents:   Implementation of Control Range
//
//  Class:      CAutoTxtSiteRange
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CTLRANGE_HXX_
#define X_CTLRANGE_HXX_
#include "ctlrange.hxx"
#endif


#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "seglist.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "siterang.hdl"

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

MtDefine(CAutoTxtSiteRange, ObjectModel, "CAutoTxtSiteRange")
MtDefine(CAutoTxtSiteRange_aryElements_pv, CAutoTxtSiteRange, "CAutoTxtSiteRange::_aryElements::_pv")
MtDefine(CAutoTxtSiteRangeIterator, ObjectModel, "CAutoTxtSiteRangeIterator")

// IOleCommandTarget methods

BEGIN_TEAROFF_TABLE(CAutoTxtSiteRange, IOleCommandTarget)
    TEAROFF_METHOD(CAutoTxtSiteRange, QueryStatus, querystatus, (GUID * pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext))
    TEAROFF_METHOD(CAutoTxtSiteRange, Exec, exec, (GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut))
END_TEAROFF_TABLE()

//+------------------------------------------------------------------------
//
//  Member:     s_classdesc
//
//  Synopsis:   class descriptor
//
//-------------------------------------------------------------------------

const CBase::CLASSDESC CAutoTxtSiteRange::s_classdesc =
{
    0,                              // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLControlRange,     // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+------------------------------------------------------------------------
//
//  Member:     CAutoTxtSiteRange constructor
//
//-------------------------------------------------------------------------

CAutoTxtSiteRange::CAutoTxtSiteRange(CElement * pElementOwner)
    : _aryElements(Mt(CAutoTxtSiteRange_aryElements_pv))
{
    _pElementOwner = pElementOwner;   
}


CAutoTxtSiteRange::~CAutoTxtSiteRange()
{
    int             iElement;
    CElementSegment **ppSegment = NULL;
    
    _EditRouter.Passivate();

    for ( iElement = _aryElements.Size(), ppSegment = _aryElements;
            iElement > 0;
            iElement--, ppSegment++ )
    {
        delete *ppSegment;
    }

    _aryElements.DeleteAll();
    
}


//+------------------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   vanilla implementation
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLControlRange)
        QI_TEAROFF(this, IOleCommandTarget, (IHTMLControlRange *)this)
        QI_INHERITS(this, IHTMLControlRange)
        QI_INHERITS(this, IHTMLControlRange2)
        QI_INHERITS(this, ISegmentList)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    } 

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CloseErrorInfo
//
//  Synopsis:   defer to base object
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::CloseErrorInfo(HRESULT hr)
{
    return _pElementOwner->CloseErrorInfo(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     add
//
//  Synopsis:   add any element that can have a laypout to the range
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::addElement(IHTMLElement *pDisp)
{
    HRESULT hr = E_POINTER;
    CElement *pElement;

    if (!pDisp)
        goto Cleanup;

    hr = THR(pDisp->QueryInterface(CLSID_CElement, (void**)&pElement));
    if (hr)
        goto Cleanup;

    return add(pElement);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAutoTxtSiteRange::add(IHTMLControlElement *pDisp)
{
    HRESULT hr = E_POINTER;
    CElement *pElement;

    if (!pDisp)
        goto Cleanup;

    hr = THR(pDisp->QueryInterface(CLSID_CElement, (void**)&pElement));
    if (hr)
        goto Cleanup;

    return add(pElement);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     add
//
//  Synopsis:   add a site to the range
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::add(CElement *pElement)
{
    HRESULT     hr = E_INVALIDARG;
    ELEMENT_TAG eTag;
    CTreeNode * pNode;

    Assert(pElement);

    //
    // Check to see whether this element is a "site"
    //
    pNode = pElement->GetFirstBranch();
    if (! (pNode && pNode->ShouldHaveLayout()) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
        
    //
    // Do not allow table content to be added per bug 44154
    //
    eTag = pElement->Tag();
    switch (eTag)
    {
    case ETAG_BODY:
    case ETAG_TD:
    case ETAG_TR:
    case ETAG_TH:
    case ETAG_TC:
    case ETAG_CAPTION:
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    //
    // Verify that the element being added is within the hierarchy
    // of the owner
    //
    pNode = pElement->GetFirstBranch();
    if ( (pNode == NULL) || (pNode->SearchBranchToRootForScope( _pElementOwner ) == NULL) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // It's OK to add the element
    //
    hr = THR( AddElement( pElement) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT 
CAutoTxtSiteRange::AddElement( CElement* pElement )
{
    IHTMLElement    *pElem = NULL;
    CElementSegment *pSegment = NULL;
    HRESULT         hr;
    
    pSegment = new CElementSegment();
    if( !pSegment )
        goto Error;

    // Retrieve the IHTMLElement, and initialize our segment        
    IFC( pElement->QueryInterface(IID_IHTMLElement, (void **)&pElem) );
    IFC( pSegment->Init( pElem ) );

    // Add it
    IFC( _aryElements.Append( pSegment ) );
    
Cleanup:

    ReleaseInterface( pElem );
    
    RRETURN ( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     delete
//
//  Synopsis:   remove a site from the range
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::remove(long lIndex)
{
    CElementSegment *pSegment = NULL;
    HRESULT         hr = S_OK;

    if ( lIndex < 0 || lIndex >= _aryElements.Size() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pSegment = _aryElements.Item(lIndex);
    
    _aryElements.Delete(lIndex);

    pSegment->Release();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     Select
//
//  Synopsis:   turn this range into the selection, but only if there are
//      sites selected
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::select ( void )
{

    HRESULT         hr = CTL_E_METHODNOTAPPLICABLE;   
    CElement        *pElement = NULL;
    IElementSegment *pISegmentAdded = NULL;
    ISegmentList    *pSegmentList = NULL;
    IHTMLElement    *pIElement = NULL;
    CTreeNode       *pMyNode;
    CDoc            *pDoc = _pElementOwner->Doc();
    int             i;

    if (! _aryElements.Size() )
    {
        //
        // We now place the caret in the edit context
        //
        hr = pDoc->NotifySelection (
                                    EDITOR_NOTIFY_CARET_IN_CONTEXT , 
                                    (IUnknown*) (IHTMLControlRange*) this );   
    }
    else
    {

        // Make the owner current
        if ( pDoc->_state >= OS_INPLACE )
        {
            //
            // NOTE: this was an access fix - with OLE Sites not going UI Active
            // on selecting away from them. Changing currencty should do this "for free".
            //
            if (!_pElementOwner->HasCurrency() && (pDoc->_pElemCurrent->_etag == ETAG_OBJECT))
                pDoc->_pElemCurrent->YieldUI( _pElementOwner );              
        }

        //
        // TODO: (tracking bug 111961) - We should just QI for our own ISegmentList interface and
        // pass this to Select.
        //
        CSegmentList segmentList;
        BOOL		fIsPrimary;
        IFC( segmentList.SetSelectionType( SELECTION_TYPE_Control ));

        for ( i = 0; i < _aryElements.Size(); i ++ )
        {
            IFC( LookupElement( _aryElements.Item(i), &pElement ) );
            
            pMyNode = pElement->GetFirstBranch();
            Assert( pMyNode );
            if ( ! pMyNode )
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            IFC( _aryElements.Item(i)->GetElement(&pIElement) );
            IFC( segmentList.AddElementSegment( pIElement, &pISegmentAdded));      
            Assert(pISegmentAdded);
            if (pISegmentAdded)
            {
	         IFC( _aryElements.Item(i)->IsPrimary(&fIsPrimary));
	         IFC( pISegmentAdded->SetPrimary(fIsPrimary) );
            }            
            ClearInterface( &pIElement );
            ClearInterface( &pISegmentAdded );
        }

        // Select these segments
        IFC( segmentList.QueryInterface( IID_ISegmentList, (void **)&pSegmentList ) );
        IFC( pDoc->Select(pSegmentList));
    }

Cleanup:                                    

    ReleaseInterface( pISegmentAdded );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pIElement );

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     Getlength
//
//  Synopsis:   SiteRange object model
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::get_length(long * plSize)
{
    *plSize = _aryElements.Size();

    RRETURN(SetErrorInfo(S_OK));
}


//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   SiteRange object model Method
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::item ( long lIndex, IHTMLElement ** ppElem )
{
    HRESULT     hr = E_INVALIDARG;
    CElementSegment *pSegment;

    if (! ppElem)
        goto Cleanup;

    *ppElem = NULL;

    // Check Index validity, too low
    if (lIndex < 0)
        goto Cleanup;

    // ... too high
    if (lIndex >=_aryElements.Size())
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    // ... just right    
    pSegment = _aryElements[ lIndex ];

    if (! pSegment )
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = THR( pSegment->GetElement(ppElem));
    
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     scrollIntoView
//
//  Synopsis:   scroll the first control into view
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::scrollIntoView (VARIANTARG varargStart)
{
    HRESULT         hr = CTL_E_METHODNOTAPPLICABLE;
    CElementSegment *pSegment = NULL;
    CElement        *pElement = NULL;

    if (! _aryElements.Size() )
        goto Cleanup;

    //
    // Multiple selection not supported, only the first item
    // is scrolled into view
    //
    pSegment = _aryElements[ 0 ]; 
    if (! pSegment )
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    IFC( LookupElement( pSegment, &pElement ) );
    IFC( pElement->scrollIntoView(varargStart) );

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     commonParentElement()
//
//  Synopsis:   Return the common parent for elements in the control range
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoTxtSiteRange::commonParentElement ( IHTMLElement ** ppParent )
{
    HRESULT         hr = S_OK;
    LONG            nSites;
    CTreeNode       *pNodeCommon;
    int             i;
    CElement        *pElement = NULL;

    //
    // Check incoming pointer
    //
    if (!ppParent)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppParent = NULL;

    nSites = _aryElements.Size();

    if (nSites <= 0)
        goto Cleanup;

    //
    // Loop through the elements to find their common parent
    //
    IFC( LookupElement( _aryElements[0], &pElement ) );
    pNodeCommon = pElement->GetFirstBranch();
    
    for(i = 1; i < nSites; i++)
    {
        IFC( LookupElement( _aryElements[i], &pElement ) );
        pNodeCommon = pElement->GetFirstBranch()->GetFirstCommonAncestor(pNodeCommon, NULL);
    }

    if (! pNodeCommon)
        goto Cleanup;

    hr = THR( pNodeCommon->Element()->QueryInterface( IID_IHTMLElement, (void **) ppParent ) );
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo(hr) );

}


//+--------------------------------------------------------------------------
//
// Member : CTxtSiteRange::Exec
//
// Sysnopsis : deal with commands related to sites in text
//
//+--------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT         hr = S_OK;
    int             iElement;
    CDoc         *  pDoc;
    CElement     *  pElement = NULL;
    AAINDEX         aaindex;
    IUnknown *      pUnk = NULL;
    
    Assert( _pElementOwner );
    pDoc = _pElementOwner->Doc();
    Assert( pDoc );

    aaindex = FindAAIndex(DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
    if (aaindex != AA_IDX_UNKNOWN)
    {
        hr = THR(GetUnknownObjectAt(aaindex, &pUnk));
        if (hr)
            goto Cleanup;
    }
    
    //
    // Allow the elements a chance to handle the command
    //
    for ( iElement = 0; iElement < _aryElements.Size(); iElement++ )
    {
        IFC( LookupElement( _aryElements.Item( iElement ), &pElement ) );

        if (pUnk)
        {
            pElement->AddUnknownObject(
                DISPID_INTERNAL_INVOKECONTEXT, pUnk, CAttrValue::AA_Internal);
        }
        
        hr = THR( pElement->Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut));
        if (pUnk)
        {
            pElement->FindAAIndexAndDelete(
                DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
        }
        
        if (hr)
            break;
    }

    //
    // Route the command using the edit router, unless all 
    // elements handled it already
    //
    if (hr || !pElement)
    {
        hr = THR( _EditRouter.ExecEditCommand(pguidCmdGroup,
                                        nCmdID, nCmdexecopt,
                                        pvarargIn, pvarargOut,
                                        (IUnknown *) (IHTMLControlRange *)this, 
                                        pDoc ) );                
    }

Cleanup:
    ReleaseInterface(pUnk);
    RRETURN(hr);
}


VOID 
CAutoTxtSiteRange::QueryStatusSitesNeeded(MSOCMD *pCmd, INT cSitesNeeded)
{
    pCmd->cmdf = (cSitesNeeded <= _aryElements.Size()) ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED; 
}
//+--------------------------------------------------------------------------
//
// Member : CAutoTxtSiteRange::QueryStatus
//
// Sysnopsis : deal with commands related to sites in text
//
//+--------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::QueryStatus(
    GUID * pguidCmdGroup,
    ULONG cCmds,
    MSOCMD rgCmds[],
    MSOCMDTEXT * pcmdtext)
{
    MSOCMD *    pCmd = &rgCmds[0];
    HRESULT     hr = S_OK;
    CDoc  *     pDoc;
    DWORD       cmdID;

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert( _pElementOwner );
    pDoc = _pElementOwner->Doc();
    Assert( pDoc );
    
    cmdID = CBase::IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);
    switch (cmdID)
    {        
    case IDM_DYNSRCPLAY:
    case IDM_DYNSRCSTOP:

    case IDM_BROWSEMODE:
    case IDM_EDITMODE:
    case IDM_REFRESH:
    case IDM_REDO:
    case IDM_UNDO:
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        break;
        
    case IDM_SIZETOCONTROLWIDTH:
    case IDM_SIZETOCONTROLHEIGHT:
    case IDM_SIZETOCONTROL:
        QueryStatusSitesNeeded(pCmd, 2);
        break;

    case IDM_SIZETOFIT:
        QueryStatusSitesNeeded(pCmd, 1);
        break;
        
    case IDM_CODE:
    break;

    case IDM_OVERWRITE:
    case IDM_SELECTALL:
    case IDM_CLEARSELECTION:
        // Delegate this command to document
        if(_pElementOwner != NULL && _pElementOwner->Doc()!= NULL)
        {
            hr = _pElementOwner->Doc()->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
        }
        break;
    break;

    default:
        // Make sure we have at least one contol
        QueryStatusSitesNeeded(pCmd, 1);

        if (pCmd->cmdf == MSOCMDSTATE_DISABLED)
        {
            break;
        }

        // Delegate to the edit router
        hr = _EditRouter.QueryStatusEditCommand(
                    pguidCmdGroup,
                    1,
                    pCmd,
                    pcmdtext,
                    (IUnknown *) (IHTMLControlRange *)this,
                    NULL,                                       // No CMarkup ptr for Ranges
                    pDoc );

    }

    RRETURN_NOTRACE(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandSupported
//
//  Synopsis:
//
//  Returns: returns true if given command (like bold) is supported
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandSupported(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandSupported(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandEnabled
//
//  Synopsis:
//
//  Returns: returns true if given command is currently enabled. For toolbar
//          buttons not being enabled means being grayed.
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandEnabled(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandEnabled(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandState
//
//  Synopsis:
//
//  Returns: returns true if given command is on. For toolbar buttons this
//          means being down. Note that a command button can be disabled
//          and also be down.
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandState(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandState(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandIndeterm
//
//  Synopsis:
//
//  Returns: returns true if given command is in indetermined state.
//          If this value is TRUE the value returnd by queryCommandState
//          should be ignored.
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandIndeterm(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandIndeterm(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandText
//
//  Synopsis:
//
//  Returns: Returns the text that describes the command (eg bold)
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandText(BSTR bstrCmdId, BSTR *pcmdText)
{
    RRETURN(CBase::queryCommandText(bstrCmdId, pcmdText));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandValue
//
//  Synopsis:
//
//  Returns: Returns the  command value like font name or size.
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandValue(BSTR bstrCmdId, VARIANT *pvarRet)
{
    RRETURN(CBase::queryCommandValue(bstrCmdId, pvarRet));
}


//+------------------------------------------------------------------------
//
//  Member:     CAutoTxtSiteRange::execCommand
//
//  Synopsis:
//
//-------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRange::execCommand(BSTR bstrCmdId, VARIANT_BOOL showUI, VARIANT varValue,
                                        VARIANT_BOOL *pfRet)
{
    HRESULT hr = S_OK;
    BOOL fAllow;

    Assert(_pElementOwner);
    
    if (_pElementOwner->HasMarkupPtr())
    {
        hr = THR(_pElementOwner->GetMarkupPtr()->AllowClipboardAccess(bstrCmdId, &fAllow));
        if (hr || !fAllow)
            goto Cleanup;           // Fail silently

        hr = CBase::execCommand(bstrCmdId, showUI, varValue);

        if (pfRet)
        {
            // We return false when any error occures
            *pfRet = hr ? VB_FALSE : VB_TRUE;
            hr = S_OK;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     execCommandShowHelp
//
//  Synopsis:
//
//  Returns:
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::execCommandShowHelp(BSTR cmdId, VARIANT_BOOL *pfRet)
{
    HRESULT   hr;
    DWORD     dwCmdId;

    // Convert the command ID from string to number
    hr = CmdIDFromCmdName(cmdId, &dwCmdId);
    if(hr)
        goto Cleanup;

    hr = THR(CBase::execCommandShowHelp(cmdId));

Cleanup:
    if(pfRet != NULL)
    {
        // We return false when any error occures
        *pfRet = hr ? VB_FALSE : VB_TRUE;
        hr = S_OK;
    }
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRange::GetType
//
//  Synopsis:   Retrieves the type of selection this segment list contains
//
//  Arguments:  peType = OUT pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRange::GetType( SELECTION_TYPE *peType )
{
    HRESULT hr = E_FAIL;
    
    Assert( peType );

    if( peType )
    {
        *peType = SELECTION_TYPE_Control; 
        hr = S_OK;
    }        

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRange::IsEmpty
//
//  Synopsis:   Determines whether the segment list is empty or not
//
//  Arguments:  pfEmpty = Empty pointer to BOOL
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRange::IsEmpty( BOOL *pfEmpty )
{
    HRESULT hr = E_FAIL;
    
    Assert( pfEmpty );

    if( pfEmpty )
    {
        *pfEmpty = (_aryElements.Size() == 0) ? TRUE :FALSE; 
        hr = S_OK;
    }        

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRange::CreateIterator
//
//  Synopsis:   Creates an iterator that can be used to iterate over the 
//              segments in our list.
//
//  Arguments:  pIIter = Iterator to return
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRange::CreateIterator( ISegmentListIterator **pIIter )
{
    HRESULT hr = S_OK;

    CAutoTxtSiteRangeIterator *pListIter = new CAutoTxtSiteRangeIterator();

    if( pListIter == NULL )
        goto Error;

    // Initialize the iterator, and retrieve the ISegmentListIterator interface
    IFC( pListIter->Init( &_aryElements ) );
    IFC( pListIter->QueryInterface(IID_ISegmentListIterator, (void **)pIIter) );
  
Cleanup:
    ReleaseInterface( pListIter );
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRange::LookupElement
//
//  Synopsis:   Retrieves a CElement based on a CElementSegment.
//
//  Arguments:  pSegment = CElementSegment to lookup
//              pElement = Elemen to return
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRange::LookupElement( CElementSegment *pSegment, CElement **ppElement )
{
    IHTMLElement    *pIElement = NULL;
    HRESULT         hr = E_FAIL;

    Assert( pSegment && ppElement );

    if( pSegment && ppElement )
    {
        IFC( pSegment->GetElement(&pIElement) );
        IFC( pIElement->QueryInterface( CLSID_CElement, (void **)ppElement ) );
    }        

Cleanup:
    ReleaseInterface( pIElement );
    RRETURN(hr);
}    

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::CSegmentListIterator
//
//  Synopsis:   Constructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CAutoTxtSiteRangeIterator::CAutoTxtSiteRangeIterator()
{
    Assert( _parySegments == NULL );
    _ulRefs = 1;
    _nIndex = 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::CAutoTxtSiteRangeIterator
//
//  Synopsis:   Destructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CAutoTxtSiteRangeIterator::~CAutoTxtSiteRangeIterator()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::Init
//
//  Synopsis:   Initializes our segment list iterator
//
//  Arguments:  pFirst = Pointer to first segment
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRangeIterator::Init(CPtrAry<CElementSegment *> *parySegments)
{
    _parySegments = parySegments;
    _nIndex = 0;
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::First
//
//  Synopsis:   Resets the iterator
//
//  Arguments:  VOID
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CAutoTxtSiteRangeIterator::First()
{
    _nIndex = 0;
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::Current
//
//  Synopsis:   Returns the current ISegment position of the iterator.
//
//  Arguments:  ppISegment = OUTPUT pointer to an ISegment which will contain
//                the current segment for this iterator.
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CAutoTxtSiteRangeIterator::Current(ISegment **pISegment)
{
    CElementSegment *pSegment = NULL;
    HRESULT         hr = E_FAIL;

    Assert( pISegment != NULL );
    
    if( (pISegment != NULL) && (_nIndex < _parySegments->Size() ) )
    {
        pSegment = _parySegments->Item(_nIndex);
           
        hr = pSegment->QueryInterface(IID_ISegment, (void **)pISegment);
    }

    RRETURN(hr);        
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::IsDone
//
//  Synopsis:   Returns whether or not we have iterated past the end of our
//              list.
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = There are no more elements
//              S_FALSE = There are more elements
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRangeIterator::IsDone(void)
{
    return (_nIndex == _parySegments->Size() ) ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::Advance
//
//  Synopsis:   Advances the iterator by one element.
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = The iterator was advanced successfully
//              S_FALSE = The advance operation failed
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRangeIterator::Advance(void)
{
    HRESULT hr = S_FALSE;

    if( IsDone() == S_FALSE )
    {
        _nIndex++;
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::QueryInterface
//
//  Synopsis:   IUnknown QueryInterface implementation
//--------------------------------------------------------------------------
STDMETHODIMP
CAutoTxtSiteRangeIterator::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppvObj )
{
    if(!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegmentListIterator )
    {
        *ppvObj = (ISegmentListIterator *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\cglyph.cxx ===
//+---------------------------------------------------------------------
//
//   File:      cglyph.cxx
//
//  Contents:   CGlyph Class which manages the information for glyphs and makes it available at rendering time.
//
//  Classes:    CGlyph
//              CGlyphTreeType
//
//------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "cglyph.hxx"

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif


MtDefine(CGlyph,        CDoc,       "CGlyph")
MtDefine(CTreeObject,    CGlyph,     "CTreeObject")
MtDefine(CTreeList,      CTreeObject, "CTreeList")
MtDefine(GyphInfoType,  CTreeObject, "GyphInfoType")
    
    
//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyph()     
//
//  Synopsis:   Initializes the class' static data.  
//  
//----------------------------------------------------------------------------
CGlyph::CGlyph(CDoc * pDoc)
{
    _pDoc               = pDoc;
    s_levelSize [0]     = NUM_STATE_ELEMS; 
    s_levelSize [1]     = NUM_POS_ELEMS;
    s_levelSize [2]     = NUM_ALIGN_ELEMS;
    s_levelSize [3]     = NUM_ORIENT_ELEMS;
    _pchBeginDelimiter     = NULL;
    _pchEndDelimiter       = NULL;
    _pchEndLineDelimiter   = NULL;
    _pchDefaultImgURL      = NULL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::Init()     
//
//  Synopsis:   Makes the necessary memory allocations and initializations  
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::Init ()
{
    HRESULT     hr  = S_OK;
    TCHAR szBuffer[256];
    _XMLStack       = new CList;

    if (!_XMLStack)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _gHashTable     = new CPtrBagCi<CGlyphTreeType *>(TRUE);
    if (!_gHashTable)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _pDoc->GetEditingString(IDS_BEGIN_DELIMITER , szBuffer, ARRAY_SIZE(szBuffer));
    if (hr)
        goto Cleanup;

     _pchBeginDelimiter = new TCHAR[_tcslen(szBuffer)+1];
     if (!_pchBeginDelimiter)
     {
         hr = E_OUTOFMEMORY ;
         goto Cleanup;
     }
     _tcscpy(_pchBeginDelimiter , szBuffer);

    hr = _pDoc->GetEditingString(IDS_END_DELIMITER , szBuffer, ARRAY_SIZE(szBuffer));
    if (hr)
        goto Cleanup;
    _pchEndDelimiter = new TCHAR[_tcslen(szBuffer)+1];
     if (!_pchEndDelimiter)
     {
         hr = E_OUTOFMEMORY ;
         goto Cleanup;
     }
     _tcscpy(_pchEndDelimiter , szBuffer);

    hr = _pDoc->GetEditingString(IDS_END_LINE_DELIMITER , szBuffer, ARRAY_SIZE(szBuffer));
    if (hr)
        goto Cleanup;
    _pchEndLineDelimiter = new TCHAR[_tcslen(szBuffer)+1];
     if (!_pchEndLineDelimiter)
     {
         hr = E_OUTOFMEMORY ;
         goto Cleanup;
     }
     _tcscpy(_pchEndLineDelimiter , szBuffer);

        
    hr = ConstructResourcePath (szBuffer);
    if (hr)
        goto Cleanup;

    _tcscat (szBuffer, DEFAULT_IMG_NAME);
    _pchDefaultImgURL = new TCHAR [_tcslen(szBuffer)+1];
    if (!_pchDefaultImgURL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy (_pchDefaultImgURL, szBuffer);

Cleanup:
    RRETURN (hr);
}


HRESULT 
CGlyph::ConstructResourcePath (TCHAR szBuffer [])
{
    HRESULT     hr = S_OK;

    HINSTANCE hResourceLibrary = NULL;
    hr = _pDoc->GetEditResourceLibrary(&hResourceLibrary);
    if (hr)
        goto Cleanup;
    
    _tcscpy(szBuffer, _T("res://"));

    if (!GetModuleFileName(
            hResourceLibrary,
            szBuffer + _tcslen(szBuffer),
            pdlUrlLen - _tcslen(szBuffer) - 1))
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

#ifdef UNIX
    {
        TCHAR* p = _tcsrchr(szBuffer, _T('/'));
        if (p)
        {
            int iLen = _tcslen(++p);
            memmove(szBuffer + 6, p, sizeof(TCHAR) * iLen);
            szBuffer[6 + iLen] = _T('\0');
        }
    
    }
#endif

    _tcscat (szBuffer, _T("/"));

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::~CGlyph()     
//
//  Synopsis:   First deletes the contents of the hash table, which is in 
//              charge of keeping track of glyphs for XML tags. Then, 
//              deletes the hash table, and finally iterates through the 
//              static array which keeps track of all the identified 
//              tags and deletes the contents of that as well.                 
//  
//              Note:   The sole putpose of _XMLStack is in fact to keep
//                      track of the information entered into the hash 
//                      table, because this implementation of a hash table
//                      does not have a handy way of iterating through it.
//
//----------------------------------------------------------------------------    
CGlyph::~CGlyph()                    
{
    RemoveGlyphTableContents ();
    delete _pchBeginDelimiter;
    delete _pchEndDelimiter;
    delete _pchEndLineDelimiter;
    delete _pchDefaultImgURL;
    delete _gHashTable;
    delete _XMLStack;
 
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::RemoveGlyphTableContents ()
//
//  Synopsis:   This method deletes all of the CGlyphTreeType structures
//              that we have. It begins by popping the entire stack 
//              of data that is contained in the hash table, and then
//              iterates through the static array which is reserved for
//              the known tags.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::RemoveGlyphTableContents ()
{
    CGlyphTreeType * XMLTree;
    int count;
 
    if (_XMLStack)
    {
        _XMLStack->Pop ((void**) &XMLTree);
        while (XMLTree)
        {
            delete XMLTree;
            _XMLStack->Pop ((void**) &XMLTree);
        }
    }
    for (count = 0; count <= ETAG_LAST; count++)
    {
        if ( _gIdentifiedTagArray [count] != NULL )
        {
            delete _gIdentifiedTagArray [count];
            _gIdentifiedTagArray [count] = NULL;
        }
    }
    return (S_OK);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::ReplaceGlyphTableContents
//
//  Synopsis:   This public method is called to purge the glyph information
//              and reconstruct the new data given a BSTR input.
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::ReplaceGlyphTableContents (BSTR inputStream)
{
    HRESULT hr;

    hr = THR( RemoveGlyphTableContents () );
    if (FAILED (hr))
        RRETURN (hr);
    hr = THR( ParseGlyphTable (inputStream, TRUE) );
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::AddToGlyphTable
//
//  Synopsis:   This public method is used to insert new information
//              using a table formatted in a BSTR
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::AddToGlyphTable (BSTR inputStream)
{
    return ( ParseGlyphTable (inputStream, TRUE) );
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::RemoveFromGlyphTable 
//
//  Synopsis:   This public method is used to delete a rule from the table.
//              If this rule is not found ERROR_NOT_FOUND is returned.
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::RemoveFromGlyphTable (BSTR inputStream)
{
    return ( ParseGlyphTable (inputStream, FALSE) );
}



HRESULT 
CGlyph::AddSynthesizedRule (const TCHAR imgName [], ELEMENT_TAG eTag, GLYPH_STATE_TYPE eState, GLYPH_POSITION_TYPE ePos, 
                            GLYPH_ALIGNMENT_TYPE eAlign, GLYPH_ORIENTATION_TYPE eOrient, PTCHAR tagName )
{
    HRESULT                 hr                  = S_OK;
    CGlyphInfoType *        gInfo               = NULL;
    TCHAR                   pchImgURL [256];

    hr = ConstructResourcePath(pchImgURL);
    if (hr)
        goto Cleanup;
        
    _tcscat (pchImgURL, imgName);

    gInfo = new CGlyphInfoType;
    if (gInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    gInfo->pImageContext = NULL;
    gInfo->width = gInfo->height = gInfo->offsetX = gInfo->offsetY = DEFAULT_GLYPH_SIZE;
    gInfo->pchImgURL = new TCHAR [_tcslen(pchImgURL)+1];
    if (!gInfo->pchImgURL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy (gInfo->pchImgURL, pchImgURL);
    if (tagName == NULL)
    {
        hr = THR( InsertIntoTable (gInfo, eTag, eState, eAlign, ePos, eOrient, TRUE) );
    }
    else
    {
        hr = THR( InsertIntoTable (gInfo, tagName, eState, eAlign, ePos, eOrient, TRUE) );
    }
    if (FAILED (hr))
    {
        delete gInfo;
        goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::Exec   
//
//  Synopsis:   This method is used to implement various IDM command executions.
//              Nothing too complicated, except that it also takes charge of 
//              informing text whether it has shifted from a no-info state
//              to a state where CGlyph needs to be querried for glyph info.   
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::Exec(
        GUID * pguidCmdGroup,
        UINT idm,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT                 hr          =   S_OK;

    switch (idm)
    {
    case IDM_SHOWALLTAGS:
        AddSynthesizedRule (_T("unknown.gif"), ETAG_NULL);
        hr = Exec (pguidCmdGroup, IDM_SHOWUNKNOWNTAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
    case IDM_SHOWMISCTAGS:
        hr = Exec (pguidCmdGroup, IDM_SHOWALIGNEDSITETAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWSCRIPTTAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWSTYLETAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWCOMMENTTAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWAREATAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWUNKNOWNTAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWWBRTAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        AddSynthesizedRule (_T("abspos.gif"), ETAG_NULL, GST_DEFAULT, GPT_ABSOLUTE, GAT_DEFAULT, GOT_DEFAULT);
        break;
    case IDM_SHOWALIGNEDSITETAGS:
        AddSynthesizedRule (_T("leftalign.gif"), ETAG_NULL, GST_DEFAULT, GPT_DEFAULT, GAT_LEFT, GOT_DEFAULT);
        AddSynthesizedRule (_T("centeralign.gif"), ETAG_NULL, GST_DEFAULT, GPT_DEFAULT, GAT_CENTER, GOT_DEFAULT);
        AddSynthesizedRule (_T("rightalign.gif"), ETAG_NULL, GST_DEFAULT, GPT_DEFAULT, GAT_RIGHT, GOT_DEFAULT);
        break;
    case IDM_SHOWSCRIPTTAGS:
        AddSynthesizedRule (_T("script.gif"), ETAG_SCRIPT);
        break;
    case IDM_SHOWSTYLETAGS:
        AddSynthesizedRule (_T("style.gif"), ETAG_STYLE);
        break;
    case IDM_SHOWCOMMENTTAGS:
        AddSynthesizedRule (_T("comment.gif"), ETAG_COMMENT);
        AddSynthesizedRule (_T("comment.gif"), ETAG_RAW_COMMENT);
        break;
    case IDM_SHOWAREATAGS:
        AddSynthesizedRule (_T("area.gif"), ETAG_AREA);
        break;
    case IDM_SHOWUNKNOWNTAGS:
        AddSynthesizedRule (_T("unknown.gif"), ETAG_NULL, GST_DEFAULT, GPT_DEFAULT, GAT_DEFAULT, GOT_DEFAULT, DEFAULT_XML_TAG_NAME);
        break;
    case IDM_SHOWWBRTAGS:
        AddSynthesizedRule (_T("wordbreak.gif"), ETAG_WBR);
        AddSynthesizedRule (_T("br.gif"), ETAG_BR);
        break;
    case IDM_EMPTYGLYPHTABLE:
        {
            hr = THR(RemoveGlyphTableContents ());
            break;
        }
    case IDM_ADDTOGLYPHTABLE:
        if (!pvarargIn->bstrVal)
            break;
        hr = THR( AddToGlyphTable (pvarargIn->bstrVal) );
        break;
    case IDM_REMOVEFROMGLYPHTABLE:
        if (!pvarargIn->bstrVal)
            break;
        hr = THR( RemoveFromGlyphTable (pvarargIn->bstrVal) );
        break;
    case IDM_REPLACEGLYPHCONTENTS:
        if (!pvarargIn->bstrVal)
           break;
        hr = THR( ReplaceGlyphTableContents (pvarargIn->bstrVal) );
        break;
    default:
        hr = OLECMDERR_E_NOTSUPPORTED;
    }
    
    RRETURN (hr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::ParseGlyphTable 
//
//  Synopsis:   This is the main method in the glyph table parsing from 
//              a BSTR. It begins by setting a PTCHAR that will walk 
//              down the BSTR as we are parsing it. Then, it enters a 
//              while loop until it runs into the end of the BSTR. 
//              Within the While loop, we first need to decide whether the
//              first entry is a tag ID or a tag name. If the first entry 
//              consists only of decimals, we conclude that is is a tag ID,
//              Then, we dispatch the parsing of the rest of the rule 
//              accordingly.
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::ParseGlyphTable (BSTR inputStream, BOOL addToTable)
{
    PTCHAR      pchInStream = inputStream;
    PTCHAR      pchThisSection;
    HRESULT     hr = S_OK;

    if (_tcslen (pchInStream) < _tcslen (_pchBeginDelimiter))
        goto Cleanup;
    pchInStream = _tcsstr (pchInStream, _pchBeginDelimiter);
    while (pchInStream)
    {
        GetThisSection (pchInStream, pchThisSection);
        if (pchThisSection == NULL)    //If the tag ID/name field is empty, we make it default
        {
            pchThisSection = new TCHAR [5];
            if (!pchThisSection)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            _itot (ETAG_UNKNOWN, pchThisSection, 10);
        }
        if (_tcsspn (pchThisSection, DECIMALS) == _tcsclen(pchThisSection))   //If this rule specifies a tag ID
        {
            IDParse (pchInStream, pchThisSection, addToTable);    
        }
        else    //If this rule specifies a tag name
        {
            XMLParse (pchInStream, pchThisSection, addToTable);
        }
        delete pchThisSection;
        // Goto next rule
        if (pchInStream)           
            pchInStream = _tcsstr (pchInStream, _pchEndLineDelimiter);
        if (pchInStream)
            pchInStream = pchInStream + _tcsclen (_pchEndLineDelimiter);
        if (pchInStream)
            pchInStream = _tcsstr (pchInStream, _pchBeginDelimiter);
    }

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::ParseBasicInfo 
//
//  Synopsis:   This method parses the basic Glyph info which is common
//              to both tags with identified ID's and others (i.e. XML's).
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::ParseBasicInfo (PTCHAR & pchInStream, BasicGlyphInfoType & newRule)
{
    HRESULT             hr = S_OK;
    LONG                temp;

    //Initialize the Fields
    newRule.eState = GST_DEFAULT;
    newRule.eAlign = GAT_DEFAULT;
    newRule.ePos = GPT_DEFAULT;
    newRule.eOrient = GOT_DEFAULT;
    newRule.width = newRule.height = newRule.offsetX = newRule.offsetY = DEFAULT_GLYPH_SIZE;

    GetThisSection (pchInStream, newRule.pchImgURL);
    if (newRule.pchImgURL == NULL)
    {
        newRule.pchImgURL = new TCHAR [_tcsclen(_pchDefaultImgURL)+1];
        if (!newRule.pchImgURL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcscpy(newRule.pchImgURL, _pchDefaultImgURL);
        goto Cleanup;
    }


    if (!NextIntSection (pchInStream, temp))
        goto Cleanup;
    newRule.eState  =   (GLYPH_STATE_TYPE)          temp;

    if (!NextIntSection (pchInStream, temp))
        goto Cleanup;
    newRule.eAlign  =   (GLYPH_ALIGNMENT_TYPE)      temp;

    if (!NextIntSection (pchInStream, temp))
        goto Cleanup;
    newRule.ePos    =   (GLYPH_POSITION_TYPE)       temp;

    if (!NextIntSection (pchInStream, temp))
        goto Cleanup;
    newRule.eOrient =   (GLYPH_ORIENTATION_TYPE)    temp;

    if (!NextIntSection (pchInStream, newRule.width))
        goto Cleanup;
    if (!NextIntSection (pchInStream, newRule.height))
        goto Cleanup;
    if (!NextIntSection (pchInStream, newRule.offsetX))
        goto Cleanup;
    if (!NextIntSection (pchInStream, newRule.offsetY))
        goto Cleanup;

Cleanup:
    return (S_OK);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::IDParse 
//
//  Synopsis:   This nethod takes care of the parsing of rules where the
//              tag is identified by its ID. It begins by setting the 
//              correct tag ID, and then parsing the rest of the info
//              which is common to rules with ID's and names, and finally
//              enters the information.
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::IDParse (PTCHAR & pchInStream, PTCHAR & pchThisSection, BOOL addToTable)
{
    HRESULT             hr;
    PTCHAR              pchTagName;
    ELEMENT_TAG_ID      tagID = (ELEMENT_TAG_ID)  _ttol(pchThisSection);
    extern ELEMENT_TAG  ETagFromTagId ( ELEMENT_TAG_ID tagID );

    if (   tagID <= TAGID_NULL
        || tagID == TAGID_UNKNOWN
        || tagID >= TAGID_COUNT
       )
    {
        hr = THR( _pDoc->GetNameForTagID (tagID, &pchTagName));
        if (hr || !pchTagName)
            goto Cleanup;
        hr = THR( XMLParse (pchInStream, pchTagName, addToTable) );
    }
    else
    {
        IDGlyphTableType    newRule;
        hr = THR( ParseBasicInfo (pchInStream, newRule.basicInfo) ); 
        if (hr)
            goto Cleanup;
        newRule.eTag = ETagFromTagId(tagID);
        hr = THR( NewEntry (newRule, addToTable) );
    }

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::XMLParse 
//
//  Synopsis:   This nethod takes care of the parsing of rules where the
//              tag is identified by its name. It begins by setting the 
//              correct tag name, and then parsing the rest of the info
//              which is common to rules with ID's and names, and finally
//              enters the information.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::XMLParse (PTCHAR & pchInStream, PTCHAR & pchThisSection, BOOL addToTable)
{
    XMLGlyphTableType   newRule;
    HRESULT             hr;

    newRule.pchTagName = new TCHAR [_tcsclen(pchThisSection)+1];
    if (!newRule.pchTagName)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy(newRule.pchTagName, pchThisSection);
    hr = THR( ParseBasicInfo (pchInStream, newRule.basicInfo) ); 
    if (hr)
        goto Cleanup;
    hr = THR( NewEntry (newRule, addToTable) );

Cleanup:
    delete newRule.pchTagName;
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::NextIntSection 
//
//  Synopsis:   This method parses between a _pchBeginDelimiter and _pchEndDelimiter,
//              expecting to find an integer there. If this section is not 
//              empty, the 'result' parameter is set to the integer 
//              translation of the string, and TRUE is returned. If not,
//              'result' is left unchanges, and FALSE is returned.
//  
//              Note:   Both the return value and the setting of
//                      'result' are used by 'ParseBasicInfo,' depending
//                      on whether we need to typecase a dummy variable.
//
//----------------------------------------------------------------------------
BOOL
CGlyph::NextIntSection (PTCHAR & pchInStream, LONG & result)
{
    PTCHAR  pchThisSection  = NULL;
    BOOL    f_rVal          = FALSE;

    if (pchInStream == NULL) // We leave and the default value remains
    {
        goto Cleanup;
    }
    GetThisSection (pchInStream, pchThisSection);
    if (pchThisSection == NULL)
    {
        goto Cleanup;
    }
    result = _ttol(pchThisSection);
    f_rVal = TRUE;

Cleanup:
    delete pchThisSection;
    return (f_rVal);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::GetThisSection 
//
//  Synopsis:   This method is used to retrieve a section in the input 
//              stream that we are parsing. What is does is localize the
//              the next input field, and then constructs a TCHAR string
//              out of that.
//  
//              Note:   In case the caller does not need to preserve 
//                      'newString', the latter should be deleted 
//                      when no longer need by the caller.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::GetThisSection (PTCHAR & pchSectionBegin, PTCHAR & pchNewString)
{
    PTCHAR      pchSectionEnd;
    PTCHAR      pchRuleEnd;
    int         beginLen;
    int         endLen;
    HRESULT     hr = S_OK;

    AssertSz(pchSectionBegin, "Parser Should Have Popped Out Before Passing In a Null"); 
    pchNewString = NULL;
    pchRuleEnd      = _tcsstr (pchSectionBegin, _pchEndLineDelimiter);
    if (!pchRuleEnd)    //  Messed up syntax - Try to recover cleanly
    {
        goto Cleanup;
    }
    pchSectionEnd = _tcsstr (pchSectionBegin, _pchBeginDelimiter);
    if (!pchSectionEnd || pchRuleEnd < pchSectionEnd)    // The next non-empty field is for another rule 
    {
        goto Cleanup;
    }

    // Now, we can begin
    pchSectionBegin = pchSectionEnd;
    beginLen = _tcsclen(pchSectionBegin);
    AssertSz (pchSectionBegin && CompareUpTo (pchSectionBegin, _pchBeginDelimiter, _tcsclen(_pchBeginDelimiter)) == 0, "Illegal Input Stream");
    pchSectionBegin = pchSectionBegin + _tcsclen (_pchBeginDelimiter);
    if (!pchSectionBegin)
    {
        goto Cleanup;
    }
    pchSectionEnd = _tcsstr (pchSectionBegin, _pchEndDelimiter);
    if (!pchSectionEnd)
    {
        goto Cleanup;
    }
    beginLen = _tcsclen(pchSectionBegin);
    endLen = _tcsclen(pchSectionEnd);
    if (beginLen == endLen) //Check if this field is empty
    {
        goto Cleanup;
    }
    pchNewString = new TCHAR [beginLen-endLen+1];
    if (!pchNewString)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcsncpy (pchNewString, pchSectionBegin, beginLen-endLen);
    pchNewString[beginLen-endLen] = '\0';
    pchSectionBegin = pchSectionEnd + _tcsclen (_pchEndDelimiter);
    
Cleanup:
    return (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CompareUpTo 
//
//  Synopsis:   This method return TRUE or FALSE depending on whether 
//              two strings are identical up to a certain number of 
//              characters.
//
//----------------------------------------------------------------------------
int
CGlyph::CompareUpTo (PTCHAR first, PTCHAR second, int numToComp)
{
    int count;
    int firstLen = _tcslen (first);
    int secondLen = _tcslen (second);

    for (count = 0; count < numToComp; count++)
        if (((count >= firstLen) || (count >= secondLen)) || (first[count] != second[count]))
            break;
    if (count == numToComp)
        return 0;
    else return 1;
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::InitGInfo 
//
//  Synopsis:   Creates a CGlyphInfoType and sets it to its default values,
//              specified in basicInfo.
//  
//----------------------------------------------------------------------------
HRESULT 
CGlyph::InitGInfo (pCGlyphInfoType & gInfo, BasicGlyphInfoType & basicInfo)
{
    HRESULT hr = NOERROR;

    gInfo = new CGlyphInfoType;
    if (gInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    gInfo->pImageContext    = NULL;
    gInfo->pchImgURL           = basicInfo.pchImgURL;
    gInfo->width            = basicInfo.width;
    gInfo->height           = basicInfo.height;
    gInfo->offsetX          = basicInfo.offsetX;
    gInfo->offsetY          = basicInfo.offsetY;

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::NewEntry
//
//  Synopsis:   This version of NewEntry is used to enter a new struct into
//              the database of Glyph info, where the name of a tag has been
//              specified.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::NewEntry (XMLGlyphTableType & gTableElem, BOOL addToTable )
{
    HRESULT         hr = S_OK;
    CGlyphInfoType * gInfo;

    hr = THR( InitGInfo (gInfo, gTableElem.basicInfo) );
    if ( FAILED (hr) )
        goto Cleanup;
    hr = THR( InsertIntoTable (gInfo, gTableElem.pchTagName, gTableElem.basicInfo.eState, gTableElem.basicInfo.eAlign, 
        gTableElem.basicInfo.ePos, gTableElem.basicInfo.eOrient, addToTable) );
    if (!addToTable)
        delete gInfo;

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     
//
//  Synopsis:   This version of NewEntry is used to enter a new struct into
//              the database of Glyph info, where the tag is identified
//              by its tag ID.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::NewEntry(IDGlyphTableType & gTableElem, BOOL addToTable)
{
    HRESULT hr = NOERROR;

    CGlyphInfoType * gInfo;
    hr = THR( InitGInfo (gInfo, gTableElem.basicInfo) );
    if ( FAILED (hr) )
        goto Cleanup;
    hr = THR( InsertIntoTable (gInfo, gTableElem.eTag, gTableElem.basicInfo.eState, gTableElem.basicInfo.eAlign, 
        gTableElem.basicInfo.ePos, gTableElem.basicInfo.eOrient, addToTable) );

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::InsertIntoTable 
//
//  Synopsis:   This method adds a new entry into the database of 
//              CGlyphInfoTypes when the tag has been identified by its name.
//              First, if the tag name is empty, or null it is set to the 
//              default value of ETAG_NULL. Next, if we attempt to resolve 
//              this tag name with a tag ID. If we have been able to attach
//              the tag name with an ID, we enter the new info into the
//              static array that contains info for tags with identified
//              ID's. If that is not the case, we enter the info into
//              the hash table which is reserved for tags that we can 
//              not resolve into an ID.
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::InsertIntoTable (CGlyphInfoType * gInfo, PTCHAR pchTagName, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign, 
                         GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient,
                         BOOL addToTable)
{
    CGlyphTreeType *    infoTable;
    HRESULT             hr;

    ELEMENT_TAG         eTag;
    hr = THR( AttemptToResolveTagName (pchTagName, eTag) );
    if (FAILED (hr))
    {
        delete gInfo;
        goto Cleanup;
    }
    
    if ( !IsGenericTag (eTag) && _tcscmp (pchTagName, DEFAULT_XML_TAG_NAME) != 0 && !(eTag == NULL))
    {
        hr = THR( InsertIntoTable (gInfo, eTag, eState, eAlign, ePos, eOrient, addToTable) );
        goto Cleanup;
    }

    infoTable = _gHashTable->GetCi(pchTagName);

    if (infoTable == NULL)
    {
        infoTable = new CGlyphTreeType();
        if (infoTable == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        hr = THR( _gHashTable->SetCi (pchTagName, infoTable) );
        if (FAILED (hr) )
        {
            delete infoTable;
            goto Cleanup;
        }
        _XMLStack->Push ((void**)infoTable);
    }
    if (infoTable != NULL)
    {
        hr = THR( infoTable->AddRule (gInfo, eState, eAlign, ePos, eOrient, addToTable, this) );
    }

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::InsertIntoTable 
//
//  Synopsis:   This method enters a CGlyphInfoType struct into the static
//              array. If ever an unidentified tag ID is passed in, 
//              this entry is ignored.
//  
//----------------------------------------------------------------------------
HRESULT 
CGlyph::InsertIntoTable (CGlyphInfoType * gInfo, ELEMENT_TAG eTag, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign, 
                         GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient,
                         BOOL addToTable)
{
    CGlyphTreeType *    infoTable;
    HRESULT             hr = S_OK;

    if (eTag >= ETAG_LAST)
    {
        delete gInfo;
        goto Cleanup;
    }
    if (_gIdentifiedTagArray[eTag] == NULL)
    {
        infoTable = new CGlyphTreeType();
        if (infoTable == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _gIdentifiedTagArray[eTag] = infoTable;
    }
    else 
    {
        infoTable = _gIdentifiedTagArray[eTag];
    }
    if (infoTable != NULL)
    {
        hr = THR( infoTable->AddRule (gInfo, eState, eAlign, ePos, eOrient, addToTable, this) );
    }

Cleanup:
    RRETURN (hr);

}







//+---------------------------------------------------------------------------
//
//  Member:     CALLBACK OnImgCtxChange
//
//  Synopsis:   This is the callback function that is used to invalidate 
//              the page when a new image has finished downloading for the 
//              first time.
//
//----------------------------------------------------------------------------
void CALLBACK 
CGlyph::OnImgCtxChange( VOID * pvImgCtx, VOID * pv )
{
    ((CDoc *)pv)->GetView()->Invalidate();
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::InitRenderTagInfo 
//
//  Synopsis:   None
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::InitRenderTagInfo (CGlyphRenderInfoType * renderTagInfo)
{
    HRESULT hr = S_OK;

    if (renderTagInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    renderTagInfo->pImageContext = NULL;
    renderTagInfo->width = 0;
    renderTagInfo->height = 0;
    renderTagInfo->offsetX = 0;
    renderTagInfo->offsetY = 0;

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CompleteInfoProcessing 
//
//  Synopsis:   Once the CGlyphInfoType structure has been found, this method
//              is used to set up the information to send it back to 
//              rendering.
//  
//              Note:   This method unfifes the code path for XML and normal
//                      tags.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::CompleteInfoProcessing (CGlyphInfoType * localInfo, CGlyphRenderInfoType * pTagInfo, void * invalidateInfo)
{
    HRESULT hr = S_OK;

    AssertSz (localInfo, "This point should only be reached if a valid query was made");
        
    // Bitmap handle has not been loaded yet
    // i.e. this is the first time this image is requested
    if (localInfo->pImageContext == NULL) 
    {
         hr = THR( GetImageContext (localInfo, invalidateInfo, localInfo->pImageContext) );
         if (FAILED (hr) )
             goto Cleanup;
    }
    pTagInfo->pImageContext = localInfo->pImageContext;
    pTagInfo->width = localInfo->width;
    pTagInfo->height = localInfo->height;
    pTagInfo->offsetX = localInfo->offsetX;
    pTagInfo->offsetY = localInfo->offsetY;

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::AttemptToResolveTagName 
//
//  Synopsis:   Retrieves that tag info given a tag name. If the tag name
//              is resolvable into an ID. the the codepath goes to the ID-
//              identified glyphs. If not, we go on to looking in the hash
//              table.
//  
//              Note:   The attempt to resolve tag names into ID's is the 
//                      same as the point where new info is entered.
//
//----------------------------------------------------------------------------
    

HRESULT
CGlyph::AttemptToResolveTagName (PTCHAR pchTagName, ELEMENT_TAG & eTag)
{
    HRESULT hr  = S_OK;

    AssertSz (pchTagName, "Tag name cannot be NULL");
    eTag = ETAG_NULL;
    if (pchTagName == NULL)
    {
        eTag = ETAG_UNKNOWN;
    }
    else
    {
        //
        // If the name has a colon in it - assume it's an XML namespace tag.
        //
        if ( _tcsstr( pchTagName, _T(":") ) > 0 )
        {
            eTag = ETAG_GENERIC;
        }
        else
            eTag = EtagFromName (pchTagName, _tcslen(pchTagName));
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::GetTagInfo 
//
//  Synopsis:   Retrieves that tag info given a ptp. It first searches for
//              a location in the data where the the ID's resolve (an entry
//              for the specific tag or an entry for the dafaults). Then,
//              if we can find the info, the return struct is set.
//  
//              Note:   The attempt to resolve tag names into ID's is the 
//                      same as the point where new info is entered.
//
//----------------------------------------------------------------------------



HRESULT
CGlyph::GetTagInfo (CTreePos * ptp, GLYPH_ALIGNMENT_TYPE eAlign, 
                    GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient, 
                    void * invalidateInfo, CGlyphRenderInfoType * pTagInfo)
{  
    CGlyphTreeType *            infoTree        = NULL;
    CGlyphInfoType *            localInfo       = NULL;
    HRESULT                     hr              = S_OK;
    ELEMENT_TAG                 eTag;
    GLYPH_STATE_TYPE            eState;
    CTreeNode *                 pNode;

    pTagInfo->pImageContext = NULL;

    if ( !ptp || !ptp->IsNode() )
        goto Cleanup;
    
    pNode = ptp->Branch ();
    eTag = pNode->Tag();

    //
    // HACKHACK: ETAG_COMMENT can turn into ETAG_RAW_COMMENT.  The parser
    // guys don't understand why but don't want to change it.  So, we need to 
    // unify these so that all comments render glyphs (bug 100991)
    //

    if (eTag == ETAG_RAW_COMMENT)
    {
        eTag = ETAG_COMMENT;        
    }

    if (  (eTag == ETAG_NULL)
        || !ptp->IsEdgeScope()
        || (   ptp->IsEndNode()
            && pNode->Element()->IsNoScope()
           )
       )
        goto Cleanup;

    eState = (GLYPH_STATE_TYPE)!(ptp->IsBeginElementScope());
    if (eTag == ETAG_UNKNOWN || IsGenericTag (eTag))        //. If it is a generic (i.e. known XML tag), we go off to the XML tag search path
    {
        hr = THR( GetXMLTagInfo (ptp, eState, eAlign, ePos, eOrient, invalidateInfo, pTagInfo) );
        goto Cleanup;
    }

    infoTree = _gIdentifiedTagArray[eTag];  // First, we try to see if we have info for this specific tag
    if (infoTree)
    {
        hr = THR( infoTree->GetGlyphInfo (ptp, localInfo, eState, eAlign, ePos, eOrient) );
        if (FAILED (hr))
            goto Cleanup;
    }
    
    if (!localInfo) // If we don't have info for the specific tag
    {
        infoTree = _gIdentifiedTagArray[ETAG_UNKNOWN];  // We first try the ETAG default
        if (infoTree)
        {
            hr = THR( infoTree->GetGlyphInfo (ptp, localInfo, eState, eAlign, ePos, eOrient) );
            if (FAILED (hr))
                goto Cleanup;
        }
        if (!localInfo)
        {
            hr = THR( AttemptFinalDefault (ptp, localInfo, eState, eAlign, ePos, eOrient) );
            if (FAILED (hr))
                goto Cleanup;
        }
    }

    if (!localInfo)
        goto Cleanup;

    hr = THR( CompleteInfoProcessing (localInfo, pTagInfo, invalidateInfo) );

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::GetTagInfo 
//
//  Synopsis:   Retrieves that tag info given an ptp, and knowing that it 
//              point to a generic tag.
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::GetXMLTagInfo (CTreePos * ptp, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign, 
                    GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient, 
                    void * invalidateInfo, CGlyphRenderInfoType * pTagInfo)
{  
    CGlyphTreeType *            infoTree        = NULL;
    CGlyphInfoType *            localInfo       = NULL;
    CElement*                   pElement;
    HRESULT                     hr              = S_OK;
    TCHAR                       *strLookupName  = NULL;
    size_t                      strLen;
    

    if (!ptp->Branch())
        goto Cleanup;
    pElement = ptp->Branch()->Element();

    //
    // Construct a string that is NameSpace:TagName
    //
    if (pElement->Namespace())
    {
        strLen = _tcslen(pElement->Namespace()) + _tcslen(_T(":")) + _tcslen(pElement->TagName()) + 1 /* term */;
        strLookupName = new TCHAR[strLen];
        if (!strLookupName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcscpy(strLookupName, pElement->Namespace());
        _tcscat(strLookupName, _T(":") );
        _tcscat(strLookupName, pElement->TagName() );
    }
    else
    {
        strLen = _tcslen(pElement->TagName()) + 1 /* term */;
        strLookupName = new TCHAR[strLen];
        if (!strLookupName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcscpy(strLookupName, pElement->TagName());
    }
    
    infoTree = _gHashTable->GetCi( strLookupName ); // Attempt to find entry for specific XML tag
    if (infoTree)
    {
        hr = THR( infoTree->GetGlyphInfo (ptp, localInfo, eState, eAlign, ePos, eOrient) );
        if (FAILED (hr))
            goto Cleanup;
    }


    if (!localInfo) // Attempt to find default entry for all XML's
    {
        infoTree = _gHashTable->GetCi(DEFAULT_XML_TAG_NAME);
        if (infoTree)
        {
            hr = THR( infoTree->GetGlyphInfo (ptp, localInfo, eState, eAlign, ePos, eOrient) );
            if (FAILED (hr))
                goto Cleanup;
        }
        if (!localInfo) // Attempt final default for all tags (ETAGS and XMLs)
        {
            hr = THR( AttemptFinalDefault (ptp, localInfo, eState, eAlign, ePos, eOrient) );
            if (FAILED (hr))
                goto Cleanup;
        }
    }

    if (!localInfo)
        goto Cleanup;

    hr = THR( CompleteInfoProcessing (localInfo, pTagInfo, invalidateInfo) );

Cleanup:
    if (strLookupName)
        delete[] strLookupName;
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::AttemptFinalDefault 
//
//  Synopsis:   This is the final default condition, where we tet if the table
//              contains an entry for ETAG_NULL, which is the final default
//              that everything falls through to.
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::AttemptFinalDefault (CTreePos * ptp, pCGlyphInfoType & localInfo, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign,
                             GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient)
{
    CGlyphTreeType *    infoTable   = NULL;
    HRESULT             hr          = S_OK;

    infoTable = _gIdentifiedTagArray[ETAG_NULL];
    if (infoTable)
        hr = THR( infoTable->GetGlyphInfo (ptp, localInfo, eState, eAlign, ePos, eOrient) );

    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::GetImageContext 
//
//  Synopsis:   Creates the image context, and sets the callback function
//              after having created the invalidation stack and mande the 
//              first entry to it.   
//  
//              Note:   We pass in a pointer to the gInfo into the callback.
//                      This is an elegant way of keeping track of what needs
//                      to be invalidated when an image is done loading,
//                      because whenever we want to display an image and it
//                      is not loaded, we know the CGlyphInfoType, so we 
//                      can add the invalidation info in the stack.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::GetImageContext (CGlyphInfoType * gInfo, void * pvCallback, pIImgCtx & newImageContext)
{
    HRESULT     hr      = S_OK;

    newImageContext = NULL;
    hr = THR( CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                          IID_IImgCtx, (LPVOID*)&newImageContext) );
    if (SUCCEEDED(hr))
    {
        hr = THR( newImageContext->Load(gInfo->pchImgURL, IMGCHG_COMPLETE) );
        if ( SUCCEEDED( hr ))
        {
            hr = THR( newImageContext->SetCallback( OnImgCtxChange, _pDoc ) );
        }
        if ( SUCCEEDED( hr ))
        {
            hr = THR( newImageContext->SelectChanges( IMGCHG_COMPLETE, 0, TRUE) );
        }
        if ( FAILED( hr ))
        {
            newImageContext->Release();
            return hr;
        }
    }           

    RRETURN (hr); 
}




//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::CGlyphTreeType 
//
//  Synopsis:   Creates the frst level of the tree and initializes it.
//  
//----------------------------------------------------------------------------
CGlyph::CGlyphTreeType::CGlyphTreeType ()
{
    _infoTree = new CTreeList (s_levelSize [0]);
    if (_infoTree == NULL)
    {
        goto Cleanup;
    }

Cleanup:
    return;
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::~CGlyphTreeType 
//
//----------------------------------------------------------------------------
CGlyph::CGlyphTreeType::~CGlyphTreeType ()
{
    delete _infoTree;
}






//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::TransformInfoToArray
//
//  Synopsis:   Converts glyph access information into indexes along the
//              the various levels of the tree.
//  
//              Note:   This is one of the only two methods that needs to be changed to
//                      modify the searching priority.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::CGlyphTreeType::TransformInfoToArray (GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign, GLYPH_POSITION_TYPE ePos, 
                                     GLYPH_ORIENTATION_TYPE eOrient, int indexArray [])
{
    indexArray [TREEDEPTH_STATE]            = eState;
    indexArray [TREEDEPTH_POSITIONINING]    = ePos;
    indexArray [TREEDEPTH_ALIGNMENT]        = eAlign;
    indexArray [TREEDEPTH_ORIENTATION]      = eOrient;
    return (S_OK);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::ComputeLevelIndex
//
//  Synopsis:   Takes a ptpt and retrieves the specific details that are 
//              are needed to iterate through the next level in the tree.
//              This allows us to querry for specific info from the 
//              CTreePos only as needed.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::CGlyphTreeType::ComputeLevelIndex (CTreePos * ptp, int index [], int levelCount)
{
    HRESULT             hr          = S_OK;
    CTreeNode *         pNode       = ptp->Branch ();
    htmlControlAlign    alignment;
    CFlowLayout *       pLayout;
    LCID                curKbd;

    AssertSz ((levelCount >= 0) && (levelCount < NUM_INFO_LEVELS), "levelCount needs to be within bounds");
    AssertSz (index [levelCount] == COMPUTE, "index [levelCount] == COMPUTE is why we called this in the first place");

    switch (levelCount)
    {
    case TREEDEPTH_STATE : 
        if ( ptp->IsEndElementScope () )
            index [levelCount] = GST_CLOSE;
        else
            index [levelCount] = GST_OPEN;
        break;
    case TREEDEPTH_POSITIONINING : 
        if ( pNode->IsPositionStatic () )
            index [levelCount] = GPT_STATIC;
        else if ( pNode->IsAbsolute () )
            index [levelCount] = GPT_ABSOLUTE;
        else if ( pNode->IsRelative () )
            index [levelCount] = GPT_RELATIVE;
        else 
            index [levelCount] = GPT_DEFAULT;
        break;
    case TREEDEPTH_ALIGNMENT:
        alignment   = pNode->GetSiteAlign ();

        if ( alignment == htmlBlockAlignLeft )
            index [levelCount] = GAT_LEFT;
        else if ( alignment == htmlBlockAlignCenter )
            index [levelCount] = GAT_CENTER;
        else if ( alignment == htmlBlockAlignRight )
            index [levelCount] = GAT_RIGHT;
        else 
            index [levelCount] = GAT_DEFAULT;
        break;
    case TREEDEPTH_ORIENTATION:
        pLayout     = pNode->GetFlowLayout();
        if (!pLayout)
        {
            index [levelCount] = GOT_DEFAULT;
            break;
        }
        curKbd      = LOWORD(GetKeyboardLayout(0));

        if(IsRtlLCID(curKbd))       // RIGHT-LEFT
           index [levelCount] = GOT_RIGHT_TO_LEFT;
        else 
           index [levelCount] = GOT_LEFT_TO_RIGHT;
        break;
    default:
        AssertSz (0, "We should always be at a level that we know about and can resolve");
    }
    
    return (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::AddRule
//              CGlyph::CGlyphTreeType::InsertIntoTree
//
//  Synopsis:   This method adds a new rule (CGlyphInfoType struct) into
//              a tree. It searches for the location, creating levels 
//              if necessary, and inserting the new info.
//  
//              Note:   Rules that map on to the same location are resolved
//                      by deleting the old rule and replacing it by the new
//                      one. This allows for a handy way of overwriting
//                      a rule.
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::CGlyphTreeType::AddRule (CGlyphInfoType * gInfo, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign,
                  GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient, BOOL addToTable, CGlyph * glyphTable)
{
    int indexArray [NUM_INFO_LEVELS];
    HRESULT     hr = S_OK;

    TransformInfoToArray (eState, eAlign, ePos, eOrient, indexArray);
    hr = THR( InsertIntoTree (gInfo, indexArray, addToTable, glyphTable) );
    if (hr == S_OK)
        glyphTable->_pDoc->ForceRelayout();
    RRETURN (hr);
}


HRESULT
CGlyph::CGlyphTreeType::InsertIntoTree (CGlyphInfoType * gInfo, int index [], BOOL addToTable, CGlyph * glyphTable)
{
    int         levelCount;
    CTreeList *     thisLevel = _infoTree;
    CTreeList *     newLevel;
    HRESULT     hr = S_OK;
    
    for (levelCount = 0; levelCount < NUM_INFO_LEVELS-1; levelCount ++)
    {
        if ((*thisLevel)[index[levelCount]] == NULL)
        {
            if (!addToTable)
            {
                goto Cleanup;
            }
            newLevel = new CTreeList(s_levelSize[levelCount+1]);
            if (newLevel == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            (*thisLevel)[index[levelCount]] = newLevel;
        }
        else 
        {
            newLevel = DYNCAST(CTreeList, (*thisLevel)[index[levelCount]]);    
        }
        thisLevel = newLevel;
    }
    // Rule collisions are handled by preserving the last one
    if ((*thisLevel)[index[levelCount]] != NULL)
    {
        delete (*thisLevel)[index[levelCount]]; 
        (*thisLevel)[index[levelCount]] = NULL;
    }
    else if (!addToTable)       //Tried to delete non-existing rule
    {
        goto Cleanup;
    }
    if (addToTable)
    {
        (*thisLevel)[index[levelCount]] = gInfo;
    }

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::GetGlyphInfo
//              CGlyph::CGlyphTreeType::GetFromTree
//
//  Synopsis:   Retrieves the pointer to a CGlyphInfoType struct from a tree.
//              The search performed is depth-first. We begin by looking 
//              for the exact rule specified, and as we climb back up
//              We try each default.
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::CGlyphTreeType::GetGlyphInfo (CTreePos * ptp, pCGlyphInfoType & gInfo, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign,
                             GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient)
{
    int indexArray [NUM_INFO_LEVELS];
    HRESULT     hr = S_OK;

    TransformInfoToArray (eState, eAlign,  ePos, eOrient, indexArray);
    hr = THR( GetFromTree (ptp, gInfo, indexArray) );
    RRETURN (hr);
}


HRESULT
CGlyph::CGlyphTreeType::GetFromTree (CTreePos * ptp, pCGlyphInfoType & gInfo, int index [])
{
    int         levelCount = 0;
    CTreeObject *  thisLevel = DYNCAST(CTreeList, _infoTree);
    HRESULT     hr = S_OK;
    CList *     traversalStack = new CList;

    if (!traversalStack)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    gInfo = NULL;
    while ((levelCount < NUM_INFO_LEVELS) || ((thisLevel==NULL) && levelCount > 0))
    {
        if (index[levelCount] == COMPUTE)
        {
            hr = THR( ComputeLevelIndex (ptp, index, levelCount));
        }

        if ( FAILED( hr ) )
            goto Cleanup;

        if (thisLevel == NULL)
        {
            traversalStack->Pop((void**)(&thisLevel));
            levelCount --;
            if (thisLevel == NULL)
            {
                goto Cleanup;
            }
            if (index[levelCount] == s_levelSize[levelCount]-1)
            {
                thisLevel = NULL;
            }
            else 
            {
                index[levelCount] = s_levelSize[levelCount]-1;
            }
        }
        else
        {
            traversalStack->Push ((void**)thisLevel);
            thisLevel = ( *DYNCAST(CTreeList, thisLevel) ) [index[levelCount]];
            if (thisLevel && thisLevel->IsInfoType ())
            {
                gInfo =  DYNCAST(CGlyphInfoType, thisLevel); 
                goto Cleanup;
            }
            levelCount ++;
        }
    }

Cleanup:
    delete traversalStack;
    return hr;
}
            





CGlyph::CList::CList ()
{
    _elemList = NULL;
}

CGlyph::CList::~CList ()
{
    void * dummy;

    while (_elemList != NULL)
    {
        Pop (&dummy);
    }
}


HRESULT 
CGlyph::CList::Push (void * pushed)
{
    ListElemType * newElem = new ListElemType;

    if (newElem == NULL)
        return E_OUTOFMEMORY;

    newElem->elem = pushed;
    newElem->next = _elemList;
    _elemList = newElem;
    return (S_OK);
}

HRESULT 
CGlyph::CList::Pop (void ** popped)
{
    ListElemType * toDelete = _elemList;

    if (_elemList == NULL)
    {
        *popped = NULL;
        goto Cleanup;
    }
    *popped = _elemList->elem;
    _elemList = _elemList->next;
    delete toDelete;

Cleanup:
    return S_OK;
}



CGlyph::CTreeList::CTreeList (LONG numObjects)
{
    int count;

    _numObjects = numObjects;
    _nextLevel = new CTreeObject * [numObjects];
    if (!_nextLevel)
        return;
    for (count = 0; count < numObjects; count ++)
        _nextLevel [count] = NULL;
}
        
CGlyph::CTreeList::~CTreeList () 
{
    int count;

    for (count = 0; count < _numObjects; count ++)
        delete _nextLevel [count];
    delete _nextLevel; 
}

CGlyph::CTreeObject * & 
CGlyph::CTreeList::operator[](int index)
{
    static  CTreeObject * s_pNULL = NULL;
    AssertSz (s_pNULL == NULL, "Invalid Flag Set To NULL");

    if ((index >= 0) && (index < _numObjects))
        return (_nextLevel [index]);
    else
        return s_pNULL;
}


CGlyph::CGlyphInfoType::~CGlyphInfoType () 
{ 
    ReleaseInterface(pImageContext);
    delete pchImgURL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\doc.cxx ===
/*
 *  @doc INTERNAL
 *
 *  @module DOC.C   CTxtStory and CTxtArray implementation |
 *
 *  Original Authors: <nl>
 *      Original RichEdit code: David R. Fulmer <nl>
 *      Christian Fortini   <nl>
 *      Murray Sargent <nl>
 *
 *  History: <nl>
 *      6/25/95 alexgo  Cleanup and reorganization
 *
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif


MtDefine(CTxtBlk, Tree, "CTxtBlk")
MtDefine(CTxtBlkData, CTxtBlk, "CTxtBlk data")
MtDefine(CTxtArray, Tree, "CTxtArray")
MtDefine(CTxtArray_pv, CTxtArray, "CTxtArray::_pv")
MtDefine(CRunArray, Tree, "CRunArray")
MtDefine(CRunArray_pv, CRunArray, "CRunArray::_pv")
MtDefine(CLineArray, Tree, "CLineArray")
MtDefine(CLineArray_pv, CLineArray, "CLineArray::_pv")
MtDefine(CListCache, Tree, "CListCache")
MtDefine(CListCacheInst, Tree, "CListCacheInst")
MtDefine(CListIndexArray, Tree, "CListIndexArray")
MtDefine(CListIndexArray_pv, CListIndexArray, "CListIndexArray::_pv")
MtDefine(CCharFormat, Tree, "CCharFormat")
MtDefine(CParaFormat, Tree, "CParaFormat")
MtDefine(CFancyFormat, Tree, "CFancyFormat")
MtDefine(CFancyFormat_pszFilters, CFancyFormat, "CFancyFormat::_pscFilters")
MtDefine(CPseudoElementInfo, Tree, "CPseudoElementInfo")


// ===========================  Invariant stuff  ======================

#define DEBUG_CLASSNAME CTxtArray
#include "_invar.h"

// ========================  CTxtArray class  =========================


#if DBG==1

/*
 *  CTxtArray::Invariant
 *
 *  @mfunc  Tests CTxtArray's state
 *
 *  @rdesc  returns TRUE always; failures are indicated by Asserts
 */

BOOL
CTxtArray::Invariant(  ) const
{
    static LONG numTests = 0;
    numTests++;             // how many times we've been called.

    if ( Count() > 0 )
    {

        // make sure total characters stored in the blocks match the length
        // that is stored in _cchText.
        long  cch = 0;
        DWORD i, iMax;

        iMax = Count();

        for ( i = 0; i < iMax; i++ )
        {
            CTxtBlk *ptb = Elem(i);

            // ptb shouldn't be NULL since we're within Count elements
            Assert(ptb);

            long currCch = ptb->_cch;

            cch += currCch;

            Assert ( currCch >= 0 );
            Assert ( currCch <= long(CchOfCb(ptb->_cbBlock)) );

            // while we're here, check the range of the interblock gaps.
            Assert (ptb->_ibGap <= ptb->_cbBlock);


            DWORD cchGap = CchOfCb(ptb->_ibGap);

            Assert ( long(cchGap) <= currCch );

        }
        Assert ( cch == GetCch() );
    }

    return TRUE;
}

#endif

/*
 *  CTxtArray::CTxtArray
 *
 *  @mfunc      Text array constructor
 *
 */
CTxtArray::CTxtArray()
    : CArray<CTxtBlk>(Mt(CTxtArray_pv))
{
    AssertSz(CchOfCb(cbBlockMost) - cchGapInitial >= cchBlkInitmGapI * 2,
        "cchBlockMax - cchGapInitial must be at least (cchBlockInitial - cchGapInitial) * 2");

    _cchText = 0;
}

/*
 *  CTxtArray::~CTxtArray
 *
 *  @mfunc      Text array destructor
 */
CTxtArray::~CTxtArray()
{
    DWORD itb = Count();

    while(itb--)
    {
        Assert(Elem(itb) != NULL);
        Elem(itb)->FreeBlock();
    }
}

/*
 *  CTxtArray::RemoveAll
 *
 *  @mfunc      Removes all characters in the array
 */
void
CTxtArray::RemoveAll()
{
    DWORD itb = Count();

    while(itb--)
    {
        Assert(Elem(itb) != NULL);
        Elem(itb)->FreeBlock();
    }

    Clear( AF_DELETEMEM );

    _cchText = 0;
}


/*
 *  CTxtArray::GetCch()
 *
 *  @mfunc      Computes and return length of text in this text array
 *
 *  @rdesc      The number of character in this text array
 *
 *  @devnote    This call may be computationally expensive; we have to
 *              sum up the character sizes of all of the text blocks in
 *              the array.
 */

long
CTxtArray::GetCch ( ) const
{
//    _TEST_INVARIANT_

    DWORD itb = Count();
    long  cch = 0;

    while (itb--)
    {
        Assert(Elem(itb) != NULL);
        cch += Elem(itb)->_cch;
    }

    return cch;
}

/*
 *  CTxtArray::AddBlock(itbNew, cb)
 *
 *  @mfunc      create new text block
 *
 *  @rdesc
 *      FALSE if block could not be added
 *      non-FALSE otherwise
 *
 *  @comm
 *  Side Effects:
 *      moves text block array
 */
BOOL CTxtArray::AddBlock(
    DWORD   itbNew,     //@parm index of the new block
    LONG    cb)         //@parm size of new block; if <lt>= 0, default is used
{
    _TEST_INVARIANT_

    CTxtBlk *ptb;

    if(cb <= 0)
        cb = cbBlockInitial;

    AssertSz(cb > 0, "CTxtArray::AddBlock() - adding block of size zero");
    AssertSz(cb <= cbBlockMost, "CTxtArray::AddBlock() - block too big");

    ptb = Insert(itbNew, 1);

    if( !ptb || !ptb->InitBlock(cb))
    {
        TraceTag((tagError, "TXTARRAT::AddBlock() - unable to allocate new block"));
        return FALSE;
    }

    return TRUE;
}

/*
 *  CTxtArray::SplitBlock(itb, ichSplit, cchFirst, cchLast, fStreaming)
 *
 *  @mfunc      split a text block into two
 *
 *  @rdesc
 *      FALSE if the block could not be split <nl>
 *      non-FALSE otherwise
 *
 *  @comm
 *  Side Effects: <nl>
 *      moves text block array
 */
BOOL CTxtArray::SplitBlock(
    DWORD itb,          //@parm index of the block to split
    DWORD ichSplit,     //@parm character index within block at which to split
    DWORD cchFirst,     //@parm desired extra space in first block
    DWORD cchLast,      //@parm desired extra space in new block
    BOOL fStreaming)    //@parm TRUE if streaming in new text
{
    _TEST_INVARIANT_

    LPBYTE pbSrc;
    LPBYTE pbDst;
    CTxtBlk *ptb, *ptb1;

    AssertSz(ichSplit > 0 || cchFirst > 0, "CTxtArray::SplitBlock(): splitting at beginning, but not adding anything");

    ptb = Elem(itb);

    // compute size for first half

    AssertSz(cchFirst + ichSplit <= CchOfCb(cbBlockMost),
        "CTxtArray::SplitBlock(): first size too large");
    cchFirst += ichSplit + cchGapInitial;
    // Does not work!, need fail to occur. jonmat cchFirst = min(cchFirst, CchOfCb(cbBlockMost));
    // because our client expects cchFirst chars.

    // NOTE (cthrash) I *think* this should work but I also *know* this
    // code needs to be revisited.  Basically, there are Asserts sprinkled
    // about the code requiring the _cbBlock < cbBlockMost.  We can of course
    // exceed that if we insist on tacking on cchGapInitial (See AssertSz
    // above).  My modifications make certain you don't.  It would seem fine
    // except for the comment by jonmat.

    // (cthrash) jonmat's comment makes no sense to me.  The new buffer size
    // *wants* to cchFirst + ichSplit + cchGapInitial; it seems to me that
    // it'll be ok as long as we give it a gap >= 0.
    cchFirst = min(cchFirst, (DWORD)CchOfCb(cbBlockMost));

    // compute size for second half

    AssertSz(cchLast + ptb->_cch - ichSplit <= CchOfCb(cbBlockMost),
        "CTxtArray::SplitBlock(): second size too large");
    cchLast += ptb->_cch - ichSplit + cchGapInitial;
    // Does not work!, need fail to occur. jonmat cchLast = min(cchLast, CchOfCb(cbBlockMost));
    // because our client expects cchLast chars.

    // (cthrash) see comment above with cchFirst.
    cchLast = min(cchLast, (DWORD)CchOfCb(cbBlockMost));

    // allocate second block and move text to it

    // ***** moves rgtb ***** //
    // if streaming in, allocate a block that's as big as possible so that
    // subsequent additions of text are faster
    // we always fall back to smaller allocations so this won't cause
    // unneccesary errors
    // when we're done streaming we compress blocks, so this won't leave
    // a big empty gap
    if(fStreaming)
    {
        DWORD cb = cbBlockMost;
        const DWORD cbMin = CbOfCch(cchLast);

        while(cb >= cbMin && !AddBlock(itb + 1, cb))
            cb -= cbBlockCombine;
        if(cb >= cbMin)
            goto got_block;
    }
    if(!AddBlock(itb + 1, CbOfCch(cchLast)))
    {
        TraceTag((tagError, "CTxtArray::SplitBlock(): unabled to add new block"));
        return FALSE;
    }

got_block:
    ptb1 = Elem(itb+1); // recompute ptb after rgtb moves
    ptb = Elem(itb);    // recompute ptb after rgtb moves
    ptb1->_cch = ptb->_cch - ichSplit;
    ptb1->_ibGap = 0;
    pbDst = (LPBYTE) (ptb1->_pch - ptb1->_cch) + ptb1->_cbBlock;
    ptb->MoveGap(ptb->_cch); // make sure pch points to a continuous block of all text in ptb.
    pbSrc = (LPBYTE) (ptb->_pch + ichSplit);
    CopyMemory(pbDst, pbSrc, CbOfCch(ptb1->_cch));
    ptb->_cch = ichSplit;
    ptb->_ibGap = CbOfCch(ichSplit);

    // resize the first block
    if(CbOfCch(cchFirst) != ptb->_cbBlock)
    {
//$ FUTURE: don't resize unless growing or shrinking considerably
        if(!ptb->ResizeBlock(CbOfCch(cchFirst)))
        {
            // Review, if this fails then we need to delete all of the Added blocks, right? jonmat
            TraceTag((tagError, "TXTARRA::SplitBlock(): unabled to resize block"));
            return FALSE;
        }
    }

    return TRUE;
}


/*
 *  CTxtArray::ShrinkBlocks()
 *
 *  @mfunc      Shrink all blocks to their minimal size
 *
 *  @rdesc
 *      nothing
 *
 */
void CTxtArray::ShrinkBlocks()
{
    _TEST_INVARIANT_

    DWORD itb = Count();
    CTxtBlk *ptb;

    while(itb--)
    {
        ptb = Elem(itb);
        Assert(ptb);
        ptb->ResizeBlock(CbOfCch(ptb->_cch));
    }
}


/*
 *  CTxtArray::RemoveBlocks(itbFirst, ctbDel)
 *
 *  @mfunc      remove a range of text blocks
 *
 *  @rdesc
 *      nothing
 *
 *  @comm Side Effects: <nl>
 *      moves text block array
 */
VOID CTxtArray::RemoveBlocks(
    DWORD itbFirst,         //@parm index of first block to remove
    DWORD ctbDel)           //@parm number of blocks to remove
{
    _TEST_INVARIANT_

    DWORD itb = itbFirst;
    DWORD ctb = ctbDel;

    AssertSz(itb + ctb <= Count(), "CTxtArray::RemoveBlocks(): not enough blocks");

    while(ctb--)
    {
        Assert(Elem(itb) != NULL);
        Elem(itb++)->FreeBlock();
    }

    Remove(itbFirst, ctbDel, AF_KEEPMEM);
}


/*
 *  CTxtArray::CombineBlocks(itb)
 *
 *  @mfunc      combine adjacent text blocks
 *
 *  @rdesc
 *      TRUE if blocks were combined, otherwise false
 *
 *  @comm
 *  Side Effects: <nl>
 *      moves text block array
 *
 *  @devnote
 *      scans blocks from itb - 1 through itb + 1 trying to combine
 *      adjacent blocks
 */
BOOL CTxtArray::CombineBlocks(
    DWORD itb)      //@parm index of the first block modified
{
    _TEST_INVARIANT_

    DWORD ctb;
    DWORD cbT;
    CTxtBlk *ptb, *ptb1;
    BOOL  fRet = FALSE;

    if(itb > 0)
        itb--;

    ctb = min(3, int(Count() - itb));
    if(ctb <= 1)
        return FALSE;

    for(; ctb > 1; ctb--)
    {
        ptb  = Elem(itb);                       // Can we combine current
        ptb1 = Elem(itb+1);                     //  and next blocks ?
        cbT = CbOfCch(ptb->_cch + ptb1->_cch + cchGapInitial);
        if(cbT <= cbBlockInitial)
        {                                           // Yes
            if(cbT != ptb->_cbBlock && !ptb->ResizeBlock(cbT))
                continue;
            ptb ->MoveGap(ptb->_cch);               // Move gaps at ends of
            ptb1->MoveGap(ptb1->_cch);              //  both blocks
            CopyMemory(ptb->_pch + ptb->_cch,       // Copy next block text
                ptb1->_pch, CbOfCch(ptb1->_cch));   //  into current block
            ptb->_cch += ptb1->_cch;
            ptb->_ibGap += CbOfCch(ptb1->_cch);
            RemoveBlocks(itb+1, 1);                 // Remove next block
            fRet = TRUE;
        }
        else
            itb++;
    }

    return fRet;
}

/*
 *  CTxtArray::GetChunk(ppch, cch, pchChunk, cchCopy)
 *
 *  @mfunc
 *      Get content of text chunk in this text array into a string
 *
 *  @rdesc
 *      remaining count of characters to get
 */
LONG CTxtArray::GetChunk(
    TCHAR **ppch,           //@parm ptr to ptr to buffer to copy text chunk into
    DWORD cch,              //@parm length of pch buffer
    TCHAR *pchChunk,        //@parm ptr to text chunk
    DWORD cchCopy) const    //@parm count of characters in chunk
{
    _TEST_INVARIANT_

    if(cch > 0 && cchCopy > 0)
    {
        if(cch < cchCopy)
            cchCopy = cch;                      // Copy less than full chunk
        CopyMemory(*ppch, pchChunk, cchCopy*sizeof(TCHAR));
        *ppch   += cchCopy;                     // Adjust target buffer ptr
        cch     -= cchCopy;                     // Fewer chars to copy
    }
    return cch;                                 // Remaining count to copy
}


// ========================  CTxtBlk class  =================================


/*
 *  CTxtBlk::InitBlock(cb)
 *
 *  @mfunc
 *      Initialize this text block
 *
 *  @rdesc
 *      TRUE if success, FALSE if allocation failed
 */
BOOL CTxtBlk::InitBlock(
    DWORD cb)           //@parm initial size of the text block
{
    _pch    = NULL;
    _cch    = 0;
    _ibGap  = 0;

    if (cb)
        _pch = (TCHAR*)MemAllocClear(Mt(CTxtBlkData), cb);

    MemSetName((_pch, "CTxtBlk data"));

    if (_pch)
    {
        _cbBlock = cb;
        return TRUE;
    }
    else
    {
        _cbBlock = 0;
        return FALSE;
    }
}

/*
 *  CTxtBlk::FreeBlock()
 *
 *  @mfunc
 *      Free this text block
 *
 *  @rdesc
 *      nothing
 */
VOID CTxtBlk::FreeBlock()
{
    MemFree(_pch);
    _pch    = NULL;
    _cch    = 0;
    _ibGap  = 0;
    _cbBlock= 0;
}

/*
 *  CTxtBlk::MoveGap(ichGap)
 *
 *  @mfunc
 *      move gap in this text block
 *
 *  @rdesc
 *      nothing
 */
void CTxtBlk::MoveGap(
    DWORD ichGap)           //@parm new position for the gap
{
    DWORD cbMove;
    DWORD ibGapNew = CbOfCch(ichGap);
    LPBYTE pbFrom = (LPBYTE) _pch;
    LPBYTE pbTo;

    if(ibGapNew == _ibGap)
        return;

    if(ibGapNew < _ibGap)
    {
        cbMove = _ibGap - ibGapNew;
        pbFrom += ibGapNew;
        pbTo = pbFrom + _cbBlock - CbOfCch(_cch);
    }
    else
    {
        cbMove = ibGapNew - _ibGap;
        pbTo = pbFrom + _ibGap;
        pbFrom = pbTo + _cbBlock - CbOfCch(_cch);
    }

    MoveMemory(pbTo, pbFrom, cbMove);
    _ibGap = ibGapNew;
}


/*
 *  CTxtBlk::ResizeBlock(cbNew)
 *
 *  @mfunc
 *      resize this text block
 *
 *  @rdesc
 *      FALSE if block could not be resized <nl>
 *      non-FALSE otherwise
 *
 *  @comm
 *  Side Effects: <nl>
 *      moves text block
 */
BOOL CTxtBlk::ResizeBlock(
    DWORD cbNew)        //@parm the new size
{
    TCHAR *pch;
    DWORD cbMove;
    HRESULT hr;

    AssertSz(cbNew > 0, "resizing block to size <= 0");

    if(cbNew < _cbBlock)
    {
        if(_ibGap != CbOfCch(_cch))
        {
            // move text after gap down so that it doesn't get dropped

            cbMove = CbOfCch(_cch) - _ibGap;
            pch = _pch + CchOfCb(_cbBlock - cbMove);
            MoveMemory(pch - CchOfCb(_cbBlock - cbNew), pch, cbMove);
        }
        _cbBlock = cbNew;
    }
    pch = _pch;
    hr = MemRealloc(Mt(CTxtBlkData), (void **) & pch, cbNew);
    if(hr)
        return _cbBlock == cbNew;   // FALSE if grow, TRUE if shrink

    _pch = pch;
    if(cbNew > _cbBlock)
    {
        if(_ibGap != CbOfCch(_cch))     // Move text after gap to end so that
        {                               // we don't end up with two gaps
            cbMove = CbOfCch(_cch) - _ibGap;
            pch += CchOfCb(_cbBlock - cbMove);
            MoveMemory(pch + CchOfCb(cbNew - _cbBlock), pch, cbMove);
        }
        _cbBlock = cbNew;
    }

    return TRUE;
}

HRESULT
CMarkup::CreateInitialMarkup( CRootElement * pElementRoot )
{
    HRESULT hr = S_OK;
    CTreeNode * pNodeRoot;
    CTreePos *  ptpNew;

    // Assert that there is nothing in the splay tree currently
    Assert( FirstTreePos() == NULL );

    // If someone passes a null root in here, chances are that 
    // we are out of memory.
    if (!pElementRoot)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pNodeRoot = new CTreeNode( NULL, pElementRoot );
    if ( !pNodeRoot )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // The initial ref on the node will transfer to the tree

    ptpNew = pNodeRoot->InitBeginPos( TRUE );
    Verify( ! Append(ptpNew) );

    ptpNew = pNodeRoot->InitEndPos( TRUE );
    Verify( ! Append(ptpNew) );

    pNodeRoot->PrivateEnterTree();

    pElementRoot->SetMarkupPtr( this );
    pElementRoot->__pNodeFirstBranch = pNodeRoot;
    pElementRoot->PrivateEnterTree();

    // Insert the chars for the node poses
    if( CTxtPtr( this, 0 ).InsertRepeatingChar( 2, WCH_NODE ) != 2 )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    {
        CNotification nf;
        nf.ElementEntertree( pElementRoot );
        pElementRoot->Notify( &nf );
    }

    UpdateMarkupTreeVersion();

    WHEN_DBG( _cchTotalDbg = 2 );
    WHEN_DBG( _cElementsTotalDbg = 1 );

Cleanup:
    RRETURN( hr );
}


#if DBG == 1
//+----------------------------------------------------------------------------
//
//  Member:     ValidateChange
//
//  Synopsis:   The markup maintains a redundant count of characters and
//              elements so that notifications can be validated.
//
//-----------------------------------------------------------------------------

void
CMarkup::ValidateChange(CNotification * pnf)
{
    switch ( pnf->Type() )
    {
    case NTYPE_CHARS_ADDED :
    {
        _cchTotalDbg += pnf->Cch(LONG_MAX);

        break;
    }
    case NTYPE_CHARS_DELETED :
    {
        _cchTotalDbg -= pnf->Cch(LONG_MAX);

        break;
    }

    case NTYPE_CHARS_RESIZE :
    case NTYPE_CHARS_INVALIDATE :
        break;

    case NTYPE_ELEMENTS_ADDED :
    {
        _cElementsTotalDbg += pnf->CElements();

        break;
    }

    case NTYPE_ELEMENTS_DELETED :
    {
        _cElementsTotalDbg -= pnf->CElements();

        break;
    }

    case NTYPE_ELEMENT_ENTERVIEW_1:
    case NTYPE_ELEMENT_EXITVIEW_1:
        break;

    case NTYPE_MARKUP_RENDER_STYLE:
        return;

    default :
        AssertSz( 0, "Unknown change kind" );
        break;
    }

    //
    // Make sure the debug count and the real doc are the same
    //

    Assert( !pnf->IsTextChange()
        ||  pnf->_fNoTextValidate
        || (    _cchTotalDbg == GetTextLength()
            &&  _cchTotalDbg == Cch() ) );
    Assert( !pnf->IsTreeChange()
        ||  pnf->_fNoElementsValidate
        ||  _cElementsTotalDbg == NumElems() );
}

//+----------------------------------------------------------------------------
//
//  Member:     AreChangesValid
//
//  Synopsis:   Return if the counds match the real situation
//
//-----------------------------------------------------------------------------

BOOL
CMarkup::AreChangesValid()
{
    return  _cchTotalDbg == GetTextLength()
        &&  _cchTotalDbg == Cch()
        &&  _cElementsTotalDbg == NumElems();
}
#endif

//+----------------------------------------------------------------------------
//
//  Member:     FindMyListContainer
//
//  Synopsis:   Searches the given branch (potentially starting above the base
//              of the branch) for the first list element above the start of
//              the search.
//
//   Returns:   Returns the element along the branch which has the same scope
//              as the given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::FindMyListContainer ( CTreeNode * pNodeStartHere )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode = pNodeStartHere;

    //
    // If we get to the CTxtSite immediately, stop searching!
    //

    if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
        return NULL;

    for ( ; ; )
    {
        CElement * pElementScope;

        pNode = pNode->Parent();

        if (!pNode)
            return NULL;

        pElementScope = pNode->Element();

        if (pElementScope->IsFlagAndBlock(TAGDESC_LIST))
            return pNode;

        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;

        if (IsGenericBlockListItem(pNode))
            return NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForCriteria
//
//  Synopsis:   Searches the given branch for an element which meets
//              certain criteria starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForCriteria (
    CTreeNode * pNodeStartHere,
    BOOL (* pfnSearchCriteria ) ( CTreeNode *, void * ),
    void *pvData)
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        if (pfnSearchCriteria( pNode, pvData ))
            return pNode;

        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForCriteriaInStory
//
//  Synopsis:   Searches the given branch for an element which meets
//              certain criteria starting from a given element.
//
//     Notes:   Does not stop searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForCriteriaInStory (
    CTreeNode * pNodeStartHere,
    BOOL (* pfnSearchCriteria) ( CTreeNode * ) )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        if (pfnSearchCriteria( pNode ))
            return pNode;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForPreLikeNode
//
//  Synopsis:   Searches the given branch for a pre-like node
//
//-----------------------------------------------------------------------------
CTreeNode *
CMarkup::SearchBranchForPreLikeNode ( CTreeNode * pNodeStartHere )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for( pNode = pNodeStartHere; pNode; pNode = pNode->Parent() )
    {
        ELEMENT_TAG eTag = pNode->Tag();
        if( eTag == ETAG_PRE || eTag == ETAG_XMP || eTag == ETAG_PLAINTEXT || eTag == ETAG_LISTING)
        {
            return pNode;
        }

        if (pNode->GetFancyFormat()->IsWhitespaceSet())
        {
            if (pNode->GetParaFormat()->_fPreInner)
                return pNode;

            return NULL;
        }

    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForAnchor
//
//  Synopsis:   Searches the given branch for an anchor element
//              starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForAnchor ( CTreeNode * pNodeStartHere )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode = pNodeStartHere;

    for ( ; ; )
    {
        if (!pNode || pNode->HasFlowLayout( GUL_USEFIRSTLAYOUT))
            return NULL;

        if (pNode->Tag() == ETAG_A)
            break;

        pNode = pNode->Parent();
    }

    return pNode;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForAnchorLink
//
//  Synopsis:   Searches the given branch for an anchor element which
//              has a HREF starting from a given element.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForAnchorLink ( CTreeNode * pNodeStartHere )
{
    CTreeNode * pNodeAnchor = pNodeStartHere;

    for ( ; ; )
    {
        CAnchorElement * pAnchor;

        if (!pNodeAnchor)
            break;

        pNodeAnchor = SearchBranchForAnchor( pNodeAnchor );

        if (!pNodeAnchor)
            break;

        pAnchor = DYNCAST( CAnchorElement, pNodeAnchor->Element() );

        if (pAnchor->GetAAhref())
            break;

        pNodeAnchor = pNodeAnchor->Parent();
    }

    return pNodeAnchor;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForTag
//
//  Synopsis:   Searches the given branch for an element with a given tag.
//              starting from a given element.
//
//   Returns:   Returns the element along the branch which has the tag.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForTag ( CTreeNode * pNodeStartHere, ELEMENT_TAG etag )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ;
          pNode && etag != pNode->Tag() ;
          pNode = pNode->Parent() )
    {
        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;
    }

    return pNode;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForTagInStory
//
//  Synopsis:   Searches the given branch for an element with a given tag.
//              starting from a given element.
//
//   Returns:   Returns the element along the branch which has the tag.
//
//     Notes:   Stops searching after the CTxtEdit goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForTagInStory (
    CTreeNode * pNodeStartHere, ELEMENT_TAG etag )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ;
          pNode ;
          pNode = pNode->Parent() )
    {
        if ( etag == pNode->Tag() )
            return pNode;
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForScope
//
//  Synopsis:   Searches the given branch for the scope of a given element,
//              starting from a given element.
//
//   Returns:   Returns the element along the branch which has the same scope
//              as the given element.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForScope (
    CTreeNode * pNodeStartHere,
    CElement *  pElementFindMyScope )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElementScope = pNode->Element();

        if (pElementFindMyScope == pElementScope)
            return pNode;

        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;
    }

    Assert( ! pNode );

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForScopeInStory
//
//  Synopsis:   Searches the given branch for the scope of a given element,
//              starting from a given element.
//
//   Returns:   Returns the element along the branch which has the same scope
//              as the given element.
//
//-----------------------------------------------------------------------------

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

CTreeNode *
CMarkup::SearchBranchForScopeInStory (
    CTreeNode * pNodeStartHere,
    CElement *  pElementFindMyScope )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElementScope = pNode->Element();

        if (pElementFindMyScope == pElementScope)
            return pNode;
    }

    return NULL;
}

#pragma optimize("", on)

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForNode
//
//  Synopsis:   Searches the given branch for a given element (non scope),
//              starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForNode (
    CTreeNode * pNodeStartHere, CTreeNode * pNodeFindMe )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        if (pNodeFindMe == pNode)
            return pNode;

        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForNodeInStory
//
//  Synopsis:   Searches the given branch for a given element (non-scope),
//              starting from a given element.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForNodeInStory (
    CTreeNode * pNodeStartHere, CTreeNode * pNodeFindMe )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; pNode ; pNode = pNode->Parent() )
    {
        if (pNodeFindMe == pNode)
            return pNode;
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForChildOfScope
//
//  Synopsis:   Searches the given branch for the scope of a given element,
//              starting from a given node.
//
//   Returns:   Returns the child node of the node found.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForChildOfScope (
    CTreeNode * pNodeStartHere, CElement * pElementFindChildOfMyScope )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode, * pNodeChild = NULL;

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        CElement * pElementScope = pNode->Element();

        if (pElementFindChildOfMyScope == pElementScope)
            return pNodeChild;

        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;

        pNodeChild = pNode;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForChildOfScopeInStory
//
//  Synopsis:   Searches the given branch for the scope of a given element,
//              starting from a given node.
//
//   Returns:   Returns the child node of the node found.
//
//     Notes:   Stops searching after the CTxtEdit goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForChildOfScopeInStory (
    CTreeNode * pNodeStartHere, CElement * pElementFindChildOfMyScope )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode, * pNodeChild = NULL;

    for ( pNode = pNodeStartHere ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElementScope = pNode->Element();

        if (pElementFindChildOfMyScope == pElementScope)
            return pNodeChild;

        pNodeChild = pNode;
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForBlockElement
//
//  Synopsis:   Searches the given branch for the first block element,
//              starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForBlockElement (
    CTreeNode * pNodeStartHere,
    CFlowLayout * pFLContext )
{
    CTreeNode * pNode;

    Assert( pNodeStartHere );

    if (!pFLContext && GetElementClient())
        pFLContext = GetElementClient()->GetFlowLayout(GUL_USEFIRSTLAYOUT);

    if (!pFLContext)
        return NULL;

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        CElement * pElementScope = pNode->Element();

        if (pFLContext->IsElementBlockInContext( pElementScope ))
            return pNode;

        if (pElementScope == pFLContext->ElementContent())
            return NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForNonBlockElement
//
//  Synopsis:   Searches the given branch for the first non block element,
//              starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForNonBlockElement (
    CTreeNode * pNodeStartHere,
    CFlowLayout * pFLContext )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    if (!pFLContext)
        pFLContext = GetElementClient()->GetFlowLayout(GUL_USEFIRSTLAYOUT);

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        CElement * pElementScope = pNode->Element();

        if (!pFLContext->IsElementBlockInContext( pElementScope ))
        {
            return pNode;
        }

        if (pElementScope == pFLContext->ElementOwner())
            return NULL;
    }
}

//+----------------------------------------------------------------------------
//
//    Member:   CreateInclusion
//
//  Synopsis:   Splits the branch up to but not including pNodeStop.
//              The inclusion will occur at ptpgLocation.  ptpgInclusion will
//              be set to the middle of the inclusion.
//
// Arguments:
//      pNodeStop       -   the node to split up to but not including
//      ptpgLocation    -   create the split here. IN ONLY
//      ptpgInclusion   -   return the CTreePos just before the split. OUT ONLY
//      pNodeAboveLocation - the node directly above ptpgLocation, if NULL,
//                           it will be computed
//      fFullReparent   -   if TRUE, everything will be reparented correctly
//                          if FALSE, only the new nodes will
//      ppNodeLastAdded -   return the top of the new element chain
//
//-----------------------------------------------------------------------------

HRESULT
CMarkup::CreateInclusion(
    CTreeNode *     pNodeStop,
    CTreePosGap *   ptpgLocation,
    CTreePosGap *   ptpgInclusion,
    CTreeNode *     pNodeAboveLocation /*= NULL*/,
    BOOL            fFullReparent /*= TRUE*/,
    CTreeNode **    ppNodeLastAdded /*= NULL*/)
{
    HRESULT     hr = S_OK;
    CTreePosGap tpgInsert ( TPG_LEFT );
    CTreeNode * pNodeCurr, * pNodeNew = NULL;
    CTreeNode * pNodeLastNew = NULL;

    //
    // The passed in gap must be specified and positioned at a valid point
    // in this tree.
    //

    Assert( ptpgLocation );
    Assert( ptpgLocation->IsValid() );
    Assert( ptpgLocation->GetAttachedMarkup() == this );

    //
    // The node up to which we should split must be specified and in this tree.
    // Note that this node may not actually curently influence the gap in the
    // tree specified by ptpgLocation.  This is so because the tree may be in
    // an unstable state.
    //

    Assert( pNodeStop );
    Assert( pNodeStop->GetMarkup() == this );

    //
    // The pNodeAboveLocation, if specified, should be assumed to be the first node
    // which influences the gap specified by ptpgLocation.  Because the tree may be
    // in an unstable state, this node may not be visible to ptpgLocation.
    //
    // In any case, here we compute the node where we start the creation of the
    // inclusion.
    //

    pNodeCurr = pNodeAboveLocation ? pNodeAboveLocation : ptpgLocation->Branch();

    Assert( pNodeCurr );

    //
    // Now that we have a place to start with in the tree, make sure the stop node
    // is somewhere along the parent chain from the start node (now pNodeCurr).
    //

    Assert( pNodeCurr->SearchBranchToRootForScope( pNodeStop->Element() ) == pNodeStop );

    //
    // Set up the spot to insert
    //

    Verify( ! tpgInsert.MoveTo( ptpgLocation ) );

    while (pNodeCurr != pNodeStop)
    {
        CTreePos * ptpNew;

        //
        // Create the new node (proxy to the current element)
        //

        pNodeNew = new CTreeNode( pNodeCurr->Parent(), pNodeCurr->Element() );

        if (!pNodeNew)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        //
        // Insert the end pos of the new node to be just before the end pos of
        // the node we cloned it from.  It inherits edge scopeness from the end
        // of the current node.
        //

        ptpNew = pNodeNew->InitEndPos( pNodeCurr->GetEndPos()->IsEdgeScope() );

        Verify( ! Insert( ptpNew, pNodeCurr->GetEndPos(), TRUE ) );

        //
        // Based on the attach preference of the tree gap which originally
        // specified where to create the inclusion, push that gap around.
        //

        if (ptpgLocation->AttachedTreePos() == pNodeCurr->GetEndPos())
        {
            Assert( ptpgLocation->AttachDirection() == TPG_RIGHT );

            ptpgLocation->MoveTo( ptpNew, TPG_LEFT );
        }

        //
        // Insert the begin pos to the right of the point of the inclusion.  It is
        // automatically not an edge.
        //

        ptpNew = pNodeNew->InitBeginPos( FALSE );

        Verify( ! Insert( ptpNew, tpgInsert.AttachedTreePos(), FALSE ) );

        //
        // Mark this node as being in the markup
        //
        pNodeNew->PrivateEnterTree();

        //
        // Move the end pos of the current node to be to the left of the
        // location of the inclusion.
        //

        Verify( ! Move( pNodeCurr->GetEndPos(), tpgInsert.AttachedTreePos(), FALSE ) );

        //
        // The end pos of the current node is no longer an edge
        //

        // CONSIDER (JHarding): We may want to amortize these adjustments, if there's some way to do that.
        pNodeCurr->GetEndPos()->MakeNonEdge();

        //
        // Move over the end of end of the current node to get back into the
        // location of the inclusion.
        //

        Verify( ! tpgInsert.Move( TPG_RIGHT ) );

        Assert( tpgInsert.AdjacentTreePos( TPG_LEFT ) == pNodeCurr->GetEndPos() );

        //
        // Reparent the direct children in the range affected
        //

        if (fFullReparent)
        {
            hr = THR( ReparentDirectChildren( pNodeNew ) );

            if (hr)
                goto Cleanup;
        }
        else if (pNodeLastNew)
        {
            pNodeLastNew->SetParent( pNodeNew );
        }

        //
        // Finally, set up for the next time around
        //

        pNodeLastNew = pNodeNew;
        pNodeCurr = pNodeCurr->Parent();
    }


    if (ppNodeLastAdded)
        *ppNodeLastAdded = pNodeLastNew;

    if (ptpgInclusion)
        Verify( ! ptpgInclusion->MoveTo( & tpgInsert ) );

Cleanup:

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//    Member:   CloseInclusion
//
//  Synopsis:   Close a possible empty inclusion.  It is possible that there
//              will be no inclusion at ptpgMiddle, in which case
//              CloseInclusion does nothing.  Otherwise, it removes as many
//              redundant nodes as possible.
//
// Arguments:
//      ptpgMiddle -   The middle of the inclusion to close.  Will be
//                     set to the gap where the inclusion was on exit
//
//-----------------------------------------------------------------------------

HRESULT
CMarkup::CloseInclusion (
    CTreePosGap * ptpgMiddle )
{
    HRESULT     hr = S_OK;
    CTreePosGap tpgMiddle ( TPG_LEFT );

    //
    // Note: tpgMiddle is bound to the pos which is to the left of the
    // gap because it will move to the left as we delete nodes.  This
    // way, it stays out of the way (to the left) of the removals.
    //

    //
    // The middle gap argument must be specified and positioned in this
    // tree.
    //

    Assert( ptpgMiddle );
    Assert( ptpgMiddle->IsPositioned() );
    Assert( ptpgMiddle->GetAttachedMarkup() == this );

    //
    // Copy the incomming argument to our local gap, nd unposition the argument.
    // We'll reposition it later, after we have closed the inclusion.
    //

    Verify( ! tpgMiddle.MoveTo( ptpgMiddle ) );

    ptpgMiddle->UnPosition();

    for ( ; ; )
    {
        CTreePos * ptpRightMiddle, * ptpLeftMiddle;
        CTreeNode * pNodeBefore, * pNodeAfter;

        //
        // Get the pos to the left of the gap which travels accross
        // the splays.
        //

        ptpLeftMiddle = tpgMiddle.AttachedTreePos();

        //
        // We know we're not in an inclusion anymore when the pos to the
        // left is not a ending edge.
        //
        // Note, we don't have to check to tree pointers or text because
        // they must never be seen in inclusions.
        //

        if (!ptpLeftMiddle->IsEndNode() || ptpLeftMiddle->IsEdgeScope())
            break;

        //
        // Get the tree pos to the right of the one which is to the
        // left of the gap.  This will, then, be to the right of the gap.
        //

        ptpRightMiddle = ptpLeftMiddle->NextTreePos();

        //
        // Check the right edge for non matching ptp's.  We can
        // have a non edge end node pos on the left but not a non edge begin
        // node ont he right during certain circumstances in splice.
        //

        if (!ptpRightMiddle->IsBeginNode() || ptpRightMiddle->IsEdgeScope())
            break;

        //
        // Move the gap to the left (<--) by one (not right).
        //

        Verify( ! tpgMiddle.MoveLeft() );

        //
        // If we've gotten this far, then there better be
        // an inclusion here.
        //
        // Thus, we must have a non edge beginning to our right.
        //

        Assert(
              ptpRightMiddle->IsBeginNode() &&
            ! ptpRightMiddle->IsEdgeScope() );

        //
        // Get the nodes associated with either side of the gap in question.
        //

        pNodeBefore = ptpLeftMiddle->Branch();
        pNodeAfter  = ptpRightMiddle->Branch();

        //
        // To be in an inclusion, the two adjacent nodes must refer to
        // the same element.
        //

        Assert( pNodeBefore->Element() == pNodeAfter->Element() );

        //
        // Make sure the inclusion does not refer to the root!
        //

        Assert( !pNodeBefore->Element()->IsRoot() );


        //
        // Move the end pos of the node left of the gap to be just before
        // the end pos of the node right of the gap.
        //
        // This way, the node left of the gap will subsume "ownership"
        // of all the stuff which is under the node right of the gap.
        //

        Verify( ! Move( pNodeBefore->GetEndPos(), pNodeAfter->GetEndPos(), TRUE ) );

        //
        // Now that the node right of the gap is going away, the end pos
        // of the node left of the gap needs to reflect the same edge status
        // of the end pos going away.  Because there may be yet another
        // proxy for this element to the right, we can't assume that it
        // is an edge.
        //

        pNodeBefore->GetEndPos()->SetScopeFlags(
            pNodeAfter->GetEndPos()->IsEdgeScope() );

        //
        // Here we remove the node right of the gap (and its pos's)
        //

        Verify( ! Remove( pNodeAfter->GetBeginPos() ) );

        Verify( ! Remove( pNodeAfter->GetEndPos() ) );

        //
        // Reparent the children that were pointing to the node going away.
        //
        // Now that the node to the right of the gap is gone, we must
        // make sure that all the nodes which pointed to the node which
        // we just removed now point to the node which remains.
        //
        // We start the reparent starting at the current location of the gap
        // and extending until the remaining node goes out of scope.
        //

        hr = THR( ReparentDirectChildren( pNodeBefore, & tpgMiddle ) );

        if (hr)
            goto Cleanup;

        //
        // Now, kill the node we just removed.  No one in this tree better be
        // pointing to it after the reparent operation.
        //

        // pNodeAfter is not usable after this
        pNodeAfter->PrivateExitTree();
        pNodeAfter = NULL;
    }

    //
    // Put the incomming argument back into the tree
    //

    Verify( ! ptpgMiddle->MoveTo( & tpgMiddle ) );

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//    Member:   ReparentDirectChildren
//
//  Synopsis:   This routine assumes that the begin and end node pos's for
//              pNodeParentNew are already in place.  What it does is
//              make sure all direct children (according to the runs)
//              point to pNodeParentNew.  In other words, this routine makes
//              sure the parent info implied by the runs is reflected by
//              the tree itself.
//
//              If ptpgStart and ptpgEnd are passed in, they must be under the
//              direct scope of the parent.  This allows the routine to skip
//              over all the runs of direct children.
//
// Arguments:
//      pNodeParentNew  -   the new parent
//      ptpgStart       -   where to start parenting, IN only
//      ptpgEnd         -   where to stop parenting, IN only
//
//-----------------------------------------------------------------------------

HRESULT
CMarkup::ReparentDirectChildren (
    CTreeNode *   pNodeParentNew,
    CTreePosGap * ptpgStart,
    CTreePosGap * ptpgEnd )
{
    CTreePos *  ptpCurr, * ptpEnd;

    //
    // If the start/end is specified, make sure they're sane
    //

    Assert( ! ptpgStart || ptpgStart->GetAttachedMarkup() == this );
    Assert( ! ptpgEnd   || ptpgEnd->GetAttachedMarkup()   == this );

    //
    // If the position where we should start and end the reparent operation
    // are specified, then go there, otherwise start/end at where the new
    // parent starts/ends.
    //

    ptpCurr =
        ptpgStart
            ? ptpgStart->AdjacentTreePos( TPG_RIGHT )
            : pNodeParentNew->GetBeginPos()->NextTreePos();

    ptpEnd =
        ptpgEnd
            ? ptpgEnd->AdjacentTreePos( TPG_RIGHT )
            : pNodeParentNew->GetEndPos();

    //
    // Make sure the start is to the left of the end
    //

    Assert( ptpCurr->InternalCompare( ptpEnd ) <= 0 );

    //
    // Loop and reparent.  Get to just direct children by skipping
    // over direct children.
    //

    while ( ptpCurr != ptpEnd )
    {
        switch ( ptpCurr->Type() )
        {
        case CTreePos::NodeEnd :

            //
            // We will (most) never find an end pos because we'll skip over
            // them when we encounter the begin pos for that node.
            //

            AssertSz( 0, "Found an end pos during reparent children" );

            break;

        case CTreePos::NodeBeg :

            ptpCurr->Branch()->SetParent( pNodeParentNew );

            //
            // Skip over everything under this node
            //
            ptpCurr = ptpCurr->Branch()->GetEndPos();

            break;

        case CTreePos::Pointer :

            if (ptpCurr->HasCollapsedWhitespace())
            {
                ptpCurr->SetWhitespaceParent( pNodeParentNew );
            }

            break;

        default:

            Assert( ! ptpCurr->IsUninit() );

            break;
        }

        ptpCurr = ptpCurr->NextTreePos();
    }

    RRETURN( S_OK );
}

//+----------------------------------------------------------------------------
//
//    Member:   RemoveElement
//
//  Synopsis:   Removes the influence of an element
//
//-----------------------------------------------------------------------------

static void
RemoveNodeChars ( CMarkup * pMarkup, long cp, long cch, CTreeNode * pNode )
{
    CNotification nf;

    Assert( cp >= 0 && cp < pMarkup->GetTextLength() );
    Assert( cch > 0 && cp + cch <= pMarkup->GetTextLength() );

    nf.CharsDeleted( cp, cch, pNode );

#if DBG == 1
    {
        CTxtPtr tp2 ( pMarkup, cp );

        for ( int i = 0 ; i < cch; i++, tp2.AdvanceCp( 1 ) )
            Assert( tp2.GetChar() == WCH_NODE );
    }
#endif

    CTxtPtr( pMarkup, cp ).DeleteRange( cch );

    pMarkup->Notify( & nf );
}

HRESULT
CMarkup::RemoveElementInternal (
    CElement * pElementRemove,
    DWORD      dwFlags )
{
    HRESULT            hr = S_OK;
    BOOL               fDOMOperation = dwFlags & MUS_DOMOPERATION;
    CTreePosGap        tpgElementBegin ( TPG_LEFT );
    CTreePosGap        tpgEnd ( TPG_RIGHT );
    CTreeNode *        pNodeCurr, * pNodeNext;
    long               siStart;
    BOOL               fDelayRelease = FALSE, fExitTreeSc = FALSE;
    CMarkup::CLock     MarkupLock( this );
    CRemoveElementUndo Undo( this, pElementRemove, dwFlags );
    long               cpBegin = 0, cpEnd = 0;

    // TODO (EricVas): Specialcase the removal of an empty element so that
    //                   multiple notifications can be amortized

    //
    // The element to be removed must be specified and in this tree.  Also,
    // We better not be trying to remove the tree element itself!
    //

    Assert( pElementRemove );
    Assert( pElementRemove->GetMarkup() );
    Assert( pElementRemove->GetMarkup() == this );
    Assert( !pElementRemove->IsRoot() );

    if( HasLogManager() && GetLogManager()->IsAnyoneListening() )
    {
        CTreePos * ptpBegin;
        CTreePos * ptpEnd;

        pElementRemove->GetTreeExtent( &ptpBegin, &ptpEnd );
        cpBegin = ptpBegin->GetCp();
        cpEnd   = ptpEnd->GetCp();

        fDelayRelease = TRUE;
        WHEN_DBG( pElementRemove->_fDelayRelease = TRUE );
    }


    //
    // Notify element it is about to exit the tree
    //

    {
        CNotification nf;

        Assert( !pElementRemove->_fExittreePending );
        pElementRemove->_fExittreePending = TRUE;

        nf.ElementExittree1( pElementRemove );

        Assert( nf.IsSecondChanceAvailable() );

        // If we are in the undo queue, we will have _ulRefs>1 by now.
        if( pElementRemove->GetObjectRefs() == 1 )
        {
            nf.SetData( EXITTREE_PASSIVATEPENDING );
            Assert( !pElementRemove->_fPassivatePending );
            WHEN_DBG( pElementRemove->_fPassivatePending = TRUE );
        }

        pElementRemove->Notify( & nf );

        if (nf.IsSecondChanceRequested())
        {
            fDelayRelease = TRUE;
            fExitTreeSc = TRUE;
            WHEN_DBG( pElementRemove->_fDelayRelease = TRUE );
        }
        else if (nf.DataAsDWORD() & EXITTREE_DELAYRELEASENEEDED)
        {
            fDelayRelease = TRUE;
            WHEN_DBG( pElementRemove->_fDelayRelease = TRUE );
        }

        pElementRemove->_fExittreePending = FALSE;
    }

    hr = THR( EmbedPointers() );

    if (hr)
        goto Cleanup;

    //
    // Remove tree pointers with cling around the edges of the element being removed
    //
    {
        CTreePosGap tpgCling;
        CTreePos * ptpBegin, * ptpEnd;

        pElementRemove->GetTreeExtent( &ptpBegin, &ptpEnd );

        Assert( ptpBegin && ptpEnd );

        // Around the beginning
        Verify( ! tpgCling.MoveTo( ptpBegin, TPG_LEFT ) );
        tpgCling.PartitionPointers(this, fDOMOperation);
        tpgCling.CleanCling( this, TPG_RIGHT, fDOMOperation );

        Verify( ! tpgCling.MoveTo( ptpBegin, TPG_RIGHT ) );
        tpgCling.PartitionPointers(this, fDOMOperation);
        tpgCling.CleanCling( this, TPG_LEFT, fDOMOperation );

        // Around the end
        Verify( ! tpgCling.MoveTo( ptpEnd, TPG_LEFT ) );
        Verify( ! tpgCling.MoveLeft( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );
        tpgCling.PartitionPointers(this, fDOMOperation);
        tpgCling.CleanCling( this, TPG_RIGHT, fDOMOperation );

        Verify( ! tpgCling.MoveTo( ptpEnd, TPG_RIGHT ) );
        Verify( ! tpgCling.MoveRight( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );
        tpgCling.PartitionPointers(this, fDOMOperation);
        tpgCling.CleanCling( this, TPG_LEFT, fDOMOperation );
    }

    //
    // Record where the element begins, making sure the gap used to record this
    // points to the tree pos to the left so that stuff removed from the tree
    // does not include that.
    //

    tpgElementBegin.MoveTo( pElementRemove->GetFirstBranch()->GetBeginPos(), TPG_LEFT );

    //
    // Remember the source index of the element that we are removing
    //

    siStart = pElementRemove->GetFirstBranch()->GetBeginPos()->SourceIndex();

    //
    // Run through the context chain removing contexts in their entirety
    //

    for ( pNodeCurr = pElementRemove->GetFirstBranch() ;
          pNodeCurr ;
          pNodeCurr = pNodeNext )
    {
        CTreeNode * pNodeParent;
        CTreePosGap tpgNodeBegin ( TPG_LEFT );
        BOOL        fBeginEdge;

        //
        // Before we nuke this node, record its parent and next context
        //

        pNodeParent = pNodeCurr->Parent();
        pNodeNext = pNodeCurr->NextBranch();

        //
        // Record the gaps where the node is right now
        //

        tpgNodeBegin.MoveTo( pNodeCurr->GetBeginPos(), TPG_RIGHT );
        tpgEnd.MoveTo( pNodeCurr->GetEndPos(), TPG_LEFT );

        //
        // Make all the immediate children which were beneath this node point
        // to its parent.
        //

        hr = THR(
            ReparentDirectChildren(
                pNodeParent, & tpgNodeBegin, & tpgEnd ) );

        if (hr)
            goto Cleanup;

        //
        // Swing the pointers to the outside
        //

        tpgNodeBegin.MoveTo( pNodeCurr->GetBeginPos(), TPG_LEFT );
        tpgEnd.MoveTo( pNodeCurr->GetEndPos(), TPG_RIGHT );

        //
        // Remove the begin pos
        //

        fBeginEdge = pNodeCurr->GetBeginPos()->IsEdgeScope();

        hr = THR( Remove( pNodeCurr->GetBeginPos() ) );

        if (hr)
            goto Cleanup;

        //
        // Delete the character and send the notification
        //

        if( fBeginEdge )
        {
            RemoveNodeChars(this, tpgNodeBegin.GetCp(), 1, pNodeParent );
        }

//...        hr = THR( MergeRightText( tpgNodeBegin.AttachedTreePos() );


        //
        // Remove the end pos
        //

        {
            hr = THR( Remove( pNodeCurr->GetEndPos() ) );

            if (hr)
                goto Cleanup;

            //
            // If this is the last node in the content chain, there must be
            // an inclusion here.  Remove it.
            //

            if (!pNodeNext)
            {
                hr = THR( CloseInclusion( & tpgEnd ) );
                if (hr)
                    goto Cleanup;

                //
                // Delete the chracters and send the  notification
                //
                RemoveNodeChars(this, tpgEnd.GetCp(), 1, tpgEnd.Branch() );
            }

        }

        //
        // Kill the node
        //

        pNodeCurr->PrivateExitTree();
        pNodeCurr = NULL;
    }

    //
    // Set the Undo data
    //

    Undo.SetData( tpgElementBegin.GetCp(), tpgEnd.GetCp() );


    //
    // Release element from the tree
    //

    {
        WHEN_DBG(BOOL fPassivatePending = pElementRemove->_fPassivatePending);

        if (fDelayRelease)
        {
            pElementRemove->AddRef();
            WHEN_DBG( pElementRemove->_fPassivatePending = FALSE );
        }

        pElementRemove->__pNodeFirstBranch = NULL;

        pElementRemove->DelMarkupPtr();
        pElementRemove->PrivateExitTree( this );

#if DBG==1
        if (fDelayRelease)
            pElementRemove->_fPassivatePending = fPassivatePending;
#endif
    }

    //
    // Clear caches, etc
    //

    UpdateMarkupTreeVersion();

    if (tpgElementBegin != tpgEnd)
    {
        CTreePos * ptpLeft = tpgElementBegin.AdjacentTreePos( TPG_RIGHT );
        CTreePos * ptpRight = tpgEnd.AdjacentTreePos( TPG_LEFT );

        hr = THR( RangeAffected( ptpLeft, ptpRight ) );
    }

    tpgEnd.UnPosition();
    tpgElementBegin.UnPosition();

    //
    //  Send the ElementsDeleted notification
    //

    {
        CNotification nf;

        nf.ElementsDeleted( siStart, 1 );

        Notify( nf );
    }

    Assert( IsNodeValid() );

    Undo.CreateAndSubmit();

    if( HasLogManager() && GetLogManager()->IsAnyoneListening() )
    {
        IGNORE_HR( GetLogManager()->InsertOrRemoveElement( FALSE, cpBegin, cpEnd, pElementRemove ) );
    }

    //
    // Send the ExitTreeSc notification and do the delay release
    //

    if( fExitTreeSc )
    {
        Assert( fDelayRelease );
        CNotification nf;

        nf.ElementExittree2( pElementRemove );
        pElementRemove->Notify( &nf );
    }

    if( fDelayRelease )
    {
        // Release the element
        Assert( pElementRemove->_fDelayRelease );
        WHEN_DBG( pElementRemove->_fDelayRelease = FALSE );
        Assert( !pElementRemove->_fPassivatePending || pElementRemove->GetObjectRefs() == 1 );
        pElementRemove->Release();
    }

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//    Member:   InsertElement
//
//  Synopsis:   Inserts an element into the tree.  The element must not already
//              be in the tree when this is called.
//
// Arguments:
//      pElementInsertThis  -   The element to insert
//      ptpgBegin           -   Element will begin here.  Must be a valid gap.
//                              IN only
//      ptpgEnd             -   Element will end here. Must be a valid gap.
//                              IN only
//-----------------------------------------------------------------------------

static void
InsertNodeChars ( CMarkup * pMarkup, long cp, long cch, CTreeNode * pNode )
{
    CNotification nf;

    Assert( cp >= 0 && cp < pMarkup->GetTextLength() );

    nf.CharsAdded( cp, cch, pNode );

    CTxtPtr( pMarkup, cp ).InsertRepeatingChar( cch, WCH_NODE );

    pMarkup->Notify( & nf );
}

HRESULT
CMarkup::InsertElementInternal (
    CElement *    pElementInsertThis,
    CTreePosGap * ptpgBegin,
    CTreePosGap * ptpgEnd,
    DWORD         dwFlags )
{
    HRESULT      hr = S_OK;
    CDoc *       pDoc = Doc();
    BOOL         fDOMOperation = dwFlags & MUS_DOMOPERATION;
    CTreePosGap  tpgCurr( TPG_LEFT );
    CTreeNode *  pNodeNew = NULL;
    CTreeNode *  pNodeLast = NULL;
    CTreeNode *  pNodeParent = NULL;
    CTreeNode *  pNodeAboveEnd;
    BOOL         fLast = FALSE;
    CTreePosGap  tpgBegin( TPG_LEFT ), tpgEnd( TPG_RIGHT );
    CInsertElementUndo Undo( this, dwFlags );
    long         cpBegin = 0, cpEnd = 0;

    Assert( ! HasUnembeddedPointers() );

    EnsureTotalOrder( ptpgBegin, ptpgEnd );

    Undo.SetData( pElementInsertThis );

    // TODO (EricVas) : Make insertion of unscoped element amortize notifications

    //
    // Element to insert must be specified and not in any tree
    //

    Assert( pElementInsertThis && !pElementInsertThis->GetFirstBranch() );

    //
    // The gaps specifying where to put the element must be specified and
    // in valid locations in the splay tree.  They must also both be in
    // the same tree (this tree).
    //

    if(!ptpgBegin || !ptpgEnd)
        return E_FAIL;

    Assert( ptpgBegin && ptpgBegin->IsValid() );
    Assert( ptpgEnd && ptpgEnd->IsValid() );
    Assert( ptpgBegin->AttachedTreePos()->IsInMarkup( this ) );
    Assert( ptpgEnd->AttachedTreePos()->IsInMarkup( this ) );

    //
    // Push any tree pointers at the insertion points in the correct directions
    //

    ptpgBegin->PartitionPointers(this, fDOMOperation);
    ptpgEnd->PartitionPointers(this, fDOMOperation);

    //
    // Make sure to split any text IDs
    //

    if (pDoc->_lLastTextID)
    {
        SplitTextID(
            ptpgBegin->AdjacentTreePos( TPG_LEFT ),
            ptpgBegin->AdjacentTreePos( TPG_RIGHT) );

        if (*ptpgBegin != *ptpgEnd)
        {
            SplitTextID(
                ptpgEnd->AdjacentTreePos( TPG_LEFT ),
                ptpgEnd->AdjacentTreePos( TPG_RIGHT) );
        }
    }

    //
    // Copy the endpoints to local gaps.  This way we don't muck with the
    // arguments.
    //

    Verify( ! tpgBegin.MoveTo( ptpgBegin ) );
    Verify( ! tpgEnd.MoveTo( ptpgEnd ) );

    if( HasLogManager() && GetLogManager()->IsAnyoneListening() )
    {
        cpBegin = tpgBegin.AdjacentTreePos( TPG_RIGHT )->GetCp();
        cpEnd   = tpgEnd.AdjacentTreePos( TPG_RIGHT )->GetCp();
    }

    //
    // The var tpgCurr will walk through the insertionm left to right
    //

    tpgCurr.MoveTo( ptpgBegin );

    pNodeAboveEnd = ptpgEnd->Branch();

    //
    // Get the parent for the new node
    //

    pNodeParent = tpgCurr.Branch();

    while (!fLast)
    {
        //
        // Check to see if this is the last node we will have to insert
        //

        if (SearchBranchForNodeInStory( pNodeAboveEnd, pNodeParent ))
            fLast = TRUE;

        //
        // Create the new node and hook it into the context list
        //

        pNodeNew = new CTreeNode( pNodeParent, pElementInsertThis );

        if ( !pNodeNew )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }


        if (! pNodeLast)
        {
            pElementInsertThis->__pNodeFirstBranch = pNodeNew;

            pElementInsertThis->SetMarkupPtr( this );
            pElementInsertThis->PrivateEnterTree();
        }

        //
        // Insert the start node
        //

        {
            CTreePos * ptpNew;

            Assert( pNodeNew->GetBeginPos()->IsUninit() );

            ptpNew = pNodeNew->InitBeginPos( !pNodeLast );

            Verify( ! Insert( ptpNew, & tpgCurr ) );

            // The element is now in the tree so add a ref for the
            // tree
            pNodeNew->PrivateEnterTree();

            // Only the first begin node gets a node char
            if( !pNodeLast )
            {

                // Since the begin isn't part of an inclusion, we don't have to calculate
                // who to notify.
                InsertNodeChars( this, ptpNew->GetCp(), 1, pNodeParent );
            }
        }

        //
        // Insert the end node
        //
        {
            CTreePos *  ptpNew;
            long        cpInsert;
            CTreeNode * pNodeNotify = NULL;

            //
            // Create or set the insertion point
            //

            if (fLast)
            {
                //
                // Split the branch to create a spot for our end node pos
                //
                pNodeNotify = pNodeAboveEnd;

                cpInsert = tpgEnd.GetCp();

                hr = THR( CreateInclusion(  pNodeParent,
                                            & tpgEnd,
                                            & tpgCurr,
                                            pNodeAboveEnd ) );

                if (hr)
                    goto Cleanup;
            }
            else
            {
                CTreePosGap tpgNotify( TPG_RIGHT );

                Verify( !tpgCurr.MoveTo( pNodeParent->GetEndPos(), TPG_LEFT ) );

                cpInsert = tpgCurr.GetCp();

            }


            Assert( pNodeNew->GetEndPos()->IsUninit() );

            ptpNew = pNodeNew->InitEndPos( fLast );

            Verify( ! Insert( ptpNew, & tpgCurr ) );

            Verify( ! tpgCurr.MoveRight() );
            Assert( tpgCurr.AdjacentTreePos( TPG_LEFT ) == ptpNew );

            if( fLast )
                InsertNodeChars( this, cpInsert, 1, pNodeAboveEnd );
        }

        //
        // Reparent direct children to the new node
        //

        hr = THR( ReparentDirectChildren( pNodeNew ) );

        if (hr)
            goto Cleanup;

        if (!fLast)
        {
            // if we are here, it implies that we are
            // inserting the end after the end of pNodeParent
            // This _can't_ happen if pNodeParent is a ped.

            Assert( !pNodeParent->IsRoot() );

            //
            // Set up for the next new node
            //

            pNodeLast = pNodeNew;

            //
            // This sets our beginning insertion point
            // for the next node.  What we are doing here
            // is essentially threading the new element
            // through any inclusions.
            //

            Verify( ! tpgCurr.MoveRight() );

            Assert( tpgCurr.AttachedTreePos()->IsEndNode() &&
                    tpgCurr.AttachedTreePos()->Branch() == pNodeParent );

            //
            // pNodeParent is done so its parent is the new pNodeParent
            //

            if( tpgCurr.AttachedTreePos()->IsEdgeScope() )
            {
                pNodeParent = pNodeParent->Parent();
            }
            else
            {
                //
                // Find the next branch of pNodeParent
                //

                CElement *pElementParent = pNodeParent->Element();
                CTreeNode *pNodeCurr;

                do
                {
                    Verify( ! tpgCurr.MoveRight() );

                    Assert( tpgCurr.AttachedTreePos()->IsNode() );

                    pNodeCurr = tpgCurr.AttachedTreePos()->Branch();
                }
                while( pNodeCurr->Element() != pElementParent );

                Assert( tpgCurr.AttachedTreePos()->IsBeginNode() );

                pNodeParent = pNodeCurr;
            }

        }
    }

    //
    // Tell the element that it is now in the tree
    //

    {
        CNotification nf;

        nf.ElementEntertree( pElementInsertThis );
        pElementInsertThis->Notify( & nf );
    }

    if (tpgBegin != tpgEnd)
    {
        CTreePos * ptpLeft = tpgBegin.AdjacentTreePos( TPG_RIGHT );
        CTreePos * ptpRight = tpgEnd.AdjacentTreePos( TPG_LEFT );

        hr = THR( RangeAffected( ptpLeft, ptpRight ) );
    }

    // Send the element added notification
    {
        CTreePos *      ptpBegin;
        CNotification   nf;

        pElementInsertThis->GetTreeExtent( &ptpBegin, NULL );
        Assert( ptpBegin );

        nf.ElementsAdded( ptpBegin->SourceIndex(), 1 );
        Notify( nf );
    }

    //
    // Things should be valid here
    //

    Assert( IsNodeValid() );

    UpdateMarkupTreeVersion();

    Undo.CreateAndSubmit();

    if( HasLogManager() && GetLogManager()->IsAnyoneListening() )
    {
        IGNORE_HR( GetLogManager()->InsertOrRemoveElement( TRUE, cpBegin, cpEnd, pElementInsertThis ) );
    }

Cleanup:

    RRETURN( hr );
}

BOOL
AreDifferentScriptIDs(SCRIPT_ID * psidFirst, SCRIPT_ID sidSecond)
{
    if(     *psidFirst == sidSecond
       ||   sidSecond == sidMerge
       ||   *psidFirst == sidAsciiLatin && sidSecond == sidAsciiSym)
    {
        return FALSE;
    }

    if (    *psidFirst == sidMerge
        ||  *psidFirst == sidAsciiSym && sidSecond == sidAsciiLatin)
    {
        *psidFirst = sidSecond;
        return FALSE;
    }

    return TRUE;
}
//+----------------------------------------------------------------------------
//
//    Member:   InsertText
//
//  Synopsis:   Inserts a chunk of text into the tree before the given TreePos
//              This does not send notifications.
//
//-----------------------------------------------------------------------------

// NOTE: we can probably share code here between this function and
// the slow loop of CHtmRootParseCtx::AddText

HRESULT
CMarkup::InsertTextInternal (
    CTreePos *    ptpAfterInsert,
    const TCHAR * pch,
    long          cch,
    DWORD         dwFlags )
{
    HRESULT         hr = S_OK;
    BOOL            fDOMOperation = dwFlags & MUS_DOMOPERATION;
    CTreePosGap     tpg( TPG_RIGHT );
    CTreePos *      ptpLeft;
    const TCHAR *   pchCurr;
    const TCHAR *   pchStart;
    long            cchLeft;
    SCRIPT_ID       sidLast = sidMerge;
    SCRIPT_ID       sidHint;
    SCRIPT_ID       sidCurr = 0;
    long            lTextIDCurr = 0;
    CNotification   nf;
    long            cpStart = ptpAfterInsert->GetCp();
    CInsertSpliceUndo Undo( Doc() );
    WHEN_DBG(long   ichAfterInsert = 0);

    Undo.Init( this, dwFlags );

    Assert( ! HasUnembeddedPointers() );

    Assert( ptpAfterInsert );
    Assert( cch >= 0 );

    if (cch <= 0)
        goto Cleanup;

    UpdateMarkupContentsVersion();

    Assert( ptpAfterInsert );
    Assert( cch >= 0 );

    // Partition the pointers to ensure gravity

    tpg.MoveTo( ptpAfterInsert, TPG_LEFT );
    tpg.PartitionPointers(this, fDOMOperation);
    ptpAfterInsert = tpg.AdjacentTreePos( TPG_RIGHT );

    Undo.SetData( cpStart, cpStart + cch );

    nf.CharsAdded( cpStart, cch, tpg.Branch() );

    //
    // Collect some information that we'll need later
    //

    // Get info about the previous pos

    ptpLeft = tpg.AdjacentTreePos( TPG_LEFT );
    Assert( ptpLeft );

    pchCurr = pchStart = pch;
    cchLeft = cch;

    // Look around for a TextID to merge with

    {
        CTreePos * ptp;

        for ( ptp = ptpLeft ; ! ptp->IsNode() ;  ptp = ptp->PreviousTreePos() )
        {
            if (ptp->IsText())
            {
                sidLast = ptp->Sid();
                lTextIDCurr = ptp->TextID();
                break;
            }
        }

        if (!lTextIDCurr)
        {
            for ( ptp = ptpAfterInsert ; ! ptp->IsNode() ; ptp = ptp->NextTreePos() )
            {
                if (ptp->IsText())
                {
                    lTextIDCurr = ptp->TextID();
                    break;
                }
            }
        }
    }

    sidHint = sidLast;

    //
    // Break up the text into chunks of compatible SIDs.
    //

    while (cchLeft)
    {
        SCRIPT_ID   sidChunk;
        ULONG       cchChunk;
        TCHAR       chCurr = *pchCurr;

        sidChunk = sidHint;

        // Find the end of this chunk of characters with the same sid

        while (cchLeft)
        {
            chCurr = *pchCurr;

            //
            // If we find an illeagal character, then simply compute a new,
            // correct, buffer and call recursively.
            //

            if (chCurr == 0 || !IsValidWideChar( chCurr ))
            {
                TCHAR * pch2;
                long i;

                AssertSz( 0, "Bad char during insert" );

                pch2 = new TCHAR [ cch ];

                if (!pch2)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                for ( i = 0 ; i < cch ; i++ )
                {
                    TCHAR ch = pch[ i ];

                    if (ch == 0 || !IsValidWideChar( ch ))
                        ch = _T('?');

                    pch2[i] = ch;
                }

                hr = THR( InsertTextInternal( ptpAfterInsert, pch2, cch, dwFlags ) );

                delete pch2;

                goto Cleanup;
            }

            sidCurr = ScriptIDFromCh(chCurr);

            if (AreDifferentScriptIDs( & sidChunk, sidCurr ))
                break;

            pchCurr++;
            cchLeft--;
        }

        cchChunk = pchCurr - pchStart;

        if(cchChunk == 0)
        {
            Assert( sidLast != sidCurr && sidCurr != sidMerge );
            sidHint = sidCurr;
            continue;
        }

        // If this is the first chunk, attempt to merge with a text pos to the left
        if(ptpLeft->IsText() && !AreDifferentScriptIDs(&sidChunk, sidLast))
        {

            Assert(pchStart == pch);
            ptpLeft->ChangeCch(cchChunk);
            ptpLeft->DataThis()->t._sid = sidChunk;
        }
        else
        {
            // If we can merge with the text pos after insertion, do so
            if(cchLeft == 0 &&
               ptpAfterInsert->IsText() &&
                !AreDifferentScriptIDs(&sidChunk, ptpAfterInsert->Sid()))
            {
                WHEN_DBG( ichAfterInsert = cchChunk );
                ptpAfterInsert->ChangeCch(cchChunk);
                ptpAfterInsert->DataThis()->t._sid = sidChunk;
            }
            else
            {
                if( sidChunk == sidMerge )
                {
                    sidChunk = sidDefault;
                }

                // No merging - we actually have to create a new text pos
                ptpLeft = NewTextPos(cchChunk, sidChunk, lTextIDCurr);
                if(!ptpLeft)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                hr = THR(Insert(ptpLeft, &tpg));
                if(hr)
                    goto Cleanup;

                Assert(tpg.AttachedTreePos() == ptpAfterInsert);
                Assert(tpg.AdjacentTreePos( TPG_LEFT ) == ptpLeft);
            }
        }

        pchStart  = pchCurr;
        sidLast = sidChunk;
        sidHint = sidCurr;
    }

    Assert( cch == pchCurr - pch );
    Assert( cch == ptpAfterInsert->GetCp() + ichAfterInsert - cpStart );

    //
    // Now actually stuff the characters into the story
    //

    CTxtPtr( this, cpStart).InsertRange( cch, pch );

    //
    // Send the notification
    //
    Notify( & nf );

    Undo.CreateAndSubmit();

    if( HasLogManager() && GetLogManager()->IsAnyoneListening() )
    {
        IGNORE_HR( GetLogManager()->InsertText( cpStart, cch, pch ) );
    }

    Assert( IsNodeValid() );

Cleanup:

    RRETURN(hr);
}

DeclareTag(tagTreePosNoIsNodeValid,"TreePoslist","Don't Validate Tree (in nodal sense)");

#if DBG==1
// Verify that the runs match the state of the tree
BOOL
CMarkup::IsNodeValid()
{
    BOOL        fValid = FALSE;
    CTreePos *  ptpCurr, *ptpStored;
    CTreeNode * pNodeCurr = NULL, *pNodeStored;
    CStackPtrAry<CTreeNode*, 8> aryNodes(Mt(Mem));
    CStackPtrAry<CTreePos*, 8> aryTreePosOverlap(Mt(Mem));
    CStackPtrAry<LONG_PTR, 8> aryTextIDSeen(Mt(Mem));
    long        lCurrTextID = 0;
    BOOL        fAddingOverlap = TRUE;
    CTxtPtr     tp( this, 0 );

    if (IsTagEnabled( tagTreePosNoIsNodeValid ))
        return TRUE;

    ptpCurr = FirstTreePos();

    while(ptpCurr)
    {
        if(ptpCurr->IsText() || ptpCurr->IsPointer())
        {
            if(!fAddingOverlap)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - Text/Pointer pos inside inclusion"));
                goto Error;
            }

            if(aryTreePosOverlap.Size())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - Text/Pointer pos inside inclusion"));
                goto Error;
            }


            if(aryNodes.Size() == 0)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - Text/Pointer pos outside of all nodes"));
                goto Error;
            }

            if(ptpCurr->IsText())
            {
                tp.AdvanceCp( ptpCurr->Cch() );

                if( ptpCurr->TextID() != lCurrTextID )
                {
                    lCurrTextID = ptpCurr->TextID();
                    if( lCurrTextID != 0 )
                    {
                        if( aryTextIDSeen.Find( ptpCurr->TextID() ) != -1 )
                        {
                            TraceTag((tagError, "CMarkup::IsNodeValid - non contiguous TextID"));
                            goto Error;
                        }

                        aryTextIDSeen.Append( lCurrTextID );
                    }
                }

            }

            goto NextLoop;
        }

        if(!ptpCurr->IsNode())
        {
            TraceTag((tagError, "CMarkup::IsNodeValid - CTreePos that isn't Text, Pointer or Node"));
            goto Error;
        }

        lCurrTextID = 0;

        if( ptpCurr->IsEdgeScope() && tp.GetChar() != WCH_NODE )
        {
            TraceTag((tagError, "CMarkup::IsNodeValid - NodePos without WCH_NODE"));
            goto Error;
        }

        if( ptpCurr->IsEdgeScope() )
            tp.AdvanceCp(1);

        if(ptpCurr->IsBeginNode())
        {
            if(ptpCurr->Branch()->IsDead())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - dead node in tree"));
                goto Error;
            }

            if( ptpCurr->Branch()->Parent() != pNodeCurr )
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - invalid parent chain"));
                goto Error;
            }
        }


        if(ptpCurr->IsBeginNode() && ptpCurr->IsEdgeScope())
        {
            if(aryTreePosOverlap.Size())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - BeginEdge Node pos inside of inclusion"));
                goto Error;
            }

            pNodeCurr = ptpCurr->Branch();

            Assert(pNodeCurr);
            aryNodes.Append(pNodeCurr);

            if(pNodeCurr->Element()->__pNodeFirstBranch != pNodeCurr)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - wrong first branch pointer"));
                goto Error;
            }

            if(!pNodeCurr->Element()->IsInMarkup())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - element not marked as in markup"));
                goto Error;
            }

        }
        else if(ptpCurr->IsBeginNode())
        {
            Assert(!ptpCurr->IsEdgeScope());

            if(aryTreePosOverlap.Size() == 0)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - BeginNonEdge Node pos without corresponding end"));
                goto Error;
            }

            if(fAddingOverlap)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - Empty inclusion, non optimal tree"));
                goto Error;
            }

            fAddingOverlap = FALSE;

            ptpStored = aryTreePosOverlap[aryTreePosOverlap.Size()-1];
            aryTreePosOverlap.Delete(aryTreePosOverlap.Size()-1);

            if(aryTreePosOverlap.Size() == 0)
                fAddingOverlap = TRUE;

            if(ptpStored->Branch()->Element() != ptpCurr->Branch()->Element())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - Unmatched/Unbalanced node pos' inside of inclusion"));
                goto Error;
            }

            Assert(ptpCurr->Branch());
            aryNodes.Append(ptpCurr->Branch());

            pNodeCurr = ptpCurr->Branch();
        }
        else if(ptpCurr->IsEdgeScope())
        {
            Assert(ptpCurr->IsEndNode());

            if(!fAddingOverlap)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - EndEdge Node pos in wrong place in inclusion"));
                goto Error;
            }

            if(!aryNodes.Size())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - EndEdge Node pos without corresponding begin"));
                goto Error;
            }


            pNodeStored = aryNodes[aryNodes.Size()-1];
            aryNodes.Delete(aryNodes.Size()-1);

            pNodeCurr = ptpCurr->Branch();

            if(pNodeStored != pNodeCurr)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - EndEdge Node pos does not match begin"));
                goto Error;
            }

            if( aryNodes.Size() )
                pNodeCurr = aryNodes[aryNodes.Size()-1];

            if(aryTreePosOverlap.Size())
                fAddingOverlap = FALSE;
        }
        else
        {
            Assert(ptpCurr->IsEndNode() && !ptpCurr->IsEdgeScope());

            if(!fAddingOverlap)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - EndNonEdge Node pos in wrong place in inclusion"));
                goto Error;
            }


            pNodeStored = aryNodes[aryNodes.Size()-1];
            aryNodes.Delete(aryNodes.Size()-1);

            pNodeCurr = ptpCurr->Branch();

            if(pNodeStored != pNodeCurr)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - EndNonEdge Node pos does not match begin"));
                goto Error;
            }

            if( aryNodes.Size() )
                pNodeCurr = aryNodes[aryNodes.Size()-1];

            aryTreePosOverlap.Append(ptpCurr);
        }

NextLoop:
        ptpCurr = ptpCurr->NextTreePos();
    }

    if( !AreChangesValid() )
    {
        TraceTag((tagError, "CMarkup::IsNodeValid - Changes out of sync with markup"));
        goto Error;
    }

    if(aryNodes.Size() == 0 && aryTreePosOverlap.Size() == 0)
    {
        fValid = TRUE;
    }
    else
    {
        TraceTag((tagError, "CMarkup::IsNodeValid - unclosed nodes in CTreePosList"));
    }

Error:
    return fValid;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\doc2.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_EPARA_HXX_
#define X_EPARA_HXX_
#include "epara.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif


#pragma warning(disable:4706) /* assignment within conditional expression */

//+------------------------------------------------------------------------
//
//  Memeber:    GetRunOwnerBranch
//
//  Synopsis:   Locates the highest CSite which owns runs but also
//              occurs beneath pSitecontext
//
//  Arguments:  brElement    - The node from which to begin searching
//              pSiteContext - The context of the owner; that is,
//                             when not NULL, return the highest run
//                             owner in the tree beneath the passed
//                             site. Passing NULL returns the lowest
//                             site in the tree which owns the run
//
//  Returns:    branch which owns the passed iRun or the passed brElement
//              if pSiteContext is the only owner in the chain
//
//-------------------------------------------------------------------------

CTreeNode *
CMarkup::GetRunOwnerBranch(
    CTreeNode * pNode,
    CLayout *   pLayoutContext )
{
    CTreeNode * pNodeLayoutOwnerBranch;
    CTreeNode * pNodeLayoutBranch;
    CElement  * pElementLytCtx = pLayoutContext ? pLayoutContext->ElementOwner() : NULL;

    Assert( pNode );
    Assert( pNode->GetUpdatedNearestLayout(pLayoutContext->LayoutContext()) );
    Assert( !pElementLytCtx || pElementLytCtx->IsRunOwner() );
    
    pNodeLayoutBranch      = pNode->GetUpdatedNearestLayoutNode();
    pNodeLayoutOwnerBranch = NULL;

    do
    {
        CLayout * pLayout;
        
        // set this to the new branch every step
        
        pLayout = pNodeLayoutBranch->GetUpdatedLayout( pLayoutContext->LayoutContext() );

        // if we hit the context get out
        
        if (SameScope( pNodeLayoutBranch, pElementLytCtx ))
        {
            // if we don't have an owner yet the context
            // branch is returned

            if(!pNodeLayoutOwnerBranch)
                pNodeLayoutOwnerBranch = pNodeLayoutBranch;

            break;
        }

        if (pNodeLayoutBranch->Element()->IsRunOwner())
        {
            pNodeLayoutOwnerBranch = pNodeLayoutBranch;

            if (!pElementLytCtx)
                break;
        }

        pNodeLayoutBranch = pNodeLayoutBranch->GetUpdatedParentLayoutNode();
    }
    while ( pNodeLayoutBranch );

#if DBG == 1
    if (pNodeLayoutBranch)
    {
        Assert( pNodeLayoutOwnerBranch );
        Assert( pNodeLayoutOwnerBranch->Element()->IsRunOwner() );
    }
#endif

    return (pNodeLayoutBranch
                ? pNodeLayoutOwnerBranch
                : NULL);
}

//+----------------------------------------------------------------------------
//
//  Member:     ClearRunCaches
//
//  Synopsis:   This method invalidates cached information associated with a
//              range of runs.
//
//-----------------------------------------------------------------------------

//
// This function is not optimized at all.  It just runs around
// and does the same thing as the function above
//

HRESULT
CMarkup::ClearCaches ( CTreePos * ptpStart, CTreePos * ptpFinish )
{
    CTreePos * ptpCurr, *ptpAfterFinish = ptpFinish->NextTreePos();

    for(ptpCurr = ptpStart;
        ptpCurr != ptpAfterFinish;
        ptpCurr = ptpCurr->NextTreePos())
    {
        if(ptpCurr->IsBeginNode())
        {
            ptpCurr->Branch()->VoidCachedInfo();

            if (ptpCurr->IsEdgeScope())
            {
                CElement * pElementCur = ptpCurr->Branch()->Element();

                // Clear caches on the slave
                if (pElementCur->HasSlavePtr())
                {
                    CTreePos    *ptpStartSlave, *ptpFinishSlave;
                    CElement    *pElementSlave = pElementCur->GetSlavePtr();
                    
                    Assert(pElementSlave->IsInMarkup());
                    pElementSlave->GetTreeExtent(&ptpStartSlave, &ptpFinishSlave);
                    pElementSlave->GetMarkup()->ClearCaches(ptpStartSlave, ptpFinishSlave);
                }
            }
        }
    }

    return S_OK;
}

HRESULT
CMarkup::ClearRunCaches (DWORD dwFlags, CElement *pElement)
{
    CTreePos *  ptpStart            = NULL;
    CTreePos *  ptpEnd;
    BOOL        fClearAllFormats    = dwFlags & ELEMCHNG_CLEARCACHES;
    BOOL        fSettingViewLink    = dwFlags & ELEMCHNG_SETTINGVIEWLINK;
    BOOL        fEnteringView       = dwFlags & ELEMCHNG_ENTERINGVIEW;

    Assert(pElement);
    pElement->GetTreeExtent( & ptpStart, & ptpEnd );

    if (fSettingViewLink)
    {
        // Clear this bit since we don't want to propagate it.
        dwFlags &= ~ELEMCHNG_SETTINGVIEWLINK;
    }

    if (ptpStart)
    {
        CTreePos *ptpAfterFinish = ptpEnd->NextTreePos();

        for( ; ptpStart != ptpAfterFinish; ptpStart = ptpStart->NextTreePos())
        {
            if(ptpStart->IsBeginNode())
            {
                CTreeNode * pNodeCur     = ptpStart->Branch();
                CElement  * pElementCur  = pNodeCur->Element();
                BOOL        fNotifyFormatChange = FALSE;

                if (fEnteringView)
                {
                    CNotification nf;

                    nf.ElementEnterview1(pElementCur );
                    pElementCur->Notify(&nf);
                }
                if(fClearAllFormats)
                {
                    // clear the formats on the node
                    pNodeCur->VoidCachedInfo();
                    fNotifyFormatChange = TRUE;
                }
                else if (pElement == pElementCur || pElementCur->_fInheritFF)
                {
                    pNodeCur->VoidFancyFormat();
                    fNotifyFormatChange = pElement == pElementCur;
                }


                // if the node comming into scope is a new element
                // notify the element of a format cache change.
                if (fNotifyFormatChange && ptpStart->IsEdgeScope())
                {
                    if (pElementCur->CurrentlyHasAnyLayout())
                    {
                        pElementCur->GetLayoutInfo()->OnFormatsChange(dwFlags);
                    }

                    // Clear caches on the slave
                    if (    pElementCur->HasSlavePtr()
                        // (olego) but don't let go down into layoutRects -- 
                        // this will crash our non-incremental calc of layoutRects. (IE6 14804)
                        &&  !pElementCur->IsLinkedContentElement()  )
                    {
                        CElement * pElementSlave = pElementCur->GetSlavePtr();

                        if (pElementSlave->IsInMarkup())
                        {
                            DWORD   dwFlagsNew  = dwFlags;

                            if (fSettingViewLink && pElementCur == pElement)
                            {
                                dwFlagsNew |= ELEMCHNG_ENTERINGVIEW;
                            }
                            pElementSlave->GetMarkup()->ClearRunCaches(dwFlagsNew, pElementSlave);
                        }
                    }
                }
            }
        }
    }
    else if (pElement->GetFirstBranch())
    {
        // this could happen, when element's are temporarily parented to the
        // rootsite.
        pElement->GetFirstBranch()->VoidCachedInfo();
    }
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     RunsAffected
//
//  Synopsis:   Adds a change event to the CTextChanges object which
//              describes the fact that the chars between two runs have
//              been affected (their tree context changed).
//
//-------------------------------------------------------------------------


HRESULT
CMarkup::RangeAffected ( CTreePos *ptpLeft, CTreePos *ptpRight )
{
    HRESULT         hr;
    CNotification   nf;
    long            cp, cch;
    CTreeNode *     pNodeNotify = NULL;
    CTreePos *      ptpStart = ptpLeft, *ptpAfterLast;

    // clear all of the caches
    hr = THR( ClearCaches( ptpLeft, ptpRight ) );
    if (hr)
        goto Cleanup;

    Assert( ptpLeft && ptpRight );
    ptpAfterLast = ptpRight->NextTreePos();

    // Send the CharsResize notification
    cp  = ptpStart->GetCp();
    cch = 0;

    Assert( cp >= 0 );

    // Note: notifications for the WCH_NODE characters go
    // to intersting places.  For WCH_NODE characters inside
    // of an inclusion, the notifations go to nodes at the
    // bottom of the inclusion.  Also, for edges, notifications
    // go to the parent of the element, not the element itself.
    // This way, noscope elements to not get any notifications
    // in this loop.

    while( ptpStart != ptpAfterLast )
    {
        if( ptpStart->IsNode() )
        {
            // if we are entering an inclusion
            // then remember the first node as the
            // one to send the left half of 
            // the notification to
            if(     ! pNodeNotify 
                &&  ptpStart->IsEndNode() 
                &&  ! ptpStart->IsEdgeScope() )
            {
                pNodeNotify = ptpStart->Branch();
            }

            if( ptpStart->IsBeginElementScope() )
            {
                cch++;
            }

            // send a notification if we hit the edge
            // of a layout
            if(     cch 
                &&  ptpStart->IsEdgeScope() 
                &&  ptpStart->Branch()->ShouldHaveLayout() )
            {
/*
        (dmitryt) APPHACK for ExcelXP Web data import dialog (IE 6 35827)
        this piece of code should look like this:
    
                if( ! pNodeNotify )
                    pNodeNotify = ptpStart->Branch();

                //no assert neccessary. Assert( !pNodeNotify->Element()->IsNoScope() || g_fInExcelXP);

        ... but we don't have enough testing time now at the end of IE 6.0 to do generic fix.
        TODO: do this for IE6.1.
*/

                extern BOOL g_fInExcelXP;


                if( ! pNodeNotify )
                    pNodeNotify = ptpStart->IsBeginNode() && !g_fInExcelXP
                        ? ptpStart->Branch()->Parent()
                        : ptpStart->Branch();

                Assert( !pNodeNotify->Element()->IsNoScope() || g_fInExcelXP);

// end of APPHACK for ExcelXP

                nf.CharsResize( cp, cch, pNodeNotify );
                //(dmitryt) set NFLAGS_FORCE to ensure recalc of no-scope layouts (IE5 bug 112722)
                // this flag will set CFlowLayout::_fDTRForceLayout which tells us "force fill recalc
                // of any layout that happen to be in a dirty text range"
                nf.SetFlag(NFLAGS_FORCE);   
                Notify( nf );

                cp += cch;
                cch = 0;
            }
            
            // If we hit an edge, clear pNodeNotify.  Either we sent
            // a notification or we didn't. Either way, we are done
            // with this inclusion so we don't have to remember pNodeNotify
            if( ptpStart->IsEdgeScope() )
            {
                pNodeNotify = NULL;
            }

            if( ptpStart->IsEndElementScope() )
                cch++;
        }
        else if( ptpStart->IsText() )
        {
            cch += ptpStart->Cch();
        }

        ptpStart = ptpStart->NextTreePos();
    }

    // Finish off any notification left over
    if( cch )
    {
        if( !pNodeNotify )
        {
            CTreePosGap tpg( ptpStart, TPG_LEFT );
            pNodeNotify = tpg.Branch();
        }

        nf.CharsResize( cp, cch, pNodeNotify );
        Notify( nf );
    }

Cleanup:
    RRETURN( hr );
}

#if 0
This routine is not currently needed and may not even be correct!
//+------------------------------------------------------------------------
//
//  Member:     EnsureSidAfterCharsInserted
//
//  Arguments:  pNodeNotify     - the node to send changes to
//              ptpText         - the text pos to examine
//              ich             - the character to start with
//              cch             - the count of characters added
//
//  Synopsis:   Runs through the chracters added and splits off
//              new runs for new script IDs as needed
//
//  Returns:    S_OK if successful
//
//-------------------------------------------------------------------------
HRESULT CMarkup::EnsureSidAfterCharsInserted(
    CTreeNode * pNodeNotify,
    CTreePos *  ptpText,
    long        ichStart,
    long        cch )
{
    Assert( ptpText && ptpText->IsText() );
    Assert( cch > 0 && cch <= ptpText->Cch() );
    Assert( ichStart < ptpText->Cch() );

    HRESULT         hr = S_OK;
    CMarkupUndo     mu( this );
    CTxtPtr         tp( this, ptpText->GetCp() + ichStart );
    long            ichCurr = ichStart;
    long            ichLastAdded = ichStart + cch - 1;
    long            ichLastInRun = ptpText->Cch() - 1;
    CTreePos *      ptpCurr = ptpText;
    long            sidCurr = ptpText->Sid();
    long            sidOrig = sidCurr;
    TCHAR           chCurr = tp.GetChar();
    BOOL            fFirst = TRUE;

    //
    // Iterate through all of the characters added
    //

    for( ; ichCurr <= ichLastAdded; ichCurr++ )
    {
        long    sidNew;

        if( ! fFirst )
            chCurr = tp.NextChar();

        fFirst = FALSE;

        sidNew = ScriptIDFromCh( chCurr );

        // NOTE (t-johnh): This can be a LOT smarter about when
        // to split, as right now, we get excessive fragmentation.
        // This should be using AreDifferentSids, which currently
        // sits in doc.cxx to see when different sids can coexist.
        // HOWEVER, it also needs to be smarter about sidCurr - 
        // sidCurr should represent the sid of the combination of
        // all characters previous in the text pos.

        sidNew = FoldScriptIDs( sidCurr, sidNew );

        if( sidCurr != sidNew )
        {
            if( ichCurr )
            {
                //
                // Split the run at this ich
                //

                mu.TextPosSplit( ptpCurr );

                hr = THR( Split( ptpCurr, ichCurr, sidNew ) );
                if (hr)
                    goto Cleanup;

                Doc()->InvalidateTreeCache();

                // I'm turning this off as it can break linebreaking.
#if NEVER
                // NOTE: this is dangerous as it plays with the run
                // before the run being examined.  The calling code must
                // be aware that the run that it passed in may be invalid
                // after the call! -- Do we really want to do this merging?

                // If this is the fist time we've split, and
                // the new characters start at the beginning of the run, 
                // try to join the left run (with the new characters) with
                // the previous run
                if( nRunsAdded == 0 && ichStart == 0)
                {
                    CTreePos *ptpPrev = ptpCurr->PreviousTreePos();

                    if( ptpPrev->IsText() && ptpPrev->Sid() == ptpCurr->Sid() )
                    {
                        Assert( long(tp.GetCp()) - ichCurr == ptpPrev->GetCp() + ptpPrev->Cch() );
                        nf.RunsJoined( tp.GetCp() - ichCurr, ptpPrev->Index(), ptpPrev->Cch(), pNodeNotify );
                        mu.TextPosJoined( ptpPrev );

                        hr = THR( Join( ptpPrev ) );
                        if (hr)
                            goto Cleanup;

                        nRunsAdded --;

                        Doc()->InvalidateTreeCache();

                        Notify( nf );

                        ptpCurr = ptpPrev;
                    }

                }
#endif

                // We are now examining the added pos
                ptpCurr = ptpCurr->NextTreePos();
                Assert( ptpCurr && ptpCurr->IsText() );

                // Update all of ich's
                ichLastAdded -= ichCurr;
                ichLastInRun -= ichCurr;
                ichCurr = 0;

            }
            else
            {
                // Set the sid for the current run since
                // the run wasn't split, this didn't get
                // set that way.
                mu.TextPosSidChanged( ptpCurr );
                ptpCurr->DataThis()->_sid = sidNew;
            }
        }
        
        //
        // Set up for the next loop
        //

        sidCurr = sidNew;
    }

    //
    // The characters were inserted into the middle
    // of the run.  Split after those characters and give
    // the run the original sid.
    // NOTE: we may want to reexamine this later as if everything
    // left is neutral, we don't want to split again.
    //
    Assert( sidCurr == ptpCurr->Sid() );
    if( sidOrig != sidCurr && ichCurr && ichCurr <= ichLastInRun )
    {
        // Advance to catch up with the ich
        tp.AdvanceCp(1);

        mu.TextPosSplit( ptpCurr );

        hr = THR( Split( ptpCurr, ichCurr, sidOrig ) );
        if (hr)
            goto Cleanup;

        Doc()->InvalidateTreeCache();

#if NEVER
        // Same comment as above
        if( nRunsAdded == 0 && ichStart == 0)
        {
            CTreePos *ptpPrev = ptpCurr->PreviousTreePos();

            if( ptpPrev->IsText() && ptpPrev->Sid() == ptpCurr->Sid() )
            {
                Assert( long(tp.GetCp()) - ichCurr == ptpPrev->GetCp() + ptpPrev->Cch() );
                nf.RunsJoined( tp.GetCp() - ichCurr, ptpPrev->Index(), ptpPrev->Cch(), pNodeNotify );
                mu.TextPosJoined( ptpPrev );

                hr = THR( Join( ptpPrev ) );
                if (hr)
                    goto Cleanup;

                nRunsAdded --;

                Doc()->InvalidateTreeCache();

                Notify( nf );

                ptpCurr = ptpPrev;
            }
        }
#endif
    }

Cleanup:
    RRETURN(hr);
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     SetTextID
//
//  Arguments:  ptpgStart   - where to start setting
//              ptpgEnd     - where to stop setting
//
//  Synopsis:   Gives a unique textID to every chunk of text in the given
//              range.
//
//  Returns:    S_OK if successful
//
//-------------------------------------------------------------------------
HRESULT 
CMarkup::SetTextID(
    CTreePosGap *   ptpgStart,
    CTreePosGap *   ptpgEnd,
    long *plNewTextID )
{
    HRESULT hr = S_OK;
    long lTxtID;

    Assert( ! HasUnembeddedPointers() );

    EnsureTotalOrder( ptpgStart, ptpgEnd );

    Assert( ptpgStart && ptpgStart->IsPositioned() && ptpgStart->GetAttachedMarkup() == this );
    Assert( ptpgEnd && ptpgEnd->IsPositioned() && ptpgEnd->GetAttachedMarkup() == this );

    CTreePos *  ptpFirst, * ptpCurr, *ptpStop;
    CDoc *      pDoc = Doc();

    if ( !plNewTextID )
        plNewTextID = &lTxtID;

    *plNewTextID = 0;

    ptpFirst = ptpgStart->AdjacentTreePos( TPG_LEFT );
    ptpCurr = ptpFirst;
    ptpStop = ptpgEnd->AdjacentTreePos( TPG_RIGHT );

    ptpgStart->UnPosition();
    ptpgEnd->UnPosition();

    SplitTextID( ptpCurr, ptpStop );

    ptpCurr = ptpCurr->NextTreePos();

    while( ptpCurr != ptpStop )
    {
        Assert( ptpCurr );

        if( ptpCurr->IsNode() )
        {
            *plNewTextID = 0;
        }

        if( ptpCurr->IsText() )
        {
            if( *plNewTextID == 0 )
            {
                *plNewTextID = ++(pDoc->_lLastTextID);
            }

            hr = THR( SetTextPosID( &ptpCurr, *plNewTextID ) );
            if (hr)
                goto Cleanup;

        }

        ptpCurr = ptpCurr->NextTreePos();
    }

    if( !*plNewTextID )
    {
        CTreePos * ptpNew;
        CTreePosGap tpgInsert( ptpCurr, TPG_RIGHT );

        ptpNew = NewTextPos(0, sidDefault, *plNewTextID = ++(pDoc->_lLastTextID));

        hr = THR(Insert(ptpNew, &tpgInsert));
        if(hr)
            goto Cleanup;
    }

    Verify( ! ptpgStart->MoveTo( ptpFirst, TPG_RIGHT ) );
    Verify( ! ptpgEnd->MoveTo( ptpStop, TPG_LEFT ) );

Cleanup:
    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Member:     GetTextID
//
//  Arguments:  ptpg        - where
//
//  Synopsis:   Finds the TextID for any text to the right of the gap
//              passed in.
//
//  Returns:    -1 if no text is to the right
//              0  if text to right has no ID assigned
//              otherwise, the textID to the right
//
//-------------------------------------------------------------------------
long 
CMarkup::GetTextID( 
    CTreePosGap * ptpg )
{
    Assert( ptpg && ptpg->IsPositioned() && ptpg->GetAttachedMarkup() == this );

    CTreePos * ptp = ptpg->AdjacentTreePos( TPG_RIGHT );

    while( ! ptp->IsNode() )
    {
        if( ptp->IsText() )
            return ptp->TextID();

        ptp = ptp->NextTreePos();
        Assert( ptp );
    }

    return -1;
}

//+------------------------------------------------------------------------
//
//  Member:     FindTextID
//
//  Arguments:  lTextID     - IN the id to scan for
//              ptpgStart   - IN/OUT where to start scanning
//              ptpgEnd     - OUT the end of the extent
//
//  Synopsis:   Find the extent of lTextID.  Start searching at ptpgStart.
//              Set ptpgStart to the beginning and ptpgEnd to the end of
//              the extent
//
//  Returns:    S_OK if text ID found
//              S_FALSE if text ID not found
//              error otherwise
//
//-------------------------------------------------------------------------
HRESULT 
CMarkup::FindTextID(
    long            lTextID,
    CTreePosGap *   ptpgStart,
    CTreePosGap *   ptpgEnd )
{
    Assert( ptpgStart && ptpgStart->IsPositioned() && ptpgStart->GetAttachedMarkup() == this );
    Assert( ptpgEnd );

    CTreePos * ptpLeft, *ptpRight, *ptpFound = NULL;

    ptpLeft = ptpgStart->AdjacentTreePos( TPG_LEFT );
    ptpRight = ptpgStart->AdjacentTreePos( TPG_RIGHT );

    //
    // Start from ptpgStart and search both directions at the same time.
    //

    while( ptpLeft || ptpRight )
    {
        if( ptpLeft )
        {
            if( ptpLeft->IsText() && ptpLeft->TextID() == lTextID )
            {
                ptpRight = ptpLeft;

                // Starting at ptpLeft, loop to the left
                // looking for all of consecutive text poses 
                // with TextID of lTextID
                do
                {
                    if( ptpLeft->IsText() )
                    {
                        if( ptpLeft->TextID() == lTextID )
                        {
                            ptpFound = ptpLeft;
                        }
                        else
                        {
                            break;
                        }
                    }
                    ptpLeft = ptpLeft->PreviousTreePos();
                }
                while( !ptpLeft->IsNode() );

                ptpLeft = ptpFound;

                break;
            }

            ptpLeft = ptpLeft->PreviousTreePos();
        }

        if( ptpRight )
        {
            if( ptpRight->IsText() && ptpRight->TextID() == lTextID )
            {
                ptpLeft = ptpRight;

                // Starting at ptpRight, loop to the right
                // looking for all of consecutive text poses 
                // with TextID of lTextID
                do
                {
                    if( ptpRight->IsText() )
                    {
                        if( ptpRight->TextID() == lTextID )
                        {
                            ptpFound = ptpRight;
                        }
                        else
                        {
                            break;
                        }
                    }
                    ptpRight = ptpRight->NextTreePos();
                }
                while( !ptpRight->IsNode() );

                ptpRight = ptpFound;

                break;
            }
            ptpRight = ptpRight->NextTreePos();
        }
    }

    if( ptpFound )
    {
        Verify( !ptpgStart->MoveTo( ptpLeft, TPG_LEFT ) );
        Verify( !ptpgEnd->MoveTo( ptpRight, TPG_RIGHT ) );

        return S_OK;
    }

    return S_FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     SplitTextID
//
//  Arguments:  ptpLeft     - The left side of the split
//              ptpRight    - The right side to split
//
//  Synopsis:   If text to the left of ptpLeft has the same ID
//              as the text to the right of ptpRight, give the
//              fragment after ptpRight a new ID
//
//-------------------------------------------------------------------------
void
CMarkup::SplitTextID(
    CTreePos *   ptpLeft,
    CTreePos *   ptpRight )
{
    Assert( ptpLeft && ptpRight );

    Assert( ! HasUnembeddedPointers() );

    //
    // Find a text pos to the left if any
    //
    
    while ( ptpLeft )
    {
        if( ptpLeft->IsNode() )
        {
            ptpLeft = NULL;
            break;
        }

        if( ptpLeft->IsText() )
        {
            break;
        }

        ptpLeft = ptpLeft->PreviousTreePos();
    }

    //
    // Find one to the right
    //
    
    while ( ptpRight )
    {
        if( ptpRight->IsNode() )
        {
            ptpRight = NULL;
            break;
        }

        if( ptpRight->IsText() )
        {
            break;
        }

        ptpRight = ptpRight->NextTreePos();
    }

    //
    // If we have one to the left and right and they
    // both have the same ID (that isn't 0) we want
    // to give the fragment to the right a new ID.
    //
    
    if(     ptpLeft 
        &&  ptpRight 
        &&  ptpRight->TextID()
        &&  ptpLeft->TextID() == ptpRight->TextID() )
    {
        long lCurrTextID = ptpRight->TextID();
        long lNewTextID = ++(Doc()->_lLastTextID);

        while( ptpRight && !ptpRight->IsNode() )
        {
            if( ptpRight->IsText() )
            {
                if( ptpRight->TextID() == lCurrTextID )
                {
                    WHEN_DBG( CTreePos * ptpOld = ptpRight );
                    Verify( ! SetTextPosID( &ptpRight, lNewTextID ) );
                    Assert( ptpOld == ptpRight );
                }
                else
                {
                    break;
                }
            }

            ptpRight = ptpRight->NextTreePos();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\ebody.cxx ===
//+---------------------------------------------------------------------
//
//   File:      ebody.cxx
//
//  Contents:   Body element class
//
//  Classes:    CBodyElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_DIV_HXX_
#define X_DIV_HXX_
#include "div.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif


#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_BODYLYT_HXX_
#define X_BODYLYT_HXX_
#include "bodylyt.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include <htiface.h>
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#define _cxx_
#include "body.hdl"

HRESULT InitTextSubSystem();

MtDefine(CBodyElement, Elements, "CBodyElement")


#ifndef NO_PROPERTY_PAGE
const CLSID * const CBodyElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CBackgroundPropertyPage,
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1        
    NULL
};
#endif // NO_PROPERTY_PAGE

CElement::ACCELS CBodyElement::s_AccelsBodyRun    = CElement::ACCELS (&CElement::s_AccelsElementRun,    IDR_ACCELS_BODY_RUN);

const CElement::CLASSDESC CBodyElement::s_classdesc =
{
    {
        &CLSID_HTMLBody,                // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE  |
        ELEMENTDESC_BODY      |
        ELEMENTDESC_NOTIFYENDPARSE,     // _dwFlags
        &IID_IHTMLBodyElement,          // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBodyElement,   // TearOff
    &CBodyElement::s_AccelsBodyRun          // _pAccelsRun
};

const long s_adispCommonProps[CBodyElement::NUM_COMMON_PROPS][2] =
{
    { DISPID_CDocument_bgColor,    DISPID_CBodyElement_bgColor},
    { DISPID_CDocument_linkColor,  DISPID_CBodyElement_link},
    { DISPID_CDocument_alinkColor, DISPID_CBodyElement_aLink},
    { DISPID_CDocument_vlinkColor, DISPID_CBodyElement_vLink},
    { DISPID_CDocument_fgColor,    DISPID_CBodyElement_text}
};

//+------------------------------------------------------------------------
//
//  Member:     CBodyElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CBodyElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_TEAROFF(this, IHTMLBodyElement2, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

HRESULT
CBodyElement::CreateElement(CHtmTag *pht,
                            CDoc *pDoc, CElement **ppElement)
{
    HRESULT hr;

    Assert(pht->IsBegin(ETAG_BODY));
    Assert(ppElement);

    hr = InitTextSubSystem();
    if(hr)
        goto Cleanup;

    *ppElement = new CBodyElement(pDoc);

    hr = (*ppElement) ? S_OK : E_OUTOFMEMORY;

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CBodyElement::CBodyElement
//
//---------------------------------------------------------------

CBodyElement::CBodyElement ( CDoc * pDoc )
  : CTxtSite ( ETAG_BODY, pDoc ) 
{
    _fSynthetic     = FALSE;
    _fInheritFF     = TRUE;     // Default for back compat, not CSS1Strict.
}

//+---------------------------------------------------------------
//
//  Member:     CBodyElement::Init2
//
//  Synopsis:   Final initializer
//
//---------------------------------------------------------------


HRESULT
CBodyElement::Init2(CInit2Context * pContext)
{
    HRESULT         hr;
    int             i;

    // before we do anything copy potentially initialized values
    // from the document's aa

    if (    pContext 
        &&  pContext->_pTargetMarkup 
        &&  pContext->_pTargetMarkup->HasDocument())
    {
        CDocument *     pDocument = pContext->_pTargetMarkup->Document();

        CAttrArray *pAA = *(pDocument->GetAttrArray());
        if (pAA)
        {
            CAttrValue * pAV = NULL;

            for (i = 0; i < NUM_COMMON_PROPS; i++)
            {
                pAV = pAA->Find(s_adispCommonProps[i][0]);
                if (pAV)
                {
                    // Implicit assumption that we're always dealing with I4's
                    hr = THR(AddSimple ( s_adispCommonProps[i][1], pAV->GetLong(), pAV->GetAAType() ));
                }
            }
        }
    }

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Notify
//
//-------------------------------------------------------------------------

void
CBodyElement::Notify ( CNotification * pNF )
{
    CDoc *  pDoc = Doc();

    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYTABBABLE:
        {
            CQueryFocus *   pQueryFocus = (CQueryFocus *)pNF->DataAsPtr();
            BOOL            fInFrame    = FALSE;

            if (IsInMarkup())
            {
                CElement * pElemMaster = GetMarkup()->Root()->GetMasterPtr();

                if (pElemMaster)
                {
                    switch (pElemMaster->Tag())
                    {
                    case ETAG_FRAME:
                    case ETAG_IFRAME:
                        fInFrame = TRUE;
                        break;
                    }
                }
            }
            if (fInFrame || DocIsDeskTopItem(pDoc))
            {
                pQueryFocus->_fRetVal = TRUE;
            }
            else
            {
                pQueryFocus->_fRetVal = FALSE;
            }
        }
        break;

    case NTYPE_ELEMENT_SETFOCUS:
        {
            CSetFocus * pSetFocus       = (CSetFocus *)pNF->DataAsPtr();
            CMessage *  pMessage        = pSetFocus->_pMessage;

            // We want to turn on the focus rect only during certain
            // conditions:
            // 1) we are the current site
            // 2) we got here due to a tab/frametab key
            // 3) There is no selection or 0 len selection ( a Caret ! )
            Layout( GUL_USEFIRSTLAYOUT )->RequestFocusRect(
                    pDoc->_pElemCurrent == this
                &&  pMessage && pMessage->message == WM_KEYDOWN
                &&  (pDoc->HasSelection() ? ( pDoc->GetSelectionType() == SELECTION_TYPE_Caret) : TRUE));
        }
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        {
            //
            // Alert the view that the top client element may have changed
            //

            pDoc->OpenView();

            Layout()->_fContentsAffectSize = FALSE;
            
            //
            // NOTE:
            //
            // Major hack code to simulate the setting of the top site
            //

            CMarkup *     pMarkup = GetMarkup();
            CElement *    pElemClient = pMarkup->GetElementClient();

            // If we are CSS1 compatible, we should *not* be inheriting formats
            // If we expect to run more in CSS1 compatible mode, we should change the default and turn the bit on instead of off.
            _fInheritFF = !pMarkup->IsHtmlLayout();

            // If the HTML element has had it's formats calc'd, it has made scrolling decisions without us.
            // We want it to be aware of its client before making scrolling decisions.  Let it redecide.
            if (pMarkup->IsHtmlLayout())
            {
                CElement * pHTML = pMarkup->GetHtmlElement();
                //this can happen to be NULL when DOM makes insertions
                if(pHTML)
                    pHTML->GetFirstBranch()->VoidFancyFormat();
            }


            // This could be NULL during DOM operations!
            if (pElemClient)
                pElemClient->ResizeElement(NFLAGS_SYNCHRONOUSONLY);

            if (pMarkup->IsPrimaryMarkup())
            {
                // Notify the view of a new possible top-most element
                SendNotification(NTYPE_VIEW_ATTACHELEMENT);

                if (!pDoc->_fCurrencySet)
                {
                    // EnterTree is not a good place to set currency, especially in
                    // design mode, because it could force a synchronous recalc by
                    // trying to set the caret. So, we delay setting the currency.
                    THR(GWPostMethodCall(pDoc,
                                         ONCALL_METHOD(CDoc,
                                                       DeferSetCurrency,
                                                       defersetcurrency),
                                         0, FALSE, "CDoc::DeferSetCurrency"));
                }
            }

            //
            // End hack
            //

            // Okay to display the document unless we have to scroll
            // at startup (have BookmarkTask)
            // TODO (dmitryt, track bug 112326) In some cases we still need change of load status here
            // because it doesn't happen in other places. RestartLoad and Refresh
            // both create a new markup, switch to it but don't request 
            // to go interactive before the very end then we loose opportunity to 
            // fire NavigateComplete2. 
            {

                BOOL fHasBookmarkTask = 
                       pMarkup->HasTransNavContext() 
                    && pMarkup->GetTransNavContext()->_pTaskLookForBookmark;

                BOOL fInRestartLoad = 
                       pMarkup->HasWindowPending() 
                    && pMarkup->GetWindowPending()->Window()->_fRestartLoad;

                BOOL fInRefresh = pMarkup->_fInRefresh;

                if (    pMarkup->HasWindowPending() 
                     && (fInRestartLoad || fInRefresh || !fHasBookmarkTask))
                {               
                    pMarkup->OnLoadStatus(LOADSTATUS_INTERACTIVE);
                }
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        {
            // Notify the view that the top element may have left
            CMarkup *pMarkup = GetMarkup();
            if (pMarkup && pMarkup->IsPrimaryMarkup())
            {
                if (!(pNF->DataAsDWORD() & EXITTREE_DESTROY))
                    SendNotification(NTYPE_VIEW_DETACHELEMENT);
            }
        }
        break;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     createTextRange
//
//-------------------------------------------------------------------------

HRESULT
CBodyElement::createTextRange( IHTMLTxtRange * * ppDisp )
{
    HRESULT hr = S_OK;

    hr = THR( EnsureInMarkup() );
    
    if (hr)
        goto Cleanup;

    hr = THR( GetMarkup()->createTextRange( ppDisp, this ) );
    
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}

//+-------------------------------------------------------------------------
//
//  Method:     ShowTooltip
//
//  Synopsis:   Displays the tooltip for the site.
//
//  Arguments:  [pt]    Mouse position in container window coordinates
//              msg     Message passed to tooltip for Processing
//
//--------------------------------------------------------------------------


HRESULT 
CBodyElement::ShowTooltip(CMessage *pmsg, POINT pt)
{
    HRESULT hr = super::ShowTooltip(pmsg, pt);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBodyElement::GetBorderInfo, public
//
//  Synopsis:   Returns information about what borders we have.
//
//----------------------------------------------------------------------------
#define WIDTH_3DBORDER 2

inline void Set3DBorderEdgeInfo(BOOL fNeedBorderEdge, int cEdge,
                CBorderInfo * pborderinfo)
{
    if (fNeedBorderEdge)
    {
        pborderinfo->abStyles[cEdge] = fmBorderStyleSunken;
        pborderinfo->aiWidths[cEdge] = WIDTH_3DBORDER;
    }
}

BOOL
ShouldCallGetFrameOptions(CDoc * pDoc, CWindow * pWindow, CMarkup * pMarkup)
{   
    Assert(pDoc);
    Assert(pMarkup);

    if (    !pDoc->_fViewLinkedInWebOC
        ||  !pDoc->_fActiveDesktop
        ||  pWindow && !pWindow->IsPrimaryWindow()
        ||  !pMarkup->_fIsActiveDesktopComponent )
    {
        return TRUE;
    }
    return FALSE;
}

DWORD
CBodyElement::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if (    IsInViewLinkBehavior( TRUE )
        ||  GetMarkup()->IsHtmlLayout() )
    {
        return super::GetBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
    }

    DWORD     dwRet = 0;
    CDoc    * pDoc = Doc();
    CMarkup * pMarkup = GetMarkup();
    CWindow * pWindow = pMarkup->Window() ? pMarkup->Window()->Window() : NULL;

    // if host says no border, then we have no border.
    // if the frame options say no border, we want no border. However (85696) in
    // design mode, if there are no borders, then there is no way to wysiwyg resize
    // and so VS/VID/et. al. want this turned off.  
    if (    ShouldCallGetFrameOptions(pDoc, pWindow, pMarkup)
        &&  (pMarkup->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0
        &&  (   (pDoc->_dwFlagsHostInfo  & DOCHOSTUIFLAG_NO3DBORDER) == 0
              || (   pDoc->_fScriptletDoc                                   // a scriptlet doc with an iframe
                  && pMarkup->Root()->HasMasterPtr()                        //    should still have a border on the
                  && pMarkup->Root()->GetMasterPtr()->Tag() == ETAG_IFRAME  //    IFRAME (100612)
            )    )
        &&  pWindow
        &&  !   (   pMarkup->IsPrintMedia()
                &&  !pWindow->_pWindowParent
                )       
        &&  !   (   (pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NO3DOUTERBORDER) != 0 
                &&  pMarkup 
                &&  pMarkup->IsPrimaryMarkup()
        )       )
    {
        // raid 41791 3D border
        // For a (nested) frameset HTML document, Trident will draw 3D border
        // for the top-level frameset (pDocRoot->_pSiteRoot->_pElemClient is
        // a CFrameSetSite), so we don't need to draw 3D border edge(s) if
        // it (they) overlaps with top-level 3D borders.
        //
        BYTE b3DBorder;

        if (!pWindow->_pWindowParent)
        {
            pWindow->_b3DBorder = NEED3DBORDER_TOP | NEED3DBORDER_LEFT
                             | NEED3DBORDER_BOTTOM | NEED3DBORDER_RIGHT;
        }
        else
            pWindow->_pWindowParent->CheckDoc3DBorder(pWindow);

        b3DBorder = pWindow->_b3DBorder;

        Set3DBorderEdgeInfo(
                (b3DBorder & NEED3DBORDER_TOP) != 0,
                SIDE_TOP,
                pborderinfo);
        Set3DBorderEdgeInfo(
                (b3DBorder & NEED3DBORDER_LEFT) != 0,
                SIDE_LEFT,
                pborderinfo);
        Set3DBorderEdgeInfo(
                (b3DBorder & NEED3DBORDER_BOTTOM) != 0,
                SIDE_BOTTOM,
                pborderinfo);
        Set3DBorderEdgeInfo(
                (b3DBorder & NEED3DBORDER_RIGHT) != 0,
                SIDE_RIGHT,
                pborderinfo);

        pborderinfo->wEdges = BF_RECT;

        // Unless we're the top, add space for the frame highlighting area
        if (pWindow->_pWindowParent)
        {
            pborderinfo->xyFlat = CFrameSetSite::iPixelFrameHighlightWidth;
            pborderinfo->aiWidths[SIDE_TOP]    += pborderinfo->xyFlat;
            pborderinfo->aiWidths[SIDE_RIGHT]  += pborderinfo->xyFlat;
            pborderinfo->aiWidths[SIDE_BOTTOM] += pborderinfo->xyFlat;
            pborderinfo->aiWidths[SIDE_LEFT]   += pborderinfo->xyFlat;
            pborderinfo->acrColors[SIDE_TOP][1]
                    = pborderinfo->acrColors[SIDE_RIGHT][1]
                    = pborderinfo->acrColors[SIDE_BOTTOM][1]
                    = pborderinfo->acrColors[SIDE_LEFT][1]
                    = (pDoc->_state < OS_UIACTIVE)
                            ? GetInheritedBackgroundColor()
                            : RGB(0,0,0); // black, for now
        }
    }

    dwRet = CElement::GetBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);

    return dwRet;
}

//+------------------------------------------------------------------------
//
//  Member:     CBodyElement::ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CBodyElement::ApplyDefaultFormat ( CFormatInfo * pCFI )
{
    HRESULT     hr          = S_OK;
    CElement *  pRoot       = GetMarkup()->Root();
    BOOL        fSlaveBody  = pRoot->HasMasterPtr();
    BOOL        fIsFrame    = FALSE;
    BOOL        fHtmlLayout = GetMarkup()->IsHtmlLayout();

    DWORD       dwWidth     = 0xffffffff;
    DWORD       dwHeight    = 0xffffffff;
    CDoc *      pDoc        = Doc();
 
    pCFI->PrepareFancyFormat();

    if (fSlaveBody)
    {
        CElement * pElement = pRoot->GetMasterPtr();

        // TODO: (lmollico, track bug 112336): should be more general
        if (    pElement->Tag() == ETAG_FRAME   
            ||  pElement->Tag() == ETAG_IFRAME)
        {
            fIsFrame = TRUE;

            dwWidth = DYNCAST(CFrameSite, pElement)->_dwWidth;
            dwHeight = DYNCAST(CFrameSite, pElement)->_dwHeight;
        }
    }

    //  If we are in a BackCompat (not strict CSS1 doctype) scenario,
    //  then the BODY controls the canvas 3D border, background, & scrollbar and
    //  relevant default formats need to be applied.
    if (!fHtmlLayout)
    {
        const CFancyFormat * pFFParent = NULL;
        CTreeNode * pNodeContext = pCFI->_pNodeContext;
        CTreeNode * pNode;
        BOOL        fGotMaster = FALSE;

        Assert(pNodeContext && SameScope(this, pNodeContext));

        //
        // Climb up the tree to find a background color, inherit an image url
        // from our parent.
        //
        for (pNode = pNodeContext->Parent(); pNode; pNode = pNode->Parent())
        {
            if (pNode->Element()->HasMasterPtr())
            {
                fGotMaster = TRUE;

                // Don't do this for frames or layout rects.
                CElement * pElemMaster = pNode->Element()->GetMasterPtr();

                if (   pElemMaster->TagType() == ETAG_GENERIC
                    && !pElemMaster->IsLinkedContentElement() )
                {
                    pNode = pElemMaster->GetFirstBranch();
                    if (!pNode)
                        break;
                }
            }
            pFFParent = pNode->GetFancyFormat();

            // Do NOT inherit the background-image from the containing doc
            if (!fGotMaster && !pCFI->_ff()._lImgCtxCookie)
                pCFI->_ff()._lImgCtxCookie = pFFParent->_lImgCtxCookie;

            if (pFFParent->_ccvBackColor.IsDefined())
                break;
        }

        if (pFFParent)
        {
            pCFI->_ff()._ccvBackColor = pFFParent->_ccvBackColor;
        }
        Assert(pCFI->_ff()._ccvBackColor.IsDefined());

        // Default BODY border.
        if (!fSlaveBody || fIsFrame)
        {
            pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
            pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);
            pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
            pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
        }    

        // (greglett) Changing this code will affect the canvas scrollbar.
        // This code is more crusty (and erratic) than you think... be careful.
        if (    !fSlaveBody
            &&  !DocIsDeskTopItem(pDoc)
            &&  !(pDoc->_dwFlagsHostInfo & (DOCHOSTUIFLAG_SCROLL_NO | DOCHOSTUIFLAG_DIALOG))
           )
        {
            switch (GetAAscroll())
            {
            case bodyScrollno:
            case bodyScrollyes:
            case bodyScrollauto:
                break;

            default:
                // Body is always horizontal.
                pCFI->_ff().SetOverflowX(styleOverflowAuto);
                pCFI->_ff().SetOverflowY(styleOverflowScroll);
                break;
            }
        }    

        if (GetAAscroll() == bodyScrollno)
        {
            pCFI->_ff().SetOverflowX(styleOverflowHidden);
            pCFI->_ff().SetOverflowY(styleOverflowHidden);
        }
    }    

    pCFI->UnprepareForDebug();

    hr = super::ApplyDefaultFormat (pCFI);
    if (hr)
        goto Cleanup;

    // Do special stuff for margins, etc.
    {
        pCFI->PrepareFancyFormat();

        // Do some of this stuff only for the main Body
        if (!fSlaveBody || fIsFrame)
        {
            CUnitValue cuvLeftMargin;
            CUnitValue cuvRightMargin;

            //
            // if the markup this body tag is on is the primary markup, then ask the container
            // for this information. Otherwise, set the values to -1. (old shdocvw default)
            //
            if (GetMarkup()->IsPrimaryMarkup())
            {
                ITargetFrame *  pTargetFrame = NULL;

                // query if the body is contained in a frame
                if (!pDoc->QueryService(IID_ITargetFrame, IID_ITargetFrame, (void **)&pTargetFrame))
                {
                    // query the frame for its margins
                    hr = THR(pTargetFrame->GetFrameMargins(&dwWidth, &dwHeight));

                    if (hr)
                    {
                        hr = S_OK;
                    }

                    pTargetFrame->Release();

                    fIsFrame = TRUE;
                }
            }

            //
            // NOTE (srinib) - for frames, if right/bottom margin is not specified and left/top
            // are specified through attributes then use left/top as default values.
            //

            //
            // If an explicit top margin is not specified, set it to the default value
            // 
            if (!pCFI->_pff->HasExplicitMargin(SIDE_TOP))
            {
                CUnitValue uv;
                if (dwHeight == 0xffffffff)
                {
                    uv.SetRawValue(s_propdescCBodyElementtopMargin.a.ulTagNotPresentDefault);
                }
                else
                {
                    uv.SetValue(long(dwHeight), CUnitValue::UNIT_PIXELS);
                }
                pCFI->_ff().SetMargin(SIDE_TOP, uv);
            }

            //
            // if an explicit bottom margin is not specified, set default bottom margin.
            //
            if (!pCFI->_pff->HasExplicitMargin(SIDE_BOTTOM))
            {
                CUnitValue uv;
                // if we are in a frame use top margin as default.
                if (fIsFrame && !pCFI->_fHasCSSTopMargin)
                {
                    uv = pCFI->_pff->GetMargin(SIDE_TOP);
                }
                else
                {
                    if (dwHeight == 0xffffffff)
                    {
                        uv.SetRawValue(s_propdescCBodyElementbottomMargin.a.ulTagNotPresentDefault);
                    }
                    else
                    {
                        uv.SetValue(long(dwHeight), CUnitValue::UNIT_PIXELS);
                    }
                }
                pCFI->_ff().SetMargin(SIDE_BOTTOM, uv);
            }

            if (!pCFI->_pff->HasExplicitMargin(SIDE_LEFT))
            {
                CUnitValue uv;
                if (dwWidth ==  0xffffffff)  // margin specified on the frame
                {
                    uv.SetRawValue(s_propdescCBodyElementleftMargin.a.ulTagNotPresentDefault);
                }
                else
                {
                    uv.SetValue(long(dwWidth), CUnitValue::UNIT_PIXELS);
                }
                pCFI->_ff().SetMargin(SIDE_LEFT, uv);
            }

            if (!pCFI->_pff->HasExplicitMargin(SIDE_RIGHT))
            {
                CUnitValue uv;
                // if we are in a frame use left margin as default.
                if (fIsFrame && !pCFI->_fHasCSSLeftMargin)
                {
                    uv = pCFI->_pff->GetMargin(SIDE_LEFT);
                }
                else
                {
                    if (dwWidth ==  0xffffffff)  // margin specified on the frame
                    {
                        uv.SetRawValue(s_propdescCBodyElementrightMargin.a.ulTagNotPresentDefault);
                    }
                    else
                    {
                        uv.SetValue(long(dwWidth), CUnitValue::UNIT_PIXELS);
                    }
                }
                pCFI->_ff().SetMargin(SIDE_RIGHT, uv);
            }


            pCFI->_ff()._fHasMargins = TRUE;
        }

        // cache percent attribute information
        // BackCompat: BODY Margin acts like padding.  Set the Percent info if necessary.
        // CSS1Strict: BODY Margin acts like margin.
        if (    !fHtmlLayout
            &&  (   pCFI->_pff->GetMargin(SIDE_TOP).IsPercent()
                 || pCFI->_pff->GetMargin(SIDE_BOTTOM).IsPercent() ))
        {
            pCFI->_ff().SetPercentVertPadding(TRUE);
        }
        if (    !fHtmlLayout
            &&  (   pCFI->_pff->GetMargin(SIDE_LEFT).IsPercent()
                 || pCFI->_pff->GetMargin(SIDE_RIGHT).IsPercent() ))
        {
            pCFI->_ff().SetPercentHorzPadding(TRUE);
        }
        pCFI->UnprepareForDebug();
    }

    if (IsInViewLinkBehavior(FALSE))
    {
        CElement * pElemMaster = pRoot->GetMasterPtr();

        Assert(pElemMaster);
        if (    pElemMaster->IsInMarkup()
            &&  !fHtmlLayout )
        {
            CTreeNode *             pNode   = pElemMaster->GetFirstBranch();
            const CFancyFormat *    pFF     = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
            const CCharFormat  *    pCF     = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
            BOOL                    fVLF    = pCF->HasVerticalLayoutFlow();
            BOOL                    fWMU    = pCF->_fWritingModeUsed;

            pCFI->PrepareFancyFormat();
            if (!pFF->GetLogicalWidth(fVLF, fWMU).IsNullOrEnum())
            {
                CUnitValue uv;
                
                uv.SetPercent(100);
                pCFI->_ff().SetWidth(uv);
                pCFI->_ff().SetWidthPercent(TRUE);
            }
            if (!pFF->GetLogicalHeight(fVLF, fWMU).IsNullOrEnum())
            {
                CUnitValue uv;
                
                uv.SetPercent(100);
                pCFI->_ff().SetHeight(uv);
                pCFI->_ff().SetHeightPercent(TRUE);
            }
            pCFI->UnprepareForDebug();
        }
    }
    else
    {
        pCFI->PrepareFancyFormat();
       
        if (!fHtmlLayout)
        {
            pCFI->_ff().SetHeightPercent(TRUE);
            pCFI->_ff().SetWidthPercent(TRUE);
        }
        //
        // if we are in print preview, and this is the contentbody of
        // a layout rect then we need to make sure scrollbars are turned 
        // off.  (110464)
        if (IsInViewLinkBehavior(TRUE))
        {
            Assert(   GetMarkup()
                   && GetMarkup()->Root()
                   && GetMarkup()->Root()->HasMasterPtr()
                   && GetMarkup()->Root()->GetMasterPtr()->IsLinkedContentElement() 
                   );

            pCFI->_ff().SetOverflowX(styleOverflowVisible);
            pCFI->_ff().SetOverflowY(styleOverflowVisible);
        }

        pCFI->UnprepareForDebug();
    }

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CBodyElement::OnPropertyChange
//
//  Synopsis:   Handles change of property on body tag
//
//  Arguments:  dispid:  id of the property changing
//              dwFlags: change flags
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CBodyElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if (hr != S_OK)
        goto Cleanup;

    switch (dispid)
    {
    case DISPID_BACKCOLOR:
    case DISPID_A_BACKGROUNDIMAGE:
        {
            CMarkup *pMarkup = GetMarkup();

            if (pMarkup && pMarkup->IsHtmlLayout())
            {
                CElement * pElement = pMarkup->GetHtmlElement();

                if (    pElement
                    &&  DYNCAST(CHtmlElement, pElement)->ShouldStealBackground())
                {
                    CLayoutInfo * pLayoutInfo = pElement->GetUpdatedNearestLayoutInfo();
                    if (pLayoutInfo)
                    {
                        pLayoutInfo->OnPropertyChange(dispid, dwFlags);   
                    }
                   
                    pElement->Invalidate();
                    break;
                }

            }

            // If we need to invalidate ourselves, do so here.
            Invalidate();
        }
        break;
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CBodyElement::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CBodyElement::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    RRETURN1(Layout( GUL_USEFIRSTLAYOUT )->GetFocusShape(lSubDivision, pdci, ppShape), S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Member: WaitForRecalc
//
//-----------------------------------------------------------------------------

void
CBodyElement::WaitForRecalc()
{
    CFlowLayout * pFlowLayout = Layout();

    if (pFlowLayout)
    {
        pFlowLayout->WaitForRecalc(GetLastCp(), -1);
    }
}

CBase *
CBodyElement::GetBaseObjectFor(DISPID dispID, CMarkup * pMarkup)
{
    // Messy.  We want to supply the window/markup if:
    // 1. We are backwards compatible and a BODY/FRAMESET (really should be *primary* BODY/FRAMESET).
    // 2. We are CSS1 strict, a BODY/FRAMESET (should be primary), and is not DISPID_EVPROP_ONSCROLL.
    // 3. We are CSS1 strict, an HTML element, and are DISPID_EVPROP_ONSCROLL
    // If we have to add other events to the list, we should make another static CMarkup fn.  (greglett)
    if (    !pMarkup
        &&  IsInMarkup() )
        pMarkup = GetMarkup();

    if (    CMarkup::IsTemporaryDISPID (dispID)
        &&  (   dispID != DISPID_EVPROP_ONSCROLL
            ||  !pMarkup                    
            ||  !pMarkup->IsHtmlLayout() ))
    {        
        if (!pMarkup)
            return NULL;
        else if (pMarkup->HasWindow())
            return pMarkup->Window();       // if we have a window use it 

        // if we have a pending window, we temporarily store these 
        // DISPIDs on the markup and move them onto the window when we switch
        else if (pMarkup->_fWindowPending)
            return pMarkup;
    }

    return this;
}

//+----------------------------------------------------------------------------
// Text subsystem initialization
//-----------------------------------------------------------------------------

void RegisterFETCs();
void ConvertDrawDCMapping(HDC);
WORD wConvScroll(WORD);

// System static variables

extern void DeInitFontCache();

HRESULT
InitTextSubSystem()
{
    static BOOL fTSInitted = FALSE;

    if (!fTSInitted)
    {
        InitUnicodeWrappers();              // Init UNICODE wrappers for Chicago
        RegisterFETCs();                    // Register new clipboard formats

        fTSInitted = TRUE;
    }

    return S_OK;
}

void
DeinitTextSubSystem ( )
{
    DeInitFontCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\disp2.cxx ===
//+----------------------------------------------------------------------------
// File: disp2.cxx
//
// Description: Utility function on CDisplay
//
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_LSM_HXX
#define X_LSM_HXX
#include "lsm.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_MARQUEE_HXX_
#define X_MARQUEE_HXX_
#include "marquee.hxx"
#endif

#ifndef X_RCLCLPTR_HXX_
#define X_RCLCLPTR_HXX_
#include "rclclptr.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_EPHRASE_HXX_
#define X_EPHRASE_HXX_
#include "ephrase.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifdef MULTI_LAYOUT
#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif
#endif // MULTI_LAYOUT

#ifndef X_FONTLINK_HXX_
#define X_FONTLINK_HXX_
#include "fontlink.hxx"
#endif

#pragma warning(disable:4706) /* assignment within conditional expression */

MtDefine(CDisplayShowSelectedRange_aryInvalRects_pv, Locals, "CDisplay::ShowSelectedRange aryInvalRects::_pv");
MtDefine(CDisplayRegionFromElement_aryChunks_pv, Locals, "CDisplay::RegionFromElement::aryChunks_pv");
MtDefine(CDisplayGetWigglyFromRange_aryWigglyRect_pv, Locals, "CDisplay::GetWigglyFromRange::aryWigglyRect_pv");

DeclareTag(tagNotifyLines, "NotifyLines", "Fix-up a line cch from Notify");
DeclareTag(tagRFEGeneral, "RFE", "General trace");
DeclareTag(tagRFEClipToVis, "RFE", "Clip to Visible trace");

DeclareLSTag(tagDumpLineCache, "Dump line cache info in DumpLines");

// ================================  Line info retrieval  ====================================

/*
 *  CDisplay::YposFromLine(ili)
 *
 *  @mfunc
 *      Computes top of line position
 *
 *  @rdesc
 *      top position of given line (relative to the first line)
 *      Computed by accumulating CLineCore _yHeight's for each line with
 *      _fForceNewLine true.
 */
LONG CDisplay::YposFromLine(
    CCalcInfo * pci,
    LONG        ili,       //@parm Line we're interested in
    LONG      * pyHeight_IgnoreNeg)
{
    LONG yPos;
    CLineCore * pli;
    LONG yPosMax = 0;
    
    // if the flowlayout is hidden, all we have is zero height lines.
    if(GetFlowLayout()->IsDisplayNone())
        return 0;


    if(!WaitForRecalcIli(ili, pci))          // out of range, use last valid line
    {
        ili = LineCount() -1;
        ili = (ili > 0) ? ili : 0;
    }

    yPos = 0;
    for (long i=0; i < ili; i++)
    {
        pli = Elem(i);
        if (pli->_fForceNewLine)
        {
            yPos += pli->_yHeight;
            if (yPosMax < yPos)
            {
                yPosMax = yPos;
            }
        }
    }

    if (pyHeight_IgnoreNeg)
    {
        *pyHeight_IgnoreNeg = yPosMax;
    }
    
    return yPos;
}


/*
 *  CDisplay::CpFromLine(ili, pyHeight)
 *
 *  @mfunc
 *      Computes cp at start of given line
 *      (and top of line position relative to this display)
 *
 *  @rdesc
 *      cp of given line
 */
LONG CDisplay::CpFromLine (
    LONG ili,               // Line we're interested in (if <lt> 0 means caret line)
    LONG *pyHeight) const   // Returns top of line relative to display
{
    long    cp = GetFlowLayout()->GetContentFirstCpForBrokenLayout();
    long    y  = 0;
    CLineCore * pli;

    for (long i=0; i < ili; i++)
    {
        pli = Elem(i);
        if (pli->_fForceNewLine)
        {
            y += pli->_yHeight;
        }
        cp += pli->_cch;
    }

    if(pyHeight)
        *pyHeight = y;

    return cp;
}

//+----------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Adjust all internal caches in response to a text change
//              within a nested CTxtSite
//
//  Arguments:  pnf - Notification that describes the change
//
//  NOTE: Only those caches which the notification manager is unaware of
//        need updating (e.g., _dcpCalcMax). Others, such as outstanding
//        change transactions, are handled by the notification manager.
//
//-----------------------------------------------------------------------------

inline BOOL LineIsNotInteresting(CLinePtr& rp)
{
    return rp->IsFrame() || rp->IsClear();
}

void
CDisplay::Notify(CNotification * pnf)
{
    CFlowLayout *   pFlowLayout    = GetFlowLayout();
    CElement *      pElementFL     = pFlowLayout->ElementOwner();
    BOOL            fIsDirty       = pFlowLayout->IsDirty();
    long            cpFirst        = pFlowLayout->GetContentFirstCp();
    long            cpDirty        = cpFirst + pFlowLayout->Cp();
    long            cchNew         = pFlowLayout->CchNew();
    long            cchOld         = pFlowLayout->CchOld();
    long            cpMax          = _dcpCalcMax;
    long            cchDelta       = pnf->CchChanged();
#if DBG==1
    long            dcpLastCalcMax = _dcpCalcMax;
    long            iLine          = -1;
    long            cchLine        = -1;
#endif

    //
    // If no lines yet exist, exit
    //

    if (!LineCount())
        goto Cleanup;

    //
    // Determine the end of the line array
    // (This is normally the maximum calculated cp, but that cp must
    //  be adjusted to take into account outstanding changes.
    //  Changes which overlap the maximum calculated cp effectively
    //  move it to the first cp affected by the change. Changes which
    //  come entirely before move it by the delta in characters of the
    //  change.)
    //

    if (    fIsDirty
        &&  pFlowLayout->Cp() < cpMax)
    {
        if (pFlowLayout->Cp() + cchOld >= cpMax)
        {
            cpMax = pFlowLayout->Cp();
        }
        else
        {
            cpMax += cchNew - cchOld;
        }
    }

    //
    // If the change is past the end of the line array, exit
    //

    if ((pnf->Cp(cpFirst) - cpFirst) > cpMax)
        goto Cleanup;

    //
    // If the change is entirely before or after any pending changes,
    // update the cch of the affected line, the maximum calculated cp,
    // and, if necessary, the first visible cp
    // (Changes which occur within the range of a pending change,
    //  need not be tracked since the affected lines will be completely
    //  recalculated. Additionally, the outstanding change which
    //  represents those changes will itself be updated (by other means)
    //  to cover the changes within the range.)
    // NOTE: The "old" cp must be used to search the line array
    //

    if (    cchDelta
        &&  (   !fIsDirty
            ||  pnf->Cp(cpFirst) <  cpDirty
            ||  pnf->Cp(cpFirst) >= cpDirty + cchNew))
    {
        CLinePtr    rp(this);
        long        cchCurrent  = pFlowLayout->GetContentTextLength();
        long        cchPrevious = cchCurrent - (fIsDirty
                                                    ? cchNew - cchOld
                                                    : 0);
        long        cpPrevious  = !fIsDirty || pnf->Cp(cpFirst) < cpDirty
                                        ? pnf->Cp(cpFirst)
                                        : pnf->Cp(cpFirst) + (cchOld - cchNew);

        //
        // Adjust the maximum calculated cp
        // (Sanitize the value as well - invalid values can result when handling notifications from
        //  elements that extend outside the layout)
        //

        _dcpCalcMax += cchDelta;
        if (_dcpCalcMax < 0)
        {
            _dcpCalcMax = 0;
        }
        else if (_dcpCalcMax > cchPrevious)
        {
            _dcpCalcMax = cchPrevious;
        }

        //----------------------------------------------------------------------------------
        //
        // BEGIN HACK ALERT! BEGIN HACK ALERT! BEGIN HACK ALERT! BEGIN HACK ALERT! 
        //
        // All the code here to find out the correct line to add or remove chars from.
        // Its impossible to accurately detect a line to which characters can be added.
        // So this code makes a best attempt!
        //
        //

        //
        // Find and adjust the affected line
        //
        rp.RpSetCp(cpPrevious, FALSE, FALSE);

        if (cchDelta > 0)
        {
            //
            // We adding at the end of the site?
            //
            if (pnf->Handler()->GetLastCp() == pnf->Cp(cpFirst) + cchDelta)
            {
                //
                // We are adding to the end of the site, we need to go back to a line which
                // has characters so that we can tack on these characters to that line.
                // Note that we have to go back _atleast_ once so that its the prev line
                // onto which we tack on these characters.
                //
                // Note: This also handles the case when the site was empty (no chars) and
                // we are adding characters to it. In this case we will add to the first
                // line prior to the site, because there is no line in the line array where
                // we can add these chars (since it was empty in the first place). If we
                // cannot find a line with characters before this line -- could be we are
                // adding chars to an empty table at beg. of doc., then we will find the
                // line _after_ cp to add it. If we cannot find that either then we will
                // bail out.
                //

                //
                // So go back once only if we were ambigously positioned (We will be correctly
                // positioned if this is last line and last cp of handler is the last cp of this
                // flowlayout). Dont do anything if you cannot go back -- in that
                // case we will go forward later on.
                //
                if (rp.RpGetIch() == 0)
                    rp.PrevLine(FALSE, FALSE);

                //
                // OK, so look backwards to find a line with characters.
                //
                while (LineIsNotInteresting(rp))
                {
                    if (!rp.PrevLine(FALSE, FALSE))
                        break;
                }

                //
                // If we broke out of the while look above, it would mean that we did not
                // find an interesting line before the one at which we were positioned.
                // This should only happen when we have an empty site (like table) at the
                // beginning of the document. In this case we will go forward (the code
                // outside this if block) to find a line. YUCK! This is not ideal but is
                // the best we can do in this situation.
                //
            }

            //
            // We will fall into the following while loop in 3 cases:
            // 1) When we were positioned at the beginning of the site: In this case
            //    we have to make sure that we add the chars to an interesting line.
            //    (note the 3rd possibility, i.e. adding in the middle of a site is trivial
            //    since the original RpSetCp will position us to an interesting line).
            // 2) We were positioned at the end of the site but were unable to find a prev
            //    line, hence we are now looking forward.
            //
            // If we cannot find _any_ interesting line then we shrug our shoulders
            // and bail out.
            //
            while (LineIsNotInteresting(rp))
            {
                if (!rp.NextLine(FALSE, FALSE))
                    goto Cleanup;
            }


            // NOTE: Arye - It shouldn't be necessary to do this here, it should be possible
            // to do it only in the case where we're adding to the end. Since this code
            // is likely to go away with the display tree I'm not going to spend a lot of
            // time making that work right now.
            // Before this, however, in edit mode we might end up on the last (BLANK) line.
            // This is bad, nothing is there to change the number of characters,
            // so just back up.
            if (rp->_cch == 0 && pElementFL->IsEditable(/*fCheckContainerOnly*/FALSE) &&
                rp.GetLineIndex() == LineCount() - 1)
            {
                do  
                {
                    if (!rp.PrevLine(FALSE, FALSE))
                        goto Cleanup;
                } while(LineIsNotInteresting(rp));
            }

            //
            // Right, if we are here then we have a line into which we can pour
            // the characters.
            //
        }

        //
        // We are removing chars. Easy problem; just find a line from which we can remove
        // the chars!
        //
        else
        {
            while (!rp->_cch)
            {
                if (!rp.NextLine(FALSE, FALSE))
                {
                    Assert("No Line to goto, doing nothing");
                    goto Cleanup;
                }
            }
        }

        //
        //
        // END HACK ALERT! END HACK ALERT! END HACK ALERT! END HACK ALERT! END HACK ALERT! 
        //
        //----------------------------------------------------------------------------------

        Assert(rp.GetLineIndex() >= 0);

        // (IEv60 33838) : The assert started to fire in debug on IA64, when ITGWEB was showing "Access Denied" page.
        //Assert(cchDelta > 0 || !rp.GetLineIndex() || ( rp->_cch + cchDelta ) >= 0);
        Check(cchDelta > 0 || !rp.GetLineIndex() || ( rp->_cch + cchDelta ) >= 0);

        WHEN_DBG(iLine = rp.GetLineIndex());
        WHEN_DBG(cchLine = rp->_cch);

        //
        // Update the number of characters in the line
        // (Sanitize the character count if the delta is too large - this can happen for
        //  notifications from elements that extend outside the layout)
        //

        rp->_cch += cchDelta;
        if (!rp.GetLineIndex())
        {
            rp->_cch = max(rp->_cch, 0L);
        }
        else if (rp.IsLastTextLine())
        {
            rp->_cch = min(rp->_cch, rp.RpGetIch() + (cchPrevious  - (cpPrevious - cpFirst)));
        }
        Assert(cchDelta > 0 || !rp.GetLineIndex() || rp->_cch >= 0);
    }

Cleanup:
#if DBG==1
    if (iLine >= 0)
    {
        TraceTagEx((tagNotifyLines, TAG_NONAME,
                    "NotifyLine: (%d) Element(0x%x,%S) ChldNd(%d) dcp(%d) cchDelta(%d) line(%d) cch(%d,%d) dcpCalcMax(%d,%d)",
                    pnf->SerialNumber(),
                    pFlowLayout->ElementOwner(),
                    pFlowLayout->ElementOwner()->TagName(),
                    pnf->Node()->_nSerialNumber,
                    pnf->Cp(cpFirst) - cpFirst,
                    cchDelta,
                    iLine,
                    cchLine, max(0L, cchLine + cchDelta),
                    dcpLastCalcMax, _dcpCalcMax));
    }
    else
    {
        TraceTagEx((tagNotifyLines, TAG_NONAME,
                    "NotifyLine: (%d) Element(0x%x,%S) dcp(%d) dcpCalcMax(%d) delta(%d) IGNORED",
                    pnf->SerialNumber(),
                    pFlowLayout->ElementOwner(),
                    pFlowLayout->ElementOwner()->TagName(),
                    pnf->Cp(cpFirst) - cpFirst,
                    _dcpCalcMax,
                    cchDelta));
    }
#endif
    return;
}

//+----------------------------------------------------------------------------
//
//  Member:     LineFromPos
//
//  Synopsis:   Computes the line at a given x/y and returns the appropriate
//              information
//
//  Arguments:  dwBlockID - Layout block ID of this line array
//              prc      - CRect that describes the area in which to look for the line
//              pyLine   - Returned y-offset of the line (may be NULL)
//              pcpLine  - Returned cp at start of line (may be NULL)
//              grfFlags - LFP_xxxx flags
//
//  Returns:    Index of found line (-1 if no line is found)
//
//-----------------------------------------------------------------------------
LONG CDisplay::LineFromPos (
    const CRect &   rc,
    LONG *          pyLine,
    LONG *          pcpLine,
    DWORD           grfFlags,
    LONG            iliStart,
    LONG            iliFinish) const
{
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    CElement    *   pElement    = pFlowLayout->ElementOwner();
    CLineCore   *   pli;
    CLineOtherInfo *ploi;
    long            ili;
    long            yli;
    long            cpli;
    long            iliCandidate;
    long            yliCandidate;
    long            cpliCandidate;
    BOOL            fCandidateWhiteHit;
    long            yIntersect;
    BOOL            fInBrowse = !pElement->IsEditable(FALSE FCCOMMA LC_TO_FC(pFlowLayout->LayoutContext()));

    CRect myRc( rc );

    if( myRc.top < 0 )
        myRc.top = 0;
    if (myRc.bottom < 0)
        myRc.bottom = 0;
    
    Assert(myRc.top    <= myRc.bottom);
    Assert(myRc.left   <= myRc.right);
    //
    //  If hidden or no lines exist, return immediately
    //

    if (    (   pElement->IsDisplayNone(LC_TO_FC(pFlowLayout->LayoutContext()))
            &&  pElement->Tag() != ETAG_BODY)
        ||  LineCount() == 0)
    {
        ili  = -1;
        yli  = 0;
        cpli = GetFirstCp();
        goto FoundIt;
    }

    if (iliStart < 0)
        iliStart = 0;

    if (iliFinish < 0)
        iliFinish = LineCount();

    Assert(iliStart < iliFinish && iliFinish <= LineCount());

    ili  = iliStart;
    pli  = Elem(ili);;
    ploi = pli->oi();
    
    if (iliStart > 0)
    {
        yli  = -pli->GetYTop(ploi);
        cpli = CpFromLine(ili);
        // REVIEW olego(sidda): 12-10-98 xsync. Is cpli computed correctly here for page view case?
    }
    else
    {
        yli  = 0;
        cpli = pFlowLayout->GetContentFirstCpForBrokenLayout(); // MULTI_LAYOUT
    }

    iliCandidate  = -1;
    yliCandidate  = -1;
    cpliCandidate = -1;
    fCandidateWhiteHit = TRUE;

    //
    //  Set up to intersect top or bottom of the passed rectangle
    //

    yIntersect = (grfFlags & LFP_INTERSECTBOTTOM
                        ? myRc.bottom - 1
                        : myRc.top);

    //
    //  Examine all lines that intersect the passed offsets
    //

    while ( ili < iliFinish
        &&  yIntersect >= yli + _yMostNeg)
    {
        pli = Elem(ili);
        ploi = pli->oi();
        
        //
        //  Skip over lines that should be ignored
        //  These include:
        //      1. Lines that do not intersect
        //      2. Hidden and dummy lines
        //      3. Relative lines (when requested)
        //      4. Line chunks that do not intersect the x-offset
        //      5. Its an aligned line and we have been asked to skip aligned lines
        //
        
        if (    yIntersect >= yli + min(0l, pli->GetYLineTop(ploi))
            &&  yIntersect < yli + max(0l, pli->GetYLineBottom(ploi))
            &&  !pli->_fHidden
            &&  (   !pli->_fDummyLine
                ||  !fInBrowse)
            &&  (   !pli->_fRelative
                ||  !(grfFlags & LFP_IGNORERELATIVE))
            &&  (   pli->_fForceNewLine
                ||  (!pli->_fRTLLn
                            ? myRc.left <= pli->GetTextRight(ploi, ili == LineCount() - 1)
                            : myRc.left >= pli->GetRTLTextLeft(ploi)))
            &&  (   (!pli->IsFrame()
                ||   !(grfFlags & LFP_IGNOREALIGNED)))
           )

        {
            //
            //  If searching for the top-most line in z-order,
            //  then save the "hit" line and continue the search
            //  NOTE: Progressing up through the z-order, multiple lines can be hit.
            //        Hits on text always win over hits on whitespace.
            //

            if (grfFlags & LFP_ZORDERSEARCH)
            {
                BOOL    fWhiteHit =  (!pli->_fRTLLn
                                     ? /*LTR*/  (   myRc.left < ploi->GetTextLeft() - (pli->_fHasBulletOrNum
                                                                                     ? ploi->_xLeft
                                                                                     : 0)
                                                ||  myRc.left > pli->GetTextRight(ploi, ili == LineCount() -1))
                                     : /*RTL*/  (   myRc.left < pli->GetRTLTextLeft(ploi)
                                                ||  myRc.left > pli->GetRTLTextRight(ploi) - (pli->_fHasBulletOrNum
                                                                                            ? pli->_xRight
                                                                                            : 0)))
                                ||  (   yIntersect >= yli
                                    &&  yIntersect <  (yli + pli->GetYTop(ploi)))
                                ||  (   yIntersect >= (yli + pli->GetYBottom(ploi))
                                    &&  yIntersect <  (yli + pli->_yHeight));

                if (    iliCandidate < 0
                    ||  !fWhiteHit
                    ||  fCandidateWhiteHit)
                {
                    iliCandidate       = ili;
                    yliCandidate       = yli;
                    cpliCandidate      = cpli;
                    fCandidateWhiteHit = fWhiteHit;
                }
            }

            //
            //  Otherwise, the line is found
            //

            else
            {
                goto FoundIt;
            }

        }

        if(pli->_fForceNewLine)
        {
            yli += pli->_yHeight;
        }

        cpli += pli->_cch;
        ili++;
    }

    //
    // if we are lookig for an exact line hit and
    // do not have a candidate line, it's a miss
    //
    if (iliCandidate < 0 && grfFlags & LFP_EXACTLINEHIT)
    {
        return -1;
    }

    Assert(ili <= LineCount());


    //
    // we better have a candidate, if yIntersect < yli + _yMostNeg
    //
    Assert( iliCandidate >= 0 || yIntersect >= yli + _yMostNeg || (grfFlags & LFP_IGNORERELATIVE));

    //
    //  No intersecting line was found, take either the candidate or last line
    //
    
    //
    //  ili == LineCount() - is TRUE only if the point we are looking for is
    //  below all the content or we found a candidate line but are performing
    //  a Z-Order search on a layout with lines with negative margin.
    //
    if (    ili == iliFinish

    //
    //  Here we don't really need to check if iliCandidate >= 0. It is added
    //  to make the code more robust to handle cases like a negative yIntersect
    //  passed in.
    //
        ||  (   yIntersect < yli + _yMostNeg
            &&  iliCandidate >= 0))
    {
        //
        //  If a candidate line was found, use it
        //

        if (iliCandidate >= 0)
        {
            // The following assert is invalid when we have line height(see bug 26107)
            //Assert(yliCandidate  >= 0);

            Assert(cpliCandidate >= 0);

            ili  = iliCandidate;
            yli  = yliCandidate;
            cpli = cpliCandidate;
        }

        //
        //  Otherwise use the last line
        //

        else
        {
            Assert(pli);
            Assert(ploi);
            Assert(ili > 0);
            Assert(LineCount());

            ili--;

            if (pli->_fForceNewLine)
            {
                yli -= pli->_yHeight;
            }

            cpli -= pli->_cch;
        }

        //
        //  Ensure that frame lines are not returned if they are to be ignored
        //

        if (grfFlags & LFP_IGNOREALIGNED)
        {
            pli = Elem(ili);
            
            if (pli->IsFrame())
            {
                while(pli->IsFrame() && ili)
                {
                    ili--;
                    pli = Elem(ili);
                }

                if(pli->_fForceNewLine)
                    yli -= pli->_yHeight;
                cpli -= pli->_cch;
            }
        }
    }

FoundIt:
    Assert(ili < LineCount());

    if(pyLine)
    {
        *pyLine = yli;
    }

    if(pcpLine)
    {
        *pcpLine = cpli;
    }

    return ili;
}

//==============================  Point <-> cp conversion  ==============================

LONG CDisplay::CpFromPointReally(
    POINT       pt,               // Point to compute cp at (client coords)
    CLinePtr  * const prp,         // Returns line pointer at cp (may be NULL)
    CMarkup **  ppMarkup,          // Markup which cp belongs to (in case of viewlinking)   
    DWORD       dwCFPFlags,       // flags to CpFromPoint
    BOOL      * pfRightOfCp,
    LONG      * pcchPreChars,
    BOOL      * pfHitGlyph)
{
    CMessage      msg;
    HTC           htc;
    CTreeNode   * pNodeElementTemp = NULL; // keep compiler happy
    DWORD         dwFlags = HT_SKIPSITES | HT_VIRTUALHITTEST | HT_IGNORESCROLL | HT_HTMLSCOPING;
    LONG          cpHit;
    CFlowLayout * pFlowLayout = GetFlowLayout();
    CTreeNode   * pNode = pFlowLayout->GetFirstBranch();
    CRect         rcClient;

    Assert(pNode);

    CElement  * pContainer = pNode->GetContainer();

    if (   pContainer
        && pContainer->Tag() == ETAG_BODY
        && pContainer->GetMarkup()->IsStrictCSS1Document()
       )
    {
        CElement *pContainerOld = pContainer;
        pContainer = pContainer->GetFirstBranch()->Parent()->SafeElement();
        if (   !pContainer
            || pContainer->Tag() != ETAG_HTML
           )
        {
            pContainer = pContainerOld;
        }
    }

    if (pfHitGlyph)
        *pfHitGlyph = FALSE;

    pFlowLayout->GetContentRect(&rcClient, COORDSYS_GLOBAL);

    if (pt.x < rcClient.left)
        pt.x = rcClient.left;
    if (pt.x >= rcClient.right)
        pt.x = rcClient.right - 1;
    if (pt.y < rcClient.top)
        pt.y = rcClient.top;
    if (pt.y >= rcClient.bottom)
        pt.y = rcClient.bottom - 1;
    
    msg.pt = pt;

    if (dwCFPFlags & CFP_ALLOWEOL)
        dwFlags |= HT_ALLOWEOL;
    if (!(dwCFPFlags & CFP_IGNOREBEFOREAFTERSPACE))
        dwFlags |= HT_DONTIGNOREBEFOREAFTER;
    if (!(dwCFPFlags & CFP_EXACTFIT))
        dwFlags |= HT_NOEXACTFIT;

    //
    // Ideally I would have liked to perform the hit test on _pFlowLayout itself,
    // however when we have relatively positioned lines, then this will miss
    // some lines (bug48689). To avoid missing such lines we have to hittest
    // from the ped. However, doing that has other problems when we are
    // autoselecting. For example, if the point is on a table, the table finds
    // the closest table cell and passes that table cell the message to
    // extend a selection. However, this hittest hits the table and
    // msg._cpHit is not initialized (bug53706). So in this case, do the CpFromPoint
    // in the good ole' traditional manner.
    //

    // Note (yinxie): I changed GetPad()->HitTestPoint to GetContainer->HitTestPoint
    // for the flat world, container is the new notion to replace ped
    // this will ix the bug (IE5 17135), the bugs mentioned above are all checked
    // there is no regression.

    // HACKHACK (grzegorz) CElement::HitTestPoint can call EnsureView, at this point
    // there is possibility to change the tree or to navigate to a different location.
    // Hence pElementFL can be removed from the tree. In this case return an error.

    CElement * pElementFL = pFlowLayout->ElementOwner();
    pElementFL->AddRef();
    htc = (pContainer) 
            ? pContainer->HitTestPoint(&msg, &pNodeElementTemp, dwFlags)
            : HTC_NO;
    BOOL fRemovedFromTree = !pElementFL->GetFirstBranch();
    pElementFL->Release();
    if (fRemovedFromTree)
        return -1;

    // Take care of INPUT which contains its own private ped. If cpHit is inside the INPUT,
    // change it to be the cp of the INPUT in its contaning ped.
    //if (htc >= HTC_YES && pNodeElementTemp && pNodeElementTemp->Element()->IsMaster())
    //{
    //    msg.resultsHitTest.cpHit = pNodeElementTemp->Element()->GetFirstCp();
    //}
    if (    htc >= HTC_YES
        &&  pNodeElementTemp
        &&  (   pNodeElementTemp->IsContainer()
             && pNodeElementTemp->GetContainer() != pContainer
            )
       )
    {
        htc= HTC_NO;
    }

    if (htc >= HTC_YES && msg.resultsHitTest._cpHit >= 0)
    {
        cpHit = msg.resultsHitTest._cpHit;
        if (prp)
        {
            prp->RpSet(msg.resultsHitTest._iliHit, msg.resultsHitTest._ichHit);
        }
        if (pfRightOfCp)
            *pfRightOfCp = msg.resultsHitTest._fRightOfCp;
        if (pcchPreChars)
            *pcchPreChars = msg.resultsHitTest._cchPreChars;
        if (pfHitGlyph)
            *pfHitGlyph = msg.resultsHitTest._fGlyphHit;
        if(ppMarkup && pNodeElementTemp)
            *ppMarkup = pNodeElementTemp->GetMarkup();
    }
    else
    {
        CPoint ptLocal(pt);
        CTreePos *ptp = NULL;
        //
        // We now need to convert pt to client coordinates from global coordinates
        // before we can call CpFromPoint...
        //
        pFlowLayout->TransformPoint(&ptLocal, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
        cpHit = CpFromPoint(ptLocal, prp, &ptp, NULL, dwCFPFlags,
                            pfRightOfCp, NULL, pcchPreChars, NULL);
        if(ppMarkup && ptp)
            *ppMarkup = ptp->GetMarkup();
    }
    return cpHit;
}

LONG
CDisplay::CpFromPoint(
    POINT       pt,                     // Point to compute cp at (site coords)
    CLinePtr  * const prp,         // Returns line pointer at cp (may be NULL)
    CTreePos ** pptp,             // pointer to return TreePos corresponding to the cp
    CLayout  ** ppLayout,          // can be NULL
    DWORD       dwFlags,
    BOOL      * pfRightOfCp,
    BOOL      * pfPseudoHit,
    LONG      * pcchPreChars,
    CCalcInfo * pci)
{
    CCalcInfo   CI;
    CRect       rc;
    LONG        ili;
    LONG        cp;
    LONG        yLine;

    CFlowLayout *pFlowLayout = GetFlowLayout();

    if(!pci)
    {
        CI.Init(pFlowLayout);
        pci = &CI;
    }

    // Get line under hit
    pFlowLayout->GetClientRect(&rc);

    rc.MoveTo(pt);

    ili = LineFromPos(
        rc, &yLine, &cp, LFP_ZORDERSEARCH | LFP_IGNORERELATIVE |
                                        (!ppLayout
                                            ? LFP_IGNOREALIGNED
                                            : 0) |
                                        (dwFlags & CFP_NOPSEUDOHIT
                                            ? LFP_EXACTLINEHIT
                                            : 0));
    if(ili < 0)
        return -1;
        
                         
    return CpFromPointEx(ili, yLine, cp, pt, prp, pptp, ppLayout,
                         dwFlags, pfRightOfCp, pfPseudoHit,
                         pcchPreChars, NULL, NULL, pci);
                        
}

LONG
CDisplay::CpFromPointEx(
    LONG       ili,
    LONG       yLine,
    LONG       cp,
    POINT      pt,                      // Point to compute cp at (site coords)
    CLinePtr  *const prp,               // Returns line pointer at cp (may be NULL)
    CTreePos **pptp,                    // pointer to return TreePos corresponding to the cp
    CLayout  **ppLayout,                // can be NULL
    DWORD      dwFlags,
    BOOL      *pfRightOfCp,
    BOOL      *pfPseudoHit,
    LONG      *pcchPreChars,
    BOOL      *pfGlyphHit,
    BOOL      *pfBulletHit,
    CCalcInfo *pci)
{
    CFlowLayout *pFlowLayout = GetFlowLayout();
    CElement    *pElementFL  = pFlowLayout->ElementOwner();
    CCalcInfo    CI;
    CLineCore   *pli = Elem(ili);
    CLineFull    lif;
    LONG         cch = 0;
    LONG         dx = 0;
    BOOL         fPseudoHit = FALSE;
    CTreePos    *ptp = NULL;
    CTreeNode   *pNode;
    LONG         cchPreChars = 0;
    LONG         yProposed = 0;
    
    if (pfGlyphHit)
        *pfGlyphHit = FALSE;

    if (pfBulletHit)
        *pfBulletHit = FALSE;
    
    if (!pci)
    {
        CI.Init(pFlowLayout);
        pci = &CI;
    }

    if (   dwFlags & CFP_IGNOREBEFOREAFTERSPACE
        && (   pli == NULL
            || (   !pli->_fRelative
                && pli->_fSingleSite
               )
           )
       )
    {
        return -1 ;
    }

    if (pli)
    {
        lif = *pli;
        if (   lif.IsFrame()
            && !lif._fHasFloatedFL
           )
        {
            if(ppLayout)
            {
                *ppLayout = lif.AO_GetUpdatedLayout(&lif, LayoutContext());
            }
            cch = 0;

            if(pfRightOfCp)
                *pfRightOfCp = TRUE;

            fPseudoHit = TRUE;
        }
        else
        {
            if (    !(dwFlags & CFP_IGNOREBEFOREAFTERSPACE)
                &&  lif._fHasNestedRunOwner
                &&  yLine + lif._yHeight <= pt.y)
            {
                // If the we are not ignoring whitespaces and we have hit a line
                // which has a nested runowner, but are BELOW the line (happens when
                // that line is the last line in the document) then we want
                // to be at the end of that line. The measurer would put us at the
                // beginning or end depending upon the X position.
                cp += lif._cch;
            }
            else
            {
                // Create measurer
                CLSMeasurer me(this, pci);
                LONG yHeightRubyBase = 0;

                AssertSz((pli != NULL) || (ili == 0),
                         "CDisplay::CpFromPoint invalid line pointer");

                 if (!me._pLS)
                    return -1;

                // Get character in the line
                me.SetCp(cp, NULL);

                // The y-coordinate should be relative to the baseline, and positive going up
                cch = lif.CchFromXpos(me, pt.x, yLine + lif._yHeight - lif._yDescent - pt.y, &dx, 
                                       dwFlags & CFP_EXACTFIT, &yHeightRubyBase, pfGlyphHit, &yProposed);
                cchPreChars = me._cchPreChars;
                
                if (pfRightOfCp)
                    *pfRightOfCp = dx < 0;

                if (ppLayout)
                {
                    ptp = me.GetPtp();
                    if (ptp->IsBeginElementScope())
                    {
                        pNode = ptp->Branch();
                        if (   pNode->ShouldHaveLayout()
                            && pNode->IsInlinedElement()
                           )
                        {
                            AssertSz( (pNode->Element()->GetFirstCp() >= GetFirstCp()), "Found element outside display -- don't know context!" );
                            AssertSz( (pNode->Element()->GetLastCp() <= GetLastCp()), "Found element outside display -- don't know context!" );                            
                            *ppLayout = pNode->GetUpdatedLayout( LayoutContext() );
                        }
                        else
                        {
                            *ppLayout = NULL;
                        }
                    }
                }

                // Don't allow click at EOL to select EOL marker and take into account
                // single line edits as well

                if (!(dwFlags & CFP_ALLOWEOL) && cch && cch == lif._cch)
                {
                    long cpPtp;

                    ptp = me.GetPtp();
                    Assert(ptp);

                    cpPtp = ptp->GetCp();

                    //
                    // cch > 0 && we are not in the middle of a text run,
                    // skip past all the previous node/pointer tree pos's.
                    // and position the measurer just after text.
                    if(cp < cpPtp && cpPtp == me.GetCp())
                    {
                        while (cp < cpPtp)
                        {
                            CTreePos *ptpPrev = ptp->PreviousTreePos();

                            if (!ptpPrev->GetBranch()->IsDisplayNone())
                            {
                                if (ptpPrev->IsText())
                                    break;
                                if (ptpPrev->IsNode() && ptpPrev->ShowTreePos())
                                    break;
                                if (   ptpPrev->IsEndElementScope()
                                    && ptpPrev->Branch()->ShouldHaveLayout()
                                   )
                                    break;
                            }
                            ptp = ptpPrev;
                            Assert(ptp);
                            cch   -= ptp->GetCch();
                            cpPtp -= ptp->GetCch();
                        }

                        while(ptp->GetCch() == 0)
                            ptp = ptp->NextTreePos();
                    }
                    else if (pElementFL->GetFirstBranch()->GetParaFormat()->HasInclEOLWhite(TRUE))
                    {
                        CTxtPtr tpTemp(GetMarkup(), cp + cch);
                        if (tpTemp.GetPrevChar() == WCH_CR)
                        {
                            cch--;
                            if (cp + cch < cpPtp)
                                ptp = NULL;
                        }
                    }

                    me.SetCp(cp + cch, ptp);
                }

                // Check if the pt is within bounds *vertically* too.
                if (dwFlags & CFP_IGNOREBEFOREAFTERSPACE)
                {
                    LONG top, bottom;
                    
                    ptp = me.GetPtp();
                    if (   ptp->IsBeginElementScope()
                        && ptp->Branch()->ShouldHaveLayout()
                        && ptp->Branch()->IsInlinedElement()
                       )
                    {
                        AssertSz( (ptp->Branch()->Element()->GetFirstCp() >= GetFirstCp()), "Found element outside display -- don't know context!" );
                        AssertSz( (ptp->Branch()->Element()->GetLastCp() <= GetLastCp()), "Found element outside display -- don't know context!" );

                        // Hit a site. Check if we are within the boundaries
                        // of the site.
                        RECT rc;
                        CLayout *pLayout = ptp->Branch()->GetUpdatedLayout( LayoutContext() );
                        
                        pLayout->GetRect(&rc);

                        top = rc.top;
                        bottom = rc.bottom;
                    }
                    else
                    {
                        GetTopBottomForCharEx(pci,
                                              &top,
                                              &bottom,
                                              yLine,
                                              &lif,
                                              pt.x,
                                              yProposed,
                                              me.GetPtp(),
                                              pfBulletHit
                                             );
                        top -= yHeightRubyBase;
                        bottom -= yHeightRubyBase;
                    }

                    // NOTE (t-ramar): this is fine for finding 99% of the
                    // pseudo hits, but if someone has a ruby with wider base
                    // text than pronunciation text, or vice versa, hits in the
                    // whitespace that results will not register as pseudo hits.
                    if (    pt.y <  top
                        ||  pt.y >= bottom
                        ||  pt.x <  lif.GetTextLeft()
                        ||  pt.x >= lif.GetTextRight(ili == LineCount() - 1))
                    {
                        fPseudoHit = TRUE;
                    }
                }
                
                cp = (LONG)me.GetCp();

                ptp = me.GetPtp();
            }
        }
    }

    if(prp)
        prp->RpSet(ili, cch);

    if(pfPseudoHit)
        *pfPseudoHit = fPseudoHit;

    if(pcchPreChars)
        *pcchPreChars = cchPreChars;

    if(pptp)
    {
        LONG ich;

        *pptp = ptp ? ptp : pFlowLayout->GetContentMarkup()->TreePosAtCp(cp, &ich, TRUE);
    }

    return cp;
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::PointFromTp(tp, prcClient, fAtEnd, pt, prp, taMode,
//                                    pci, pfComplexLine, pfRTLFlow)
//
// Synopsis:    return the origin that corresponds to a given text pointer,
//              relative to the view
//
//-----------------------------------------------------------------------------
#if DBG==1
#pragma warning(disable:4189) // local variable initialized but not used 
#endif

LONG CDisplay::PointFromTp(
    LONG        cp,         // point for the cp to be computed
    CTreePos *  ptp,        // tree pos for the cp passed in, can be NULL
    BOOL fAtEnd,            // Return end of previous line for ambiguous cp
    BOOL fAfterPrevCp,      // Return the trailing point of the previous cp (for an ambigous bidi cp)
    POINT &pt,              // Returns point at cp in client coords
    CLinePtr * const prp,   // Returns line pointer at tp (may be null)
    UINT taMode,            // Text Align mode: top, baseline, bottom
    CCalcInfo *pci,         // This can be NULL
    BOOL *pfComplexLine,    // This can be NULL
    BOOL *pfRTLFlow)        // This can be NULL // RTL note: this is only non NULL in ViewServices
{
    CFlowLayout * pFL = GetFlowLayout();
    CLinePtr    rp(this);
    BOOL        fLastTextLine;
    CCalcInfo   CI;
    BOOL        fRTLLine;
    BOOL        fAtEndOfRubyBase;
    RubyInfo rubyInfo = {-1, 0, 0};

    //
    // If cp points to a node position somewhere between ruby base and ruby text, 
    // then we have to remember for later use that we are at the end of ruby text
    // (fAtEndOfRubyBase is set to TRUE).
    // If cp points to a node at the and of ruby element, then we have to move
    // cp to the beginning of text which follows ruby or to the beginning of block
    // element, whichever is first.
    //
    fAtEndOfRubyBase = FALSE;

    CTreePos * ptpNode = ptp ? ptp : GetMarkup()->TreePosAtCp(cp, NULL, TRUE);
    LONG cpOffset = 0;
    while ( ptpNode && ptpNode->IsNode() )
    {
        ELEMENT_TAG eTag = ptpNode->Branch()->Element()->Tag();
        if ( eTag == ETAG_RT )
        {
            fAtEndOfRubyBase = ptpNode->IsBeginNode();
            break;
        }
        else if ( eTag == ETAG_RP )
        {
            if (ptpNode->IsBeginNode())
            {
                //
                // At this point we check where the RP tag is located: before or 
                // after RT tag. If this is before RT tag then we set fAtEndOfRubyBase
                // to TRUE, in the other case we do nothing.
                //
                // If RT tag is a parent of RP tag then we are after RT tag. 
                // In the other case we are before RT tag.
                //
                CTreeNode * pParent = ptpNode->Branch()->Parent();
                while ( pParent )
                {
                    if ( pParent->Tag() == ETAG_RUBY )
                    {
                        fAtEndOfRubyBase = TRUE;
                        break;
                    }
                    else if ( pParent->Tag() == ETAG_RT )
                    {
                        break;
                    }
                    pParent = pParent->Parent();
                }
            }
            break;
        }
        else if ( ptpNode->IsEndNode() && eTag == ETAG_RUBY )
        {
            for (;;)
            {
                cpOffset++;
                ptpNode = ptpNode->NextTreePos();
                if ( !ptpNode || !ptpNode->IsNode() || 
                    ptpNode->Branch()->Element()->IsBlockElement() )
                {
                    cp += cpOffset;
                    break;
                }
                cp = min(cp, GetLastCp()); // Keep it inside the range
            }
            break;
        }
        cpOffset++;
        ptpNode = ptpNode->NextNonPtrTreePos();
    }

    if(!pci)
    {
        CI.Init(pFL);
        pci = &CI;
    }

    if (pFL->IsDisplayNone() ||
        !WaitForRecalc(cp, -1, pci))
        return -1;

    if(!rp.RpSetCp(cp, fAtEnd))
        return -1;

    if (!WaitForRecalc(min(cp + rp->_cch, GetLastCp()), -1, pci))
        return -1;

    if(!rp.RpSetCp(cp, fAtEnd))
        return -1;

#if DBG==1
    CLineCore * pliDbg = rp.CurLine();
#endif

    // Determine line's RTL
    if (rp.IsValid())
        fRTLLine = rp->_fRTLLn;
    else if(ptp)
        fRTLLine = ptp->GetBranch()->GetParaFormat()->HasRTL(TRUE);
    else
    {
        // RTL note: this looks like defensive code. It is hard to tell if we ever get here, 
        //           partly because the result is only used by ViewServices. 
        //           If curious about why this code is here, uncommend this assert.
        // Assert(0); 
        fRTLLine = IsRTLDisplay();
    }

    if(pfRTLFlow)
        *pfRTLFlow = fRTLLine;

    pt.y = YposFromLine(pci, rp, NULL);
    pt.x = rp.IsValid()
        ? rp.oi()->_xLeft + rp.oi()->_xLeftMargin + (fRTLLine ? rp->_xWidth : 0)
                : 0;
                    
    fLastTextLine = rp.IsLastTextLine();

    {
        CLSMeasurer me(this, pci);
        if (!me._pLS)
            return -1;

        // Backup to start of line
        if(rp.GetIch())
            me.SetCp(cp - rp.RpGetIch(), NULL);
        else
            me.SetCp(cp, ptp);

        // And measure from there to where we are
        me.NewLine(*rp);

        Assert(rp.IsValid());

        me._li._xLeft = rp.oi()->_xLeft;
        me._li._xLeftMargin = rp.oi()->_xLeftMargin;
        me._li._xWidth = rp->_xWidth;
        me._li._xRight = rp->_xRight;
        me._li._xRightMargin = rp.oi()->_xRightMargin;
        me._li._fRTLLn = rp->_fRTLLn;

        // can we also add the _cch and _cchWhite here so we can pass them to 
        // the BidiLine stuff?
        me._li._cch = rp->_cch;
        me._li._cchWhite = rp.oi()->_cchWhite;

        LONG xCalc = me.MeasureText(rp.RpGetIch(), rp->_cch, fAfterPrevCp, pfComplexLine, pfRTLFlow, &rubyInfo);

        // Remember we ignore trailing spaces at the end of the line
        // in the width, therefore the x value that MeasureText finds can
        // be greater than the width in the line so we truncate to the
        // previously calculated width which will ignore the spaces.
        // pt.x += min(xCalc, rp->_xWidth);
        //
        // Why anyone would want to ignore the trailing spaces at the end
        // of the line is beyond me. For certain, we DON'T want to ignore
        // them when placing the caret at the end of a line with trailing
        // spaces. If you can figure out a reason to ignore the spaces,
        // please do, just leave the caret placement case intact. - Arye
        if (!fRTLLine)
            pt.x += xCalc;
        else
            pt.x -= xCalc;
    }

    if (prp)
        *prp = rp;

    if(rp >= 0 && taMode != TA_TOP)
    {
        // Check for vertical calculation request
        if (taMode & TA_BOTTOM)
        {
            const CLineCore *pli = Elem(rp);
            const CLineOtherInfo *ploi = pli->oi();
            
            if(pli && ploi)
            {
                pt.y += pli->_yHeight;
                if ( rubyInfo.cp != -1 && !fAtEndOfRubyBase )
                {
                    pt.y -= rubyInfo.yHeightRubyBase + ploi->_yDescent - ploi->_yTxtDescent;
                }
                
                if (!pli->IsFrame() &&
                    (taMode & TA_BASELINE) == TA_BASELINE)
                {
                    if ( rubyInfo.cp != -1 && !fAtEndOfRubyBase )
                    {
                        pt.y -= rubyInfo.yDescentRubyText;
                    }
                    else
                    {
                        pt.y -= ploi->_yDescent;
                    }
                }
            }
        }

        // Do any specical horizontal calculation
        if (taMode & TA_CENTER)
        {
            CLSMeasurer me(this, pci);

            if (!me._pLS)
                return -1;

            me.SetCp(cp, ptp);

            me.NewLine(*rp);

            pt.x += (me.MeasureText(1, rp->_cch) >> 1);
        }
    }

    return rp;
}
#if DBG==1
#pragma warning(default:4189) // local variable initialized but not used 
#endif

//+----------------------------------------------------------------------------
//
// Function:    AppendRectToElemRegion
//
// Synopsis:    Utility function for region from element, which appends the
//              given rect to region if it is within the clip range and
//              updates the bounding rect.
//
//-----------------------------------------------------------------------------
void  AppendRectToElemRegion(CDataAry <RECT> * paryRects, RECT * prcBound,
                             RECT * prcLine, CPoint & ptTrans,
                             LONG cp, LONG cpClipStart, LONG cpClipFinish
                             )
{
    if(ptTrans.x || ptTrans.y)
        OffsetRect(prcLine, ptTrans.x, ptTrans.y);

    if(cp >= cpClipStart && cp <= cpClipFinish)
    {
        paryRects->AppendIndirect(prcLine);
    }

    if(prcBound)
    {
        if(!IsRectEmpty(prcLine))
        {
            UnionRect(prcBound, prcBound, prcLine);
        }
        else if (paryRects->Size() == 1)
        {
            *prcBound = *prcLine;
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:    RcFromAlignedLine
//
// Synopsis:    Utility function for region from element, which computes the
//              rect for a given aligned line
//
//-----------------------------------------------------------------------------
void
RcFromAlignedLine(RECT * prcLine, CLineCore * pli, CLineOtherInfo *ploi, LONG yPos,
                  BOOL fBlockElement, BOOL fFirstLine, BOOL fRTLDisplay,
                  long xParentLeftIndent, long xParentRightIndent)
{
    CSize size;

    long xProposed = pli->AO_GetXProposed(ploi);
    long yProposed = pli->AO_GetYProposed(ploi);

    pli->AO_GetSize(ploi, &size);

    // add the curent line to the region
    prcLine->top = yProposed + yPos + ploi->_yBeforeSpace;

    if(!fRTLDisplay)
    {
        prcLine->left = xProposed + ploi->_xLeftMargin + ploi->_xLeft;
        prcLine->right = prcLine->left + size.cx;
    }
    else
    {
        prcLine->right = ploi->_xLeftMargin + pli->_xLineWidth + ploi->_xNegativeShiftRTL - pli->_xRight - xProposed;
        prcLine->left = prcLine->right - size.cx;
    }

    prcLine->bottom = prcLine->top + size.cy;
}

//+----------------------------------------------------------------------------
//
// Function:    ComputeIndentsFromParentNode
//
// Synopsis:    Compute the indent for a given Node and a left and/or
//              right aligned site that a current line is aligned to.
//
//-----------------------------------------------------------------------------

void 
CDisplay::ComputeIndentsFromParentNode(CCalcInfo * pci,         // (IN)
                                       CTreeNode * pNode,       // (IN) node we want to compute indents for
                                       DWORD  dwFlags,          // (IN) flags from RFE
                                       LONG * pxLeftIndent,     // (OUT) the node is indented this many pixels from left edge of the layout
                                       LONG * pxRightIndent)    // (OUT) ...
{
    CElement  * pElement = pNode->Element();
    CElement  * pElementFL = GetFlowLayoutElement();
    LONG        xParentLeftPadding = 0, xParentRightPadding = 0;
    LONG        xParentLeftBorder = 0, xParentRightBorder = 0;

    const CParaFormat *pPF = pNode->GetParaFormat();
    BOOL  fInner = pNode->Element() == pElementFL;

    Assert(pNode);

    LONG xParentWidth = pci->_sizeParent.cx;
    if (   pPF->_cuvLeftIndentPercent.GetUnitValue()
        || pPF->_cuvRightIndentPercent.GetUnitValue()
       )
    {
        xParentWidth = pNode->GetParentWidth(pci, xParentWidth);
    }
    
    // GetLeft/RightIndent returns the cumulative CSS margin (+ some other gunk
    // like list bullet offsets).
    
    LONG xLeftMargin  = pPF->GetLeftIndent(pci, fInner, xParentWidth);
    LONG xRightMargin = pPF->GetRightIndent(pci, fInner, xParentWidth);

    // We only want to include the area for the bullet for hit-testing;
    // we _don't_ draw backgrounds and borders around the bullet for list items.
    if (    dwFlags == RFE_HITTEST
        &&  pPF->_bListPosition != styleListStylePositionInside
        &&  (   IsGenericBlockListItem(pNode)
            ||  pElement->IsFlagAndBlock(TAGDESC_LIST)))

    {
        if (!pPF->HasRTL(fInner))
        {
            xLeftMargin -= pPF->GetBulletOffset(pci);
        }
        else
        {
            xRightMargin -= pPF->GetBulletOffset(pci);
        }
    }

    // Compute the padding and border space cause by the current
    // element's ancestors (up to the layout).
    if ( pNode->Element() == pElementFL )
    {
        // If the element in question is actually the layout owner,
        //b then we don't want to offset by our own border/padding,
        // so set the values to 0.
        Assert(xParentLeftPadding + xParentLeftBorder +
               xParentRightPadding + xParentRightBorder == 0);
    }
    else
    {
        // We need to get the cumulative sum of our ancestor's borders/padding.
        if (pNode->Parent())
            pNode->Parent()->Element()->ComputeHorzBorderAndPadding( pci, 
                                pNode->Parent(),     pElementFL,
                                &xParentLeftBorder,  &xParentLeftPadding,
                                &xParentRightBorder, &xParentRightPadding );
                                
        // The return results of ComputeHorzBorderAndPadding() DO NOT include
        // the border or padding of the layout itself; this makes sense for
        // borders, because the layout's border is outside the bounds we're
        // interested in.  However, we do want to account for the layout's
        // padding since that's inside the bounds.  We fetch that separately
        // here, and add it to the cumulative padding.

        long lPadding[SIDE_MAX];
        GetPadding( pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH );
        
        xParentLeftPadding += lPadding[SIDE_LEFT];
        xParentRightPadding += lPadding[SIDE_RIGHT];
    }

    // The element is indented by the sum of CSS margins and ancestor
    // padding/border.  This indent value specifically ignores aligned/floated
    // elements, per CSS!
    *pxLeftIndent = xLeftMargin + xParentLeftBorder + xParentLeftPadding;
    *pxRightIndent = xRightMargin + xParentRightBorder + xParentRightPadding;
}

//+----------------------------------------------------------------------------
//
// Member:      RegionFromElement
//
// Synopsis:    for a given element, find the set of rects (or lines) that this
//              element occupies in the display. The rects returned are relative
//              the site origin.
//              Certain details about the returned region are determined by the
//              call type parameter:..
//
//-----------------------------------------------------------------------------

void
CDisplay::RegionFromElement(CElement       * pElement,  // (IN)
                            CDataAry<RECT> * paryRects, // (OUT)
                            CPoint         * pptOffset, // == NULL, point to offset the rects by (IN param)
                            CFormDrawInfo  * pDI,       // == NULL
                            DWORD dwFlags,              // == 0
                            LONG cpClipStart,           // == -1, (IN)
                            LONG cpClipFinish,          // == -1, (IN) clip range
                            RECT * prcBound             // == NULL, (OUT param) returns bounding rect that ignores clipping
                            )
{
    RegionFromElementCore(pElement,     paryRects,
                          pptOffset,    pDI,
                          dwFlags,      cpClipStart,
                          cpClipFinish, prcBound);
    
    if (dwFlags & RFE_SCREENCOORD)
    {
        CFlowLayout *       pFL = GetFlowLayout();
        // Transform the relative offset to global coords if caller specified
        // RFE_SCREENCOORD.        
        for (LONG i = 0; i < paryRects->Size(); i++)
        {
            pFL->TransformRect(&paryRects->Item(i), COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
        }
        if (prcBound)
            pFL->TransformRect(prcBound,  COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
    }
}

void
CDisplay::RegionFromElementCore(CElement       * pElement,  // (IN)
                           CDataAry<RECT> * paryRects, // (OUT)
                           CPoint         * pptOffset, // == NULL, point to offset the rects by (IN param)
                           CFormDrawInfo  * pDI,       // == NULL
                           DWORD dwFlags,              // == 0
                           LONG cpClipStart,           // == -1, (IN)
                           LONG cpClipFinish,          // == -1, (IN) clip range
                           RECT * prcBound             // == NULL, (OUT param) returns bounding rect that ignores clipping
                          )
{
    CFlowLayout *       pFL = GetFlowLayout();
    CElement *          pElementFL = pFL->ElementOwner();
    CTreePos *          ptpStart;
    CTreePos *          ptpFinish;
    CCalcInfo           CI;
    RECT                rcLine;
    CRect               rcClipWork = g_Zero.rc;        // RECT used for doing various fClipVisible work
    CPoint              ptTrans = g_Zero.pt;
    LONG                cchAdvance = 0;

    Assert( pElement->IsInMarkup() );

    // clear the array before filling it
    paryRects->SetSize(0);
    if(prcBound)
        memset(prcBound, 0, sizeof(RECT));

    if(pElementFL->IsDisplayNone() || !pElement || pElement->IsDisplayNone() ||
       (pElement->Tag() == ETAG_ROOT && !pElement->HasMasterPtr()) || 
       (pElementFL->Tag() == ETAG_ROOT && !pElementFL->HasMasterPtr()) )
        return;

    if (pElement == pElementFL)
    {
        pFL->GetContentTreeExtent(&ptpStart, &ptpFinish);
    }
    else
    {
        pElement->GetTreeExtent(&ptpStart, &ptpFinish);
    }
    Assert(ptpStart && ptpFinish);

    // now that we have the scope of the element, find its range.
    // and compute the rects (lines) that contain the range.
    {
        CTreePos          * ptpElemStart;
        CTreePos          * ptpElemFinish;
        CTreeNode         * pNode = pElement->GetFirstBranch();
        CLSMeasurer         me(this, pDI);
        CMarkup           * pMarkup = pFL->GetContentMarkup();
        BOOL                fBlockElement;
        BOOL                fTightRects = (dwFlags & RFE_TIGHT_RECTS);
        BOOL                fIgnoreBlockness = (dwFlags & RFE_IGNORE_BLOCKNESS);
        BOOL                fIncludeAlignedElements = !(dwFlags & RFE_IGNORE_ALIGNED);
        BOOL                fIgnoreClipForBoundRect = (dwFlags & RFE_IGNORE_CLIP_RC_BOUNDS);
        BOOL                fIgnoreRel = (dwFlags & RFE_IGNORE_RELATIVE);
        BOOL                fNestedRel = (dwFlags & RFE_NESTED_REL_RECTS);
        BOOL                fScrollIntoView = (dwFlags & RFE_SCROLL_INTO_VIEW);
        BOOL                fClipToVisible = (dwFlags & RFE_CLIP_TO_VISIBLE); // perf optimization; if true, don't compute region for lines that aren't visible
        BOOL                fOnlyBackground = (dwFlags & RFE_ONLY_BACKGROUND);
        BOOL                fNoExtent = (dwFlags & RFE_NO_EXTENT) ? TRUE : FALSE;
        BOOL                fNeedToMeasureLine;
        LONG                cp, cpStart, cpFinish, cpElementLast;
        LONG                cpElementStart, cpElementFinish;
        LONG                iCurLine, iFirstLine, ich;
        LONG                yPos;
        LONG                xParentRightIndent = 0;
        LONG                xParentLeftIndent = 0;
        LONG                yTop;
        BOOL                fFirstLine;
        CLinePtr            rp(this);
        BOOL                fRestorePtTrans = FALSE;
        CStackDataAry<CChunk, 8> aryChunks(Mt(CDisplayRegionFromElement_aryChunks_pv));

        if (!me._pLS)
            goto Cleanup;
    
        // Do we treat the element we're finding the region for
        // as a block element?  Things that influence this decision:
        // If RFE_SELECTION was specified, it means we're doing
        // finding a region for selection, which is always character
        // based (never block based).  RFE_SELECTION causes fIgnoreBlockness to light up.
        // The only time RFE should get called on an element that
        // needs layout is when the pElement == pElementFL.  When
        // this happens, even though the element _is_ block, we
        // want to treat it as though it isn't, since the caller
        // in this situation wants the rects of some text that's
        // directly under the layout (e.g. "x" in <BODY>x<DIV>...</DIV></BODY>)
        // NOTE: (KTam) this would be a lot more obvious if we changed
        // the !pElement->ShouldHaveLayout() condition to pElement != pElementFL
        fBlockElement =  !fIgnoreBlockness &&
                          pElement->IsBlockElement() &&
                         !pElement->ShouldHaveLayout();          
    
        if (pDI)
        {
            CI.Init(pDI, pFL);
        }
        else
        {
            CI.Init(pFL);
        }
    
        long            xParentWidth;
        long            yParentHeight;
        // Fetch parent's width and height (i.e. view width & height minus padding)
        GetViewWidthAndHeightForChild(&CI, &xParentWidth, &yParentHeight);
        CI.SizeToParent(xParentWidth, yParentHeight);
    
        // If caller hasn't specified non-relative behaviour, then account for
        // relativeness on the layout by fetching the relative offset in ptTrans.
        if(!fIgnoreRel)
            pNode->GetRelTopLeft(pElementFL, &CI, &ptTrans.x, &ptTrans.y);
    
        // Combine caller-specified offset (if any) into relative offset.
        if(pptOffset)
        {
            ptTrans.x += pptOffset->x;
            ptTrans.y += pptOffset->y;
        }

        cpStart  = pFL->GetContentFirstCpForBrokenLayout();
        cpFinish = pFL->GetContentLastCpForBrokenLayout();
    
        // get the cp range for the element
        cpElementStart  = ptpStart->GetCp();
        cpElementFinish = ptpFinish->GetCp();
    
        // Establish correct cp's and treepos's, including clipping stuff..
        // We may have elements overlapping multiple layout's, so clip the cp range
        // to the current flow layout's bounds,
        cpStart       = max(cpStart, cpElementStart);
        cpFinish      = min(cpFinish, cpElementFinish);
        cpElementLast = cpFinish;
    
        // clip cpFinish to max calced cp
        cpFinish      = min(cpFinish, GetMaxCpCalced());
    
        if( cpStart != cpElementStart )
            ptpStart  = pMarkup->TreePosAtCp(cpStart, &ich);
        ptpElemStart = ptpStart;
    
        if( cpFinish != cpElementFinish )
            ptpFinish = pMarkup->TreePosAtCp(cpFinish, &ich);
        ptpElemFinish = ptpFinish;

        // This is a perf optimization for drawing backgrounds of large elements:
        // if only part of the element is visible, there's no point computing the region
        // of the element that isn't visible, since we're not going to draw there.
        if ( fClipToVisible )
        {
            // If we have been asked to clip to the visible region, start from the first visible cp...
            LONG cpFirstVisible;

            pFL->_pDispNode->GetClippedBounds( &rcClipWork, COORDSYS_FLOWCONTENT );

            if (LineFromPos( rcClipWork, NULL, &cpFirstVisible, 0) < 0 )
                goto Cleanup;

            cpStart = max(cpStart, cpFirstVisible);

            // The client rect of the display's layout determines the
            // visible area we clip to.  From now on, each time we finish
            // processing a line, we see whether we've gone past the bottom
            // of the visible area.
            pFL->GetClientRect( &rcClipWork );   // store client rect in rcClipWork so we can check in later before appending rects

            TraceTagEx((tagRFEClipToVis, TAG_NONAME,
                        "RFE Clip To Visible: FL(0x%x,e=0x%x,%S, dn=0x%x) E(0x%x,%S), cpStart=%d, ClipRect(%d,%d,%d,%d), ptTrans(%d,%d) ptOffset(%d,%d)",
                        pFL,
                        pFL->ElementOwner(),
                        pFL->ElementOwner()->TagName(),
                        pFL->_pDispNode,
                        pElement,
                        pElement->TagName(),
                        cpStart,
                        rcClipWork.top, rcClipWork.left, rcClipWork.bottom, rcClipWork.right,
                        ptTrans.x, ptTrans.y,
                        pptOffset->x, pptOffset->y));
        }
    
        if(cpClipStart < cpStart)
            cpClipStart = cpStart;
        if(cpClipFinish == -1 || cpClipFinish > cpFinish)
            cpClipFinish = cpFinish;

        // VS7 has a scenario where this happens (bug #101633)
        if(cpClipStart > cpClipFinish)
            cpClipStart = cpClipFinish;

        if ( !fIgnoreClipForBoundRect )
        {
            if(cpStart != cpClipStart)
            {
                cpStart  = cpClipStart;
                ptpStart = pMarkup->TreePosAtCp(cpStart, &ich);
            }
            if(cpFinish != cpClipFinish)
            {
                cpFinish = cpClipFinish;
                ptpFinish = pMarkup->TreePosAtCp(cpFinish, &ich);
            }
        }
    
        if(!LineCount())
            return;
    
        // NOTE: we pass in absolute cp here so RpSetCp must call
        // pElementFL->GetFirstCp while we have just done this.  We
        // should optimize this out by having a relative version of RpSetCp.
    
        // skip frames and position it at the beginning of the line
        rp.RpSetCp(cpStart, /* fAtEnd = */ FALSE, TRUE, /* fSupportBrokenLayout= */ TRUE);
        
        // (cpStart - rp.GetIch) == cp of beginning of line (pointed to by rp)
        // If fFirstLine is true, it means that the first line of the element
        // is within the clipping range (accounted for by cpStart).
        fFirstLine = cpElementStart >= cpStart - rp.GetIch();

        // Assert( cpStart != cpFinish );
        // Update 12/09/98: It is valid for cpStart == cpFinish
        // under some circumstances!  When a hyperlink jump is made to
        // a local anchor (#) that's empty (e.g. <A name="foo"></A>, 
        // the clipping range passed in is empty! (HOT bug 60358)
        // If the element has no content then return the null rectangle
        if(cpStart == cpFinish)
        {
            me._li = *Elem(rp);
            
            yPos = YposFromLine(&CI, rp, NULL);

            rcLine.top = yPos + me._li.GetYTop();
            rcLine.bottom = yPos + me._li.GetYBottom();

            rcLine.left = me._li.GetTextLeft();

            if(rp.GetIch())
            {
                me.SetCp(cpStart - rp.GetIch(), NULL);
                rcLine.left +=  me.MeasureText(rp.RpGetIch(), me._li._cch);
            }
            rcLine.right = rcLine.left;

            AppendRectToElemRegion(paryRects, prcBound, &rcLine,
                                    ptTrans,
                                    cpStart, cpClipStart, cpClipFinish
                                    );
            return;
        }
    
        iCurLine = iFirstLine = rp;
    
        // Now that we know what line contains the cp, let's try to compute the
        // bounding rectangle.
    
        // If the line has aligned images in it and if they are at the begining of the
        // the line, back up all the frame lines that are before text and contained
        // within the element of interest.  This only necessary when doing selection
        // and hit testing, since the region for borders/backgrounds ignores aligned
        // and floated stuff.
    
        // (recall rp is like a smart ptr that points to a particular cp by
        // holding a line index (ili) AND an offset into the line's chars
        // (ich), and that we called CLinePtr::RpSetCp() some time back.
    
        // (recall frame lines are those that were created expressly for
        // aligned elems; they are the result of "breaking" a line, which
        // we had to do when we were measuring and saw it had aligned elems)
        
        if ( fIncludeAlignedElements  && rp->HasAligned() )
        {
            LONG diLine = -1;
            CLineCore * pli;
    
            // rp[x] means "Given that rp is indexing line y, return the
            // line indexed by y - x".
    
            // A line is "blank" if it's "clear" or "frame".  Here we
            // walk backwards through the line array until all consecutive
            // frame lines before text are passed.
            while((iCurLine + diLine >= 0) && (pli = &rp[diLine]) && pli->IsBlankLine())
            {
                // Stop walking back if we've found a frame line that _isn't_ "before text",
                // or one whose ending cp is prior to the beginning of our clipping range
                // (which means it's not contained in the element of interest)
                // Consider: <div><img align=left><b><img align=left>text</b>
                // The region for the bold element includes the 2nd image but
                // not the 1st, but both frame lines will show up in front of the bold line.
                // The logic below notes that the last cp of the 1st img is before the cpStart
                // of the bold element, and breaks so we don't include it.
                if (pli->IsFrame())
                {
                    CLineOtherInfo *ploi = pli->oi();
                    LONG cpLine;

                    if (ploi->_fHasFloatedFL)
                        cpLine = CpFromLine(rp + diLine);
                    else
                        cpLine = -1;
                        
                    if  (   !pli->_fFrameBeforeText
                         ||  pli->AO_GetLastCp(ploi, cpLine) < cpStart
                        )
                    {
                        break;
                    }
                }
    
                diLine--;
            }
            iFirstLine = iCurLine + diLine + 1;
        }
    
        // compute the ypos for the first line
        yTop = yPos = YposFromLine(&CI, iFirstLine, NULL);
    
        // For calls other than backgrounds/borders, add all the frame lines
        // before the current line under the influence of
        // the element to the region.
    
        if ( fIncludeAlignedElements )
        {
            for ( ; iFirstLine < iCurLine; iFirstLine++)
            {
                CLineCore * pli = Elem(iFirstLine);
                // If the element of interest is block level, find out
                // how much it's indented (left and right) in from its
                // parent layout.
                if (fBlockElement)
                {
                    CTreeNode * pNodeTemp = pMarkup->SearchBranchForScopeInStory(ptpStart->GetBranch(), pElement);
                    if (pNodeTemp)
                    {
                        //Assert(pNodeTemp);
                        ComputeIndentsFromParentNode( &CI, pNodeTemp, dwFlags,
                                                      &xParentLeftIndent,
                                                      &xParentRightIndent);
                    }
                }
    
                // If it's a frame line, add the line's rc to the region.
                if (pli->IsFrame())
                {
                    LONG cpLine;
                    CLineOtherInfo *ploi = pli->oi();
                    
                    if (ploi->_fHasFloatedFL)
                        cpLine = CpFromLine(iFirstLine);
                    else
                        cpLine = -1;
                    long cpLayoutStart  = pli->AO_GetFirstCp(ploi, cpLine);
                    long cpLayoutFinish = pli->AO_GetLastCp(ploi, cpLine);
    
                    if (cpLayoutStart >= cpStart && cpLayoutFinish <= cpFinish)
                    {
                        RcFromAlignedLine(&rcLine, pli, ploi, yPos,
                                            fBlockElement, fFirstLine, IsRTLDisplay(),
                                            xParentLeftIndent, xParentRightIndent);
    
                        AppendRectToElemRegion(paryRects, prcBound, &rcLine,
                                               ptTrans,
                                               cpFinish, cpClipStart, cpClipFinish
                                               );
                    }
                }
                // if it's not a frame line, it MUST be a clear line (since we
                // only walked by while seeing blank lines).  All clear lines
                // force a new physical line, so account for change in yPos.
                else
                {
                    Assert( pli->IsClear() && pli->_fForceNewLine );
                    yPos += pli->_yHeight;
                }
            }
        }
    
        // now add all the lines that are contained by the range
        for ( cp = cpStart; cp <= cpFinish; iCurLine++ )
        {
            BOOL    fRTLLine;
            LONG    xStart = 0;
            LONG    xEnd = 0;
            long    yTop, yBottom;
            CLineCore * pli;
            CLineOtherInfo *ploi;
            LONG    i;
            LONG    cChunk;
            CPoint  ptTempForPtTrans = ptTrans;
                    
            Assert(!fRestorePtTrans);

            //---------------------------------------------------------------------------
            //
            // HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK!
            //
            //
            // Originally, the loop used to be of the form:
            //  for (cp = cpStart; cp < cpFinish; iCurLine++)
            //  { ....
            // What this meant was that the line containing the last character would
            // *never* get processed! While this might be desired behaviour under
            // certain circumstances, in a lot of cases it is a bad thing to do.
            // We have such a case when we have a bottom border on a block element,
            // and we have another block element nested inside it. What ends up
            // happening is that we have a single line which contains the end ptp
            // of the block element which has the border. If the current hack were
            // not there then the border will not have the correct height, since the
            // last line (containing the end ptp and the bottom border width) will
            // not get accounted for.
            //
            // To get around this problem, I changed the loop to be *cp <= cpFinish*
            // so now we get a chance to look at the line containing the last
            // character. Howerver, we do not want to do this in all situations,
            // hence there are some qualifying conditions for us to include the last
            // line in the computations:
            //
            // Qualifying condition (QC1): We should be at the last character.
            if (cp == cpFinish)
            {
                // QC2: There should be more lines which we can look at
                // QC3: That line should be a special line -- one which should be
                //      considered for inclusion. We marked the line as such when
                //      we created the line
                // QC4: We should be at the beginning of the line. We are not at BOL
                //      in cases where the end splay is on the same line as the rest
                //      of the characters (happens when the end block element has
                //      no nested block elements). In this situation, rp is positioned
                //      just before the last ptp.
                // QC5: If we had consecutive lines which were marked _fIsPadBordLine,
                //      then we should consume only one. Lets say we consumed the
                //      the first one (when cp == cpFinish). During attempting to
                //      advance to the next positon, the code below will notice that
                //      it is already at cpFinish and hence will not advance, giving
                //      cchAdvance==0.
                //
                // Any problems with the QCs? Please talk with either SujalP or KTam.
                //
                if(   iCurLine >= LineCount()
                   || !Elem(iCurLine)->oi()->_fIsPadBordLine
                   || rp.GetIch() != 0
                   || cchAdvance == 0
                  )
                {
                    break;
                }
            }
            else
                
            //
            // HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! 
            //---------------------------------------------------------------------------
                
            {
                if ( iCurLine >= LineCount() )
                {
                    // (srinib) - please check with one of the text
                    // team members if anyone hits this assert. We want
                    // to investigate. We shoud never be here unless
                    // we run out of memory.
                    AssertSz(FALSE, "WaitForRecalc failed to measure lines till cpFinish");
                    break;
                }
            }
            
            cchAdvance = min(rp.GetCchRemaining(), cpFinish - cp);
            pli = Elem(iCurLine);
            ploi = pli->oi();
            
            // When drawing backgrounds, we skip frame lines contained
            // within the element (since aligned stuff doesn't affect our borders/background)
            // but for hit testing and selection we need to account for them.
            if ( !fIncludeAlignedElements  && pli->IsFrame() )
            {
                goto AdvanceToNextLineInRange;
            }

            // If we are drawing background, and we hit a line which was
            // created only for drawing the block borders, then skip its
            // height (bug 84595).
            if (fOnlyBackground && ploi->_fIsPadBordLine)
            {
                // We do this only for the first line (see bug 100949).
                if (fFirstLine)
                    goto AdvanceToNextLineInRange;

                // Really the right thing to do here to fix bothe 84595 and 100949
                // correctly is to create a dummy line for empty divs with
                // background.
            }
                
            // If line is relative then add in the relative offset
            // In the case of Wigglys we ignore the line's relative positioning, but want any nested
            // elements to be handled CLineServices::CalcRectsOfRangeOnLine
            if (   fNestedRel 
                && pli->_fRelative
               )
            {
                CPoint ptTemp;
                CTreeNode *pNodeNested = pMarkup->TreePosAtCp(cp, &ich)->GetBranch();

                // We only want to adjust for nested elements that do not have layouts. The pElement
                // we passed in is handled by the fIgnoreRel flag. Layout elements are handled in
                // CalcRectsOfRegionOnLine
                if(    pNodeNested->Element() != pElement 
                   && !pNodeNested->ShouldHaveLayout()
                  )
                {
                    pNodeNested->GetRelTopLeft(pElementFL, &CI, &ptTemp.x, &ptTemp.y);
                    ptTempForPtTrans = ptTrans;
                    if(!fIgnoreRel)
                    {
                        ptTrans.x = ptTemp.x - ptTrans.x;
                        ptTrans.y = ptTemp.y - ptTrans.y;
                    }
                    else
                    {
                        // We were told to ignore the pElement's relative positioning. Therefore
                        // we only want to adjust by the amount of the nested element's relative
                        // offset from pElement
                        long xElemRelLeft = 0, yElemRelTop = 0;
                        pNode->GetRelTopLeft(pElementFL, &CI, &xElemRelLeft, &yElemRelTop);
                        ptTrans.x = ptTemp.x - xElemRelLeft;
                        ptTrans.y = ptTemp.y - yElemRelTop;
                    }
                    fRestorePtTrans = TRUE;
                }
            }
            
            fRTLLine = pli->_fRTLLn;
    
            // If the element of interest is block level, find out
            // how much it's indented (left and right) in from its
            // parent layout.
            if ( fBlockElement )
            {
                if ( cp != cpStart )
                {
                    ptpStart = pMarkup->TreePosAtCp(cp, &ich);
                }
    
                CTreeNode * pNodeTemp = pMarkup->SearchBranchForScopeInStory(ptpStart->GetBranch(), pElement);
                // (fix this for IE5:RTM, #46824) srinib - if we are in the inclusion, we
                // wont find the node.
                if ( pNodeTemp )
                {
                    //Assert(pNodeTemp);
                    ComputeIndentsFromParentNode( &CI, pNodeTemp, dwFlags,
                                                  &xParentLeftIndent,
                                                  &xParentRightIndent);
                }
            }
    
            // For RTL lines, we will work from the right side. LTR lines work
            // from the left, of course.
            if ( fBlockElement )
            {
                // Block elems, except when processing selection:
                
                // _fFirstFragInLine means it's the first logical line (chunk) in the physical line.
                // If that is the case, the starting edge is just the indent from the parent
                // (margin due to floats is ignored).
                // If it's not the first logical line, then treat element as though it were inline.
                xStart = (!fRTLLine)
                         ? /*LTR*/ (IsLogicalFirstFrag(iCurLine) ? xParentLeftIndent  : ploi->_xLeftMargin  + ploi->_xLeft)
                         : /*RTL*/ (IsLogicalFirstFrag(iCurLine) ? xParentRightIndent : ploi->_xRightMargin + pli->_xRight);
                         
                // _fForceNewLine means it's the last logical line (chunk) in a physical line.
                // If that is the case, the line or view width includes the parent's right indent,
                // so we need to subtract it out.  We also do this for dummy lines (actually,
                // we should think about whether it's possible to skip processing of dummy lines altogether!)
                // Otherwise, xLeftMargin+xLineWidth doesn't already include parent's right indent
                // (because there's at least 1 other line to the right of this one), so we don't
                // need to subtract it out, UNLESS the line is right aligned, in which case
                // it WILL include it so we DO need to subtract it (wheee..).
                xEnd = (!fRTLLine)
                       ? /*LTR*/ 
                         ( ( pli->_fForceNewLine || pli->_fDummyLine )
                         ? max(pli->_xLineWidth, GetViewWidth() ) - xParentRightIndent
                         : ploi->_xLeftMargin  + pli->_xLineWidth - (pli->IsRightAligned() ? xParentRightIndent : 0))
                       : /*RTL*/ 
                         ( ( pli->_fForceNewLine || pli->_fDummyLine )
                         ? max(pli->_xLineWidth, GetViewWidth() ) - xParentLeftIndent
                         : ploi->_xRightMargin + pli->_xLineWidth - (pli->IsLeftAligned()  ? xParentLeftIndent  : 0));
            }
            else
            {
                // Inline elems, and all selections begin at the text of
                // the element, which is affected by margin.
                xStart = (!fRTLLine)
                         ? ploi->_xLeftMargin  + ploi->_xLeft
                         : ploi->_xRightMargin + pli->_xRight;
                         
                // GetTextRight() tells us where the text ends, which is
                // just what we want.
                xEnd = (!fRTLLine)
                       ? pli->GetTextRight(ploi, iCurLine == LineCount() - 1)
                       : pli->GetRTLTextLeft(ploi);
                // Only include whitespace for selection
                if ( fIgnoreBlockness )
                {
                    xEnd += ploi->_xWhite;
                }
            }
    
            if (xEnd < xStart)
            {
                // Only clear lines can have a _xLineWidth < _xWidth + _xLeft + _xRight ...

                // (grzegorz) In case of negative letter spacing we may assert here.
                // Since there is no easy way to get letter spacing information for the line
                // this assert is disabled.
                // Assert(pli->IsClear());

                xEnd = xStart;
            }
    
            // Set the top and bottom
            if (fBlockElement)
            {
                LONG yLIBottom = pli->_yHeight;
                LONG yLITopOff = 0;
                LONG yLITop = 0;

                if (!fNoExtent)
                {
                    yLIBottom = pli->GetYBottom(ploi);
                    yLITopOff = pli->GetYHeightTopOff(ploi);
                    yLITop    = pli->GetYTop(ploi);
                }
                
                yTop = yPos;
                yBottom = yPos + max(pli->_yHeight, yLIBottom);
    
                if (fFirstLine)
                {
                    yTop += ploi->_yBeforeSpace + min(0L, yLITopOff);
                    Assert(fNoExtent || yBottom >= yTop);
                }
                else
                {
                    yTop += min(0L, yLITop);
                }
            }
            else
            {
                yTop = yPos + pli->GetYTop(ploi);
                yBottom = yPos + pli->GetYBottom(ploi);

                // 66677: Let ScrollIntoView scroll to top of yBeforeSpace on first line.
                if (fScrollIntoView && yPos==0)
                    yTop = 0;
            }
    
            aryChunks.DeleteAll();
            cChunk = 0;
    
            // At this point we've found the bounds (xStart, xEnd, yTop, yBottom)
            // for a line that is part of the range.  Under certain circumstances,
            // this is insufficient, and we need to actually do measurement.  These
            // circumstances are:
            // 1.) If we're doing selection, we only need to measure partially
            // selected lines (i.e. at most we need to measure 2 lines -- the
            // first and the last).  For completely selected lines, we'll
            // just use the line bounds.  NOTE: this MAY introduce selection
            // turds, since LS uses tight-rects to draw the selection, and
            // our line bounds may not be as wide as LS tight-rects measurement
            // (recall that LS measurement catches whitespace that we sometimes
            // omit -- this may be fixable by adjusting our treatment of xWhite
            // and/or cchWhite).
            // Determination of partially selected lines is done as follows:
            // rp.GetIch() != 0 implies it starts mid-line,
            // rp.GetCchRemaining() != 0 implies it ends mid-line (the - _cchWhite
            // makes us ignore whitespace chars at the end of the line)
            // 2.) For all other situations, we're choosing to measure all
            // non-block elements.  This means that situations specifying
            // tight-rects (backgrounds, focus rects) will get them for
            // non-block elements (which is what we want), and hit-testing
            // will get the right rect if the element is inline and doesn't
            // span the entire line.  NOTE: there is a possible perf
            // improvement here; for hit-testing we really only need to
            // measure when the inline element doesn't span the entire line
            // (right now we measure when hittesting all inline elements);
            // this condition is the same as that for selecting partial lines,
            // however there may be subtler issues here that need investigation.
            if ( (dwFlags & RFE_SELECTION) == RFE_SELECTION )
            {
                fNeedToMeasureLine =    !rp->IsBlankLine()
                                     && (   rp.GetIch()
                                         || max(0L, (LONG)(rp.GetCchRemaining() - (fBlockElement ? rp->oi()->_cchWhite : 0))) > cchAdvance );
                // In case of drawing ellipsis turn off this mode.
                // We need to invalidate more then selection area only.
                if (fNeedToMeasureLine)
                {
                    fNeedToMeasureLine = !GetFlowLayout()->GetFirstBranch()->HasEllipsis();
                }
            }
            else
            {
                fNeedToMeasureLine = !fBlockElement;
            }


            if ( fNeedToMeasureLine )
            {
                // (KTam) why do we need to set the measurer's cp to the 
                // beginning of the line? (cp - rp.GetIch() is beg. of line)
                Assert(!rp.GetIch() || cp == cpStart);
                ptpStart = pMarkup->TreePosAtCp(cp - rp.GetIch(), &ich);
                me.SetCp(cp - rp.GetIch(), ptpStart);
                me._li = *pli;
                // Get chunk info for the (possibly partial) line.
                // Chunk info is returned in aryChunks.
                cChunk = me.MeasureRangeOnLine(pElement, rp.GetIch(), cchAdvance, *pli, yPos, &aryChunks, dwFlags);
                if (cChunk == 0)
                {
                    xEnd = xStart;
                }
            }

            // cChunk == 0 if we didn't need to measure the line, or if we tried
            // to measure it and MeasureRangeOnLine() failed.
            if ( cChunk == 0 )
            {
                rcLine.top = yTop;
                rcLine.bottom = yBottom; 
    
                // Adjust xStart and xEnd for RTL line rectangle alignment
                pli->AdjustChunkForRtlAndEnsurePositiveWidth(ploi, xStart, xEnd,
                                                             &rcLine.left, &rcLine.right);
                
                // If we're clipping to the visible area, check whether this
                // line comes after the visible area.
                if (   fClipToVisible
                    && rcLine.top + ptTrans.y + _yMostNeg >= rcClipWork.bottom   // And we have gone past the bottom
                   )
                {
                    goto Cleanup;                          // then stop
                }

                AppendRectToElemRegion(paryRects, prcBound, &rcLine,
                                       ptTrans,
                                       cp, cpClipStart, cpClipFinish
                                       );
    
            }
            else
            {
                Assert(aryChunks.Size() > 0);
    
                i = 0;
                while (i < aryChunks.Size())
                {
                    RECT rcChunk = aryChunks[i++];
                    LONG xStartChunk = xStart + rcChunk.left;
                    LONG xEndChunk;
    
                    // if it is the first or the last chunk, use xStart & xEnd
                    if (fBlockElement && (i == 1 || i == aryChunks.Size()))
                    {
                        if (i == 1)
                            xStartChunk = xStart;

                        if(i == aryChunks.Size())
                            xEndChunk = xEnd;
                        else
                            xEndChunk = xStart + rcChunk.right;
                    }
                    else
                    {
                         xEndChunk = xStart + rcChunk.right;
                    }
    
                    // Adjust xStart and xEnd for RTL line rectangle alignment
                    pli->AdjustChunkForRtlAndEnsurePositiveWidth(ploi, xStartChunk, xEndChunk,
                                                                 &rcLine.left, &rcLine.right);
    
                    if(!fTightRects)
                    {
                        rcLine.top = yTop;
                        rcLine.bottom = yBottom; 
                    }
                    else
                    {
                        rcLine.top = rcChunk.top;
                        rcLine.bottom = rcChunk.bottom; 
                    }
    
                    if (   fClipToVisible                                    // If we are clipping to visible
                        && rcLine.top + ptTrans.y + _yMostNeg >= rcClipWork.bottom   // And we have gone past the bottom
                       )
                    {
                        goto Cleanup;                          // then stop
                    }

                    AppendRectToElemRegion(paryRects, prcBound, &rcLine,
                                           ptTrans,
                                           cp, cpClipStart, cpClipFinish
                                           );
                }
            }
    
        AdvanceToNextLineInRange:

            if (fRestorePtTrans)
            {
                ptTrans = ptTempForPtTrans;
                fRestorePtTrans = FALSE;
            }
            
            cp += cchAdvance;
    
            if(cchAdvance)
            {
                rp.RpAdvanceCp(cchAdvance, FALSE);
            }
            else
                rp.AdjustForward(); // frame lines or clear lines
    
            if(pli->_fForceNewLine)
            {
                yPos += pli->_yHeight;
                fFirstLine = FALSE;
            }
        }
    
        // For calls for selection or hittesting (but not background/borders),
        // if the last line contains any aligned images, check to see if
        // there are any aligned lines following the current line that come
        // under the scope of the element
        if ( fIncludeAlignedElements )
        {
            if(!rp.GetIch())
                rp.AdjustBackward();
    
            iCurLine = rp;
    
            if(rp->HasAligned())
            {
                LONG diLine = 1;
                CLineCore * pli;
                CLineOtherInfo *ploi;
                
                // we dont have to worry about clear lines because, all the aligned lines that
                // follow should be consecutive.
                while((iCurLine + diLine < LineCount()) &&
                        (pli = &rp[diLine]) && pli->IsFrame() && !pli->_fFrameBeforeText)
                {
                    ploi = pli->oi();
                    LONG cpLine;

                    if (ploi->_fHasFloatedFL)
                        cpLine = CpFromLine(rp + diLine);
                    else
                        cpLine = -1;
                    
                    long cpLayoutStart  = pli->AO_GetFirstCp(ploi, cpLine);
                    long cpLayoutFinish = pli->AO_GetLastCp(ploi, cpLine);
    
                    if (fBlockElement)
                    {
                        CTreeNode * pNodeTemp = pMarkup->SearchBranchForScopeInStory (ptpFinish->GetBranch(), pElement);
                        if (pNodeTemp)
                        {
                            // Assert(pNodeTemp);
                            ComputeIndentsFromParentNode( &CI, pNodeTemp, dwFlags,
                                                          &xParentLeftIndent, 
                                                          &xParentRightIndent);
                        }
                    }
    
                    // if the current line is a frame line and if the site contained
                    // in it is contained by the current element include it other wise
                    if(cpStart <= cpLayoutStart && cpFinish >= cpLayoutFinish)
                    {
                        RcFromAlignedLine(&rcLine, pli, ploi, yPos,
                                            fBlockElement, fFirstLine, IsRTLDisplay(),
                                            xParentLeftIndent, xParentRightIndent);
    
                        AppendRectToElemRegion(paryRects, prcBound, &rcLine,
                                               ptTrans,
                                               cpFinish, cpClipStart, cpClipFinish
                                               );
                    }
                    diLine++;
                }
            }
        }
    }
Cleanup:
    return;
}


//+----------------------------------------------------------------------------
//
// Member:      RegionFromRange
//
// Synopsis:    Return the set of rectangles that encompass a range of
//              characters
//
//-----------------------------------------------------------------------------

void
CDisplay::RegionFromRange(
    CDataAry<RECT> *    paryRects,
    long                cp,
    long                cch )
{
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    long            cpFirst     = pFlowLayout->GetContentFirstCp();
    CLinePtr        rp(this);
    CLineCore *     pli;
    CLineOtherInfo *ploi;
    CRect           rc;
    long            ili;
    long            yTop, yBottom;

    if (    pFlowLayout->IsRangeBeforeDirty(cp - cpFirst, cch)
        &&  rp.RpSetCp(cp, FALSE, TRUE
        ))
    {
        //
        //  First, determine the starting line
        //

        ili = rp;

        if(rp->HasAligned())
        {
            while(ili > 0)
            {
                LONG cpLine;
                
                pli = Elem(ili);
                ploi = pli->oi();

                if (   pli->IsFrame()
                    && ploi->_fHasFloatedFL
                   )
                    cpLine = CpFromLine(ili);
                else
                    cpLine = -1;
                
                if (    !pli->IsFrame()
                    ||  !pli->_fFrameBeforeText
                    ||  pli->AO_GetFirstCp(ploi, cpLine) < cp)
                    break;

                Assert(pli->_cch == 0);
                ili--;
            }
        }

        //
        //  Start with an empty rectangle (whose width is that of the client rectangle)
        //

        GetFlowLayout()->GetClientRect(&rc);
            {
            rc.top    =
            rc.bottom = YposFromLine(NULL, rp, NULL);

            //
            // 1) There is no guarantee that cp passed in will be at the beginning of a line
            // 2) In the loop below we decrement cch by the count of chars in the line
            //
            // This would be correct if the cp passed in was the beginning of the line
            // but since it is not, we need to bump up the char count by the offset
            // of cp within the line. If at BOL then this would be 0. (bug 47687 fix 2)
            //
            cch += rp.RpGetIch();

            //
            //  Extend the rectangle over the affected lines
            //
            
            for (; cch > 0 && ili < LineCount(); ili++)
            {
                pli = Elem(ili);
                ploi = pli->oi();

                yTop    = rc.top + pli->GetYLineTop(ploi);
                yBottom = rc.bottom + pli->GetYLineBottom(ploi);

                rc.top    = min(rc.top, yTop);
                rc.bottom = max(rc.bottom, yBottom);

                // TODO: (dmitryt, track bug 112037) we need to get the right pNode.. how?
                // If the line is relative, apply its relative offset
                // to the rect
                /*
                if ( pli->_fRelative )
                {
                    long xRelOffset, yRelOffset;
                    CCalcInfo CI( pFlowLayout );

                    Assert( pNode );
                    pNode->GetRelTopLeft( pFlowLayout->ElementOwner(), &CI, &xRelOffset, &yRelOffset );

                    rc.top += yRelOffset;
                    rc.bottom += yRelOffset;
                }
                */

                Assert( !pli->IsFrame()
                    ||  !pli->_cch);
                cch -= pli->_cch;
            }
        }
        //
        //  Save the invalid rectangle
        //

        if (rc.top != rc.bottom)
        {
            paryRects->AppendIndirect(&rc);
        }
    }
}


//+----------------------------------------------------------------------------
//
// Member:      RenderedPointFromTp
//
// Synopsis:    Find the rendered position of a given cp. For cp that corresponds
//              normal text return its position in the line. For cp that points
//              to an aligned site find the aligned line rather than its poition
//              in the text flow. This function also takes care of relatively
//              positioned lines. Returns point relative to the display
//
//-----------------------------------------------------------------------------

LONG
CDisplay::RenderedPointFromTp(
    LONG        cp,         // point for the cp to be computed
    CTreePos *  ptp,        // tree pos for the cp passed in, can be NULL
    BOOL        fAtEnd,     // Return end of previous line for ambiguous cp
    POINT &     pt,         // Returns point at cp in client coords
    CLinePtr * const prp,   // Returns line pointer at tp (may be null)
    UINT taMode,            // Text Align mode: top, baseline, bottom
    CCalcInfo * pci,
    BOOL *pfRTLFlow)
{
    CFlowLayout * pFlowLayout = GetFlowLayout();
    CLayout     * pLayout = NULL;
    CElement    * pElementLayout = NULL;
    CLinePtr    rp(this);
    LONG        ili;
    BOOL        fAlignedSite = FALSE;
    CCalcInfo   CI;
    CTreeNode * pNode;

    if(!pci)
    {
        CI.Init(pFlowLayout);
        pci = &CI;
    }

    // initialize flow with current layout direction
    if (pfRTLFlow)
        *pfRTLFlow = IsRTLDisplay();

    if (pFlowLayout->IsDisplayNone() || !WaitForRecalc(cp, -1, pci))
        return -1;

    // now position the line array point to the cp in the rtp.
    // Skip frames, let us worry about them latter.
    if(!rp.RpSetCp(cp, FALSE))
        return -1;

    if(!ptp)
    {
        LONG ich;
        ptp = pFlowLayout->GetContentMarkup()->TreePosAtCp(cp, &ich, TRUE);
    }

    pNode   = ptp->GetBranch();
    pLayout = pNode->GetUpdatedNearestLayout(pFlowLayout->LayoutContext());

    if(pLayout != pFlowLayout)
    {
        pElementLayout = pLayout ? pLayout->ElementOwner() : NULL;

        // is the current run owner the txtsite, if not get the runowner
        if(rp->_fHasNestedRunOwner)
        {
            CLayout *   pRunOwner = pFlowLayout->GetContentMarkup()->GetRunOwner(pNode, pFlowLayout);

            if(pRunOwner != pFlowLayout)
            {
                pLayout = pRunOwner;
                pElementLayout = pLayout->ElementOwner();
            }
        }

        // if the site is left or right aligned and not a hr
        if (    !pElementLayout->IsInlinedElement()
            &&  !pElementLayout->IsAbsolute())
        {
            long    iDLine = -1;
            BOOL    fFound = FALSE;

            fAlignedSite = TRUE;

            // run back and forth in the line array and figure out
            // which line belongs to the current site

            // first pass let's go back, look at lines before the current line
            while(rp + iDLine >= 0 && !fFound)
            {
                CLineCore *pLine = &rp[iDLine];
                
                if(pLine->IsClear() || (pLine->IsFrame() && pLine->_fFrameBeforeText))
                {
                    if(pLine->IsFrame() && pElementLayout == pLine->AO_Element(NULL))
                    {
                        fFound = TRUE;

                        // now back up the linePtr to point to this line
                        rp.SetRun(rp + iDLine, 0);
                        break;
                    }
                }
                else
                {
                    break;
                }
                iDLine--;
            }

            // second pass let's go forward, look at lines after the current line.
            if(!fFound)
            {
                iDLine = 1;
                while(rp + iDLine < LineCount())
                {
                    CLineCore *pLine = &rp[iDLine];

                    // If it is a frame line
                    if(pLine->IsFrame() && !pLine->_fFrameBeforeText)
                    {
                        if(pElementLayout == pLine->AO_Element(NULL))
                        {
                            fFound = TRUE;

                            // now adjust the linePtr to point to this line
                            rp.SetRun(rp + iDLine, 0);
                            break;
                        }
                    }
                    else
                        break;
                    iDLine++;
                }
            }

            // if we didn't find an aligned line, we are in deep trouble.
            Assert(fFound);
        }
    }

    if(!fAlignedSite)
    {
        // If it is not an aligned site then use PointFromTp
        ili = PointFromTp(cp, ptp, fAtEnd, FALSE, pt, prp, taMode, pci, NULL, pfRTLFlow);
        if(ili > 0)
            rp.SetRun(ili, 0);
    }
    else
    {
        ili = rp;

        pt.y = YposFromLine(pci, rp, NULL);
        pt.x = rp.oi()->_xLeft + rp.oi()->_xLeftMargin;

        // TODO: (dmitryt, track bug 112026) This assert replaces following code 
        // because we don't know at the moment how to make HTML that gets us here.
        // Take a look at this one later.
        AssertSz(!_fRTLDisplay || !IsTagEnabled(tagDebugRTL), "RTL site in RenderedPointFromTp");

#if 0 // old RTL code. Note that usually, when we deal with right margin, we want to check 
      // for line RTL flag, not layout. If any special code is needed for RTL, this may be a bug
        if (IsRTLDisplay())
        {
            pt.x = rp->_xRight + rp.oi()->_xRightMargin;
        }
#endif

        if (prp)
            *prp = rp;

    }

    return rp;
}

/*
 *  CDisplay::UpdateViewForLists()
 *
 *  @mfunc
 *      Invalidate the number regions for numbered list items.
 *
 *  @params
 *      prcView:   The rect for this display
 *      tpFirst:  Where the change happened -- the place where we check for
 *                parentedness by an OL.
 *      iliFirst: The first line where we start checking for a line beginning a
 *                list item. It may not necessarily be the line containing
 *                tpFirst. Could be any line after it.
 *      yPos:     The yPos for the line iliFirst.
 *      prcInval: The rect which returns the invalidation region
 *
 *  @rdesc
 *      TRUE if updated anything else FALSE
 */
BOOL
CDisplay::UpdateViewForLists(
             RECT       *prcView,
             LONG        cpFirst,
             long        iliFirst,
             long        yPos,
             RECT       *prcInval)
{
    BOOL fHasListItem = FALSE;
    CLineCore *pLine = NULL; // Keep compiler happy.
    CMarkup *pMarkup = GetMarkup();
    CTreePos *ptp;
    LONG cchNotUsed;
    Assert(prcView);
    Assert(prcInval);

    ptp = pMarkup->TreePosAtCp(cpFirst, &cchNotUsed, TRUE);
    Assert(ptp);

    // TODO (sujalp, track bug 112039): We might want to search for other interesting
    // list elements here.
    CElement *pElement = pMarkup->SearchBranchForTag(ptp->GetBranch(), ETAG_OL)->SafeElement();
    if (   pElement
        && pElement->IsBlockElement()
       )
    {
        while (iliFirst < LineCount()   &&
               yPos     < prcView->bottom
              )
        {
            pLine = Elem(iliFirst);

            if (pLine->_fHasBulletOrNum)
            {
                fHasListItem = TRUE;
                break;
            }

            if(pLine->_fForceNewLine)
                yPos += pLine->_yHeight;

            iliFirst++;
        }

        if (fHasListItem)
        {
            // Invalidate the complete strip starting at the current
            // line, right down to the bottom of the view. And only
            // invalidate the strip containing the numbers not the
            // lines themselves.
            prcInval->top    = yPos;
            prcInval->left   = prcView->left;
            prcInval->right  = pLine->oi()->_xLeft;
            prcInval->bottom = prcView->bottom;
        }
    }

    return fHasListItem;
}

// ================================  DEBUG methods  ============================================


#if DBG==1
/*
 *  CDisplay::CheckLineArray()
 *
 *  @mfunc
 *      Ensure that the total amount of text in the line array is the same as
 *      that contained in the runs under the scope of the associated CTxtSite.
 *      Additionally, verify the total height of the contained lines matches
 *      the total calculated height.
 */

VOID CDisplay::CheckLineArray()
{
#ifdef MULTI_LAYOUT
    {
        // TODO (olego, track bug 112029) : need different consistency checking code for multiple/chain case
        CFlowLayout *pFlowLayout = GetFlowLayout();
        CLayoutContext *pLayoutContext;
        
        if (pFlowLayout
            && (pLayoutContext = pFlowLayout->LayoutContext()) != NULL
            && pLayoutContext->ViewChain())
        {
            return;
        }
    }
#endif // MULTI_LAYOUT

    // If we are marked as needing a recalc or if we are in the process of a
    // background recalc, we cannot verify the line array
    if(!_fRecalcDone)
    {
        return;
    }

    LONG            yHeight  = 0;
    LONG            yHeightMax = 0;
    LONG            cchSum   = 0;
    LONG            cchTotal = GetFlowLayout()->GetContentTextLength();
    LONG            ili      = LineCount();
    CLineCore const *pli     = Elem(0);

    while(ili--)
    {
        Assert(pli->_iLOI != -1);
        if(pli->_fForceNewLine)
        {
            yHeight += pli->_yHeight;
            if(yHeightMax < yHeight)
                yHeightMax = yHeight;
        }
        cchSum += pli->_cch;
        pli++;
    }

    if(cchSum != cchTotal)
    {
        TraceTag((tagWarning, "cchSum (%d) != cchTotal (%d)", cchSum, GetFlowLayout()->GetContentTextLength()));
        AssertSz(FALSE, "cchSum != cchTotal");
    }

    if(max(0l, yHeightMax) != max(0l, _yHeight))
    {
        TraceTag((tagWarning, "sigma (*this)[]._yHeight = %ld, _yHeight = %ld", yHeight, _yHeight));
        CMarkup *pMarkup = GetMarkup();
        AssertSz(!pMarkup, "sigma (*this)[]._yHeight != _yHeight");
    }
}


/*
 *  CDisplay::CheckView()
 *
 *  @mfunc
 *      Checks coherence between _iliFirstVisible, _dcpFirstVisible
 *      and _dyFirstVisible
 */
void CDisplay::CheckView()
{
}


/*
 *  CDisplay::VerifyFirstVisible
 *
 *  @mfunc  checks the coherence between FirstVisible line and FirstVisible dCP
 *
 *  @rdesc  TRUE if things are hunky dory; FALSE otherwise
 */
BOOL CDisplay::VerifyFirstVisible()
{
    return TRUE;
}
#endif

#if DBG==1 || defined(DUMPTREE)
void CDisplay::DumpLines()
{
    CTxtPtr      tp ( GetMarkup(), GetFlowLayout()->GetContentFirstCpForBrokenLayout() );
    LONG            yHeight = 0;

    if (!InitDumpFile())
        return;

    WriteString( g_f,
        _T("\r\n------------- LineArray -------------------------------\r\n" ));


    long    nLines = Count();
    CLineCore * pLine;
    CLineOtherInfo *ploi;
    
    WriteHelp(g_f, _T("CTxtSite     : 0x<0x>\r\n"), GetFlowLayoutElement());
    WriteHelp(g_f, _T("TextLength   : <0d>\r\n"), (long)GetFlowLayout()->GetContentTextLength());
    WriteHelp(g_f, _T("Bottom margin : <0d>\r\n"), (long)_yBottomMargin);

    for(long iLine = 0; iLine < nLines; iLine++)
    {
        pLine = Elem(iLine);
        ploi = pLine->oi();
        
        WriteHelp(g_f, _T("\r\nLine: <0d> - "), (long)iLine);
        WriteHelp(g_f, _T("Cp: <0d> - "), (long)tp.GetCp());

        // Write out all the flags.
        if (pLine->_fHasBulletOrNum)
            WriteString(g_f, _T("HasBulletOrNum - "));
        if (pLine->_fHasBreak)
            WriteString(g_f, _T("HasBreak - "));
        if (pLine->_fHasEOP)
            WriteString(g_f, _T("HasEOP - "));
        if (pLine->_fFirstInPara)
            WriteString(g_f, _T("FirstInPara - "));
        if (pLine->_fForceNewLine)
            WriteString(g_f, _T("ForceNewLine - "));
        if (pLine->_fHasNestedRunOwner)
            WriteString(g_f, _T("HasNestedRunOwner - "));
        if (pLine->_fDummyLine)
            WriteString(g_f, _T("DummyLine - "));
        if (pLine->_fHidden)
            WriteString(g_f, _T("Hidden - "));
        if (pLine->_fRelative)
            WriteString(g_f, _T("IsRelative - "));
        if (pLine->_fFirstFragInLine)
            WriteString(g_f, _T("FirstFrag - "));
        if (pLine->_fPartOfRelChunk)
            WriteString(g_f, _T("PartOfRelChunk - "));
        if (pLine->_fHasBackground)
            WriteString(g_f, _T("HasBackground - "));
        if (!pLine->_fCanBlastToScreen)
            WriteString(g_f, _T("Noblast - "));
        if (pLine->_fRTLLn)
            WriteString(g_f, _T("RTL - "));
        if (pLine->_fHasTransmittedLI)
            WriteString(g_f, _T("TransmittedLI - "));
        if (ploi->_fHasFirstLine)
            WriteString(g_f, _T("FirstLine - "));
        if (ploi->_fHasFirstLetter)
            WriteString(g_f, _T("FirstLetter - "));
        if (ploi->_fIsPadBordLine)
            WriteString(g_f, _T("EmptyPadBordEnd - "));
        if (ploi->_fHasInlineBgOrBorder)
            WriteString(g_f, _T("HasInlineBgOrBorder - "));
        if (ploi->_fHasAbsoluteElt)
            WriteString(g_f, _T("HasAbsoluteElt - "));
            
        if(pLine->IsFrame())
        {
            WriteString(g_f, _T("\r\n\tFrame "));
            WriteString(g_f, pLine->_fFrameBeforeText ?
                                _T("(B) ") :
                                _T("(A) "));
        }
        else if (pLine->IsClear())
        {
            WriteString(g_f, _T("\r\n\tClear     "));
        }
        else
        {
            WriteHelp(g_f, _T("\r\n\tcch = <0d>  "), (long)pLine->_cch);
        }

        // Need to cast stuff to (long) when using <d> as Format Specifier for Win16.
        WriteHelp(g_f, _T("y-Offset = <0d>, "), (long)yHeight);
        WriteHelp(g_f, _T("left-margin = <0d>, "), (long)ploi->_xLeftMargin);
        WriteHelp(g_f, _T("right-margin = <0d>, "), (long)ploi->_xRightMargin);
        WriteHelp(g_f, _T("xWhite = <0d>, "), (long)ploi->_xWhite);
        WriteHelp(g_f, _T("cchWhite = <0d> "), (long)ploi->_cchWhite);
        WriteHelp(g_f, _T("overhang = <0d>, "), (long)ploi->_xLineOverhang);
        WriteHelp(g_f, _T("\r\n\tleft  = <0d>, "), (long)ploi->_xLeft);
        WriteHelp(g_f, _T("right = <0d>, "), (long)pLine->_xRight);
        WriteHelp(g_f, _T("line-width = <0d>, "), (long)pLine->_xLineWidth);
        WriteHelp(g_f, _T("width = <0d>, "), (long)pLine->_xWidth);
        WriteHelp(g_f, _T("height = <0d>, "), (long)pLine->_yHeight);

        WriteHelp(g_f, _T("\r\n\tbefore-space = <0d>, "), (long)ploi->_yBeforeSpace);
        WriteHelp(g_f, _T("descent = <0d>, "), (long)ploi->_yDescent);
        WriteHelp(g_f, _T("txt-descent = <0d>, "), (long)ploi->_yTxtDescent);
        WriteHelp(g_f, _T("extent = <0d>, "), (long)ploi->_yExtent);
        WriteHelp(g_f, _T("loi = <0d>, "), (long)pLine->_iLOI);
        if(pLine->_cch)
        {
            WriteString( g_f, _T("\r\n\ttext = '"));
            DumpLineText(g_f, &tp, iLine);
        }

        WriteString( g_f, _T("\'\r\n"));
        
        if (pLine->_fForceNewLine)
            yHeight += pLine->_yHeight;
    }

    if(GetFlowLayout()->_fContainsRelative)
    {
        CRelDispNodeCache * prdnc = GetRelDispNodeCache();

        if(prdnc)
        {
            WriteString( g_f, _T("   -- relative disp node cache --  \r\n"));

            for(long i = 0; i < prdnc->Size(); i++)
            {
                CRelDispNode * prdn = (*prdnc)[i];

                WriteString(g_f, _T("\tElement: "));
                WriteString(g_f, (TCHAR *)prdn->GetElement()->TagName());
                WriteHelp(g_f, _T(", SN:<0d>,"), prdn->GetElement()->SN());

                WriteHelp(g_f, _T("\t\tLine: <0d>, "), prdn->_ili);
                WriteHelp(g_f, _T("cLines: <0d>, "), prdn->_cLines);
                WriteHelp(g_f, _T("yLine: <0d>, "), prdn->_yli);
                WriteHelp(g_f, _T("ptOffset(<0d>, <1d>), "), prdn->_ptOffset.x, prdn->_ptOffset.y);
                WriteHelp(g_f, _T("xAnchor(<0d>), "), prdn->_xAnchor);
                WriteHelp(g_f, _T("DispNode: <0x>,\r\n"), prdn->_pDispNode);
            }

            WriteString(g_f, _T("\r\n"));
        }
    }

    if (IsTagEnabled(tagDumpLineCache))
    {
        CLineInfoCache * pLineInfoCache = TLS(_pLineInfoCache);
        LONG iTotalRefs = 0;
        
        for (LONG i = 0; i < pLineInfoCache->Size(); i++)
        {
            iTotalRefs += pLineInfoCache->Refs(i);
        }
        if (iTotalRefs)
        {
            WriteHelp(g_f, _T("\r\nTotal %age saving = <0d>\r\n"), 100 - ((pLineInfoCache->CelsInCache() * 100) / iTotalRefs));

            LONG memUsedBefore = (sizeof(CLineFull) - sizeof(LONG)) * iTotalRefs;
            LONG memUsedNow;

            memUsedNow = iTotalRefs * sizeof(CLineCore);
            memUsedNow += pLineInfoCache->CelsInCache() * (sizeof(CLineOtherInfo) + sizeof(CDataCacheElem));
            WriteHelp(g_f, _T("Memused before = <0d>\r\n"), memUsedBefore);
            WriteHelp(g_f, _T("Memused now = <0d>\r\n"), memUsedNow);
            WriteHelp(g_f, _T("Mem savings = <0d>%\r\n"),
                      100 - ((memUsedNow * 100) / memUsedBefore));
        }         
    }
    
    CloseDumpFile();
}

void
CDisplay::DumpLineText(HANDLE hFile, CTxtPtr* ptp, long iLine)
{
    CLineCore * pLine = Elem(iLine);
    
    if(pLine->_cch)
    {
        TCHAR   chBuff [ 100 ];
        long    cchChunk;

        cchChunk = min( pLine->_cch, long( ARRAY_SIZE( chBuff ) ) );

        ptp->GetRawText( cchChunk, chBuff );

        WriteFormattedString( hFile, chBuff, cchChunk );

        if (pLine->_cch > cchChunk)
        {
            WriteString( hFile, _T("..."));
        }
        ptp->AdvanceCp(pLine->_cch);
    }
}
#endif

//==================================  Inversion (selection)  ============================



 //+==============================================================================
 //
 // Method: ShowSelected
 //
 // Synopsis: The "Selected-ness" between the two CTreePos's has changed.
 //           We tell the renderer about it - via Invalidate.
 //
 //           We also need to set the TextSelectionNess of any "sites"
 //           on screen
 //
 //-------------------------------------------------------------------------------
#define CACHED_INVAL_RECTS 20

DeclareTag(tagDisplayShowSelected, "Selection", "Selection CDisplay::ShowSelected output")
DeclareTag(tagDisplayShowInval, "Selection", "Selection show inval rects")

VOID CDisplay::ShowSelected(
    CTreePos* ptpStart,
    CTreePos* ptpEnd,
    BOOL fSelected    ) 
{
    CFlowLayout * pFlowLayout = GetFlowLayout();
    CElement * pElement = pFlowLayout->ElementContent();
    CStackDataAry < RECT, CACHED_INVAL_RECTS > aryInvalRects(Mt(CDisplayShowSelectedRange_aryInvalRects_pv));
    
    AssertSz(pFlowLayout->IsInPlace(),
        "CDisplay::ShowSelected() called when not in-place active");

    int cpClipStart = ptpStart->GetCp( WHEN_DBG(FALSE));
    int cpClipFinish = ptpEnd->GetCp( WHEN_DBG(FALSE));
    Assert( cpClipStart <= cpClipFinish);

    if ( cpClipFinish > cpClipStart) // don't bother with cpClipFinish==cpClipStart
    {

        // 
        // we make the minimum selection size 3 chars to plaster over any off-by-one
        // problems with Region-From-Element, but we don't cross layout boundaries
        // or blocks
        //
    
        CTreePos *  ptpCur = ptpStart->PreviousNonPtrTreePos();

        //
        // expand one real (non-node) character to the left
        // without crossing layout or block boundaries.
        //
        
        while( ptpCur && ptpCur->IsNode() )
        {
            CElement * pElement = ptpCur->Branch()->Element();
        
            if (    pElement->ShouldHaveLayout() 
                ||  pElement->IsBlockElement()
                ||  pElement->Tag() == ETAG_ROOT)
            {
                break;
            }
            
            // we know we can skip this one
            cpClipStart--;

            // check the previous tree pos
            ptpCur = ptpCur->PreviousNonPtrTreePos();
        }

        // We hit real text before we hit a 
        // layout or the edge of the markup
        if (ptpCur && ptpCur->IsText())
        {
            // Overshoot intentionally by 
            // one character of real text.
            cpClipStart--;
        }
        
        //
        // expand one real (non-node) character to the right
        // without crossing layout or block boundaries.
        //

        ptpCur = ptpEnd;

        if( ptpCur->IsPointer() )
            ptpCur = ptpCur->NextNonPtrTreePos();

        while( ptpCur && ptpCur->IsNode() )
        {
            CElement * pElement = ptpCur->Branch()->Element();
        
            if (    pElement->ShouldHaveLayout() 
                ||  pElement->IsBlockElement()
                ||  pElement->Tag() == ETAG_ROOT)
            {
                break;
            }

            cpClipFinish++;

            ptpCur = ptpCur->NextNonPtrTreePos();
        }
         
        // We hit real text before we hit a 
        // layout or the edge of the markup
        if (ptpCur && ptpCur->IsText())
        {
            // Overshoot intentionally by 
            // one character of real text.
            cpClipFinish++;
        }

        //
        // Make sure the recalc has caught up
        //
        
        WaitForRecalc(min(GetLastCp(), long(cpClipFinish)), -1);

        //
        // Get the actual region
        //
      
        RegionFromElement( pElement, &aryInvalRects, NULL, NULL, RFE_SELECTION, cpClipStart, cpClipFinish, NULL ); 

#if DBG == 1
        TraceTag((tagDisplayShowSelected, "cpClipStart=%d, cpClipFinish=%d fSelected:%d", cpClipStart, cpClipFinish, fSelected));

        RECT dbgRect;
        int i;
        for ( i = 0; i < aryInvalRects.Size(); i++)
        {
            dbgRect = aryInvalRects[i];
            TraceTag((tagDisplayShowInval,"InvalRect Left:%d Top:%d, Right:%d, Bottom:%d", dbgRect.left, dbgRect.top, dbgRect.right, dbgRect.bottom));
        }
#endif 

        pFlowLayout->Invalidate(&aryInvalRects[0], aryInvalRects.Size());           

    }
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::GetViewHeightAndWidthForChild
//
// Synopsis:    returns the view width/height - padding
//
//-----------------------------------------------------------------------------
void
CDisplay::GetViewWidthAndHeightForChild(
    CParentInfo *   ppri,
    long *          pxWidthParent,
    long *          pyHeightParent,
    BOOL            fMinMax)
{
    long lPadding[SIDE_MAX];

    Assert(pxWidthParent && pyHeightParent);

    GetPadding(ppri, lPadding, fMinMax);

    *pxWidthParent  = max(0L, GetViewWidth() - lPadding[SIDE_LEFT] - lPadding[SIDE_RIGHT]);
    *pyHeightParent = max(0L, GetViewHeight() - lPadding[SIDE_TOP] - lPadding[SIDE_BOTTOM]);
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::GetPadding
//
// Synopsis:    returns the top/left/right/bottom padding of the current
//              flowlayout
//
//-----------------------------------------------------------------------------
void
CDisplay::GetPadding(
    CParentInfo *   ppri,
    long            lPadding[],
    BOOL            fMinMax)
{
    CElement  * pElementFL   = GetFlowLayout()->ElementOwner();
    CTreeNode * pNode        = pElementFL->GetFirstBranch();
    CDoc      * pDoc         = pElementFL->Doc();
    ELEMENT_TAG etag         = pElementFL->Tag();
    long        lPaddingTop, lPaddingLeft, lPaddingRight, lPaddingBottom;
    const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(ppri->GetLayoutContext()));
    const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(ppri->GetLayoutContext())); 
    BOOL fLayoutVertical = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
    LONG lFontHeight  = pCF->GetHeightInTwips(pDoc);

    //  This flag is TRUE if layout should be calculated in CSS1 strict mode. 
    BOOL fStrictCSS1Document =      pElementFL->HasMarkupPtr() 
                                &&  pElementFL->GetMarkupPtr()->IsStrictCSS1Document();

    long lParentWidth        = (fMinMax || fStrictCSS1Document)
                                ? ppri->_sizeParent.cx
                                : GetViewWidth();
    if(     _fDefPaddingSet
         && !pElementFL->IsEditable(/*fCheckContainerOnly*/FALSE) && !pElementFL->IsPrintMedia()    )
    {
        lPaddingTop    = _defPaddingTop;
        lPaddingBottom = _defPaddingBottom;
    }
    else
    {
        lPaddingTop    = 
        lPaddingBottom = 0;
    }

    if (etag != ETAG_TC)
    {
        lPaddingTop +=
            pFF->GetLogicalPadding(SIDE_TOP, fLayoutVertical, fWritingModeUsed).YGetPixelValue(ppri, lParentWidth, lFontHeight);
                                // (srinib) parent width is intentional as per css spec

        lPaddingBottom +=
            pFF->GetLogicalPadding(SIDE_BOTTOM, fLayoutVertical, fWritingModeUsed).YGetPixelValue(ppri, lParentWidth, lFontHeight);
                                // (srinib) parent width is intentional as per css spec

        lPaddingLeft =
            pFF->GetLogicalPadding(SIDE_LEFT, fLayoutVertical, fWritingModeUsed).XGetPixelValue(ppri, lParentWidth, lFontHeight);


        lPaddingRight =
            pFF->GetLogicalPadding(SIDE_RIGHT, fLayoutVertical, fWritingModeUsed).XGetPixelValue(ppri, lParentWidth, lFontHeight);

        if (    etag == ETAG_BODY
            &&  !GetFlowLayout()->GetOwnerMarkup()->IsHtmlLayout() )
        {
            lPaddingLeft  +=
                pFF->GetLogicalMargin(SIDE_LEFT, fLayoutVertical, fWritingModeUsed).XGetPixelValue(ppri, lParentWidth, lFontHeight);
            lPaddingRight +=
                pFF->GetLogicalMargin(SIDE_RIGHT, fLayoutVertical, fWritingModeUsed).XGetPixelValue(ppri, lParentWidth, lFontHeight);
            lPaddingTop +=
                pFF->GetLogicalMargin(SIDE_TOP, fLayoutVertical, fWritingModeUsed).YGetPixelValue(ppri, lParentWidth, lFontHeight);
            lPaddingBottom +=
                pFF->GetLogicalMargin(SIDE_BOTTOM, fLayoutVertical, fWritingModeUsed).YGetPixelValue(ppri, lParentWidth, lFontHeight);
        } 
    }
    else
    {
        lPaddingLeft = 0;
        lPaddingRight = 0; 
    }

    //
    // negative padding is not supported. What does it really mean?
    //
    lPadding[SIDE_TOP]    = lPaddingTop > SHRT_MAX
                             ? SHRT_MAX
                             : lPaddingTop < 0 ? 0 : lPaddingTop;
    lPadding[SIDE_BOTTOM] = lPaddingBottom > SHRT_MAX
                             ? SHRT_MAX
                             : lPaddingBottom < 0 ? 0 : lPaddingBottom;
    lPadding[SIDE_LEFT]   = lPaddingLeft > SHRT_MAX
                             ? SHRT_MAX
                             : lPaddingLeft < 0 ? 0 : lPaddingLeft;
    lPadding[SIDE_RIGHT]  = lPaddingRight > SHRT_MAX
                             ? SHRT_MAX
                             : lPaddingRight < 0 ? 0 : lPaddingRight;

    _fContainsVertPercentAttr |= pFF->HasLogicalPercentVertPadding(fLayoutVertical, fWritingModeUsed);
    _fContainsHorzPercentAttr |= pFF->HasLogicalPercentHorzPadding(fLayoutVertical, fWritingModeUsed);
}


//+----------------------------------------------------------------------------
//
// Member:      GetRectForChar
//
// Synopsis:    Returns the top, the bottom and the width for a character
//
//  Notes:      If pWidth is not NULL, the witdh of ch is returned in it.
//              Otherwise, ch is ignored.
//-----------------------------------------------------------------------------

void
CDisplay::GetRectForChar(
                    CCalcInfo  *pci,
                    LONG       *pTop,
                    LONG       *pBottom,
                    LONG        yTop,
                    LONG        yProposed,
                    CLineFull  *pli,
                    CTreePos   *ptp)
{
    CCcs     ccs;
    const CBaseCcs *pBaseCcs;
    CTreeNode *pNode = ptp->GetBranch();
    const CCharFormat *pcf = pNode->GetCharFormat(LC_TO_FC(pci->GetLayoutContext()));
    
    Assert(pci && pTop && pBottom && pli && pcf);
    if (!fc().GetCcs(&ccs, pci->_hdc, pci, pcf))
    {
        *pTop = *pBottom = 0;
        goto Cleanup;
    }
    pBaseCcs = ccs.GetBaseCcs();
    Assert(pBaseCcs);

    *pBottom = yTop + pli->_yHeight - pli->_yDescent + pli->_yTxtDescent;
    *pTop = *pBottom - pBaseCcs->_yHeight -
            (pli->_yTxtDescent - pBaseCcs->_yDescent);

    if (yProposed != LONG_MIN)
    {
        // I need to pull this run up so that its only yDelta from the top
        LONG yDiff = *pTop - yTop;
        LONG yDelta = yDiff - yProposed;
        *pTop -= yDelta;
        *pBottom -= yDelta;
        Assert(*pTop - yTop == yProposed);
    }
    
    if (pNode->HasInlineMBP(LC_TO_FC(pci->GetLayoutContext())))
    {
        CRect rc;
        BOOL fIgnore;
        pNode->GetInlineMBPContributions(pci, GIMBPC_ALL, &rc, &fIgnore, &fIgnore);
        *pBottom += max(0l, rc.bottom);
        *pTop -= max(0l, rc.top);
    }
    
Cleanup:    
    ccs.Release();
}


//+----------------------------------------------------------------------------
//
// Member:      GetTopBottomForCharEx
//
// Synopsis:    Returns the top and the bottom for a character
//
// Params:  [pDI]:     The DI
//          [pTop]:    The top is returned in this
//          [pBottom]: The bottom is returned in this
//          [yTop]:    The top of the line containing the character
//          [pli]:     The line itself
//          [xPos]:    The xPos at which we need the top/bottom
//          [ptp]:     ptp owning the char
//
//-----------------------------------------------------------------------------
void
CDisplay::GetTopBottomForCharEx(
                             CCalcInfo     *pci,
                             LONG          *pTop,
                             LONG          *pBottom,
                             LONG           yTop,
                             CLineFull     *pli,
                             LONG           xPos,
                             LONG           yProposed,
                             CTreePos      *ptp,
                             BOOL          *pfBulletHit)
{
    //
    // If we are on a line in a list, and we are on the area occupied
    // (horizontally) by the bullet, then we want to find the height
    // of the bullet.
    //

    if (    pli->_fHasBulletOrNum
        &&  (   (   xPos >= pli->_xLeftMargin
                &&  xPos < pli->GetTextLeft()))
       )
    {
        Assert(pci && pTop && pBottom && pli);

        *pBottom = yTop + pli->_yHeight - pli->_yDescent;
        *pTop = *pBottom - pli->_yBulletHeight;
        if (pfBulletHit)
            *pfBulletHit = TRUE;
    }
    else
    {
        GetRectForChar(pci, pTop, pBottom, yTop, yProposed, pli, ptp);
    }
}


//+----------------------------------------------------------------------------
//
// Member:      GetClipRectForLine
//
// Synopsis:    Returns the clip rect for a given line
//
// Params:  [prcClip]: Returns the rect for the line
//          [pTop]:    The top is returned in this
//          [pBottom]: The bottom is returned in this
//          [yTop]:    The top of the line containing the character
//          [pli]:     The line itself
//          [pcf]:     Character format for the char
//
//-----------------------------------------------------------------------------
void
CDisplay::GetClipRectForLine(RECT *prcClip, LONG top, LONG xOrigin, CLineCore *pli, CLineOtherInfo *ploi) const
{
    Assert(prcClip && pli);

    prcClip->left   = xOrigin + ploi->GetTextLeft();
    prcClip->right  = xOrigin + pli->GetTextRight(ploi);

    if (pli->_fForceNewLine)
    {
        if (!pli->_fRTLLn)
        {
            prcClip->right += ploi->_xWhite;
        }
        else
        {
            prcClip->left -= ploi->_xWhite;
        }
    }
    prcClip->top    = top + pli->GetYTop(ploi);
    prcClip->bottom = top + pli->GetYBottom(ploi);
}


//=================================  IME support  ===================================

#ifdef DBCS

/*
 *  ConvGetRect
 *
 *  Purpose:
 *      Converts a rectangle obtained from Windows for a vertical control
 *
 *  Arguments:
 *      prc     Rectangle to convert
 */
void ConvGetRect(LPRECT prc, BOOL fVertical)
{
    RECT    rc;
    INT     xWidth;
    INT     yHeight;

    if(fVertical)
    {
        rc          = *prc;
        xWidth      = rc.right - rc.left;
        yHeight     = rc.bottom - rc.top;
        prc->left   = rc.top;
        prc->top    = rc.left;
        prc->right  = rc.top + yHeight;
        prc->bottom = rc.left + xWidth;
    }
}

/*
 *  VwUpdateIMEWindow(ped)
 *
 *  Purpose:
 *      Update position of IME candidate/composition string
 *
 *  Arguments:
 */
VOID VwUpdateIMEWindow(CPED ped)
{
    POINTL  pt;
    RECT    rc;
    SIZE    size;

    if((ped->_dwStyle & ES_NOIME) && (ped->_dwStyle & ES_SELFIME))
        return;

    ConvGetRect(ped->_fVertical, &rc);


    rc.left     = _pdp->GetViewLeft();
    rc.top      = _pdp->GetViewTop();
    rc.right    = _pdp->GetViewWidth() + _pdp->GetViewLeft();
    rc.bottom   = _pdp->GetViewHeight() + _pdp->GetViewTop();

    size.cy     = ped->_yHeightCaret;
    size.cx     = ped->_yHeightCaret;

    if(ped->_fVertical)
    {
        ConvSetRect(&rc);
        pt.y    = (INT)ped->_xCaret - size.cx;
        pt.x    = ped->_xWidth - (INT)ped->_yCaret;
    }
    else
    {
        pt.x    = (INT)ped->_xCaret;
        pt.y    = (INT)ped->_yCaret;
    }

    SetIMECandidatePos (ped->_hwnd, pt, (LPRECT)&rc, &size);
}
#endif

//+----------------------------------------------------------------------------
//
// Member:      GetWigglyFromRange
//
// Synopsis:    Gets rectangles to use for focus rects. This
//              element or range.
//
//-----------------------------------------------------------------------------
HRESULT
CDisplay::GetWigglyFromRange(CDocInfo * pdci, long cp, long cch, CShape ** ppShape)
{
    CStackDataAry<RECT, 8> aryWigglyRects(Mt(CDisplayGetWigglyFromRange_aryWigglyRect_pv));
    HRESULT         hr = S_FALSE;
    CWigglyShape *  pShape = NULL;
    CMarkup *       pMarkup = GetMarkup();
    long            ich, cRects;
    CTreePos *      ptp      = pMarkup->TreePosAtCp(cp, &ich, TRUE);
    CTreeNode *     pNode    = ptp->GetBranch();
    CElement *      pElement = pNode->Element();

    if (!cch)
    {
        goto Cleanup;
    }

    pShape = new CWigglyShape;
    if (!pShape)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // get all of the rectangles that apply and load them into CWigglyShape's
    // array of CRectShapes.
    // RegionFromElement will give rects for any chunks within the number of
    // lines required.
    RegionFromElement( pElement, 
                       &aryWigglyRects, 
                       NULL, 
                       NULL, 
                       RFE_WIGGLY, 
                       cp,               // of lines that have different heights
                       cp + cch, 
                       NULL ); 

    for(cRects = 0; cRects < aryWigglyRects.Size(); cRects++)
    {
        CRectShape * pWiggly = NULL;

        pWiggly = new CRectShape;
        if (!pWiggly)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pWiggly->_rect = aryWigglyRects[cRects];

        // Expand the focus shape by shifting the left edges by 1 pixel.
        // This is a hack to get around the fact that the Windows
        // font rasterizer occasionally uses the leftmost pixel column of its
        // measured text area, and if we don't do this, the focus rect
        // overlaps that column.  IE bug #76378, taken for NT5 RTM (ARP).
        if (   pWiggly->_rect.left > 0
            && pWiggly->_rect.left != pWiggly->_rect.right )    // don't expand empty rects
        {
            --(pWiggly->_rect.left);
        }

        pShape->_aryWiggly.Append(pWiggly);

    }

    *ppShape = pShape;
    hr = S_OK;

Cleanup:
    if (hr && pShape)
    {
        delete pShape;
    }

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Member:      GetAveCharSize
//
// Synopsis:    Gets size of average characger for the flow layout.
//
//-----------------------------------------------------------------------------
BOOL
CDisplay::GetAveCharSize(CCalcInfo * pci, SIZE * psizeChar)
{
    BOOL fRet = FALSE;
    XHDC hdc = pci->_hdc;

    Assert(psizeChar);
    psizeChar->cx = psizeChar->cy = 0;

    // Get first text ptp for the flow layout
    CTreeNode * pNode = GetFlowLayoutElement()->GetFirstBranch();
    CTreePos * ptp = pNode->GetBeginPos();
    while (ptp && !ptp->IsText())
        ptp = ptp->NextTreePos();

    if (ptp)
    {
        // Get first character of the flow layout
        TCHAR ach[2];
        CTxtPtr tp(GetMarkup(), ptp->GetCp());
        ach[0] = tp.GetChar();
        ach[1] = _T('\0');

        // Create run for the first character of the flow layout
        COneRun onerun;
        memset(&onerun, 0, sizeof(onerun));
        onerun._fInnerCF = TRUE;    // same scope
        onerun._pCF = (CCharFormat* )pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
#if DBG == 1
        onerun._pCFOriginal = onerun._pCF;
#endif
        onerun._pFF = (CFancyFormat*)pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
        onerun._bConvertMode = CM_UNINITED;
        onerun._ptp = ptp;
        onerun.SetSidFromTreePos(ptp);
        onerun._lscch = 1;
        onerun._pchBase = ach;


        // Ununify sidHan script
        if (onerun._sid == sidHan)
        {
            CCcs ccsFLF;
            GetCcs(&ccsFLF, &onerun, hdc, pci, FALSE);
            const CBaseCcs * pBaseCcsFLF = ccsFLF.GetBaseCcs();
            const UINT uiFamilyCodePage = GetMarkup()->GetFamilyCodePage();

            SCRIPT_IDS sidsFace = 0;
            if (pBaseCcsFLF)
                sidsFace = fc().EnsureScriptIDsForFont(hdc, pBaseCcsFLF, FC_SIDS_USEMLANG);
            onerun._sid = fl().UnunifyHanScript(uiFamilyCodePage, 
                onerun.GetCF()->_lcid, sidsFace, onerun._pchBase, &onerun._lscch);

            ccsFLF.Release();
        }

        // Disambiguate ScriptId
        if (onerun._sid == sidAmbiguous)
        {
            onerun._sid = fl().DisambiguateScript(GetMarkup()->GetFamilyCodePage(), 
                onerun.GetCF()->_lcid, sidDefault, onerun._pchBase, &onerun._lscch);
        }

        // Get average character width, fontlink if necessary
        CCcs ccs;
        GetCcs(&ccs, &onerun, hdc, pci);
        const CBaseCcs * pBaseCcs = ccs.GetBaseCcs();
        if (pBaseCcs && !hdc.IsEmpty() && pBaseCcs->HasFont())
        {
            psizeChar->cy = pBaseCcs->_yHeight;

            FONTIDX hfontOld = ccs.PushFont(hdc);
            UINT iCharForAveWidth = g_aSidInfo[onerun._sid]._iCharForAveWidth;
            GetCharWidthHelper(hdc, iCharForAveWidth, (LPINT)&psizeChar->cx);
            if(pBaseCcs->_fScalingRequired) 
                psizeChar->cx *= pBaseCcs->_flScaleFactor;
            ccs.PopFont(hdc, hfontOld);

            if (psizeChar->cx == 0)
                psizeChar->cx = pBaseCcs->_xAveCharWidth;

            fRet = TRUE;
        }
        ccs.Release();
    }

    return fRet;
}

//+----------------------------------------------------------------------------
//
// Member:      GetCcs
//
// Synopsis:    Gets the suitable font (CCcs) for the given COneRun.
//
//-----------------------------------------------------------------------------
BOOL
CDisplay::GetCcs(CCcs * pccs, COneRun *por, XHDC hdc, CDocInfo *pdi, BOOL fFontLink)
{
    Assert(pccs);
    
    const CCharFormat *pCF = por->GetCF();
    const BOOL fDontFontLink =    !por->_ptp
                               || !por->_ptp->IsText()
                               || !fFontLink
                               || pCF->_bCharSet == SYMBOL_CHARSET
                               || pCF->_fDownloadedFont
                               || (pdi->_pDoc->_pWindowPrimary && pdi->_pMarkup->GetCodePage() == 50000);

    BOOL fCheckAltFont;   // TRUE if _pccsCache does not have glyphs needed for sidText
    SCRIPT_ID sidAlt = 0;
    BYTE bCharSetAlt = 0;
    SCRIPT_ID sidText;

    if (fc().GetCcs(pccs, hdc, pdi, pCF))
    {
        if (CM_UNINITED != por->_bConvertMode)
        {
            pccs->SetConvertMode((CONVERTMODE)por->_bConvertMode); 
        }
    }
    else
    {
        AssertSz(0, "CCcs failed to be created.");
        goto Cleanup;
    }

    if (fDontFontLink)
        goto Cleanup;

    //
    // Check if the pccs covers the sid of the text run
    //

    sidText = por->_sid;

    AssertSz( sidText != sidMerge, "Script IDs should have been merged." );
    AssertSz( sidText != sidAmbiguous, "Script IDs should have been disambiguated." );

    {
        // sidHalfWidthKana has to be treated as sidKana
        if (sidText == sidHalfWidthKana)
            sidText = sidKana;

        const CBaseCcs * pBaseCcs = pccs->GetBaseCcs();
        Assert(pBaseCcs);

        if (sidText == sidDefault)
        {
            fCheckAltFont = FALSE; // Assume the author picked a font containing the glyph.  Don't fontlink.
        }
        else if (sidText == sidEUDC)
        {
            const UINT uiFamilyCodePage = pdi->_pMarkup->GetFamilyCodePage();
            SCRIPT_ID sidForPUA;
            
            fCheckAltFont = ShouldSwitchFontsForPUA(hdc, uiFamilyCodePage, pBaseCcs, pCF, &sidForPUA);
            if (fCheckAltFont)
            {
                sidText = sidAlt = sidAmbiguous;
                bCharSetAlt = DefaultCharSetFromScriptAndCodePage( sidForPUA, uiFamilyCodePage );
            }
        }
        else 
        {
            fCheckAltFont = (pBaseCcs->_sids & ScriptBit(sidText)) == sidsNotSet;
        }
    }

    if (!fCheckAltFont)
        goto Cleanup;

    //
    // Check to see if the _ccsAltCache covers the sid of the text run
    //
    
    if (sidText != sidAmbiguous)
    {
        SCRIPT_IDS sidsFace = fc().EnsureScriptIDsForFont(hdc, pccs->GetBaseCcs(), FC_SIDS_USEMLANG);

        if (IsFESid(sidText))
        {
            // 
            // To render FE characters we need to keep current font if only possible,
            // even if it is used to render non-native characters.
            // So try to pickup the most appropriate charset, because GDI prefers 
            // charset over font face during font creation.
            // In case of FE lang id, use charset appropriate for it. This is because
            // lang id has highest priority font selection in case of FE characters.
            //
            if (pCF->_lcid)
            {
                bCharSetAlt = CharSetFromLangId(LANGIDFROMLCID(pCF->_lcid));
                if (!IsFECharset(bCharSetAlt))
                {
                    bCharSetAlt = DefaultCharSetFromScriptsAndCodePage(sidsFace, sidText, pdi->_pMarkup->GetFamilyCodePage());
                }
            }
            else
                bCharSetAlt = DefaultCharSetFromScriptsAndCodePage(sidsFace, sidText, pdi->_pMarkup->GetFamilyCodePage());
        }
        else
            bCharSetAlt = DefaultCharSetFromScriptAndCodePage(sidText, pdi->_pMarkup->GetFamilyCodePage());

        if ((sidsFace & ScriptBit(sidText)) == sidsNotSet)
        {
            sidAlt = sidText;           // current face does not cover
        }
        else
        {
            sidAlt = sidAmbiguous;      // current face does cover
        }
    }

    //
    // Looks like we need to pick a new alternate font
    //
    {
        CCharFormat cfAlt = *pCF;

        // sidAlt of sidAmbiguous at this point implies we have the right facename,
        // but the wrong GDI charset.  Otherwise, lookup in the registry/mlang to
        // determine an appropriate font for the given script id.

        if (sidAlt != sidAmbiguous)
        {
            SelectScriptAppropriateFont(sidAlt, bCharSetAlt, pdi->_pDoc, pdi->_pMarkup, &cfAlt);
        }
        else
        {
            cfAlt._bCharSet = bCharSetAlt;
            cfAlt._bCrcFont = cfAlt.ComputeFontCrc();
        }

        CCcs ccsForFontLink = *pccs;
        if (fc().GetFontLinkCcs(pccs, hdc, pdi, &ccsForFontLink, &cfAlt))
        {
            pccs->MergeSIDs(ScriptBit(sidAlt));
        }
        ccsForFontLink.Release();
    }

Cleanup:
    Assert(!pccs->GetBaseCcs() || pccs->GetHDC() == hdc);
    return !!pccs->GetBaseCcs();
}

void
CDisplay::GetExtraClipValues(LONG *plLeftV, LONG *plRightV)
{
    *plLeftV = *plRightV = 0;
    if (_fHasNegBlockMargins)
    {
        CLineFull lif;
        LONG left = LONG_MAX;
        LONG right = LONG_MAX;
        for (LONG i = 0; i < LineCount(); i++)
        {
            lif = *Elem(i);
            left = min(left, lif._xLeft);
            right = min(right, lif._xRight);
        }
        if (left < 0)
            *plLeftV = -left;
        if (right < 0)
            *plRightV = -right;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\dxfrobj.cxx ===
/*
 *  @doc INTERNAL
 *
 *  @module - DXFROBJ.C |
 *
 *      implementation of a generic IDataObject data transfer object.
 *      This object is suitable for use in OLE clipboard and drag drop
 *      operations
 *
 *  Author: <nl>
 *      alexgo (4/25/95)
 *
 *  Revisions: <nl>
 *      murrays (7/13/95) autodoc'd and added cf_RTF
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef _X_SELDRAG_HXX_
#define _X_SELDRAG_HXX_
#include "seldrag.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif


MtDefine(CTextXBag, Tree, "CTextXBag")
MtDefine(CTextXBag_prgFormats, CTextXBag, "CTextXBag::_prgFormats")

//
//  Common Data types
//

// If you change g_rgFETC[], change g_rgDOI[] and enum FETCINDEX and CFETC in
// _dxfrobj.h accordingly, and register nonstandard clipboard formats in
// RegisterFETCs(). Order entries in order of most desirable to least, e.g.,
// RTF in front of plain text.

FORMATETC g_rgFETC[] =
{
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_HTML
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_RTF
    {CF_UNICODETEXT,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    {CF_TEXT,           NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // Filename
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_RTFASTEXT
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_FILEDESCRIPTORA
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_FILEDESCRIPTORW
    {0,                 NULL, DVASPECT_CONTENT,  0, TYMED_HGLOBAL}, // CF_FILECONTENTS
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_SHELLIDLIST
    {0,                 NULL, DVASPECT_CONTENT,  0, TYMED_HGLOBAL}, // CF_UNIFORMRESOURCELOCATOR
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbObject
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbSource
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // ObjDesc
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // LnkSource
//    {CF_METAFILEPICT,   NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT},
//    {CF_DIB,            NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
//    {CF_BITMAP,         NULL, DVASPECT_CONTENT, -1, TYMED_GDI},
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // RTF with no objs
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// Text with objs
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// Richedit
};

const int CFETC = ARRAY_SIZE( g_rgFETC );



//TODO v-richa check the added members for correctness
const DWORD g_rgDOI[] =
{
    DOI_CANPASTEPLAIN,
    DOI_CANPASTEPLAIN,
    DOI_CANPASTEPLAIN,
    DOI_CANPASTEPLAIN,
//    DOI_CANPASTEOLE,
    DOI_CANPASTEPLAIN,
    DOI_NONE,
    DOI_NONE,
    DOI_NONE,
    DOI_NONE,
    DOI_NONE,
//    DOI_CANPASTEOLE,
//    DOI_CANPASTEOLE,
//    DOI_NONE,
//    DOI_CANPASTEOLE,
//    DOI_CANPASTEOLE,
//    DOI_CANPASTEOLE,
//    DOI_CANPASTEOLE,
//    DOI_CANPASTERICH,
//    DOI_CANPASTERICH,
//    DOI_CANPASTERICH
};


/*
 *  RegisterFETCs()
 *
 *  @func
 *      Register nonstandard format ETCs.  Called when DLL is loaded
 *
 *  @todo
 *      Register other RTF formats (and add places for them in g_rgFETC[])
 */
void RegisterFETCs()
{
    if(!g_rgFETC[iHTML].cfFormat)
        g_rgFETC[iHTML].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormatA("HTML Format");

    if(!g_rgFETC[iRtfFETC].cfFormat)
        g_rgFETC[iRtfFETC].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormatA("Rich Text Format");

    if(!g_rgFETC[iRtfAsTextFETC].cfFormat)
        g_rgFETC[iRtfAsTextFETC].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormatA("RTF As Text");

    if(!g_rgFETC[iFileDescA].cfFormat)
        g_rgFETC[iFileDescA].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);

    if(!g_rgFETC[iFileDescW].cfFormat)
        g_rgFETC[iFileDescW].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);

    if(!g_rgFETC[iFileContents].cfFormat)
        g_rgFETC[iFileContents].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILECONTENTS);

    if(!g_rgFETC[iShellIdList].cfFormat)
        g_rgFETC[iShellIdList].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);

    if(!g_rgFETC[iUniformResourceLocator].cfFormat)
        g_rgFETC[iUniformResourceLocator].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLURL);

//    if(!g_rgFETC[iRichEdit].cfFormat)
//        g_rgFETC[iRichEdit].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA("RICHEDIT");

//    if(!g_rgFETC[iObtDesc].cfFormat)
//        g_rgFETC[iObtDesc].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA(CF_OBJECTDESCRIPTOR);

//    if(!g_rgFETC[iEmbObj].cfFormat)
//        g_rgFETC[iEmbObj].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA(CF_EMBEDDEDOBJECT);

//    if(!g_rgFETC[iEmbSrc].cfFormat)
//        g_rgFETC[iEmbSrc].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA(CF_EMBEDSOURCE);

//    if(!g_rgFETC[iLnkSrc].cfFormat)
//        g_rgFETC[iLnkSrc].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA(CF_LINKSOURCE);

//    if(!g_rgFETC[iRtfNoObjs].cfFormat)
//        g_rgFETC[iRtfNoObjs].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA("Rich Text Format Without Objects");

//    if(!g_rgFETC[iTxtObj].cfFormat)
//        g_rgFETC[iTxtObj].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA("RichEdit Text and Objects");

//    if(!g_rgFETC[iFilename].cfFormat)
//        g_rgFETC[iFilename].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA(CF_FILENAME);
}


//
//  CTextXBag PUBLIC methods
//

/*
 *  CTextXBag::EnumFormatEtc (dwDirection, ppenumFormatEtc)
 *
 *  @mfunc
 *      returns an enumerator which lists all of the available formats in
 *      this data transfer object
 *
 *  @rdesc
 *      HRESULT
 *
 *  @devnote
 *      we have no 'set' formats for this object
 */
STDMETHODIMP CTextXBag::EnumFormatEtc(
    DWORD dwDirection,                  // @parm DATADIR_GET/SET
    IEnumFORMATETC **ppenumFormatEtc)   // @parm out parm for enum FETC interface
{
    HRESULT hr = NOERROR;
    FORMATETC*      paryFETC = NULL;
    IEnumFORMATETC* pIEFC = NULL;

    *ppenumFormatEtc = NULL;

    if (_pLinkDataObj && (_cTotal < _cFormatMax))
    {
        _prgFormats[ _cTotal++ ] = g_rgFETC[iFileDescA];
        _prgFormats[ _cTotal++ ] = g_rgFETC[iFileDescW];
        _prgFormats[ _cTotal++ ] = g_rgFETC[iFileContents];
        _prgFormats[ _cTotal++ ] = g_rgFETC[iUniformResourceLocator];
    }

    if (dwDirection == DATADIR_GET)
    {
        if ( _pGenDO )
        {
            //
            // We have a generic dataobject.
            // We create a new array that contains the PEFTC's from both our stuff
            // and that of the generic dataobject
            //
             FORMATETC* pcurFETC = NULL;
             
            int size = _pGenDO->Size();
            int i = 0;
#if DBG == 1
            ULONG ctActual; 
#endif            
            paryFETC = new FORMATETC[ _cTotal + size ];
            if ( ! paryFETC )
                goto Error;

            for ( i = 0, pcurFETC = paryFETC; i < _cTotal; i++, pcurFETC++ )
                *pcurFETC = _prgFormats[i];

            hr = THR( _pGenDO->EnumFormatEtc( dwDirection, & pIEFC ));
            if ( FAILED(hr))
                goto Cleanup;
                
#if DBG == 1
            hr = THR( pIEFC->Next( size,pcurFETC,&ctActual  ));
            Assert( ctActual == (unsigned) size );
#else
            hr = THR( pIEFC->Next( size,pcurFETC, NULL ));
#endif            
            if( FAILED( hr ))
                goto Cleanup;
                
            hr = CEnumFormatEtc::Create(paryFETC, _cTotal + size , ppenumFormatEtc);
        }
        else
        {
            hr = CEnumFormatEtc::Create(_prgFormats, _cTotal, ppenumFormatEtc);
        }
    }
    
Cleanup:    
    delete[] paryFETC;
    ReleaseInterface( pIEFC );
    
    return hr;

Error:
    return E_OUTOFMEMORY;
}

/*
 *  CTextXBag::GetData (pformatetcIn, pmedium)
 *
 *  @mfunc
 *      retrieves data of the specified format
 *
 *  @rdesc
 *      HRESULT
 *
 *  @devnote
 *      The three formats currently supported are CF_UNICODETEXT on
 *      an hglobal, CF_TEXT on an hglobal, and CF_RTF on an hglobal
 *
 *  @todo (alexgo): handle all of the other formats as well
 */
STDMETHODIMP CTextXBag::GetData(
    FORMATETC *pformatetcIn,
    STGMEDIUM *pmedium )
{
    CLIPFORMAT  cf = pformatetcIn->cfFormat;
    HRESULT     hr = DV_E_FORMATETC;
    HGLOBAL     hGlobal = NULL ;
    
    if (! (pformatetcIn->tymed & TYMED_HGLOBAL) )
        goto Cleanup;

    memset(pmedium, '\0', sizeof(STGMEDIUM));
    pmedium->tymed = TYMED_NULL;

    if (cf == cf_HTML)
        hGlobal = _hCFHTMLText;

    else if (cf == CF_UNICODETEXT)
        hGlobal = _hUnicodeText;

    else if (cf == CF_TEXT)
        hGlobal = _hText;

    else if (cf == cf_RTF || cf == cf_RTFASTEXT)
    {
        if (!_fRtfConverted && _hRTFText)
        {
            HGLOBAL hRTFText;
            
            hr = THR(ConvertHTMLToRTF(_hRTFText, &hRTFText));
            if (hr)
                goto Cleanup;

            GlobalFree(_hRTFText);
            _hRTFText = hRTFText;                
            _fRtfConverted = TRUE;
        }
        hGlobal = _hRTFText;
    }
    else if ( _pGenDO )
    {
        hr = THR( _pGenDO->GetData( pformatetcIn,pmedium)) ;
        goto Cleanup;
    }
    else
        goto Cleanup;

    if (hGlobal)
    {
        pmedium->tymed   = TYMED_HGLOBAL;
        pmedium->hGlobal = DuplicateHGlobal(hGlobal);
        if (!pmedium->hGlobal)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = S_OK;
    }

Cleanup:
    if (hr && _pLinkDataObj)
        hr = _pLinkDataObj->GetData(pformatetcIn, pmedium);
    RRETURN(hr);
}

/*
 *  CTextXBag::QueryGetData (pformatetc)
 *
 *  @mfunc
 *      Queries whether the given format is available in this data object
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CTextXBag::QueryGetData(
    FORMATETC *pformatetc )     // @parm FETC to look for
{
    DWORD   cFETC = _cTotal;
    CLIPFORMAT cf = pformatetc->cfFormat;
    HRESULT hr = DV_E_FORMATETC;
    
    while (cFETC--)             // Maybe faster to search from start
    {
        if( cf == _prgFormats[cFETC].cfFormat && 
            pformatetc->tymed & TYMED_HGLOBAL )
        {
            // Check for RTF handle even if we claim to support the format
            if (_hRTFText ||
                (cf != cf_RTF && cf != cf_RTFASTEXT))
            {
                hr = NOERROR;
                goto Cleanup;
            }
        }
    }

    if ( _pGenDO )
    {
        hr = _pGenDO->QueryGetData( pformatetc );
    }
    else if (_pLinkDataObj)
        hr = _pLinkDataObj->QueryGetData(pformatetc);

Cleanup:

    return hr;
}

STDMETHODIMP CTextXBag::SetData(LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium, BOOL fRelease)
{
    HRESULT hr = S_OK;

    Assert(pformatetc && pmedium);
    switch (pformatetc->cfFormat)
    {
    case CF_UNICODETEXT:
        if (_hUnicodeText)
        {
            GlobalFree(_hUnicodeText);
        }
        _hUnicodeText = pmedium->hGlobal;

        //
        // We don't set to null null strings - to mimic IE5 behavior
        //
        SetTextHelper(NULL, NULL, 0, 0, 0, &_hUnicodeText, iUnicodeFETC, FALSE );
        break;
    case CF_TEXT:
        if (_hText)
        {
            GlobalFree(_hText);
        }
        _hText = pmedium->hGlobal;

        //
        // We don't set to null null strings - to mimic IE5 behavior
        //        
        SetTextHelper(NULL, NULL, 0, 0, 0, &_hText, iAnsiFETC, FALSE );
        break;

    default:
        if ( ! _pGenDO )
        {
            _pGenDO = new CGenDataObject( _pDoc );
        }

        hr = THR( _pGenDO->SetData(pformatetc,pmedium, fRelease ));
        
        break;
    }
    return hr;
}

STDMETHODIMP CTextXBag::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (    _pSelDragDropSrcInfo
        &&  (iid == IID_IUnknown))
        return _pSelDragDropSrcInfo->QueryInterface(iid, ppv);
    else
        return super::QueryInterface(iid, ppv);
}

STDMETHODIMP_(ULONG) CTextXBag::AddRef()
{
    return _pSelDragDropSrcInfo ? _pSelDragDropSrcInfo->AddRef() : super::AddRef();
}

STDMETHODIMP_(ULONG) CTextXBag::Release()
{
    return _pSelDragDropSrcInfo ? _pSelDragDropSrcInfo->Release() : super::Release();
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::Create
//
//  Synopsis:   Static creator of text xbags
//
//  Arguments:  pMarkup         The markup that owns the selection
//              dwFlags         Flags
//              ppRange         Array of ptrs to ranges
//              cRange          Number of items in above array
//              ppTextXBag      Returned xbag.
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::Create(CMarkup *             pMarkup,
                  DWORD                 dwFlags,
                  ISegmentList *        pSegmentList,
                  BOOL                  fDragDrop,
                  CTextXBag **          ppTextXBag,
                  CSelDragDropSrcInfo * pSelDragDropSrcInfo /* = NULL */)
{
    HRESULT hr;

    CTextXBag * pTextXBag = new CTextXBag();

    if (!pTextXBag)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pTextXBag->_pSelDragDropSrcInfo = pSelDragDropSrcInfo;

    if (fDragDrop)
    {
        pTextXBag->_pDoc = pMarkup->Doc();
    }

    hr = THR(pTextXBag->SetKeyState());
    if (hr)
        goto Error;

    hr = THR(pTextXBag->FillWithFormats(pMarkup, dwFlags, pSegmentList));
    if (hr)
        goto Error;

Cleanup:
    *ppTextXBag = pTextXBag;

    RRETURN(hr);

Error:
    delete pTextXBag;
    pTextXBag = NULL;
    goto Cleanup;
}

//
//  CTextXBag PRIVATE methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CTextXBag::CTextXBag
//
//  Synopsis:   Private ctor
//
//----------------------------------------------------------------------------

CTextXBag::CTextXBag()
{
    _ulRefs       = 1;
    _cTotal       = CFETC;
    _cFormatMax   = 1;
    _prgFormats   = g_rgFETC;
    _hText        = NULL;
    _hUnicodeText = NULL;
    _hRTFText     = NULL;
    _hCFHTMLText  = NULL;
    _pLinkDataObj = NULL;
    _pGenDO       = NULL;
    _fRtfConverted = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextXBag::~CTextXBag
//
//  Synopsis:   Private dtor
//
//----------------------------------------------------------------------------

CTextXBag::~CTextXBag()
{
    if( _prgFormats && _prgFormats != g_rgFETC)
    {
        delete [] _prgFormats;
    }

    if (_hText)
        GlobalFree(_hText);

    if (_hUnicodeText)
        GlobalFree(_hUnicodeText);

    if (_hRTFText)
        GlobalFree(_hRTFText);

    if (_hCFHTMLText)
        GlobalFree(_hCFHTMLText);

    if ( _pGenDO )
        _pGenDO->Release();
}


//+------------------------------------------------------------------------/
//
//  Member:     CTextXBag::SetKeyState
//
//  Synopsis:   Sets the _dwButton member of the CTextXBag
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::SetKeyState()
{
    static int  vk[] =
    {
        VK_LBUTTON,     // MK_LBUTTON = 0x0001
        VK_RBUTTON,     // MK_RBUTTON = 0x0002
        VK_SHIFT,       // MK_SHIFT   = 0x0004
        VK_CONTROL,     // MK_CONTROL = 0x0008
        VK_MBUTTON,     // MK_MBUTTON = 0x0010
        VK_MENU,        // MK_ALT     = 0x0020
    };

    int     i;
    DWORD   dwKeyState = 0;

    for (i = 0; i < ARRAY_SIZE(vk); i++)
    {
        if (GetKeyState(vk[i]) & 0x8000)
        {
            dwKeyState |= (1 << i);
        }
    }

    _dwButton = dwKeyState & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON);

    return S_OK;
}


//+------------------------------------------------------------------------/
//
//  Member:     CTextXBag::FillWithFormats
//
//  Synopsis:   Fills the text bag with the formats it supports
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::FillWithFormats(CMarkup *    pMarkup,
                           DWORD        dwFlags,
                           ISegmentList * pSegmentList )
{
    typedef HRESULT (CTextXBag::*FnSet)(CMarkup*, DWORD, ISegmentList *);

    static FnSet aFnSet[] = {
        SetText,
        SetUnicodeText,
        SetCFHTMLText,
#ifndef NO_RTF
        SetLazyRTFText
#endif // !NO_RTF
    };

    HRESULT hr = S_OK;
    int     n;

    // Allocate our _prgFormats array
    _cFormatMax = ARRAY_SIZE(aFnSet) + 3;
    _cTotal     = 0;
    _prgFormats = new(Mt(CTextXBag_prgFormats)) FORMATETC[_cFormatMax];
    if (NULL == _prgFormats)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    for (n = 0; n < ARRAY_SIZE(aFnSet); ++n)
    {
        // If one format fails to copy, do not abort all formats.
        IGNORE_HR(CALL_METHOD( this, aFnSet[n], (pMarkup, dwFlags, pSegmentList)));
    }
    
Cleanup:
    RRETURN(hr);
}


HRESULT 
CTextXBag::GetDataObjectInfo(IDataObject *   pdo,        // @parm data object to get info on
                             DWORD *         pDOIFlags)  // @parm out parm for info
{
    DWORD       i;
    FORMATETC * pfetc = g_rgFETC;

    for( i = 0; i < DWORD(CFETC); i++, pfetc++ )
    {
        if( pdo->QueryGetData(pfetc) == NOERROR )
            *pDOIFlags |= g_rgDOI[i];
    }
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTextXBag::GetHTMLText
//
//  Synopsis:   Converts the SegmentList into text stored in an hglobal
//
//----------------------------------------------------------------------------


HRESULT
CTextXBag::GetHTMLText(
    HGLOBAL      *  phGlobal, 
    ISegmentList *  pSegmentList,
    CMarkup      *  pMarkup, 
    DWORD           dwSaveHtmlMode,
    CODEPAGE        codepage, 
    DWORD           dwStrWrBuffFlags )
{
    HGLOBAL                 hGlobal  = NULL;   // Global memory handle
    LPSTREAM                pIStream = NULL;   // IStream pointer
    HRESULT                 hr;
    CDoc                    *pDoc;
    ISegment                *pISegment = NULL;
    ISegmentListIterator    *pIter = NULL;

    //
    // Do the prep work
    //
    hr = THR(CreateStreamOnHGlobal(NULL, FALSE, &pIStream));
    if (hr)
        goto Error;

    pDoc = pMarkup->Doc();
    Assert( pDoc );


    //
    // Use a scope to clean up the StreamWriteBuff
    //

    {
        CMarkupPointer      mpStart( pDoc ), mpEnd( pDoc );
        CStreamWriteBuff    StreamWriteBuff(pIStream, codepage);

        hr = THR( StreamWriteBuff.Init() );
        if( hr )
            goto Cleanup;

        StreamWriteBuff.SetFlags(dwStrWrBuffFlags);
      
        //
        // Save the segments using the range saver
        //
        hr = THR( pSegmentList->CreateIterator( &pIter ) );
        if( hr )
            goto Error;

        BOOL fEmpty = FALSE;

        hr = THR( pSegmentList->IsEmpty( &fEmpty ) );
        if( hr )
            goto Error;

        if (fEmpty)
            goto Error;

        hr = THR( pIter->Current(&pISegment) );
        if( hr )
            goto Error;
        
        hr = THR( pISegment->GetPointers(&mpStart, &mpEnd) );
        if( hr )
            goto Error;

        {
            CRangeSaver rs( &mpStart, &mpEnd, dwSaveHtmlMode , &StreamWriteBuff, mpStart.Markup() );
            hr = THR( rs.SaveSegmentList(pSegmentList, pMarkup));
            if (hr)
                goto Error;
        }

        StreamWriteBuff.Terminate();    // appends a null character
    }

    //
    // Wrap it up
    //
    hr = THR(GetHGlobalFromStream(pIStream, &hGlobal));
    if (hr)
        goto Error;

Cleanup:
    ReleaseInterface( pIStream );
    ReleaseInterface( pIter );
    ReleaseInterface( pISegment );
    *phGlobal = hGlobal;
    RRETURN(hr);

Error:
    if (hGlobal)
    {
        GlobalFree(hGlobal);
        hGlobal = NULL;
    }
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::SetTextHelper
//
//  Synopsis:   Gets text in a variety of formats
//
//  Argument:   pTxtSite:           The text site under which to get the text from
//              ppRanges:           Text ranges to save text from
//              cRanges:            Count of ppRanges
//              dwSaveHtmlFlags:    format to save in
//              cp:                 codepage to save in
//              dwStmWrBuffFlags:   stream write buffer flags
//              phGlobalText:       hGlobal to get back
//              iFETCIndex:         _prgFormat index, or -1 to not set it
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::SetTextHelper(CMarkup *      pMarkup,
                         ISegmentList * pSegmentList,
                         DWORD          dwSaveHtmlFlags,
                         CODEPAGE       cp,
                         DWORD          dwStmWrBuffFlags,
                         HGLOBAL *      phGlobalText,
                         int            iFETCIndex,
                         BOOL           fSetToNull /*=TRUE*/)                         
{
    HRESULT hr = S_OK;
    HGLOBAL hText = NULL;

    Assert(_cTotal < _cFormatMax);

    // Make sure not to crash if we are out of space for this format.
    if (_cTotal >= _cFormatMax)
        return S_OK;

    if (pSegmentList)
    {
        hr = THR(GetHTMLText( 
                    &hText, pSegmentList, pMarkup, 
                    dwSaveHtmlFlags, cp, dwStmWrBuffFlags));
        if (hr || !hText)
            goto Error;
    }
    else
    {
        Assert(!pMarkup && !dwSaveHtmlFlags && !cp && !dwStmWrBuffFlags);
        Assert(phGlobalText);
        Assert(iUnicodeFETC == iFETCIndex || iAnsiFETC == iFETCIndex);
        hText = *phGlobalText;
        // remove data from FETC array.
        if (!hText)
        {
            int i,j;
            CLIPFORMAT cfFormat = (iUnicodeFETC == iFETCIndex) ? CF_UNICODETEXT : CF_TEXT;
            for (i = 0; i < _cTotal; i++)
            {
                if (_prgFormats[i].cfFormat == cfFormat)
                {
                    Assert(_cTotal > 0);
                    _cTotal--;
                    for (j = i; j < _cTotal; j++)
                        _prgFormats[j] = _prgFormats[j+1];

                    break;
                }
            }

            goto Cleanup;
        }
    }

    // if the text length is zero, pretend as if the format is
    // unavailable (see bug #52407)
    if (iUnicodeFETC == iFETCIndex || iAnsiFETC == iFETCIndex)
    {
        BOOL    fEmpty;

        Assert(hText);

        LPVOID pText= GlobalLock(hText);
        if (pText == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        if( iAnsiFETC == iFETCIndex ) 
        {
            fEmpty= *((char *)pText) == 0;
        }
        else
        {
            // Please don't use strlen on unicode strings.
            fEmpty= *((TCHAR *)pText) == 0;
        }
        GlobalUnlock(hText);
        if (fEmpty && fSetToNull )
        {
            GlobalFree(hText);
            hText = NULL;
            goto Cleanup;
        }
    }

    if (iFETCIndex != -1)
    {
        _prgFormats[ _cTotal++ ] = g_rgFETC[iFETCIndex];
    }

Cleanup:

    *phGlobalText = hText;

    RRETURN(hr);

Error:
    if (hText)
    {
        GlobalFree(hText);
        hText = NULL;
    }

    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::SetText
//
//  Synopsis:   Gets ansi plaintext in CP_ACP
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::SetText(CMarkup *      pMarkup,
                   DWORD          dwFlags,
                   ISegmentList * pSegmentList )
{
    DWORD dwBuffFlags = WBF_SAVE_PLAINTEXT|WBF_NO_WRAP|WBF_FORMATTED_PLAINTEXT;
    DWORD dwHTMLFlags = RSF_SELECTION|RSF_NO_ENTITIZE_UNKNOWN;

    if (!(dwFlags & CREATE_FLAGS_SupportsHtml))
    {
        dwBuffFlags |= WBF_KEEP_BREAKS;
    }
    if( dwFlags & CREATE_FLAGS_NoIE4SelCompat )
    {
        dwHTMLFlags |= RSF_NO_IE4_COMPAT_SEL;
    }

    RRETURN( SetTextHelper( pMarkup, pSegmentList,
                            dwHTMLFlags,
                            g_cpDefault, dwBuffFlags, &_hText, iAnsiFETC ) );
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::SetUnicodeText
//
//  Synopsis:   Gets unicode plaintext
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::SetUnicodeText(CMarkup *      pMarkup,
                          DWORD          dwFlags,
                          ISegmentList * pSegmentList )
{
    DWORD dwBuffFlags = WBF_SAVE_PLAINTEXT|WBF_NO_WRAP|WBF_FORMATTED_PLAINTEXT;
    DWORD dwHTMLFlags = RSF_SELECTION;

    if (!(dwFlags & CREATE_FLAGS_SupportsHtml))
    {
        dwBuffFlags |= WBF_KEEP_BREAKS;
    }
    if( dwFlags & CREATE_FLAGS_NoIE4SelCompat )
    {
        dwHTMLFlags |= RSF_NO_IE4_COMPAT_SEL;
    }

    RRETURN(SetTextHelper(pMarkup, pSegmentList,
                          dwHTMLFlags, CP_UCS_2,
                          dwBuffFlags, &_hUnicodeText, iUnicodeFETC));
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::SetCFHTMLText
//
//  Synopsis:   Gets HTML with CF_HTML header in UTF-8
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::SetCFHTMLText(CMarkup *      pMarkup,
                         DWORD          dwFlags,
                         ISegmentList * pSegmentList )
{
    HRESULT hr = S_OK;
    DWORD dwHTMLFlags = RSF_CFHTML;

    if( dwFlags & CREATE_FLAGS_NoIE4SelCompat )
    {
        dwHTMLFlags |= RSF_NO_IE4_COMPAT_SEL;
    }

    if (dwFlags & CREATE_FLAGS_SupportsHtml)
    {
        hr = THR(SetTextHelper(pMarkup, pSegmentList,
            dwHTMLFlags, CP_UTF_8, WBF_NO_NAMED_ENTITIES, &_hCFHTMLText, iHTML));
    }

    RRETURN(hr);
}

#ifndef NO_RTF
//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::SetLazyRTFText
//
//  Synopsis:   Gets RTF from the HTML
//
//-------------------------------------------------------------------------
HRESULT
CTextXBag::SetLazyRTFText(CMarkup *     pMarkup,
                          DWORD          dwFlags,
                          ISegmentList * pSegmentList )
{
#ifdef WINCE
    return S_OK;
#else
    if (!pMarkup->Doc()->RtfConverterEnabled())
        return S_OK;

    HRESULT hr = S_OK;
    HGLOBAL hHTMLText = NULL;     
    DWORD dwHTMLFlags = RSF_FOR_RTF_CONV|RSF_FRAGMENT;
    
    Assert(_cTotal < _cFormatMax);

    // Do not dump out RTF for intrinsics
    if (!(dwFlags & CREATE_FLAGS_SupportsHtml))
        return S_OK;

    // Make sure not to crash if we are out of space for this format.
    if (_cTotal >= _cFormatMax)
        return S_OK;

    if( dwFlags & CREATE_FLAGS_NoIE4SelCompat )
    {
        dwHTMLFlags |= RSF_NO_IE4_COMPAT_SEL;
    }

    //
    //  For the RTF converter, do not use name entities, since our name list
    //  can be more recent.  Save in UTF-8 so that we can at least represent
    //  the unicode for every character.
    //
    hr = THR(SetTextHelper(pMarkup, pSegmentList,
        dwHTMLFlags, CP_UTF_8,
        WBF_NO_NAMED_ENTITIES, &hHTMLText, -1));

    if (hr)
        goto Cleanup;

    // Add RTF to the clipboard formats only if conversion succeeded
    _prgFormats[ _cTotal++ ] = g_rgFETC[iRtfFETC];
    _fRtfConverted = FALSE;
    _hRTFText = hHTMLText;

Cleanup:
    RRETURN(hr);
#endif // WINCE
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::ConvertHTMLToRTF
//
//  Synopsis:   Calls the RTF to HTML converter
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::ConvertHTMLToRTF(HGLOBAL hHTMLText, HGLOBAL *phRTFText)
{
    HRESULT              hr = S_OK;
    HGLOBAL              hRTFText = NULL;
    LPSTR                pszHtml;

    Assert(phRTFText);

    *phRTFText = NULL;
    
    pszHtml = (LPSTR)GlobalLock(hHTMLText);
    if (!pszHtml)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(CRtfToHtmlConverter::StringHtmlToStringRtf(NULL, pszHtml, &hRTFText));

    GlobalUnlock(hHTMLText);

    if (hr)
        goto Cleanup;
    
    *phRTFText = hRTFText;

Cleanup:
    RRETURN(hr);
}
#endif // ndef NO_RTF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\flownode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       flownode.cxx
//
//  Contents:   Routines for managing display tree nodes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

extern const ZERO_STRUCTS g_Zero;

ExternTag(tagCalcSize);

//+----------------------------------------------------------------------------
//
//  Member:     AddLayoutDispNode
//
//  Synopsis:   Add, as a sibling of the passed display node,
//              the display node of passed layout
//
//  Arguments:  pTreeNode    - CTreeNode from which to obtain the layout
//              pLayout      - Layout whose display node is to be added
//              dx, dy       - Left/top offset to set on the node
//              pDispSibling - CDispNode that is the left-hand sibling
//              dwBlockIDParent - Layout block ID of this parent line array
//
//  Returns:    Node to be used as the next sibling if successful, NULL otherwise
//
//-----------------------------------------------------------------------------

CDispNode *
CDisplay::AddLayoutDispNode(
    CParentInfo *   ppi,
    CLayout *       pLayout,
    long            dx,
    long            dy,
    CDispNode *     pDispSibling
    )
{
    CDispNode   * pDispNode;
    CFlowLayout * pFL = GetFlowLayout();

    Assert(pLayout);
    Assert(!pLayout->IsDisplayNone());

    pDispNode = pLayout->GetElementDispNode();

    Assert(!pDispNode || pDispSibling != pDispNode);

    //
    //  Insert the node if it exists
    //  (Nodes will not exist for unmeasured elements, such as hidden INPUTs or
    //   layouts which have display set to none)
    //

    if (pDispNode)
    {
        Assert(pDispNode->IsFlowNode());

        //
        // If no sibling was provided, insert directly under the content containing node
        //

        if (!pDispSibling)
        {
            //
            //  Ensure the display node can contain children
            //

            if (!pFL->EnsureDispNodeIsContainer())
                goto Cleanup;

            pDispSibling = pFL->GetFirstContentDispNode();


            if (!pDispSibling)
                goto Cleanup;
        }

        pDispSibling->InsertSiblingNode(pDispNode, CDispNode::after);

        //
        //  Position the node
        //
        pLayout->SetPosition(CPoint(dx, dy), TRUE);

        pDispSibling = pDispNode;
    }
Cleanup:
    return pDispSibling;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetPreviousDispNode
//
//  Synopsis:   Given a cp, find the display node just before that which
//              would contain the cp
//
//  Arguments:  cp - cp for searching
//              dwBlockID - layout block ID
//
//  Returns:    Previous CDispNode (if found), NULL otherwise
//
//-----------------------------------------------------------------------------

CDispNode *
CDisplay::GetPreviousDispNode(
    long    cp,
    long    iLineStart
    )
{
    CFlowLayout * pFlowLayout       = GetFlowLayout();
    CDispNode   * pDispNodeOwner    = pFlowLayout->GetElementDispNode();
    CDispNode   * pDispNodeSibling  = NULL;


    Assert(pDispNodeOwner);

    if(pDispNodeOwner->IsContainer())
    {
        CDispNode * pDispNode = pFlowLayout->GetFirstContentDispNode();

        void *      pvOwner;
        CElement *  pElement;

        Assert(pDispNode);

        pDispNodeSibling = pDispNode;

        //
        // Since the first node is the flownode, we can just skip it.
        //

        for (pDispNode = pDispNode->GetNextFlowNode();
             pDispNode;
             pDispNode = pDispNode->GetNextFlowNode())
        {
            CDispClient * pDispClient = pFlowLayout;

            //
            // if the disp node corresponds to the text flow,
            // the cookie stores the line index from where the
            // current text flow node starts.
            //
            if (pDispNode->GetDispClient() == pDispClient)
            {
                if(iLineStart <= (LONG)(LONG_PTR)pDispNode->GetExtraCookie())
                    break;
            }
            else
            {
                pDispNode->GetDispClient()->GetOwner(pDispNode, &pvOwner);

                if (pvOwner)
                {
                    pElement = DYNCAST(CElement, (CElement *)pvOwner);
                    if(pElement->GetFirstCp() >= cp)
                        break;
                }
            }

            pDispNodeSibling = pDispNode;
        }
    }

    return pDispNodeSibling;
}


//+----------------------------------------------------------------------------
//
//  Member:     AdjustDispNodes
//
//  Synopsis:   Adjust display nodes after text measurement
//              * Newly added display nodes may be adjusted horizontally for RTL
//              * Display nodes following last node produced by this measrurement 
//                pass are extracted or translated
//
//  Arguments:  pdnLastUnchanged - Left-hand sibling of first display node affected by change
//                                 NULL in clean recalc
//              pdnLastChanged   - Last display node affected (added) by calculation
//                                 NULL if no new nodes added
//              pled             - Current CLed (may be NULL)
//
//-----------------------------------------------------------------------------

void
CDisplay::AdjustDispNodes(
    CDispNode * pdnLastUnchanged,
    CDispNode * pdnLastChanged,
    CLed *      pled
    )
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CDisplay::AdjustDispNodes() LU:0x%x LC:0x%x LED:0x%x", pdnLastUnchanged, pdnLastChanged, pled ));
    CDispNode * pDispNodeOwner = GetFlowLayout()->GetElementDispNode();

    if (pDispNodeOwner && pDispNodeOwner->IsContainer())
    {

        // If last changed node is NULL, it means there are no new nodes. Adjust everything.
        if (!pdnLastChanged)
        {
            pdnLastChanged = GetFlowLayout()->GetFirstContentDispNode();
            if (!pdnLastChanged)
            {
                TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::AdjustDispNodes()" ));
                return;
            }
        }

        //
        // Adjust dispay nodes following the newly calculated ones
        //
        CDispNode* pDNAdjustFrom = pdnLastChanged->GetNextFlowNode();

        if (pDNAdjustFrom)
        {
            if (    !pled
                ||  pled->_iliMatchNew == MAXLONG)
            {
                GetFlowLayout()->ExtractDispNodes(pDNAdjustFrom);
            }
            else
            {
                //
                // Update the cookie on text disp nodes and destroy
                // any that lie in the dirty line's range
                if (_fHasMultipleTextNodes)
                {
                    CDispClient * pDispClient = GetFlowLayout();
                    CDispNode * pDispNode = pDNAdjustFrom;
                    
                    while (pDispNode)
                    {
                        CDispNode * pDispNodeCur = pDispNode;

                        pDispNode = pDispNode->GetNextFlowNode();

                        if (pDispNodeCur->GetDispClient() == pDispClient)
                        {
                            long iLine = (LONG)(LONG_PTR)pDispNodeCur->GetExtraCookie();

                            if (iLine < pled->_iliMatchOld)
                            {
                                Assert(!pDispNodeCur->IsOwned());

                                if (pDNAdjustFrom == pDispNodeCur)
                                {
                                    pDNAdjustFrom = pDispNode;
                                }

                                //
                                // Extract the disp node and destroy it
                                //
                                // NOTE: (donmarsh) - do we really have to extract
                                // these from the tree?  It would probably be
                                // more efficient to just Destroy them, and then
                                // let batch processing remove them from the tree.
                                GetFlowLayout()->GetView()->ExtractDispNode(pDispNodeCur);
                                pDispNodeCur->Destroy();
                            }
                            else
                            {
                                pDispNodeCur->SetExtraCookie(
                                                (void *)(LONG_PTR)(iLine +
                                                pled->_iliMatchNew -
                                                pled->_iliMatchOld));
                            }
                        }
                    }
                }

                if (pDNAdjustFrom)
                {
                    GetFlowLayout()->TranslateDispNodes(
                                        CSize(0, pled->_yMatchNew - pled->_yMatchOld),
                                        pDNAdjustFrom,
                                        NULL,       // dispnode to stop at
                                        TRUE,       // restrict to layer
                                        TRUE
                                        );      // extract hidden
                }
            }
        }
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::AdjustDispNodes()" ));
}


//+----------------------------------------------------------------------------
//
//  Member:     DestroyFlowDispNodes
//
//  Synopsis:   Destroy all display tree nodes created for the flow layer
//
//-----------------------------------------------------------------------------

void
CDisplay::DestroyFlowDispNodes()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\font.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module FONT.C -- font cache
 *
 *  Owner: GrzegorZ, SujalP and DmitryT
 *
 *  Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

DeclareTag( tagTextOutA, "TextOut", "Render using TextOutA always." );
DeclareTag( tagTextOutFE, "TextOut", "Reneder using FE ExtTextOutW workaround.");
DeclareTag( tagCCcsMakeFont, "Font", "Trace CCcs::MakeFont");
DeclareTag( tagCCcsCompare, "Font", "Trace CCcs::Compare");
DeclareTag( tagFontLeaks, "Font", "Trace HFONT leaks");
DeclareTag( tagFontNoWidth, "Font", "Trace no width");

MtDefine(CCcs, PerProcess, "CCcs");
MtDefine(CBaseCcs, PerProcess, "CBaseCcs");
MtDefine(CWidthCache, PerProcess, "CWidthCache");
MtDefine(CWidthCacheEntry, CWidthCache, "CWidthCache::GetEntry");

//
// UseScreenDCForMeasuring()
// 
// We were using printer DC to measure fonts when printing. That is not 
// the right thing to do with printer-independent measurement. When combined 
// with huge virtual printer resolution, it has produced bogus font data on some 
// printers. The bogus fonts are probably a printer driver bug, but using 
// printer DC for anything other than final output is wrong in the new printing 
// model.
// 
// The fix is to always use screen-compatible DC for font measurements. Note 
// that in the future, we may need to make a special case for printer fonts, 
// which can only be measured in printer DC. 
//
// In IE5.5, printer fonts are not supported.
//
// (This fixes bug 101791: HOT IE 5.5 2827: Printing http://www.msn.com home page, 
// text is overlayed, missing and out of place.)
//
void UseScreenDCForMeasuring(XHDC *pxhdc)
{
#if NEEDED // DBG==1
    // Font measurements should never be taken from printer DC. 
    // That's how it becines printer-independent

    int technology = GetDeviceCaps(pxhdc->GetFontInfoDC(), TECHNOLOGY);
    int logpixel_x = GetDeviceCaps(pxhdc->GetFontInfoDC(), LOGPIXELSX);

    if (technology != DT_RASDISPLAY ||
        logpixel_x > 200)
    {
        AssertSz(FALSE, "We must not take font metrics from printer DC!");
    }
#endif

    *pxhdc = XHDC(TLS(hdcDesktop), NULL);
}

//+----------------------------------------------------------------------------
//
//  Begin font wrappers
//
//-----------------------------------------------------------------------------

// We need this wrapper to compile. 
// In this file (font.cxx) GetCharWidth32 is resolved to wrapper from 
//      mshtml\src\core\include\xgdiwrap.h
// But in flowlyt.cxx GetCharWidth32 is resolved to wrapper from <w95wrap.h>
// No time to investigate this problem.
BOOL GetCharWidthHelper(XHDC hdc, UINT c, LPINT piWidth)
{
    return GetCharWidth32(hdc, c, c, piWidth);
}

//#if DBG != 1

inline BOOL    DeleteFontIdx(FONTIDX hfont)         { return DeleteFontEx(hfont); }
inline FONTIDX GetSystemFontIdx()                   { return (HFONT)GetStockObject(SYSTEM_FONT); }
inline FONTIDX GetCurrentFontIdx(XHDC hdc)          { return (HFONT)GetCurrentObject(hdc, OBJ_FONT); }
inline FONTIDX CreateFontIndirectIdx(CONST LOGFONT *lplf) { return CreateFontIndirect(lplf); }
inline FONTIDX PushFontIdx(XHDC hdc, FONTIDX idx)   { return SelectFontEx(hdc, idx); }
inline FONTIDX PopFontIdx(XHDC hdc, FONTIDX idx)    { return SelectFontEx(hdc, idx); }
inline HFONT   GetFontFromIdx(FONTIDX idx)          { return idx; }

//#else
#if DBG == 1

MtDefine(IdxToHFONT, PerProcess, "CIdxToHFONT")

// ----------------------------------------------------------------------------
// Implementation of HDC <=> HFONT mapping; HFONT leaks detection
// ----------------------------------------------------------------------------
const int cMapSize = 1024;
class CDCToHFONT
{
    HDC   _dc[cMapSize];
    HFONT _font[cMapSize];
    DWORD _objType[cMapSize];
public:
    CDCToHFONT() 
    {
        memset(_dc, 0, cMapSize*sizeof(HDC));
        memset(_font, 0, cMapSize*sizeof(HFONT));
        memset(_objType, 0, cMapSize*sizeof(DWORD));
    };
    void Assign(HDC hdc, HFONT hfont) 
    {
        int freePos = -1;
        for (int i = 0; i < cMapSize; i++) 
        {
            if (_dc[i] == hdc) 
            {
                _font[i] = hfont;
                return;
            } 
            else if (freePos == -1 && _dc[i] == 0)
                freePos = i;
        }
        if (freePos == -1) 
        {
            CleanMap();
            for (int i = 0; i < cMapSize; i++) 
            {
                if (_dc[i] == 0) 
                {
                    freePos = i;
                    break;
                }
            }
            Assert(freePos != -1);
        }
        _dc[freePos] = hdc;
        _font[freePos] = hfont;
        _objType[freePos] = ::GetObjectType(hdc);
    };
    int FindNextFont(int posStart, HFONT hfont) 
    {
        for (int i = posStart; i < cMapSize; i++) 
        {
            if (_font[i] == hfont)
                return i;
        }
        return -1;
    };
    void CleanMap() 
    {
        for (int i = 0; i < cMapSize; i++) 
        {
            if (_objType[i] != OBJ_DC) 
            {
                _dc[i] = 0;
                _font[i] = 0;
                _objType[i] = 0;
            }
        }
    };
    void Erase(int pos) 
    {
        _dc[pos] = 0;
        _font[pos] = 0;
        _objType[pos] = 0;
    };
    HFONT Font(int pos) 
    {
        return _font[pos];
    };
    HDC DC(int pos) 
    {
        return _dc[pos];
    };
};

#ifdef NEVER
// ----------------------------------------------------------------------------
// Implementation of index <=> HFONT mapping
// ----------------------------------------------------------------------------
class CIdxToHFONT
{
    struct FONTDATA {
        HFONT _font;
        DWORD _data;
    };
    enum {
        MASK_CREATED = 0x80000000,
        MASK_ALL     = 0x80000000
    };
    FONTDATA *   _afd;
    size_t       _size;
    const size_t _cchunk;
    CRITICAL_SECTION _cs;

    void Alloc();
    void Realloc();
    DWORD Ref(FONTIDX idx)       const { return (_afd[idx]._data & ~MASK_ALL); };
    void  SetCreated(FONTIDX idx)      { _afd[idx]._data |= MASK_CREATED; };

    FONTIDX Add(HFONT hfont, BOOL fCreated);

public:
    CIdxToHFONT();
    ~CIdxToHFONT();

    BOOL  IsCreated(FONTIDX idx) const { return !!(_afd[idx]._data & MASK_CREATED); };
    void ClearFontData(FONTIDX idx)    { _afd[idx]._font = HFONT_INVALID; _afd[idx]._data = 0; };

    FONTIDX AddFont(HFONT hfont, BOOL fCreated);
    FONTIDX IdxFromHFont(HFONT hfont, BOOL fAdd);
    HFONT RemoveFont(FONTIDX idx);
    HFONT HFontFromIdx(FONTIDX idx);

    void AddRef(FONTIDX idx);
    void Release(FONTIDX idx, BOOL fStrict);
};

CIdxToHFONT::CIdxToHFONT()
    : _cchunk(32) 
{
    HrInitializeCriticalSection(&_cs);
    _size = 0;
    _afd  = 0;
    Alloc();
}
CIdxToHFONT::~CIdxToHFONT() 
{
    MemFree((void *)_afd);
    DeleteCriticalSection(&_cs);
}
void CIdxToHFONT::Alloc() 
{
    Assert(_size == 0);
    _afd = (FONTDATA *) MemAlloc(Mt(IdxToHFONT), _cchunk * sizeof(FONTDATA));
    memset((void *)_afd, 0, _cchunk * sizeof(FONTDATA));
    _size += _cchunk;
}
void CIdxToHFONT::Realloc() 
{
    MemRealloc(Mt(IdxToHFONT), (void **)&_afd, (_size + _cchunk) * sizeof(FONTDATA));
    memset((void *)(_afd + _size), 0, _cchunk * sizeof(FONTDATA));
    _size += _cchunk;
}
FONTIDX CIdxToHFONT::Add(HFONT hfont, BOOL fCreated) 
{
    size_t i = 1;       // skip 0
    while (i < _size)
    {
        if (_afd[i]._font == HFONT_INVALID)
            break;
        ++i;
    }
    if (i == _size)
    {
        Realloc();
        Assert(i == _size - _cchunk);
    }
    Assert(_afd[i]._data == 0);
    _afd[i]._font = hfont;
    if (fCreated)
        SetCreated(i);
    return i;
};
FONTIDX CIdxToHFONT::AddFont(HFONT hfont, BOOL fCreated) 
{
    EnterCriticalSection(&_cs);
    AssertSz(hfont != HFONT_INVALID, "Got invalid font handle");
    size_t i = 1;       // skip 0
    while (i < _size)
    {
        if (_afd[i]._font == hfont)
        {
            AssertSz(fCreated, "Duplicate font handle");
            break;
        }
        ++i;
    }
    if (i == _size)
        i = Add(hfont, fCreated);
    LeaveCriticalSection(&_cs);
    return i;
};
HFONT CIdxToHFONT::RemoveFont(FONTIDX idx) 
{
    EnterCriticalSection(&_cs);
    AssertSz(idx < _size,    "Accessing non-existing entry");
    AssertSz(IsCreated(idx), "Deleting non-Trident created font");
    AssertSz(Ref(idx) == 0,  "Deleting selected font");
    HFONT hfont = _afd[idx]._font;
    AssertSz(hfont != HFONT_INVALID, "Got invalid font handle");
    ClearFontData(idx);
    LeaveCriticalSection(&_cs);
    return hfont;
};
FONTIDX CIdxToHFONT::IdxFromHFont(HFONT hfont, BOOL fAdd) 
{
    EnterCriticalSection(&_cs);
    AssertSz(hfont != HFONT_INVALID, "Got invalid font handle");
    size_t i = 1;       // skip 0
    while (i < _size)
    {
        if (_afd[i]._font == hfont)
            break;
        ++i;
    }
    if (i == _size)
    {
        AssertSz(fAdd, "Font index not found");
        i = AddFont(hfont, FALSE);
    }
    LeaveCriticalSection(&_cs);
    return i;
};

HFONT CIdxToHFONT::HFontFromIdx(FONTIDX idx) 
{
    EnterCriticalSection(&_cs);
    AssertSz(idx < _size,    "Accessing non-existing entry");
    HFONT hfont = _afd[idx]._font;
    AssertSz(hfont != HFONT_INVALID, "Got invalid font handle");
    LeaveCriticalSection(&_cs);
    return hfont;
};

void CIdxToHFONT::AddRef(FONTIDX idx)
{
    EnterCriticalSection(&_cs);
    AssertSz(idx < _size,    "Accessing non-existing entry");
    ++_afd[idx]._data;
    AssertSz(Ref(idx) != 0, "Ref counter overflow");
    LeaveCriticalSection(&_cs);
};

void CIdxToHFONT::Release(FONTIDX idx, BOOL fStrict)
{
    EnterCriticalSection(&_cs);
    AssertSz(idx < _size,    "Accessing non-existing entry");
    if (Ref(idx) == 0)
        AssertSz(!fStrict, "Releasing unselected object");
    else
        --_afd[idx]._data;
    LeaveCriticalSection(&_cs);
};
CIdxToHFONT g_mIdx2HFont;
#endif

CDCToHFONT mDc2Font;

inline BOOL IsFontHandle(HFONT hfont)
{
    // WIN64: GetObjectType is returning zero.
#ifndef _WIN64
    return (OBJ_FONT == GetObjectType(hfont));
#else
    return TRUE;
#endif
}

#ifdef NEVER

inline BOOL DeleteFontIdx(FONTIDX idx)
{
    HFONT hfont = g_mIdx2HFont.RemoveFont(idx);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    return DeleteFontEx(hfont);
}

inline FONTIDX GetSystemFontIdx()
{
    HFONT hfont = (HFONT)GetStockObject(SYSTEM_FONT);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    return g_mIdx2HFont.AddFont(hfont, FALSE);
}

inline FONTIDX CreateFontIndirectIdx(CONST LOGFONT *lplf)
{
    HFONT hfont = CreateFontIndirect(lplf);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    return g_mIdx2HFont.AddFont(hfont, TRUE);
}

inline FONTIDX GetCurrentFontIdx(XHDC hdc)
{
    HFONT hfont = (HFONT)GetCurrentObject(hdc, OBJ_FONT);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    return g_mIdx2HFont.IdxFromHFont(hfont, TRUE);
}

FONTIDX PushFontIdx(XHDC hdc, FONTIDX idx)
{
    HFONT hfont = g_mIdx2HFont.HFontFromIdx(idx);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    HFONT hfontold = SelectFontEx(hdc, hfont);
    AssertSz(IsFontHandle(hfontold), "This is not valid font handle");

    g_mIdx2HFont.AddRef(idx);
    FONTIDX idxold = g_mIdx2HFont.IdxFromHFont(hfontold, FALSE);
    g_mIdx2HFont.Release(idxold, FALSE);

    return idxold;
}

FONTIDX PopFontIdx(XHDC hdc, FONTIDX idx)
{
    HFONT hfont = g_mIdx2HFont.HFontFromIdx(idx);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    HFONT hfontold = SelectFontEx(hdc, hfont);
    AssertSz(IsFontHandle(hfontold), "This is not valid font handle");

    g_mIdx2HFont.AddRef(idx);
    FONTIDX idxold = g_mIdx2HFont.IdxFromHFont(hfontold, FALSE);
    g_mIdx2HFont.Release(idxold, TRUE);

    // if we are selecting back font not created by us, remove it from our mapping
    if (!g_mIdx2HFont.IsCreated(idx))
    {
        g_mIdx2HFont.ClearFontData(idx);
    }

    return idxold;
}

inline HFONT GetFontFromIdx(FONTIDX idx)
{ 
    return g_mIdx2HFont.HFontFromIdx(idx);; 
}

#endif

HFONT SelectFontEx(XHDC hdc, HFONT hfont)
{
    if (IsTagEnabled(tagFontLeaks))
    {
        mDc2Font.Assign(hdc.GetDebugDC(), hfont);
    }
    return SelectFont(hdc.GetDebugDC(), hfont);
}

BOOL DeleteFontEx(HFONT hfont)
{
    if (IsTagEnabled(tagFontLeaks))
    {
        int pos = -1;
        while (-1 != (pos = mDc2Font.FindNextFont(pos+1, hfont))) 
        {
            TraceTag((tagFontLeaks, "##### Attempt to delete selected font"));
            SelectObject(mDc2Font.DC(pos), GetStockObject(SYSTEM_FONT));
            mDc2Font.Erase(pos);
        }
    }
    return DeleteObject((HGDIOBJ)hfont);
}

#endif // DBG==1
//+----------------------------------------------------------------------------
//
//  End font wrappers
//
//-----------------------------------------------------------------------------

#define CLIP_DFA_OVERRIDE   0x40    //  Used to disable Korea & Taiwan font association

// corresponds to yHeightCharPtsMost in textedit.h
#define yHeightCharMost 32760

ExternTag(tagMetrics);

static TCHAR lfScriptFaceName[LF_FACESIZE] = _T("Script");

inline const TCHAR * Arial() { return _T("Arial"); }
inline const TCHAR * TimesNewRoman() { return _T("Times New Roman"); }


// U+0000 -> U+4DFF     All Latin and other phonetics.
// U+4E00 -> U+ABFF     CJK Ideographics
// U+AC00 -> U+FFFF     Korean+, as Korean ends at U+D7A3

// For 2 caches at CJK Ideo split, max cache sizes {256,512} that give us a
// respective collision rate of <4% and <22%, and overall rate of <8%.
// Stats based on a 300K char Japanese text file.
const INT maxCacheSize[TOTALCACHES] = {255, 511, 511};

DeclareTag(tagFontCache, "FontCache", "FontCache");

#define IsZeroWidth(ch) ((ch) >= 0x0300 && IsZeroWidthChar((ch)))

//
// Work around Win9x GDI bugs
//

static inline BOOL
FEFontOnNonFE95(BYTE bCharSet)
{
    // Use ExtTextOutA to hack around all sort of Win95FE EMF or font problems
    return VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID &&
            !g_fFarEastWin9X &&
            IsFECharset(bCharSet);
}

#if DBG==1
LONG CBaseCcs::s_cMaxCccs = 0;
LONG CBaseCcs::s_cTotalCccs = 0;
#endif

// =============================  CBaseCcs  class  ============================

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::Init
//
//  Synopsis:   Init one font cache object. The global font cache stores
//              individual CBaseCcs objects.
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::Init(
    XHDC hdc,                       // HDC into which font will be selected
    const CCharFormat * const pcf,  // description of desired logical font
    CDocInfo * pdci,
    LONG latmBaseFaceName,
    BOOL fForceTTFont)
{
    Assert(pdci && pdci->_pDoc);

    _sc = NULL; // Initialize script cache to NULL - COMPLEXSCRIPT
    _fPrinting = pdci->_pMarkup->IsPrintMedia();
    _bConvertMode = CM_NONE;
    _fScalingRequired = FALSE;

    if (MakeFont(hdc, pcf, pdci, fForceTTFont))
    {
        _bCrc = pcf->_bCrcFont;
        _yCfHeight = pcf->_yHeight;
        _latmBaseFaceName = latmBaseFaceName;
        _fHeightAdjustedForFontlinking = FALSE;

        // TODO: (cthrash, track bug 112152) This needs to be removed.  We used to calculate
        // this all the time, now we only calculate it on an as-needed basis,
        // which means at intrinsics fontlinking time.
      
        _dwLangBits = 0;

        _dwAge = fc()._dwAgeNext++;

        return TRUE;         // successfully created a new font cache.
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::ReleaseScriptCache
//
//-----------------------------------------------------------------------------

void
CBaseCcs::ReleaseScriptCache()
{
    // Free the script cache
    if (_sc)
    {
        ::ScriptFreeCache(&_sc);
        // NB (mikejoch) If ScriptFreeCache() fails then there is no way to
        // free the cache, so we'll end up leaking it. This shouldn't ever
        // happen since the only way for _sc to be non- NULL is via some other
        // USP function succeeding.

        Assert(_sc == NULL);
        _sc = NULL; // A safety value so we don't crash.
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::PrivateRelease
//
//-----------------------------------------------------------------------------

void
CBaseCcs::PrivateRelease()
{
    if (InterlockedDecrement((LONG *)&_dwRefCount) == 0)
        delete this;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GrabInitNewBaseCcs
//
//  Synopsis:   Create a logical font and store it in our cache.
//
//-----------------------------------------------------------------------------

CBaseCcs *
CFontCache::GrabInitNewBaseCcs(
    XHDC hdc,                       // HDC into which font will be selected
    const CCharFormat * const pcf,  // description of desired logical font
    CDocInfo * pdci,
    LONG latmBaseFaceName,
    BOOL fForceTTFont)
{
    int     i;
    int     iReplace = -1;
    int     iOldest = -1;
    DWORD   dwAgeReplace = 0xffffffff;
    DWORD   dwAgeOldest = 0xffffffff;
    CBaseCcs *pBaseCcsNew = new CBaseCcs();

    // Initialize new CBaseCcs
    if (!pBaseCcsNew || !pBaseCcsNew->Init(hdc, pcf, pdci, latmBaseFaceName, fForceTTFont))
    {
        if (pBaseCcsNew)
            pBaseCcsNew->PrivateRelease();

        AssertSz(FALSE, "CFontCache::GrabInitNewBaseCcs init of entry FAILED");
        return NULL;
    }

    MemSetName((pBaseCcsNew, "CBaseCcs F:%ls, H:%d, W:%d", pBaseCcsNew->_lf.lfFaceName, -pBaseCcsNew->_lf.lfHeight, pBaseCcsNew->_lf.lfWeight));

    // Don't cache in 'force TrueType' mode
    if (!fForceTTFont)
    {
        // look for unused entry and oldest in use entry
        for(i = 0; i < CFontCache::cFontCacheSize && _rpBaseCcs[i]; i++)
        {
            CBaseCcs * pBaseCcs = _rpBaseCcs[i];
            if (pBaseCcs->_dwAge < dwAgeOldest)
            {
                iOldest = i;
                dwAgeOldest = pBaseCcs->_dwAge;
            }
            if (pBaseCcs->_dwRefCount == 1)
            {
                if (pBaseCcs->_dwAge < dwAgeReplace)
                {
                    iReplace  = i;
                    dwAgeReplace = pBaseCcs->_dwAge;
                }
            }
        }

        if (i == CFontCache::cFontCacheSize)     // Didn't find an unused entry, use oldest entry
        {
            int hashKey;
            // if we didn't find a replacement, replace the oldest
            if (iReplace == -1)
            {
                Assert(iOldest != -1);
                iReplace = iOldest;
            }

#if DBG == 1
            _cCccsReplaced++;
#endif

            hashKey = _rpBaseCcs[iReplace]->_bCrc & CFontCache::cQuickCrcSearchSize;
            if (quickCrcSearch[hashKey].pBaseCcs == _rpBaseCcs[iReplace])
            {
                quickCrcSearch[hashKey].pBaseCcs = NULL;
            }

            TraceTag((tagFontCache, "Releasing font(F:%ls, H:%d, W:%d) from slot %d",
                      _rpBaseCcs[iReplace]->_lf.lfFaceName,
                      -_rpBaseCcs[iReplace]->_lf.lfHeight,
                      _rpBaseCcs[iReplace]->_lf.lfWeight,
                      iReplace));

            _rpBaseCcs[iReplace]->PrivateRelease();
            i = iReplace;
        }

        TraceTag((tagFontCache, "Storing font(F:%ls, H:%d, W:%d) in slot %d",
                  pBaseCcsNew->_lf.lfFaceName,
                  -pBaseCcsNew->_lf.lfHeight,
                  pBaseCcsNew->_lf.lfWeight,
                  i));

        _rpBaseCcs[i]  = pBaseCcsNew;
    }

    return pBaseCcsNew;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::MakeFont
//
//  Synopsis:   Wrapper, setup for CreateFontIndirect() to create the font to be
//              selected into the HDC.
//
//  Returns:    TRUE if OK, FALSE if allocation failure
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::MakeFont(
    XHDC hdc,                       // HDC into which  font will be selected
    const CCharFormat * const pcf,  // description of desired logical font
    CDocInfo * pdci,
    BOOL fForceTTFont)
{
    BOOL fTweakedCharSet = FALSE;
    FONTIDX hfontOriginalCharset = HFONT_INVALID;
    TCHAR pszNewFaceName[LF_FACESIZE];
    const CODEPAGE cpDoc = pdci->_pMarkup->GetFamilyCodePage();
    const LCID lcid = pcf->_lcid;
    BOOL fRes;
    LONG lfHeight;

    // Note (paulpark): We must be careful with _lf.  It is important that
    // _latmLFFaceName be kept in sync with _lf.lfFaceName.  The way to do that
    // is to use the SetLFFaceName function.
    SetLFFaceNameAtm(pcf->_latmFaceName);

    // We need the _sCodePage in case we need to call ExtTextOutA rather than ExtTextOutW.  
    _sCodePage = (USHORT)DefaultCodePageFromCharSet(pcf->_bCharSet, cpDoc);

    // Computes font height
    AssertSz(pcf->_yHeight <= INT_MAX, "It's too big");

    //  Roundoff can result in a height of zero, which is bad.
    //  If this happens, use the minimum legal height.
    lfHeight = -(const_cast<CCharFormat *const>(pcf)->GetHeightInPixels(hdc, pdci));
    if (lfHeight > 0)
    {
        lfHeight = -lfHeight;       // TODO: do something more intelligent...
    }
    else if (!lfHeight)
    {
        lfHeight--;                 // round error, make this a minimum legal height of -1.
    }
    
    _lf.lfHeight = _yOriginalHeight = lfHeight;
    _lf.lfWidth  = 0;

    _lf.lfWeight        = (pcf->_wWeight != 0) ? pcf->_wWeight : (pcf->_fBold ? FW_BOLD : FW_NORMAL);
    _lf.lfItalic        = pcf->_fItalic;
    _lf.lfUnderline     = 0; // pcf->_fUnderline;
    _lf.lfStrikeOut     = 0; // pcf->_fStrikeOut;
    _lf.lfCharSet       = pcf->_bCharSet;
    _lf.lfEscapement    = 0;
    _lf.lfOrientation   = 0;
    _lf.lfOutPrecision  = OUT_DEFAULT_PRECIS;
    if (pcf->_fOutPrecision)
        _lf.lfOutPrecision = (g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS) ? OUT_TT_ONLY_PRECIS : OUT_SCREEN_OUTLINE_PRECIS;
    if (fForceTTFont)
        _lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;
    _lf.lfQuality       = DEFAULT_QUALITY;
    _lf.lfPitchAndFamily = _bPitchAndFamily = pcf->_bPitchAndFamily;
    _lf.lfClipPrecision = CLIP_DEFAULT_PRECIS | CLIP_DFA_OVERRIDE;

    //
    // Don't pick a non-TT font if we cannot find any default font for sid.
    // Ex. For surrogated (sidSurrogateA/B) on 9x/NT4 systems we may not 
    // have any font, which support them, so pcf->_latmFaceName in this case 
    // is 0.
    // We used to set pcf->_latmFaceName to 0 for generic font families, but 
    // this case is now handled during ComputeFormats.
    //
    if (pcf->_latmFaceName == 0)
        _lf.lfOutPrecision |= OUT_TT_ONLY_PRECIS;
    
    // Only use CLIP_EMBEDDED when necessary, or Win95 will make you pay.
    if (pcf->_fDownloadedFont)
    {
        _lf.lfClipPrecision |= CLIP_EMBEDDED;
    }

    fRes = GetFontWithMetrics(hdc, pszNewFaceName, cpDoc, lcid);

    if (!_tcsiequal(pszNewFaceName, _lf.lfFaceName))
    {
        BOOL fCorrectFont = FALSE;

        if (_bCharSet == SYMBOL_CHARSET)
        {
            // #1. if the face changed, and the specified charset was SYMBOL,
            //     but the face name exists and suports ANSI, we give preference
            //     to the face name

            _lf.lfCharSet = ANSI_CHARSET;
            fTweakedCharSet = TRUE;

            hfontOriginalCharset = _hfont;
            GetFontWithMetrics(hdc, pszNewFaceName, cpDoc, lcid);

            if (_tcsiequal(pszNewFaceName, _lf.lfFaceName))
                // that's right, ANSI is the asnwer
                fCorrectFont = TRUE;
            else
                // no, fall back by default
                // the charset we got was right
                _lf.lfCharSet = pcf->_bCharSet;
        }
        else if (_lf.lfCharSet == DEFAULT_CHARSET &&
                 _bCharSet == DEFAULT_CHARSET)
        {
            // #2. If we got the "default" font back, we don't know what it
            // means (could be anything) so we verify that this guy's not SYMBOL
            // (symbol is never default, but the OS could be lying to us!!!)
            // we would like to verify more like whether it actually gave us
            // Japanese instead of ANSI and labeled it "default"...
            // but SYMBOL is the least we can do

            _lf.lfCharSet = SYMBOL_CHARSET;
            SetLFFaceName(pszNewFaceName);
            fTweakedCharSet = TRUE;

            hfontOriginalCharset = _hfont;
            GetFontWithMetrics(hdc, pszNewFaceName, cpDoc, lcid);

            if (_tcsiequal(pszNewFaceName, _lf.lfFaceName))
                // that's right, it IS symbol!
                // 'correct' the font to the 'true' one,
                //  and we'll get fMappedToSymbol
                fCorrectFont = TRUE;

            // always restore the charset name, we didn't want to
            // question he original choice of charset here
            _lf.lfCharSet = pcf->_bCharSet;

        }
#ifndef NO_MULTILANG
        else if ( _bConvertMode != CM_SYMBOL &&
                  IsFECharset(_lf.lfCharSet) &&
                  (!g_fFarEastWinNT || !g_fFarEastWin9X))
        {
            // NOTE (cthrash) _lf.lfCharSet is what we asked for, _bCharset is what we got.

            if (_bCharSet != _lf.lfCharSet &&
                (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID))
            {
                SCRIPT_ID sid;
                LONG latmFontFace;

                // on Win95, when rendering to PS driver,
                // it will give us something other than what we asked.
                // We have to try some known font we got from GDI
                switch (_lf.lfCharSet)
                {
                    case CHINESEBIG5_CHARSET:
                        sid = sidBopomofo;
                        break;

                    case SHIFTJIS_CHARSET:
                        sid = sidKana;
                        break;

                    case HANGEUL_CHARSET:
                        sid = sidHangul;
                        break;

                    case GB2312_CHARSET:
                        sid = sidHan;
                        break;

                    default:
                        sid = sidDefault;
                        break;
                }

                ScriptAppropriateFaceNameAtom(sid, pdci->_pDoc, FALSE, pcf, pdci->_pMarkup, &latmFontFace);
                SetLFFaceNameAtm(latmFontFace);
            }
            else if (   _lf.lfCharSet == GB2312_CHARSET
                     && _lf.lfPitchAndFamily | FIXED_PITCH)
            {
                // HACK (cthrash) On vanilla PRC systems, you will not be able to ask
                // for a fixed-pitch font which covers the non-GB2312 GBK codepoints.
                // We come here if we asked for a fixed-pitch PRC font but failed to 
                // get a facename match.  So we try again, only without FIXED_PITCH
                // set.  The side-effect is that CBaseCcs::Compare needs to compare
                // against the original _bPitchAndFamily else it will fail every time.
                
                _lf.lfPitchAndFamily = _lf.lfPitchAndFamily ^ FIXED_PITCH;
            }
            else
            {
                // this is a FE Font (from Lang pack) on a nonFEsystem
                SetLFFaceName(pszNewFaceName);
            }

            hfontOriginalCharset = _hfont;

            GetFontWithMetrics(hdc, pszNewFaceName, cpDoc, lcid);

            if (_tcsiequal(pszNewFaceName, _lf.lfFaceName))
            {
                // that's right, it IS the FE font we want!
                // 'correct' the font to the 'true' one.
                fCorrectFont = TRUE;
            }

            fTweakedCharSet = TRUE;
        }
#endif // !NO_IME

        if (hfontOriginalCharset != HFONT_INVALID)
        {
            // either keep the old font or the new one

            if (fCorrectFont)
            {
                DeleteFontIdx(hfontOriginalCharset);
                hfontOriginalCharset = HFONT_INVALID;
            }
            else
            {
                // fall back to the original font
                DeleteFontIdx(_hfont);

                _hfont = hfontOriginalCharset;
                hfontOriginalCharset = HFONT_INVALID;

                GetTextMetrics( hdc, cpDoc, lcid );
            }
        }
    }

RetryCreateFont:
    if (!pcf->_fDownloadedFont)
    {
        // could be that we just plain symply get mapped to symbol.
        // avoid it
        BOOL fMappedToSymbol =  (_bCharSet == SYMBOL_CHARSET &&
                                 _lf.lfCharSet != SYMBOL_CHARSET);

        BOOL fChangedCharset = (_bCharSet != _lf.lfCharSet &&
                                _lf.lfCharSet != DEFAULT_CHARSET);

        if (fChangedCharset || fMappedToSymbol)
        {
            const TCHAR * pchFallbackFaceName = (pcf->_bPitchAndFamily & FF_ROMAN)
                                                ? TimesNewRoman()
                                                : Arial();
            
            // Here, the system did not preserve the font language or mapped
            // our non-symbol font onto a symbol font,
            // which will look awful when displayed.
            // Giving us a symbol font when we asked for a non-symbol one
            // (default can never be symbol) is very bizzare and means
            // that either the font name is not known or the system
            // has gone complete nuts here.
            // The charset language takes priority over the font name.
            // Hence, I would argue that nothing can be done to save the
            // situation at this point, and we have to
            // delete the font name and retry

            // let's tweak it a bit
            fTweakedCharSet = TRUE;

            if (_tcsiequal(_lf.lfFaceName, pchFallbackFaceName))
            {
                // we've been here already
                // no font with an appropriate charset is on the system
                // try getting the ANSI one for the original font name
                // next time around, we'll null out the name as well!!
                if (_lf.lfCharSet == ANSI_CHARSET)
                {
                    TraceTag((tagWarning, "Asking for ANSI ARIAL and not getting it?!"));

                    // those Win95 guys have definitely outbugged me
                    goto Cleanup;
                }

                SetLFFaceNameAtm(pcf->_latmFaceName);
                _lf.lfCharSet = ANSI_CHARSET;
            }
            else
                SetLFFaceName(pchFallbackFaceName);

            DeleteFontIdx(_hfont);
            _hfont = HFONT_INVALID;

            GetFontWithMetrics(hdc, pszNewFaceName, cpDoc, lcid);
            goto RetryCreateFont;
        }

    }

Cleanup:
    if (fTweakedCharSet || _bConvertMode == CM_SYMBOL)
    {
        // we must preserve the original charset value, since it is used in Compare()
        _lf.lfCharSet = pcf->_bCharSet;
        SetLFFaceNameAtm(pcf->_latmFaceName);
    }

    if (hfontOriginalCharset != HFONT_INVALID)
    {
        DeleteFontIdx(hfontOriginalCharset);
        hfontOriginalCharset = HFONT_INVALID;
    }

    // if we're really really stuck, just get the system font and hope for the best.
    if (_hfont == HFONT_INVALID)
        _hfont = GetSystemFontIdx();

    _fFEFontOnNonFEWin95 = FEFontOnNonFE95( _bCharSet );


    // What font are we *really* using?
    _latmRealFaceName = fc().GetAtomFromFaceName(pszNewFaceName);

    // Make sure we know what have script IDs computed for this font.  Cache this value
    // to avoid a lookup later.
    BOOL fHKSCSHack = pdci->_pDoc->_pOptionSettings->fHKSCSSupport;
    _sids = fc().EnsureScriptIDsForFont(hdc, this, pcf->_fDownloadedFont ? FC_SIDS_DOWNLOADEDFONT : 0, &fHKSCSHack);
    _sids &= GetScriptsFromCharset(_bCharSet);
    if (fHKSCSHack)
        _sids |= ScriptBit(sidLatin);

    Assert(!fForceTTFont || _fTTFont);   // We are forceing to TT font, so we should get one.

    TraceTag((tagCCcsMakeFont,
              "CCcs::MakeFont(facename=%S,charset=%d) returned %S(charset=%d), rendering %S",
             fc().GetFaceNameFromAtom(pcf->_latmFaceName),
             pcf->_bCharSet,
             fc().GetFaceNameFromAtom(_latmLFFaceName),
             _bCharSet,
             fc().GetFaceNameFromAtom(_latmRealFaceName)));

    return (_hfont != HFONT_INVALID);
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::GetFontWithMetrics
//
//  Synopsis:   Get metrics used by the measurer and renderer 
//              and the new face name.
//              
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::GetFontWithMetrics (
    XHDC hdc,                              
    TCHAR* szNewFaceName,
    CODEPAGE cpDoc,
    LCID lcid )
{
    UseScreenDCForMeasuring(&hdc);

    // if required font is too big (more then 30000), Windows (incl W2K and W9x) 
    // computes wrong char widths. We use scale factor and smaller font then to
    // calculate right widths. (dmitryt)
    _fScalingRequired = FALSE;
    LONG lHeight = _lf.lfHeight;
    if(lHeight < 0) lHeight = -lHeight; 
    if(lHeight > MAX_SAFE_FONT_SIZE)
    {
        _lf.lfHeight = (_lf.lfHeight < 0) ? -MAX_SAFE_FONT_SIZE : MAX_SAFE_FONT_SIZE; 
        _fScalingRequired = TRUE; 
        _flScaleFactor = ((float)lHeight) / (float)MAX_SAFE_FONT_SIZE; 
    }

    // IMPORTANT: we want to keep _lf untouched as it is used in Compare().
    LOGFONT lf = _lf;

#ifdef UNIX
    if (( lf.lfCharSet == DEFAULT_CHARSET ) ||
        ( lf.lfCharSet == SYMBOL_CHARSET )) {
        // On Unix we actually do sometimes map to a symbol charset
        // and somewhere in this code we don't handle that case well
        // and end up showing symbols where text should be.  I don't
        // have time to fix that right now so always ask for ansi.
        lf.lfCharSet = ANSI_CHARSET;
    }
#endif

    // Sometimes we want to retry font creation with different paramenter.
    // Of course, we are very careful when we jump back to this label.
Retry:
    _hfont = CreateFontIndirectIdx(&lf);

    if (_hfont != HFONT_INVALID)
    {
        // get text metrics, in logical units, that are constant for this font,
        // regardless of the hdc in use.

        if (GetTextMetrics( hdc, cpDoc, lcid ))
        {
            // Retry if we have asked for a TT font, but got something else
            if (lf.lfOutPrecision == OUT_TT_ONLY_PRECIS && !_fTTFont)
            {
                // remove font name and ask for a nameless font 
                // with same pitch and family
                if (lf.lfFaceName[0])
                {
                    // destroying the font name ensures we wont come here again
                    lf.lfFaceName[0] = 0;
                    
                    if (!lf.lfPitchAndFamily)
                    {
                        // use pitch and family returned by GetTextMetrics (we hope the family is usable)
                        lf.lfPitchAndFamily = _sPitchAndFamily;
                    }

                    // dangerously jump back. 
                    DeleteObject((HGDIOBJ)_hfont);
                    goto Retry;
                }
                else
                {
                    // this may not be the first retry. give up
                }
            }
        }

        {
            FONTIDX hfontOld = PushFont(hdc);
            GetTextFace(hdc, LF_FACESIZE, szNewFaceName);
            PopFont(hdc, hfontOld);
        }
    }

    return (_hfont != HFONT_INVALID);
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::GetTextMetrics
//
//  Synopsis:   Get metrics used by the measureer and renderer.
//              These are in logical coordinates which are dependent
//              on the mapping mode and font selected into the hdc.
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::GetTextMetrics(
    XHDC hdc,
    CODEPAGE cpDoc,
    LCID lcid )
{
    UseScreenDCForMeasuring(&hdc);

    BOOL        fRes = TRUE;
    TEXTMETRIC  tm;

    FONTIDX hfontOld = PushFont(hdc);

    if (!::GetTextMetrics(hdc, &tm))
    {
        WHEN_DBG(GetLastError());
        fRes = FALSE;
        goto Cleanup;
    }

    if(_fScalingRequired)
    {
        tm.tmHeight *= _flScaleFactor;
        tm.tmAscent *= _flScaleFactor;
        tm.tmDescent *= _flScaleFactor;
        tm.tmAveCharWidth *= _flScaleFactor;
        tm.tmMaxCharWidth *= _flScaleFactor;
        tm.tmOverhang *= _flScaleFactor;
        tm.tmInternalLeading *= _flScaleFactor;
        tm.tmExternalLeading *= _flScaleFactor;
    }

    // if we didn't know the true codepage, determine this now.
    if (_lf.lfCharSet == DEFAULT_CHARSET)
    {
        // TODO: investigate (track bug 112167). 
        // Looks like _sCodePage is always defined at this point.
        // (cthrash) Remove this.  The _sCodePage computed by MakeFont should
        // be accurate enough.
        
        _sCodePage = (USHORT)DefaultCodePageFromCharSet( tm.tmCharSet, cpDoc, lcid );
    }

    // the metrics, in logical units, dependent on the map mode and font.
    _yHeight         = tm.tmHeight;
    _yDescent        = tm.tmDescent;
    _xAveCharWidth   = tm.tmAveCharWidth;
    _xMaxCharWidth   = tm.tmMaxCharWidth;
    _xOverhangAdjust = (SHORT) tm.tmOverhang;
    _sPitchAndFamily = (SHORT) tm.tmPitchAndFamily;
    _bCharSet        = tm.tmCharSet;
    _fTTFont         = !!(TMPF_TRUETYPE & tm.tmPitchAndFamily);

    if (   _bCharSet == SHIFTJIS_CHARSET 
        || _bCharSet == CHINESEBIG5_CHARSET 
        || _bCharSet == HANGEUL_CHARSET
        || _bCharSet == GB2312_CHARSET
       )
    {
        if (tm.tmExternalLeading == 0)
        {
            // Increase descent by 1/8 font height for FE fonts
            LONG delta = _yHeight / 8;
            _yDescent += delta;
            _yHeight  += delta;
        }
        else
        {
            //
            // use the external leading
            //

            _yDescent += tm.tmExternalLeading;
            _yHeight += tm.tmExternalLeading;
        }
    }

#ifndef UNIX // We don't support TRUE_TYPE font yet.
    // bug in windows95, synthesized italic?
    if ( _lf.lfItalic && 0 == tm.tmOverhang &&
         !(TMPF_TRUETYPE & tm.tmPitchAndFamily) &&
         !( (TMPF_DEVICE & tm.tmPitchAndFamily) &&
            (TMPF_VECTOR & tm.tmPitchAndFamily ) ) )
    {                                               // This is a *best* guess.
        // When printing to a PCL printer, we prefer zero as our overhang adjust. (41546)
        DWORD   dwDCObjType = GetObjectType(hdc);
        if (!_fPrinting
            || (dwDCObjType != OBJ_ENHMETADC && dwDCObjType != OBJ_METADC))
        {
            _xOverhangAdjust = (SHORT) (tm.tmMaxCharWidth >> 1);
        }
    }
#endif

    _xOverhang = 0;
    _xUnderhang = 0;
    if ( _lf.lfItalic )
    {
        _xOverhang =  SHORT ( (tm.tmAscent + 1) >> 2 );
        _xUnderhang =  SHORT ( (tm.tmDescent + 1) >> 2 );
    }

    // HACK (cthrash) Many Win3.1 vintage fonts (such as MS Sans Serif, Courier)
    // will claim to support all of Latin-1 when in fact it does not.  The hack
    // is to check the last character, and if the font claims that it U+2122
    // TRADEMARK, then we suspect the coverage is busted.

    _fLatin1CoverageSuspicious =    !(_sPitchAndFamily & TMPF_TRUETYPE)
                                 && (PRIMARYLANGID(LANGIDFROMLCID(g_lcidUserDefault)) == LANG_ENGLISH);

    // if fix pitch, the tm bit is clear
    _fFixPitchFont = !(TMPF_FIXED_PITCH & tm.tmPitchAndFamily);
    _xDefDBCWidth = 0;

    if (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID)
    {
        // Hack imported from Word via Riched.  This is how they compute the
        // discrepancy between the return values of GetCharWidthA and
        // GetCharWidthW.   Compute it once per CBaseCcs, so we don't have to
        // recompute on every Include call.

        const TCHAR chX = _T('X');
        SIZE size;
        INT dxX;

        GetTextExtentPoint(hdc, &chX, 1, &size);
        GetCharWidthA(hdc, chX, chX, &dxX);

        _sAdjustFor95Hack = size.cx - dxX;
        _sAdjustFor95Hack = ( !_fScalingRequired ? _sAdjustFor95Hack : (SHORT)(_sAdjustFor95Hack * _flScaleFactor));

        _fLatin1CoverageSuspicious &= (tm.tmLastChar == 0xFF);
    }
    else
    {
        _sAdjustFor95Hack = 0;

        _fLatin1CoverageSuspicious &= (tm.tmLastChar == 0x2122);
    }

    if (_bCharSet == SYMBOL_CHARSET)
    {
        // Must use doc codepage, unless of course we have a Unicode document
        // In this event, we pick cp1252, just to maximize coverage.

        _sCodePage = IsStraightToUnicodeCodePage(cpDoc) ? CP_1252 : cpDoc;

        _bConvertMode = CM_SYMBOL;        
    }
    else if (IsExtTextOutWBuggy( _sCodePage ))
    {
        _bConvertMode = CM_MULTIBYTE;
    }
#if !defined(WINCE)
    else if (_bConvertMode == CM_NONE &&
         VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID)
    {
        // Some fonts have problems under Win95 with the GetCharWidthW call;
        // this is a simple heuristic to determine if this problem exists.

        INT     widthA, widthW;
        BOOL    fResA, fResW;

        // Future(BradO):  We should add the expression
        //  "&& IsFELCID(GetSystemDefaultLCID())" to the 'if' below to use
        //  Unicode GetCharWidth and ExtTextOut for FE fonts on non-FE
        //  systems (see postponed bug #3337).

        // Yet another hack - FE font on Non-FE Win95 cannot use
        // GetCharWidthW and ExtTextOutW
        if (FEFontOnNonFE95(tm.tmCharSet))
        {
            // always use ANSI call for DBC fonts.
            _bConvertMode = CM_FEONNONFE;

            // setup _xDefDBWidth to by-pass some Trad. Chinese character
            // width problem.
            if (CHINESEBIG5_CHARSET == tm.tmCharSet)
            {
                BYTE    ansiChar[2] = {0xD8, 0xB5 };

                fResA = GetCharWidthA( hdc, *((USHORT *) ansiChar),
                                       *((USHORT *) ansiChar), &widthA );
                if (fResA && widthA)
                {
                    _xDefDBCWidth = ( !_fScalingRequired ? widthA : widthA * _flScaleFactor );
                }
            }
        }
        else
        {
            fResA = GetCharWidthA( hdc, ' ', ' ', &widthA );
            fResW = GetCharWidthW( hdc, L' ', L' ', &widthW );
            if ( fResA && fResW && widthA != widthW )
            {
                _bConvertMode = CM_MULTIBYTE;
            }
            else
            {
                fResA = GetCharWidthA( hdc, 'a', 'a', &widthA );
                fResW = GetCharWidthW( hdc, L'a', L'a', &widthW );
                if ( fResA && fResW && widthA != widthW )
                {
                    _bConvertMode = CM_MULTIBYTE;
                }
            }
        }
    }
#endif // !WINCE

    _fHasInterestingData =    _fFixPitchFont
                           || _xOverhang != 0
                           || _xOverhangAdjust != 0
                           || _bConvertMode == CM_SYMBOL
                           || !_fTTFont;

Cleanup:
    PopFont(hdc, hfontOld);

    return fRes;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::NeedConvertNBSPs
//
//  Synopsis:   Determine NBSPs need conversion or not during render
//              Some fonts wont render NBSPs correctly.
//              Flag fonts which have this problem
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::NeedConvertNBSPs(XHDC hdc, CDoc *pDoc)
{
    UseScreenDCForMeasuring(&hdc);
    
    Assert(!_fConvertNBSPsSet);

    FONTIDX hfontOld = PushFont(hdc);

    // NOTE: (cthrash) Once ExtTextOutW is supported in CRenderer, we need
    //                 to set _fConvertNBSPsIfA, so that we can better tune when we need to
    //                 convert NBSPs depending on which ExtTextOut variant we call.

#if !defined(WINCE)
    if (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID)
    {
        extern BOOL IsATMInstalled();

        Assert(pDoc);
        if (   pDoc
            && pDoc->PrimaryMarkup()->IsPrintMedia()
            && IsATMInstalled()
           )
        {
            _fConvertNBSPs = FALSE;
        }
        else
        {
            TCHAR   ch = WCH_NBSP;
            char    b;
            BOOL    fUsedDefChar;

            WideCharToMultiByte(_sCodePage, 0, &ch, 1, &b, 1, NULL, &fUsedDefChar);

            if (fUsedDefChar)
            {
                _fConvertNBSPs = TRUE;
            }
            else
            {
                // Some fonts (like Wide Latin) claim the width of spaces and
                // NBSP chars are the same, but when you actually call ExtTextOut,
                // you'll get fatter spaces;

                ABC abcSpace, abcNbsp;

                _fConvertNBSPs = !GetCharABCWidthsA( hdc, ' ', ' ', &abcSpace ) ||
                                 !GetCharABCWidthsA( hdc, b, b, &abcNbsp ) ||
                                 abcSpace.abcA != abcNbsp.abcA ||
                                 abcSpace.abcB != abcNbsp.abcB ||
                                 abcSpace.abcC != abcNbsp.abcC;
            }
        }
    }
    else
    {
#ifndef UNIX // UNIX doesn't have true-type fonts
        ABC abcSpace, abcNbsp;

        _fConvertNBSPs = !GetCharABCWidthsW( hdc, L' ', L' ', &abcSpace ) ||
                         !GetCharABCWidthsW( hdc, WCH_NBSP, WCH_NBSP, &abcNbsp ) ||
                         abcSpace.abcA != abcNbsp.abcA ||
                         abcSpace.abcB != abcNbsp.abcB ||
                         abcSpace.abcC != abcNbsp.abcC;
#else // UNIX
        int lSpace, lNbsp;

        _fConvertNBSPs = !GetCharWidthW( hdc, L' ', L' ', &lSpace ) ||
                         !GetCharWidthW( hdc, WCH_NBSP, WCH_NBSP, &lNbsp ) ||
                         lSpace != lNbsp;
#endif
    }
#endif // !WINCE

    PopFont(hdc, hfontOld);

    _fConvertNBSPsSet = TRUE;
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::DestroyFont
//
//  Synopsis:   Destroy font handle for this CBaseCcs.
//
//-----------------------------------------------------------------------------

void
CBaseCcs::DestroyFont()
{
    // clear out any old font
    if (_hfont != HFONT_INVALID)
    {
        DeleteFontIdx(_hfont);
        _hfont = HFONT_INVALID;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::Compare
//
//  Synopsis:   Compares this font cache with the font properties of a
//              given CHARFORMAT.
//
//  Returns:    FALSE if did not match exactly
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::Compare( CompareArgs * pCompareArgs )
{
    VerifyLFAtom();
    // NB: We no longer create our logical font with an underline and strike through.
    // We draw strike through & underline separately.

    // If are mode is CM_MULTIBYTE, we need the sid to match exactly, otherwise we
    // will not render correctly.  For example, <FONT FACE=Arial>A&#936; will have two
    // text runs, first sidAsciiLatin, second sidCyrillic.  If are conversion mode is
    // multibyte, we need to make two fonts, one with ANSI_CHARSET, the other with
    // RUSSIAN_CHARSET.
    const CCharFormat * pcf = pCompareArgs->pcf;

    BOOL fMatched =    (_yCfHeight == pcf->_yHeight) // because different mapping modes
                    && (_lf.lfWeight == ((pcf->_wWeight != 0) ? pcf->_wWeight : (pcf->_fBold ? FW_BOLD : FW_NORMAL)))
                    && (_latmLFFaceName == pcf->_latmFaceName)
                    && (_lf.lfItalic == pcf->_fItalic)
                    && (_lf.lfHeight == pCompareArgs->lfHeight)  // have diff logical coords
                    && (   pcf->_bCharSet == DEFAULT_CHARSET
                        || _bCharSet == DEFAULT_CHARSET
                        || pcf->_bCharSet == _bCharSet)
                    && (_bPitchAndFamily == pcf->_bPitchAndFamily)
                    && (!pCompareArgs->fTTFont || _fTTFont);

    WHEN_DBG( if (!fMatched) )
    {
        TraceTag((tagCCcsCompare,
                  "%s%s%s%s%s%s%s",
                  (_yCfHeight == pcf->_yHeight) ? "" : "height ",
                  (_lf.lfWeight == ((pcf->_wWeight != 0) ? pcf->_wWeight : (pcf->_fBold ? FW_BOLD : FW_NORMAL))) ? "" : "weight ",
                  (_latmLFFaceName == pcf->_latmFaceName) ? "" : "facename ",
                  (_lf.lfItalic == pcf->_fItalic) ? "" : "italicness ",
                  (_lf.lfHeight == pCompareArgs->lfHeight) ? "" : "logical-height ",
                  (   pcf->_bCharSet == DEFAULT_CHARSET
                   || _bCharSet == DEFAULT_CHARSET
                   || pcf->_bCharSet == _bCharSet) ? "" : "charset ",
                  (_lf.lfPitchAndFamily == pcf->_bPitchAndFamily) ? "" : "pitch&family" ));
    }

    return fMatched;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::CompareForFontLink
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::CompareForFontLink( CompareArgs * pCompareArgs )
{
    // The difference between CBaseCcs::Compare and CBaseCcs::CompareForFontLink is in it's
    // treatment of adjusted/pre-adjusted heights.  If we ask to fontlink with MS Mincho
    // in the middle of 10px Arial text, we may choose to instantiate an 11px MS Mincho to
    // compenstate for the ascent/descent discrepancies.  10px is the _yOriginalHeight, and
    // 11px is the _lf.lfHeight in this scenario.  If we again ask for 10px MS Mincho while
    // fontlinking Arial, we want to match based on the original height, not the adjust height.
    // CBaseCcs::Compare, on the other hand, is only concerned with the adjusted height.

    VerifyLFAtom();
    // NB: We no longer create our logical font with an underline and strike through.
    // We draw strike through & underline separately.

    // If are mode is CM_MULTIBYTE, we need the sid to match exactly, otherwise we
    // will not render correctly.  For example, <FONT FACE=Arial>A&#936; will have two
    // text runs, first sidAsciiLatin, second sidCyrillic.  If are conversion mode is
    // multibyte, we need to make two fonts, one with ANSI_CHARSET, the other with
    // RUSSIAN_CHARSET.
    const CCharFormat * pcf = pCompareArgs->pcf;

    BOOL fMatched =    (_yCfHeight == pcf->_yHeight) // because different mapping modes
                    && (_lf.lfWeight == ((pcf->_wWeight != 0) ? pcf->_wWeight : (pcf->_fBold ? FW_BOLD : FW_NORMAL)))
                    && (_latmLFFaceName == pcf->_latmFaceName)
                    && (_latmBaseFaceName == pCompareArgs->latmBaseFaceName)
                    && (_lf.lfItalic == pcf->_fItalic)
                    && (_yOriginalHeight == pCompareArgs->lfHeight)  // have diff logical coords
                    && (   pcf->_bCharSet == DEFAULT_CHARSET
                        || _bCharSet == DEFAULT_CHARSET
                        || pcf->_bCharSet == _bCharSet)
                    && (_bPitchAndFamily == pcf->_bPitchAndFamily)
                    && (!pCompareArgs->fTTFont || _fTTFont);

    WHEN_DBG( if (!fMatched) )
    {
        TraceTag((tagCCcsCompare,
                  "%s%s%s%s%s%s%s",
                  (_yCfHeight == pcf->_yHeight) ? "" : "height ",
                  (_lf.lfWeight == ((pcf->_wWeight != 0) ? pcf->_wWeight : (pcf->_fBold ? FW_BOLD : FW_NORMAL))) ? "" : "weight ",
                  (_latmLFFaceName == pcf->_latmFaceName) ? "" : "facename ",
                  (_lf.lfItalic == pcf->_fItalic) ? "" : "italicness ",
                  (_yOriginalHeight == pCompareArgs->lfHeight) ? "" : "logical-height ",
                  (   pcf->_bCharSet == DEFAULT_CHARSET
                   || _bCharSet == DEFAULT_CHARSET
                   || pcf->_bCharSet == _bCharSet) ? "" : "charset ",
                  (_lf.lfPitchAndFamily == pcf->_bPitchAndFamily) ? "" : "pitch&family" ));
    }

    return fMatched;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::SetLFFaceNameAtm
//
//-----------------------------------------------------------------------------

void 
CBaseCcs::SetLFFaceNameAtm(LONG latmFaceName)
{
    VerifyLFAtom();
    Assert(latmFaceName >= 0);
    _latmLFFaceName = latmFaceName;
    // Sets the string inside _lf to what _latmLFFaceName represents.
    _tcsncpy(_lf.lfFaceName, fc().GetFaceNameFromAtom(_latmLFFaceName), LF_FACESIZE );
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::SetLFFaceName
//
//-----------------------------------------------------------------------------

void 
CBaseCcs::SetLFFaceName(const TCHAR * szFaceName)
{
    VerifyLFAtom();
    LONG latmLFFaceName = fc().GetAtomFromFaceName(szFaceName);
    Assert(latmLFFaceName >= 0);
    _latmLFFaceName = latmLFFaceName;
    _tcsncpy(_lf.lfFaceName, szFaceName, LF_FACESIZE );
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::GetConvertMode
//
//-----------------------------------------------------------------------------

CONVERTMODE
CBaseCcs::GetConvertMode(
    BOOL fEnhancedMetafile,
    BOOL fMetafile ) const
{
#if DBG==1
    if (IsTagEnabled(tagTextOutA))
    {
        if (IsTagEnabled(tagTextOutFE))
        {
            TraceTag((tagTextOutFE,
                      "tagTextOutFE is being ignored "
                      "(tagTextOutA is set.)"));
        }

        return CM_MULTIBYTE;
    }
    else if (IsTagEnabled(tagTextOutFE))
    {
        return CM_FEONNONFE;
    }
#endif

    CONVERTMODE cm = (CONVERTMODE)_bConvertMode;

    // For hack around ExtTextOutW Win95 FE problems.
    // NB (cthrash) The following is an enumeration of conditions under which
    // ExtTextOutW is broken.  This code is originally from RichEdit.

    if (cm == CM_MULTIBYTE)
    {
        // If we want CM_MULTIBYTE, that's what we get.
    }
    else if (g_fFarEastWin9X || _fFEFontOnNonFEWin95)
    {
        // Ultimately call ReExtTextOutW, unless symbol.
        // If symbol, call ExtTextOutA.

        if (cm != CM_SYMBOL)
        {
            if (   IsExtTextOutWBuggy( _sCodePage )
                && IsFECharset( _lf.lfCharSet ) )
            {
                // CHT ExtTextOutW does not work on Win95 Golden on
                // many characters (cthrash).

                cm = CM_MULTIBYTE;
            }
            else
            {
                cm = CM_FEONNONFE;
            }
        }
    }
    else
    {
        if (CM_SYMBOL != cm)
        {
#if NOTYET
            if (fEnhancedMetafile &&
                ((VER_PLATFORM_WIN32_WINDOWS   == g_dwPlatformID) ||
                 (VER_PLATFORM_WIN32_MACINTOSH == g_dwPlatformID)))
#else
                if (fEnhancedMetafile &&
                    (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID))
#endif
                {
                    cm = CM_MULTIBYTE;
                }
                else if (fMetafile && g_fFarEastWinNT)
                {
                    // FE NT metafile ExtTextOutW hack.
                    cm = CM_MULTIBYTE;
                }
        }
        if ((VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID) &&
            fMetafile && !fEnhancedMetafile )
        {
            //Win95 can't handle TextOutW to regular metafiles
            cm = CM_MULTIBYTE;
        }
    }

    return cm;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::FillWidths
//
//  Synopsis:   Fill in this CBaseCcs with metrics info for given device.
//
//  Returns:    TRUE if OK, FALSE if failed
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::FillWidths(
    XHDC hdc,
    TCHAR ch,                       // the TCHAR character we need a width for.
    LONG &rlWidth)                  // the width of the character
{
    UseScreenDCForMeasuring(&hdc);
    
    BOOL  fRes = FALSE;

    FONTIDX hfontOld = PushFont(hdc);

    // fill up the width info.
    fRes = _widths.FillWidth( hdc, this, ch, rlWidth );

    PopFont(hdc, hfontOld);

    return fRes;
}

#if DBG==1
//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::PopFont
//
//  Synopsis:   Selects the instance var _hfont so we can measure, 
//              but remembers the old font so we don't actually change anything 
//              when we're done measuring.
//              Returns the previously selected font.
//              
//-----------------------------------------------------------------------------

FONTIDX
CBaseCcs::PushFont(XHDC hdc)
{
    AssertSz(_hfont != HFONT_INVALID, "CBaseCcs has no font");

    FONTIDX hfontOld = GetCurrentFontIdx(hdc);

    if (hfontOld != _hfont)
    {
        hdc.SetBaseCcsPtr(this );

        WHEN_DBG( FONTIDX hfontReturn = )
        PushFontIdx(hdc, _hfont);
        AssertSz(hfontReturn == hfontOld, "GDI failure changing fonts");
    }

    return hfontOld;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::PopFont
//
//  Synopsis:   Restores the selected font from before PushFont.
//              This is really just a lot like SelectFont, but is optimized, and
//              will only work if PushFont was called before it.
//              
//-----------------------------------------------------------------------------

void
CBaseCcs::PopFont(XHDC hdc, FONTIDX hfontOld)
{
    // This assert will fail if Pushfont was not called before popfont,
    // Or if somebody else changes fonts in between.  (They shouldn't.)
    AssertSz(_hfont == GetCurrentFontIdx(hdc), "PushFont has not been called");

    if (hfontOld != _hfont)
    {
        hdc.SetBaseCcsPtr(NULL);

        WHEN_DBG( FONTIDX hfontReturn = )
        PopFontIdx(hdc, hfontOld);
        AssertSz(hfontReturn == _hfont, "GDI failure changing fonts");
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::GetHFont
//              
//-----------------------------------------------------------------------------

HFONT
CBaseCcs::GetHFont() const
{
    return GetFontFromIdx(_hfont);
}
#endif

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::FixupForFontLink
//
//  Synopsis:   Optionally scale a font height when fontlinking.
//
//              This code was borrowed from UniScribe (usp10\str_ana.cxx)
//
//              Let's say you're base font is a 10pt Tahoma, and you need
//              to substitute a Chinese font (e.g. MingLiU) for some ideo-
//              graphic characters.  When you simply ask for a 10pt MingLiU,
//              you'll get a visibly smaller font, due to the difference in
//              in distrubution of the ascenders/descenders.  The purpose of
//              this function is to examine the discrepancy and pick a
//              slightly larger or smaller font for improved legibility. We
//              may also adjust the baseline by 1 pixel.
//              
//-----------------------------------------------------------------------------

void
CBaseCcs::FixupForFontLink(
    XHDC hdc,
    const CBaseCcs * const pBaseBaseCcs,
    BOOL fFEFont )
{
    LONG lOriginalDescender = pBaseBaseCcs->_yDescent;
    LONG lFallbackDescender = _yDescent;
    LONG lOriginalAscender  = pBaseBaseCcs->_yHeight - lOriginalDescender;
    LONG lFallbackAscender  = _yHeight - lFallbackDescender;

    if (   lFallbackAscender  > 0
        && lFallbackDescender > 0)
    {
        LONG lAscenderRatio  = 1024 * lOriginalAscender  / lFallbackAscender;
        LONG lDescenderRatio = 1024 * lOriginalDescender / lFallbackDescender;

        if (lAscenderRatio != lDescenderRatio)
        {
            // We'll allow moving the baseline by one pixel to reduce the amount of
            // scaling required.

            if (lAscenderRatio < lDescenderRatio)
            {
                // Clipping, if any, would happen in the ascender.
                ++lOriginalAscender;    // Move the baseline down one pixel.
                --lOriginalDescender;
                TraceTag((tagMetrics, "Moving baseline down one pixel to leave more room for ascender"));
            }
            else
            {
                // Clipping, if any, would happen in the descender.
                --lOriginalAscender;    // Move the baseline up one pixel.
                ++lOriginalDescender;
                TraceTag((tagMetrics, "Moving baseline up one pixel to leave more room for descender"));
            }

            // Recalculate ascender ratio based on shifted baseline
            lAscenderRatio  = 1024 * lOriginalAscender  / lFallbackAscender;
        }

        // Establish extent of worst mismatch, either too big or too small
        LONG lNewRatio = max(lAscenderRatio, 768L); // Never reduce size by over 25%
        if (fFEFont && lNewRatio < 1024)
        {
            // Never reduce size of FE font. We expect only to increase the size.
            lNewRatio = 1024;
        }

        if (lNewRatio < 1000 || lNewRatio > 1048)
        {
            LONG  lfHeightCurrent = _lf.lfHeight;
            LONG  lAdjust = (lNewRatio < 1024) ? 1023 : 0; // round towards 100% (1024)
            LONG  lfHeightNew = (lfHeightCurrent * lNewRatio - lAdjust) / 1024;

            Assert(lfHeightCurrent < 0);  // lfHeight should be negative; otherwise rounding will be incorrect

            if (lfHeightNew != lfHeightCurrent)
            {
                FONTIDX hfontCurrent   = _hfont;
                LONG  yHeightCurrent   = _yHeight;
                SHORT sCodePageCurrent = _sCodePage;
                TCHAR achNewFaceName[LF_FACESIZE];

                // Reselect with new ratio

                TraceTag((tagMetrics, "Reselecting fallback font to improve legibility"));
                TraceTag((tagMetrics, " Original font ascender %4d, descender %4d, lfHeight %4d, \'%S\'",
                          lOriginalAscender, lOriginalDescender, pBaseBaseCcs->_yHeight, fc().GetFaceNameFromAtom(pBaseBaseCcs->_latmLFFaceName)));
                TraceTag((tagMetrics, " Fallback font ascender %4d, descender %4d, -> lfHeight %4d, \'%s\'",
                          lFallbackAscender, lFallbackDescender, _yHeight * lNewRatio / 1024, fc().GetFaceNameFromAtom(_latmLFFaceName)));

                _lf.lfHeight = lfHeightNew;

                if (GetFontWithMetrics(hdc, achNewFaceName, CP_UCS_2, 0))
                {
                    _latmRealFaceName = fc().GetAtomFromFaceName(achNewFaceName);
                    DeleteFontIdx(hfontCurrent);
                }
                else
                {
                    Assert(_hfont == HFONT_INVALID);

                    _lf.lfHeight = lfHeightCurrent;
                    _yHeight = yHeightCurrent;
                    _hfont = hfontCurrent;
                }

                _sCodePage = sCodePageCurrent;
            }
        }
    }

    _fHeightAdjustedForFontlinking = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::EnsureLangBits
//
//-----------------------------------------------------------------------------

// TODO: (cthrash, track bug 112152) This needs to be removed as soon as the FontLinkTextOut
// is cleaned up for complex scripts.

void
CBaseCcs::EnsureLangBits(XHDC hdc)
{
    if (!_dwLangBits)
    {
        // Get the charsets supported by this font.
        if (_bCharSet != SYMBOL_CHARSET)
        {
            _dwLangBits = GetFontScriptBits( hdc,
                                             fc().GetFaceNameFromAtom( _latmLFFaceName ),
                                             &_lf );
        }
        else
        {
            // See comment in GetFontScriptBits.
            // SBITS_ALLLANGS means _never_ fontlink.

            _dwLangBits = SBITS_ALLLANGS;
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::GetLogFont
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::GetLogFont(LOGFONT * plf) const
{
    BOOL fSuccess = GetObject(GetHFont(), sizeof(LOGFONT), (LPVOID)plf);
    if (fSuccess && _fScalingRequired)
    {
        plf->lfHeight *= _flScaleFactor;
        plf->lfWidth  *= _flScaleFactor;
    }
    return fSuccess;
}

// =========================  WidthCache by jonmat  ===========================

//+----------------------------------------------------------------------------
//
//  Function:   CWidthCache::FillWidth
//
//  Synopsis:   Call GetCharWidth() to obtain the width of the given char.
//
//              The HDC must be setup with the mapping mode and proper font
//              selected *before* calling this routine.
//              
//  Returns:    TRUE if we were able to obtain the widths
//
//-----------------------------------------------------------------------------

BOOL
CWidthCache::FillWidth (
    XHDC hdc,
    CBaseCcs * pBaseCcs,
    const TCHAR ch,                 // Char to obtain width for
    LONG &rlWidth )                 // Width of character
{
    BOOL    fRes;
    INT     numOfDBCS = 0;
    CacheEntry  widthData;
    
    // NOTE: GetCharWidthW is really broken for bullet on Win95J. Sometimes it will return
    // a width or 0 or 1198 or ...So, hack around it. Yuk!
    // Also, WideCharToMultiByte() on Win95J will NOT convert bullet either.

    Assert( !IsCharFast(ch) );  // This code shouldn't be called for that.

    if ( ch == WCH_NBSP )
    {
        // Use the width of a space for an NBSP
        fRes = pBaseCcs->Include(hdc, L' ', rlWidth);

        if( !fRes )
        {
            // Error condition, just use the default width.
            rlWidth = pBaseCcs->_xAveCharWidth;
        }

        widthData.ch = ch;
        widthData.width = rlWidth;
        *GetEntry(ch) = widthData;
    }
    else
    {
        INT xWidth = 0;

        // Diacritics, tone marks, and the like have 0 width so return 0 if
        // GetCharWidthW() succeeds.
        BOOL fZeroWidth = IsZeroWidth(ch);
        BOOL fEUDCFixup = g_dwPlatformVersion < 0x40000 && IsEUDCChar(ch);

        if ( pBaseCcs->_bConvertMode == CM_SYMBOL )
        {
            if ( ch > 255 )
            {
#ifndef UNIX
                const unsigned char chSB = InWindows1252ButNotInLatin1(ch);
            
                if (chSB)
                {
                    fRes = GetCharWidthA( hdc, chSB, chSB, &xWidth );
                    if(pBaseCcs->_fScalingRequired) 
                        xWidth *= pBaseCcs->_flScaleFactor;
                }
                else
#endif
                {
                    char achSB[3];
                    INT xWidthSBC;

                    int cb = WideCharToMultiByte( pBaseCcs->_sCodePage, 0, &ch, 1, achSB, 3, NULL, NULL );

                    while (cb)
                    {
                        unsigned char uch = achSB[cb-1];
                        if (GetCharWidthA( hdc, uch, uch, &xWidthSBC ))
                            xWidth += ( !pBaseCcs->_fScalingRequired ? 
                                            xWidthSBC : xWidthSBC * pBaseCcs->_flScaleFactor );
                        else
                            xWidth += pBaseCcs->_xAveCharWidth;
                        --cb;
                    }
                    fRes = TRUE;
                }

            }
            else
            {
                fRes = GetCharWidthA( hdc, ch, ch, &xWidth );
                if(pBaseCcs->_fScalingRequired) 
                    xWidth *= pBaseCcs->_flScaleFactor;
            }
        }
        else if ( !fEUDCFixup && pBaseCcs->_bConvertMode != CM_MULTIBYTE )
        {
            // GetCharWidthW will crash on a 0xffff.
            Assert(ch != 0xffff);
            fRes = GetCharWidthW( hdc, ch, ch, &xWidth );
            if(pBaseCcs->_fScalingRequired) 
                xWidth *= pBaseCcs->_flScaleFactor;

            // See comment in CBaseCcs::GetTextMetrics

            xWidth += pBaseCcs->_sAdjustFor95Hack;
        }
        else
        {
            fRes = FALSE;
        }

        // either fAnsi case or GetCharWidthW fail, let's try GetCharWidthA
#ifndef UNIX
        if (!fRes || (0 == xWidth && !fZeroWidth))
#else // It's possible on UNIX with charWidth=0.
        if (!fRes)
#endif
        {
            WORD wDBCS;
            char ansiChar[2] = {0};
            UINT uCP = fEUDCFixup ? CP_ACP : pBaseCcs->_sCodePage;

            // Convert string
            numOfDBCS = WideCharToMultiByte( uCP, 0, &ch, 1,
                                             ansiChar, 2, NULL, NULL);

            if (2 == numOfDBCS)
                wDBCS = (BYTE)ansiChar[0] << 8 | (BYTE)ansiChar[1];
            else
                wDBCS = (BYTE)ansiChar[0];

            fRes = GetCharWidthA( hdc, wDBCS, wDBCS, &xWidth );
            if(pBaseCcs->_fScalingRequired) 
                xWidth *= pBaseCcs->_flScaleFactor;
        }

        widthData.width = xWidth;

        if ( fRes )
        {
#ifndef UNIX // On Unix , charWidth == 0 is not a bug.
            if (0 == widthData.width && !fZeroWidth)
            {
                // Sometimes GetCharWidth will return a zero length for small
                // characters. When this happens we will use the default width
                // for the font if that is non-zero otherwise we just us 1
                // because this is the smallest valid value.

                // NOTE: - under Win95 Trad. Chinese, there is a bug in the
                // font. It is returning a width of 0 for a few characters
                // (Eg 0x09F8D, 0x81E8) In such case, we need to use 2 *
                // pBaseCcs->_xAveCharWidth since these are DBCS

                if (0 == pBaseCcs->_xAveCharWidth)
                {
                    widthData.width = 1;
                }
                else
                {
                    widthData.width = (numOfDBCS == 2)
                                      ? (pBaseCcs->_xDefDBCWidth
                                         ? pBaseCcs->_xDefDBCWidth
                                         : 2 * pBaseCcs->_xAveCharWidth)
                                      : pBaseCcs->_xAveCharWidth;
                }
            }
#endif
            widthData.ch      = ch;
            if (widthData.ch <= pBaseCcs->_xOverhangAdjust)
                widthData.width = 1;
            else
                widthData.width   -= pBaseCcs->_xOverhangAdjust;
            rlWidth = widthData.width;
            *GetEntry(ch) = widthData;
        }
    }

#if DBG==1
    if (!fRes) 
         TraceTag((tagFontNoWidth, "no width?"));
#endif // DBG==1

    Assert( widthData.width == rlWidth );  // Did we forget to set it?

    return fRes;
}

//+----------------------------------------------------------------------------
//
//  Function:   CWidthCache::~CWidthCache
//
//  Synopsis:   Free any allocated caches
//
//-----------------------------------------------------------------------------

CWidthCache::~CWidthCache()
{
    INT i;

    for (i = 0; i < TOTALCACHES; i++ )
    {
        if (_pWidthCache[i])
            MemFree(_pWidthCache[i]);
    }
    MemFree(_pFastWidthCache);
}

//+----------------------------------------------------------------------------
//
//  Function:   CWidthCache::~CWidthCache
//
//  Synopsis:   Goes into a critical section, and allocates memory for 
//              a width cache.
//
//-----------------------------------------------------------------------------

void
CWidthCache::ThreadSafeCacheAlloc(void** ppCache, size_t iSize)
{
    EnterCriticalSection(&(fc()._csOther));

    if (!*ppCache)
    {
        *ppCache = MemAllocClear( Mt(CWidthCacheEntry), iSize );
    }

    LeaveCriticalSection(&(fc()._csOther));
}

//+----------------------------------------------------------------------------
//
//  Function:   CWidthCache::PopulateFastWidthCache
//
//  Synopsis:   Fills in the widths of the low 128 characters.
//              Allocates memory for the block if needed
//
//-----------------------------------------------------------------------------

#if !defined(WINCE)
// This function uses GetCharacterPlacement to get character widths. This
// This works better than GetCharWidths() under Win95.
static BOOL
GetWin95CharWidth(
    XHDC hdc,
    UINT iFirstChar,
    UINT iLastChar,
    int *pWidths)
{
    UINT i, start;
    TCHAR chars[257];
    GCP_RESULTS gcp={sizeof(GCP_RESULTS), NULL, NULL, pWidths,
    NULL, NULL, NULL, 128, 0};

    // Avoid overflows.
    Assert (iLastChar - iFirstChar < 128);

    // We want to get all the widths from 0 to 255 to stay in sync with our
    // width cache. Unfortunately, the zeroeth character is a zero, which
    // is the string terminator, which prevents any of the other characters
    // from getting the correct with. Since we can't use it anyway, we get the
    // width of a space character for zero.
    start=iFirstChar;
    if (iFirstChar == 0)
    {
        chars[0] = (TCHAR)' ';
        start++;
    }

    // Fill up our "string" with
    for (i=start; i<=iLastChar; i++)
    {
        chars[i-iFirstChar] = (TCHAR)i;
    }
    // Null terminate because I'm suspicious of GetCharacterPlacement's handling
    // of NULL characters.
    // chars[i-iFirstChar] = 0;

    gcp.nGlyphs = iLastChar - iFirstChar + 1;

    return !!GetCharacterPlacement(hdc, chars, iLastChar-iFirstChar + 1, 0, &gcp, 0);
}
#endif // !WINCE

extern BOOL g_fPrintToGenericTextOnly;

#if DBG==1
#pragma warning(disable:4189) // local variable initialized but not used
#endif

BOOL
CWidthCache::PopulateFastWidthCache(XHDC hdc, CBaseCcs* pBaseCcs, CDocInfo * pdci)
{    
    UseScreenDCForMeasuring(&hdc);

    BOOL fRes;
    FONTIDX hfontOld;
    // First switch to the appropriate font.
    hfontOld = pBaseCcs->PushFont(hdc);

    // characters in 0 - 127 range (cache 0), so initialize the character widths for
    // for all of them.
    int widths[ FAST_WIDTH_CACHE_SIZE ];
    int i;

    // TODO: (track bug 112157) remove this HACKHACK..
    // HACKHACK (greglett)
    // Remove this for v4!
    // Hack to support Generic/Text Only printer - it always returns non TrueType, monospace 60px/12px (NT/9x) characters.
    // Since we instantiate fonts on the screen DC, we get completely wrong answers.  So, our hack is just to assume
    // we know what the character widths should be.
    // This should be removed in v4, when we have time to do a correct fix!  It's related to (and should be fixed at the same
    // time as) the UseScreenDCForMeasuring hack.
    if (    g_fPrintToGenericTextOnly
        &&  pdci->GetResolution().cx > 400 )    // HACK!  (on top of hack!) to check print media for Generic/TextOnly printer.
    {
        int nTargetWidth = g_fUnicodePlatform ? 60 : 12;                // Known character width on printer.
        double nScale    = pdci->GetResolution().cx / (nTargetWidth * 10);    // Known resolution of printer.
        nTargetWidth = (nTargetWidth * nScale) + (nTargetWidth - 1);

        for(int i=0; i < FAST_WIDTH_CACHE_SIZE; i++) 
            widths[i] = nTargetWidth;

        fRes = TRUE;
    }
    else
    {

#if !defined(WINCE) && !defined(UNIX)
    // If this is Win95 and this is not a true type font
    // GetCharWidth*() returns unreliable results, so we do something
    // slow, painful, but accurate.
#if defined(_MAC)
    fRes = GetCharWidth(hdc, 0, FAST_WIDTH_CACHE_SIZE-1, widths);
    if(pBaseCcs->_fScalingRequired)
    {
        for(int i=0; i < FAST_WIDTH_CACHE_SIZE; i++) 
            widths[i] *= pBaseCcs->_flScaleFactor; 
    }
    
    // ## v-gsrir
    // Overhang adjustments for non-truetype fonts in Win16
    if (   pBaseCcs->_xOverhangAdjust 
        && fRes)
    {
        for (i=0; i< FAST_WIDTH_CACHE_SIZE; i++)
            widths[i] -= pBaseCcs->_xOverhangAdjust;
    }

#else
    if (!g_fUnicodePlatform)
    {
        LONG lfAbsHeight = abs(pBaseCcs->_lf.lfHeight);

        // COMPLEXSCRIPT - With so many nonsupported charsets, why not avoid using GCP?
        //                 GCP does not work with any of the languages that need it.
        // HACK (cthrash) If the absolute height is too small, the return values
        // from GDI are unreliable.  We might as well use the GetCharWidthA values,
        // which aren't stellar either, but empirically better.
        if (lfAbsHeight > 3 &&
            !(pBaseCcs->_sPitchAndFamily & TMPF_VECTOR) &&
            pBaseCcs->_bCharSet != SYMBOL_CHARSET &&
            pBaseCcs->_bCharSet != ARABIC_CHARSET &&
            pBaseCcs->_bCharSet != HEBREW_CHARSET &&
            pBaseCcs->_bCharSet != VIETNAMESE_CHARSET &&
            pBaseCcs->_bCharSet != THAI_CHARSET)
        {
            fRes = GetWin95CharWidth(hdc, 0, FAST_WIDTH_CACHE_SIZE-1, widths);
            if(pBaseCcs->_fScalingRequired)
            {
                for(int i=0; i < FAST_WIDTH_CACHE_SIZE; i++) 
                    widths[i] *= pBaseCcs->_flScaleFactor; 
            }
        }
        else
        {
            fRes = GetCharWidthA(hdc, 0, FAST_WIDTH_CACHE_SIZE-1, widths);
            if(pBaseCcs->_fScalingRequired)
            {
                for(int i=0; i < FAST_WIDTH_CACHE_SIZE; i++) 
                    widths[i] *= pBaseCcs->_flScaleFactor; 
            }

            if (   pBaseCcs->_xOverhangAdjust 
                && fRes)
            {
                for (i=0; i< FAST_WIDTH_CACHE_SIZE; i++)
                    widths[i] -= pBaseCcs->_xOverhangAdjust;
            }
        }
    }
    else
#endif // !_MAC
#endif // !WINCE && !UNIX

    {
        fRes = GetCharWidth32(hdc, 0, FAST_WIDTH_CACHE_SIZE-1, widths);
        if(pBaseCcs->_fScalingRequired)
        {
            for(int i=0; i < FAST_WIDTH_CACHE_SIZE; i++) 
                widths[i] *= pBaseCcs->_flScaleFactor; 
        }
#if DBG==1
        if (!fRes)
        {
            AssertSz(0, "GetCharWidth32 failed");
            INT errorVal = GetLastError();
            HFONT hf = (HFONT)GetCurrentObject(hdc, OBJ_FONT);
#ifdef NEVER
            FONTIDX fidx = GetCurrentFontIdx(hdc);
            Assert(fidx == pBaseCcs->_hfont);
#endif // NEVER
        }
#endif // DBG==1
    }
    }

    // Copy the results back into the real cache, if it worked.
    if (fRes)
    {
        Assert( !_pFastWidthCache );  // Since we should only populate this once.

        ThreadSafeCacheAlloc( (void **)&_pFastWidthCache, sizeof(CharWidth) * FAST_WIDTH_CACHE_SIZE );

        if( !_pFastWidthCache )
        {
            // We're kinda in trouble if we can't get memory for the cache.
            AssertSz(0,"Failed to allocate fast width cache.");
            fRes = FALSE;
            goto Cleanup;
        }

        for(i = 0; i < FAST_WIDTH_CACHE_SIZE; i++)
        {
            _pFastWidthCache[i]= (widths[i]) ? widths[i] : pBaseCcs->_xAveCharWidth;
        }

        // NB (cthrash) Measure NBSPs with space widths.
        SetCacheEntry(WCH_NBSP, _pFastWidthCache[_T(' ')] );
    }

Cleanup:
    pBaseCcs->PopFont(hdc, hfontOld);

    return fRes;
}  // PopulateFastWidthCache

#if DBG==1
#pragma warning(default:4189) // local variable initialized but not used 
#endif

//+----------------------------------------------------------------------------
//
//  Function:   InWindows1252ButNotInLatin1Helper
//
//-----------------------------------------------------------------------------
BYTE
InWindows1252ButNotInLatin1Helper(WCHAR ch)
{
    for (int i=32;i--;)
    {
        if (ch == g_achLatin1MappingInUnicodeControlArea[i])
        {
            return 0x80 + i;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\fontcache.cxx ===
#include "headers.hxx"

#ifndef X_FONTCACHE_HXX_
#define X_FONTCACHE_HXX_
#include "fontcache.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

DeclareTag(tagNoFontLinkAdjust, "Font", "Don't adjust font height when fontlinking");
ExternTag(tagMetrics);
MtDefine(CFontCache, PerProcess, "CFontCache");

//+----------------------------------------------------------------------------
//
//  Font cache stock object.
//
//-----------------------------------------------------------------------------

CFontCache g_FontCache;

//+----------------------------------------------------------------------------
//
//  Function:   InitFontCache
//
//  Synopsis:   Initialize the font cache.
//
//  Returns:    E_OUTOFMEMORY if cannot initialize critical sections;
//              S_OK otherwise
//
//-----------------------------------------------------------------------------

HRESULT InitFontCache()
{
    return fc().Init();
}

//+----------------------------------------------------------------------------
//
//  Function:   DeInitFontCache
//
//  Synopsis:   Cleart the font cache.
//
//-----------------------------------------------------------------------------

void DeInitFontCache()
{
    fc().DeInit();
}

//+----------------------------------------------------------------------------
//
//  Function:   ClearFaceCache
//
//  Synopsis:   Return our small face name cache to a zero state.
//
//-----------------------------------------------------------------------------

void ClearFaceCache()
{
    fc().ClearFaceCache();
}

//+----------------------------------------------------------------------------
//
//  Function:   DeinitUniscribe
//
//  Synopsis:   Clear script caches in USP.DLL private heap. This will permit 
//              a clean shut down of USP.DLL (Uniscribe).
//
//-----------------------------------------------------------------------------

void DeinitUniscribe()
{
    fc().FreeScriptCaches();
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::CFontCache
//
//  Synopsis:   Font cache ctor.
//
//-----------------------------------------------------------------------------

CFontCache::CFontCache()
{
    _dwAgeNext = 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::CFontCache
//
//  Synopsis:   Font cache dctor.
//
//-----------------------------------------------------------------------------

CFontCache::~CFontCache()
{
#if DBG == 1
    unsigned long i;

    //
    // Make sure font cache is cleared
    //
    for (i = 0; i < cFontCacheSize; i++)
    {
        Assert(NULL == _rpBaseCcs[i]);
    }
    for (i = 0; i < cQuickCrcSearchSize+1; i++)
    {
        Assert(NULL == quickCrcSearch[i].pBaseCcs);
    }

    //
    // Make sure font face cache is cleared
    //
    Assert(0 == _iCacheLen);
    Assert(0 == _iCacheNext);
#endif
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::Init
//
//  Synopsis:   Initialize font cache data.
//
//              Don't need to be guarded. This function is called only if
//              the current process is attaching.
//
//-----------------------------------------------------------------------------

HRESULT CFontCache::Init()
{
    //
    // Make sure font cache is uninitialized
    //
    Assert(_dwAgeNext == 0);

    HRESULT hr;

    //
    // Initialize font cache guards.
    //
    _lCSInited = 0;

    hr = HrInitializeCriticalSection(&_cs);
    if (hr) goto Cleanup;
    ++_lCSInited;

    hr = HrInitializeCriticalSection(&_csOther);
    if (hr) goto Cleanup;
    ++_lCSInited;

    hr = HrInitializeCriticalSection(&_csFaceCache);
    if (hr) goto Cleanup;
    ++_lCSInited;

    hr = HrInitializeCriticalSection(&_csFaceNames);
    if (hr) goto Cleanup;
    ++_lCSInited;

    //
    // Initialize font cache.
    //
    EnterCriticalSection(&_cs/*FontCache*/);
    unsigned long i;
    for (i = 0; i < cFontCacheSize; i++)
    {
        _rpBaseCcs[i] = NULL;
    }
    for (i = 0; i < cQuickCrcSearchSize+1; i++)
    {
        quickCrcSearch[i].pBaseCcs = NULL;
    }
    LeaveCriticalSection(&_cs/*FontCache*/);

    //
    // Initialize face cache
    //

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::DeInit
//
//  Synopsis:   Uninitialize font cache data.
//
//              Don't need to be guarded. This function is called only if
//              the current process is detaching.
//
//-----------------------------------------------------------------------------

void CFontCache::DeInit()
{
    //
    // Clear caches
    //
    ClearFontCache();
    ClearFaceCache();

    // Only delete the Critical Sections that were successfully initialized
    unsigned long iCSCurrent = 4;
    if (iCSCurrent-- <= _lCSInited)
        DeleteCriticalSection(&_csFaceNames);
    if (iCSCurrent-- <= _lCSInited)
        DeleteCriticalSection(&_csFaceCache);
    if (iCSCurrent-- <= _lCSInited)
        DeleteCriticalSection(&_csOther);
    if (iCSCurrent-- <= _lCSInited)
        DeleteCriticalSection(&_cs);
    _lCSInited = 0;

    _atFontInfo.Free();  // Maybe we should do this in a critical section, but naw...

#if DBG == 1
    TraceTag((tagMetrics, "Font Metrics:"));

    TraceTag((tagMetrics, "\tSize of FontCache:%ld", sizeof(CFontCache)));
    TraceTag((tagMetrics, "\tSize of Cccs:%ld + a min of 1024 bytes", sizeof(CCcs)));
    TraceTag((tagMetrics, "\tMax no. of fonts allocated:%ld", CBaseCcs::s_cMaxCccs));
    TraceTag((tagMetrics, "\tNo. of fonts replaced: %ld", _cCccsReplaced));
#endif
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::ClearFontFaceCache
//
//  Synopsis:   Clear font face cache.
//
//-----------------------------------------------------------------------------

void CFontCache::ClearFaceCache()
{
    EnterCriticalSection(&_csFaceCache);

    _iCacheLen = 0;
    _iCacheNext = 0;

    LeaveCriticalSection(&_csFaceCache);
}


//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::ClearFontCache
//
//  Synopsis:   Clear font cache.
//
//-----------------------------------------------------------------------------

void CFontCache::ClearFontCache()
{
    EnterCriticalSection(&_cs/*FontCache*/);

    unsigned long i;
    for (i = 0; i < cFontCacheSize; i++)
    {
        if (_rpBaseCcs[i])
        {
            _rpBaseCcs[i]->ReleaseScriptCache();
            _rpBaseCcs[i]->PrivateRelease();
            _rpBaseCcs[i] = NULL;
        }
    }
    for (i = 0; i < cQuickCrcSearchSize+1; i++)
    {
        quickCrcSearch[i].pBaseCcs = NULL;
    }
    _dwAgeNext = 0;

    LeaveCriticalSection(&_cs/*FontCache*/);
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::FreeScriptCaches
//
//  Synopsis:   Free script caches in USP.DLL private heap. This will permit 
//              a clean shut down of USP.DLL (Uniscribe).
//
//              Don't need to be guarded. This function is called only if
//              all threads have been detached.
//
//-----------------------------------------------------------------------------

void CFontCache::FreeScriptCaches()
{
    unsigned long i;
    for (i = 0; i < cFontCacheSize; i++)
    {
        if (_rpBaseCcs[i])
        {
            _rpBaseCcs[i]->ReleaseScriptCache();
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::EnsureScriptIDsForFont
//
//  Synopsis:   When we add a new facename to our _atFontInfo cache, we
//              defer the calculation of the script IDs (sids) for this
//              face.  An undetermined sids has the value of sidsNotSet.
//              Inside of CBaseCcs::MakeFont, we need to make sure that the
//              script IDs are computed, as we will need this information
//              to fontlink properly.
//
//  Arguments:  [hdc]             - handle to the current DC
//              [pBaseCcs]        - font information set
//              [dwFlags]         - is font downloaded? or need to use MLang?
//              [pfHKSCSHack]     - [in] need to check for HKSCS hack?
//                                  [out] need to apply HKSCS hack?
//
//  Returns:    SCRIPT_IDS.  If an error occurs, we return sidsAll, which
//              effectively disables fontlinking for this font.
//
//-----------------------------------------------------------------------------

SCRIPT_IDS CFontCache::EnsureScriptIDsForFont(
    XHDC hdc,                   // [in]
    const CBaseCcs * pBaseCcs,  // [in]
    DWORD dwFlags,              // [in]
    BOOL * pfHKSCSHack )        // [in, out]
{
    // NOTE (grzegorz): It might be a good idea to use _latmRealFaceName
    // instead of _latmLFFaceName.

    const LONG latmFontInfo = pBaseCcs->_latmLFFaceName;
    SCRIPT_IDS sids;

    if (latmFontInfo)
    {
        CFontInfo * pfi;
        HRESULT hr = THR(_atFontInfo.GetInfoFromAtom(latmFontInfo-1, &pfi));

        if (SUCCEEDED(hr))
        {
            if (   pfi->_sids == sidsNotSet
                || (pfi->_fFSOnly && (dwFlags & FC_SIDS_USEMLANG)))
            {
                if (!(dwFlags & FC_SIDS_DOWNLOADEDFONT))
                {
                    CFontInfo * pfiReal;
                    Assert(pBaseCcs->_latmRealFaceName > 0);
                    HRESULT hr = THR(_atFontInfo.GetInfoFromAtom(pBaseCcs->_latmRealFaceName-1, &pfiReal));
                    if (SUCCEEDED(hr))
                    {
                        pfi->_sids = GetFontScriptCoverage(pfiReal->_cstrFaceName, hdc.GetFontInfoDC(), 
                                                           pBaseCcs->GetHFont(), 
                                                           pBaseCcs->_sPitchAndFamily & TMPF_TRUETYPE,
                                                           !(dwFlags & FC_SIDS_USEMLANG));
                    }
                    else
                    {
                        pfi->_sids = sidsAll;
                    }
                }
                else
                {
                    pfi->_sids = sidsAll; // don't fontlink for embedded fonts
                }
                pfi->_fFSOnly = !(dwFlags & FC_SIDS_USEMLANG);
            }

            sids = pfi->_sids;

            // NOTE (cthrash) FE fonts will rarely cover enough of the Greek & Cyrillic
            // codepoints.  This hack basically forces us to fontlink for these.
            if (IsFECharset(pBaseCcs->_bCharSet))
            {
                sids &= ~(ScriptBit(sidLatin) | ScriptBit(sidCyrillic) | ScriptBit(sidGreek));
            }
            if (pBaseCcs->_fLatin1CoverageSuspicious && !(dwFlags & FC_SIDS_DOWNLOADEDFONT))
            {
                sids &= ~ScriptBit(sidLatin);
            }
            if (pfHKSCSHack)
            {
                if (*pfHKSCSHack
                    && sids & ScriptBit(sidBopomofo)
                    && pfi->_cstrFaceName.Length())
                {
                    TCHAR * szFaceName = pfi->_cstrFaceName;
                    if (pfi->_cstrFaceName[0] == _T('@'))
                        ++szFaceName;
                    const TCHAR * szAltFaceName = AlternateFontNameIfAvailable(szFaceName);

                    if (   0 == _tcsicmp(_T("MingLiU_HKSCS"), szFaceName)
                        || 0 == _tcsicmp(_T("MingLiU"), szFaceName)
                        || 0 == _tcsicmp(_T("PMingLiU"), szFaceName)
                        || 0 == _tcsicmp(_T("MingLiU_HKSCS"), szAltFaceName)
                        || 0 == _tcsicmp(_T("MingLiU"), szAltFaceName)
                        || 0 == _tcsicmp(_T("PMingLiU"), szAltFaceName))
                    {
                        sids |= ScriptBit(sidLatin);
                        Assert(*pfHKSCSHack == TRUE);
                    }
                    else
                    {
                        *pfHKSCSHack = FALSE;
                    }
                }
                else
                {
                    *pfHKSCSHack = FALSE;
                }
            }

            if (sids & ScriptBit(sidLatin))
            {
                sids |= ScriptBit(sidCurrency);
            }
        }
        else
            sids = sidsAll;
    }
    else
    {
        sids = sidsAll;
    }

    return sids;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetAtomWingdings
//
//-----------------------------------------------------------------------------

LONG
CFontCache::GetAtomWingdings()
{
    if( !_latmWingdings )
    {
        _latmWingdings = GetAtomFromFaceName( _T("Wingdings") );
        _atFontInfo.SetScriptIDsOnAtom( _latmWingdings - 1, sidsAll );
    }
    return _latmWingdings;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetCcs
//
//  Synopsis:   Search the font cache for a matching logical font and return it.
//              If a match is not found in the cache, create one.
//
//-----------------------------------------------------------------------------

BOOL
CFontCache::GetCcs(
    CCcs * pccs,
    XHDC hdc,
    CDocInfo * pdci,
    const CCharFormat * const pcf )
{
    Assert(pccs);
    pccs->SetHDC(hdc);
    pccs->SetBaseCcs(GetBaseCcs(hdc, pdci, pcf, NULL, pccs->_fForceTTFont));
    return !!pccs->GetBaseCcs();
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetFontLinkCcs
//
//  Synopsis:   Search the font cache for a matching logical font and return it.
//              If a match is not found in the cache, create one.
//
//-----------------------------------------------------------------------------

BOOL
CFontCache::GetFontLinkCcs(
    CCcs * pccs,
    XHDC hdc,
    CDocInfo * pdci,
    CCcs * pccsBase,
    const CCharFormat * const pcf )
{
    Assert(pccs);

#if DBG==1
    //
    // Allow disabling the height-adjusting feature of fontlinking through tags
    //
    
    if (IsTagEnabled(tagNoFontLinkAdjust))
        return GetCcs(pccs, hdc, pdci, pcf);
#endif

    CBaseCcs * pBaseBaseCcs = pccsBase->_pBaseCcs;

    pBaseBaseCcs->AddRef();

    pccs->SetHDC(hdc);
    pccs->SetBaseCcs(GetBaseCcs(hdc, pdci, pcf, pBaseBaseCcs, pccs->_fForceTTFont));
                   
    pBaseBaseCcs->PrivateRelease();

    return !!pccs->GetBaseCcs();
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetBaseCcs
//
//  Synopsis:   Search the font cache for a matching logical font and return it.
//              If a match is not found in the cache, create one.
//
//-----------------------------------------------------------------------------

CBaseCcs *
CFontCache::GetBaseCcs(
    XHDC hdc,
    CDocInfo * pdci,
    const CCharFormat * const pcf,          // description of desired logical font
    const CBaseCcs * const pBaseBaseCcs,    // facename from which we're fontlinking
    BOOL fForceTTFont)
{
    CBaseCcs *pBaseCcs = NULL;
    LONG      lfHeight;
    int       i;
    BYTE      bCrc;
    SHORT     hashKey;
    CBaseCcs::CompareArgs cargs;
    BOOL (CBaseCcs::*CompareFunc)(CBaseCcs::CompareArgs*);
    BOOL fNeedRelease = FALSE;

    // Duplicate the format structure because we might need to change some of the
    // values by the zoom factor
    // and in the case of sub superscript
    CCharFormat cf = *pcf;

    //FUTURE igorzv
    //Take subscript size, subscript offset, superscript offset, superscript size
    // from the OUTLINETEXMETRIC

    lfHeight = -cf.GetHeightInPixels(hdc, pdci);

    bCrc = cf._bCrcFont;

    Assert (bCrc == cf.ComputeFontCrc());

    if (!lfHeight)
        lfHeight--; // round error, make this a minimum legal height of -1.

    cargs.pcf = &cf;
    cargs.lfHeight = lfHeight;
    cargs.fTTFont = fForceTTFont;

    if (pBaseBaseCcs)
    {
        cargs.latmBaseFaceName = pBaseBaseCcs->_latmLFFaceName;
        CompareFunc = CBaseCcs::CompareForFontLink;
    }
    else
    {
        cargs.latmBaseFaceName = pcf->_latmFaceName;
        CompareFunc = CBaseCcs::Compare;
    }

    EnterCriticalSection(&_cs);

    // check our hash before going sequential.
    hashKey = bCrc & cQuickCrcSearchSize;
    if ( bCrc == quickCrcSearch[hashKey].bCrc )
    {
        pBaseCcs = quickCrcSearch[hashKey].pBaseCcs;
        if (pBaseCcs && pBaseCcs->_bCrc == bCrc)
        {
            if ((pBaseCcs->*CompareFunc)( &cargs ))
            {
                goto matched;
            }
        }
    }
    quickCrcSearch[hashKey].bCrc = bCrc;

    // squentially search ccs for same character format
    for (i = 0; i < cFontCacheSize; i++)
    {
        pBaseCcs = _rpBaseCcs[i];
        if (pBaseCcs && pBaseCcs->_bCrc == bCrc)
        {
            if ((pBaseCcs->*CompareFunc)( &cargs ))
            {
                goto matched;
            }
        }
    }
    pBaseCcs = NULL;

matched:
    if (!pBaseCcs)
    {
        fNeedRelease = fForceTTFont;

        // we did not find a match, init a new font cache.
        pBaseCcs = GrabInitNewBaseCcs(hdc, &cf, pdci, cargs.latmBaseFaceName, fForceTTFont);

        if (   pBaseCcs
            && pBaseBaseCcs
            && !pBaseCcs->_fHeightAdjustedForFontlinking)
        {
            // Adjust font height only for:
            // 1) thai script
            // 2) FE script and size < 9pt
            SCRIPT_IDS sidsFE = ScriptBit(sidKana) | ScriptBit(sidHan) | ScriptBit(sidBopomofo) | ScriptBit(sidHangul);
            if (   (pBaseCcs->_sids & ScriptBit(sidThai))
                || ((pBaseCcs->_sids & sidsFE) && cf._yHeight < TWIPS_FROM_POINTS(9)))
            {
                pBaseCcs->FixupForFontLink(hdc, pBaseBaseCcs, pBaseCcs->_sids & sidsFE);
            }
        }
    }
    else
    {
        if (pBaseCcs->_dwAge != _dwAgeNext - 1)
            pBaseCcs->_dwAge = _dwAgeNext++;
    }

    if (pBaseCcs)
    {
        // Don't cache in 'force TrueType' mode
        if (!fForceTTFont)
            quickCrcSearch[hashKey].pBaseCcs = pBaseCcs;

        // AddRef the entry being returned
        pBaseCcs->AddRef();

        if (!pBaseCcs->EnsureFastCacheExists(hdc, pdci))
        {
            pBaseCcs->PrivateRelease();
            pBaseCcs = NULL;
        }

        if (fNeedRelease)
            pBaseCcs->PrivateRelease();
    }

    LeaveCriticalSection(&_cs);

    return pBaseCcs;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetAtomFromFaceName
//
//  Synopsis:   Checks to see if this face name is in the atom table.
//              if not, puts it in.  We report externally 1 higher than the
//              actualy atom table values, so that we can reserve latom==0
//              to the error case, or a blank string.
//
//-----------------------------------------------------------------------------

LONG
CFontCache::GetAtomFromFaceName( const TCHAR* szFaceName )
{
    HRESULT hr;
    LONG lAtom=0;

    // If they pass in the NULL string, when they ask for it out again,
    // they're gonna get a blank string, which is different.
    Assert(szFaceName);

    if( szFaceName && *szFaceName ) {

        EnterCriticalSection(&_csFaceNames);
        hr= _atFontInfo.GetAtomFromName(szFaceName, &lAtom);
        if( hr )
        {
            // String not in there.  Put it in.
            // Note we defer the calculation of the SCRIPT_IDS.
            hr= THR(_atFontInfo.AddInfoToAtomTable(szFaceName, &lAtom));
            AssertSz(hr==S_OK,"Failed to add Font Face Name to Atom Table");
        }
        if( hr == S_OK )
        {
            lAtom++;
        }
        LeaveCriticalSection(&_csFaceNames);
    }
    // else input was NULL or empty string.  Return latom=0.

    return lAtom;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::FindAtomFromFaceName
//
//  Synopsis:   Checks to see if this face name is in the atom table.
//
//-----------------------------------------------------------------------------

LONG
CFontCache::FindAtomFromFaceName( const TCHAR* szFaceName )
{
    HRESULT hr;
    LONG lAtom=0;

    // If they pass in the NULL string, when they ask for it out again,
    // they're gonna get a blank string, which is different.
    Assert(szFaceName);

    if( szFaceName && *szFaceName ) {

        EnterCriticalSection(&_csFaceNames);
        hr= _atFontInfo.GetAtomFromName(szFaceName, &lAtom);
        if( hr == S_OK )
        {
            lAtom++;
        }
        LeaveCriticalSection(&_csFaceNames);
    }

    // lAtom of zero means that it wasn't found or that the input was bad.
    return lAtom;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetFaceNameFromAtom
//
//-----------------------------------------------------------------------------

const TCHAR *
CFontCache::GetFaceNameFromAtom( LONG latmFaceName )
{
    const TCHAR* szReturn=g_Zero.ach;

    if (latmFaceName > 0)
    {
        HRESULT hr;
        CFontInfo * pfi;

        EnterCriticalSection(&_csFaceNames);
        hr = THR(_atFontInfo.GetInfoFromAtom(latmFaceName-1, &pfi));
        LeaveCriticalSection(&_csFaceNames);
        Assert( !hr );
        Assert( pfi->_cstrFaceName.Length() < LF_FACESIZE );
        szReturn = pfi->_cstrFaceName;
    }
    return szReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\fontlink.cxx ===
#include "headers.hxx"

#ifndef X_FONTLINK_HXX_
#define X_FONTLINK_HXX_
#include "fontlink.hxx"
#endif

#ifndef X_MULTILANG_HXX_
#define X_MULTILANG_HXX_
#include "multilang.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_FONTCACHE_HXX_
#define X_FONTCACHE_HXX_
#include "fontcache.hxx"
#endif

#ifndef X_WCHDEFS_H___
#define X_WCHDEFS_H___
#include "wchdefs.h"
#endif

extern CUnicodeRanges g_UnicodeRanges;

//+----------------------------------------------------------------------------
//
//  MLang fontlinking deinitialization
//  This function is implemented here because intlcore library doesn't know
//  about THREADSTATE.
//
//-----------------------------------------------------------------------------
void DeinitMLangFontLinking(THREADSTATE * pts)
{
    if (mlang().IsLoaded())
    {
        IMLangFontLink * pMLangFontLink = mlang().GetMLangFontLink();
        if (pMLangFontLink)
            pMLangFontLink->ResetFontMapping();
    }
}

//+----------------------------------------------------------------------------
// Fontlink wrapper object
//-----------------------------------------------------------------------------

CFontLink g_FontLink;

//+----------------------------------------------------------------------------
//
//  Function:   DeinitFontLinking
//
//  Synopsis:   Detach from Fontlink. Called from DllAllThreadsDetach.
//              Globals are locked during the call.
//
//-----------------------------------------------------------------------------
void DeinitFontLinking()
{
    fl().Unload();
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::CFontLink
//
//  Synopsis:   Initializes Fontlink wrapper object.
//
//-----------------------------------------------------------------------------

CFontLink::CFontLink()
{
    _pUnicodeScriptMapper = NULL;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::~CFontLink
//
//  Synopsis:   Deinitializes Fontlink wrapper object.
//
//-----------------------------------------------------------------------------

CFontLink::~CFontLink()
{
    Assert(_pUnicodeScriptMapper == NULL);
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::CreateObjects
//
//  Synopsis:   Create Fontlink object and QI required interfaces.
//
//-----------------------------------------------------------------------------

void CFontLink::CreateObjects()
{
    g_UnicodeRanges.QueryInterface(IID_IUnicodeScriptMapper, reinterpret_cast<void **>(&_pUnicodeScriptMapper));
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::DestroyObjects
//
//  Synopsis:   Release all Fontlink interfaces
//
//-----------------------------------------------------------------------------

void CFontLink::DestroyObjects()
{
    if (_pUnicodeScriptMapper)
    {
        _pUnicodeScriptMapper->Release();
        _pUnicodeScriptMapper = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::DisambiguateScript
//
//  Synopsis:   Pick up one of valid script ids for a string of ambiguous characters.
//              Will stop analyzing when finds a new script.
//
//  Arguments:  [cpFamily] - family codepage of the document
//              [lcid]     - locale id of the text
//              [sidLast]  - script id of the previous character
//              [pch]      - text buffer to analyze
//              [pcch]     - [in]  size of the text buffer
//                           [out] number of characters analyzed
//
//  Returns:    Script ID.
//
//-----------------------------------------------------------------------------

SCRIPT_ID CFontLink::DisambiguateScript(
    CODEPAGE cpFamily, 
    LCID lcid, 
    SCRIPT_ID sidLast, 
    const TCHAR * pch, 
    long * pcch)
{
    Assert(pch && *pch);
    Assert(pcch && (*pcch > 0));

    //
    // PERF (cthrash) In the following HTML, we will have a sidAmbiguous
    // run with a single space char in in (e.g. amazon.com): <B>&middot;</B> X
    // The middot is sidAmbiguous, the space is sidMerge, and thus they merge.
    // The X of course is sidAsciiLatin.  When called for a single space char,
    // we don't want to bother calling MLANG.  Just give the caller a stock
    // answer so as to avoid the unnecessary busy work.
    //    
    if (*pcch == 1 && *pch == WCH_SPACE)
        return sidAsciiLatin;

    //
    // PERF (grzegorz) When called for single Latin-1, General Punctuation
    // or Letterlike Symbols character on English pages, 
    // we don't want to bother calling MLANG. Just give the caller a stock answer.
    // NOTE: we cannot apply this hack for Unicode pages, because we can have any content there.
    //
    if (   cpFamily == CP_1252
        && (   InRange(*pch, 0x0080, 0x00ff)
            || InRange(*pch, 0x2000, 0x206f) 
            || InRange(*pch, 0x2100, 0x214f)))
    {
        *pcch = 1;
        return sidLatin;
    }

    EnsureObjects();

    if (!_pUnicodeScriptMapper) 
        return sidDefault;

    SCRIPT_ID  sidPrefered;
    SCRIPT_IDS sidsAvailable = ScriptsFromCPBit(mlang().GetInstalledLangPacks());

    if (lcid)
    {
        sidPrefered = ScriptIDFromLangID(LANGIDFROMLCID(lcid));
    }
    else
    {
        sidPrefered = sidLast;
        if (sidPrefered == sidDefault)
        {
            sidPrefered = ScriptIDFromCodePage(cpFamily);
            if (sidPrefered == sidDefault)
            {
                LANGID lid  = LANGIDFROMLCID(GetSystemDefaultLCID());
                sidPrefered = ScriptIDFromLangID(lid);
            }
        }
    }

    HRESULT hr;
    SCRIPT_ID sid;
    hr = _pUnicodeScriptMapper->DisambiguateScriptMulti(pch, *pcch, 
        sidPrefered, sidsAvailable, 0, pcch, &sid);
    if (FAILED(hr))
        return sidDefault;

    return sid;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::UnunifyHanScript
//
//  Synopsis:   Pick up one of the Far East script ids (sidKana, sidHangul, 
//              sidBopomofo, sidHan) for a string of Han characters.
//              Will stop analyzing when finds a new script.
//
//  Arguments:  [cpFamily] - family codepage of the document
//              [lcid]     - locale id of the text
//              [sidsFontFace] - script coverage of the current font
//              [pch]      - text buffer to analyze
//              [pcch]     - [in]  size of the text buffer
//                           [out] number of characters analyzed
//
//  Returns:    sidKana     for Japanese
//              sidHangul   for Korean
//              sidBopomofo for Traditional Chinese
//              sidHan      for Simplified Chinese
//
//-----------------------------------------------------------------------------

SCRIPT_ID CFontLink::UnunifyHanScript(
    CODEPAGE cpFamily, 
    LCID lcid, 
    SCRIPT_IDS sidsFontFace, 
    const TCHAR * pch, 
    long * pcch)
{
    Assert(pch && *pch);
    Assert(pcch && (*pcch > 0));

    EnsureObjects();

    if (!_pUnicodeScriptMapper) 
        return sidDefault;

    SCRIPT_ID  sidPrefered;
    SCRIPT_IDS sidsAvailable = ScriptsFromCPBit(mlang().GetInstalledLangPacks());

    if (lcid)
    {
        sidPrefered = ScriptIDFromLangID(LANGIDFROMLCID(lcid));
    }
    else
    {
        sidPrefered = ScriptIDFromCodePage(cpFamily);
        if (sidPrefered == sidDefault)
        {
            LANGID lid  = LANGIDFROMLCID(GetSystemDefaultLCID());
            sidPrefered = ScriptIDFromLangID(lid);
        }
    }
    
    HRESULT hr = S_FALSE;
    SCRIPT_ID sid = sidDefault;
    long cch = *pcch;

    // First ask about scripts supported by the current font.
    // If it fails to resolve to appropriate script id, use available
    // lang pack.
    if (sidsFontFace)
    {
        hr = _pUnicodeScriptMapper->UnunifyHanScriptMulti(pch, *pcch,
            sidPrefered, sidsFontFace, USM_AVAILABLESIDONLY, &cch, &sid);
        if (FAILED(hr))
            return sidDefault;
    }
    if (hr == S_FALSE)
    {
        cch = *pcch;
        hr = _pUnicodeScriptMapper->UnunifyHanScriptMulti(pch, *pcch,
            sidPrefered, sidsAvailable, 0, &cch, &sid);
        if (FAILED(hr))
            return sidDefault;
    }

    *pcch = cch;

    return sid;
}

//+----------------------------------------------------------------------------
//
//  Function:   ScriptAppropriateFaceNameAtom
//
//  Synopsis:   Queries MLANG for a font that supports a particular script.
//
//  Returns:    An atom value for the script-appropriate font.  0 on error.
//              0 implies the system font.
//
//-----------------------------------------------------------------------------

HRESULT CFontLink::ScriptAppropriateFaceNameAtom(
    SCRIPT_ID sid,
    LONG & atmProp,
    LONG & atmFixed)
{
    Assert(atmProp == -1 || atmFixed == -1);

    HRESULT hr;
    wchar_t pchPropName  [LF_FACESIZE];
    wchar_t pchFixedName [LF_FACESIZE];

    hr = mlang().ScriptAppropriateFaceName(sid, pchPropName, pchFixedName);
    if (SUCCEEDED(hr))
    {
        if (atmProp == -1)
            atmProp = pchPropName[0] ? fc().GetAtomFromFaceName(pchPropName) : 0; // 0 == System
        if (atmFixed == -1)
            atmFixed = pchFixedName[0] ? fc().GetAtomFromFaceName(pchFixedName) : 0; // 0 == System
    }
    else
    {
        atmProp  = 0; // 0 == System
        atmFixed = 0; // 0 == System
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\keynav.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       keynav.cxx
//
//  Contents:   Implementation of some key navigation code
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif


#define FUZZY_HIT_BORDER_WIDTH 7

//+----------------------------------------------------------------------------
//
//  Member:     MoveLineUpOrDown
//
//  Synopsis:   Given a line, will move one line up/down. If there are no lines in
//              the given direction, will find an appropriate line (if one exists)
//              in a containing txtsite.
//
//  Arguments:  [iDir]           : The dirn we are moving in
//              [rp]             : The line to navigate from
//              [xCaret]         : The desired x position of the caret
//              [pcp]            : The New cp position after line up done
//              [pfCaretNotAtBOL]: Is the caret at BOL?
//              [pfAtLogicalBOL] : Is the caret at the logical BOL?
//
//  Returns:    The txtsite where the new cp resides. Could be the same txt site.
//
//
//  HACKHACK:   Since we are using global coord. system, we need a paramter to
//              signal whether or not we are in vertical layout
//
//-----------------------------------------------------------------------------
CFlowLayout *
CDisplay::MoveLineUpOrDown(NAVIGATE_DIRECTION iDir, BOOL fVertical, CLinePtr& rp, POINT ptCaret, LONG *pcp,
                           BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    CFlowLayout *pFlowLayout = NULL;  // The new txtsite we navigate to
    CPoint       ptGlobal;                  // The point to navigate to
    CFlowLayout *pFlowLayoutThis = GetFlowLayout();

    // Setup the desired x position in global co-ordinate system.
    ptGlobal.x = ptCaret.x;
    ptGlobal.y = ptCaret.y;
   
    if (    (   iDir == NAVIGATE_UP
            &&  !IsTopLine(rp))
        ||  (   iDir == NAVIGATE_DOWN
            &&  !IsBottomLine(rp)))
    {
        CRect   rc;
        CPoint  ptContent(ptGlobal);
        
        // We need to convert pt to client coordinate system so that line from pos can use it
        pFlowLayoutThis->TransformPoint(&ptContent, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);

        ptContent.x = max(0l, ptContent.x);
        
        // Find the Y position of the line geographically before/after us
        ptContent.y = YposFromLine(NULL, rp, NULL);
        if (iDir == NAVIGATE_UP)
        {
            ptContent.y += rp->GetYLineTop(rp->oi());
            ptContent.y--;
        }
        else
            ptContent.y += rp->GetYLineBottom(rp->oi());

        // Get the rectangle of this CDisplay in block coords.
        GetFlowLayout()->GetClientRect(&rc);
        // Move the rectangle to the position of ptContent, the intersection of this rectangle with the original
        // ClientRect will be the search area for text.
        rc.MoveTo(ptContent.x, ptContent.y);

        // Find that line
        rp = LineFromPos(rc, (LFP_ZORDERSEARCH | LFP_IGNOREALIGNED | LFP_IGNORERELATIVE));
                   
        // Remember that NavigateToLine requires global coords. So transalte all of this
        // back to global coords
        ptGlobal = ptContent;
        pFlowLayoutThis->TransformPoint(&ptGlobal, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);

        if (rp >= 0)
        {
            // The line we want to navigate is found. Now navigate
            // to that line
            pFlowLayout = NavigateToLine(iDir, rp, ptGlobal, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
        }
    }
    else
    {
        CRect rcBound;
        pFlowLayoutThis->GetRect( &rcBound, COORDSYS_GLOBAL);
        if (fVertical)
        {
            ptGlobal.x = iDir == NAVIGATE_UP ? rcBound.right : rcBound.left;
        }
        else
        {
            ptGlobal.y = iDir == NAVIGATE_UP ? rcBound.top : rcBound.bottom;
        }
    }

    if (!pFlowLayout)
    {
        pFlowLayout = pFlowLayoutThis->GetNextFlowLayout(iDir, ptGlobal, NULL, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
    }

    // Return the flowlayout we ended up in
    return pFlowLayout;
}

//+----------------------------------------------------------------------------
//
//  Member:     NavigateToLine
//
//  Synopsis:   Given a line, we will first check if it has any nested sites
//              where a caret could live. If not, then we will place the caret
//              at the desired X position.
//
//  Arguments:  [iDir]           : The dirn we are moving in
//              [rp]             : The line to navigate to
//              [pt]             : The desired position of the caret (COORDSYS_GLOBAL)
//              [pcp]            : The New cp position after line up done
//              [pfCaretNotAtBOL]: Is the caret at BOL?
//              [pfAtLogicalBOL] : Is the caret at logical BOL?
//
//  Returns:    The txtsite where the new cp resides. Could be the same txt site.
//
//-----------------------------------------------------------------------------
CFlowLayout *
CDisplay::NavigateToLine(NAVIGATE_DIRECTION iDir, CLinePtr& rp, POINT pt, LONG *pcp, BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    CElement    *pElementFL  = GetFlowLayoutElement();
    CFlowLayout *pFlowLayout = NULL;            // The new flowlayout we want to navigate to
    CTreeNode   *pNodeLayout;                   // The layout element (if any) within the line
    CTreeNode   *pNodeElem = NULL;
    CLayout     *pLayout;

    // Find the site in the beneath it (if it exists).
    if (LineCount() != 0 && rp->_fHasNestedRunOwner)
    {
        HTC htc; // The hit test code
        CMessage msg;

        msg.pt = pt;

        if (iDir == NAVIGATE_UP)
        {
            //
            // HACK HACK HACK (SujalP + JohnBed)
            //
            // Get over the fuzzy hit test problem of it having a 7px border
            //
            msg.pt.y -= FUZZY_HIT_BORDER_WIDTH;
        }
        else
        {
            msg.pt.y += rp->GetYTop(rp->oi());
        }
        
        // Find out the site which was within this line
        htc = GetFlowLayout()->Doc()->HitTestPoint(&msg, &pNodeElem,
                                 HT_IGNORESCROLL | HT_VIRTUALHITTEST | HT_DONTIGNOREBEFOREAFTER);
        Assert (HTC_NO != htc);

        //
        // HACK HACK PREVENT CRASH TILL VIRTUAL HIT-TESTING IS BACK ON ITS FEET!
        //
        if (HTC_NO == htc)
            return NULL;
        
        if( !pNodeElem)
            return NULL;
        
        if (pNodeElem->Element()->HasMasterPtr())
        {
            Assert(pNodeElem->Element()->HasMasterPtr());
            pNodeElem = pNodeElem->Element()->GetMasterPtr()->GetFirstBranch();
            Assert(pNodeElem);
        }
            
        pLayout = pNodeElem->GetUpdatedNearestLayout();

        //  NOTE:  (GregLett, AshrafM) 
        //  Editing expects us to return the position just outside this site (DIV, &c...) unless
        //  the site is a table, in which case we need to return the character just inside the
        //  cell.  As their code is updated, this needs to be changed.
        if (!   (pLayout->TestLayoutDescFlag(LAYOUTDESC_TABLECELL)
            ||  pLayout->TestLayoutDescFlag(LAYOUTDESC_TABLELAYOUT))  )
        {
            pLayout = GetFlowLayout();
        }

        if(!pLayout)
            return NULL;

        pNodeLayout = pLayout->GetFirstBranch();
    }
    else
    {
        pLayout = GetFlowLayout();
        pNodeLayout = pElementFL->GetFirstBranch();
    }

    Assert(pLayout);

    // If a site other than the site containing this line is found AND it
    // belongs to the same ped as this, then that is the site we want to
    // navigate to.
    if (DifferentScope(pNodeLayout, pElementFL) &&
        pNodeLayout->GetContainer() == pElementFL->GetFirstBranch()->GetContainer() )
    {
        // Be sure that the point is *within* that site's *client* rect
        pLayout->RestrictPointToClientRect(&pt);
        // And find out the nearest flowlayout within that layout.
        pFlowLayout = pLayout->GetFlowLayoutAtPoint(pt);
    }

    if(!pFlowLayout)
        pFlowLayout = GetFlowLayout();

    if (pFlowLayout != GetFlowLayout())
    {
        pFlowLayout = pFlowLayout->GetPositionInFlowLayout(iDir, pt, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
    }
    else
    {
        // There are no nested txtsites in this line. So lets position ourselves
        // in the correct position and return ourself as the text site.
        CLinePtr   rpNew(this);     // The line we end up in.
        TCHAR      ch;
        CTxtPtr    tp(GetMarkup());
        LONG       cchPreChars = 0;

        // Found the txtsite, so lets get the cp
        *pcp = CpFromPointReally(pt, &rpNew, NULL, CFP_ALLOWEOL, NULL, &cchPreChars);
        if (*pcp == -1)
            return NULL;

        // In any line, we donot want to end up after a line/block/textsite break
        // characters. Be sure of that ... however, also be careful to stay in
        // the same line.
        tp.SetCp(*pcp);
        ch = tp.GetPrevChar();
        while( rpNew.GetIch() && IsASCIIEOP( ch ) )
        {
            if (!tp.AdvanceCp(-1))
                break;
            ch = tp.GetPrevChar();
            rpNew.AdvanceCp(-1);
        }

        // Finally got our cp
        *pcp = tp.GetCp();

        // and the start of BOL'ness
        *pfCaretNotAtBOL = rpNew.GetIch() != 0;

        // are we at the logical BOL
        *pfAtLogicalBOL = rpNew.GetIch() <= cchPreChars;
    }

    return pFlowLayout;
}

//+----------------------------------------------------------------------------
//
//  Member:     IsTopLine
//
//  Synopsis:   Given a line, check if it is geographically the top line
//
//  Arguments:  [rp]: The line to check
//
//-----------------------------------------------------------------------------
BOOL
CDisplay::IsTopLine(CLinePtr& rp)
{
    CLinePtr rpTravel(rp);

    while(rpTravel.PrevLine(TRUE, TRUE))
    {
        // If there is a line before this one which forces a new line,
        // then this line is not the top one.
        if (rpTravel->_fForceNewLine)
            return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     IsBottomLine
//
//  Synopsis:   Given a line, check if it is geographically the bototm line
//
//  Arguments:  [rp]: The line to check
//
//
//  Legend:
//
//  ====== the line pointed to by rp
//  ------ the lines after it
//  -----> indicates that the line forces a new line
//
//  This function returns TRUE in all these cases:
//
//  1) ======== ---------->
//  2) ======== ----------
//  3) ========>
//  4) ========
//
//  And it returns FALSE in all these cases
//  5) ======== ---------->
//     --------
//  6) ======== ---------->
//     -------->
//  7) ========>
//     --------
//-----------------------------------------------------------------------------
BOOL
CDisplay::IsBottomLine(CLinePtr& rp)
{
    CLinePtr rpTravel(rp);          // Line ptr used to traverse the line array
    LONG     cNewLinesSeen = 0;     // How many lines having force new line seen?
    BOOL     fLastWasForceNewLine;  // The last line we saw was a force-new-line line

    do
    {
        // Account for this line
        cNewLinesSeen += rpTravel->_fForceNewLine ? 1 : 0;
        fLastWasForceNewLine = !!rpTravel->_fForceNewLine;

        // We cannot decide whether we are the last line when we just
        // see one line having the _fForceNewLine bit set. This would
        // break case 1 and 3 above. If we see atleast 2 lines with
        // this bit then we are sure that this line is not the last line
        // and can return FALSE (case 6)
        if (cNewLinesSeen == 2)
            return FALSE;

    } while(rpTravel.NextLine(TRUE, TRUE));

    // If we have seen only one new line and the last line we saw
    // did not force a new line then we have case 5/7, where we have
    // to return FALSE.
    if (cNewLinesSeen && !fLastWasForceNewLine)
        return FALSE;

    // case     cNewLinesSeen  fLastWasForceNewLine
    // 1        1              TRUE
    // 2        0              FALSE
    // 3        1              TRUE
    // 4        0              TRUE
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\fontlnk.cxx ===
//+---------------------------------------------------------------------
//
//   File:      fontlnk.cxx
//
//  Contents:   Code for fontlinking.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#ifndef X_MULTILANG_HXX_
#define X_MULTILANG_HXX_
#include "multilang.hxx"
#endif

MtDefine(FontLinkTextOut_aryLinkFonts_pv, Locals, "FontLinkTextOut aryLinkFonts::_pv")
MtDefine(FontLinkTextOut_aryStringCopy_pv, Locals, "FontLinkTextOut aryStringCopy::_pv")

#pragma warning(disable:4706) /* assignment within conditional expression */

#define FLTO_CACHE_SIZE 32  // Number of font pointers in FontLinkTextOut stack cache
                            //     max possible, only 32 distinct script bits
#define CHUNKSIZE 32

//+----------------------------------------------------------------------------
//
//  Function:   GetLangBits
//
//  Synopsis:   ...
//
//-----------------------------------------------------------------------------

DWORD
GetLangBits(
    IMLangFontLink * pMLangFontLink,
    WCHAR wc )
{
    DWORD dwCodePages = 0;

    if (wc < 128 || wc == WCH_NBSP)
    {
        dwCodePages = SBITS_ALLLANGS;
    }
    else if (pMLangFontLink)
    {
#ifndef NO_UTF16
        if (!IsSurrogateChar(wc))
        {
            IGNORE_HR(pMLangFontLink->GetCharCodePages(wc, &dwCodePages));
        }
        else
        {
            if (IsLowSurrogateChar(wc))
            {
                dwCodePages = SBITS_SURROGATE_A | SBITS_SURROGATE_B;
            }
            else
            {
                const CHAR_CLASS cc = CharClassFromCh(wc);

                Assert( cc == NHS_ || cc == WHT_ );
                
                dwCodePages = (cc == NHS_) ? SBITS_SURROGATE_A : SBITS_SURROGATE_B;
            }
        }
#else
        IGNORE_HR(pMLangFontLink->GetCharCodePages(wc, &dwCodePages));
#endif
    }

    return dwCodePages;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFontScriptBits
//
//  Synopsis:   ...
//
//-----------------------------------------------------------------------------

DWORD 
GetFontScriptBits(
    XHDC hDC, 
    const TCHAR * szFaceName, 
    LOGFONT * plf )
{
#ifndef WINCE
    HRESULT hr = E_FAIL;
    DWORD dwCodePages = 0;

    if ( 0 == StrCmpC( szFaceName, _T("MS Sans Serif") ) &&
         PRIMARYLANGID(LANGIDFROMLCID(g_lcidUserDefault)) == LANG_ENGLISH)
    {
        // NB (cthrash) MS Sans Serif is a really evil font - in spite of the
        // fact that it contains virtually none of the Latin-1 characters,
        // it claims it supports Latin-1.  Unfortunately, MS Sans Serif is
        // an extremely common font for use as DEFUAULT_GUI_FONT.  This means
        // that intrinsic controls will often use MS Sans Serif.  By setting
        // our lang bits to SBITS_ASCII, we make certain we always font link
        // for non-ASCII characters.  We should never fontlink for ASCII chars.
        // See comment in _fontlnk.h.

        dwCodePages = SBITS_ASCII;
        goto Cleanup;
    }
    else
    {
        IMLangFontLink * pMLangFontLink = mlang().GetMLangFontLink();
        if (pMLangFontLink)
        {
            LOGFONT lf;
            HFONT hFont;

            lf = *plf;
            Assert(_tcsclen(szFaceName) < LF_FACESIZE);
            ::_tcsncpy(lf.lfFaceName, szFaceName, ARRAY_SIZE(lf.lfFaceName));

            hFont = ::CreateFontIndirect(&lf);
            if (hFont)
            {
                hr = pMLangFontLink->GetFontCodePages(hDC.GetFontInfoDC(), hFont, &dwCodePages);
                Verify(::DeleteObject(hFont));
            }
            else
            {
                hr = E_FAIL; // Out of GDI resource
            }
        }
    }

    if (FAILED(hr) || !dwCodePages)
    {
        CHARSETINFO csi;

        if (::TranslateCharsetInfo((LPDWORD)(LONG_PTR)MAKELONG(plf->lfCharSet, 0), &csi, TCI_SRCCHARSET))
        {
            dwCodePages = csi.fs.fsCsb[0];
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL; // Invalid plf->lfCharSet
        }
    }

    // If dwLangBits is zero, this means we would ALWAYS fontlink.  If
    // it is in fact zero, we can't really know what the font supports.
    // Here we set all the bits on, so as to NEVER fontlink.

    if (dwCodePages == 0 || FAILED(hr))
    {
        dwCodePages = SBITS_ALLLANGS;
    }

    // NB (cthrash) We've decouple the ASCII portion of Latin-1 so that
    // we may more efficiently handle bad fonts which claim to support
    // Latin-1 when only really supporting ASCII.

    dwCodePages |= SBITS_ASCII;

Cleanup:

    return dwCodePages;
#else
    return 0;
#endif // WINCE
}

//+----------------------------------------------------------------------------
//
//  Function:   CharSetFromLangBits
//
//  Synopsis:   Compute a valid GDI charset from the language bits
//
//-----------------------------------------------------------------------------

static const BYTE s_abCharSetFromLangBit[32] =
{
    SYMBOL_CHARSET,      // FS_SYMBOL               0x80000000L
    DEFAULT_CHARSET,     //                         0x40000000L
    DEFAULT_CHARSET,     //                         0x20000000L
    DEFAULT_CHARSET,     //                         0x10000000L
    DEFAULT_CHARSET,     //                         0x08000000L
    DEFAULT_CHARSET,     //                         0x04000000L
    DEFAULT_CHARSET,     //                         0x02000000L
    DEFAULT_CHARSET,     //                         0x01000000L
    DEFAULT_CHARSET,     //                         0x00800000L
    DEFAULT_CHARSET,     //                         0x00400000L
    JOHAB_CHARSET,       // FS_JOHAB                0x00200000L
    CHINESEBIG5_CHARSET, // FS_CHINESETRAD          0x00100000L
    HANGEUL_CHARSET,     // FS_WANSUNG              0x00080000L
    GB2312_CHARSET,      // FS_CHINESESIMP          0x00040000L
    SHIFTJIS_CHARSET,    // FS_JISJAPAN             0x00020000L
    THAI_CHARSET,        // FS_THAI                 0x00010000L
    DEFAULT_CHARSET,     //                         0x00008000L
    DEFAULT_CHARSET,     //                         0x00004000L
    DEFAULT_CHARSET,     //                         0x00002000L
    DEFAULT_CHARSET,     //                         0x00001000L
    DEFAULT_CHARSET,     //                         0x00000800L
    DEFAULT_CHARSET,     //                         0x00000400L
    DEFAULT_CHARSET,     //                         0x00000200L
    VIETNAMESE_CHARSET,  // FS_VIETNAMESE           0x00000100L
    BALTIC_CHARSET,      // FS_BALTIC               0x00000080L
    ARABIC_CHARSET,      // FS_ARABIC               0x00000040L
    HEBREW_CHARSET,      // FS_HEBREW               0x00000020L
    TURKISH_CHARSET,     // FS_TURKISH              0x00000010L
    GREEK_CHARSET,       // FS_GREEK                0x00000008L
    RUSSIAN_CHARSET,     // FS_CYRILLIC             0x00000004L
    EASTEUROPE_CHARSET,  // FS_LATIN2               0x00000002L
    ANSI_CHARSET         // FS_LATIN1               0x00000001L
};

BYTE
CharSetFromLangBits( DWORD dwLangBits )
{
    for (int i=32; i--; dwLangBits >>= 1)
    {
        if (dwLangBits & 1)
        {
            return s_abCharSetFromLangBit[i];
        }
    }

    return DEFAULT_CHARSET;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFontLinkFontName
//
//  Synopsis:   An appropriate facename for the script/lang input set in pcf
//
//-----------------------------------------------------------------------------

BOOL
GetFontLinkFontName(
    IMLangFontLink *pMLangFontLink, // IN
    XHDC            hdc,            // IN
    CDoc *          pDoc,           // IN                    
    DWORD           dwScriptBits,   // IN
    LCID            lcidLang,       // IN
    const LOGFONT * lplf,           // IN
    CMarkup *       pMarkup,        // IN
    CCharFormat *   pcf )           // OUT
{
    HFONT hSrcFont = ::CreateFontIndirect(lplf);
    HFONT hDestFont = NULL;
    LOGFONT lfDestFont;
    BOOL fNewlyFetchedFromRegistry = FALSE; // for surrogates

#ifndef NO_UTF16
    if (dwScriptBits & (SBITS_SURROGATE_A | SBITS_SURROGATE_B))
    {
        fNewlyFetchedFromRegistry = SelectScriptAppropriateFont( (dwScriptBits & SBITS_SURROGATE_A)
                                                                 ? sidSurrogateA
                                                                 : sidSurrogateB,
                                                                 DEFAULT_CHARSET,
                                                                 pDoc,
                                                                 pMarkup,
                                                                 pcf );

        goto Cleanup;
    }
    else
#endif
    if (hSrcFont && pMLangFontLink)
    {
        TCHAR pszCodePage[4+1];
        DWORD dwCodePages;

        if (::GetLocaleInfo(lcidLang, LOCALE_IDEFAULTANSICODEPAGE, pszCodePage, ARRAY_SIZE(pszCodePage)) &&
            SUCCEEDED(pMLangFontLink->CodePageToCodePages(StrToInt(pszCodePage), &dwCodePages)))
        {
            dwCodePages &= dwScriptBits;
            if (dwCodePages &&
                dwCodePages != dwScriptBits &&
                FAILED(pMLangFontLink->MapFont(hdc.GetFontInfoDC(), dwCodePages, hSrcFont, &hDestFont)))
            {
                hDestFont = NULL;
            }
        }

        if (!hDestFont &&
            FAILED(pMLangFontLink->MapFont(hdc.GetFontInfoDC(), dwScriptBits, hSrcFont, &hDestFont)))
        {
            hDestFont = NULL;
        }

        if (hSrcFont)
            ::DeleteObject(hSrcFont);

        if (hDestFont)
        {
            ::GetObject(hDestFont, sizeof(lfDestFont), &lfDestFont);
            pMLangFontLink->ReleaseFont(hDestFont);

            lplf = &lfDestFont;
        }
    }

    pcf->SetFaceName(lplf->lfFaceName);

    // NOTE: (cthrash) MLANG suffers from the same GDI bug that Trident does, namely
    // it calls EnumFontFamilies instead of EnumFontFamiliesEx and thus gets
    // inaccurate GDI charset information.  For now, we will assume all charset values
    // other than 0 (ANSI_CHARSET) to be valid.  This is so we don't pick the wrong
    // charset in the unified-Han scenario.  Note that WinNT has no issue with
    // the the GDI charset being DEFAULT_CHARSET

    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        pcf->_bCharSet = DEFAULT_CHARSET;
    }
    else if (lplf->lfCharSet != ANSI_CHARSET)
    {
        pcf->_bCharSet = lplf->lfCharSet;
    }
    else
    {
        pcf->_bCharSet = CharSetFromLangBits( dwScriptBits );
    }

Cleanup:

    return fNewlyFetchedFromRegistry;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFont
//
//  Synopsis:   Returns a CCcs * with langbits matching ch. 
//              Helper function for FontLinkTextOut.
//
//-----------------------------------------------------------------------------

CCcs *
GetFont(
    IMLangFontLink * pMLangFontLink,
    TCHAR ch,
    XHDC hDC,
    CDocInfo * pdci,
    const CCharFormat *pCF,
    CCcs * pccsDefault,
    CStackDataAry<CCcs*, FLTO_CACHE_SIZE> * paryLinkFonts )
{
    CCharFormat cf;
    DWORD dwLangBits;
    CCcs *pccs;
    CCcs **ppccs;
    int i;
    const CBaseCcs *pBaseCcsDefault = pccsDefault->GetBaseCcs();

    // TODO: (cthrash, track bug 112152) Temporary hack, remove it.

    pccsDefault->EnsureLangBits();

    // check the default font first
    if (ch <= 0x7f || // perf hack: all fonts have glyphs for unicode 0 - 0x7f
        (dwLangBits = GetLangBits(pMLangFontLink, ch)) == 0 ||
        (dwLangBits & pBaseCcsDefault->_dwLangBits))
    {
        return pccsDefault;
    }

    // Search for a match in the cache we build up.
    // There's some perf improvement here because we avoid extra calls
    // to GetFontLinkFontName, but the real reason we do this is to
    // ensure the same character is always rendered with a consistent
    // glyph.
    for (i=0; i < paryLinkFonts->Size(); i++)
    {
        if (dwLangBits & (*paryLinkFonts)[i]->GetBaseCcs()->_dwLangBits)
        {
            break;
        }
    }

    if (i < paryLinkFonts->Size())
    {
        return (*paryLinkFonts)[i];
    }

    // no match, grab a new font from the global cache

    // First allocate mem for the new CCcs object
    if ((pccs = new CCcs()) == NULL)
    {
        return pccsDefault;
    }

    cf = *pCF;
    GetFontLinkFontName(pMLangFontLink, hDC, pdci->_pDoc, dwLangBits, cf._lcid, &pBaseCcsDefault->_lf, pdci->_pMarkup, &cf);
    cf._bCrcFont = cf.ComputeFontCrc();
    if (!fc().GetFontLinkCcs(pccs, hDC, pdci, pccsDefault, &cf))
    {
        delete pccs;
        return pccsDefault;
    }
    
    pccs->EnsureLangBits();

#ifndef NO_UTF16
    if (dwLangBits & (SBITS_SURROGATE_A | SBITS_SURROGATE_B))
    {
        // EnsureLangBits isn't going to set the SBITS_SURROGATE_A or _B flags.
        // Force the bits set, so that the next char can be rendered in the same font.

        pccs->MergeLangBits(dwLangBits);
    }
#endif

    if  ((pccs->GetBaseCcs()->_dwLangBits & dwLangBits) == 0 ||
         (ppccs = paryLinkFonts->Append()) == NULL)
    {
        pccs->Release();
        delete pccs;
        return pccsDefault;
    }

    *ppccs = pccs;

    return pccs;
}

//+----------------------------------------------------------------------------
//
//  Function:   FontLinkTextOut
//
//  Synopsis:   ExtTextOutW functionality with font linking thrown in.
//
//  uMode is one of
//      FLTO_BOTH           render the string and return its text extent
//      FLTO_TEXTOUTONLY    render the string, return value is pos/neg only
//      FLTO_TEXTEXTONLY    just return the text textent, render nothing
//      
//  Return value is negative on error, otherwise the text extent
//  or in any case a non-negative number.
//-----------------------------------------------------------------------------

int
FontLinkTextOut (
    XHDC hDC,
    int x, int y,
    UINT fuOptions,
    const GDIRECT * prc,
    LPCTSTR pString,
    UINT cch,
    CDocInfo * pdci,
    const CCharFormat * pCF,
    UINT uMode )
{
    CStackDataAry<CCcs*, FLTO_CACHE_SIZE> aryLinkFonts(Mt(FontLinkTextOut_aryLinkFonts_pv));
    CCcs *pccsRun;
    CCcs *pccsNextRun;
    CCcs ccsDefault;
    LPCTSTR pPastRun;
    long lCharWidth = 0;
    FONTIDX hOldFont = HFONT_INVALID;
    int iDefBaseLinePlusY;
    int xin;
    int iDx;
    int i;
    CStackDataAry <TCHAR, CHUNKSIZE> aryStringCopy(Mt(FontLinkTextOut_aryStringCopy_pv));
    CODEPAGE codepage = pdci->_pMarkup->GetFamilyCodePage();
    BOOL fBidiCodepage = (codepage == CP_1256 || codepage == CP_1255);

    if (pString == NULL || cch <= 0)
    {
        return (cch == 0) ? 0 : -1;
    }

    if (!fc().GetCcs(&ccsDefault, hDC, pdci, pCF))
        return -1;

    ccsDefault.EnsureLangBits();

    Assert(ccsDefault.GetBaseCcs() != NULL);
    if (ccsDefault.GetBaseCcs()->_dwLangBits == 0)
    {
        ccsDefault.Release();
        return -1;
    }

    xin = x;
    iDefBaseLinePlusY = ccsDefault.GetBaseCcs()->_yHeight -
                        ccsDefault.GetBaseCcs()->_yDescent + y;

    //
    // Get IMultiLanguage::IMLangFontLink
    //
    IMLangFontLink * pMLangFontLink = mlang().GetMLangFontLink();

    // init for loop
    pPastRun = pString;
    pccsNextRun = GetFont(pMLangFontLink, *pString, hDC, pdci, pCF, &ccsDefault, &aryLinkFonts);

    do
    {
        // set the font for this run
        hOldFont = pccsNextRun->PushFont(hDC);

        // skip first char in run -- already checked its font
        pPastRun++;
        cch--;
        pccsRun = pccsNextRun;

        // get the length of the run and next font
        while (cch)
        {
            // May need to do the *ugly* NBSP hack.
            if (*pPastRun == WCH_NBSP)
            {
                if (ccsDefault.ConvertNBSPs(hDC, pdci->_pDoc))
                {
                    LONG cchDelta = pPastRun - pString;
                    LONG cchNew = cch + cchDelta;

                    if (aryStringCopy.Grow( cchNew ) == S_OK)
                    {
                        TCHAR * pNewString = aryStringCopy;
                        const TCHAR * pSrc = pString;
                        TCHAR * pDst = pNewString;

                        while (cchNew--)
                        {
                            TCHAR ch = *pSrc++;
                            *pDst++ = (ch == WCH_NBSP) ? _T(' ') : ch;
                        }

                        pString = pNewString;
                        pPastRun = pString + cchDelta;
                    }
                }
            }

            if(!fBidiCodepage)
            {
                pccsNextRun = GetFont(pMLangFontLink, *pPastRun, hDC, pdci, pCF, &ccsDefault, &aryLinkFonts);
            }
            else
            {
                // If we have a bidi codepage (Arabic or Hebrew) we want to try the existing font for the character first.
                // This will help us not to break in cases where we have RTL text in a LTR control - Uniscribe
                // correctly handles shaping for us in LSUniscribeTextOut if an entire run of mixed text
                // is fed in.
                pccsNextRun = GetFont(pMLangFontLink, *pPastRun, hDC, pdci, pCF, pccsRun, &aryLinkFonts);
            }

            if (pccsRun->GetBaseCcs() != pccsNextRun->GetBaseCcs())
                break;

            cch--;
            pPastRun++;
        }

        // output this run
        iDx = 0;
        if (uMode != FLTO_TEXTEXTONLY)
        {
            int yRun = iDefBaseLinePlusY - (pccsRun->GetBaseCcs()->_yHeight - pccsRun->GetBaseCcs()->_yDescent);

            if (*pString != WCH_NBSP)
            {
                VanillaTextOut(pccsRun, hDC, x, yRun, fuOptions, prc, pString, pPastRun - pString, codepage, &iDx);
            }
            else
            {
                int cch = pPastRun - pString - 1;

                VanillaTextOut(pccsRun, hDC, x, yRun, fuOptions, prc, L" ", 1, codepage, &iDx);

                if (cch)
                {
                    int xT;
                    
                    pccsRun->Include(L' ', lCharWidth);
                    if (fuOptions & ETO_RTLREADING)
                        xT = x - lCharWidth;
                    else
                        xT = x + lCharWidth;

                    VanillaTextOut(pccsRun, hDC, xT, yRun, fuOptions, prc, pString + 1, cch, codepage, &iDx);
                }                    
            }
        }

        // Handle char widths for the final run only if caller wants text extent
        // or we need the text extent to handle underline/strikeout.
        if(iDx == 0)
        {
            if (cch || uMode != FLTO_TEXTOUTONLY || pCF->_fUnderline || pCF->_fStrikeOut)
            {
                int dx = 0;

                while (pString < pPastRun)
                {
                    pccsRun->Include(*pString, lCharWidth);
                    dx += lCharWidth;
                    pString++;
                }

                x += (fuOptions & ETO_RTLREADING) ? -dx : dx;
            }
        }
        else
        {
            if(fuOptions & ETO_RTLREADING)
                x -= iDx;
            else
                x += iDx;

            pString = pPastRun;
        }

        pccsRun->PopFont(hDC, hOldFont);

    } while (cch);

    if (uMode != FLTO_TEXTEXTONLY && (pCF->_fUnderline || pCF->_fStrikeOut))
    {
        HFONT hFont;
        LOGFONT lf;

        // Fonts from the global cache never have underline/strikeout attributes
        // because CRenderer draws its own underlines/strikeouts.  So allocate
        // an appropriate font here.
        // We do the underline/strikeout in one go to ensure consistency across
        // multiple runs and to work around a win95 gdi bug.
        // perf: could have the caller pass in the new HFONT, but the tradeoff
        // is generality and the risk of the font not matching.
        lf = ccsDefault.GetBaseCcs()->_lf;
        lf.lfUnderline = pCF->_fUnderline;
        lf.lfStrikeOut = pCF->_fStrikeOut;

        if ((hFont = CreateFontIndirect(&lf)) != 0)
        {
            DrawUnderlineStrikeOut(xin, y, 
                                   fuOptions & ETO_RTLREADING ? xin - x : x - xin, 
                                   hDC, hFont, prc);
            Verify(DeleteObject(hFont));
        }
    }

    ccsDefault.Release();

    for (i=0; i < aryLinkFonts.Size(); i++)
    {
        aryLinkFonts[i]->Release();
        delete aryLinkFonts[i];
    }

    return (fuOptions & ETO_RTLREADING ? xin - x : x - xin);
}

//+----------------------------------------------------------------------------
//
//  Function:   VanillaTextOut
//
//  Synopsis:   A wrapped ExtTextOutW, accounting for a win95 china bug.
//
//-----------------------------------------------------------------------------

void 
VanillaTextOut(
    CCcs * pccs,                    
    XHDC hdc,
    int x, int y,
    UINT fuOptions,
    const GDIRECT * prc,
    LPCTSTR pString,
    UINT cch,
    UINT uCodePage,
    int * piDx )
{
    // COMPLEX TEXT.  ExtTextOutW does not work properly on foreign language versions
    //                of Win95. Additionally, we want to send all glyphable text through
    //                Uniscribe for shaping and output.

    BOOL fGlyph = FALSE;
    BOOL fEuro  = FALSE;
    BOOL fRTL   = FALSE;

    // There is an assumption that *piDx is 0 coming in. Really, we should move
    // the measurement code from FontLinkTextOut() down here and use it
    // whenever we don't go through LSUniscribeTextOut(). Then this wouldn't
    // matter.
    Assert(piDx == NULL || *piDx == 0);

    fRTL = !!(fuOptions & ETO_RTLREADING);

    if(!fRTL)
    {
        for(UINT i = 0; i < cch; i++)
        {
            WCHAR ch = pString[i];
            if(ch >= 0x300 && IsGlyphableChar(ch))
            {
                fGlyph = TRUE;
                break;
            }
            else if (ch == WCH_EURO)
            {
                fEuro = TRUE;
                break;
            }
        }
    }


    // send complex text or text layed out right-to-left
    // to be drawn through Uniscribe
    if((fGlyph || fRTL) && !g_fExtTextOutGlyphCrash)
    {
        HRESULT hr;

        extern HRESULT LSUniscribeTextOut(const XHDC& hdc, 
                                       int iX, 
                                       int iY, 
                                       UINT uOptions, 
                                       CONST RECT *prc, 
                                       LPCTSTR pString, 
                                       UINT cch,
                                       int *piDx); 
 
        hr = LSUniscribeTextOut(hdc,
                                x, 
                                y,
                                fuOptions,
                                prc,
                                pString,
                                cch,
                                piDx);

        // if we failed, let the normal path be our fallback
        if(!hr)
            return;
    }

    if (    IsExtTextOutWBuggy(uCodePage)
        ||  (fEuro && g_fExtTextOutGlyphCrash))   // FE Win95 GDI fails when rendering Euro character
    {
        extern BOOL LSReExtTextOut( CCcs *, XHDC, int, int, UINT,
                                    CONST RECT *, const WCHAR *,
                                    long cbCount, CONST INT *lpDx,
                                    CONVERTMODE cm);

        LSReExtTextOut( pccs,
                        hdc,
                        x, y,
                        fuOptions,
                        prc,
                        pString,
                        cch,
                        NULL,
                        CM_MULTIBYTE );
    }
    else
    {
        ExtTextOutW(hdc,
                    x, y,
                    fuOptions,
                    prc,
                    pString,
                    cch,
                    NULL);
    }

    return;
}

//+----------------------------------------------------------------------------
//
//  Function:   DrawUnderlineStrikeOut
//
//  Synopsis:   Draws an underline/strikeout.  This is a workaround
//              for a win95 ExtTextOutW problems with underlines.
//
//-----------------------------------------------------------------------------

void 
DrawUnderlineStrikeOut(
    int x, int y, 
    int iLength, 
    XHDC hDC, 
    HFONT hFont, 
    const GDIRECT  *prc )
{
    int iOldBkMode;
    HFONT hOldFont;

    if ((iOldBkMode = SetBkMode(hDC, TRANSPARENT)) == 0)
    {
        return;
    }
    hOldFont = SelectFontEx(hDC, hFont);

    ExtTextOutA(hDC, x, y, 0, prc, " ", 1, &iLength);

    SelectFontEx(hDC, hOldFont);
    SetBkMode(hDC, iOldBkMode);

    return;
}

//+----------------------------------------------------------------------------
//
//  Function:   NeedsFontLinking
//
//  Synopsis:   Returns TRUE iff the supplied font does not contain
//              glyphs for the entire string.
//
//-----------------------------------------------------------------------------

BOOL 
NeedsFontLinking(
    XHDC hdc, 
    CCcs * pccs, 
    LPCTSTR pString, 
    int cch, 
    CDoc * pDoc )
{
    const CBaseCcs *pBaseCcs;
    IMLangFontLink * pMLangFontLink = NULL;
    
    if (pccs == NULL ||
        pccs->GetBaseCcs() == NULL ||
        pString == NULL ||
        cch <= 0)
    {
        return FALSE;
    }

    
    pBaseCcs = pccs->GetBaseCcs();
    pccs->EnsureLangBits();

    if (pBaseCcs->_dwLangBits == 0)
    {
        return FALSE;
    }

    const DWORD dwDefLangBits = pBaseCcs->_dwLangBits;

    for (; cch; cch--)
    {
        const TCHAR ch = *pString++;

        if (ch < 0x80)
        {
            continue; // perf hack: all fonts have glyphs for unicode 0 - 0x7f
        }
        else if (ch == WCH_NBSP)
        {
            if (pccs->ConvertNBSPs(hdc, pDoc))
            {
                break;
            }
        }
        else
        {
            if (!pMLangFontLink)
            {
                pMLangFontLink = mlang().GetMLangFontLink();
            }
                
            if (!(GetLangBits(pMLangFontLink, ch) & dwDefLangBits))
                break;
        }
    }

    return cch != 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   SelectScriptAppropriateFont
//
//  Synopsis:   Populates a CCharFormat element on the fly for fontlinking
//              with script-appropriate information.
//
//  Notes:      The incomoming SCRIPT_ID (sid) should already by Han ununified,
//              This means if any CJK disamguation is necessary, it should
//              have been done before calling this function.
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

const WCHAR * AlternateFontNameIfAvailable( const WCHAR * );

BOOL
SelectScriptAppropriateFont(
    SCRIPT_ID sid,          // IN
    BYTE bCharSet,          // IN
    CDoc * pDoc,            // IN
    CMarkup * pMarkup,      // IN
    CCharFormat * pcf )     // IN/OUT
{
    HRESULT hr;
    BOOL fNewlyFetched = FALSE;
    LONG latmFontFace;

    hr = THR( pDoc->UpdateFromRegistry() );
    if (hr)
        goto Cleanup;

    sid = RegistryAppropriateSidFromSid( sid );

    fNewlyFetched = ScriptAppropriateFaceNameAtom(sid, pDoc, pcf->_bPitchAndFamily & FIXED_PITCH, pcf, pMarkup, &latmFontFace );

    if (latmFontFace < 0)
        latmFontFace = 0;

    pcf->SetFaceNameAtom(latmFontFace);
    pcf->_bCharSet = bCharSet;
    pcf->_fNarrow  = IsNarrowCharSet( bCharSet );
    pcf->_bCrcFont = pcf->ComputeFontCrc();

Cleanup:

    return fNewlyFetched;
}

//+----------------------------------------------------------------------------
//
//  Function:   ScriptAppropriateFaceNameAtom
//
//  Synopsis:   For given script ID we get default font face atom (fixed or
//              variable pitch). Check also if we need @font.
//
//  Returns:    TRUE if fetched from registry.
//
//-----------------------------------------------------------------------------

BOOL
ScriptAppropriateFaceNameAtom(
    SCRIPT_ID sid,                  // IN
    CDoc * pDoc,                    // IN
    BOOL fFixed,                    // IN
    const CCharFormat * const pcf,  // IN
    CMarkup * pMarkup,              // IN
    LONG *platmFontFace )           // OUT
{
    LONG latmFontFace = fFixed
                        ? pDoc->_pOptionSettings->alatmFixedPitchFonts[sid]
                        : pDoc->_pOptionSettings->alatmProporitionalFonts[sid];
    const BOOL fFetch = latmFontFace == -1;

    if (fFetch)
    {
        CODEPAGESETTINGS CS;

        CS.SetDefaults(pMarkup->GetFamilyCodePage(), pDoc->_pOptionSettings->sBaselineFontDefault );

        pDoc->_pOptionSettings->ReadCodepageSettingsFromRegistry( &CS, 0, sid );

        pDoc->_pOptionSettings->alatmFixedPitchFonts[sid] = CS.latmFixedFontFace;
        pDoc->_pOptionSettings->alatmProporitionalFonts[sid] = CS.latmPropFontFace;

        latmFontFace = fFixed
                       ? CS.latmFixedFontFace
                       : CS.latmPropFontFace;
    }

    if (pcf->NeedAtFont() && !pcf->_fExplicitAtFont)
    {
        LONG latmAtFontFace = fFixed
                              ? pDoc->_pOptionSettings->alatmFixedPitchAtFonts[sid]
                              : pDoc->_pOptionSettings->alatmProporitionalAtFonts[sid];

        if (latmAtFontFace == -1)
        {
            Assert(pDoc->_pOptionSettings->alatmFixedPitchFonts[sid] != -1);
            Assert(pDoc->_pOptionSettings->alatmProporitionalFonts[sid] != -1);

            const TCHAR * szFaceNameOriginal = fc().GetFaceNameFromAtom(latmFontFace);
            if (szFaceNameOriginal && (szFaceNameOriginal[0] != _T('@')))
            {
                TCHAR szFaceName[LF_FACESIZE];
                szFaceName[0] = _T('@');
                _tcsncpy(szFaceName + 1, szFaceNameOriginal, LF_FACESIZE - 2);
                szFaceName[LF_FACESIZE - 1] = 0;

                CCharFormat cf(*pcf);

                ApplyFontFace(&cf, szFaceName, AFF_ATFONTPASS, pDoc, pMarkup);
                latmAtFontFace = cf._latmFaceName;
            }
            if (fFixed)
                pDoc->_pOptionSettings->alatmFixedPitchAtFonts[sid] = latmAtFontFace;
            else
                pDoc->_pOptionSettings->alatmProporitionalAtFonts[sid] = latmAtFontFace;
        }
        latmFontFace = latmAtFontFace;
    }

    *platmFontFace = latmFontFace;
    
    return fFetch;
}

//-----------------------------------------------------------------------------
//
//  Function:   ShouldSwitchFontsForPUA
//
//  Synopsis:   Decide if we should switch fonts for Unicode Private Use Area
//              characters.  This is a heuristic approach.
//
//  Returns:    BOOL    - true if we should switch fonts
//              *psid   - the SCRIPT_ID to which we should switch
//
//-----------------------------------------------------------------------------

BOOL
ShouldSwitchFontsForPUA(
    XHDC hdc,                   // IN
    UINT uiFamilyCodePage,      // IN
    const CBaseCcs * pBaseCcs,  // IN
    const CCharFormat * pcf,    // IN
    SCRIPT_ID * psid )          // OUT
{
    BOOL fShouldSwitch;
    
    if (pcf->_fExplicitFace)
    {
        // Author specified a face name -- don't switch fonts on them.

        fShouldSwitch = FALSE;
    }
    else
    {
        SCRIPT_ID sid = sidDefault;

        if (pcf->_lcid)
        {
            // Author specified a LANG attribute -- see if the current font
            // covers this script

            const LANGID langid = LANGIDFROMLCID(pcf->_lcid);
            sid = ScriptIDFromLangID(langid);
        }
        else
        {
            // Check the document codepage, then the system codepage

            switch (uiFamilyCodePage)
            {
                case CP_CHN_GB:     sid = sidHan;       break;
                case CP_KOR_5601:   sid = sidHangul;    break;
                case CP_TWN:        sid = sidBopomofo;  break;
                case CP_JPN_SJ:     sid = sidKana;      break;
                default:
                {
                    switch (g_cpDefault)
                    {
                        case CP_CHN_GB:     sid = sidHan;       break;
                        case CP_KOR_5601:   sid = sidHangul;    break;
                        case CP_TWN:        sid = sidBopomofo;  break;
                        case CP_JPN_SJ:     sid = sidKana;      break;
                        default:            sid = sidDefault;   break;                        
                    }
                }
            }
        }

        if (sid != sidDefault)
        {
            SCRIPT_IDS sidsFace = fc().EnsureScriptIDsForFont(hdc, pBaseCcs, FC_SIDS_USEMLANG);
            fShouldSwitch = (sidsFace & ScriptBit(sid)) == sidsNotSet;
            *psid = sid;
        }
        else
        {
            fShouldSwitch = FALSE;
        }
    }

    return fShouldSwitch;            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\line.cxx ===
/*
 *  LINE.C
 *
 *  Purpose:
 *      CLine* classes
 *
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X__LINE_H_
#define X__LINE_H_
#include "_line.h"
#endif

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

MtDefine(CLinePtr, Tree, "CLinePtr")
MtDefine(CLine, Tree, "CLine")

ExternTag(tagAssertOnHittestingWithLS);

/*
 *  CLineFull::CchFromXPos
 *
 *  Purpose:
 *      Computes cp corresponding to a x position in a line
 *
 *  Arguments:
 *      me                  measurer position at start of line
 *      x                   xpos to search for
 *      y                   ypos to search for
 *      pdx                 returns adjustment to x at returned cp
 *      fExactFit           Do we need to fit exactly?
 *      pyHeightRubyBase    Support for ruby
 *
 *      HACKHACK (t-ramar): This function calls DiscardLine() at the 
 *              end, but we would like to keep information about Ruby Base
 *              heights around for hit testing purposes.  Thus, there is an
 *              optional parameter:
 *                  ppRubyInfo (out):  is the information pertaining to
 *                                     ruby object that contains the cp
 *                                     (NULL by default)
 *              It's also important to note that this value is ignored if
 *              line flag FLAG_HAS_RUBY is not set.  In this case the 
 *              value pointed to by ppRubyInfo will remain unchanged.
 *  Returns
 *      cp of character found
 *
 *  Note:
 *      me is moved to returned cp
 *
 *  TKTK CF
 *      this should probably be done by a CRenderer to allow
 *      left - right justification
 */
LONG CLineFull::CchFromXpos(CLSMeasurer& me, LONG x, LONG y, LONG *pdx,
                            BOOL fExactFit, LONG *pyHeightRubyBase,
                            BOOL *pfGlyphHit, LONG *pyProposed) const
{
    CMarginInfo marginInfo;
    LONG dx = 0;
    LONG cpStart = me.GetCp();
    LONG cp = cpStart;
    UINT uiFlags = 0;
    WHEN_DBG( LONG oldcch = 0; );
    WHEN_DBG( LONG olddx  = 0; );
    BOOL fReverseFlow = FALSE;

    //
    // Bail out if the line has no charaters in it.
    //
    if (_cch == 0)
        return 0;

    if (me._pFlowLayout->IsDisplayNone())
        return 0;
    
    me.SetBreakLongLines(me._ptpCurrent->GetBranch(), &uiFlags);

    if (pyProposed)
        *pyProposed = LONG_MIN;

    // Determine where x is relative to the line. LTR lines have their origin
    // at the left edge of the text in the line and progress positively to the
    // right; RTL lines have their origin at the  right edge of the text and
    // progress positively to the left.
    if (!_fRTLLn)
    {
        x = x - (_xLeftMargin + _xLeft);
    }
    else
    {
        x = -(x - (_xLeftMargin + _xLeft + _xWidth - 1));
    }

    me._li._cch = 0;                         // Default zero count

    if(x > 0)                          // In between right & left margins
    {
        {
            CLineCore *pliFirstFrag;
            LONG cpStartContainerLine;
            LSERR lserr = lserrNone;
                
            lserr = me.PrepAndMeasureLine((CLineFull*)this, &pliFirstFrag, &cpStartContainerLine, &marginInfo, _cch, uiFlags);

            if (lserr == lserrNone)
            {
                if (me._pLS->_plsline)
                {
                    LONG xTrailEdge;
                    CLineOtherInfo *ploi = pliFirstFrag->oi();
                    
                    Assert(pliFirstFrag->_fRTLLn == _fRTLLn);
                    if (!_fRTLLn)
                    {
                        x += (_xLeft + _xLeftMargin) -
                             (ploi->_xLeft + ploi->_xLeftMargin);
                    }
                    else
                    {
                        x += (_xRight + _xRightMargin) -
                             (pliFirstFrag->_xRight + ploi->_xRightMargin);
                    }

                    if (pliFirstFrag != (CLineCore*)this)
                    {
                        long durWithTrailing, duIgnore;
                        HRESULT hr = me._pLS->GetLineWidth(&durWithTrailing, &duIgnore);
                        if (hr)
                            goto Cleanup;
                        xTrailEdge = durWithTrailing;
                    }
                    else
                    {
                        xTrailEdge = _xWidth + _xWhite;
                    }
                     
                    // If our point is past the end of the line, the return value of
                    // LsQueryLinePointPcp is invalid.
                    if (x < xTrailEdge)
                    {
                        HRESULT hr;
                        LSTEXTCELL lsTextCell;
                        LSTFLOW kTFlow;
                        COneRun *porHit;
                        
                        // FUTURE: (paulnel) If we find we need any more information
                        // from the LSQSUBLINEINFO we can pass it back here.
                        hr = THR( me._pLS->QueryLinePointPcp( x, y, 
                                            &kTFlow, &lsTextCell ) );

                        if (hr)
                        {
                            AssertSz(0,"QueryLinePointPcp failed.");
                            goto Cleanup;
                        }

                        dx = lsTextCell.pointUvStartCell.u - x;
                        fReverseFlow = (IsRTLLine() == !(kTFlow & fUDirection));
                        cp = me._pLS->CPFromLSCPCore(lsTextCell.cpStartCell, &porHit);

                        if (pfGlyphHit)
                        {
                            *pfGlyphHit =    porHit 
                                          && porHit->IsSyntheticRun() 
                                          && porHit->_synthType == CLineServices::SYNTHTYPE_GLYPH;
                        }

                        if (pyProposed)
                        {
                            if (me._pLS->_fHasVerticalAlign)
                                *pyProposed = porHit->_yProposed;
                        }
#if DBG==1
                        // (paulnel) This is a helper for hit testing to see if we 
                        // have the correct character
                        CTxtPtr tp(me._pdp->GetMarkup(), cp);
                        TCHAR ch = tp.GetChar();
                        Assert(!g_Zero.ab[0] || ch);
#endif // DBG
                        if (!fExactFit)
                        {
                            if (cp + long(lsTextCell.cCharsInCell) <= me._cp + _cch)
                            {
                                // It is possible to have lsTextCell flowing against
                                // the line. If this is the case dx is positive and
                                // we will need to subtract dupCell from dx if we
                                // advance the cp.
                                if ( ((!fReverseFlow) ? -dx : dx) >= lsTextCell.dupCell / 2 )
                                {
                                    cp += lsTextCell.cCharsInCell;
                                    dx += (!fReverseFlow) ? lsTextCell.dupCell : -lsTextCell.dupCell;
                                }
                            }
                        }
                    }
                    else
                    {
                        cp = cpStart + _cch;
                        // NOTE: (mikejoch) Shouldn't this be (_xWidth + _xWhite) - x?
                        // NOTE: (dmitryt) I think it doesn't matter. the only place where 
                        // this function (CchFromXpos) is called, is only using the sign of dx (+ or -)
                        // If our point was past the line, dx will be negative. We could assign -1 here...
                        dx = _xWidth - x;
                    }
                }
                else
                {
                    // If _plsline is NULL, we didn't measure.  This usually
                    // means we had no text to measure, or we had no width.
                    
                    Assert(   IsTagEnabled(tagAssertOnHittestingWithLS)
                           || me._li._cch == 0 );
                    
                    dx = _xWidth - x;
                    cp = cpStart;
                }

                // The IE4 measure has a bug in that if you hit test on a
                // BR, you'll get the cch *after* the BR regardless of
                // where in the BR you're positioned.  Don't assert on
                // these false alarms (cthrash)

  #if DBG==1
                if (IsTagEnabled(tagAssertOnHittestingWithLS))
                {
                    WHEN_DBG( if (!me._fLastWasBreak) )
                    {
                        Assert(cp - cpStart == oldcch);
                        Assert(dx           == olddx);
                    }
                }
  #endif // DBG
            }
        }
        me._li._cch = cp - cpStart;
    }
    else
    {
        CTreePos *  ptp;

        me._pdp->FormattingNodeForLine(FNFL_STOPATGLYPH, me.GetCp(), me.GetPtp(), _cch, &me._cchPreChars, &ptp, NULL);

        me._li._cch = me._cchPreChars;
        dx = -x;
    }

    if (pdx)
    {
        *pdx = (!fReverseFlow ? dx : -dx);
    }

Cleanup:
    if (cpStart != long(me.GetCp()))
        me.SetCp(cpStart, NULL);
    me.Advance(me._li._cch);

    if(me.CurrBranch()->GetCharFormat(LC_TO_FC(me._pci->GetLayoutContext()))->_fIsRubyText && pyHeightRubyBase)
    {
        RubyInfo *pRubyInfo = me._pLS->GetRubyInfoFromCp(me.GetCp());
        if(pRubyInfo) 
        {
            *pyHeightRubyBase = pRubyInfo->yHeightRubyBase;
        }
    }

    me._pLS->DiscardLine();
    me.PseudoLineDisable();

    return me._li._cch;
}

// =====================  CLinePtr: Line Run Pointer  ==========================

void CLinePtr::Init ( CLineArray & line_arr )
{
    _prgRun = (CRunArray *) & line_arr;
    SetIRun( 0 );
    SetIch( 0 );
    _iLOI = -1;
    _pLOI = &g_loiStock; //better then NULL, will not crash in low mem stress
}

//
// NOTE (sujalp): Presently this method is only called from the
// constructor. However, we may need it when we need to point the
// rp's to different displays. This functionality may be needed
// when we implement cursor navigation in edit mode between sites.
//
void
CLinePtr::Hijack (CDisplay *pdp)
{
    _pdp = pdp;
    _pdp->InitLinePtr( * this );
}

// Move runptr by a certain number of cch/runs

BOOL
CLinePtr::RpAdvanceCp ( long cch, BOOL fSkipFrame )
{
    // See if this is a multi-line ptr

    Assert( _prgRun );

    if (cch == CRunPtr<CLineCore>::AdvanceCp(cch))
    {
        if (fSkipFrame)
        {
            CLineCore *pLine=GetCurrRun();

            // There might not be a valid run pointer.
            if (pLine && pLine->IsFrame())
            {
                int iStep;
                long iRunEnd;

                Assert( NumRuns() );

                if (cch < 0)
                {
                    iStep = -1;
                    iRunEnd = 0;
                }
                else
                {
                    iStep = 1;
                    iRunEnd = NumRuns() - 1;
                }

                while (GetCurrRun()->IsFrame())
                {
                    if (GetIRun() == iRunEnd)
                    {
                        // If the last line is a frame line, then put the
                        // line ptr at the end of the previous line. Assert
                        // that we have a previous line: it will contain the
                        // embedding character for the site in the frame line.
                        Assert(iRunEnd > 0);
                        SetIRun(iRunEnd - 1);
                        if ((pLine = GetCurrRun()) != NULL)
                        {
                            SetIch(pLine->_cch);
                        }

#if DBG==1
                        {
                            CTxtPtr tp(_pdp->GetMarkup(), GetCp() - 1);
                            TCHAR ch = tp.GetChar();

                            Assert( '\r' != ch );
                        }
#endif
                        return TRUE;
                    }
                    else
                    {
                        SetIRun( GetIRun() + iStep );
                    }
                }
            }
        }
    }
    else
    {
        return FALSE;
    }
    return TRUE;
}

BOOL
CLinePtr::PrevLine ( BOOL fSkipFrame, BOOL fSkipEmptyLines )
{
    long iRun = GetIRun();

    if (PrevRun())
    {
        while ((fSkipFrame && GetCurrRun()->IsFrame()) ||
               (fSkipEmptyLines && 0 == GetCurrRun()->_cch))
        {
            if (!PrevRun())
            {
                SetIRun( iRun );
                SetIch( 0 );

                return FALSE;
            }
        }

        return TRUE;
    }

    return FALSE;
}

BOOL
CLinePtr::NextLine( BOOL fSkipFrame, BOOL fSkipDummyLines )
{
    long iRun = GetIRun();

    if (NextRun())
    {
        while ((fSkipFrame && GetCurrRun()->IsFrame()) ||
                (fSkipDummyLines && GetCurrRun()->IsClear()))
        {
            if (!NextRun())
            {
                SetIRun( iRun );
                SetIch( GetCurrRun()->_cch );

                return FALSE;
            }
        }

        return TRUE;
    }

    return FALSE;
}

CLineCore &
CLinePtr::operator [] ( long dRun )
{
    if (_prgRun)
        return * CRunPtr<CLineCore>::GetRunRel( dRun );

    AssertSz( dRun + GetIRun() == 0 ,
        "LP::[]: inconsistent line ptr");

    return  * (CLineCore *) CRunPtr<CLineCore>::GetRunAbs( GetIRun() );
}

/*
 *  CLinePtr::RpSetCp(cp, fAtEnd)
 *
 *  Purpose
 *      Set this line ptr to cp allowing for ambigous cp and taking advantage
 *      of _cpFirstVisible and _iliFirstVisible
 *
 *  Arguments:
 *      cp      position to set this line ptr to
 *      fAtEnd  if ambiguous cp:
 *              if fAtEnd = TRUE, set this line ptr to end of prev line;
 *              else set to start of line (same cp, hence ambiguous)
 *  Return:
 *      TRUE iff able to set to cp
 */
BOOL CLinePtr::RpSetCp(LONG cp, BOOL fAtEnd, BOOL fSkipFrame, BOOL fSupportBrokenLayout)
{
    Assert(_prgRun);

    BOOL fRet;
    // Adjust the cp to be relative to the txt site containting the disp
    if ( !fSupportBrokenLayout )
    {
        cp -= _pdp->GetFlowLayout()->GetContentFirstCp();
    }
    else
    {
        cp -= _pdp->GetFlowLayout()->GetContentFirstCpForBrokenLayout();
    }
    
    {
        SetIRun( 0 );
        SetIch( 0 );
        fRet = RpAdvanceCp(cp, fSkipFrame);  // Start from 0
    }

    //
    // Note(SujalP): As exposed in bug 50281, it can happen that the containing
    // txtsite contains no lines. In which case we cannot really position
    // ourselves anywhere. Return failure.
    //
    if (!CurLine())
    {
        fRet = FALSE;
    }

    //
    // Note(SujalP): Problem exposed in bug34660 -- when we are positioned at a
    // frame line, then the fAtEnd flag is really meaning less, since we base
    // our decision to move to prev or next line based on where in the line
    // is the cp positioned. Since, frame lines contain to characters, we really
    // cannot make that decision at all.
    //
    else if (!CurLine()->IsFrame())
    {
        // Ambiguous-cp caret position, should we be at the end of the line?
        if(fAtEnd)
        {
            if (!GetIch() && PrevLine( fSkipFrame, FALSE ))
            {
                SetIch( GetCurrRun()->_cch );  //  the first, go to end of
            }
        }

        // Or the beginning of the next one?
        else
        {
            if (GetIch() == long( GetCurrRun()->_cch ) && NextLine( fSkipFrame, FALSE ))
            {
                SetIch( 0 );   // Beginning of next line.
            }
        }
    }

    return fRet;
}


/*
 *  CLinePtr::RpBeginLine(void)
 *
 *  Purpose
 *      Move the current character to the beginning of the line.
 *
 *  Return:
 *      change in cp
 *
 *  Note that this will only work on the array type of line pointer.
 *  You will get an assert otherwise.
 */

long
CLinePtr::RpBeginLine ( )
{
    long cch = GetIch();

    Assert( _prgRun );

    SetIch( 0 );

    return cch - GetIch();
}

/*
 *  CLinePtr::RpEndLine(void)
 *
 *  Purpose
 *      Move the current character to the end of the line.
 *
 *  Return:
 *      change in cp
 *
 *  Note that this will only work on the array type of line pointer.
 *  You will get an assert otherwise.
 */
LONG CLinePtr::RpEndLine(void)
{
    LONG cch = GetIch();

    Assert( _prgRun );

    SetIch( GetCurrRun()->_cch );

    return GetIch() - cch;
}

/*
 *  CLinePtr::FindParagraph(fForward)
 *
 *  Purpose
 *      Move this line ptr to paragraph (fForward) ? end : start, and return
 *      change in cp
 *
 *  Arguments:
 *      fForward    TRUE move this line ptr to para end; else to para start
 *
 *  Return:
 *      change in cp
 */

long
CLinePtr::FindParagraph ( BOOL fForward )
{
    LONG cch;

    if(!fForward)                           // Go to para start
    {
        cch = 0;                            // Default already at para start
        if(RpGetIch() != (LONG)(*this)->_cch ||
           !((*this)->_fHasEOP)) // It isn't at para start
        {
            cch = -RpGetIch();              // Go to start of current line
            while(!((*this)->_fFirstInPara) && (*this) > 0)
            {
                if (!PrevLine(TRUE, FALSE)) // Go to start of prev line
                    break;
                cch -= (*this)->_cch;       // Subtract # chars in line
            }
            SetIch( 0 );                       // Leave *this at para start
        }
    }
    else                                    // Go to para end
    {
        cch = (*this)->_cch - RpGetIch();   // Go to end of current line

        while(((*this) < _pdp->LineCount() - 1 ||
                _pdp->WaitForRecalcIli((LONG)*this + 1))
              && !((*this)->_fHasEOP))
        {
            if (!NextLine(TRUE, FALSE))      // Go to start of next line
                break;
            cch += (*this)->_cch;           // Add # chars in line
        }
        SetIch( (*this)->_cch );               // Leave *this at para end
    }
    return cch;
}

/*
 *  CLinePtr::GetAdjustedLineLength
 *
 *  @mfunc  returns the length of the line _without_ EOP markers
 *
 *  @rdesc  LONG; the length of the line
 */
LONG CLinePtr::GetAdjustedLineLength()
{
    CLineCore * pline = GetCurrRun();
    Assert(pline);
    
    LONG cchJunk;
    LONG cchTrim;
    CTreePos *ptpRet, *ptpPrev;
    
    LONG cpEndLine = _pdp->GetFirstCp() + GetCp() - GetIch() + pline->_cch;
    CTreePos *ptp = _pdp->GetMarkup()->TreePosAtCp(cpEndLine, &cchJunk);
    
    _pdp->EndNodeForLine(cpEndLine, ptp, NULL, &cchTrim, &ptpRet, NULL);
    cchTrim = min(cchTrim, pline->_cch);

    LONG cpNewMost = cpEndLine - cchTrim;
    
    if (ptpRet)
    {
        ptpPrev = ptpRet;

        
        if (   ptpPrev->GetCch() == 0
            || (   ptpPrev->IsNode()
                && !ptpPrev->ShowTreePos()
               )
            || (   ptpPrev->IsText()
                && ptpPrev->GetCp() >= cpNewMost
               )
           )
        {
            do
            {
                ptpPrev = ptpPrev->PreviousTreePos();
            }
            while (ptpPrev->GetCch() == 0);
        }
        
        if (   ptpPrev->IsEndElementScope()
            && ptpPrev->Branch()->Tag() == ETAG_BR
           )
        {
            cchTrim += 2;
        }
        else if (ptpPrev->IsText())
        {
            CTxtPtr tp(_pdp->GetMarkup(), cpNewMost - 1);
            if (tp.GetChar() == WCH_ENDPARA1)
                cchTrim++;
        }
    }
    
    cchTrim = min(cchTrim, pline->_cch);
    return pline->_cch - cchTrim;
}

BOOL
CLinePtr::IsLastTextLine()
{
    return _pdp->IsLastTextLine(*this);
}

#if DBG==1
void
CLineArray::Remove(DWORD ielFirst, LONG celFree, ArrayFlag flag)
{
    DWORD ielLast = (celFree == -1) ? Count() : (ielFirst + celFree);
    CLineCore *pli;
    DWORD i;

    for (i = ielFirst, pli=Elem(ielFirst); i < ielLast; i++, pli++)
    {
        AssertSz(pli->_iLOI == -1, "Not freed, need to call Forget before this!");
    }
    super::Remove(ielFirst, celFree, flag);
}

void
CLineArray::Clear(ArrayFlag flag)
{
    CLineCore *pli;
    DWORD i;
    for (i = 0, pli = Elem(0); i < Count(); i++, pli++)
    {
        AssertSz(pli->_iLOI == -1, "Not freed, need to call Forget before this!");
    }
    super::Clear(flag);
}

BOOL
CLineArray::Replace (DWORD iel, LONG cel, CArrayBase *par)
{
    CLineCore *pli;
    DWORD i;
    CLineArray *plar = DYNCAST(CLineArray, par);
    DWORD iLimit = cel == -1 ? Count() : iel + cel;

    for (i = iel, pli = Elem(iel); i < iLimit; i++, pli++)
    {
        AssertSz(pli->_iLOI == -1, "Not freed, need to call Forget before this!");
    }
    for (i = 0, pli = plar->Elem(0); i < plar->Count(); pli++, i++)
    {
        Assert(pli->_iLOI != -1);
    }
    return super::Replace(iel, cel, par);
}
#endif

BOOL
CLinePtr::Replace(LONG cRun, CLineArray *parLine)
{
    CLineCore *pli;
    DWORD i;

    ((CLineArray *)_prgRun)->Forget(GetIRun(), cRun);
    for (i = 0, pli = parLine->Elem(0); i < parLine->Count(); pli++, i++)
    {
        pli->AddRefOtherInfo();
    }
    return CRunPtr<CLineCore>::Replace(cRun,(CRunArray *)parLine);
}

void
CLineArray::Forget(DWORD iel, LONG cel)
{
    DWORD iLimit = cel == -1 ? Count() : iel + cel;
    CLineCore *pli;
    DWORD i;

    for (i = iel, pli = Elem(iel); i < iLimit; i++, pli++)
    {
        pli->ReleaseOtherInfo();
    }
}

CLineOtherInfo *
CLinePtr::oi()
{
    CLineCore *pli = CurLine();

    Assert(pli->_iLOI != -1);

    if (pli->_iLOI != _iLOI)
    {
        _pLOI = pli->oi();
        _iLOI = pli->_iLOI;
    }
    return _pLOI;
}

WORD
CLineOtherInfo::ComputeCrc() const
{
    Assert((sizeof(CLineOtherInfo) / sizeof(DWORD)) * sizeof(DWORD) == sizeof(CLineOtherInfo));
    DWORD dwCrc=0, z;

    for (z=0;z<sizeof(CLineOtherInfo)/sizeof(DWORD);z++)
    {
        dwCrc ^= ((DWORD*) this)[z];
    }
    return (LOWORD(dwCrc) ^ HIWORD(dwCrc));
}

CElement *
CLineCore::AO_Element(CLineOtherInfo *ploi)
{
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    return ploi->_fHasFloatedFL ? NULL : ploi->_pNodeForLayout->Element();
}

CLayout *
CLineCore::AO_GetUpdatedLayout(CLineOtherInfo *ploi, CLayoutContext *pLayoutContext)
{
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    return ploi->_fHasFloatedFL ? NULL : ploi->_pNodeForLayout->GetUpdatedLayout(pLayoutContext);
}

LONG
CLineCore::AO_GetFirstCp(CLineOtherInfo *ploi, LONG cpLine)
{
    LONG cpFirst;
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    if (ploi->_fHasFloatedFL)
    {
        Assert(cpLine != -1);
        cpFirst = cpLine - ploi->_cchFirstLetter;
    }
    else
    {
        cpFirst = ploi->_pNodeForLayout->Element()->GetFirstCp();
    }
    return cpFirst;
}

LONG
CLineCore::AO_GetLastCp(CLineOtherInfo *ploi, LONG cpLine)
{
    LONG cpLast;
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    if (ploi->_fHasFloatedFL)
    {
        Assert(cpLine != -1);
        cpLast = cpLine;
    }
    else
    {
        cpLast = ploi->_pNodeForLayout->Element()->GetLastCp();
    }
    return cpLast;
}

void
CLineCore::AO_GetSize(CLineOtherInfo *ploi, CSize *pSize)
{
    Assert(IsFrame());
    Assert(pSize);
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    if (ploi->_fHasFloatedFL)
    {
        pSize->cx = _xWidth;
        pSize->cy = _yHeight;
    }
    else
    {
        AO_GetUpdatedLayout(ploi)->GetSize(pSize);
    }
}

const CFancyFormat *
CLineCore::AO_GetFancyFormat(CLineOtherInfo *ploi)
{
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    return ploi->_fHasFloatedFL ? NULL : ploi->_pNodeForLayout->GetFancyFormat();
}

LONG
CLineCore::AO_GetXProposed(CLineOtherInfo *ploi)
{
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    return ploi->_fHasFloatedFL ? 0 : AO_GetUpdatedLayout(ploi)->GetXProposed();
}

LONG
CLineCore::AO_GetYProposed(CLineOtherInfo *ploi)
{
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    return ploi->_fHasFloatedFL ? 0 : AO_GetUpdatedLayout(ploi)->GetYProposed();
}

//
//  For RTL line, convert offsets from right to offsets from left
//  Also, ensure that the chunk widh is >= 0.
//  (why do we need to ensure positive width in LTR case? Don't know, may be we don't.)
//
void CLineCore::AdjustChunkForRtlAndEnsurePositiveWidth(CLineOtherInfo const *ploi, 
                                             LONG xStartChunk, LONG xEndChunk, 
                                             LONG *pxLeft, LONG *pxRight)
{
    
    if (IsRTLLine())
    {
        // note: _xLineWidth is defined as width between margins. 
        //       If there is no overflow, line width is not affected by _xLeft or _xRight; 
        //       it takes all space between margins.
        //       In case of RTL, chunks are positioned relative to the right margin.
        //         
        int xLineRight = ploi->_xLeftMargin + ploi->_xRightMargin + _xLineWidth;
      
        // in RTL layout, _xLineWidth doesn't always start at left margin
        xLineRight += ploi->_xNegativeShiftRTL;
            
        xStartChunk = xLineRight - xStartChunk;
        xEndChunk = xLineRight - xEndChunk;
    }

    if (xStartChunk <= xEndChunk)
    {
        *pxLeft = xStartChunk;
        *pxRight = xEndChunk;
    }
    else
    {
        // This shouldn't happen in LTR, but the author is being over 
        // optimistic about more common usage of content offset in the future.
        // Some call it overengineering, some call it defensive code.
        Assert(IsRTLLine() || !IsTagEnabled(tagDebugRTL));    
        *pxLeft = xEndChunk;
        *pxRight = xStartChunk;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\irange.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       irange.cxx
//
//  Contents:   Implementation of the CAutoRange and related classes
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_OMRECT_HXX_
#define X_OMRECT_HXX_
#include "omrect.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif


#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifdef UNIX
#ifndef X_QUXCOPY_H_
#define X_QUXCOPY_H_
#include "quxcopy.hxx"
#endif
#endif

#define _cxx_
#include "range.hdl"

MtDefine(CAutoRange, ObjectModel, "CAutoRange")
MtDefine(CAutoRangeGetRangeBoundingRect_aryRects_pv, Locals, "CAutoRange::GetRangeBoudningRect aryRects::_pv")
MtDefine(CAutoRangegetClientRects_aryRects_pv, Locals, "CAutoRange::getClientRects aryRects::_pv")
MtDefine(CAutoRange_paryAdjacentRangePointers_pv, Locals , "CAutoRange::_paryAdjacentRangePointers::_pv")
MtDefine(CAutoRangeIterator, ObjectModel, "CAutoRangeIterator")
MtDefine(CAutoRangeCollection,ObjectModel,"CAutoRangeCollection")
MtDefine(CAutoRangeCollection_aryRanges_pv,ObjectModel,"CAutoRange::CAutoRangeCollection_aryRanges_pv")

extern HRESULT 
HandleIE50CompatUIPasteHTML (
    CMarkupPointer * pPointerTargetStart,
    CMarkupPointer * pPointerTargetFinish,
    HGLOBAL          hglobal,
    BOOL             fAutomation );


const CBase::CLASSDESC CAutoRange::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // property pages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    & IID_IHTMLTxtRange,            // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

// IOleCommandTarget methods

BEGIN_TEAROFF_TABLE(CAutoRange, IOleCommandTarget)
    TEAROFF_METHOD(CAutoRange, QueryStatus, querystatus, (GUID * pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext))
    TEAROFF_METHOD(CAutoRange, Exec, exec, (GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut))
END_TEAROFF_TABLE()

//+----------------------------------------------------------------------------
//
//  Constructor / Destructor
//
//-----------------------------------------------------------------------------

CAutoRange::CAutoRange ( CMarkup * pMarkup, CElement * pElemContainer )
{
    Assert(!pElemContainer || pElemContainer->GetMarkup() == pMarkup);

    CElement::SetPtr( & _pElemContainer, pElemContainer );

    _pMarkup = pMarkup;

    _pMarkup->AddRef();

    _pLeft = _pRight = NULL;

    _pNextRange = NULL;

    InitPointers();
}


CAutoRange::~CAutoRange()
{
    RemoveLookAsideEntry();

    ClearAdjacentRangePointers();

    ReleaseInterface( _pLeft );
    
    ReleaseInterface( _pRight );

    CElement::ClearPtr( & _pElemContainer );

    _EditRouter.Passivate();
    
    _pMarkup->Release();
}


//+----------------------------------------------------------------------------
//
//  Member:     RemoveLookAsideEntry
//
//  Synopsis:   The markup keeps a lookaside pointer which is a list of 
//              active CAutoRanges on the markup. This routine clears this list.
//
//-----------------------------------------------------------------------------

void
CAutoRange::RemoveLookAsideEntry()
{
    WHEN_DBG( BOOL fFound = FALSE );

    CAutoRange * pAutoRange = _pMarkup->GetTextRangeListPtr();

    Assert( pAutoRange );

    if ( pAutoRange == this )
    {
        CAutoRange * pLookAsideRange = pAutoRange->_pNextRange;

        _pMarkup->DelTextRangeListPtr();

        if ( pLookAsideRange )
        {
            IGNORE_HR( _pMarkup->SetTextRangeListPtr( pLookAsideRange ) );
        }
        WHEN_DBG( fFound = TRUE );
    }
    else
    {
        CAutoRange * pPrevRange = pAutoRange;

        pAutoRange = pAutoRange->_pNextRange;

        Assert( pAutoRange );

        while ( pAutoRange )
        {
            if ( pAutoRange == this )
            {
                Assert ( pPrevRange );
                pPrevRange->_pNextRange = pAutoRange->_pNextRange;
                WHEN_DBG( fFound = TRUE );
                break;
            }

            pPrevRange = pAutoRange;
            pAutoRange = pAutoRange->_pNextRange;
        }     
    }

    Assert( fFound );
}


//+----------------------------------------------------------------------------
//
//  Member:     AdjustRangePointerGravity
//
//  Synopsis:   This function compares the passed in pRangePointer to _pLeft.
//              if pRangePointer has right gravity and it is equal to _pLeft
//              then its gravity is temporarily set to POINTER_GRAVITY_Left, 
//              in preparation for the upcoming put_text operation. 
//              This prevents pther range pointers around _pLeft to accidently move
//              right, when InsertText() is called.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::AdjustRangePointerGravity( IMarkupPointer * pRangePointer )
{
    BOOL        fEqual;
    HRESULT     hr;
    POINTER_GRAVITY eGravity;

    hr = THR( pRangePointer->Gravity( &eGravity ) );
    if (hr)
        goto Cleanup;

    if ( eGravity == POINTER_GRAVITY_Left )
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR( _pLeft->IsEqualTo( pRangePointer, & fEqual ) );
    if (hr)
        goto Cleanup;

    if ( fEqual )
    {
        hr = THR( pRangePointer->SetGravity( POINTER_GRAVITY_Left ) );
        if (hr)
            goto Cleanup;

        hr = THR( StoreAdjacentRangePointer( pRangePointer ) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureAdjacentRangesGravity
//
//  Synopsis:   This function calls AdjustRangePointerGravity() on all the 
//              ranges in the current markup. Please see comments under
//              AdjustRangePointerGravity for more info.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::EnsureAdjacentRangesGravity()
{
    HRESULT      hr = S_OK;
    CAutoRange * pAutoRange = _pMarkup->GetTextRangeListPtr();
    Assert( pAutoRange );

    while ( pAutoRange )
    {
        if ( pAutoRange != this )
        {
            hr = THR( AdjustRangePointerGravity( pAutoRange->_pLeft ) );
            if (hr)
                goto Cleanup;
            
            hr = THR( AdjustRangePointerGravity( pAutoRange->_pRight ) );
            if (hr)
                goto Cleanup;
        }

        pAutoRange = pAutoRange->_pNextRange;
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     RestoreAdjacentRangesGravity
//
//  Synopsis:   This function restores the gravity of range pointers whose gravity
//              was temporarily set by AdjustRangePointerGravity, and clears the
//              _paryAdjacentRangePointers list.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::RestoreAdjacentRangesGravity()
{
    HRESULT      hr = S_OK;
    long         iPointer;
    IMarkupPointer * pRangePointer;

    if (! _paryAdjacentRangePointers)
    {
        // Nothing to do
        goto Cleanup;
    }

    iPointer = _paryAdjacentRangePointers->Size() - 1;

    while ( iPointer >= 0 )
    {        
        pRangePointer = _paryAdjacentRangePointers->Item( iPointer );

        Assert( pRangePointer );

        if ( pRangePointer )
        {
            hr = THR( pRangePointer->SetGravity( POINTER_GRAVITY_Right ) );
            if (hr)
                goto Cleanup;        

            pRangePointer->Release();
        }

        _paryAdjacentRangePointers->Delete( iPointer );        
        
        iPointer--;
    }

    ClearAdjacentRangePointers();

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     ClearAdjacentRangePointers
//
//  Synopsis:   Delete the list of adjacent range pointers array.
//
//-----------------------------------------------------------------------------

void
CAutoRange::ClearAdjacentRangePointers()
{
    if ( _paryAdjacentRangePointers )
    {
        delete _paryAdjacentRangePointers;
        _paryAdjacentRangePointers = NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     StoreAdjacentRangePointer
//
//  Synopsis:   Append a range pointer whose gravity was set by AdjustRangePointerGravity
//              to the list of adjacent range pointers array.
//
//-----------------------------------------------------------------------------

HRESULT 
CAutoRange::StoreAdjacentRangePointer( IMarkupPointer * pAdjacentPointer )
{
    HRESULT hr = S_OK;

    if ( ! _paryAdjacentRangePointers )
    {
        _paryAdjacentRangePointers = new ( Mt( CAutoRange_paryAdjacentRangePointers_pv ) )  
                    CPtrAry<IMarkupPointer *> ( Mt( CAutoRange_paryAdjacentRangePointers_pv ) )  ;

        if (! _paryAdjacentRangePointers) 
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;        
        }
    }

    pAdjacentPointer->AddRef();

    hr = THR( _paryAdjacentRangePointers->Append( pAdjacentPointer ) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     IsCompatibleWith
//
//  Synopsis:   Makes sure two pointers are in the same region of the tree.
//              Operations involving two pointers need to be compatible.
//
//-----------------------------------------------------------------------------

BOOL
CAutoRange::IsCompatibleWith ( IHTMLTxtRange * pIRangeThat )
{
    CAutoRange * pRangeThat;

    if (pIRangeThat->QueryInterface( CLSID_CRange, (void **) & pRangeThat ) != S_OK)
        return FALSE;

    return pRangeThat->GetContainer() == GetContainer();
}

//+----------------------------------------------------------------------------
//
//  Member:     SanityCheck
//
//  Synopsis:   Do a little self diagnosis
//
//-----------------------------------------------------------------------------

#if DBG == 1

void
CAutoRange::SanityCheck ( )
{
}

#define DO_SANITY_CHECK SanityCheck();

#else

#define DO_SANITY_CHECK

#endif


//+----------------------------------------------------------------------------
//
//  Member:     QueryStatus
//
//  Synopsis:   Implements IOleCommandTarget::QueryStatus() for IHTMLTxtRange
//
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::QueryStatus (GUID * pguidCmdGroup,
                         ULONG cCmds,
                         MSOCMD rgCmds[],
                         MSOCMDTEXT * pcmdtext)
{
    HRESULT     hr = S_OK;
    MSOCMD *    pCmd;
    INT         c;
    DWORD       cmdID;

    Assert( CBase::IsCmdGroupSupported( pguidCmdGroup ) );

    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        cmdID = CBase::IDMFromCmdID( pguidCmdGroup, pCmd->cmdID );
        
        switch ( cmdID )
        {
            case IDM_SIZETOCONTROL:
            case IDM_SIZETOCONTROLHEIGHT:
            case IDM_SIZETOCONTROLWIDTH:
            case IDM_DYNSRCPLAY:
            case IDM_DYNSRCSTOP:

            case IDM_BROWSEMODE:
            case IDM_EDITMODE:
            case IDM_REFRESH:
            case IDM_REDO:
            case IDM_UNDO:
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
                break;

            default:
                hr = _EditRouter.QueryStatusEditCommand(
                            pguidCmdGroup,
                            1,
                            pCmd,
                            pcmdtext,
                            (IUnknown *) (IHTMLTxtRange *)this,
                            NULL,                                   // No CMarkup ptr for Ranges
                            GetMarkup()->Doc() );
        }
    }

    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     Exec
//
//  Synopsis:   Implements IOleCommandTarget::Exec() for IHTMLTxtRange
//
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::Exec (GUID * pguidCmdGroup,
                  DWORD nCmdID,
                  DWORD nCmdexecopt,
                  VARIANTARG * pvarargIn,
                  VARIANTARG * pvarargOut)
{
    HRESULT     hr;
    int         idm;

    idm = CBase::IDMFromCmdID( pguidCmdGroup, nCmdID );

    if ( CheckOwnerSiteOrSelection(idm) )
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
        goto Cleanup;
    }

    //
    // ie50 compatible paste is handled in trident, so don't route to editor    
    //

    if (nCmdID == IDM_IE50_PASTE)
    {
        CMarkupPointer * pmpLeft, * pmpRight;
        
        if (!pvarargIn || V_VT(pvarargIn) != VT_BYREF)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = THR( _pLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpLeft ) );
        if (hr)
            goto Cleanup;
            
        hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpRight ) );
        if (hr)
            goto Cleanup;

        hr = THR( HandleIE50CompatUIPasteHTML(pmpLeft, pmpRight, HGLOBAL(V_BYREF(pvarargIn)), FALSE) );
        
        goto Cleanup;
    }

    //
    // Route command using the edit router...
    //
    hr = THR( _EditRouter.ExecEditCommand(pguidCmdGroup,
                                     nCmdID, nCmdexecopt,
                                     pvarargIn, pvarargOut,
                                     (IUnknown *) (IHTMLTxtRange *)this,
                                     GetMarkup()->Doc() ) );

    //
    // For commands that perform an insert, collapse the range 
    // after the insertion point
    //
    if (hr)
        goto Cleanup;

    switch( idm )
    {
    case IDM_IMAGE:
    case IDM_PARAGRAPH:
    case IDM_IFRAME:
    case IDM_TEXTBOX:
    case IDM_TEXTAREA:
#ifdef  NEVER
    case IDM_HTMLAREA:
#endif
    case IDM_CHECKBOX:
    case IDM_RADIOBUTTON:
    case IDM_DROPDOWNBOX:
    case IDM_LISTBOX:
    case IDM_BUTTON:
    case IDM_MARQUEE:
    case IDM_1D:
    case IDM_LINEBREAKNORMAL:
    case IDM_LINEBREAKLEFT:
    case IDM_LINEBREAKRIGHT:
    case IDM_LINEBREAKBOTH:
    case IDM_HORIZONTALLINE:
    case IDM_INSINPUTBUTTON:
    case IDM_INSINPUTIMAGE:
    case IDM_INSINPUTRESET:
    case IDM_INSINPUTSUBMIT:
    case IDM_INSINPUTUPLOAD:
    case IDM_INSFIELDSET:
    case IDM_INSINPUTHIDDEN:
    case IDM_INSINPUTPASSWORD:
    case IDM_PASTE:
        {
            BOOL fResult;

            hr = THR( _pLeft->IsRightOf( _pRight, & fResult ) );

            if ( fResult )
                hr = THR( _pRight->MoveToPointer( _pLeft ) );
            else
                hr = THR( _pLeft->MoveToPointer( _pRight ) );
        }
    }

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    DO_SANITY_CHECK

    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLTxtRange)
        QI_TEAROFF(this, IOleCommandTarget, (IHTMLTxtRange *)this)
        QI_INHERITS(this, IHTMLTxtRange)
        QI_INHERITS(this, ISegmentList)
        QI_INHERITS(this, ISegment)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_TEAROFF(this, IHTMLTextRangeMetrics, NULL)
        QI_TEAROFF(this, IHTMLTextRangeMetrics2, NULL)

        default:
            if (IsEqualIID(iid, CLSID_CRange))
            {
                *ppv = this;
                return S_OK;
            }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CloseErrorInfo, IHTMLTxtRange
//
//  Synopsis:   Pass the call to the form so it can return its clsid
//              instead of the object's clsid as in CBase.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::CloseErrorInfo(HRESULT hr)
{
    GetMarkup()->Doc()->CloseErrorInfo( hr );

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     GetText, IHTMLTxtRange
//
//  Synopsis:   Gets the simple text from the range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::get_text( BSTR * pText )
{
    HRESULT hr = E_POINTER;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (pText)
    {
        hr = THR( KeepRangeLeftToRight() );
        if (hr)
            goto Cleanup;

        // NOTE: Work around a saver bug when range is empty
        if ( IsRangeCollapsed() )
        {
            hr = FormsAllocString(_T( "" ), pText);
        }
        else
        {
            hr = THR(GetBstrHelper(pText, RSF_SELECTION, WBF_SAVE_PLAINTEXT|WBF_NO_WRAP));  // new
        }

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( SetErrorInfoPGet( hr, DISPID_CAutoRange_text ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     SetText, IHTMLTxtRange
//
//  Synopsis:   Sets the simple text in the range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::put_text( BSTR Text )
{
    HRESULT hr;
    CMarkup *   pMarkup = GetMarkup();
    CDoc     *  pDoc = pMarkup->Doc();
    CParentUndo pu( pDoc );
    CElement *  pContainer;
    IHTMLEditingServices * pedserv = NULL;
    IHTMLEditor * phtmed;
    BOOL          result;

    Assert( pDoc );
    Assert( pMarkup );

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    pContainer = GetCommonContainer();

    if (pContainer && pContainer->TestClassFlag(CElement::ELEMENTDESC_OMREADONLY))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if( pContainer->IsEditable(/*fCheckContainerOnly*/FALSE) )
        pu.Start( IDS_UNDOGENERICTEXT );

    if (!CheckSecurity(L"paste"))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    //
    // Get the editing services interface with which I can
    // insert sanitized text
    //

    phtmed = pDoc->GetHTMLEditor();

    if (!phtmed)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(
        phtmed->QueryInterface(
            IID_IHTMLEditingServices, (void **) & pedserv ) );
    if (hr)
        goto Cleanup;

    hr = THR( EnsureAdjacentRangesGravity() );
    if (hr)
        goto Cleanup;

    hr = THR( pedserv->Paste( _pLeft, _pRight, Text ) );
    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->IsRightOf( _pRight, & result ) );
    if ( result )
        hr = THR( _pRight->MoveToPointer( _pLeft ) );
    else
        hr = THR( _pLeft->MoveToPointer( _pRight ) );
    if (hr)
        goto Cleanup;

    hr = THR( RestoreAdjacentRangesGravity() );
    if (hr)
        goto Cleanup;

    hr = THR( ValidatePointers() );
    if (hr)
        goto Cleanup;


Cleanup:
    pu.Finish( hr );
    ReleaseInterface( pedserv );
    RRETURN( SetErrorInfoPSet( hr, DISPID_CAutoRange_text ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     GetText, IHTMLTxtRange
//
//  Synopsis:   Gets the HTML (fragment) text from the range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::get_htmlText( BSTR * ppHtmlText )
{
    HRESULT hr = S_OK;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!ppHtmlText)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( GetBstrHelper(ppHtmlText, RSF_FRAGMENT, 0) );
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfoPGet( hr, DISPID_CAutoRange_htmlText ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     parentElement, IHTMLTxtRange
//
//  Synopsis:   Get the common parent element for all chars int the range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::parentElement ( IHTMLElement * * ppParent )
{
    HRESULT           hr;
    IMarkupPointer  * pCurrent = NULL;
    IMarkupPointer  * pAdjustedLeft = NULL;
    IMarkupPointer  * pPointer = NULL;
    IHTMLElement    * pOldElement = NULL;
    CMarkup         * pMarkup = GetMarkup();
    CDoc            * pDoc;
    CElement        * pElement = NULL;
    BOOL              fEqual;
    BOOL              fRangeIsCollapsed;
    BOOL              fUseRightForParent = FALSE;
    CMarkupPointer  * pointerLeft;
    CMarkupPointer  * pointerRight;
    BOOL              fBlockBreakAdjustment = FALSE;
    MARKUP_CONTEXT_TYPE context;    
    IMarkupPointer    * pLeftBoundary  = NULL;
    IMarkupPointer    * pRightBoundary = NULL;

    Assert( pMarkup );

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Check incoming pointer
    //

    if (!ppParent)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppParent = NULL;
    
    pDoc = pMarkup->Doc();
    Assert( pDoc );

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( pDoc->CreateMarkupPointer( & pCurrent ) );
    if (hr)
        goto Cleanup;

    hr = THR( pDoc->CreateMarkupPointer( & pAdjustedLeft ) );
    if (hr)
        goto Cleanup;

    //
    // SetRangeToElementText() adjusts the left end of the range just before a character.
    // Here we must undo the adjustment to achieve IE4 compat for parentElement()
    //

    hr = THR( pAdjustedLeft->MoveToPointer( _pLeft ) );
    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->IsEqualTo(_pRight, &fRangeIsCollapsed) );
    if (hr)
        goto Cleanup;
        
    if (fRangeIsCollapsed)
    {
        hr = THR( pAdjustedLeft->MoveToPointer( _pLeft ) );
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR( MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
        if (hr)
            goto Cleanup;

        hr = THR( pCurrent->MoveToPointer( _pLeft ) );
        if (hr)
            goto Cleanup;

        hr = THR( MoveCharacter( pCurrent, MOVEUNIT_NEXTCHAR, pLeftBoundary, pRightBoundary, pAdjustedLeft ) );
        if (hr)
            goto Cleanup;

        hr = THR( pAdjustedLeft->IsRightOfOrEqualTo( _pRight, & fEqual ) );
        if (hr)
            goto Cleanup;

        if ( fEqual )
        {
            hr = THR( pAdjustedLeft->MoveToPointer( _pLeft ) );
            if (hr)
                goto Cleanup;
        }
        
        hr = THR( pAdjustedLeft->IsEqualTo( _pRight, & fRangeIsCollapsed ) );
        if (hr)
            goto Cleanup;
    }


    //
    // IE4 compat: If _pLeft and _pRight are around a noscope element that has layout,
    //             we want to return the noscope element as the parentElement for the range
    //
    hr = THR( pCurrent->MoveToPointer( pAdjustedLeft ) ) ;
    if (hr)
        goto Cleanup;

    hr = THR( RightOrSlave( pCurrent, TRUE, & context, ppParent , NULL, NULL ) );
    if (hr)
        goto Cleanup;

    if ( context == CONTEXT_TYPE_NoScope && *ppParent )
    {
        hr = THR( (*ppParent)->QueryInterface( CLSID_CElement, (void **) & pElement ) );
        if (hr)
            goto Cleanup;
            
        if ( pElement->ShouldHaveLayout() )
        {
            hr = THR( pCurrent->IsEqualTo( _pRight, & fEqual ) );
            if (hr)
                goto Cleanup;

            if ( fEqual )
            {
                // return ppParent as the parent element 
                // of the range
                goto Cleanup;
            }
        }
    }        
    // 
    // End IE4 compat, reset ppParent back to NULL and find the parent element
    //
    ClearInterface( ppParent ); 

    //
    // If the right end of the range is placed after a block break, we would
    // like to adjust it inside the element before detecting the parent element
    //
    {
        DWORD           dwBreaks;

        hr = THR( pDoc->CreateMarkupPointer( & pPointer ) );
        if (hr)
            goto Cleanup;

        hr = THR( pPointer->MoveToPointer( _pRight ) );
        if (hr)
            goto Cleanup;

        hr = THR( LeftOrSlave(pPointer, TRUE, & context, NULL, NULL, NULL ) );
        if (hr)
            goto Cleanup;

        //
        // We're looking for cases where the right pointer
        // is immediately after the end scope of an element that has
        // a block break
        //
        if ( context == CONTEXT_TYPE_EnterScope )
        {
            // We've enter the scope of an element, now check for block breaks
            hr = THR( pDoc->QueryBreaks( pPointer, & dwBreaks, FALSE) );
            if (hr)
                goto Cleanup;

            // A Site End is almost the same as a Block Break, so handle that too
            if ( (dwBreaks & (BREAK_BLOCK_BREAK | BREAK_SITE_END)) != BREAK_NONE )
            {
                // Adjust _pRight to the left
                hr = THR( LeftOrSlave( _pRight, TRUE, NULL, NULL, NULL, NULL ) );
                if (hr)
                    goto Cleanup;
                fBlockBreakAdjustment = TRUE;
                fUseRightForParent = TRUE;
            }
        }
    }    

    if (fUseRightForParent)
        hr = THR( _pRight->CurrentScope( ppParent ) );
    else
        hr = THR( pAdjustedLeft->CurrentScope( ppParent ) );

    if (hr)
        goto Cleanup;

    if (fRangeIsCollapsed && fBlockBreakAdjustment)
    {
        fBlockBreakAdjustment = FALSE;
        hr = THR( RightOrSlave( _pRight, TRUE, NULL, NULL, NULL, NULL ) );
        if (hr)
            goto Cleanup;
    }

    //
    // CurrentScope return NULL, we must be in a slave,
    // return the master element as the parent element of the range
    //
    if ( *ppParent == NULL )
    {
        hr = THR( pAdjustedLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pointerLeft ) );
        if( hr )
            goto Cleanup;

        hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pointerRight ) );
        if( hr )
            goto Cleanup;

        if ( pointerLeft->Markup() == pointerRight->Markup() )
        {
            // If both pointers are in the same markup, return the master
            CTreeNode * pNode = pointerLeft->Branch();
            
            pElement = (pNode && pNode->Element()->HasMasterPtr()) ? pNode->Element()->GetMasterPtr() : NULL;
            if ( !pElement || pElement->Tag() != ETAG_INPUT)
                goto Cleanup;

            hr = THR( pElement->QueryInterface( IID_IHTMLElement, (void **) ppParent ) );
            // Return ppParent as the parent element
            goto Cleanup;
        }
        else
        {
            // if the range pointers are not in the same markup
            // set ppParent to the slave and find the common parent
            // in the loop below...
            ClearInterface( ppParent );
            hr = THR( pDoc->CurrentScopeOrSlave( pAdjustedLeft, ppParent ) );
            if (hr)
                goto Cleanup;
        }
    }        

    //
    // If we have a current scope and the range is collapsed, return ppParent
    //
    if ( fRangeIsCollapsed )
    {
        hr = S_OK;
        goto Cleanup;
    }

    //
    // Walk the left pointer up until the right end of the element
    // is to the right of _pRight
    //
    while ( *ppParent )
    {
        BOOL fResult;
        
        hr = THR( pCurrent->MoveAdjacentToElement( *ppParent, ELEM_ADJ_AfterEnd ) );
        if (hr)
            goto Cleanup;

        hr = THR( pCurrent->IsLeftOf( _pRight, & fResult ) );

        if (!fResult)
            break; // found common element

        pOldElement = *ppParent;                
        hr = THR( pOldElement->get_parentElement( ppParent ) );
        pOldElement->Release();
        if (hr)
            goto Cleanup;        
        Assert( *ppParent ); // we should never walk up past the root of the tree
    }
    
Cleanup:
    ReleaseInterface( pAdjustedLeft );
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    ReleaseInterface(pCurrent);
    ReleaseInterface(pPointer);
    if (hr)
    {
        ClearInterface( ppParent );
    }

    if ( fBlockBreakAdjustment )
    {
        hr = THR( RightOrSlave( _pRight, TRUE, NULL, NULL, NULL, NULL ) );
    }

    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     Duplicate, IHTMLTxtRange
//
//  Synopsis:   Create a duplicate range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::duplicate ( IHTMLTxtRange * * ppTheClone )
{
    HRESULT hr = S_OK;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    //
    // Create the new range
    //

    hr = THR( GetMarkup()->createTextRange( ppTheClone, _pElemContainer, _pLeft, _pRight, FALSE ) );

    if (hr)
        goto Cleanup;

    Assert( *ppTheClone );

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     InRange, IHTMLTxtRange
//
//  Synopsis:   Determine whether the passed in range in within my range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::inRange ( IHTMLTxtRange * pDispRhs, VARIANT_BOOL * pfInRange )
{
    BOOL         fResult;
    HRESULT      hr = S_OK;   
    CAutoRange * pRangeRhs;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pfInRange || !pDispRhs)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    // Make sure the two ranges belong to the same ped (story)
    //

    hr = THR( pDispRhs->QueryInterface( CLSID_CRange, (void**) & pRangeRhs ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert( pRangeRhs );

    if (GetMarkup() != pRangeRhs->GetMarkup() || !IsCompatibleWith( pDispRhs ))
    {
        *pfInRange = VB_FALSE;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( pRangeRhs->KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    //
    // Now, compare for containment
    // Ranges are ordered left to right, so the following two tests are sufficient
    //
    
    *pfInRange = VB_FALSE; // Assume the result is false

    hr = THR( pRangeRhs->_pLeft->IsLeftOf( _pLeft, & fResult ) );
    if (hr || fResult )
        goto Cleanup;

    hr = THR( _pRight->IsLeftOf( pRangeRhs->_pRight, & fResult ) );
    if (hr || fResult )
        goto Cleanup;

    *pfInRange = VB_TRUE; // Passed the tests so set the result to true

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     IsEqual, IHTMLTxtRange
//
//  Synopsis:   Is the passed in range equal to me?
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::isEqual ( IHTMLTxtRange * pDispRhs, VARIANT_BOOL * pfIsEqual )
{
    BOOL         fResult;
    HRESULT      hr = S_OK;
    CAutoRange * pRangeRhs;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pfIsEqual)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    // Make sure the two ranges belong to the same ped (story)
    //

    hr = THR( pDispRhs->QueryInterface( CLSID_CRange, (void**) & pRangeRhs ) );
    
    if ( hr )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
        
    Assert( pRangeRhs );

    if ( GetMarkup() != pRangeRhs->GetMarkup()  || !IsCompatibleWith( pDispRhs ) )
    {
        *pfIsEqual = VB_FALSE;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( pRangeRhs->KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    //
    // Now, compare the ends
    //

    *pfIsEqual = VB_FALSE; 

    hr = THR( _pLeft->IsEqualTo( pRangeRhs->_pLeft, & fResult ) );
    if (hr || !fResult)
        goto Cleanup;

    hr = THR( _pRight->IsEqualTo( pRangeRhs->_pRight, & fResult ) );
    if (hr || !fResult)
        goto Cleanup;

    *pfIsEqual = VB_TRUE;

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     ScrollIntoView, IHTMLTxtRange
//
//  Synopsis:   Scroll range into view
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::scrollIntoView ( VARIANT_BOOL fStart )
{
    HRESULT     hr = S_OK;
    CTreeNode * pNode;
    SCROLLPIN   sp = fStart ? SP_MINIMAL : SP_BOTTOMRIGHT;
    CMarkupPointer * pRightInternal = NULL;
    CMarkupPointer * pLeftInternal = NULL;
    LONG cpMin, cpMost;
    CFlowLayout* pFlowLayout = NULL;
    
    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Scroll the end of the selection into view
    pNode = RightNode();
    if (! pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    pFlowLayout = pNode->GetFlowLayout();

    Assert( pNode->Element());
    
    if ( pFlowLayout && (
         ( pFlowLayout == pNode->GetUpdatedNearestLayout() ) || 
         ( pNode->Element()->HasMasterPtr() ) ) )
    {
        hr = THR( _pLeft->QueryInterface(CLSID_CMarkupPointer, (void **)&pLeftInternal) );
        if (hr)
            goto Cleanup;

        hr = THR( _pRight->QueryInterface(CLSID_CMarkupPointer, (void **)&pRightInternal) );
        if (hr)
            goto Cleanup;

        // We are only interested in the end of the selection, so cut off the beginning of 
        // range to avoid the ScrollRangeIntoView asserts

        cpMin  = max(pLeftInternal->GetCp(), pFlowLayout->GetContentFirstCp());
        cpMost = pRightInternal->GetCp();
        
        hr = THR( pFlowLayout->ScrollRangeIntoView( cpMin, cpMost, sp, sp ) );
    }
    else
    {
        hr = THR( pNode->Element()->ScrollIntoView() );
    }

Cleanup:
    // S_FALSE can be returned if we were asked to scroll something that didn't have a 
    // display.  this is not an error but there is nothing that needs to be done.
    RRETURN1( SetErrorInfo( hr ), S_FALSE );
}


//+----------------------------------------------------------------------------
//
//  Member:     collapse, IHTMLTxtRange
//
//  Synopsis:   Collapse the range pointers at start or end
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::collapse ( VARIANT_BOOL fStart )
{
    HRESULT hr = S_OK;

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    if  (fStart)
    {
        hr = THR( _pRight->MoveToPointer( _pLeft ) );
    }
    else
    {
        hr = THR( _pLeft->MoveToPointer( _pRight ) );
    }

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     Helper function MoveWithinBoundary
//
//  Synopsis:   Wrapper for CMarkupPointer::MoveUnit() which keeps the passed in 
//              pointer within the range boundary.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::MoveWithinBoundary( IMarkupPointer *pPointerToMove, 
                               MOVEUNIT_ACTION muAction, 
                               IMarkupPointer *pBoundary,
                               BOOL            fLeftBound )
{
    IMarkupPointer *    pPointer = NULL;
    BOOL                fSuccess = FALSE;
    HRESULT             hr;

    hr = THR( 
            GetMarkup()->Doc()->CreateMarkupPointer( & pPointer ) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->MoveUnit( muAction ) );
    if (hr)
        goto Cleanup;
    
    if ( fLeftBound )
    {
        BOOL fResult;
        
        hr = THR( pPointer->IsRightOfOrEqualTo( pBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        // Going left we ended up to the right of the boundry
        if ( fResult )
        {
            fSuccess = TRUE;
        }
    }
    else
    {
        BOOL fResult;
        
        hr = THR( pPointer->IsLeftOfOrEqualTo( pBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        // Going right we ended up to the left of the boundry
        if ( fResult )
        {
            fSuccess = TRUE;
        }
    }

    if ( fSuccess )
    {
        hr = THR( pPointerToMove->MoveToPointer( pPointer ) );
        if (hr)
        {
            fSuccess = FALSE;
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface( pPointer );
    return fSuccess ? S_OK : S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     Expand, IHTMLTxtRange
//
//  Synopsis:   Expands the range by the given unit
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::expand ( BSTR bstrUnit, VARIANT_BOOL * pfSuccess )
{
    HRESULT             hr;
    htmlUnit            Unit;
    IMarkupPointer    * pLeftBoundary  = NULL;
    IMarkupPointer    * pRightBoundary = NULL;
    IMarkupPointer    * pPointer = NULL;
    long                nCountLeft, nCountRight;
    BOOL                fEqual;
    BOOL                fLeftWasAlreadyExpanded = FALSE;
    BOOL                fRightWasAlreadyExpanded = FALSE;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pfSuccess)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pfSuccess = VB_FALSE;

    //
    // Determine what action must take place based on bstrUnit
    //

    hr = ENUMFROMSTRING ( htmlUnit, bstrUnit, (long *)&Unit );
    if ( hr )
        goto Cleanup;

    hr = THR( ValidatePointers() );
    if (hr)
        goto Cleanup;

    switch (Unit)
    {
    case 2: // "Word"
    {

        // Move Left to the beginning of the previous word unless if Left is at beginning of the word already
        // Check End of prev word and compare it to the start of current word
        hr = THR( 
                GetMarkup()->Doc()->CreateMarkupPointer( & pPointer ) );
        if (hr)
            goto Cleanup;

        hr = THR( 
                MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
        if (hr)
            goto Cleanup;

        // 
        // If the left end of the range is at the end of document
        // we cannot expand by a word.
        //
        hr = THR( pPointer->MoveToPointer( _pLeft ) );
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE( MoveWithinBoundary( pPointer, MOVEUNIT_NEXTWORDEND, pRightBoundary, FALSE ) );
        if (hr)
        {
            break;
        }

        //
        // The next two MoveWord() calls will place _pLeft at the beginning of the current word,
        // note that MoveWord() unlike MoveUnit() will account for block breaks, BRs, and boundaries
        //
        hr = THR( pPointer->MoveToPointer( _pLeft ) );
        if (hr)
            goto Cleanup;

        hr = THR( MoveWord( pPointer, MOVEUNIT_NEXTWORDBEGIN, pLeftBoundary, pRightBoundary ) );        
        if (hr)
            goto Cleanup;

        hr = THR( MoveWord( pPointer, MOVEUNIT_PREVWORDBEGIN, pLeftBoundary, pRightBoundary ) );        
        if (hr)
            goto Cleanup;

        hr = THR( pPointer->IsEqualTo( _pLeft, & fEqual ) );
        if ( fEqual )
        {
            fLeftWasAlreadyExpanded = TRUE;
        }
        else
        {
            hr = THR( _pLeft->MoveToPointer( pPointer ) );
            if (hr)
                goto Cleanup;
        }

        //
        // Move _pRight to the beginning of the next word to include trailing spaces.
        // If there are no trailing spaces, move it to the end of the next word.
        // As usual, check for corner cases in the end of the document.
        //

        hr = THR( pPointer->MoveToPointer( _pRight ) );
        if (hr)
            goto Cleanup;

        hr = THR( MoveWord( pPointer, MOVEUNIT_PREVWORDBEGIN, pLeftBoundary, pRightBoundary ) );        
        if (hr)
            goto Cleanup;

        hr = THR( MoveWord( pPointer, MOVEUNIT_NEXTWORDBEGIN, pLeftBoundary, pRightBoundary ) );
        if (hr)
            goto Cleanup;

        hr = THR( pPointer->IsEqualTo( _pRight, & fEqual ) );
        if ( fEqual )
        {
            //
            // pRight is at the end or beginning of a word, if pRight is not equal to pLeft
            // we want to expand the word, otherwise, we're already expanded
            //
            hr = THR( _pLeft->IsEqualTo( _pRight, & fEqual ) );
            if (fEqual)
            {
                hr = THR( MoveWord( _pRight, MOVEUNIT_NEXTWORDBEGIN, pLeftBoundary, pRightBoundary ) );                
                if (hr)
                    goto Cleanup;
            }
            else
            {
                fRightWasAlreadyExpanded = TRUE;
            }
        }
        else
        {
            hr = THR( _pRight->MoveToPointer( pPointer ) );
            if (hr)
                goto Cleanup;
        }
        break;
    
    }

    case 3: // "Sentence"
    {
        nCountRight = 1;
        hr  = MoveUnitWithinRange( _pRight, MOVEUNIT_NEXTSENTENCE, & nCountRight );
        if (hr)
            goto Cleanup;

        if (! nCountRight)
        {
            hr = S_FALSE;
            break;
        }

        hr = THR( _pLeft->MoveToPointer( _pRight ) );
        if (hr)
            goto Cleanup;

        nCountLeft = -1;
        hr  = MoveUnitWithinRange( _pLeft, MOVEUNIT_PREVSENTENCE, & nCountLeft );
        if (hr)
            goto Cleanup;

        hr  = (nCountLeft == -1 && nCountRight == 1) ? S_OK : S_FALSE ;
        break;
    }

    case 1: // "Character"   
    {
        nCountRight = 1;
        hr  = MoveUnitWithinRange( _pRight, MOVEUNIT_NEXTCHAR, & nCountRight );
        if (hr)
            goto Cleanup;

        hr  = (nCountRight == 1) ? S_OK : S_FALSE ;
        break;
    }

    case 6: // "TextEdit"
    {
        //
        // Move range pointers to right/left borders to move by textedit units
        //
        hr = THR( 
                MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
        if (hr)
            goto Cleanup;

        hr = THR( _pRight->MoveToPointer( pRightBoundary ) );
        if (hr)
            goto Cleanup;

        hr = THR( _pLeft->MoveToPointer( pLeftBoundary ) );
        if (hr)
            goto Cleanup;
            
        break;
    }

    default:
        hr = E_NOTIMPL;
        goto Cleanup;
    }
    
    if (hr == S_OK && (!fLeftWasAlreadyExpanded || !fRightWasAlreadyExpanded) )
    {
        *pfSuccess = VB_TRUE;
    }
    else
    {
        *pfSuccess = VB_FALSE;
        hr = S_OK;
    }

Cleanup:
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    ReleaseInterface( pPointer );
    hr = THR( ValidatePointers() );

    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     GetMoveUnitAndType
//
//  Synopsis:   Expands the range by the given unit
//
//-----------------------------------------------------------------------------

HRESULT 
CAutoRange::GetMoveUnitAndType( BSTR bstrUnit, long Count, 
                                MOVEUNIT_ACTION     * pmuAction,
                                htmlUnit            * phtmlUnit )
{
    HRESULT     hr = S_OK;

    hr = THR( ENUMFROMSTRING( htmlUnit, bstrUnit, (long *) phtmlUnit ) );
    if (hr)
        goto Cleanup;

    switch (*phtmlUnit)
    {
    case 2: // "Word"
        if( Count > 0 )
            *pmuAction = MOVEUNIT_NEXTWORDBEGIN;
        else
            *pmuAction = MOVEUNIT_PREVWORDBEGIN;
        *phtmlUnit = htmlUnit_Max;
        break;

    case 3: // "Sentence"
        if( Count > 0 )
            *pmuAction = MOVEUNIT_NEXTSENTENCE;
        else
            *pmuAction = MOVEUNIT_PREVSENTENCE;
        *phtmlUnit = htmlUnit_Max;
        break;

    case 1: // "Character"   
        if( Count > 0 )
            *pmuAction = MOVEUNIT_NEXTCHAR; 
        else
            *pmuAction = MOVEUNIT_PREVCHAR; 
        *phtmlUnit = htmlUnit_Max;
        break;

    case 6: // "TextEdit"
        //
        // Since MoveUnit() does not handle TextEdit, this case does not set
        // pmuType, instead phtmlUnit is set properly and will be used by the caller 
        //
        break;

    default:
        hr = E_NOTIMPL;
        *phtmlUnit = htmlUnit_Max;
        break;
    }

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     moveToPoint, IHTMLTextRange
//
//  Synopsis:   Clips the point to the client rect of the ped, finds the site
//              which was hit by the point, and within that site finds the
//              cp at which the point lies.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::moveToPoint ( long x, long y )
{
    HRESULT        hr = S_OK;        // The return value
    POINT          pt;               // The point
    POINT          ptOrigin;
    CMarkup      * pMarkup;          // The markup for the range
    CElement     * pElementClient;
    CFlowLayout  * pFlowLayout;
    CTreeNode    * pNode;
    CHitTestInfo   hti;
    HITTESTRESULTS htr;
    CDispNode    * pDisp=NULL;
    CLayout      * pElemLayout = NULL;

    DO_SANITY_CHECK;

    x = g_uiDisplay.DeviceFromDocPixelsX(x);
    y = g_uiDisplay.DeviceFromDocPixelsY(y);

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // TODO: (dmitryt. track bug 112264) Need to revisit OM issues for multilayoutness.
    // all calls like this should actually be specifically directed to "active default" layout.
    // $$ktam: don't have layout context for pElementClient

    pMarkup = GetMarkup();
    pElementClient = pMarkup->GetElementClient();
    if (!pElementClient)
        goto Cleanup;

    pElemLayout = pElementClient->GetUpdatedLayout();
    if (!pElemLayout)
        goto Cleanup;

    //
    // Construct the point
    // in the global coordinate system
    //
    pElementClient->GetClientOrigin( &ptOrigin );

    pt.x = ptOrigin.x + x;
    pt.y = ptOrigin.y + y;

    //
    // Clip/Restrict the point to the client rect of the ped
    //
    pElemLayout->RestrictPointToClientRect(&pt);

    //
    // Wait for the ped and its parents to recalc, so that we hit test the right stuff
    //
    pElementClient->GetFlowLayout()->WaitForParentToRecalc(-1, pt.y, NULL);

    //
    // Find the site within the ped which was hit. Note that we cannot call the doc's
    // HitTestPoint() because if there are sites which are hovering above this ped,
    // then we will hit test those sites. We want to hit test within our own layout

    htr._fWantArrow = FALSE;
    htr._fRightOfCp = FALSE;
    htr._cpHit = 0;
    htr._iliHit = 0;
    htr._ichHit = 0;
    htr._cchPreChars = 0;

    hti._grfFlags = HT_VIRTUALHITTEST | HT_HTMLSCOPING;
    hti._htc = HTC_NO;
    hti._pNodeElement = NULL;
    hti._pDispNode = NULL;
    hti._ptContent.x = x;
    hti._ptContent.y = y;
    hti._phtr = &htr;
    hti._pLayoutContext = NULL;
    pDisp = pElemLayout->GetElementDispNode(pElementClient);

    if (!pDisp || !pElemLayout->HitTestContent(&pt, pDisp, &hti, FALSE))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    Assert(hti._htc == HTC_YES);

    //
    // Got the site which was hit. Get the txtsite containing the site (we will always find
    // the ped)> Also be sure that the ped of txtsite we get is the same as the ped of the
    // range. (We could have a text box inside the ped and the point over it -- in this
    // case we do not want the txtsite belonging to the text box. Rather we want the parent
    // text site of the text box).
    //
    // NOTE: (SLAVE_TREE) do we need to iterate through markups? (jbeda)
    pNode = hti._pNodeElement->GetFlowLayoutNode();
    while (pNode->GetMarkup() != pMarkup)
    {
        pNode = pNode->Parent()->GetFlowLayoutNode();
        Assert(pNode);
    }

    pFlowLayout = pNode->HasFlowLayout( hti._pLayoutContext );
    Assert(pFlowLayout);

    //
    // From the display of the textsite we hit, get the cp
    //
    {
        CTreeNode         * pTreeNode =NULL;
        CLayoutContext    * pLayoutContext = NULL;
        POINT               ptContent;
        CMarkupPointer      HitMarkup(pMarkup->Doc());
        BOOL                bNotAtBOL;
        BOOL                bAtLogicalBOL;
        BOOL                bRightOfCp;

        // we need to get from the cp to a markup in order to set _pRight and _pLeft
        // we CAN'T call MoveMarkupToPoint() for these for the same reason that we
        // couldn't call cdoc's HitTestPoint above.
        //-------------------------------------------------------------------------
        // position the markup pointer at the point that we are given
        pTreeNode = pMarkup->Doc()->GetNodeFromPoint( pt, &pLayoutContext, TRUE, &ptContent );
        if( pTreeNode == NULL )
            goto Cleanup;

        // TODO (mikhaill, track bug 112270): This can be incorrect in case of relatively positioned nodes.
        //         I think that following changes shouldd be done:
        //         1) add new variable, CDispNode *pDispnode;
        //         2) pass &pDispnode as 8th argument GetNodeFromPoint();
        //         3) supply MovePointerToPointInternal() with this pDispNode as 13th arg.
        //         See accutil.cxx for example, and bugs 105942, 106131, 109587 fixes.
        //         Not fixed because of improper project stage (mikhaill 5/9/00).
        hr = THR( pMarkup->Doc()->MovePointerToPointInternal( ptContent, 
                                                            pTreeNode,
                                                            pLayoutContext,
                                                            &HitMarkup, 
                                                            &bNotAtBOL,
                                                            &bAtLogicalBOL,
                                                            &bRightOfCp, 
                                                            FALSE,
                                                            pFlowLayout));
        if (hr)
            goto Cleanup;


        hr = THR(SetLeftAndRight(&HitMarkup, &HitMarkup));

    }
Cleanup:

    //
    // MovePointerToPointInternal now returns CTL_E_INVALIDLINE when you attempt to
    // position a markup pointer in a table or TR.  Previously, this was returning
    // E_FAIL.  We want to prop the E_FAIL return code for compat.
    //
    if( hr == CTL_E_INVALIDLINE )
    {
        hr = E_FAIL;
    }

    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     setEndPoint, IHTMLTextRange
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::setEndPoint ( BSTR bstrHow, IHTMLTxtRange * pHTMLRangeSource )
{
    HRESULT hr = S_OK;
    htmlEndPoints how;
    CAutoRange * pRangeSource;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pHTMLRangeSource)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!IsCompatibleWith( pHTMLRangeSource ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( ENUMFROMSTRING( htmlEndPoints, bstrHow, (long *) & how ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        pHTMLRangeSource->QueryInterface(
            CLSID_CRange, (void **) & pRangeSource ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( pRangeSource->KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    switch ( how )
    {
    case htmlEndPointsStartToStart : 
        SetLeft( pRangeSource->_pLeft );
        break;

    case htmlEndPointsStartToEnd :
        SetLeft( pRangeSource->_pRight );
        break;

    case htmlEndPointsEndToStart :
        SetRight( pRangeSource->_pLeft );
        break;

    case htmlEndPointsEndToEnd :
        SetRight( pRangeSource->_pRight );
        break;

    default:
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( ValidatePointers() );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     CompareRangePointers() 
//              helper function for compareEndPoints()
//
//  Synopsis:   Use IE4 compatible comparison for range pointers
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::CompareRangePointers( IMarkupPointer * pPointerSource, IMarkupPointer * pPointerTarget, int * piReturn )
{
    HRESULT     hr;
    BOOL        fLeft;
    CDoc      * pDoc;
    BOOL        fResult;
    CTreeNode * pNode;
    MARKUP_CONTEXT_TYPE context;

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );
    CMarkupPointer  pointer( pDoc );

    hr = THR( OldCompare( pPointerSource, pPointerTarget, piReturn ) );
    if (hr)
        goto Cleanup;

    if ( *piReturn == 0 )
    {
        // If the pointers are equal we're done
        goto Cleanup;
    }

    //
    // If Source is greater than Target, the direction is going to be left to right,
    // otherwise we'll go right to left
    //
    fLeft = ( *piReturn == 1 );

    hr = THR( pointer.MoveToPointer( pPointerSource ) );
    if (hr)
        goto Cleanup;

    //
    // We're going to move  from source to target, if we don't encounter any text, 
    // block or layout when we get to target, the range pointers are equal.
    //

    for ( ; ; )
    {
        if( fLeft )
        {
            hr = THR( pointer.Left( TRUE, & context, & pNode, NULL, NULL, NULL ) );
        }
        else
        {
            hr = THR( pointer.Right( TRUE, & context, & pNode, NULL, NULL, NULL ) );
        }

        if( hr )
            goto Cleanup;

        switch( context )
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
                if( pNode )
                {
                    if ( pNode->ShouldHaveLayout() || pNode->Element()->IsBlockElement() )
                    {
                        goto Cleanup;
                    }
                }
                break;

            case CONTEXT_TYPE_Text:            
            case CONTEXT_TYPE_NoScope:
            case CONTEXT_TYPE_None:
                goto Cleanup;

        }
        
        //
        // Check our situation
        //
        hr = THR( pointer.IsEqualTo( pPointerTarget, & fResult ) );
        if (hr)
            goto Cleanup;

        if ( fResult )
        {
            // We successfully moved from source to target, so consider the 
            // pointers equal, and take us outta here
            *piReturn = 0;
            goto Cleanup;
        }

        //
        // If we've gone past the Target, we're done, otherwise keep looping...
        //
        if (fLeft)
        {
            hr = THR( pointer.IsLeftOf( pPointerTarget, & fResult ) );
            if (hr)
                goto Cleanup;

            if ( fResult )
            {
                goto Cleanup;
            }
        }
        else
        {
            hr = THR( pointer.IsRightOf( pPointerTarget, & fResult ) );
            if (hr)
                goto Cleanup;

            if ( fResult )
            {
                goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN( hr );
}
        

//+----------------------------------------------------------------------------
//
//  Member:     compareEndPoints, IHTMLTextRange
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::compareEndPoints (
    BSTR bstrHow, IHTMLTxtRange * pHTMLRangeSource, long * pReturn )
{
    HRESULT         hr = S_OK;
    htmlEndPoints   how;
    CAutoRange *    pRangeSource;
    int             iReturn;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pHTMLRangeSource || !pReturn)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!IsCompatibleWith( pHTMLRangeSource ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pReturn = 0;

    hr = THR( ENUMFROMSTRING( htmlEndPoints, bstrHow, (long *) & how ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        pHTMLRangeSource->QueryInterface(
            CLSID_CRange, (void **) & pRangeSource ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( pRangeSource->KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    switch ( how )
    {
    case htmlEndPointsStartToStart :
        hr = THR( CompareRangePointers( _pLeft, pRangeSource->_pLeft, & iReturn ) );
        break;

    case htmlEndPointsStartToEnd :
        hr = THR( CompareRangePointers( _pLeft, pRangeSource->_pRight, & iReturn ) );
        break;

    case htmlEndPointsEndToStart :
        hr = THR( CompareRangePointers( _pRight, pRangeSource->_pLeft, & iReturn ) );
        break;

    case htmlEndPointsEndToEnd :
        hr = THR( CompareRangePointers( _pRight, pRangeSource->_pRight, & iReturn ) );
        break;

    default:
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *pReturn = iReturn;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member: CAutoRange::getBookmark
//
//  Synopsis: Passes through to its markup pointers, asking them for a
//            bookmark representing this range.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::getBookmark ( BSTR * pbstrBookmark )
{
    HRESULT hr = S_OK;
    CMarkupPointer * pLeft, * pRight;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pLeft ) );

    if (hr)
        goto Cleanup;

    hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pRight ) );

    if (hr)
        goto Cleanup;

    hr = THR( pLeft->GetBookmark( pbstrBookmark, pRight ) );

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member: CAutoRange::moveToBookmark
//
//  Synopsis: Passes through to its markup pointers, asking them to position
//            themselves at this bookmark
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::moveToBookmark ( BSTR bstrBookmark, VARIANT_BOOL * pvbSuccess )
{
    HRESULT hr = S_OK;
    CMarkupPointer * pLeft, * pRight;

    DO_SANITY_CHECK

    Assert( pvbSuccess );
    *pvbSuccess = VB_FALSE;

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pLeft ) );

    if (hr)
        goto Cleanup;

    hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pRight ) );

    if (hr)
        goto Cleanup;

    
    hr = THR( pLeft->MoveToBookmark( bstrBookmark, pRight ) );
    
    if( S_OK == hr )
    {
        *pvbSuccess = TRUE;
    }
    else if( S_FALSE == hr )
    {
        // S_FALSE means we didn't find the bookmark, but that's not an error.
        hr = S_OK;
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     moveToElementText, IHTMLTxtIRange
//
//  Synopsis:   move the range to encompass an element
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::moveToElementText ( IHTMLElement * element )
{
    HRESULT hr = S_OK;
    CElement * pElement;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!element)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( element->QueryInterface( CLSID_CElement, (void **) & pElement ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    hr = THR( SetTextRangeToElement( pElement ) );

    if (hr == S_FALSE)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     IsTextInCompatiblePlace, Helper function
//
//  Synopsis:   If text found using findText() is within an OPTION tag, IE4 would
//              not have found it, used for IE4 compat.
//
//-----------------------------------------------------------------------------

BOOL
CAutoRange::IsTextInCompatiblePlace( IMarkupPointer * pmpLeft, IMarkupPointer * pmpRight )
{
    ELEMENT_TAG     eTag;
    CTreeNode *     pNode;
    CMarkupPointer* pmp = NULL;

    IGNORE_HR( pmpLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pmp ) );
    Assert( pmp );

    pNode = pmp->CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode)
        return FALSE;
    eTag = pNode->Tag();    
    if (eTag == ETAG_OPTION)
        return FALSE;   

    IGNORE_HR( pmpRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pmp ) );
    
    Assert( pmp );

    pNode = pmp->CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode)
        return FALSE;
    eTag = pNode->Tag();    
    if (eTag == ETAG_OPTION)
        return FALSE;
    
    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Member:     findText, IHTMLTxtIRange
//
//  Synopsis:   findText within range boundaries
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::findText ( BSTR String, long count, long Flags, VARIANT_BOOL * pfSuccess )
{
    HRESULT          hr = S_OK;
    IMarkupPointer * pLeftBoundary = NULL;
    IMarkupPointer * pRightBoundary = NULL;
    IMarkupPointer * pmpLeft = NULL;
    IMarkupPointer * pmpRight = NULL;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // are all the required parameters provided
    if (!String || !pfSuccess)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // did we actually get a searchstring with text in it
    if (!SysStringLen( String ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    //
    // Position two temporary pointers that will be used for finding text
    //
    hr = THR( 
            GetMarkup()->Doc()->CreateMarkupPointer( & pmpLeft ) );
    if (hr) 
        goto Cleanup;

    hr = THR( 
            GetMarkup()->Doc()->CreateMarkupPointer( & pmpRight ) );
    if (hr) 
        goto Cleanup;

    hr = THR( 
            pmpLeft->MoveToPointer( _pLeft ) );
    if (hr)
        goto Cleanup;

    hr = THR( 
            pmpRight->MoveToPointer( _pRight ) );
    if (hr)
        goto Cleanup;

    //
    // Position the range boundry pointers
    //
    hr = THR( 
            MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
    if (hr)
        goto Cleanup;

    //
    // Call FindText(), for compat reasons we do not want to find text inside an OPTION
    //

    if (count == 0)
    {
        hr = THR( pmpLeft->FindText( String, Flags, pmpRight, pmpRight ) );

        if (hr == S_FALSE)
        {
            hr = S_OK;
            *pfSuccess = VB_FALSE;
            goto Cleanup;
        }

        goto FoundIt;
    }
        
    if ( count < 0 )
        Flags = Flags | FINDTEXT_BACKWARDS;

    for ( ; ; )
    {
        if ( Flags & FINDTEXT_BACKWARDS ) 
        {
            hr = THR( pmpRight->FindText( String, Flags, pmpLeft, pLeftBoundary ) );
        }
        else
        {            
            hr = THR( pmpLeft->FindText( String, Flags, pmpRight, pRightBoundary ) );
        }

        if (hr == S_FALSE)
        {
            // not found
            hr = S_OK;
            *pfSuccess = VB_FALSE;
            goto Cleanup;
        }

        if (hr)
            goto Cleanup;

        if ( IsTextInCompatiblePlace( pmpLeft, pmpRight ) )
            goto FoundIt;

        long cch = 1;
            
        if ( Flags & FINDTEXT_BACKWARDS ) 
            IGNORE_HR( LeftOrSlave( pmpRight, TRUE, NULL, NULL, & cch, NULL ));
        else
            IGNORE_HR( RightOrSlave( pmpLeft, TRUE, NULL, NULL, & cch, NULL ));
    }

Cleanup:
    
    ReleaseInterface( pmpLeft );
    ReleaseInterface( pmpRight );
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    
    RRETURN( SetErrorInfo( hr ) );

FoundIt:
    
    *pfSuccess = VB_TRUE;
    
    IGNORE_HR( _pLeft->MoveToPointer( pmpLeft ) );
    IGNORE_HR( _pRight->MoveToPointer( pmpRight ) );
    
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Member:     MoveStart, IHTMLTxtRange
//
//  Synopsis:   move the left end of the range per parameters passed
//
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CAutoRange::moveStart ( BSTR bstrUnit, long Count, long * pActualCount )
{
    return THR( moveRange( bstrUnit, Count, pActualCount, MOVERANGE_Left ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     MoveEnd, IHTMLTxtRange
//
//  Synopsis:   move the right end of the range per parameters passed
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::moveEnd ( BSTR bstrUnit, long Count, long * pActualCount )
{
    return THR( moveRange( bstrUnit, Count, pActualCount, MOVERANGE_Right ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     Move, TxtIRange
//
//  Synopsis:   move the left end of the range per parameters passed, 
//              and collapse the range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::move ( BSTR bstrUnit, long Count, long * pActualCount )
{
    return THR( moveRange( bstrUnit, Count, pActualCount, MOVERANGE_Both ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     MovePointersToRangeBoundary 
//
//  Synopsis:   Position pointers around the boundry of _pElemContainer
//
//-----------------------------------------------------------------------------
HRESULT
CAutoRange::MovePointersToRangeBoundary ( IMarkupPointer ** ppLeftBoundary,
                                          IMarkupPointer ** ppRightBoundary )
{
    HRESULT             hr = S_OK;
    IHTMLElement      * pHTMLElement = NULL; 
    CDoc              * pDoc = NULL;
    CMarkup           * pMarkup = NULL;
    //
    // Set the left and right borders around _pElemContainer. 
    // Range pointers shall not move outside these boundries or else...
    // 
    if (! _pElemContainer)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR_NOTRACE( 
            _pElemContainer->QueryInterface( IID_IHTMLElement, (void **) & pHTMLElement ) );
    if (hr)
        goto Cleanup;
    
    pMarkup = GetMarkup();     
    pDoc = pMarkup->Doc();

    Assert( pMarkup );
    Assert( pDoc );

    hr = THR( pDoc->CreateMarkupPointer( ppLeftBoundary ) );
    if (hr)
        goto Cleanup;

    hr = THR( pDoc->CreateMarkupPointer( ppRightBoundary ) );
    if (hr)
        goto Cleanup;

    hr = THR( (*ppLeftBoundary)->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_AfterBegin ) );
    if (hr)
        goto Cleanup;

    hr = THR( (*ppRightBoundary)->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_BeforeEnd ) );
    if (hr)
        goto Cleanup;

    //
    // Make sure the bounderies cling to text, just like the
    // range pointers do
    //

    hr = THR( AdjustPointers( *ppLeftBoundary, *ppRightBoundary ));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface( pHTMLElement );
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     MoveCharacter
//
//  Synopsis:   Move the range by a single character according to IE4 rules
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::MoveCharacter ( IMarkupPointer * pPointerToMove,
                            MOVEUNIT_ACTION  muAction,
                            IMarkupPointer * pLeftBoundary,
                            IMarkupPointer * pRightBoundary,
                            IMarkupPointer * pJustBefore )
{
    HRESULT hr;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    CTreeNode       *   pNode;
    CDoc            *   pDoc = GetMarkup()->Doc();
    DWORD               dwBreaks;
    IHTMLElement    *   pIElement = NULL;
    CMarkupPointer      pointerSource( pDoc );
    BOOL                fResult;

    extern BOOL IsIntrinsicTag( ELEMENT_TAG eTag );

    Assert ( muAction == MOVEUNIT_PREVCHAR ||  muAction == MOVEUNIT_NEXTCHAR );

    hr = THR( pointerSource.MoveToPointer( pPointerToMove ) );
    
    if (hr)
        goto Cleanup;

    if (pJustBefore)
    {
        hr = THR( pJustBefore->MoveToPointer( & pointerSource ) );

        if (hr)
            goto Cleanup;
    }

    //
    // If we are starting out at a block break
    //
    
    if (muAction == MOVEUNIT_NEXTCHAR)
    {
        hr = THR( pointerSource.QueryBreaks( & dwBreaks ) );
        
        if (hr)
            goto Cleanup;
            
        if (dwBreaks != BREAK_NONE)
        {
            hr = THR( pointerSource.Right( TRUE, NULL, NULL, NULL, NULL ) );

            if (hr)
                goto Cleanup;

            goto MoveIt;
        }
    }
    
    //
    // Walk pointerSource in the right direction, looking
    // for IE4 compatible text
    //    

    for ( ; ; )
    {
        long cch = 1;
        
        if (pJustBefore)
        {
            hr = THR( pJustBefore->MoveToPointer( & pointerSource ) );

            if (hr)
                goto Cleanup;
        }

        if (muAction == MOVEUNIT_PREVCHAR)
        {
            hr = THR( pointerSource.Left( TRUE, & context, & pNode , & cch, NULL, NULL ));

            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR( pointerSource.Right( TRUE, & context, & pNode , & cch, NULL, NULL ));
            
            if (hr)
                goto Cleanup;
        }

        switch( context )
        {
        //
        // Nowhere to go - we bail.
        //
            
        case CONTEXT_TYPE_None:
        case CONTEXT_TYPE_Text:
            goto MoveIt;

        case CONTEXT_TYPE_NoScope:

            if ( pNode->Tag() == ETAG_BR      ||
                 pNode->Tag() == ETAG_SCRIPT  ||
                 pNode->Element()->ShouldHaveLayout() )
            {
                // Per IE4, if we pass a BR, SCRIPT or noscope with a layout 
                // before hitting text, then we're done. 
                goto MoveIt;
            }
            break;

        case CONTEXT_TYPE_EnterScope:
        case CONTEXT_TYPE_ExitScope:
            
            Assert( pNode );

            if (IsIntrinsicTag( pNode->Tag() ))
            {
                // Move over intrinsics (e.g. <BUTTON>), don't go inside them like MoveUnit() does.
                // Here the passed in pointer is set before or after the intrinsic based
                // on our direction and whether or not we've traveled over text before.
                
                ClearInterface( & pIElement );
                
                hr = THR( pNode->Element()->QueryInterface( IID_IHTMLElement, (void **) & pIElement ) );
                
                if (hr)
                    goto Cleanup;

                if ( muAction == MOVEUNIT_NEXTCHAR )
                    hr = THR( pointerSource.MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ) );
                else
                    hr = THR( pointerSource.MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ) );
                
                goto MoveIt;
            }
            
            break;            
        }

        //
        // Check whether we have hit a break before reaching text
        //
        
        hr = THR( pointerSource.QueryBreaks( & dwBreaks ) );
        
        if (hr)
            goto Cleanup;

        if (dwBreaks != BREAK_NONE)
        {
            // If I hit a break while going right, I want to be after the break
            // going left however, I want to stop right where I am.
            //
            
            if (muAction == MOVEUNIT_NEXTCHAR)
            {
                long cch = 1;
                
                hr = THR( pointerSource.Right( TRUE, & context, & pNode , &cch, NULL, NULL ));
                
                if (hr)
                    goto Cleanup;
            }

            goto MoveIt;
        }

    }

Cleanup:
    
    ReleaseInterface( pIElement );
    
    RRETURN( hr );
    
MoveIt:

    fResult = FALSE;

    if (muAction == MOVEUNIT_PREVCHAR)
    {
        hr = THR( pointerSource.IsLeftOf( pLeftBoundary, & fResult ) );

        if (hr)
            goto Cleanup;

        if (fResult)
        {
            hr = THR( pointerSource.MoveToPointer( pLeftBoundary ) );

            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = THR( pointerSource.IsRightOf( pRightBoundary, & fResult ) );

        if (hr)
            goto Cleanup;

        if (fResult)
        {
            hr = THR( pointerSource.MoveToPointer( pRightBoundary ) );

            if (hr)
                goto Cleanup;
        }
    }
    
    if (fResult && pJustBefore)
    {
        hr = THR( pJustBefore->MoveToPointer( & pointerSource ) );

        if (hr)
            goto Cleanup;
    }

    hr = THR( pPointerToMove->MoveToPointer( & pointerSource ) );
    
    if (hr)
        goto Cleanup;

    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Member:     MoveWord
//
//  Synopsis:   MoveWord() is a wrapper for MoveUnit(). It stops at IE4 word breaks
//              that MoveUnit() ignores such as:
//              <BR>, Block Break, TSB, TSE, and Intrinsics 
//              The only muActions supported are MOVEUNIT_PREVWORDBEGIN and 
//              MOVEUNIT_NEXTWORDBEGIN
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::MoveWord ( IMarkupPointer * pPointerToMove,
                       MOVEUNIT_ACTION  muAction,
                       IMarkupPointer * pLeftBoundary,
                       IMarkupPointer * pRightBoundary )
{
    HRESULT hr;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    CTreeNode       *   pNode;
    CDoc            *   pDoc;
    DWORD               dwBreaks;
    BOOL                fResult;
    BOOL                fPassedText;
    BOOL                fPassedBlock;
    IHTMLElement    *   pIElement = NULL;

    extern BOOL IsIntrinsicTag( ELEMENT_TAG eTag );

    Assert ( muAction == MOVEUNIT_PREVWORDBEGIN || 
             muAction == MOVEUNIT_NEXTWORDBEGIN );

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );

    //
    // pPointerDestination is where MoveUnit() would have positioned us, however, 
    // since MoveUnit() does not account for IE4 word breaks like intrinsics,
    // Block Breaks, text site begin/ends, and Line breaks, we use another pointer
    // called pPointerSource. This pointer walks towards pPointerDestination
    // to detect IE4 word breaking characters that MoveUnit() does not catch.
    //
    CMarkupPointer  pointerSource( pDoc );
    CMarkupPointer  pointerDestination( pDoc );

    hr = THR( 
            pointerSource.MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    hr = THR( 
            pointerDestination.MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    hr = THR(
            pointerDestination.MoveUnit( muAction ) );
    if (hr)
        goto Cleanup;

    //
    // MoveUnit() may place the destination outside the range boundary. 
    // First make sure that the destination is within range boundaries.
    //
    if ( muAction == MOVEUNIT_PREVWORDBEGIN )
    {
        hr = THR( pointerDestination.IsLeftOf( pLeftBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        if ( fResult )
        {
            hr = THR( pointerDestination.MoveToPointer( pLeftBoundary ) );
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = THR( pointerDestination.IsRightOf( pRightBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        if ( fResult )
        {
            hr = THR( pointerDestination.MoveToPointer( pRightBoundary ) );
            if (hr)
                goto Cleanup;
        }
    }

    //
    // Walk pointerSource towards pointerDestination, looking
    // for word breaks that MoveUnit() might have missed.
    //
    
    fPassedText = FALSE;
    fPassedBlock = FALSE;

    for ( ; ; )
    {
        if ( muAction == MOVEUNIT_PREVWORDBEGIN )
        {
            hr = THR( pointerSource.Left( TRUE, & context, & pNode , NULL, NULL, NULL ));
        }
        else
        {
            hr = THR( pointerSource.Right( TRUE, & context, & pNode , NULL, NULL, NULL ));
        }
        if ( hr )
            goto Cleanup;

        switch( context )
        {
        case CONTEXT_TYPE_None:
            break;
            
        case CONTEXT_TYPE_Text:
            fPassedText = TRUE;
            break;

        case CONTEXT_TYPE_NoScope:
        case CONTEXT_TYPE_EnterScope:
        case CONTEXT_TYPE_ExitScope:
            if ( !pNode )
                break;

            if ( IsIntrinsicTag( pNode->Tag() ) )
            {
                // Move over intrinsics (e.g. <BUTTON>), don't go inside them like MoveUnit() does.
                // Here the passed in pointer is set before or after the intrinsic based
                // on our direction and whether or not we've travelled over text before.
                ClearInterface( & pIElement );
                hr = THR( pNode->Element()->QueryInterface( IID_IHTMLElement, (void **) & pIElement ) );
                if (hr)
                    goto Cleanup;

                if ( muAction == MOVEUNIT_NEXTWORDBEGIN )
                {
                    hr = THR( pPointerToMove->MoveAdjacentToElement( pIElement, 
                                fPassedText ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ) );
                }
                else
                {
                    hr = THR( pPointerToMove->MoveAdjacentToElement( pIElement, 
                                fPassedText ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ) );
                }
                //
                // We're done
                //
                goto Cleanup;
            }

            
            // <BR> is a word break 
            if ( pNode->Tag() == ETAG_BR )
            {
                if ( (fPassedText || fPassedBlock) && muAction == MOVEUNIT_NEXTWORDBEGIN )
                {
                    // If we're travelling right and have passed some text, backup
                    // before the last BR, we've gone too far.
                    hr = THR( pointerSource.Left( TRUE, NULL, NULL, NULL, NULL, NULL ));
                    goto Done;
                }
                else if ( muAction == MOVEUNIT_PREVWORDBEGIN )
                {
                    // Travelling left we are at the right place: we're at the beginning of <BR>
                    // which is a valid word break.
                    goto Done;
                }                 
                else
                {
                    fPassedText = TRUE;
                }           
            }
            else if (pNode->Element()->ShouldHaveLayout()
                     || context == CONTEXT_TYPE_NoScope)
            {
                fPassedText = TRUE;
            }
            else if ( pNode->Element()->IsBlockElement() )
            {
                fPassedBlock = TRUE;
            }
            break;
            
        }

        //
        // If we are at or beyond the destination point where MoveUnit() took us, 
        // set the passed in pointer to the destination and we're outta here
        //
        if ( muAction == MOVEUNIT_PREVWORDBEGIN )
        {            
            if ( pointerSource.IsLeftOfOrEqualTo( & pointerDestination ) )
            {                
                hr = THR( 
                        pPointerToMove->MoveToPointer( & pointerDestination ) );
                goto Cleanup;
            }
        }
        else
        {
            if ( pointerSource.IsRightOfOrEqualTo( & pointerDestination ) )
            {                
                hr = THR( 
                        pPointerToMove->MoveToPointer( & pointerDestination ) );
                goto Cleanup;
            }
        }

        //
        // Detect Block break, Text site begin or text site end
        //
        hr = THR( pointerSource.QueryBreaks( & dwBreaks ) );
        if (hr)
            goto Cleanup;

        // We hit a break before reaching our destination, time to stop...
        if ( dwBreaks != BREAK_NONE )
        {
            if (fPassedText || fPassedBlock)
            {
                // We're done
                goto Done;
            }
            else
            {
                fPassedText = TRUE;
            }
        }
    }

Done:
    hr = THR( 
            pPointerToMove->MoveToPointer( & pointerSource ) );
    if (hr)
        goto Cleanup;
    
Cleanup:
    ReleaseInterface( pIElement );
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     MoveUnitWithinRange
//
//  Synopsis:   Helper function for moveRange, watches MoveUnit() to ensure 
//              that range pointers don't go outside the range boundaries
//
//-----------------------------------------------------------------------------

HRESULT 
CAutoRange::MoveUnitWithinRange( IMarkupPointer * pPointerToMove, 
                                 MOVEUNIT_ACTION  muAction,
                                 long * pnActualCount )
{
    HRESULT hr = S_OK;
    long    nRequestedCount;
    BOOL    fLeftBound;
    long    i;
    IMarkupPointer * pPointer = NULL;
    IMarkupPointer * pLeftBoundary = NULL;
    IMarkupPointer * pRightBoundary = NULL;
    BOOL             fEqual;
    
    fLeftBound = ( (*pnActualCount) < 0 );
    nRequestedCount = abs(*pnActualCount);
    *pnActualCount = 0;

    hr = THR( 
            GetMarkup()->Doc()->CreateMarkupPointer( & pPointer ) );
    if (hr) 
        goto Cleanup;

    hr = THR( 
            pPointer->MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    hr = THR( 
            MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
    if (hr)
        goto Cleanup;

    //
    // Bail if we are at range boundaries and we're going the wrong way
    //
    if (fLeftBound)
    {
        IGNORE_HR( 
                pPointer->IsEqualTo( pLeftBoundary, & fEqual ) );

        if ( fEqual )
        {
            goto Cleanup;
        }
    }
    else
    {
        IGNORE_HR( 
                pPointer->IsEqualTo( pRightBoundary, & fEqual ) );

        if ( fEqual )
        {
            goto Cleanup;
        }
    }
  
    //
    // Do the move...
    //

    for ( i=1; i <= nRequestedCount; i++ )
    {      
        if ( muAction == MOVEUNIT_NEXTCHAR ||
             muAction == MOVEUNIT_PREVCHAR )
        {
            MARKUP_CONTEXT_TYPE context;
            
            // Look left for text.  If we find text, skip over it with
            // Left/Right instead of MoveCharacter.
            //
            if (fLeftBound)
                hr = THR(LeftOrSlave(pPointer, FALSE, &context, NULL, NULL, NULL));
            else
                hr = THR(RightOrSlave(pPointer, FALSE, &context, NULL, NULL, NULL));
            if (FAILED(hr))
                goto Cleanup;
                
            if (context == CONTEXT_TYPE_Text)
            {
                LONG cCharactersLeft = nRequestedCount - i + 1;

                if (fLeftBound)
                    hr = THR(LeftOrSlave( pPointer, TRUE, NULL, NULL, &cCharactersLeft, NULL));
                else
                    hr = THR(RightOrSlave(pPointer, TRUE, NULL, NULL, &cCharactersLeft, NULL));
                if (FAILED(hr))
                    goto Cleanup;

                if (cCharactersLeft > 0)
                {
                    i += (cCharactersLeft - 1);                
                }
                else
                {
                    hr = THR( MoveCharacter( pPointer, muAction, pLeftBoundary, pRightBoundary ) );
                }
            }
            else
            {           
                hr = THR( MoveCharacter( pPointer, muAction, pLeftBoundary, pRightBoundary ) );
            }
        }
        else if ( muAction == MOVEUNIT_NEXTWORDBEGIN ||
                  muAction == MOVEUNIT_PREVWORDBEGIN )
        {
            hr = THR( 
                    MoveWord( pPointer, muAction, pLeftBoundary, pRightBoundary ) );
        }
        else
        {
            hr = THR( pPointer->MoveUnit( muAction ) );
        }
        
        if (hr)
        {
            if (hr == S_FALSE)
            {
                hr = S_OK;
            }
            break;
        }

        //
        // Update the count of movements made and 
        // check to see if we are within range boundaries
        //
        if (fLeftBound)
        {            
            (*pnActualCount) = -1*i;

            IGNORE_HR( pPointer->IsLeftOfOrEqualTo( pLeftBoundary, & fEqual ) );
            
            if ( fEqual )
            {
                hr = THR( 
                       pPointerToMove->MoveToPointer( pLeftBoundary ) );
                if (hr)
                    goto Cleanup;

                // We're Done
                break;
            }            
        }
        else
        {    
            (*pnActualCount) = i;

            IGNORE_HR( pPointer->IsRightOfOrEqualTo( pRightBoundary, & fEqual ) );

            if ( fEqual )
            {
                hr = THR( 
                       pPointerToMove->MoveToPointer( pRightBoundary ) );
                if (hr)
                    goto Cleanup;

                // We're Done
                break;
            }            
        }

        hr = THR( 
               pPointerToMove->MoveToPointer( pPointer ) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface( pPointer );
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     moveRange
//
//  Synopsis:   private method that implements move(), moveStart() and moveEnd()
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::moveRange ( BSTR bstrUnit, long Count, long * pActualCount, int moveWhat )
{
    HRESULT hr;
    MOVEUNIT_ACTION     muAction;
    htmlUnit            Unit;
    IMarkupPointer    * pLeftBoundary  = NULL;
    IMarkupPointer    * pRightBoundary = NULL;
    BOOL                fEqual;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pActualCount)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    // Initialize actual count value to zero
    //
    *pActualCount = 0;

    if (! _pElemContainer)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Make sure the range is positioned correctly
    //
    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    //
    // Determine what action must take place based on the bstrUnit
    //
    hr = THR( GetMoveUnitAndType( bstrUnit, Count, & muAction, & Unit ) );
    if (hr)
        goto Cleanup;

    if ( Unit != htmlUnitTextEdit )
    {
        // Use MoveUnit() to move by Character, Word, or Sentence

        Assert( Unit == htmlUnit_Max );

        *pActualCount = Count;

        if (moveWhat == MOVERANGE_Right)
        {
            hr = THR( 
                    MoveUnitWithinRange( _pRight, muAction, pActualCount ) );
        }
        else
        {
            hr = THR( 
                    MoveUnitWithinRange( _pLeft, muAction, pActualCount ) );
        }
                                 
    }
    else
    {
        //
        // Move range pointers to right/left borders to move by textedit units
        //

        if (Count == 0 || Count < -1 || Count > 1)
        {
            // Can only move textedit by -1 or 1 units
            hr = S_OK;
            goto Cleanup;
        }

        //
        // Position the left/right boundry pointers around _pElemContainer
        //
        hr = THR(
                MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
        if (hr)
            goto Cleanup;

        //
        // Move the pointers according to the values passed
        // Note that if the pointer is already where
        // it is asked to go, we don't do anything. ActualCount of
        // zero is returned in such cases to be compatible with IE4
        //
        if (Count == 1)
        {
            if (moveWhat == MOVERANGE_Right)
            {
                hr = THR( _pRight->IsEqualTo( pRightBoundary, &fEqual ) );
                if (hr || fEqual)
                    goto Cleanup;

                hr = THR( _pRight->MoveToPointer( pRightBoundary ) );
                if (hr)
                    goto Cleanup;
            }
            else
            {
                hr = THR( _pLeft->IsEqualTo( pRightBoundary, &fEqual ) );
                if (hr || fEqual)
                    goto Cleanup;

                hr = THR( _pLeft->MoveToPointer( pRightBoundary ) );
                if (hr)
                    goto Cleanup;
            }
        }
        else
        {
            Assert( Count == -1 );

            if (moveWhat == MOVERANGE_Right)
            {
                hr = THR( _pRight->IsEqualTo( pLeftBoundary, &fEqual ) );
                if (hr || fEqual)
                    goto Cleanup;

                hr = THR( _pRight->MoveToPointer( pLeftBoundary ) );
                if (hr)
                    goto Cleanup;
            }
            else
            {
                hr = THR( _pLeft->IsEqualTo( pLeftBoundary, &fEqual ) );
                if (hr || fEqual)
                    goto Cleanup;

                hr = THR( _pLeft->MoveToPointer( pLeftBoundary ) );
                if (hr)
                    goto Cleanup;
            }            
        }
        //
        // Oh, yes don't forget to set pActualCount for textedit move
        //
        *pActualCount = Count;
    }
    
    //
    // Here we collapse the range according to IE4 behavior:
    // move() must always collapse at the Start (left)
    // moveStart and moveEnd collapse the range at start or end
    // respectively, only if start is after the end
    // 
    if (moveWhat == MOVERANGE_Both)
    {
        // Collapse the range for move()
        hr = THR( _pRight->MoveToPointer( _pLeft ) );
        if (hr)
            goto Cleanup;
    }
    else
    {
        int result;
        
        IGNORE_HR( _pLeft->IsRightOf( _pRight, & result ) );
        
        if (result)
        {
            if (moveWhat == MOVERANGE_Left)
            {
                // Collpase the range at the start for MOVERANGE_Left
                hr = THR( _pRight->MoveToPointer( _pLeft ) );
                if (hr)
                    goto Cleanup;
            }
            else 
            {
                // Collapse the range at the end for MOVERANGE_Right case
                hr = THR( _pLeft->MoveToPointer( _pRight ) );
                if (hr)
                    goto Cleanup;
            }
        }
    }

    hr = THR( ValidatePointers() );

    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    RRETURN( SetErrorInfo( hr ) );
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandSupported
//
//  Synopsis:
//
//  Returns: returns true if given command (like bold) is supported
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandSupported(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandSupported(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandEnabled
//
//  Synopsis:
//
//  Returns: returns true if given command is currently enabled. For toolbar
//          buttons not being enabled means being grayed.
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandEnabled(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandEnabled(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandState
//
//  Synopsis:
//
//  Returns: returns true if given command is on. For toolbar buttons this
//          means being down. Note that a command button can be disabled
//          and also be down.
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandState(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandState(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandIndeterm
//
//  Synopsis:
//
//  Returns: returns true if given command is in indetermined state.
//          If this value is TRUE the value returnd by queryCommandState
//          should be ignored.
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandIndeterm(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandIndeterm(bstrCmdId, pfRet));
}



//+---------------------------------------------------------------------------
//
//  Member:     queryCommandText
//
//  Synopsis:
//
//  Returns: Returns the text that describes the command (eg bold)
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandText(BSTR bstrCmdId, BSTR *pcmdText)
{
    RRETURN(CBase::queryCommandText(bstrCmdId, pcmdText));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandValue
//
//  Synopsis:
//
//  Returns: Returns the  command value like font name or size.
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandValue(BSTR bstrCmdId, VARIANT *pvarRet)
{
    RRETURN(CBase::queryCommandValue(bstrCmdId, pvarRet));
}


//+----------------------------------------------------------------------------
//
//  Member:     execCmd, IHTMLTxtRange
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::execCommand(BSTR bstrCmdId, VARIANT_BOOL showUI, VARIANT varValue, VARIANT_BOOL * pfRet )
{
    HRESULT hr = S_OK;
    BOOL fAllow;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Check for security violations

    hr = THR(GetMarkup()->AllowClipboardAccess(bstrCmdId, &fAllow));
    if (hr || !fAllow)
        goto Cleanup;           // Fail silently

    if (!CheckSecurity((LPCWSTR) bstrCmdId))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(CBase::execCommand(bstrCmdId, showUI, varValue));
    if(hr)
        goto Cleanup;

    hr = THR( ValidatePointers() );

    if (hr)
        goto Cleanup;

Cleanup:

    if(pfRet != NULL)
    {
        // We return false when any error occures
        *pfRet = hr ? VB_FALSE : VB_TRUE;
        hr = S_OK;
    }

    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Member:     CheckSecurity
//
//  Synopsis:   Check for things like paste into File Input or Copy from Password
//
//-----------------------------------------------------------------------------
BOOL
CAutoRange::CheckSecurity(LPCWSTR pszCmdId)
{
    BOOL                fPaste = FALSE;
    BOOL                fCopy = FALSE;
    BOOL                fOk = TRUE;
    HRESULT             hr = S_OK;
    CMarkupPointer    * pointerLeft;
    CMarkupPointer    * pointerRight;
    CElement          * pElement;
    htmlInput           type;

    if (StrCmpICW(pszCmdId, L"paste") == 0)
        fPaste = TRUE;
    else if (StrCmpICW(pszCmdId, L"copy") == 0)
        fCopy = TRUE;
    else
        goto Cleanup;       // Nothing to do here

    // Get the element to check for being in an Input element
    hr = THR( _pLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pointerLeft ) );
    if( hr )
        goto Cleanup;

    hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pointerRight ) );
    if( hr )
        goto Cleanup;

    if ( pointerLeft->Markup() == pointerRight->Markup() )
    {
        // If both pointers are in the same markup, return the master
        CTreeNode * pNode = pointerLeft->Branch();
        
        pElement = (pNode && pNode->Element()->HasMasterPtr()) ? pNode->Element()->GetMasterPtr() : NULL;
        if ( !pElement || (pElement->Tag() != ETAG_INPUT))
            goto Cleanup;

        type = DYNCAST(CInput, pElement)->GetType();

        if (type == htmlInputFile)
            fOk = FALSE;
    }

Cleanup:
    if (S_OK != hr)
        fOk = FALSE;
    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     execCommandShowHelp
//
//  Synopsis:
//
//  Returns:
//----------------------------------------------------------------------------

HRESULT
CAutoRange::execCommandShowHelp(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT   hr;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(CBase::execCommandShowHelp(bstrCmdId));

Cleanup:

    if(pfRet != NULL)
    {
        // We return false when any error occures
        *pfRet = hr ? VB_FALSE : VB_TRUE;
        hr = S_OK;
    }

    RRETURN(SetErrorInfo(hr));
}




//+----------------------------------------------------------------------------
//
//  Member:     select, IAutoRange
//
//  Synopsis:   take the given range (this), goto the markups selection and set it
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::select ( )
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup  = GetMarkup();
    CDoc *      pDoc = NULL;     
    SELECTION_TYPE eSelType  = SELECTION_TYPE_Text;
    BOOL fEqual = FALSE;
    
    if( ! pMarkup )
    {
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );
        
    if ( ! pDoc->_pInPlace )
    {
        hr = S_OK ;
        goto Cleanup;
    }
        
    IGNORE_HR( scrollIntoView ( TRUE ) );

    //
    // IE 4.01 Compat if the 
    //
    hr = THR( _pLeft->IsEqualTo(_pRight, &fEqual) );
    if ( hr )
    {
        AssertSz(0,"Compare on pointers failed - are they in the same tree ?");
        goto Cleanup;
    }
    
    if( fEqual )
    { 
        eSelType  = SELECTION_TYPE_Caret;
    }
    hr = THR( pDoc->Select( _pLeft, _pRight , eSelType ));

Cleanup:
    RRETURN ( SetErrorInfo(hr) );   
}

//+====================================================================================
//
// Method: IsRangeEquivalentToSelection
//
// Synopsis: Is the given range "equivalent" to the selection
//
//------------------------------------------------------------------------------------


HRESULT
CAutoRange::IsRangeEquivalentToSelection ( BOOL *pfEquivalent)
{
    HRESULT             hr = S_OK;
    BOOL                fEquivalent = FALSE;
    IMarkupPointer      *pSelStart = NULL;
    IMarkupPointer      *pSelEnd = NULL;
    ISegmentList        *pSegmentList = NULL;
    CDoc                *pDoc = GetMarkup()->Doc();
    ISegment            *pSegment = NULL;
    ISegmentListIterator *pIter = NULL;
    
    if ( pDoc->GetSelectionType() == SELECTION_TYPE_Text ||
         pDoc->GetSelectionType() == SELECTION_TYPE_Control )
    {    
        hr = THR( pDoc->CreateMarkupPointer( & pSelStart ));
        if ( hr )
            goto Cleanup;

        hr = THR( pDoc->CreateMarkupPointer( & pSelEnd ));
        if ( hr )
            goto Cleanup;
            
        hr = THR( pDoc->GetCurrentSelectionSegmentList( & pSegmentList ));    
        if ( hr )
            goto Cleanup;

#if DBG
        BOOL fEmpty;
        
        hr = THR( pSegmentList->IsEmpty(&fEmpty) );
        if( hr )
            goto Cleanup;

        Assert( !fEmpty );            
#endif

        hr = THR( pSegmentList->CreateIterator( &pIter ) );
        if( hr )
            goto Cleanup;

        hr = THR( pIter->Current(&pSegment) );
        if( hr )
            goto Cleanup;
            
        hr = THR( pSegment->GetPointers( pSelStart, pSelEnd ));
        if ( hr )
            goto Cleanup;

        //
        // Now make the pointers cling to text like the range dows.
        //
        hr = AdjustPointers( pSelStart, pSelEnd );
        if ( hr )
            goto Cleanup;

        hr = THR ( pSelStart->IsEqualTo( _pLeft, &fEquivalent ));
        if ( hr )
            goto Cleanup;

        if ( fEquivalent )
        {
            hr = THR ( pSelEnd->IsEqualTo( _pRight, & fEquivalent ));
            if ( hr )
                goto Cleanup;  
        }
    }
Cleanup:
    if ( pfEquivalent )
        *pfEquivalent = fEquivalent;

    ReleaseInterface( pSegment );
    ReleaseInterface( pIter );
    ReleaseInterface( pSelStart );
    ReleaseInterface( pSelEnd );
    ReleaseInterface( pSegmentList );
    
    RRETURN( hr );        
}
//+----------------------------------------------------------------------------
//
//  Member:     pasteHTML, IAutoRange
//
//  Synopsis:   Used to be put_htmltext
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::pasteHTML ( BSTR htmlText )
{
    HRESULT     hr = S_OK;
    CParentUndo pu( GetMarkup()->Doc() );
    CElement *  pContainer;
    BOOL        result;
    IHTMLElement* pIFlowElement1 = NULL;
    IHTMLElement* pIFlowElement2 = NULL;
    IObjectIdentity * pIdentity = NULL;
    CMarkup *   pMarkup = GetMarkup();   
    CDoc     *  pDoc = pMarkup->Doc();
    BOOL fInSameFlow = TRUE;
    BOOL fRangeEquivalentToSelection = FALSE;
    
    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    pContainer = GetCommonContainer();

    if (pContainer && pContainer->TestClassFlag( CElement::ELEMENTDESC_OMREADONLY ))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!FSupportsHTML())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // CHeck the pointers are both in the same flow layout. If they're not - fail.
    //
    hr = THR( pDoc->GetFlowElement( _pLeft, & pIFlowElement1));
    if ( hr )
        goto Cleanup;

    hr = THR( pDoc->GetFlowElement( _pRight, & pIFlowElement2));
    if ( hr )
        goto Cleanup;

    hr = THR( pIFlowElement1->QueryInterface( IID_IObjectIdentity, (void **) &pIdentity ) );
    if (hr)
        goto Cleanup;

    fInSameFlow = ( pIdentity->IsEqualObject( pIFlowElement2 ) == S_OK );   
    if ( ! fInSameFlow )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    //
    // See if the range and the selection are "equivalent" - ie the pointers are in the same places
    // if they are - we have to mimic the ie 4 behavior of collapsing to a caret at the end of paste.
    //

    hr = THR( IsRangeEquivalentToSelection( & fRangeEquivalentToSelection));
    if ( hr)
        goto Cleanup;
        
    if( pContainer->IsEditable(/*fCheckContainerOnly*/FALSE) )
        pu.Start( IDS_UNDOPASTE );

    //
    //
    //
    
    {
        CMarkupPointer * pmpLeft, * pmpRight;

        extern HRESULT HandleIE50CompatUIPasteHTML (
            CMarkupPointer *, CMarkupPointer *, const TCHAR *, long, BOOL );

        hr = THR( _pLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpLeft ) );

        if (hr)
            goto Cleanup;

        hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpRight ) );

        if (hr)
            goto Cleanup;

        hr = THR( HandleIE50CompatUIPasteHTML( pmpLeft, pmpRight, htmlText, -1, TRUE ) );

        if (hr == S_FALSE)
        {
            hr = S_OK; 
            goto Cleanup;
        }

        if (hr)
            goto Cleanup;
    }
    
    //
    // Collapse the range after the paste
    // Note: Since _pLeft has right gravity and _pRight has left gravity
    //       after paste, _pLeft ends up to the right of _pRight.
    //       That's why we're moving _pRight to _pLeft to collapse the range.
    //
    
    hr = THR( _pLeft->IsRightOf( _pRight, & result ) );

    if ( result )
        hr = THR( _pRight->MoveToPointer( _pLeft ) );
    else
        hr = THR( _pLeft->MoveToPointer( _pRight ) );

    hr = THR( ValidatePointers() );

    if (hr)
        goto Cleanup;

    //
    // Place the caret where we just pasted.
    //
    if ( fRangeEquivalentToSelection )
    {
        hr = THR( GetMarkup()->Doc()->Select( _pRight,_pRight, SELECTION_TYPE_Caret ));
    }        

Cleanup:
    ReleaseInterface( pIFlowElement1 );
    ReleaseInterface( pIFlowElement2 );
    ReleaseInterface( pIdentity );
    
    pu.Finish( hr );

    RRETURN( SetErrorInfo( hr ) );
}


//+-------------------------------------------------------------------
//
//  function : GetRangeTopLeft()
//
//  Synopsis : just a local helper function for getting the offsetTop
//      and the offsetLeft.
//
//-------------------------------------------------------------------
HRESULT
CAutoRange::GetRangeTopLeft(POINT * pPt, BOOL fScreenCoord)
{
    HRESULT       hr = S_OK;
    CDataAry<RECT>  aryRects(Mt(CAutoRangeGetRangeBoundingRect_aryRects_pv));
    CDataAry<RECT> * paryRects = &aryRects;
    RECT *  prc;
    LONG    iRect;
    LONG    lSize;

    if (!pPt)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pPt->x = pPt->y = 0;

    // Get the bounding rectangles
    hr = THR(GetRangeBoundingRects(&aryRects, fScreenCoord));
    if(hr)
        goto Cleanup;

    lSize = paryRects->Size();

    // skip any zero rects in our search for the rect of the first line
    for(  prc = *paryRects, iRect =0 ;
          (   prc 
           && prc->left == 0 
           && prc->right == 0 
           && prc->top == 0 
           && prc->bottom == 0
           && iRect < lSize ); 
           prc++, iRect++ )
           
               ;

    // Set the Point to the left and top of the first non-zero rect
    if (prc)
    {
        pPt->y = prc->top;
        pPt->x = prc->left;
        
        if (GetContainer())
        {
            POINT ptOrg;
            GetContainer()->GetClientOrigin(&ptOrg);
            pPt->x -= ptOrg.x;
            pPt->y -= ptOrg.y;
        }

    }

 Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     offsetTop,  IHTMLTextRangeMetrics
//
//  Synopsis:  returns the offsetTop of the start cp of the range
//
//----------------------------------------------------------------------------

HRESULT
CAutoRange::get_offsetTop( long *pLong )
{
    HRESULT    hr;
    POINT      pt;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (IsOrphaned())
    {
        *pLong = -1;
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(GetRangeTopLeft( &pt, TRUE)); 

    *pLong = (hr) ? -1 : pt.y;

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     offsetLeft,  IHTMLTextRangeMetrics
//
//  Synopsis:  returns the offsetleft of the start cp of the range
//
//----------------------------------------------------------------------------

HRESULT
CAutoRange::get_offsetLeft( long *pLong )
{
    HRESULT    hr;
    POINT      pt;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (IsOrphaned())
    {
        *pLong = -1;
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(GetRangeTopLeft( &pt, TRUE)); 

    *pLong = (hr) ? -1 : pt.x;

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}



//+-----------------------------------------------------------------
//
//  member : GetRangeBoundingRects()
//
//  synopsis : private helper function used by the boundingBox queries.
//               returns the array that has a rectangle for each line
//               in the range
//
//------------------------------------------------------------------

HRESULT
CAutoRange::GetRangeBoundingRects(CDataAry<RECT> * pRects, BOOL fScreenCoord)
{
    HRESULT     hr = S_FALSE;
    CTreeNode * pNode = NULL;
    CTreeNode * pNodeLeft;
    CFlowLayout * pFlowLayout = NULL;

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    Assert(pRects);

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    if (! IsRangeCollapsed() )
    {
        pNodeLeft = LeftNode();

        if (! pNodeLeft)
            goto Cleanup;

        pNode = pNodeLeft->GetFirstCommonAncestor( RightNode(), NULL);
    }
    else
    {
        pNode = LeftNode();
    }

    if(!pNode)
        goto Cleanup;

    pFlowLayout = pNode->GetFlowLayout();

    if(   pFlowLayout
       && !pFlowLayout->IsDisplayNone())
    {
        CNotification    nf;
        CMarkupPointer * pLeft;
        CMarkupPointer * pRight = NULL;
        int              cpClipStart; 
        int              cpClipFinish;

        hr = THR_NOTRACE( _pLeft->QueryInterface(CLSID_CMarkupPointer, (void **) & pLeft) );
        if (! hr)
            hr = THR_NOTRACE( _pRight->QueryInterface(CLSID_CMarkupPointer, (void **) & pRight) );
        if (hr)
            goto Cleanup;

        cpClipStart = pLeft->GetCp();
        cpClipFinish = pRight->GetCp();

        Assert( cpClipStart <= cpClipFinish);

        nf.RangeEnsurerecalc(cpClipStart, cpClipFinish - cpClipStart, pNode);
        pLeft->Markup()->Notify(&nf);
    
        // OVERKILL - but the above recalc is not sufficient, EnsureView needs to be
        // called. However, we can be a little clever and only do this work if we have
        // NOT already called onload.  After this we know that we have calculated at 
        // least once and this will likely be correct
        if (   pFlowLayout->ElementOwner()->GetMarkup()
            && pFlowLayout->ElementOwner()->GetMarkup()->Window()
            && !pFlowLayout->ElementOwner()->GetMarkup()->Window()->_fFiredOnLoad )
        {
            hr = THR(pFlowLayout->ElementOwner()->EnsureRecalcNotify());
            if (hr) 
                goto Cleanup;
        }

        // We cannot pass the bounding rect to the function because in that case
        // it will ignore the cpMin and cpMost
        pFlowLayout->RegionFromElement(
                            pNode->Element(),
                            pRects,
                            NULL,
                            NULL,  
                            fScreenCoord
                                ? RFE_SCREENCOORD | RFE_SELECTION
                                : RFE_SELECTION,
                            cpClipStart, 
                            cpClipFinish); 
    }
                        
Cleanup:
    if (hr == S_FALSE)
        hr = S_OK;
    RRETURN(hr);
}


//+-----------------------------------------------------------------
//
//  member : GetRangeBoundingRect()
//
//  synopsis : private helper function used by the boundingBox queries.
//
//------------------------------------------------------------------


HRESULT
CAutoRange::GetRangeBoundingRect(RECT * prcBound, BOOL fScreenCoord)
{
    HRESULT         hr;
    CDataAry<RECT>  aryRects(Mt(CAutoRangeGetRangeBoundingRect_aryRects_pv));

    Assert(prcBound);

    prcBound->left = prcBound->right = prcBound->top = prcBound->bottom = 0;

    hr = THR(GetRangeBoundingRects(&aryRects, fScreenCoord));
    if(hr)
        goto Cleanup;

    // Calculate and return the total bounding rect
    BoundingRectForAnArrayOfRectsWithEmptyOnes(prcBound, &aryRects);

    // and turn the rect into "frame" window coordinates. (5.0 compat due to Native Frames)
    // this only applies to frames.  Viewlinks are considered in the parent window and so 
    // we should not pull the ClientOrigin off.  However we need to find the nearest Windowed
    // markup and remove that origin
    if (   GetContainer()
        && GetContainer()->GetMarkup())
    {
        POINT      ptOrg;
        CMarkup  * pMarkup = GetContainer()->GetMarkup();
        CElement * pMaster = pMarkup->Root()->GetMasterPtr();

        if (   pMaster
            && pMaster->Tag() == ETAG_INPUT)
        {
            pMarkup = pMaster->GetMarkup();

        }
        
        pMarkup->GetElementTop()->GetClientOrigin(&ptOrg);

        prcBound->left   -= ptOrg.x;
        prcBound->right  -= ptOrg.x;
        prcBound->top    -= ptOrg.y;
        prcBound->bottom -= ptOrg.y;
    }

Cleanup:
    RRETURN(hr);
}


//+-----------------------------------------------------------------
//
//  member : CAutoRange::getBoundingClientRect() - External method
//
//  Synopsis:   Returns Bounding rect of the range text in client
//                coordinates
//------------------------------------------------------------------

HRESULT
CAutoRange::getBoundingClientRect(IHTMLRect **ppIRect)
{
    HRESULT       hr = S_OK;
    CRect         Rect;
    COMRect     * pOMRect = NULL;

    DO_SANITY_CHECK

    if (!ppIRect)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppIRect = NULL;

    // Get the infromation
    hr = THR(GetRangeBoundingRect(&Rect));
    if(hr)
        goto Cleanup;

    g_uiDisplay.DocPixelsFromDevice(Rect, Rect);

    // Create an instance of the rectangle object
    pOMRect = new COMRect(&Rect);
    if (!pOMRect)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppIRect = (IHTMLRect *)pOMRect;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+-----------------------------------------------------------------
//
//  member : CAutoRange::getClientRects() - External method
//
//  Synopsis:   Returns the collection of rectangles for the text under
//               element's influence in client coordinates.
//              Each rectangle represents a line of text on the screen.
//------------------------------------------------------------------

HRESULT
CAutoRange::getClientRects(IHTMLRectCollection **ppIRects)
{
    HRESULT              hr;
    COMRectCollection  * pOMRectCollection;
    CDataAry<RECT>       aryRects(Mt(CAutoRangegetClientRects_aryRects_pv));

    DO_SANITY_CHECK

    if (!ppIRects)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppIRects = NULL;

    // Get the array taht contains bounding rects for each line in the range
    hr = THR(GetRangeBoundingRects(&aryRects));
    if(hr)
        goto Cleanup;

    for (int i = 0; i < aryRects.Size(); i++)
    {
        g_uiDisplay.DocPixelsFromDevice(aryRects[i], aryRects[i]);
    }

    // Create a rectangle collection class instance
    pOMRectCollection = new COMRectCollection();
    if (!pOMRectCollection)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Fill the collection with values from aryRects
    hr = THR(pOMRectCollection->SetRects(&aryRects));
    if(hr)
        goto Cleanup;

        *ppIRects = (IHTMLRectCollection *) pOMRectCollection;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:    get_bounding[Width|Height|Top|Left],  IHTMLTextRangeMetrics
//
//  Synopsis:  returns the rect values for the bounding box around the range
//
//----------------------------------------------------------------------------

HRESULT
CAutoRange::get_boundingWidth( long *pLong )
{
    HRESULT    hr;
    RECT       rect;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetRangeBoundingRect(&rect));

    if (FAILED(hr))
    {
        *pLong = -1;
    }
    else
    {
        *pLong = g_uiDisplay.DocPixelsFromDeviceX(rect.right-rect.left);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}


HRESULT
CAutoRange::get_boundingHeight( long *pLong )
{
    HRESULT    hr;
    RECT       rect;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetRangeBoundingRect(&rect));

    if (FAILED(hr))
    {
        *pLong = -1;
    }
    else
    {
        *pLong = g_uiDisplay.DocPixelsFromDeviceY(rect.bottom-rect.top);
    }
Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}



HRESULT
CAutoRange::get_boundingTop( long *pLong )
{
    HRESULT    hr;
    RECT       rect;
    LONG       lScroll;
    CElement * pContainer = NULL;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetRangeBoundingRect(&rect));

    if (hr)
    {
        *pLong = -1;
    }
    else
    {
        *pLong = g_uiDisplay.DocPixelsFromDeviceY(rect.top);

        // for ie4.01sp1/2 compatability we need to subtract
        // the scrollTop in order to make this client coords
        // rather than document coords.
        pContainer = GetCommonContainer();

        if (pContainer && 
            (SUCCEEDED(pContainer->get_scrollTop( &lScroll ))))
           *pLong -= lScroll;
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}


HRESULT
CAutoRange::get_boundingLeft( long *pLong )
{
    HRESULT    hr;
    RECT       rect;
    LONG       lScroll;
    CElement * pContainer = NULL;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetRangeBoundingRect(&rect));

    if (hr)
    {
        *pLong = -1;
    }
    else
    {
        *pLong = g_uiDisplay.DocPixelsFromDeviceX(rect.left);

        // for ie4.01sp1/2 compatability we need to subtract
        // the scrollLeft in order to make this clientwindow coords
        // rather than document client coords.
        pContainer = GetCommonContainer();

        if (pContainer && 
            (SUCCEEDED(pContainer->get_scrollLeft( &lScroll ))))
           *pLong -= lScroll;
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

// ISegmentList methods
HRESULT
CAutoRange::GetType(SELECTION_TYPE *peType)
{
    HRESULT hr = S_FALSE;

    if( peType )
    {
        *peType = SELECTION_TYPE_Text;
        hr = S_OK;
    }

    RRETURN(hr);
}

HRESULT
CAutoRange::CreateIterator(ISegmentListIterator **ppIIter)
{
    HRESULT hr = S_OK;

    CAutoRangeIterator *pListIter = new CAutoRangeIterator();

    if( pListIter == NULL )
        goto Error;

    // Initialize the iterator, and retrieve the ISegmentListIterator interface
    hr = pListIter->Init( this );
    if( FAILED(hr) )
        goto Cleanup;
    
    hr = pListIter->QueryInterface(IID_ISegmentListIterator, (void **)ppIIter);
    if( FAILED(hr) )
        goto Cleanup;
  
Cleanup:
    ReleaseInterface( pListIter );
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

HRESULT
CAutoRange::IsEmpty(BOOL *pfEmpty)
{
    HRESULT hr = E_FAIL;
    
    Assert( pfEmpty );

    if( pfEmpty )
    {
        *pfEmpty = FALSE;
        hr = S_OK;
    }        

    return hr;
}

// ISegment methods
HRESULT
CAutoRange::GetPointers(IMarkupPointer *pIStart,
                        IMarkupPointer *pIEnd )
{
    return MovePointersToSegment(0, pIStart, pIEnd );
}

HRESULT 
CAutoRange::MovePointersToSegment ( 
    int iSegmentIndex, 
    IMarkupPointer * pILeft, 
    IMarkupPointer * pIRight ) 
{
    HRESULT     hr;
    POINTER_GRAVITY eGravity = POINTER_GRAVITY_Left;
    
    if ( iSegmentIndex != 0 )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // check argument sanity
    if (! (pILeft && pIRight) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pILeft->MoveToPointer( _pLeft ) );
    
    if (!hr)
        hr = THR( pIRight->MoveToPointer( _pRight ) );
    

    //
    // copy gravity - important for commands
    //
    if ( !hr ) hr = _pLeft->Gravity( &eGravity );            // need to maintain gravity
    if ( !hr ) hr = pILeft->SetGravity( eGravity );

    if ( !hr ) hr = _pRight->Gravity( &eGravity );            // need to maintain gravity
    if ( !hr ) hr = pIRight->SetGravity( eGravity );
    
    if (hr) 
        goto Cleanup;
    
Cleanup:        
    RRETURN( hr );
}    

HRESULT
CAutoRange::MoveSegmentToPointers ( int iSegmentIndex,
                                    IMarkupPointer * pILeft, 
                                    IMarkupPointer * pIRight )  
{
    HRESULT     hr;
    BOOL        fPositioned = FALSE;
    
    // check argument sanity
    if (! (pILeft && pIRight) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR( pILeft->IsPositioned( &fPositioned ) );
    if (hr)
        goto Cleanup;
    if (! fPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    hr = THR( pIRight->IsPositioned( &fPositioned ) );
    if (hr)
        goto Cleanup;
    if (! fPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
   
    hr = THR( SetLeft( pILeft ) );
    if (! hr)   hr = THR( SetRight( pIRight ) );
    if (hr)
        goto Cleanup;
    
Cleanup:    
    RRETURN( hr );
}


HRESULT
CAutoRange::GetSegmentCount(
    int* piSegmentCount,
    SELECTION_TYPE *peSelectionType )
{
    HRESULT hr = S_FALSE;

    if ( piSegmentCount )
    {
        *piSegmentCount = 1;
        hr = S_OK;
    }
    if ( peSelectionType )
        *peSelectionType = SELECTION_TYPE_Text;
        
    RRETURN( hr );
}


#if DBG==1
void CAutoRange::DumpTree()
{
    GetMarkup()->DumpTree();
}
#endif


BOOL
IsIntrinsicTag( ELEMENT_TAG eTag )
{
    switch (eTag)
    {
    case ETAG_BUTTON:
    case ETAG_TEXTAREA:
#ifdef  NEVER
    case ETAG_HTMLAREA:
#endif
    case ETAG_FIELDSET:
    case ETAG_LEGEND:
    case ETAG_MARQUEE:
    case ETAG_SELECT:
        return TRUE;

    default:
        return FALSE;
    }
}


HRESULT
CAutoRange::AdjustIntoTextSite(
    IMarkupPointer *    pPointerToMove,
    MV_DIR              Dir,
    IMarkupPointer *    pBoundary )
{
    HRESULT         hr;
    IHTMLElement *  pHTMLElement = NULL;    
    IHTMLElement *  pSite = NULL;
    IMarkupPointer* pPointer = NULL;
    CDoc *          pDoc;
    BOOL            fTextSite = FALSE;
    BOOL            fResult;
    MARKUP_CONTEXT_TYPE context;

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );

    hr = THR( pDoc->CreateMarkupPointer( & pPointer ) );        
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;
    
    for ( ; ; )
    {
        ClearInterface( & pHTMLElement );

        if( Dir == MV_DIR_Left )
        {
            hr = THR( LeftOrSlave( pPointer, TRUE, & context, & pHTMLElement, NULL, NULL ) );
            if (hr)
                goto Cleanup;

            hr = THR( pPointer->IsLeftOf( pBoundary, & fResult ) );
            if (hr)
                goto Cleanup;

        }
        else
        {
            hr = THR( RightOrSlave( pPointer, TRUE, & context, & pHTMLElement, NULL, NULL ) );
            if (hr)
                goto Cleanup;

            hr = THR( pPointer->IsRightOf( pBoundary, & fResult ));
            if (hr)
                goto Cleanup;
        }

        // Check Boundary
        if (fResult)
        {
            goto Cleanup;
        }

        switch( context )
        {
        case CONTEXT_TYPE_None:
            goto Cleanup;

        case CONTEXT_TYPE_EnterScope:
        case CONTEXT_TYPE_ExitScope:
            if (! pHTMLElement)
                break;

            ClearInterface( & pSite );
            hr = THR( GetSiteContainer( pHTMLElement, & pSite,  & fTextSite ) );
            if (hr)
                goto Cleanup;

            if ( fTextSite )
            {                
                goto Cleanup;
            }
        }
    }

Cleanup:
    if( SUCCEEDED( hr ) && fTextSite )
    {
        hr = THR( pPointerToMove->MoveToPointer( pPointer ));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = E_FAIL;
    }
    ReleaseInterface( pPointer );
    ReleaseInterface( pHTMLElement );
    ReleaseInterface( pSite );
    return( hr );
}    


//+---------------------------------------------------------------------------
//
//  Member:     CAutoRange::ClingToText()
//
//  Synopsis:   Move pOrigin towards pTarget while the context type is not text. 
//              The direction of the move is denoted by fLeftBound.
//              If the move causes pOrigin to pass pTarget, the pointers are
//              adjusted to move next to each other.
//
//----------------------------------------------------------------------------

CLING_RESULT
CAutoRange::ClingToText( 
    IMarkupPointer *        pInPointer, 
    IMarkupPointer *        pBoundary, 
    MV_DIR                  eDir )
{
    CLING_RESULT        cr = CR_Failed;
    HRESULT             hr = S_OK;
    BOOL                fDone = FALSE;
    BOOL                fLeft = eDir == MV_DIR_Left;
    CElement *          pElement = NULL;
    MARKUP_CONTEXT_TYPE eCtxt = CONTEXT_TYPE_None;

    IMarkupPointer *    pPointer = NULL;
    IHTMLElement *      pHTMLElement = NULL;
    CMarkupPointer  *   pointer = NULL;
    DWORD               dwBreaks;
    long                cch;
    CDoc                *pDoc = _pMarkup->Doc();

#if 0
    //
    // Quick Out: Check if I'm adjacent to text. If so, go nowhere.
    //

    if( fLeft )
        hr = THR( RightOrSlave( pInPointer, FALSE, & eCtxt, NULL, NULL, NULL ) );
    else
        hr = THR( LeftOrSlave( pInPointer, FALSE, & eCtxt, NULL , NULL, NULL ) );
    
    if( eCtxt == CONTEXT_TYPE_Text )
    {
        cr = CR_Text;
        goto Cleanup;   // Nothing to do!
    }
#endif // if 0

    hr = THR( GetMarkup()->Doc()->CreateMarkupPointer( & pPointer ) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->MoveToPointer( pInPointer ) );
    if (hr)
        goto Cleanup;

    hr = THR(
            pPointer->QueryInterface(CLSID_CMarkupPointer, (void**) & pointer ) );
    if (hr)
        goto Cleanup;

    while( ! fDone )
    {
        BOOL fResult;
        
        ClearInterface( & pHTMLElement );
        
        if ( fLeft ) 
        {
            hr = pPointer->IsLeftOf( pBoundary, & fResult ) ;
        }
        else
        {
            hr = pPointer->IsRightOf( pBoundary, & fResult ) ;
        }

        if ( fResult )
        {
            cr = CR_Boundary;
            goto Done;
        }
            
        cch = 1;
        if( fLeft )
        {
            hr = THR( LeftOrSlave( pPointer, TRUE, & eCtxt, & pHTMLElement, & cch, NULL ));
        }
        else
        {
            hr = THR( RightOrSlave(pPointer, TRUE, & eCtxt, & pHTMLElement, & cch, NULL ));
        }

        if( FAILED( hr ))
            goto Done;

        switch( eCtxt )
        {
            case CONTEXT_TYPE_EnterScope:
                if( pHTMLElement )
                {
                    pElement = NULL;
                    IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                    //  We don't want to cling to text for atomic elements.  We need to keep the
                    //  end pointer outside of the atomic element.
                    if ( pDoc->IsElementAtomic(pElement) )
                    {
                        cr = CR_AtomicElement;
                        fDone = TRUE;
                    }
                    else if ( IsIntrinsicTag( pElement->Tag() ) ||
                         pElement->ShouldHaveLayout() )
                    {
                        cr = CR_Intrinsic;
                        fDone = TRUE;
                    }
                    else if ( pElement->IsBlockElement() )
                    {
                        //
                        // Check for any break characters
                        //
                        hr = THR( pointer->QueryBreaks( & dwBreaks ) );
                        if (hr)
                            goto Cleanup;

                        if ( dwBreaks == BREAK_BLOCK_BREAK )
                        {
                            // Stay after the block break, we're done
                            cr = CR_BlockBreak;
                            fDone = TRUE;
                        }
                    }
                }
                break;

            case CONTEXT_TYPE_ExitScope:
                if( pHTMLElement )
                {
                    pElement = NULL;
                    IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                    if( pElement &&
                          (pElement->ShouldHaveLayout() || pElement->IsBlockElement() || pElement->Tag()==ETAG_BR))
                    {
                        cr = CR_Failed;
                        // cr = CR_Text; // this could also be CR_Failed, but this simulates a block break or tsb char
                        fDone = TRUE;
                    }
                }
                break;
                
            case CONTEXT_TYPE_NoScope:
                if( pHTMLElement )
                {
                    pElement = NULL;
                    IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                    if( pElement 
                        && (pElement->ShouldHaveLayout() || pElement->IsBlockElement() || pElement->Tag()==ETAG_BR ||
                           pElement->Tag()==ETAG_SCRIPT ))
                    {
                        cr = CR_NoScope;
                        fDone = TRUE;
                    }
                }
                break;
                
            case CONTEXT_TYPE_Text:
                cr = CR_Text;
                fDone = TRUE;
                break;
                
            case CONTEXT_TYPE_None:
                cr = CR_Failed;
                fDone = TRUE;
                break;
        }
    }

Done:

    //
    // If we found text, move our pointer
    //
    
    switch( cr )
    {
        case CR_Text:
        case CR_NoScope:
        case CR_Intrinsic:
        case CR_BlockBreak:
        case CR_AtomicElement:

            //
            // We have inevitably gone one move too far, back up one move
            //

            cch = 1;
            if( fLeft )
            {
                hr = THR( RightOrSlave( pPointer, TRUE, & eCtxt, NULL, & cch, NULL ));
            }
            else
            {
                hr = THR( LeftOrSlave( pPointer, TRUE, & eCtxt, NULL, & cch, NULL ));
            }

            if( FAILED( hr ))
                goto Cleanup;

            //
            // Now we position the pointer
            //
            
            hr = THR( pInPointer->MoveToPointer( pPointer ));
            break;
    }

Cleanup:
    ReleaseInterface( pPointer );
    ReleaseInterface( pHTMLElement );
    
    return( cr );
}

//+---------------------------------------------------------------------------
//
//  Member:     Private helper function GetSiteContainer()
//
//  Synopsis:   Returns the text site corresponding to the passed in 
//              markup pointer
//
//----------------------------------------------------------------------------

HRESULT     
CAutoRange::GetSiteContainer (
        IMarkupPointer *     pPointer,
        IHTMLElement **      ppSite,
        BOOL *               pfText )
{
    HRESULT        hr = E_FAIL;
    IHTMLElement * pHTMLElement = NULL;
    CDoc         * pDoc;

    Assert( pPointer != NULL && ppSite != NULL );
    if( pPointer == NULL || ppSite == NULL )
        goto Cleanup;

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );

    hr = THR( pDoc->CurrentScopeOrSlave( pPointer, & pHTMLElement ));
    if (hr)
        goto Cleanup;
    
    if( pHTMLElement )
    {
        hr = THR( GetSiteContainer( pHTMLElement, ppSite, pfText ));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    ReleaseInterface( pHTMLElement ); 
    RRETURN( hr );
}


HRESULT     
CAutoRange::GetSiteContainer(
        IHTMLElement *      pElementStart,
        IHTMLElement **     ppSite,
        BOOL *              pfText )
{
    HRESULT         hr = E_FAIL;
    BOOL            fSite = FALSE;
    BOOL            fText = FALSE;
    IHTMLElement *  pHTMLElement = NULL;
    CDoc         *  pDoc;
    IHTMLElement * pElementParent = NULL;

    Assert( pElementStart != NULL && ppSite != NULL );
    Assert( *ppSite == NULL );

    if( pElementStart == NULL || ppSite == NULL )
        goto Cleanup;

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );

    *ppSite = NULL;
    ReplaceInterface( & pHTMLElement, pElementStart );

    while( ! fSite && pHTMLElement != NULL )
    {
        hr = THR( pDoc->IsSite( pHTMLElement, &fSite, &fText, NULL, NULL ));
        if (hr)
            goto Cleanup;

        if( fSite )
        {       
            hr = S_OK;

            ReplaceInterface( ppSite, pHTMLElement );

            if( pfText != NULL )
                *pfText = fText;
        }
        else
        {
            ClearInterface( & pElementParent );
            hr = THR( pHTMLElement->get_parentElement( & pElementParent ));
            ReplaceInterface( & pHTMLElement, pElementParent );
        }
    }
    
Cleanup:
    ReleaseInterface( pElementParent );
    ReleaseInterface( pHTMLElement );
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     AdjustForInsert()
//
// . Set the boundary
//
// . Find a text site 
//
// . Bail if we're next to text
//
// . Adjust the boundary to the text site
//
// . Go Left looking for Text while in the text site boundary, break for anything other than phrase elements
//
// . Go right looking for Text, Line break or Block Break while in the text site boundary
//
//----------------------------------------------------------------------------

HRESULT
CAutoRange::AdjustForInsert( IMarkupPointer * pPointerToMove )
{
    CLING_RESULT        cr = CR_Failed;
    HRESULT             hr = S_OK;
    BOOL                fDone = FALSE;
    CElement *          pElement = NULL;
    MARKUP_CONTEXT_TYPE context;
    IMarkupPointer *    pPointer = NULL;
    IHTMLElement *      pHTMLElement = NULL;
    IHTMLElement *      pSite = NULL;
    CDoc  *             pDoc;
    BOOL                fResult;
    BOOL                fTextSite = FALSE;
    long                cch;
    DWORD               dwBreaks;
    CMarkupPointer *    mpPointer;
    IMarkupPointer *    pLeftBoundary = NULL;
    IMarkupPointer *    pRightBoundary = NULL;
    
    pDoc = GetMarkup()->Doc();
    Assert( pDoc );

    if (! _pElemContainer)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( pDoc->CreateMarkupPointer( & pPointer ) );
    if (hr)
        goto Cleanup;

    //
    // Set the range boundaries
    //
    hr = THR_NOTRACE( 
            _pElemContainer->QueryInterface( IID_IHTMLElement, (void **) & pHTMLElement ) );
    if (hr)
        goto Cleanup;
    
    hr = THR( pDoc->CreateMarkupPointer( & pLeftBoundary ) );
    if (hr)
        goto Cleanup;

    hr = THR( pDoc->CreateMarkupPointer( & pRightBoundary ) );
    if (hr)
        goto Cleanup;

    hr = THR( pLeftBoundary->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_AfterBegin ) );
    if (hr)
        goto Cleanup;

    hr = THR( pRightBoundary->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_BeforeEnd ) );
    if (hr)
        goto Cleanup;

    ClearInterface( & pHTMLElement );

    //
    // Position pPointerToMove within a text site
    //

    hr = THR( GetSiteContainer( pPointerToMove, & pSite, & fTextSite ));
    if (hr)
        goto Cleanup;
    
    if( ! fTextSite )
    {
        hr = AdjustIntoTextSite( pPointerToMove, MV_DIR_Right, pRightBoundary );        
        if( FAILED( hr ))
        {
            hr = AdjustIntoTextSite( pPointerToMove, MV_DIR_Left, pLeftBoundary );
        }
        
        if( FAILED( hr ))
        {
            hr = E_FAIL;
            goto Cleanup;
        }        
        ClearInterface( & pSite );
        hr = THR( GetSiteContainer( pPointerToMove, & pSite, & fTextSite ));
        if (hr)
            goto Cleanup;
    }

    //
    // Adjust the boundaries to enclose the text site, if necessary
    //        
    hr = THR( pPointer->MoveAdjacentToElement( pSite, ELEM_ADJ_AfterBegin ) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->IsRightOf( pLeftBoundary, & fResult ) );
    if (hr)
        goto Cleanup;

    if ( fResult )
    {
        hr = THR( pLeftBoundary->MoveToPointer( pPointer ) );
        if (hr)
            goto Cleanup;
    }

    hr = THR( pPointer->MoveAdjacentToElement( pSite, ELEM_ADJ_BeforeEnd ) );
    if (hr)
        goto Cleanup;
    
    hr = THR( pPointer->IsLeftOf( pRightBoundary, & fResult ) );
    if (hr)
        goto Cleanup;

    if ( fResult )
    {
        hr = THR( pRightBoundary->MoveToPointer( pPointer ) );
        if (hr)
            goto Cleanup;
    }

    ClearInterface( & pSite );

    //
    // Go Left looking for Text while in the text site boundary, 
    // break for anything other than phrase elements
    //
    hr = THR( pPointer->MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    while ( ! fDone )
    {
        ClearInterface( & pHTMLElement );                    
        cch = 1;

        hr = THR( LeftOrSlave( pPointer, TRUE, &context, &pHTMLElement, & cch, NULL ));
        if ( hr )
            goto Cleanup;

        hr = THR( pPointer->IsLeftOf( pLeftBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        if ( fResult )
        {
            cr = CR_Boundary;
            fDone = TRUE;
            break;
        }

        switch( context )
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
                if (! pHTMLElement)
                    break;

                pElement = NULL;
                IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement) );

                if ( IsIntrinsicTag( pElement->Tag() ) )
                {
                    cr = CR_Intrinsic; 
                    fDone = TRUE;
                }
                else if ( pElement->ShouldHaveLayout() ||
                          pElement->IsBlockElement() )
                {
                    cr = CR_Intrinsic; 
                    fDone = TRUE;
                }
                break;
               
            case CONTEXT_TYPE_NoScope:
                cr = CR_NoScope;

                if (pHTMLElement)
                {
                    pElement = NULL;
                    IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement) );
                    if (pElement)
                    {
                        if (pElement->ShouldHaveLayout() 
                            || pElement->Tag() == ETAG_BR)
                        {
                            goto Cleanup;
                        }
                    }
                }
                fDone = TRUE;            
                break;
                
            case CONTEXT_TYPE_Text:
                cr = CR_Text;
                fDone = TRUE;
                break;
                
            case CONTEXT_TYPE_None:
                cr = CR_Boundary;
                fDone = TRUE;
                break;
        }
    }

    if ( cr == CR_Text )
    {
        // The only significant thing to the left is Text
        // We're done
        goto Cleanup;
    }
    
    //
    // Go right looking for Text, Line breaks or Block Breaks 
    // while in the text site boundary
    //

    hr = THR( pPointer->MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & mpPointer ) );
    if (hr)
        goto Cleanup;

    fDone = FALSE;

    while ( ! fDone )
    {
        hr = THR( mpPointer->QueryBreaks( & dwBreaks ) );
        if (hr)
            goto Cleanup;

        if ( dwBreaks == BREAK_BLOCK_BREAK )
        {
            cr = CR_BlockBreak; 
            break;
        }

        ClearInterface( & pHTMLElement );                    
        cch = 1;

        hr = THR( RightOrSlave(pPointer, TRUE, &context, &pHTMLElement, & cch, NULL ));
        if ( hr )
            goto Cleanup;

        hr = THR( pPointer->IsRightOf( pRightBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        if ( fResult )
        {
            cr = CR_Boundary;
            fDone = TRUE;
            break;
        }

        switch( context )
        {
            case CONTEXT_TYPE_EnterScope:
                if (! pHTMLElement)
                    break;

                pElement = NULL;
                IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                if ( IsIntrinsicTag( pElement->Tag() ) || 
                     pElement->ShouldHaveLayout() )
                {
                    cr = CR_Intrinsic;
                    fDone = TRUE;
                }
                break;

            case CONTEXT_TYPE_ExitScope:
                if (! pHTMLElement)
                    break;

                pElement = NULL;
                IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                if( pElement->ShouldHaveLayout() || pElement->IsBlockElement() )
                {
                    cr = CR_Failed;
                    fDone = TRUE;
                }
                break;
                
            case CONTEXT_TYPE_NoScope:
                if (! pHTMLElement)
                    break;

                pElement = NULL;
                IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                if (pElement->Tag() == ETAG_BR )
                {
                    cr = CR_LineBreak;
                    fDone = TRUE;
                }
                else if ( pElement->ShouldHaveLayout() || pElement->Tag() == ETAG_SCRIPT )
                {
                    cr = CR_NoScope; 
                    fDone = TRUE;
                }
                break;
                
            case CONTEXT_TYPE_Text:
                cr = CR_Text;
                fDone = TRUE;
                break;
                
            case CONTEXT_TYPE_None:
                cr = CR_Failed;
                fDone = TRUE;
                break;
        }
    }

    switch (cr)        
    {
    case CR_LineBreak:
    case CR_Text: 
    case CR_NoScope: 
    case CR_Intrinsic: 
        // We've gone too far, need to go left once
        hr = THR( LeftOrSlave( pPointer, TRUE, &context, NULL, & cch, NULL ));
        if ( hr )
            goto Cleanup;
        hr = THR( pPointerToMove->MoveToPointer( pPointer ));
        goto Cleanup;


    case CR_BlockBreak:
        hr = THR( AdjustLeftIntoEmptyPhrase(pPointer) );
        if (hr)
            goto Cleanup;

        hr = THR( pPointerToMove->MoveToPointer( pPointer ));
        goto Cleanup;

    }


Cleanup:
    ReleaseInterface( pPointer );
    ReleaseInterface( pHTMLElement );
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    ReleaseInterface( pSite );
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CTextSegment::FlipRangePointers()
//
//  Synopsis:   Wiggles pointers to appropriate position
//
//  Arguments:  none
//
//  Returns:    none
//
//----------------------------------------------------------------------------
HRESULT
CAutoRange::FlipRangePointers()
{
    IMarkupPointer *  pTemp = NULL;
    HRESULT         hr = S_OK;
    POINTER_GRAVITY eGravityLeft = POINTER_GRAVITY_Left;    // need to initialize
    POINTER_GRAVITY eGravityRight = POINTER_GRAVITY_Left;  // need to initialize
    
    GetMarkup()->Doc()->CreateMarkupPointer( & pTemp );
      
    if (! pTemp)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    // Remember gravity
    hr = THR(_pLeft->Gravity(&eGravityLeft));
    if ( hr )
        goto Cleanup;
        
    hr = THR(_pRight->Gravity(&eGravityRight));
    if ( hr )
        goto Cleanup;

    // Swap pointers
    hr = THR( pTemp->MoveToPointer( _pRight ) );
    if ( hr )
        goto Cleanup;
        
    hr = THR( _pRight->MoveToPointer( _pLeft ) );
    if ( hr )
        goto Cleanup;
        
    hr = THR( _pLeft->MoveToPointer( pTemp ) );
    if ( hr )
        goto Cleanup;
    
    // Swap gravity as well
    if (eGravityLeft != eGravityRight)
    {
        THR(_pLeft->SetGravity(eGravityLeft));
        THR(_pRight->SetGravity(eGravityRight));
    }

Cleanup:
    ReleaseInterface( pTemp );
    RRETURN( hr );
}

HRESULT
CAutoRange::InitPointers()
{
    HRESULT hr = S_OK;

    if ( ! GetMarkup() )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ClearInterface( & _pLeft );

    hr = THR( _pMarkup->Doc()->CreateMarkupPointer( & _pLeft ) );

    if (hr)
        goto Cleanup;

    WHEN_DBG( SetDebugName( _pLeft, _T( "Range Left" ) ) );
    
    hr = THR( _pLeft->SetGravity( POINTER_GRAVITY_Right ) );
    
    if (hr)
        goto Cleanup;

    ClearInterface( & _pRight );

    hr = THR( _pMarkup->Doc()->CreateMarkupPointer( & _pRight ) );

    if (hr)
        goto Cleanup;
    
    WHEN_DBG( SetDebugName( _pRight, _T( "Range Right" ) ) );
    
    hr = THR( _pRight->SetGravity( POINTER_GRAVITY_Left ) );
    
    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}


HRESULT
CAutoRange::KeepRangeLeftToRight()
{
    HRESULT     hr;
    BOOL        fResult;

    hr = THR( _pLeft->IsRightOf( _pRight, & fResult ) );
    if (hr)
        goto Cleanup;

    if ( fResult )
    { 
        hr = THR( FlipRangePointers() );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}


HRESULT
CAutoRange::ValidatePointers()
{
    HRESULT         hr = S_OK;

    if (! (_pLeft && _pRight) )
        goto Cleanup;

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( AdjustPointers( _pLeft, _pRight ));

Cleanup:   
    RRETURN( hr );
}


//+====================================================================================
//
// Method: IsPhraseElement
//
// Synopsis: Is the element a phrase element
//
//------------------------------------------------------------------------------------
BOOL 
CAutoRange::IsPhraseElement( IHTMLElement *pElement )
{
    HRESULT         hr;
    BOOL            fNotPhrase = TRUE;

    // Make sure the element is not a site or block element
    hr = THR( _pMarkup->Doc()->IsSite(pElement, &fNotPhrase, NULL, NULL, NULL) );
    if (hr || fNotPhrase)
        return FALSE;
        
    hr = THR( _pMarkup->Doc()->IsBlockElement(pElement, &fNotPhrase) );
    if (hr || fNotPhrase)
        return FALSE;

    return TRUE;
}


HRESULT 
CAutoRange::AdjustLeftIntoEmptyPhrase( IMarkupPointer *pLeft )
{
    HRESULT               hr;
    MARKUP_CONTEXT_TYPE   context;
    IHTMLElement          *pElement = NULL;
    IMarkupPointer        *pmpTest = NULL;
    CDoc                  *pDoc = _pMarkup->Doc();

    hr = THR( pDoc->CreateMarkupPointer(&pmpTest) );
    if (hr)
        goto Cleanup;

    hr = THR( pmpTest->MoveToPointer(pLeft) );
    if (hr)
        goto Cleanup;

    do
    {
        ClearInterface(&pElement);
        hr = THR(LeftOrSlave(pmpTest, TRUE, &context, &pElement, NULL, NULL));
        if (hr)
            goto Cleanup;

        if (context == CONTEXT_TYPE_ExitScope && pElement && IsPhraseElement(pElement))
        {
            hr = THR(RightOrSlave(pmpTest, TRUE, NULL, NULL, NULL, NULL));
            if (hr)
                goto Cleanup;

            hr = THR( pLeft->MoveToPointer(pmpTest) );
        } 
    } 
    while (context == CONTEXT_TYPE_EnterScope && pElement && IsPhraseElement(pElement));

Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pmpTest);
    RRETURN(hr);
}


//+====================================================================================
//
// Method: AdjustPointers
//
// Synopsis: Do the work of clinging for the range. Called by validatepointers
//
//------------------------------------------------------------------------------------



HRESULT
CAutoRange::AdjustPointers( IMarkupPointer *pLeft, IMarkupPointer* pRight)
{
    HRESULT hr;
    CLING_RESULT cr;
    BOOL fResult;
    
    hr = THR( AdjustForInsert( pLeft ) );
    if (hr)
        goto Cleanup;

    hr = THR( pRight->IsLeftOf( pLeft, & fResult ) );
    if (hr)
        goto Cleanup;

    if (fResult)
    {
        hr = THR( pRight->MoveToPointer( pLeft ) );
        if (hr)
            goto Cleanup;
    }

    cr = ClingToText( pRight, pLeft, MV_DIR_Left );

Cleanup:   
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CAutoRange::IsRangeCollpased
//
//  Synopsis:   returns true if left and right pointers are equal
//
//
//  Returns:    BOOL
//
//----------------------------------------------------------------------------

BOOL
CAutoRange::IsRangeCollapsed()
{
    BOOL    fEqual = FALSE;
    HRESULT hr;

    hr = THR( _pLeft->IsEqualTo( _pRight, & fEqual ) );
    if (hr)
        goto Cleanup;

Cleanup:
    return fEqual;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAutoRange::SaveHTMLToStream
//
//  Synopsis:   Saves the range text to the specified stream.
//
//----------------------------------------------------------------------------

HRESULT
CAutoRange::SaveHTMLToStream(CStreamWriteBuff * pswb, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CMarkupPointer mpLeft( GetMarkup()->Doc() );
    CMarkupPointer mpRight( GetMarkup()->Doc() );
    
    hr = THR( mpLeft.MoveToPointer( _pLeft ));
    if( FAILED( hr ))
        goto Cleanup;

    hr = THR( mpRight.MoveToPointer( _pRight ));
    if( FAILED( hr ))
        goto Cleanup;

    //
    // Now we can actually do our work
    //
    {
        CRangeSaver rs( &mpLeft, &mpRight, dwFlags, pswb, GetMarkup() );
        hr = THR( rs.Save());
    }
    
Cleanup:
    RRETURN( hr );
}


HRESULT 
CAutoRange::GetLeft( IMarkupPointer * ptp )
{
    HRESULT  hr = THR( ptp->MoveToPointer( _pLeft ) );
    RRETURN( hr );
}

HRESULT
CAutoRange::GetLeft( CMarkupPointer * ptp )
{
    HRESULT  hr = THR( ptp->MoveToPointer( _pLeft  ) );
    RRETURN( hr );
}

HRESULT 
CAutoRange::GetRight( IMarkupPointer * ptp )
{
    HRESULT  hr = THR( ptp->MoveToPointer( _pRight ) );
    RRETURN( hr );
}

HRESULT 
CAutoRange::GetRight( CMarkupPointer * ptp )
{
    HRESULT  hr = THR( ptp->MoveToPointer( _pRight ) );
    RRETURN( hr );
}

HRESULT 
CAutoRange::SetLeft( IMarkupPointer * ptp )
{
    HRESULT  hr;
    
    // NOTE: aren't we guarranteed to have _pLeft and _pRight
    if (! _pLeft )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    
    hr = THR( _pLeft->MoveToPointer( ptp ) );
    if (hr)
        goto Cleanup;

    hr = THR( ValidatePointers() );

Cleanup:
    RRETURN( hr );
}


HRESULT 
CAutoRange::SetRight( IMarkupPointer * ptp )
{
    HRESULT  hr;
    
    if (! _pRight )
    {
        hr = E_FAIL;
        goto Cleanup;
    }


    hr = THR( _pRight->MoveToPointer( ptp ) );
    if (hr)
        goto Cleanup;

    hr = THR( ValidatePointers() );

Cleanup:
    RRETURN( hr );
}


HRESULT 
CAutoRange::SetLeftAndRight( 
                                IMarkupPointer * pLeft, 
                                IMarkupPointer * pRight, 
                                BOOL fAdjustPointers /*=TRUE*/ )
{
    HRESULT  hr;
    
    if (! _pRight || !_pLeft)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( _pRight->MoveToPointer( pRight ) );
    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->MoveToPointer( pLeft ) );
    if (hr)
        goto Cleanup;
            
    if ( fAdjustPointers )
    {
        hr = THR( ValidatePointers() );
    }
Cleanup:
    RRETURN( hr );
}

HRESULT 
CAutoRange::GetLeftAndRight( CMarkupPointer * pLeft, CMarkupPointer * pRight )
{
    HRESULT  hr;

    // internal function...
    Assert( pRight );
    Assert( pLeft );
   
    hr = THR( pRight->MoveToPointer( _pRight ) );
    if (hr)
        goto Cleanup;

    hr = THR( pLeft->MoveToPointer( _pLeft ) );

Cleanup:
    RRETURN( hr );
}

CTreeNode * 
CAutoRange::GetNode(BOOL fLeft)
{   
    CMarkupPointer * pmp = NULL;
    HRESULT          hr = S_OK;

    if (fLeft)
        hr = THR_NOTRACE( _pLeft->QueryInterface(CLSID_CMarkupPointer, (void **) & pmp) );
    else
        hr = THR_NOTRACE( _pRight->QueryInterface(CLSID_CMarkupPointer, (void **) & pmp) );
    
    if (hr)
    {
        return NULL;
    }
    
    return pmp ? pmp->CurrentScope(MPTR_SHOWSLAVE) : NULL;
}


CTreeNode * 
CAutoRange::LeftNode()
{   
    return ( GetNode( TRUE ) );
}


CTreeNode * 
CAutoRange::RightNode()
{   
    return ( GetNode( FALSE ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     SetTextRangeToElement
//
//  Synopsis:   Have this range select all text under the influence of the
//              given element.  
//
//  Return:     S_FALSE if the element cannot be located in the tree
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::SetTextRangeToElement ( CElement * pElement )
{
    HRESULT             hr = S_OK;
    IHTMLElement *      pHTMLElement = NULL;
    CElement     *      pElementTarget = NULL;
    CMarkupPointer      mpJustBefore ( GetMarkup()->Doc() );
    CMarkupPointer      mpTemp ( GetMarkup()->Doc() );
    IMarkupPointer *    pLeftBoundary = NULL;
    IMarkupPointer *    pRightBoundary = NULL;

    if (! pElement || ! pElement->IsInMarkup() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // First check whether the element has a slave.
    // Note that when CInputTxt::createTextRange() calls us,
    // it passes us a textslave, which does not have a slave.
    // However, if the element does have a slave, we must see 
    // if it is the same as the one that this range was created on.
    //
    if ( pElement->HasSlavePtr() )
    {
        CElement * pElementSlave;

        pElementSlave = pElement->GetSlavePtr();
        Assert( pElementSlave );

        if ( pElementSlave == _pElemContainer )
        {
            // The range was created on an INPUT and we've been 
            // asked to move to that same INPUT's text.
            pElementTarget = pElementSlave;
        }
    }

    if ( ! pElementTarget && 
         (pElement == _pElemContainer ||
          (pElement->GetFirstBranch()->Parent() &&
           pElement->GetFirstBranch()->Parent()->GetContainer() == _pElemContainer)))
    {
        pElementTarget = pElement;
    }
    else
    {
        // If the container of pElement is not the range's container 
        // we return an error. 
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    Assert( pElementTarget );

    hr = THR( pElementTarget->QueryInterface( IID_IHTMLElement, (void **) & pHTMLElement ) );
    if (hr)
        goto Cleanup;

    if ( pElementTarget->IsNoScope() )
    {
        // Place the range around the noscope element 
        hr = THR( _pLeft->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_BeforeBegin ) );
        if (hr)
            goto Cleanup;

        hr = THR( _pRight->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_AfterEnd ) );
        if (hr)
            goto Cleanup;

    }
    else
    {
        DWORD               dwBreaks;
        CMarkupPointer  *   pointer;

        // Place the left edge inside the element
        hr = THR( _pLeft->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_AfterBegin ) );
        if (hr)
            goto Cleanup;
        
        // Position the right edge inside the element, unless there is a block break there
        hr = THR( _pRight->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_BeforeEnd ) );
        if (hr)
            goto Cleanup;

        hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pointer ) );
        if( hr )
            goto Cleanup;

        hr = THR( pointer->QueryBreaks( & dwBreaks ) );
        if (hr)
            goto Cleanup;

        if ( dwBreaks == BREAK_BLOCK_BREAK )
        {
            hr = THR( _pRight->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_AfterEnd ) );
            if (hr)
                goto Cleanup;
        }
    }

    //
    // To keep IE4 compatibility, shift the left side up to the next "char".
    // Note: we do not shift the right side, since there already is code up above 
    // that positions the right end of the range AFTER the element end, 
    // passed a block break character.
    //

    hr = THR( MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
    
    if (hr)
        goto Cleanup;

    hr = THR( mpTemp.MoveToPointer( _pLeft ) );

    if (hr)
        goto Cleanup;

    hr = THR( MoveCharacter( & mpTemp, MOVEUNIT_PREVCHAR, pLeftBoundary, pRightBoundary, & mpJustBefore ) );

    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->MoveToPointer( & mpJustBefore ) );

    if (hr)
        goto Cleanup;

    //
    //
    //
    hr = THR( ValidatePointers() );
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    ReleaseInterface( pHTMLElement );
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::GetBstrHelper
//
//  Synopsis:   Gets text from the range into a given bstr in a specified
//              save mode.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::GetBstrHelper(BSTR * pbstr, DWORD dwSaveMode, DWORD dwStrWrBuffFlags)
{
    HRESULT  hr;
    LPSTREAM pIStream = NULL;

    *pbstr = NULL;

    hr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);
    if (hr)
        goto Cleanup;

    //
    // Use a scope to clean up the StreamWriteBuff
    //
    {
        CStreamWriteBuff StreamWriteBuff(pIStream, CP_UCS_2);

        hr = THR( StreamWriteBuff.Init() );
        if( hr )
            goto Cleanup;

        StreamWriteBuff.SetFlags(dwStrWrBuffFlags);
       
        hr = THR( SaveHTMLToStream( &StreamWriteBuff, dwSaveMode ));
        if (hr)
            goto Cleanup;

        StreamWriteBuff.Terminate();    // appends a null character
    }

    hr = GetBStrFromStream(pIStream, pbstr, TRUE);

Cleanup:

    ReleaseInterface(pIStream);

    RRETURN(hr);
}
 

//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::GetCommonElement
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

CTreeNode *
CAutoRange::GetCommonNode()
{
    CTreeNode * ptnLeft  = LeftNode();
    CTreeNode * ptnRight = RightNode();
    
    if (ptnLeft && ptnRight)
    {
        return ptnLeft->GetFirstCommonAncestor( ptnRight, NULL);
    }
    else
    {
        return NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::GetCommonContainer
//
//  Synopsis:   Find the common container of the range, if the range is inside
//              the same textsite, we return the textsite, otherwise we return
//              the ped.
//
//-----------------------------------------------------------------------------

CElement *CAutoRange::GetCommonContainer()
{
    return GetCommonNode()->GetContainer();
}

//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::OwnedBySingleTxtSite
//
//  Synopsis:   Function to determine if a single txt site owns the complete
//              range.
//
//  Arguments   None
//
//-----------------------------------------------------------------------------

BOOL
CAutoRange::OwnedBySingleFlowLayout()
{
    HRESULT     hr;
    BOOL        bResult = FALSE;
    CTreeNode   *ptnLeft  = LeftNode();
    CTreeNode   *ptnRight = RightNode();
    CElement    *pElemFlowLeft;
    CElement    *pElemFlowRight;
    IObjectIdentity *pIdentLeft = NULL;
    IObjectIdentity *pUnkRight = NULL;
    
    if (ptnLeft && ptnRight)
    {
        CFlowLayout * pFlowLeft  = ptnLeft->GetFlowLayout();
        CFlowLayout * pFlowRight = ptnRight->GetFlowLayout();

        if (pFlowLeft && pFlowRight)
        {
            pElemFlowLeft = pFlowLeft->ElementOwner();
            pElemFlowRight = pFlowRight->ElementOwner();

            hr = THR(pElemFlowLeft->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdentLeft));
            if (FAILED(hr))
                goto Cleanup;

            hr = THR(pElemFlowRight->QueryInterface(IID_IUnknown, (LPVOID *)&pUnkRight));
            if (FAILED(hr))
                goto Cleanup;

            hr = THR(pIdentLeft->IsEqualObject(pUnkRight));
            bResult = (hr == S_OK);
        }
    }

Cleanup:
    ReleaseInterface(pIdentLeft);
    ReleaseInterface(pUnkRight);
    return bResult;
}

//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::SelectionInOneTxtSite
//
//  Synopsis:   Function to determine if a single txt site owns both the
//              begin and end of a selection.
//
//  Arguments   None
//
//-----------------------------------------------------------------------------

BOOL
CAutoRange::SelectionInOneFlowLayout()
{
    BOOL fRet = TRUE;
    CFlowLayout * pFromOFL;
    CFlowLayout * pToOFL;
    CTreeNode * ptnLeft  = LeftNode();
    CTreeNode * ptnRight = RightNode();
    
    if (ptnLeft && ptnRight) 
    {
        pFromOFL = ptnLeft->GetFlowLayout();
        pToOFL   = ptnRight->GetFlowLayout();

        fRet = pFromOFL == pToOFL;

    }
    return fRet;
}

#if 0
//
// These routines have been moved to MshtmlEd
//

//+----------------------------------------------------------------------------
//
//  Method:     VariantCompareBSTRS, local helper
//
//  Synopsis:   compares 2 btrs
//
//-----------------------------------------------------------------------------

BOOL VariantCompareBSTRS(VARIANT * pvar1, VARIANT * pvar2)
{
    BOOL    fResult;
    TCHAR  *pStr1;
    TCHAR  *pStr2;

    if (V_VT(pvar1) == VT_BSTR && V_VT(pvar2) == VT_BSTR)
    {
        pStr1 = V_BSTR(pvar1) ? V_BSTR(pvar1) : g_Zero.ach;
        pStr2 = V_BSTR(pvar2) ? V_BSTR(pvar2) : g_Zero.ach;

        fResult = StrCmpC(pStr1, pStr2) == 0;
    }
    else
    {
        fResult = FALSE;
    }

    return fResult;
}


//+----------------------------------------------------------------------------
//
//  Method:     VariantCompareFontSize, local helper
//
//  Synopsis:   compares font size
//
//-----------------------------------------------------------------------------

BOOL VariantCompareFontSize(VARIANT * pvarSize1, VARIANT * pvarSize2)
{
    CVariant    convVar1;
    CVariant    convVar2;
    BOOL        fResult;

    Assert(pvarSize1);
    Assert(pvarSize2);

    if (   V_VT(pvarSize1) == VT_NULL
        || V_VT(pvarSize2) == VT_NULL
       )
    {
        fResult = V_VT(pvarSize1) == V_VT(pvarSize2);
        goto Cleanup;
    }

    if (VariantChangeTypeSpecial(&convVar1, pvarSize1, VT_I4))
        goto Error;

    if (VariantChangeTypeSpecial(&convVar2, pvarSize2, VT_I4))
        goto Error;

    fResult = V_I4(&convVar1) == V_I4(&convVar2);

Cleanup:
    return fResult;

Error:
    fResult = FALSE;
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Method:     VariantCompareColor, local helper
//
//  Synopsis:   compares color
//
//-----------------------------------------------------------------------------

BOOL VariantCompareColor(VARIANT * pvarColor1, VARIANT * pvarColor2)
{
    BOOL        fResult;
    CVariant    var;
    COLORREF    color1;
    COLORREF    color2;

    if (   V_VT(pvarColor1) == VT_NULL
        || V_VT(pvarColor2) == VT_NULL
       )
    {
        fResult = V_VT(pvarColor1) == V_VT(pvarColor2);
        goto Cleanup;
    }

    if (VariantChangeTypeSpecial(&var, pvarColor1,  VT_I4))
        goto Error;

    color1 = (COLORREF)V_I4(&var);

    if (VariantChangeTypeSpecial(&var, pvarColor2, VT_I4))
        goto Error;

    color2 = (COLORREF)V_I4(&var);

    fResult = color1 == color2;

Cleanup:
    return fResult;

Error:
    fResult = FALSE;
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Method:     VariantCompareFontName, local helper
//
//  Synopsis:   compares font names
//
//-----------------------------------------------------------------------------

BOOL VariantCompareFontName(VARIANT * pvarName1, VARIANT * pvarName2)
{
    return VariantCompareBSTRS(pvarName1, pvarName2);
}

#endif // 0


//+----------------------------------------------------------------------------
//
//  Method:     CheckOwnerSiteOrSelection
//
//-----------------------------------------------------------------------------
HRESULT
CAutoRange::CheckOwnerSiteOrSelection(ULONG cmdID)
{
    HRESULT     hr = S_OK;

    switch ( cmdID )
    {
    case IDM_OVERWRITE:
        if (!OwnedBySingleFlowLayout())
        {
            hr = S_FALSE;
        }
        break;

    case IDM_IMAGE:
    case IDM_PARAGRAPH:
    case IDM_IFRAME:
    case IDM_TEXTBOX:
    case IDM_TEXTAREA:
#ifdef  NEVER
    case IDM_HTMLAREA:
#endif
    case IDM_CHECKBOX:
    case IDM_RADIOBUTTON:
    case IDM_DROPDOWNBOX:
    case IDM_LISTBOX:
    case IDM_BUTTON:
    case IDM_MARQUEE:
    case IDM_1D:
    case IDM_LINEBREAKNORMAL:
    case IDM_LINEBREAKLEFT:
    case IDM_LINEBREAKRIGHT:
    case IDM_LINEBREAKBOTH:
    case IDM_HORIZONTALLINE:
    case IDM_INSINPUTBUTTON:
    case IDM_INSINPUTIMAGE:
    case IDM_INSINPUTRESET:
    case IDM_INSINPUTSUBMIT:
    case IDM_INSINPUTUPLOAD:
    case IDM_INSFIELDSET:
    case IDM_INSINPUTHIDDEN:
    case IDM_INSINPUTPASSWORD:

    case IDM_GETBLOCKFMTS:
    case IDM_TABLE:

    case IDM_CUT:
    case IDM_PASTE:

        if (!SelectionInOneFlowLayout())
        {
            hr = S_FALSE;
        }
        break;
    }

    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Method:     FSupportsHTML
//
//-----------------------------------------------------------------------------
BOOL
CAutoRange::FSupportsHTML()
{
    CTreeNode * pNode  = GetCommonNode();

    return ( pNode && pNode->SupportsHtml() );
}

//
// Helper functions so that measurer can make empty lines
// have the same height they will have after we spring
// load them and put text in them.
// 
long
GetSpringLoadedHeight(IMarkupPointer * pmpPosition, CFlowLayout * pFlowLayout, LONG * pyDescentOut)
{
    CDoc         * pDoc = pFlowLayout->Doc();
    CTreeNode    * pNode = pFlowLayout->GetFirstBranch();
    CCcs           ccs;
    const CBaseCcs * pBaseCcs;
    CCharFormat    cfLocal = *(pNode->GetCharFormat());
    CCalcInfo      CI;
    int            yHeight = -1;
    CVariant       varIn, varOut;
    GUID           guidCmdGroup = CGID_MSHTML;
    HRESULT        hr;

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = pmpPosition;

    hr = THR(pDoc->Exec(&guidCmdGroup, IDM_COMPOSESETTINGS, 0, &varIn, &varOut));
    V_VT(&varIn) = VT_NULL;
    if (hr || V_VT(&varOut) == VT_NULL)
        goto Cleanup;

    // We now know that we have to apply compose settings on this line.

    // Get font size.
    V_VT(&varIn) = VT_I4;
    V_I4(&varIn) = IDM_FONTSIZE;
    hr = THR(pDoc->Exec(&guidCmdGroup, IDM_COMPOSESETTINGS, 0, &varIn, &varOut));
    if (hr)
        goto Cleanup;

    // If we got a valid font size, apply it to the local charformat.
    if (V_VT(&varOut) == VT_I4 && V_I4(&varOut) != -1)
    {
        int iFontSize = ConvertHtmlSizeToTwips(V_I4(&varOut));
        cfLocal.SetHeightInTwips(iFontSize);
    }

    // Get font name.
    V_VT(&varIn) = VT_I4;
    V_I4(&varIn) = IDM_FONTNAME;
    hr = THR(pDoc->Exec(&guidCmdGroup, IDM_COMPOSESETTINGS, 0, &varIn, &varOut));
    if (hr)
        goto Cleanup;

    // If we got a valid font name, apply it to the local charformat.
    if (V_VT(&varOut) == VT_BSTR)
    {
        TCHAR * pstrFontName = V_BSTR(&varOut);
        cfLocal.SetFaceName(pstrFontName);
    }

    cfLocal._bCrcFont = cfLocal.ComputeFontCrc();

    CI.Init(pFlowLayout);

    if (fc().GetCcs(&ccs, CI._hdc, &CI, &cfLocal))
    {
        pBaseCcs = ccs.GetBaseCcs();
        yHeight = pBaseCcs->_yHeight;

        if (pyDescentOut)
            *pyDescentOut = pBaseCcs->_yDescent;

        ccs.Release();
    }

Cleanup:

    return yHeight;
}



long
GetSpringLoadedHeight(CCalcInfo *pci, CFlowLayout * pFlowLayout, CTreePos *ptp, long cp, long * pyDescentOut)
{
    CElement     * pElementContent = pFlowLayout->ElementContent();
    int            yHeight;

    Assert(pyDescentOut);

    if (   pElementContent
        && pElementContent->HasFlag(TAGDESC_ACCEPTHTML)
       )
    {
        CMarkup      * pMarkup = pFlowLayout->GetContentMarkup();
        CDoc         * pDoc = pMarkup->Doc();
        CMarkupPointer mpComposeFont(pDoc);
        HRESULT        hr;

        hr = THR(mpComposeFont.MoveToCp(cp, pMarkup));
        if (hr)
        {
            yHeight = -1;
            goto Cleanup;
        }

        //
        // don't ask for springloaded height - unless editor already exists !!
        //
        if ( pDoc->GetHTMLEditor( FALSE ))
        {
            yHeight = GetSpringLoadedHeight(&mpComposeFont, pFlowLayout, pyDescentOut);
        }
        else
            yHeight = -1; 
    }
    else
    {
        WHEN_DBG(CMarkup *pMarkup = pFlowLayout->GetContentMarkup());
        WHEN_DBG(LONG junk);

        Assert(ptp);
        Assert(ptp == pMarkup->TreePosAtCp(cp, &junk));
        const CCharFormat *pCF = ptp->GetBranch()->GetCharFormat();
        CCcs ccs;
        const CBaseCcs *pBaseCcs;
        
        if (!fc().GetCcs(&ccs, pci->_hdc, pci, pCF))
        {
            yHeight = -1;
            goto Cleanup;
        }
        pBaseCcs = ccs.GetBaseCcs();
        yHeight = pBaseCcs->_yHeight;
        *pyDescentOut = pBaseCcs->_yDescent;

        ccs.Release();
    }

Cleanup:

    return yHeight;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::CAutoRangeIterator
//
//  Synopsis:   Constructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CAutoRangeIterator::CAutoRangeIterator()
{
    Assert( _pRange == NULL );
    _ulRefs = 1;
    _fDone = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::CAutoRangeIterator
//
//  Synopsis:   Destructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CAutoRangeIterator::~CAutoRangeIterator()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::Init
//
//  Synopsis:   Initializes our segment list iterator
//
//  Arguments:  pRange = Pointer to an Auto range
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CAutoRangeIterator::Init(CAutoRange *pRange)
{
    _pRange = pRange;

    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::First
//
//  Synopsis:   Resets the iterator
//
//  Arguments:  VOID
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CAutoRangeIterator::First()
{
    _fDone = FALSE;
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::Current
//
//  Synopsis:   Returns the current ISegment position of the iterator.
//
//  Arguments:  ppISegment = OUTPUT pointer to an ISegment which will contain
//                the current segment for this iterator.
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CAutoRangeIterator::Current(ISegment **pISegment)
{
    HRESULT hr = E_FAIL;

    Assert( pISegment != NULL );
    
    if( (_pRange != NULL) && (pISegment != NULL ) )
    {
        hr = _pRange->QueryInterface(IID_ISegment, (void **)pISegment);
    }

    RRETURN(hr);        
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::IsDone
//
//  Synopsis:   Returns whether or not we have iterated past the end of our
//              list.
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = There are no more elements
//              S_FALSE = There are more elements
//
//--------------------------------------------------------------------------
HRESULT
CAutoRangeIterator::IsDone(void)
{
    return (_fDone == TRUE) ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::Advance
//
//  Synopsis:   Advances the iterator by one element.  For the auto range, 
//              which only has one element, this sets fDone to TRUE
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = The iterator was advanced successfully
//              S_FALSE = The advance operation failed
//
//--------------------------------------------------------------------------
HRESULT
CAutoRangeIterator::Advance(void)
{
    HRESULT hr = S_FALSE;

    if( IsDone() == S_FALSE )
    {
        _fDone = TRUE;
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::QueryInterface
//
//  Synopsis:   IUnknown QueryInterface implementation
//--------------------------------------------------------------------------
STDMETHODIMP
CAutoRangeIterator::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppvObj )
{
    if(!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegmentListIterator )
    {
        *ppvObj = (ISegmentListIterator *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}


//+====================================================================================
//
// Method:   LeftOrSlave
//
// Synopsis: Like IMarkupPointer::Left, but doesn't hide textslave
//
//------------------------------------------------------------------------------------
HRESULT
CAutoRange::LeftOrSlave (
        IMarkupPointer * pPointer,
        BOOL fMove,
        MARKUP_CONTEXT_TYPE *pContext,
        IHTMLElement** ppElement,
        long *pcch,
        OLECHAR* pchText)
{
    HRESULT          hr = S_OK;
    CMarkupPointer * pmp = NULL;
    DWORD            dwFlags = MPTR_SHOWSLAVE;

    if (!pPointer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pmp ) );
    if (hr)
        goto Cleanup;
        
    hr = THR( pmp->There( TRUE, fMove, pContext, ppElement, pcch, pchText, & dwFlags ) );

Cleanup:

    RRETURN( hr );
}

//+====================================================================================
//
// Method:   RightOrSlave
//
// Synopsis: Like IMarkupPointer::Right, but doesn't hide textslave
//
//------------------------------------------------------------------------------------
HRESULT
CAutoRange::RightOrSlave (
        IMarkupPointer * pPointer,
        BOOL fMove,
        MARKUP_CONTEXT_TYPE *pContext,
        IHTMLElement** ppElement,
        long *pcch,
        OLECHAR* pchText)
{
    HRESULT          hr;
    CMarkupPointer * pmp = NULL;
    DWORD            dwFlags = MPTR_SHOWSLAVE;

    if (!pPointer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pmp ) );
    if (hr)
        goto Cleanup;
        
    hr = THR( pmp->There( FALSE, fMove, pContext, ppElement, pcch, pchText, & dwFlags ) );

Cleanup:

    RRETURN( hr );
}

//
//============================================================================
//


//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::~CAutoRangeCollection
//
//----------------------------------------------------------------

CAutoRangeCollection::~CAutoRangeCollection()
{
    _aryRanges.ReleaseAll();
}


//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CAutoRangeCollection::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLTxtRangeCollection,      // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CAutoRangeCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    if(!ppv)
        return E_POINTER;
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLTxtRangeCollection)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::length
//
//  Sysnopsis : Returns number of elements in the collection
//
//----------------------------------------------------------------

HRESULT
CAutoRangeCollection::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    // Simply return the array size
    *pLength = _aryRanges.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::item
//
//  Sysnopsis : Returns rect at given index
//----------------------------------------------------------------

HRESULT
CAutoRangeCollection::item(VARIANT * pvarIndex, VARIANT * pvarRet)
{
    HRESULT   hr = S_OK;
    CVariant  varArg;
    long      lIndex;

    if (!pvarRet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // ECMA rule - return empty for access beyond array bounds
    V_VT(pvarRet) = VT_EMPTY;

    // first attempt ordinal access...
    hr = THR(varArg.CoerceVariantArg(pvarIndex, VT_I4));
    if (hr==S_OK)
    {
        lIndex = V_I4(&varArg);
    }
    else
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(GetItem(lIndex, pvarRet));
    if(hr)
    {
        if(hr == S_FALSE)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::_newEnum
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
CAutoRangeCollection::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryRanges.EnumVARIANT(VT_DISPATCH,
                                    (IEnumVARIANT**)ppEnum,
                                    FALSE,
                                    FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::FindByName
//
//  Sysnopsis : This function seraches for an item having given
//                name in the collection and returns its index.
//                It returns -1 if item is not found.
//              We do not support named items for rectangle 
//               collection so we always return a -1
//----------------------------------------------------------------
long 
CAutoRangeCollection::FindByName(LPCTSTR pszName, BOOL fCaseSensitive)
{
    return -1;
}

//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::GetName
//
//  Sysnopsis : This virtual function returns the name of given item.
//              We do not support named collection access.
//----------------------------------------------------------------

LPCTSTR 
CAutoRangeCollection::GetName(long lIdx)
{
    return NULL;
}


//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::GetItem
//
//  Sysnopsis : Returns the item that has given order in the collection.
//              If the index is out of range returns S_FALSE.
//              If ppDisp is NULL only checks that range and returns
//               S_OK if index is in range, S_FALSE if out
//
//----------------------------------------------------------------

HRESULT 
CAutoRangeCollection::GetItem( long lIndex, VARIANT *pvar )
{
    HRESULT hr;
    CAutoRange * pRange;

    if (lIndex < 0 || lIndex >= _aryRanges.Size())
    {
        hr = S_FALSE;
		if(pvar)
			V_DISPATCH(pvar) = NULL;
        goto Cleanup;
    }

    if(!pvar)
    {
        // No ppDisp, caller wanted only to check for correct range
        hr = S_OK;
        goto Cleanup;
    }

    V_DISPATCH(pvar) = NULL;

    pRange = _aryRanges[lIndex];
    Assert(pRange);
    hr = THR(pRange->PrivateQueryInterface(IID_IDispatch, (void **) &V_DISPATCH(pvar)));
    if (hr)
        goto Cleanup;

    V_VT(pvar) = VT_DISPATCH;
Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lscomplx.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSCOMPLX.CXX -- line services complex script support
 *
 *
 *  Owner: <nl>
 *      Michael Jochimsen <nl>
 *
 *  History: <nl>
 *      04/02/98     mikejoch created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include <wchdefs.h>
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include <txtdefs.h>
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

MtDefine(CAryDirRun_pv, LineServices, "CAryDirRun::_pv");
MtDefine(CComplexRun, LineServices, "CComplexRun");
MtDefine(CBidiLine, LineServices, "CBidiLine");
MtDefine(CComplexRunComputeAnalysis_aryAnalysis_pv, Locals, "CComplexRun::ComputeAnalysis::aryAnalysis_pv");
MtDefine(CComplexRunNoSpaceLangBrkcls_aryItemize_pv, Locals, "CComplexRun::NoSpaceLangBrkcls::aryItemize::_pv");
MtDefine(CComplexRunNoSpaceLangBrkcls_aryItems_pv, Locals, "CComplexRun::NoSpaceLangBrkcls::aryItems::_pv");

#define DEFAULT_CHARS_TO_EVALUATE ((LONG) 100)

extern LCID g_lcidLocalUserDefault;

extern CGlobalCriticalSection g_csJitting;
extern BYTE g_bUSPJitState;

//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::CBidiLine
//
//  Synopsis:   Create a complex line. This essentially consists of
//              grabbing copies of the properties that describe the line's
//              place in the backing store, initializing the bidi stack and
//              algorithm state, and priming the DIR_RUN array. If we know the
//              length of the line already the we also go ahead and run the
//              bidi algorithm for the text in the line.
//
//-----------------------------------------------------------------------------
CBidiLine::CBidiLine(
    const CTreeInfo & treeinfo,
    LONG cp,
    BOOL fRTLPara,
    const CLineFull * pli) :
        _txtptr(treeinfo._pMarkup, cp)
{
#ifdef NO_IMPLICIT_BIDI
    DIR_RUN dr;

    dr.cp = cp;
    dr.iLevel = fRTLPara;
    _aryDirRun.AppendIndirect(&dr);
#else
    const CCharFormat * pCF = NULL;
    CTreeNode * ptn;
    DIR_RUN dr;
    LONG nEmbed;
    WORD wDir;
    WORD wOverride;
    LONG cchOffset;

    // Keep a copy of the flow layout and markup.
    _pFlowLayout = treeinfo._pFlowLayout;
    _pMarkup = treeinfo._pMarkup;
    Assert(_pFlowLayout != NULL && _pMarkup != NULL);

    // The cp should be in the scope of the flow layout.
    Assert(cp >= _pFlowLayout->GetContentFirstCp() && cp <= _pFlowLayout->GetContentLastCp());
    _cpFirst = _cp = cp;
    _cpLim = treeinfo._cpLayoutLast;

     // Initialize the tree pointer and _cchRemaining.
    _ptp = _pMarkup->TreePosAtCp(cp, &cchOffset);
    _cchRemaining = (_ptp->IsText() ? _ptp->Cch() - cchOffset : 0);
    Assert(_ptp != NULL && (!_ptp->IsText() || _cchRemaining > 0));

    // Initialize the bidi stack.
    _fRTLPara = fRTLPara;
    // TODO (track bug 112281): SLOWBRANCH: GetBranch is very slow, but it is the best thing to
    // use here. It only gets called when the CBidiLine is created, so it isn't
    // actually prohibitive.
    ptn = _ptp->GetBranch();
    nEmbed = 0;
    wDir = 0;
    wOverride = 0;
    while (ptn && !ptn->Element()->IsBlockElement() && ptn->GetUpdatedLayout() != _pFlowLayout)
    {
        // We can measure lines with the node chars for the phrase elements at BOL;
        // this would happen when we have borders/glyphs/backgrounds etc. To handle
        // this case, make sure that we do account for them here, since we are going 
        // to see the begin node's for these elements during our regular processing.
        if (_cpFirst >= ptn->Element()->GetFirstCp())
        {
            pCF = ptn->GetCharFormat();
            if (pCF->_fBidiEmbed)
            {
                wDir = (wDir << 1) | pCF->_fRTL;
                wOverride = (wOverride << 1) | pCF->_fBidiOverride;
                nEmbed++;
            }
        }
        ptn = ptn->Parent();
    }

    _iLevel = _fRTLPara;
    // set the static reading order state for the line
    if (ptn)
    {
        _fVisualLine = (_pMarkup->_fVisualOrder &&
                        !ptn->Element()->HasFlag(TAGDESC_LOGICALINVISUAL));
        _dcEmbed = (_fVisualLine || ptn->GetCharFormat()->_fBidiOverride ) 
                    ? (_fRTLPara ? RLO : LRO) : (_fRTLPara ? RLE : LRE);
    }
    _iEmbed = 0;
    _iOverflow = 0;
    while (nEmbed > 0)
    {
        // We're starting an embedding. Update the stack and _iLevel.
        BOOL fRTL = (wDir & 1);
        if (_iLevel < 14 + fRTL && _iOverflow == 0)
        {
            _aEmbed[_iEmbed++] = _dcEmbed;
            _iLevel += 1 + ((_iLevel & 1) == fRTL);
            _dcEmbed = (wOverride & 1) ? (fRTL ? RLO : LRO) : (fRTL ? RLE : LRE);
        }
        else
        {
            _iOverflow++;
        }
        wDir >>= 1;
        wOverride >>= 1;
        nEmbed--;
    }

    // Initialize the bidi algorithm state.
    _dcPrev = _dcPrevStrong = GetInitialDirClass(_iLevel & 1);

    // Initialize the run array. We always have at least one entry in the
    // current embedding level (usually the paragraph direction). We don't need
    // to worry about OOM because we're derived from a CStackDataArray with 8
    // element.
    dr.cp = cp;
    dr.iLevel = _iLevel;
    _aryDirRun.AppendIndirect(&dr);
    Assert(_aryDirRun.Size() == 1);

    // Initialize to current run to zero.
    _iRun = 0;

    if (pli != NULL)
    {
        // If we know the length of the line already precompute the runs.
        Assert(cp + pli->_cch <= _cpLim);
        if (pli->_cch > 0)
        {
            EvaluateLayoutToCp(cp + pli->_cch - 1, cp + pli->_cch - 1);
            AdjustTrailingWhitespace(cp + pli->_cch - 1);
        }
    }

#if DBG==1
    _fStringLayout = FALSE;
#endif
#endif // NO_IMPLICIT_BIDI
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::CBidiLine
//
//  Synopsis:   Create a complex line from a text buffer. This is used to get
//              the ordering for bidi numbering. We basically just zap out most
//              of the properties and pass the text straight into the bidi
//              algorithm.
//
//-----------------------------------------------------------------------------
CBidiLine::CBidiLine(
    BOOL fRTLPara,
    LONG cchText,
    const WCHAR * pchText)
{
#ifdef NO_IMPLICIT_BIDI
    DIR_RUN dr;

    dr.cp = 0;
    dr.iLevel = fRTLPara;
    _aryDirRun.AppendIndirect(&dr);
#else
    DIR_RUN dr;

    // Nuke the flow layout and markup.
    _pFlowLayout = NULL;
    _pMarkup = NULL;

    // Set CPs. These are just indices into pchText.
    _cpFirst = _cp = 0;
    _cpLim = cchText - 1;

     // Nuke the tree pointer and _cchRemaining.
    _ptp = NULL;
    _cchRemaining = 0;

    // Initialize the bidi stack.
    _fRTLPara = fRTLPara;
    _iLevel = _fRTLPara;
    _dcEmbed = _fRTLPara ? RLE : LRE;
    _iEmbed = 0;
    _iOverflow = 0;

    // Initialize the bidi algorithm state.
    _dcPrev = _dcPrevStrong = (_iLevel & 1) ? RTL : LTR;

    // Initialize the run array. We always have at least one entry in the
    // current embedding level. We don't need to worry about OOM because we're
    // derived from a CStackDataArray with 8 elements.
    dr.cp = 0;
    dr.iLevel = _iLevel;
    _aryDirRun.AppendIndirect(&dr);
    Assert(_aryDirRun.Size() == 1);

    // Initialize to current run to zero.
    _iRun = 0;

    // We've already got the text so compute the runs.
    EvaluateLayout(pchText, cchText, BLK, BLK, 0);
    _cp += cchText;

#if DBG==1
    _fStringLayout = TRUE;
#endif
#endif // NO_IMPLICIT_BIDI
}


#if DBG==1
//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::IsEqual
//
//  Synopsis:   Check to see if the line which would be created using the
//              passed parameters is the same as the current line.
//
//  Returns:    TRUE if the lines would be the same, FALSE if not.
//
//-----------------------------------------------------------------------------
BOOL CBidiLine::IsEqual(
    const CTreeInfo & treeinfo,
    LONG cp,
    BOOL fRTLPara,
    const CLineFull * pli) const
{
#ifdef NO_IMPLICIT_BIDI
    return _aryDirRun[0].cp == cp;
#else
    Assert(!_fStringLayout);
    return _pFlowLayout == treeinfo._pFlowLayout &&
           _pMarkup == treeinfo._pMarkup &&
           _cpFirst == cp &&
           _cpLim == treeinfo._cpLayoutLast &&
           _fRTLPara == (unsigned)fRTLPara;
#endif // NO_IMPLICIT_BIDI
}
#endif


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::GetInitialDirClass
//
//  Synopsis:   Figure out the start state for the bidi algorithm, based on the
//              line direction, document charset, and system locale.
//
//  Returns:    The initial DIRCLS used to prime the bidi algorithm.
//
//-----------------------------------------------------------------------------
DIRCLS
CBidiLine::GetInitialDirClass(
    BOOL fRTLLine)
{
    if (!fRTLLine)
    {
        // LTR lines always start with a LTR DIRCLS.
        return LTR;
    }

    CODEPAGE codepage = _pFlowLayout->ElementOwner()->GetMarkup()->GetCodePage();

    switch (codepage)
    {
    case CP_ASMO_708:
    case CP_ASMO_720:
    case CP_1256:
    case CP_ISO_8859_6:
        // If the charset is Arabic, set the DIRCLS to be ARA.
        return ARA;
    case CP_UNDEFINED:
    case CP_UCS_2:
    case CP_UCS_2_BIGENDIAN:
    case CP_AUTO:
    case CP_AUTO_JP:
    case CP_UTF_7:
    case CP_UTF_8:
    case CP_UCS_4:
    case CP_UCS_4_BIGENDIAN:
        // If the charset is ambiguous, and the system locale is Arabic, set
        // the DIRCLS to ARA.
        if(IsInArabicBlock(PRIMARYLANGID(g_lcidLocalUserDefault)))
        {
            return ARA;
        }
    }

    // In all other cases, set the DIRCLS to RTL for RTL lines.
    return RTL;
}

//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::DirClassFromChAndContextSlow
//
//  Synopsis:   Figure out character's direction class based on its context.
//
//-----------------------------------------------------------------------------
DIRCLS 
CBidiLine::DirClassFromChAndContextSlow(WCHAR ch, LANGID lang, LANGID sublang)
{
    Assert(ch == WCH_PLUSSIGN || ch == WCH_MINUSSIGN);

    DIRCLS   dc = DirClassFromCh(ch);
    CODEPAGE cp = _pMarkup->GetFamilyCodePage();

    Assert(dc == NEU);

    // The + and - signs need to be classified as ES when used with Hebrew Script
    // 1. If the language of the run is Hebrew, change
    // 2. If the language of the run is Yiddish, change (uses Hebrew script)
    // 3. If no language is assigned to the run, and the previous strong character 
    //    has DIRCLS of RTL, and the document CP is Hebrew or the user's default 
    //    LCID is Hebrew or Yiddish, change
    if (   LANG_HEBREW == lang
        || LANG_YIDDISH == lang
        || (   LANG_NEUTRAL == lang
            && RTL == _dcPrevStrong
            && (   CP_1255 == cp 
                || LANG_HEBREW == PRIMARYLANGID(g_lcidLocalUserDefault)
                || LANG_YIDDISH == PRIMARYLANGID(g_lcidLocalUserDefault)) ) )
    {
        dc = ESP;
    }

    return dc;
}

//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::GetRunCchRemaining
//
//  Synopsis:   Gets the number of characters remaining in the DIR_RUN at cp,
//              limited by cchMax. This will just look in the run array if
//              possible, but if cp is beyond the end of the run array then we
//              will extend the run array by analyzing the text with the bidi
//              algorithm.
//
//  Returns:    The number of characters remaining in the DIR_RUN or cchMax,
//              whichever is greater.
//
//-----------------------------------------------------------------------------
LONG
CBidiLine::GetRunCchRemaining(
    LONG cp,
    LONG cchMax)
{
#ifdef NO_IMPLICIT_BIDI
    return cchMax;
#else
    LONG iRun;
    LONG cch;

    Assert(!_fStringLayout);
    Assert(cp >= _cpFirst && cp <= _cpLim);
    Assert(cchMax > 0);

    // If we don't have the requested run evaluate it with the bidi algorithm.
    if (cp + cchMax > _cp)
    {
        EvaluateLayoutToCp(cp + cchMax - 1);
        Assert(cp < _cp);
    }

    // Find the requested run.
    iRun = FindRun(cp);
    Assert(iRun >= 0 && iRun < _aryDirRun.Size());

    // Get the length of the requested run.
    cch = ((iRun == _aryDirRun.Size() - 1) ? _cp : _aryDirRun[iRun + 1].cp) - cp;

    return min(cchMax, cch);
#endif // NO_IMPLICIT_BIDI
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::GetDirRun
//
//  Synopsis:   Gets the DIR_RUN at cp.
//
//  Returns:    The DIR_RUN at cp.
//
//-----------------------------------------------------------------------------
const DIR_RUN &
CBidiLine::GetDirRun(
    LONG cp)
{
#ifdef NO_IMPLICIT_BIDI
    return _aryDirRun[0];
#else
    LONG iRun;

    Assert(!_fStringLayout);
    Assert(cp >= _cpFirst && cp <= _cpLim);

    // If we don't have the requested run evaluate it with the bidi algorithm.
    if (cp >= _cp)
    {
        EvaluateLayoutToCp(cp);
        Assert(cp < _cp);
    }

    // Find the requested run.
    iRun = FindRun(cp);
    Assert(iRun >= 0 && iRun < _aryDirRun.Size());

    // Return the requested DIR_RUN.
    return _aryDirRun[iRun];
#endif // NO_IMPLICIT_BIDI
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::FindRun
//
//  Synopsis:   Find the run which contains the specified cp. Set _iRun and
//              return the run value.
//
//  Returns:    The run that the cp is in.
//
//-----------------------------------------------------------------------------
LONG
CBidiLine::FindRun(
    LONG cp)
{
    Assert(!_fStringLayout);
    Assert(_aryDirRun.Size() != 0);
    Assert(cp >= _cpFirst && cp < _cp);
    Assert(_iRun >= 0 && _iRun < _aryDirRun.Size());

    // If the requested cp is in the range of _aryDirRun[_iRun] then we can
    // just return _iRun. Otherwise we'll have to search for it.
    if (_aryDirRun[_iRun].cp > cp ||
        (_iRun != _aryDirRun.Size() - 1 && _aryDirRun[_iRun + 1].cp <= cp))
    {
        LONG iRun;

        // We have to search for the correct run. If the current run (_iRun)
        // is before cp, then we start searching from _iRun (which we will
        // do most of the time), otherwise we start searching from the start of
        // the run array. We keep searching until we blow out the end of the
        // run array or we find a run beyond cp, at which point we back up
        // one run.
        for (iRun = (_aryDirRun[_iRun].cp <= cp) ? _iRun : 0;
             iRun < _aryDirRun.Size() && _aryDirRun[iRun].cp <= cp;
             iRun++);
        _iRun = iRun - 1;
    }

    // Make sure the current run is in range.
    Assert(_iRun >= 0 && _iRun < _aryDirRun.Size());

    return _iRun;
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::LogicalToVisual
//
//  Synopsis:   Convert an array of characters from logical to visual order
//              using the levels stored in _aryDirRun[]. The visual string is
//              passed back in pchVisual. The conversion optionally reverse the
//              visual string, which is handy if it will eventually be rendered
//              RTL (as with RTL numbering).
//
//              The algorithm used is not necessarily the fastest out there,
//              but given that this function is primarily used for strings that
//              are no deeper than 2 levels and are virtually never longer than
//              10 characters it should suffice.
//
//-----------------------------------------------------------------------------
void CBidiLine::LogicalToVisual(
    BOOL fRTLBuffer,
    LONG cchText,
    const WCHAR * pchLogical,
    WCHAR * pchVisual)
{
    LONG iLev = 0;
    LONG iRun;
    LONG cRun = _aryDirRun.Size();
    WCHAR * pch1;
    WCHAR * pch2;
    WCHAR ch;

    Assert(_fStringLayout);

    // Copy off the logical buffer.
    CopyMemory(pchVisual, pchLogical, cchText * sizeof(WCHAR));

    // Find run with the deepest level
    for (iRun = 0; iRun < cRun; iRun++)
    {
        iLev = max(iLev, _aryDirRun[iRun].iLevel);
    }

    // For each level, walk through the runs.

    while (iLev > 0)
    {
        for (iRun = 0; iRun < cRun; iRun++)
        {
            // If the run is as deep as the current level, reverse the text
            // under it.
            if (_aryDirRun[iRun].iLevel >= iLev)
            {
                pch1 = pchVisual + _aryDirRun[iRun].cp;
                // Look forward for a run which is shallower than the current
                // level.
                while (++iRun < cRun && _aryDirRun[iRun].iLevel >= iLev);
                pch2 = pchVisual + (iRun == cRun ? _cp : _aryDirRun[iRun].cp) - 1;
                while (pch1 < pch2)
                {
                    ch = *pch1;
                    *pch1 = *pch2;
                    *pch2 = ch;
                    pch1++;
                    pch2--;
                }
                iRun--;
            }
        }
        iLev--;
    }

    // If the fRTLBuffer flag is set reverse the entire buffer.
    if (fRTLBuffer)
    {
        pch1 = pchVisual;
        pch2 = pchVisual + cchText - 1;
        while (pch1 < pch2)
        {
            ch = *pch1;
            *pch1 = *pch2;
            *pch2 = ch;
            pch1++;
            pch2--;
        }
    }
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::EvaluateLayoutToCp
//
//  Synopsis:   Evaluates the text beginning at _cp up to (and including)
//              cpLine using the bidi algorithm. If cpLine is -1, we evaluate
//              the next DEFAULT_CHARS_TO_EVALUATE characters, limited by
//              _cpLim. We also guarentee that we at least evaluate as far as
//              cp.
//
//-----------------------------------------------------------------------------
void
CBidiLine::EvaluateLayoutToCp(
    LONG cp,
    LONG cpLine)
{
    WCHAR ach[DEFAULT_CHARS_TO_EVALUATE];
    LONG cch;
    const WCHAR * pch;
    const WCHAR * pchLim;
    DIRCLS dcTrail;
    DIRCLS dcTrailForNumeric;
    LONG cchFetch;

    Assert(cp >= _cpFirst && cp <= _cpLim &&
           (cpLine == -1 || (cpLine >= _cpFirst && cpLine <= _cpLim)));

    // While we haven't processed the requested cp...
    while (_cp <= cp)
    {
        // Fetch some text from the store
        cchFetch = (cpLine == -1) ?
                   DEFAULT_CHARS_TO_EVALUATE :
                   min(DEFAULT_CHARS_TO_EVALUATE, (LONG) (cpLine - _cp + 1));
        cch = GetTextForLayout(ach, cchFetch, _cp, &_ptp, &_cchRemaining);
        Assert(cch > 0 && cch <= cchFetch);

        // Find the last non-node character
        for (pch = ach + cch; pch-- > ach && *pch == WCH_NODE; );

        // If there was some non-node text in the retreived data...
        if (pch >= ach)
        {
            BOOL fNeedNumericPunctResolution;

            // Get the DIRCLS of the final character.
            dcTrail = DirClassFromChAndContext(*pch, _cp + (pch - ach));

            // If the final DIRCLS is a ETM, ESP, or CSP then we'll need to
            // find the character that resolves it.
            fNeedNumericPunctResolution = IsNumericPunctuationClass(dcTrail);
            dcTrailForNumeric = dcTrail;

            // If the final DIRCLS is neutral we'll need to look beyond it to
            // resolve it in EvaluateLayout().
            if (IsIndeterminateClass(dcTrail))
            {
#define TRAIL_BUFFER 32
                CTreePos * ptpTrail;
                LONG cchTrailRemaining;
                LONG cpTrail;
                LONG cchTrail;
                WCHAR achTrail[TRAIL_BUFFER];

                // Record the position of the end of the fetch. We'll start
                // looking from here.
                ptpTrail = _ptp;
                cchTrailRemaining = _cchRemaining;
                cpTrail = _cp + cch;

                // TEMPORARY FIX: (gschneid) This check prevents IE to crash. In case ptpTrail 
                // is NULL dcTrail is set to BLK which is a reasonable choice. 
                // (TODO) This bug (#20341) needs to be reviewed for blackcomb.
                if (ptpTrail)
                {
                    if (ptpTrail->IsBeginNode() && cchTrailRemaining > 1)
                    {
                        // We're in the midst of an embedding. Go ahead and skip
                        // over all the embedding text, since it will all evaluate
                        // as neutrals and waste lots of our time.
    
                        // We should never need numeric punctuation; since we
                        // should always be preceeded by a WCH_EMBEDDING (neutral).
                        Assert(!fNeedNumericPunctResolution);
                        cpTrail += cchTrailRemaining - 1;
                        cchTrailRemaining = 1;
                    }
    
                    do
                    {
                        // if out of range, break
                        if (cpTrail < _cpFirst || cpTrail > _cpLim)
                        {
                            if (cpTrail > _cpLim && IsIndeterminateClass(dcTrail))
                            {
                                // NOTE (grzegorz): we run out of characters and direction
                                // is still unresolved, treat this situation as and of block
                                dcTrail = BLK;
                            }
                            break;
                        }

                        // Fetch some more text from the store.
                        cchTrail = GetTextForLayout(achTrail, TRAIL_BUFFER, cpTrail,
                                                    &ptpTrail, &cchTrailRemaining);
                        Assert(cchTrail > 0 && cchTrail <= TRAIL_BUFFER);

                        // Advance cpTrail. ptpTrail and cchTrailRemaining have
                        // already been advanced.
                        cpTrail += cchTrail;

                        // Search until we find a non-neutral class (or we run out
                        // of text). Note that WCH_NODE evaluates as neutral.
                        for (pch = achTrail, pchLim = achTrail + cchTrail;
                             pch < pchLim && IsIndeterminateClass(dcTrail);
                            pch++)
                        {
                            dcTrail = DirClassFromChAndContext(*pch, cpTrail + (pch - achTrail));
                            if (dcTrail == FMT)
                            {
                                // FMT covers all the embedding control characters.
                                // We need to differentiate between them.
                                Assert(InRange(*pch, WCH_LRE, WCH_RLO));
                                dcTrail = s_adcEmbedding[*pch - WCH_LRE];
                            }

                            // If we need to find a character to resolve a ETM,
                            // ESP, or CSP then check for it here. Note that ESP
                            // and CSP are resolved by whatever the next character
                            // is, while ETM needs the next non-ETM character.
                            if (fNeedNumericPunctResolution &&
                                *pch != WCH_NODE &&
                                (dcTrail != ETM || IsNumericSeparatorClass(dcTrailForNumeric)))
                            {
                                dcTrailForNumeric = dcTrail;
                                fNeedNumericPunctResolution = FALSE;
                            }
                        }

                    // If that pass failed to find a dcTrail that would resolve
                    // things pull in some more text.
                    } while (IsIndeterminateClass(dcTrail));
                    // This flag should always get cleared in the above loop.
                    // TODO (grzegorz): see IE6 #20157, need to reenable this assert.
                    //      For now it's harmless assert in some situations 
                    //      (see repro file for the bug).
                    // Assert(!fNeedNumericPunctResolution);

                    // Let 'er rip! _cp is only needed to record the DIR_RUNs.
                }
                else
                {
                    // See comment of gschneid at the beginning of the if statement.
                    // (TODO) When reviewing this bug please take grzegorz comment above in
                    // account.
                    dcTrail = BLK;
                }
            }

            EvaluateLayout(ach, cch, dcTrail, dcTrailForNumeric, _cp);
        }

        // We've now added all cch characters to _aryDirRun[]. Move _cp ahead.
        _cp += cch;
    }
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::EvaluateLayout
//
//  Synopsis:   Evaluates pchText using the bidi algorithm. When this function
//              is called we assume that we are in the midst of processing
//              EvaluateLayout() several times, hence we carry the following
//              state:
//
//              _dcPrev         Previous resolved character class
//              _dcPrevStrong   Previous strong character class
//              _iLevel         Current level
//              _dcEmbed        Type of current embedding
//              _aEmbed         Bidi stack
//              _iEmbed         Depth of bidi stack
//              _iOverflow      Overflow from bidi stack
//              _fRTLPara       Paragraph direction
//
//              This state is updated by the algorithm to reflect the
//              processing of the text in pchText. The algorithm also updates
//              _aryDirRun to include a list of directions matching the
//              resolved levels of pchText.
//
//              WARNING! This function can only deal with text which is shorter
//              than DEFAULT_CHARS_TO_EVALUATE. The calling functions currently
//              constrain this so it's not a problem. If (at some future time)
//              it becomes necessary to deal with text longer than this, turn
//              on HANDLE_LONG_LAYOUT_TEXT.
//
//-----------------------------------------------------------------------------
void
CBidiLine::EvaluateLayout(
    const WCHAR * pchText,
    LONG cchText,
    DIRCLS dcTrail,
    DIRCLS dcTrailForNumeric,
    LONG cp)
{
    DIRCLS dc;
    DIRCLS dcPrev;
    const WCHAR * pchLim;
    const WCHAR * pch;
    DIRCLS adc[DEFAULT_CHARS_TO_EVALUATE];
    LONG cdc;
    DIRCLS * pdcStart = adc;
    DIRCLS * pdcLim;
    DIRCLS * pdc;
    DIRCLS * pdcNeutral;
    DIRCLS dcNumeral;
    DIRCLS dcNeutral;
    BYTE aLevel[DEFAULT_CHARS_TO_EVALUATE];
    BYTE * pLevelStart = aLevel;
    BYTE * pLevel;
    BYTE iLevel;
    BOOL fRTL = FALSE;

    // Verify our parameters
    Assert(pchText != NULL && !IsIndeterminateClass(dcTrail) && cp <= _cpLim);

    // Verify our state
    Assert(IsFinalClass(_dcPrev) && IsStrongClass(_dcPrevStrong));
    Assert((_iLevel & 1) == IsRTLEmbeddingClass(_dcEmbed));
#if DBG==1
    {
        LONG i;
        LONG iLev;

        iLev = _iLevel;
        for (i = _iEmbed - 1; i >= 0; i--)
        {
            Assert(IsEmbeddingClass(_aEmbed[i]));
            iLev -= 1 + ((iLev & 1) == IsRTLEmbeddingClass(_aEmbed[i]));
        }
        Assert(_iLevel < 16 && iLev == (long)_fRTLPara);
    }
#endif

#ifdef HANDLE_LONG_LAYOUT_TEXT
    // If there are more characters than will fit in our stack buffers
    // allocatate some working buffers off the heap.
    if (cchText > DEFAULT_CHARS_TO_EVALUATE)
    {
        pdcStart = new DIRCLS[cchText];
        pLevelStart = new BYTE[cchText];
        if (pdcStart == NULL || pLevelStart == NULL)
        {
            goto Cleanup;
        }
    }
#else
    Assert(cchText <= DEFAULT_CHARS_TO_EVALUATE);
#endif

    // Convert the characters into DIRCLSs
    pch = pchText;
    pdc = pdcStart;
    pchLim = pchText + cchText;
    for (pch = pchText; pch < pchLim; pch++)
    {
        // Skip nodes. They have no effect on layout.
        if (*pch != WCH_NODE)
        {
            dc = DirClassFromChAndContext(*pch, _cp + (pch - pchText));
            if (dc == FMT)
            {
                // FMT covers all the embedding control characters. We need to
                // differentiate between them.
                Assert(InRange(*pch, WCH_LRE, WCH_RLO));
                dc = s_adcEmbedding[*pch - WCH_LRE];
            }
            *pdc++ = dc;
        }
    }
    cdc = pdc - pdcStart;
    pdcLim = pdc;

    // Resolve breaks, embeddings, and overrides and set base level values.
    pdc = pdcStart;
    pLevel = pLevelStart;
    while (pdc < pdcLim)
    {
        if (IsBreakOrEmbeddingClass(*pdc))
        {
            dc = *pdc;
            switch (dc)
            {
            case BLK:
                // Block breaks reset the embedding level and are resolved as
                // strong characters in the paragraph direction.
                _iEmbed = 0;
                _iLevel = _fRTLPara;
                _dcEmbed = _fVisualLine ? (_fRTLPara ? RLO : LRO) : (_fRTLPara ? RLE : LRE);

                break;
            case SEG:
                // Segment separators are set at the paragraph level and are
                // resolved as strong characters in the paragraph direction.
                // Note that the do NOT reset the stack, so we advance pdc and
                // pLevel and continue.
                *pLevel++ = (BYTE)_fRTLPara;
                *pdc++ = _fRTLPara ? RTL : LTR;
                continue;
            case PDF:
                // PDF resets the embedding level to the previous entry on the
                // stack. It is resolved as a strong character in the direction
                // of the current level before the stack is popped. Since the
                // level and dc do not necessarily match the popped values, we
                // advance pLevel and pdc and continue.
                *pLevel++ = _iLevel;
                *pdc++ = (_iLevel & 1) ? RTL : LTR;
                if (_iEmbed > 0 && _iOverflow == 0)
                {
                    _dcEmbed = _aEmbed[--_iEmbed];
                    fRTL = IsRTLEmbeddingClass(_dcEmbed);
                    _iLevel -= 1 + ((_iLevel & 1) == fRTL);
                }
                else if (_iOverflow > 0)
                {
                    _iOverflow--;
                }
                continue;
            case LRE:
            case RLE:
            case LRO:
            case RLO:
                // The embedding controls push the current embedding onto the
                // stack and set a new embedding direction. They are resolved
                // as strong characters in the direction of the embedding.
                fRTL = IsRTLEmbeddingClass(dc);
                if (_iLevel < 14 + fRTL && _iOverflow == 0)
                {
                    _aEmbed[_iEmbed++] = _dcEmbed;
                    _iLevel += 1 + ((_iLevel & 1) == fRTL);
                    _dcEmbed = dc;
                }
                else
                {
                    _iOverflow++;
                }
                break;
#if DBG==1
            default:
                Assert(FALSE);
                break;
#endif
            }
            // All block characters are resolved as strong characters.
            *pdc = (_iLevel & 1) ? RTL : LTR;
        }
        if (IsOverrideClass(_dcEmbed))
        {
            // If we're currently in an override stomp on the dc and turn it
            // into a strong character in the override direction.
            *pdc = (_dcEmbed == LRO) ? LTR : RTL;
        }
        // Record the level and advance pLevel and pdc.
        *pLevel++ = _iLevel;
        pdc++;
    }
    if (IsBreakOrEmbeddingClass(dcTrail))
    {
        // If the dcTrail class is a break or embedding turn it into the
        // appropriate strong direction.
        switch (dcTrail)
        {
        case BLK:
        case SEG:
            fRTL = _fRTLPara;
            break;
        case PDF:
            fRTL = (_iLevel & 1);
            break;
        case LRE:
        case LRO:
            fRTL = FALSE;
            break;
        case RLE:
        case RLO:
            fRTL = TRUE;
            break;
#if DBG==1
        default:
            Assert(FALSE);
            break;
#endif
        }
        dcTrail = fRTL ? RTL : LTR;
    }

    // Resolve numerals.
    dcPrev = _dcPrevStrong;
    for (pdc = pdcStart; pdc < pdcLim; pdc++)
    {
        if (IsStrongClass(*pdc))
        {
            dcPrev = *pdc;
        }
        else if (*pdc == ENM)
        {
            // European numerals are changed into ENL, ENR, or ANM depending
            // on the previous strong character.
            Assert(IsStrongClass(dcPrev));
            *pdc = s_adcNumeric[dcPrev];
        }
    }
    if (dcTrail == ENM)
    {
        // The trailing character is also changed to ENL, ENR or ANM.
        dcTrail = s_adcNumeric[dcPrev];
    }

    // Update _dcPrevStrong to the last strong class in the text.
    _dcPrevStrong = dcPrev;

    // Resolve numeric punctuation (separators and terminators).
    dcPrev = _dcPrev;
    for (pdc = pdcStart; pdc < pdcLim; pdc++)
    {
        if (IsNumericPunctuationClass(*pdc))
        {
            if (*pdc == ETM)
            {
                DIRCLS * pdcT;

                if (!IsResolvedEuroNumClass(dcPrev))
                {
                    // If the run of ETMs is bounded by a ENL or ENR then we
                    // get dcPrev set to ENL or ENR.
                    for (pdcT = pdc + 1; pdcT < pdcLim && *pdcT == ETM; pdcT++);
                    if (pdcT == pdcLim)
                    {
                        if (dcTrailForNumeric == ENM)
                        {
                            dcTrailForNumeric = s_adcNumeric[_dcPrevStrong];
                        }
                        pdcT = &dcTrailForNumeric;
                    }
                    dcPrev = *pdcT;
                }
                // Turn the ETMs into ENLs or ENRs if they are bounded on
                // either side by such a class, otherwise turn them into NEUs.
                dcNumeral = IsResolvedEuroNumClass(dcPrev) ? dcPrev : NEU;
                for (pdcT = pdc; pdcT < pdcLim && *pdcT == ETM; pdcT++)
                {
                    *pdcT = dcNumeral;
                }
            }
            else
            {
                // If a separator is bounded on both sides by numerals of the same
                // class, and it is not an ESP bounded by ANMs, turn it into such
                // a numeral. Otherwise turn it into a neutral.
                DIRCLS dcNext = (pdc + 1 < pdcLim) ? *(pdc + 1) : dcTrailForNumeric;
                if (dcPrev == dcNext &&
                    (IsResolvedEuroNumClass(dcPrev) || (dcPrev == ANM && *pdc == CSP)) )
                {
                    *pdc = dcPrev;
                }
                else
                {
                    *pdc = NEU;
                }
            }
        }
        dcPrev = *pdc;
    }

    // Resolve neutrals
    dcPrev = _dcPrev;
    pLevel = pLevelStart;
    pdcNeutral = NULL;
    for (pdc = pdcStart; pdc < pdcLim; pdc++, pLevel++)
    {
        dc = *pdc;
        if (!IsNeutralClass(dc))
        {
            Assert(IsFinalClass(dc));
            if (pdcNeutral != NULL)
            {
                // If this is character is not a neutral and it is preceeded by
                // neutrals (pdcNeutral != NULL) figure out what class the
                // neutrals should be resolved as using s_adcNeutral and
                // replace them with that class.
                Assert(pLevel - pLevelStart >= 1);
                dcNeutral = s_adcNeutral[*(pLevel - 1) & 1][dcPrev][dc];
                while (pdcNeutral < pdc)
                {
                    *pdcNeutral++ = dcNeutral;
                }
                pdcNeutral = NULL;
            }
            dcPrev = dc;
        }
        else if (pdcNeutral == NULL)
        {
            if (dc == CBN)
            {
                // If this is a combining mark let if follow the classification
                // of the previous text
                *pdc = dcPrev;
            }
            else
            {
                // If we encounter a run of neutrals record where the run starts.
                pdcNeutral = pdc;
            }
        }
    }
    if (pdcNeutral != NULL)
    {
        Assert(IsFinalClass(dcTrail));
        // Resolve trailing neutrals using dcTrail.
        dcNeutral = s_adcNeutral[_iLevel & 1][dcPrev][dcTrail];
        while (pdcNeutral < pdcLim)
        {
            *pdcNeutral++ = dcNeutral;
        }
    }

    // Update _dcPrev to the last class in the text.
    if (cdc != 0)
    {
        _dcPrev = *(pdcLim - 1);
    }

    // Convert resolved classes to levels using s_abLevelOffset.
    for (pdc = pdcStart, pLevel = pLevelStart; pdc < pdcLim; pdc++, pLevel++)
    {
        Assert(IsFinalClass(*pdc));
        *pLevel += s_abLevelOffset[*pLevel & 1][*pdc];
    }

    // Convert the resolved levels into an array of DIR_RUNs. We merge the
    // nodes back in at this time.
    Assert(_aryDirRun.Size() > 0);
    iLevel = _aryDirRun[_aryDirRun.Size() - 1].iLevel;
    for (pch = pchText, pLevel = pLevelStart; pch < pchLim; pch++, cp++)
    {
        if (*pch != WCH_NODE)
        {
            if (*pLevel != iLevel)
            {
                DIR_RUN dr;
                iLevel = *pLevel;
                dr.iLevel = iLevel;
                dr.cp = cp;
                _aryDirRun.AppendIndirect(&dr);
            }
            pLevel++;
        }
    }
    Assert(pLevel == pLevelStart + cdc);

#ifdef HANDLE_LONG_LAYOUT_TEXT
Cleanup:
    if (cchText > DEFAULT_CHARS_TO_EVALUATE)
    {
        // If we had to allocate working buffers off the heap free them now.
        if (pdcStart != NULL)
        {
            Assert(pdcStart != adc);
            delete pdcStart;
        }
        if (pLevelStart != NULL)
        {
            Assert(pLevelStart != aLevel);
            delete pLevelStart;
        }
    }
#endif
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::AdjustTrailingWhitespace
//
//  Synopsis:   Adjusts the trailing whitespace on the line to follow the line
//              direction. This gets called after the bidi algorithm has been
//              run over the full line.
//
//-----------------------------------------------------------------------------
void
CBidiLine::AdjustTrailingWhitespace(
    LONG cpEOL)
{
    LONG iRun;
    BOOL fWhite;
    LONG cchValid;
    LONG cchRemaining;
    CTreePos * ptp;
    const WCHAR * pch=NULL;
    LONG cpTrail;
    LONG cp = cpEOL;

    iRun = _aryDirRun.Size() - 1;
    Assert(iRun >= 0);
    if (_aryDirRun[iRun].iLevel == (long)_fRTLPara)
    {
        // If the last run (potential whitespace) is the same as the paragraph
        // direction, then we don't need to adjust it.
        return;
    }

     // Initialize the tree pointer and cchRemaining.
    ptp = _pMarkup->TreePosAtCp(cpEOL, &cchRemaining);
    if (ptp->IsText())
    {
        cchRemaining++;
    }
    Assert(ptp != NULL && (ptp->IsText() ^ (cchRemaining == 0)));

    // Only need to go back as far as the first direction change. At this point
    // there is either non-white text or a level transition.
    cpTrail = _aryDirRun[iRun].cp;
    fWhite = TRUE;
    cchValid = 0;
    while (fWhite && cp >= cpTrail)
    {
        if (cchValid == 0)
        {
            // This is sort of goofy. GetPchReverse() doesn't actaully return
            // a valid pointer to cp, it returns a pointer to cp such that
            // there is text behind pch. This means that pch itself may point
            // into the gap or beyond the end of a block. We fix this by
            // grabbing text at cp + 1 (which is safe due to the trailing
            // WCH_NODE character) and decrementing pch.
            _txtptr.SetCp(cp + 1);
            pch = _txtptr.GetPchReverse(cchValid);
            Assert(pch != NULL);
            pch--;
        }

        AssertSz(pch != NULL, "Checking on a complaint from the compiler.");
        switch (ptp->Type())
        {
        case CTreePos::NodeBeg:
        case CTreePos::NodeEnd:
            if (ptp->IsEdgeScope())
            {
                Assert(*pch == WCH_NODE && cchRemaining == 0);
                fWhite = !ptp->Branch()->ShouldHaveLayout();
                if (fWhite)
                {
                    cchValid--;
                    pch--;
                    cp--;
                }
            }
            break;
        case CTreePos::Text:
            if (cchRemaining == 0)
            {
                cchRemaining = ptp->Cch();
            }
            while (fWhite && cchValid && cchRemaining && cp >= cpTrail)
            {
                fWhite = (DirClassFromCh(*pch--) == WSP);
                if (fWhite)
                {
                    cchValid--;
                    cchRemaining--;
                    cp--;
                }
            }
            break;
#if DBG==1
        default:
            // The only other type we should encounter are pointers.
            Assert(ptp->Type() == CTreePos::Pointer);
            break;
#endif
        }

        // Update ptp.
        if (!cchRemaining)
        {
            ptp = ptp->PreviousTreePos();
        }
    }

    if (!fWhite || cp < cpTrail)
    {
        cp++;
    }

    Assert(cp >= cpTrail);
    if (cp == cpTrail)
    {
        // If the last run is completely whitespace just change its level.
        _aryDirRun[iRun].iLevel = _fRTLPara;
    }
    else
    {
        // Add another run that follows the paragraph direction which
        // covers the trailing whitespace.
        DIR_RUN dr;
        dr.iLevel = _fRTLPara;
        dr.cp = cp;
        _aryDirRun.AppendIndirect(&dr);
    }
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::GetTextForLayout
//
//  Synopsis:   Gets cch characters from the backing store. Directional
//              embeddings are fixed up to use LRE/RLE/PDF type marks, and
//              elements with their own layout are overridden to WCH_EMBEDDING.
//              The final ptp and the number of characters remaining in it are
//              passed back to the caller.
//
//  Returns:    The number of characters in the buffer. This may be less than
//              cch if an end of line (block element, BR, etc) was encountered.
//
//-----------------------------------------------------------------------------
LONG
CBidiLine::GetTextForLayout(
    WCHAR * pch,
    LONG cch,
    LONG cp,
    CTreePos ** pptp,
    LONG * pcchRemaining)
{
    WCHAR * pchStart;
    WCHAR * pchLim;
    LONG cchRemaining = *pcchRemaining;
    CTreePos * ptp = *pptp;
    CTreeNode * ptnText = NULL;

    // Position the tree node for the text format
    ptnText = ptp->GetBranch();

    // Move the _txtptr to the requested cp.
    if ((LONG) _txtptr.GetCp() != cp)
    {
        _txtptr.SetCp(cp);
    }

    pchStart = pch;
    pchLim = pch + min((LONG) (_cpLim - cp + 1), cch);

    // Copy from the store into the buffer.
    while (pch < pchLim)
    {
        const TCHAR * pchRead;
        LONG cchFetch;

        pchRead = _txtptr.GetPch(cchFetch);

        Assert(pchRead != NULL);

        cchFetch = min(cchFetch, (LONG) (pchLim - pch));
        CopyMemory(pch, pchRead, cchFetch * sizeof(WCHAR));
        pch += cchFetch;
        if (pch < pchLim)
        {
            _txtptr.AdvanceCp(cchFetch);
        }
    }

    pch = pchStart;

    // Keep going while we have characters.
    while (pch < pchLim)
    {
        Assert(ptp != NULL);
        Assert(   *pch == WCH_NODE
               || ptp->IsText()
               || ptp->IsPointer()
               || (   ptp->IsBeginNode()
                   && !ptp->IsEdgeScope()
                  )
               || (   ptp->IsBeginNode()
                   && cchRemaining > 0
                  )
              );

        switch (ptp->Type())
        {
        case CTreePos::NodeBeg:
        {
            if (ptp->NodeCch())
            {
                // Handle element begin processing.
                CTreeNode * ptn = ptp->Branch();
                CElement * pElement = ptn->Element();

                Assert(ptn != NULL);

                // Update the tree node for the text format
                ptnText = ptn;

                if (pElement->HasFlag(TAGDESC_OWNLINE) ||
                    pElement->Tag() == ETAG_BR ||
                    pElement->IsBlockElement())
                {
                    // If the element would force a new line to be created then
                    // replace the node with a CR and cut short the processing.
                    *pch++ = WCH_CR;
                    pchLim = pch;
                }
                else
                {
                    if (!pElement->ShouldHaveLayout())
                    {
                        // We are transitioning into an element's scope. We
                        // need to check to see if the direction level of the
                        // CCharFormat has changed.
                        const CCharFormat * pCF = ptn->GetCharFormat();

                        if (pCF->_fBidiEmbed)
                        {
                            // We've changed levels, so generate a character which
                            // describes the transition.
                            *pch = ((!pCF->_fBidiOverride) ?
                                    (!pCF->_fRTL ? WCH_LRE : WCH_RLE) :
                                    (!pCF->_fRTL ? WCH_LRO : WCH_RLO));
                        }
                        pch++;
                    }
                    else if (pElement->GetUpdatedLayout() != _pFlowLayout)
                    {
                        // We are entering an element which has its own layout. This will
                        // be handled as an embedding, so all we need to do is treat all
                        // the text under the element as a single neutral run.
                        LONG cchEmbed;
                        CTreePos * ptpEnd = NULL;

                        if (cchRemaining == 0)
                        {
                            // cchRemaining is the number of characters under the
                            // element plus the begin and end node characters.
                            pElement->GetTreeExtent(NULL, &ptpEnd);
                            Assert(ptpEnd != NULL && ptpEnd->IsEndNode() &&
                                   ptpEnd->Branch()->Element() == pElement);
                            cchRemaining = ptpEnd->GetCp() - (pch - pchStart + cp) + 1;
                        }

                        cchEmbed = min(cchRemaining, (LONG) (pchLim - pch));
                        cchRemaining -= cchEmbed;
                        while (cchEmbed--)
                        {
                            *pch++ = WCH_SYNTHETICEMBEDDING;
                        }
                        if (cchRemaining == 0)
                        {
                            // Advance the ptp to the end of the element.
                            if (ptpEnd != NULL)
                            {
                                ptp = ptpEnd;
                            }
                            else
                            {
                                pElement->GetTreeExtent(NULL, &ptp);
                                Assert(ptp != NULL && ptp->IsEndNode() &&
                                       ptp->Branch()->Element() == pElement);
                            }
                        }
                    }
                    else
                    {
                        // This is just the beginning of the flow layout. Skip it.
                        Assert(pElement->GetUpdatedLayout() == _pFlowLayout);
                        Assert(ptp->GetCp() == _cpFirst);
                        pch++;
                    }
                }
            }
            break;
        }
        case CTreePos::NodeEnd:
        {
            if (ptp->NodeCch())
            {
                // Handle element end processing.
                CTreeNode * ptn = ptp->Branch();
                CElement * pElement = ptn->Element();

                Assert(ptn != NULL);

                // Update the tree node for the text format
                ptnText = ptn->Parent();

                if (pElement->HasFlag(TAGDESC_OWNLINE) ||
                    pElement->Tag() == ETAG_BR ||
                    pElement->IsBlockElement() ||
                    pElement->GetUpdatedLayout() == _pFlowLayout)
                {
                    // If the element would force a new line to be created then
                    // replace the node with a CR and cut short the processing.
                    *pch = WCH_CR;
                    pchLim = pch;
                }
                else
                {
                    Assert(!pElement->ShouldHaveLayout());

                    // We are transitioning out of an element's scope. We
                    // need to check to see if the direction level of the
                    // CCharFormat has changed.
                    if (ptn->GetCharFormat()->_fBidiEmbed)
                    {
                        // We've changed levels, so generate a PDF.
                        *pch = WCH_PDF;
                    }
                }
                pch++;
            }
            break;
        }
        case CTreePos::Text:
        {
            LONG cchText;
            Assert(ptnText != NULL);
            const CCharFormat * pCF = ptnText->GetCharFormat();

            // Return a text run.
            if (cchRemaining == 0)
            {
                cchRemaining = ptp->Cch();
            }
            cchText = min((LONG) (pchLim - pch), cchRemaining);
            if (pCF->_bCharSet == SYMBOL_CHARSET)
            {
                WCHAR * pchSymbol;
                for (pchSymbol = pch + cchText - 1;
                     pchSymbol >= pch;
                     pchSymbol--)
                {
                    *pchSymbol = WCH_SYNTHETICEMBEDDING;
                }
            }
            pch += cchText;
            cchRemaining -= cchText;
            break;
        }
#if DBG==1
        default:
            // The only other type we should encounter are pointers.
            Assert(ptp->Type() == CTreePos::Pointer);
            break;
#endif
        }

        // Update ptp.
        if (!cchRemaining)
        {
            ptp = ptp->NextTreePos();
        }
    }

    if ((cchRemaining == 0) && ptp && ptp->IsText())
    {
        cchRemaining = ptp->Cch();
    }

    cch = (pch - pchStart);
    *pptp = ptp;
    *pcchRemaining = cchRemaining;

    return cch;
}


//-----------------------------------------------------------------------------
//
//  Table:      CBidiLine::s_adcEmbedding
//
//  Synopsis:   Translates an embedding, override, or PDF character into the
//              appropriate DIRCLS. This is needed because all these characters
//              are in the same partition. If they were in different partitions
//              we wouldn't need this.
//
//-----------------------------------------------------------------------------
const DIRCLS
CBidiLine::s_adcEmbedding[5] =
{
    LRE,    // WCH_LRE (LTR Embedding)
    RLE,    // WCH_RLE (RTL Embedding)
    PDF,    // WCH_PDF (Pop directional formatting)
    LRO,    // WCH_LRE (LTR Override)
    RLO,    // WCH_RLO (RTL Override)
};


//-----------------------------------------------------------------------------
//
//  Table:      CBidiLine::s_adcNumeric
//
//  Synopsis:   Translates an ENM into an ENL, ENR, or ANM based on the
//              preceeding strong character.
//
//-----------------------------------------------------------------------------
const DIRCLS
CBidiLine::s_adcNumeric[3] =
{
    ENL,    // LTR ENM
    ENR,    // RTL ENM
    ANM,    // ARA ENM
};


//-----------------------------------------------------------------------------
//
//  Table:      CBidiLine::s_adcNeutral
//
//  Synopsis:   Translates a neutral into LTR or RTL based on the base
//              embedding direction and the bounding characters. The table is
//              constructed as s_adcNeutral[fRTLEmbedding][dcLead][dcTrail].
//
//-----------------------------------------------------------------------------
const DIRCLS
CBidiLine::s_adcNeutral[2][6][6] =
{
//  Table for LTR embedding. First class is in the rows, second class is the columns.
//  LTR     RTL     ARA     ANM     ENL     ENR
    LTR,    LTR,    LTR,    LTR,    LTR,    LTR,    // LTR
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // RTL
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // ARA
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // ANM
    LTR,    LTR,    LTR,    LTR,    LTR,    LTR,    // ENL
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // ENR

//  Table for RTL embedding. First class is in the rows, second class is the columns.
//  LTR     RTL     ARA     ANM     ENL     ENR
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // LTR
    RTL,    RTL,    RTL,    RTL,    RTL,    RTL,    // RTL
    RTL,    RTL,    RTL,    RTL,    RTL,    RTL,    // ARA
    RTL,    RTL,    RTL,    RTL,    RTL,    RTL,    // ANM
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // ENL
    RTL,    RTL,    RTL,    RTL,    RTL,    RTL,    // ENR
};


//-----------------------------------------------------------------------------
//
//  Table:      CBidiLine::s_abLevelOffset
//
//  Synopsis:   Translates a DIRCLS into a level offset to be added to the base
//              embedding level. The table is constructed as
//              s_abLevelOffset[fRTLEmbedding][dc].
//
//-----------------------------------------------------------------------------
const BYTE
CBidiLine::s_abLevelOffset[2][6] =
{
//  Table for LTR embedding.
    0,  // LTR
    1,  // RTL
    1,  // ARA
    2,  // ANM
    0,  // ENL
    2,  // ENR

//  Table for RTL embedding.
    1,  // LTR
    0,  // RTL
    0,  // ARA
    1,  // ANM
    1,  // ENL
    1,  // ENR
};


//+----------------------------------------------------------------------------
//
//  Function:   CchContextFromScript
//
//  Synopsis:   We return a default script ID based on the language id passed
//              in. There is usually a 1:1 mapping here, but there are
//              exceptions for FE langs. In these cases we try to pick a unique
//              script ID.
//
//  Returns:    Script ID matching the lang.
//
//-----------------------------------------------------------------------------

static const BYTE s_acchContextFromLang[] = 
{
    0,      // LANG_NEUTRAL     0x00
    6,      // LANG_ARABIC      0x01
    0,      // LANG_BULGARIAN   0x02
    0,      // LANG_CATALAN     0x03
    0,      // LANG_CHINESE     0x04
    0,      // LANG_CZECH       0x05
    0,      // LANG_DANISH      0x06
    0,      // LANG_GERMAN      0x07
    0,      // LANG_GREEK       0x08
    0,      // LANG_ENGLISH     0x09
    0,      // LANG_SPANISH     0x0a
    0,      // LANG_FINNISH     0x0b
    0,      // LANG_FRENCH      0x0c
    4,      // LANG_HEBREW      0x0d
    0,      // LANG_HUNGARIAN   0x0e
    0,      // LANG_ICELANDIC   0x0f
    0,      // LANG_ITALIAN     0x10
    0,      // LANG_JAPANESE    0x11
    0,      // LANG_KOREAN      0x12
    0,      // LANG_DUTCH       0x13
    0,      // LANG_NORWEGIAN   0x14
    0,      // LANG_POLISH      0x15
    0,      // LANG_PORTUGUESE  0x16
    0,      //                  0x17
    0,      // LANG_ROMANIAN    0x18
    0,      // LANG_RUSSIAN     0x19
    0,      // LANG_SERBIAN     0x1a
    0,      // LANG_SLOVAK      0x1b
    0,      // LANG_ALBANIAN    0x1c
    0,      // LANG_SWEDISH     0x1d
    3,      // LANG_THAI        0x1e
    0,      // LANG_TURKISH     0x1f
    6,      // LANG_URDU        0x20
    0,      // LANG_INDONESIAN  0x21
    0,      // LANG_UKRAINIAN   0x22
    0,      // LANG_BELARUSIAN  0x23
    0,      // LANG_SLOVENIAN   0x24
    0,      // LANG_ESTONIAN    0x25
    0,      // LANG_LATVIAN     0x26
    0,      // LANG_LITHUANIAN  0x27
    0,      //                  0x28
    6,      // LANG_FARSI       0x29
    0,      // LANG_VIETNAMESE  0x2a
    0,      // LANG_ARMENIAN    0x2b
    0,      // LANG_AZERI       0x2c
    0,      // LANG_BASQUE      0x2d
    0,      //                  0x2e
    0,      // LANG_MACEDONIAN  0x2f
    0,      //                  0x30
    0,      //                  0x31
    0,      //                  0x32
    0,      //                  0x33
    0,      //                  0x34
    0,      //                  0x35
    0,      // LANG_AFRIKAANS   0x36
    0,      // LANG_GEORGIAN    0x37
    0,      // LANG_FAEROESE    0x38
    13,     // LANG_HINDI       0x39
    0,      //                  0x3a
    0,      //                  0x3b
    0,      //                  0x3c
    0,      //                  0x3d
    0,      // LANG_MALAY       0x3e
    0,      // LANG_KAZAK       0x3f
    0,      //                  0x40
    0,      // LANG_SWAHILI     0x41
    0,      //                  0x42
    0,      // LANG_UZBEK       0x43
    0,      // LANG_TATAR       0x44
    13,     // LANG_BENGALI     0x45
    13,     // LANG_PUNJABI     0x46
    13,     // LANG_GUJARATI    0x47
    13,     // LANG_ORIYA       0x48
    13,     // LANG_TAMIL       0x49
    13,     // LANG_TELUGU      0x4a
    13,     // LANG_KANNADA     0x4b
    13,     // LANG_MALAYALAM   0x4c
    13,     // LANG_ASSAMESE    0x4d
    13,     // LANG_MARATHI     0x4e
    13,     // LANG_SANSKRIT    0x4f
    0,      //                  0x50
    0,      //                  0x51
    0,      //                  0x52
    0,      //                  0x53
    0,      //                  0x54
    0,      //                  0x55
    0,      //                  0x56
    13,     // LANG_KONKANI     0x57
    13,     // LANG_MANIPURI    0x58
    6,      // LANG_SINDHI      0x59
    0,      //                  0x5a
    0,      //                  0x5b
    0,      //                  0x5c
    0,      //                  0x5d
    0,      //                  0x5e
    0,      //                  0x5f
    6,      // LANG_KASHMIRI    0x60
    13,     // LANG_NEPALI      0x61
};

BYTE
CchContextFromScript(
    WORD eScript)
{
    const SCRIPT_PROPERTIES * pProp = GetScriptProperties(eScript);
    LANGID lang;

    Assert(pProp != NULL);
    lang = PRIMARYLANGID(pProp->langid);
    if (lang >= 0 && lang < sizeof(s_acchContextFromLang) / sizeof(s_acchContextFromLang[0]))
    {
        return s_acchContextFromLang[lang];
    }
    else
    {
        return sidDefault;
    }
}


//-----------------------------------------------------------------------------
//
//  Function:   CComplexRun::ComputeAnalysis
//
//  Synopsis:   Compute the first SCRIPT_ANALYSIS in the string in pch.
//
//  Returns:    True if the run needs to be glyphed, otherwise false.
//
//-----------------------------------------------------------------------------

void
CComplexRun::ComputeAnalysis(
    const CFlowLayout * pFlowLayout,
    BOOL fRTL,                          // RTL paragraph/line
    BOOL fForceGlyphing,
    WCHAR chNext,
    WCHAR chPassword,
    COneRun * por,
    COneRun * porTail,
    DWORD uLangDigits,
    CBidiLine * pBidiLine)
{
    CStackDataAry<SCRIPT_ITEM, 64> aryItem(Mt(CComplexRunComputeAnalysis_aryAnalysis_pv));
    CStr strText;
    const WCHAR * pch = por->_pchBase;
    LONG cch = por->_lscch;
    HRESULT hr;
    INT cRuns = 0;
    INT iItem;
    WORD eScript;
    BOOL fNumeric;
    BOOL fUseControlState = fRTL;
    SCRIPT_CONTROL sControl = {0};
    SCRIPT_STATE sState = {0};

    // Zap the _Analysis structure and initialize fRTL and fLogicalOrder.
    memset(&_Analysis, 0, sizeof(SCRIPT_ANALYSIS));
    _Analysis.fRTL = fRTL;
    _Analysis.fLogicalOrder = TRUE;

    // We disable glyphing when we're dealing with passwords or symbols. Also,
    // if glyphing causes crashes (Win95FE) then bypass it and return. The net
    // effect of this is that we render as if we didn't have USP loaded.
    if (chPassword || por->GetCF()->_bCharSet == SYMBOL_CHARSET ||
        g_fExtTextOutGlyphCrash)
    {
        _Analysis.eScript = SCRIPT_UNDEFINED;
        return;
    }

    if (fForceGlyphing && chNext != WCH_NULL)
    {
        if (THR(strText.Set(pch, cch)) == S_OK &&
            THR(strText.Append(&chNext, 1)) == S_OK)
        {
            pch = strText;
            cch++;
        }
    }

    // set up state and control
    sState.fArabicNumContext = por->GetCF()->_fRTL;
    sState.uBidiLevel = (fRTL ? 1 : 0);

    sControl.uDefaultLanguage = uLangDigits;

    if (g_iNumShape != NUMSHAPE_NONE && uLangDigits != LANG_NEUTRAL)
    {
        sState.fDigitSubstitute = TRUE;
        fUseControlState = TRUE;
    }

    // Call ScriptItemize().
    if(g_bUSPJitState == JIT_OK)
        hr = ::ScriptItemize(pch, 
                             cch, 
                             64, 
                             fUseControlState ? &sControl : NULL, 
                             fUseControlState ? &sState : NULL, 
                             &aryItem, 
                             &cRuns);
    else
        hr = E_PENDING;

    if (FAILED(hr))
    {
        if(hr == USP10_NOT_FOUND)
        {
            g_csJitting.Enter();
            if(g_bUSPJitState == JIT_OK)
            {
                g_bUSPJitState = JIT_PENDING;

                // We must do this asyncronously.
                IGNORE_HR(GWPostMethodCall(pFlowLayout->Doc(), 
                                           ONCALL_METHOD(CDoc, FaultInUSP, faultinusp), 
                                           0, FALSE, "CDoc::FaultInUSP"));

            }
            g_csJitting.Leave();
        }

        // If ScriptItemize() failed, set the script to SCRIPT_UNDEFINED. This
        // will cause the run to be handled as a regular text run, which, while
        // not acurate, may be legible.
        _Analysis.eScript = SCRIPT_UNDEFINED;
        return;
    }

    // Make sure this is the right size (cRuns + sentinel item).
    Assert(cRuns + 1 == aryItem.Size());

    eScript = aryItem[0].a.eScript;
    fNumeric = IsNumericScript(eScript);

    // Accumulate all the items which have the same script.
    for (iItem = 1; iItem < cRuns && aryItem[iItem].a.eScript == eScript; iItem++);

    // If we're not going to be glyphing this run then we can accumulate
    // additional items.
    if (!fForceGlyphing && uLangDigits == LANG_NEUTRAL && !IsComplexScript(eScript))
    {
        while (iItem < cRuns && !IsComplexScript(aryItem[iItem].a.eScript))
        {
            iItem++;
        }
    }

    Assert(iItem < cRuns + 1);

    // Set the number of characters in the por covered by the _Analysis.
    por->_lscch = min(por->_lscch, (LONG) aryItem[iItem].iCharPos);

    Assert(por->_lscch > 0);

    // Determine the script to be used for shaping and set it in the _Analysis.
    if (IsComplexScript(eScript))
    {
        // If the first item needs to be handled as complex text, find all the
        // adjacent SCRIPT_ITEMs which are of the same script.
        _Analysis.eScript = eScript;
    }
    else if (uLangDigits != LANG_NEUTRAL && (fNumeric || IsNumericSeparatorRun(por, porTail, pBidiLine)))
    {
        // Merge all the adjacent SCRIPT_ITEMs which have the same
        // script.
        _Analysis.eScript = GetNumericScript(uLangDigits);
    }
    else
    {
        // Not a complex or numeric script. Set the script as
        // SCRIPT_UNDEFINED unless we are forcing glyphing.
        if (   fRTL
            || fForceGlyphing
            || InRange(*por->_pchBase, 0x1100, 0x11FF))
        {
            _Analysis.eScript = eScript;
        }
        else
        {
            _Analysis.eScript = SCRIPT_UNDEFINED;
        }
    }

    // Set the flag indicating whether or not this run needs to be glyphed.
    if (_Analysis.eScript != SCRIPT_UNDEFINED)
    {
        const CCharFormat * pCFBase = por->GetCF();
        BYTE bScriptCharSet = (BYTE)GetScriptCharSet(_Analysis.eScript);
        // HACKHACK (grzegorz): usp10.dll has a bug causing to return ANSI_CHARSET
        // for some scripts. It should return DEFAULT_CHARSET in this cases.
        // But this change affects a lot of cases which use Uniscribe.
        // To avoid any regressions we are doing the right thing only for Hangul.
        if (_Analysis.eScript == 18)
        {
            const SCRIPT_PROPERTIES * pProp = GetScriptProperties(_Analysis.eScript);
            Assert(pProp);
            bScriptCharSet = pProp->fAmbiguousCharSet ? DEFAULT_CHARSET : pProp->bCharSet;
        }

        Assert(pCFBase != NULL);

        por->_lsCharProps.fGlyphBased = TRUE;
        por->_lsCharProps.dcpMaxContext = CchContextFromScript(_Analysis.eScript);

        // Tweak the charset of the CCharFormat to match the script.
        if (IsComplexScript(_Analysis.eScript) &&
            pCFBase->_bCharSet != bScriptCharSet)
        {
            CCharFormat * pCF;

            if (!por->_fMustDeletePcf)
            {
                // We need a custom CF for the por. Base it on the current CF.
                pCF = por->GetOtherCF();
                *pCF = *pCFBase;
            }
            else
            {
                // We've already copied out a custom CF for the por, so we can
                // just scribble on it.
                pCF = (CCharFormat *) pCFBase;
            }

            pCF->_bCharSet = bScriptCharSet;
            pCF->_bCrcFont = pCF->ComputeFontCrc();
        }
    }
    else
    {
        por->_lsCharProps.fGlyphBased = FALSE;
    }
}


//-----------------------------------------------------------------------------
//
//  Function:   CComplexRun::IsNumericSeparatorRun
//
//  Synopsis:   Determines if por is a run consisting of a single numeric
//              separator character surrounded by numbers.
//
//  Returns:    True if the run is a text run consisting a numeric separator
//              bound by numbers.
//
//-----------------------------------------------------------------------------

BOOL
CComplexRun::IsNumericSeparatorRun(
    COneRun * por,
    COneRun * porTail,
    CBidiLine * pBidiLine)
{
    // Check if we've got a single numeric separator for the run.
    if (   por->_lscch != 1 
        || !pBidiLine
        || !IsNumericSeparatorClass(pBidiLine->DirClassFromChAndContext(*(por->_pchBase), 
                                    PRIMARYLANGID(por->GetCF()->_lcid), SUBLANGID(por->GetCF()->_lcid)))
       )
    {
        return FALSE;
    }

    // Check for a number preceeding the por. We can just look back in the por
    // list to do this.
    if (porTail == por)
    {
        porTail = porTail->_pPrev;
    }
    while (porTail != NULL && !(porTail->IsNormalRun() && porTail->_pchBase != NULL))
    {
        porTail = porTail->_pPrev;
    }
    if (porTail == NULL || !InRange(*(porTail->_pchBase + porTail->_lscch - 1), '0', '9'))
    {
        return FALSE;
    }

    // Check for a number following the por. Usually we'll just be able to look
    // in the text store that was originally attached to this por (before it
    // was chopped up), but sometimes we may need to go to the backing store,
    // in which case we have to watch for both the text and the nodes (we want
    // to ignore non-displaying nodes (like <span>) but anything else causes us
    // to evaluate).
    if (por->_lscchOriginal > 1)
    {
        if (!InRange(*(por->_pchBaseOriginal + 1), '0', '9'))
        {
            return FALSE;
        }
    }
    else
    {
        CTreePos * ptp = por->_ptp;
        CTxtPtr txtptr(ptp->GetMarkup(), por->_lscpBase - por->_chSynthsBefore);
        WCHAR ch;

        while ((ch = txtptr.NextChar()) == WCH_NODE)
        {
            ptp = ptp->NextTreePos();

            while(ptp->IsPointer())
            {
                ptp = ptp->NextTreePos();
            }

            Assert(ptp->IsNode() && ptp->Branch() != NULL);

            CElement * pElement = ptp->Branch()->Element();

            if (pElement->HasFlag(TAGDESC_OWNLINE) ||
                pElement->Tag() == ETAG_BR ||
                pElement->ShouldHaveLayout())
            {
                return FALSE;
            }
        }
        if (!InRange(ch, '0', '9'))
        {
            return FALSE;
        }
    }

    return TRUE;
}


//-----------------------------------------------------------------------------
//
//  Function:   NoSpaceLangBrkcls
//
//  Synopsis:   Makes a SCRIPT_ANALYSIS for the run. This is used by Uniscribe
//              functions for Complex Text handling. The SCRIPT_ANALYSIS is
//              stored in the plsrun for multiple uses.
//
//  Arguments:  plsrun              pointer to the run
//              cp                  the cp to evaluate
//              pbrkclsAfter        Can we break after the current cp?
//              pbrkclsBefore       Can we break before the current cp?
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
#define NSL_BREAK_AFTER  0x10
#define NSL_BREAK_BEFORE 0xee
#define NSL_BREAK_TOTAL  0xff

void
CComplexRun::NoSpaceLangBrkcls(CMarkup * pMarkup, LONG cpLineStart, LONG cp, BRKCLS* pbrkclsAfter, BRKCLS* pbrkclsBefore)
{
    long    cchBefore = 0;
    long    cchAfter = 0;

    if(cp < (LONG) _ThaiWord.cp || cp >= (LONG) (_ThaiWord.cp + _ThaiWord.cch))
    {
        // The CP is not in the currently cached word. Bummer. We'll have to
        // compute the word position and length.

        HRESULT hr;
        const TCHAR * pch;
        TCHAR aryItemize[NSL_BREAK_TOTAL];
        unsigned short aryNodePos[NSL_BREAK_TOTAL];
        CStackDataAry<SCRIPT_ITEM, 8> aryItems(Mt(CComplexRunNoSpaceLangBrkcls_aryItems_pv));
        SCRIPT_LOGATTR arySLA[NSL_BREAK_TOTAL];
        int     cItems;
        int     nItem;
        long    cchCtrlBefore = 0;
        long    cchCtrlAfter = 0;
        long    cch;
        long    cchTotal;
        long    cchValid;
        long    ichBreakBefore;
        long    ichBreakAfter;
        CTxtPtr tp(pMarkup, cp);
        TCHAR chCur;

        // Set up for ScriptItemize(). We need to re-itemize the string instead
        // of using the cached _Analysis struct because we don't know how many
        // characters are involved.

        // Make sure the current character is ThaiType
        Assert(NoWhiteBetweenWords(tp.GetChar()));

        // Advance until NSL_BREAK_AFTER characters have passed or a non-ThaiType character
        // is encountered
        while(cchAfter < NSL_BREAK_AFTER)
        {
            chCur = tp.NextChar();
            if(NoWhiteBetweenWords(chCur))
            {
                cchAfter++;
            }
            else if(chCur == WCH_NODE)
            {
                cchCtrlAfter++;
            }
            else
            {
                break;
            }
        }

        // Back up until NSL_BREAK_BEFORE characters have passed or a non-ThaiType character
        // is encountered, or we have arrived to the beginning of the current
        // line. Thai breaking has trouble figuring out correct word break
        // context, so we need to help by beginning at a valid context.
        tp.SetCp(cp);
        while(cchBefore < NSL_BREAK_BEFORE && cp - cchBefore > cpLineStart)
        {
            chCur = tp.PrevChar();
            if(NoWhiteBetweenWords(chCur))
            {
                cchBefore++;
            }
            else if(chCur == WCH_NODE)
            {
                cchCtrlBefore++;
            }
            else
            {
                break;
            }
        }

        // Position the tp to the start of the Thai-type text.
        tp.SetCp(cp - cchBefore - cchCtrlBefore);

        // Get a pointer to the Thai string. We'll only copy data if we must.
        pch = tp.GetPch(cchValid);
        cch = cchBefore + cchAfter + 1;
        cchTotal = cch + cchCtrlBefore + cchCtrlAfter;

        // Strip out any control characters
        long lCount = 0;
        long lTotal = 0;
        long lNode = 0;
        long cchChecked = cchValid;

        while(lCount < cch)
        {
            Assert(lTotal <= cchTotal);

            if(*pch != WCH_NODE)
            {
                Assert(NoWhiteBetweenWords(*pch));

                aryItemize[lCount] = *pch;
                aryNodePos[lCount] = lNode;
                lCount++;
            }
            else
            {
                lNode++;
            }
            lTotal++;
            cchValid--;

            if(cchValid > 0)
            {
                pch++;
            }
            else if(lCount < cch)
            {
                // we've encountered a gap and need to get some more 
                // characters into the pch
                tp.AdvanceCp(cchChecked);
                pch = tp.GetPch(cchValid);
                cchChecked = cchValid;
            }
        }
        Assert(cch == lCount);

        // Prepare SCRIPT_ITEM buffer
        if (FAILED(aryItems.Grow(8)))
        {
            // We should always be able to grow to 8 itemse as we are based on
            // a CStackDataAry of this size.
            Assert(FALSE);
            goto Error;
        }

        // Call ScriptItemize() wrapper in usp.cxx.
        if(g_bUSPJitState == JIT_OK)
            hr = ScriptItemize(aryItemize, cch, 16, 
                               NULL, NULL, &aryItems, &cItems);
        else
            hr = E_PENDING;

        if (FAILED(hr))
        {
            if(hr == USP10_NOT_FOUND)
            {
                g_csJitting.Enter();
                if(g_bUSPJitState == JIT_OK)
                {
                    g_bUSPJitState = JIT_PENDING;
 
                    // We must do this asyncronously.
                    IGNORE_HR(GWPostMethodCall(pMarkup->Doc(), 
                                               ONCALL_METHOD(CDoc, FaultInUSP, faultinusp), 
                                               0, FALSE, "CDoc::FaultInUSP"));

                }
                g_csJitting.Leave();
           }
            // ScriptItemize() failed (for whatever reason). We are unable to
            // break, so assume we've got a single word and return.
            goto Error;
        }

        // Find the SCRIPT_ITEM containing cp.
        for(nItem = aryItems.Size() - 1;
            cchBefore < aryItems[nItem].iCharPos;
            nItem--);
        if (nItem < 0 || nItem + 1 >= aryItems.Size())
        {
            // Somehow the SCRIPT_ITEM array has gotten messed up. We can't
            // break, so assume we've got a single word and return.
            goto Error;
        }

        // NB (mikejoch) eScript may have been nuked in GetGlyphs(). If so then
        // this won't match up, but generally it should.
        Assert(_Analysis.eScript == SCRIPT_UNDEFINED ||
               aryItems[nItem].a.eScript == _Analysis.eScript);

        // Adjust pch and cch to correspond to the text indicated by this item.
        cch = aryItems[nItem + 1].iCharPos - aryItems[nItem].iCharPos;
        cchBefore -= aryItems[nItem].iCharPos;
        cchAfter = cch - cchBefore - 1;
        Assert(cchBefore >= 0 && cchAfter >= 0 && cchBefore + cchAfter + 1 == cch);

        // do script break
        hr = ScriptBreak(aryItemize + aryItems[nItem].iCharPos, cch,
                         (SCRIPT_ANALYSIS *) &aryItems[nItem].a,
                         arySLA);

        if (FAILED(hr))
        {
            // ScriptBreak() failed (for whatever reason). We are unable to break,
            // so assume we've got a single word and return.
            goto Error;
        }

        // begin checking for the break before on the current CP
        for(ichBreakBefore = cchBefore;
            ichBreakBefore > 0 && !arySLA[ichBreakBefore].fSoftBreak;
            ichBreakBefore--);

        _ThaiWord.cp = cp - (cchBefore - ichBreakBefore);

        for(ichBreakAfter = cchBefore + 1;
            ichBreakAfter < cch && !arySLA[ichBreakAfter].fSoftBreak;
            ichBreakAfter++);

        Assert(ichBreakAfter <= cch && ichBreakAfter - ichBreakBefore < 64);

        // get the delta between node counts in the word 
        long offset1 = ichBreakBefore + aryItems[nItem].iCharPos;
        long offset2 = ichBreakAfter + aryItems[nItem].iCharPos - 1;

        _ThaiWord.cch = (ichBreakAfter - ichBreakBefore) + 
                        (aryNodePos[offset2] - aryNodePos[offset1]);

    }

    Assert(cp >= (LONG) _ThaiWord.cp && cp < (LONG) (_ThaiWord.cp + _ThaiWord.cch));

    // Can we break before the character?
    if(cp != (LONG) _ThaiWord.cp)
    {
        *pbrkclsBefore = CLineServices::brkclsThaiMiddle;
    }
    else
    {
        *pbrkclsBefore = CLineServices::brkclsThaiFirst;
    }

    // Can we break after the character?
    if(cp != (LONG) (_ThaiWord.cp + _ThaiWord.cch - 1))
    {
        *pbrkclsAfter = CLineServices::brkclsThaiMiddle;
    }
    else
    {
        *pbrkclsAfter = CLineServices::brkclsThaiLast;
    }

    return;

Error:

    *pbrkclsBefore = (cchBefore == 0 ? CLineServices::brkclsThaiFirst : CLineServices::brkclsThaiMiddle);
    *pbrkclsAfter = (cchAfter == 0 ? CLineServices::brkclsThaiLast : CLineServices::brkclsThaiMiddle);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lsbreak.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSBREAK.CXX -- line services break callbacks
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      12/22/97     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_TXTDEFS_H
#define X_TXTDEFS_H
#include "txtdefs.h"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_LSSETDOC_H_
#define X_LSSETDOC_H_
#include <lssetdoc.h>
#endif

#ifndef X_BRKCLS_H_
#define X_BRKCLS_H_
#include <brkcls.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

ExternTag(tagLSCallBack);

// The following tables depend on the fact that there is no more
// than a single alternate for each MWCLS and that at most one
// condition needs to be taken into account in resolving each MWCLS

// NB (cthrash) This is a packed table.  The first three elements (brkcls,
// brkclsAlt and brkopt) are indexed by CHAR_CLASS.  The fourth column we
// access (brkclsLow) we access by char value.  The fourth column is for a
// speed optimization.

#if defined(UNIX) || (defined(_MSC_VER) && (_MSC_VER >= 1200))
// Unix and Newer MS compilers can't use DWORD to initialize enum type BRKCLS.
#define BRKINFO(a,b,c,d) { CLineServices::a, CLineServices::b, CLineServices::c, CLineServices::d }
#else
#define BRKINFO(a,b,c,d) { DWORD(CLineServices::a), DWORD(CLineServices::b), DWORD(CLineServices::c), DWORD(CLineServices::d) }
#endif

const CLineServices::PACKEDBRKINFO CLineServices::s_rgBrkInfo[CHAR_CLASS_MAX] =
{
    //       brkcls             brkclsAlt         brkopt     brkclsLow                    QPID ( CC)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOB_   1 (  0)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // NOPP   2 (  1)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // NOPA   2 (  2)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // NOPW   2 (  3)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // HOP_   3 (  4)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOP_   4 (  5)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOP5   5 (  6)
    BRKINFO( brkclsQuote,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NOQW   6 (  7)
    BRKINFO( brkclsQuote,       brkclsOpen,       fCscWide,  brkclsAlpha        ), // AOQW   7 (  8)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsSpaceN       ), // WOQ_   8 (  9)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsSpaceN       ), // WCB_   9 ( 10)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCPP  10 ( 11)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsSpaceN       ), // NCPA  10 ( 12)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsSpaceN       ), // NCPW  10 ( 13)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // HCP_  11 ( 14)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WCP_  12 ( 15)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WCP5  13 ( 16)
    BRKINFO( brkclsQuote,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCQW  14 ( 17)
    BRKINFO( brkclsQuote,       brkclsClose,      fCscWide,  brkclsAlpha        ), // ACQW  15 ( 18)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WCQ_  16 ( 19)
    BRKINFO( brkclsQuote,       brkclsClose,      fCscWide,  brkclsAlpha        ), // ARQW  17 ( 20)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCSA  18 ( 21)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // HCO_  19 ( 22)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WC__  20 ( 23)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WCS_  20 ( 24)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WC5_  21 ( 25)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WC5S  21 ( 26)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NKS_  22 ( 27)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WKSM  23 ( 28)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WIM_  24 ( 29)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSSW  25 ( 30)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WSS_  26 ( 31)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAsciiSpace   ), // WHIM  27 ( 32)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsExclaInterr  ), // WKIM  28 ( 33)
    BRKINFO( brkclsIdeographic, brkclsNoStartIdeo,fBrkStrict,brkclsQuote        ), // NKSL  29 ( 34)
    BRKINFO( brkclsIdeographic, brkclsNoStartIdeo,fBrkStrict,brkclsAlpha        ), // WKS_  30 ( 35)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsPrefix       ), // WKSC  30 ( 36)
    BRKINFO( brkclsIdeographic, brkclsNoStartIdeo,fBrkStrict,brkclsPostfix      ), // WHS_  31 ( 37)
    BRKINFO( brkclsExclaInterr, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQFP  32 ( 38)
    BRKINFO( brkclsExclaInterr, brkclsNil,        fBrkNone,  brkclsQuote        ), // NQFA  32 ( 39)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsOpen         ), // WQE_  33 ( 40)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsClose        ), // WQE5  34 ( 41)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NKCC  35 ( 42)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WKC_  36 ( 43)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsNumSeparator ), // NOCP  37 ( 44)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsSpaceN       ), // NOCA  37 ( 45)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsNumSeparator ), // NOCW  37 ( 46)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsSlash        ), // WOC_  38 ( 47)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WOCS  38 ( 48)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WOC5  39 ( 49)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WOC6  39 ( 50)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // AHPW  40 ( 51)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsNumeral      ), // NPEP  41 ( 52)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsNumeral      ), // NPAR  41 ( 53)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // HPE_  42 ( 54)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WPE_  43 ( 55)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WPES  43 ( 56)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WPE5  44 ( 57)
    BRKINFO( brkclsInseparable, brkclsNil,        fBrkNone,  brkclsNumSeparator ), // NISW  45 ( 58)
    BRKINFO( brkclsInseparable, brkclsNil,        fBrkNone,  brkclsNumSeparator ), // AISW  46 ( 59)
    BRKINFO( brkclsGlueA,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQCS  47 ( 60)
    BRKINFO( brkclsGlueA,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQCW  47 ( 61)
    BRKINFO( brkclsGlueA,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQCC  47 ( 62)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsExclaInterr  ), // NPTA  48 ( 63)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPNA  48 ( 64)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPEW  48 ( 65)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPEH  48 ( 66)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPEV  48 ( 67)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // APNW  49 ( 68)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // HPEW  50 ( 69)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // WPR_  51 ( 70)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQEP  52 ( 71)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQEW  52 ( 72)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQNW  52 ( 73)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // AQEW  53 ( 74)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // AQNW  53 ( 75)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // AQLW  53 ( 76)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // WQO_  54 ( 77)
    BRKINFO( brkclsAsciiSpace,  brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSBL  55 ( 78)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WSP_  56 ( 79)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WHI_  57 ( 80)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NKA_  58 ( 81)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WKA_  59 ( 82)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ASNW  60 ( 83)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ASEW  60 ( 84)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ASRN  60 ( 85)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ASEN  60 ( 86)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ALA_  61 ( 87)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // AGR_  62 ( 88)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ACY_  63 ( 89)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WID_  64 ( 90)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsOpen         ), // WPUA  65 ( 91)
    BRKINFO( brkclsHangul,      brkclsNil,        fBrkNone,  brkclsPrefix       ), // NHG_  66 ( 92)
    BRKINFO( brkclsHangul,      brkclsNil,        fBrkNone,  brkclsClose        ), // WHG_  67 ( 93)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WCI_  68 ( 94)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NOI_  69 ( 95)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOI_  70 ( 96)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOIC  70 ( 97)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOIL  70 ( 98)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOIS  70 ( 99)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOIT  70 (100)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSEN  71 (101)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSET  71 (102)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSNW  71 (103)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // ASAN  72 (104)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // ASAE  72 (105)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NDEA  73 (106)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WD__  74 (107)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NLLA  75 (108)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WLA_  76 (109)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NWBL  77 (110)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NWZW  77 (111)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPLW  78 (112)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPZW  78 (113)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPF_  78 (114)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPFL  78 (115)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPNW  78 (116)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // APLW  79 (117)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // APCO  79 (118)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // ASYW  80 (119)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHYP  81 (120)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHYW  81 (121)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // AHYW  82 (122)
    BRKINFO( brkclsQuote,       brkclsNil,        fBrkNone,  brkclsOpen         ), // NAPA  83 (123)
    BRKINFO( brkclsQuote,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQMP  84 (124)
    BRKINFO( brkclsSlash,       brkclsNil,        fBrkNone,  brkclsClose        ), // NSLS  85 (125)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSF_  86 (126)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSBS  86 (127)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSBB  86 (128)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NLA_  87 (129)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NLQ_  88 (130)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NLQN  88 (131)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NLQC  88 (132)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ALQ_  89 (133)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ALQN  89 (134)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NGR_  90 (135)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NGRN  90 (136)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NGQ_  91 (137)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NGQN  91 (138)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCY_  92 (139)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCYP  93 (140)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCYC  93 (141)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAR_  94 (142)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAQL  95 (143)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAQN  95 (144)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHB_  96 (145)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHBC  96 (146)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHBW  96 (147)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHBR  96 (148)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NASR  97 (149)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAAR  97 (150)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAAC  97 (151)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAAD  97 (152)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAED  97 (153)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NANW  97 (154)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAEW  97 (155)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAAS  97 (156)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHI_  98 (157)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHIN  98 (158)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHIC  98 (159)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsGlueA        ), // NHID  98 (160)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBE_  99 (161)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NBEC  99 (162)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NBED  99 (163)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBET  99 (164)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NGM_ 100 (165)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NGMC 100 (166)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NGMD 100 (167)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NGJ_ 101 (168)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NGJC 101 (169)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NGJD 101 (170)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOR_ 102 (171)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NORC 102 (172)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NORD 102 (173)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NTA_ 103 (174)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTAC 103 (175)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NTAD 103 (176)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NTE_ 104 (177)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTEC 104 (178)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NTED 104 (179)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NKD_ 105 (180)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NKDC 105 (181)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NKDD 105 (182)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NMA_ 106 (183)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NMAC 106 (184)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NMAD 106 (185)
    BRKINFO( brkclsThaiFirst,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTH_ 107 (186)
    BRKINFO( brkclsThaiFirst,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTHC 107 (187)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NTHD 107 (188)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsNil          ), // NTHT 107 (189)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NLO_ 108 (190)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NLOC 108 (191)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NLOD 108 (192)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NTI_ 109 (193)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTIC 109 (194)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NTID 109 (195)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NTIN 109 (196)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NGE_ 110 (197)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NGEQ 111 (198)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBO_ 112 (199)
    BRKINFO( brkclsGlueA,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBSP 113 (200)
    BRKINFO( brkclsGlueA,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBSS 113 (201)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOF_ 114 (202)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOBS 114 (203)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOEA 114 (204)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NONA 114 (205)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NONP 114 (206)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOEP 114 (207)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NONW 114 (208)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOEW 114 (209)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOLW 114 (210)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NOCO 114 (211)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOSP 114 (212)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOEN 114 (213)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOBN 114 (214)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NET_ 115 (215)
    BRKINFO( brkclsSpecialPunct,brkclsNil,        fBrkNone,  brkclsNil          ), // NETP 115 (216)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NETD 115 (217)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NCA_ 116 (218)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NCH_ 117 (219)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsNil          ), // WYI_ 118 (220)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsNil          ), // WYIN 118 (221)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBR_ 119 (222)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NRU_ 120 (223)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOG_ 121 (224)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOGS 121 (225)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOGN 121 (226)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NSI_ 122 (227)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NSIC 122 (228)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NTN_ 123 (229)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTNC 123 (230)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NKH_ 124 (231)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NKHC 124 (232)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NKHD 124 (233)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NKHT 124 (234)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBU_ 125 (235)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NBUC 125 (236)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NBUD 125 (237)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NSY_ 126 (238)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NSYP 126 (239)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NSYC 126 (240)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NSYW 126 (241)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NMO_ 127 (242)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NMOC 127 (243)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NMOD 127 (244)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NMOB 127 (245)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NMON 127 (246)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NHS_ 128 (247)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsNil          ), // WHT_ 129 (248)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // LS__ 130 (249)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // XNW_ 131 (250)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          )  // XNWA 131 (251)
};

// Break pair information for normal or strict Kinsoku
const BYTE s_rgbrkpairsKinsoku[CLineServices::brkclsLim][CLineServices::brkclsLim] =
{
//1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25    = brclsAfter
                                                                                                    //  brkclsBefore:
  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  1,  1,  1,  1,  0, //   1 brkclsOpen    
  0,  1,  1,  1,  0,  0,  2,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   2 brkclsClose   
  0,  1,  2,  1,  2,  0,  2,  4,  0,  0,  4,  2,  1,  2,  1,  4,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   3 brkclsNoStartIdeo
  0,  1,  2,  1,  0,  0,  0,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   4 brkclsExclamInt
  0,  1,  2,  1,  2,  0,  0,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   5 brkclsInseparable
  2,  1,  2,  1,  0,  2,  0,  2,  2,  0,  3,  2,  1,  2,  1,  2,  2,  0,  0,  2,  1,  1,  1,  1,  0, //   6 brkclsPrefix  
  0,  1,  2,  1,  0,  0,  0,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   7 brkclsPostfix 
  0,  1,  2,  1,  2,  0,  2,  4,  0,  0,  4,  2,  1,  2,  1,  4,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   8 brkclsIdeoW   
  0,  1,  2,  1,  2,  0,  2,  0,  3,  0,  3,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   9 brkclsNumeral 
  0,  1,  2,  1,  0,  0,  0,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  10 brkclsSpaceN  
  0,  1,  2,  1,  2,  2,  2,  4,  3,  0,  3,  2,  1,  2,  1,  4,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  11 brkclsAlpha   
  2,  1,  2,  1,  2,  2,  2,  2,  2,  2,  2,  2,  1,  2,  1,  2,  2,  2,  2,  2,  1,  1,  1,  1,  0, //  12 brkclsGlueA   
  0,  1,  2,  1,  2,  0,  2,  0,  2,  0,  3,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  13 brkclsSlash   
  1,  1,  2,  1,  2,  2,  3,  2,  2,  2,  2,  2,  1,  2,  1,  2,  2,  2,  2,  2,  1,  1,  1,  1,  0, //  14 brkclsQuotation
  0,  1,  2,  1,  0,  2,  2,  0,  2,  0,  3,  2,  1,  2,  2,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  15 brkclsNumSeparator
  0,  1,  2,  1,  2,  0,  2,  4,  0,  0,  4,  2,  1,  2,  1,  4,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  16 brkclsHangul  
  0,  1,  2,  1,  2,  0,  2,  0,  0,  0,  0,  2,  1,  2,  1,  4,  2,  2,  2,  2,  1,  1,  1,  1,  0, //  17 brkclsThaiFirst
  0,  1,  2,  1,  2,  0,  2,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  2,  2,  2,  1,  1,  1,  1,  0, //  18 brkclsThaiLast
  0,  1,  2,  1,  2,  0,  0,  0,  0,  0,  0,  2,  2,  2,  1,  0,  2,  2,  2,  2,  1,  1,  1,  1,  0, //  19 brkclsThaiAlpha
  0,  1,  2,  1,  2,  2,  2,  4,  3,  0,  3,  2,  1,  2,  1,  4,  0,  0,  0,  1,  1,  1,  1,  1,  0, //  20 brkclsCombining
  0,  1,  2,  1,  0,  0,  0,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  21 brkclsAsiiSpace
  0,  1,  2,  1,  0,  2,  2,  0,  2,  0,  0,  2,  1,  2,  2,  0,  0,  0,  0,  2,  1,  2,  1,  1,  0, //  22 brkclsSpecialPunct
  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0, //  23 brkclsMBPOpen
  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0, //  24 brkclsMBPClose
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, //  25 brkclsWBR
};

inline CLineServices::BRKCLS
QuickBrkclsFromCh(WCHAR ch)
{
    Assert(ch);  // This won't work for ch==0.
    Assert( CanQuickBrkclsLookup(ch) );
    return (CLineServices::BRKCLS)CLineServices::s_rgBrkInfo[ch].brkclsLow;
}

inline
CLineServices::BRKCLS
BrkclsFromCh(WCHAR ch, DWORD brkopt)
{
    Assert( !CanQuickBrkclsLookup(ch) ); // Should take another code path.

    CHAR_CLASS cc = CharClassFromCh(ch);
    Assert(cc < CHAR_CLASS_MAX);

    const CLineServices::PACKEDBRKINFO * p = CLineServices::s_rgBrkInfo + cc;

    return CLineServices::BRKCLS((p->brkopt & brkopt) ? p->brkclsAlt : p->brkcls);
}

// Line breaking behaviors

// Standard Breaking Behaviors retaining normal line break for non-FE text
static const LSBRK s_rglsbrkNormal[] = 
{
    /* 0*/ 1,1,  // always allowed
    /* 1*/ 0,0,  // always prohibited
    /* 2*/ 0,1,  // only allowed across space
    /* 3*/ 0,1,  // only allowed across space (word wrap case)
    /* 4*/ 1,1,  // always allowed (no CJK/Hangul word wrap case)
};

// Breaking Behaviors allowing FE style breaking in the middle of words (any language)
static const LSBRK s_rglsbrkBreakAll[] = 
{
    /* 0*/ 1,1,  // always allowed
    /* 1*/ 0,0,  // always prohibited
    /* 2*/ 0,1,  // only allowed across space
    /* 3*/ 1,1,  // always allowed (no word wrap case)
    /* 4*/ 1,1,  // always allowed (no CJK/Hangul word wrap case)
};

// Breaking Behaviors allowing Hangul style breaking 
static const LSBRK s_rglsbrkKeepAll[] = 
{
    /* 0*/ 1,1,  // always allowed
    /* 1*/ 0,0,  // always prohibited
    /* 2*/ 0,1,  // only allowed across space
    /* 3*/ 0,1,  // only allowed across space (word wrap case)
    /* 4*/ 0,1,  // only allowed across space (CJK/Hangul word wrap case)
};

const struct lsbrk * const alsbrkTables[4] =
{                                                           
    s_rglsbrkNormal,
    s_rglsbrkNormal,
    s_rglsbrkBreakAll,
    s_rglsbrkKeepAll
};

LSERR
CLineServices::CheckSetBreaking()
{
    const struct lsbrk * lsbrkCurr = alsbrkTables[_pPFFirst->_fWordBreak];

    HRESULT hr;

    //
    // Are we in need of calling LsSetBreaking?
    //

    if (lsbrkCurr == _lsbrkCurr)
    {
        hr = S_OK;
    }
    else
    {
        hr = HRFromLSERR( LsSetBreaking( _plsc,
                                         sizeof( s_rglsbrkNormal ) / sizeof( LSBRK ),
                                         lsbrkCurr,
                                         brkclsLim,
                                         (const BYTE *)s_rgbrkpairsKinsoku ) );

        _lsbrkCurr = (struct lsbrk *)lsbrkCurr;
    }

    RRETURN(hr);
}


#ifdef _MAC
void ReverseByteSex(DWORD* pdw);
void ReverseByteSex(DWORD* pdw)
{
    DWORD In = (*pdw);
    BYTE* pIn = (BYTE*) &In;
    BYTE* pOut = ((BYTE*) pdw) + 3;
    
    for ( short i = 0; i < 4; i++, pIn++, pOut-- )
        (*pOut) = (*pIn);
}

void ClearDWORD(DWORD* pdw);
void ClearDWORD(DWORD* pdw)
{
    (*pdw) = 0;
}

#endif


LSERR WINAPI
CLineServices::GetBreakingClasses(
    PLSRUN plsrun,          // IN
    LSCP lscp,              // IN
    WCHAR wch,              // IN
    BRKCLS* pbrkclsFirst,    // OUT
    BRKCLS* pbrkclsSecond)  // OUT
{
    LSTRACE(GetBreakingClasses);
    LSERR lserr = lserrNone;

#ifdef _MAC
    ClearDWORD((DWORD*) pbrkclsFirst);
    ClearDWORD((DWORD*) pbrkclsSecond);
#endif

#if 0
    if (plsrun->GetCF()->_bCharSet == SYMBOL_CHARSET)
    {
        *pbrkclsFirst = *pbrkclsSecond = brkclsAlpha;
    }
    else
#endif
    if (CanQuickBrkclsLookup(wch))
    {
        // prefer ASCII (true block) for performance
        Assert( HasWhiteBetweenWords(wch) );
        *pbrkclsFirst = *pbrkclsSecond = QuickBrkclsFromCh(wch);
    }
    else if(plsrun->IsSpecialCharRun())
    {
        if (plsrun->IsMBPRun())
        {
            GetMBPBreakingClasses(plsrun, pbrkclsFirst, pbrkclsSecond);
        }
        else
        {
            Assert(plsrun->_synthType == SYNTHTYPE_WBR);
            *pbrkclsFirst = *pbrkclsSecond = brkclsWBR;
        }
    }
    else if(HasWhiteBetweenWords(wch))  
    {
        *pbrkclsFirst = *pbrkclsSecond = BrkclsFromCh(wch, plsrun->_brkopt);
    }
    else
    {
        switch(CharClassFromCh(wch))
        {
        // numbers and Baht sign need to be given correct break class
        case NTHT:  // Thai Baht
        case NTHD:  // Thai digits
        case NLOD:  // Lao digits
        case NKHD:  // Khmer digits
        case NBUD:  // Burmese/Myanmar digits
            *pbrkclsFirst = *pbrkclsSecond = BrkclsFromCh(wch, plsrun->_brkopt);
            break;
        // rest needs to be handled as no space language text.
        default:
            {
                
                CComplexRun * pcr = plsrun->GetComplexRun();

                if (pcr != NULL)
                {
                    LONG cp = CPFromLSCP(lscp);

#if DBG==1
                    // Assertion to make sure that someone has not changed the 
                    // s_aPropBitsFromCharClass[] table
                    CHAR_CLASS cclass = CharClassFromCh(wch);
                    Assert(   cclass == NTH_
                           || cclass == NTHC
                           || cclass == NLO_
                           || cclass == NLOC
                           || cclass == NKH_
                           || cclass == NKHC
                           || cclass == NBU_
                           || cclass == NBUC);

                    Assert(LSCPFromCP(cp) == lscp);
#endif // DBG

                    pcr->NoSpaceLangBrkcls(_pMarkup, _cpStart, cp, (::BRKCLS*)pbrkclsFirst, (::BRKCLS*)pbrkclsSecond);
                }
                else
                {
                    // BUGFIX 14717 (a-pauln)
                    // A complex run has not been created so pass this through the normal
                    // Kinsoku classes for clean failure.
                    *pbrkclsFirst = *pbrkclsSecond = BrkclsFromCh(wch, plsrun->_brkopt);
                }
            }
            break;
        }
    }

#ifdef _MAC
    ReverseByteSex((DWORD*) pbrkclsFirst);
    ReverseByteSex((DWORD*) pbrkclsSecond);
#endif

    return lserr;
}

// NB (cthrash) This table came from Quill.

const BRKCOND CLineServices::s_rgbrkcondBeforeChar[brkclsLim] =
{
    brkcondPlease,  // brkclsOpen
    brkcondNever,   // brkclsClose
    brkcondNever,   // brkclsNoStartIdeo
    brkcondNever,   // brkclsExclaInterr
    brkcondCan,     // brkclsInseparable
    brkcondCan,     // brkclsPrefix
    brkcondCan,     // brkclsPostfix
    brkcondPlease,  // brkclsIdeographic
    brkcondCan,     // brkclsNumeral
    brkcondCan,     // brkclsSpaceN
    brkcondCan,     // brkclsAlpha
    brkcondCan,     // brkclsGlueA
    brkcondPlease,  // brkclsSlash
    brkcondCan,     // brkclsQuote
    brkcondCan,     // brkclsNumSeparator
    brkcondCan,     // brkclsHangul
    brkcondCan,     // brkclsThaiFirst
    brkcondNever,   // brkclsThaiLast
    brkcondNever,   // brkclsThaiMiddle
    brkcondCan,     // brkclsCombining
    brkcondCan,     // brkclsAsciiSpace
    brkcondPlease,  // brkclsMBPOpen
    brkcondNever,   // brkclsMBPClose
    brkcondPlease,  // brkclsWBR
};

LSERR WINAPI
CLineServices::CanBreakBeforeChar(
    BRKCLS brkcls,          // IN
    BRKCOND* pbrktxtBefore) // OUT
{
    LSTRACE(CanBreakBeforeChar);

    Assert( brkcls >= 0 && brkcls < brkclsLim );

    *pbrktxtBefore = s_rgbrkcondBeforeChar[ brkcls ];

    return lserrNone;
}

const BRKCOND CLineServices::s_rgbrkcondAfterChar[brkclsLim] =
{
    brkcondPlease,  // brkclsOpen
    brkcondCan,     // brkclsClose
    brkcondCan,     // brkclsNoStartIdeo
    brkcondCan,     // brkclsExclaInterr
    brkcondCan,     // brkclsInseparable
    brkcondCan,     // brkclsPrefix
    brkcondCan,     // brkclsPostfix
    brkcondPlease,  // brkclsIdeographic
    brkcondCan,     // brkclsNumeral
    brkcondCan,     // brkclsSpaceN
    brkcondCan,     // brkclsAlpha
    brkcondNever,   // brkclsGlueA
    brkcondPlease,  // brkclsSlash
    brkcondCan,     // brkclsQuote
    brkcondCan,     // brkclsNumSeparator
    brkcondCan,     // brkclsHangul
    brkcondNever,   // brkclsThaiFirst
    brkcondCan,     // brkclsThaiLast
    brkcondNever,   // brkclsThaiAlpha
    brkcondCan,     // brkclsCombining
    brkcondCan,     // brkclsAsciiSpace
    brkcondNever,   // brkclsMBPOpen
    brkcondPlease,  // brkclsMBPClose
    brkcondPlease,  // brkclsWBR
};

LSERR WINAPI
CLineServices::CanBreakAfterChar(
    BRKCLS brkcls,          // IN
    BRKCOND* pbrktxtAfter)  // OUT
{
    LSTRACE(CanBreakAfterChar);

    Assert( brkcls >= 0 && brkcls < brkclsLim );

    *pbrktxtAfter = s_rgbrkcondAfterChar[ brkcls ];

    return lserrNone;
}

void
CLineServices::GetMBPBreakingClasses(PLSRUN plsrun, BRKCLS *pbrkclsFirst, BRKCLS *pbrkclsSecond)
{
    COneRun *por;
    BRKCLS dummy;

    if (plsrun->_synthType == SYNTHTYPE_MBPOPEN)
    {
        *pbrkclsFirst = brkclsMBPOpen; /* After */
        
        *pbrkclsSecond = brkclsOpen;
        por = plsrun->_pNext;
        while(por)
        {
            if (   por->IsNormalRun()
                && por->_synthType == SYNTHTYPE_NONE
               )
            {
                if (por->_pchBase)
                {
                    GetBreakingClasses(por, por->_lscpBase, por->_pchBase[0], &dummy, pbrkclsSecond);
                }
                // Presently, if a border starts before an embedded object
                // we will just break between the border and whatever (say X) is
                // there before it, even if there was not a break opportunity
                // between X and the object.
                break;
            }
            por = por->_pNext;
        }
    }
    else
    {
        Assert(plsrun->_synthType == SYNTHTYPE_MBPCLOSE);
        *pbrkclsSecond = brkclsMBPClose; /* before */
        
        *pbrkclsFirst = brkclsClose;
        por = plsrun->_pPrev;
        while(por)
        {
            if (   por->IsNormalRun()
                && por->_synthType == SYNTHTYPE_NONE
               )
            {
                if (por->_pchBase)
                {
                    GetBreakingClasses(por, por->_lscpBase+por->_lscch-1, por->_pchBase[por->_lscch-1], pbrkclsFirst, &dummy);
                }
                // Presently, if a border starts before an embedded object
                // we will just break between the border and whatever (say X) is
                // there before it, even if there was not a break opportunity
                // between X and the object.
                break;
            }
            por = por->_pPrev;
        }
    }
}

#if DBG==1
const char * s_achBrkCls[] =  // Note brkclsNil is -1
{
    "brkclsNil",
    "brkclsOpen",
    "brkclsClose",
    "brkclsNoStartIdeo",
    "brkclsExclaInterr",
    "brkclsInseparable",
    "brkclsPrefix",
    "brkclsPostfix",
    "brkclsIdeographic",
    "brkclsNumeral",
    "brkclsSpaceN",
    "brkclsAlpha",
    "brkclsGlueA",
    "brkclsSlash",
    "brkclsQuote",
    "brkclsNumSeparator",
    "brkclsHangul",
    "brkclsThaiFirst",
    "brkclsThaiLast",
    "brkclsThaiMiddle",
    "brkclsCombining",
    "brkclsAsciiSpace",
    "brkclsMBPOpen",
    "brkclsMBPClose",
};

const char *
CLineServices::BrkclsNameFromCh(TCHAR ch, BOOL fStrict)
{
    BRKCLS brkcls = CanQuickBrkclsLookup(ch) ? QuickBrkclsFromCh(ch) : BrkclsFromCh(ch, fStrict);

    return s_achBrkCls[int(brkcls)+1];    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lscache.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSCACHE.CXX -- CLSCache and related classes implementation
 *
 *  Owner: <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      1/26/98     sujalp created
 *
 *  Note:
 *      The LS cache is a cache of CLineServices objects. We use one
 *      such object per line calculation and then return it to this
 *      cache. It can then be used for subsequent line computations.
 *      More than one such object will be in use only when we have
 *      nested flow layouts (like table cells).
 *  
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include <textxfrm.hxx>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_LSCACHE_HXX_
#define X_LSCACHE_HXX_
#include <lscache.hxx>
#endif

MtDefine(CAryLSCache_aryLSCacheEntry_pv, LineServices, "CLSCache::CLSEntry allocation")
MtDefine(THREADSTATE_pLSCache, THREADSTATE, "THREADSTATE::_pLSCache")

//+----------------------------------------------------------------------------
//
//  Function:   InitLSCache
//
//  Synopsis:   Allocate the LS context cache
//
//  Arguments:  pts - THREADSTATE for current thread
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
InitLSCache(THREADSTATE *pts)
{
    Assert(pts);
    pts->_pLSCache = new (Mt(THREADSTATE_pLSCache)) CLSCache;
    if (!pts->_pLSCache)
        RRETURN(E_OUTOFMEMORY);
    RRETURN(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function:   DeinitLSCache
//
//  Synopsis:   Delete the LS context cache
//
//  Arguments:  pts - THREADSTATE for current thread
//
//-----------------------------------------------------------------------------
void DeinitLSCache(THREADSTATE *pts)
{
    Assert(pts);

#if DBG==1
    if (pts->_pLSCache)
    {
        pts->_pLSCache->VerifyNoneUsed();
    }
#endif

    delete pts->_pLSCache;
}

//-------------------------------------------------------------------------
//
// Member:   GetFreeEntry
//
// Synopsis: Finds a free entry inside LS cache. If one does not exist, creates
//           a new and adds it to the LS cache.
//           called internally by the constructors.
//
// Params:   None.
//
// Retruns:  A CLineServices object.
//
//-------------------------------------------------------------------------

CLineServices *
CLSCache::GetFreeEntry(CMarkup *pMarkup, BOOL fStartUpLSDLL)
{
    CLSCacheEntry *pLSEntry;
    CLSCacheEntry  LSEntry;
    CLineServices *pLS = NULL;
    HRESULT        hr = S_OK;
    LONG           i;
    
    for (i = _aLSEntries.Size() - 1; i >= 0; i--)
    {
        pLSEntry = &_aLSEntries[i];
        if (!pLSEntry->_fUsed)
        {
            pLS = pLSEntry->_pLS;

            // If the LS context has not been intialized and initialization
            // has been requested, then start it up.
            if (fStartUpLSDLL)
            {
                hr = THR(StartUpLSDLL(pLS, pMarkup));
                if (hr)
                {
                    pLS = NULL;
                    goto Error;
                }
                Assert(pLS->_plsc);
            }
            else
            {
                if (pMarkup != pLS->GetMarkup())
                    pLS->_treeInfo._tpFrontier.Reinit(pMarkup, 0);
            }
            
            pLSEntry->_fUsed = TRUE;
            goto Cleanup;
        }
    }

    hr = THR(InitLineServices(pMarkup, fStartUpLSDLL, &LSEntry._pLS));
    if (hr)
        goto Cleanup;

    LSEntry._fUsed = TRUE;

    hr = THR(_aLSEntries.AppendIndirect(&LSEntry));
    if (hr)
        goto Cleanup;

    pLS = LSEntry._pLS;
    
Cleanup:
    if (pLS)
    {
        Assert(!fStartUpLSDLL || pLS->_plsc);
        _cUsed++;
    }

Error:    
    return pLS;
}

//-------------------------------------------------------------------------
//
// Member:   ReleaseEntry
//
// Synopsis: Releases an entry which was retrieved via GetFreeEntry(). It
//           puts this CLineServices object back into the cache for it to
//           be used by subsequent GetFreeEntry() calls.
//
// Params:   [pLS]: The entry to be released.
//
// Retruns:  None.
//
//-------------------------------------------------------------------------

void
CLSCache::ReleaseEntry(CLineServices *pLS)
{
    CLSCacheEntry *pLSEntry;
    LONG           i;

    Assert(pLS);
    for (i = 0; i < _aLSEntries.Size(); i++)
    {
        pLSEntry = &_aLSEntries[i];
        if (pLSEntry->_pLS == pLS)
        {
            Assert(pLSEntry->_fUsed == TRUE);
            pLSEntry->_fUsed = FALSE;
            goto Cleanup;
        }
    }

    AssertSz(0, "Invalid cache entry passed to release");
    
Cleanup:
    _cUsed--;
    if (!_cUsed)
    {
        Dispose(FALSE);
    }
    return;
}

//-------------------------------------------------------------------------
//
// Member:   Dispose
//
// Synopsis: Appropriately destroys the complete cache of entries.
//
// Params:   fDiposeAll - Dispose all the entries.
//
// Retruns:  None.
//
//-------------------------------------------------------------------------
void
CLSCache::Dispose(BOOL fDisposeAll)
{
    CLSCacheEntry *pLSEntry;
    LONG i;

    //
    // Find the number of entries to free from the cache.
    //
    LONG nUnusedEntriesNeedToFree = _aLSEntries.Size() - (fDisposeAll ? 0 : N_CACHE_MINSIZE);

    //
    // Do we need to free any entries?
    //
    if (nUnusedEntriesNeedToFree > 0)
    {
        //
        // Run thru the array finding free entries and disposing them till we
        // have disposed as many unused entries as we needed to.
        //
        for(i = _aLSEntries.Size() - 1; i >= 0; i--)
        {
            Assert(nUnusedEntriesNeedToFree > 0);
            pLSEntry = &_aLSEntries[i];
            if (!pLSEntry->_fUsed)
            {
                Assert(pLSEntry->_pLS);
                DeinitLineServices(pLSEntry->_pLS);
                _aLSEntries.Delete(i);
                if (--nUnusedEntriesNeedToFree == 0)
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lsdraw.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSDRAW.CXX -- line services drawing callbacks
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      12/29/97     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

ExternTag(tagLSCallBack);

LSERR WINAPI
CLineServices::DrawUnderline(
    PLSRUN plsrun,          // IN
    UINT kUlBase,           // IN
    const POINT* pptStart,  // IN
    DWORD dupUl,            // IN
    DWORD dvpUl,            // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const RECT* prcClip)    // IN
{
    LSTRACE(DrawUnderline);

    GetRenderer()->DrawUnderline(plsrun, kUlBase, pptStart, dupUl, dvpUl, kTFlow, kDisp, prcClip);
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawStrikethrough(
    PLSRUN plsrun,          // IN
    UINT kStBase,           // IN
    const POINT* pptStart,  // IN
    DWORD dupSt,            // IN
    DWORD dvpSt,            // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const RECT* prcClip)    // IN
{
    LSTRACE(DrawStrikethrough);
    LSNOTIMPL(DrawStrikethrough);
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawBorder(
    PLSRUN plsrun,                              // IN
    const POINT* pptStart,                      // IN
    PCHEIGHTS pheightsLineFull,                 // IN
    PCHEIGHTS pheightsLineWithoutAddedSpace,    // IN
    PCHEIGHTS pheightsSubline,                  // IN
    PCHEIGHTS pheightRuns,                      // IN
    long dupBorder,                             // IN
    long dupRunsInclBorders,                    // IN
    LSTFLOW kTFlow,                             // IN
    UINT kDisp,                                 // IN
    const RECT* prcClip)                        // IN
{
    LSTRACE(DrawBorder);
    LSNOTIMPL(DrawBorder);
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawUnderlineAsText(
    PLSRUN plsrun,          // IN
    const POINT* pptStart,  // IN
    long dupLine,           // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const RECT* prcClip)    // IN
{
    LSTRACE(DrawUnderlineAsText);
    LSNOTIMPL(DrawUnderlineAsText);
    return lserrNone;
}

LSERR WINAPI
CLineServices::ShadeRectangle(
    PLSRUN plsrun,                              // IN
    const POINT* pptStart,                      // IN
    PCHEIGHTS pheightsLineWithAddSpace,         // IN
    PCHEIGHTS pheightsLineWithoutAddedSpace,    // IN
    PCHEIGHTS pheightsSubline,                  // IN
    PCHEIGHTS pheightsRunsExclTrail,            // IN
    PCHEIGHTS pheightsRunsInclTrail,            // IN
    long dupRunsExclTrail,                      // IN
    long dupRunsInclTrail,                      // IN
    LSTFLOW kTFlow,                             // IN
    UINT kDisp,                                 // IN
    const RECT* prcClip)                        // IN
{
    LSTRACE(ShadeRectangle);
    LSNOTIMPL(ShadeRectangle);
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawTextRun(
    PLSRUN plsrun,          // IN
    BOOL fStrikeout,        // IN
    BOOL fUnderline,        // IN
    const POINT* pptText,   // IN
    LPCWSTR plwchRun,       // IN
    const int* rgDupRun,    // IN
    DWORD cwchRun,          // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const POINT* pptRun,    // IN
    PCHEIGHTS heightPres,   // IN
    long dupRun,            // IN
    long dupLimUnderline,   // IN
    const RECT* pRectClip)  // IN
{
    LSTRACE(DrawTextRun);

    TCHAR *pch = (TCHAR *)plwchRun;
    if (plsrun->IsSpecialCharRun())
    {
        GetRenderer()->ShouldSkipThisRun(plsrun, dupRun);
    }
    else
    {
        if (plsrun->_fMakeItASpace)
        {
            Assert(cwchRun == 1);
            pch = _T(" ");
        }
        GetRenderer()->TextOut(plsrun,   fStrikeout, fUnderline, pptText,
                               pch,      rgDupRun,   cwchRun,    kTFlow,
                               kDisp,    pptRun,     heightPres, dupRun,
                               dupLimUnderline,      pRectClip
                              );
    }
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawSplatLine(
    enum lsksplat,                              // IN
    LSCP cpSplat,                               // IN
    const POINT* pptSplatLine,                  // IN
    PCHEIGHTS pheightsLineFull,                 // IN
    PCHEIGHTS pheightsLineWithoutAddedSpace,    // IN
    PCHEIGHTS pheightsSubline,                  // IN
    long dup,                                   // IN
    LSTFLOW kTFlow,                             // IN
    UINT kDisp,                                 // IN
    const RECT* prcClip)                        // IN
{
    LSTRACE(DrawSplatLine);
    // FUTURE (mikejoch) Need to adjust cpSplat if we ever implement this.
    LSNOTIMPL(DrawSplatLine);
    return lserrNone;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLineServices::DrawGlyphs
//
//  Synopsis:   Draws the glyphs which are passed in
//
//  Arguments:  plsrun              pointer to the run
//              fStrikeout          is this run struck out?
//              fUnderline          is this run underlined?
//              pglyph              array of glyph indices
//              rgDu                array of widths after justification
//              rgDuBeforeJust      array of widths before justification
//              rgGoffset           array of glyph offsets
//              rgGprop             array of glyph properties
//              rgExpType           array of glyph expansion types
//              cglyph              number of glyph indices
//              kTFlow              text direction and orientation
//              kDisp               display mode - opaque, transparent
//              pptRun              starting point of the run
//              heights             presentation height for this run
//              dupRun              presentation width of this run
//              dupLimUnderline     underline limit
//              pRectClip           clipping rectangle
//
//  Returns:    LSERR               lserrNone if succesful
//                                  lserrInvalidRun if failure
//
//----------------------------------------------------------------------------
LSERR WINAPI
CLineServices::DrawGlyphs(
    PLSRUN plsrun,                  // IN
    BOOL fStrikeout,                // IN
    BOOL fUnderline,                // IN
    PCGINDEX pglyph,                // IN
    const int* rgDu,                // IN
    const int* rgDuBeforeJust,      // IN
    PGOFFSET rgGoffset,             // IN
    PGPROP rgGprop,                 // IN
    PCEXPTYPE rgExpType,            // IN
    DWORD cglyph,                   // IN
    LSTFLOW kTFlow,                 // IN
    UINT kDisp,                     // IN
    const POINT* pptRun,            // IN
    PCHEIGHTS heightsPres,          // IN
    long dupRun,                    // IN
    long dupLimUnderline,           // IN
    const RECT* pRectClip)          // IN
{
    LSTRACE(DrawGlyphs);

    GetRenderer()->GlyphOut(plsrun,    fStrikeout, fUnderline, pglyph,
                            rgDu,      rgDuBeforeJust,         rgGoffset,
                            rgGprop,   rgExpType,  cglyph,     kTFlow,
                            kDisp,     pptRun,     heightsPres,
                            dupRun,    dupLimUnderline,        pRectClip
                           );
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawEffects(
    PLSRUN plsrun,              // IN
    UINT EffectsFlags,          // IN
    const POINT* ppt,           // IN
    LPCWSTR lpwchRun,           // IN
    const int* rgDupRun,        // IN
    const int* rgDupLeftCut,    // IN
    DWORD cwchRun,              // IN
    LSTFLOW kTFlow,             // IN
    UINT kDisp,                 // IN
    PCHEIGHTS heightPres,       // IN
    long dupRun,                // IN
    long dupLimUnderline,       // IN
    const RECT* pRectClip)      // IN
{
    LSTRACE(DrawEffects);
    LSNOTIMPL(DrawEffects);
    return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lsfecbk.cxx ===
/*
 *  ExternTag(@module) LSFECBK.CXX -- line services non-Latin object handlers
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      12/22/97     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifdef DLOAD1
extern "C" // MSLS interfaces are plain C
{
#endif

#ifndef X_RUBY_H_
#define X_RUBY_H_
#include <ruby.h>
#endif

#ifndef X_TATENAK_H_
#define X_TATENAK_H_
#include <tatenak.h>
#endif

#ifndef X_HIH_H_
#define X_HIH_H_
#include <hih.h>
#endif

#ifndef X_WARICHU_H_
#define X_WARICHU_H_
#include <warichu.h>
#endif

#ifndef X_LSENSUBL_H_
#define X_LSENSUBL_H_
#include <lsensubl.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

ExternTag(tagLSCallBack);

//-----------------------------------------------------------------------------
//
// Ruby support
//
//-----------------------------------------------------------------------------

#define RUBY_OFFSET    2

LSERR WINAPI
CLineServices::FetchRubyPosition(
    LSCP lscp,                          // IN
    LSTFLOW lstflow,                    // IN
    DWORD cdwMainRuns,                  // IN
    const PLSRUN *pplsrunMain,          // IN
    PCHEIGHTS pcheightsRefMain,         // IN
    PCHEIGHTS pcheightsPresMain,        // IN
    DWORD cdwRubyRuns,                  // IN
    const PLSRUN *pplsrunRuby,          // IN
    PCHEIGHTS pcheightsRefRuby,         // IN
    PCHEIGHTS pcheightsPresRuby,        // IN
    PHEIGHTS pheightsRefRubyObj,        // OUT
    PHEIGHTS pheightsPresRubyObj,       // OUT
    long *pdvrOffsetMainBaseline,       // OUT
    long *pdvrOffsetRubyBaseline,       // OUT
    long *pdvpOffsetRubyBaseline,       // OUT
    enum rubycharjust *prubycharjust,   // OUT
    BOOL *pfSpecialLineStartEnd)        // OUT
{
    LSTRACE(FetchRubyPosition);
    LONG yAscent;
    RubyInfo rubyInfo;
    long yRubyOffset = (cdwRubyRuns > 0) ? RUBY_OFFSET : 0;
    
    *pdvrOffsetMainBaseline = 0;  // Don't want to offset the main text from
                                  // the ruby object's baseline

    if(cdwMainRuns)
    {
        HandleRubyAlignStyle((COneRun *)(*pplsrunMain), prubycharjust, pfSpecialLineStartEnd);
    }

    rubyInfo.cp = CPFromLSCP(lscp);

    // Ruby offset is the sum of the ascent of the main text
    // and the descent of the pronunciation text.
    yAscent = max(_yMaxHeightForRubyBase, pcheightsRefMain->dvAscent);
    
    *pdvpOffsetRubyBaseline = 
    *pdvrOffsetRubyBaseline = 
         yAscent + yRubyOffset + pcheightsRefRuby->dvDescent;
    rubyInfo.yHeightRubyBase = yAscent + pcheightsRefMain->dvDescent + yRubyOffset;
    rubyInfo.yDescentRubyBase = pcheightsRefMain->dvDescent;
    rubyInfo.yDescentRubyText = pcheightsRefRuby->dvDescent;

    pheightsRefRubyObj->dvAscent = yAscent + pcheightsRefRuby->dvAscent + pcheightsRefRuby->dvDescent + yRubyOffset;
    pheightsRefRubyObj->dvDescent = pcheightsRefMain->dvDescent;
    pheightsRefRubyObj->dvMultiLineHeight = 
        pheightsRefRubyObj->dvAscent + pheightsRefRubyObj->dvDescent;
    memcpy(pheightsPresRubyObj, pheightsRefRubyObj, sizeof(*pheightsRefRubyObj));

    
    // code in GetRubyInfoFromCp depends on the idea that this callback 
    // is called in order of increasing cps. This of course depends on Line Services.  
    // If this is not guaranteed to be true, then we can't just blindly append the 
    // entry here, we must insert it in sorted order or hold cp ranges in the RubyInfos
    Assert(_aryRubyInfo.Size() == 0
           || _aryRubyInfo[_aryRubyInfo.Size()-1].cp <= rubyInfo.cp);
    if(_aryRubyInfo.FindIndirect(&rubyInfo) == -1)
    {
        _aryRubyInfo.AppendIndirect(&rubyInfo);
    }

    return lserrNone;
}


// Ruby Align Style table
// =========================
// Holds the justification values to pass to line services for each ruby alignment type.
//

static const enum rubycharjust s_aRubyAlignStyleValues[] =
{
    rcjCenter,   // not set
    rcjCenter,   // auto
    rcjLeft,     // left
    rcjCenter,   // center
    rcjRight,    // right
    rcj010,      // distribute-letter
    rcj121,      // distribute-space
    rcjCenter    // line-edge
};

void WINAPI
CLineServices::HandleRubyAlignStyle(
    COneRun *porMain,                   // IN
    enum rubycharjust *prubycharjust,   // OUT
    BOOL *pfSpecialLineStartEnd)        // OUT
{
    Assert(porMain);
    
    CTreeNode *     pNode = porMain->Branch();  // This will call_ptp->GetBranch()
    CElement *      pElement = pNode->SafeElement();
    VARIANT varRubyAlign;
    styleRubyAlign styAlign;

    pElement->ComputeExtraFormat(DISPID_A_RUBYALIGN, 
        ComputeFormatsType_GetInheritedValue, pNode, &varRubyAlign);
    styAlign = (((CVariant *)&varRubyAlign)->IsEmpty()) 
                                                 ? styleRubyAlignNotSet 
                                                 : (styleRubyAlign) V_I4(&varRubyAlign);

    Assert(styAlign >= styleRubyAlignNotSet && styAlign <= styleRubyAlignLineEdge);

    *prubycharjust = s_aRubyAlignStyleValues[styAlign];
    *pfSpecialLineStartEnd = (styAlign == styleRubyAlignLineEdge);

    if(   (styAlign == styleRubyAlignNotSet || styAlign == styleRubyAlignAuto)
       && !porMain->_fCharsForNestedLayout) 
    {
        // default behavior should be centered alignment for latin characters,
        // distribute-space for ideographic characters
        const SCRIPT_ID sid = porMain->_ptp->Sid();
        if (   (sid >= sidFEFirst && sid <= sidFELast)
            || sid == sidSurrogateA 
            || sid == sidSurrogateB)
        {
            *prubycharjust = rcj121;
        }
    }
}


LSERR WINAPI
CLineServices::FetchRubyWidthAdjust(
    LSCP cp,                // IN
    PLSRUN plsrunForChar,   // IN
    WCHAR wch,              // IN
    MWCLS mwclsForChar,     // IN
    PLSRUN plsrunForRuby,   // IN
    enum rubycharloc rcl,   // IN
    long durMaxOverhang,    // IN
    long *pdurAdjustChar,   // OUT
    long *pdurAdjustRuby)   // OUT
{
    LSTRACE(FetchRubyWidthAdjust);
    Assert(plsrunForRuby);

    COneRun *       porRuby = (COneRun *)plsrunForRuby;
    CTreeNode *     pNode = porRuby->Branch();  // This will call_ptp->GetBranch()
    CElement *      pElement = pNode->SafeElement();
    styleRubyOverhang sty;

    {
        VARIANT varValue;

        pElement->ComputeExtraFormat(DISPID_A_RUBYOVERHANG, 
                                     ComputeFormatsType_GetInheritedValue, 
                                     pNode, 
                                     &varValue);

        sty = (((CVariant *)&varValue)->IsEmpty())
                 ? styleRubyOverhangNotSet
                 : (styleRubyOverhang)V_I4(&varValue);
    }
  
	*pdurAdjustChar = 0;
	*pdurAdjustRuby = (sty == styleRubyOverhangNone) ? 0 : -durMaxOverhang;
    return lserrNone;
}

LSERR WINAPI
CLineServices::RubyEnum(
    PLSRUN plsrun,              // IN
    PCLSCHP plschp,             // IN
    LSCP cp,                    // IN
    LSDCP dcp,                  // IN
    LSTFLOW lstflow,            // IN
    BOOL fReverse,              // IN
    BOOL fGeometryNeeded,       // IN
    const POINT* pt,            // IN
    PCHEIGHTS pcheights,        // IN
    long dupRun,                // IN
    const POINT *ptMain,        // IN
    PCHEIGHTS pcheightsMain,    // IN
    long dupMain,               // IN
    const POINT *ptRuby,        // IN
    PCHEIGHTS pcheightsRuby,    // IN
    long dupRuby,               // IN
    PLSSUBL plssublMain,        // IN
    PLSSUBL plssublRuby)        // IN
{
    LSTRACE(RubyEnum);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
// Tatenakayoko (HIV) support
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetTatenakayokoLinePosition(
    LSCP cp,                            // IN
    LSTFLOW lstflow,                    // IN
    PLSRUN plsrun,                      // IN
    long dvr,                           // IN
    PHEIGHTS pheightsRef,               // OUT
    PHEIGHTS pheightsPres,              // OUT
    long *pdvrDescentReservedForClient) // OUT
{
    LSTRACE(GetTatenakayokoLinePosition);
    // FUTURE (mikejoch) Need to adjust cp if we ever implement this.
    LSNOTIMPL(GetTatenakayokoLinePosition);
    return lserrNone;
}

LSERR WINAPI
CLineServices::TatenakayokoEnum(
    PLSRUN plsrun,          // IN
    PCLSCHP plschp,         // IN
    LSCP cp,                // IN
    LSDCP dcp,              // IN
    LSTFLOW lstflow,        // IN
    BOOL fReverse,          // IN
    BOOL fGeometryNeeded,   // IN
    const POINT* pt,        // IN
    PCHEIGHTS pcheights,    // IN
    long dupRun,            // IN
    LSTFLOW lstflowT,       // IN
    PLSSUBL plssubl)        // IN
{
    LSTRACE(TatenakayokoEnum);
    LSNOTIMPL(TatenakayokoEnum);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
// Warichu support
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetWarichuInfo(
    LSCP cp,                            // IN
    LSTFLOW lstflow,                    // IN
    PCOBJDIM pcobjdimFirst,             // IN
    PCOBJDIM pcobjdimSecond,            // IN
    PHEIGHTS pheightsRef,               // OUT
    PHEIGHTS pheightsPres,              // OUT
    long *pdvrDescentReservedForClient) // OUT
{
    LSTRACE(GetWarichuInfo);
    // FUTURE (mikejoch) Need to adjust cp if we ever implement this.
    LSNOTIMPL(GetWarichuInfo);
    return lserrNone;
}

LSERR WINAPI
CLineServices::FetchWarichuWidthAdjust(
    LSCP cp,                        // IN
    enum warichucharloc wcl,        // IN
    PLSRUN plsrunForChar,           // IN
    WCHAR wch,                      // IN
    MWCLS mwclsForChar,             // IN
    PLSRUN plsrunWarichuBracket,    // IN
    long *pdurAdjustChar,           // OUT
    long *pdurAdjustBracket)        // OUT
{
    LSTRACE(FetchWarichuWidthAdjust);
    // FUTURE (mikejoch) Need to adjust cp if we ever implement this.
    LSNOTIMPL(FetchWarichuWidthAdjust);
    return lserrNone;
}

LSERR WINAPI
CLineServices::WarichuEnum(
    PLSRUN plsrun,                  // IN: plsrun for the entire Warichu Object
    PCLSCHP plschp,                 // IN: lschp for lead character of Warichu Object
    LSCP cp,                        // IN: cp of first character of Warichu Object
    LSDCP dcp,                      // IN: number of characters in Warichu Object
    LSTFLOW lstflow,                // IN: text flow at Warichu Object
    BOOL fReverse,                  // IN: whether text should be reversed for visual order
    BOOL fGeometryNeeded,           // IN: whether Geometry should be returned
    const POINT* pt,                // IN: starting position, iff fGeometryNeeded
    PCHEIGHTS pcheights,            // IN: height of Warichu object, iff fGeometryNeeded
    long dupRun,                    // IN: length of Warichu Object, iff fGeometryNeeded
    const POINT *ptLeadBracket,     // IN: point for second line iff fGeometryNeeded and plssublSecond not NULL
    PCHEIGHTS pcheightsLeadBracket, // IN: height for ruby line iff fGeometryNeeded 
    long dupLeadBracket,            // IN: length of Ruby line iff fGeometryNeeded and plssublSecond not NULL
    const POINT *ptTrailBracket,    // IN: point for second line iff fGeometryNeeded and plssublSecond not NULL
    PCHEIGHTS pcheightsTrailBracket,// IN: height for ruby line iff fGeometryNeeded 
    long dupTrailBracket,           // IN: length of Ruby line iff fGeometryNeeded and plssublSecond not NULL
    const POINT *ptFirst,           // IN: starting point for main line iff fGeometryNeeded
    PCHEIGHTS pcheightsFirst,       // IN: height of main line iff fGeometryNeeded
    long dupFirst,                  // IN: length of main line iff fGeometryNeeded 
    const POINT *ptSecond,          // IN: point for second line iff fGeometryNeeded and plssublSecond not NULL
    PCHEIGHTS pcheightsSecond,      // IN: height for ruby line iff fGeometryNeeded and plssublSecond not NULL
    long dupSecond,                 // IN: length of Ruby line iff fGeometryNeeded and plssublSecond not NULL
    PLSSUBL plssublLeadBracket,     // IN: subline for lead bracket
    PLSSUBL plssublTrailBracket,    // IN: subline for trail bracket
    PLSSUBL plssublFirst,           // IN: first subline in Warichu object
    PLSSUBL plssublSecond)          // IN: second subline in Warichu object
{
    LSTRACE(WarichuEnum);
    LSNOTIMPL(WarichuEnum);
    return lserrNone;
}


//-----------------------------------------------------------------------------
//
// HIH support
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::HihEnum(
    PLSRUN plsrun,          // IN
    PCLSCHP plschp,         // IN
    LSCP cp,                // IN
    LSDCP dcp,              // IN
    LSTFLOW lstflow,        // IN
    BOOL fReverse,          // IN
    BOOL fGeometryNeeded,   // IN
    const POINT* pt,        // IN
    PCHEIGHTS pcheights,    // IN
    long dupRun,            // IN
    PLSSUBL plssubl)        // IN
{
    LSTRACE(HihEnum);
    LSNOTIMPL(HihEnum);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
// Reverse Object support
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ReverseEnum(
    PLSRUN plsrun,          // IN
    PCLSCHP plschp,         // IN
    LSCP cp,                // IN
    LSDCP dcp,              // IN
    LSTFLOW lstflow,        // IN
    BOOL fReverse,          // IN
    BOOL fGeometryNeeded,   // IN
    const POINT* ppt,       // IN
    PCHEIGHTS pcheights,    // IN
    long dupRun,            // IN
    LSTFLOW lstflowSubline, // IN
    PLSSUBL plssubl)        // IN
{
    LSTRACE(ReverseEnum);

    return LsEnumSubline(plssubl, fReverse, fGeometryNeeded, ppt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\linesrv.cxx ===
\/*
 *  @doc    INTERNAL
 *
 *  @module LINESRV.CXX -- line services interface
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *      Paul Parker
 *
 *  History: <nl>
 *      11/20/97     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include <textxfrm.hxx>
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_RUBY_H_
#define X_RUBY_H_
#include <ruby.h>
#endif

#ifndef X_HIH_H_
#define X_HIH_H_
#include <hih.h>
#endif

#ifndef X_TATENAK_H_
#define X_TATENAK_H_
#include <tatenak.h>
#endif

#ifndef X_WARICHU_H_
#define X_WARICHU_H_
#include <warichu.h>
#endif

#ifndef X_ROBJ_H_
#define X_ROBJ_H_
#include <robj.h>
#endif

#ifndef X_LSHYPH_H_
#define X_LSHYPH_H_
#include <lshyph.h>
#endif

#ifndef X_LSKYSR_H_
#define X_LSKYSR_H_
#include <lskysr.h>
#endif

#ifndef X_LSEMS_H_
#define X_LSEMS_H_
#include <lsems.h>
#endif

#ifndef X_LSPAP_H_
#define X_LSPAP_H_
#include <lspap.h>
#endif

#ifndef X_LSCHP_H_
#define X_LSCHP_H_
#include <lschp.h>
#endif

#ifndef X_LSTABS_H_
#define X_LSTABS_H_
#include <lstabs.h>
#endif

#ifndef X_LSTXM_H_
#define X_LSTXM_H_
#include <lstxm.h>
#endif

#ifndef X_OBJDIM_H_
#define X_OBJDIM_H_
#include <objdim.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_FONTLINK_HXX_
#define X_FONTLINK_HXX_
#include "fontlink.hxx"
#endif

DeclareLSTag( tagLSCallBack, "Trace callbacks" );
DeclareLSTag( tagLSAsserts, "Show LS Asserts" );
DeclareLSTag( tagLSFetch, "Trace FetchPap/FetchRun" );
DeclareLSTag( tagLSNoBlast, "No blasting at render time" );
DeclareLSTag( tagLSIME, "Trace IME" );
DeclareLSTag( tagAssertOnHittestingWithLS, "Enable hit-testing assertions.");

MtDefine(LineServices, Mem, "LineServices")
MtDefine(LineServicesMem, LineServices, "CLineServices::NewPtr/ReallocPtr")
MtDefine(CLineServices, LineServices, "CLineServices")
MtDefine(CLineServices_arySynth_pv, CLineServices, "CLineServices::_arySynth::_pv")
MtDefine(CLineServices_aryOneRuns_pv, CLineServices, "CLineServices::_aryOneRuns::_pv")
MtDefine(CLineServices_aryLineFlags_pv,  CLineServices, "CLineServices::_aryLineFlags::_pv")
MtDefine(CLineServices_aryLineCounts_pv, CLineServices, "CLineServices::_aryLineCounts::_pv")
MtDefine(CLineServicesCalculatePositionsOfRangeOnLine_aryLsqsubinfo_pv, Locals, "CLineServices::CalculatePositionsOfRangeOnLine::aryLsqsubinfo_pv");
MtDefine(CLineServicesCalculateRectsOfRangeOnLine_aryLsqsubinfo_pv, Locals, "CLineServices::CalculateRectsOfRangeOnLine::aryLsqsubinfo_pv");
MtDefine(COneRun, LineServices, "COneRun")
MtDefine(CLineServices_SetRenHighlightScore_apRender_pv, CLineServices, "CLineServices::SetRenHighlightScore_apRender_pv");
MtDefine(CLineServices_VerticalAlignOneObjectFast, LFCCalcSize, "Calls to VerticalAlignOneObjectFast" )

extern LCID g_lcidLocalUserDefault;

enum KASHIDA_PRIORITY
{
    KASHIDA_PRIORITY1,    // SCRIPT_JUSTIFY_ARABIC_KASHIDA
    KASHIDA_PRIORITY2,    // SCRIPT_JUSTIFY_ARABIC_SEEN
    KASHIDA_PRIORITY3,    // SCRIPT_JUSTIFY_ARABIC_HA
    KASHIDA_PRIORITY4,    // SCRIPT_JUSTIFY_ARABIC_ALEF
    KASHIDA_PRIORITY5,    // SCRIPT_JUSTIFY_ARABIC_BARA
    KASHIDA_PRIORITY6,    // SCRIPT_JUSTIFY_ARABIC_RA
    KASHIDA_PRIORITY7,    // SCRIPT_JUSTIFY_ARABIC_NORMAL
    KASHIDA_PRIORITY8,    // SCRIPT_JUSTIFY_ARABIC_BA
    KASHIDA_PRIORITY9,    // Max - lowest priority
};

int const s_iKashidaPriFromScriptJustifyType[] =
    {
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_NONE
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_ARABIC_BLANK
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_CHARACTER
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_RESERVED1
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_BLANK    
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_RESERVED2
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_RESERVED3
    KASHIDA_PRIORITY7, // SCRIPT_JUSTIFY_ARABIC_NORMAL
    KASHIDA_PRIORITY1, // SCRIPT_JUSTIFY_ARABIC_KASHIDA
    KASHIDA_PRIORITY4, // SCRIPT_JUSTIFY_ARABIC_ALEF
    KASHIDA_PRIORITY3, // SCRIPT_JUSTIFY_ARABIC_HA
    KASHIDA_PRIORITY6, // SCRIPT_JUSTIFY_ARABIC_RA
    KASHIDA_PRIORITY8, // SCRIPT_JUSTIFY_ARABIC_BA
    KASHIDA_PRIORITY5, // SCRIPT_JUSTIFY_ARABIC_BARA
    KASHIDA_PRIORITY2, // SCRIPT_JUSTIFY_ARABIC_SEEN
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_RESERVED4
    };

//-----------------------------------------------------------------------------
//
//  Function:   InitLineServices (global)
//
//  Synopsis:   Instantiates a instance of the CLineServices object and makes
//              the requisite calls into the LineServices DLL.
//
//  Returns:    HRESULT
//              *ppLS - pointer to newly allocated CLineServices object
//
//-----------------------------------------------------------------------------

HRESULT
InitLineServices(
    CMarkup *pMarkup,           // IN
    BOOL fStartUpLSDLL,         // IN
    CLineServices ** ppLS)      // OUT
{
    HRESULT hr = S_OK;
    CLineServices * pLS;

    // Note: this assertion will fire sometimes if you're trying to put
    // pointers to member functions into the lsimethods structure.  Note that
    // pointer to member functions are different from function pointers -- ask
    // one of the Borland guys (like ericvas) to explain.  Sometimes they will
    // be bigger than 4 bytes, causing mis-alignment between our structure and
    // LS's, and thus this assertion to fire.

#if defined(UNIX) || defined(_MAC) // IEUNIX uses 8/12 bytes Method ptrs.
    AssertSz(sizeof(CLineServices::LSIMETHODS) == sizeof(LSIMETHODS),
             "Line Services object callback struct has unexpectedly changed.");
    AssertSz(sizeof(CLineServices::LSCBK) == sizeof(LSCBK),
             "Line Services callback struct has unexpectedly changed.");
#endif
    //
    // Create our Line Services interface object
    //

    pLS = new CLineServices(pMarkup);
    if (!pLS)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    WHEN_DBG(pLS->_lockRecrsionGuardFetchRun = FALSE;)
            
    pLS->_plsc = NULL;
    if (fStartUpLSDLL)
    {
        hr = THR(StartUpLSDLL(pLS, pMarkup));
        if (hr)
        {
            delete pLS;
            goto Cleanup;
        }
    }

    //
    // Return value
    //

    *ppLS = pLS;

Cleanup:
    RRETURN(hr);
}


HRESULT
StartUpLSDLL(CLineServices *pLS, CMarkup *pMarkup)
{
    LSCONTEXTINFO lsci;
    HRESULT hr = S_OK;

    if (pMarkup != pLS->GetMarkup())
        pLS->_treeInfo._tpFrontier.Reinit(pMarkup, 0);

    if (pLS->_plsc)
        goto Cleanup;

#ifndef DLOAD1
    //
    // Make sure we init all of the dynprocs for LS
    //
    hr = THR( InitializeLSDynProcs() );
    if (hr)
        goto Cleanup;
#endif

    //
    // Fetch the Far East object handlers
    //

    hr = THR( pLS->SetupObjectHandlers() );
    if (hr)
        goto Cleanup;

    //
    // Populate the LSCONTEXTINFO
    //

    lsci.version = 0;
    lsci.cInstalledHandlers = CLineServices::LSOBJID_COUNT;
#if !defined(UNIX) && !defined(_MAC)
    *(CLineServices::LSIMETHODS **)&lsci.pInstalledHandlers = pLS->g_rgLsiMethods;
#else
    {
        static BOOL fInitDone = FALSE;
        if (!fInitDone)
        {
            // Copy g_rgLsiMethods -> s_unix_rgLsiMethods
            pLS->InitLsiMethodStruct();
            fInitDone = TRUE;
        }
    }
    lsci.pInstalledHandlers = pLS->s_unix_rgLsiMethods;
#endif
    lsci.lstxtcfg = pLS->s_lstxtcfg;
    lsci.pols = (POLS)pLS;
#if !defined(UNIX) && !defined(_MAC)
    *(CLineServices::LSCBK *)&lsci.lscbk = CLineServices::s_lscbk;
#else
    CLineServices::s_lscbk.fill(&lsci.lscbk);
#endif
    lsci.fDontReleaseRuns = TRUE;

    //
    // Call in to Line Services
    //

    hr = HRFromLSERR( LsCreateContext( &lsci, &pLS->_plsc ) );
    if (hr)
        goto Cleanup;

    //
    // Set Expansion/Compression tables
    //

    hr = THR( pLS->SetModWidthPairs() );
    if (hr)
        goto Cleanup;
            
    //
    // Runtime sanity check
    //

    WHEN_DBG( pLS->InitTimeSanityCheck() );

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   DeinitLineServices (global)
//
//  Synopsis:   Frees a CLineServes object.
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------------

HRESULT
DeinitLineServices(CLineServices * pLS)
{
    HRESULT hr = S_OK;

    if (pLS->_plsc)
        hr = HRFromLSERR( LsDestroyContext( pLS->_plsc ) );

    delete pLS;

    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   SetupObjectHandlers (member)
//
//  Synopsis:   LineServices uses object handlers for special textual
//              representation.  There are six such objects in Trident,
//              and for five of these, the callbacks are implemented by
//              LineServices itself.  The sixth object, our handle for
//              embedded/nested objects, is implemented in lsobj.cxx.
//
//  Returns:    S_OK - Success
//              E_FAIL - A LineServices error occurred
//
//-----------------------------------------------------------------------------

HRESULT
CLineServices::SetupObjectHandlers()
{
    HRESULT hr = E_FAIL;
    ::LSIMETHODS *pLsiMethod;

#if !defined(UNIX) && !defined(_MAC)
    pLsiMethod = (::LSIMETHODS *)g_rgLsiMethods;
#else
    pLsiMethod = s_unix_rgLsiMethods;
#endif

    if (lserrNone != LsGetRubyLsimethods( pLsiMethod + LSOBJID_RUBY ))
        goto Cleanup;

    if (lserrNone != LsGetTatenakayokoLsimethods( pLsiMethod + LSOBJID_TATENAKAYOKO ))
        goto Cleanup;

    if (lserrNone != LsGetHihLsimethods( pLsiMethod + LSOBJID_HIH ))
        goto Cleanup;

    if (lserrNone != LsGetWarichuLsimethods( pLsiMethod + LSOBJID_WARICHU ))
        goto Cleanup;

    if (lserrNone != LsGetReverseLsimethods( pLsiMethod + LSOBJID_REVERSE ))
        goto Cleanup;

    hr = S_OK;

#if DBG == 1
    // Every object, which has a scope have to have a level in object hierarchy.
    // Non-scope objects have to have level set to 0.
    for (int type = SYNTHTYPE_NONE; type < SYNTHTYPE_COUNT; type++)
    {
        if (s_aSynthData[type].fObjStart || s_aSynthData[type].fObjEnd)
            Assert(s_aSynthData[type].idLevel != 0);
        else
            Assert(s_aSynthData[type].idLevel == 0);
    }
#endif

Cleanup:

    return hr;
}

//-----------------------------------------------------------------------------
//
//  Function:   NewPtr (member, LS callback)
//
//  Synopsis:   A client-side allocation routine for LineServices.
//
//  Returns:    Pointer to buffer allocated, or NULL if out of memory.
//
//-----------------------------------------------------------------------------

void* WINAPI
CLineServices::NewPtr(DWORD cb)
{
    void * p;

    p = MemAlloc( Mt(LineServicesMem), cb );

    MemSetName((p, "CLineServices::NewPtr"));

    return p;
}

//-----------------------------------------------------------------------------
//
//  Function:   DisposePtr (member, LS callback)
//
//  Synopsis:   A client-side 'free' routine for LineServices
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

void  WINAPI
CLineServices::DisposePtr(void* p)
{
    MemFree(p);
}

//-----------------------------------------------------------------------------
//
//  Function:   ReallocPtr (member, LS callback)
//
//  Synopsis:   A client-side reallocation routine for LineServices
//
//  Returns:    Pointer to new buffer, or NULL if out of memory
//
//-----------------------------------------------------------------------------

void* WINAPI
CLineServices::ReallocPtr(void* p, DWORD cb)
{
    void * q = p;
    HRESULT hr;

    hr = MemRealloc( Mt(LineServicesMem), &q, cb );

    return hr ? NULL : q;
}

LSERR WINAPI
CLineServices::GleanInfoFromTheRun(COneRun *por, COneRun **pporOut)
{
    LSERR         lserr = lserrNone;
    const         CCharFormat *pCF;
    WHEN_DBG(BOOL fWasTextRun = TRUE;)
    SYNTHTYPE     synthCur = SYNTHTYPE_NONE;
    LONG          cp = por->Cp();
    LONG          nDirLevel;
    LONG          nSynthDirLevel;
    COneRun     * porOut = por;
    BOOL          fLastPtp;
    BOOL          fNodeRun;
    CTreeNode   * pNodeRun;

    por->_fHidden = FALSE;
    porOut->_fNoTextMetrics = FALSE;

    if (   _pflw._fDoPostFirstLetterWork
        && _pflw._fStartedPseudoMBP
        && _pMarkup->HasCFState() // may be null in OOM
       )
    {
        BOOL fH, fV;
        CRect rcDimensions;
        CComputeFormatState * pcfState = _pMarkup->GetCFState();

        pNodeRun = pcfState->GetBlockNodeLetter();
        Verify(pNodeRun->GetInlineMBPForPseudo(_pci, GIMBPC_ALL, &rcDimensions, &fH, &fV));
        _pflw._fStartedPseudoMBP = FALSE;
        lserr = AppendSynth(por, SYNTHTYPE_MBPCLOSE, &porOut);
        if (lserr == lserrNone)
        {
            porOut->_mbpTop = _mbpTopCurrent;
            porOut->_mbpBottom = _mbpBottomCurrent;
            _mbpTopCurrent -= rcDimensions.top;
            _mbpBottomCurrent -= rcDimensions.bottom;
            porOut->_xWidth = rcDimensions.right;
            porOut->_fIsPseudoMBP = TRUE;
        }

        if (HasBorders(pNodeRun->GetFancyFormat(), pNodeRun->GetCharFormat(), TRUE))
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_INLINE_BG_OR_BORDER);
        }

        goto Done;
    }
    
    if (por->_ptp->IsNode())
    {
        fNodeRun = TRUE;
        pNodeRun = por->_ptp->Branch();
        fLastPtp = por->_ptp == _treeInfo._ptpLayoutLast;
        const      CCharFormat *pCF  = por->GetCF();

        if (    pCF->_fHasInlineBg
            && !pCF->IsDisplayNone()
           )
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST | FLAG_HAS_INLINE_BG_OR_BORDER);
        }
        
        // if the run is
        // a) is an node pos
        // b) and needs to glyphed either for glyphs or for MBP
        // c) and has not been synthed either for editing glyphs or MBP
        // d) not the last run in the layout
        // then we want to create those synths
        if (((  _fIsEditable
              && por->_ptp->ShowTreePos()
             )
             || (   pNodeRun->HasInlineMBP(LC_TO_FC(GetLayoutContext()))
                 && !pCF->IsDisplayNone()
                )
            )
            && !por->_fSynthedForMBPOrG
            && !fLastPtp
           )
        {
            CRect rcDimensions;
            BOOL fHPercentAttr;
            BOOL fVPercentAttr;
            COneRun *porRet = NULL;

            if (por->_ptp->IsBeginNode())
            {
                // Create open glyph if it is needed
                if (   _fIsEditable
                    && por->_ptp->ShowTreePos()
                   )
                {
                    lserr = AppendSynth(por, SYNTHTYPE_GLYPH, &porRet);
                    if (lserr != lserrNone)
                        goto Done;
                    Assert(porRet);
                    porRet->_lsCharProps.idObj = LSOBJID_GLYPH;
                    SetRenderingHighlights(porRet);
                    _lineFlags.AddLineFlagForce(cp - 1, FLAG_HAS_NOBLAST | FLAG_HAS_NODUMMYLINE);
                }

                // Now create an open mbp if it is needed
                if (   pNodeRun->HasInlineMBP()
                    && pNodeRun->GetInlineMBPContributions(_pci, GIMBPC_ALL, &rcDimensions, &fHPercentAttr, &fVPercentAttr)
                   )
                {
                    if (fHPercentAttr)
                        ((CDisplay*)(_pMeasurer->_pdp))->SetHorzPercentAttrInfo(TRUE);
                    if (fVPercentAttr)
                        ((CDisplay*)(_pMeasurer->_pdp))->SetVertPercentAttrInfo(TRUE);
                    _mbpTopCurrent += rcDimensions.top;
                    _mbpBottomCurrent += rcDimensions.bottom;

                    _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST | FLAG_HAS_MBP);

                    if (   por->_ptp->IsEdgeScope()
                        && rcDimensions.left
                       )
                    {
                        COneRun *porTemp;
                        lserr = AppendSynth(por, SYNTHTYPE_MBPOPEN, &porTemp);
                        if (lserr != lserrNone)
                            goto Done;
                        Assert(porTemp);
                        if (!porRet)
                            porRet = porTemp;
                        porTemp->_xWidth = rcDimensions.left;
                        porTemp->_fIsLTR = !(GetDirLevel(porTemp->_lscpBase) & 0x1);
                    }

                    if (HasBorders(pNodeRun->GetFancyFormat(), pNodeRun->GetCharFormat(), FALSE))
                    {
                        _lineFlags.AddLineFlag(cp, FLAG_HAS_INLINE_BG_OR_BORDER);
                    }
                }
            }
            else
            {
                // Create a close mbp if it is needed
                if (   pNodeRun->HasInlineMBP()
                    && pNodeRun->GetInlineMBPContributions(_pci, GIMBPC_ALL, &rcDimensions, &fHPercentAttr, &fVPercentAttr)
                    && !pCF->IsDisplayNone()
                   )
                {
                    if (fHPercentAttr)
                        ((CDisplay*)(_pMeasurer->_pdp))->SetHorzPercentAttrInfo(TRUE);
                    if (fVPercentAttr)
                        ((CDisplay*)(_pMeasurer->_pdp))->SetVertPercentAttrInfo(TRUE);
                    _mbpTopCurrent -= rcDimensions.top;
                    _mbpBottomCurrent -= rcDimensions.bottom;

                    _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST | FLAG_HAS_MBP);

                    if (   por->_ptp->IsEdgeScope()
                        && rcDimensions.right
                       )
                    {
                        lserr = AppendSynth(por, SYNTHTYPE_MBPCLOSE, &porRet);
                        if (lserr != lserrNone)
                            goto Cleanup;
                        Assert(porRet);
                        porRet->_xWidth = rcDimensions.right;
                        porRet->_fIsLTR = !(GetDirLevel(porRet->_lscpBase) & 0x1);
                    }

                    if (HasBorders(pNodeRun->GetFancyFormat(), pNodeRun->GetCharFormat(), FALSE))
                    {
                        _lineFlags.AddLineFlag(cp, FLAG_HAS_INLINE_BG_OR_BORDER);
                    }

                }

                // Create close glyph if it is needed
                if (   _fIsEditable
                    && por->_ptp->ShowTreePos()
                   )
                {
                    COneRun *porTemp;
                    lserr = AppendSynth(por, SYNTHTYPE_GLYPH, &porTemp);
                    if (lserr != lserrNone)
                        goto Done;
                    Assert(porTemp);
                    if (!porRet)
                        porRet = porTemp;
                    porTemp->_lsCharProps.idObj = LSOBJID_GLYPH;
                    SetRenderingHighlights(porTemp);
                    _lineFlags.AddLineFlagForce(cp -1, FLAG_HAS_NOBLAST | FLAG_HAS_NODUMMYLINE);
                }
            }
            if (porRet)
            {
                por->_fSynthedForMBPOrG = TRUE;
                porOut = porRet; 
                goto Done;
            }
        }
    }
    else
    {
        fNodeRun = FALSE;
        fLastPtp = FALSE;
        Assert(por->_ptp != _treeInfo._ptpLayoutLast);
        pNodeRun = NULL;
    }

    if (_pflw._fDoPostFirstLetterWork)
    {
        _pflw._fDoPostFirstLetterWork = FALSE;
        _pflw._fStartedPseudoMBP = FALSE;

        CTreeNode *pNode = por->Branch();
        _pMeasurer->PseudoLetterDisable();
        _treeInfo.SetupCFPF(TRUE, pNode FCCOMMA LC_TO_FC(GetLayoutContext()));

        if (_pflw._fTerminateLine)
        {
            _pflw._fTerminateLine = FALSE;
            lserr = TerminateLine(por, TL_ADDLBREAK, &porOut);
            goto Cleanup;
        }

        if (_pflw._fChoppedFirstLetter)
        {
            _pflw._fChoppedFirstLetter = FALSE;
            if (por->_fMustDeletePcf)
            {
                delete por->_pCF;
                por->_fMustDeletePcf = FALSE;
            }
            por->_pCF = (CCharFormat *)_treeInfo._pCF;
#if DBG==1
            por->_pCFOriginal = por->_pCF;
#endif
            por->_pPF = _treeInfo._pPF;
            por->_pFF = _treeInfo._pFF;
        }
    }
    
    if (   _pMeasurer->_fMeasureFromTheStart
        && (cp - _cpStart) < _pMeasurer->_cchPreChars
       )
    {
        WhiteAtBOL(cp, por->_lscch);
        por->MakeRunAntiSynthetic();
        goto Done;
    }

    //
    // Take care of hidden runs. We will simply anti-synth them
    //
    if (   por->GetCF()->IsDisplayNone()
        && !fLastPtp // Check for !lastptp since the formats are not setup correctly
                     // for the last ptp
       )
    {
        if (IsFirstNonWhiteOnLine(cp))
            WhiteAtBOL(cp, por->_lscch);
        // This condition will succeed only if we have overlapping display:none.
        // In that case, we do not want to overload BlastLineToScreen with checking
        // for overlapping and hence we just do not blast such lines.
        if (!por->_fCharsForNestedElement)
            _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST);
        _lineCounts.AddLineCount(cp, LC_HIDDEN, por->_lscch);
        por->MakeRunAntiSynthetic();
        goto Done;
    }

    // BR with clear causes a break after the line break,
    // where as clear on phrase or block elements should clear
    // before the phrase or block element comes into scope.
    // Clear on aligned elements is handled separately, so
    // do not mark the line with clear flags for aligned layouts.
    if (   cp != _cpStart
        && fNodeRun
        && pNodeRun->Tag() != ETAG_BR
        && !por->GetFF()->_fAlignedLayout
        && por->_ptp->IsBeginNode()
        && _pMeasurer->TestForClear(_pMarginInfo, cp - 1, TRUE, por->GetFF())
       )
    {
        lserr = TerminateLine(por, TL_ADDEOS, &porOut);
        Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
        goto Cleanup;
    }
            
    if (   !por->_fCharsForNestedLayout
        && fNodeRun
       )
    {
        CElement  *pElement          = pNodeRun->Element();
        BOOL       fFirstOnLineInPre = FALSE;
        const      CCharFormat *pCF  = por->GetCF();

        // This run can never be hidden, no matter what the HTML says
        Assert(!por->_fHidden);

        if (!fLastPtp && IsFirstNonWhiteOnLine(cp))
        {
            WhiteAtBOL(cp, por->_lscch);

            //
            // If we have a <BR> inside a PRE tag then we do not want to
            // break if the <BR> is the first thing on this line. This is
            // because there should have been a \r before the <BR> which
            // caused one line break and we should not have the <BR> break
            // another line. The only execption is when the <BR> is the
            // first thing in the paragraph. In this case we *do* want to
            // break (the exception was discovered via bug 47870).
            //
            if (   _pPFFirst->HasPre(_fInnerPFFirst)
                && !(_lsMode == LSMODE_MEASURER ? _li._fFirstInPara : _pli->_fFirstInPara)
               )
            {
                fFirstOnLineInPre = TRUE;
            }
        }

        if (   por->_ptp->IsEdgeScope()
            && (   _pFlowLayout->IsElementBlockInContext(pElement)
                || fLastPtp
               )
            && (   !fFirstOnLineInPre
                || (   por->_ptp->IsEndElementScope()
                    && pElement->_fBreakOnEmpty
                    && pElement->Tag() == ETAG_PRE
                   )
               )
            && pElement->Tag() != ETAG_BR
           )
        {
#if 0            
            Assert(   fLastPtp
                   || !IsFirstNonWhiteOnLine(cp)
                   || pElement->_fBreakOnEmpty
                   || (ETAG_LI == pElement->Tag())
                  );
#endif

            if (   pCF->HasPadBord(FALSE)
                && !fLastPtp
               )
            {
                CheckForPaddingBorder(por);
            }

            // NOTE(SujalP): We are check for MBPorG while it should ideally be just
            // glyph, but since the current por is a block element it can only be
            // Glyph, since MBP is for inline elements only.
            lserr = TerminateLine(por,
                                  ((fLastPtp || por->_fSynthedForMBPOrG) ? TL_ADDEOS : TL_ADDLBREAK),
                                  &porOut);
            if (lserr != lserrNone || !porOut)
            {
                lserr = lserrOutOfMemory;
                goto Done;
            }

            // Hide the run that contains the WCH_NODE for the end
            // edge in the layout
            por->_fHidden = TRUE;

            if (fLastPtp)
            {
                if (   IsFirstNonWhiteOnLine(cp)
                    && (   _fIsEditable
                        || _pFlowLayout->GetContentTextLength() == 0
                       )
                    )
                {
                    CCcs ccs;
                    if (GetCcs(&ccs, por, _pci->_hdc, _pci))
                        RecalcLineHeight(por->GetCF(), cp - 1, &ccs, &_li);

                    // This line is not a dummy line. It has a height. The
                    // code later will treat it as a dummy line. Prevent
                    // that from happening.
                    _fLineWithHeight = TRUE;
                }
                goto Done;
            }

            //
            // Bug66768: If we came here at BOL without the _fHasBulletOrNum flag being set, it means
            // that the previous line had a <BR> and we will terminate this line at the </li> so that
            // all it contains is the </li>. In this case we do infact want the line to have a height
            // so users can type there.
            //
            else if (   IsListItem(pNodeRun)
                     && por->_ptp->IsEndNode()
                     && !_li._fHasBulletOrNum
                     && IsFirstNonWhiteOnLine(cp)
                     && (  !_pMeasurer->_fEmptyLineForPadBord
                         || _fIsEditable
                        )
                    )
            {
                CCcs ccs;
                if (GetCcs(&ccs, por, _pci->_hdc, _pci))
                    RecalcLineHeight(por->GetCF(), cp - 1, &ccs, &_li);
                _fLineWithHeight = TRUE;
            }
        }
        else  if (   por->_ptp->IsEndNode()
                  && pElement->Tag() == ETAG_BR
                  && !fFirstOnLineInPre
                 )
        {
            _lineFlags.AddLineFlag(cp - 1, FLAG_HAS_A_BR);
            AssertSz(por->_ptp->IsEndElementScope(), "BR's cannot be proxied!");
            Assert(por->_lscch == 1);
            Assert(por->_lscchOriginal == 1);

            lserr = TerminateLine(por, TL_ADDNONE, &porOut);
            if (lserr != lserrNone)
                goto Done;
            if (!porOut)
                porOut = por;

            por->FillSynthData(SYNTHTYPE_LINEBREAK);
            _pMeasurer->TestForClear(_pMarginInfo, cp, FALSE, por->GetFF());
            if (IsFirstNonWhiteOnLine(cp))
                _fLineWithHeight = TRUE;

            if (   _pci->GetLayoutContext() 
                && _pci->GetLayoutContext()->ViewChain() )
            {
                Assert(pNodeRun);

                // page break before / after support on br
                const CFancyFormat *pFF = pNodeRun->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));

                _li._fPageBreakAfter    |= GET_PGBRK_BEFORE(pFF->_bPageBreaks) || GET_PGBRK_AFTER(pFF->_bPageBreaks);
                _pci->_fPageBreakLeft   |= (   IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft) 
                                            || IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft)   );
                _pci->_fPageBreakRight  |= (   IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight)
                                            || IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight)  );
            }
        }
        //
        // Handle premature Ruby end here
        // Example: <RUBY>some text</RUBY>
        //
        else if (   pElement->Tag() == ETAG_RUBY
                 && por->_ptp->IsEndNode()       // this is an end ruby tag
                 && _fIsRuby                     // and we currently have an open ruby
                 && !_fIsRubyText                // and we have not yet closed it off
                 && !IsFrozen())
        {
            COneRun *porTemp = NULL;
            Assert(por->_lscch == 1);
            Assert(por->_lscchOriginal == 1);

            // if we got here then we opened a ruby but never ended the main
            // text (i.e., with an RT).  Now we want to end everything, so this
            // involves first appending a synthetic to end the main text and then
            // another one to end the (nonexistent) pronunciation text.
            lserr = AppendILSControlChar(por, SYNTHTYPE_ENDRUBYMAIN, &porOut);
            Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
            lserr = AppendILSControlChar(por, SYNTHTYPE_ENDRUBYTEXT, &porTemp);
            Assert(lserr != lserrNone || porTemp->_synthType != SYNTHTYPE_NONE);

            // We set this to FALSE because por will eventually be marked as
            // "not processed yet", which means that the above condition will trip
            // again unless we indicate that the ruby is now closed
            _fIsRuby = FALSE;
        }
        // WBR handling - if we are currently inside NOBR, we have to close
        //and reopen NOBR, creating breaking opportunity.
        //If we are not inside NOBR, we synthesize SYNTHTYPE_WBR run that 
        //modifies breaking behavior to break the line if it doesn't fit.
        //We use _fSynthedForMBPOrG flag to ignore and antisynth the run when it
        //will come back to us next time.
        else if(   pElement->Tag() == ETAG_WBR
                && por->_ptp->IsEndNode()
                && !por->_fSynthedForMBPOrG
               )
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_EMBED_OR_WBR);

            if(_fNoBreakForMeasurer)    //inside NOBR subline?
            {
                por->FillSynthData(SYNTHTYPE_ENDNOBR);
            }
            else
            {
                lserr = AppendSynth(por, SYNTHTYPE_WBR, &porOut);
                Assert(lserr != lserrNone || porOut->_synthType == SYNTHTYPE_WBR);
                if (lserr == lserrNone)
                    porOut->_xWidth = 0;
                por->_fSynthedForMBPOrG = TRUE;
            }
        }
        // NOBR handling (IE5.0 compat) - if we are currently inside NOBR object, 
        // and we see a closing tag - it's may be a tag that closes nobr.
        //If the next ptp will be an opening tag with nobr attribute, we can skip
        // a breaking opportunity. To create it, we catch every EndNode tag here 
        // and see if parent doesn't have a nobr attribute. If so, we create a breaking
        // opportunity. This works for IE5.0 case (<NOBR> tags, no overlapping or inheritance),
        // and it works for CSS attribute white-space:nowrap,
        // (this attribute is the same as NOBR but can be inherited, nested, etc)
        else if(   _fNoBreakForMeasurer 
                && por->_ptp->IsEndNode() 
                && !por->_fSynthedForMBPOrG
               )
        {
            CTreeNode *pParentNode = por->Branch()->Parent();
            const CCharFormat *pParentCF = pParentNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));

            if (!pParentCF->HasNoBreak(SameScope(pParentNode, _pFlowLayout->ElementContent())))
            {
                lserr = AppendSynth(por, SYNTHTYPE_ENDNOBR, &porOut);
                if (lserr != lserrNone)
                    goto Cleanup;
                por->_fSynthedForMBPOrG = TRUE;
            }
            else
                por->MakeRunAntiSynthetic();

        }
        else
        {
            //
            // A normal phrase element start or end run. Just make
            // it antisynth so that it is hidden from LS
            //
            por->MakeRunAntiSynthetic();
        }

        if (!por->IsAntiSyntheticRun())
        {
            //
            // Empty lines will need some height!
            //
            if (   pElement->_fBreakOnEmpty
                && (  !_pMeasurer->_fEmptyLineForPadBord
                    || _fIsEditable
                   )
                && IsFirstNonWhiteOnLine(cp)
               )
            {
                // We provide a line height only if something in our whitespace
                // is not providing some visual representation of height. So if our
                // whitespace was either aligned or abspos'd then we do NOT provide
                // any height since these sites provide some height of their own.
                if (   _lineCounts.GetLineCount(por->Cp(), LC_ALIGNEDSITES) == 0
                    && _lineCounts.GetLineCount(por->Cp(), LC_ABSOLUTESITES) == 0
                    && !_pMeasurer->_fSeenAbsolute
                   )
                {
                    CCcs ccs;
                    if (GetCcs(&ccs, por, _pci->_hdc, _pci))
                        RecalcLineHeight(por->GetCF(), cp - 1, &ccs, &_li);
                    _fLineWithHeight = TRUE;
                }
            }

            if (   IsFrozen()                       // if we called terminate line
                && IsDummyLine(por->Cp())           // and we are a dummy line
                && (   _pMeasurer->_fSeenAbsolute   // and we have absolutes
                    || _lineCounts.GetLineCount(por->Cp(), LC_ABSOLUTESITES) != 0
                   )
               )
            {
                // then we need to replace the PF in the measurer so that alignment
                // will work per the PF of the chars in the dummy line and not
                // based on the first char in the following line. Ideally I would
                // do this for all dummy lines, except that other dummy lines
                // really do not matter since they do not have anything rendered.
                LONG cpBegin = _cpStart;

                if (!_pMeasurer->_fMeasureFromTheStart)
                    cpBegin -= _pMeasurer->_cchPreChars;
                CTreePos *ptp = _pMarkup->TreePosAtCp(cpBegin, NULL, TRUE);
                if (ptp)
                {
                    CTreeNode *pNode = ptp->GetBranch();
                    _pMeasurer->MeasureSetPF(pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext())),
                                             SameScope(pNode, _pFlowLayout->ElementContent()),
                                             TRUE);
                }
            }
            
            //
            // If we have already decided to give the line a height then we want
            // to get the text metrics else we do not want the text metrics. The
            // reasons are explained in the blurb below.
            //
            if (!_fLineWithHeight)
            {
                //
                // If we have not anti-synth'd the run, it means that we have terminated
                // the line -- either due to a block element or due to a BR element. In either
                // of these 2 cases, if the element did not have break on empty, then we
                // do not want any of them to induce a descent. If it did have a break
                // on empty then we have already computed the heights, so there is no
                // need to do so again.
                //
                por->_fNoTextMetrics = TRUE;
            }
        }

        if (pCF->IsRelative(por->_fInnerCF))
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_RELATIVE);
        }

        // Set the flag on the line if the current pcf has a background
        // image or color
        if(pCF->HasBgImage(por->_fInnerCF) || pCF->HasBgColor(por->_fInnerCF))
        {
            //
            // NOTE(SujalP): If _cpStart has a background, and nothing else ends up
            // on the line, then too we want to draw the background. But since the
            // line is empty cpMost == _cpStart and hence GetLineFlags will not
            // find this flag. To make sure that it does, we subtract 1 from the cp.
            // (Bug  43714).
            //
            (cp == _cpStart)
                    ? _lineFlags.AddLineFlagForce(cp - 1, FLAG_HAS_BACKGROUND)
                    : _lineFlags.AddLineFlag(cp, FLAG_HAS_BACKGROUND);
            _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST);
        }

        if (pCF->_fBidiEmbed && _pBidiLine == NULL && !IsFrozen())
        {
            _pBidiLine = new CBidiLine(_treeInfo, _cpStart, _li._fRTLLn, _pli);
            Assert(GetDirLevel(por->_lscpBase) == 0);
        }

        // Some cases here which we need to let thru for the orther glean code
        // to look at........

        goto Done;
    }

    //
    // Figure out CHP, the layout info.
    //
    pCF = IsAdornment() ? _pNodeLi->GetCharFormat() : por->GetCF();
    Assert(pCF);

    // If we've transitioned directions, begin or end a reverse object.
    if (_pBidiLine != NULL &&
        (nDirLevel = _pBidiLine->GetLevel(cp)) !=
        (nSynthDirLevel = GetDirLevel(por->_lscpBase)))
    {
        if (!IsFrozen())
        {
            // Determine the type of synthetic character to add.
            if (nDirLevel > nSynthDirLevel)
            {
                synthCur = SYNTHTYPE_REVERSE;
            }
            else
            {
                synthCur = SYNTHTYPE_ENDREVERSE;
            }

            // Add the new synthetic character.
            lserr = AppendILSControlChar(por, synthCur, &porOut);
            Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
            goto Cleanup;
        }
    }
    else
    {
        if(!IsFrozen() && CheckForSpecialObjectBoundaries(por, &porOut))
            goto Cleanup;
    }

    CHPFromCF( por, pCF );

    por->_brkopt = (pCF->_fLineBreakStrict ? fBrkStrict : 0) |
                   (pCF->_fNarrow ? 0 : fCscWide);

    // Set the flag on the line if the current pcf has a background
    // image or color
    if(pCF->HasBgImage(por->_fInnerCF) || pCF->HasBgColor(por->_fInnerCF))
    {
        _lineFlags.AddLineFlag(cp, FLAG_HAS_BACKGROUND);
    }

    if (!por->_fCharsForNestedLayout)
    {
        const TCHAR chFirst = por->_pchBase[0];

        //
        // Check for bidi line
        //
        // NOTE: (grzegorz): The correct thing to do is to check if the parent has 
        // _fBidiEmbed or _fRTL flag set to true in case of layouts. Because there 
        // is no point to creating a bidi line if only layout is RTL.
        // But, since this check is expensive at this point we don't care and we 
        // create a bidi line. This will ensure correct behavior, but can be slight
        // slower, but anyway how many real word pages have ...<img dir=rtl>...
        //
        // NOTE: We have similar case for _fCharsForNestedLayout, but we have different
        // conditions and we need to eliminate any perf regressions, so we have this code
        // in 2 different places.
        //
        if (   _pBidiLine == NULL 
            && (   IsRTLChar(chFirst)
                || pCF->_fBidiEmbed 
                || pCF->_fRTL
               )
           )
        {
            if (!IsFrozen())
            {
                _pBidiLine = new CBidiLine(_treeInfo, _cpStart, _li._fRTLLn, _pli);
                Assert(GetDirLevel(por->_lscpBase) == 0);

                if (_pBidiLine != NULL && _pBidiLine->GetLevel(cp) > 0)
                {
                    synthCur = SYNTHTYPE_REVERSE;
                    // Add the new synthetic character.
                    lserr = AppendILSControlChar(por, synthCur, &porOut);
                    Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
                    goto Cleanup;
                }
            }
        }

        //
        // Currently the only nested elements we have other than layouts are hidden
        // elements. These are taken care of before we get here, so we should
        // never be here with this flag on.
        //

        // Note the relative stuff
        if (pCF->IsRelative(por->_fInnerCF))
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_RELATIVE);
        }

        // Don't blast:
        // a) disabled lines.
        // b) lines having hidden stuff
        if (   pCF->_fDisabled
            || pCF->IsVisibilityHidden()
           )
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST);
        }

        // NB (cthrash) If an NBSP character is at the beginning of a
        // text run, LS will convert that to a space before calling
        // GetRunCharWidths.  This implies that we will fail to recognize
        // the presence of NBSP chars if we only check at GRCW. So an
        // additional check is required here.  Similarly, if our 
        if ( chFirst == WCH_NBSP )
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_NBSP);
        }
        
        lserr = ChunkifyTextRun(por, &porOut);
        if (lserr != lserrNone)
            goto Cleanup;

        if (porOut != por)
            goto Cleanup;
    }
    else
    {
        //
        // Check for bidi line
        //
        // NOTE: (grzegorz): The correct thing to do is to check if the parent has 
        // _fBidiEmbed or _fRTL flag set to true in case of layouts. Because there 
        // is no point to creating a bidi line if only layout is RTL.
        // But, since this check is expensive at this point we don't care and we 
        // create a bidi line. This will ensure correct behavior, but can be slight
        // slower, but anyway how many real word pages have ...<img dir=rtl>...
        //
        // NOTE: We have similar case for !_fCharsForNestedLayout, but we have different
        // conditions and we need to eliminate any perf regressions, so we have this code
        // in 2 different places.
        //
        if (   _pBidiLine == NULL 
            && (   pCF->_fBidiEmbed 
                || pCF->_fRTL
               )
           )
        {
            if (!IsFrozen())
            {
                _pBidiLine = new CBidiLine(_treeInfo, _cpStart, _li._fRTLLn, _pli);
                Assert(GetDirLevel(por->_lscpBase) == 0);

                if (_pBidiLine != NULL && _pBidiLine->GetLevel(cp) > 0)
                {
                    synthCur = SYNTHTYPE_REVERSE;
                    // Add the new synthetic character.
                    lserr = AppendILSControlChar(por, synthCur, &porOut);
                    Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
                    goto Cleanup;
                }
            }
        }

        //
        // It has to be some layout other than the layout we are measuring
        //
        Assert(   por->Branch()->GetUpdatedLayout( _pci->GetLayoutContext() ) );
        Assert(   por->Branch()->GetUpdatedLayout( _pci->GetLayoutContext() ) != _pFlowLayout);

#if DBG == 1
        CElement *pElementLayout = por->Branch()->GetUpdatedLayout( _pci->GetLayoutContext() )->ElementOwner();
        long cpElemStart = pElementLayout->GetFirstCp();

        // Count the characters in this site, so LS can skip over them on this line.
        Assert(por->_lscch == GetNestedElementCch(pElementLayout));
#endif

        _fHasSites = _fMinMaxPass;
        
        // We check if this site belongs on its own line.
        // If so, we terminate this line with an EOS marker.
        if (IsOwnLineSite(por))
        {
            // This guy belongs on his own line.  But we only have to terminate the
            // current line if he's not the first thing on this line.
            if (cp != _cpStart
#if 0
                // See bugs 100429 and 80980 for more details of the 2 lines of code here
                || (   _pMeasurer->_cchPreChars != 0
                    && IsDummyLine(cp)
                   )
#endif
               )
            {
                Assert(!por->_fHidden);

                // We're not first on line.  Terminate this line!
                lserr = TerminateLine(por, TL_ADDEOS, &porOut);
                Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
                goto Cleanup;
            }
            // else we are first on line, so even though this guy needs to be
            // on his own line, keep going, because he is!

            // Note the relative stuff
            CTreeNode *pParentNode = por->Branch()->Parent();
            const CCharFormat *pParentCF = pParentNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));

            if (pParentCF->IsRelative(SameScope(pParentNode, _pFlowLayout->ElementContent())))
            {
                _lineFlags.AddLineFlag(cp, FLAG_HAS_RELATIVE);
            }

        }

        // If we kept looking after a single line site in _fScanForCR and we
        // came here, it means that we have another site after the single site and
        // hence should terminate the line
        else if (   _fScanForCR
                 && _fSingleSite
                )
        {
            lserr = TerminateLine(por, TL_ADDEOS, &porOut);
            goto Cleanup;
        }

        // Whatever this is, it is under a different site, so we have
        // to give LS an embedded object notice, and later recurse back
        // to format this other site.  For tables and spans and such, we have
        // to count and skip over the characters in this site.
        por->_lsCharProps.idObj = LSOBJID_EMBEDDED;

        Assert(cp == cpElemStart - 1);

        // ppwchRun shouldn't matter for a LSOBJID_EMBEDDED, but chunkify
        // objectrun might modify for putting in the symbols for aligned and
        // abspos'd sites
        WHEN_DBG(fWasTextRun = FALSE;)
        ChunkifyObjectRun(por, &porOut);

        por = porOut;
        goto Cleanup;
    }

    Assert(fWasTextRun);
    
    if (!por->_fHidden)
    {
        por->CheckForUnderLine(_fIsEditable);
        SetRenderingHighlights(por);
        
        if (_chPassword)
        {
            lserr = CheckForPassword(por);
            if (lserr != lserrNone)
                goto Cleanup;
        }
        else if (por->GetCF()->IsTextTransformNeeded())
        {
            lserr = TransformTextRun(por);
            if (lserr != lserrNone)
                goto Cleanup;
        }
    }

Cleanup:
    // Some characters we don't want contributing to the line height.
    // Non-textual runs shouldn't, don't bother for hidden runs either.
    //
    // ALSO, we want text metrics if we had a BR or block element
    // which was not break on empty
    porOut->_fNoTextMetrics |=   porOut->_fHidden
                              || porOut->_lsCharProps.idObj != LSOBJID_TEXT;

Done:
    if (   _pMeasurer->_fPseudoLetterEnabled
        && !porOut->IsSyntheticRun()
        && _pMarkup->HasCFState() // May be null in OOM
       )
    {
        BOOL fH, fV;
        CRect rcDimensions;
        CComputeFormatState * pcfState = _pMarkup->GetCFState();

        pNodeRun = pcfState->GetBlockNodeLetter();
        AssertSz(porOut == por, "Por's can only change if you add synthetics");
        if (   !_pflw._fStartedPseudoMBP
            && porOut->IsNormalRun()
            && porOut->_lsCharProps.idObj == LSOBJID_TEXT
            && pNodeRun->GetInlineMBPForPseudo(_pci, GIMBPC_ALL, &rcDimensions, &fH, &fV)
           )
        {
            _pflw._fStartedPseudoMBP = TRUE;
            lserr = AppendSynth(por, SYNTHTYPE_MBPOPEN, &porOut);
            if (lserr == lserrNone)
            {
                porOut->_mbpTop = _mbpTopCurrent;
                porOut->_mbpBottom = _mbpBottomCurrent;
                porOut->_xWidth = rcDimensions.left;
                _mbpTopCurrent += rcDimensions.top;
                _mbpBottomCurrent += rcDimensions.bottom;
                por->_mbpTop = _mbpTopCurrent;
                por->_mbpBottom = _mbpBottomCurrent;
                porOut->_fIsPseudoMBP = TRUE;
            }

            const CFancyFormat *pFF = pNodeRun->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
            if (   HasBorders(pFF, pNodeRun->GetCharFormat(), TRUE)
                || pFF->HasBackgrounds(TRUE))
            {
                _lineFlags.AddLineFlag(cp, FLAG_HAS_INLINE_BG_OR_BORDER);
            }

            goto Done;
        }
        
        Assert(porOut->_lscch);
        Assert(porOut->Cp() < _pMeasurer->_cpStopFirstLetter);
        Assert(_pMeasurer->_cpStopFirstLetter >= 0);
        
        LONG cpLast = porOut->Cp() + porOut->_lscch;
        if (_pMeasurer->_cpStopFirstLetter <= cpLast)
        {
            porOut->_lscch = _pMeasurer->_cpStopFirstLetter - porOut->Cp();
            Assert(porOut->_lscch > 0);
            
            _lineFlags.AddLineFlag(porOut->Cp(), FLAG_HAS_NOBLAST);
            _pflw._fDoPostFirstLetterWork = TRUE;
            _pflw._fChoppedFirstLetter = TRUE;
            if (porOut->_pFF->_fHasAlignedFL)
            {
                _pflw._fTerminateLine = TRUE;
                _li._fForceNewLine = FALSE;
                _li._fHasFloatedFL = TRUE;
            }
        }
    }
    
    *pporOut = porOut;
    return lserr;
}


BOOL
IsPreLikeTag(ELEMENT_TAG eTag)
{
    return eTag == ETAG_PRE || eTag == ETAG_XMP || eTag == ETAG_PLAINTEXT || eTag == ETAG_LISTING;
}


BOOL
IsPreLikeNode(CTreeNode * pNode)
{
    return IsPreLikeTag(pNode->Tag()) || pNode->GetParaFormat()->_fPreInner;
}

//-----------------------------------------------------------------------------
//
//  Function:   CheckForSpecialObjectBoundaries
//
//  Synopsis:   This function checks to see whether special objects should
//              be opened or closed based on the CF properties
//
//  Returns:    The one run to submit to line services via the pporOut
//              parameter.  Will only change this if necessary, and will
//              return TRUE if that parameter changed.
//
//-----------------------------------------------------------------------------

BOOL  WINAPI
CLineServices::CheckForSpecialObjectBoundaries(
    COneRun *por,
    COneRun **pporOut)
{
    BOOL fRet = FALSE;
    LSERR lserr;
    const CCharFormat *pCF = por->GetCF();
    Assert(pCF);

    if(pCF->_fIsRuby && !_fIsRuby)
    {
        Assert(!_fIsRubyText);

        // Open up a new ruby here (we only enter here in the open ruby case,
        // the ruby object is closed when we see an /RT)
        _fIsRuby = TRUE;
#ifdef RUBY_OVERHANG
        // We set this flag here so that LS will try to do modify the width of
        // run, which will trigger a call to FetchRubyWidthAdjust
        por->_lsCharProps.fModWidthOnRun = TRUE;
#endif
        _yMaxHeightForRubyBase = 0;
        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_RUBY);
        lserr = AppendILSControlChar(por, SYNTHTYPE_RUBYMAIN, pporOut);
        Assert(lserr != lserrNone || IsFrozen() || (*pporOut)->_synthType != SYNTHTYPE_NONE);
        fRet = TRUE;
    }
    else if(pCF->_fIsRubyText != _fIsRubyText)
    {
        Assert(_fIsRuby);

        // if _fIsRubyText is true, that means we have now arrived at text that
        // is no longer Ruby Text.  So, we should close the Ruby object by passing
        // ENDRUBYTEXT to Line Services
        if(_fIsRubyText)
        {
           _fIsRubyText = FALSE;
           _fIsRuby = FALSE;
           lserr = AppendILSControlChar(por, SYNTHTYPE_ENDRUBYTEXT, pporOut);
        }
        // if _fIsRubyText is false, that means that we are now entering text that
        // is Ruby text.  So, we must tell Line Services that we are no longer
        // giving it main text.
        else
        {
            _fIsRubyText = TRUE;
            lserr = AppendILSControlChar(por, SYNTHTYPE_ENDRUBYMAIN, pporOut);
        }
        Assert(lserr != lserrNone || IsFrozen() || (*pporOut)->_synthType != SYNTHTYPE_NONE);
        fRet = TRUE;
    }
    else if (_uLayoutGridModeInner != pCF->_uLayoutGridModeInner)
    {
        LONG cLayoutGridObj = 0;
        if (!pCF->HasCharGrid(TRUE))
        {
            // Character grid layout was turned off. Check if we are entering 
            // nested element.

            // Count nested elements with turned off character grid layout
            // within block element scope.
            CTreeNode * pNodeCurrent = por->_ptp->GetBranch();
            Assert(pNodeCurrent->_iFF != -1);
            while (!pNodeCurrent->_fBlockNess)
            {
                if (    !pNodeCurrent->GetCharFormat()->HasCharGrid(TRUE)
                    &&  pNodeCurrent->Parent()->GetCharFormat()->HasCharGrid(TRUE))
                {
                    ++cLayoutGridObj;
                }
                pNodeCurrent = pNodeCurrent->Parent();
                Assert(pNodeCurrent->_iFF != -1);
            }
            Assert(cLayoutGridObj >= _cLayoutGridObj);

            if (cLayoutGridObj != _cLayoutGridObj)
            {
                // Entering nested element.

                COneRun * porTemp = NULL;
                *pporOut = NULL;
                if (_cLayoutGridObjArtificial > 0)
                {
                    // Need to tell LS that we are closing artificially opened
                    // layout grid object.
                    --_cLayoutGridObjArtificial;
                    Assert(_cLayoutGridObjArtificial == 0);
                    lserr = AppendILSControlChar(por, SYNTHTYPE_ENDLAYOUTGRID, pporOut);
                    Assert(lserr != lserrNone || IsFrozen() || (*pporOut)->_synthType != SYNTHTYPE_NONE);
                }

                // Need to tell LS that we entering nested element with
                // turned off character grid layout.
                ++_cLayoutGridObj;
                lserr = AppendILSControlChar(por, SYNTHTYPE_LAYOUTGRID, (*pporOut) ? &porTemp : pporOut);
                Assert(lserr != lserrNone || IsFrozen() || (porTemp ? porTemp : *pporOut)->_synthType != SYNTHTYPE_NONE);
                fRet = TRUE;
                _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
            }
        }
        else if (   _cLayoutGridObj > 0
                &&  !(_uLayoutGridModeInner & styleLayoutGridModeChar)
                &&  pCF->HasCharGrid(TRUE))
        {
            // Character grid layout was turned on. Check if we are exiting 
            // nested element.

            // Count nested elements with turned on character grid layout
            // within block element scope.
            CTreeNode * pNodeCurrent = por->_ptp->GetBranch();
            Assert(pNodeCurrent->_iFF != -1);
            while (!pNodeCurrent->_fBlockNess)
            {
                if (    pNodeCurrent->GetCharFormat()->HasCharGrid(TRUE)
                    &&  !pNodeCurrent->Parent()->GetCharFormat()->HasCharGrid(TRUE))
                {
                    ++cLayoutGridObj;
                }
                pNodeCurrent = pNodeCurrent->Parent();
                Assert(pNodeCurrent->_iFF != -1);
            }
            if (pNodeCurrent->GetCharFormat()->HasCharGrid(TRUE))
            {
                ++cLayoutGridObj;
            }

            if (cLayoutGridObj == _cLayoutGridObj)
            {
                // Exiting nested element.

                COneRun * porTemp = NULL;
                *pporOut = NULL;
                if (_cLayoutGridObjArtificial > 0)
                {
                    // Need to tell LS that we are closing artificially opened
                    // layout grid object.
                    --_cLayoutGridObjArtificial;
                    Assert(_cLayoutGridObjArtificial == 0);
                    lserr = AppendILSControlChar(por, SYNTHTYPE_ENDLAYOUTGRID, pporOut);
                    Assert(lserr != lserrNone || IsFrozen() || (*pporOut)->_synthType != SYNTHTYPE_NONE);
                }

                // Need to tell LS that we exiting nested element with
                // turned off character grid layout.
                --_cLayoutGridObj;
                lserr = AppendILSControlChar(por, SYNTHTYPE_ENDLAYOUTGRID, (*pporOut) ? &porTemp : pporOut);
                Assert(lserr != lserrNone || IsFrozen() || (porTemp ? porTemp : *pporOut)->_synthType != SYNTHTYPE_NONE);
                fRet = TRUE;
                _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
            }
        }
        // Update special object's flags
        _uLayoutGridModeInner = pCF->_uLayoutGridModeInner;
    }
    
    //
    // So far we didn't add a synthetic run. Check if we need to add NOBR.
    //
    if (!fRet)
    {
        BOOL fNoBreak = pCF->HasNoBreak(por->_fInnerCF);
        if (fNoBreak != !!_fNoBreakForMeasurer)
        {
            Assert(!IsFrozen());

            //
            // phrase elements inside PRE's which have layout will not have the HasPre bit turned
            // on and hence we will still start a NOBR object for them. The problem then is that
            // we need to terminate the line for '\r'. To do this we will have to scan the text.
            // To minimize the scanning we find out if we are really in such a situation.
            //
#if DBG==1
            {
                CTreeNode *pNodeOne = por->Branch();
                CTreeNode *pNodeTwo = _pMarkup->SearchBranchForPreLikeNode(por->Branch());
                BOOL fp1Overlapped = pNodeOne && pNodeOne->Element()->IsOverlapped();
                BOOL fp2Overlapped = pNodeTwo && pNodeTwo->Element()->IsOverlapped();
                Assert(   fp1Overlapped 
                       || fp2Overlapped
                       || (!!por->GetPF()->_fHasPreLikeParent == !!pNodeTwo));
            }
#endif
            
            if (por->GetPF()->_fHasPreLikeParent)
            {
                _fScanForCR = TRUE;
                goto Cleanup;
            }

            if (!(por->_fCharsForNestedLayout && IsOwnLineSite(por)))
            {
                // Begin or end NOBR block.
                lserr = AppendILSControlChar(por,
                                             (fNoBreak ? SYNTHTYPE_NOBR : SYNTHTYPE_ENDNOBR),
                                             pporOut);
                Assert(lserr != lserrNone || IsFrozen() || (*pporOut)->_synthType != SYNTHTYPE_NONE);
                fRet = TRUE;
            }
        }
    }

    // Update special object's flags
    _uLayoutGridMode = pCF->_uLayoutGridMode;

Cleanup:

    return fRet;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetAutoNumberInfo (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetAutoNumberInfo(
    LSKALIGN* plskalAnm,    // OUT
    PLSCHP plsChpAnm,       // OUT
    PLSRUN* pplsrunAnm,     // OUT                                  
    WCHAR* pwchAdd,         // OUT
    PLSCHP plsChpWch,       // OUT                                 
    PLSRUN* pplsrunWch,     // OUT                                  
    BOOL* pfWord95Model,    // OUT
    long* pduaSpaceAnm,     // OUT
    long* pduaWidthAnm)     // OUT
{
    LSTRACE(GetAutoNumberInfo);
    LSNOTIMPL(GetAutoNumberInfo);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetNumericSeparators (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetNumericSeparators(
    PLSRUN plsrun,          // IN
    WCHAR* pwchDecimal,     // OUT
    WCHAR* pwchThousands)   // OUT
{
    LSTRACE(GetNumericSeparators);

    // NOTE: (cthrash) Should set based on locale.
    // NOTE: (dmitryt) Maybe (a matter of spec) on a LANG attribute also (one paragraph may be in 
    //                  Russian (decimal=','), other in English (decimal=".")

    *pwchDecimal = L'.';
    *pwchThousands = L',';

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CheckForDigit (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::CheckForDigit(
    PLSRUN plsrun,      // IN
    WCHAR wch,          // IN
    BOOL* pfIsDigit)    // OUT
{
    LSTRACE(CheckForDigit);

    // NOTE: (mikejoch) IsCharDigit() doesn't check for international numbers.

    *pfIsDigit = IsCharDigit(wch);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FetchPap (member, LS callback)
//
//  Synopsis:   Callback to fetch paragraph properties for the current line.
//
//  Returns:    lserrNone
//              lserrOutOutMemory
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FetchPap(
    LSCP   lscp,        // IN
    PLSPAP pap)         // OUT
{
    LSTRACE(FetchPap);
    LSERR      lserr = lserrNone;
    const      CParaFormat *pPF;
    CTreePos  *ptp;
    CTreeNode *pNode;
    LONG       cp;
    BOOL       fInnerPF;
    CComplexRun *pcr = NULL;
    CComplexRun crTemp;
    CElement  *pElementFL = _pFlowLayout->ElementContent();

    Assert(lscp <= _treeInfo._lscpFrontier);

    if (lscp < _treeInfo._lscpFrontier)
    {
        COneRun *por = FindOneRun(lscp);
        Assert(por);
        if(!por)
            goto Cleanup;
        ptp = por->_ptp;
        pPF = por->_pPF;
        fInnerPF = por->_fInnerPF;
        cp = por->Cp();
        pcr = por->GetComplexRun();
    }
    else
    {
        //
        // The problem is that we are at the end of the list
        // and hence we cannot find the interesting one-run. In this
        // case we have to use the frontier information. However,
        // the frontier information maybe exhausted, so we need to
        // refresh it by calling AdvanceTreePos() here.
        //
        if (!_treeInfo.GetCchRemainingInTreePos() && !_treeInfo._fHasNestedElement)
        {
            if (!_treeInfo.AdvanceTreePos(LC_TO_FC(_pci->GetLayoutContext())))
            {
                lserr = lserrOutOfMemory;
                goto Cleanup;
            }
        }
        ptp = _treeInfo._ptpFrontier;
        pPF = _treeInfo._pPF; // should we use CLineServices::_pPFFirst here???
        fInnerPF = _treeInfo._fInnerPF;
        cp  = _treeInfo._cpFrontier;

        // if might be on a reverse object to begin with. see if we are a
        // complex script
        if (ptp->IsText() && ptp->IsDataPos())
        {
            // if we are a complex script, we just put an unitialized CComplexRun
            // into pcr. We will only be checking for pcr != NULL
            if (IsComplexScriptSid(ptp->Sid()))
                pcr = &crTemp;
        }

    }

    Assert(ptp);
    Assert(pPF);

    //
    // Set up paragraph properties
    //
    PAPFromPF (pap, pPF, fInnerPF, pcr);

    pap->cpFirst = cp;

    // TODO (dmitryt, track bug 112281): SLOWBRANCH: GetBranch is **way** too slow to be used here.
    pNode = ptp->GetBranch();
    if (pNode->Element() == pElementFL)
        pap->cpFirstContent = _treeInfo._cpLayoutFirst;
    else
    {
        CTreeNode *pNodeBlock = _treeInfo._pMarkup->SearchBranchForBlockElement(pNode, _pFlowLayout);
        if (pNodeBlock)
        {
            CElement *pElementPara = pNodeBlock->Element();
            pap->cpFirstContent = (pElementPara == pElementFL) ?
                                  _treeInfo._cpLayoutFirst :
                                  pElementPara->GetFirstCp();
        }
        else
            pap->cpFirstContent = _treeInfo._cpLayoutFirst;
    }

Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FetchTabs (member, LS callback)
//
//  Synopsis:   Callback to return tab positions for the current line.
//
//              LineServices calls the callback when it encounters a tab in
//              the line, but does not pass the plsrun.  The cp is supposed to
//              be used to locate the paragraph.
//
//              Instead of allocating a buffer for the return value, we return
//              a table that resides on the CLineServices object.  The tab
//              values are in twips.
//
//  Returns:
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FetchTabs(
    LSCP lscp,                      // IN
    PLSTABS plstabs,                // OUT
    BOOL* pfHangingTab,             // OUT
    long* pduaHangingTab,           // OUT
    WCHAR* pwchHangingTabLeader )   // OUT
{
    LSTRACE(FetchTabs);

    LONG cTab = _pPFFirst->GetTabCount(_fInnerPFFirst);

    // This tab might end up on the current line, so we can't blast.

    _fSpecialNoBlast = TRUE;

    // Note: lDefaultTab is a constant defined in textedit.h

    plstabs->duaIncrementalTab = lDefaultTab;

    // NOTE (dmitryt) hanging tabs are not implemented for now..

    *pfHangingTab = FALSE;
    *pduaHangingTab = 0;
    *pwchHangingTabLeader = 0;

    AssertSz(cTab >= 0 && cTab <= MAX_TAB_STOPS, "illegal tab count");

    if (!_pPFFirst->HasTabStops(_fInnerPFFirst) && cTab < 2)
    {
        if (cTab == 1)
        {
            plstabs->duaIncrementalTab = _pPFFirst->GetTabPos(_pPFFirst->_rgxTabs[0]);
        }

        plstabs->iTabUserDefMac = 0;
        plstabs->pTab = NULL;
    }
    else
    {
        LSTBD * plstbd = _alstbd + cTab - 1;

        while (cTab)
        {
            long uaPos = 0;
            long lAlign = 0;
            long lLeader = 0;

            if (S_OK != _pPFFirst->GetTab( --cTab, &uaPos, &lAlign, &lLeader ) )
            {
                return lserrOutOfMemory;
            }

            Assert( lAlign >= 0 && lAlign < tomAlignBar &&
                    lLeader >= 0 && lLeader < tomLines );

            // NB (cthrash) To ensure that the LSKTAB cast is safe, we
            // verify that that define's haven't changed values in
            // CLineServices::InitTimeSanityCheck().

            plstbd->lskt = LSKTAB(lAlign);
            plstbd->ua = uaPos;
            plstbd->wchTabLeader = s_achTabLeader[lLeader];
            plstbd--;

        }

        plstabs->iTabUserDefMac = cTab;
        plstabs->pTab = _alstbd;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetBreakThroughTab (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetBreakThroughTab(
    long uaRightMargin,         // IN
    long uaTabPos,              // IN
    long* puaRightMarginNew)    // OUT
{
    LSTRACE(GetBreakThroughTab);
    LSNOTIMPL(GetBreakThroughTab);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CheckParaBoundaries (member, LS callback)
//
//  Synopsis:   Callback to determine whether two cp's reside in different
//              paragraphs (block elements in HTML terms).
//
//  Returns:    lserrNone
//              *pfChanged - TRUE if cp's are in different block elements.
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::CheckParaBoundaries(
    LSCP lscpOld,       // IN
    LSCP lscpNew,       // IN
    BOOL* pfChanged)    // OUT
{
    LSTRACE(CheckParaBoundaries);
    *pfChanged = FALSE;
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetRunCharWidths (member, LS callback)
//
//  Synopsis:   Callback to return character widths of text in the current run,
//              represented by plsrun.
//
//  Returns:    lserrNone
//              rgDu - array of character widths
//              pduDu - sum of widths in rgDu, upto *plimDu characters
//              plimDu - character count in rgDu
//
//-----------------------------------------------------------------------------

#if DBG != 1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif // DBG != 1

LSERR WINAPI
CLineServices::GetRunCharWidths(
    PLSRUN plsrun,              // IN
    LSDEVICE lsDeviceID,        // IN
    LPCWSTR pwchRun,            // IN
    DWORD cwchRun,              // IN
    long du,                    // IN
    LSTFLOW kTFlow,             // IN
    int* rgDu,                  // OUT
    long* pduDu,                // OUT
    long* plimDu)               // OUT
{
    LSTRACE(GetRunCharWidths);

    LSERR lserr = lserrNone;
    pwchRun = plsrun->_fMakeItASpace ? _T(" ") : pwchRun;
    const WCHAR * pch = pwchRun;
    int * pdu = rgDu;
    int * pduEnd = rgDu + cwchRun;
    long duCumulative = 0;
    LONG cpCurr = plsrun->Cp();
    const CCharFormat *pCF = plsrun->GetCF();
    CCcs ccs, ccsAlt;
    XHDC hdc;
    const CBaseCcs *pBaseCcs;
    WHEN_DBG(LONG xLetterSpacingRemovedDbg = 0);

    Assert(cwchRun);

    WHEN_DBG(pBaseCcs = NULL;)
    if (!GetCcs(&ccs, plsrun, _pci->_hdc, _pci))
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }
    hdc = ccs.GetHDC();
    pBaseCcs = ccs.GetBaseCcs();
    
    if (   pBaseCcs->_fHasInterestingData 
        && !pBaseCcs->_fTTFont
        && _pci->_hdc.HasComplexTransform())
    {
        ccsAlt.SetForceTTFont(TRUE);
        if (!GetCcs(&ccsAlt, plsrun, _pci->_hdc, _pci))
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }
        pBaseCcs = ccsAlt.GetBaseCcs();
    }

    //
    // CSS
    //
    Assert(IsAdornment() || !plsrun->_fCharsForNestedElement);

    //
    // Add up the widths
    //
    while (pdu < pduEnd)
    {
        MeasureCharacter(*pch++, cpCurr, rgDu, hdc, pBaseCcs, pdu);
        duCumulative += *pdu++;
        if (duCumulative > du)
            break;
    }
    
    if (plsrun->IsSpecialCharRun())
    {
        *rgDu = plsrun->_xWidth;
        *pduDu = plsrun->_xWidth;
        *plimDu = pdu - rgDu;
    }
    else if (   pCF->_wSpecialObjectFlags() != 0
             && (   HasSomeSpacing(pCF)
                 || pCF->HasCharGrid(plsrun->_fInnerCF)
                )
            )
    {
        lserr = AdjustGlyphWidths( &ccs, GetLetterSpacing(pCF), GetWordSpacing(pCF),
                                   plsrun, pwchRun, cwchRun, 
                                   du, rgDu, pduDu, plimDu, NULL 
#if DBG==1
                                   , &xLetterSpacingRemovedDbg
#endif
                                  );
    }
    else
    {
        *pduDu = duCumulative;
        *plimDu = pdu - rgDu;
        if (   plsrun->_xWidth == 0 
            || plsrun->_pchBase == pwchRun
           )
        {
            plsrun->_xWidth = duCumulative;
            if (   DWORD(plsrun->_lscch) != cwchRun
                && *plsrun->_pchBase == WCH_HYPHEN
               )
            {
                _fSpecialNoBlast = TRUE;
            }
        }
        else
        {
            _fSpecialNoBlast = TRUE;
        }
    }
    
#if DBG == 1
    if (lserr == lserrNone && !GetWordSpacing(pCF))
    {
        // If we are laying out a character grid, skip all the debug verification
        if (pCF->HasCharGrid(plsrun->_fInnerCF))
            goto Cleanup;

        if (    plsrun->IsSyntheticRun()
            && *plsrun->_pchBase == WCH_NODE
           )
            goto Cleanup;
        
        //
        // In debug mode, confirm that all the fast tweaks give the same
        // answer as the really old slow way.
        //

        int* rgDuDbg= new int[ cwchRun ];  // no meters in debug mode.
        long limDuDbg;  // i.e. *plimDu
        DWORD cchDbg = cwchRun;
        const WCHAR * pchDbg = pwchRun;
        int * pduDbg = rgDuDbg;
        long duCumulativeDbg = 0;
        LONG cpCurrDbg = plsrun->Cp();
        int xLetterSpacing = GetLetterSpacing(pCF);

        //index of a last character that has width>0 and is not Combining (dmitryt)
        int cchLastBaseGlyph = -1;   

        Assert(pBaseCcs);
        if (rgDuDbg != NULL)
        {
            while (cchDbg--)
            {
                long duCharDbg = 0;
                TCHAR chDbg = *pchDbg++;

                ((CBaseCcs *)pBaseCcs)->Include(hdc, chDbg, duCharDbg);

                if (duCharDbg)
                {
                    duCharDbg += xLetterSpacing;
                    if(!IsCombiningMark(chDbg))
                        cchLastBaseGlyph = cwchRun - cchDbg - 1;
                }    
                *pduDbg++ = duCharDbg;
                duCumulativeDbg += duCharDbg;

                if (duCumulativeDbg > du)
                  break;

                cpCurrDbg++;
            }

            //dmitryt: we need to adjust the last base (combining diacritic and width>0) 
            //glyph because it doesn't have letter spacing added (last 'real' character
            //in a line - nothing to space from)
            if (cchLastBaseGlyph != -1)
            {
                rgDuDbg[cchLastBaseGlyph] -= xLetterSpacingRemovedDbg;
                duCumulativeDbg -= xLetterSpacingRemovedDbg;
            }

            // *pduDuDbg = duCumulativeDbg;
            limDuDbg = pchDbg - pwchRun;

#ifndef ND_ASSERT // May 17, 1999.  Repro: Switch to Draftview in Netdocs (AlexPf)
            // Calculation done.  Check results.
            Assert( duCumulativeDbg == *pduDu );  // total distance measured.
            Assert( limDuDbg == *plimDu );        // characters measured.
            for(int i=0; i< limDuDbg; i++)
            {
                Assert( rgDu[i] == rgDuDbg[i] );
            }
#endif // ND_ASSERT
          delete rgDuDbg;
        }
    }
#endif  // DBG == 1

Cleanup:
#if DBG==1
    if (pBaseCcs)
    {
        CDisplay *pdp = (CDisplay*)_pMeasurer->_pdp;
        if (pdp->_fBuildFontList)
        {
            pdp->_cstrFonts.Append(fc().GetFaceNameFromAtom(pBaseCcs->_latmLFFaceName));
            pdp->_cstrFonts.Append(_T(";"));
        }
    }
#endif
    return lserr;
}

#if DBG != 1
#pragma optimize("",on)
#endif // DBG != 1

LSERR
CLineServices::AdjustGlyphWidths(
    CCcs *pccs,
    LONG xLetterSpacing,
    LONG xWordSpacing,
    PLSRUN plsrun,
    LPCWSTR pwch,
    DWORD cwch,
    LONG du,            // not used during glyph positioning pass
    int *rgDu,
    long *pduDu,
    long *plimDu,
    PGOFFSET rgGoffset
#if DBG==1
    , LONG *pxLetterSpacingRemovedDbg
#endif
)
{
    LONG lserr = lserrNone;
    LONG duCumulative = 0;
    LONG cpCurr = plsrun->Cp();
    int *pdu = rgDu;
    int *pduLastNonZero = pdu;
    int *pduEnd = rgDu + cwch;
    const CCharFormat *pCF = plsrun->GetCF();
    const CBaseCcs *pBaseCcs = pccs->GetBaseCcs();
    XHDC hdc = pccs->GetHDC();
    BOOL fGlyphPositionPass = !!rgGoffset;
    BOOL fLooseGrid = TRUE;
    BOOL fIsSpace;

    // Add line flags only during non glyph positioning pass.
    // During glyph positioning those flags are already set.
    if (!fGlyphPositionPass)
    {
        _lineFlags.AddLineFlagForce(cpCurr, FLAG_HAS_NOBLAST);
#if DBG==1
        if (xLetterSpacing < 0 || xWordSpacing < 0)
            _fHasNegLetterSpacing = TRUE;
#endif
    }

    //
    // We must be careful to deal with negative letter spacing,
    // since that will cause us to have to actually get some character
    // widths since the line length will be extended.  If the
    // letterspacing is positive, then we know all the letters we're
    // gonna use have already been measured.
    //

    // Apply layout grid widths
    if (pCF->HasCharGrid(plsrun->_fInnerCF))
    {
        long lGridSize = GetCharGridSize();
        styleLayoutGridType lgt = plsrun->GetPF()->GetLayoutGridType(plsrun->_fInnerCF);
        fLooseGrid = !(lgt == styleLayoutGridTypeStrict || lgt == styleLayoutGridTypeFixed);
        BOOL fOneCharPerGridCell = fLooseGrid ? TRUE : plsrun->IsOneCharPerGridCell();
        
        for (pdu = rgDu; pdu < pduEnd;)
        {
            if (   (   xLetterSpacing < 0
                    || xWordSpacing < 0
                   )
                && !fGlyphPositionPass
               )
            {
                MeasureCharacter(pwch[pdu - rgDu], cpCurr, rgDu, hdc, pBaseCcs, pdu);
            }
            
            fIsSpace = isspace(pwch[pdu - rgDu]);
            if (fIsSpace && !fGlyphPositionPass)
            {
                *pdu += xWordSpacing;
            }
            
            if (*pdu)
            {
                pduLastNonZero = pdu;

                *pdu += xLetterSpacing;

                if (fLooseGrid)
                {
                    *pdu += LooseTypeWidthIncrement(pwch[pdu - rgDu], 
                                                    (plsrun->_brkopt == fCscWide), lGridSize);
                }
                else if (fOneCharPerGridCell)
                {
                    *pdu = GetClosestGridMultiple(lGridSize, *pdu);
                }
            }
            else if (fGlyphPositionPass && !fIsSpace)
            {
                if (fLooseGrid)
                {
                    rgGoffset[pdu - rgDu].du -= xLetterSpacing;
                    rgGoffset[pdu - rgDu].du -= LooseTypeWidthIncrement(
                                                    pwch[pduLastNonZero - rgDu], 
                                                    plsrun->_brkopt == fCscWide, lGridSize);
                }
            }

            duCumulative += *pdu++;
            if (duCumulative > du && !fGlyphPositionPass)
                break;
        }
    }
    else
    {
        for (pdu = rgDu; pdu < pduEnd;)
        {
            if (   (   xLetterSpacing < 0
                    || xWordSpacing < 0
                   )
                && !fGlyphPositionPass
               )
            {
                MeasureCharacter(pwch[pdu - rgDu], cpCurr, rgDu, hdc, pBaseCcs, pdu);
            }

            fIsSpace = isspace(pwch[pdu - rgDu]);
            if (fIsSpace && !fGlyphPositionPass)
            {
                *pdu += xWordSpacing;
            }
            
            if (*pdu)
            {
                pduLastNonZero = pdu;
                *pdu += xLetterSpacing;
            }

            // You might think that the !fIsSpace is useless since *pdu for
            // a space will always be non-zero -- NOT true, since xWordSpacing
            // could be negative and reduce *pdu down to zero.
            else if (fGlyphPositionPass && !fIsSpace)
            {
                rgGoffset[pdu - rgDu].du -= xLetterSpacing;
            }

            duCumulative += *pdu++;
            if (duCumulative > du && !fGlyphPositionPass)
                break;
        }
    }

    if (xLetterSpacing && pdu >= pduEnd && !_pNodeLi && fLooseGrid)
    {
        LPCWSTR  lpcwstrJunk;
        DWORD    dwJunk;
        BOOL     fJunk;
        LSCHP    lschpJunk;
        COneRun *por;
        int      xLetterSpacingNextRun = 0;

        lserr = FetchRun(plsrun->_lscpBase + plsrun->_lscch, &lpcwstrJunk, &dwJunk, &fJunk, &lschpJunk, &por);
        if (   lserr == lserrNone
            && por->_ptp != _treeInfo._ptpLayoutLast
           )
        {
            xLetterSpacingNextRun = GetLetterSpacing(por->GetCF());
        }
        
        if (xLetterSpacing != xLetterSpacingNextRun)
        {
            *pduLastNonZero -= xLetterSpacing;
            duCumulative -= xLetterSpacing;
            if (fGlyphPositionPass)
            {
                int *pduZero = pduLastNonZero + 1;
                while (pduZero < pduEnd)
                {
                    rgGoffset[pduZero - rgDu].du += xLetterSpacing;
                    pduZero++;
                }
            }
#if DBG==1
        if (pxLetterSpacingRemovedDbg)
            *pxLetterSpacingRemovedDbg = xLetterSpacing;
#endif
        }
    }

    if (pduDu)
        *pduDu = duCumulative;
    if (plimDu)
        *plimDu = pdu - rgDu;

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetLineOrCharGridSize()
//
//  Synopsis:   This function finds out what the height or width of a grid cell 
//              is in pixels, making conversions if necessary.  If this value has 
//              already been calculated, the calculated value is immediately returned
//
//  Returns:    long value of the width of a grid cell in pixels
//
//-----------------------------------------------------------------------------

long WINAPI
CLineServices::GetLineOrCharGridSize(BOOL fGetCharGridSize)
{
    const CUnitValue *pcuv = NULL;
    CUnitValue::DIRECTION dir;
    long * plGridSize = fGetCharGridSize 
        ? (_fInnerPFFirst ? &_lCharGridSizeInner : &_lCharGridSize) 
        : (_fInnerPFFirst ? &_lLineGridSizeInner : &_lLineGridSize);
    
    // If we already have a cached value, return that, or if we haven't set
    // set up the ccs yet return zero
    if(*plGridSize != 0 || !_pPFFirst)
        goto Cleanup;

#if defined(_M_ALPHA64)
    // NOTE: (grzegorz) Do not change second 'if' to 'else'
    // This causes internal compiler error on AXP64.
    if (fGetCharGridSize)
        pcuv = &(_pPFFirst->GetCharGridSize(_fInnerPFFirst));
    if (!fGetCharGridSize)
        pcuv = &(_pPFFirst->GetLineGridSize(_fInnerPFFirst));
#else
    pcuv = fGetCharGridSize ? &(_pPFFirst->GetCharGridSize(_fInnerPFFirst)) : &(_pPFFirst->GetLineGridSize(_fInnerPFFirst));
#endif

    // The uv should have some value, otherwise we shouldn't even be
    // here making calculations for a non-existent grid.
    switch(pcuv->GetUnitType())
    {
    case CUnitValue::UNIT_NULLVALUE:
        break;

    case CUnitValue::UNIT_ENUM:
        // need to handle "auto" here
        if(pcuv->GetUnitValue() == styleLayoutGridCharAuto && _ccsCache.GetBaseCcs()) 
            *plGridSize = fGetCharGridSize ? _ccsCache.GetBaseCcs()->_xMaxCharWidth :
                          _ccsCache.GetBaseCcs()->_yHeight;
        else
            *plGridSize = 0;
        break;

    case CUnitValue::UNIT_PERCENT:
        if (_fMinMaxPass)
            *plGridSize = 1;
        else
        {
            if (fGetCharGridSize)
                *plGridSize = _xWrappingWidth;
            else
            {
                *plGridSize = _pci->_sizeParent.cy;
                if (*plGridSize == 0 && _pFlowLayout->GetFirstBranch()->GetCharFormat()->HasVerticalLayoutFlow())
                    *plGridSize = _pci->_sizeParentForVert.cy;
            }
            *plGridSize = *plGridSize * pcuv->GetUnitValue() / 10000;
        }
        break;

    default:
        dir = fGetCharGridSize ? CUnitValue::DIRECTION_CX : CUnitValue::DIRECTION_CY;
        *plGridSize = pcuv->GetPixelValue(_pci, dir, 
            fGetCharGridSize ? _xWrappingWidth : _pci->_sizeParent.cy, _pPFFirst->_lFontHeightTwips);
        break;
    }

    if (pcuv->IsPercent() && _pFlowLayout && !fGetCharGridSize)
            _pFlowLayout->SetVertPercentAttrInfo(TRUE);

Cleanup:
    return *plGridSize;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetClosestGridMultiple
//
//  Synopsis:   This function just calculates the width of an object in lGridSize
//              multiples.  For example, if lGridSize is 12 and lObjSize is 16,
//              this function would return 24.  If lObjSize is 0, this function
//              will return 0.
//              
//  Returns:    long value of the width in pixels
//
//-----------------------------------------------------------------------------

long WINAPI
CLineServices::GetClosestGridMultiple(long lGridSize, long lObjSize)
{
    long lReturnWidth = lObjSize;
    long lRemainder;
    if (lObjSize == 0 || lGridSize == 0)
        goto Cleanup;

    lRemainder = lObjSize % lGridSize;
    lReturnWidth = lObjSize + lGridSize - (lRemainder ? lRemainder : lGridSize);

Cleanup:
    return lReturnWidth;
}

//-----------------------------------------------------------------------------
//
//  Function:   CheckRunKernability (member, LS callback)
//
//  Synopsis:   Callback to test whether current runs should be kerned.
//
//              We do not support kerning at this time.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::CheckRunKernability(
    PLSRUN plsrunLeft,  // IN
    PLSRUN plsrunRight, // IN
    BOOL* pfKernable)   // OUT
{
    LSTRACE(CheckRunKernability);

    *pfKernable = FALSE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetRunCharKerning (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetRunCharKerning(
    PLSRUN plsrun,              // IN
    LSDEVICE lsDeviceID,        // IN
    LPCWSTR pwchRun,            // IN
    DWORD cwchRun,              // IN
    LSTFLOW kTFlow,             // IN
    int* rgDu)                  // OUT
{
    LSTRACE(GetRunCharKerning);

    DWORD iwch = cwchRun;
    int *pDu = rgDu;

    while (iwch--)
    {
        *pDu++ = 0;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetRunTextMetrics (member, LS callback)
//
//  Synopsis:   Callback to return text metrics of the current run
//
//  Returns:    lserrNone
//              plsTxMet - LineServices textmetric structure (lstxm.h)
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetRunTextMetrics(
    PLSRUN   plsrun,            // IN
    LSDEVICE lsDeviceID,        // IN
    LSTFLOW  kTFlow,            // IN
    PLSTXM   plsTxMet)          // OUT
{
    LSTRACE(GetRunTextMetrics);
    const CCharFormat * pCF;
    CCcs ccs, ccsAlt;
    const CBaseCcs *pBaseCcs;
    LONG lLineHeight;
    LSERR lserr = lserrNone;
    
    Assert(plsrun);
    
    if (plsrun->_fNoTextMetrics)
    {
        ZeroMemory( plsTxMet, sizeof(LSTXM) );
        goto Cleanup;
    }

    pCF = plsrun->GetCF();
    if (!GetCcs(&ccs, plsrun, _pci->_hdc, _pci))
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }
    pBaseCcs = ccs.GetBaseCcs();

    if (pBaseCcs->_fHasInterestingData)
    {
        if (   !pBaseCcs->_fTTFont
            && _pci->_hdc.HasComplexTransform())
        {
            ccsAlt.SetForceTTFont(TRUE);
            if (!GetCcs(&ccsAlt, plsrun, _pci->_hdc, _pci))
            {
                lserr = lserrOutOfMemory;
                goto Cleanup;
            }
            pBaseCcs = ccsAlt.GetBaseCcs();
        }

        if (pBaseCcs->_xOverhangAdjust || pBaseCcs->_bConvertMode == CM_SYMBOL)
        {
            _lineFlags.AddLineFlag(plsrun->Cp(), FLAG_HAS_NOBLAST);
        }
        _fHasOverhang |= ((plsrun->_xOverhang = pBaseCcs->_xOverhang) != 0);
        plsTxMet->fMonospaced = pBaseCcs->_fFixPitchFont ? TRUE : FALSE;
    }
    else
    {
        plsTxMet->fMonospaced = FALSE;
        Assert(pBaseCcs->_xOverhangAdjust == 0);
        Assert(pBaseCcs->_xOverhang == 0);
        Assert(!pBaseCcs->_fFixPitchFont);
    }

    // Keep track of the line heights specified in all the
    // runs so that we can adjust the line height at the end.
    // Note that we don't want to include break character NEVER
    // count towards height.
    lLineHeight = RememberLineHeight(plsrun->Cp(), pCF, pBaseCcs);

    if (_fHasSites)
    {
        Assert(_fMinMaxPass);
        plsTxMet->dvAscent = 1;
        plsTxMet->dvDescent = 0;
        plsTxMet->dvMultiLineHeight = 1;
    }
    else
    {
        long dvAscent, dvDescent;
        
        dvDescent = pBaseCcs->_yDescent;
        dvAscent  = pBaseCcs->_yHeight - dvDescent;

        plsTxMet->dvAscent = dvAscent;
        plsTxMet->dvDescent = dvDescent;
        plsTxMet->dvMultiLineHeight = lLineHeight;

        if (_pMeasurer->_fPseudoLetterEnabled)
        {
            KernHeightToGlyph(plsrun, &ccs, plsTxMet);
        }
    }

Cleanup:    
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetRunUnderlineInfo (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//  Note(SujalP): Lineservices is a bit wierd. It will *always* want to try to
//  merge runs and that to based on its own algorithm. That algorith however is
//  not the one which IE40 implements. For underlining, IE 40 always has a
//  single underline when we have mixed font sizes. The problem however is that
//  this underline is too far away from the smaller pt text in the mixed size
//  line (however within the dimensions of the line). When we give this to LS,
//  it thinks that the UL is outside the rect of the small character and deems
//  it incorrect and does not call us for a callback. To overcome this problem
//  we tell LS that the UL is a 0 (baseline) but remember the distance ourselves
//  in the PLSRUN.
//
//  Also, since color of the underline can change from run-to-run, we
//  return different underline types to LS so as to prevent it from
//  merging such runs. This also helps avoid merging when we are drawing overlines.
//  Overlines are drawn at different heigths (unlinke underlines) from pt
//  size to pt size. (This probably is a bug -- but this is what IE40 does
//  so lets just go with that for now).
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetRunUnderlineInfo(
    PLSRUN plsrun,          // IN
    PCHEIGHTS heightsPres,  // IN
    LSTFLOW kTFlow,         // IN
    PLSULINFO plsUlInfo)    // OUT
{
    LSTRACE(GetRunUnderlineInfo);
    BYTE  bUnderlineType;
    CComplexRun *pCcr = plsrun->GetComplexRun();
    static BOOL s_fToggleSwitch = FALSE;

    if (pCcr && pCcr->_RenderStyleProp._fStyleUnderline)
    {
        if (pCcr->_RenderStyleProp._underlineStyle == styleTextUnderlineStyleDotted)
        {
            // NOTE: (cthrash) We need to switch between dotted and solid
            // underlining when the text goes from unconverted to converted.

            bUnderlineType = CFU_UNDERLINEDOTTED;
        }
        else if (pCcr->_RenderStyleProp._underlineStyle == styleTextUnderlineStyleThickDash)
        {
            bUnderlineType = CFU_UNDERLINETHICKDASH;
        }
        else
        {
            bUnderlineType = CFU_CF1UNDERLINE;
        }
    }
    else
    {
        bUnderlineType = CFU_CF1UNDERLINE;
    }

    plsUlInfo->kulbase = bUnderlineType | (s_fToggleSwitch ? CFU_SWITCHSTYLE : 0);
    s_fToggleSwitch = !s_fToggleSwitch;

    plsUlInfo->cNumberOfLines = 1;
    plsUlInfo->dvpUnderlineOriginOffset = 0;
    plsUlInfo->dvpFirstUnderlineOffset  = 0;
    plsUlInfo->dvpFirstUnderlineSize = 1;
    plsUlInfo->dvpGapBetweenLines = 0;
    plsUlInfo->dvpSecondUnderlineSize = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetRunStrikethroughInfo (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetRunStrikethroughInfo(
    PLSRUN plsrun,          // IN
    PCHEIGHTS heightPres,   // IN
    LSTFLOW kTFlow,         // IN
    PLSSTINFO plsStInfo)    // OUT
{
    LSTRACE(GetRunStrikethroughInfo);
    LSNOTIMPL(GetRunStrikethroughInfo);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetBorderInfo (member, LS callback)
//
//  Synopsis:   Not implemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetBorderInfo(
    PLSRUN plsrun,      // IN
    LSTFLOW ktFlow,     // IN
    long* pdurBorder,   // OUT
    long* pdupBorder)   // OUT
{
    LSTRACE(GetBorderInfo);

    // This should only ever be called if we set the fBorder flag in lschp.
    LSNOTIMPL(GetBorderInfo);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ReleaseRun (member, LS callback)
//
//  Synopsis:   Callback to release plsrun object, which we don't do.  We have
//              a cache of COneRuns which we keep (and grow) for the lifetime
//              of the CLineServices object.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ReleaseRun(
    PLSRUN plsrun)      // IN
{
    LSTRACE(ReleaseRun);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Hyphenate (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::Hyphenate(
    PCLSHYPH plsHyphLast,   // IN
    LSCP cpBeginWord,       // IN
    LSCP cpExceed,          // IN
    PLSHYPH plsHyph)        // OUT
{
    LSTRACE(Hyphenate);
    // FUTURE (mikejoch) Need to adjust cp values if kysr != kysrNil.

    plsHyph->kysr = kysrNil;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetHyphenInfo (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetHyphenInfo(
    PLSRUN plsrun,      // IN
    DWORD* pkysr,       // OUT
    WCHAR* pwchKysr)    // OUT
{
    LSTRACE(GetHyphenInfo);

    *pkysr = kysrNil;
    *pwchKysr = WCH_NULL;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FInterruptUnderline (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FInterruptUnderline(
    PLSRUN plsrunFirst,         // IN
    LSCP cpLastFirst,           // IN
    PLSRUN plsrunSecond,        // IN
    LSCP cpStartSecond,         // IN
    BOOL* pfInterruptUnderline) // OUT
{
    LSTRACE(FInterruptUnderline);
    // FUTURE (mikejoch) Need to adjust cp values if we ever interrupt underlining.

    *pfInterruptUnderline = FALSE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FInterruptShade (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FInterruptShade(
    PLSRUN plsrunFirst,         // IN
    PLSRUN plsrunSecond,        // IN
    BOOL* pfInterruptShade)     // OUT
{
    LSTRACE(FInterruptShade);

    *pfInterruptShade = TRUE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FInterruptBorder (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FInterruptBorder(
    PLSRUN plsrunFirst,         // IN
    PLSRUN plsrunSecond,        // IN
    BOOL* pfInterruptBorder)    // OUT
{
    LSTRACE(FInterruptBorder);

    *pfInterruptBorder = FALSE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FInterruptShaping (member, LS callback)
//
//  Synopsis:   We compare CF between the runs to see if they are different
//              enough to cause an interrup in shaping between the runs
//
//  Arguments:  kTFlow              text direction and orientation
//              plsrunFirst         run pointer for the previous run
//              plsrunSecond        run pointer for the current run
//              pfInterruptShaping  TRUE - Interrupt shaping
//                                  FALSE - Don't interrupt shaping, merge runs
//
//  Returns:    LSERR               lserrNone if succesful
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FInterruptShaping(
    LSTFLOW kTFlow,                 // IN
    PLSRUN plsrunFirst,             // IN
    PLSRUN plsrunSecond,            // IN
    BOOL* pfInterruptShaping)       // OUT
{
    LSTRACE(FInterruptShaping);

    Assert(pfInterruptShaping != NULL &&
           plsrunFirst != NULL && plsrunSecond != NULL);

    CComplexRun * pcr1 = plsrunFirst->GetComplexRun();
    CComplexRun * pcr2 = plsrunSecond->GetComplexRun();

    Assert(pcr1 != NULL && pcr2 != NULL);

    *pfInterruptShaping = (pcr1->GetScript() != pcr2->GetScript());

    if (!*pfInterruptShaping)
    {
        const CCharFormat *pCF1 = plsrunFirst->GetCF();
        const CCharFormat *pCF2 = plsrunSecond->GetCF();

        Assert(pCF1 != NULL && pCF2 != NULL);

        // We want to break the shaping if the formats are not similar format
        *pfInterruptShaping = !pCF1->CompareForLikeFormat(pCF2);
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetGlyphs (member, LS callback)
//
//  Synopsis:   Returns an index of glyph ids for the run passed in
//
//  Arguments:  plsrun              pointer to the run
//              pwch                string of character codes
//              cwch                number of characters in pwch
//              kTFlow              text direction and orientation
//              rgGmap              map of glyph info parallel to pwch
//              prgGindex           array of output glyph indices
//              prgGprop            array of output glyph properties
//              pcgindex            number of glyph indices
//
//  Returns:    LSERR               lserrNone if succesful
//                                  lserrInvalidRun if failure
//                                  lserrOutOfMemory if memory alloc fails
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetGlyphs(
    PLSRUN plsrun,          // IN
    LPCWSTR pwch,           // IN
    DWORD cwch,             // IN
    LSTFLOW kTFlow,         // IN
    PGMAP rgGmap,           // OUT
    PGINDEX* prgGindex,     // OUT
    PGPROP* prgGprop,       // OUT
    DWORD* pcgindex)        // OUT
{
    LSTRACE(GetGlyphs);

    LSERR lserr = lserrNone;
    HRESULT hr = S_OK;
    CComplexRun * pcr;
    DWORD cMaxGly;
    XHDC hdc = _pci->_hdc;
    XHDC hdcShape(NULL,NULL);
    FONTIDX hfontOld = HFONT_INVALID;
    SCRIPT_CACHE *psc;
    WORD *pGlyphBuffer = NULL;
    WORD *pGlyph = NULL;
    SCRIPT_VISATTR *pVisAttr = NULL;
    CCcs ccs;
    CStr strTransformedText;
    BOOL fTriedFontLink = FALSE;

    pcr = plsrun->GetComplexRun();
    if (pcr == NULL)
    {
        Assert(FALSE);
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    if (!GetCcs(&ccs, plsrun, hdc, _pci))
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    psc = ccs.GetUniscribeCache();
    Assert(psc != NULL);

    // In some fonts in some locales, NBSPs aren't rendered like spaces.
    // Under these circumstances, we need to convert NBSPs to spaces
    // before calling ScriptShape.
    // NOTE: Due to a bug in Bidi Win9x GDI, we can't detect that
    // old bidi fonts lack an NBSP (IE5 bug 68214). We hack around this by
    // simply always swapping the space character for the NBSP. Since this
    // only happens for glyphed runs, US perf is not impacted.
    if (_lineFlags.GetLineFlags(plsrun->Cp() + cwch) & FLAG_HAS_NBSP)
    {
        const WCHAR * pwchStop;
        WCHAR * pwch2;

        HRESULT hr = THR(strTransformedText.Set(pwch, cwch));
        if (hr == S_OK)
        {
            pwch = strTransformedText;

            pwch2 = (WCHAR *) pwch;
            pwchStop = pwch + cwch;

            while (pwch2 < pwchStop)
            {
                if (*pwch2 == WCH_NBSP)
                {
                    *pwch2 = L' ';
                }

                pwch2++;
            }
        }
    }

    // Inflate the number of max glyphs to generate
    // A good high end guess is the number of chars plus 6% or 10,
    // whichever is greater.
    cMaxGly = cwch + max(10, (int)cwch >> 4);

    Assert(cMaxGly > 0);
    pGlyphBuffer = (WORD *) NewPtr(cMaxGly * (sizeof(WORD) + sizeof(SCRIPT_VISATTR)));
    // Our memory alloc failed. No point in going on.
    if (pGlyphBuffer == NULL)
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }
    pGlyph = (WORD *) pGlyphBuffer;
    pVisAttr = (SCRIPT_VISATTR *) (pGlyphBuffer + cMaxGly);

    // Repeat the shaping process until it succeds, or fails for a reason different
    // from insufficient memory, a cache fault, or failure to glyph a character using
    // the current font
    do
    {
        // If a prior ::ScriptShape() call failed because it needed the font
        // selected into the hdc, then select the font into the hdc and try
        // again.
        if (hr == E_PENDING)
        {
            // If we have a valid hdcShape, then ScriptShape() failed for an
            // unknown reason. Bail out.
            if (hdcShape != NULL)
            {
                AssertSz(FALSE, "ScriptShape() failed for an unknown reason");
                lserr = LSERRFromHR(hr);
                goto Cleanup;
            }

            // Select the current font into the hdc and set hdcShape to hdc.
            hfontOld = ccs.PushFont(hdc);
            hdcShape = hdc;
        }
        // If a prior ::ScriptShape() call failed because it was unable to
        // glyph a character with the current font, swap the font around and
        // try it again.
        else if (hr == USP_E_SCRIPT_NOT_IN_FONT)
        {
            if (!fTriedFontLink)
            {
                // Unable to find the glyphs in the font. Font link to try an
                // alternate font which might work.
                fTriedFontLink = TRUE;

                // Set the sid for the complex run to match the text (instead
                // of sidDefault.
                Assert(plsrun->_ptp->IsText());
                plsrun->_sid = plsrun->_ptp->Sid();
                if (plsrun->_sid == sidAmbiguous)
                {
                    plsrun->_sid = sidDefault;
                }

                // Deselect the font if we selected it.
                if (hdcShape != NULL)
                {
                    Assert(hfontOld != HFONT_INVALID);
                    ccs.PopFont(hdc, hfontOld);
                    hdcShape = NULL;
                    hfontOld = HFONT_INVALID;
                }

                // Get the font using the normal sid from the text to fontlink.
                if (!GetCcs(&ccs, plsrun, hdc, _pci))
                {
                    lserr = lserrOutOfMemory;
                    goto Cleanup;
                }

                // Reset the psc using the new ccs.
                psc = ccs.GetUniscribeCache();
                Assert(psc != NULL);
            }
            else
            {
                // We tried to font link but we still couldn't make it work.
                // Blow the SCRIPT_ANALYSIS away and just let GDI deal with it.
                pcr->NukeAnalysis();
            }
        }
        // If ScriptShape() failed because of insufficient buffer space,
        // resize the buffer
        else if (hr == E_OUTOFMEMORY)
        {
            WORD *pGlyphBufferT = NULL;

            // enlarge the glyph count by another 6% of run or 10, whichever is larger.
            cMaxGly += max(10, (int)cwch >> 4);

            Assert(cMaxGly > 0);
            pGlyphBufferT = (WORD *) ReallocPtr(pGlyphBuffer, cMaxGly *
                                                (sizeof(WORD) + sizeof(SCRIPT_VISATTR)));
            if (pGlyphBufferT != NULL)
            {
                pGlyphBuffer = pGlyphBufferT;
                pGlyph = (WORD *) pGlyphBuffer;
                pVisAttr = (SCRIPT_VISATTR *) (pGlyphBuffer + cMaxGly);
            }
            else
            {
                // Memory alloc failure.
                lserr = lserrOutOfMemory;
                goto Cleanup;
            }
        }

        // Try to shape the script again
        hr = ::ScriptShape(hdcShape, psc, pwch, cwch, cMaxGly, pcr->GetAnalysis(),
                           pGlyph, rgGmap, pVisAttr, (int *) pcgindex);

        // Uniscribe can return S_OK when it resolves to the default glyph.
        // In this case we are forcing to fontlink, if we didn't do it yet.
        if ((S_OK == hr) && (!fTriedFontLink) && (0 == *pGlyph))
            hr = USP_E_SCRIPT_NOT_IN_FONT;
    }
    while (hr == E_PENDING || hr == USP_E_SCRIPT_NOT_IN_FONT || hr == E_OUTOFMEMORY);

    // NB (mikejoch) We shouldn't ever fail except for the OOM case. USP should
    // always be loaded, since we wouldn't get a valid eScript otherwise.
    Assert(hr == S_OK || hr == E_OUTOFMEMORY);
    lserr = LSERRFromHR(hr);

Cleanup:
    // Restore the font if we selected it
    if (hfontOld != HFONT_INVALID)
    {
        Assert(hdcShape != NULL);
        ccs.PopFont(hdc, hfontOld);
    }

    // If LS passed us a string which was an aggregate of several runs (which
    // happens if we returned FALSE from FInterruptShaping()) then we need
    // to make sure that the same _sid is stored in each por covered by the
    // aggregate string. Normally this isn't a problem, but if we changed
    // por->_sid for font linking then it becomes necessary. We determine
    // if a change occurred by comparing plsrun->_sid to sidDefault, which
    // is the value plsrun->_sid is always set to for a glyphed run (in
    // ChunkifyTextRuns()).
    if (plsrun->_sid != sidDefault && plsrun->_lscch < (LONG) cwch)
    {
        DWORD sidAlt = plsrun->_sid;
        COneRun * por = plsrun->_pNext;
        LONG lscchMergedRuns = cwch - plsrun->_lscch;

        while (lscchMergedRuns > 0 && por)
        {
            if (por->IsNormalRun() || por->IsSyntheticRun())
            {
                por->_sid = sidAlt;
                lscchMergedRuns -= por->_lscch;
            }
            por = por->_pNext;
        }
    }

    if (lserr == lserrNone)
    {
        // Move the values from the working buffer to the output arguments
        pcr->CopyPtr(pGlyphBuffer);
        *prgGindex = pGlyph;
        *prgGprop = (WORD *) pVisAttr;
    }
    else
    {
        // free up the allocated memory on failure
        if (pGlyphBuffer != NULL)
        {
            DisposePtr(pGlyphBuffer);
        }
        *prgGindex = NULL;
        *prgGprop = NULL;
        *pcgindex = 0;
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetGlyphPositions (member, LS callback)
//
//  Synopsis:   Returns an index of glyph ids for the run passed in
//
//  Arguments:  plsrun              pointer to the run
//              lsDevice            presentation or reference
//              pwch                string of character codes
//              rgGmap              map of glyphs
//              cwch                number of characters in pwch
//              prgGindex           array of output glyph indices
//              prgGprop            array of output glyph properties
//              pcgindex            number of glyph indices
//              kTFlow              text direction and orientation
//              rgDu                array of glyph widths
//              rgGoffset           array of glyph offsets
//
//  Returns:    LSERR               lserrNone if succesful
//                                  lserrModWidthPairsNotSet if failure
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetGlyphPositions(
    PLSRUN plsrun,          // IN
    LSDEVICE lsDevice,      // IN
    LPWSTR pwch,            // IN
    PCGMAP pgmap,           // IN
    DWORD cwch,             // IN
    PCGINDEX rgGindex,      // IN
    PCGPROP rgGprop,        // IN
    DWORD cgindex,          // IN
    LSTFLOW kTFlow,         // IN
    int* rgDu,              // OUT
    PGOFFSET rgGoffset)     // OUT
{
    LSTRACE(GetGlyphPositions);

    LSERR lserr = lserrNone;
    HRESULT hr = S_OK;
    CComplexRun * pcr;
    XHDC hdc = _pci->_hdc;
    XHDC hdcPlace(NULL,NULL);
    FONTIDX hfontOld = HFONT_INVALID;
    SCRIPT_CACHE *psc;
    CCcs ccs;
    const CCharFormat *pCF = plsrun->GetCF();
    const CBaseCcs *pBaseCcs = NULL;
    ULONG i;
    
    pcr = plsrun->GetComplexRun();
    if (pcr == NULL)
    {
        Assert(FALSE);
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    if (!GetCcs(&ccs, plsrun, hdc, _pci))
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    psc = ccs.GetUniscribeCache();
    Assert(psc != NULL);


    // Try to place the glyphs
    hr = ::ScriptPlace(hdcPlace, psc, rgGindex, cgindex, (SCRIPT_VISATTR *)rgGprop,
                       pcr->GetAnalysis(), rgDu, rgGoffset, NULL);

    // Handle failure
    if(hr == E_PENDING)
    {

        Assert(hdcPlace == NULL);

        // Select the current font into the hdc and set hdcShape to hdc.
        hfontOld = ccs.PushFont(hdc);
        hdcPlace = hdc;

        // Try again
        hr = ::ScriptPlace(hdcPlace, psc, rgGindex, cgindex, (SCRIPT_VISATTR *)rgGprop,
                           pcr->GetAnalysis(), rgDu, rgGoffset, NULL);

    }

    //see if font measurements needs scaling adjustment
    pBaseCcs = ccs.GetBaseCcs();
    Assert(pBaseCcs);

    for (i = 0; i < cgindex; i++)
    {
        // see if font measurements needs scaling adjustment
        if (pBaseCcs->_fScalingRequired)
        {
            rgDu[i] *= pBaseCcs->_flScaleFactor;
            rgGoffset[i].du *= pBaseCcs->_flScaleFactor;
            rgGoffset[i].dv *= pBaseCcs->_flScaleFactor;
        }
        if (rgGoffset[i].dv > 0)
            _cyAscent = max(_cyAscent, rgGoffset[i].dv);
        else if (rgGoffset[i].dv < 0)
            _cyDescent = max(_cyDescent, -rgGoffset[i].dv);
    }

    if (pCF->_wSpecialObjectFlags() != 0)
    {
        LONG xLetterSpacing = GetLetterSpacing(pCF);
        LONG xWordSpacing   = GetWordSpacing(pCF);

        if (xLetterSpacing || xWordSpacing || pCF->HasCharGrid(plsrun->_fInnerCF))
        {
            AdjustGlyphWidths(&ccs, xLetterSpacing, xWordSpacing, plsrun, pwch, cwch, 
                              0, rgDu, NULL, NULL, rgGoffset
#if DBG==1
                              , NULL
#endif
                                  );
        }
    }

    // NB (mikejoch) We shouldn't ever fail except for the OOM case (if USP is
    // allocating the cache). USP should always be loaded, since we wouldn't
    // get a valid eScript otherwise.
    Assert(hr == S_OK || hr == E_OUTOFMEMORY);
    lserr = LSERRFromHR(hr);

Cleanup:
    // Restore the font if we selected it
    if (hfontOld != HFONT_INVALID)
    {
        ccs.PopFont(hdc, hfontOld);
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   ResetRunContents (member, LS callback)
//
//  Synopsis:   This callback seems to be more informational.
//
//  Arguments:  plsrun              pointer to the run
//              cpFirstOld          cpFirst before shaping
//              dcpOld              dcp before shaping
//              cpFirstNew          cpFirst after shaping
//              dcpNew              dcp after shaping
//
//  Returns:    LSERR               lserrNone if succesful
//                                  lserrMismatchLineContext if failure
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ResetRunContents(
    PLSRUN plsrun,      // IN
    LSCP cpFirstOld,    // IN
    LSDCP dcpOld,       // IN
    LSCP cpFirstNew,    // IN
    LSDCP dcpNew)       // IN
{
    LSTRACE(ResetRunContents);
    // FUTURE (mikejoch) Need to adjust cp values if we ever implement this.
    // FUTURE (paulnel) this doesn't appear to be needed for IE. Clarification
    // is being obtained from Line Services
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetGlyphExpansionInfo (member, LS callback)
//
//  Synopsis:   This callback is used for glyph based justification
//              1. For Arabic, it handles kashida insetion
//              2. For cluster characters, (thai vietnamese) it keeps tone 
//                 marks on their base glyphs
//
//  NOTE:       LS uses exptAddWhiteSpace for proportional expansion and
//                      exptAddInkContinuous for non-proportional expansion
//              Be sure that Thai uses exptAddInkContinuous for justification
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetGlyphExpansionInfo(
    PLSRUN plsrun,                  // IN
    LSDEVICE lsDeviceID,            // IN
    LPCWSTR pwch,                   // IN
    PCGMAP rggmap,                  // IN
    DWORD cwch,                     // IN
    PCGINDEX rgglyph,               // IN
    PCGPROP rgProp,                 // IN
    DWORD cglyph,                   // IN
    LSTFLOW kTFlow,                 // IN
    BOOL fLastTextChunkOnLine,      // IN
    PEXPTYPE rgExpType,             // OUT
    LSEXPINFO* rgexpinfo)           // OUT
{
    LSTRACE(GetGlyphExpansionInfo);

    LSERR lserr = lserrNone;
    SCRIPT_VISATTR *psva = (SCRIPT_VISATTR *)&rgProp[0];
    CComplexRun * pcr;
    const SCRIPT_PROPERTIES *psp = NULL;
    float flKashidaPct = 100;
    BOOL fKashida = FALSE;
    int iKashidaWidth = 1;  // width of a kashida
    int iWhiteWidth = 1;
    int iPropL = 0;         // index to the connecting glyph left
    int iPropR = 0;         // index to the connecting glyph right
    int iBestPr = -1;       // address of the best priority in a word so far
    int iPrevBestPr = -1;   
    int iKashidaLevel = 0;
    int iBestKashidaLevel = 10;
    BYTE bBestPr = SCRIPT_JUSTIFY_NONE;
    BYTE bCurrentPr = SCRIPT_JUSTIFY_NONE;
    BYTE bNext;
    BYTE expType = exptNone;
    int iSpaceMax, iCharMax;
    LSEMS lsems;
    
    pcr = plsrun->GetComplexRun();
    UINT justifyStyle = plsrun->_pPF->_uTextJustify;

    if (pcr == NULL)
    {
        Assert(FALSE);
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    // 1. From the script analysis we can tell what language we are dealing with
    //    a. if we are Arabic block languages, we need to do the kashida insertion
    //    b. if we are Thai or Vietnamese, we need to set the expansion type for diacritics 
    //       to none so they remain on their base glyph.
    psp = GetScriptProperties(pcr->GetAnalysis()->eScript);

    // Check to see if we are an Arabic block language
    fKashida = IsInArabicBlock(psp->langid);

    // if we are going to do kashida insertion we need to get the kashida width information
    if(fKashida)
    {
        lserr = GetKashidaWidth(plsrun, &iKashidaWidth);

        if(lserr != lserrNone)
            goto Cleanup;

        if (!plsrun->_pPF->_cuvTextKashidaSpace.IsNull())
        {
            flKashidaPct = plsrun->_pPF->_cuvTextKashidaSpace.GetUnitValue();
        }

        if (flKashidaPct == 0)
        {
            iWhiteWidth = iKashidaWidth;
            iKashidaWidth = 1;
        }
        else if (flKashidaPct < 100)
        {
            iWhiteWidth = max((int)((float)iKashidaWidth * ((100 - flKashidaPct) / flKashidaPct)), 1);
        }

    }

    // find the max space and character widths for expansion
    // this will give us compatibility with expansion used by
    // character based runs. 8-)
    lserr = GetEms(plsrun, kTFlow, &lsems);
    if(lserr != lserrNone)
        goto Cleanup;

    if (justifyStyle == styleTextJustifyNewspaper)
    {
        iSpaceMax = lsems.udExp;
    }
    else
    {
        iSpaceMax = lsems.em2;
    }
    iCharMax = lsems.em4;

    //initialize rgExpType and rgexpinfo to zeros
    expType = exptNone;
    memset(rgExpType, expType, sizeof(EXPTYPE)*cglyph);
    memset(rgexpinfo, 0, sizeof(LSEXPINFO)*cglyph);

    // Loop through the glyph attributes. We assume logical order here
    while(iPropL < (int)cglyph)
    {
        bCurrentPr = psva[iPropL].uJustification;

        switch(bCurrentPr)
        {
        case SCRIPT_JUSTIFY_NONE:
            rgExpType[iPropL] = exptNone;

            // this is a HACK to fix a Uniscribe problem. When Uniscribe is fixed, 
            // this needs to be removed.
            if(IsNoSpaceLang(psp->langid) && !psva[iPropL].fDiacritic && !psva[iPropL].fZeroWidth)
            {
                if(!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1)) // base glyph
                {
                    BOOL fLastBaseGlyph = FALSE;

                    if (fLastTextChunkOnLine)
                    {
                        iPropR = cglyph - 1;
                        while (iPropR > iPropL)
                        {
                            if (!psva[iPropR].fDiacritic && !psva[iPropR].fZeroWidth) // base glyph
                                break;
                            iPropR--;
                        }
                        if (iPropR == iPropL)
                            fLastBaseGlyph = TRUE;
                    }
                    if (!fLastBaseGlyph)
                    {
                        switch(justifyStyle)
                        {
                        default:
                        case styleTextJustifyInterWord:
                        case styleTextJustifyInterIdeograph:
                        case styleTextJustifyKashida:
                            rgExpType[iPropL] = exptNone;
                            break;
                        case styleTextJustifyNewspaper:
                        case styleTextJustifyDistribute:
                        case styleTextJustifyDistributeAllLines:
                        case styleTextJustifyInterCluster:
                            rgExpType[iPropL] = exptAddInkContinuous;
                            rgexpinfo[iPropL].prior = 1;
                            rgexpinfo[iPropL].duMax = iSpaceMax;
                            rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                            rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                            break;
                        }
                    }
                }
            }

            break;

        case SCRIPT_JUSTIFY_CHARACTER:
            if(!NoInterClusterJustification(psp->langid) && !IsNoSpaceLang(psp->langid))
            {
                if (!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1))
                {
                    switch(justifyStyle)
                    {
                    default:
                    case styleTextJustifyInterWord:
                    case styleTextJustifyInterIdeograph:
                    case styleTextJustifyKashida:
                    case styleTextJustifyInterCluster:
                        rgExpType[iPropL] = exptNone;
                        break;
                    case styleTextJustifyNewspaper:
                    case styleTextJustifyDistribute:
                    case styleTextJustifyDistributeAllLines:
                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 2;
                        rgexpinfo[iPropL].duMax = iCharMax;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                        break;
                    }
                }
                // Final character on the line should not get justification
                // flag set.
                else
                {
                    rgExpType[iPropL] = exptNone;
                }
                
            }
            // NoSpaceLanguage
            else if (IsNoSpaceLang(psp->langid))
            {
                if(!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1)) 
                {
                    if (!psva[iPropL].fDiacritic && !psva[iPropL].fZeroWidth) // base glyph
                    {
                        BOOL fLastBaseGlyph = FALSE;

                        if (fLastTextChunkOnLine)
                        {
                            iPropR = cglyph - 1;
                            while (iPropR > iPropL)
                            {
                                if (!psva[iPropR].fDiacritic && !psva[iPropR].fZeroWidth) // base glyph
                                    break;
                                iPropR--;
                            }
                            if (iPropR == iPropL)
                                fLastBaseGlyph = TRUE;
                        }
                        if (!fLastBaseGlyph)
                        {
                            switch(justifyStyle)
                            {
                            default:
                            case styleTextJustifyInterWord:
                            case styleTextJustifyInterIdeograph:
                            case styleTextJustifyKashida:
                                rgExpType[iPropL] = exptNone;
                                break;
                            case styleTextJustifyNewspaper:
                            case styleTextJustifyDistribute:
                            case styleTextJustifyDistributeAllLines:
                            case styleTextJustifyInterCluster:
                                rgExpType[iPropL] = exptAddInkContinuous;
                                rgexpinfo[iPropL].prior = 1;
                                rgexpinfo[iPropL].duMax = iSpaceMax;
                                rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                                rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                                break;
                            }
                        }
                    }
                    else
                    {
                        rgExpType[iPropL] = exptNone;
                    }
                }
                // Final character on the line should not get justification
                // flag set.
                else
                {
                    rgExpType[iPropL] = exptNone;
                }
            }
            // NoInterClusterJustification
            else
            {
                rgExpType[iPropL] = exptNone;
            }
            break;

        case SCRIPT_JUSTIFY_BLANK:
            if(!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1))
            {
                rgExpType[iPropL] = exptAddInkContinuous;
                rgexpinfo[iPropL].prior = 1;
                rgexpinfo[iPropL].duMax = iSpaceMax;
                rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
            }
            // Final character on the line should not get justification
            // flag set.
            else
            {
                rgExpType[iPropL] = exptNone;
            }
            break;

        case SCRIPT_JUSTIFY_ARABIC_BLANK:
            if(!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1))
            {

                switch(justifyStyle)
                {
                case styleTextJustifyInterWord:
                    rgExpType[iPropL] = exptAddInkContinuous;
                    rgexpinfo[iPropL].prior = 1;
                    rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                    rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                    rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                    break;
                case styleTextJustifyNewspaper:
                case styleTextJustifyDistribute:
                case styleTextJustifyDistributeAllLines:
                    if (flKashidaPct < 100)
                    {
                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 1;
                        rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = iWhiteWidth;
                    }
                    else
                    {
                        rgExpType[iPropL] = exptNone;
                    }
                    break;
                case styleTextJustifyInterCluster:
                case styleTextJustifyInterIdeograph:
                    if (flKashidaPct < 100)
                    {
                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 2;
                        rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = iWhiteWidth;
                    }
                    else
                    {
                        rgExpType[iPropL] = exptNone;
                    }
                    break;
                case styleTextJustifyNotSet:
                case styleTextJustifyKashida:
                case styleTextJustifyAuto:
                    if (flKashidaPct == 100)
                    {
                        if (iBestPr >= 0)
                        {
                            rgExpType[iBestPr] = exptAddInkContinuous;
                            rgexpinfo[iBestPr].prior = 1;
                            rgexpinfo[iBestPr].duMax = lsexpinfInfinity;
                            rgexpinfo[iBestPr].fCanBeUsedForResidual = FALSE;
                            rgexpinfo[iBestPr].u.AddInkContinuous.duMin = iKashidaWidth;
                        }

                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 2;
                        rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                    }
                    else if (flKashidaPct > 0)
                    {
                        if (iBestPr >= 0)
                        {
                            rgExpType[iBestPr] = exptAddInkContinuous;
                            rgexpinfo[iBestPr].prior = 1;
                            rgexpinfo[iBestPr].duMax = lsexpinfInfinity;
                            rgexpinfo[iBestPr].fCanBeUsedForResidual = FALSE;
                            rgexpinfo[iBestPr].u.AddInkContinuous.duMin = iKashidaWidth;
                        }

                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 1;
                        rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = iWhiteWidth;
                    }
                    else // fKashida == 0
                    {
                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 1;
                        rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                    }

                    if (flKashidaPct > 0 && iBestPr >=0)
                    {
                        iPrevBestPr = iPropL;
                        iBestPr = -1;
                        bBestPr = SCRIPT_JUSTIFY_NONE;
                        iBestKashidaLevel = KASHIDA_PRIORITY9;
                    }
                    break;
                default:
                    rgExpType[iPropL] = exptNone;
                    break;
                }
            }
            // Final character on the line should not get justification
            // flag set.
            else
            {
                rgExpType[iPropL] = exptNone;
            }
            break;

        case SCRIPT_JUSTIFY_ARABIC_KASHIDA: // kashida is placed after kashida and seen characters
        case SCRIPT_JUSTIFY_ARABIC_SEEN:
        case SCRIPT_JUSTIFY_ARABIC_HA: // kashida is placed before the ha and alef
        case SCRIPT_JUSTIFY_ARABIC_ALEF:
        case SCRIPT_JUSTIFY_ARABIC_RA: // kashida is placed before prior character if prior char is a medial ba type
        case SCRIPT_JUSTIFY_ARABIC_BARA:
        case SCRIPT_JUSTIFY_ARABIC_BA:
        case SCRIPT_JUSTIFY_ARABIC_NORMAL:
            if(!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1))
            {
                switch(justifyStyle)
                {
                case styleTextJustifyInterWord:
                case styleTextJustifyInterCluster:
                case styleTextJustifyInterIdeograph:
                    rgExpType[iPropL] = exptNone;
                    break;
                case styleTextJustifyNewspaper:
                case styleTextJustifyDistribute:
                case styleTextJustifyDistributeAllLines:
                    if (flKashidaPct > 0)
                    {
                        if (   bCurrentPr == SCRIPT_JUSTIFY_ARABIC_KASHIDA
                            || bCurrentPr == SCRIPT_JUSTIFY_ARABIC_SEEN)
                        {
                            rgExpType[iPropL] = exptAddInkContinuous;
                            rgexpinfo[iPropL].prior = 1;
                            rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                            rgexpinfo[iPropL].fCanBeUsedForResidual = FALSE;
                            rgexpinfo[iPropL].u.AddInkContinuous.duMin = iKashidaWidth;
                        }
                        else
                        {
                            Assert(iPropL > 0);
                            rgExpType[iPropL - 1] = exptAddInkContinuous;
                            rgexpinfo[iPropL - 1].prior = 1;
                            rgexpinfo[iPropL - 1].duMax = lsexpinfInfinity;
                            rgexpinfo[iPropL - 1].fCanBeUsedForResidual = FALSE;
                            rgexpinfo[iPropL - 1].u.AddInkContinuous.duMin = iKashidaWidth;

                            bNext = psva[iPropL + 1].uJustification;
                            if (   bNext >= SCRIPT_JUSTIFY_ARABIC_NORMAL
                                && bNext < SCRIPT_JUSTIFY_ARABIC_SEEN
                                && bNext != SCRIPT_JUSTIFY_ARABIC_KASHIDA)
                            {
                                rgExpType[iPropL] = exptAddInkContinuous;
                                rgexpinfo[iPropL].prior = 1;
                                rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                                rgexpinfo[iPropL].fCanBeUsedForResidual = FALSE;
                                rgexpinfo[iPropL].u.AddInkContinuous.duMin = iKashidaWidth;
                            }
                        }
                    }
                    else
                    {
                        rgExpType[iPropL] = exptNone;
                    }
                    break;
                case styleTextJustifyKashida:
                default:
                    if (flKashidaPct > 0)
                    {
                        iKashidaLevel = s_iKashidaPriFromScriptJustifyType[bCurrentPr];
                        if(iKashidaLevel <= iBestKashidaLevel)
                        {
                            iBestKashidaLevel = iKashidaLevel;

                            if (   bCurrentPr == SCRIPT_JUSTIFY_ARABIC_KASHIDA
                                || bCurrentPr == SCRIPT_JUSTIFY_ARABIC_SEEN)
                            {
                                // these types of kashida go after this glyph visually
                                for(iPropR = iPropL + 1; iPropR < (int)cglyph && psva[iPropR].fDiacritic; iPropR++);
                                if(iPropR != iPropL)
                                    iPropR--;

                                iBestPr = iPropR;
                            }
                            else
                            {
                                if (bCurrentPr != SCRIPT_JUSTIFY_ARABIC_BARA)
                                {
                                    Assert(iPropL > 0);
                                    iBestPr = iPropL - 1;
                                }
                                else
                                {
                                    Assert(iPropL > 0);

                                    // if we have a medial ba before the ra, add the kashida before
                                    // the medial ba
                                    if (   psva[iPropL - 1].uJustification == SCRIPT_JUSTIFY_ARABIC_BA)
                                    {
                                        Assert(iPropL > 1);
    	                                iBestPr = iPropL - 2;
                                    }
                                    else
                                    {
                                        // We did not have a medial tooth type character before, so we
                                        // demote the value
                                        iBestKashidaLevel = s_iKashidaPriFromScriptJustifyType[SCRIPT_JUSTIFY_ARABIC_RA];

                                        iBestPr = iPropL - 1;
                                    }
                                }
                            }
                        }
                    }
                    break;
                }
            }
            // Final character on the line should not get justification
            // flag set.
            else
            {
                if (   bCurrentPr != SCRIPT_JUSTIFY_ARABIC_KASHIDA
                    && bCurrentPr != SCRIPT_JUSTIFY_ARABIC_SEEN
                    && flKashidaPct > 0)
                {
                    iKashidaLevel = KASHIDA_PRIORITY3;
                    if(iKashid