gado", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\redir\ru\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "   ணࠬ   ᨨ MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "Vdm Redirector 㦥 㦥", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\tools\src\buildidx\buildidx.c ===
/*
  PROGRAM NAME	BUILDIDX.C	Program by Sam W  Nunn	  Sep 24 1987

  To create from a file of messages a second file with offsets to the
  message headers of the first file, the quantity of messages with it,
  and update the level of the level of the files unless there are no
  changes to the files ( both files already exist with accurate data
  in the second file ).

  One argument from command line is needed :	  input file spec

  Sudeepb 03-May-1991 Ported for NT DOSEm
*/


#define LINT_ARGS ON                   /* Not needed in final version. */
#include <stdio.h>                     /* Req. for feof, fgets, printf, fputs */
                                       /* rewind. */
#include <stdlib.h>
#include <io.h>                        /* Req. for rename */
#include <process.h>                   /* Req. for exit */
#include <ctype.h>                     /* Req for isdigit, isalpha */
#include <string.h>                    /* Required for strcpy, strcat, */
                                       /* strlen */
#define LNMAX 200                      /* Max length of a line. */
#define LVMAX 4                        /* Max length of the message level. */
#define FNMAX 64                       /* Max length of the file spec. */
#define TEMPFILE "tempfile.msg\0"

  char fnameA[FNMAX];                  /* File spec from command line. */
  char fnameB[FNMAX];                  /* File spec for index file. */

void main(argc, argv)

  int argc;                             /* Quantity of command parms. */
  char *argv[];                         /* Command line input to Message. */

 {
   int  len,                           /* File spec character length */
        comparable,                    /* Comparable %1.IDX and %1.MSG files ? */
        Msg_Tot_Pos,                   /* Position on header line of total. */
        Msg_Cnt_Str,                   /* String converted to int. */
        Msg_Cnt;                       /* Quantity of messages per header. */
   char msgline[LNMAX] ,               /* A line read from message file. */
        filespec[FNMAX],               /* Name and location of final ?.MSG */
        header[10],
        idxline[LNMAX] ;               /* A line read from index file. */
   long header_offset ;                /* Byte count to header line. */
   long header_os_str ;                /* Byte count to header line. */
   long return_offset ;                /* Byte count to header line. */
   FILE *msgfile ,                     /* Message list to be checked */
        *idxfile ;                     /* Index file to the messages. */


   if ( argc != 2 )                     /* Look for file to use */
     {                                  /* from command line.        */
     printf("Incorrect number of parms  given to BUILDIDX.") ;
     return ;                           /* Print error and quit. */
     }
   else
     {
     strcpy(fnameA,argv[1]) ;           /* Get the first file spec. */
     strcpy(fnameB,argv[1]) ;           /* Get the second file spec. */
     len = strlen(fnameB) ;
     fnameB[len-3] = (char)73 ;         /* Put the IDX extension on it. */
     fnameB[len-2] = (char)68 ;
     fnameB[len-1] = (char)88 ;
     }
   if (( msgfile = fopen(fnameA,"r")) != NULL )   /* Exist input file ? */
     if (( idxfile = fopen(fnameB,"r")) != NULL )  /* Exist second file ? */
       comparable = 1 ;
     else
       comparable = 0 ;
   else
      {
      perror("Could't open message data file. \n") ;
      exit(1);
      }
   if ( comparable )
     {                                  /* Test the Message Levels. */
     fgets(msgline,LNMAX,msgfile) ;
     fgets(idxline,LNMAX,idxfile) ;
     if ( strcmp(msgline,idxline) == 0 )
       comparable = 1 ;
     else
       comparable = 0 ;
     }
   else
     printf("Can not find index file of the same message file level.\n") ;
   header_offset = ftell(msgfile) ;     /* Test header offset to the one */
   fscanf(msgfile,"%s",header) ;        /* recorded in the message file. */
   fscanf(msgfile,"%lx",&header_os_str) ;       /* Header offset. */
   fscanf(msgfile,"%d",&Msg_Cnt_Str) ;          /* Total messages. */
   if ( header_offset != header_os_str )
       comparable = 0 ;
   else
     fseek(msgfile,header_offset,0) ;
   fgets(msgline,LNMAX,msgfile) ;     /* Skip to header lines. */
   while ( !feof(msgfile) && !feof(idxfile) && comparable )
     {                                  /* Test the message header lines. */
     fgets(idxline,LNMAX,idxfile) ;
     if( strcmp(idxline, msgline ) == 0 )
       Msg_Cnt = 0 ;                    /* Msg_Cnt reset to count messages. */
     else
       comparable = 0 ;
     header_offset = ftell(msgfile) ;
     fgets(msgline,LNMAX,msgfile) ;
     while ( !isalpha(msgline[0]) && !feof(msgfile) && comparable )
       {
       while ( !isdigit(msgline[0]) && !isalpha(msgline[0]) && !feof(msgfile) )
         {
         header_offset = ftell(msgfile) ;
         fgets(msgline,LNMAX,msgfile) ;
         }
       while ( isdigit(msgline[0]) && !feof(msgfile) )
         {                              /* Check the number of messages. */
         Msg_Cnt++ ;
         header_offset = ftell(msgfile) ;
         fgets(msgline,LNMAX,msgfile) ;
         }
       }
     if ( Msg_Cnt == Msg_Cnt_Str )
       comparable = 1 ;
     else
       {
       comparable = 0 ;
       printf("The number of messages has changed. \n");
       }
     if (!feof(msgfile))
       {                                /* Test header offset to the one */
       return_offset = ftell(msgfile) ; /* recorded in the message file. */
       fseek(msgfile,header_offset,0) ;
       fscanf(msgfile,"%s",header) ;
       fscanf(msgfile,"%lx",&header_os_str) ;
       fscanf(msgfile,"%d",&Msg_Cnt_Str) ;          /* Total messages. */
       if ( header_offset != header_os_str )
           comparable = 0 ;
       else
         fseek(msgfile,return_offset,0) ;
       }
     }
   if ( comparable && feof(msgfile) && !feof(idxfile) )
     {                                 /* The two files compared OK. */
     printf("Message file and index file are not changed.\n") ;
     fclose(msgfile) ;
     fclose(idxfile) ;
     }
   else                         /* Rebuild %1.MSG file then %1.IDX file. */
     {
     fclose(msgfile) ;
     fclose(idxfile) ;
     strcpy(filespec, argv[1]) ;
     printf("Message file and index file will be updated.\n") ;
     updatemsg() ;              /* Make a new %1.MSG from the old. */
     bldindex() ;               /* Make an index file( %1.IDX ). */
     unlink(fnameA) ;           /* Get ridd of the old file. */
     rename(TEMPFILE,filespec) ;  /* Give output file the old file name. */
     }
 }


 updatemsg()
   {
   int  c,                      /* Charactor bucket for temp. storage */
        Message_Level,          /* Level of the message file. */
        File_Offset,            /* Offset to find title. */
        Msg_Cnt,                /* Quantity of messages per title. */
        First_line ,            /* Control recording qty.of prev.msg. */
        blank_line ,            /* A blank line from input sets to 1. */
        title,                  /* Flag to indicate strg. is a title. */
        index;                  /* Index into  array. */
   long bycnt_ot_fl ,           /* Byte count read from output file. */
        MsgCntLoc ,             /* Location of the count of messages. */
        temp_end ;              /* Byte count read from output file. */
   char File_in[LNMAX];         /* A line read from input file. */
   FILE *inpfile ,              /* Message file to be updated. */
        *outfile ;              /* Updated message file. */

   inpfile = fopen(fnameA,"r") ;              /* Open file for input. */
   outfile = fopen(TEMPFILE,"w");             /* Open file for output. */
   Msg_Cnt = 0 ;
   First_line = 1 ;
   title = 0 ;
   blank_line = 0 ;
                      /* Increment the Message level for the output file. */
   fscanf(inpfile,"%d",&Message_Level) ;    /* Read the old level. */
   Message_Level++ ;
   fprintf(outfile,"%04d\n",Message_Level) ; /* Output the new level. */
   fgetc(inpfile);                  /* Skip over eol. */
   while ( !feof(inpfile))          /* Stop when whole file has been read. */
     {
     while (( c = fgetc(inpfile)) == (char)32 ) ;
     while ( c == (char)'\t')
       c = fgetc(inpfile);             /* Skip over leading blank spaces. */
     index = 0 ;
     if ( isdigit(c) )           /* Starting with a number ? */
       {
       File_in[index] = c ;
       Msg_Cnt = Msg_Cnt + 1 ;        /* Add to the quantity of messages. */
       index = index + 1 ;
       while (((c = fgetc(inpfile))!= (char)'\n' ) &&
              ( index < LNMAX ) && !feof(inpfile))
         {                            /* Stop at the end of line char. */
         File_in[index] = c ;
         index++ ;
         }
       File_in[index] = (char)'\n';   /* Add end of line to string. */
       File_in[index+1] = (char)'\0';   /* Add end of string. */
       }
     else
       {
       if ( isalpha(c))
         {                            /* Found the title of the module. */
         if ( First_line )            /* Only on the first header. */
           {
           bycnt_ot_fl = ftell(outfile) ;     /* Locate header offset. */
           First_line = 0 ;
           }
         else
           {                                  /* Go back and update */
           temp_end = ftell(outfile) ;        /* the count of messages */
           fseek(outfile,MsgCntLoc,0) ;       /* under that header. */
           fprintf(outfile,"%04d",Msg_Cnt) ;
           Msg_Cnt = 0 ;                      /* Reset the msg. count. */
           bycnt_ot_fl = temp_end ;           /* Done with that, so off */
           fseek(outfile,temp_end,0) ;        /* to work on the next */
           }                                  /* header. */
         title = 1 ;
         File_in[index] = c ;                 /* Put together the header. */
         index = index +1 ;
         while (((c = fgetc(inpfile)) != (char)32 ) && ( c != (char)'\n') &&
                                              ( c != (char)'\t'))
           {
           File_in[index] = c ;               /* Save only the first str. */
           index++ ;                          /* for the header. */
           }
         File_in[index] = (char)'\0';
                                      /* Get ridd of the rest of the line, */
         while (c != (char)'\n' )     /* we have no use for it. */
           c = fgetc(inpfile) ;
         }
       else                           /* Line is PART of a define msg. */
         {
         while ( c == (char)'\t')        /* Control the number of tabs */
           c = fgetc(inpfile) ;           /* to just one leading tab. */
                                      /* One tab helps to make it visable. */
         if ( c == (char)34 )         /* Looking for a quote mark. */
           {
           File_in[index] = (char)'\t' ;
           index = index + 1 ;          /* Get the whole message line */
           File_in[index] = c ;         /* into the string. */
           index = index + 1 ;
           while (((c = fgetc(inpfile)) != (char)'\n' ) &&
                  ( index < LNMAX ) && !feof(inpfile))
             {
             File_in[index] = c ;
             index++ ;                    /* Stop at the end of line char. */
             }
           File_in[index] = (char)'\n';   /* Add end of line to string. */
           index = index + 1 ;
           File_in[index] = (char)'\0';   /* Add end of string. */
           }
         else
           {                          /* Must not be a line to save. */
           blank_line = 1 ;
                                      /* Get ridd of the rest of the line, */
           while (c != (char)'\n'&& !feof(inpfile) )     /* we have no use for it. */
             c = fgetc(inpfile) ;
           }
         }    /* End test for Alpha char. at the front of the line. */
       }      /* End test for a Digit at the front of the line. */
     if ( title && !feof(inpfile))
       {              /* Output to the new file. */
       fprintf(outfile,"%-8.8s %08lx %04d\n",File_in,bycnt_ot_fl,Msg_Cnt) ;
       MsgCntLoc = ftell(outfile)-6 ;
       title = 0 ;
       }
     else
       {
       title = 0 ;
       if ( !First_line && !blank_line )
         fputs(File_in,outfile) ;     /* Output to the new file. */
       else
         blank_line = 0 ;
       }      /* End test for title line to output. */
     }        /* While not end of file */
   if ( feof(inpfile) && Msg_Cnt > 0 )
     {
     temp_end = ftell(outfile) ;                /* Put down the last */
     fseek(outfile,MsgCntLoc,0) ;               /* update to the quantity */
     fprintf(outfile,"%04d",Msg_Cnt) ;          /* of messages listed. */
     fseek(outfile,temp_end,0) ;
     printf("Message file updated.\n") ;
     }
   else
     {        /* Nothing else to do !   Might as well finish. */
     printf("Message file update completed.\n") ;
     }
   /*cleanx(*inpfile, *outfile) ;*/
   fclose(inpfile) ;
   fclose(outfile) ;
   }      /* End of updatemsg */

 bldindex()
   {
   FILE *msgf ;
   FILE *idxf;
   char msgline[LNMAX] ;                /* A line read from input file. */

   msgf = fopen(TEMPFILE,"r");
   /*msgf = fopen(fnameA,"r"); */
   idxf = fopen(fnameB,"w");            /* Open to write to %1.IDX file */
   fgets(msgline,LNMAX,msgf) ;
   fputs(msgline,idxf) ;                /* Output the message file level. */
   fgets(msgline,LNMAX,msgf) ;
   while ( isalpha(msgline[0]) && !feof(msgf) )
     {
     fputs(msgline,idxf) ;              /* Save header in the index file. */
     fgets(msgline,LNMAX,msgf) ;
     while ( !isalpha(msgline[0]) && !feof(msgf) )
       fgets(msgline,LNMAX,msgf) ;      /* Not saveing non-header lines. */
     }
   printf("Index file updated.\n") ;
   fclose(msgf) ;
   fclose(idxf) ;
   }


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\redir\tr\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "Program bu MS-DOS srmnde altrlamaz", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "Vdm Ynlendiricisi zaten ykl", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "Vdm Ynlendiricisi yklenemiyor", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\tools\src\getsize\getsize.c ===
/***************************************************************************

   Module Name: getsize

   Description:
	Obtains BIOS_DATA (bios data size), BIOS_CODE ( bios code size )
	from ..\bios\msbio.map and DOSDATA (dos data size) from msdos.map
	and compares it with existing values in bdsiz.inc. If the values are
	update bdsiz.inc with the new values.

   Sudeepb 03-May-1991 Ported for NT DOSEm.
***************************************************************************/


#include<stdio.h>
#include<process.h>
#include<string.h>
#define	MAXLINE	200
#define	MAXWORD	64

int 	getline(s, lim, fileptr)
char	*s;
int	lim;
FILE	*fileptr;

{

	int	c, i;

	for	(i=0; (i < lim-1) && ((c=fgetc(fileptr)) != EOF) && (c!='\n'); ++i)
			s[i] = c;

	if		(c == '\n')
			s[i++] = c;

	s[i] = '\0';
	return(i);
}

scanline(s, prev, template)
char	*s, *template, *prev ;

{

	char	str[MAXWORD];
	int	i = 0;

	while ( *s == ' ')		
			s++;

	while	( *s != '\n' )
	{
		while( (*s != ' ') && (*s != '\n') && (*s != '\t'))
		{
			str[i++] = *s++;
		}
		str[i] = '\0';

		if ( (*s == ' ') || (*s == '\t') )
			s++;

 /*		printf("%s\n", str); */

		if ( strcmp( str, template) == 0 )
			return(0);

		strcpy(prev, str);

		i = 0;
	}

	return(-1);

}


void main()
{
	FILE	*fp1, *fp2;
	char	buffer[MAXLINE], 
			prev[MAXWORD],
			newdosdata[MAXWORD],
			newbiosdata[MAXWORD],
			newbioscode[MAXWORD],
			olddosdata[MAXWORD],
			oldbiosdata[MAXWORD],
			oldbioscode[MAXWORD];


	int	len, scanres, changed = 0;

	if ( (fp1	= fopen("ntdos.map", "r")) == NULL )
		{
			printf("getsize: cannot open ntdos.map\n");
			exit(0);
		}

	if ( (fp2 = fopen("..\\bios\\ntio.map", "r")) == NULL )
		{
			printf("getsize: cannot open ntio.map\n");
			exit(0);
		}


	/* Look for line containing string DOSDATA in msdos.map */

	do
	{
		len 	= getline(buffer, MAXLINE, fp1);
		scanres = scanline(buffer, prev, "DOSDATA");

	}
	while ( (scanres != 0) && (len !=0) ) ;

	/* Save word before DOSDATA (dosdata size) in newdosdata. */
	strcpy(newdosdata, prev);	


	/* Look for line containing string BIOS_DATA in msbio.map */

	do
	{
		len 	= getline(buffer, MAXLINE, fp2);
		scanres = scanline(buffer, prev, "BIOS_DATA");
	}
	while ( (scanres != 0) && (len !=0) ) ;

	/* Save word before BIOS_DATA (biosdata size) in newbiosdata. */
	strcpy(newbiosdata, prev);


	/* Seek back to beginning of MSBIO.MAP */
	if ( fseek(fp2, 0L, SEEK_SET) )
		printf("getsize: fseek failed on msbio.map\n");

	/* Look for line containing string BIOS_CODE in msbio.map */

	do
	{
		len 	= getline(buffer, MAXLINE, fp2);
		scanres = scanline(buffer, prev, "BIOS_CODE");
	}
	while ( (scanres != 0) && (len !=0) ) ;

	/* Save word before BIOS_CODE (bios code size) in newbioscode. */
	strcpy(newbioscode, prev);

	fclose(fp1);	
	fclose(fp2);

	if ( (fp1 = fopen("..\\..\\inc\\bdsize.inc", "r")) == NULL )
		{
			printf("getsize: cannot open origin.inc\n");
			exit(0);
		}

	/* read in existing values of bios code , bios data and dos data  */
	/* size from bdsize.inc. 														*/

	fscanf(fp1, "%s%s%s", oldbiosdata, oldbiosdata, oldbiosdata);
	fscanf(fp1, "%s%s%s", oldbioscode, oldbioscode, oldbioscode);
	fscanf(fp1, "%s%s%s", olddosdata, olddosdata, olddosdata);

	printf("oldbiosdata=%s newbiosdata=%s\n",oldbiosdata, newbiosdata);
	printf("oldbioscode=%s newbioscode=%s\n",oldbioscode, newbioscode);
	printf("olddosdata=%s newdosdata=%s\n",olddosdata, newdosdata);


	/* Check to see if any one of them has changed */

	if ( strcmp(oldbiosdata, newbiosdata) != 0 )
		changed = 1;
	else if 	( strcmp(oldbioscode, newbioscode) != 0 )
		changed = 1;
	else if 	( strcmp(olddosdata, newdosdata) != 0 )
		changed = 1;

	/* if not changed, done. */

	if	(changed == 0)
		exit(0);
	

	/* One of the values has changed update bdsize.inc */

	fclose(fp1);

	if ( (fp1 = fopen("..\\inc\\bdsize.inc", "w")) == NULL )
		{
			printf("getsize: cannot open origin.inc\n");
			exit(0);
		}

	fprintf(fp1, "%s %s %s\n", "BIODATASIZ", "EQU", newbiosdata);
	fprintf(fp1, "%s %s %s\n", "BIOCODESIZ", "EQU", newbioscode);
	fprintf(fp1, "%s %s %s\n", "DOSDATASIZ", "EQU", newdosdata);
}




	
 

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\tools\src\h2inc\h2inc.c ===
/*static char *SCCSID = "@(#)h2inc.c 13.28 90/08/21";*/

/****************************** Module Header ******************************\
* Module Name: h2inc
*
* .H to .INC file translator
*
* Created: 15-Aug-87
*
* Author:  NeilK
* Modified:Jameelh	25-Jul-88
*		New switches added at command line '-n' & '-c' & '-g'.
*		o '-c' strips off the comments.
*		o Can handle structs without typedefs.
*		o Struct name need not have a prepended '_'.
*		o Don't need a Hungarian tag for it to work.
*		o Added a tag - for ptda_s - to genereate a
*		  named SEGMENT instead of struc. ( if '-g' specified )
*		o Added PUBLIC, INIT, and AINIT directives.
*		o Can handle structs within structs if 'typedef'ed.
*		o Added switch to define int size INT_16 or INT_32.
*		  -  All this works if '-n' switch is used.
*		o Added support for nested structs and bitfields upto
*		  32-bit long.
*		o Added XLATOFF & XLATON directives to switch translation
*		  off and on.
* Modified:  Lindsay Harris [lindsayh] - 13-Dec-88
*		o Remove casts of KNOWN types from #define statements
*		o Bug fix in handling NEAR pointers
* Modified:  Floyd Rogers [floydr] - 02-Jan-89
*		o Added function prototype argument lists for -W3
*		o Modified to use runtime lib declarations
*		o Removed unused variables, routine.
*		o Found bug in GetFieldName that would trash memory.
* Modified:  Floyd Rogers [floydr] - 04-Jan-89
*		o Added -d switch so that pm include files wouldn't break
*		o Added -? switch so that users can see more info about options
*		o gathered all #defines together.
*		o gathered all data declarations together, and alphabetized.
*		o initialize option flags in preset
* Modified:  Floyd Rogers [floydr] - 20-Jan-89
*		o Merged with 1.2 version.
*			Added -d switch:  when not specified, does not emit
*			struc definitions for typedef'd items.  This maintains
*			the 'old' h2inc standard.  1.3 will have to specify -d.
*			See above.
*		o Deleted -n switch
*		o switches now lower case only
* Modified:  Floyd Rogers [floydr] - 17-Apr-89
*		o Merged with 2.0 version.
*		    - Added processing of DEFINESOFF/DEFINESON to 2.0 version.
*		o REALLY removed -n switch
* Modified:  Floyd Rogers [floydr] - 18-Apr-89
*		o Fixed bug in processing fields - must emit DW, not just DD
* Modified:  Floyd Rogers [floydr] - 26-Apr-89
*		o Added code to check for string equates.
* Modified:  Floyd Rogers [floydr] - 10-May-89
*		o Fixed error in FindFieldname where compare was (pch == 0)
*		  rather than (*pch == 0)
*		o changed all character compares and assignments of the null
*		  character from 0 to '\000'
*		o beautified the thing by rationalizing all tabs to be at
*		  4 character increments, fixing up switch statements, moving
*		  all open braces to the end of the preceding if/while/do/for.
* Modified:  JR (John Rogers, JohnRo@Microsoft) - 21-Aug-90
*		o PTR B789499: Allow comment to start right after semicolon
*		  in field definition.
*		o Do real processing of unions.  (Don't use nested unions yet.)
*		o Allow "struct sess2{" (no space before brace).
*		o Allow NOINC and INC as synonyms for XLATOFF and XLATON.
*		o Don't break if keyword is part of a token (e.g. mytypedef).
*		o Improved error reporting on initialization errors.
*		o Hungarianized more of the code.
*		o Fixed trivial portability error which C6 caught (*pch==NULL).
*		o Add version number to help text (run "h2inc -?" to display).
*
* Copyright (c) 1987-1990  Microsoft Corporation
\***************************************************************************/

char	H2i1[]="h2inc - .H to .INC file translator (version 13.28)";
char	H2i2[]="     (C) Microsoft Corp 1987, 1988, 1989, 1990";
#define TRUE	1
#define FALSE	0
#define	IsAlpha(c)	(((c|' ') >= 'a') && ((c|' ') <= 'z'))
#define	IsParen(c)	(c == '(' || c == ')')
#define	IsDec(c)	(c >= '0' && c <= '9')
#define	IsSeparator(c)	(c && c != '_' && !IsDec(c) && !IsAlpha(c))
#define	IsHex(c)	(IsDec(c) || (((c|' ') >= 'a') && ((c|' ') <= 'f')))
#define	IsOct(c)	(c >= '0' && c <= '7')
#define	IsOper(c)	(c && c == '<' || c == '>' || c == '!' || c == '&' || \
			 c == '|' || c == ';' || c == '~')
#define	IsWhite(c)	((c) == ' ' || (c) == '\t' || (c) == '\n')
#define VOID void

#define	HEXCON	4
#define	OCTCON	2
#define	DECCON	1
#define	HEX(c)	(c & HEXCON)
#define	OCT(c)	(c & OCTCON)
#define	DEC(c)	(c & DECCON)


#define CCHMAX	    2048
#define CCHSYMMAX   512

#define ICHEQUTAB   20
#define ICHVALTAB   (ICHEQUTAB+4)
#define ICHCMTTAB   (ICHVALTAB+8)

typedef unsigned short BOOL;	/* f */
typedef char CHAR;
typedef int INT;
typedef long LONG;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef CHAR * PSZ;		/* psz - Pointer to zero-terminated string. */

#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
#include <malloc.h>
#include <stdlib.h>
#include <io.h>

/*
 * Structure definition processing stuff
 */
#define CCHALLOCMAX 8192
#define cMaxDD		200
#define cMaxDW		50
#define cMaxDB		20
#define cMaxW_D		20
#define CCHTYPEMAX  512
#define CCHTAGMAX   512
#define CCHINDEXMAX 512
#define CCHNAMEMAX  512
#define CCHBITFIELDMAX	512

#define TYPE_UNKNOWN	0
#define TYPE_DB		1
#define TYPE_DW		2
#define TYPE_DD		3
#define	TYPE_PTR	4

#define COMMENTCHAR ';'

typedef enum {INIT_NONE, INIT_SIMPLE, INIT_ARRAY} INITTYPE;

#define	INT_16	1
#define	INT_32	2

int  cBitfield = 0;
int  cLines = 0;

BOOL fArray = FALSE;
BOOL fcomm_out = FALSE;
BOOL fComment = FALSE;
BOOL fDeftype = FALSE;
BOOL fDefines = FALSE;
BOOL fError = FALSE;
BOOL fIf = FALSE;
BOOL fInTypedef = FALSE;	/* Currently in a typedef? */
BOOL fMac = FALSE;		/* Generate macros for structs */
BOOL fNew = TRUE;		/*	Additions - Jameelh	*/
BOOL fSeg = FALSE;		/* Generate SEGMENTS, if specified */
BOOL fSegAllowed = FALSE;
BOOL fstructtype[32];		/* fTypes if TYPE <..> */
INT  fStruct = 0;
BOOL fUnion  = FALSE;
BOOL fUseIfe = FALSE;
BOOL fWarn = FALSE;

FILE *hfErr = stderr;
FILE *hfIn;
FILE *hfOut = stdout;

INT  int_16_32=0;
INT  ctypeDB=0;
INT  ctypeDD=0;
INT  ctypeDW=0;

CHAR rgchBitfield[CCHBITFIELDMAX];
CHAR rgchIndex[CCHINDEXMAX];
CHAR rgchLine[CCHMAX];
CHAR rgchName[CCHNAMEMAX];
CHAR rgchOut[CCHMAX];
CHAR rgchSave[CCHMAX];
CHAR rgchSym[CCHSYMMAX];
CHAR rgchType[CCHTYPEMAX];
CHAR rgchTag[CCHTAGMAX];
CHAR rgchAlloc[CCHALLOCMAX];
CHAR *pstructname[32];	/* upto 32 nested structs */

CHAR *pchAlloc = rgchAlloc;
CHAR *pchBitfield;
CHAR *pchFileIn;
CHAR *pchFileOut;
CHAR *pchOut;

CHAR *rgpchDD[cMaxDD+1] = {
    "long",
    "unsigned long",
    "LONG",
    "ULONG",
    "ulong_t",
    "FlatAddr",			/* Huh.. */
    NULL
};

CHAR *rgpchDB[cMaxDB+1] = {
    "char",
    "unsigned char",
    "CHAR",
    "BYTE",
    "UCHAR",
    "uchar_t",
    NULL
};

CHAR *rgpchDW[cMaxDW+1] = {
    "short",
    "SHORT",
    "USHORT",
    "ushort_t",
    NULL
};

CHAR *rgpchW_D[cMaxW_D+1] = {		/* DW or DD depending on int_16_32 */
    "int",
    "INT",
    "unsigned",
    "UINT",
    NULL
};

static CHAR *rgpchUsage="Usage: h2inc [-?] [-c] [-d] [-f] [-g] [-m] [-t] [-w] [-s symfile.h] infile.h [-o outfile.inc]\n";

static PSZ pszUnionSizeVar = "?UnionSize";

VOID main(int, unsigned char**);
CHAR *fgetl(CHAR*, int, FILE*);
CHAR *fgetlx(CHAR*, int, FILE*);
VOID OpenFile(CHAR *);
VOID Translate(void);
VOID ProcessLine(void);
VOID PrintString(CHAR *);
PSZ  FindString(PSZ, PSZ, BOOL);
PSZ  FindWord(PSZ, PSZ);
BOOL DoComment(void);
VOID DoAsm(CHAR *);
VOID OutTab(void);
VOID OutString(CHAR *);
CHAR *GetToken(CHAR *, PSZ, INT);
CHAR *SkipWhite(CHAR *);
VOID OutFlush(void);
BOOL IsLongConstant(CHAR *);
VOID Error(PSZ);
VOID Warning(CHAR *);
VOID OutEqu(void);
CHAR *IsBitfield(CHAR *);
VOID DoBitfield(CHAR *, CHAR *);
CHAR **CalcType2(CHAR *, CHAR **);
INT  CalcType(CHAR*);
VOID FixSizeof(CHAR *);
VOID FixCast( CHAR * );
VOID DoIf(CHAR*);
VOID DoIfLine(CHAR*);
VOID DoInclude(CHAR*);
VOID OutBitfield(void);
VOID DoSimpleType(CHAR*);
VOID AddType(CHAR*, CHAR**);
VOID DoDefine(CHAR*);
VOID DoStruct(CHAR*, BOOL);
VOID DoUnionDefn(void);
VOID DoUnionFieldDefn(INT, PSZ, PSZ);
VOID DoDoneUnion(PSZ, BOOL);
VOID DoStructLine(CHAR*);
VOID EmitStrucHeader(PSZ, BOOL);
VOID EmitStrucTrailer(PSZ, PSZ);
VOID EmitSizeAsMod(INT);
VOID EmitSizeAsNum(INT, PSZ);
VOID getInitVal(PSZ, PSZ);
BOOL PublicField(CHAR*);
INITTYPE GetInitType(CHAR*);
BOOL IsStructPtr(CHAR*);
BOOL IsStructDefn(CHAR*);
VOID GetFieldName(CHAR*);
VOID DumpBitfields(void);
VOID OutVal(CHAR *);
VOID OutDiscard(void);
VOID initerror(void);
VOID DoNoInc(void);
VOID DoXlatOff(void);
VOID DoExtern(CHAR*);
VOID DoDefinesOff(void);




VOID main(argc, argv)
int argc;
unsigned char *argv[];
{
    char	*pchtmp;
    BOOL	InpOpened, OtpOpened;
    FILE	*hfOutSave;
#ifdef	DEBUG
    extern	int3();

    int3();
#endif
    InpOpened = OtpOpened = FALSE;

    argc--; argv ++;		/* Skip over invocation */
    while (argc > 0) {
	if (**argv == '-') {
	    switch (*(*argv+1)) {
		case 's':
		    if (argc < 2)
			initerror();
		    OpenFile(*++argv);
		    hfOutSave = hfOut;
		    hfOut = NULL;
		    Translate();
		    argv++; argc -= 2;
		    fclose(hfIn);
		    hfOut = hfOutSave;
		    break;

		case 'd':
		    fDeftype = TRUE;
		    argv++; argc--;
		    break;
		case 'f':
		    int_16_32 = INT_32;
		    argv++; argc--;
		    break;
		case 'g':
		    fSegAllowed = TRUE;
		    argv++; argc--;
		    break;

		case 'm':
		    fMac = TRUE;
		    argv++; argc--;
		    break;

		case 't':
		    fNew = FALSE;
		    argv++; argc--;
		    break;

		case 'c':
		    fcomm_out = TRUE;
		    argv++; argc--;
		    break;

		case 'w':
		    fWarn = TRUE;
		    argv++; argc--;
		    break;

		case 'o':
		    if (argc < 2 || OtpOpened)
			initerror();
		    OtpOpened = TRUE;
		    hfErr = stdout;
		    pchFileOut = *++argv;
		    pchtmp = mktemp("H2XXXXXX");
		    if ((hfOut = fopen(pchtmp, "w")) == NULL) {
			fprintf(hfErr, "Can't open temp file %s\n", pchtmp);
			exit(1);
		    }
		    argv++; argc -= 2;
		    break;

		case '?':
		    fprintf(hfErr, "\n%s\n%s\n\n", H2i1, H2i2);
		    fprintf(hfErr, rgpchUsage);
		    fprintf(hfErr, "\tc - Emit assembler comments (Default no comments)\n");
		    fprintf(hfErr, "\td - Emit DEFTYPE/struc for typedefs\n");
		    fprintf(hfErr, "\tf - Default size of 'int' is 32 bits\n");
		    fprintf(hfErr, "\tg - Segment directives allowed\n");
		    fprintf(hfErr, "\tm - Generate macros for structs\n");
		    fprintf(hfErr, "\tt - Don't handle typedef'd structs\n");
		    fprintf(hfErr, "\to - Output file follows\n");
		    fprintf(hfErr, "\ts - Symbol file follows\n");
		    fprintf(hfErr, "\tw - Emit warnings (default no warnings)\n");
		    fprintf(hfErr, "\t? - Print this message\n");
		    exit(0);
		default:
		    initerror();
		    break;
	    }
	}
	else {
	    if (InpOpened)
		initerror();
	    else {
		OpenFile(*argv);
		argc--; argv++;
		InpOpened = TRUE;
	    }
	}
    }
    if (!InpOpened)
	initerror();

/*
    fprintf(hfErr, "%s\n"%s\n", h2i1, h2i2);
*/

    Translate();
    fclose(hfIn);

    /*
     * Close the files, and then rename temp file to new file
     */
    fflush(hfOut);
    if (ferror(hfOut)) {
	fprintf(hfErr, "Error writing %s\n", pchtmp);
	exit(1);
    }
    fcloseall();

    if (!fError) {
	if ((hfOutSave=fopen(pchFileOut, "r")) > 0) {
	    fclose(hfOutSave);
	    if (unlink(pchFileOut) < 0) {
		unlink(pchtmp);
		fprintf(hfErr, "Can't unlink %s\n", pchFileOut);
		exit(1);
	    }
	}
	rename(pchtmp, pchFileOut);
    }
    exit(fError);

} /* main() */

VOID initerror()
{
    fprintf(hfErr, rgpchUsage);
    exit(1);
}

VOID Translate()
{
    *rgchLine = '\000';
    while (fgetlx(rgchLine, CCHMAX, hfIn))
	ProcessLine();
}

VOID OpenFile(szFilename)
char *szFilename;
{
    pchFileIn = szFilename;
    if ((hfIn = fopen(pchFileIn, "r")) == NULL) {
	fprintf(hfErr, "Can't open input file %s\n", pchFileIn);
	exit(1);
    }
}

/* Process a line, or more than one in some cases. */
VOID ProcessLine()
{
    CHAR *pch;
    CHAR buf[128];

    cLines++;

    pchOut = rgchOut;

    /*
     * Skip white space
     */

    if (*rgchLine == '\000' || ((*rgchLine == '\n') && !fcomm_out))
	return;
    pch = SkipWhite(rgchLine);
    if (*pch == '\000') {
	if (!fcomm_out)
	    return;
	rgchLine[0] = '\0';
    }

    if (DoComment())
	return;
    /*
     * If null comment line, just return
     */

    pch = SkipWhite(rgchLine);

    if (!fComment && *pch == '\000')
	return;

    if (pch[0] == COMMENTCHAR) {
	buf[0] = '\000';
	pch = GetToken(pch, buf, 2);
	if (!strcmp(buf, "ASM") || (fSegAllowed && !strcmp(buf, "GASM")) ||
			(!fSegAllowed  && !strcmp(buf, "!GASM"))) {
	    pch=SkipWhite(pch);
	    DoAsm(pch);
	    return;
	}
	if (!strcmp(buf, "DEFINESOFF")) {
	    DoDefinesOff();
	    return;
	}
	if (!strcmp(buf, "NOINC")) {
	    DoNoInc();
	    return;
	}
	if (!strcmp(buf, "XLATOFF")) {
	    DoXlatOff();
	    return;
	}
	if (!int_16_32) {
	    if (!strcmp(buf, "INT16"))
		int_16_32 = INT_16;
	    else if (!strcmp(buf, "INT32"))
		int_16_32 = INT_32;
	}
	if (fcomm_out) {
	    OutString(rgchLine);
	    OutFlush();
	    return;
	}
	else
	    return;
    }

    if (FindWord("#undef", rgchLine)) {
	return;
    }

    if (FindWord("#include", rgchLine)) {
	DoInclude(rgchLine);
	return;
    }

    if (FindWord("#define", rgchLine)) {
	DoDefine(pch);
	return;
    }

    /*
     * Handle extern before struct/union, so we don't get confused by
     * "extern void flarp(struct x_s x);".
     */
    if (FindWord("extern", rgchLine) != NULL) {
	DoExtern(rgchLine);
	return;
    }

    if (FindWord("union", rgchLine) != NULL) {
	DoStruct(rgchLine, TRUE);
	return;
    }

    if (FindWord("struct", rgchLine) != NULL) {
	DoStruct(rgchLine, FALSE);
	return;
    }

    if (FindWord("typedef", rgchLine) != NULL) {
	DoSimpleType(rgchLine);
	return;
    }

    if (FindWord("#if", rgchLine) != NULL) {
	DoIf(rgchLine);
	return;
    }

    if (fIf)
	DoIfLine(rgchLine);

    /*
     * Handle #ifndef, #else, #endif, etc.
     *
     */
    pch = SkipWhite(rgchLine);
    if (*pch == '#') {
	OutString(pch + 1);
	OutFlush();
	return;
    }

    if (fNew || fStruct)
	DoStructLine(rgchLine);
}

VOID PrintString(pch)
register CHAR *pch;
{
    if (hfOut != NULL) {
	while (*pch != '\000')
	    putc(*pch++, hfOut);
	putc('\n', hfOut);
    }
}

VOID Warning(sz)
CHAR *sz;
{
    if (fWarn) {
	fprintf(hfErr, "\n%s(%d) : Warning: %s:", pchFileIn, cLines, sz);
	fprintf(hfErr, "\n>>> %s <<<\n\n", rgchLine);
    }
}

VOID Error(psz)
PSZ psz;
{
    fprintf(hfErr, "\n%s(%d) : Error: %s:", pchFileIn, cLines, psz);
    fprintf(hfErr, "\n>>> %s <<<\n\n", rgchLine);
    fError = TRUE;
}

VOID OutTab()
{
    *pchOut++ = '\t';
}

VOID OutString(pch)
register CHAR *pch;
{
    while (*pch != '\000' && pchOut < &rgchOut[CCHMAX]) {
	if (*pch == COMMENTCHAR && !fcomm_out)
	    break;
	*pchOut++ = *pch++;
    }

    if (pch == &rgchOut[CCHMAX]) {
	*--pch = '\000';
	Error("Output line too long");
    }
}

VOID OutEqu()
{
    OutString("\tEQU\t");
}

PSZ FindString(pszKey, pchStart, fToken)
PSZ pszKey;
PSZ pchStart;
BOOL fToken;
{
    register INT cch;
    register CHAR *pch;

    pch = pchStart;
    cch = strlen(pszKey);

    while ((pch = strchr(pch, *pszKey)) != NULL) {
	/*
	 * If rest of string matches, then we have a match
	 */
	if (strncmp(pch, pszKey, cch) == 0) {
	    if (!fToken ||
		    ((pch == pchStart || IsWhite(*(pch - 1))) &&
		    (pch[cch] == '\000' || IsWhite(pch[cch])))) {
		return(pch);
	    }
	}
	pch++;
    }
    return(NULL);
}

/*
 * FindWord: Search for a word (not part of another word).
 * Note that this also works for words beginning with "#", e.g. "#define".
 * Unfortunately, this doesn't know about comments or string constants.
 */
PSZ FindWord(pszKey, pszStart)
PSZ pszKey;
PSZ pszStart;
{
    register INT cch;
    register CHAR *pch;

    pch = pszStart;
    cch = strlen(pszKey);

    while ((pch = strchr(pch, *pszKey)) != NULL) {
	/*
	 * If rest of string matches, then we have a match
	 */
	if (strncmp(pch, pszKey, cch) == 0) {
	    /* Insist on this being an exact match. */
	    if ( (pch == pszStart || !iscsymf(*(pch - 1))) &&
		 (pch[cch] == '\000' || !iscsym(pch[cch])) ) {
		return (pch);
	    }
	}
	pch++;
    }
    return (NULL);
}

CHAR *SkipWhite(buf)
register CHAR *buf;
{
    while (isspace(*buf))
	buf++;
    return(buf);
}

VOID OutDiscard()
{
    pchOut = rgchOut;
}

VOID OutFlush()
{
    *pchOut++ = '\000';

    PrintString(rgchOut);

    pchOut = rgchOut;
}

BOOL IsLongConstant(pch)
register CHAR *pch;
{
    while (*pch != '\000' && *pch != COMMENTCHAR) {
	if (*pch == 'L' || *pch == 'l')
	    return(TRUE);
	pch++;
    }
    return(FALSE);
}

CHAR *GetToken(pch, pszToken, cSkip)
register CHAR *pch;
PSZ pszToken;
INT cSkip;
{
    CHAR *pchEnd;
    register CHAR *pchStart;

    pchStart = pchEnd = pch;
    assert(cSkip > 0);
    while (cSkip-- > 0) {
	/*
	 * Skip leading whitespace
	 */
	while (isspace(*pch))
	    pch++;

	pchStart = pch;

	/*
	 * Depending of type of token, scan it.
	 */
	if (iscsymf(*pchStart)) {
	    /* It's an identifier or keyword... */
	    while (*pch != '\000' && iscsym(*pch))
		pch++;

	} else if (*pchStart=='#') {
	    /*
	     * Preprocessor stuff (e.g. "#define") is treated as 1 token here.
	     */
	    pch++;
	    while (*pch != '\000' && iscsym(*pch))
		pch++;

	} else if (IsDec(*pchStart)) {
	    /* Must be a number, e.g. "0xffFF" or "1L". */
	    while (*pch != '\000' && (IsHex(*pch)
				      || ((*pch | ' ') == 'x')
				      || ((*pch | ' ') == 'l')))
		pch++;

	} else if (!strncmp(pch, "!GASM", 5)) {
	    /*
	     * Special case, treat as 1 token.  We might regret this later,
	     * if GASM turns out to be the first 4 letters of a variable.
	     */
	    pch++;
	    while (*pch != '\000' && iscsym(*pch))
		pch++;

	} else {
	    /*
	     * Must be punctuation of some kind.
	     * Look for contiguous puncuation (e.g. "/*" or "*++").
	     */
	    while (*pch != '\000' && (!isspace(*pch)) && IsSeparator(*pch))
		pch++;
	}
	pchEnd = pch;
    }

    while (pchStart != pch)
	*pszToken++ = *pchStart++;

    *pszToken = '\000';
    return(pchEnd);
}

BOOL DoComment()
{
    register CHAR *pch;

    if (fComment && *rgchLine && !(*rgchLine == '*' && rgchLine[1] == '/'))
	rgchLine[0] = COMMENTCHAR;

    if (!fComment && (pch=FindString("//", rgchLine, FALSE))) {
	*pch++ = COMMENTCHAR;
	*pch = ' ';
	return (FALSE);
    }

    if ((pch = FindString("/*", rgchLine, FALSE)) != NULL) {
	pch[0] = COMMENTCHAR;
	if (pch[2] != '*')
	    pch[1] = ' ';
	fComment = TRUE;
    }

    if (pch = FindString("*/", rgchLine, FALSE)) {
	pch[0] = ' ';
	pch[1] = ' ';
	fComment = FALSE;
    }

    return(FALSE);
}


VOID DoDefine(pch)
register CHAR *pch;
{
    register CHAR *pchVal;
    CHAR *pchT;
    CHAR rgchT[128];
    int	fString=FALSE;

    /*
     * Skip "#define" (1 token) and get name (2nd token) being #define'd into
     * rgchSym.
     */
    pchVal = GetToken(pch, rgchSym, 2);
    if ( (*rgchSym) == '\000')
	Error("#define without name");

    /* Make sure this isn't a macro with arguments. */
    if ( (*pchVal) == '(') {
	Warning("Macros with parameters - ignored");
	return;
    }

    pchVal = SkipWhite(pchVal);		/* Skip space (if any) after name. */

    if (*pchVal == '"')
	fString = TRUE;

    if (fDefines) {
	if (IsAlpha(*pchVal) || *pchVal == '_') {
	    Warning("Define of symbol to symbol - ignored");
	    return;
	}
	if (*pchVal == '(') {
	    strcpy(rgchT, pchVal);
	    FixSizeof(rgchT);
	    FixCast(rgchT);
	    pchT = SkipWhite(rgchT);
	    while (*pchT == '(')
		pchT = SkipWhite(++pchT);

	    if (strncmp(pchT,"SIZE ", 5) && (IsAlpha(*pchT) || *pchT == '_')) {
		Warning("Define of symbol to symbol - ignored");
		return;
	    }
	}
    }

    OutString(rgchSym);
    OutEqu();
    if (*pchVal == '\000' || *pchVal == COMMENTCHAR) {
	*pchOut++ = '1';
	OutFlush();
    }
    if (fString) {
	*pchOut++ = '<';
	*pchOut++ = *pchVal++;
	if (*pchVal != '"') {
	    do {
		if (*pchVal == '\\')
		    pchVal++;
		*pchOut++ = *pchVal++;
	    } while (*pchVal != '"');
	}
	*pchOut++ = *pchVal++;
	*pchOut++ = '>';
	OutFlush();
    }
    else
	OutVal(pchVal);		/* process text, skip		*/
}

VOID OutVal(pch)
char	*pch;
{
    BOOL	con;

    FixSizeof(pch);
    FixCast( pch );			/* Remove them */
    while (*pch && *pch != ';') {
	con = DECCON;		/* default decimal */
	if (IsDec(*pch)) {
	    if (*pch == '0') {	/* could be octal or hex */
		pch ++;
		if ((*pch | ' ') == 'x') {
		    con = HEXCON; pch ++;
		    if (!IsDec(*pch))
			*pchOut++ = '0';
		}
		else if (IsOct(*pch))
			con = OCTCON;
		else
		    *pchOut++ = '0';
	    }
	    while ( *pch && ( (HEX(con) && IsHex(*pch)) ||
			      (OCT(con) && IsOct(*pch)) ||
			      (DEC(con) && IsDec(*pch))) )
		*pchOut++ = *pch++;

	    if (OCT(con))
		*pchOut++ = 'Q';
	    else if (HEX(con))
		*pchOut++ = 'H';

	    *pchOut++ = ' ';
	    if (*pch == 'L')
		pch++;
	}
	else if (*pch == '>') {
	    switch (pch[1]) {
		case '>':
		    OutString(" SHR ");
		    pch += 2;
		    break;
		case '=':
		    OutString(" GE ");
		    pch += 2;
		    break;
		default:
		    OutString(" GT ");
		    pch++;
		    break;
	    }
	}
	else if (*pch == '<') {
	    switch (pch[1]) {
		case '<':
		    OutString(" SHL ");
		    pch += 2;
		    break;
		case '=':
		    OutString(" LE ");
		    pch += 2;
		    break;
		default:
		    OutString(" LT ");
		    pch++;
		    break;
	    }
	}
	else if (*pch == '=' && pch[1] == '=') {
	    OutString(" EQ ");
	    pch += 2;
	}
	else if (*pch == '!' && pch[1] == '=') {
	    OutString(" NE ");
	    pch += 2;
	}
	else if (*pch == '!') {
	    OutString(" NOT ");
	    pch ++;
	    Warning("Bitwise NOT used for '!'");
	}
	else if (*pch == '~') {
	    OutString(" NOT ");
	    pch ++;
	}
	else if (*pch == '&' && pch[1] != '&') {
	    OutString(" AND ");
	    pch ++;
	}
	else if (*pch == '|' && pch[1] != '|') {
	    OutString(" OR ");
	    pch ++;
	}
	else {
	    while (*pch && !IsSeparator(*pch))
		*pchOut++ = *pch++;
	    while (*pch && IsSeparator(*pch) && !IsOper(*pch))
		*pchOut++ = *pch++;
	}
    }
    if (*pch == ';' && fcomm_out)
	    OutString(pch);
    OutFlush();
}

VOID DoStruct(pch, fUnionT)
register CHAR *pch;
BOOL fUnionT;
{
    CHAR buf[128];

    if (!IsStructDefn(pch)) {
	if (FindWord("typedef", pch))	/*  || IsStructPtr(pch) */
	    DoSimpleType(pch);
	else
	    DoStructLine(pch);
	return;
    }
    fUnion = fUnionT;
    fInTypedef = (BOOL)FindWord("typedef", rgchLine);
    fSeg = FALSE;
    if (fUnion)
	DoUnionDefn();

     /*	If fNew is set
      * Handle simple structs - i.e. without typedefs now
      * Names are maintained - no prepend tag is necessary
      * Else simple structs - without typedef are ignored
      */
    if (!fNew && !fInTypedef)
	return;

    /*
     * Skip "struct" or "typedef struct" and get structure name
     */
    pch = GetToken(pch, rgchType, (fInTypedef ? 3 : 2));

    *rgchTag = '\000';
    if (!fNew) {
	/*
	 * Skip curly brace & semicolon
	 */
	pch = GetToken(pch, rgchTag, 2);
	if (rgchTag[0] != COMMENTCHAR) {
	    Error("Missing type prefix in structure definition");
	    return;
	}
	/*
	 * Now fetch hungarian tag
	 */
	pch = GetToken(pch, rgchTag, 1);
    }
    else if (fSegAllowed) {	/* check for segment directive */
	pch = GetToken(pch, rgchTag, 2);
	if (rgchTag[0] != COMMENTCHAR) {
	    *rgchTag = '\000';
	    goto go1;
	}
	pch = GetToken(pch, rgchTag, 1);
	if (strcmp(rgchTag, "SEGMENT") != 0) {
	    *rgchTag = '\000';
	    goto go1;
	}
	pch = GetToken(pch, rgchType, 1);
	*rgchTag = '\000';
	sprintf(buf, "%s\tSEGMENT", rgchType);
	OutString(buf);
	OutFlush();
	fSeg = TRUE;
	goto go2;
    }
    if (!fNew && rgchTag[0])
	strcat(rgchTag, "_");
    if (fUnion)
	goto go2;	/* Don't output STRUC/etc yet. */
go1:

    /*
     * Output "TYPE struc"
     */
    if (!fNew)
	sprintf(buf,"\n%s\tSTRUC",(*rgchType == '_')?rgchType+1:rgchType);
    else {
	if (fInTypedef && fMac)
	    sprintf(buf, "\nDEFSTRUC\t,%s", rgchType);
	else
	    sprintf(buf, "\n%s\tSTRUC", rgchType);
    }
    OutString(buf);
    OutFlush();
go2:
    if (fNew) {
	pstructname[fStruct] = malloc(strlen(rgchType)+1);
	if (pstructname[fStruct] == NULL) {
	    Error("Can't allocate memory");
	    exit(2);
	}
	fstructtype[fStruct] = fInTypedef;
	strcpy(pstructname[fStruct++], rgchType); /* save away struct name */
    }
    else
	fStruct = TRUE;
    cBitfield = 0;
    pchBitfield = rgchBitfield;
    return;
}

BOOL	IsStructPtr(pch)
char	*pch;
{
    char	cbuf[128];

    if (GetToken(pch, cbuf, 2) == NULL)
	return (FALSE);
    if (cbuf[0] == '*')
	return (TRUE);
    else
	return (FALSE);
}

BOOL IsStructDefn(pch)
CHAR	*pch;
{
    if (FindString("{", pch, FALSE))
	return (TRUE);
    else
	return (FALSE);
}

VOID DoStructLine(pch)
register CHAR *pch;
{
    CHAR *pchT;
    CHAR *pComm;
    CHAR *pType;
    register INT type;
    INITTYPE InitType;
    char initval[100];

    /*
     * If the line has a colon in it, then we have a bitfield.
     */
    InitType = INIT_NONE;

    if ((pchT = IsBitfield(pch))) {

	if (cBitfield == -1) {
	    Error("Only one set of bitfields per structure allowed");
	    return;
	}

	while ((pchT = IsBitfield(pch))) {
	    DoBitfield(pch, pchT);
	    if (!fgetl(rgchLine, CCHMAX, hfIn))
		break;
	}

	OutTab();
	if (fNew) {
	    OutString(pstructname[fStruct-1]);
	    *pchOut++ = '_';
	}
	else
	    OutString(rgchTag);
	OutString("fs");
	OutTab();
	if (cBitfield <= 16)
	    OutString("DW  ?");
	else
	    OutString("DD  ?");
	OutFlush();
	cBitfield = -1;			/* flag bitfield emitted	*/
	/* Now drop through to process the next line			*/
    }
    pComm = FindString(";", pch, FALSE);

    /*
     * If we find a curly brace, then time for "ends"
     */
    if ((pType = strchr(pch, '}')) != NULL) {
	if (fUnion) {
	    /*
	     * OK, now we finally know how large it is, so we can emit the
	     * STRUC..ENDS stuff.
	     */
	    DoDoneUnion(rgchType,	/* pszTag */
			fInTypedef);
	    fUnion = FALSE;
	    goto out;
	}

	/*
	 * Output "TYPE ends"
	 */
	if (!fNew) {
	    /* remove underscore if one is present */
	    OutString((*rgchType == '_')?rgchType+1:rgchType);
	    OutString("\tENDS");
	    fStruct = FALSE;
	}
	else {
	    if (fstructtype[fStruct-1] && fMac) {
		pType = GetToken(pType, initval, 2);
		OutString("ENDSTRUC\t");
		OutString(initval);
		*pchOut++ = '\n';
		goto out;
	    }
	    else {
		OutString(pstructname[--fStruct]);
		OutString("\tENDS\n");
		free(pstructname[fStruct]);
		goto out;
	    }
	}
    out:
	OutFlush();

	DumpBitfields();

	return;
    }

    /*
     * Figure out what type the thing is.
     */
    type = CalcType(pch);
    /*
     * Get field name and index, if any
     */
    GetFieldName(pch);
    if (fSeg) {
	if (PublicField(pch)) {
	    OutString("\tPUBLIC  ");
	    OutString(rgchName);
	    OutFlush();
	}
	if ( (InitType=GetInitType(pch)) != INIT_NONE )
	    getInitVal(pch, initval);
    }

    if (fUnion == FALSE) {
	OutString(rgchTag);
	OutString(rgchName);
	OutTab();
    } else {
	DoUnionFieldDefn(type,
			rgchSym,	/* pszFieldType (struct/union name). */
			rgchName);	/* pszFieldName */
	goto DoneField;
    }

    switch (type) {
	case TYPE_DB:
	    OutString("DB\t");
	    goto common;
	    break;

	case TYPE_DW:
	    OutString("DW\t");
	    goto common;
	    break;

	case TYPE_DD:
	    OutString("DD\t");
	common:
	    if (fArray && (InitType != INIT_ARRAY))
		OutString(rgchIndex);
	    if (InitType == INIT_NONE) {
		if (fArray)
		    OutString(" DUP (?)");
		else
		    OutString("?");
	    }
	    else {
		if (InitType == INIT_ARRAY) {
		    if (!fArray)
			Error("Initialization error (AINIT on nonarray type)");
		    else
			OutString(initval);
		    }
		else {
		    if (fArray)
			OutString(" DUP (");
		    OutString(initval);
		    if (fArray)
			OutString(")");
		    break;
		}
	    }
	    break;

	case TYPE_UNKNOWN:
	    if (fMac && !FindWord("struct", pch)) {
		OutDiscard();
		OutString(rgchSym);
		OutTab();
		OutString(rgchName);
		if (fArray) {
		    OutString(",,");
		    OutString(rgchIndex);
		}
	    }
	    else {
		if (!fStruct) {
		    OutString(rgchSym);
		    if (!fArray && (InitType==INIT_NONE))
			OutString(" <>");
		    else if ((InitType==INIT_NONE) && fArray) {
			OutString(" * ");
			OutString(rgchIndex);
			OutString("DUP (<>)");
		    }
		    else
			Error("Initialization error (1)");
		}
		else {
		    if (InitType!=INIT_NONE)
			Error("Initialization error (2)");
		    OutString("DB\tSIZE ");
		    OutString(rgchSym);
		    if (fArray) {
			OutString(" * ");
			OutString(rgchIndex);
		    }
		    OutString(" DUP (?)");
		}
	    }
	    break;

	default:
	    break;
    }
DoneField:
    if (fcomm_out) {
	pComm++;
	OutString(pComm);
    }
    OutFlush();
    if ((InitType == INIT_ARRAY) && fArray) {
	sprintf(initval, "\t.ERRNZ  ($-%s) - (%s * %s)", rgchName,
		rgchIndex, type==TYPE_DB?"1":type==TYPE_DW?"2":type==TYPE_DD?
		"4":rgchSym);
	OutString(initval);
	OutFlush();
    }
}

VOID DoUnionDefn(void)
{
    OutString(pszUnionSizeVar);
    OutString(" = 0");
    OutFlush();
}

VOID DoUnionFieldDefn(
    INT type,				/* TYPE_DW, etc. */
    PSZ pszFieldType,
    PSZ pszFieldName)
{
    OutString("if ");
    EmitSizeAsNum(type, pszFieldType);
    OutString(" gt ");
    OutString(pszUnionSizeVar);
    OutFlush();

    OutString("\t");
    OutString(pszUnionSizeVar);
    OutString(" = ");
    EmitSizeAsNum(type, pszFieldType);
    OutFlush();

    OutString("endif");
    OutFlush();

    OutString(pszFieldName);
    OutString("\tequ\t(");
    EmitSizeAsMod(type);		/* Emit "byte" or whatever. */
    OutString(" ptr 0");		/* Fields in unions always offset 0. */
    OutString(")");
    OutFlush();
}

VOID DoDoneUnion(PSZ pszTag, BOOL fTypedef)
{
    /* Generate "flarp STRUC" or whatever line. */
    EmitStrucHeader(pszTag, fTypedef);

    /* Generate single field, of the max size. */
    OutString("\tDB\t");
    OutString(pszUnionSizeVar);
    OutString(" dup(?)");
    OutFlush();

    /* Now generate ENDS or whatever. */
    EmitStrucTrailer(pszTag, (CHAR *)0);
}

/* Generate start of struct/union. */
VOID EmitStrucHeader(PSZ pszTag, BOOL fTypedef)
{
    CHAR buf[128];

    /*
     * Output "TYPE struc"
     */
    if (!fNew)
	sprintf(buf,"\n%s\tSTRUC",(*pszTag == '_')?pszTag+1:pszTag);
    else {
	if (fTypedef && fMac)
	    sprintf(buf, "\nDEFSTRUC\t,%s", pszTag);
	else
	    sprintf(buf, "\n%s\tSTRUC", pszTag);
    }
    OutString(buf);
    OutFlush();
}

/* Generate end of struct/union. */
VOID EmitStrucTrailer(PSZ pszTag, PSZ pszInitval)
{
    if (!fNew) {
	/* remove underscore if one is present */
	OutString((*pszTag == '_')?pszTag+1:pszTag);
	OutString("\tENDS");
    }
    else {
	if (fstructtype[fStruct-1] && fMac) {
	    OutString("ENDSTRUC\t");
	    OutString(pszInitval);
	}
	else {
	    OutString(pszTag);
	    OutString("\tENDS\n");
	}
    }
    OutFlush();
}

/*
 * Generate size of type as modifier, if possible.  (For a structure,
 * generate a "byte" modifier, instead.)
 */
VOID EmitSizeAsMod(INT type)
{
    switch (type) {
	case TYPE_DB:	
	    OutString("byte");
	    break;
	case TYPE_DW:
	    OutString("word");
	    break;
	case TYPE_DD:
	    OutString("dword");
	    break;
	case TYPE_PTR:
	    Warning("assuming pointer is 4 bytes long");
	    OutString("dword");
	    break;
	case TYPE_UNKNOWN:
	    /* Struct, so treat as byte. */
	    OutString("byte");
    }
}

/*
 * Generate size of type as number, if possible.  (For a structure,
 * generate a "size typename" instead.)
 */
VOID EmitSizeAsNum(INT type, PSZ pszTypeName)
{
    switch (type) {
	case TYPE_DB:	
	    OutString("1");
	    break;
	case TYPE_DW:
	    OutString("2");
	    break;
	case TYPE_DD:
	    OutString("4");
	    break;
	case TYPE_PTR:
	    Warning("assuming pointer is 4 bytes long");
	    OutString("4");
	    break;
	case TYPE_UNKNOWN:
	    OutString("size ");
	    OutString(pszTypeName);
    }
}

VOID DoBitfield(pch, pchColon)
register CHAR *pch;
CHAR *pchColon;
{
    register int w;
    int cbit;
    int	temp;

    GetFieldName(pch);
    OutString(rgchTag);
    OutString(rgchName);
    OutEqu();

    /*
     * Skip ':' and any leading whitespace
     */
    pchColon = SkipWhite(pchColon + 1);

    /*
     * Calc number of bits for the field (handle up to 2 digits)
     */
    if (!isdigit(pchColon[0]))
	Error("Illegal bitfield");

    cbit = pchColon[0] - '0';
    if (isdigit(pchColon[1]))
	cbit = cbit * 10 + pchColon[1] - '0';

    if (cbit + cBitfield > 32) {
	Error("Only 32 bitfield bits allowed");
    }

    /*
     * Calculate mask
     * the field should look like this
     *
     * | 0..0 | 11 .. 11 | 00 ....... 00 |
     *     |<- cbit ->|<- cBitfield ->|
     *
     * If we have a 32 bit C compiler the following would produce the
     * reqd. bit field.
     *
     * w = ((1 << cbit) - 1) << cBitfield;
     *
     * But now we have to split this up. If either cbit + cBitfield <= 16
     * then there is no problem, or cBitfield is > 16 so that we just shift
     * everything appropriately. If neither then we have to divide and rule.
     *
     */
    if (cbit + cBitfield <= 16) {
	w = ((1 << cbit) - 1) << cBitfield;
	pchOut += sprintf(pchOut, "0%xh", w);
    }
    else if (cBitfield > 16) {
	w = (((1 << cbit) - 1) << (cBitfield - 16));
	pchOut += sprintf(pchOut, "0%x0000h", w);
    }
    else {
	temp = cbit;
	cbit = cbit + cBitfield - 16;
	w = ((1 << cbit) - 1);
	pchOut += sprintf(pchOut, "0%04x", w);
	cbit = 16 - cBitfield;
	w = ((1 << cbit) - 1) << cBitfield;
	pchOut += sprintf(pchOut, "%04xh", w);
	cbit = temp;
    }

    cBitfield += cbit;

    OutBitfield();
    pchOut = rgchOut;
    return;

}

CHAR *IsBitfield(pch)
register CHAR *pch;
{
    while (*pch != '\000' && *pch != COMMENTCHAR) {
	if (*pch == ':')
	    return(pch);
	pch++;
    }
    return(NULL);
}

/*
 * Figure out the type of the field.
 * If unknown type, this routine leaves the typename in rgchSym[].
 */
INT CalcType(pch)
register CHAR *pch;
{
    register INT i;
    CHAR     chbuf[128];
    CHAR     token[128];

    for (i=0;pch[i] && pch[i] != ';';i++)
	chbuf[i] = pch[i];
    chbuf[i]=0;

    /*
     * If it has a FAR in it, then assume a DD.
     */
    if (FindWord("FAR", chbuf) != NULL ||
		FindWord("far", chbuf) != NULL)
	return(TYPE_DD);

    /*
     * If no FAR, but it has a star, then PTR
     */

    i=2;
    if (FindWord("typedef", chbuf))
	i++;
    if (FindWord("struct", chbuf) || FindWord("union", chbuf))
	i++;
    if (FindWord( "NEAR", chbuf) || FindWord( "near", chbuf))
	i++;
    GetToken(chbuf, token, i);
    if (token[0] == '*') {
	if (int_16_32 == INT_32)
	    return (TYPE_DD);
	else
	    return (TYPE_DW);
    }

    /*
     * Now look up the type in one of the tables.
     * Note that we search the DD and DB tables before
     * we search the DW table, because "unsigned" may be
     * part of "unsigned long" and "unsigned char".
     */
    if (CalcType2(chbuf, rgpchDD) == 0)
	return(TYPE_DD);

    if (CalcType2(chbuf, rgpchDB) == 0)
	return(TYPE_DB);

    if (CalcType2(chbuf, rgpchDW) == 0) {
	return(TYPE_DW);
    }
    if (CalcType2(chbuf, rgpchW_D) == 0) {
	if (int_16_32 == INT_32)
	    return(TYPE_DD);
	else if (!int_16_32)
	    Warning("int/unsigned assumed DW");
	return(TYPE_DW);
    }

    /*
     * An unknown type: must be a structure.
     * Return the type name in rgchSym
     */
    i = 1;
    if (FindWord("typedef", chbuf))
	i++;
    if (FindWord("struct", chbuf))
	i++;
    else if (FindWord("union", chbuf))
	i++;
    GetToken(chbuf, rgchSym, i);

    return(TYPE_UNKNOWN);
}

/*
 * This nifty little function searches the "symbol table"
 * and returns NULL if the thing is found, or the pointer to the
 * end of the symbol table if not.
 */
CHAR **CalcType2(pch, rgpch)
CHAR *pch;
register CHAR **rgpch;
{
    register INT i;

    /*
     * One of the DWORD types?
     */
    for (i=0 ; rgpch[i]!=NULL ; i++) {
	if (FindString(rgpch[i], pch, TRUE) != NULL) {
	    return(NULL);
	}
    }
    return(&rgpch[i]);
}

/*
 * Find name part of field definition, and store in rgchName.
 * Also calculates whether this is an array or not, returning
 * the array index string in rgchIndex.  Sets fArray (global).
 */

VOID GetFieldName(pch)
register CHAR *pch;
{
    register CHAR *pchT;
    CHAR *pchStart;
    CHAR *pchEnd;

    pchStart = pch;
    /*
     * Find name part of field.  We do this by scanning ahead for the
     * semicolon, then backing up to first separator char.
     * Bitfields are handled here too, by stopping if we find a ':'.
     */

    while (*pch != COMMENTCHAR && *pch != ':') {
	if (*pch == '\000') {
	    Error("Missing semicolon");
	    return;
	}
	pch++;
    }

    /*
     * Back up past spaces
     */
    while (*(pch - 1) == ' ')
	pch--;

    fArray = FALSE;

    /*
     * Check for array definition:
     */
    if (*(pch - 1) == ']') {

	fArray = TRUE;

	/*
	 * Back up over array index
	 */
	while (*(pch - 1) != '[' && pch != pchStart)
	    pch--;

	/*
	 * remember pointer to '['..
	 */
	pchEnd = pch - 1;

	/*
	 * Save index string away...
	 */
	for (pchT = rgchIndex; *pch != ']'; )
	    *pchT++ = *pch++;
	*pchT = '\000';

	pch = pchEnd;
	FixSizeof(rgchIndex);
    }

    /*
     * Back up past spaces
     */
    while (*(pch - 1) == ' ')
	pch--;

    /*
     * Skip over proc declaration parameter lists
     */
    if (*(pch - 1) == ')') {
	/*
	 * Skip the parameter list
	 */
	while (*(--pch) != '(' && pch != pchStart)
	    ;
	/*
	 * Skip any leftover trailing parens
	 */
	while (*(pch - 1) == ')')
	    pch--;
    }

    /*
     * Remember the end of the name
     */
    pchEnd = pch;

    /*
     * Scan the rest of the string to see if he has multiple fields on a line
     */
    for (pchT = pchStart; pchT != pchEnd; pchT++) {
	if (*pchT == ',') {
	    Error("Only one field per line allowed");
	    return;
	}
    }

    /*
     * Now find the beginning of the name string...
     */
    while (pch>pchStart &&
	*(pch - 1) != ' ' && *(pch - 1) != '(' && *(pch - 1) != '*') {

	pch--;
	/*
	 * If this is a bitfield guy, then reset pchEnd
	 */
	if (*pch == ':')
	    pchEnd = pch;
    }

    /*
     * Copy the name to rgchName.
     */
    for (pchT = rgchName; pch != pchEnd && pchT<&rgchName[CCHNAMEMAX-1]; )
	*pchT++ = *pch++;
    *pchT++ = '\000';

    return;
}

/*
 * This routine sticks the newly defined type in the appropriate array.
 */

VOID DoSimpleType(pch)
register CHAR *pch;
{
    INT type;
    CHAR **ppch;
    CHAR buf[128];
    char *ptype;

    /*
     * First see if this thing already has a type
     */

    GetFieldName(pch);

    ptype = NULL;
    switch (type = CalcType(pch)) {
	case TYPE_DW:
	    if ((ppch = CalcType2(rgchName, rgpchDW)) != NULL) {
		if (++ctypeDW < cMaxDW)
		    AddType(rgchName, ppch);
		else
		    fprintf(hfErr, "Error - no room in symbol table - type %s not added\n", rgchName);
	    }
	    ptype = "dw";
	    break;
	case TYPE_DD:
	    if ((ppch = CalcType2(rgchName, rgpchDD)) != NULL) {
		if (++ctypeDD < cMaxDD)
		    AddType(rgchName, ppch);
		else
		    fprintf(hfErr, "Error - no room in symbol table - type %s not added\n", rgchName);
	    }
	    ptype = "dd";
	    break;
	case TYPE_DB:
	    if ((ppch = CalcType2(rgchName, rgpchDB)) != NULL) {
		if (++ctypeDB < cMaxDB)
		    AddType(rgchName, ppch);
		else
		    fprintf(hfErr, "Error - no room in symbol table - type %s not added\n", rgchName);
	    }
	    ptype = "db";
	    break;
	case TYPE_UNKNOWN:
	    break;
	default:
	    break;
    }
    if (fDeftype) {
	if (fMac) {
	    sprintf(buf, "DEFTYPE\t%s,%s", rgchName, ptype? ptype : rgchSym);
	}
	else if (ptype) {
	    sprintf(buf, "%s struc\n\t%s ?\n%s ends\n",rgchName,ptype,rgchName);
	}
	else {
	    sprintf(buf, "%s struc\ndb size %s dup(?)\n%s ends\n",
		    rgchName, rgchSym, rgchName);
	}
	OutString(buf);
	OutFlush();
    }
}

VOID AddType(pch, ppch)
register CHAR *pch;
CHAR	**ppch;
{
    INT cch;

    cch = strlen(pch) + 1;

    if (pchAlloc + cch > &rgchAlloc[CCHALLOCMAX]) {
	Error("Symbol table full");
	return;
    }
    strcpy(pchAlloc, pch);
    *ppch = pchAlloc;
    pchAlloc += cch;
    return;
}

/*
 * Because the peice of assembler can't handle EQU's inside of
 * STRUC declarations, we buffer up the bitfield constant definitions
 * in a separate buffer, and dump them out after we output the ENDS.
 */
VOID OutBitfield()
{
    *pchOut = '\000';

    if (pchBitfield-rgchBitfield+strlen(rgchOut) > CCHBITFIELDMAX) {
	Error("Internal error - bitfield name buffer overflow:  bitfield ignored");
	return;
    }
    strcpy(pchBitfield, rgchOut);
    pchBitfield += strlen(rgchOut) + 1;
}

VOID DumpBitfields()
{
    register CHAR *pch;

    for (pch = rgchBitfield; pch != pchBitfield; pch += strlen(pch) + 1) {
	OutString(pch);
	OutFlush();
    }
}

VOID DoInclude(pch)
register char *pch;
{
    register char *pchend;

    OutString("INCLUDE ");
    /*
     * Skip ahead to start of file name
     */
    while (*pch != '\000' && *pch != '"' && *pch != '<')
	pch++;

    /*
     * Skip string delimiter
     */
    pch++;

    /*	pch now points to the beginning of the filename.
     *	scan forward till the delimiter ('"' or '>').
     *	Then scan backwards till a '.' and append it with 'INC'
     */
    pchend = pch;
    while (*pchend != '"' && *pchend != '>')
	pchend++;
    while (*pchend != '.')
	pchend --;
    *++pchend = '\000';
    OutString(pch);
    OutString("INC");
    OutFlush();
}


/*
 * Handle logical ORs...
 */
VOID DoIf(pch)
CHAR *pch;
{
    static cIfTemp = 0;

    if (strchr(pch, '&') != NULL) {
	Error("Can't handle logical ANDs in IFs");
	return;
    }
    if (FindWord("defined", pch) == NULL)
	goto skip;
    strcpy(rgchSym, "IFTEMP00");
    rgchSym[7] += (char)(cIfTemp % 10);
    rgchSym[6] += (char)(cIfTemp / 10);
    cIfTemp++;

    OutString(rgchSym);
    OutString(" = 0");
    OutFlush();
skip:
    fUseIfe = (BOOL)FindString("!(", pch, FALSE);

    fIf = TRUE;

    DoIfLine(pch);
}

VOID DoIfLine(pch)
register CHAR *pch;
{
    BOOL fOutIf;
    BOOL fIfndef;
    BOOL fEx;
    CHAR *pline;

    pline=pch;
    /*
     * If this is the last line of defined()'s, remember to output initial if
     */
    fEx = FALSE;
    fOutIf =  ((strchr(pch, '\\') == NULL));

    if (FindWord("defined", pch) != NULL) {
	while ((pch = FindWord("defined", pch)) != NULL) {

	    /*
	     * If defined is preceded by '!', then use ifndef
	     */
	    fIfndef = (*(pch - 1) == '!');

	    OutString(fIfndef ? "IFNDEF " : "IFDEF ");

	    /* Skip "defined", "(", and get symbol */
	    while (*pch != '\000' && *pch++  != '(')
		;
	    pch = SkipWhite(pch);
	    while (*pch != '\000' && *pch != ' ' && *pch != ')')
		*pchOut++ = *pch++;
	    OutFlush();

	    /*
	     * Now set temporary variable...
	     */
	    OutString(rgchSym);
	    OutString(" = 1");
	    OutFlush();

	    OutString("ENDIF");
	    OutFlush();
	}
    }
    else
	fEx = TRUE;

    if (fOutIf) {
	OutString(fUseIfe ? "IFE " : "IF ");
	if (fEx) {
	    pch = GetToken(pline, rgchSym, 1);
		OutVal(pch);
	}
	else {
	    OutString(rgchSym);
	    OutFlush();
	}
	fIf = FALSE;
    }
}

VOID DoAsm(cline)
char	*cline;
{
    CHAR	line[128];
    CHAR	*pch, *pch1;

    if (fComment) {		/* fComment => that we are still within
			       a comment => its not a single line ASM */
	OutString(cline);
	while (cLines++ && fgetl(line,sizeof(line) , hfIn)) {
	    pch = SkipWhite(line);
	    if (pch1=FindString("*/", pch, FALSE)) {
		*pch1 = '\000';
		OutString(line);
		OutFlush();
		fComment = FALSE;
		return;
	    }
	    else {
		OutString(line);
		OutFlush();
	    }
	}
    }
    else {	/* Single line ASM */
	OutString(cline);
	OutFlush();
	return;
    }
}

BOOL PublicField(Str)
CHAR	*Str;
{
    char	*pch;

    if (pch = FindString(";", Str, FALSE)) {
	if (FindWord("PUBLIC", pch) != NULL)
	    return (TRUE);
	else
	    return (FALSE);
    }
    else
	return (FALSE);
}

INITTYPE GetInitType(pch)
CHAR	*pch;
{
    if (FindWord("AINIT", pch))
	return (INIT_ARRAY);
    if (FindWord("INIT", pch))
	return (INIT_SIMPLE);
    else
	return (INIT_NONE);		/* No init (same value as FALSE). */
}

VOID getInitVal(pch, val)
PSZ	pch;
PSZ	val;
{
    CHAR	*pval;

    pval = val;
    *pval = '\000';
    {
	PSZ pszInitOrAInit;

	pszInitOrAInit = FindWord("INIT", pch);
	if (pszInitOrAInit == NULL)
	    pszInitOrAInit = FindWord("AINIT", pch);
	pch = pszInitOrAInit;
	if (pch == NULL) {
	    Error("Initialization error (bug in getInitVal/caller?)");
	    return;
	}
    }

    pch = FindString("<", pch, FALSE);
    if (pch == NULL) {
	Error("Initialization error (missing '<')");
	return;
    }

    for (pch++; (*pch && *pch != '>') ; pch++, val++)
	*val = *pch;
    if (*pch == '>' && *(pch+1) == '>')
	*val++ = '>';
    if (*pch == '\000') {
	Error("Initialization error (need '>' to end value)");
	*pval = '\000';
	return;
    }
    *val = '\000';
}

/*	Fix sizeof( foo )	 to size foo
**	    sizeof  foo		 to size foo
**	    sizeof( struct foo ) to size foo
*/
VOID FixSizeof(pbuf)
CHAR	*pbuf;
{
    char	*pch;
    char	*s;
    int		i;

    while (TRUE) {
	if ((pch=FindWord("sizeof", pbuf)) == NULL)
	    return;
	s = "SIZE  ";
	for (i=0; i < 6 ; i++)
	    *pch++ = *s++;
	if ((s=FindString("(", pch, FALSE)) == NULL)
	    continue;
	*s++ = ' ';
	i = 0;
	do {
	    if (*s == '(')
		i++;
	    else if (*s == ')') {
		if (i == 0) {
		    *s = ' ';
		    break;
		}
		i--;
	    }
	} while (*++s != '\000');
	if ((pch=FindWord("struct", pch)) == NULL)
	    continue;
	for (i=0; i<6;i++)
	    *pch++ = ' ';
	while (*pch)
	    pch++;
	*pch++ = ';';
	*pch = '\000';
    }
}

VOID FixCast( pch )
CHAR  *pch;
{
    /*
     *	  Look for and remove any casts.  These are defined as (XXX *),
     *	where XXX is a type we know about,  and * may or may not be present.
     *	These are meaningless to assembler,  which is typeless.
     *	  We remove casts by whiting them out.
     */

    register  CHAR  *pchT;
    register  CHAR  *pchT1;

    CHAR  *pchStart;
    CHAR  chBuf[ 128 ];

    /*	 Start looking from the RHS */
    while (pchStart = strchr( pch, '(' ) ) {
	/*  Worth looking - there are candidates */
	while (*pchStart == '(' )
	    ++pchStart;		/* May be nested for other reasons */

	for( pchT = pchStart; *pchT && isspace( *pchT ); ++pchT )
	    ;		/* Scan to start of type */
	pchT1 = chBuf;
	while (*pchT && (isalnum( *pchT ) || *pchT == '_' ) )
	    *pchT1++ = *pchT++;		/* Copy ONLY type to local */
	*pchT1 = '\0';


	/*  Is it a type we have?  */
	if (CalcType2( chBuf, rgpchDD ) == 0 ||
	    CalcType2( chBuf, rgpchDB ) == 0 ||
	    CalcType2( chBuf, rgpchDW ) == 0 ||
	    CalcType2( chBuf, rgpchW_D ) == 0 ) {
	    /*	 Known type - maybe a cast! */
	    while (*pchT && isspace( *pchT ) )
		++pchT;
	    if ( *pchT == '*' ) {
		/*  Pointer - still OK */
		++pchT;
		while (*pchT && isspace( *pchT ) )
		    ++pchT;
	    }
	    if ( *pchT == ')' ) {
		/*  Found all the bits - white them out */
		while (pchT >= pchStart )
		    *pchT-- = ' ';
		*pchT = ' ';		/* Skipped over leading ( */
	    }
	}
	pch = pchStart;			/* Continue from here */
    }

    return;
}

VOID DoDefinesOff()
{
    fDefines = TRUE;
    while (cLines++ && fgetl(rgchLine, CCHMAX, hfIn)) {
	if (FindWord("DEFINESON", rgchLine)) {
	    fDefines = FALSE;
	    return;
	}
	ProcessLine();
    }
    fDefines = FALSE;
    return;
}

VOID DoNoInc()
{
    while (cLines++ && fgetl(rgchLine, CCHMAX, hfIn)) {
	if (FindWord("INC", rgchLine))
	    return;
    }
}

VOID DoXlatOff()
{
    while (cLines++ && fgetl(rgchLine, CCHMAX, hfIn)) {
	if (FindWord("XLATON", rgchLine))
	    return;
    }
}

VOID DoExtern(pline)
char	*pline;
{
    char	*pch;

    while (TRUE) {
	pch = pline;
	while (*pch && *pch != ';')
	    pch++;
	if (*pch == ';')
	    return;
	if (fgetlx(pline, CCHMAX, hfIn))
	    cLines++;
	else
	    return;
    }
}


CHAR	*fgetlx(buffer,buflen,fi)
char	*buffer;
int	buflen;		/* Buffer length */
FILE	*fi;		/* Input file */
{
    int		i, j;
    char	*buf;

    j = buflen;
    buf = buffer;
    while (TRUE) {
	if (fgetl(buf, j, fi) == NULL)
	    return (NULL);
	i = strlen(buf) - 1;
	if (i < 0 || buf[i] != '\\')
	    return (buffer);
	else if (buflen -i >= 40) {
	    j -= i;
	    buf += i;
	}
	else {
	    Error("Line too long");
	    break;
	}
    }
    return (buffer);
}

/*
 *  This function differs from fgets() in the following ways:
 *
 *  (1) It ignores carriage returns.
 *  (2) It expands tabs.
 *  (3) It does NOT include the terminating linefeed in the
 *	string it returns.
 *
 *  I didn't spec the interface to behave this way; it is
 *  some fool PM private incompatible C runtime function.
 */

CHAR			*fgetl(buffer,buflen,fi)
CHAR			*buffer;	/* Buffer pointer */
register int		buflen;		/* Buffer length */
FILE			*fi;		/* Input file */
{
    int			c;		/* A character */
    register CHAR	*cp1;		/* Char pointer */
    int			i;		/* Counter */

    if (buflen-- == 0) return(NULL);	/* NULL if zero-length buffer */
    for(cp1 = buffer; buflen > 0; ) {	/* Loop to get line */
	if ((c = getc(fi)) == EOF) {	/* If end of file */
	    if (cp1 > buffer)
		break;			/* Break if buffer not empty */
	    return(NULL);		/* End of file */
	}
	if (c == '\r')
	    continue;			/* Ignore CRs */
	if (c == '\t') {		/* If tab */
	    i = 8 - ((cp1 - buffer) % 8);
					/* Compute number of spaces to fill */
	    if (i > buflen)
		i = buflen;	/* Don't exceed space remaining */
	    while (i-- > 0) {		/* While spaces remaining */
		*cp1++ = ' ';		/* Fill with space */
		--buflen;		/* Decrement buffer count */
	    }
	    continue;			/* Go get next character */
	}
	if (c == '\n')
	    break;			/* Break if linefeed */
	*cp1++ = (CHAR)c;		/* Copy the character */
	--buflen;			/* Decrement buffer count */
    }
    *cp1 = '\0';			/* Add terminator */
    return(buffer);			/* Return pointer to buffer */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\tools\src\stripdd\stripdd.c ===
/***
****
* File : stripdd.c
*	Used to strip out the zeroes in a segment which is orged to a high
*	value. Mostly written for the following scenario. Has not been
*	tested for any other stunts.
*
*
*	/--------------------------------------\  File offset Grows
*	|				       |
*	|				       |
*	| First Segment			       |
*	|				       |
*	|				       |
*	|				       |
*	|--------------------------------------|
*	|				       |
*	|				       |
*	|				       |									|
*	| Zeroes due to the ORG		       |
*	| in the second segment		       |
*	|				       |
*	|				       |
*	|--------------------------------------|
*	|				       |
*	|				       |
*	| data part of 2nd segment	       |
*	|--------------------------------------|
*	|				       |
*	|				       |
*	| Tail for Stripdd		       |
*	|				       |
*	\--------------------------------------/
*
*
*	This utility removes the 'Zeroes' portion from the source file
*
*
*	The Tail is of the following format
*
*	struct Tail {
*		int	TailLen ; len of Tail including len field
*		struct Entry[NUMENTRIES]
*		long	Terminator ; == -1
*		filler
*	}
*
*	struct Entry {
*		long	offset ;	offset of Zeroes from the beg of file
*		int	size ;	number of zeroes to be stripped
*	}
*
*
*	Even though the Tail was designed variable number of entries
*	the utility handles only one entry right now.
*
*	Also the offset field in the Entry structure is being
*	rounded to para boundary, assuming that the 2nd segment
*	starts at a para boundary.
*
*
*	Usage : stripdd <sourcefile> <destfile>
***
***/

#include	<fcntl.h>
#include	<io.h>
#include	<stdio.h>
#include	<sys\types.h>
#include	<sys\stat.h>
#include	<process.h>

int		SrcFile, DstFile ;
unsigned int	HeadLen, *HeadPtr ;
long		FileSize ;

extern	void *malloc() ;

GetHeader ()
{
	char	tempbuf[2] ;
	int	*tptr ;

	fprintf ( stderr, "Reading in Tail Info...\n" ) ;

	if ( (FileSize = lseek (SrcFile, -16L, SEEK_END )) == -1) {
		fprintf ( stderr, "Error while seeking\n" ) ;
		exit (1) ;
	}

	if ( read(SrcFile, tempbuf, 2) != 2 ) {
		fprintf ( stderr, "Error while reading in the header\n" ) ;
		exit ( 1 ) ;
	}
	tptr = (int *)tempbuf ;
	HeadLen = *tptr - 2 ;
	HeadPtr = malloc ( HeadLen ) ;
	if (HeadPtr == NULL) {
		fprintf ( stderr, "Memory allocation error\n" ) ;
		exit (1) ;
	}
	if ( read(SrcFile, (char *)HeadPtr, HeadLen) != HeadLen ) {
		fprintf ( stderr, "Error while reading in the header\n" ) ;
		exit ( 1 ) ;
	}

	if ( lseek (SrcFile, 0L, SEEK_SET ) == -1) {
		fprintf ( stderr, "Error while seeking\n" ) ;
		exit (1) ;
	}

}

Process()
{
	long	offset ;


	offset = * ( (long *)HeadPtr) ;
	offset = (offset + 15) & 0xfffffff0 ;
	fprintf ( stderr, "Copying first segment...\n" ) ;
	copy ( offset ) ;
	FileSize -= offset ;
	HeadPtr += 2 ;
	offset = *HeadPtr ;
	fprintf ( stderr, "Stripping zeroes from the second segment...\n" ) ;
	lseek ( SrcFile, offset, SEEK_CUR ) ;
	FileSize -= offset ;
	fprintf ( stderr, "Copying second segment...\n" ) ;
	copy (FileSize) ;
}
char	buf[4096] ;

copy ( len )
long	len ;

{
	int	readlen ;

	while ( len > 0 ) {
		if ( len > 4096 )
			readlen = 4096 ;
		else
			readlen = len ;

		if ( read (SrcFile, buf, readlen ) != readlen ) {
			fprintf ( stderr, "Error while reading data\n" ) ;
			exit (1) ;
		}

		if ( write (DstFile, buf, readlen ) != readlen ) {
			fprintf ( stderr, "Error while writing data\n" ) ;
			exit (1) ;
		}
		len -= readlen ;
	}
}

main ( argc, argv )
int	argc ;
char	*argv[] ;

{
	if (argc != 3) {
		fprintf ( stderr, "Usage : stripdd infile outfile\n" ) ;
		exit (1) ;
	}

	SrcFile = open ( argv[1], O_BINARY ) ;
	if ( SrcFile == -1 ) {
		fprintf ( stderr, "Error opening %s\n", argv[1] ) ;
		exit (1) ;
	}

	DstFile = open ( argv[2], O_RDWR | O_CREAT | O_TRUNC | O_BINARY,
														S_IREAD | S_IWRITE ) ;

	GetHeader() ;
	Process() ;
	fprintf ( stderr, "%s stripped to %s\n", argv[1], argv[2] ) ;
	return(0) ;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\tools\src\stripz\stripz.c ===
/*
 *	Stripz.c - Strip the header off of a .SYS file
 *
 *	I don't know what this is for, but this program reads a file
 *	of the format
 *
 *	DW	<len>
 *	DB	<len-2> dup (0)
 *	DB	N bytes of data to keep
 *
 *	This program copies argv[1] to argv[2], striping off those leading
 *	bytes of zero and the length word.
 *
 *	We don't check to see if they're really zero, we just discard
 *	the first <len> bytes of argv[1].
 */

#include <stdio.h>
#include <fcntl.h>
#include <sys\types.h>
#include	<sys\stat.h>
#include	<io.h>

char buf[16384];
unsigned int pos;
int rdcnt;
int srcfile, tgtfile ;

main(argc, argv)
int	argc ;
char	*argv[] ;
{
	if ( argc != 3 ) {
		fprintf (stderr, "Usage : stripz src_file trgt_file\n") ;
		exit (1) ;
	}

	if ((srcfile = open(argv[1], (O_BINARY | O_RDONLY))) == -1) {
		fprintf (stderr, "Error opening %s\n", argv[1]) ;
		exit (1) ;
	}

	rdcnt = read (srcfile, buf, 2);
	if (rdcnt != 2) {
		fprintf (stderr, "Can't read %s\n", argv[1]);
		exit(1);
	}

	pos = lseek (srcfile, 0L, SEEK_END ) ;
	if ( (long)(*(unsigned int *)buf) > pos ) {
		fprintf (stderr, "File too short or improper format.\n");
		exit(1);
	}

	lseek(srcfile, (long)(*(unsigned int *)buf), SEEK_SET ) ;

	if ( (tgtfile = open(argv[2], (O_BINARY|O_WRONLY|O_CREAT|O_TRUNC),
											(S_IREAD|S_IWRITE))) == -1) {
		printf ("Error creating %s\n", argv[2]) ;
		close (srcfile) ;
		exit (1) ;
	}

	while ( (rdcnt = read (srcfile, buf, sizeof buf)) > 0)
		write (tgtfile, buf, rdcnt);

	close (srcfile) ;
	close (tgtfile) ;

	return ( 0 ) ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpm\fiofam\dpmffio.c ===
//************************************************************************
//
// dpmffio.c : Dynamic Patch Module for File I/O API family
//
// History:
//    26-jan-02   cmjones    created it.
//
//************************************************************************
#ifdef DBG
unsigned long dwLogLevel = 0;
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "dpmtbls.h"
#include "dpmdbg.h"   // include handy debug print macros
#include "shimdb.h" 

BOOL          DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext);
PFAMILY_TABLE DpmInitFamTable(PFAMILY_TABLE, 
                              HMODULE, 
                              PVOID, 
                              PVOID, 
                              LPWSTR, 
                              PDPMMODULESETS);
void          DpmDestroyFamTable(PFAMILY_TABLE pgDpmFamTbl, PFAMILY_TABLE pFT);


#define GROW_HEAP_AS_NEEDED 0
HANDLE  hHeap = NULL;

DWORD    dwTlsIndex;
char     szShimEngDll[] = "\\ShimEng.dll";

BOOL DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext)
{
    BOOL bRet = TRUE;

    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(pContext);

    switch(Reason) {

        case DLL_PROCESS_ATTACH:
    
            if((hHeap = HeapCreate(0, 4096, GROW_HEAP_AS_NEEDED)) == NULL) {
                DPMDBGPRN("NTVDM::DpmfFio:Can't initialize heap!\n");
                bRet = FALSE;
            }

            dwTlsIndex = TlsAlloc();
            if(dwTlsIndex == TLS_OUT_OF_INDEXES) {
                DPMDBGPRN("NTVDM::DpmfFio:Can't initialize TLS!\n");
                bRet = FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:
            if(hHeap) {
                HeapDestroy(hHeap);
            }
            TlsFree(dwTlsIndex);
            break;
    }

    return bRet;
}




PFAMILY_TABLE DpmInitFamTable(PFAMILY_TABLE  pgDpmFamTbl, 
                              HMODULE        hMod, 
                              PVOID          hSdb, 
                              PVOID          pSdbQuery, 
                              LPWSTR         pwszAppFilePath, 
                              PDPMMODULESETS pModSet)
{
    int            i, numApis, len;
    PVOID          lpdpmfn;
    PFAMILY_TABLE  pFT = NULL;
    PVOID         *pFN = NULL;
    PVOID         *pShimTbl = NULL;
    PAPIDESC       pApiDesc = NULL;
    VDMTABLE       VdmTbl;
    char           szShimEng[MAX_PATH];
    HMODULE        hModShimEng = NULL;
    LPFNSE_SHIMNTVDM lpShimNtvdm;

    DPMDBGPRN("NTVDM::DpmfFio:Initialziing File I/O API tables\n");


    // Get hooked API count from global table
    numApis = pgDpmFamTbl->numHookedAPIs;

    // Allocate a new family table
    pFT = (PFAMILY_TABLE)HeapAlloc(hHeap, 
                                   HEAP_ZERO_MEMORY, 
                                   sizeof(FAMILY_TABLE));
    if(!pFT) {
        DPMDBGPRN("NTVDM::DpmfFio:DpmInit:malloc 1 failed\n");
        goto ErrorExit;
    }

    // Allocate the shim dispatch table for this family in this task
    pShimTbl = (PVOID *)HeapAlloc(hHeap,
                                  HEAP_ZERO_MEMORY,
                                  numApis * sizeof(PVOID));
    if(!pShimTbl) {
        DPMDBGPRN("NTVDM::DpmfFio:DpmInit:malloc 2 failed\n");
        goto ErrorExit;
    }
    pFT->pDpmShmTbls = pShimTbl; 

    // Allocate an array of ptrs to hooked API's
    pFN = (PVOID *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, numApis * sizeof(PVOID));

    if(!pFN) {
        DPMDBGPRN("NTVDM::DpmfFio:DpmInit:malloc 3 failed\n");
        goto ErrorExit;
    }
    pFT->pfn = pFN;

    pFT->numHookedAPIs = numApis;
    pFT->hMod          = hMod;

    // Allocate a temp array of APIDESC structs to help attach shims
    pApiDesc = (PAPIDESC)HeapAlloc(hHeap,
                                   HEAP_ZERO_MEMORY,
                                   numApis * sizeof(APIDESC));
    if(!pApiDesc) {
        DPMDBGPRN("NTVDM::DpmfFio:DpmInit:malloc 4 failed\n");
        goto ErrorExit;
    }
    VdmTbl.nApiCount = numApis;
    VdmTbl.ppfnOrig  = pShimTbl;
    VdmTbl.pApiDesc  = pApiDesc;

    // Fill in the family table with ptrs to the patch functions in this DLL.
    for(i = 0; i < numApis; i++) {

        // must start with 1 since EXPORT ordinals can't be == 0
        lpdpmfn = (PVOID)GetProcAddress(hMod, (LPCSTR)MAKELONG(i+1, 0));
        if(!lpdpmfn) {
            DPMDBGPRN("NTVDM::DpmfFio:DpmInit:Unable to get proc address\n");
            goto ErrorExit;
        }

        // save ptr to the real API in the shim table until it gets shimmed
        pShimTbl[i] = pgDpmFamTbl->pfn[i];

        // relate the corresponding module and API name to the API function ptr
        pApiDesc[i].pszModule = (char *)pModSet->ApiModuleName;
        pApiDesc[i].pszApi    = (char *)pModSet->ApiNames[i];

        // save ptr to the patch function
        pFN[i] = lpdpmfn;

    } 

    // Only do this if we need to attach the shim engine.
    GetSystemDirectory(szShimEng, MAX_PATH);
    strcat(szShimEng, szShimEngDll);
    hModShimEng = LoadLibrary(szShimEng);
    pFT->hModShimEng = hModShimEng;

    if(NULL == hModShimEng) {
        DPMDBGPRN("NTVDM::DpmfFio:DpmInit:ShimEng load failed\n");
        goto ErrorExit;
    }

    lpShimNtvdm = (LPFNSE_SHIMNTVDM)GetProcAddress(hModShimEng, "SE_ShimNTVDM");

    if(!lpShimNtvdm) {
        DPMDBGPRN("NTVDM::DpmfFio:DpmInit:GetProcAddress failed\n");
        goto ErrorExit;
    }

    // Patch the shim dispatch table with the shim function ptrs
    // If this fails we will stick with ptrs to the original API's
    (lpShimNtvdm)(pwszAppFilePath, hSdb, pSdbQuery, &VdmTbl);

    // Do this if you want dispatch directly to the shim functions
    // for(i = 0; i < numApis; i++) {
    //     pFN[i] = pShimTbl[i];
    // }
    // HeapFree(hHeap, 0, pShimTbl);
    // pFT->pDpmShmTbls = NULL;

    if(!TlsSetValue(dwTlsIndex, pFT)) {
        DPMDBGPRN("NTVDM::DpmfFio:DpmInit:TLS set failed\n");
        goto ErrorExit;
    }

    if(pApiDesc) {
        HeapFree(hHeap, 0, pApiDesc);
    }

    DPMDBGPRN1("  DpmfFio:Returning File I/o API tables: %#lx\n",pFT);
    return(pFT);

ErrorExit:
    DPMDBGPRN("  DpmfFio:Init failed: Returning NULL\n");
    DpmDestroyFamTable(pgDpmFamTbl, pFT);

    if(pApiDesc) {
        HeapFree(hHeap, 0, pApiDesc);
    }
    return(NULL);
}







void DpmDestroyFamTable(PFAMILY_TABLE pgDpmFamTbl, PFAMILY_TABLE pFT)
{
    PVDM_TIB       pVdmTib;
    PVOID         *pShimTbl;
    LPFNSE_REMOVENTVDM lpfnSE_RemoveNtvdmTask = NULL;

    DPMDBGPRN("NTVDM::DpmfFio:Destroying File I/O API tables for task\n");

    // if this task is using the global table for this family, nothing to do
    if(!pFT || pFT == pgDpmFamTbl)
        return;

    pShimTbl = pFT->pDpmShmTbls;

    if(pShimTbl) {
        HeapFree(hHeap, 0, pShimTbl);
    }

    if(pFT->pfn) {
        HeapFree(hHeap, 0, pFT->pfn);
    }

    // See if the shim engine is attached & detach it
    if(pFT->hModShimEng) {

        lpfnSE_RemoveNtvdmTask = 
           (LPFNSE_REMOVENTVDM)GetProcAddress(pFT->hModShimEng,
                                              "SE_RemoveNTVDMTask");

        if(lpfnSE_RemoveNtvdmTask) {
            (lpfnSE_RemoveNtvdmTask)(NtCurrentTeb()->ClientId.UniqueThread);
        }
        FreeLibrary(pFT->hModShimEng);
    }

    HeapFree(hHeap, 0, pFT);

}



// ^^^^^^^^^^ All the above should be in every DPM module.  ^^^^^^^^^^^^



// vvvvvvvvvv Define module specific stuff below. vvvvvvvvvvvv



HFILE dpmOpenFile(LPCSTR lpFileName, 
                  LPOFSTRUCT lpof, 
                  UINT uStyle)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    HFILE ret = 0;

    DPMDBGPRN("OpenFile: ");

    ret = SHM_OpenFile(lpFileName, lpof, uStyle);

    DPMDBGPRN1("  -> %#lx\n", ret);
    
    return(ret);
}




HFILE dpm_lclose(HFILE hFile)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    HFILE ret = 0;

    DPMDBGPRN("_lclose: ");

    ret = SHM__lclose(hFile);

    DPMDBGPRN1("  -> %#lx\n", ret);
    
    return(ret);
}



HFILE dpm_lopen(LPCSTR lpPathName, int iReadWrite)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    HFILE ret = 0;

    DPMDBGPRN("_lopen: ");

    ret = SHM__lopen(lpPathName, iReadWrite);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}



HFILE dpm_lcreat(LPCSTR lpPathName, int iAttribute)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    HFILE ret = 0;

    DPMDBGPRN("_lcreat: ");

    ret = SHM__lcreat(lpPathName, iAttribute);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}



LONG  dpm_llseek(HFILE hFile, LONG lOffset, int iOrigin)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    LONG ret = 0;

    DPMDBGPRN("_llseek: ");

    ret = SHM__llseek(hFile, lOffset, iOrigin);

    DPMDBGPRN1("  -> %ld\n", ret);

    return(ret);
}




UINT  dpm_lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    UINT ret = 0;

    DPMDBGPRN("_lread: ");

    ret = SHM__lread(hFile, lpBuffer, uBytes);

    DPMDBGPRN1("  -> %ld\n", ret);

    return(ret);
}




UINT  dpm_lwrite(HFILE hFile, LPCSTR lpBuffer, UINT uBytes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    UINT ret = 0;

    DPMDBGPRN("_lwrite: ");

    ret = SHM__lwrite(hFile, lpBuffer, uBytes);

    DPMDBGPRN1("  -> %ld\n", ret);

    return(ret);
}





long  dpm_hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    long ret = 0;

    DPMDBGPRN("_hread: ");

    ret = SHM__hread(hFile, lpBuffer, lBytes);

    DPMDBGPRN1("  -> %ld\n", ret);

    return(ret);
}




long  dpm_hwrite(HFILE hFile, LPCSTR lpBuffer, long lBytes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    LONG ret = 0;

    DPMDBGPRN("_hwrite: ");

    ret = SHM__hwrite(hFile, lpBuffer, lBytes);

    DPMDBGPRN1("  -> %ld\n", ret);

    return(ret);
}





UINT  dpmGetTempFileName(LPCSTR lpPathName, 
                         LPCSTR lpPrefixString, 
                         UINT uUnique, 
                         LPSTR lpTempFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    LONG ret = 0;

    DPMDBGPRN("GetTempFileName: ");

    ret = SHM_GetTempFileName(lpPathName, lpPrefixString, uUnique, lpTempFileName);

    DPMDBGPRN1("  -> %ld\n", ret);

    return(ret);
}




BOOL dpmAreFileApisANSI(VOID)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("AreFileApisANSI: ");

    ret = SHM_AreFileApisANSI();

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmCancelIo(HANDLE hFile)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("CancelIo: ");

    ret = SHM_CancelIo(hFile);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmCloseHandle(HANDLE hObject)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("CloseHandle: ");

    ret = SHM_CloseHandle(hObject);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmCopyFile(LPCSTR lpExistingFileName, 
                 LPCSTR lpNewFileName, 
                 BOOL bFailIfExists)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("CopyFile: ");

    ret = SHM_CopyFile(lpExistingFileName, lpNewFileName, bFailIfExists);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmCopyFileEx(LPCSTR lpExistingFileName, 
                   LPCSTR lpNewFileName, 
                   LPPROGRESS_ROUTINE lpProgressRoutine, 
                   LPVOID lpData, 
                   LPBOOL pbCancel, 
                   DWORD dwCopyFlags)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("CopyFileEx: ");

    ret = SHM_CopyFileEx(lpExistingFileName, 
                     lpNewFileName, 
                     lpProgressRoutine, 
                     lpData, 
                     pbCancel, 
                     dwCopyFlags);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmCreateDirectory(LPCSTR lpPathName, 
                        LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("CreateDirectory: ");

    ret = SHM_CreateDirectory(lpPathName, lpSecurityAttributes);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmCreateDirectoryEx(LPCSTR lpTemplateDirectory, 
                          LPCSTR lpNewDirectory, 
                          LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("CreateDirectoryEx: ");

    ret = SHM_CreateDirectoryEx(lpTemplateDirectory,
                            lpNewDirectory, 
                            lpSecurityAttributes);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





HANDLE dpmCreateFile(LPCSTR lpFileName, 
                     DWORD dwDesiredAccess, 
                     DWORD dwShareMode, 
                     LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                     DWORD dwCreationDisposition, 
                     DWORD dwFlagsAndAttributes, 
                     HANDLE hTemplateFile)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    HANDLE ret = 0;

    DPMDBGPRN("CreateFile: ");

    ret = SHM_CreateFile(lpFileName, 
                     dwDesiredAccess, 
                     dwShareMode, 
                     lpSecurityAttributes, 
                     dwCreationDisposition, 
                     dwFlagsAndAttributes, 
                     hTemplateFile);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmDeleteFile(LPCSTR lpFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("DeleteFile: ");

    ret = SHM_DeleteFile(lpFileName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmFindClose(HANDLE hFindFile)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("FindClose: ");

    ret = SHM_FindClose(hFindFile);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmFindCloseChangeNotification(HANDLE hChangeHandle)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("FindCloseChangeNotification: ");

    ret = SHM_FindCloseChangeNotification(hChangeHandle);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





HANDLE dpmFindFirstChangeNotification(LPCSTR lpPathName, 
                                      BOOL bWatchSubtree, 
                                      DWORD dwNotifyFilter)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    HANDLE ret = 0;

    DPMDBGPRN("FindFirstChangeNotification: ");

    ret = SHM_FindFirstChangeNotification(lpPathName,bWatchSubtree,dwNotifyFilter);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





HANDLE dpmFindFirstFile(LPCSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    HANDLE ret = 0;

    DPMDBGPRN("FindFirstFile: ");

    ret = SHM_FindFirstFile(lpFileName, lpFindFileData);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmFindNextChangeNotification(HANDLE hChangeHandle)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("FindNextChangeNotification: ");

    ret = SHM_FindNextChangeNotification(hChangeHandle);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}



BOOL dpmFindNextFile(HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("FindNextFile: ");

    ret = SHM_FindNextFile(hFindFile, lpFindFileData);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmFlushFileBuffers(HANDLE hFile)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("FlushFileBuffers: ");

    ret = SHM_FlushFileBuffers(hFile);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmGetCurrentDirectory(DWORD nBufferLength, LPSTR lpBuffer)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetCurrentDirectory: ");

    ret = SHM_GetCurrentDirectory(nBufferLength, lpBuffer);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmGetDiskFreeSpace(LPCSTR lpRootPathName,
                         LPDWORD lpSectorsPerCluster,
                         LPDWORD lpBytesPerSector,
                         LPDWORD lpNumberOfFreeClusters,
                         LPDWORD lpTotalNumberOfClusters)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("GetDiskFreeSpace: ");

    ret = SHM_GetDiskFreeSpace(lpRootPathName,
                           lpSectorsPerCluster,
                           lpBytesPerSector,
                           lpNumberOfFreeClusters,
                           lpTotalNumberOfClusters);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmGetDiskFreeSpaceEx(LPCSTR lpDirectoryName,
                           PULARGE_INTEGER lpFreeBytesAvailable,
                           PULARGE_INTEGER lpTotalNumberOfBytes,
                           PULARGE_INTEGER lpTotalNumberOfFreeBytes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("GetDiskFreeSpaceEx: ");

    ret = SHM_GetDiskFreeSpaceEx(lpDirectoryName,
                             lpFreeBytesAvailable,
                             lpTotalNumberOfBytes,
                             lpTotalNumberOfFreeBytes);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




UINT dpmGetDriveType(LPCSTR lpRootPathName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    UINT ret = 0;

    DPMDBGPRN("GetDriveType: ");

    ret = SHM_GetDriveType(lpRootPathName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmGetFileAttributes(LPCSTR lpFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetFileAttributes: ");

    ret = SHM_GetFileAttributes(lpFileName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmGetFileAttributesEx(LPCSTR lpFileName,
                            GET_FILEEX_INFO_LEVELS fInfoLevelId,
                            LPVOID lpFileInformation)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("GetFileAttributesEx: ");

    ret = SHM_GetFileAttributesEx(lpFileName,
                              fInfoLevelId,
                              lpFileInformation);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmGetFileInformationByHandle(HANDLE hFile,
                                LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("GetFileInformationByHandle: ");

    ret = SHM_GetFileInformationByHandle(hFile, lpFileInformation);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmGetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetFileSize: ");

    ret = SHM_GetFileSize(hFile, lpFileSizeHigh);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}



DWORD dpmGetFileType(HANDLE hFile)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetFileType: ");

    ret = SHM_GetFileType(hFile);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}



DWORD dpmGetFullPathName(LPCSTR lpFileName,
                         DWORD nBufferLength, 
                         LPSTR lpBuffer, 
                         LPSTR *lpFilePart)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetFullPathName: ");

    ret = SHM_GetFullPathName(lpFileName, 
                          nBufferLength, 
                          lpBuffer, 
                          lpFilePart);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmGetLogicalDrives(VOID)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetLogicalDrives: ");

    ret = SHM_GetLogicalDrives();

    DPMDBGPRN("  -> void return\n");

    return(ret);
}




DWORD dpmGetLogicalDriveStrings(DWORD nBufferLength, LPSTR lpBuffer)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetLogicalDriveStrings: ");

    ret = SHM_GetLogicalDriveStrings(nBufferLength, lpBuffer);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





DWORD dpmGetLongPathName(LPCSTR lpszShortPath, 
                         LPSTR lpszLongPath, 
                         DWORD cchBuffer)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetLongPathName: ");

    ret = SHM_GetLongPathName(lpszShortPath,
                          lpszLongPath, 
                          cchBuffer);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmGetShortPathName(LPCSTR lpszLongPath, 
                          LPSTR lpszShortPath, 
                          DWORD cchBuffer)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetShortPathName: ");

    ret = SHM_GetShortPathName(lpszLongPath, 
                           lpszShortPath,
                           cchBuffer);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmGetTempPath(DWORD nBufferLength, LPSTR lpBuffer)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetTempPath: ");

    ret = SHM_GetTempPath(nBufferLength, lpBuffer);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmLockFile(HANDLE hFile, 
                 DWORD dwFileOffsetLow, 
                 DWORD dwFileOffsetHigh, 
                 DWORD nNumberOfBytesToLockLow, 
                 DWORD nNumberOfBytesToLockHigh)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("LockFile: ");

    ret = SHM_LockFile(hFile, 
                   dwFileOffsetLow, 
                   dwFileOffsetHigh, 
                   nNumberOfBytesToLockLow, 
                   nNumberOfBytesToLockHigh);
    
    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmMoveFile(LPCSTR lpExistingFileName, 
                 LPCSTR lpNewFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("MoveFile: ");

    ret = SHM_MoveFile(lpExistingFileName, lpNewFileName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmMoveFileEx(LPCSTR lpExistingFileName, 
                   LPCSTR lpNewFileName, 
                   DWORD dwFlags)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("MoveFileEx: ");

    ret = SHM_MoveFileEx(lpExistingFileName, lpNewFileName, dwFlags);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmQueryDosDevice(LPCSTR lpDeviceName, 
                        LPSTR lpTargetPath, 
                        DWORD ucchMax)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("QueryDosDevice: ");

    ret = SHM_QueryDosDevice(lpDeviceName, lpTargetPath, ucchMax);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}


BOOL dpmReadFile(HANDLE hFile, 
                 LPVOID lpBuffer, 
                 DWORD nNumberOfBytesToRead, 
                 LPDWORD lpNumberOfBytesRead, 
                 LPOVERLAPPED lpOverlapped)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);

    BOOL ret = 0;

    DPMDBGPRN("ReadFile: ");

    ret = SHM_ReadFile(hFile, 
                   lpBuffer, 
                   nNumberOfBytesToRead, 
                   lpNumberOfBytesRead, 
                   lpOverlapped);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmReadFileEx(HANDLE hFile, 
                   LPVOID lpBuffer, 
                   DWORD nNumberOfBytesToRead, 
                   LPOVERLAPPED lpOverlapped, 
                   LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("ReadFileEx: ");

    ret = SHM_ReadFileEx(hFile, 
                     lpBuffer, 
                     nNumberOfBytesToRead, 
                     lpOverlapped,
                     lpCompletionRoutine);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmRemoveDirectory(LPCSTR lpPathName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("RemoveDirectory: ");

    ret = SHM_RemoveDirectory(lpPathName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmSearchPath(LPCSTR lpPath, 
                    LPCSTR lpFileName, 
                    LPCSTR lpExtension, 
                    DWORD nBufferLength, 
                    LPSTR lpBuffer, 
                    LPSTR *lpFilePart)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("SearchPath: ");

    ret = SHM_SearchPath(lpPath,
                     lpFileName, 
                     lpExtension, 
                     nBufferLength,  
                     lpBuffer, 
                     lpFilePart);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmSetCurrentDirectory(LPCSTR lpPathName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("SetCurrentDirectory: ");

    ret = SHM_SetCurrentDirectory(lpPathName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmSetEndOfFile(HANDLE hFile)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("SetEndOfFile: ");

    ret = SHM_SetEndOfFile(hFile);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




VOID dpmSetFileApisToANSI(VOID)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DPMDBGPRN("SetFileApisToANSI: ");

    SetFileApisToANSI();

    DPMDBGPRN("  -> Void return");
}




VOID dpmSetFileApisToOEM(VOID)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DPMDBGPRN("SetFileApisToOEM: ");

    SetFileApisToOEM();

    DPMDBGPRN("  -> Void return");
}




BOOL dpmSetFileAttributes(LPCSTR lpFileName, DWORD dwFileAttributes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("SetFileAttributes: ");

    ret = SHM_SetFileAttributes(lpFileName, dwFileAttributes);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmSetFilePointer(HANDLE hFile, 
                        LONG lDistanceToMove, 
                        PLONG lpDistanceToMoveHigh, 
                        DWORD dwMoveMethod)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("SetFilePointer: ");

    ret = SHM_SetFilePointer(hFile, 
                         lDistanceToMove, 
                         lpDistanceToMoveHigh, 
                         dwMoveMethod);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmSetVolumeLabel(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("SetVolumeLabel: ");

    ret = SHM_SetVolumeLabel(lpRootPathName, lpVolumeName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmUnlockFile(HANDLE hFile, 
                   DWORD dwFileOffsetLow, 
                   DWORD dwFileOffsetHigh, 
                   DWORD nNumberOfBytesToUnlockLow, 
                   DWORD nNumberOfBytesToUnlockHigh)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("UnlockFile: ");

    ret = SHM_UnlockFile(hFile, 
                     dwFileOffsetLow, 
                     dwFileOffsetHigh, 
                     nNumberOfBytesToUnlockLow, 
                     nNumberOfBytesToUnlockHigh);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmWriteFile(HANDLE hFile, 
                  LPCVOID lpBuffer, 
                  DWORD nNumberOfBytesToWrite, 
                  LPDWORD lpNumberOfBytesWritten, 
                  LPOVERLAPPED lpOverlapped)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("WriteFile: ");

    ret = SHM_WriteFile(hFile, 
                    lpBuffer, 
                    nNumberOfBytesToWrite, 
                    lpNumberOfBytesWritten, 
                    lpOverlapped);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}

BOOL dpmWriteFileEx(HANDLE hFile, 
                    LPCVOID lpBuffer, 
                    DWORD nNumberOfBytesToWrite, 
                    LPOVERLAPPED lpOverlapped, 
                    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("WriteFileEx: ");

    ret = SHM_WriteFileEx(hFile, 
                      lpBuffer, 
                      nNumberOfBytesToWrite, 
                      lpOverlapped,
                      lpCompletionRoutine);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




/*

VOID CALLBACK dpmFileIOCompletionRoutine(DWORD dwErrorCode, 
                                         DWORD dwNumberOfBytesTransfered, 
                                         LPOVERLAPPED lpOverlapped)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DPMDBGPRN("FileIOCompletionRoutine: ");

    FileIOCompletionRoutine(dwErrorCode,
                            dwNumberOfBytesTransfered,
                            lpOverlapped);

    DPMDBGPRN("  -> void return\n");
}

*/

UINT  dpmGetTempFileNameW(LPCWSTR lpPathName, 
                          LPCWSTR lpPrefixString, 
                          UINT uUnique, 
                          LPWSTR lpTempFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    LONG ret = 0;

    DPMDBGPRN("GetTempFileNameW: ");

    ret = SHM_GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);

    DPMDBGPRN1("  -> %ld\n", ret);

    return(ret);
}








BOOL dpmCopyFileW(LPCWSTR lpExistingFileName, 
                  LPCWSTR lpNewFileName, 
                  BOOL bFailIfExists)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("CopyFileW: ");

    ret = SHM_CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmCopyFileExW(LPCWSTR lpExistingFileName, 
                    LPCWSTR lpNewFileName, 
                    LPPROGRESS_ROUTINE lpProgressRoutine, 
                    LPVOID lpData, 
                    LPBOOL pbCancel, 
                    DWORD dwCopyFlags)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("CopyFileExW: ");

    ret = SHM_CopyFileExW(lpExistingFileName, 
                     lpNewFileName, 
                     lpProgressRoutine, 
                     lpData, 
                     pbCancel, 
                     dwCopyFlags);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmCreateDirectoryW(LPCWSTR lpPathName, 
                         LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("CreateDirectoryW: ");

    ret = SHM_CreateDirectoryW(lpPathName, lpSecurityAttributes);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmCreateDirectoryExW(LPCWSTR lpTemplateDirectory, 
                           LPCWSTR lpNewDirectory, 
                           LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("CreateDirectoryExW: ");

    ret = SHM_CreateDirectoryExW(lpTemplateDirectory,
                            lpNewDirectory, 
                            lpSecurityAttributes);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





HANDLE dpmCreateFileW(LPCWSTR lpFileName, 
                      DWORD dwDesiredAccess, 
                      DWORD dwShareMode, 
                      LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                      DWORD dwCreationDisposition, 
                      DWORD dwFlagsAndAttributes, 
                      HANDLE hTemplateFile)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    HANDLE ret = 0;

    DPMDBGPRN("CreateFileW: ");

    ret = SHM_CreateFileW(lpFileName, 
                     dwDesiredAccess, 
                     dwShareMode, 
                     lpSecurityAttributes, 
                     dwCreationDisposition, 
                     dwFlagsAndAttributes, 
                     hTemplateFile);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmDeleteFileW(LPCWSTR lpFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("DeleteFileW: ");

    ret = SHM_DeleteFileW(lpFileName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





HANDLE dpmFindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    HANDLE ret = 0;

    DPMDBGPRN("FindFirstFileW: ");

    ret = SHM_FindFirstFileW(lpFileName, lpFindFileData);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}







BOOL dpmFindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("FindNextFileW: ");

    ret = SHM_FindNextFileW(hFindFile, lpFindFileData);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}






DWORD dpmGetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetCurrentDirectoryW: ");

    ret = SHM_GetCurrentDirectoryW(nBufferLength, lpBuffer);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmGetDiskFreeSpaceW(LPCWSTR lpRootPathName,
                          LPDWORD lpSectorsPerCluster,
                          LPDWORD lpBytesPerSector,
                          LPDWORD lpNumberOfFreeClusters,
                          LPDWORD lpTotalNumberOfClusters)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("GetDiskFreeSpaceW: ");

    ret = SHM_GetDiskFreeSpaceW(lpRootPathName,
                           lpSectorsPerCluster,
                           lpBytesPerSector,
                           lpNumberOfFreeClusters,
                           lpTotalNumberOfClusters);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}







BOOL dpmGetDiskFreeSpaceExW(LPCWSTR lpDirectoryName,
                            PULARGE_INTEGER lpFreeBytesAvailable,
                            PULARGE_INTEGER lpTotalNumberOfBytes,
                            PULARGE_INTEGER lpTotalNumberOfFreeBytes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("GetDiskFreeSpaceExW: ");

    ret = SHM_GetDiskFreeSpaceExW(lpDirectoryName,
                             lpFreeBytesAvailable,
                             lpTotalNumberOfBytes,
                             lpTotalNumberOfFreeBytes);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




UINT dpmGetDriveTypeW(LPCWSTR lpRootPathName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    UINT ret = 0;

    DPMDBGPRN("GetDriveTypeW: ");

    ret = SHM_GetDriveTypeW(lpRootPathName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmGetFileAttributesW(LPCWSTR lpFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetFileAttributesW: ");

    ret = SHM_GetFileAttributesW(lpFileName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmGetFileAttributesExW(LPCWSTR lpFileName,
                             GET_FILEEX_INFO_LEVELS fInfoLevelId,
                             LPVOID lpFileInformation)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("GetFileAttributesExW: ");

    ret = SHM_GetFileAttributesExW(lpFileName,
                              fInfoLevelId,
                              lpFileInformation);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}






DWORD dpmGetFullPathNameW(LPCWSTR lpFileName, 
                          DWORD nBufferLength, 
                          LPWSTR lpBuffer, 
                          LPWSTR *lpFilePart)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetFullPathNameW: ");

    ret = SHM_GetFullPathNameW(lpFileName, 
                          nBufferLength, 
                          lpBuffer, 
                          lpFilePart);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}






DWORD dpmGetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetLogicalDriveStringsW: ");

    ret = SHM_GetLogicalDriveStringsW(nBufferLength, lpBuffer);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





DWORD dpmGetLongPathNameW(LPCWSTR lpszShortPath, 
                          LPWSTR lpszLongPath, 
                          DWORD cchBuffer)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetLongPathNameW: ");

    ret = SHM_GetLongPathNameW(lpszShortPath,
                          lpszLongPath, 
                          cchBuffer);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmGetShortPathNameW(LPCWSTR lpszLongPath, 
                           LPWSTR lpszShortPath, 
                           DWORD cchBuffer)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetShortPathNameW: ");

    ret = SHM_GetShortPathNameW(lpszLongPath, 
                           lpszShortPath,
                           cchBuffer);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmGetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("GetTempPathW: ");

    ret = SHM_GetTempPathW(nBufferLength, lpBuffer);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("MoveFileW: ");

    ret = SHM_MoveFileW(lpExistingFileName, lpNewFileName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




BOOL dpmMoveFileExW(LPCWSTR lpExistingFileName, 
                    LPCWSTR lpNewFileName, 
                    DWORD dwFlags)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("MoveFileExW: ");

    ret = SHM_MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmQueryDosDeviceW(LPCWSTR lpDeviceName, 
                         LPWSTR lpTargetPath, 
                         DWORD ucchMax)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("QueryDosDeviceW: ");

    ret = SHM_QueryDosDeviceW(lpDeviceName, lpTargetPath, ucchMax);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmRemoveDirectoryW(LPCWSTR lpPathName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("RemoveDirectoryW: ");

    ret = SHM_RemoveDirectoryW(lpPathName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}




DWORD dpmSearchPathW(LPCWSTR lpPath, 
                     LPCWSTR lpFileName, 
                     LPCWSTR lpExtension, 
                     DWORD nBufferLength, 
                     LPWSTR lpBuffer, 
                     LPWSTR *lpFilePart)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("SearchPathW: ");

    ret = SHM_SearchPathW(lpPath,
                     lpFileName, 
                     lpExtension, 
                     nBufferLength,  
                     lpBuffer, 
                     lpFilePart);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmSetCurrentDirectoryW(LPCWSTR lpPathName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("SetCurrentDirectoryW: ");

    ret = SHM_SetCurrentDirectoryW(lpPathName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}






BOOL dpmSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("SetFileAttributesW: ");

    ret = SHM_SetFileAttributesW(lpFileName, dwFileAttributes);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}





BOOL dpmSetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    BOOL ret = 0;

    DPMDBGPRN("SetVolumeLabelW: ");

    ret = SHM_SetVolumeLabelW(lpRootPathName, lpVolumeName);

    DPMDBGPRN1("  -> %#lx\n", ret);

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpm\ntdfam\dpmfntd.c ===
//************************************************************************
//
// dpmfntd.c : Dynamic Patch Module for NTDLL API family
//
// History:
//    26-jan-02   cmjones    created it.
//
//************************************************************************
#ifdef DBG
unsigned long dwLogLevel = 0;
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "dpmtbls.h"
#include "dpmdbg.h"   // include handy debug print macros
#include "shimdb.h"

BOOL          DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext);
PFAMILY_TABLE DpmInitFamTable(PFAMILY_TABLE, 
                              HMODULE, 
                              PVOID, 
                              PVOID, 
                              LPWSTR, 
                              PDPMMODULESETS);
void          DpmDestroyFamTable(PFAMILY_TABLE pgDpmFamTbl, PFAMILY_TABLE pFT);


#define GROW_HEAP_AS_NEEDED 0
HANDLE  hHeap = NULL;

DWORD    dwTlsIndex;
char     szShimEngDll[] = "\\ShimEng.dll";

BOOL DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext)
{
    BOOL bRet = TRUE;

    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(pContext);

    switch(Reason) {

        case DLL_PROCESS_ATTACH:
    
            if((hHeap = HeapCreate(0, 4096, GROW_HEAP_AS_NEEDED)) == NULL) {
                DPMDBGPRN("NTVDM::DpmfNtd:Can't initialize heap!\n");
                bRet = FALSE;
            }

            dwTlsIndex = TlsAlloc();
            if(dwTlsIndex == TLS_OUT_OF_INDEXES) {
                DPMDBGPRN("NTVDM::DpmfNtd:Can't initialize TLS!\n");
                bRet = FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:
            if(hHeap) {
                HeapDestroy(hHeap);
            }
            TlsFree(dwTlsIndex);
            break;
    }

    return bRet;
}




PFAMILY_TABLE DpmInitFamTable(PFAMILY_TABLE  pgDpmFamTbl, 
                              HMODULE        hMod, 
                              PVOID          hSdb, 
                              PVOID          pSdbQuery, 
                              LPWSTR         pwszAppFilePath, 
                              PDPMMODULESETS pModSet)
{
    int            i, numApis, len;
    PVOID          lpdpmfn;
    PFAMILY_TABLE  pFT = NULL;
    PVOID         *pFN = NULL;
    PVOID         *pShimTbl = NULL;
    PAPIDESC       pApiDesc = NULL;
    VDMTABLE       VdmTbl;
    char           szShimEng[MAX_PATH];
    HMODULE        hModShimEng = NULL;
    LPFNSE_SHIMNTVDM lpShimNtvdm;

    DPMDBGPRN("NTVDM::DpmfNtd:Initialziing File I/O API tables\n");


    // Get hooked API count from global table
    numApis = pgDpmFamTbl->numHookedAPIs;

    // Allocate a new family table
    pFT = (PFAMILY_TABLE)HeapAlloc(hHeap, 
                                   HEAP_ZERO_MEMORY, 
                                   sizeof(FAMILY_TABLE));
    if(!pFT) {
        DPMDBGPRN("NTVDM::DpmfNtd:DpmInit:malloc 1 failed\n");
        goto ErrorExit;
    }

    // Allocate the shim dispatch table for this family in this task
    pShimTbl = (PVOID *)HeapAlloc(hHeap,
                                  HEAP_ZERO_MEMORY,
                                  numApis * sizeof(PVOID));
    if(!pShimTbl) {
        DPMDBGPRN("NTVDM::DpmfNtd:DpmInit:malloc 2 failed\n");
        goto ErrorExit;
    }
    pFT->pDpmShmTbls = pShimTbl; 

    // Allocate an array of ptrs to hooked API's
    pFN = (PVOID *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, numApis * sizeof(PVOID));

    if(!pFN) {
        DPMDBGPRN("NTVDM::DpmfNtd:DpmInit:malloc 3 failed\n");
        goto ErrorExit;
    }
    pFT->pfn = pFN;

    pFT->numHookedAPIs = numApis;
    pFT->hMod          = hMod;

    // Allocate a temp array of APIDESC structs to help attach shims
    pApiDesc = (PAPIDESC)HeapAlloc(hHeap,
                                   HEAP_ZERO_MEMORY,
                                   numApis * sizeof(APIDESC));
    if(!pApiDesc) {
        DPMDBGPRN("NTVDM::DpmfNtd:DpmInit:malloc 4 failed\n");
        goto ErrorExit;
    }
    VdmTbl.nApiCount = numApis;
    VdmTbl.ppfnOrig = pShimTbl;
    VdmTbl.pApiDesc = pApiDesc;

    // Fill in the family table with ptrs to the patch functions in this DLL.
    for(i = 0; i < numApis; i++) {

        // must start with 1 since EXPORT ordinals can't be == 0
        lpdpmfn = (PVOID)GetProcAddress(hMod, (LPCSTR)MAKELONG(i+1, 0));
        if(!lpdpmfn) {
            DPMDBGPRN("NTVDM::DpmfNtd:DpmInit:Unable to get proc address\n");
            goto ErrorExit;
        }

        // save ptr to the real API in the shim table until it gets shimmed
        pShimTbl[i] = pgDpmFamTbl->pfn[i];

        // relate the corresponding module and API name to the API function ptr
        pApiDesc[i].pszModule = (char *)pModSet->ApiModuleName;
        pApiDesc[i].pszApi    = (char *)pModSet->ApiNames[i];

        // save ptr to the patch function
        pFN[i] = lpdpmfn;

    }

    // Only do this if we need to attach the shim engine.
    GetSystemDirectory(szShimEng, MAX_PATH);
    strcat(szShimEng, szShimEngDll);
    hModShimEng = LoadLibrary(szShimEng);
    pFT->hModShimEng = hModShimEng;

    if(NULL == hModShimEng) {
        DPMDBGPRN("NTVDM::dpmfntd:DpmInit:ShimEng load failed\n");
        goto ErrorExit;
    }

    lpShimNtvdm = (LPFNSE_SHIMNTVDM)GetProcAddress(hModShimEng, "SE_ShimNTVDM");

    if(!lpShimNtvdm) {
        DPMDBGPRN("NTVDM::DpmfNtd:DpmInit:GetProcAddress failed\n");
        goto ErrorExit;
    }

    // Patch the shim dispatch table with the shim function ptrs
    // If this fails we will stick with ptrs to the original API's
    (lpShimNtvdm)(pwszAppFilePath, hSdb, pSdbQuery, &VdmTbl);

    // Do this if you want dispatch directly to the shim functions
    // for(i = 0; i < numApis; i++) {
    //     pFN[i] = pShimTbl[i];
    // }
    // HeapFree(hHeap, 0, pShimTbl);
    // pFT->pDpmShmTbls = NULL;

    if(!TlsSetValue(dwTlsIndex, pFT)) {
        DPMDBGPRN("NTVDM::DpmfNtd:DpmInit:TLS set failed\n");
        goto ErrorExit;
    }

    if(pApiDesc) {
        HeapFree(hHeap, 0, pApiDesc);
    }

    DPMDBGPRN1("  DpmfNtd:Returning File I/o API tables: %#lx\n",pFT);
    return(pFT);

ErrorExit:
    DPMDBGPRN("  DpmfNtd:Init failed: Returning NULL\n");
    DpmDestroyFamTable(pgDpmFamTbl, pFT);

    if(pApiDesc) {
        HeapFree(hHeap, 0, pApiDesc);
    }
    return(NULL);
}







void DpmDestroyFamTable(PFAMILY_TABLE pgDpmFamTbl, PFAMILY_TABLE pFT)
{
    PVDM_TIB       pVdmTib;
    PVOID         *pShimTbl;
    LPFNSE_REMOVENTVDM lpfnSE_RemoveNtvdmTask = NULL;

    DPMDBGPRN("NTVDM::DpmfNtd:Destroying NTDLL API tables for task\n");

    // if this task is using the global table for this family, nothing to do
    if(!pFT || pFT == pgDpmFamTbl)
        return;

    pShimTbl = pFT->pDpmShmTbls;
 
    if(pShimTbl) {
        HeapFree(hHeap, 0, pShimTbl);
    }

    if(pFT->pfn) {
        HeapFree(hHeap, 0, pFT->pfn);
    }

    // See if the shim engine is attached & detach it
    if(pFT->hModShimEng) {

        lpfnSE_RemoveNtvdmTask =
           (LPFNSE_REMOVENTVDM)GetProcAddress(pFT->hModShimEng,
                                              "SE_RemoveNTVDMTask");

        if(lpfnSE_RemoveNtvdmTask) {
            (lpfnSE_RemoveNtvdmTask)(NtCurrentTeb()->ClientId.UniqueThread);
        }
        FreeLibrary(pFT->hModShimEng);
    }

    HeapFree(hHeap, 0, pFT);
}




// ^^^^^^^^^^ All the above should be in every DPM module.  ^^^^^^^^^^^^



// vvvvvvvvvv Define module specific stuff below. vvvvvvvvvvvv



DWORD dpmNtOpenFile(PHANDLE FileHandle,
                    ACCESS_MASK DesiredAccess,
                    POBJECT_ATTRIBUTES ObjectAttributes,
                    PIO_STATUS_BLOCK IoStatusBlock,
                    ULONG ShareAccess,
                    ULONG OpenOptions)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("NtOpenFile: ");

    ret = SHM_NtOpenFile(FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         ShareAccess,
                         OpenOptions);

    DPMDBGPRN1("  -> %#lx\n", ret);
    
    return(ret);
}




DWORD dpmNtQueryDirectoryFile(HANDLE FileHandle,
                              HANDLE Event OPTIONAL,
                              PIO_APC_ROUTINE ApcRoutine OPTIONAL,
                              PVOID ApcContext OPTIONAL,
                              PIO_STATUS_BLOCK IoStatusBlock,
                              PVOID FileInformation,
                              ULONG Length,
                              FILE_INFORMATION_CLASS FileInformationClass,
                              BOOLEAN ReturnSingleEntry,
                              PUNICODE_STRING FileName OPTIONAL,
                              BOOLEAN RestartScan)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("NtQueryDirectoryFile: ");

    ret = SHM_NtQueryDirectoryFile(FileHandle,
                                   Event,
                                   ApcRoutine,
                                   ApcContext,
                                   IoStatusBlock,
                                   FileInformation,
                                   Length,
                                   FileInformationClass,
                                   ReturnSingleEntry,
                                   FileName,
                                   RestartScan);

    DPMDBGPRN1("  -> %#lx\n", ret);
    
    return(ret);
}





DWORD dpmRtlGetFullPathName_U(PCWSTR lpFileName,
                              ULONG nBufferLength,
                              PWSTR lpBuffer,
                              PWSTR *lpFilePart)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("RtlGetFullPathName_U: ");

    ret = SHM_RtlGetFullPathName_U(lpFileName, 
                                   nBufferLength, 
                                   lpBuffer, 
                                   lpFilePart);

    DPMDBGPRN1("  -> %#lx\n", ret);
    
    return(ret);
}







DWORD dpmRtlGetCurrentDirectory_U(ULONG nBufferLength, PWSTR lpBuffer)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    DWORD ret = 0;

    DPMDBGPRN("RtlGetCurrentDirectory_U: ");

    ret = SHM_RtlGetCurrentDirectory_U(nBufferLength, lpBuffer);

    DPMDBGPRN1("  -> %#lx\n", ret);
    
    return(ret);
}






NTSTATUS dpmRtlSetCurrentDirectory_U(PUNICODE_STRING PathName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    NTSTATUS ret = 0;

    DPMDBGPRN("RtlSetCurrentDirectory_U: ");

    ret = SHM_RtlSetCurrentDirectory_U(PathName);

    DPMDBGPRN1("  -> %#lx\n", ret);
    
    return(ret);
}



DWORD dpmNtVdmControl(VDMSERVICECLASS vdmClass, PVOID pInfo)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    NTSTATUS ret = 0;

    DPMDBGPRN("NtVdmControl: ");

    ret = SHM_NtVdmControl(vdmClass, pInfo);

    DPMDBGPRN1("  -> %#lx\n", ret);
    
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpm\regfam\dpmfreg.c ===
//************************************************************************
//
// dpmfreg.c : Dynamic Patch Module for Registry API family
//
// History:
//    12-jan-02   cmjones    created it.
//
//************************************************************************
#ifdef DBG
unsigned long dwLogLevel = 0;
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "dpmtbls.h"
#include "dpmdbg.h"   // include handy debug print macros
#include "shimdb.h" 

BOOL          DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext);
PFAMILY_TABLE DpmInitFamTable(PFAMILY_TABLE, 
                              HMODULE, 
                              PVOID, 
                              PVOID, 
                              LPWSTR, 
                              PDPMMODULESETS);
void          DpmDestroyFamTable(PFAMILY_TABLE pgDpmFamTbl, PFAMILY_TABLE pFT);


#define GROW_HEAP_AS_NEEDED 0
HANDLE  hHeap = NULL;

DWORD    dwTlsIndex;
char     szShimEngDll[] = "\\ShimEng.dll";

BOOL DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext)
{
    BOOL bRet = TRUE;

    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(pContext);

    switch(Reason) {

        case DLL_PROCESS_ATTACH:
    
            if((hHeap = HeapCreate(0, 4096, GROW_HEAP_AS_NEEDED)) == NULL) {
                DPMDBGPRN("NTVDM::DpmfReg:Can't initialize heap!\n");
                bRet = FALSE;
            }

            dwTlsIndex = TlsAlloc();
            if(dwTlsIndex == TLS_OUT_OF_INDEXES) {
                DPMDBGPRN("NTVDM::DpmfReg:Can't initialize TLS!\n");
                bRet = FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:
            if(hHeap) {
                HeapDestroy(hHeap);
            }
            TlsFree(dwTlsIndex);
            break;
    }

    return bRet;
}




PFAMILY_TABLE DpmInitFamTable(PFAMILY_TABLE  pgDpmFamTbl, 
                              HMODULE        hMod, 
                              PVOID          hSdb, 
                              PVOID          pSdbQuery, 
                              LPWSTR         pwszAppFilePath, 
                              PDPMMODULESETS pModSet)
{
    int            i, numApis, len;
    PVOID          lpdpmfn;
    PFAMILY_TABLE  pFT = NULL;
    PVOID         *pFN = NULL;
    PVOID         *pShimTbl = NULL;
    PAPIDESC       pApiDesc = NULL;
    VDMTABLE       VdmTbl;
    char           szShimEng[MAX_PATH];
    HMODULE        hModShimEng = NULL;
    LPFNSE_SHIMNTVDM lpShimNtvdm;

    DPMDBGPRN("NTVDM::DpmfReg:Initialziing File I/O API tables\n");


    // Get hooked API count from global table
    numApis = pgDpmFamTbl->numHookedAPIs;

    // Allocate a new family table
    pFT = (PFAMILY_TABLE)HeapAlloc(hHeap, 
                                   HEAP_ZERO_MEMORY, 
                                   sizeof(FAMILY_TABLE));
    if(!pFT) {
        DPMDBGPRN("NTVDM::DpmfReg:DpmInit:malloc 1 failed\n");
        goto ErrorExit;
    }

    // Allocate the shim dispatch table for this family in this task
    pShimTbl = (PVOID *)HeapAlloc(hHeap,
                                  HEAP_ZERO_MEMORY,
                                  numApis * sizeof(PVOID));
    if(!pShimTbl) {
        DPMDBGPRN("NTVDM::DpmfReg:DpmInit:malloc 2 failed\n");
        goto ErrorExit;
    }
    pFT->pDpmShmTbls = pShimTbl; 

    // Allocate an array of ptrs to hooked API's
    pFN = (PVOID *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, numApis * sizeof(PVOID));

    if(!pFN) {
        DPMDBGPRN("NTVDM::DpmfReg:DpmInit:malloc 3 failed\n");
        goto ErrorExit;
    }
    pFT->pfn = pFN;

    pFT->numHookedAPIs = numApis;
    pFT->hMod          = hMod;

    // Allocate a temp array of APIDESC structs to help attach shims
    pApiDesc = (PAPIDESC)HeapAlloc(hHeap,
                                   HEAP_ZERO_MEMORY,
                                   numApis * sizeof(APIDESC));
    if(!pApiDesc) {
        DPMDBGPRN("NTVDM::DpmfReg:DpmInit:malloc 4 failed\n");
        goto ErrorExit;
    }
    VdmTbl.nApiCount = numApis;
    VdmTbl.ppfnOrig = pShimTbl;
    VdmTbl.pApiDesc = pApiDesc;

    // Fill in the family table with ptrs to the patch functions in this DLL.
    for(i = 0; i < numApis; i++) {

        // must start with 1 since EXPORT ordinals can't be == 0
        lpdpmfn = (PVOID)GetProcAddress(hMod, (LPCSTR)MAKELONG(i+1, 0));
        if(!lpdpmfn) {
            DPMDBGPRN("NTVDM::DpmfReg:DpmInit:Unable to get proc address\n");
            goto ErrorExit;
        }

        // save ptr to the real API in the shim table until it gets shimmed
        pShimTbl[i] = pgDpmFamTbl->pfn[i];

        // relate the corresponding module and API name to the API function ptr
        pApiDesc[i].pszModule = (char *)pModSet->ApiModuleName;
        pApiDesc[i].pszApi    = (char *)pModSet->ApiNames[i];

        // save ptr to the patch function
        pFN[i] = lpdpmfn;

    }

    // Only do this if we need to attach the shim engine.
    GetSystemDirectory(szShimEng, MAX_PATH);
    strcat(szShimEng, szShimEngDll);
    hModShimEng = LoadLibrary(szShimEng);
    pFT->hModShimEng = hModShimEng;

    if(NULL == hModShimEng) {
        DPMDBGPRN("NTVDM::dpmfreg:DpmInit:ShimEng load failed\n");
        goto ErrorExit;
    }

    lpShimNtvdm = (LPFNSE_SHIMNTVDM)GetProcAddress(hModShimEng, "SE_ShimNTVDM");

    if(!lpShimNtvdm) {
        DPMDBGPRN("NTVDM::dpmfreg:DpmInit:GetProcAddress failed\n");
        goto ErrorExit;
    }

    lpShimNtvdm = (LPFNSE_SHIMNTVDM)GetProcAddress(hModShimEng, "SE_ShimNTVDM");

    if(!lpShimNtvdm) {
        DPMDBGPRN("NTVDM::DpmfReg:DpmInit:GetProcAddress failed\n");
        goto ErrorExit;
    }

    // Patch the shim dispatch table with the shim function ptrs
    // If this fails we will stick with ptrs to the original API's
    (lpShimNtvdm)(pwszAppFilePath, hSdb, pSdbQuery, &VdmTbl);

    // Do this if you want dispatch directly to the shim functions
    // for(i = 0; i < numApis; i++) {
    //     pFN[i] = pShimTbl[i];
    // }
    // HeapFree(hHeap, 0, pShimTbl);
    // pFT->pDpmShmTbls = NULL;

    if(!TlsSetValue(dwTlsIndex, pFT)) {
        DPMDBGPRN("NTVDM::DpmfReg:DpmInit:TLS set failed\n");
        goto ErrorExit;
    }

    if(pApiDesc) {
        HeapFree(hHeap, 0, pApiDesc);
    }

    DPMDBGPRN1("  DpmfReg:Returning File I/o API tables: %#lx\n",pFT);
    return(pFT);

ErrorExit:
    DPMDBGPRN("  DpmfReg:Init failed: Returning NULL\n");
    DpmDestroyFamTable(pgDpmFamTbl, pFT);

    if(pApiDesc) {
        HeapFree(hHeap, 0, pApiDesc);
    }
    return(NULL);
}







void DpmDestroyFamTable(PFAMILY_TABLE pgDpmFamTbl, PFAMILY_TABLE pFT)
{
    PVDM_TIB       pVdmTib;
    PVOID         *pShimTbl;
    LPFNSE_REMOVENTVDM lpfnSE_RemoveNtvdmTask = NULL;

    DPMDBGPRN("NTVDM::DpmfReg:Destroying Registry API tables for task\n");

    // if this task is using the global table for this family, nothing to do
    if(!pFT || pFT == pgDpmFamTbl)
        return;

    pShimTbl = pFT->pDpmShmTbls;

    if(pShimTbl) {
        HeapFree(hHeap, 0, pShimTbl);
    }

    if(pFT->pfn) {
        HeapFree(hHeap, 0, pFT->pfn);
    }

    // See if the shim engine is attached & detach it
    if(pFT->hModShimEng) {

        lpfnSE_RemoveNtvdmTask =
           (LPFNSE_REMOVENTVDM)GetProcAddress(pFT->hModShimEng,
                                              "SE_RemoveNTVDMTask");

        if(lpfnSE_RemoveNtvdmTask) {
            (lpfnSE_RemoveNtvdmTask)(NtCurrentTeb()->ClientId.UniqueThread);
        }
        FreeLibrary(pFT->hModShimEng);
    }

    HeapFree(hHeap, 0, pFT);
}

// ^^^^^^^^^^ All the above should be in every DPM module.  ^^^^^^^^^^^^



// vvvvvvvvvv Define module specific stuff below. vvvvvvvvvvvv






ULONG dpmRegCloseKey(HKEY hKey)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegCloseKey: ");

    ret = SHM_RegCloseKey(hKey);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));
    
    return(ret);
}







ULONG dpmRegCreateKey(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    
    ULONG ret = 0;

    DPMDBGPRN("RegCreateKey: ");

    ret = SHM_RegCreateKey(hKey, lpSubKey, phkResult);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));
    
    return(ret);
}







ULONG dpmRegDeleteKey(HKEY hKey, LPCSTR lpSubKey)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegDeleteKey: ");

    ret = SHM_RegDeleteKey(hKey, lpSubKey);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}







ULONG dpmRegEnumKey(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegEnumKey: ");

    ret = SHM_RegEnumKey(hKey, dwIndex, lpName, cchName);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));
    
    return(ret);
}






ULONG dpmRegOpenKey(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegOpenKey: ");

    ret = SHM_RegOpenKey(hKey, lpSubKey, phkResult);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}








ULONG dpmRegQueryValue(HKEY hKey, 
                       LPCSTR lpSubKey, 
                       LPSTR lpValue, 
                       PLONG lpcbValue) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegQueryValue: ");

    ret = SHM_RegQueryValue(hKey, lpSubKey, lpValue, lpcbValue);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}







ULONG dpmRegSetValue(HKEY hKey, 
                     LPCSTR lpSubKey, 
                     DWORD dwType, 
                     LPCSTR lpData, 
                     DWORD cbData) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegSetValue: ");

    ret = SHM_RegSetValue(hKey, lpSubKey, dwType, lpData, cbData);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}








ULONG dpmRegDeleteValue(HKEY hKey, LPCSTR lpValueName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegDeleteValue: ");

    ret = SHM_RegDeleteValue(hKey, lpValueName); 

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}








ULONG dpmRegEnumValue(HKEY hKey, 
                      DWORD dwIndex, 
                      LPSTR lpValueName, 
                      LPDWORD lpcValueName, 
                      LPDWORD lpReserved, 
                      LPDWORD lpType, 
                      LPBYTE lpData, 
                      LPDWORD lpcbData) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegEnumValue: ");

    ret = SHM_RegEnumValue(hKey, 
                       dwIndex, 
                       lpValueName, 
                       lpcValueName, 
                       lpReserved, 
                       lpType, 
                       lpData, 
                       lpcbData);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}









ULONG dpmRegFlushKey(HKEY hKey)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegFlushKey: ");

    ret = SHM_RegFlushKey(hKey);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}








ULONG dpmRegLoadKey(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegLoadKey: ");

    ret = SHM_RegLoadKey(hKey, lpSubKey, lpFile);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}










ULONG dpmRegQueryValueEx(HKEY hKey, 
                         LPCSTR lpValueName, 
                         LPDWORD lpReserved, 
                         LPDWORD lpType, 
                         LPBYTE lpData, 
                         LPDWORD lpcbData) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegQueryValueEx: ");

    ret = SHM_RegQueryValueEx(hKey, 
                          lpValueName, 
                          lpReserved, 
                          lpType, 
                          lpData, 
                          lpcbData);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}










ULONG dpmRegSaveKey(HKEY hKey, 
                    LPCSTR lpFile, 
                    LPSECURITY_ATTRIBUTES lpSecurityAttributes) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegSaveKey: ");

    ret = SHM_RegSaveKey(hKey, lpFile, lpSecurityAttributes);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}











ULONG dpmRegSetValueEx(HKEY hKey, 
                       LPCSTR lpValueName, 
                       DWORD Reserved, 
                       DWORD dwType, 
                       CONST BYTE *lpData, 
                       DWORD cbData) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegSetValueEx: ");

    ret = SHM_RegSetValueEx(hKey, lpValueName, Reserved, dwType, lpData, cbData);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}










ULONG dpmRegUnLoadKey(HKEY hKey, LPCSTR lpSubKey)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegUnLoadKey: ");

    ret = SHM_RegUnLoadKey(hKey, lpSubKey);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}










ULONG dpmRegConnectRegistry(LPCSTR lpMachineName, 
                            HKEY hKey, 
                            PHKEY phkResult) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegConnectRegistry: ");

    ret = SHM_RegConnectRegistry(lpMachineName, hKey, phkResult);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}










ULONG dpmRegCreateKeyEx(HKEY hKey, 
                        LPCSTR lpSubKey, 
                        DWORD dwReserved, 
                        LPSTR lpClass, 
                        DWORD dwOptions, 
                        REGSAM samDesired, 
                        LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                        PHKEY phkResult, 
                        LPDWORD lpdwDisposition) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegCreateKeyEx: ");

    ret = SHM_RegCreateKeyEx(hKey, 
                         lpSubKey, 
                         dwReserved, 
                         lpClass, 
                         dwOptions, 
                         samDesired, 
                         lpSecurityAttributes, 
                         phkResult, 
                         lpdwDisposition);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}













ULONG dpmRegEnumKeyEx(HKEY hKey, 
                      DWORD dwIndex, 
                      LPSTR lpName, 
                      LPDWORD lpcName, 
                      LPDWORD lpReserved, 
                      LPSTR lpClass, 
                      LPDWORD lpcClass, 
                      PFILETIME lpftLastWriteTime) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegEnumKeyEx: ");

    ret = SHM_RegEnumKeyEx(hKey, 
                       dwIndex, 
                       lpName, 
                       lpcName, 
                       lpReserved, 
                       lpClass, 
                       lpcClass, 
                       lpftLastWriteTime);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}












ULONG dpmRegNotifyChangeKeyValue(HKEY hKey, 
                                 BOOL bWatchSubtree, 
                                 DWORD dwNotifyFilter, 
                                 HANDLE hEvent, 
                                 BOOL fAsynchronous)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    
    ULONG ret = 0;

    DPMDBGPRN("RegNotifyChangeKeyValue: ");

    ret = SHM_RegNotifyChangeKeyValue(hKey, 
                                  bWatchSubtree, 
                                  dwNotifyFilter, 
                                  hEvent, 
                                  fAsynchronous);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}









ULONG dpmRegOpenKeyEx(HKEY hKey, 
                      LPCSTR lpSubKey, 
                      DWORD ulOptions, 
                      REGSAM samDesired, 
                      PHKEY phkResult) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegOpenKeyEx: ");

    ret = SHM_RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}









ULONG dpmRegQueryInfoKey(HKEY hKey, 
                         LPSTR lpClass, 
                         LPDWORD lpcClass, 
                         LPDWORD lpReserved, 
                         LPDWORD lpcSubKeys, 
                         LPDWORD lpcMaxSubKeyLen, 
                         LPDWORD lpcMaxClassLen, 
                         LPDWORD lpcValues, 
                         LPDWORD lpcMaxValueNameLen, 
                         LPDWORD lpcMaxValueLen, 
                         LPDWORD lpcbSecurityDescriptor, 
                         PFILETIME lpftLastWriteTime) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegQueryInfoKey: ");

    ret = SHM_RegQueryInfoKey(hKey, 
                          lpClass, 
                          lpcClass, 
                          lpReserved, 
                          lpcSubKeys, 
                          lpcMaxSubKeyLen, 
                          lpcMaxClassLen, 
                          lpcValues, 
                          lpcMaxValueNameLen, 
                          lpcMaxValueLen, 
                          lpcbSecurityDescriptor, 
                          lpftLastWriteTime);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}











ULONG dpmRegQueryMultipleValues(HKEY hKey, 
                                PVALENT val_list, 
                                DWORD num_vals, 
                                LPSTR lpValueBuf, 
                                LPDWORD ldwTotsize) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegQueryMultipleValues: ");

    ret = SHM_RegQueryMultipleValues(hKey, 
                                 val_list, 
                                 num_vals, 
                                 lpValueBuf, 
                                 ldwTotsize);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}












ULONG dpmRegReplaceKey(HKEY hKey, 
                       LPCSTR lpSubKey, 
                       LPCSTR lpNewFile, 
                       LPCSTR lpOldFile) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegReplaceKey: ");

    ret = SHM_RegReplaceKey(hKey, lpSubKey, lpNewFile, lpOldFile);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}








ULONG dpmRegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    
    ULONG ret = 0;

    DPMDBGPRN("RegCreateKeyW ");

    ret = SHM_RegCreateKeyW(hKey, lpSubKey, phkResult);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));
    
    return(ret);
}







ULONG dpmRegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegDeleteKeyW ");

    ret = SHM_RegDeleteKeyW(hKey, lpSubKey);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}







ULONG dpmRegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegEnumKeyW ");

    ret = SHM_RegEnumKeyW(hKey, dwIndex, lpName, cchName);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));
    
    return(ret);
}






ULONG dpmRegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegOpenKeyW ");

    ret = SHM_RegOpenKeyW(hKey, lpSubKey, phkResult);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}








ULONG dpmRegQueryValueW(HKEY hKey, 
                        LPCWSTR lpSubKey, 
                        LPWSTR lpValue, 
                        PLONG lpcbValue) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegQueryValueW ");

    ret = SHM_RegQueryValueW(hKey, lpSubKey, lpValue, lpcbValue);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}







ULONG dpmRegSetValueW(HKEY hKey, 
                      LPCWSTR lpSubKey, 
                      DWORD dwType, 
                      LPCWSTR lpData, 
                      DWORD cbData) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegSetValueW ");

    ret = SHM_RegSetValueW(hKey, lpSubKey, dwType, lpData, cbData);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}








ULONG dpmRegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegDeleteValueW ");

    ret = SHM_RegDeleteValueW(hKey, lpValueName); 

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}








ULONG dpmRegEnumValueW(HKEY hKey, 
                       DWORD dwIndex, 
                       LPWSTR lpValueName, 
                       LPDWORD lpcValueName, 
                       LPDWORD lpReserved, 
                       LPDWORD lpType, 
                       LPBYTE lpData, 
                       LPDWORD lpcbData) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegEnumValueW ");

    ret = SHM_RegEnumValueW(hKey, 
                        dwIndex, 
                        lpValueName, 
                        lpcValueName, 
                        lpReserved, 
                        lpType, 
                        lpData, 
                        lpcbData);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}









ULONG dpmRegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegLoadKeyW ");

    ret = SHM_RegLoadKeyW(hKey, lpSubKey, lpFile);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}










ULONG dpmRegQueryValueExW(HKEY hKey, 
                          LPCWSTR lpValueName, 
                          LPDWORD lpReserved, 
                          LPDWORD lpType, 
                          LPBYTE  lpData, 
                          LPDWORD lpcbData) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegQueryValueExW ");

    ret = SHM_RegQueryValueExW(hKey, 
                           lpValueName, 
                           lpReserved, 
                           lpType, 
                           lpData, 
                           lpcbData);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}










ULONG dpmRegSaveKeyW(HKEY hKey, 
                     LPCWSTR lpFile, 
                     LPSECURITY_ATTRIBUTES lpSecurityAttributes) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegSaveKeyW ");

    ret = SHM_RegSaveKeyW(hKey, lpFile, lpSecurityAttributes);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}











ULONG dpmRegSetValueExW(HKEY hKey, 
                        LPCWSTR lpValueName, 
                        DWORD Reserved, 
                        DWORD dwType, 
                        CONST BYTE *lpData, 
                        DWORD cbData) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegSetValueExW "); 

    ret = SHM_RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}










ULONG dpmRegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegUnLoadKeyW ");

    ret = SHM_RegUnLoadKeyW(hKey, lpSubKey);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}










ULONG dpmRegConnectRegistryW(LPCWSTR lpMachineName, 
                             HKEY hKey, 
                             PHKEY phkResult) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegConnectRegistryW ");

    ret = SHM_RegConnectRegistryW(lpMachineName, hKey, phkResult);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}










ULONG dpmRegCreateKeyExW(HKEY hKey, 
                         LPCWSTR lpSubKey, 
                         DWORD dwReserved, 
                         LPWSTR lpClass, 
                         DWORD dwOptions, 
                         REGSAM samDesired, 
                         LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                         PHKEY phkResult, 
                         LPDWORD lpdwDisposition) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegCreateKeyExW "); 

    ret = SHM_RegCreateKeyExW(hKey, 
                          lpSubKey, 
                          dwReserved, 
                          lpClass, 
                          dwOptions, 
                          samDesired, 
                          lpSecurityAttributes, 
                          phkResult, 
                          lpdwDisposition);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}













ULONG dpmRegEnumKeyExW(HKEY hKey, 
                       DWORD dwIndex, 
                       LPWSTR lpName, 
                       LPDWORD lpcName, 
                       LPDWORD lpReserved, 
                       LPWSTR lpClass, 
                       LPDWORD lpcClass, 
                       PFILETIME lpftLastWriteTime) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegEnumKeyExW "); 

    ret = SHM_RegEnumKeyExW(hKey, 
                        dwIndex, 
                        lpName, 
                        lpcName, 
                        lpReserved, 
                        lpClass, 
                        lpcClass, 
                        lpftLastWriteTime);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}













ULONG dpmRegOpenKeyExW(HKEY hKey, 
                       LPCWSTR lpSubKey, 
                       DWORD ulOptions, 
                       REGSAM samDesired, 
                       PHKEY phkResult) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegOpenKeyExW ");

    ret = SHM_RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}









ULONG dpmRegQueryInfoKeyW(HKEY hKey, 
                          LPWSTR lpClass, 
                          LPDWORD lpcClass, 
                          LPDWORD lpReserved, 
                          LPDWORD lpcSubKeys, 
                          LPDWORD lpcMaxSubKeyLen, 
                          LPDWORD lpcMaxClassLen, 
                          LPDWORD lpcValues, 
                          LPDWORD lpcMaxValueNameLen, 
                          LPDWORD lpcMaxValueLen, 
                          LPDWORD lpcbSecurityDescriptor, 
                          PFILETIME lpftLastWriteTime) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegQueryInfoKeyW "); 

    ret = SHM_RegQueryInfoKeyW(hKey, 
                           lpClass, 
                           lpcClass, 
                           lpReserved, 
                           lpcSubKeys, 
                           lpcMaxSubKeyLen, 
                           lpcMaxClassLen, 
                           lpcValues, 
                           lpcMaxValueNameLen, 
                           lpcMaxValueLen, 
                           lpcbSecurityDescriptor, 
                           lpftLastWriteTime);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}











ULONG dpmRegQueryMultipleValuesW(HKEY hKey, 
                                 PVALENTW val_list, 
                                 DWORD num_vals, 
                                 LPWSTR lpValueBuf, 
                                 LPDWORD ldwTotsize) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegQueryMultipleValuesW ");

    ret = SHM_RegQueryMultipleValuesW(hKey, 
                                  val_list, 
                                  num_vals, 
                                  lpValueBuf, 
                                  ldwTotsize);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}












ULONG dpmRegReplaceKeyW(HKEY hKey, 
                        LPCWSTR lpSubKey, 
                        LPCWSTR lpNewFile, 
                        LPCWSTR lpOldFile) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("RegReplaceKeyW ");

    ret = SHM_RegReplaceKeyW(hKey, lpSubKey, lpNewFile, lpOldFile);

    DPMDBGPRN1("  -> %s\n", RETSTR(ret));

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpm\inc\dpmdbg.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 2002, Microsoft Corporation
 *
 *  dpmdbg.h
 *  WOW32 Dynamic Patch Module Debug print macros
 *
 *  History:
 *  Created 01-10-2002 by cmjones
 *  
--*/
#ifndef _DPMDBG_H_
#define _DPMDBG_H_

#include <stdarg.h>
#include <stdio.h>


#ifdef DBG
VOID dpmlogprintf(LPCSTR pszFmt, ...);
VOID dpmlogprintfW(LPCWSTR pszFmt, ...);


VOID dpmlogprintf(LPCSTR pszFmt, ...)
{
    int  len;
    va_list arglist;
    char buffer[512];

    if(dwLogLevel) {

        va_start(arglist, pszFmt);

        len = vsprintf(buffer, pszFmt, arglist);

        OutputDebugString(buffer);
    
        va_end(arglist);
    }
}

/*
VOID dpmlogprintfW(LPCWSTR pszFmt, ...)
{
    int  len;
    va_list arglist;
    wchar_t buffer[512];


    if(dwLogLevel) {

        va_start(arglist, pszFmt);

// this is not linked unless UNICODE is defined
//        len = vswprintf(buffer, pszFmt, arglist);

        OutputDebugStringW(buffer);

        va_end(arglist);
    }
}
*/

char szNULL[] = "NULL";
#define BIF(a)    ((a!=0) ? "TRUE" : "FALSE")     // boolean
#define PIF(a)    ((a!=0) ? *a : 0)               // value @pointer
#define SIF(a)    ((a!=NULL) ? a : szNULL)        // string
#define RETSTR(a) ((a==0) ? "SUCCESS" : "FAILED") // return
/* Turn these off for now -- until I can make the string buffer checks safe */
#ifdef _SAFE_BUFFERS_IMPLEMENTED_
#define DPMDBGPRN(fmt)                       dpmlogprintf(fmt)
#define DPMDBGPRN1(fmt,a)                    dpmlogprintf(fmt,a)
#define DPMDBGPRN2(fmt,a,b)                  dpmlogprintf(fmt,a,b)
#define DPMDBGPRN3(fmt,a,b,c)                dpmlogprintf(fmt,a,b,c)
#define DPMDBGPRN4(fmt,a,b,c,d)              dpmlogprintf(fmt,a,b,c,d)
#define DPMDBGPRN5(fmt,a,b,c,d,e)            dpmlogprintf(fmt,a,b,c,d,e)
#define DPMDBGPRN6(fmt,a,b,c,d,e,f)          dpmlogprintf(fmt,a,b,c,d,e,f)
#define DPMDBGPRN7(fmt,a,b,c,d,e,f,g)        dpmlogprintf(fmt,a,b,c,d,e,f,g)
#define DPMDBGPRN8(fmt,a,b,c,d,e,f,g,h)      dpmlogprintf(fmt,a,b,c,d,e,f,g,h)
#define DPMDBGPRN9(fmt,a,b,c,d,e,f,g,h,i)                                      \
                 dpmlogprintf(fmt,a,b,c,d,e,f,g,h,i)
#define DPMDBGPRN10(fmt,a,b,c,d,e,f,g,h,i,j)                                   \
                 dpmlogprintf(fmt,a,b,c,d,e,f,g,h,i,j)
#define DPMDBGPRN11(fmt,a,b,c,d,e,f,g,h,i,j,k)                                 \
                 dpmlogprintf(fmt,a,b,c,d,e,f,g,h,i,j,k)
#define DPMDBGPRN12(fmt,a,b,c,d,e,f,g,h,i,j,k,l)                               \
                 dpmlogprintf(fmt,a,b,c,d,e,f,g,h,i,j,k,l)
#define DPMDBGPRN13(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m)                             \
                 dpmlogprintf(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m)
#define DPMDBGPRN14(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n)                           \
                 dpmlogprintf(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
#define DPMDBGPRN15(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)                         \
                 dpmlogprintf(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
#else  // _SAFE_BUFFERS_IMPLEMENTED_
#define DPMDBGPRN(fmt)                                       dpmlogprintf(fmt)
#define DPMDBGPRN1(fmt,a)                                    dpmlogprintf(fmt,a)
#define DPMDBGPRN2(fmt,a,b)                                  dpmlogprintf(fmt,a)
#define DPMDBGPRN3(fmt,a,b,c)                                dpmlogprintf(fmt,a)
#define DPMDBGPRN4(fmt,a,b,c,d)                              dpmlogprintf(fmt,a)
#define DPMDBGPRN5(fmt,a,b,c,d,e)                            dpmlogprintf(fmt,a)
#define DPMDBGPRN6(fmt,a,b,c,d,e,f)                          dpmlogprintf(fmt,a)
#define DPMDBGPRN7(fmt,a,b,c,d,e,f,g)                        dpmlogprintf(fmt,a)
#define DPMDBGPRN8(fmt,a,b,c,d,e,f,g,h)                      dpmlogprintf(fmt,a)
#define DPMDBGPRN9(fmt,a,b,c,d,e,f,g,h,i)                    dpmlogprintf(fmt,a)
#define DPMDBGPRN10(fmt,a,b,c,d,e,f,g,h,i,j)                 dpmlogprintf(fmt,a)
#define DPMDBGPRN11(fmt,a,b,c,d,e,f,g,h,i,j,k)               dpmlogprintf(fmt,a)
#define DPMDBGPRN12(fmt,a,b,c,d,e,f,g,h,i,j,k,l)             dpmlogprintf(fmt,a)
#define DPMDBGPRN13(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m)           dpmlogprintf(fmt,a)
#define DPMDBGPRN14(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n)         dpmlogprintf(fmt,a)
#define DPMDBGPRN15(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)       dpmlogprintf(fmt,a)
#endif // !_SAFE_BUFFERS_IMPLEMENTED_



/*
wchar_t szNULLW[] = L"NULL";
#define BIFW(a)    ((a!=0) ? L"TRUE" : L"FALSE")     // boolean
#define PIF(a)     ((a!=0) ? *a : 0)                 // value @pointer
#define SIFW(a)    ((a!=NULL) ? a : szNULLW)         // string
#define RETSTRW(a) ((a==0) ? L"SUCCESS" : L"FAILED") // return

#define DPMDBGPRNW(fmt)                       dpmlogprintfW(fmt)
#define DPMDBGPRNW1(fmt,a)                    dpmlogprintfW(fmt,a)
#define DPMDBGPRNW2(fmt,a,b)                  dpmlogprintfW(fmt,a,b)
#define DPMDBGPRNW3(fmt,a,b,c)                dpmlogprintfW(fmt,a,b,c)
#define DPMDBGPRNW4(fmt,a,b,c,d)              dpmlogprintfW(fmt,a,b,c,d)
#define DPMDBGPRNW5(fmt,a,b,c,d,e)            dpmlogprintfW(fmt,a,b,c,d,e)
#define DPMDBGPRNW6(fmt,a,b,c,d,e,f)          dpmlogprintfW(fmt,a,b,c,d,e,f)
#define DPMDBGPRNW7(fmt,a,b,c,d,e,f,g)        dpmlogprintfW(fmt,a,b,c,d,e,f,g)
#define DPMDBGPRNW8(fmt,a,b,c,d,e,f,g,h)      dpmlogprintfW(fmt,a,b,c,d,e,f,g,h)
#define DPMDBGPRNW9(fmt,a,b,c,d,e,f,g,h,i)                                     \
                 dpmlogprintfW(fmt,a,b,c,d,e,f,g,h,i)
#define DPMDBGPRNW10(fmt,a,b,c,d,e,f,g,h,i,j)                                  \
                 dpmlogprintfW(fmt,a,b,c,d,e,f,g,h,i,j)
#define DPMDBGPRNW11(fmt,a,b,c,d,e,f,g,h,i,j,k)                                \
                 dpmlogprintfW(fmt,a,b,c,d,e,f,g,h,i,j,k)
#define DPMDBGPRNW12(fmt,a,b,c,d,e,f,g,h,i,j,k,l)                              \
                 dpmlogprintfW(fmt,a,b,c,d,e,f,g,h,i,j,k,l)
#define DPMDBGPRNW13(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m)                            \
                 dpmlogprintfW(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m)
#define DPMDBGPRNW14(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n)                          \
                 dpmlogprintfW(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
#define DPMDBGPRNW15(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)                        \
                 dpmlogprintfW(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
*/

// turn these off for now until we can fix vswprintf()
#define DPMDBGPRNW(fmt)  
#define DPMDBGPRNW1(fmt,a)
#define DPMDBGPRNW2(fmt,a,b)
#define DPMDBGPRNW3(fmt,a,b,c)
#define DPMDBGPRNW4(fmt,a,b,c,d)
#define DPMDBGPRNW5(fmt,a,b,c,d,e)
#define DPMDBGPRNW6(fmt,a,b,c,d,e,f)
#define DPMDBGPRNW7(fmt,a,b,c,d,e,f,g)
#define DPMDBGPRNW8(fmt,a,b,c,d,e,f,g,h)
#define DPMDBGPRNW9(fmt,a,b,c,d,e,f,g,h,i)
#define DPMDBGPRNW10(fmt,a,b,c,d,e,f,g,h,i,j)
#define DPMDBGPRNW11(fmt,a,b,c,d,e,f,g,h,i,j,k)
#define DPMDBGPRNW12(fmt,a,b,c,d,e,f,g,h,i,j,k,l)
#define DPMDBGPRNW13(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m)
#define DPMDBGPRNW14(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
#define DPMDBGPRNW15(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)

#else // !DBG

#define DPMDBGPRN(fmt)  
#define DPMDBGPRN1(fmt,a)
#define DPMDBGPRN2(fmt,a,b)
#define DPMDBGPRN3(fmt,a,b,c)
#define DPMDBGPRN4(fmt,a,b,c,d)
#define DPMDBGPRN5(fmt,a,b,c,d,e)
#define DPMDBGPRN6(fmt,a,b,c,d,e,f)
#define DPMDBGPRN7(fmt,a,b,c,d,e,f,g)
#define DPMDBGPRN8(fmt,a,b,c,d,e,f,g,h)
#define DPMDBGPRN9(fmt,a,b,c,d,e,f,g,h,i)
#define DPMDBGPRN10(fmt,a,b,c,d,e,f,g,h,i,j)
#define DPMDBGPRN11(fmt,a,b,c,d,e,f,g,h,i,j,k)
#define DPMDBGPRN12(fmt,a,b,c,d,e,f,g,h,i,j,k,l)
#define DPMDBGPRN13(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m)
#define DPMDBGPRN14(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
#define DPMDBGPRN15(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)

#define DPMDBGPRNW(fmt)  
#define DPMDBGPRNW1(fmt,a)
#define DPMDBGPRNW2(fmt,a,b)
#define DPMDBGPRNW3(fmt,a,b,c)
#define DPMDBGPRNW4(fmt,a,b,c,d)
#define DPMDBGPRNW5(fmt,a,b,c,d,e)
#define DPMDBGPRNW6(fmt,a,b,c,d,e,f)
#define DPMDBGPRNW7(fmt,a,b,c,d,e,f,g)
#define DPMDBGPRNW8(fmt,a,b,c,d,e,f,g,h)
#define DPMDBGPRNW9(fmt,a,b,c,d,e,f,g,h,i)
#define DPMDBGPRNW10(fmt,a,b,c,d,e,f,g,h,i,j)
#define DPMDBGPRNW11(fmt,a,b,c,d,e,f,g,h,i,j,k)
#define DPMDBGPRNW12(fmt,a,b,c,d,e,f,g,h,i,j,k,l)
#define DPMDBGPRNW13(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m)
#define DPMDBGPRNW14(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
#define DPMDBGPRNW15(fmt,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
#endif // !DBG

#endif _DPMDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpm\prffam\dpmfprf.c ===
//************************************************************************
//
// dpmfprf.c : Dynamic Patch Module for Profile API family
//
// History:
//    19-jan-02   cmjones    created it.
//
//************************************************************************
#ifdef DBG
unsigned long dwLogLevel = 0;
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "dpmtbls.h"
#include "dpmdbg.h"   // include handy debug print macros
#include "shimdb.h" 

BOOL          DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext);
PFAMILY_TABLE DpmInitFamTable(PFAMILY_TABLE, 
                              HMODULE, 
                              PVOID, 
                              PVOID, 
                              LPWSTR, 
                              PDPMMODULESETS);
void          DpmDestroyFamTable(PFAMILY_TABLE pgDpmFamTbl, PFAMILY_TABLE pFT);


#define GROW_HEAP_AS_NEEDED 0
HANDLE  hHeap = NULL;

DWORD    dwTlsIndex;
char     szShimEngDll[] = "\\ShimEng.dll";

BOOL DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext)
{
    BOOL bRet = TRUE;

    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(pContext);

    switch(Reason) {

        case DLL_PROCESS_ATTACH:
    
            if((hHeap = HeapCreate(0, 4096, GROW_HEAP_AS_NEEDED)) == NULL) {
                DPMDBGPRN("NTVDM::DpmfPrf:Can't initialize heap!\n");
                bRet = FALSE;
            }

            dwTlsIndex = TlsAlloc();
            if(dwTlsIndex == TLS_OUT_OF_INDEXES) {
                DPMDBGPRN("NTVDM::DpmfPrf:Can't initialize TLS!\n");
                bRet = FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:
            if(hHeap) {
                HeapDestroy(hHeap);
            }
            TlsFree(dwTlsIndex);
            break;
    }

    return bRet;
}




PFAMILY_TABLE DpmInitFamTable(PFAMILY_TABLE  pgDpmFamTbl, 
                              HMODULE        hMod, 
                              PVOID          hSdb, 
                              PVOID          pSdbQuery, 
                              LPWSTR         pwszAppFilePath, 
                              PDPMMODULESETS pModSet)
{
    int            i, numApis, len;
    PVOID          lpdpmfn;
    PFAMILY_TABLE  pFT = NULL;
    PVOID         *pFN = NULL;
    PVOID         *pShimTbl = NULL;
    PAPIDESC       pApiDesc = NULL;
    VDMTABLE       VdmTbl;
    char           szShimEng[MAX_PATH];
    HMODULE        hModShimEng = NULL;
    LPFNSE_SHIMNTVDM lpShimNtvdm;

    DPMDBGPRN("NTVDM::DpmfPrf:Initialziing File I/O API tables\n");


    // Get hooked API count from global table
    numApis = pgDpmFamTbl->numHookedAPIs;

    // Allocate a new family table
    pFT = (PFAMILY_TABLE)HeapAlloc(hHeap, 
                                   HEAP_ZERO_MEMORY, 
                                   sizeof(FAMILY_TABLE));
    if(!pFT) {
        DPMDBGPRN("NTVDM::DpmfPrf:DpmInit:malloc 1 failed\n");
        goto ErrorExit;
    }

    // Allocate the shim dispatch table for this family in this task
    pShimTbl = (PVOID *)HeapAlloc(hHeap,
                                  HEAP_ZERO_MEMORY,
                                  numApis * sizeof(PVOID));
    if(!pShimTbl) {
        DPMDBGPRN("NTVDM::DpmfPrf:DpmInit:malloc 2 failed\n");
        goto ErrorExit;
    }
    pFT->pDpmShmTbls = pShimTbl; 

    // Allocate an array of ptrs to hooked API's
    pFN = (PVOID *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, numApis * sizeof(PVOID));

    if(!pFN) {
        DPMDBGPRN("NTVDM::DpmfPrf:DpmInit:malloc 3 failed\n");
        goto ErrorExit;
    }
    pFT->pfn = pFN;

    pFT->numHookedAPIs = numApis;
    pFT->hMod          = hMod;

    // Allocate a temp array of APIDESC structs to help attach shims
    pApiDesc = (PAPIDESC)HeapAlloc(hHeap,
                                   HEAP_ZERO_MEMORY,
                                   numApis * sizeof(APIDESC));
    if(!pApiDesc) {
        DPMDBGPRN("NTVDM::DpmfPrf:DpmInit:malloc 4 failed\n");
        goto ErrorExit;
    }
    VdmTbl.nApiCount = numApis;
    VdmTbl.ppfnOrig = pShimTbl;
    VdmTbl.pApiDesc = pApiDesc;

    // Fill in the family table with ptrs to the patch functions in this DLL.
    for(i = 0; i < numApis; i++) {

        // must start with 1 since EXPORT ordinals can't be == 0
        lpdpmfn = (PVOID)GetProcAddress(hMod, (LPCSTR)MAKELONG(i+1, 0));
        if(!lpdpmfn) {
            DPMDBGPRN("NTVDM::DpmfPrf:DpmInit:Unable to get proc address\n");
            goto ErrorExit;
        }

        // save ptr to the real API in the shim table until it gets shimmed
        pShimTbl[i] = pgDpmFamTbl->pfn[i];

        // relate the corresponding module and API name to the API function ptr
        pApiDesc[i].pszModule = (char *)pModSet->ApiModuleName;
        pApiDesc[i].pszApi    = (char *)pModSet->ApiNames[i];

        // save ptr to the patch function
        pFN[i] = lpdpmfn;

    }

    // Only do this if we need to attach the shim engine.
    GetSystemDirectory(szShimEng, MAX_PATH);
    strcat(szShimEng, szShimEngDll);
    hModShimEng = LoadLibrary(szShimEng);
    pFT->hModShimEng = hModShimEng;

    if(NULL == hModShimEng) {
        DPMDBGPRN("NTVDM::dpmfprf:DpmInit:ShimEng load failed\n");
        goto ErrorExit;
    }

    lpShimNtvdm = (LPFNSE_SHIMNTVDM)GetProcAddress(hModShimEng, "SE_ShimNTVDM");

    if(!lpShimNtvdm) {
        DPMDBGPRN("NTVDM::DpmfPrf:DpmInit:GetProcAddress failed\n");
        goto ErrorExit;
    }

    // Patch the shim dispatch table with the shim function ptrs
    // If this fails we will stick with ptrs to the original API's
    (lpShimNtvdm)(pwszAppFilePath, hSdb, pSdbQuery, &VdmTbl);

    // Do this if you want dispatch directly to the shim functions
    // for(i = 0; i < numApis; i++) {
    //     pFN[i] = pShimTbl[i];
    // }
    // HeapFree(hHeap, 0, pShimTbl);
    // pFT->pDpmShmTbls = NULL;

    if(!TlsSetValue(dwTlsIndex, pFT)) {
        DPMDBGPRN("NTVDM::DpmfPrf:DpmInit:TLS set failed\n");
        goto ErrorExit;
    }

    if(pApiDesc) {
        HeapFree(hHeap, 0, pApiDesc);
    }

    DPMDBGPRN1("  DpmfPrf:Returning File I/o API tables: %#lx\n",pFT);
    return(pFT);

ErrorExit:
    DPMDBGPRN("  DpmfPrf:Init failed: Returning NULL\n");
    DpmDestroyFamTable(pgDpmFamTbl, pFT);

    if(pApiDesc) {
        HeapFree(hHeap, 0, pApiDesc);
    }
    return(NULL);
}







void DpmDestroyFamTable(PFAMILY_TABLE pgDpmFamTbl, PFAMILY_TABLE pFT)
{
    PVDM_TIB       pVdmTib;
    PVOID         *pShimTbl;
    LPFNSE_REMOVENTVDM lpfnSE_RemoveNtvdmTask = NULL;


    DPMDBGPRN("NTVDM::DpmfPrf:Destroying Profile API tables for task\n");

    // if this task is using the global table for this family, nothing to do
    if(!pFT || pFT == pgDpmFamTbl)
        return;

    pShimTbl = pFT->pDpmShmTbls;

    if(pShimTbl) {
        HeapFree(hHeap, 0, pShimTbl);
    }

    if(pFT->pfn) {
        HeapFree(hHeap, 0, pFT->pfn);
    }

    // See if the shim engine is attached & detach it
    if(pFT->hModShimEng) {

        lpfnSE_RemoveNtvdmTask =
           (LPFNSE_REMOVENTVDM)GetProcAddress(pFT->hModShimEng,
                                              "SE_RemoveNTVDMTask");

        if(lpfnSE_RemoveNtvdmTask) {
            (lpfnSE_RemoveNtvdmTask)(NtCurrentTeb()->ClientId.UniqueThread);
        }
        FreeLibrary(pFT->hModShimEng);
    }

    HeapFree(hHeap, 0, pFT);
}

// ^^^^^^^^^^ All the above should be in every DPM module.  ^^^^^^^^^^^^



// vvvvvvvvvv Define module specific stuff below. vvvvvvvvvvvv



ULONG dpmGetPrivateProfileInt(LPCSTR lpszSection, 
                              LPCSTR lpszEntry, 
                              int    iDefault, 
                              LPCSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetPrivateProfileInt: ");

    ret = SHM_GetPrivateProfileInt(lpszSection, lpszEntry, iDefault, lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}







ULONG dpmGetPrivateProfileString(LPCSTR lpszSection, 
                                 LPCSTR lpszEntry, 
                                 LPCSTR lpszDefault, 
                                 LPSTR  lpszRetBuf, 
                                 int    cbRetBuf, 
                                 LPCSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetPrivateProfileString: ");

    ret = SHM_GetPrivateProfileString(lpszSection, 
                                  lpszEntry, 
                                  lpszDefault, 
                                  lpszRetBuf, 
                                  cbRetBuf, 
                                  lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}








ULONG dpmGetProfileInt(LPCSTR lpszSection, LPCSTR lpszEntry, int iDefault)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetProfileInt: ");

    ret = SHM_GetProfileInt(lpszSection, lpszEntry, iDefault);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}









ULONG dpmGetProfileString(LPCSTR lpszSection, 
                          LPCSTR lpszEntry, 
                          LPCSTR lpszDefault, 
                          LPSTR  lpszRetBuf, 
                          int    cbRetBuf)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetProfileString: ");

    ret = SHM_GetProfileString(lpszSection, 
                           lpszEntry, 
                           lpszDefault, 
                           lpszRetBuf, 
                           cbRetBuf);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}








ULONG dpmWritePrivateProfileString(LPCSTR lpszSection, 
                                   LPCSTR lpszEntry, 
                                   LPCSTR lpszString, 
                                   LPCSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("WritePrivateProfileString: ");

    ret = SHM_WritePrivateProfileString(lpszSection, 
                                    lpszEntry, 
                                    lpszString,
                                    lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}








ULONG dpmWriteProfileString(LPCSTR lpszSection, 
                            LPCSTR lpszEntry, 
                            LPCSTR lpszString)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("WriteProfileString: ");

    ret = SHM_WriteProfileString(lpszSection, 
                             lpszEntry, 
                             lpszString);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}






ULONG dpmWritePrivateProfileSection(LPCSTR lpszSection, 
                                    LPCSTR lpszString, 
                                    LPCSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("WritePrivateProfileSection: ");

    ret = SHM_WritePrivateProfileSection(lpszSection, 
                                     lpszString, 
                                     lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}







ULONG dpmGetPrivateProfileSection(LPCSTR lpszSection, 
                                  LPSTR  lpszRetString, 
                                  DWORD  dwSize,
                                  LPCSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetPrivateProfileSection: ");

    ret = SHM_GetPrivateProfileSection(lpszSection, 
                                   lpszRetString, 
                                   dwSize,
                                   lpszFileName);

    DPMDBGPRN1("  -> %d\n",  ((int)(ret)));
    
    return(ret);
}







ULONG dpmGetProfileSection(LPCSTR lpszSection, 
                           LPSTR  lpszRetString, 
                           DWORD  dwSize) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetProfileSection: ");

    ret = SHM_GetProfileSection(lpszSection, 
                            lpszRetString, 
                            dwSize);

    DPMDBGPRN1("  -> %d\n",  ((int)(ret)));
    
    return(ret);
}







ULONG dpmGetPrivateProfileSectionNames(LPSTR  lpszRetBuf, 
                                       DWORD  dwSize,
                                       LPCSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetPrivateProfileSectionNames: ");

    ret = SHM_GetPrivateProfileSectionNames(lpszRetBuf, 
                                        dwSize,
                                        lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}




/* This isn't an API

ULONG dpmGetProfileSectionNames(LPSTR  lpszRetBuf, DWORD  dwSize)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetProfileSectionNames: ");

    ret = SHM_GetProfileSectionNames(lpszRetBuf, 
                                 dwSize);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}
*/







ULONG dpmGetPrivateProfileStruct(LPCSTR lpszSection, 
                                 LPCSTR lpszKey, 
                                 LPVOID lpStruct,
                                 UINT   cbSize,
                                 LPCSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetPrivateProfileStruct: ");

    ret = SHM_GetPrivateProfileStruct(lpszSection, 
                                  lpszKey, 
                                  lpStruct,
                                  cbSize,
                                  lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}






ULONG dpmWritePrivateProfileStruct(LPCSTR lpszSection, 
                                   LPCSTR lpszKey, 
                                   LPVOID lpStruct,
                                   UINT   cbSize,
                                   LPCSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("WritePrivateProfileStruct: ");

    ret = SHM_WritePrivateProfileStruct(lpszSection, 
                                    lpszKey, 
                                    lpStruct,
                                    cbSize,
                                    lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}






ULONG dpmWriteProfileSection(LPCSTR lpszSection, LPCSTR lpszString)
              
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("WriteProfileSection: ");

    ret = SHM_WriteProfileSection(lpszSection, 
                              lpszString);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}







ULONG dpmGetPrivateProfileIntW(LPCWSTR lpszSection, 
                               LPCWSTR lpszEntry, 
                               int    iDefault, 
                               LPCWSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetPrivateProfileIntW ");

    ret = SHM_GetPrivateProfileIntW(lpszSection, lpszEntry, iDefault, lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}







ULONG dpmGetPrivateProfileStringW(LPCWSTR lpszSection, 
                                  LPCWSTR lpszEntry, 
                                  LPCWSTR lpszDefault, 
                                  LPWSTR  lpszRetBuf, 
                                  int     cbRetBuf, 
                                  LPCWSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetPrivateProfileStringW ");

    ret = SHM_GetPrivateProfileStringW(lpszSection, 
                                   lpszEntry, 
                                   lpszDefault, 
                                   lpszRetBuf, 
                                   cbRetBuf, 
                                   lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}








ULONG dpmGetProfileIntW(LPCWSTR lpszSection, LPCWSTR lpszEntry, int iDefault)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetProfileIntW ");

    ret = SHM_GetProfileIntW(lpszSection, lpszEntry, iDefault);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}









ULONG dpmGetProfileStringW(LPCWSTR lpszSection, 
                           LPCWSTR lpszEntry, 
                           LPCWSTR lpszDefault, 
                           LPWSTR  lpszRetBuf, 
                           int     cbRetBuf)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetProfileStringW ");

    ret = SHM_GetProfileStringW(lpszSection, 
                            lpszEntry, 
                            lpszDefault, 
                            lpszRetBuf, 
                            cbRetBuf);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}








ULONG dpmWritePrivateProfileStringW(LPCWSTR lpszSection, 
                                    LPCWSTR lpszEntry, 
                                    LPCWSTR lpszString, 
                                    LPCWSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("WritePrivateProfileStringW ");

    ret = SHM_WritePrivateProfileStringW(lpszSection, 
                                     lpszEntry, 
                                     lpszString,
                                     lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}








ULONG dpmWriteProfileStringW(LPCWSTR lpszSection, 
                             LPCWSTR lpszEntry, 
                             LPCWSTR lpszString)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("WriteProfileStringW ");

    ret = SHM_WriteProfileStringW(lpszSection, 
                              lpszEntry, 
                              lpszString);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}






ULONG dpmWritePrivateProfileSectionW(LPCWSTR lpszSection, 
                                     LPCWSTR lpszString, 
                                     LPCWSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("WritePrivateProfileSectionW ");

    ret = SHM_WritePrivateProfileSectionW(lpszSection, 
                                      lpszString, 
                                      lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}







ULONG dpmGetPrivateProfileSectionW(LPCWSTR lpszSection, 
                                   LPWSTR  lpszRetString, 
                                   DWORD   dwSize,
                                   LPCWSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetPrivateProfileSectionW ");

    ret = SHM_GetPrivateProfileSectionW(lpszSection, 
                                    lpszRetString, 
                                    dwSize,
                                    lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}






ULONG dpmGetProfileSectionW(LPCWSTR lpszSection, 
                            LPWSTR  lpszRetString, 
                            DWORD   dwSize) 
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetProfileSectionW ");

    ret = SHM_GetProfileSectionW(lpszSection, 
                             lpszRetString, 
                             dwSize);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}







ULONG dpmGetPrivateProfileSectionNamesW(LPWSTR  lpszRetBuf, 
                                        DWORD   dwSize,
                                        LPCWSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetPrivateProfileSectionNamesW ");

    ret = SHM_GetPrivateProfileSectionNamesW(lpszRetBuf, 
                                         dwSize,
                                         lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}







ULONG dpmGetPrivateProfileStructW(LPCWSTR lpszSection, 
                                  LPCWSTR  lpszKey, 
                                  LPVOID   lpStruct,
                                  UINT     cbSize,
                                  LPCWSTR  lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("GetPrivateProfileStructW ");

    ret = SHM_GetPrivateProfileStructW(lpszSection, 
                                   lpszKey, 
                                   lpStruct,
                                   cbSize,
                                   lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}






ULONG dpmWritePrivateProfileStructW(LPCWSTR lpszSection, 
                                    LPCWSTR lpszKey, 
                                    LPVOID  lpStruct,
                                    UINT    cbSize,
                                    LPCWSTR lpszFileName)
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("WritePrivateProfileStructW ");

    ret = SHM_WritePrivateProfileStructW(lpszSection, 
                                     lpszKey, 
                                     lpStruct,
                                     cbSize,
                                     lpszFileName);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}






ULONG dpmWriteProfileSectionW(LPCWSTR lpszSection, LPCWSTR lpszString)
              
{
    PFAMILY_TABLE pFT = (PFAMILY_TABLE)TlsGetValue(dwTlsIndex);
    ULONG ret = 0;

    DPMDBGPRN("WriteProfileSectionW ");

    ret = SHM_WriteProfileSectionW(lpszSection, 
                              lpszString);

    DPMDBGPRN1("  -> %d\n", ((int)(ret)));
    
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxboot.asm ===
PAGE    ,132
        TITLE   DXBOOT.ASM -- Dos Extender Startup Code

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXBOOT.ASM      -   Dos Extender Startup Code           *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains real mode initialization code that     *
;*  initializes the dos extender itself.  This includes         *
;*  allocating and initializing the descriptor tables, and      *
;*  relocating the dos extender for protected mode operation.   *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  01/29/92 mattfe Build for MIPS                              *
;*  12/19/90 amitc  NetHeapSize default made 4k from 8k         *
;*  12/03/90 amitc  Added support for 'Win30CommDriver' switch  *
;                   in system.ini                               *
;*  10/09/90 earleh split LDT from GDT and reduced XMS handles  *
;*                  needed to boot program to 1                 *
;*  08/08/90 earleh DOSX and client privilege ring determined   *
;*                  by equate in pmdefs.inc                     *
;*  05/07/90 jimmat Started VCPI related changes.               *
;*  04/09/90 jimmat Detect if on 286 & 287 installed.           *
;*  04/02/90 jimmat Added PM Int 70h handler.                   *
;*  09/27/89 jimmat Changes to use FindFile to locate child     *
;*                  program.                                    *
;*  08/29/89 jimmat Now hooks real mode Int 2Fh chain.          *
;*  08/20/89 jimmat Removed A20 code since HIMEM version 2.07   *
;*                  now works properly across processor resets. *
;*  07/28/89 jimmat Int PM Int 30h & 41h to be ignored, not     *
;*                  reflected to real mode.                     *
;*  07/14/89 jimmat Added call to EMMDisable                    *
;*  06/16/89 jimmat Ifdef'd combined DOSX/child .EXE code       *
;*  05/22/89 jimmat Added Int 13h/25h/26h/67h hooks.            *
;*  05/18/89 jimmat Added setting of real mode Int 30h hook.    *
;*  03/31/89 jimmat Added Priv Level to selectors during        *
;*                  relocation and removed some dead code.      *
;*  03/15/89 jimmat Added INT 31h hook                          *
;*  03/11/89 jimmat Added support for TSS & LDT & ring 1        *
;*  03/07/89 jimmat Converted to use WDEB386 debugger           *
;*  02/25/89 (GeneA): added support for combined exe file where *
;*      the Dos Extender and the child reside in the same exe   *
;*      file.                                                   *
;*  02/17/89 (GeneA): fixed error handling code during init.    *
;*  02/14/89 (GeneA): added initialization of INT15h vector,    *
;*      and changed segment limit of BIOS_CODE segment to       *
;*      64k.                                                    *
;*  02/14/89 (GeneA): added code to copy protected mode code    *
;*      segment up into extended memory.  Also code to allocate *
;*      and copy GDT and IDT in extended memory.                *
;*  01/31/89 (GeneA): reorganization of code.  This module now  *
;*      contains only code for initializing the Dos Extender    *
;*      itself.                                                 *
;*  01/25/89 (GeneA): moved code for loading and relocating     *
;*      the child program here from dxinit.asm                  *
;*  01/24/89 (Genea): removed routines for hooking into real    *
;*      mode int 2Fh.  (part of removing real mode int 2Fh      *
;*      interface from the dos extender).                       *
;*  12/13/88 (GeneA): created by moving code from DXINIT.ASM    *
;*                                                              *
;****************************************************************

.286p
.287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

.xlist
.sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include dpmi.inc
ifdef WOW_x86
include vdmtib.inc
endif
include intmac.inc
include dbgsvc.inc
.list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

;
; This structure defines the format of the EXE file header.

EXEHDR  struc

idExeFile       dw      ?       ;magic number to identify EXE file
cbLastPage      dw      ?       ;number of bytes in last page of the file
crgbFileLen     dw      ?       ;number of 512 byte pages in the file
clpRelocLen     dw      ?       ;number of relocation entries in the table
cparHdrSize     dw      ?       ;number of 16 byte paragraphs in header
cparMinAlloc    dw      ?
cparMaxAlloc    dw      ?
segStackInit    dw      ?       ;initial stack segment
offStackInit    dw      ?       ;initial stack pointer
wCheckSum       dw      ?
offCodeInit     dw      ?       ;initial program counter
segCodeInit     dw      ?       ;initial code segment
wRelocOffset    dw      ?       ;byte offset of relocation table
idOverlay       dw      ?       ;overlay number

EXEHDR  ends

;
; This structure defines the parameter block to the XMS driver block
; move function.

XMSMOVE struc

cbxmsLen        dd      ?       ;length of memory block
hxmsSource      dw      ?       ;XMS source block handle
oxmsSource      dd      ?       ;source offset
hxmsDest        dw      ?       ;XMS destination block handle
oxmsDest        dd      ?       ;destination offset

XMSMOVE ends

NOP_OPCODE      equ     090h            ; NO-OP opcode
IRET_OPCODE     equ     0CFh            ; IRET opcode
FAR_JMP_OPCODE  equ     0EAh            ; JMP FAR opcode
SHORT_JMP_OPCODE equ    0EBh            ; JMP SHORT opcode

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   PMIntr31:NEAR
        extrn   PMIntr13:NEAR
        extrn   PMIntr19:NEAR
        extrn   PMIntr28:NEAR
        extrn   PMIntr25:NEAR
        extrn   PMIntr26:NEAR
        extrn   PMIntr4B:NEAR
        extrn   PMIntrDos:NEAR
        extrn   PMIntrMisc:NEAR
        extrn   PMIntrVideo:NEAR
        extrn   PMIntrMouse:NEAR
        extrn   PMIntrIgnore:NEAR
        extrn   PMIntrEntryVector:NEAR
        extrn   PMFaultEntryVector:NEAR
        extrn   ReadINIFile:NEAR
ifdef      NEC_98    ;
        extrn   PMIntrSound:NEAR                ; for Sound Bios
        extrn   PMIntrExDos:NEAR                ; for Extend Dos Function
        extrn   PMIntr11dummy:NEAR
        extrn   PMIntrPrinter:NEAR
        extrn   PMIntrCalTi:NEAR
        extrn   PMIntrGraph:NEAR
endif   ;NEC_98   ;

        extrn   EMMDisable:NEAR
        extrn   FindFIle:NEAR

ifdef WOW_x86
        extrn   NpxExceptionHandler:near
        extrn   EndNpxExceptionHandler:near
endif

        extrn   RmUnsimulateProc:FAR
        extrn   PmUnsimulateProc:FAR

        extrn   PMFaultHandlerIRET:NEAR
        extrn   PMFaultHandlerIRETD:NEAR
        extrn   PMIntHandlerIRET:NEAR
        extrn   PMIntHandlerIRETD:NEAR
        extrn   PMDosxIret:NEAR
        extrn   PMDosxIretd:NEAR

        extrn   RMCallBackBop:FAR
        extrn   RMtoPMReflector:FAR

        extrn   RmSaveRestoreState:far
        extrn   PmSaveRestoreState:far
        extrn   RmRawModeSwitch:far
        extrn   PmRawModeSwitch:far
        extrn   DPMI_MsDos_API:far
        extrn   VCD_PM_Svc_Call:far
        extrn   XmsControl:far
        extrn   HungAppExit:far

DXPMCODE    segment
        extrn   CodeEndPM:NEAR
externFP        NSetSegmentDscr
DXPMCODE    ends

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   selGDT:WORD
        extrn   segGDT:WORD
        extrn   selIDT:WORD
        extrn   segIDT:WORD
        extrn   bpGDT:FWORD
        extrn   bpIDT:FWORD
        extrn   sysTSS:WORD
        extrn   segPSP:WORD
        extrn   selPSP:WORD
        extrn   hmemDOSX:WORD
        extrn   f286_287:BYTE
        extrn   bpRmIVT:FWORD
        extrn   fhExeFile:WORD
        extrn   idCpuType:WORD
        extrn   cdscGDTMax:WORD
        extrn   rgbXfrBuf0:BYTE
        extrn   rgbXfrBuf1:BYTE
        extrn   clpRelocItem:WORD
        extrn   plpRelocItem:WORD
        extrn   lpfnXMSFunc:DWORD
ifdef      NEC_98    ;
        extrn   fPCH98:BYTE                     ; PC-H98 flag
        extrn   fNHmode:BYTE                    ; NHmode flag
endif   ;NEC_98   ;
        extrn   lpfnUserMouseHandler:DWORD
        extrn   fUsingHMA:BYTE
ifdef WOW_x86
        extrn   rgwWowStack:word
        extrn   FastBop:fword
endif
        extrn   pbHwIntrStack:word

IFNDEF WOW_x86
        extrn   IretBopTable:BYTE
ENDIF

        public  fDebug
fDebug   db     0

szModName db    'DOSX',0        ;Our module name for use by WDEB386


if DEBUG
        public  lpchFileName
lpchFileName    dd  ?
endif


INIFileName     db      'SYSTEM.INI',0  ;.INI file to read

        public  NetHeapSize, Int28Filter

INIKeywords     label   byte
                db      '[standard]',0
                db      'netheapsize',0
NetHeapSize     dw      4                       ;default is 8k
                db      'int28filter',0
Int28Filter     dw      10                      ;default is every 10th

if DEBUG   ;------------------------------------------------------------
                public  fTraceDOS
                db      'tracedos',0
fTraceDOS       dw      0
                public  fTraceFault
                db      'tracefault',0
fTraceFault     dw      0
                public  fTraceA20
                db      'tracea20',0
fTraceA20       dw      1
                public  TrapDOS
                db      'trapdos',0
TrapDOS         dw      0
                db      'tableslow',0
fTablesLow      dw      0
                public  fTraceReflect
                db      'tracereflect',0
fTraceReflect   dw      0
                public  fTraceMode
                db      'tracemode',0
fTraceMode      dw      0
endif   ;DEBUG  --------------------------------------------------------
                db      0

szExeExtension  db      '.exe',0


; The following set of variables are used when copying our Pmode data
; structures into a HIMEM-allocated block.

        public lmaIDT,lmaGDT,lmaDXPMCODE

CBIDTOFF        = 0
CBGDTOFF        = CDSCIDTDEFAULT * 8
IFNDEF WOW_x86
CBDXPMCODEOFF   = CBGDTOFF + GDT_SIZE
ELSE
;
; Since we have no GDT for wow, we do not need space for it.
;
CBDXPMCODEOFF   = CBGDTOFF
ENDIF
CBTABLESIZE     = CBDXPMCODEOFF

.errnz  CBIDTOFF and 0fh
.errnz  CBGDTOFF and 0fh
.errnz  CBDXPMCODEOFF and 0fh

lmaIDT      dd  CBIDTOFF
lmaGDT      dd  CBGDTOFF
lmaDXPMCODE dd  CBDXPMCODEOFF
lmaLDT      dd  CBDXPMCODEOFF


        extrn   rgwStack:WORD
DXDATA  ends


DXSTACK segment
        extrn   ResetStack:WORD
DXSTACK ends

; -------------------------------------------------------
        page
; -------------------------------------------------------
;               CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

;************************************************************************
;
;       REMEMBER... any code segment variables defined in this file
;                   will be discarded after initialization.
;
;************************************************************************

        extrn   CodeEnd:NEAR
        extrn   segDXCode:WORD
        extrn   segDXData:WORD
        extrn   selDgroup:WORD

ErrMsg  MACRO   name
        extrn   ER_&name:BYTE
ERC_&name       equ offset ER_&name
        ENDM

        ErrMsg  CPUTYPE
        ErrMsg  DXINIT
        ErrMsg  PROTMODE
        ErrMsg  NOHIMEM
        ErrMsg  EXTMEM
        ErrMsg  NOEXE

        extrn   RMInt2FHandler:NEAR

        extrn   PrevInt2FHandler:DWORD

lpfnPrevXMS     dd      0


DXCODE  ends


DXPMCODE    segment

        extrn   selDgroupPM:WORD

        extrn   segDXCodePM:WORD
        extrn   segDXDataPM:WORD

DXPMCODE    ends

; -------------------------------------------------------
        page

DXCODE  segment
        assume  cs:DXCODE
; -------------------------------------------------------
;               MAIN INITIALIZATION ROUTINES
; -------------------------------------------------------

;   InitDosExtender     -- This routine is the executive
;       for initializing the dos extender.
;
;   Input:  none
;   Output: various global tables and variables initialized.
;           Dos Extender relocated for protected mode execution
;           and moved into extended memory.
;   Errors: returns CY set if error occurs, pointer to error message
;           in DX
;   Uses:

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  InitDosExtender

InitDosExtender:

; Init the key code & data segment variables.

        mov     ax,cs
        mov     segDXCode,ax

        mov     ax,ds
        mov     segDXData,ax
        mov     selDgroup,ax

        push    es
        mov     ax,seg DXPMCODE
        mov     es,ax
        assume  es:DXPMCODE

        mov     selDgroupPM,SEL_DXDATA or STD_RING
        mov     segDXCodePM,cs
        mov     segDXDataPM,ds
        pop     es
        assume  es:DGROUP



; Do an initial shrink of our program memory.  This assumes that DXPMCODE
; is the last segment in program.

        mov     bx,(offset DXPMCODE:CodeEndPM) + 10h
        shr     bx,4
        add     bx,seg DXPMCODE
        sub     bx,segPSP
        mov     es,segPSP
        dossvc  4Ah

        push    ds
        pop     es


; Determine the type of CPU we are running on and make sure it is
; at least an 80286.

        call    CheckCPUType
        cmp     ax,2
        jae     indx14
        mov     ax,ERC_CPUTYPE
        jmp     indx80
indx14:


; If running on a 286, see if there is a 287 coprocessor installed

ifdef      NEC_98    ;
;------------------- 90/08/15 --------------------
;check N/H at system area BIOS_FLAG(0:501h)
;if H mode, fNHmode bit on.
        push    es
        push    ax
        mov     ax,0
        mov     es,ax
        test    byte ptr es:[501h],8h   ;if Hmode 
        jz      not_Hmode
        mov     fNHmode,0FFh    ;Now! Running on Hmode!!! 90/07/07
not_Hmode:
        pop     ax
        pop     es
;------------------- 90/08/15 --------------------
; If running on a 286, see if there is a 287 coprocessor installed
        cmp     al,2            ;286 processor?
        jnz     EMM_Disable
        test    fNHmode,0FFh
        jz      Copro_Nmode
;----- 90/07/04 in -----
;  check co-processor exist at memory-switch
;----------------- Hmode -----------------
        push    ds
        push    bx
;;;;;;;;        mov     bx,0Eh
        mov     bx,0E000h               ;90/10/04 bug
        mov     ds,bx
        mov     bx,3FEAh
        mov     al,byte ptr ds:[bx]
        pop     bx
        pop     ds
        test    al,08h          ;0=none,1=exists
        jmp     Coprocessor
Copro_Nmode:
;----------------- Nmode -----------------
        push    ds
        push    bx
;;;;;;;;        mov     bx,0Ah
        mov     bx,0A000h               ;90/10/04 bug
        mov     ds,bx
        mov     bx,3FEAh
        mov     al,byte ptr ds:[bx]
        pop     bx
        pop     ds
        test    al,08h          ;0=none,1=exists
Coprocessor:
        jz      EMM_Disable
        inc     f286_287        ;  yup, 286 & 287
EMM_Disable:
else    ;NEC_98   ;
        cmp     al,2            ;286 processor?
        jnz     @f

        int     11h             ;math coprocessor installed?
        test    al,2
        jz      @f
ifndef WOW_x86
        inc     f286_287        ;  yup, 286 & 287
endif
@@:
endif   ;NEC_98   ;

; If on a 386 or greater, try to disable the EMM drivers we know about

          call    EMMDisable

; Check if the machine is already running in protected mode.  If so, we
; can't run.
ifndef WOW_x86
        smsw    ax
        test    ax,1        ;check the protected mode bit
        jz      @f
        mov     ax,ERC_PROTMODE
        jmp     indx80
endif
@@:

; Get the full pathname of our EXE file, it's needed in a couple of places

        call    GetExeName
        jnc     @F
        mov     ax,ERC_DXINIT
        jmp     indx80
@@:

; Determine if the real mode Int 28h vector points anywhere.  If it doesn't
; then we don't need to reflect Int 28h calls from protected to real mode.
; The user can still override this by putting a Int28Filter= entry in
; SYSTEM.INI.

        push    es
        mov     ax,3528h
        int     21h
        assume  es:NOTHING

        cmp     byte ptr es:[bx],IRET_OPCODE    ;Int 28h -> IRET?
        jne     @f
        mov     Int28Filter,0                   ;  yes, don't need to reflect
@@:
        pop     es
        assume  es:DGROUP

; Read SYSTEM.INI for any parameter overrides - NOTE: requires GetExeName
; having been run first!

        mov     bx,offset INIKeywords
        mov     dx,offset INIFileName
        call    ReadINIFile

; Check that the HIMEM.SYS driver is installed so that we can use it
; for extended memory management.

        call    SetupHimemDriver
        jnc     @F                              ; Himem is OK.
        mov     ax,ERC_NOHIMEM
        jmp     indx80
@@:

ifdef      NEC_98    ;
        push    es
        xor     ax, ax
        mov     es, ax
        test    byte ptr es:[458h], 80h         ; if NESA
        jz      not_MC
        mov     fPCH98, 0FFh                    ; it's a NPC NESA
not_MC:
        pop     es
        assume  es:DGROUP
endif   ;NEC_98   ;

; Hook the real mode int vectors

        mov     ax,352Fh                        ;get previous Int 2Fh vector
        int     21h
        assume  es:NOTHING

        mov     word ptr [PrevInt2FHandler],bx
        mov     word ptr [PrevInt2FHandler+2],es

        push    ds
        pop     es
        assume  es:DGROUP

        mov     ax,cs                           ;point to our rMode Int 2Fh
        mov     ds,ax
        assume  ds:NOTHING
        mov     dx,offset DXCODE:RMInt2FHandler
        mov     ax,252Fh
        int     21h

        push    es
        pop     ds
        assume  ds:DGROUP

; Allocate and initialize the descriptor tables and TSS.

        cCall   AllocateExtMem
        jnc     indx20
        mov     ax,ERC_EXTMEM
        jmp     indx80
indx20:

        push    es
        push    bx
        push    dx
        push    di
        push    si

;
; Bop to initialize 32 bit support.
;

        mov     di, sp                          ;original stack offset

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:HungAppExit

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:XmsControl
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:DPMI_MsDos_API
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:VCD_PM_Svc_Call

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PmRawModeSwitch
        push    segDXCode
        push    offset DXCODE:RmRawModeSwitch

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PmSaveRestoreState
        push    segDXCode
        push    offset DXCODE:RmSaveRestoreState

        mov     bx,cdscGDTMax
        shl     bx,3
        dec     bx
        push    bx                              ;Initial LDT size
        push    selGDT

        push    SEL_DXPMCODE OR STD_RING        ;pm reflector seg

        push    segDXCode
        push    offset DXCODE:RMtoPMReflector
        push    segDXCode
        push    offset DXCODE:RMCallBackBop

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMDosxIretd
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMDosxIret

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMIntHandlerIRETD
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMIntHandlerIRET
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMFaultHandlerIRETD
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMFaultHandlerIRET

        push    SEL_DXCODE OR STD_RING
        push    segDXCode
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PmUnsimulateProc
        push    segDXCode
        push    offset DXCODE:RmUnsimulateProc
        push    word ptr CB_STKFRAME
        push    segDXData
        mov     si,sp                           ;pass stack offset
        DPMIBOP InitDosxRM
        mov     sp, di                          ;restore stack

ifdef WOW_x86
        mov     word ptr [FastBop],bx
        mov     word ptr [FastBop + 2],dx
        mov     word ptr [FastBop + 4],es
endif

        pop     si
        pop     di
        pop     dx
        pop     bx
        pop     es

        call    InitGlobalDscrTable     ;set up the GDT

        call    SendDbgNotification     ;tell NTSD about our segments

        call    InitIntrDscrTable       ;set up the IDT

ifndef WOW_x86              ;bugbug
        call    InitTaskStateSeg        ;set up the TSS
endif

if DEBUG

; DOSX is written such that it does not require any segment fix ups for
; protected mode operation.  This wasn't always the case, and it's easy
; to make create dependencies so the routine CheckDOSXFixUps exists in
; the debug version to check for segment fix ups in non-initialization
; code.

        call    CheckDOSXFixUps
        jnc     @F
        mov     ax,ERC_DXINIT
        jmp     short indx80
@@:
endif   ;DEBUG

; Move the Extended memory segment up into extended memory.

        mov     dx,seg DXPMCODE
        call    MoveDosExtender
        jc      indx80


; Move the GDT and IDT up into extended memory.

        call    MoveDscrTables

; Parse the command line, and locate the child exe file

        call    ParseCommandLine

; Initialized okay!

        clc
        jmp     short indx90

; Error occured.  Free any extended memory blocks allocated and then
; return the error code.

indx80: push    ax              ;save the error code

;
; If we have allocated an extended memory block, then free it.
; If we have allocated the HMA, then free it.
;
        mov     dx,hmemDOSX
        or      dx,dx
        jz      @F
        xmssvc  0Dh
        xmssvc  0Ah

@@:
        cmp     fUsingHMA,0
        je      @F
        xmssvc  2
@@:

indxEXIT:
        pop     ax              ;restore the error code

        stc                     ;set error flag

indx90: ret


; -------------------------------------------------------
;   AllocateExtMem  --  Allocates memory used by DOSX for
;                       system tables and protected mode
;                       code.
;                       Allocates a temporary buffer in
;                       DOS memory for building the
;                       IDT and GDT.
; Input: none
; Output: none
; Uses: Flags
; Error: Carry set if cannot allocate memory.
;
; History:
;       10/05/90 - earleh wrote it

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

cProc   AllocateExtMem,<PUBLIC,NEAR>,<ax,bx,dx>
cBegin

; If there is sufficient XMS memory, increase the size of the GDT/LDT
; up to the max of 8k selectors.

        add     word ptr lmaLDT,offset DXPMCODE:CodeEndPM
        adc     word ptr lmaLDT+2,0
        add     word ptr lmaLDT,0Fh     ;make sure LDT is para aligned
        adc     word ptr lmaLDT+2,0
        and     word ptr lmaLDT,0FFF0h

@@:

        xmssvc  08h             ;Query Free Extended memory
        cmp     dx,1024         ;is there more than 1 meg available?
        jb      @f
        mov     cdscGDTMax,CDSCMAXLDT   ; yes, max out the GDT size
@@:
        mov     ax,cdscGDTMax
        xor     dx,dx
        shl     ax,3
        adc     dx,0
        add     ax,word ptr lmaLDT
        adc     dx,word ptr lmaLDT+2
        add     ax,1023d
        adc     dx,0                    ; DX:AX = total extended memory needed
        shl     dx,6
        shr     ax,10d
        or      dx,ax                   ; DX = kbytes needed
        mov     si,dx                   ; SI = kbytes needed
        xmssvc  09h                     ; allocate the XMS block
        or      ax,ax
        jz      axm_error
        mov     hmemDOSX,dx
        xmssvc  0Ch                     ; lock it, DX:BX = address
        or      ax,ax
        jz      axm_error

axm_address:

        add     word ptr lmaIDT,bx      ; relocate tables & Pmode code
        adc     word ptr lmaIDT+2,dx
        add     word ptr lmaGDT,bx
        adc     word ptr lmaGDT+2,dx
        add     word ptr lmaDXPMCODE,bx
        adc     word ptr lmaDXPMCODE+2,dx
        add     word ptr lmaLDT,bx
        adc     word ptr lmaLDT+2,dx
        mov     bx,(CDSCIDTDEFAULT + GDT_SELECTORS + 1) shr 1
        dossvc  48h                     ; get a DOS block for building tables
        jc      axm_error               ; abort if error

        mov     segIDT,ax
        mov     selIDT,ax
        add     ax,CDSCIDTDEFAULT shr 1
        mov     segGDT,ax
        mov     selGDT,ax

        clc
        jmp     axm_exit
axm_error:
        stc
axm_exit:
cEnd


; -------------------------------------------------------
; SetupHimemDriver      -- This routine checks that an XMS driver
;       is installed and sets up for calling it.
;
;   Input:  none
;   Output: none
;   Errors: returns CY set if no driver available
;   Uses:   AX, all other registers preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  SetupHimemDriver

SetupHimemDriver proc   near


        push    bx
        push    es

; Check to see if there is an XMS driver resident.

        mov     ax,4300h
        int     2Fh
        cmp     al,80h
        jnz     sthd80

; There is an XMS driver resident, so init for calling it.

        mov     ax,4310h
        int     2Fh
        mov     word ptr [lpfnXMSFunc],bx
        mov     word ptr [lpfnXMSFunc+2],es

; Make sure this is the proper XMS/driver version

        xmssvc  0               ;returns XMS vers in ax, driver vers in bx
        cmp     ax,300h         ;assume okay if XMS 3.0 or above
        jae     @f
        cmp     ax,200h         ;require at least XMS 2.00
        jb      sthd80
        cmp     bx,21Ch         ;if XMS 2.x, require driver version 2.28+
        jb      sthd80          ; (himem used to have minor vers in decimal)
@@:

; Verify that the XMS driver's A20 functions work

        xmssvc  5                       ;local enable
        or      ax,ax
        jz      sthd80

        xmssvc  7                       ;query A20
        push    ax

        xmssvc  6                       ;local disable
        or      ax,ax

        pop     ax                      ;recover query status
        jz      sthd80

        or      ax,ax                   ;should be NZ, (A20 enabled status)
        jz      sthd80

; Looks good to me...

        clc
        jmp     short sthd90

; No XMS driver resident or wrong version or we couldn't enable A20.

sthd80: stc

sthd90: pop     es
        pop     bx
        ret

SetupHimemDriver endp


; -------------------------------------------------------
;   MoveDosExtender     -- This routine will move the Dos Extender
;       protected mode segment up into extended memory.
;       The himem driver function for moving memory blocks is used.
;       The parameter block for this function is built in rgbXfrBuf0.
;
;   Input:  DX      - real mode segment address of the segment to move
;   Output: none
;   Errors: returns CY set if error, Error code in AX
;   Uses:   AX used, all else preserved
;           modifies rgbXfrBuf0

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  MoveDosExtender

MoveDosExtender proc    near

        push    bx
        push    cx
        push    dx
        push    si

        cmp     fUsingHMA,0
        je      mvdx40

;
; Our extended memory block is actually the HMA.  Enable A20 and do
; the move ourselves.
;

        xmssvc  5                       ;local enable

        push    di
        push    ds
        push    es
        mov     cx,offset DXPMCODE:CodeEndPM
        inc     cx
        and     cx,0FFFEh
        mov     di,CBDXPMCODEOFF+10h
        xor     si,si
        dec     si
        mov     es,si
        inc     si
        mov     ds,dx
        assume  ds:NOTHING
;
; DS:SI = segIDT:0
; ES:DI = 0FFFF:CBDXPMCODEOFF+10h
; CX = code size
;
        cld
        rep     movsb
        pop     es
        assume  ds:DGROUP
        pop     ds
        pop     di

        xmssvc  6                       ;local disable

        jmp     mvdx65
mvdx40:
; Move the data up into extended memory using the XMS driver's function.

        mov     si,offset DGROUP:rgbXfrBuf0
        mov     cx,offset DXPMCODE:CodeEndPM
        inc     cx
        and     cx,0FFFEh
        mov     word ptr [si].cbxmsLen,cx
        mov     word ptr [si].oxmsSource+2,dx   ;real mode code segment address
        mov     ax,hmemDOSX
        mov     word ptr [si].hxmsDest,ax
        xor     ax,ax
        mov     word ptr [si].cbxmsLen+2,ax
        mov     [si].hxmsSource,ax
        mov     word ptr [si].oxmsSource,ax
        mov     word ptr [si].oxmsDest,CBDXPMCODEOFF
        mov     word ptr [si].oxmsDest+2,ax

        xmssvc  0Bh

mvdx65:
        clc
        jmp     short mvdx90

; Error occured

mvdx80: stc

mvdx90: pop     si
        pop     dx
        pop     cx
        pop     bx
        ret

MoveDosExtender endp


; -------------------------------------------------------
;   MoveDscrTables      -- This routine will move the GDT
;       and IDT up into extended memory.  The himem driver
;       function for moving memory blocks is used.  The parameter
;       block for this function is built in rgbXfrBuf0.
;
;   Input:  none
;   Output: none
;   Errors: returns CY set if error occurs.  Error code in AX
;   Uses:   AX, all else preserved
;           modifies rgbXfrBuf0

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  MoveDscrTables

MoveDscrTables  proc    near

        push    bx
        push    si
        push    es

        cmp     fUsingHMA,0
        je      @F

;
; Our extended memory block is actually the HMA.  Enable A20 and do
; the move ourselves.
;

        xmssvc  5                       ;local enable

        push    ds
        push    di
        push    cx

        mov     cx,CBTABLESIZE
        mov     di,10h
        xor     si,si
        dec     si
        mov     es,si
        inc     si
        mov     ds,segIDT
        assume  ds:NOTHING
;
; DS:SI = segIDT:0
; ES:DI = 0FFFF:10
; CX = tables size
;
        cld
        rep     movsb
        pop     cx
        pop     di
        pop     ds
        assume  ds:DGROUP

        xmssvc  6                       ;local disable

        clc
        jmp     mvdt_ret

@@:

; Move the GDT and IDT together.

        mov     si,offset DGROUP:rgbXfrBuf0

        mov     word ptr [si].cbxmsLen,CBTABLESIZE
        mov     word ptr [si].cbxmsLen+2,0
        mov     ax,segIDT
        mov     word ptr [si].oxmsSource+2,ax
        mov     ax,hmemDOSX
        mov     word ptr [si].hxmsDest,ax
        xor     ax,ax
        mov     [si].hxmsSource,ax
        mov     word ptr [si].oxmsSource,ax
        mov     word ptr [si].oxmsDest,ax
        mov     word ptr [si].oxmsDest+2,ax

        xmssvc  0Bh
IFDEF WOW
;
; Move the initialized selectors from the gdt to the ldt
;
        mov     word ptr [si].cbxmsLen,GDT_SIZE
        mov     word ptr [si].cbxmsLen+2,0
        mov     ax,segGDT
        mov     word ptr [si].oxmsSource+2,ax
        mov     ax,hmemDOSX
        mov     word ptr [si].hxmsDest,ax
        xor     ax,ax
        mov     word ptr [si].hxmsSource,ax
        mov     word ptr [si].oxmsSource,ax
        mov     word ptr [si].oxmsDest+2,ax
        mov     word ptr [si].oxmsDest,CBTABLESIZE + offset DXPMCODE:CodeEndPM

        xmssvc  0Bh
ENDIF

mvdt_ret:

        mov     es,segIDT                       ;free the low memory copy
        dossvc  49h

        pop     es
        pop     si
        pop     bx

        ret

MoveDscrTables  endp

; -------------------------------------------------------
; Send Debugger Notification

SendDbgNotification proc near
IFDEF WOW
;
; Send load notification to the debugger for DXDATA
;
        push    1                       ; data
        push    ds                      ; exe name
        push    offset EXEC_DXNAME
        push    ds                      ; module name
        push    offset szModName
        push    0
        push    SEL_DXDATA OR STD_RING
        push    DBG_SEGLOAD
        BOP     BOP_DEBUGGER
        add     sp,16
;
; Send load notification to the debugger for DXCODE
;
        push    0                       ; code
        push    ds                      ; exe name
        push    offset EXEC_DXNAME
        push    ds                      ; module name
        push    offset szModName
        push    1
        push    SEL_DXCODE OR STD_RING
        push    DBG_SEGLOAD
        BOP     BOP_DEBUGGER
        add     sp,16
;
; Send load notification to the debugger
;
        push    0                       ; code
        push    ds                      ; exe name
        push    offset EXEC_DXNAME
        push    ds                      ; module name
        push    offset szModName
        push    2
        push    SEL_DXPMCODE OR STD_RING
        push    DBG_SEGLOAD
        BOP     BOP_DEBUGGER
        add     sp,16
ENDIF
        ret
SendDbgNotification endp


; -------------------------------------------------------
;   InitGlobalDscrTable -- This function will allocate a memory
;       buffer from DOS and then initialize it as a global
;       descriptor table.  It will also initialize all global
;       variables associated with GDT management.
;       Descriptors in the range 0 - SEL_USER are given statically
;       defined meanings.  Descriptors from SEL_USER up are defined
;       dynamically when a program is loaded or when dynamic memory
;       management calls occur.
;
;   NOTE:   This routine works in real mode.  The buffer where
;           the GDT is built is in low memory.
;
;   Input:  AX      - number of descriptors to initialize
;   Output: none
;   Errors: CY set if unable to obtain memory for the GDT
;   Uses:   AX used, all other registers preserved
;           bpGDT initialized.

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  InitGlobalDscrTable

InitGlobalDscrTable     proc    near

        push    bx
        push    cx
        push    dx
        push    di
        push    es

        mov     word ptr [bpGDT+0],GDT_SIZE - 1
        mov     ax,word ptr lmaGDT
        mov     word ptr [bpGDT+2],ax
        mov     ax,word ptr lmaGDT+2
        mov     word ptr [bpGDT+4],ax
;
; Start by initializing the GDT to 0.
;
        mov     cx,GDT_SIZE shr 1
        mov     es,segGDT
        assume  es:NOTHING
        xor     ax,ax
        mov     di,ax
        rep     stosw

; Next, initialize the statically defined descriptors.
;
; Set up a descriptor for our protected mode code.

        xor     ax,ax                   ;AX = 0
        mov     dx,cs                   ;our code segment paragraph address
        call    B_ParaToLinear          ;convert to linear byte address
        mov     cx,offset CodeEnd
        cCall   NSetSegmentDscr,<SEL_DXCODE,bx,dx,ax,cx,STD_CODE>

; Set up another one, but ring 0 this time.  Limit should be 0FFFFh
; or 386 reset to real mode will not work properly.

        mov     cx,0FFFFh
        cCall   NSetSegmentDscr,<SEL_DXCODE0,bx,dx,ax,cx,ARB_CODE0>
;
; Set up one for the other segment, and a Ring 0 alias.
;
        mov     cx,offset CodeEndPM
        mov     bx,word ptr lmaDXPMCODE
        mov     dx,word ptr lmaDXPMCODE+2
        cCall   NSetSegmentDscr,<SEL_DXPMCODE,dx,bx,0,cx,STD_CODE>
        cCall   NSetSegmentDscr,<SEL_NBPMCODE,dx,bx,0,cx,STD_CODE>


ifndef WOW_x86
        cCall   NSetSegmentDscr,<SEL_EH,dx,bx,0,cx,EH_CODE>
else
        cCall   NSetSegmentDscr,<SEL_EH,dx,bx,0,cx,STD_CODE>
endif
        mov     cx,0FFFFh

; Set up a descriptor for our protected mode data and stack area.

        mov     dx,ds                   ;our data segment paragraph address
        call    B_ParaToLinear          ;convert to linear byte address
        cCall   NSetSegmentDscr,<SEL_DXDATA,bx,dx,ax,cx,STD_DATA>

IFNDEF WOW_x86
; Set up descriptor for IRET HOOKS
        push    dx
        push    bx
        add     dx,offset IretBopTable
        adc     bx,0
        cCall   NSetSegmentDscr,<SEL_IRETHOOK,bx,dx,ax,cx,STD_CODE>
        pop     bx
        pop     dx
ELSE
; Set up descriptor for IRET HOOKS
        push    dx
        push    bx
        add     dx,offset FastBop
        adc     bx,0
        cCall   NSetSegmentDscr,<SEL_IRETHOOK,bx,dx,ax,cx,STD_CODE>
        pop     bx
        pop     dx
ENDIF

IFNDEF WOW_x86
; And another one of those for ring 0

        cCall   NSetSegmentDscr,<SEL_DXDATA0,bx,dx,ax,cx,ARB_DATA0>
ENDIF
;
; Set up descriptors pointing to our PSP and environment.

        mov     dx,segPSP               ;segment address of the PSP
        call    B_ParaToLinear          ;convert to linear byte address
        cCall   NSetSegmentDscr,<SEL_PSP,bx,dx,ax,cx,STD_DATA>
        mov     selPSP,SEL_PSP
;
        push    es
        mov     es,segPSP
        assume  es:PSPSEG
        mov     dx,segEnviron
        call    B_ParaToLinear
        cCall   NSetSegmentDscr,<SEL_ENVIRON,bx,dx,ax,7FFFH,STD_DATA>
        pop     es
        assume  es:nothing

; Set up a descriptor that points to the GDT.

        mov     dx,word ptr [bpGDT+2]   ;get the GDT linear byte address
        mov     bx,word ptr [bpGDT+4]
        mov     cx,word ptr [bpGDT+0]    ;get the GDT segment size
        cCall   NSetSegmentDscr,<SEL_GDT,bx,dx,ax,cx,STD_DATA>


; Set up a descriptor for the LDT and an LDT data alias.

        mov     cx,cdscGDTMax           ;get count of descriptors
        shl     cx,3
        dec     cx
        mov     dx,word ptr lmaLDT
        mov     bx,word ptr lmaLDT+2
IFNDEF WOW_x86
        cCall   NSetSegmentDscr,<SEL_LDT,bx,dx,ax,cx,STD_LDT>
ENDIF
        cCall   NSetSegmentDscr,<SEL_LDT_ALIAS,bx,dx,ax,cx,STD_DATA>

        ; set up a readonly selector to the LDT for the wow kernel
        cCall   NSetSegmentDscr,<SEL_WOW_LDT,bx,dx,ax,cx,STD_DATA>

; Set up descriptors pointing to the BIOS code and data areas

        mov     cx,0FFFFH               ; CX = 0FFFFH
        cCall   NSetSegmentDscr,<SEL_BIOSCODE,000fh,ax,ax,cx,STD_CODE>

        mov     dx,40h*16
        cCall   NSetSegmentDscr,<SEL_BIOSDATA,ax,dx,ax,cx,STD_DATA>

; Set up a descriptor pointing to the real mode interrupt vector table.

        cCall   NSetSegmentDscr,<SEL_RMIVT,ax,ax,ax,cx,STD_DATA>

IFNDEF WOW_x86
; Setup a selector and data alias for the TSS

        mov     dx,ds                           ;get base address of TSS
        call    B_ParaToLinear                  ;  (it may not be para aligned)
        add     dx,offset DGROUP:sysTSS
        adc     bx,ax

        mov     cx,(TYPE TSS286) - 1
        cCall   NSetSegmentDscr,<SEL_TSS,bx,dx,ax,cx,STD_TSS>
        cCall   NSetSegmentDscr,<SEL_TSS_ALIAS,bx,dx,ax,cx,STD_DATA>

ENDIF

;
;       Pass address of HwIntr stack, and form pointer to lockcount in
;       VdmTib. This enables us to coordinate stack switching with
;       the nt kernel and the monitor. These components will switch
;       the stack on Hw Interrupt reflection, dosx will switch it
;       back at iret.
;

        push    es
        mov     ax,SEL_DXDATA or STD_RING
        mov     es, ax
        mov     bx, pbHwIntrStack
        DPMIBOP InitPmStackInfo
        pop     es

IFDEF WOW_x86
;
;       Create a code selector for the NPX emulation exception handler
;
        mov     ax,offset EndNpxExceptionHandler
        sub     ax,offset NpxExceptionHandler
        mov     bx,offset DXPMCODE:NpxExceptionHandler
        add     bx,word ptr lmaDXPMCODE
        mov     dx,word ptr lmaDXPMCODE + 2
        cCall   NSetSegmentDscr,<SEL_NPXHDLR,dx,bx,0,ax,STD_CODE>
ENDIF

        clc                             ;worked! make sure CY is clear


; All done

igdt90: pop     es
        pop     di
        pop     dx
        pop     cx
        pop     bx
        ret

InitGlobalDscrTable     endp


; -------------------------------------------------------
;   InitIntrDscrTable   -- This function will initialize the
;       specified memory buffer as an Interrupt Descriptor Table,
;       and set up all of the control variables associated with
;       the IDT.
;
;   NOTE:   This routine works in real mode.  The buffer where
;           the IDT is built is in low memory.
;   NOTE:   The InitGlobalDscrTable function must be called before
;           this function can be called.
;
;   Input:  AX      - number of descriptors to initialize
;   Output: none
;   Errors: CY set if unable to obtain the memory required
;   Uses:   AX, all other registers preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  InitIntrDscrTable

InitIntrDscrTable  proc near

        push    bx
        push    cx
        push    dx
        push    si
        push    di
        push    es

ifndef WOW_x86
; Save the current pointer to the real mode interrupt vector table.

        sidt    fword ptr bpRmIVT
endif
        mov     es,selIDT
        assume  es:NOTHING

        mov     cx,256              ;number of descriptors in table
        shl     cx,3                ;convert to count of bytes
        dec     cx                  ;compute segment size limit

        mov     word ptr [bpIDT+0],cx
        mov     dx,word ptr lmaIDT
        mov     word ptr [bpIDT+2],dx
        mov     bx,word ptr lmaIDT+2
        mov     word ptr [bpIDT+4],bx
        cCall   NSetSegmentDscr,<SEL_IDT,bx,dx,0,cx,STD_DATA>

; Fill the IDT with interrupt gates that point to the fault handler and
; interrupt reflector entry vector.

        xor     di,di

        mov     dx,offset DXPMCODE:PmIntrEntryVector
        mov     cx,256
iidt23: mov     es:[di].offDest,dx
        mov     es:[di].selDest,SEL_DXPMCODE or STD_RING
        mov     es:[di].cwParam,0
        mov     es:[di].arbGate,STD_TRAP   ; BUGBUG- int gates not set up
        mov     es:[di].rsvdGate,0
        add     dx,5
        add     di,8
        loop    iidt23

; Now, fix up the ones that don't point to the interrupt reflector.

; BUGBUG In dxstrt.asm, these are x86 ONLY.
        mov     es:[1h*8].offDest,offset PMIntrIgnore
        mov     es:[3h*8].offDest,offset PMIntrIgnore
ifdef      NEC_98                                          ;
        mov     es:[11h*8].offDest,offset PMIntr11dummy
        mov     es:[18h*8].offDest,offset PMIntrVideo
        mov     es:[1ah*8].offDest,offset PMIntrPrinter
        mov     es:[1bh*8].offDest,offset PMIntr13
        mov     es:[1ch*8].offDest,offset PMIntrCalTi
        mov     es:[1dh*8].offDest,offset PMIntrGraph
        mov     es:[1fh*8].offDest,offset PMIntrMisc
else    ;NEC_98                                         ;
        mov     es:[10h*8].offDest,offset PMIntrVideo
        mov     es:[13h*8].offDest,offset PMIntr13
        mov     es:[15h*8].offDest,offset PMIntrMisc
        mov     es:[19h*8].offDest,offset PMIntr19
endif   ;NEC_98                                         ;

        mov     es:[21h*8].offDest,offset DXPMCODE:PMIntrDos
        mov     es:[25h*8].offDest,offset DXPMCODE:PMIntr25
        mov     es:[26h*8].offDest,offset DXPMCODE:PMIntr26
        mov     es:[28h*8].offDest,offset DXPMCODE:PMIntr28
        mov     es:[30h*8].offDest,offset DXPMCODE:PMIntrIgnore
        mov     es:[31h*8].offDest,offset DXPMCODE:PMIntr31
        mov     es:[33h*8].offDest,offset DXPMCODE:PMIntrMouse
        mov     es:[41h*8].offDest,offset DXPMCODE:PMIntrIgnore

ifndef WOW_x86
        mov     es:[4Bh*8].offDest,offset DXPMCODE:PMIntr4B
ifdef      NEC_98    ;
;  Sound BIOS Int D2h handler
        mov     es:[0D2h*8].offDest,offset DXPMCODE:PMIntrSound

;  Extended DOS Int DCh handler (KANA/KANJI)
        mov     es:[0DCh*8].offDest,offset DXPMCODE:PMIntrExDos
endif   ;NEC_98   ;
endif

;
; Set up the IDT, and dpmi32 state
;
        mov     ax,es                   ; Idt selector
        mov     bx,VDM_INT_16
        DPMIBOP InitIDT

        mov     ax,5                    ; handler increment
        mov     cx,SEL_DXPMCODE OR STD_RING
        mov     dx,offset DXPMCODE:PmFaultEntryVector

        DPMIBOP InitExceptionHandlers


        .286p
; All done

iidt90: pop     es
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        ret

InitIntrDscrTable endp

; -------------------------------------------------------
;
;   InitTaskStateSeg    -- This function initializes the
;       TSS for the DOS Extender.
;
;   Input:  none
;   Output: none
;   Errors: returns CY if unable to allocate memory
;   Uses:   all registers preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  InitTaskStateSeg

InitTaskStateSeg  proc  near

        push    ax
        push    cx
        push    di

; As a start, zero out the TSS

        xor     al,al
        mov     cx,type TSS286
        mov     di,offset DGROUP:sysTSS
        rep stosb

; Set the LDT selector

        mov     sysTSS.tss_ldt,SEL_LDT

; Set the ring 0 stack seg/pointer, we don't bother to set the others
; since nothing runs below DOSX's ring.  Currently very little code runs
; ring 0 - just when switching between real/proteted modes.

        mov     sysTSS.tss_ss0,SEL_DXDATA0
        mov     sysTSS.tss_sp0,offset DGROUP:ResetStack

; That's all it takes

        pop     di
        pop     cx
        pop     ax

        clc
        ret

InitTaskStateSeg  endp

; -------------------------------------------------------
;               MISC. STARTUP ROUTINES
; -------------------------------------------------------

; *** CheckCPUType - Set global variable for CPU type
;
;       This routine relies on Intel-approved code that takes advantage
;       of the documented behavior of the high nibble of the flag word
;       in the REAL MODE of the various processors.  The MSB (bit 15)
;       is always a one on the 8086 and 8088 and a zero on the 286 and
;       386.  Bit 14 (NT flag) and bits 13/12 (IOPL bit field) are
;       always zero on the 286, but can be set on the 386.
;
;       For future compatibility of this test, it is strongly recommended
;       that this specific instruction sequence be used.  The exit codes
;       can of course be changed to fit a particular need.
;
;       CALLABLE FROM REAL MODE ONLY
;
;       ENTRY:  NONE
;
;       EXIT:   AX holds CPU type ( 0=8086,80186; 2=80286; 3=80386; 4=80486 )
;
;       USES:   AX, DS must point to DX data segment
;               idCpuType initialized
;
;       Modified: 07-31-90 Earleh added code from Kernel, originally
;               supplied by Intel, to check for 80486.  Added check
;               for V86 mode just in case a Limulator or something
;               is active.
;
        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  CheckCPUType

CheckCPUType    proc  near

.8086

        pushf                           ; save flags during cpu test

        pushf
        pop     ax                      ; flags to ax

        and     ax, 0fffh               ; clear bits 12-15

        push    ax                      ; push immediate is bad op-code on 8086
        npopf                           ; try to put that in the flags

        pushf
        pop     ax                      ; look at what really went into flags

        and     ah,0f0h                 ; mask off high flag bits
        cmp     ah,0f0h                 ; Q: was high nibble all ones ?
        mov     ax, 0
        jz      cidx                    ;   Y: 8086
.286p
        smsw    ax
        test    ax,1                    ; Protected mode?
        jnz     cid386                  ; V86!  Gotta be at least a 386.

        push    0f000h                  ;   N: try to set the high bits
        npopf                           ;      ... in the flags

        pushf
        pop     ax                      ; look at actual flags

        and     ah,0f0h                 ; Q: any high bits set ?
        mov     ax, 2                   ; at least 286
        jz      cidx                    ;   N: 80286 - exit w/ Z flag set
                                        ;   Y: 80386 - Z flag reset

; 386 or 486? See if we can set the AC (Alignment check) bit in Eflags
;   Need to insure stack is DWORD aligned for this to work properly

.386
cid386:
        mov     ax, 3

        push    cx
        push    ebx

        mov     cx,sp                   ; Assume stack aligned
        and     cx,0011b                ; set "pop" count
        sub     sp,cx                   ; Move to DWORD aligned
        pushfd                          ; save entry flags (DWORD)
        push    dword ptr 40000h        ; AC bit
        popfd
        pushfd
        pop     ebx
        popfd                           ; Recover entry flags (DWORD)
        add     sp,cx                   ; pop off alignment bytes
        test    ebx,40000h              ; Did AC bit set?

        pop     ebx
        pop     cx

        jz      short cidx              ; No, 386
.286p
        inc     ax                      ; At least 80486...

cidx:
        mov     idCpuType,ax            ;store CPU type in global
        npopf                           ; restore flags after cpu test

CheckCPUType    endp

; -------------------------------------------------------
;   B_ParaToLinear
;
;   This function will convert a paragraph address in the lower
;   megabyte of memory space into a linear address for use in
;   a descriptor table.  This is a local duplicate of the function
;   ParaToLinear in DXUTIL.ASM.  This is duplicated here to avoid
;   having to make far calls to it during the initialization.
;
;   Input:  DX      - paragraph address
;   Output: DX      - lower word of linear address
;           BX     - high word of linear address
;   Errors: none
;   Uses:   DX, BX used, all else preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

B_ParaToLinear  proc  near

        xor     bh,bh
        mov     bl,dh
        shr     bl,4
        shl     dx,4
        ret

B_ParaToLinear  endp


if DEBUG        ;-------------------------------------------------------

; -------------------------------------------------------
;   CheckDOSXFixUps -- This routine will check for segment fix ups
;       in non-initialization code that need to be converted from
;       a segment to selector.
;
;       This routine works by opening the EXE file that we were
;       loaded from and examining the relocation table.
;
;       10-09-90 Earleh modified so that references in initialization
;       code are not edited.
;
;       11-12-90 JimMat renamed from RelocateDosExtender and it now
;       only checks for fix ups in DEBUG version since all fix ups
;       in post-initialization code have been removed.
;
;   Input:  none
;   Output: none
;   Errors: returns CY set if error occurs
;   Uses:   AX, all else preserved
;           modifies lpchFileName

        assume  ds:DGROUP,es:NOTHING,ss:DGROUP
        public  CheckDOSXFixUps

CheckDOSXFixUps proc    near

        push    bp
        mov     bp,sp
        push    bx
        push    dx
        push    si
        push    di
        push    es

; Find the path to our exe fie.

        mov     word ptr [lpchFileName],offset EXEC_DXNAME
        mov     word ptr [lpchFileName+2],ds

; Set up for reading the relocation table from the exe file.

        call    B_InitRelocBuffer
        jc      rldx90              ;get out if error

; Go down through the relocation table and for each fixup item,
; patch in our selector.

        mov     bx,segPSP
        add     bx,10h          ;the relocation table items are relative
                                ; to the initial load address of our program
                                ; image which is immediately after the PSP

rldx40: call    B_GetRelocationItem   ;get next relocation table entry
        jz      rldx60          ;if end of table, get out
        mov     di,ax           ;offset of relocation item
        add     dx,bx           ;adjust relocation item segment for our load
                                ; address
        mov     es,dx           ;

;
; Do not fixup instructions in initialization code.
;
        cmp     dx,seg DXCODE
        jne     rldx41
        cmp     di,offset DXCODE:CodeEnd
        jnc     rldx40
rldx41:
        cmp     dx,seg DXPMCODE
        jne     rldx42
        cmp     di,offset DXPMCODE:CodeEndPM
        jnc     rldx40
rldx42:

        mov     ax,es:[di]      ;get the current fixup contents
        cmp     ax,seg DXCODE   ;is it the mixed mode segment?
        jnz     rldx44

        extrn   lCodeSegLoc:WORD
        cmp     di,offset DXCODE:lCodeSegLoc    ;special far jmp to flush
        jz      rldx40                          ;  pre-fetch queue?  ok if so.

; Shouldn't get here--tell developer he messed something up!

        int     3       ;****************************************

        mov     word ptr es:[di],SEL_DXCODE or STD_RING
        jmp     short rldx40

rldx44: cmp     ax,seg DXPMCODE   ;is it the protected mode only segment
        jnz     rldx40

; Shouldn't get here--tell developer he messed something up!

        int     3       ;****************************************

        mov     word ptr es:[di],SEL_DXPMCODE or STD_RING
        jmp     rldx40          ;and repeat for the next one

; We have gone through the entire relocation table, so close up the exe file

rldx60: mov     bx,fhExeFile
        dossvc  3Eh
;
        clc
        jmp     short rldx90
;
; Error occured
rldx80: stc
;
; All done
rldx90: pop     es
        pop     di
        pop     si
        pop     dx
        pop     bx
        mov     sp,bp
        pop     bp
        ret

CheckDOSXFixUps endp


; -------------------------------------------------------
;   B_InitRelocBuffer     -- This routine will open the EXE
;       file and initialize for reading the relocation table
;       as part of relocating the program for protected mode
;       execution.
;
;   Input:  lpchFileName    - pointer to exe file name
;   Output: none
;   Errors: returns CY set if error occurs
;   Uses:   AX modified, all other registers preserved
;           sets up static variables:
;               clpRelocItem, plpRelocItem, fhExeFile
;           modifies rgbXfrBuf1 at offset RELOC_BUFFER

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  B_InitRelocBuffer

B_InitRelocBuffer  proc  near

        push    bx
        push    cx
        push    dx
        push    si
;
; Open the EXE file.
        push    ds
        lds     dx,lpchFileName
        mov     al,0
        dossvc  3Dh             ;attempt to open the exe file
        pop     ds
        jc      inrl80          ;get out if error occurs
;
        mov     fhExeFile,ax    ;store the file handle
        mov     bx,ax           ;file handle to BX also

; Read the EXE file header, so that we can get information about
; the relocation table.
        mov     dx,offset RELOC_BUFFER
        mov     si,dx
        mov     cx,32
        dossvc  3Fh
        jc      inrl80          ;get out if error
        cmp     ax,32
        jnz     inrl80
;
; Get the important values from the exe file header.
        cmp     [si].idExeFile,5A4Dh    ;make sure it is an EXE file
        jnz     inrl80

        mov     ax,[si].clpRelocLen ;number of relocation items
        mov     clpRelocItem,ax
        mov     plpRelocItem,0FFFFh ;init the pointer to the first one
                                    ; to a bogus value to force the initial
                                    ; buffer to be loaded
;
; Get the location of the relocation table, and move the file pointer
; to its start.

        xor     cx,cx
        mov     dx,[si].wRelocOffset

        mov     al,cl
        dossvc  42h
        jnc     inrl90
;
; Error occured
inrl80: stc
;
; All done
inrl90: pop     si
        pop     dx
        pop     cx
        pop     bx
        ret

B_InitRelocBuffer  endp


; -------------------------------------------------------
;   B_GetRelocationItem   -- This routine will return the next
;       relocation table entry from the exe file being relocated.
;
;   Input:  none
;   Output: AX      - offset of relocation item pointer
;           DX      - segment of relocation item pointer
;   Errors: returns ZR true if end of table and no more items
;   Uses:   AX, DX modified, all other registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  B_GetRelocationItem

B_GetRelocationItem  proc  near

        push    si
;
        cmp     clpRelocItem,0  ;are there any relocation items left?
        jz      gtrl90          ;get out if not
;
; Check if the buffer is empty.  The buffer for the relocation table is
; at offset RELOC_BUFFER in the buffer rgbXfrBuf1, and is 512 bytes long.
        cmp     plpRelocItem,offset RELOC_BUFFER + 512
        jc      gtrl40
;
; The buffer is empty, so we need to read the next part of it in.
        push    cx
        push    bx
        push    dx
        mov     ax,clpRelocItem ;number of items left in file
        shl     ax,2            ;multiply by size of relocation item
        jc      gtrl22          ;check for overflow
        cmp     ax,512          ;check if bigger than the buffer
        jc      gtrl24
gtrl22: mov     ax,512          ;use buffer size as size of transfer
gtrl24: mov     cx,ax
        mov     dx,offset RELOC_BUFFER
        mov     plpRelocItem,dx ;pointer to next reloc item to return
        mov     bx,fhExeFile
        dossvc  3Fh
        pop     dx
        pop     bx
        jc      gtrl28          ;if error occured
        cmp     ax,cx           ;or, if we didn't get as much as we asked
        jnz     gtrl28          ; for, we have an error
        pop     cx
        jmp     short gtrl40
;
gtrl28: pop     cx
        stc
        jmp     short gtrl90
;
; Get the next relocation item from the buffer.
gtrl40: mov     si,plpRelocItem
        lods    word ptr [si]   ;get the offset part of the reloc item
        mov     dx,ax
        lods    word ptr [si]   ;get the segment part of the reloc item
        xchg    dx,ax           ;put offset in AX, and segment in DX
        mov     plpRelocItem,si ;store the updated pointer
        dec     clpRelocItem    ;and bump the count down by 1
        or      si,si           ;clear the zero flag
;
; All done.
gtrl90: pop     si
        ret

B_GetRelocationItem  endp

endif   ;DEBUG  --------------------------------------------------------


; -------------------------------------------------------
;   GetExeName  -- This routine will put a copy of the complete
;       path name to the dos extender's exe file.  In a name
;       buffer in rgbXfrBuf1.
;
;   Input:  none
;   Output: EXEC_DXNAME buffer updated with complete pathname.
;   Errors: returns CY set if environment not correctly built.
;   Uses:   all preserved

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  GetExeName

GetExeName proc near

        push    ax
        push    si
        push    di
        push    ds

; The name of the current program is stored at the end of the environment
; table.  There are two bytes of 0 to indicate end of table, a byte
; with a 1 in it followed by another byte of 0 and then the null terminated
; string with the current program name.

gtxe20: mov     ds,segPSP
        assume  ds:PSPSEG
        mov     ds,segEnviron
        assume  ds:NOTHING
        xor     si,si
gtxe22: lods    byte ptr [si]       ;get next byte from environment
        or      al,al               ;test if 0
        jnz     gtxe22              ;if not, keep looking
        lods    byte ptr [si]       ;get next byte
        or      al,al               ;see if it is 0 also
        jnz     gtxe22

; We have found the double 0 at the end of the environment.  So
; we can now get the name.  At the end of the environment is an
; argc, argv construct.  (i.e. a word giving the count of strings
; followed by an array of strings).  Under DOS, argc is always 1,
; so check that there is a word of 1 here.  If not, this environment
; wasn't built correctly and we don't know what is here.

        lods    word ptr [si]
        cmp     ax,1
        jnz     gtxe80


; We have the pointer to the name, now copy it.

        mov     di,offset EXEC_DXNAME
        call    strcpy
        clc
        jmp     short gtxe90

; We have an error.

gtxe80: stc                         ;set error condition flag

gtxe90: pop     ds
        pop     di
        pop     si
        pop     ax
        ret

GetExeName endp


; -------------------------------------------------------
;           COMMAND LINE PARSING ROUTINES
; -------------------------------------------------------
;   ParseCommandLine    -- This function will examine the dos
;       command line that caused the Dos Extender to be exec'd
;       and determine what the user wants done.  It will set
;       up the various buffers required for the child program
;       to be loaded.
;
;       NOTE: the child exe file name read from the command line
;       is placed in RELOC_BUFFER in the case where the child
;       name is specified on the command line.  This buffer is
;       used later when reading the relocation table while
;       performing the fixups on the child.
;
;   Input:  none
;   Output: AL      - 0 if empty command line, else non-zero
;           parse buffers in rgbXfrBuf1 set up.
;   Errors: none
;   Uses:   AX, all else preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  ParseCommandLine

ParseCommandLine proc near

        push    si
        push    di
        push    ds

        mov     ds,segPSP
        assume  ds:PSPSEG
        mov     si,81h          ;pointer to command line in PSP

; Skip any white space in front of the child program name.

prsc12: lods    byte ptr [si]
        cmp     al,' '
        jz      prsc12

        dec     si

; Copy the command line tail following the program name to the command
; line buffer for use when we load the child.

prsc40: push    si              ;save current point in parse
        mov     di,offset EXEC_CMNDLINE + 1
        xor     dl,dl           ;count characters in command line tail
prsc42: lods    byte ptr [si]   ;get the next character
        stos    byte ptr [di]   ;store it into the output buffer
        cmp     al,0Dh          ;is it the end of the line?
        jz      prsc44
        inc     dl              ;count the character
        jmp     prsc42

prsc44: mov     es:[EXEC_CMNDLINE],dl   ;store the character count
        pop     si              ;restore the buffer pointer

; Now we want to set up the two default FCB's by letting DOS parse the
; first two parameters on the command line.

        mov     di,offset EXEC_FCB0
        mov     al,1
        dossvc  29h
        mov     di,offset EXEC_FCB1
        mov     al,1
        dossvc  29h

prsc90:
        pop     ds
        pop     di
        pop     si
        ret

ParseCommandLine endp


; -------------------------------------------------------
;   strcpy      -- copy a null terminated string.
;
;   Input:  DS:SI       - pointer to source string
;           ES:DI       - pointer to destination buffer
;   Output: ES:DI       - pointer to end of destination string
;   Errors: none
;   Uses:   DI modified, all else preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  strcpy

strcpy  proc   near

        push    ax
        push    si
stcp10: lods    byte ptr [si]
        stos    byte ptr [di]
        or      al,al
        jnz     stcp10
        dec     di
        pop     si
        pop     ax
        ret

strcpy  endp


; -------------------------------------------------------
;   strcmpi     -- This function will perform a case insensitive
;       comparison of two null terminated strings.
;
;   Input:  DS:SI       -   string 1
;           ES:DI       -   string 2
;   Output: ZR if the strings match, else NZ
;           CY set if string 1 less than string 2
;   Errors: none
;   Uses:   all registers preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  strcmpi

strcmpi proc    near

        push    si
        push    di
stcm20: mov     al,byte ptr ds:[si]
        call    toupper
        mov     ah,al
        mov     al,byte ptr es:[di]
        call    toupper
        cmp     ah,al
        jnz     stcm90
        or      al,ah
        jz      stcm90
        inc     si
        inc     di
        jmp     stcm20
stcm90: pop     di
        pop     si
        ret

strcmpi endp


; -------------------------------------------------------
;   IsFileNameChar      -- This function will examine the
;       character in AL and determine if it is a legal character
;       in an MS-DOS file name.
;
;   Input:  AL      - character to test
;   Output: ZR true if character is legal in a file name
;   Errors: none
;   Uses:   all registers preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

IsFileNameChar  proc    near

        push    ax
        cmp     al,20h          ;is it a control character
        jbe     isfc80          ;if so, it isn't valid

        cmp     al,':'
        jz      isfc80
        cmp     al,';'
        jz      isfc80
        cmp     al,','
        jz      isfc80
        cmp     al,'='
        jz      isfc80
        cmp     al,'+'
        jz      isfc80
        cmp     al,'<'
        jz      isfc80
        cmp     al,'>'
        jz      isfc80
        cmp     al,'|'
        jz      isfc80
        cmp     al,'/'
        jz      isfc80
        cmp     al,'"'
        jz      isfc80
        cmp     al,'['
        jz      isfc80
        cmp     al,']'
        jz      isfc80

        xor     al,al
        jmp     short isfc90

; Not a valid file name character

isfc80: or      al,0FFh

isfc90: pop     ax
        ret

IsFileNameChar  endp


; -------------------------------------------------------
;   toupper   -- This function will convert the character
;       in AL into upper case.
;
;   Input:  AL      - character to convert
;   Output: AL      - upper case character
;   Errors: none
;   Uses:   AL modified, all else preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  toupper

toupper proc    near

        cmp     al,'a'
        jb      toup90
        cmp     al,'z'
        ja      toup90
        sub     al,'a'-'A'
toup90:
        ret

toupper endp

; -------------------------------------------------------

DXCODE  ends

;
;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxdisk.asm ===
PAGE    ,132
        TITLE   DXDISK.ASM  -- Dos Extender Low Level Disk Interface

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;***********************************************************************
;
;       DXDISK.ASM      -- Dos Extender Low Level Disk Interface
;
;-----------------------------------------------------------------------
;
; This module provides the 286 DOS extender's low level protected-to-
; real mode disk interface.  It supports a subset of the BIOS Int 13h
; and DOS Int 25h/26h services.
;
;-----------------------------------------------------------------------
;
;  05/22/89 jimmat  Original version
;  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include interupt.inc
include intmac.inc

        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   EnterIntHandler:NEAR
        extrn   LeaveIntHandler:NEAR
        extrn   EnterRealMode:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   GetSegmentAddress:NEAR
        extrn   SetSegmentAddress:NEAR
externFP        NSetSegmentDscr
        extrn   FreeSelector:NEAR
        extrn   AllocateSelector:NEAR
        extrn   ParaToLDTSelector:NEAR

ifdef     NEC_98    ;
        extrn   IncInBios:NEAR          ; 
        extrn   DecInBios:NEAR          ;
endif  ;NEC_98   ;

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   rgbXfrBuf0:BYTE
        extrn   rgbXfrBuf1:BYTE
ifdef    NEC_98
        extrn   rglpfnRmISR:DWORD
endif

cbSectorSize            dw      ?       ;sector size for target drive
cSectorsTransfered      dw      ?       ;# sectors transfered so far
cSectorsToTransfer      dw      ?       ;# sectors to read/write
cSectorsPerTransfer     dw      ?       ;# sectors to R/W at a time
cSectorsThisTransfer    dw      ?       ;# sectors to R/W this time
lpSectorData            dd      ?       ;far pointer to caller's buffer

ifdef      NEC_98    ;
public  lpRmISR
endif   ;NEC_98   ;
lpRmISR                 dd      ?       ;real mode int service rtn to invoke

ifdef      NEC_98    ;
sensedata1              dw      ?       ;sector length
sensedata2              dw      ?       ;cylinder
sensedata3              dd      ?       ;head
sensedata4              dd      ?       ;sector num

        extrn   fPCH98:BYTE     ;for PC_H98
endif   ;NEC_98   ;
DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

DXCODE  ends


DXPMCODE segment

        extrn   segDXDataPM:WORD

DXPMCODE ends


; -------------------------------------------------------
        subttl  INT 13h Mapping Services
        page
; -------------------------------------------------------
;             INT 13h MAPPING SERVICES
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntr13 -- Service routine for the Protect Mode INT 13h
;       interface to the real mode BIOS.
;
;   Input:  Various registers
;   Output: Various registers
;   Errors:
;   Uses:   All registers preserved, other than return values
;
;   Currently, the following Int 13h services are supported:
;
;   ah= 0 - Reset Disk System                   (no mapping required)
;       1 - Get Disk System Status              (no mapping required)
;       2 - Read Sector                         (mapping required)
;       3 - Write Sector                        (mapping required)
;       4 - Verify Sector                       (mapping required)
;       5 - Fromat Track                        (mapping required)
;       6 - Format Bad Track                    (no mapping required)
;       7 - Format Drive                        (no mapping required)
;       8 - Get Drive Parameters                (mapping required)
;       9 - Init Fixed Disk Characteristics     (no mapping required)
;       C - Seek                                (no mapping required)
;       D - Reset Disk System                   (no mapping required)
;      10 - Get Drive Status                    (no mapping required)
;      11 - Recalibrate Drive                   (no mapping required)
;      12 - Controller RAM Diagnostic           (no mapping required)
;      13 - Controller Drive Diagnostic         (no mapping required)
;      14 - Controller Internal Diagnostic      (no mapping required)
;      15 - Get Disk Type                       (no mapping required)
;      16 - Get Disk Change Status              (no mapping required)
;      17 - Set Disk Type                       (no mapping required)
;      18 - Set Media Type for Format           (mapping required)
;      19 - Park Heads                          (no mapping required)
;
;   Functions not listed above will most likely not work properly!
;
;   NOTE: several functions take 2 bits of the cylinder number in CL
;         if the operation is on a fixed disk.  The code currently does
;         not account for these bits, and may not work properly if
;         the request must be split into smaller operations for real/
;         extended memory buffering.
;

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntr13

PMIntr13        proc    near

ifdef      NEC_98    ;
        call    IncInBios               ; 
endif   ;NEC_98   ;
        cld                             ;cya...

        call    EnterIntHandler         ;build an interrupt stack frame
        assume  ds:DGROUP,es:DGROUP     ;  also sets up addressability

        FSTI                             ;allow HW interrupts

        call    IntEntry13              ;perform translations/buffering

; Execute the real mode BIOS routine
ifdef      NEC_98    ;
        push    es
        assume es:nothing
        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        mov     ax,word ptr es:[4*1bh]  ;move real mode Int 13h
        mov     word ptr [bp].lParam,ax         ;  handler address to
        mov     ax,word ptr es:[4*1bh+2];  lParam on stack frame
        mov     word ptr [bp].lParam+2,ax
        pop     es
        assume es:DGROUP

        mov     ah,1bh                          ;wParam1 = int #, function
else    ;NEC_98   ;

        push    es
        assume es:nothing
        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        mov     ax,word ptr es:[4*13h]  ;move real mode Int 13h
        mov     word ptr [bp].lParam,ax         ;  handler address to
        mov     ax,word ptr es:[4*13h+2];  lParam on stack frame
        mov     word ptr [bp].lParam+2,ax
        pop     es
        assume es:DGROUP

        mov     ah,13h                          ;wParam1 = int #, function
endif   ;NEC_98   ;
        mov     al,byte ptr [bp].intUserAX+1
        mov     [bp].wParam1,ax

ifdef      NEC_98    ;
        and     al,0fh
        cmp     al,05           ;write data?
        jb      i13_not_rw
        cmp     al,06           ;read data?
        ja      i13_not_rw
else    ;NEC_98   ;
        cmp     al,02                   ;call special read/write routine
        jb      i13_not_rw              ;  if this is a read/write sectors
        cmp     al,03                   ;  request
        ja      i13_not_rw
endif   ;NEC_98   ;

        call    ReadWriteSectors        ;common Int 13h/25h/26h read/write code
        jmp     short i13_done

i13_not_rw:
        SwitchToRealMode                ;otherwise, do the service ourself
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     [bp + 6],word ptr (offset i13_10)
ifdef      NEC_98    ;
        mov     ax,es:[1Bh*4]
        mov     [bp + 2],ax
        mov     ax,es:[1Bh*4 + 2]
else    ;NEC_98   ;
        mov     ax,es:[13h*4]
        mov     [bp + 2],ax
        mov     ax,es:[13h*4 + 2]
endif   ;NEC_98   ;
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

i13_10: pushf
        FCLI
        pusha
        push    ds
        push    es
        mov     bp,sp                   ;restore stack frame pointer
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        FSTI                             ;allow HW interrupts

; Perform fixups on the return register values.

i13_done:
        mov     ax,[bp].pmUserAX        ;get original function code
        call    IntExit13

        FCLI                             ;LeaveIntHandler requires ints off
        call    LeaveIntHandler         ;restore caller's registers, stack
        assume  ds:NOTHING,es:NOTHING

ifdef      NEC_98    ;
        call    DecInBios               ; 
endif   ;NEC_98   ;
        riret

PMIntr13        endp


; -------------------------------------------------------
;  IntEntry13 -- This routine performs translations and
;       buffering of Int 13h requests on entry.
;

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntEntry13

IntEntry13      proc    near

ifdef      NEC_98    ;
        and     ah,0fh

        cmp     ah,05                   ;Write sectors? 
        jb      @f
        cmp     ah,06                   ;Read sectors?  
        ja      @f

;----------- 90/08/13  copy segment address from ds -------
        push    ax                      
        mov     ax,segDXDataPM
        mov     [bp].intUserES,ax       ;segment address
        pop     ax
;------------------------------------------------------------
        mov     [bp].intUserBP,offset DGROUP:rgbXfrBuf1 ;use DOSX buffer 90/07/13 
        ret
@@:
        cmp     ah,01h                  ;Verify sectors? 
        jnz     @f

        mov     [bp].intUserES,0F000h   ;older versions of verify need a buff,
        mov     [bp].intUserBP,0        ; offset adress 90/07/12  change
        ret
@@:
        cmp     ah,0Dh                  ;Format track? 
        jnz     @f

;------ 90/11/08  debug -----

        push    ds
        mov     si,[bp].pmUserBP        ;es:bx -> 512 byte buffer to copy down
        mov     ds,[bp].pmUserES
        mov     di,offset DGROUP:rgbXfrBuf1
        mov     cx,128                  ;might be good to check segment limit
        cld                             ;  on callers source!
        rep     movsw
        pop     ds
        
        push    ax                      
        mov     ax,segDXDataPM
        mov     [bp].intUserES,ax       ;segment address
        pop     ax
        mov     [bp].intUserBP,offset DGROUP:rgbXfrBuf1

        push    es
        pop     ds

        ret
@@:
;///// 90/09/04  PC_H98 DISK BIOS command(Read Defect Data) support/////
        test    fPCH98,0FFh
        jz      @f
        cmp     ah,0Ch
        jz      ReadDD
        cmp     ah,2Ch
        jz      ReadDD
        jmp     @f

ReadDD:
        push    ax
        mov     ax,segDXDataPM
        mov     [bp].intUserES,ax       ;segment address
        pop     ax
        mov     [bp].intUserBP,offset DGROUP:rgbXfrBuf1 ;use DOSX buffer 90/07/13 
;///// 90/09/04  PC_H98 DISK BIOS command(Read Defect Data) support/////

@@:
        ret

else    ;NEC_98   ;
        cmp     ah,02                   ;Read sectors?
        jb      @f
        cmp     ah,03                   ;Write sectors?
        ja      @f

        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 ;use DOSX buffer
        ret
@@:
        cmp     ah,04h                  ;Verify sectors?
        jnz     @f

        mov     [bp].intUserES,0F000h   ;older versions of verify need a buff,
        mov     [bp].intUserBX,0        ;  we just point them at the BIOS!
        ret
@@:
        cmp     ah,05h                  ;Format track?
        jnz     @f

        mov     si,bx                   ;es:bx -> 512 byte buffer to copy down
        mov     di,offset DGROUP:rgbXfrBuf1
        mov     [bp].intUserBX,di
        mov     ds,[bp].pmUserES
        mov     cx,256                  ;might be good to check segment limit
        cld                             ;  on callers source!
        rep movsw

        push    es
        pop     ds

        ret
@@:

        ret
endif   ;NEC_98   ;

IntEntry13      endp


; -------------------------------------------------------
;  IntExit13 -- This routine performs translations and
;       buffering of Int 13h requests on exit.
;

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntExit13

IntExit13       proc    near

ifdef      NEC_98    ;
; Functions 06h (Read sectors) and 05h (Write sectors) return a count of
; sectors transfered in AL.  Since we may break the transfer up into a
; number of transfers, we have to return the total # that we transfered,
; not the number of the last bios request.

;----- 90/11/08 debug -----
        and     ah,0fh
;----- 90/11/08 debug -----

;----- 90/07/06 change -----
        cmp     ah,05h          ;Write data 
        jb      @f
        cmp     ah,06h          ;Read data 
        ja      @f

        mov     al,byte ptr cSectorsTransfered
        mov     byte ptr [bp].intUserAX,al
@@:

; Functions 06h (Read sectors), 05h (Write sectors), 01h (Verify sectors),
; and 0Dh (Format track) need to have the caller's value of bx restored.

;----- 90/07/06 change -----

        cmp     ah,01h                  ;Verify sectors? 
        je      @f
        cmp     ah,05h                  ;Write sectors? 
        je      @f
        cmp     ah,06h                  ;Read sectors? 
        je      @f
        cmp     ah,0Dh                  ;Format track? 
        jne     other
        
;offset adress 90/07/12 change
;----------- 90/08/13 copy segment address from ES -------
        mov     ax,[bp].pmUserES
        mov     [bp].intUserES,ax
;------------------------------------------------------------
@@:     mov     ax,[bp].pmUserBP        ;restore caller's BP value
        mov     [bp].intUserBP,ax
other:
        ret

else    ;NEC_98   ;
; Functions 02h (Read sectors) and 03h (Write sectors) return a count of
; sectors transfered in AL.  Since we may break the transfer up into a
; number of transfers, we have to return the total # that we transfered,
; not the number of the last bios request.

        cmp     ah,02h
        jb      @f
        cmp     ah,03h
        ja      @f

        mov     al,byte ptr cSectorsTransfered
        mov     byte ptr [bp].intUserAX,al
@@:

; Functions 02h (Read sectors), 03h (Write sectors), 04h (Verify sectors),
; and 05h (Format track) need to have the caller's value of bx restored.

        cmp     ah,02h                  ;Read sectors?
        jb      @f
        cmp     ah,05                   ;Format track?
        ja      @f

        mov     ax,[bp].pmUserBX        ;restore caller's BX value
        mov     [bp].intUserBX,ax
        ret
@@:

; Functions 08h (Get Drive Parameters) and 18h (Set Drive Type for Format)
; return a pointer in ES:DI.  Map the segment in ES to a selector

        cmp     ah,08h                  ;Get Drive Parameters
        jz      i13_map_es
        cmp     ah,18h
        jnz     @f

i13_map_es:
        test    byte ptr [bp].intUserFL,1       ;don't bother to map ES if
        jnz     @f                              ;  function failed (carry set)

i13_do_it:
        mov     ax,[bp].intUserES       ;returns a pointer in ES:DI, get
        mov     bx,STD_DATA             ;  a selector for it
        call    ParaToLDTSelector
        mov     [bp].pmUserES,ax
        ret
@@:

        ret
endif   ;NEC_98   ;

IntExit13       endp


; -------------------------------------------------------
        subttl  INT 25h/26h Absolute Disk Read/Write
        page
; -------------------------------------------------------
;        INT 25h/26h ABSOLUTE DISK READ/WRITE
; -------------------------------------------------------
;  PMIntr25 -- This routine provides the protected-to-real
;       mode mapping for Int 25h (Absolute Disk Read)
;
;       In:     al    - drive # (0 = A, 1 = B, ...)
;               cx    - # of sectors to read
;               dx    - starting sector #
;               ds:bx - selector:offset of buffer
;
;                        -- or --
;
;               al    - drive #
;               cx    - -1
;               ds:bx - pointer to 5 word parameter block
;
;       Out:    if successful, carry clear
;               if unsuccessful, carry set and
;                       ax - error code

        assume  ds:DGROUP,es:DGROUP
        public  PMIntr25

PMIntr25        proc    near

ifdef      NEC_98    ;
        call    IncInBios               ; 
endif   ;NEC_98   ;
        cld                             ;cya...

        call    EnterIntHandler         ;build an interrupt stack frame
        assume  ds:DGROUP,es:DGROUP     ;  also sets up addressability

        FSTI                             ;allow HW interrupts

        mov     ah,25h
        call    IntEntry2X              ;perform translations/buffering

; Do the read

        push    es
        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        assume  es:nothing
        mov     ax,word ptr es:[4*25h]  ;move real mode Int 25h
        mov     word ptr [bp].lParam,ax         ;  handler address to
        mov     ax,word ptr es:[4*25h+2];  lParam on stack frame
        mov     word ptr [bp].lParam+2,ax
        pop     es
        assume  es:DGROUP

        mov     ah,25h                          ;wParam1 = int #
        mov     [bp].wParam1,ax

        call    ReadWriteSectors        ;common Int 13h/25h/26h read/write code

; Perform fixups on the return register values.

        mov     ah,25h
        call    IntExit2X               ;perform translations/buffering

        FCLI
        call    LeaveIntHandler         ;restore caller's registers, stack
        assume  ds:NOTHING,es:NOTHING

; Int 25 & 26 leave the caller's flags on the stack, but we want to return
; with the flags returned by the real mode ISR (which LeaveIntHandler has
; incorporated into the caller's flags), so make a copy of the flags and
; pop them into the flags register before returning.

        push    ax
        push    bp
        mov     bp,sp                   ;bp -> BP  AX  IP  CS  FL
        mov     ax,[bp+8]
        xchg    ax,[bp+2]               ;bp -> BP  FL  IP  CS  FL
        pop     bp
ifdef      NEC_98    ;
        call    DecInBios               ; 
endif   ;NEC_98   ;
        npopf

        retf

PMIntr25        endp


; -------------------------------------------------------
;  PMIntr26 -- This routine provides the protected-to-real
;       mode mapping for Int 26h (Absolute Disk Write)
;
;       In:     al    - drive # (0 = A, 1 = B, ...)
;               cx    - # of sectors to write
;               dx    - starting sector #
;               ds:bx - selector:offset of buffer
;
;                        -- or --
;
;               al    - drive #
;               cx    - -1
;               ds:bx - pointer to 5 word parameter block
;
;       Out:    if successful, carry clear
;               if unsuccessful, carry set and
;                       ax - error code

        assume  ds:DGROUP,es:DGROUP
        public  PMIntr26

PMIntr26        proc    near

ifdef      NEC_98    ;
        call    IncInBios               ; 
endif   ;NEC_98   ;
        cld                             ;cya...

        call    EnterIntHandler         ;build an interrupt stack frame
        assume  ds:DGROUP,es:DGROUP     ;  also sets up addressability

        FSTI                             ;allow HW interrupts

        mov     ah,26h
        call    IntEntry2X              ;perform translations/buffering

; Do the write

        push    es
        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        assume  es:nothing
        mov     ax,word ptr es:[4*26h]  ;move real mode Int 25h
        mov     word ptr [bp].lParam,ax         ;  handler address to
        mov     ax,word ptr es:[4*26h+2];  lParam on stack frame
        mov     word ptr [bp].lParam+2,ax
        pop     es
        assume es:DGROUP

        mov     ah,26h                          ;wParam1 = int #
        mov     [bp].wParam1,ax

        call    ReadWriteSectors        ;common Int 13h/25h/26h read/write code

; Perform fixups on the return register values.

        mov     ah,26h
        call    IntExit2X               ;perform translations/buffering

        FCLI
        call    LeaveIntHandler         ;restore caller's registers, stack
        assume  ds:NOTHING,es:NOTHING

; Int 25 & 26 leave the caller's flags on the stack, but we want to return
; with the flags returned by the real mode ISR (which LeaveIntHandler has
; incorporated into the caller's flags), so make a copy of the flags and
; pop them into the flags register before returning.

        push    ax
        push    bp
        mov     bp,sp                   ;bp -> BP  AX  IP  CS  FL
        mov     ax,[bp+8]
        xchg    ax,[bp+2]               ;bp -> BP  FL  IP  CS  FL
        pop     bp
ifdef      NEC_98    ;
        call    DecInBios               ; 
endif   ;NEC_98   ;
        npopf

        retf

PMIntr26        endp


; -------------------------------------------------------
;  IntEntry2X -- This routine performs translations and
;       buffering of Int 25h and 26h requests on entry.
;

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntEntry2X

IntEntry2X      proc    near

        cmp     [bp].intUserCX,-1               ;DOS 4.0 extended read/write?
        jnz     e2x_dsbx                        ;  no, just go map DS:BX

        mov     ds,[bp].pmUserDS                ;  yes, copy down parameter blk
        assume  ds:NOTHING
        mov     si,[bp].pmUserBX
        mov     di,offset rgbXfrBuf0
        cld
        movsw                                   ;32-bit sector #
        movsw
        movsw                                   ;# sectors to read/write

        mov     ax,offset rgbXfrBuf1            ;replace pointer with addr of
        stosw                                   ;  our own low buffer
        mov     ax,segDXDataPM                  ;segment, not selector
        stosw

        push    es
        pop     ds
        assume  ds:DGROUP

        mov     [bp].intUserBX,offset rgbXfrBuf0

        ret

e2x_dsbx:                       ;standard read/write, just redirect DS:BX

        mov     [bp].intUserBX,offset rgbXfrBuf1

        ret

IntEntry2X      endp


; -------------------------------------------------------
;  IntExit2X -- This routine performs translations and
;       buffering of Int 25h and 26h requests on exit.
;

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntExit2X

IntExit2X       proc    near


        mov     ax,[bp].pmUserBX                ;restore caller's BX
        mov     [bp].intUserBX,ax

        ret

IntExit2X       endp


; -------------------------------------------------------
        subttl  Disk Utility Routines
        page
; -------------------------------------------------------
;               DISK UTILITY ROUTINES
; -------------------------------------------------------
;  ReadWriteSectors -- Common code to read/write disk sectors for
;       Int 13h/25h/26h.
;
;       In:     lParam  - seg:off of real mode interrupt handler
;               wParam1 - int #, and possible subfunction
;               regs on stack


        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  ReadWriteSectors

ReadWriteSectors  proc  near

ifdef      NEC_98    ;
        pop     [bp].wParam2            ;save return addr higher on stack

; Setup the global data items for the read/write--pointer to caller's
; buffer, # sectors to read/write, and sector size.

        cmp     byte ptr [bp].wParam1+1,1Bh     ;Int 1Bh?
        jz      DISK_BIOS
        jmp     DOSReadWriteSectors
;;;;;;;;        jmp     rws_dos_size

DISK_BIOS:
;offset adress 90/07/12 change
        mov     ax,[bp].pmUserBP                ;ES:BP points to caller's buf  
        mov     word ptr lpSectorData,ax
        mov     ax,[bp].pmUserES
        mov     word ptr [lpSectorData+2],ax

;US:sector num, but :data length 90/07/13 

;-------------------------- 90/07/23 in ---------------------------
;       to adjust to US, we get a data with sense command on HDD,
;       and set a data with 1MB/640KB on FDD.
;----------------------------------------------------------------------
        mov     al,byte ptr [bp].intUserAX      ;
                                                ;
        push    ax
        and     al,10h                  ;DA:4th bit on :FDD
        pop     ax
        jnz     FDBIOS
        
        mov     ah,84h                  ;SENSE command

        push    ax
        SwitchToRealMode
        pop     ax

        pushf                           ;have BIOS get the drive data
        call    rglpfnRmISR[1Bh*4]      ;90/07/04 

        mov     sensedata1,bx           ;sector length
        mov     sensedata2,cx           ;cylinder
        mov     byte ptr sensedata3,dh          ;DH = head
        mov     byte ptr sensedata4,dl          ;DL = sector num

        SwitchToProtectedMode
        jmp     SECTOR

        
FDBIOS: 

        push    ax
        mov     cx,[bp].intUserCX       ;sector size shift factor (0,1,2,3)
;;;;;;;;        mov     cl,byte ptr [bp].intUserCX      ;sector size shift factor (0,1,2,3)
        mov     ax,128
        xchg    ch,cl
        shl     ax,cl                   ;ax now = sector size
        mov     cx,ax
        mov     sensedata1,cx           ;sector length
        pop     ax
        
        cmp     al,90h                  ;1MB floppy disk,1MB/640KBdual modefloppy disk(1MB FD access)
        jb      fd640k
        cmp     al,93h
        ja      fd640k
        
;set the max value to the buffer with 1MBFD
        mov     sensedata2,77           ;cylinder
        mov     word ptr sensedata3,1           ;head
        mov     word ptr sensedata4,26          ;sector num
        jmp     SECTOR

fd640k:
        cmp     al,70h                  ;640KB floppy disk
        jb      @f
        cmp     al,73h
        ja      @f
        mov     sensedata2,79           ;cylinder
        mov     word ptr sensedata3,1           ;head
        mov     word ptr sensedata4,16          ;sector num
        jmp     SECTOR
@@:
        cmp     al,10h                  ;1MB/640KB dual modefloppy disk(640KB FD access)
        jb      @f
        cmp     al,13h
        ja      @f
        mov     sensedata2,79           ;cylinder
        mov     word ptr sensedata3,1           ;head
        mov     word ptr sensedata4,16          ;sector num
        jmp     SECTOR
@@:
        cmp     al,30h                  ;1.44MBfloppy disk '93 1/5 By S.Kurokawa
        jb      fdother
        cmp     al,33h
        ja      fdother
        mov     sensedata2,79           ;cylinder
        mov     word ptr sensedata3,1           ;head
        mov     word ptr sensedata4,18          ;sector num
        jmp     SECTOR


;------------------------ 90/07/23 ------------------------------
;       for the media except for 1MB FD,640KB FD ::i10MB FDj
;       we do not know that we can certainly issue a sense command
;--------------------------------------------------------------------
fdother:
        mov     ah,84h                  ;SENSE command

        push    ax
        SwitchToRealMode
        pop     ax

        pushf                           ;have BIOS get the drive data
        call    rglpfnRmISR[1Bh*4]      ;90/07/04 

        mov     sensedata1,bx           ;sector length
        mov     sensedata2,cx           ;cylinder
        mov     byte ptr sensedata3,dh          ;DH = head
        mov     byte ptr sensedata4,dl          ;DL = sector num

        SwitchToProtectedMode


SECTOR:
        push    dx
        xor     dx,dx
        mov     cx,sensedata1                   ;sector length
        mov     ax,[bp].intUserBX       ;# sectors caller wants to
        div     cx
        mov     cSectorsToTransfer,ax           ;bytes^sector lensector num
        pop     dx

;;;;    mov     cx,1                    ;90/07/13  
        
	FSTI                             ;don't need them disabled

if DEBUG   ;------------------------------------------------------------

        cmp     cx,512
        jz      @f
        Debug_Out "Odd sector size = #CX"
@@:

endif   ;DEBUG  --------------------------------------------------------

; CX now has the drive's sector size.  Determine how many sectors we can
; transfer at a time

rws_have_size:

        mov     cbSectorSize,cx         ;save sector size for later

        xor     dx,dx
        mov     ax,CB_XFRBUF1           ;buf size / sector size = sectors per
        div     cx                      ;  transfer

if DEBUG   ;------------------------------------------------------------
        or      ax,ax
        jnz     @f
        Debug_Out "Sectors per transfer = 0!"
@@:
endif   ;DEBUG  --------------------------------------------------------

        mov     cSectorsPerTransfer,ax

        xor     ax,ax
        mov     cSectorsTransfered,ax   ;sectors transfered so far = 0
        mov     cSectorsThisTransfer,ax ;sectors transfered last time = 0

; Get/init a selector that we'll use to reference the caller's buffer.

        mov     ax,word ptr [lpSectorData+2]    ;get lma of caller's buffer
        call    GetSegmentAddress
        add     dx,word ptr lpSectorData
        adc     bx,0

        call    AllocateSelector                ;build a sel/dscr pointing
        mov     cx,0FFFFh
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>
        xor     bx,bx
        mov     word ptr lpSectorData,bx        ;use that as the buffer ptr
        mov     word ptr [lpSectorData+2],ax


; ======================================================================
; Main sector read/write loop ------------------------------------------
; ======================================================================

rws_do_it_loop:

; Calculate how many sectors to transfer this time around, set starting
; sector number based on how many transfered last time.

;       int     3                       ;------ 90/11/08 debug ------

        mov     ax,cSectorsToTransfer                   ;total sector
        sub     ax,cSectorsTransfered                   ;total sector - transferred sector = remain
        jnz     @f
        jmp     rws_done
@@:
        cmp     ax,cSectorsPerTransfer                  ;buffer size / sector len = sectors in buffer
        jna     @f                                      ;sectors in buffer > remain sectors = remain
        mov     ax,cSectorsPerTransfer                  ;sectors in buffer < remain = sectors in buffer
@@:
        mov     bx,cSectorsThisTransfer         ;still # R/W from last loop


        push    [bp].pmUserAX                   ;the BIOS does not save
        pop     [bp].intUserAX                  ;  registers across calls to
        push    [bp].pmUserCX                   ;  it so if we're doing
        pop     [bp].intUserCX                  ;  multiple calls to buffer
;       push    [bp].pmUserDX                   ;  data, restore the initial
;       pop     [bp].intUserDX                  ;  register values

;       Previous two lines include bug. '93 1/15 Debugged by S.Kurokawa.

;in  data transmits with a byte, so mov AX to BX 90/07/18 
;;;;    mov     byte ptr [bp].intUserAX,al      ;# sectors in AL = sectors
        push    ax      ;90/11/08 
        xor     ah,ah                           ;for calc a data len, ah=0 90/07/25
        mov     cx,cbSectorSize
        mul     cx                              ;sector num * sector len                90/07/25
        mov     [bp].intUserBX,ax       ;# sectors in BX = data len
        pop     ax      ;90/11/08 
;;;;    add     byte ptr [bp].intUserCX,bl      ;update new start sector in CL
        add     byte ptr [bp].intUserDX,bl      ;update new start sector in DL = sector num@90/07/13 


rws_size_start_set:

; At this point, AX has the number of sectors to transfer.  If this is a
; write, copy a buffer of data from the caller's buffer.

        mov     cSectorsThisTransfer,ax         ;in case it's a read
        ;cSectorsThisTransfer = sectors in buffer or remained sectors

;----------------90/11/08 debug -------------------------------------
        push    ax
        mov     ax,[bp].wParam1         ;BIOS write? 
        and     ax,0ff0fh
        cmp     ax,1B05h                ;BIOS write? 
        pop     ax
;----------------90/11/08 debug -------------------------------------
        
        jnz     rws_not_write
;       call    DBIOS_DEVICE

rws_buf_write:

        mul     cbSectorSize            ;AX now = # bytes to transfer
        mov     cx,ax                   ;can safely assume < 64k
        shr     cx,1                    ;# words to move
;       lds     si,lpSectorData
;       assume  ds:NOTHING
        push    ds
        mov     si,[bp].pmUserBP        ;90/11/09 
        mov     ds,[bp].pmUserES        ;90/11/09 

;       mov     di,offset rgbXfrBuf1
        mov     di,offset DGROUP:rgbXfrBuf1
        cld
        rep movsw
        pop     ds
        
        push    es
        pop     ds
        assume  ds:DGROUP

        mov     word ptr [bp].pmUserBP,si       ;update src ptr for next time
;       mov     word ptr lpSectorData,si        ;update src ptr for next time
;       call    NormalizeBufPtr                 ;  and normalize it


rws_not_write:

;------------------------------------------------------------
        push    ax                      ;90/11/09 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        mov     ax,segDXDataPM
;       mov     ax,[bp].pmUserES        ;debug
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        mov     [bp].intUserES,ax       ;segment address
        pop     ax
        mov     [bp].intUserBP,offset DGROUP:rgbXfrBuf1
;------------------------------------------------------------

; Switch to real mode, do the transfer.

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP

        push    word ptr [bp].lParam
        pop     word ptr lpRmISR
        push    word ptr [bp].lParam+2
        pop     word ptr lpRmISR+2

        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        call    lpRmISR
        pushf
        FCLI

rws_save_regs:

        pusha
        push    ds
        push    es
        mov     bp,sp                   ;restore stack frame pointer

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        FSTI                             ;allow HW interrupts


; If the call failed, then cut out now without further processing...

        test    byte ptr [bp].intUserFL,1       ;CY set?
        jnz     rws_done

; If this was a successful read, copy the data back to the caller.

;----------------90/11/08 debug -------------------------------------
        push    ax
        mov     ax,[bp].wParam1         ;BIOS write? 
        and     ax,0ff0fh
        cmp     ax,1B06h                ;BIOS write? 
        pop     ax
;----------------90/11/08 debug -------------------------------------
        jnz     rws_not_read
;       call    DBIOS_DEVICE

rws_buf_read:
        mov     ax,cSectorsThisTransfer         ;calc size of data to move
        mul     cbSectorSize
        mov     cx,ax
        shr     cx,1                            ;in words
;;;;;;;;        les     di,lpSectorData                 ;caller's buffer pointer
;;;;;;;;        assume  es:NOTHING
        push    es
        mov     di,[bp].pmUserBP
        mov     es,[bp].pmUserES
        mov     si,offset DGROUP:rgbXfrBuf1
        cld
        rep movsw
        pop     es
        
        push    ds
        pop     es
        assume  es:DGROUP

        mov     word ptr [bp].pmUserBP,di       ;update dest ptr for next time
;       mov     word ptr lpSectorData,di        ;update dest ptr for next time
;       call    NormalizeBufPtr                 ;  and normailize it

rws_not_read:

        mov     ax,cSectorsThisTransfer         ;count total sectors transfered
        add     cSectorsTransfered,ax           ;add sectors transmitted
                                                ;to previous sectors
;----------- 90/11/09 copy the segment address -------
        push    ax
        mov     ax,[bp].pmUserES        ;90/09/19 BX regster restor
        mov     [bp].intUserES,ax
        mov     ax,[bp].pmUserBP
        mov     [bp].intUserBP,ax
        pop     ax
;------------------------------------------------------------


        jmp     rws_do_it_loop          ;go do another buffer full

rws_done:

        mov     ax,word ptr [lpSectorData+2]    ;release our temp buffer sel
        call    FreeSelector

        jmp     [bp].wParam2
else    ;NEC_98   ;
        pop     [bp].wParam2            ;save return addr higher on stack

; Setup the global data items for the read/write--pointer to caller's
; buffer, # sectors to read/write, and sector size.

        cmp     byte ptr [bp].wParam1+1,13h     ;Int 13h?
        jnz     rws_dos_size

        mov     ax,[bp].pmUserBX                ;ES:BX points to caller's buf
        mov     word ptr lpSectorData,ax
        mov     ax,[bp].pmUserES
        mov     word ptr [lpSectorData+2],ax

        mov     al,byte ptr [bp].intUserAX      ;# sectors caller wants to
        xor     ah,ah                           ;  read or write
        mov     cSectorsToTransfer,ax

        mov     ah,08h                  ;get drive parameters
        mov     dx,[bp].intUserDX       ;  for drive in DL

        push    ax
        SwitchToRealMode
        pop     ax

        pushf                           ;have BIOS get the drive data
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     [bp + 6],word ptr (offset rws_10)
        mov     ax,es:[13h*4]
        mov     [bp + 2],ax
        mov     ax,es:[13h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf
rws_10: jnc     @f

        mov     cx,512                  ;according to PS/2 tech ref, some
        jmp     short rws_to_pm         ;  old bios versions may fail this,
@@:                                     ;  just use 512 in that case

        mov     cl,es:[di+3]            ;sector size shift factor (0,1,2,3)
        mov     ax,128
        shl     ax,cl                   ;ax now = sector size
        mov     cx,ax

rws_to_pm:
        SwitchToProtectedMode

        FSTI                             ;don't need them disabled

if DEBUG   ;------------------------------------------------------------

        cmp     cx,512
        jz      @f
        Debug_Out "Odd sector size = #CX"
@@:

endif   ;DEBUG  --------------------------------------------------------

        jmp     short rws_have_size

; Before DOS 4.0, CX was the # sectors to read/write.  Starting with 4.0,
; if CX == -1, DS:BX points to a parameter block which contains the
; sector size at offset 4.

rws_dos_size:

        mov     cx,[bp].intUserCX       ;caller's cs == -1?
        inc     cx
        jcxz    rws_dos_4
        dec     cx                      ;  no, then cx has sector count

        mov     ax,[bp].pmUserBX        ;    and DS:BX points to buffer
        mov     word ptr lpSectorData,ax
        mov     ax,[bp].pmUserDS
        mov     word ptr [lpSectorData+2],ax

        jmp     short rws_dos_num_secs

rws_dos_4:

        mov     cx,word ptr rgbXfrBuf0+4 ; yes, get count from low param block

        push    ds                       ;   and DS:BX points to param block
        mov     ds,[bp].pmUserDS         ;     which contains pointer to buffer
        assume  ds:NOTHING
        mov     bx,[bp].pmUserBX
        mov     ax,word ptr ds:[bx+6]
        mov     word ptr lpSectorData,ax
        mov     ax,word ptr ds:[bx+8]
        mov     word ptr [lpSectorData+2],ax
        pop     ds
        assume  DS:DGROUP

rws_dos_num_secs:
        mov     cSectorsToTransfer,cx   ;number sectors to read/write

        mov     cx,512          ;I've been assured by a WINFILE developer
                                ;  that the Int 25/26 sector size will always
                                ;  be 512 bytes.

; CX now has the drive's sector size.  Determine how many sectors we can
; transfer at a time

rws_have_size:

        mov     cbSectorSize,cx         ;save sector size for later

        xor     dx,dx
        mov     ax,CB_XFRBUF1           ;buf size / sector size = sectors per
        div     cx                      ;  transfer

if DEBUG   ;------------------------------------------------------------
        or      ax,ax
        jnz     @f
        Debug_Out "Sectors per transfer = 0!"
@@:
endif   ;DEBUG  --------------------------------------------------------

        mov     cSectorsPerTransfer,ax

        xor     ax,ax
        mov     cSectorsTransfered,ax   ;sectors transfered so far = 0
        mov     cSectorsThisTransfer,ax ;sectors transfered last time = 0

; Get/init a selector that we'll use to reference the caller's buffer.

        mov     ax,word ptr [lpSectorData+2]    ;get lma of caller's buffer
        call    GetSegmentAddress
        add     dx,word ptr lpSectorData
        adc     bx,0

        call    AllocateSelector                ;build a sel/dscr pointing
        mov     cx,0FFFFh
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>
        xor     bx,bx
        mov     word ptr lpSectorData,bx        ;use that as the buffer ptr
        mov     word ptr [lpSectorData+2],ax


; ======================================================================
; Main sector read/write loop ------------------------------------------
; ======================================================================

rws_do_it_loop:

; Calculate how many sectors to transfer this time around, set starting
; sector number based on how many transfered last time.

        mov     ax,cSectorsToTransfer
        sub     ax,cSectorsTransfered
        jnz     @f
        jmp     rws_done
@@:
        cmp     ax,cSectorsPerTransfer
        jna     @f
        mov     ax,cSectorsPerTransfer
@@:
        mov     bx,cSectorsThisTransfer         ;STIll # R/W from last loop

        cmp     byte ptr [bp].wParam1+1,13h     ;BIOS read/write?
        jnz     rws_use_dos_size

        push    [bp].pmUserAX                   ;the BIOS does not save
        pop     [bp].intUserAX                  ;  registers across calls to
        push    [bp].pmUserCX                   ;  it so if we're doing
        pop     [bp].intUserCX                  ;  multiple calls to buffer
        push    [bp].pmUserDX                   ;  data, restore the initial
        pop     [bp].intUserDX                  ;  register values

        mov     byte ptr [bp].intUserAX,al      ;# sectors in AL

        add     byte ptr [bp].intUserCX,bl      ;update new start sector in CL

        jmp     short rws_size_start_set

rws_use_dos_size:

        cmp     [bp].intUserCX,0FFFFh           ;normal or extended DOS?
        jz      rws_dos4_size
        mov     [bp].intUserCX,ax               ; normal, # sectors in CX

        add     [bp].intUserDX,bx               ; new start sector in DX

        jmp     short rws_size_start_set

rws_dos4_size:

        mov     word ptr rgbXfrBuf0+4,ax        ; extended, # sectors & 32 bit
        add     word ptr rgbXfrBuf0,bx          ;   start sector in parameter
        adc     word ptr rgbXfrBuf0+2,0         ;   block

rws_size_start_set:

; At this point, AX has the number of sectors to transfer.  If this is a
; write, copy a buffer of data from the caller's buffer.

        mov     cSectorsThisTransfer,ax         ;in case it's a read

        cmp     [bp].wParam1,1303h              ;BIOS write?
        jz      rws_buf_write
        cmp     byte ptr [bp].wParam1+1,26h     ;DOS write?
        jnz     rws_not_write

rws_buf_write:

        mul     cbSectorSize            ;AX now = # bytes to transfer
        mov     cx,ax                   ;can safely assume < 64k
        shr     cx,1                    ;# words to move
        lds     si,lpSectorData
        assume  ds:NOTHING
        mov     di,offset rgbXfrBuf1
        cld
        rep movsw

        push    es
        pop     ds
        assume  ds:DGROUP

        mov     word ptr lpSectorData,si        ;update src ptr for next time
        call    NormalizeBufPtr                 ;  and normalize it

rws_not_write:


; Switch to real mode, do the transfer.

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP

        push    word ptr [bp].lParam
        pop     word ptr lpRmISR
        push    word ptr [bp].lParam+2
        pop     word ptr lpRmISR+2

        cmp     byte ptr [bp].wParam1+1,13h
        jnz     rws_call_dos

        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        call    lpRmISR
        pushf
        FCLI
        jmp     short rws_save_regs

rws_call_dos:
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        call    lpRmISR
        pop     word ptr lpRmISR        ;int 25/26 leave flags on stack,
        pushf                           ;  pop them to nowhere
        FCLI

rws_save_regs:
        pusha
        push    ds
        push    es
        mov     bp,sp                   ;restore stack frame pointer

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        FSTI                             ;allow HW interrupts

; If the call failed, then cut out now without further processing...

        test    byte ptr [bp].intUserFL,1       ;CY set?
        jnz     rws_done

; If this was a successful read, copy the data back to the caller.

        cmp     [bp].wParam1,1302h              ;BIOS read?
        jz      rws_buf_read
        cmp     byte ptr [bp].wParam1+1,25h     ;DOS read?
        jnz     rws_not_read

rws_buf_read:
        mov     ax,cSectorsThisTransfer         ;calc size of data to move
        mul     cbSectorSize
        mov     cx,ax
        shr     cx,1                            ;in words
        les     di,lpSectorData                 ;caller's buffer pointer
        assume  es:NOTHING
        mov     si,offset rgbXfrBuf1
        cld
        rep movsw

        push    ds
        pop     es
        assume  es:DGROUP

        mov     word ptr lpSectorData,di        ;update dest ptr for next time
        call    NormalizeBufPtr                 ;  and normailize it

rws_not_read:

        mov     ax,cSectorsThisTransfer         ;count total sectors transfered
        add     cSectorsTransfered,ax

        jmp     rws_do_it_loop          ;go do another buffer full

rws_done:

        mov     ax,word ptr [lpSectorData+2]    ;release our temp buffer sel
        call    FreeSelector

        jmp     [bp].wParam2
endif   ;NEC_98   ;

ReadWriteSectors  endp


ifdef      NEC_98    ;
; -------------------------------------------------------
        subttl  Disk Utility Routines
        page
; -------------------------------------------------------
;               DISK UTILITY ROUTINES
; -------------------------------------------------------
;  DOSReadWriteSectors -- Common code to read/write disk sectors for
;       Int 13h/25h/26h.
;
;       In:     lParam  - seg:off of real mode interrupt handler
;               wParam1 - int #, and possible subfunction
;               regs on stack


        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  DOSReadWriteSectors

DOSReadWriteSectors  proc       near

;       int     3                       ;------ 90/11/08 debug ------

;       pop     [bp].wParam3            ;save return addr higher on stack

; Setup the global data items for the read/write--pointer to caller's
; buffer, # sectors to read/write, and sector size.


; Before DOS 4.0, CX was the # sectors to read/write.  Starting with 4.0,
; if CX == -1, DS:BX points to a parameter block which contains the
; sector size at offset 4.

rws_dos_size:

        mov     cx,[bp].intUserCX       ;caller's cs == -1?
        inc     cx
        jcxz    rws_dos_4
        dec     cx                      ;  no, then cx has sector count

        mov     ax,[bp].pmUserBX        ;    and DS:BX points to buffer 
        mov     word ptr lpSectorData,ax
        mov     ax,[bp].pmUserDS
        mov     word ptr [lpSectorData+2],ax

        jmp     short rws_dos_num_secs

rws_dos_4:

        mov     cx,word ptr rgbXfrBuf0+4 ; yes, get count from low param block

        push    ds                       ;   and DS:BX points to param block
        mov     ds,[bp].pmUserDS         ;     which contains pointer to buffer
        assume  ds:NOTHING
        mov     bx,[bp].pmUserBX
        mov     ax,word ptr ds:[bx+6]
        mov     word ptr lpSectorData,ax
        mov     ax,word ptr ds:[bx+8]
        mov     word ptr [lpSectorData+2],ax
        pop     ds
        assume  DS:DGROUP

rws_dos_num_secs:
        mov     cSectorsToTransfer,cx   ;number sectors to read/write

;
; We will need the sector size if we have to break up the transfer.
;
if 0
        push    ds
        push    bx
        mov     dl,byte ptr [bp].pmUserAX
        inc     dl
        mov     ah,1ch
        assume  DS:NOTHING
        int     21h
        pop     bx
        pop     ds
        assume  DS:DGROUP
        cmp     al,0ffh
        jne     rws_have_size
;
; Call to DOS to get drive data failed, probably due to invalid
; drive number.  Assume 512, let INT 25h/26h return the failure.
;
rws_use_default:
@@    mov     cx,512

else
        push    bx
        mov     bl, byte ptr [bp].pmUserAX
        inc     bl
        call    GetSectorSize
        pop     bx
endif

; CX now has the drive's sector size.  Determine how many sectors we can
; transfer at a time

DOS_rws_have_size:

        mov     cbSectorSize,cx         ;save sector size for later

        xor     dx,dx
        mov     ax,CB_XFRBUF1           ;buf size / sector size = sectors per
        div     cx                      ;  transfer

if DEBUG   ;------------------------------------------------------------
        or      ax,ax
        jnz     @f
        Debug_Out "Sectors per transfer = 0!"
@@:
endif   ;DEBUG  --------------------------------------------------------

        mov     cSectorsPerTransfer,ax

        xor     ax,ax
        mov     cSectorsTransfered,ax   ;sectors transfered so far = 0
        mov     cSectorsThisTransfer,ax ;sectors transfered last time = 0

; Get/init a selector that we'll use to reference the caller's buffer.

        mov     ax,word ptr [lpSectorData+2]    ;get lma of caller's buffer
        call    GetSegmentAddress
        add     dx,word ptr lpSectorData
        adc     bx,0

        call    AllocateSelector                ;build a sel/dscr pointing
        mov     cx,0FFFFh
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>
        xor     bx,bx
        mov     word ptr lpSectorData,bx        ;use that as the buffer ptr
        mov     word ptr [lpSectorData+2],ax


; ======================================================================
; Main sector read/write loop ------------------------------------------
; ======================================================================

DOS_rws_do_it_loop:

; Calculate how many sectors to transfer this time around, set starting
; sector number based on how many transfered last time.

;       int     3                       ;------ 90/11/08 debug ------

        mov     ax,cSectorsToTransfer                   ;totak sectors
        sub     ax,cSectorsTransfered                   ;total sectors - sectors transmitted = remaine sectors
        jnz     @f
        jmp     DOS_rws_done
@@:
        cmp     ax,cSectorsPerTransfer                  ;buffer size / sector len = sectors in buffer
        jna     @f                                      ;sectors in buffer > remain = remain
        mov     ax,cSectorsPerTransfer                  ;sectors in buf < remain = sectors in buffer
@@:
        mov     bx,cSectorsThisTransfer         ;still # R/W from last loop

rws_use_dos_size:

        cmp     [bp].intUserCX,0FFFFh           ;normal or extended DOS?
        jz      rws_dos4_size
        mov     [bp].intUserCX,ax               ; normal, # sectors in CX

        add     [bp].intUserDX,bx               ; new start sector in DX

        jmp     short DOS_rws_size_start_set

rws_dos4_size:

        mov     word ptr rgbXfrBuf0+4,ax        ; extended, # sectors & 32 bit
        add     word ptr rgbXfrBuf0,bx          ;   start sector in parameter
        adc     word ptr rgbXfrBuf0+2,0         ;   block

DOS_rws_size_start_set:

; At this point, AX has the number of sectors to transfer.  If this is a
; write, copy a buffer of data from the caller's buffer.

        mov     cSectorsThisTransfer,ax         ;in case it's a read
        ;cSectorsThisTransfer = sectors in buffer or remain sectors 


;----------------- 90/07/24 -----------------------------------------
        cmp     byte ptr [bp].wParam1+1,26h     ;DOS write?
        jz      DOS_rws_buf_write
        jmp     DOS_rws_not_write

DOS_rws_buf_write:

        mul     cbSectorSize            ;AX now = # bytes to transfer
        mov     cx,ax                   ;can safely assume < 64k
        shr     cx,1                    ;# words to move
        lds     si,lpSectorData
        assume  ds:NOTHING
        mov     di,offset rgbXfrBuf1
        cld
        rep movsw

        push    es
        pop     ds
        assume  ds:DGROUP

        mov     word ptr lpSectorData,si        ;update src ptr for next time
        call    NormalizeBufPtr                 ;  and normalize it

DOS_rws_not_write:


; Switch to real mode, do the transfer.

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP

        push    word ptr [bp].lParam
        pop     word ptr lpRmISR
        push    word ptr [bp].lParam+2
        pop     word ptr lpRmISR+2

rws_call_dos:
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        pusha                           ; This trashes all registers
        call    lpRmISR
        mov     bp,sp
        jnc     @F                      ; If carry, AX = error code
        mov     [bp+14],ax
@@:
        popa
        pop     word ptr lpRmISR        ; int 25/26 leave flags on stack,
                                        ;  pop them to nowhere
        pushf
        FCLI

DOS_rws_save_regs:

;       int     3

        pusha
        push    ds
        push    es
        mov     bp,sp                   ;restore stack frame pointer

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        FSTI                             ;allow HW interrupts

; If the call failed, then cut out now without further processing...

        test    byte ptr [bp].intUserFL,1       ;CY set?
        jnz     DOS_rws_done

; If this was a successful read, copy the data back to the caller.

;----------------- 90/07/23 -----------------------------------------
        cmp     byte ptr [bp].wParam1+1,25h     ;DOS read?
        jz      DOS_rws_buf_read
        jmp     DOS_rws_not_read

DOS_rws_buf_read:
        mov     ax,cSectorsThisTransfer         ;calc size of data to move
        mul     cbSectorSize
        mov     cx,ax
        shr     cx,1                            ;in words
        les     di,lpSectorData                 ;caller's buffer pointer
        assume  es:NOTHING
        mov     si,offset rgbXfrBuf1
        cld
        rep movsw

        push    ds
        pop     es
        assume  es:DGROUP

        mov     word ptr lpSectorData,di        ;update dest ptr for next time
        call    NormalizeBufPtr                 ;  and normailize it

DOS_rws_not_read:

        mov     ax,cSectorsThisTransfer         ;count total sectors transfered
        add     cSectorsTransfered,ax           ;add sectors transmitted
                                                ;to previous sectors

        jmp     DOS_rws_do_it_loop              ;go do another buffer full

DOS_rws_done:

        mov     ax,word ptr [lpSectorData+2]    ;release our temp buffer sel
        call    FreeSelector

        jmp     [bp].wParam2

DOSReadWriteSectors  endp
endif   ;NEC_98   ;

; -------------------------------------------------------


; This routine 'normalizes' the far pointer in lpSectorData such that
; the selector/descriptor points to where the selector:offset currently
; points

        assume  ds:DGROUP,es:NOTHING

NormalizeBufPtr proc    near

        mov     ax,word ptr [lpSectorData+2]    ;get segment base address
        call    GetSegmentAddress
        add     dx,word ptr lpSectorData        ;add in current offset
        adc     bx,0
        call    SetSegmentAddress               ;make that the new seg base
        xor     bx,bx
        mov     word ptr lpSectorData,bx        ;  with a zero offset

        ret

NormalizeBufPtr endp

ifdef      NEC_98    ;
public GetSectorSize
GetSectorSize   proc    near

    push    ax
    push    bx
    push    dx
    push    ds
    sub     sp, 40h
    mov     dx, sp
    push    ss
    pop     ds
    mov     ax, 440Dh
    mov     cx, 0860h
    int     21h
ifdef      NEC_98
    mov     cx, 1024                 ; if 440D doesn't work, 512 bytes!
else  ;NEC_98
    mov     cx, 512                  ; if 440D doesn't work, 512 bytes!
endif ;NEC_98
    jc            @F
    mov     bx, dx
    mov     cx, word ptr ds:[bx+7]   ; bytes per sector first field
@@: add     sp, 40h
    pop     ds                       ; in BPB at offset 7.
    pop     dx
    pop     bx
    pop     ax
    ret

GetSectorSize        endp

;-------------------------- DBIOS_DEVICE --------------------------------
;       for difference of cylinders, heads, sectors between all devices
;       if reached at each max value, we change the cylinders, heads
;       to have a READ/WRITE process
;------------------------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  DBIOS_DEVICE

DBIOS_DEVICE    proc    near

        mov     ax,[bp].intUserDX       ;DH = head numCDL = sector num
        cmp     byte ptr sensedata4,al  ;maximum sector num ?
        jnz     DBIOS_RET               ;NO = JMP
        cmp     byte ptr sensedata3,ah  ;maximum head num ?
        jnz     HEADINC                 ;NO = JMP
        mov     [bp].intUserDX,0        ;DH = head numCDL = sector num 0
        mov     ax,[bp].intUserCX       ;set the next cylinder
        add     al,1                    ;
        mov     [bp].intUserCX,ax       ;
DBIOS_RET:
        ret                             ;
        
HEADINC:
        add     ah,1                    ;increase head num
        mov     al,0                    ;sector num 0
        mov     [bp].intUserDX,ax       ;set
        ret
        
DBIOS_DEVICE    endp
endif   ;NEC_98   ;
DXPMCODE    ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxdma.asm ===
PAGE    ,132
        TITLE   DXDMA.ASM  -- Dos Extender DMA Services

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXDMA.ASM       -- Dos Extender DMA Services
;
;-----------------------------------------------------------------------
;
; This module provides the protect mode DMA services for the 286 DOS
; Extender.  It supports a subset of the services documented in
; "DMA Services for DOS Virtual 8086 and Protected Mode Environments"
; by Microsoft Corporation.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Minor changes to reflect updates in DMA Service Spec.
;  11/01/89 jimmat  Started.
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
include     pmdefs.inc
include     interupt.inc
if VCPI
include     dxvcpi.inc
endif
        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

PhysicalPageSize equ    4096            ;size of 80386 physical page
PageShift        equ    12

DMAServiceByte  equ     7Bh

ChainReserved   equ     08h             ;set if unsupported services chained

DMAServiceID    equ     81h             ;Int 4Bh/AH=81h are the DMA services
FirstValidSvc   equ     02h             ;First valid DMA service #
LastValidSvc    equ     0Ch             ;Last  valid DMA service #

; Get Version information

MajorVersion    equ     01h             ;Major specification version
MinorVersion    equ     00h             ;Minor specification version

DOSXProductNumber equ   02h             ;286 DOS Extender product number
DOSXProductRevision equ 01h             ;286 DOS Extender revision number

MemoryContiguous equ    08h             ;All memory physically contigious flag
AutoRemapSupported equ  04h             ;Automatic remap supported

; DX flags on calls to DMA services

AutoBufferCopy  equ     02h             ;set if data to be copied into DMA buf
NoAutoBufferAlloc equ   04h             ;set if NO automatic buff allocation
NoAutoRemap     equ     08h             ;set if NO automatic remap attempted
Align64k        equ     10h             ;set if region can't cross 64k boundry
Align128k       equ     20h             ;set if region can't cross 128k boundry
PageTableFmt    equ     40h             ;set for page table Scatter/Gather lock

ValidDXFlags    equ     007Eh           ;valid DX register flag bits (above)

; Error return codes

ErrRegionCrossedBoundry equ     02h
ErrNoBufferAvail        equ     04h
ErrTooManyRegions       equ     09h
ErrInvalidBufferID      equ     0Ah
ErrFuncNotSupported     equ     0Fh
ErrReservedFlagBits     equ     10h

; DMA Descriptor Structure(s)

DDS     STRUC                           ;normal DDS
DDS_RegionSize  dd      ?
DDS_Offset      dd      ?
DDS_Selector    dw      ?
DDS_BufferID    dw      ?
DDS_PhyAddress  dd      ?
DDS     ENDS

SGDDS1  STRUC                           ;Extended DDS for Scatter/Gather
                dd      3 dup (?)       ;  Region format
DDS_NumAvail    dw      ?
DDS_NumUsed     dw      ?
DDS_Region0Addr dd      ?
DDS_Region0Size dd      ?
SGDDS1  ENDS

SGDDS2  STRUC                           ;Extended DDS for Scatter/Gather
                dd      4 dup (?)       ;  Page Table format
DDS_PageTblEnt0 dd      ?
SGDDS2  ENDS


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   EnterIntHandler:NEAR
        extrn   LeaveIntHandler:NEAR
        extrn   GetSegmentAddress:NEAR
        extrn   PMIntrEntryVector:NEAR


; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment
ifdef      NEC_98   
        extrn   fPCH98:BYTE
else    ;!NEC_98  
ifdef NOT_NTVDM_NOT
        extrn   fMicroChannel:BYTE
endif
endif   ;!NEC_98

if VCPI
	extrn	fVCPI:BYTE
endif
;
; Contains a copy of bit 5 of the byte at 40:7b, that indicates
; whether VDS should be used.
;
	public	bDMAServiceBit
bDMAServiceBit	db	0

DXDATA	ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

DXCODE  ends

DXPMCODE segment

        extrn   selDgroupPM:WORD

DMASvcTbl label   word

        dw      offset DXPMCODE:GetVersion
        dw      offset DXPMCODE:LockDMARegion
        dw      offset DXPMCODE:DoNothing               ;UnlockDMARegion
        dw      offset DXPMCODE:ScatterGatherLock
        dw      offset DXPMCODE:DoNothing               ;ScatterGatherUnlock
        dw      offset DXPMCODE:Fail4NoBuffer           ;RequestDMABuffer
        dw      offset DXPMCODE:DoNothing               ;ReleaseDMABuffer
        dw      offset DXPMCODE:Fail4BufferID           ;CopyIntoDMABuffer
        dw      offset DXPMCODE:Fail4BufferID           ;CopyOutOfDMABuffer
        dw      offset DXPMCODE:DoNothing               ;DisableDMATranslation
        dw      offset DXPMCODE:DoNothing               ;EnableDMATranalation

DXPMCODE ends

; -------------------------------------------------------
        subttl  DMA Service Dispatcher
        page
; -------------------------------------------------------
;                 DMA SERVICE DISPATCHER
; -------------------------------------------------------

DXPMCODE segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntr4B -- Entry routine/dispatcher for protected mode DMA
;       services.  The DMA services are invoked with an Int 4Bh
;       interrupt.  The 286 DOS Extender only supports the DMA
;       services in protected mode.  Other systems that use Virtual
;       8086 mode on 386 processors will most likely need to support
;       the services in virtual mode also.
;
;       The following services are supported (Int 4Bh/AH = 81h):
;
;               AL = 00 Reserved
;                    01 Reserved
;                    02 Get Version
;                    03 Lock DMA Region
;                    04 Unlock DMA Region
;                    05 Scatter/Gather Lock Region
;                    06 Scatter/Gather Unlock Region
;                    07 Request DMA Buffer
;                    08 Release DMA Buffer
;                    09 Copy Into DMA Buffer
;                    0A Copy Out Of DMA Buffer
;                    0B Disable DMA Translation
;                    0C Enable DMA Translation
;                    0D Reserved
;                    ...
;                    FF Reserved

        public  PMIntr4B
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

PMIntr4B        proc    near

; Is this one of the supported DMA services?

        cmp     ah,DMAServiceID         ;is this a DMA service request?
        jz      @f
        jmp     short i4b_other_service ;  no, see if it should be chained
@@:
        call    EnterIntHandler         ;saves regs, switches stacks, etc.
        assume  ds:DGROUP               ;sets DS/ES = DGROUP
        mov     es,[bp].pmUserES        ;  but we want caller's ES

        cld                             ;cya...

        cmp     al,FirstValidSvc
        jb      i4b_reserved

        cmp     al,LastValidSvc
        ja      i4b_reserved

        test    dx,NOT ValidDXFlags     ;any reserved flags set?
        jnz     i4b_bad_flags

; -------------------------------------------------------

; Setup local environment and dispatch the service

i4b_valid_svc:

        push    offset DXPMCODE:i4b_svc_ret     ;save dispatch return address

        sub     al,FirstValidSvc        ;get address of service routine
        cbw
        shl     ax,1
        add     ax,offset DXPMCODE:DMASvcTbl

        xchg    ax,bx
        mov     bx,cs:[bx]
        xchg    ax,bx

        push    ax                      ;save routine address on stack
        mov     ax,[bp].pmUserAX        ;restore entry AX

        ret                             ;invoke service routine

i4b_svc_ret:                            ;service routines return here

        jnc     i4b_good_return         ;CY set if service failed

i4b_error_return:

        or      byte ptr [bp].intUserFL,1       ;set CY in caller's flags
        jmp     short i4b_exit

i4b_good_return:

        and     byte ptr [bp].intUserFL,not 1   ;clear CY in caller's flags

i4b_exit:

        call    LeaveIntHandler         ;resotre stack, regs, etc.
        iret

; -------------------------------------------------------

; Reserved DMA service 00, 01, 0D-FF;  return with CY set and
; AL = ErrFuncNotSupported

i4b_reserved:

        mov     byte ptr [bp].intUserAX,ErrFuncNotSupported
        jmp     short i4b_error_return

; -------------------------------------------------------

; User made a DMA service call with a reserved flag bit set.  Fail the
; call with AL = ErrReservedFlagBits

i4b_bad_flags:

        mov     byte ptr [bp].intUserAX,ErrReservedFlagBits
        jmp     short i4b_error_return

; -------------------------------------------------------

; This is a non-DMA Int 4B call.  On Micro Channel systems, bit 3
; in location 40:007B indicates if we should chain the call along
; or not.  If the bit is set, we chain.  If not Micro Channel, or the
; bit is not set, we check the real mode Int 4Bh vector to see if someone
; other than the BIOS has it hooked--if so, we chain anyway.  If not,
; return without changing any regs or flags.

i4b_other_service:

        push    ds

        mov     ds,selDgroupPM
        assume  ds:DGROUP

ifdef NOT_NTVDM_NOT
ifdef      NEC_98
        test    fPCH98,0FFh
else   ;!NEC_98
        test    fMicroChannel,0FFh              ;if micro channel system
endif  ;!NEC_98
        jz      i4b_check_vector                ;  and 40:7B bit 3 set,
                                                ;  chain the call to real mode
        push    SEL_BIOSDATA or STD_RING
        pop     ds
        assume  ds:NOTHING

        test    byte ptr ds:DMAServiceByte,ChainReserved
        jnz     i4b_chain
endif

i4b_check_vector:                       ;not micro channel, or bit 3 not set

        push    ax                              ;check if the real mode Int 4Bh
        mov     ax,SEL_RMIVT or STD_RING        ;  points somewhere and not
        mov     ds,ax                           ;  at the BIOS--if so, chain
        mov     ax,word ptr ds:[4Bh*4]          ;  anyway.
        or      ax,word ptr ds:[4Bh*4+2]
        pop     ax
        jz      i4b_dont_chain

        cmp     word ptr ds:[4bh*4+2],0E000h
        jz      i4b_dont_chain

        cmp     word ptr ds:[4bh*4+2],0F000h
        jz      i4b_dont_chain

i4b_chain:

        pop     ds                              ;chain the request to real mode
        jmp     PMIntrEntryVector + 5*4Bh       ;  (no one can have pMode
                                                ;   hooked before us)

i4b_dont_chain:                         ;don't chain the interrupt,
                                        ;  just return quietly
        pop     ds
        iret

PMIntr4B        endp

; -------------------------------------------------------
        subttl  DMA Service Routines
        page
; -------------------------------------------------------
;                 DMA SERVICE ROUTINES
; -------------------------------------------------------


; -------------------------------------------------------
;   RM4B  -- Call the real mode INT 4Bh handler to
;       perform a DMA service, most likely something to
;       do with the VCPI provider's buffer when we are
;       running under VCPI.
;
;   Input:      depends on call
;   Output:     Flags, registers from real mode call
;
;   Notes:      This is strictly an internal DOSX call,
;               so if a long pointer is used, then it
;               is assumed to point into DOSX's data
;               segment.
;
cProc RM4B,<NEAR,PUBLIC>
cBegin
        pushf
        push    cs
        call  near ptr PMIntrEntryVector + 3*4Bh
cEnd

; -------------------------------------------------------
;   DoNothing  -- This routine does nothing other than return
;       indicating that the DMA service succeeded.
;
;   Input:      none
;   Output:     AL = 0, CY clear

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

DoNothing       proc    near

        clc             ;indicate success
        ret

DoNothing       endp


; -------------------------------------------------------
;   Fail4BufferID  -- This routine does nothing other than return
;       indicating that the DMA service failed with 'Invalid Buffer ID'
;
;   Input:      none
;   Output:     AL = 0Ah, CY set

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

Fail4BufferID   proc    near

        mov     byte ptr [bp].intUserAX,ErrInvalidBufferID
        stc
        ret

Fail4BufferID   endp


; -------------------------------------------------------
;   Fail4NoBuffer  -- This routine does nothing other than return
;       indicating that the DMA service failed with 'No Buffer Available'
;
;   Input:      none
;   Output:     AL = 04h, CY set

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

Fail4NoBuffer   proc    near

        mov     byte ptr [bp].intUserAX,ErrNoBufferAvail
        stc
        ret

Fail4NoBuffer   endp


; -------------------------------------------------------
;   GetVersion -- This routine processes the DMA Get Version
;       service (AL = 02).
;
;   Input:      none
;   Output:     AH/AL - Major/Minor specification level
;               BX    - Product number
;               CX    - Product revision number
;               DX    - flags
;               SI:DI - 32 bit max buffer size available

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

GetVersion      proc    near

        mov     [bp].intUserAX,(MajorVersion shl 8) or MinorVersion
        mov     [bp].intUserBX,DOSXProductNumber
        mov     [bp].intUserCX,DOSXProductRevision
        mov     [bp].intUserDX,MemoryContiguous


        xor     ax,ax                   ;0 buffer size supported, also clears
        mov     [bp].intUserSI,ax       ;  carry flag
        mov     [bp].intUserDI,ax

if VCPI
        cmp     fVCPI,0
        je      gv_x
	mov	ax,8102h
	xor	dx,dx			;DX = 0
	cmp	bDMAServiceBit,0	;VCPI provider supports VDS?
	je	gv_e
        call    RM4B
        jc      gv_x
        mov     [bp].intUserSI,si
        mov     [bp].intUserDI,di
	and	dx,NOT (AutoRemapSupported or MemoryContiguous)
gv_e:
        mov     [bp].intUserDX,dx
gv_x:
endif
        ret

GetVersion      endp


; -------------------------------------------------------
;   LockDMARegion -- This routine processes the Lock DMA Region
;       service (AL = 03).
;
;   Input:      DX    - flags
;               ES:DI - ptr to DDS
;   Output:     if successful, CY clear;  else CY set and AL = error code
;               DDS updated

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

LockDMARegion   proc    near

; Since we don't support paging or anything interesting like that, the only
; thing that can fail us is an alignment problem--check for that.

        test    dl,Align64k or Align128k        ;if they don't care,
        jz      lock_ok                         ;  we don't care

        mov     si,dx                   ;save flags in SI

        call    CalcDDSPhyAddress       ;see where the region is

        push    dx                      ;save start address
        push    ax

        mov     bx,dx                   ;bx = hi word start addr

        add     ax,word ptr es:[di].DDS_RegionSize      ;see where it ends
        adc     dx,word ptr es:[di].DDS_RegionSize+2

        sub     ax,1                    ;less 1 to point at
        sbb     dx,0                    ;  last byte, not next

        mov     cx,dx                   ;cx = hi word end addr

        test    si,Align128k            ;64k or 128k alignment wanted?
        jz      @f                      ;  already setup for 64k
        and     bl,not 1                ;mask to 128k alignment
        and     cl,not 1
@@:
        cmp     bx,cx                   ;within the boundry?
        jz      lock_ok_clr_stk         ;  yes, 'lock' it

; The region crosses an alignment boundary, we need to update the allowed
; region size in the DDS, and fail the call.

        pop     cx
        pop     dx                      ;dx:cx = region start address

        neg     cx                      ;cx = len to next 64k boundry
        xor     bx,bx
        test    si,Align128k
        jz      @f
        mov     bl,dl
        and     bl,1
        xor     bl,1                    ;bx:cx = len to next alignment boundry
@@:
        mov     word ptr es:[di].DDS_RegionSize,cx      ;update size in DDS
        mov     word ptr es:[di].DDS_RegionSize+2,bx

        mov     byte ptr [bp].intUserAX,ErrRegionCrossedBoundry ;flag failure
        stc
        ret


lock_ok_clr_stk:

        add     sp,4                    ;clear start address from stack

; No alignment problem, we can 'lock' the region.

lock_ok:

        call    CalcDDSPhyAddress       ;get physical address of region DX:AX
        mov     word ptr es:[di].DDS_PhyAddress,ax
        mov     word ptr es:[di].DDS_PhyAddress+2,dx

        xor     ax,ax                       ;*** also clears CY! ***
        mov     es:[di].DDS_BufferID,ax     ;no buffer used

        ret

LockDMARegion   endp


; -------------------------------------------------------
;   ScatterGatterLock -- This routine implements the Scatter/Gather
;       Lock Region DMA service (AL = 05h).
;
;   Input:      DX    - flags
;               ES:DI - ptr to extended DDS
;   Output:     if successful, CY clear;  else CY set & AL = error code
;               DDS updated

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

ScatterGatherLock       proc    near

        test    dl,PageTableFmt         ;Scatter/Gather page table form?
        jnz     do_page_tbl_lock

; This is the region form of Scatter/Gather Lock Region -- for us this
; is easy, since memory is contiguous -- one region covers the entire area.

        mov     ax,1                    ;we need one region entry
        mov     es:[di].DDS_NumUsed,ax

        cmp     es:[di].DDS_NumAvail,ax ;  is it available?
        jb      not_enough_entries

        call    CalcDDSPhyAddress       ;get physical address

        mov     word ptr es:[di].DDS_Region0Addr,ax     ;store in extended DDS
        mov     word ptr es:[di].DDS_Region0Addr+2,dx

        mov     ax,word ptr es:[di].DDS_RegionSize      ;copy over the size
        mov     word ptr es:[di].DDS_Region0Size,ax
        mov     ax,word ptr es:[di].DDS_RegionSize+2
        mov     word ptr es:[di].DDS_Region0Size+2,ax

        clc                             ;indicate success
        ret

; This is the page table form of Scatter/Gather Lock Region -- we need to
; build a fake page table (even though we may be on an 80286!?) to return
; in the extended DDS.

do_page_tbl_lock:

        call    CalcDDSPhyAddress       ;get region start address

        mov     cx,word ptr es:[di].DDS_RegionSize      ;calc # pages needed
        mov     bx,word ptr es:[di].DDS_RegionSize+2    ;  for region of this
        add     cx,PhysicalPageSize-1                   ;  size
        adc     bx,0
        shr     cx,PageShift
        shl     bx,16-PageShift
        or      cx,bx                                   ;cx = # pages

        test    ax,PhysicalPageSize-1   ;if region doesn't start on a page
        jz      @f                      ;  boundry, add another page to
        inc     cx                      ;  the region size
@@:
        mov     es:[di].DDS_NumUsed,cx  ;tell caller how many used/needed
        cmp     es:[di].DDS_NumAvail,cx ;did caller supply enough page entries?
        jb      not_enough_entries      ;  no!

        push    ax                      ;save low word of region start address

        and     ax,NOT PhysicalPageSize-1   ;round down to page boundry
        or      al,1                        ;set page present/locked bit
        mov     bx,di                       ;es:bx -> page table entries

        jcxz    page_ents_done          ;better safe than sorry
@@:
        mov     word ptr es:[bx].DDS_PageTblEnt0,ax     ;build fake page
        mov     word ptr es:[bx].DDS_PageTblEnt0+2,dx   ;  table entries...
        add     ax,PhysicalPageSize
        adc     dx,0
        add     bx,4
        loop    @b

page_ents_done:

        pop     ax                      ;recover low word of start address
        and     ax,PhysicalPageSize-1   ;  and get offset into first page
        mov     [bp].intUserBX,ax       ;  return to caller in BX

        clc                             ;indicate success
        ret

; Fail the request for insufficient # of region/page tbl entries

not_enough_entries:

        mov     byte ptr [bp].intUserAX,ErrTooManyRegions       ;AL = error code

        mov     ax,es:[di].DDS_NumAvail                 ;store max lockable
        mov     dx,ax                                   ;  size (bytes) in
        shl     ax,PageShift                            ;  DDS region size
        shr     dx,16-PageShift
        mov     word ptr es:[di].DDS_RegionSize,ax
        mov     word ptr es:[di].DDS_RegionSize+2,dx

        stc                             ;indicate failure
        ret


ScatterGatherLock       endp


; -------------------------------------------------------
        subttl  DMA Service Utility Routines
        page
; -------------------------------------------------------
;              DMA SERVICE UTILITY ROUTINES
; -------------------------------------------------------

; -------------------------------------------------------
;   CalcDDSPhyAddress -- This routine calculates the physical
;       address of the region specified in a DDS.
;
;   Input:      ES:DI - ptr to DDS
;   Output:     DX:AX - 32 bit physical address
;   Uses:       none.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

CalcDDSPhyAddress       proc    near

        push    bx
        xor     bx,bx
        mov     dx,bx

        mov     ax,es:[di.DDS_Selector]         ;if a selector is given,
        or      ax,ax                           ;  get it's base address
        jz      @f

        call    GetSegmentAddress               ;bx:dx = segment base
@@:
        add     dx,word ptr es:[di.DDS_Offset]          ;add 32 bit offset
        adc     bx,word ptr es:[di.DDS_Offset+2]

        mov     ax,dx                           ;32 bit address to dx:ax
        mov     dx,bx
        pop     bx

        ret

CalcDDSPhyAddress       endp


DXPMCODE ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxbug.asm ===
PAGE    ,132
        TITLE   DXBUG.ASM -- Dos Extender Debug Services

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXBUG.ASM      -   Dos Extender Debug Services          *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains protect mode debug services for the    *
;*  DOS extender.                                               *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  11/17/89 Jimmat     Added TraceBug stuff for debugging on   *
;*                      286 machines.                           *
;*  03/09/89 JimMat     Initial version.                        *
;*                                                              *
;****************************************************************

.286p
.287

ifndef DEBUG
DEBUG   =       0
endif


; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

include     segdefs.inc
include     gendefs.inc
include     pmdefs.inc

if DEBUG   ;********** ENTIRE FILE IS DEBUG CODE ***********


; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   fDebug:BYTE
        extrn   fTraceBug:WORD


;******************************************************************************
;
;   DXOutputDebugStr
;
;   Basically stolen from Windows/386 code by Ralph Lipe -- hacked up for
;   286 instead of 386.  Here in RalphL's own words is the description:
;
;   DESCRIPTION:
;       The following code is not pretty but it does what it needs to.  It will
;       only be included in DEBUG versions of Win386.  It accepts an ASCIIZ
;       string which it will output to the COM1 serial port.  If the string
;       contains #(Register) (for example #AX) then the value of that register
;       will be output.  It will not work for segment registers.
;
;       If the string contains ?(Register)[:(Register)] (for example ?AX or
;       ?AX:BX) then the value of the register(s) is passed to the debugger
;       to display the label nearest to the given address.  (It, also, will
;       not work with segment registers.  If ?AX is given, then the segment is
;       assumed to be the DX code segment.
;
;   ENTRY:
;       DS:SI -> ASCIIZ string
;
;   EXIT:
;       All registers and flags trashed
;
;   ASSUMES:
;       This procedure was called by the Trace_Out macro.  It assumes that
;       the stack is a pushad followed by a FAR call to this procedure.
;
;------------------------------------------------------------------------------

Reg_Offset_Table LABEL WORD                     ; Order of PUSHA
        dw      "DI"
        dw      "SI"
        dw      "BP"
        dw      "SP"
        dw      "BX"
        dw      "DX"
        dw      "CX"
        dw      "AX"

DXDATA  ends

DXCODE segment
        assume  cs:DXCODE

        public  DXOutDebugStr

DXOutDebugStr   proc    far

        push    bp
        mov     bp, sp                      ; Assumes BP+6 = Pusha
        pushf
        push    es

        push    SEL_DXDATA                  ; Address our own data seg
        pop     es
        assume  ds:NOTHING,es:DGROUP

        cld
        cli

OSC1_Loop:
        lodsb                               ; Get the next character
        test    al, al                      ; Q: End of string?
        jz      short OSC1_Done             ;    Y: Return
        cmp     al, "#"                     ;    N: Q: Special register out?
        je      SHORT OSC1_Hex              ;          Y: Find out which one
        cmp     al, "?"                     ;       Q: special lable out?
        je      short OSC1_Label            ;          Y: find out which one
        cmp     al, "@"                     ;       Q: special string out?
        je      short OSC1_Str
OSC1_out:
        xor     ah, ah                      ;          N: Send char to COM
        call    Out_Debug_Chr
        jmp     OSC1_Loop                   ; Loop until done

OSC1_Hex:
        call    Get_Register
        jnc     short OSC1_not_special

        cmp     bl, 2                       ; Q: Word output?
        jb      SHORT OSC1_Out_Byte         ;    N: display byte
OSC1_Out_Word:
        call    Out_Hex_Word                ; Display AX in hex
        jmp     OSC1_Loop                   ; Output next char

OSC1_Out_Byte:
        xchg    al, ah                      ; swap bytes to print just
        call    Out_Hex_Byte                ; the low one!
        jmp     OSC1_Loop                   ; Output next char

OSC1_Label:
        call    Get_Register
        jc      short show_label
OSC1_not_special:
        lodsb                               ; Get special char again
        jmp     OSC1_out                    ; display it, and continue

show_label:
        mov     cx, ax                      ; save first value
        cmp     byte ptr [si], ':'          ;Q: selector separator?
        jne     short flat_offset           ;  N:
        lodsb                               ;  Y: eat the ':'
        call    Get_Register                ;   and attempt to get the selector
        jc      short sel_offset
flat_offset:
        mov     ax, cs                      ; default selector value
sel_offset:
        call    Show_Near_Label
        jmp     OSC1_Loop

OSC1_Str:
        call    Get_Register
        jnc     short OSC1_not_special
        mov     cx,ax
        cmp     byte ptr [si],':'
        jne     short no_selector
        lodsb
        push    cx
        call    Get_Register
        pop     cx
        xchg    ax,cx
        jc      short got_sel_off
        mov     cx,ax
no_selector:
        mov     ax,ds                       ; default selector for strings
got_sel_off:
        call    Show_String
        jmp     OSC1_Loop

OSC1_Done:                                  ; The end

        pop     es
        npopf
        pop     bp
        ret     10h

DXOutDebugStr   endp


;******************************************************************************
;
;   Get_Register
;
;   DESCRIPTION:
;
;   ENTRY:
;
;   EXIT:           Carry set if register value found
;                       AX = register value
;                       BL = value size   (1, 2, 4)
;
;   USES:
;
;==============================================================================


Get_Register    proc    near

        push    si                          ; Save string pointer
        xor     ax, ax                      ; Zero AX
        mov     bl, 2                       ; BL = 2 (assume word output)
        call    Load_Up_Char                ; Get 1st char
        mov     ah, al                      ; Move 1st char to AH
        call    Load_Up_Char                ; Get second char
        cmp     al, 'L'                     ; Q: "L" (ie AL, BL, etc)?
        jne     short OSC1_WORD             ;    N: word reg
        mov     al, 'X'                     ;    Y: change to X for pos match
        mov     bl, 1                       ;       BL = 1 -- byte output
OSC1_WORD:
        xor     di, di                      ; DI = 0
        mov     cx, 8                       ; Size of a pusha
OSC1_Special_Loop:
        push    di
        shl     di,1
        cmp     ax, Reg_Offset_Table[di]    ; Q: Is this the register?
        pop     di
        je      SHORT OSC1_Out_Reg          ;    Y: Output it
        inc     di                          ;    N: Try the next one
        loop    OSC1_Special_Loop           ;       until CX = 0

OSC1_Ignore_Special:                        ; OOPS!  backup and ignore special
        pop     si                          ; Restore original string ptr
        dec     si                          ; back up to special char
        clc
        jmp     short gr_exit

OSC1_Out_Reg:
        push    di
        shl     di,1
        mov     ax, SS:[bp.6][di]           ; AX = Value to output
        pop     di
        add     sp, 2                       ; Trash pushed SI
        cmp     bl, 2                       ;Q: byte or word value?
        je      short value_fnd             ;      jump if word value
        xor     ah, ah                      ;      clear ah, if byte value
value_fnd:
        stc

gr_exit:
        ret

Get_Register    endp


;******************************************************************************
;
;   Load_Up_Char
;
;   Moves the character at DS:SI into AL and converts it to an upper case
;   character.  SI is incremented.
;
;------------------------------------------------------------------------------

Load_Up_Char    proc    near

        lodsb
        cmp     al, "Z"
        jb      SHORT LUC_Done
        sub     al, "a" - "A"
LUC_Done:
        ret

Load_Up_Char    endp


;******************************************************************************
;
;   Out_Hex_Word
;
;   Outputs the value in AX to the COM port in hexadecimal.
;
;------------------------------------------------------------------------------

Out_Hex_Word    proc    near

        rol     ax, 4
        call    Out_Hex_Char
        rol     ax, 4
        call    Out_Hex_Char
Out_Hex_Byte:
        rol     ax, 4
        call    Out_Hex_Char
        rol     ax, 4
        call    Out_Hex_Char

        ret

Out_Hex_Word    endp


;******************************************************************************
;
;   Out_Hex_Char
;
;   Outputs the low nibble in AL to the COM port.
;
;------------------------------------------------------------------------------

DXDATA  segment

Hex_Char_Tab LABEL BYTE
        db      "0123456789ABCDEF"

DXDATA  ends

Out_Hex_Char    proc    near

        push    ax
        push    bx
        mov     bx, ax
        and     bx, 1111b
        mov     al, Hex_Char_Tab[bx]
        call    Out_Debug_Chr
        pop     bx
        pop     ax
        ret

Out_Hex_Char    endp


;******************************************************************************
;
;   Out_Debug_Chr
;
;   DESCRIPTION:
;
;   ENTRY:
;       AL contains character to output
;
;   EXIT:
;
;   USES:
;       Nothing
;
;==============================================================================

Out_Debug_Chr   proc    near
        assume ds:nothing,es:DGROUP

if 0
        push    ax
        mov     ax,cs
        cmp     ax,SEL_DXCODE0          ; Are we in real mode?
        pop     ax
        jne     out_com

        cmp     fDebug,0                ; debugger installed?
        je      out_com                 ; N: go output it ourselves

        push    ax
        push    dx
        mov     dl, al
        mov     ax, DS_Out_Char
        int     Debug_Serv_Int
        pop     dx
        pop     ax
endif
        ret

Out_Debug_Chr   endp

;******************************************************************************
;
;   Show_Near_Label
;
;   DESCRIPTION:    call the debugger to display a label less than or equal
;                   to the given address
;
;   ENTRY:          AX is selector, CX is offset of address to try to find
;                   a symbol for
;                   ES selector to DOSX data segment
;   EXIT:
;
;   USES:
;
;==============================================================================

Show_Near_Label proc    near

if 0
        push    ax
        mov     ax,cs
        cmp     ax,SEL_DXCODE0          ; Are we in real mode?
        pop     ax
        jne     Show_Near_Label_ret

        cmp     es:idCpuType,3                  ;use 32 bit regs?
        jae     debug_386

        push    ax                              ;on a 286, use 16 bit regs
        push    bx
        push    cx
        mov     bx,cx
        mov     cx,ax
        mov     ax,DS_Out_Symbol
        int     Debug_Serv_Int
        pop     cx
        pop     bx
        pop     ax
endif
        ret

if 0
debug_386:
        .386p
        push    eax
        push    ebx
        push    ecx

        mov     bx, cx

        movzx   ecx, ax                         ;WDEB386 wants a 32 bit offset

        mov     ax, DS_Out_Symbol
        int     Debug_Serv_Int

        pop     ecx
        pop     ebx
        pop     eax
        ret

        .286p

Show_Near_Label_ret:
endif

Show_Near_Label endp


;******************************************************************************
;
;   Show_String
;
;   DESCRIPTION:    Display an asciiz string
;
;   ENTRY:          AX is selector, CX is offset of address to find string
;
;   EXIT:
;
;   USES:
;
;==============================================================================

Show_String     proc    near

if 0
        push    ax
        push    ds
        push    si

        mov     ds,ax
        mov     si,cx
        xor     ax,ax
@@:
        lodsb
        or      al,al
        jz      @f
        call    Out_Debug_Chr
        jmp     short @b
@@:
        pop     si
        pop     ds
        pop     ax
endif

        ret

Show_String     endp


DXCODE  ends

endif   ; DEBUG

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxemm.asm ===
PAGE	,132
	TITLE	DXEMM.ASM  -- Dos Extender MEMM Disable Code

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;	DXEMM.ASM      -- Dos Extender MEMM Disable Code
;
;-----------------------------------------------------------------------
;
; This module provides routines that attempt to disable MEMM/CEMM/EMM386
; drivers.  DOSX tries to disable MEMM when starting up, and enables MEMM
; when terminating.
;
; NOTE: All the code in this module is consider initialization, and
;	is discarded before going operational.	This includes code
;	segment variables.  The MEMM enable code is not in this file
;	since that cannot be discarded.
;
;-----------------------------------------------------------------------
;
;  12/08/89 jimmat  Minor changes so enable code could be finished.
;  07/14/89 jimmat  Original version - but largely taken from Windows/386
;		    code from ArronR
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include segdefs.inc
include gendefs.inc
	.list

if NOT VCPI
; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

EMM_OK	equ	0

; Device driver header for Microsoft 386 EMM drivers
;
emm_hdr 	STRUC
;
	DW		?			;Null segment address
	DW		?			;Null offset address
	DW		?			;Attribute - Char
	DW		?			;Strategy routine entry
	DW		?			;Interrupt routine entry
	DB		'EMMXXXX0'		;Character device name
;
; GENERAL FUNCTIONS ENTRY POINT
; ELIM_Entry is a entry point for executing general MEMM
; functions. (e.g. ON, OFF function).
;
ELIM_Entry_off	dw	?		; general entry point

;
;	       MEMM signature
;
emmsig db	?			; MEMM signature

emm_hdr 	ENDS


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA	segment

	extrn	MEMM_State:BYTE 	; initial on/off/auto state
	extrn	MEMM_Call:DWORD 	; far call address into MEMM driver
	extrn	fMEMM_Disabled:BYTE	; NZ if MEMM was disabled

DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE	segment

		extrn	segDXData:WORD

EMMDevNameRM    DB      "EMMXXXX0"      ;Character device name

MEMMsig         db      'MICROSOFT EXPANDED MEMORY MANAGER 386'
MEMMsiglen      equ     $ - MEMMsig

CEMMsig         db      'COMPAQ EXPANDED MEMORY MANAGER 386'
CEMMsiglen      equ     $ - CEMMsig

DXCODE	ends


DXPMCODE segment

DXPMCODE ends


; -------------------------------------------------------
	subttl	MEMM/CEMM/EMM386 Disable Routines
        page
; -------------------------------------------------------
;	    MEMM/CEMM/EMM386 DISABLE ROUTINES
; -------------------------------------------------------

DXCODE	segment
	assume	cs:DXCODE

; -------------------------------------------------------
;   EMMDisable -- This routine attempts to disable any installed
;	MEMM/CEMM/EMM386 driver.
;
;   Input:  none
;   Output: CY off - EMM driver disabled (or not installed)
;	    CY set - EMM installed, and can't disable
;   Errors:
;   Uses:   All registers preserved

	assume	ds:DGROUP,es:NOTHING,ss:NOTHING
	public	EMMDisable

EMMDisable	proc	near

	pusha
	push	ds
	push	es

	call	Check_for_EMM_Driver	;is there and EMM driver?
	jc	emmd_ok 		;  no, then we're already done

	call	MEMM_Inst_chk		;is it one we know about?
	jc	emmd_bad		;  no, then we can't disable it

; Get the current EMM driver state before checking for open handles.  The
; process of checking for handles may change the driver from AUTO to ON.

	xor	ax,ax			; get & save current emm state
	call	[MEMM_Call]		; returns ah = 0 - on, 1 - off,
	mov	MEMM_state,ah		;   2 - auto & off, 3 - auto & on

	call	AnyMEMMHandles		;does it have any handles allocated?
	jc	emmd_bad		;  yes, then we can't disable it

	call	TurnMEMMOff		;try to disable it
	jc	emmd_bad

	mov	fMEMM_Disabled,1	;remember that we disabled MEMM

emmd_ok:
	clc			;indicate disabled (or not installed)

emmd_ret:
	pop	es
	pop	ds
	popa

	ret

emmd_bad:
	stc				;can't disable!
	jmp	short emmd_ret

EMMDisable	endp


; -------------------------------------------------------
;	Windows/386 EMM Disable Code
; -------------------------------------------------------

	assume	ds:NOTHING,es:NOTHING,ss:NOTHING

BeginProc macro name
name	proc	near
	endm

EndProc macro	name
name	endp
	endm

;--------------------------------------------------------

;******************************************************************************
;
;       MEMM_Inst_chk - Check to see if MEMM/CEMM is already installed
;
;       ENTRY:
;           Know there is an EMM driver so INT 67 vector points to something
;
;       EXIT:
;           Carry set
;             No MEMM/CEMM driver
;           Carry Clear
;               [entry_seg] = segment of driver header
;               [entry_off] = offset of status routine in MEMM
;
;	USES: AX,CX,SI,DI,FLAGS
;
;******************************************************************************

	assume	ds:NOTHING, es:NOTHING

BeginProc MEMM_Inst_chk

	push	ds
	push	es

        xor     ax,ax
        mov     ds,ax
        mov     ax,word ptr ds:[(67h * 4)+2]   ; get segment pointed to by int 67
        mov     ds,ax
        mov     si,emmsig
        cld                             ; strings foward
        mov     di,offset MEMMsig
        push    cs
        pop     es
        mov     cx,MEMMsiglen
        cld
        repe    cmpsb                   ; q: is the MEMM signature out there?
        je      short found_sig         ; y: return one
        mov     si,emmsig
        mov     di,offset CEMMsig
        mov     cx,CEMMsiglen
        cld
        repe    cmpsb                   ; q: is the CEMM signature out there?
        jne     short Not_Found         ; n: done, not found

found_sig:
	mov	es,segDXData
	xor	si,si
	mov	word ptr es:[MEMM_Call+2],ds	; save segment for far call
	mov	cx,ds:[si.ELIM_Entry_off]
	mov	word ptr es:[MEMM_Call],cx	; Offset for far call

        clc

MEMM_Inst_Done:
	pop	es
	pop	ds
        ret

Not_Found:
        stc
        jmp     short MEMM_Inst_Done

EndProc MEMM_Inst_chk

;******************************************************************************
;
;   TurnMEMMOff
;
;       Turn MEMM off (CEMM, IEFF, MEMM)
;
;       ENTRY:
;           entry_seg entry_off set to CEMM/MEMM enable disable routine
;
;       EXIT:
;           Carry Set
;               Could not disable EMM
;           Carry Clear
;               MEMM CEMM EMM turned off
;
;       USES: EAX,FLAGS
;
;******************************************************************************

	assume	ds:DGROUP, es:NOTHING

BeginProc TurnMEMMOff

	cmp	MEMM_state,1		; MEMM already off?
	jz	short memm_off		; yes, nothing to do

	mov	AX,0101h		; no, turn it OFF
	call	[MEMM_Call]
	jc	short memm_err
memm_off:
        clc
memm_done:
        ret

memm_err:
        stc                             ; Error, set carry
        jmp     short memm_done

EndProc TurnMEMMOff

;******************************************************************************
;
;   AnyMEMMHandles/Check_For_EMM_Handles
;
;       Are there any open MEMM handles
;
;       ENTRY:
;           entry_seg entry_off set to CEMM/MEMM enable disable routine
;
;       EXIT:
;           Carry Set
;               There are open handles
;           Carry Clear
;               There are no open handles
;
;       USES: EAX,EBX,ECX,FLAGS
;
;******************************************************************************

	assume	ds:DGROUP, es:NOTHING

BeginProc AnyMEMMHandles

        mov     ax,4600h
        int     67h
        cmp     ah,EMM_OK
        jne     short memm_is_off
        mov     cx,ax
        mov     ax,4B00h
        int     67h
        cmp     ah,EMM_OK
        jne     short memm_is_off
        cmp     cl,40h
        jb      short Check_Cnt
        or      bx,bx                   ; Don't dec through 0!!!
        jz      short Check_Cnt
        dec     bx                      ; Do not include handle 0 on 4.0 drivers
Check_Cnt:
        cmp     bx,0
        stc
        jne     short HaveHandles
memm_is_off:
        clc
HaveHandles:
        ret

EndProc AnyMEMMHandles

;******************************************************************************
;
;   Check_For_EMM_Driver
;
;       See if an EMM driver is around
;
;       ENTRY:
;           None
;
;       EXIT:
;           Carry Set
;               No EMM driver around
;           Carry Clear
;               EMM driver is around
;
;	USES: AX,CX,SI,DI,FLAGS
;
;******************************************************************************

	assume	ds:NOTHING,es:NOTHING

BeginProc Check_For_EMM_Driver

	push	ds
	push	es

; Note, DS:SI & ES:DI used to be swapped, but on at least one system where
; Int 67h pointed to F000 and there was not ram or rom at F000:000A (rom
; started at F0000:8000), bus noise made the compare work when it shouldn't
; have.  Swapping ES:DI / DS:SI corrected this.

        xor     ax,ax
	mov	es,ax
	mov	ax,word ptr es:[(67h * 4)+2]	; get segment pointed to by int 67
	mov	es,ax
	mov	di,000Ah			; Offset of device name
	mov	si,offset EMMDevNameRM
        push    cs
	pop	ds
        mov     cx,8
        cld
        repe    cmpsb
        jne     short NoEMM_Seen
        clc

EMMTstDone:
	pop	es
	pop	ds
        ret

NoEMM_Seen:
        stc
        jmp     short EMMTstDone

EndProc Check_For_EMM_Driver


; -------------------------------------------------------

DXCODE	ends

;****************************************************************

endif		; NOT VCPI

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxemm2.asm ===
PAGE	,132
	TITLE	DXEMM2.ASM  -- Dos Extender MEMM Enable Code

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;	DXEMM2.ASM     -- Dos Extender MEMM Enable Code
;
;-----------------------------------------------------------------------
;
; This module provides routines that attempt to enable MEMM/CEMM/EMM386
; drivers.  DOSX tries to disable MEMM when starting up, and enables MEMM
; when terminating.
;
; NOTE: This code is in a seperate file from the disable logic because
;	the disable code is discarded after initialization.
;
;-----------------------------------------------------------------------
;
;  12/08/89 jimmat  Finally got around to implementing this.
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

if NOT VCPI

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA	segment

		public	fMEMM_Disabled, MEMM_State, MEMM_Call

fMEMM_Disabled	db	0		; NZ if MEMM disabled
MEMM_state	db	0		; Initial MEMM state

MEMM_Call	dd	0		; far call address into EMM driver

DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

DXCODE	ends


DXPMCODE segment

DXPMCODE ends


; -------------------------------------------------------
	subttl	MEMM/CEMM/EMM386 Enable Routines
        page
; -------------------------------------------------------
;	    MEMM/CEMM/EMM386 ENABLE ROUTINES
; -------------------------------------------------------

DXCODE	segment
	assume	cs:DXCODE

; -------------------------------------------------------
;   EMMEnable -- This routine attempts to re-enable any installed
;	MEMM/CEMM/EMM386 driver.
;
;   Input:  none
;   Output: CY off - EMM driver enabled (or never disabled)
;	    CY set - EMM installed, and can't disable
;   Errors:
;   Uses:   All registers preserved

	assume	ds:DGROUP,es:NOTHING,ss:NOTHING
	public	EMMEnable

EMMEnable	proc	near

	push	ax

	cmp	fMEMM_Disabled,0	; Did we disable MEMM before?
	jz	enable_exit		;   no, don't need to enable then

	mov	ah,01			; Set state command
	mov	al,MEMM_state		; Get initial state
	cmp	al,2			; They return 0 (on), 1 (off),
	jbe	@f			;   2 (auto on), 3 (auto off) -- but
	mov	al,2			;   we can only set 1 - 2
@@:
	call	[MEMM_Call]		;   and restore it
	jc	not_enabled

	mov	fMEMM_Disabled,0	; no longer disabled

	clc
	jmp	short enable_exit

not_enabled:
	stc

enable_exit:
	pop	ax

	ret

EMMEnable	endp

; -------------------------------------------------------

DXCODE	ends

;****************************************************************

endif			; NOT VCPI

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
if ?uf
?pas = ?pas and (not (?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxfind.asm ===
PAGE	,132
	TITLE	DXFIND.ASM  -- Dos Extender Find File Routine

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;***********************************************************************
;
;	DXFIND.ASM	-- Dos Extender Find File Routine
;
;-----------------------------------------------------------------------
;
; This module provides the locate file logic for the 286 DOS Extender.
;
;-----------------------------------------------------------------------
;
;  09/27/89 jimmat  Original version -- considerable code taken from
;		    old GetChildName routine in dxinit.asm.
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

	extrn	strcpy:NEAR
	extrn	toupper:NEAR

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

	extrn	segPSP:WORD
	extrn	rgbXfrBuf1:BYTE

DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE	segment

szPath	  db	'PATH',0
szWindir  db	'WINDIR',0

DXCODE	ends


; -------------------------------------------------------
	subttl	Find File Routine
        page
; -------------------------------------------------------
;		  FIND FILE ROUTINE
; -------------------------------------------------------

DXCODE	segment
	assume	cs:DXCODE

; -------------------------------------------------------
;   FindFile -- This routine is used to locate a particular file.
;	If successful, this routine will setup the buffer in rgbXfrBuf1
;	at offset EXEC_PROGNAME with the string for the file name that
;	can be used in a DOS open call.
;
;	This routine searches for the file in the following sequence:
;
;	     1) If the file name contains a relative or complete path
;		component, only look for that particular file,
;
;	     otherwise:
;
;	     1) Look int the environment for a WINDIR= variable, and if
;		found, check that directory first.
;	     2) Look in the directory the dos extender was loaded from
;	     3) Look in the current directory
;	     4) Look in all directories in the PATH environment variable
;
;	NOTE: This routine must be called in real mode!
;
;   Input:  RELOC_BUFFER has the file name to search for.
;	    EXEC_DXNAME has the complete path the dos extender
;   Output: EXEC_PROGNAME has complete path to child program.
;   Errors: returns CY set if unable to find child
;   Uses:   All registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
	public	FindFile

FindFile proc  near

	pusha
	push	ds
	push	es

        push    ds
        pop     es
        assume  es:DGROUP

; If the base file name contains a ':' '\' or '/', then we'll see if the
; file can be found with that name.  This isn't exactly the way Windows wants
; us to search for kernel, but allows a user to specify a relative or complete
; path on the command line.  If we get run for Windows/286 pMode, the base
; child name will not include any of these characters, so we will not make
; this check.

	mov	si,offset RELOC_BUFFER
@@:	lodsb
	or	al,al
	jz	fndf20		;no path characters, go do other search
	cmp	al,':'
	jz	fndf10
	cmp	al,'\'
	jz	fndf10
	cmp	al,'/'
	jnz	@b

; The name seems to include a path component.  We just want to look for that
; file, and only that file.

fndf10: mov	si,offset RELOC_BUFFER
        mov     di,offset EXEC_PROGNAME
        mov     dx,di
	call	strcpy

	mov	ax,4300h		;use get file attributes to check
	int	21h
	jmp	fndf90			;found it or not, either way we're done

; The file name doesn't include a path component.  If we were run for pMode
; Windows, the environment should include a WINDIR= entry that points to
; the Windows directory.  Look for this env variable, and check that directory
; first.

fndf20:
	push	es				;look for the
	push	cs				;WINDIR= env variable
	pop	es
	assume	es:NOTHING
	mov	di,offset DXCODE:szWindir
	call	GetEnv
	pop	es
	assume	ds:NOTHING,es:DGROUP

	jnz	fndf_dosx_dir

; Found WINDIR, copy over the path name, add child name and search

	mov	di,offset EXEC_PROGNAME ;copy WINDIR path
	mov	dx,di
	call	strcpy

	cmp	byte ptr es:[di-1],'\'  ;add trailing \ if necessary
	jz	@f
	mov	byte ptr es:[di],'\'
	inc	di
@@:
	push	es			;ds back to DGROUP
	pop	ds
	assume	ds:DGROUP

	mov	si,offset RELOC_BUFFER	;add child name
	call	strcpy

	mov	ax,4300h		;use get file attributes to check
	int	21h
	jc	fndf_dosx_dir		;no there, go do next check
	jmp	fndf90			;found it!

; Next, we try looking in the directory that the Dos Extender was loaded
; from.  Start with the complete path to the Dos Extender program file.

fndf_dosx_dir:

	push	es
	pop	ds
	assume	ds:DGROUP

	mov	si,offset EXEC_DXNAME
        mov     di,offset EXEC_PROGNAME
        mov     dx,di
	call	strcpy

; Now, search backward from the end of the string until we find the
; first backslash or colon.  This will take us back past the file name
; and leave us with the raw path.

fndf24: dec	di
        cmp     di,dx           ;check if we have gone back past the start
                                ; of the string.  (DX still has the address
                                ; of the start of the buffer from above)
	jb	fndf_cd 	;and if so skip this part as the path is null.
        mov     al,es:[di]
        cmp     al,':'
	jz	fndf26
        cmp     al,'\'
	jnz	fndf24

; Add the file name string onto the raw path and see if the file exists.

fndf26: inc	di
        mov     si,offset RELOC_BUFFER
	call	strcpy

	mov	ax,4300h		;use get file attributes to check
	int	21h
	jc	fndf_cd
        jmp     fndf90

; We didn't find the file in the same directory as the Extender itself.
; Now, try looking for the file in the current directory!

fndf_cd:
	mov	di,offset EXEC_PROGNAME ;build current directory path string
	dossvc	19h
	add	al,'A'
	stosb				;drive letter

	mov	ax,'\:'
	stosw

	xor	dl,dl
	mov	si,di
	dossvc	47h			;current directory

        mov     al,es:[di]              ;check if it's the root
        or      al,al                   ;empty string?
        jz      short fndf_cd_cpy       ;yes, don't add another '\'

@@:	lodsb				;find end of string
	or	al,al
	jnz	@b

	mov	byte ptr [si-1],'\'     ;add ending \

fndf_cd_cpy:
	mov	di,si			;add base child name
	mov	si,offset RELOC_BUFFER
	call	strcpy

	mov	dx,offset EXEC_PROGNAME ;use get file attributes to check
	mov	ax,4300h
	int	21h

	jc	fndf30
	jmp	short fndf90

; We didn't find it in the current directory, look at the PATH
; environment variable and see if the file can be found in any of
; its directories.  First off, search for the PATH environment
; string.

fndf30:
	push	es
	mov	di,offset DXCODE:szPath 	;point ES:DI to path str
	push	cs
	pop	es
	assume	es:NOTHING

	call	GetEnv				;find the path env var
	assume	ds:NOTHING

	pop	es
	assume	es:DGROUP

	jnz	fndf80				;Z flag set if FOUND

; We are pointing at the beginning of the path environment variable.  We need
; to loop for each directory specified to see if we can find the file in
; that directory.

	mov	bx,ds		;keep env segment in BX

fndf40: mov	ds,bx		;environment segment to DS
	assume	ds:NOTHING
	mov	al,ds:[si]
	or	al,al		;check for end of path variable.
	jz	fndf80		;if so, we didn't find any directory with
				; the desired file in it.

        mov     di,offset EXEC_PROGNAME
fndf42: lods	byte ptr [si]
	cmp	al,';'		;is it the separator between strings in
	jz	fndf52		; the environment variable?
	or	al,al		;is it the 0 at the end of the environment
	jz	fndf50		; string?
        stos    byte ptr [di]
	jmp	fndf42

fndf50: dec	si
fndf52: push	si		;save pointer to start of next string
	mov	al,'\'
	cmp	al,byte ptr es:[di-1]  ;dir name already end with \ (root dir?)
	jnz	fndf54
	dec	di		       ;  yes, don't make it two \'s
fndf54: stos	byte ptr [di]
	mov	si,offset RELOC_BUFFER ;pointer to file base name
	mov	ax,es		       ;put our data segment address in DS
	mov	ds,ax
	assume	ds:DGROUP
	call	strcpy		;append file base name to path

	mov	ax,4300h	;use get file attributes to check
	int	21h

	pop	si		;restore pointer to start of next string
	jc	fndf40
	jmp	short fndf90

; Unable to find the file

fndf80: stc

; Finished, successful or not

fndf90:
	pop	es
	pop	ds
	popa
	ret

FindFile  endp


; -------------------------------------------------------
;   GetEnv -- This routine searches the environment for a
;	specific variable.
;
;   Input:  ES:DI   - far pointer to wanted variable name
;   Output: DS:SI   - far pointer to variable value string
;   Errors: return Z true if variable located
;   Uses:   DS:SI modified, all else preserved

	assume	ds:DGROUP,es:NOTHING,ss:NOTHING
	public	GetEnv

GetEnv	proc	near

	push	ax
	push	dx
	push	di

; Point DS:SI to our environment block

	mov	ds,segPSP
        assume  ds:PSPSEG
	mov	ds,segEnviron
	xor	si,si
        assume  ds:NOTHING

; See if DS:SI is pointing at desired environment variable

	mov	dx,di			;keep var name offset in dx

gete10:
	cmp	byte ptr es:[di],0	;at end of variable name?
	jz	gete50			;  yes, go check '=' & optional blanks

gete20:
	lodsb				;get variable char
	call	toupper 		;just in case...
	cmp	al,es:[di]		;match desired name so far?
	jnz	gete30			;  no, go find the next var name

	inc	di			;bump var pointer
	jmp	short gete10		;  and keep on checking

gete30:
	mov	di,dx			;reset source name pointer

	or	al,al			;already at end of this env var?!
	jz	gete35

@@:	lodsb
	or	al,al			;find next environment var name
	jnz	@b
gete35:
	cmp	byte ptr ds:[si],0	;at end of environment?
	jz	gete80			;  yes, go fail the call
	jmp	short gete10		;  no, try try again

; Found the env variable, now skip the '=' and any spaces

gete50:
	cmp	byte ptr ds:[si],'='	;when we get here, better be pointing
	jnz	gete30			;  at an '='
	inc	si

@@:	cmp	byte ptr ds:[si],' '	;skip any optional blanks
	jnz	@f
	inc	si
	jmp	short @b
@@:
	xor	ax,ax			;set the Z flag
	jmp	short @f

gete80:
	or	ax,si			;pretty sure this clears Z
@@:
	pop	di
	pop	dx
	pop	ax

	ret

GetEnv	endp

; -------------------------------------------------------

DXCODE	ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxend.asm ===
PAGE	,132
        TITLE   DXEND.ASM  -- Special End Module for Dos Extender

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXEND.ASM       -   Dos Extender End Module             *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains the definition for special symbols     *
;*  which define the end of the Dos Extender code and data      *
;*  segments.  It must be the last module linked in the         *
;*  Dos Extender.                                               *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*								*
;*  01/09/90 jimmat   Remove DataEnd symbol since it wasn't     *
;*		      really useful.				*
;*  08/20/89 jimmat   Removed A20 space since HIMEM 2.07 works	*
;*		      properly across processor resets		*
;*  08/02/89 jimmat   Moved CodeEndPM to DXENDPM.ASM		*
;*  07/21/89 jimmat:  Added space for A20 handler		*
;*  02/10/89 (GeneA): changed Dos Extender from small model to  *
;*      medium model                                            *
;*  09/20/88 (GeneA):   created                                 *
;*                                                              *
;****************************************************************
;
; -------------------------------------------------------
;               INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

include segdefs.inc
include gendefs.inc
include pmdefs.inc
if VCPI
include dxvcpi.inc
endif

; -------------------------------------------------------
;               CODE SEGMENT DEFINITIONS
; -------------------------------------------------------
;
DXCODE  segment
        assume  cs:DXCODE

        public  CodeEnd


if VCPI

if1
%OUT VCPI option not ROMable.
endif

CodeEnd	db ( LDTOFF + CBPAGE386 ) dup (0)

else

CodeEnd:

endif ; VCPI

DXCODE  ends


;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxendpm.asm ===
PAGE	,132
	TITLE	DXENDPM.ASM  -- Special End Module for Dos Extender

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*	DXENDPM.ASM	  -   Dos Extender End Module		*
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*								*
;*  This module contains the end symbol for the DOS Extender's  *
;*  protected mode code segment.				*
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*								*
;*  08/02/89 jimmat   Split out from dxend.asm			*
;*  09/20/88 (GeneA):   created                                 *
;*                                                              *
;****************************************************************
;
; -------------------------------------------------------
;               INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

include     segdefs.inc

; -------------------------------------------------------
;               CODE SEGMENT DEFINITIONS
; -------------------------------------------------------


DXPMCODE    segment
        assume  cs:DXPMCODE

        public  CodeEndPM
CodeEndPM:

DXPMCODE    ends

;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxini.asm ===
PAGE    ,132
        TITLE   DXINI.ASM  -- Dos Extender INI File Processing

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXINI.ASM      -- Dos Extender INI FIle Processing
;
;-----------------------------------------------------------------------
;
; This module provides the 286 DOS extender's ...
;
;-----------------------------------------------------------------------
;
;  09/27/89 jimmat    Modified to use FindFile instead of using its
;                     own file search logic
;  05/24/89 w-glenns  Original (UNCUT, UNCENSORED!) version
;
;***********************************************************************

        .286

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
include     intmac.inc
        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

CR      equ     13
LF      equ     10
TAB     equ     9
EOF     equ     26


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   strcpy:NEAR
        extrn   FindFile:NEAR

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   rgbXfrBuf1:BYTE

DXDATA  ends

; -------------------------------------------------------
        subttl  Read INI File Routine
        page
; -------------------------------------------------------
;           READ INI FILE ROUTINE
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

;******************************************************************************
;
;   ReadIniFile
;
;   DESCRIPTION:    read and parse a .INI file for the 286 DOS Extender
;                   initialization.
;
;   ENTRY:          dx points to the file name
;                   bx points to structure to fill with ini fields
;
;   EXIT:           Carry set, if file not found, or not enough memory
;
;   USES:           ax, cx
;
;==============================================================================

        assume  ds:DGROUP
        public  ReadIniFile

ReadIniFile PROC NEAR

        push    es
        push    bx
        push    si
        push    di

        push    ds
        pop     es
        assume  es:DGROUP

        push    bx                      ; ptr to ini structure to fill

        mov     si,dx
        mov     di,offset RELOC_BUFFER  ; FindFile wants the name here
        call    strcpy

        call    FindFile                ; locate the .INI file
        jc      ri_error

        mov     ax,3D00h                ; open the .INI file
        mov     dx,offset EXEC_PROGNAME ; FindFile puts path name here
        int     21h
        jc      ri_error                ; shouldn't happen, but...

        mov     si, ax                  ; file handle

        mov     ah, 48h                 ; alloc DOS conventional memory
        mov     bx, 4096d               ; want 64k block
        int     21h
        jc      ri_error

        pop     dx                      ; ptr to ini structure to fill

        call    parse_ini               ; do the work, and come back
        assume  es:NOTHING

        pushf                           ; save parse_ini flags

        mov     ah, 49h                 ; dealloc DOS conventional memory
        int     21h                     ; es already points to block

        npopf                           ; carry set = problem
ri_end:
        pop     di
        pop     si
        pop     bx
        pop     es
        ret

ri_error:                               ; error exit
        pop     bx                      ; clear stack
        stc                             ; force carry on
        jmp     short ri_end            ; split

ReadIniFile ENDP


;******************************************************************************
;
;   Parse_Ini
;
;   DESCRIPTION:    Read in, and parse the ini file opened
;                   and find the variable values specified
;
;   ENTRY:          ax points to the memory block for the file image buffer
;                   dx points to structure to fill with ini fields
;                   si has the handle to the file opened
;
;   EXIT:           Carry set, if file not found, or not enough memory
;
;   USES:           ax, bx, cx, es
;
;==============================================================================

Parse_Ini PROC NEAR

        push    bp
        push    dx
        mov     bp,dx                   ; bp = index into structure (es:)

        assume  ds:NOTHING
        push    ds

        mov     ds, ax                  ; ptr to mem block

        mov     ah, 3Fh
        mov     bx, si
        mov     cx, 0FFFFh              ; guess extremely high
        xor     dx, dx                  ; offset 0
        int     21h

        pop     es
        assume  es:DGROUP               ; NOTE:!!! es is now data segment !!!

        pushf                           ; save flags from read
        push    ax                      ; save # bytes read

        mov     ah, 3Eh                 ; close file
        mov     bx, si
        int     21h

        pop     di                      ; number bytes read
        npopf                           ; CY flag

        jnc     @f
        jmp     parse_done_jump   ; if couldn't read, return bad
@@:

        mov     byte ptr ds:[di], EOF   ; write EOF char'r in case none present

        ; ds:si    points to the file image buffer
        ; es:di/bx structure to fill with ini stuff
        xor     si,si

        ; search until section found
find_section:
        call    Get_Char
        jc      short parse_done_jump   ; end of file, and section not found
        cmp     al, '['                 ; a section ?
        jne     short find_section

        mov     di, bp                  ; point to ini structure
        ; a section has been found, but is it the right one ?
        xor     bx, bx                  ; use as secondary index
cmp_section:
        mov     al, byte ptr ds:[si+bx] ; char'r from section name in file

        inc     bx                      ; bx starts at zero for file pointer
                                        ; index, and starts at one for
                                        ; structure index
        mov     ah, byte ptr es:[di+bx]
        or      ah, ah
        jz      short find_keyword_start ; yes: found the right section !

        call    Conv_Char_Lower         ; convert char'r in AL to lower case
        cmp     al, ah                  ; same so far ?
        jne     short find_section
        jmp     short cmp_section

find_keyword_start:
        add     si,bx                   ; update file pointer past section name

        add     bp,bx                   ; update structure ptr past section name

        ; now that section is found, want to find keywords
find_keyword:
        call    Get_Char                ; points to 1st char'r of next keyword
        jc      short parse_done_jump   ; end of file, and keyword not found

        cmp     al, '['                 ; new section ?
        je      short parse_done_jump   ; hit a new section, so we're done

search_keyword:
        xor     di,di
        ; use beginning of file image buffer for temporary storage of the
        ; keyword name currently being checked

find_keyword_loop:
        mov     byte ptr ds:[di], al    ; copy the char'r
        inc     di

        mov     dx,si                   ; save position in file image buffer
        call    Get_Char                ; points to 1st char'r of next keyword
        jc      short parse_done_jump   ; end of file, and keyword not found
        pushf
        cmp     al, '='
        je      short compare_keyword
        ; yes: found a keyword, lets do some comparisons

        npopf
        jz      short find_keyword_loop ; no white space yet...copy keyword

skip_keyword:
        ; white space has been skipped, yet there is no '='
        ; must be an error...ignore, and get next keyword
        mov     si,dx                   ; point to last char'r in keyword
        mov     byte ptr ds:[si], ';'
        ; fake a comment, so that the rest of the
        ; line is ignored in the next Get_Char call
        ; and the next keyword is pointed to
        jmp     short find_keyword


parse_done_jump:
        jmp     parse_done

        ; char'r is an equals, so compare this keyword to the list
compare_keyword:
        npopf                           ; clean top-of-stack
        mov     byte ptr ds:[di], 0     ; NULL at end of keyword for compare
        mov     bx,bp                   ; get index into INI structure in
                                        ; data segment DGROUP (where es points)

cmp_keyword1:
        xor     di,di                   ; point to start of keyword found

cmp_keyword:
        inc     bx
        mov     ah, byte ptr es:[bx]    ; next char'r in ini struct keyword
        mov     al, byte ptr ds:[di]    ; next char'r of found keyword
        inc     di
        or      al, ah
        jz      short convert_number    ; yes: found the right keyword

        call    Conv_Char_Lower         ; convert char'r in AL to lower case
        cmp     al, ah                  ; same so far ?
        je      short cmp_keyword

        xor     al,al
        dec     bx
cmp_keyword_loop:
        inc     bx
        cmp     byte ptr es:[bx], al    ; next keyword yet?
        jne     cmp_keyword_loop        ; nope: go back until done

        ; keywords don't match..try next key word in ini structure
        inc     bx
        inc     bx                      ; jump over variable space (1 word)
        cmp     byte ptr es:[bx+1], al  ; more keywords to compare with ?
        jne     short cmp_keyword1      ; yes: compare the next one
        jmp     short skip_keyword
        ; no: search file for next keyword

convert_number:
        push    si      ; save current file pointer
        call    Get_Char
        dec     si      ; point to first char'r position in number to convert

        xor     di,di
        mov     ax,di
        mov     cx,ax

        cmp     byte ptr ds:[si], '+'   ; positive number ? (default)
        jne     short cn_1

        inc     si      ; just skip the char'r - positive is default anyway

cn_1:   cmp     byte ptr ds:[si], '-'   ; negative number ?
        jne     short cn_2

        inc     si
        inc     cl      ; negative number - flag so we can negate it later

cn_2:   push    bx
        mov     bx,si   ; save ptr in file buffer - check later if it changed
        push    cx      ; save flag

convert_get_loop:
        mov     cl, byte ptr ds:[si]
        cmp     cl, '0'
        jb      short convert_done
        cmp     cl, '9'
        ja      short convert_done

        sub     cx,'0'                  ; de-ascii'ize cx ==> 0h - 09h

        inc     si                      ; increment pointer
        mov     dx,010d
        mul     dx                      ; multiply ax by 10 : dx is set to zero
        add     ax,cx                   ; add number in
        jmp     short convert_get_loop

convert_done:
        pop     cx                      ; restore -ve/+ve flag
        jcxz    convert_done_1          ; Q: -ve number ?

        neg     ax                      ; negate the number

convert_done_1:
        cmp     si,bx                   ; Q: has index changed, i.e.
                                        ; is the first char'r invalid ?
        pop     bx
        je      short convert_done_2    ; Y: don't save number

        inc     bx                      ; N: point to number in structure
        mov     word ptr es:[bx], ax    ; save value into ini structure

convert_done_2:
        pop     si                      ; get old file pointer
        mov     byte ptr ds:[si], ';'
        ; fake a comment, so that the rest of the
        ; line is ignored in the next Get_Char call
        ; and the next keyword is pointed to
        jmp     find_keyword            ; go back & get another


        ; *** single exit point for parsing code
parse_done:
        mov     ax,es                   ; swap extended and data segment ptrs
        mov     bx,ds
        mov     es,bx
        mov     ds,ax

        pop     dx
        pop     bp
        ret

Parse_Ini ENDP

;******************************************************************************
;
;   Get_Char
;
;   DESCRIPTION:    Local routine which gets the next valid ascii
;                   character from the file image, while skipping white
;                   space.
;
;   ENTRY:          ds:si -> buffer pointer
;
;   EXIT:         ds:si -> new buffer pointer
;                 al   --> character
;               Z flag --> set = no white space between last char'r and current
;               C flag --> set = reached end of file
;
;   USES:           cx
;
;==============================================================================

Get_Char PROC NEAR

        mov     cx,si
        inc     cx

get_char_loop:
        lodsb                           ; get char from file image
        cmp     al,EOF
        je      short get_char_EOF
        cmp     al,CR
        je      short get_char_loop
        cmp     al,LF
        je      short get_char_loop
        cmp     al,TAB
        je      short get_char_loop
        cmp     al,' '
        je      short get_char_loop
        cmp     al,';'
        je      short get_char_skip_comment

        ; must have got a good character finally...
        call    Conv_Char_Lower
        cmp     cx,si                   ; skipped a white space ?
        clc                             ; continue
        ret

get_char_EOF:
        stc                             ; flag end of the file
        ret

get_char_skip_comment:
        lodsb                           ; get char from file image
        cmp     al,EOF
        je      short get_char_EOF
        cmp     al,CR
        jne     short get_char_skip_comment
        jmp     short get_char_loop

Get_Char ENDP

Conv_Char_Lower PROC NEAR

        cmp     al, 'A'                 ; want char'r 'A'-'Z' to be
        jb      short lower_done        ; converted to 'a'-'z'
        cmp     al, 'Z'
        ja      short lower_done
        or      al, 020h                ; convert to lower case
lower_done:
        ret

Conv_Char_Lower ENDP

; -------------------------------------------------------

DXCODE    ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxintr.asm ===
PAGE    ,132
        TITLE   DXINTR.ASM  -- Dos Extender Interrupt Reflector

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXINTR.ASM      -   Dos Extender Interrupt Reflector    *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Revision History:                                           *
;*                                                              *
;*                                                              *
;*  09/13/90 earleh  Fault handlers Ring 0                      *
;*  09/06/90 earleh  Fault handlers DPMI compliant              *
;*                   PIC remapping no longer required           *
;*  08/08/90 earleh  DOSX and client privilege ring determined  *
;*      by equate in pmdefs.inc                                 *
;*  05/09/90 jimmat  Started VCPI changes.                      *
;*  04/02/90 jimmat  Added PM Int 70h handler.                  *
;*  01/08/90 jimmat  Don't allow nested PS/2 mouse interrupts   *
;*                   (later removed!)                           *
;*  09/15/89 jimmat  Support for 'Classic' HP Vectras which     *
;*                   have 3 8259 interrupt controllers          *
;*  07/28/89 jimmat  Save A20 state when reflecting an int to   *
;*                   protected mode, removed Int 30h handler    *
;*                   that did code patch-ups, point debugger    *
;*                   to faulting instruction, not Int 3.        *
;*  07/13/89 jimmat  Improved termination due to faults when    *
;*                   not running under a debugger--also ifdef'd *
;*                   out code to dynamically fixup code seg     *
;*                   references on GP faults                    *
;*  06/05/89 jimmat  Ints 0h-1Fh are now vectored through a 2nd *
;*                   table.  This allows Wdeb386 interaction    *
;*                   more like Windows/386.                     *
;*  05/23/89 jimmat  Added wParam & lParam to interrupt frame.  *
;*  05/07/89 jimmat  Added XMScontrol function to map protected *
;*                   mode XMS requests to real mode driver.     *
;*  05/02/89 jimmat  8259 interrupt mask saved around changing  *
;*                   of hardware interrupt base                 *
;*  04/24/89 jimmat  Added support for PS/2 Int 15h/C2h/07 Set  *
;*                   Pointing Device Handler Address function   *
;*  04/12/89 jimmat  Added PMIntr24 routine to support PM       *
;*                   Critical Error Handlers                    *
;*  03/15/89 jimmat  Added INT 31h LDT/heap interface a la      *
;*                   Windows/386                                *
;*  03/14/89 jimmat  Changes to run child in ring 1 with LDT    *
;*  02/24/89 (GeneA): fixed problem in IntEntryVideo and        *
;*      IntExitVideo for processing function 10h subfunction    *
;*      for reading and writing the VGA palette.                *
;*  02/22/89 (GeneA): added handlers for Int 10h, Int 15h, and  *
;*      Int 33h.  Added support for more general mechanism for  *
;*      handling interrupts require special servicing and       *
;*      allowing nesting of these interrupts.  Allocation and   *
;*      deallocation of stack frames is supported to allow      *
;*      nested paths through the interrupt reflection code to   *
;*      a depth of 8.                                           *
;*      There is still a problem that if an interrupt handler   *
;*      is using a static buffer to transfer data, another      *
;*      interrupt that uses the same static buffer could come   *
;*      in and trash it.  Solving the problem in a completely   *
;*      general way would require having a buffer allocation    *
;*      deallocation scheme for doing the transfers between     *
;*      real mode memory and protected mode memory.             *
;*  02/14/89 (GeneA): added code in TrapGP to print error msg   *
;*      and quit when running a non-debugging version.          *
;*  02/10/89 (GeneA): changed Dos Extender from small model to  *
;*      medium model.  Added function LoaderTrap to handle      *
;*      loader interrupts when the program contains overlays.   *
;*  11/20/88 (GeneA): changed both RM and PM interrupt reflector*
;*      routines to pass the flags returned by the ISR back to  *
;*      the originator of the interrupt, rather than returning  *
;*      the original flags.                                     *
;*  10/28/88 (GeneA): created                                   *
;  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;*                                                              *
;****************************************************************

        .286p
        .287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include interupt.inc
ifdef WOW_x86
include vdmtib.inc
endif
        .list
include intmac.inc
include stackchk.inc
include bop.inc
include dpmi.inc

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   EnterRealMode:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   ParaToLinear:NEAR
externFP        NSetSegmentDscr
ifdef   NEC_98
        extrn   GetSegmentAddress:NEAR
endif   ;NEC_98
        extrn   ParaToLDTSelector:NEAR

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   pmusrss:WORD
        extrn   pmusrsp:WORD
        extrn   npXfrBuf1:WORD
        extrn   rgbXfrBuf0:BYTE
        extrn   rgbXfrBuf1:BYTE
        extrn   lpfnXMSFunc:DWORD
        extrn   Int28Filter:WORD
        extrn   DpmiFlags:WORD
IFDEF WOW_x86
        extrn   FastBop:fword
ENDIF

;
; Variables used to store register values while mode switching.

        public  regUserSS, regUserSP, regUserFL, regUserAX, regUserDS
        public  regUserES

regUserSS       dw      ?
regUserSP       dw      ?
regUserCS       dw      ?
regUserIP       dw      ?
regUserFL       dw      ?
regUserAX       dw      ?
regUserDS       dw      ?
regUserES       dw      ?
pfnReturnAddr   dw      ?

Int28Count      dw      -1      ;Count of idle Int 28h's not reflected to RM

;
; Far pointer to the user's mouse callback function.

        public  lpfnUserMouseHandler

lpfnUserMouseHandler dd 0       ;Entry point to the users mouse handler
cbMouseState    dw      0       ;size of mouse state buffer in bytes


; Far pointer to PS/2 Pointing device handler address

        public  lpfnUserPointingHandler

lpfnUserPointingHandler dd      0       ;Sel:Off to user's handler

        align   2

if DEBUG
        extrn   StackGuard:WORD
endif
        extrn   pbReflStack:WORD
        extrn   bReflStack:WORD
;
; This buffer contains the original real mode interrupt vectors.
ifdef   NEC_98
        public  rglpfnRmISR
endif   ;NEC_98

        align   2
rglpfnRmISR     dd  256 dup (?)

; PMFaultVector is a table of selector:offsets for routines to process
; protected mode processor faults/traps/exceptions.  If we don't handle
; the exception as an exception, we vector it through PMReservedEntryVector.

FltRtn  macro  off
        dw      DXPMCODE:off
        dw      0
        dw      SEL_DXPMCODE or STD_RING
        dw      0
        endm
        public  PMFaultVector

        align   4

PMFaultVector   label   DWORD
        FltRtn  PMFaultEntryVector+5*0h      ; int 0
        FltRtn  PMFaultEntryVector+5*1h      ; int 1
        FltRtn  PMFaultEntryVector+5*2h      ; int 2
        FltRtn  PMFaultEntryVector+5*3h      ; int 3
        FltRtn  PMFaultEntryVector+5*4h      ; int 4
        FltRtn  PMFaultEntryVector+5*5h      ; int 5
        FltRtn  PMFaultEntryVector+5*6h      ; int 6
        FltRtn  PMFaultEntryVector+5*7h      ; int 7
        FltRtn  PMFaultEntryVector+5*8h      ; int 8
        FltRtn  PMFaultEntryVector+5*9h      ; int 9
        FltRtn  PMFaultEntryVector+5*0Ah     ; int a
        FltRtn  PMFaultEntryVector+5*0Bh     ; int b
        FltRtn  PMFaultEntryVector+5*0Ch     ; int c
        FltRtn  PMFaultEntryVector+5*0Dh     ; int d
        FltRtn  PMFaultEntryVector+5*0Eh     ; int e
        FltRtn  PMFaultEntryVector+5*0Fh     ; int f
        FltRtn  PMFaultEntryVector+5*10h     ; int 10h
        FltRtn  PMFaultEntryVector+5*11h     ; int 11h
        FltRtn  PMFaultEntryVector+5*12h     ; int 12h
        FltRtn  PMFaultEntryVector+5*13h     ; int 13h
        FltRtn  PMFaultEntryVector+5*14h     ; int 14h
        FltRtn  PMFaultEntryVector+5*15h     ; int 15h
        FltRtn  PMFaultEntryVector+5*16h     ; int 16h
        FltRtn  PMFaultEntryVector+5*17h     ; int 17h
        FltRtn  PMFaultEntryVector+5*18h     ; int 18h
        FltRtn  PMFaultEntryVector+5*19h     ; int 19h
        FltRtn  PMFaultEntryVector+5*1Ah     ; int 1ah
        FltRtn  PMFaultEntryVector+5*1Bh     ; int 1bh
        FltRtn  PMFaultEntryVector+5*1Ch     ; int 1ch
        FltRtn  PMFaultEntryVector+5*1Dh     ; int 1Dh
        FltRtn  PMFaultEntryVector+5*1Eh     ; int 1Eh
        FltRtn  PMFaultEntryVector+5*1Fh     ; int 1Fh


        extrn   npEHStackLimit:word
        extrn   npEHStacklet:word
ifdef      NEC_98
        extrn   fPCH98:BYTE
endif   ;NEC_98
IFDEF WOW
        public Wow16BitHandlers
Wow16BitHandlers        dw      256 dup (0,0)

ENDIF

DXDATA  ends


DXSTACK segment

        public      rgw0Stack, rgw2FStack

            dw      64 dup (?)          ; INT 2Fh handler stack

rgw2FStack  label   word

            dw      64 dup (?)          ; DOSX Ring -> Ring 0 transition stack
;
; Interrupts in the range 0-1fh cause a ring transition and leave
; an outer ring IRET frame right here.
;
Ring0_EH_DS             dw      ?       ; place to put user DS
Ring0_EH_AX             dw      ?       ; place to put user AX
Ring0_EH_BX             dw      ?       ; place to put user BX
Ring0_EH_CX             dw      ?       ; place to put user CX
Ring0_EH_BP             dw      ?       ; place to put user BP
Ring0_EH_PEC            dw      ?       ; lsw of error code for 386 page fault
                                ; also near return to PMFaultEntryVector
Ring0_EH_EC             dw      ?       ; error code passed to EH
Ring0_EH_IP             dw      ?       ; interrupted code IP
Ring0_EH_EIP            dw      ?       ; high half eip
Ring0_EH_CS             dw      ?       ; interrupted code CS
                        dw      ?       ; high half of cs
Ring0_EH_Flags  dw      ?       ; interrupted code flags
Ring0_EH_EFlags         dw      ?       ; high half of flags
Ring0_EH_SP             dw      ?       ; interrupted code SP
Rin0_EH_ESP             dw      ?       ; high half of esp
Ring0_EH_SS             dw      ?       ; interrupted code SS
                        dw      ?       ; high half of ss
rgw0Stack   label   word

                dw      64 dup (?)      ; stack for switching to ring0
        public ResetStack
ResetStack     label word
ifdef WOW_x86
                dw      64 dup (?)      ; wow stack for initial int field
        public rgwWowStack
rgwWowStack     label word
endif

DXSTACK ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   selDgroup:WORD

DXCODE  ends

DXPMCODE    segment

        extrn   selDgroupPM:WORD
        extrn   segDXCodePM:WORD
        extrn   RZCall:NEAR
        extrn   segDXDataPM:WORD

DXPMCODE    ends

; -------------------------------------------------------
        page
        subttl  Protected Mode Interrupt Reflector
; -------------------------------------------------------
;       PROTECTED MODE INTERRUPT REFLECTOR
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE
; -------------------------------------------------------
;   PMIntrEntryVector   -- This table contains a vector of
;       near jump instructions to the protected mode interrupt
;       reflector.  The protected mode interrupt descriptor
;       table is initialized so that all interrupts jump to
;       locations in this table, which transfers control to
;       the interrupt reflection code for reflecting the
;       interrupt to real mode.

StartBopTable macro
        ?intr = 0
        endm

PMIntrBop  macro
        DPMIBOP ReflectIntrToV86
        db      ?intr
        ?intr = ?intr+1
        endm

        public      PMIntrEntryVector

PMIntrEntryVector:

        StartBopTable
        rept    256
        PMIntrBop
        endm


FaultBop  macro
        DPMIBOP DpmiUnhandledException
        db      ?intr
        ?intr = ?intr+1
        endm

        public  PMFaultEntryVector

; -------------------------------------------------------
;   PMFaultEntryVector   -- This table contains a vector of
;       near jump instructions to the protected mode fault
;       analyzer.
;
PMFaultEntryVector:

        StartBopTable
        rept    32
        FaultBop
        endm

        assume ds:nothing,es:nothing,ss:nothing

        public  PMFaultHandlerIRET
PMFaultHandlerIRET:
        DPMIBOP FaultHandlerIret

        public  PMFaultHandlerIRETD
PMFaultHandlerIRETD:
        DPMIBOP FaultHandlerIretd

        public  PMIntHandlerIRET
PMIntHandlerIRET:
        DPMIBOP IntHandlerIret

        public  PMIntHandlerIRETD
PMIntHandlerIRETD:
        DPMIBOP IntHandlerIretd

        public  PMDosxIret
PMDosxIret:
        iret

        public  PMDosxIretd
PMDosxIretd:
        db      66h
        iret

        public  HungAppExit
HungAppExit:
        mov     ax,4CFFh
        int     21h

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Real Mode Interrupt Reflector
        page
; -------------------------------------------------------
;           REAL MODE INTERRUPT REFLECTOR
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE
; -------------------------------------------------------
;   RMIntrEntryVector   -- This table contains a vector of
;       near jump instructions to the real mode interrupt
;       reflector.  Real mode interrupts that have been hooked
;       by the protected mode application have their vector
;       set to entry the real mode reflector through this table.

        public RMtoPMReflector
RMtoPMReflector:
        DPMIBOP ReflectIntrToPM

        public  RMCallBackBop
RMCallBackBop proc far
        DPMIBOP RMCallBackCall
        ret                             ;finished!

RMCallBackBop endp
DXCODE  ends

; -------------------------------------------------------
        subttl  INT 24h Critical Error Mapper
        page
; -------------------------------------------------------
;               DOS CRITICAL ERROR MAPPER
; -------------------------------------------------------

DXCODE segment

; -------------------------------------------------------
; RMDefaultInt24Handler -- Default action for a DOS critical
;                          error is to fail the call.
;
        public  RMDefaultInt24Handler
RMDefaultInt24Handler   proc far
        mov     al,3
        iret
RMDefaultInt24Handler   endp

DXCODE ends

; -------------------------------------------------------
        subttl  INT 28h Idle Handler
        page
; -------------------------------------------------------
;                INT 28H IDLE HANDLER
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntr28 -- Protected mode handler for Idle Int 28h calls.
;       The purpose of this routine is simply to cut down on the
;       number of protected mode to real mode switches by ignoring
;       many of the Int 28h idle calls made by the Windows PM
;       kernel.

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntr28

PMIntr28        proc    near


        cld
        push    ds                              ;address our DGROUP
        mov     ds,selDgroupPM
        assume  ds:DGROUP

        cmp     Int28Filter,0                   ;are we passing any through?
        jz      @f

        inc     Int28Count                      ;should this one be reflected?
        jz      i28_reflect
@@:
        pop     ds
        iret                                    ;  no, just ignore it

i28_reflect:                                    ;  yes, reset count and
        push    ax                              ;    reflecto to real mode
        mov     ax,Int28Filter
        neg     ax
        mov     Int28Count,ax
        pop     ax
        pop     ds
        assume  ds:NOTHING

        jmp     PMIntrEntryVector + 5*28h

PMIntr28        endp

; -------------------------------------------------------
;   PMIntr31 -- Service routine for the Protect Mode INT 31h
;               services.  These functions duplicate the
;               Windows/386 VMM INT 31h services for protected
;               mode applications.  They were implemented to
;               support a protect mode version of Windows/286.
;
;   Input:  Various registers
;   Output: Various registers
;   Errors:
;   Uses:   All registers preserved, other than return values

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntr31

PMIntr31        proc    near

        push    ds
        push    ax
        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax
        assume  ds:DGROUP
        pop     ax

        FBOP    BOP_DPMI,Int31Entry,FastBop
        int     3
;       This BOP does an implicit IRET

PMIntr31        endp


; -------------------------------------------------------
        subttl  Ignore Interrupt Handlers
        page
; -------------------------------------------------------
;             IGNORE INTERRUPT HANDLER
; -------------------------------------------------------

;   PMIntrIgnore -- Service routine for protected mode interrupts
;       that should be ignored, and not reflected to real mode.
;       Currently used for:
;
;                   Int 30h - used to be Win/386 Virtualize I/O, now
;                             unused but no int handler in real mode
;                   Int 41h - Wdeb386 interface, no int handler in
;                             real mode

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrIgnore

PMIntrIgnore    proc    near

        iret

PMIntrIgnore    endp

; -------------------------------------------------------

        public PMIntr19
PMIntr19        proc    near

        push    offset DXPMCODE:Reboot
        call    RZCall

bpRebootIDT     df      0

Reboot:
        mov     ax,40h
        mov     es,ax
        mov     word ptr es:[0072h],1234h
        lidt    bpRebootIDT
        int     3

PMIntr19        endp

DXPMCODE ends

; -------------------------------------------------------
        subttl  XMS Driver Interface
        page
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   XMScontrol - This function implements a protected mode
;       interface to a real mode XMS driver.  Unlike other
;       routines in this module, this routine is called by
;       the user, not invoked via an INT instruction.
;
;   Input:  User's regs for XMS driver
;   Output: regs from XMS driver
;   Uses:   none

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  XMScontrol

XMScontrol  proc  far

        jmp     short XMSentry          ;'standard' XMS control function
        nop                             ;  just to be consistant
        nop
        nop

XMSentry:

; Modify the stack so it looks like we got here via an INT (except that
; we may still have interrupts enabled)

        pushf
        cld

        push    bp
        mov     bp,sp                   ;bp -> [BP] [FL] [IP] [CS]
        push    ax
        push    bx

        mov     ax,[bp+4]
        mov     bx,[bp+6]
        xchg    ax,[bp+2]
        mov     [bp+4],bx
        mov     [bp+6],ax               ;bp -> [BP] [IP] [CS] [FL]
        pop     bx
        pop     ax
        pop     bp

; We don't support XMS function 0Bh (Move Extended Memory Block) because
; it requires mapping of data between hi/low memory.  Maybe someday...

        cmp     ah,0Bh
        jnz     xms_2
xms_deny:
        xor     ax,ax                   ;if function 0Bh, return failure
        mov     bl,80h                  ;  (ax = 0, bl = 80h-not implemented)
        jmp     short XMSret
xms_2:

; We are not really an Int handler, but close enough...

        call    EnterIntHandler         ;build an interrupt stack frame
        assume  ds:DGROUP,es:DGROUP     ;  also sets up addressability

        SwitchToRealMode

        pop     es                              ;load regs for driver
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        npopf

        call    lpfnXMSFunc                     ;call real mode driver

        pushf                                  ;rebuild stack frame
        FCLI
        cld
        pusha
        push    ds
        push    es

        mov     bp,sp                           ;restore stack frame pointer

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP

        call    LeaveIntHandler
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

XMSret:
        riret

XMScontrol  endp

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Special Interrupt Handler Routines
        page
; -------------------------------------------------------
;
;   The following sets of routines handle interrupts that
;   are function call interfaces and require special servicing
;   by the Dos Extender.  These interrupts are such things as
;   the mouse driver function call interrupt, various PC BIOS
;   function call interrupts, etc.  Note that INT 21h (the Dos
;   function call interrupt) is not handled here.  These
;   interrupts typically require that register values be modified
;   and parameter data be copied between real mode memory and
;   extended memory.  The following conventions are used for these
;   interrupt function handler routines.
;
;   A stack is allocated from the interrupt reflector stack for these
;   routines to use.  This allows nested servicing of interrupts.
;   A stack frame is built in the allocated stack which contains the
;   following information:
;           original caller's stack address
;           caller's original flags and general registers (in pusha form)
;           caller's original segment registers (DS & ES)
;           flags and general registers to be passed to interrupt routine
;               (initially the same as caller's original values)
;           segment registers (DS & ES) to be passed to interrupt routine
;               (initially set to the Dos Extender data segment address)
;   This stack frame is built by the routine EnterIntHandler, and its
;   format is defined by the structure INTRSTACK.  The stack frame is
;   destroyed and the processor registers set up for return to the user
;   by the function LeaveIntHandler.
;
;   For each interrupt, there is an entry function and an exit function.
;   The entry function performs any modifications to parameter values and
;   data buffering necessary before the interrupt service routine is called.
;   The exit function performs any data buffering and register value
;   modifications after return from the interrupt service routine.
;
;   There are two sets of general registers and two sets of segment
;   registers (DS & ES) on the stack frame.  One set of register values
;   has member names of the form intUserXX.  The values in these stack
;   frame members will be passed to the interrupt service routine when
;   it is called, and will be loaded with the register values returned
;   by the interrupt service routine.  The other set of registers values
;   has member names of the form pmUserXX.  These stack frame members
;   contain the original values in the registers on entry from the
;   user program that called the interrupt.
;
;   When we return to the original caller, we want to pass back the
;   general registers as returned by the interrupt routine (and possibly
;   modified by the exit handler), and the same segment registers as
;   on entry, unless the interrupt routine returns a value in a segment
;   register. (in this case, there must be some code in the exit routine
;   to handle this).  This means that when we return to the caller, we
;   return the general register values from the intUserXX set of stack
;   frame members, but we return the segment registers from the pmUserXX
;   set of frame members.  By doing it this way, we don't have to do
;   any work for the case where the interrupt subfuntion doesn't require
;   any parameter manipulation.  NOTE however, this means that when
;   manipulating register values to be returned to the user, the segment
;   registers are treated opposite to the way the general registers are
;   treated.  For general registers, to return a value to the user,
;   store it in a intUserXX stack frame member.  To return a segment
;   value to the user, store it in a pmUserXX stack frame member.
;
; -------------------------------------------------------
        subttl  BIOS Video Interrupt (Int 10h) Service Routine
        page
; -------------------------------------------------------
;       BIOS VIDEO INTERRUPT (INT 10h) SERVICE ROUTINE
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntrVideo - Entry point into interrupt reflector code
;       for IBM PC Bios video (int 10h) calls.
;
;   Input:  normal registers for Bios calls
;   Output: normal register returns for Bios calls
;   Errors: normal Bios errors
;   Uses:   as per Bios calls

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrVideo

PMIntrVideo:

ifdef      NEC_98
        cmp     ah,40h
        jb      CRT_bios
        cmp     ah,4Fh                  ;4Bh-4Fh = Reserve
        ja      CRT_bios
        jmp     PMIntrGBIO

CRT_bios:
        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values

        call    IntEntryVideo
@@:
; Execute the interrupt service routine
        SwitchToRealMode
        assume  ss:DGROUP
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING
        popa
        call    rglpfnRmISR[4*18h]  ;execute the real mode interrupt routine
        pushf
        cli
        cld
        pusha
        push    ds
        push    es
        mov     bp,sp               ;restore stack frame pointer
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP
;
; Perform fixups on the return register values.
        mov     ax,[bp].pmUserAX    ;get original function code

;;      test    fPCH98,0FFh             
;;      jz      NotNPCVideoExit         ;for PC-H98 modelxx
;;      call    IntExitVideoNPC         ;       "        
;;      jmp     @f                      ;       "        
;;NotNPCVideoExit:                      ;       "       
        call    IntExitVideo
@@:
;
; And return to the original caller.
        call    LeaveIntHandler

        iret

;/////////////////////////////////////////////////////////////////////////
;       Nmode GRAPH BIOS
;/////////////////////////////////////////////////////////////////////////
; -------------------------------------------------------
;       PMIntrGBIO
;--------------------------------------------------------


        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrGBIO

PMIntrGBIO:

        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values            

        push    ax                      
        mov     ax,[bp].pmUserDS        
        call    GetSegmentAddress       
        shr     dx,4                    
        shl     bx,12                   
        or      bx,dx                   ;bx now = seg of parent psp
        mov     [bp].intUserDS,bx       
        pop     ax                      
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*18h]  ;execute the real mode interrupt routine 
        pushf                                           
        cli
        cld
        pusha
        push    ds
        push    es
        
        mov     ax,ss
        mov     ds,ax
        mov     es,ax
        
        mov     bp,sp               ;restore stack frame pointer        
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
        mov     ax,[bp].pmUserAX    ;get original function code         
        push    ax                                      
        mov     ax,[bp].pmUserDS                        
        mov     [bp].intUserDS,ax                       
        pop     ax                                      
;
; And return to the original caller.                     
        call    LeaveIntHandler                         
        iret                                            
else    ;!NEC_98
        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values
        call    IntEntryVideo
;
; Execute the interrupt service routine
        SwitchToRealMode
        assume  ss:DGROUP
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING
        popa
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     word ptr [bp + 6],offset piv_10
        mov     ax,es:[10h*4]
        mov     [bp + 2],ax
        mov     ax,es:[10h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

piv_10: pushf
        FCLI
        cld
        pusha
        push    ds
        push    es
        mov     bp,sp               ;restore stack frame pointer
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP
;
; Perform fixups on the return register values.
        mov     ax,[bp].pmUserAX    ;get original function code
        call    IntExitVideo
;
; And return to the original caller.
        call    LeaveIntHandler

        riret
endif   ;!NEC_98

; -------------------------------------------------------
;   IntEntryVideo   -- This routine performs any register
;       fixups and data copying needed on entry to the
;       PC BIOS video interrupt (Int 10h)
;
;   Input:  register values on stack frame
;   Output: register values on stack frame
;   Errors: none
;   Uses:   any registers modified,
;           possibly modifies buffers rgbXfrBuf0 or rgbXfrBuf1

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntEntryVideo

IntEntryVideo:

ifdef      NEC_98
;video mode

        cmp     ah,0Fh                                  
        jnz     ienv10                                  
        mov     cx,16                                   
        jmp     ienv70                                  
ienv10:                                                 
        cmp     ah,14h                                  
        jnz     ienv20                                  
        jmp     ienv80                                  
ienv20:                                                 
        cmp     ah,1Fh                                  
        jnz     ienv30                                  
        jmp     ienv110                 
ienv30:                                 
        cmp     ah,1Ah                  
        jnz     ienv40                  
        test    fPCH98,0FFh             
        jnz     H98_FontWrite_N         
        mov     cx,34                   
        jmp     ienv70                  
ienv40:                                 
        cmp     ah,20h                  
        jnz     ienv90                  
        test    fPCH98,0FFh             
        jnz     @f                      
        mov     cx,72                   
        jmp     ienv100                 

@@:
        jmp     H98_FontWrite_H 

ienv70:
        push    ds 
        mov     si,[bp].pmUserCX        ;offset address  
        mov     ds,[bp].pmUserBX        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
ienv80:                                                 

        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserBX,ax       ;segment address
        pop     ax                                      

        mov     [bp].intUserCX,offset DGROUP:rgbXfrBuf1 
ienv90:                                                 
        ret                                             

ienv100:                                                
        push    ds                                      
        mov     si,[bp].pmUserBX        ;offset address 
        mov     ds,[bp].pmUserDS        ;segment address
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
ienv110:                                                

        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserDS,ax       ;segment address

        pop     ax                                      

        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 
ienv120:                                                
        ret                                             

H98_FontWrite_N:                                        

        cmp     dx,7601h                                
        jb      @f                                      
        cmp     dx,767Fh                                
        jna     WUSKZEN                                 
        cmp     dx,7701h                                
        jb      @f                                      
        cmp     dx,777Fh                                
        jna     WUSKZEN                                 
        cmp     dx,7801h                                
        jb      @f                                      
        cmp     dx,783Fh                                
;;;;;;;;        ja      ienv35                          
        jna     WUSKZEN                 
        jmp     ienv35                  
        
WUSKZEN:
        mov     cx,34                                  
        jmp     ienv70                                 

@@: 
        jmp     ienv40 

ienv35:
        cmp     dx,7840h  
        jb      @b        
        cmp     dx,787Fh  
        jna     WUSKHAN   
        cmp     dx,7D01h  
        jb      @b        
        cmp     dx,7D7Fh  
        jna     WUSKHAN   
        cmp     dx,7E01h  
        jb      @b        
        cmp     dx,7E7Fh  
;;;;;;;;        ja      @b
        jna     WUSKHAN   
        jmp     @b        
WUSKHAN:                  
        mov     cx,18     
        jmp     ienv70    

H98_FontWrite_H:      

        cmp     dx,7601h    
        jb      @f          
        cmp     dx,767Fh    
        jna     HWUSKZEN    
        cmp     dx,7701h    
        jb      @f          
        cmp     dx,777Fh    
        jna     HWUSKZEN    
        cmp     dx,7801h    
        jb      @f          
        cmp     dx,783Fh    
;;;;;;;;        ja      @f  
        jna     HWUSKZEN    
        jmp     ienv45      
HWUSKZEN:                   
;;;;;;;;        mov     cx,74 
        mov     cx,72         
        jmp     ienv100       

@@: 
        jmp     ienv90  

ienv45: 
        cmp     dx,7840h  
        jb      @f        
        cmp     dx,787Fh  
        jna     HWUSKHAN  
        cmp     dx,7D01h  
        jb      @f        
        cmp     dx,7D7Fh  
        jna     HWUSKHAN  
        cmp     dx,7E01h  
        jb      @f        
        cmp     dx,7E7Fh  
;;;;;;;;        ja      @f
        jna     HWUSKHAN  
        jmp     @f        
HWUSKHAN:
;;;;;;;;        mov     cx,50                           
        mov     cx,48                                   
        jmp     ienv100                 
@@:                                     
        ret                             
else    ;!NEC_98
        cmp     ah,10h
        jnz     ienv20
;
; Video palette control function.  Check for subfunctions that require
; special actions.
ienv10: cmp     al,2            ;update all palette registers?
        jnz     @F
        mov     cx,17           ;palette data is 17 bytes long
        jmp     short ienv70    ;go copy the data
;
@@:     cmp     al,9            ;read all palette registers
        jz      ienv72
;
        cmp     al,12h          ;update video DAC color registers
        jnz     @F
        mov     cx,[bp].pmUserCX    ;count of table entries is in caller CX
        add     cx,cx               ;each entry is 3 bytes long
        add     cx,[bp].pmUserCX
        jmp     short ienv70        ;go copy the data down

@@:     cmp     al,17h          ;read a block of video DAC registers
        jz      ienv72
;
        jmp     short ienv90
;
;
ienv20: cmp     ah,11h
        jnz     ienv30
;
; Character generator interface function.
;   NOTE: a number of subfunctions of function 11h need to have munging
;       and data buffering performed.  However, function 30h is the only
;       one used by Codeview, so this is the only one currently implemented.
;       For this one, nothing needs to be done on entry, only on exit.
        jmp     short ienv90
;
;
ienv30: cmp     ah,1Bh
        jnz     ienv40
;
; Video BIOS functionality/state information.
; On entry, we need to fix up ES:DI to point to our buffer.
        mov     [bp].intUserDI,offset DGROUP:rgbXfrBuf0
        jmp     short ienv90
;
;
ienv40:
        jmp     short ienv90
;
; Copy the buffer from the user ES:DX to our transfer buffer and set
; the value to DX passed to the interrupt routine to point to our buffer.
ienv70: cld
        jcxz    ienv90
        push    ds
        mov     si,[bp].pmUserDX
        mov     ds,[bp].pmUserES
        mov     di,offset DGROUP:rgbXfrBuf1
        cld
        rep     movsb
        pop     ds
;
ienv72: mov     [bp].intUserDX,offset DGROUP:rgbXfrBuf1
        jmp     short ienv90

;
; All done
ienv90:
        ret
endif   ;!NEC_98

; -------------------------------------------------------
;   IntExitVideo:   This routine performs any register
;       fixups and data copying needed on exit from the
;       PC BIOS video interrupt (Int 10h).
;
;   Input:  register values on stack frame
;   Output: register values on stack frame
;   Errors: none
;   Uses:   any registers modified
;           possibly modifies buffers rgbXfrBuf0 or rgbXfrBuf1

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntExitVideo

IntExitVideo:

ifdef      NEC_98
;video mode

        cmp     ah,0Fh                                  
        jnz     iexv10                                  
        jmp     iexv80                                  
iexv10:                                                 
        cmp     ah,14h                                  
        jnz     iexv20                                  
        cmp     dh,00h                                  
        jnz     iexv11                                  
        mov     cx,10                                   
        jmp     iexv70                                  
iexv11:                                                 
        cmp     dh,80h          ;ANK(7*13)              
        jnz     iexv12                                  
        mov     cx,18                                   
        jmp     iexv70                                  
iexv12:                                                 
        test    fPCH98,0FFh             
        jnz     @f                      
        cmp     dx,2920h                
        jb      iexv13                  
        cmp     dx,297dh                
        ja      iexvhan1                
        mov     cx,18                   
        jmp     iexv70                  

iexvhan1:                                               
        cmp     dx,2a20h                                
        jb      iexv13                                  
        cmp     dx,2a5fh                                
        ja      iexv13                                  
        mov     cx,18                                   
        jmp     iexv70                                  

@@:                                                     
        jmp     H98_FontRead_N                          

iexv13:                                                 
        mov     cx,34                                   
        jmp     iexv70                                  

iexv20:                                                 
        cmp     ah,1Fh                                  
        jnz     iexv30                                  
        cmp     dh,00h                                  
        jnz     iexv21                                  
        mov     cx,48                                   
        jmp     iexv100         
iexv21:                         
        test    fPCH98,0FFh     
        jnz     @f              
        cmp     dx,2920h        
        jb      Hmode_han1      
        cmp     dx,297dh        
        ja      Hmode_han1                              
        mov     cx,48                                   
        jmp     iexv100         

Hmode_han1:
        cmp     dx,2a20h                                
        jb      iexv22                                  
        cmp     dx,2a5fh                                
        ja      iexv22                                  
        mov     cx,48                                   
        jmp     iexv100         

@@:                                                     
        jmp     H98_FontRead_H                          

iexv22:                                                 
        mov     cx,72           
        jmp     iexv100         
        
iexv30: 
        cmp     ah,1Ah          
        jnz     iexv40          
        jmp     iexv80          
        
iexv40: 
        cmp     ah,20h          
        jnz     iexv90          
        jmp     iexv110         

iexv70: 

        cld         
        push    es  
        mov     di,[bp].pmUserCX  
        mov     es,[bp].pmUserBX  
        mov     si,offset DGROUP:rgbXfrBuf1  
        rep     movsb                        
        pop     es                           
;
; Restore the caller's CX 
iexv80:                   
        push    ax        
        mov     ax,[bp].pmUserBX        ;BX regster restor
        mov     [bp].intUserBX,ax        
;------------------------------------------------------------
        mov     ax,[bp].pmUserCX         
        mov     [bp].intUserCX,ax        
        pop     ax                       
iexv90:                                  
        ret                              

iexv100: 

        cld     
        push    es   
        mov     di,[bp].pmUserBX  
        mov     es,[bp].pmUserDS  
        mov     si,offset DGROUP:rgbXfrBuf1   
        rep     movsb                         
        pop     es                            
;
; Restore the caller's CX  
iexv110:                   
        push    ax         
        mov     ax,[bp].pmUserDS        ;BX regster restor
        mov     [bp].intUserDS,ax        
;------------------------------------------------------------
        mov     ax,[bp].pmUserBX                        
        mov     [bp].intUserBX,ax                       
        pop     ax                                      
iexv120:                                                
        ret                                             

H98_FontRead_N:                                         

        cmp     dx,2920h                
        jb      iexvN15         
        cmp     dx,297fh        
        jna     iexvNhan        
        cmp     dx,2a20h        
        jb      iexvN15         
        cmp     dx,2a7fh        
        jna     iexvNhan        
        cmp     dx,2b20h        
        jb      iexvN15         
        cmp     dx,2b7fh        
        jna     iexvNhan        
        cmp     dx,7840h        
        jb      iexvN15         
        cmp     dx,787fh        
        jna     iexvNhan        
        cmp     dx,7d01h        
        jb      iexvN15         
        cmp     dx,7d7fh        
        jna     iexvNhan        
        cmp     dx,7e01h        
        jb      iexvN15         
        cmp     dx,7e7fh        
        ja      iexvN15         
iexvNhan:                       
        mov     cx,18           ;16byte+2=18 ;        jmp     iexv70

iexvN15:                                                
        mov     cx,34           ;32byte+2=34            
        jmp     iexv70           

H98_FontRead_H:                                         

        cmp     dx,2920h                
        jb      iexvN25         
        cmp     dx,297fh        
        jna     HiexvNhan       
        cmp     dx,2a20h        
        jb      iexvN25         
        cmp     dx,2a7fh        
        jna     HiexvNhan       
        cmp     dx,2b20h        
        jb      iexvN25         
        cmp     dx,2b7fh        
        jna     HiexvNhan       
        cmp     dx,7840h        
        jb      iexvN25         
        cmp     dx,787fh        
        jna     HiexvNhan       
        cmp     dx,7d01h        
        jb      iexvN25         
        cmp     dx,7d7fh        
        jna     HiexvNhan       
        cmp     dx,7e01h        
        jb      iexvN25         
        cmp     dx,7e7fh        
        ja      iexvN25         
HiexvNhan:                      
;;;;;;;;        mov     cx,50           ;48byte+2=50 
        mov     cx,48           ;48byte 
;;;;;;;;        jmp     iexv70   
        jmp     iexv100          

iexvN25:
;;;;;;;;        mov     cx,74           ;72byte+2=74 
        mov     cx,72           ;72byte
;;;;;;;;        jmp     iexv70                          
        jmp     iexv100                                 
else    ;!NEC_98
        cmp     ah,10h
        jnz     iexv20
;
; Palette control function.
        cmp     al,9            ;read palette data function
        jnz     @F
        mov     cx,17
        jmp     short iexv70
;
@@:     cmp     al,17h          ;read video DAC registers
        jnz     @F
        mov     cx,[bp].pmUserCX    ;each entry in table is 3 bytes long
        add     cx,cx
        add     cx,[bp].pmUserCX
        jmp     short iexv70
;
@@:     jmp     short iexv72
;
;
iexv20: cmp     ah,11h
        jnz     iexv30
;
; Character generator interface function.
;   NOTE: a number of subfunctions of function 11h need to have munging
;       and data buffering performed.  However, function 30h is the only
;       one used by Codeview, so this is the only one currently implemented
        cmp     al,30h
        jnz     @F
        mov     ax,[bp].intUserES   ;get the paragraph address returned by BIOS
        mov     bx,STD_DATA
        call    ParaToLDTSelector   ;get a selector for that address
        mov     [bp].pmUserES,ax    ;store the selector so that it will be
                                    ; returned to the caller
@@:     jmp     short iexv90
;
;
iexv30: cmp     ah,1Bh
        jnz     iexv40
;
; Video BIOS functionality/state information.
; On exit, we need to fix up the pointer at the beginning of the
; data put in our buffer by the BIOS, and then transfer the buffer up
; to the user.
        mov     ax,word ptr rgbXfrBuf0[2]   ;get segment of pointer to
                                            ; 'static functionallity table'
        mov     bx,STD_DATA
        call    ParaToLDTSelector           ;convert paragraph to selector
        mov     word ptr rgbXfrBuf0[2],ax   ;store back into table
        push    es
        mov     si,offset rgbXfrBuf0    ;pointer to our copy of the table
        mov     di,[bp].pmUserDI        ;where the user wants it
        mov     [bp].intUserDi,di       ;restore the DI returned to the user
        mov     es,[bp].pmUserES
        mov     cx,64                   ;the table is 64 bytes long
        cld
        rep     movsb                   ;copy the table to the user's buffer
        pop     es

        jmp     short iexv90
;
;
iexv40:
        jmp     short iexv90

;
; Copy data from our buffer to the caller's buffer pointed to by ES:DX
iexv70: cld
        push    es
        mov     di,[bp].pmUserDX
        mov     es,[bp].pmUserES
        mov     si,offset DGROUP:rgbXfrBuf1
        rep     movsb
        pop     es
;
; Restore the caller's DX
iexv72: mov     ax,[bp].pmUserDX
        mov     [bp].intUserDX,ax
;
; All done
iexv90:
        ret
endif   ;!NEC_98

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  BIOS Misc. Interrupt (Int 15h) Service Routine
        page
; -------------------------------------------------------
;       BIOS MISC. INTERRUPT (INT 15h) SERVICE ROUTINE
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntrMisc  -- Entry point into the interrupt processing code
;       for the BIOS misc functions interrupt (INT 15h).
;
;   Input:  normal registers for Bios calls
;   Output: normal register returns for Bios calls
;   Errors: normal Bios errors
;   Uses:   as per Bios calls

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrMisc

PMIntrMisc:
;
        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values
        call    IntEntryMisc
;
; Execute the interrupt service routine
        SwitchToRealMode
        assume  ss:DGROUP
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING
        popa
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     word ptr [bp + 6],offset pim_10
        mov     ax,es:[15h*4]
        mov     [bp + 2],ax
        mov     ax,es:[15h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

pim_10: pushf
        FCLI
        cld
        pusha
        push    ds
        push    es
        mov     bp,sp               ;restore stack frame pointer
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP
;
; Perform fixups on the return register values.
        mov     ax,[bp].pmUserAX    ;get original function code
        call    IntExitMisc
;
; And return to the original caller.
        call    LeaveIntHandler
        riret

; -------------------------------------------------------
;           MISC INTERRUPT SUPPORT ROUTINES
; -------------------------------------------------------
;
;   IntEntryMisc    -- This function performs data transfer
;       and register translation on entry to the BIOS Misc.
;       functions interrupt. (INT 15h).
;
;   Input:  AX      - BIOS function being performed
;   Output:
;   Errors:
;   Uses:   All registers preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntEntryMisc

IntEntryMisc:

ifdef      NEC_98
        push    cx    
        cmp     ah,90h                          ;SYSTEM BIOS  BLOCK MOVE 
        jnz     iemDMA1                         ;yes = jmp 
        jmp     iem70                                   
iemDMA1:                                                
        cmp     ah,0D5h                         ;DMA BIOS  DMA 
        jnz     iemDMA2                         ;yes = jmp 
        mov     cx,8                            ;DMA_CBIOS 
        jmp     iem70                                   
iemDMA2:                                                
        cmp     ah,0D6h                         ;DMA BIOS  DMA 
        jnz     iemROM1                         ;yes = jmp 
        jmp     iem80                           ;Read JMP 
iemROM1:                                                
        cmp     ah,0D8h                         ;ROM 
        jnz     iemROM2                         ;yes = jmp 
        mov     cx,4                            
        jmp     iem70                           

iemROM2:                                                
        cmp     ah,0D9h                         ;ROM
        jnz     iem90                           ;yes = jmp 
        mov     cx,8                            ;ROM BIOS
iem70:                                           
        push    ds                               
        mov     si,[bp].pmUserBX        ;offset address
        mov     ds,[bp].pmUserES        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
iem80:                                                  
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 
iem90:                                                  
        pop     cx                                      
        ret                                             
else    ;!NEC_98
; Map requests to set the PS/2 Pointing Device Handler Address

        cmp     ax,0C207h               ;PS/2 Set Pointing Device Handler adr?
        jnz     iem90

        mov     ax,[bp].pmUserBX                    ;User's ES:BX -> handler
        mov     word ptr lpfnUserPointingHandler,ax
        mov     ax,[bp].pmUserES
        mov     word ptr [lpfnUserPointingHandler+2],ax

        mov     ax,segDXCodePM          ;pass BIOS address of our handler
        mov     [bp].intUserES,ax
        mov     ax,offset PointDeviceHandler
        mov     [bp].intUserBX,ax

iem90:
        ret
endif   ;!NEC_98

; -------------------------------------------------------
;   IntExitMisc     -- This function performs data transfer
;       and register translation on exit from the BIOS Misc.
;       Functions interrupt (INT 15h).
;
;   Input:  AX      - BIOS function being performed
;   Output:
;   Errors:
;   Uses:   All registers preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntExitMisc

IntExitMisc:
ifdef      NEC_98                                           
        push    cx                                      
        cmp     ah,90h                          ;SYSTEM BIOS  BLOCK MOVE 
        jnz     ixmDMA1                         ;yes = jmp 
        jmp     ixm70                                   
ixmDMA1:                                                
        cmp     ah,0D5h                         ;DMA BIOS
        jnz     ixmDMA2                         ;yes = jmp
        jmp     ixm70                                   
ixmDMA2:                                                
        cmp     ah,0D6h                         ;DMA BIOS  DMA
        jnz     ixmROM1                         ;yes = jmp 
        mov     cx,16                                   
        jmp     ixm80                                   
ixmROM1:                                                
        cmp     ah,0D8h                         ;    ROM
        jnz     ixmROM2                         ;yes = jmp
        jmp     ixm70                                   
ixmROM2:                                                
        cmp     ah,0D9h                         ;    ROM
        jnz     ixm90                                   
ixm70:                                                  
        cld                                             
        push    es                                      
        mov     di,[bp].pmUserBX                        
        mov     es,[bp].pmUserES                        
        mov     si,offset DGROUP:rgbXfrBuf1             
        rep     movsb                                   
        pop     es                                      
;
; Restore the caller's ES,BX                             
ixm80:                                                  
        push    ax                                      
        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
        mov     ax,[bp].pmUserBX                        
        mov     [bp].intUserBX,ax                       
        pop     ax                                      
ixm90:                                                  
        pop     cx                                      
        ret                                             
else    ;!NEC_98
        push    ax
        push    bx
        push    cx
        push    dx
;
; Check for function 0C0h - Return System Configuration Parameters
        cmp     ah,0C0h
        jnz     ixmi30
        test    [bp].intUserFL,1    ;check if the bios call returned an error
        jnz     ixmi90          ;(carry flag set in returned flags)
;
; The BIOS call succeeded.  This means that ES:BX points to a configuration
; vector.  We need to fix up the segment to be a selector.
        mov     dx,[bp].intUserES
        cmp     dx,0F000h       ;does it point to normal BIOS segment
        jnz     ixmi22
        mov     ax,SEL_BIOSCODE or STD_RING
        jmp     short ixmi24

ixmi22: call    ParaToLinear
        mov     cx,0FFFFh
        mov     ax,SEL_USERSCR or STD_TBL_RING
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>
ixmi24: mov     [bp].pmUserES,ax
        jmp     short ixmi90

; Chack for function 0C207h - PS/2 Set Pointing Device Handler Address

ixmi30:
        cmp     ax,0C207h
        jne     ixmi90

        mov     ax,[bp].pmUserBX        ;restore user's BX
        mov     [bp].intUserBX,ax

; All done
ixmi90:
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret
endif   ;!NEC_98

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Mouse Function Interrupt (Int 33h) Service Routine
        page
; -------------------------------------------------------
;       MOUSE FUNCTION INTERRUPT (INT 33h) SERVICE ROUTINE
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntrMouse - Entry point into interrupt reflector code
;       for mouse driver (int 33h) calls.
;
;   Input:  normal registers for mouse calls
;   Output: normal register returns for mouse calls
;   Errors: normal mouse errors
;   Uses:   as per mouse calls

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrMouse

PMIntrMouse:
;
        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values
        call    IntEntryMouse
;
; Execute the interrupt service routine
        SwitchToRealMode
        assume  ss:DGROUP
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING
        popa
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     word ptr [bp + 6],offset pimo_10
        mov     ax,es:[33h*4]
        mov     [bp + 2],ax
        mov     ax,es:[33h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

pimo_10: pushf
        FCLI
        cld
        pusha
        push    ds
        push    es
        mov     bp,sp           ;restore stack frame pointer
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP
;
; Perform fixups on the return register values.
        mov     ax,[bp].pmUserAX    ;get original function code
        call    IntExitMouse
;
; And return to the original caller.
        call    LeaveIntHandler
        riret

; -------------------------------------------------------
;               MOUSE SUPPORT ROUTINES
; -------------------------------------------------------

;   IntEntryMouse   -- This function performs data transfer and
;       register translation on entry to mouse driver functions.
;       (INT 33h)
;
;   Input:  AX      - mouse function being performed
;   Output:
;   Errors:
;   Uses: NOTHING

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntEntryMouse

IntEntryMouse:
        cld
        push    ax
        push    cx
        push    si
        push    di
;
        cmp     al,9    ;Set graphics cursor block?
        jnz     ment10
;
; The user is setting a graphics cursor.  We need to copy the masks
; down to low memory so that the mouse driver can get at them and then
; fix up the pointer in DX.
        mov     cx,32
        jmp     short ment92
;
; Mouse interrupt handler establishment
ment10: cmp     al,12   ;Set user defined interrupt subroutine ?
        jnz     ment20
;
; This command has the effect of causing a call to the address es:ds
; Whenever an event of one of the types specified by the mask in cx.
; The address es:dx must be saved in lpfnUserMouseHandler and the
; real mode address of MouseInterruptHandler substituted.
        mov     ax,[bp].pmUserDX    ; Load users handler offset
        mov     word ptr lpfnUserMouseHandler,ax ; Store for future use
        mov     ax,[bp].pmUserES    ; Load users handler segment value
        mov     word ptr lpfnUserMouseHandler + 2,ax ; Store for future use
        mov     ax,segDXCodePM      ; Load real mode code segment value
        mov     [bp].intUserES,ax   ; Store in real mode es register image
        mov     ax,offset MouseInterruptHandler ; Load handler offset
        mov     [bp].intUserDX,ax   ; Store in real mode dx register image
        jmp     short ment99    ;Return
 ;
ment20: cmp     al,20
        jc      ment99
        jnz     ment30
;
; This is the swap interrupt subroutine function.  Not currently implemented
        jmp     short ment99
;
ment30: cmp     al,22   ;Save mouse driver state?
        jnz     ment40
;
; This is the save mouse driver state function.  We need to pass a pointer
; to the transer buffer down to the mouse driver.
        mov     ax,npXfrBuf1
        mov     [bp].intUserDX,ax
        jmp     short ment99

ment40: cmp     al,23   ;Restore mouse driver state?
        jnz     ment99
;
; This is the restore mouse driver state function.  We need to copy the
; mouse state buffer from the pm user location to the transfer buffer,
; and then pass the pointer to the transfer buffer on to the mouse driver.
        mov     cx,cbMouseState
        jcxz    ment99
;
; Transfer the data pointed to by the user ES:DX to the scratch buffer, and
; fix up the pointer that is passed on to the mouse driver.
ment92: mov     si,[bp].pmUserDX
        mov     di,npXfrBuf1
        mov     [bp].intUserDX,di
        push    ds
        mov     ds,[bp].pmUserES
        cld
        rep     movs word ptr [di],word ptr [si]
        pop     ds
;
ment99: pop     di
        pop     si
        pop     cx
        pop     ax
        ret

; -------------------------------------------------------
;   IntExitMouse    -- This function performs data transfer and
;       register translation on exit from mouse driver functions.
;       (INT 33h)
;
;   Input:  AX      - mouse function being performed
;   Output:
;   Errors:
;   Uses:

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntExitMouse

IntExitMouse:
        cld
        cmp     al,21       ;get state buffer size?
        jnz     mxit20
;
; We need to remember the state buffer size, so that later we will know
; how many bytes to transfer when we do the save/restore state fucntions.
        mov     ax,[bp].intUserBX
        mov     cbMouseState,ax
        return
;
mxit20: cmp     al,22   ;Save mouse driver state?
        jnz     mxit30
;
; We need to restore the original values of ES:DX and transfer the mouse
; state data from the real mode buffer to the user's protected mode buffer.
        mov     cx,cbMouseState
        jcxz    mxit28
        push    es
        mov     si,npXfrBuf1
        mov     di,[bp].pmUserDX
        mov     [bp].intUserDX,di
        mov     es,[bp].pmUserES
        rep     movs byte ptr [di],byte ptr [si]
        pop     es
mxit28: return
;
mxit30: cmp     al,23   ;Restore mouse driver state?
        jnz     mxit99
        mov     ax,[bp].pmUserDX
        mov     [bp].intUserDX,ax
;
mxit99: ret

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  PM Interrupt Support Routines
        page
; -------------------------------------------------------
;           PM INTERRUPT SUPPORT ROUTINES
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   EnterIntHandler     -- This routine will allocate a stack
;       frame on the interrupt reflector stack and make
;       a copy of the registers on the allocated stack.
;
; Note: This routine expects the current stack to contain a near
;       return address and a normal [IP] [CS] [FL] interrupt stack
;       frame.  Don't have anything else on the stack before calling
;       this routine!
;
; Note: This routine disables interrupts, and leaves them disabled.
;       Most callers already have them disabled, so it doesn't
;       really make a difference, except that this routine
;       requires that they be disabled.
;
;   Input:  none
;   Output: stack frame set up
;   Errors: none
;   Uses:   all registers preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  EnterIntHandler

EnterIntHandler proc    near

        FCLI                             ;we really want int's disabled (and
                                        ;  XMScontrol doesn't do that)
        push    ds
        mov     ds,selDgroupPM          ;save user's DS and address our DGROUP
        assume  ds:DGROUP
        pop     regUserDS

        push    bp
        mov     bp,sp                   ;bp -> [BP] [IP] [IP] [CS] [FL]
        push    word ptr [bp+8]
        pop     regUserFL               ;user's flags before doing INT
        pop     bp

        pop     pfnReturnAddr           ;near return to our immediate caller

        mov     regUserSS,ss            ;save caller's stack address
        mov     regUserSP,sp
        ASSERT_REFLSTK_OK
        mov     ss,selDgroupPM          ;switch to interrupt reflector stack
        mov     sp,pbReflStack
        sub     pbReflStack,CB_STKFRAME ;adjust pointer to next stack frame
        FIX_STACK

; Build the stack frame.  The stack frame contains the following:
;   dword & word parameter locations
;   original caller's stack address
;   caller's original flags and general registers (in pusha form)
;   caller's original segment registers (DS & ES)
;   flags and general registers to be passed to interrupt routine
;       (initially the same as caller's original values)
;   segment registers (DS & ES) to be passed to interrupt routine
;       (initially set to the Dos Extender data segment address)
;
; The parameter words and then the caller's original register values go on top.

        sub     sp,8                    ;space for a dd & 2 dw's

        push    regUserSP
        push    regUserSS
        push    regUserFL
        pusha
        push    regUserDS
        push    es

; Now, put all of the general registers, and values for the segment
; registers to be passed to the interrupt service routine.  We pass
; the Dos Extender data segment address to the interrupt routine.

        push    regUserFL
        pusha
        push    segDXDataPM
        push    segDXDataPM

; And we are done.

        mov     bp,sp                   ;set up frame pointer
        mov     es,selDgroupPM
        jmp     pfnReturnAddr           ;return to the caller.

EnterIntHandler endp


; -------------------------------------------------------
;   LeaveIntHandler     -- This routine will restore the user registers,
;       release the stack frame, and restore the original user's stack
;       for exit from an interrupt reflector routine.
;
; Note: Interrupts must be off when this routine is called.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   All registers modified

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  LeaveIntHandler

LeaveIntHandler proc    near

        FCLI
        pop     pfnReturnAddr

; The copy of the register values returned from the interrupt routine
; (and then possibly modified by the exit handler for the particular
; interrupt) are what gets returned to the caller.  We discard the original
; register values saved on entry.  (They were there so that the exit
; routine could refer to them if necessary)

        add     sp,4                ;skip over interrupt service routine's
                                    ; segment register values
        popa                        ;restore general register values
        pop     regUserFL           ;flags returned by interrupt routine
        pop     es                  ;get segment registers from pmUserES
        pop     regUserDS           ; and pmUserDS
        add     sp,18               ;skip over the original user registers
                                    ; and flags
        pop     regUserSS           ;original interrupted routine's stack
        pop     regUserSP
        mov     regUserAX,ax

; Switch back to the original user's stack.

        ASSERT_REFLSTK_OK
        ASSERT_CLI
        CHECK_STACK
        mov     ss,regUserSS
        mov     sp,regUserSP
        add     pbReflStack,CB_STKFRAME
        ASSERT_REFLSTK_OK

; We need to replace the image of the flags in the original int return
; address on the user's stack with the new flags returned from the interrupt
; service routine.

        push    bp
        mov     bp,sp           ;stack -> BP IP CS FL
        mov     ax,regUserFL    ;flags returned by interrupt service routine
        and     ax,0BFFFh       ;clear the nested task flag
        and     [bp+6],0300h    ;clear all but the interrupt and trace flags
                                ; in the caller's original flags
        or      [bp+6],ax       ;combine in the flags returned by the
                                ; interrupt service routine.  This will cause
                                ; us to return to the original routine with
                                ; interrupts on if they were on when the
                                ; interrupt occured, or if the ISR returned
                                ; with them on.
        pop     bp

; And now, return to the caller.

        push    pfnReturnAddr
        mov     ax,regUserAX
        mov     ds,regUserDS
        assume  ds:NOTHING
        ret

LeaveIntHandler endp

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Mouse Interrupt Callback Function Handler
        page
; -------------------------------------------------------
;       MOUSE INTERRUPT CALLBACK FUNCTION HANDLER
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

; -------------------------------------------------------
;   MouseInterruptHandler -- This routine is the entry point for
;       user requested mouse event interrupts. It switches the
;       processor to protected mode and transfers control to the
;       user protected mode mouse handling routine. When that
;       completes, it switches back to real mode and returns control
;       to the mouse driver.
;       Entry to this routine will have been requested by an
;       INT 33H code 12 with the real address of this routine
;       substituted for the users entry point.
;       The address of the user specified mouse handler as specified
;       in the original INT 33H is stored in the variable
;       lpfnUserMouseHandler.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   The segment registers are explicitly preserved by
;           this routine.  Other registers are as preserved or
;           modified by the users mouse handler.

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  MouseInterruptHandler

MouseInterruptHandler    proc    far
;
; On entry, the stack layout is:
;   [2] CS      - System mouse handler code segment
;   [0] IP      - System mouse handler return offset
;

        push    es
        push    ds
        pushf
        FCLI
        cld
        mov     ds,selDgroup
        assume  ds:DGROUP
        pop     regUserFL
;
; Allocate a new stack frame, and then switch to the local stack
; frame.
        mov     regUserSP,sp    ;save entry stack pointer so we can restore it
        mov     regUSerSS,ss    ;save segment too
        mov     ss,selDgroup    ;switch to our own stack frame
        ASSERT_REFLSTK_OK
        mov     sp,pbReflStack
        sub     pbReflStack,CB_STKFRAME ;adjust pointer to next stack frame
        FIX_STACK
;
; We are now running on our own stack, so we can switch into protected mode.
        push    ax              ;preserve caller's AX
        SwitchToProtectedMode
        pop     ax
;
; Build a far return frame on the stack so that the user's
; routine will return to us when it is finished.
        push    regUserSS       ; save system mouse handler stack address
        push    regUserSP       ; so we can restore it later
        push    ds
        push    cs
        push    offset mih50
;
; Build an IRET frame on the stack to use to transfer control to the
; user's protected mode routine
        push    regUserFL
        push    word ptr lpfnUserMouseHandler+2 ;push segment of user routine
        push    word ptr lpfnUserMouseHandler   ;push offset of user routine
;
; At this point the interrupt reflector stack looks like this:
;
;   [14]    stack segment of original stack
;   [12]    stack pointer of original stack
;   [10]    real mode dos extender data segment
;   [8]     segment of return address back to here
;   [6]     offset of return address back here
;   [4]     Users flags
;   [2]     segment of user routine
;   [0]     offset of user routine
;
; Execute the users mouse handler
        iret
;
; The users handler will return here after it is finsished.
mih50:  FCLI
        cld
        pop     ds
        pop     regUserSP
        pop     regUserSS
;
; Switch back to real mode.
        push    ax              ;preserve AX
        SwitchToRealMode
        pop     ax
        CHECK_STACK
;
; Switch back to the original stack.
        mov     ss,regUserSS
        mov     sp,regUserSP
        ASSERT_REFLSTK_OK
;
; Deallocate the stack frame that we are using.
        add     pbReflStack,CB_STKFRAME
        ASSERT_REFLSTK_OK
;
; And return to the original interrupted program.
        pop     ds
        pop     es

        ret

MouseInterruptHandler    endp

; -------------------------------------------------------

DXCODE  ends

; -------------------------------------------------------
        subttl  PS/2 Pointing Device Handler
        page
; -------------------------------------------------------
;           PS/2 POINTING DEVICE HANDLER
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

ifndef      NEC_98
; -------------------------------------------------------
;   PointDeviceHandler -- This routine is the entry point for
;       the PS/2 Pointing Device Handler.  It switches the
;       processor to protected mode and transfers control to the
;       user pointing device handler.  When that completes,
;       it switches back to real mode and returns control to
;       the PS/2 BIOS.
;
;       Note: The BIOS calls us with interrutps enabled!

;   Input:  none
;   Output: none
;   Errors: none

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PointDeviceHandler

PointDeviceHandler      proc    far

; On entry, the stack layout is:
;
;  [10] status
;   [8] X coordinate
;   [6] Y coordinate
;   [4] Z coordinate
;   [2] CS              - PS/2 BIOS code segment
;   [0] IP              - PS/2 BIOS return offset

        cld
        push    es              ;save PS/2 BIOS ds/es on it's stack
        push    ds

        mov     ds,selDgroup    ;addressability to DOSX DGROUP
        push    ds
        pop     es
        assume  ds:DGROUP,es:DGROUP

        FCLI                     ;protect global regUserXX vars

; Allocate a new stack frame, and then switch to the local stack
; frame.

        mov     regUserSP,sp    ;save entry stack pointer so we can restore it
        mov     regUSerSS,ss    ;save segment too
        ASSERT_REFLSTK_OK
        mov     ss,selDgroup    ;switch to our own stack frame
        mov     sp,pbReflStack
        sub     pbReflStack,CB_STKFRAME ;adjust pointer to next stack frame
        FIX_STACK

        push    regUserSS       ;save PS/2 BIOS stack address
        push    regUserSP       ;  so we can restore it later

        push    SEL_DXDATA or STD_RING  ;DOSX DS to be poped in PM

        sub     sp,4*2          ;temp save the general regs further down the
        pusha                   ;  stack, they'll get poped in a little while

; Copy PS/2 pointing device stack info to our (soon to be) protected mode stack

        mov     si,regUserSP    ;PS/2 stack pointer
        mov     ds,regUserSS    ;PS/2 stack segment
        assume  ds:NOTHING

        FSTI                     ;no more references to global regUserXX vars

        add     si,4*2          ;skip over es,ds,cs,ip
        mov     di,sp           ;loc for pointing device
        add     di,8*2          ;  data on our stack
        mov     cx,4
        cld
        rep movsw

        push    es              ;restore ds = DGROUP
        pop     ds
        assume  ds:DGROUP

; We are now running on our own stack, so we can switch into protected mode.

        SwitchToProtectedMode   ;disables interrupts again
        FSTI                     ;   but we don't want them disabled

        popa                    ;restore general registers

; At this point the stack looks like this:
;
;   [12]   stack segment of original stack
;   [10]   stack pointer of original stack
;   [8]    protect mode dos extender data segment
;   [6]    status
;   [4]    X coordinate
;   [2]    Y coordinate
;   [0]    Z coordinate

; Execute the user's pointing device handler

        call    [lpfnUserPointingHandler]

; The users handler will return here after it is finsished.

pdh50:
        cld
        add     sp,4*2                  ;discard pointing device info
        pop     ds

        FCLI                             ;protect global regUserXX vars
        pop     regUserSP
        pop     regUserSS

; Switch back to real mode.

        push    ax                      ;preserve AX
        SwitchToRealMode
        pop     ax

; Switch back to the original stack.

        CHECK_STACK
        mov     ss,regUserSS
        mov     sp,regUserSP

; Deallocate the stack frame that we are using.

        ASSERT_REFLSTK_OK
        add     pbReflStack,CB_STKFRAME
        ASSERT_REFLSTK_OK

; And return to the PS/2 BIOS

        FSTI                             ;we came in with ints enabled

        pop     ds
        pop     es

        ret

PointDeviceHandler      endp

; -------------------------------------------------------
endif   ;!NEC_98
;
; -------------------------------------------------------
        subttl  Utility Function Definitions
        page
; -------------------------------------------------------
;           UTILITY FUNCTION DEFINITIONS
; -------------------------------------------------------
;
;   SaveRMIntrVectors   -- This routine copies the current
;       real mode interrupt vector table to the shadow
;       vector table used by the interrupt reflector.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses;   all registers preserved
;
;   NOTE:   This routine can only be called in REAL MODE.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  SaveRMIntrVectors

SaveRMIntrVectors:
        push    cx
        push    si
        push    di
        push    ds
        push    es
;
        cld
        push    ds
        pop     es
        xor     cx,cx
        mov     si,cx
        mov     ds,cx
        mov     di,offset DGROUP:rglpfnRmISR
        mov     cx,2*256
        rep     movs word ptr [di],word ptr [si]
;
        pop     es
        pop     ds
        pop     di
        pop     si
        pop     cx
        ret

; -------------------------------------------------------
;   RestoreRMIntrVectors    -- This routine copies the
;       interrupt vectors from the real mode interrupt
;       vector shadow table back down to the real interrupt
;       vectors.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses;   all registers preserved
;
;   NOTE:   This routine can only be called in REAL MODE.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  RestoreRMIntrVectors

RestoreRMIntrVectors:
        push    cx
        push    si
        push    di
        push    ds
        push    es
;
        FCLI
        cld
        xor     cx,cx
        mov     di,cx
        mov     es,cx
        mov     si,offset DGROUP:rglpfnRmISR
        mov     cx,2*256
        rep     movs word ptr [di],word ptr [si]
        FSTI
;
        pop     es
        pop     ds
        pop     di
        pop     si
        pop     cx
        ret

; -------------------------------------------------------

DXCODE  ends

ifdef      NEC_98                                           
;
; -------------------------------------------------------
        subttl  INT D2h SOUND BIOS HANDRER              
        page                                            
; -------------------------------------------------------
;       PMIntrSound
;--------------------------------------------------------

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntrSound                             

PMIntrSound:                                            

        call    EnterIntHandler     ;build a stack frame and fix up the         
        cld                         ; return address so that the interrupt      
                                    ;service routine will return to us.         
;
; Perform fixups on the entry register values            
        call    IntEntrySD                              
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*0D2h]  ;execute the real mode interrupt routine 
        pushf                                           
        cli                                             
        cld                                             
        pusha                                           
        push    ds                                      
        push    es                                      
        mov     bp,sp               ;restore stack frame pointer 
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
        mov     ax,[bp].pmUserAX    ;get original function code 
        call    IntExitSD                               
;
; And return to the original caller.                     
        call    LeaveIntHandler                         

        iret                                            

;--------------------------------------------------------
;       IntEntrySD
;--------------------------------------------------------

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntEntrySD                              

IntEntrySD:                                             

        cmp     ah,0                    ;BIOS(INITIALIZE)
        jnz     ienSD10                                 
        mov     bx,0                    ;BIOS      
        mov     si,bx                    
        mov     cx,2FFh                 ;(256) (512)
        jmp     ienSD50                             
ienSD10:                                            
        cmp     ah,1                    ;(PLAY)
        jnz     ienSD20                        
        mov     si,[bp].pmUserBX               
        mov     cx,28                          
        jmp     ienSD50                        
ienSD20:                                       
        cmp     ah,16h                  ;(SET PARA BLOCK)
        jnz     ienSD90                                 
        mov     si,[bp].pmUserBX                        
        cmp     dl,0                    ;00=WORD/01=BYTE? 
        jnz     ienSD21                 ;not 0 = JMP
        mov     cx,100                  ;100        
        jmp     ienSD50                             
ienSD21:                                            
        mov     cx,51                   ;51         
ienSD50:                                            
        push    ds                                  
;;;;    mov     si,[bp].pmUserBX        ;           
        mov     ds,[bp].pmUserES        ;           
        mov     di,offset DGROUP:rgbXfrBuf1         
        rep     movsb                               
        pop     ds                                  

        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 
ienSD90:                                                
        ret                                             

;--------------------------------------------------------
;       IntExitSD
;--------------------------------------------------------

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntExitSD                               

IntExitSD:                                              

        cmp     ah,0                    ;BIOS (INITIALIZE) 
        jnz     iexSD10                                 
        jmp     iexSD50                                 
iexSD10:                                                
        cmp     ah,1                    ;(PLAY)
        jnz     iexSD20                        
        jmp     iexSD50                        
iexSD20:                                       
        cmp     ah,16h                  ;(SET PARA BLOCK)
        jnz     iexSD90                                 
iexSD50:                                                
        push    ax                                      
        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
;------------------------------------------------------------
        mov     ax,[bp].pmUserBX                        
        mov     [bp].intUserBX,ax                       
        pop     ax                                      
iexSD90:                                                
        ret                                             

DXPMCODE    ends                                        

; -------------------------------------------------------
        subttl  INT 1Ah PRINTER BIOS HANDRER            
        page                                            

;       30h(            )  2K                           
; -------------------------------------------------------
;       PMIntrPrinter
;--------------------------------------------------------

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntrPrinter                           

PMIntrPrinter:                                          


        call    EnterIntHandler     ;build a stack frame and fix up the         
        cld                         ; return address so that the interrupt      
                                    ;service routine will return to us.         
;
; Perform fixups on the entry register values            
        call    IntEntryPR                              
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*1Ah]  ;execute the real mode interrupt routine 
        pushf                                           
        cli                                             
        cld                                             
        pusha                                           
        push    ds                                      
        push    es                                      
        mov     bp,sp               ;restore stack frame pointer 
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
        mov     ax,[bp].pmUserAX    ;get original function code 
        call    IntExitPR                               
;
; And return to the original caller.                    
        call    LeaveIntHandler                         

        iret                                            

;--------------------------------------------------------
;       IntEntryPR
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntEntryPR                              

IntEntryPR:                                             

        cmp     ah,30h                  ;                
        jnz     ienPR20                 ;90/08/24        
        mov     cx,[bp].pmUserCX        ;                
        cmp     cx,2048                 ;2K      
        jbe     ienPR10                 ;NO = jmp
        mov     cx,2048                 
        mov     [bp].intUserCX,cx       
ienPR10:                                
        push    ds                      
        mov     si,[bp].pmUserBX        ;offset address 
        mov     ds,[bp].pmUserES        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 

ienPR20:                                                
        ret                                             

;--------------------------------------------------------
;       IntExitPR
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntExitPR                               

IntExitPR:                                              

        cmp     ah,30h                  
        jnz     iexPR20                 
        mov     cx,[bp].pmUserCX        
        cmp     cx,2048                 
        ja      iexPR10                 ;YES = jmp
        push    ax                                
        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
;------------------------------------------------------------
        mov     ax,[bp].pmUserBX        ;offset address 
        mov     [bp].intUserBX,ax                       
        pop     ax                                      
        ret                                             

iexPR10:                                                
        push    ax                                      
        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
;------------------------------------------------------------
        mov     cx,2048                 
        sub     [bp].pmUserCX,cx        
        mov     ax,[bp].pmUserCX        
        mov     [bp].intUserCX,ax       
        pop     ax                      
        
        push    bx 
        add     [bp].pmUserBX,cx                        
        mov     bx,[bp].pmUserBX                        
        mov     [bp].intUserBX,bx       
        pop     bx                      
iexPR20:                                
        ret                             
        
;////////////////////////////////////////////////////////////
if 0                    
;////////////////////////////////////////////////////////////
IntEntryPR:             

        cmp     ah,30h                  
        jnz     ienPR10                 
        mov     cx,[bp].pmUserCX        
        cmp     cx,2048                 
        ja      ienPR10                 ;YES = jmp
        push    ds                                
        mov     si,[bp].pmUserBX        ;offset address 
        mov     ds,[bp].pmUserES        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1            
        cld                                            
        rep     movsb                                  
        pop     ds                                     
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 
        ret                                             

ienPR10:                                                
        push    ds                                      
        mov     si,[bp].pmUserBX        ;offset address 
        mov     ds,[bp].pmUserES        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        push    bx                                      
        mov     bx,offset DGROUP:rgbXfrBuf1     ;
        add     bx,cx                           ;DGROUP:rgbXfrBuf1
        mov     [bp].intUserBX,bx               ;
        pop     bx                               
        ret                                      

;       push    ds                                      
;       mov     [bp].intUserES,ds       ;segment address
;       pop     ds                                      
;;------------------------------------------------------------
;       mov     bx,offset DGROUP:rgbXfrBuf1     ;
;       add     bx,cx                           ;
;       mov     [bp].intUserBX,bx               ;
;       ret                                      
;
;--------------------------------------------------------
;       IntExitPR
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntExitPR                               

IntExitPR:                                              

        cmp     ah,30h                  
        jnz     iexPR10                 
        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
;------------------------------------------------------------
        mov     ax,[bp].pmUserBX        ;      
        mov     [bp].intUserBX,ax                       
iexPR10:                                                
        ret                                             
;////////////////////////////////////////////////////////////
endif                   
;////////////////////////////////////////////////////////////

DXPMCODE    ends                                        


; -------------------------------------------------------
        subttl  INT 1Ch CALENDER/TIMER HANDRER
        page

; -------------------------------------------------------
;       PMIntrCalTi
;--------------------------------------------------------

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntrCalTi                             


PMIntrCalTi:                                            

        call    EnterIntHandler     ;build a stack frame and fix up the         
        cld                         ; return address so that the interrupt      
                                    ;service routine will return to us.         
;
; Perform fixups on the entry register values            
        call    IntEntryCT                              
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*1Ch]  ;execute the real mode interrupt routine 
        pushf                                           
        cli                                             
        cld                                             
        pusha                                           
        push    ds                                      
        push    es                                      
        mov     bp,sp               ;restore stack frame pointer 
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
        mov     ax,[bp].pmUserAX    ;get original function code 
        call    IntExitCT                               
;
; And return to the original caller.                     
        call    LeaveIntHandler                         

        iret                                            
        


;--------------------------------------------------------
;       IntEntryCT
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntEntryCT                              

IntEntryCT:                                             

        cmp     ah,0                    ;
        jnz     ienCT10                                 
        jmp     ienCT80                                 
ienCT10:                                                
        cmp     ah,1                    ;
        jnz     ienCT20                  
        mov     cx,6                    ;
        jmp     ienCT70                  
ienCT20:                                 
ienCT50:                                 

        push    es                                      
        push    ax                                      
        mov     ax,40h                                  
        mov     es,ax                                   
;       test    byte ptr es:[501h],8h   ;if Hmode 
        test    byte ptr es:[101h],8h   ;if Hmode 
        jz      ienCT90                           
        
;;      test    fNHmode,0FFh                            
;;      jz      ienCT90         ;0=Nmode --->jmp        

;--------------------- Hmode ----------------------
        cmp     ah,3                    
        jnz     ienCT30                                 
        mov     cx,4                    
        jmp     ienCT70                 
ienCT30:                                
        cmp     ah,4                    
        jnz     ienCT40                 
        mov     cx,12                   
        jmp     ienCT70                 
ienCT40:                                
        cmp     ah,5                    
        jnz     ienCT90                 
        mov     cx,12                   
;--------------------- Hmode ----------------------


ienCT70:                                                
        push    ds                                      
        mov     si,[bp].pmUserBX        ;offset address 
        mov     ds,[bp].pmUserES        ;segment address
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
ienCT80:                                                
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 
ienCT90:                                                
        ret                                             

;--------------------------------------------------------
;       IntExitCT
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntExitCT                               

IntExitCT:                                              

        cmp     ah,0                    
        jnz     iexCT10                                 
        mov     cx,6                                    
        jmp     iexCT70                                 
iexCT10:                                                
        cmp     ah,1                    
        jnz     iexCT20                 
        jmp     iexCT80                 
iexCT20:                                

iexCT50:                                                

        push    es                                      
        push    ax                                      
        mov     ax,40h                                  
        mov     es,ax                                   
;       test    byte ptr es:[501h],8h   ;if Hmode 
        test    byte ptr es:[101h],8h   ;if Hmode 
        jz      iexCT90                           
        
;;      test    fNHmode,0FFh                            
;;      jz      iexCT90         ;0=Nmode --->jmp        

;--------------------- Hmode ----------------------
        cmp     ah,3                    
        jnz     iexCT30                                 
        jmp     iexCT80                                 
iexCT30:                                                
        cmp     ah,4                    
        jnz     iexCT40                 
        jmp     iexCT80                 
iexCT40:                                
        cmp     ah,5                    
        jnz     iexCT90                 
        jmp     iexCT80                 
;--------------------- Hmode ----------------------

iexCT70:                                                
        push    es                                      
        mov     di,[bp].pmUserBX        ;offset address 
        mov     es,[bp].pmUserES        ;segment address
        mov     si,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     es                                      
iexCT80:                                                
        push    ax                                      

        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
;------------------------------------------------------------
        mov     ax,[bp].pmUserBX                        
        mov     [bp].intUserBX,ax                       
        pop     ax                                      
iexCT90:                                                
        ret                                             


DXPMCODE    ends                                        

; -------------------------------------------------------
        subttl  INT DCh extended DOS HANDRER
        page                     

; -------------------------------------------------------
;       PMIntrExDos
;--------------------------------------------------------

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntrExDos                             

PMIntrExDos:                                            

        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values            
        call    IntEntryED                              
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*0DCh]  ;execute the real mode interrupt routine 
        pushf                                           
        cli                                             
        cld                                             
        pusha                                           
        push    ds                                      
        push    es                                      
        mov     bp,sp               ;restore stack frame pointer 
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
;       mov     ax,[bp].pmUserAX    ;get original function code 
        mov     cx,[bp].pmUserCX    ;get original function code 
        call    IntExitED                               
;
; And return to the original caller.                     
        call    LeaveIntHandler                         

        iret                                            

;--------------------------------------------------------
;       IntEntryED
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntEntryED                              

IntEntryED:                                             

        cmp     cl,0Ch                  
        jnz     ienED10                                 
        jmp     ienED80                                 
ienED10:                                                
;;;     push    cx                      
        cmp     cl,0Dh                  
        jz      ienED                                   
        jmp     ienED20                                 
ienED:                                                  
        push    cx                      
        cmp     ax,0                    
        jnz     ienED11                 
        mov     cx,386                  ;386byte         
        jmp     ienED70                                 
ienED11:                                                
        cmp     ax,0FFh                 
        jnz     ienED12                 
        mov     cx,786                  ;786byte         
        jmp     ienED70                                 
ienED12:                                                
        cmp     ax,1                    
        jb      ienED13                 
        cmp     ax,0Ah                  
        ja      ienED13                 
        mov     cx,160                  ;16*10=160byte   
        jmp     ienED70                                 
ienED13:                                                
        cmp     ax,0Bh                  
        jb      ienED14                 
        cmp     ax,14h                  
        ja      ienED14                 
        mov     cx,160                  ;16*10=160byte   
        jmp     ienED70                                 
ienED14:                                                
        cmp     ax,15h                  
        jb      ienED15                 
        cmp     ax,1Fh                  
        ja      ienED15                 
        mov     cx,66                   ;6*11=66byte     
        jmp     ienED70                                 
ienED15:                                                
        cmp     ax,20h                  
        jb      ienED16                 
        cmp     ax,24h                  
        ja      ienED16                 
        mov     cx,80                   ;16*5=80byte     
        jmp     ienED70                                 
ienED16:                                                
        cmp     ax,25h                  
        jb      ienED17                 
        cmp     ax,29h                  
        ja      ienED17                 
        mov     cx,80                   ;16*5=80byte     
        jmp     ienED70                                 
ienED17:                                                
        cmp     ax,2Ah                  
        jb      ienED18                 
        cmp     ax,38h                  
        ja      ienED18                 
        mov     cx,240                  ;16*15=240byte   
        jmp     ienED70                                 
ienED18:                                                
        cmp     ax,100h                 
        jnz     ienED20                 
        mov     cx,514                  ;2+512=514byte   
        jmp     ienED70                                 

ienED20:                                                
        cmp     cl,10h                  
        jnz     ienED90                 
        cmp     ah,1                    
        jnz     ienED90                 
        
moji_out:                                               
        mov     si,dx                                   
        cmp     byte ptr ds:[si],'$'                    
;;;;;;;;        cmp     byte ptr ds:[dx],'$'            
        jz      ienED90                                 
        push    ds                                      
        mov     si,[bp].pmUserDX        ;offset address 
        mov     ds,[bp].pmUserDS        ;segment address
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        movsb                                           
        pop     ds                                      
        jmp     moji_out                                


ienED70:                                                
        push    ds                                      
        mov     si,[bp].pmUserDX        ;offset address 
        mov     ds,[bp].pmUserDS        ;segment address
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
        pop     cx                                      
ienED80:                                                
;----------- 
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        mov     [bp].intUserDX,offset DGROUP:rgbXfrBuf1 
ienED90:                                                
        ret                                             
        

;--------------------------------------------------------
;       IntExitED
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntExitED                               

IntExitED:                                              

        cmp     cl,0Ch                  
        jz      iexED                                   
        jmp     iexED10                                 
iexED:                                                  
        push    cx                                      
        cmp     ax,0                    
        jnz     iexED1                  
        mov     cx,386                  ;386byte         
        jmp     iexED70                                 
iexED1:                                                 
        cmp     ax,0FFh                 
        jnz     iexED2                  
        mov     cx,786                  ;786byte         
        jmp     iexED70                                 
iexED2:                                                 
        cmp     ax,1                    
        jb      iexED3                  
        cmp     ax,0Ah                  
        ja      iexED3                  
        mov     cx,160                  ;16*10=160byte  
        jmp     iexED70                                 
iexED3:                                                 
        cmp     ax,0Bh                  
        jb      iexED4                  
        cmp     ax,14h                  
        ja      iexED4                  
        mov     cx,160                  ;16*10=160byte   
        jmp     iexED70                                 
iexED4:                                                 
        cmp     ax,15h                  
        jb      iexED5                  
        cmp     ax,1Fh                  
        ja      iexED5                  
        mov     cx,66                   ;6*11=66byte     
        jmp     iexED70                                 
iexED5:                                                 
        cmp     ax,20h                  
        jb      iexED6                  
        cmp     ax,24h                  
        ja      iexED6                  
        mov     cx,80                   ;16*5=80byte     
        jmp     iexED70                                 
iexED6:                                                 
        cmp     ax,25h                  
        jb      iexED7                  
        cmp     ax,29h                  
        ja      iexED7                  
        mov     cx,80                   ;16*5=80byte     
        jmp     iexED70                                 
iexED7:                                                 
        cmp     ax,2Ah                  
        jb      iexED8                  
        cmp     ax,38h                  
        ja      iexED8                  
        mov     cx,240                  ;16*15=240byte   
        jmp     iexED70                                 
iexED8:                                                 
        cmp     ax,100h                 
        jnz     iexED10                 
        mov     cx,514                  ;2+512=514byte   
        jmp     iexED70                                 

iexED10:                                                
        cmp     cl,0Dh                  
        jnz     iexED20                 
        jmp     iexED80                 
iexED20:                                
        cmp     cl,10h                  
        jnz     iexED90                 
        cmp     ah,1                    
        jnz     iexED90                 
        jmp     iexED80                 
iexED70:                                
        push    ds                      
        mov     si,[bp].pmUserDX        ;offset address  
        mov     ds,[bp].pmUserDS        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
        pop     cx                                      
iexED80:                                                
        push    ax                                      
;----------- 
        mov     ax,[bp].pmUserDS                        
        mov     [bp].intUserDS,ax                       
;------------------------------------------------------------
        mov     ax,[bp].pmUserDX                        
        mov     [bp].intUserDX,ax                       
        pop     ax                                      
iexED90:                                                
        ret                                             


DXPMCODE    ends                                        

;/////////////////////////////////////////////////////////////////////////
;       Hmode no GRAPH ha INT 1Dh(Graph BIOS) niyori byouga sareru.
;       DOSX deha,
;/////////////////////////////////////////////////////////////////////////
; -------------------------------------------------------
;       PMIntr      GRAPH BIOS
;--------------------------------------------------------

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntrGraph                             

;///////////////////////////////////////////////////////////////////////
;;      extrn   fNHmode:BYTE            ;NHmode
;///////////////////////////////////////////////////////////////////////

PMIntrGraph:                                            


;;      test    fNHmode,0FFh                           
;;      jz      GBios_Nmode                            
        call    EnterIntHandler     ;build a stack frame and fix up the         
        cld                         ; return address so that the interrupt      
                                    ;service routine will return to us.         
;
; Perform fixups on the entry register values            

        push    ax                      
        mov     ax,[bp].pmUserDS        
        call    GetSegmentAddress       
        shr     dx,4                    
        shl     bx,12                   
        or      bx,dx                   ;bx now = seg of parent psp
        mov     [bp].intUserDS,bx       
        pop     ax                      
        
        
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*1Dh]  ;execute the real mode interrupt routine 
        pushf                                           
        cli                                             
        cld                                             
        pusha                                           
        push    ds                                      
        push    es                                      
        
        mov     ax,ss                                   
        mov     ds,ax                                   
        mov     es,ax                                   
        
        mov     bp,sp               ;restore stack frame pointer 
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
        mov     ax,[bp].pmUserAX    ;get original function code 
;///////////// 
        push    ax                                      
        mov     ax,[bp].pmUserDS                        
        mov     [bp].intUserDS,ax                       
        pop     ax                                      
;///////////// 
;
; And return to the original caller.                     
        call    LeaveIntHandler                         

        iret                                            


DXPMCODE    ends                                        

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntr11dummy                           
                                                        
PMIntr11dummy   proc    near                            
                                                        
        and     ax,0FFFDh                               
        iret                                            
                                                        
PMIntr11dummy   endp                                    
DXPMCODE    ends                                        

endif   ;NEC_98
DXPMCODE segment
        assume cs:DXPMCODE

IFDEF WOW

        public Wow32IntrRefl
Wow32IntrRefl label word
??intnum = 0
rept 256
        push    word ptr ??intnum
        jmp     Wow32Intr16Reflector
        ??intnum = ??intnum + 1
endm
;--------------------------------------------------------
;
;   Wow32Intr16Reflector -- This routine reflects a 32 bit
;       interrupt to a 16 bit handler.  It switches to the
;       dos extender stack to do so.
;
;   Inputs: none
;   Outputs: none
;
        assume ds:nothing,es:nothing,ss:nothing
        public Wow32Intr16Reflector
Wow32Intr16Reflector proc
.386p
        push    ebp
        mov     ebp,esp
        push    ds
        push    eax
        push    ebx
        push    edi
        mov     ax,ss
        movzx   eax,ax
        lar     eax,eax
        test    eax,(AB_BIG SHL 8)
        jnz     w32i16r10

        movzx   ebp,bp
w32i16r10:

;
; Get a frame on the dosx stack.
;
        mov     ax,selDgroupPM
        mov     ds,ax
        assume  ds:DGROUP

        movzx   ebx,pbReflStack
        sub     pbReflStack,CB_STKFRAME

;
; Build a frame on the stack
;
        sub     bx,30
        mov     eax, [ebp+6]            ; eip
        mov     [bx+20], eax
        mov     eax, [ebp+10]           ; cs
        mov     [bx+24], eax

        mov     [bx + 18],ss            ; ss for stack switch back
        mov     eax,ebp
        add     eax,6                   ; ebp, int number
        mov     [bx + 14],eax           ; esp for stack switch back
        mov     ax,[ebp + 14]           ; get flags
        mov     [bx + 12],ax
        mov     ax,cs
        mov     [bx + 10],ax
        mov     [bx + 8],offset DXPMCODE:w3216r30
        mov     eax,[ebp]
        mov     [bx],eax                ; put ebp on other stack for pop
;
; Get handler
;
        mov     di,[ebp + 4]            ; int number
        shl     di,2                    ; al * 4
        add     di,offset DGROUP:Wow16BitHandlers
        mov     ax,[di]
        mov     [bx + 4],ax             ; handler ip
        mov     ax,[di + 2]
        mov     [bx + 6],ax             ; handler cs

;
; Set up for stack switch
;
        push    ds
        push    ebx
;
; Restore registers
;
        mov     ax,[ebp - 2]
        mov     ds,ax
        mov     eax,[ebp - 6]
        mov     ebx,[ebp - 10]
        mov     edi,[ebp - 14]
;
; Switch stacks, restore ebp, and call handler
;
        lss     esp,[ebp - 20]
        pop     ebp
        retf
;
; N.B.  i31_RMCall looks on the stack to get the original user stack pointer.
;       if you change the stack frame the is passed to the 16 bit int
;       handlers, that WILL break.
;

w3216r30:
;
; Switch stacks, deallocate frame from dosx stack and return
;
        push    ebx
        push    eax
        push    ds
        lds     ebx,[esp+10]            ;get ss:esp
        mov     eax,[esp+16]
        mov     [ebx],eax               ;eip
        mov     eax,[esp+20]
        mov     [ebx+4],eax             ;cs
        pop     ds
        pop     eax
        pop     ebx

        lss     esp,[esp]
        push    ebx


        pushfd
        push    eax
        mov     ax,ss
        movzx   eax,ax
        lar     eax,eax
        test    eax,(AB_BIG SHL 8)      ; is the stack big?
        jnz     w32i16r40               ; jif yes, use 32bit operations
        pop     eax                     ; restore regs
        popfd

        rpushfd                         ; save flags, set virtual int bit
        pop     ebx
        push    ebp
        movzx   ebp, sp
        mov     [ebp + 16],ebx          ; put flags on iret frame
        pop     ebp
        push    ds
        mov     bx,selDgroupPM
        mov     ds,bx
        add     pbReflStack,CB_STKFRAME
        pop     ds
        pop     ebx
        riretd

w32i16r40:                              ; stack is big
        pop     eax                     ; restore regs
        popfd

        rpushfd32
        pop     ebx
        mov     [esp + 12],ebx
        push    ds
        mov     bx,selDgroupPM
        mov     ds,bx
        add     pbReflStack,CB_STKFRAME
        pop     ds
        pop     ebx
        riretd32

.286p
Wow32Intr16Reflector endp
ENDIF
DXPMCODE ends
;
;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxfunc.asm ===
PAGE    ,132
        TITLE   DXFUNC.ASM  --  Dos Extender Function Handlers

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXFUNC.ASM      - Dos Extender Function Handlers        *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains the functions for handling the Dos     *
;*  Extender user functions.  These are functions called by     *
;*  the client application to request special Dos Extender      *
;*  services.                                                   *
;*                                                              *
;*  Any INT 2Fh requests that aren't Dos Extender functions     *
;*  are handled by switching to real mode and passing control   *
;*  on to the previous owner of the real mode INT 2Fh vector.   *
;*  This is accomplished by jumping into the interrupt          *
;*  reflector entry vector at the location for int 2fh.         *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*   01/09/91 amitc  At switch out time Co-Processor being reset*
;*   11/29/90 amitc  Replaced FnSuspend/FnResume by FnObsolete  *
;*                   These are not needed anymore for 3.1       *
;*   11/29/90 amitc  Modified RMInt2FHandler to respond to the  *
;*                   BuildChain SWAPI call.                     *
;*   11/29/90 amitc  Added a SWAPI CallIn function to be called *
;*                   by the task switcher.                      *
;*   11/16/90 jimmat Added DPMI MS-DOS Extension support        *
;*   08/08/90 earleh Started changes to make DOSX a DPMI server *
;*   8/29/89 jimmat Added real mode Int 2Fh hook                *
;*   6/23/89 jimmat Added DOSX Info Int 2Fh                     *
;*   6/16/89 jimmat Ifdef'd out most DOSX Int 2Fh services      *
;*   6/15/89 jimmat Added suspend/resume Int 2Fh hooks, and     *
;*                  Win/386 compatible Int 31h check            *
;*   6/14/89 jimmat Removed PTRACE hooks & unused DynaLink code *
;*   5/19/89 jimmat Reduce # mode switches by ignoring Win/386  *
;*                  Int 2Fh/1680h idle calls                    *
;*   5/07/89 jimmat Added Int 2Fh protected mode hook to XMS    *
;*                  driver                                      *
;*   3/21/89 jimmat Corrected problem with jmping to wrong int  *
;*                  2Fh handler if not for the DOS extender     *
;*   3/09/89 jimmat Added FNDynaLink function                   *
;*  02/10/89 (GeneA): change Dos Extender from small model to   *
;*          medium model                                        *
;*  01/24/89 (GeneA):   removed all real mode dos extender      *
;*          function handlers.                                  *
;*  09/29/88 (GeneA):   created                                 *
;  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;*                                                              *
;****************************************************************

        .286p
        .287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

include segdefs.inc
include gendefs.inc
include pmdefs.inc
include dosx.inc
include hostdata.inc
include intmac.inc
include dpmi.inc
include stackchk.inc
include bop.inc

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

XMS_INS_CHK     equ     00h     ;Installition check function

WIN386_FUNC     equ     16h     ;Windows Enhanced mode Int 2Fh ID

WIN386_VER      equ     00h     ;Windows 386 version

WIN386_INIT     equ     05h     ;Windows/386 & DOSX startup call

W386_Get_Device_API equ 84h     ;es:di -> device API

DPMI_DETECT     equ     87h     ;WIN386/DPMI detection call


DPMI_VER        equ     005ah   ;version 0.90 served here
DPMI_SUCCESS    equ     0000h   ;zero to indicate success
DPMI_FLAGS      equ     0001h   ;32 bit support
                                ;DPMI client requesting 32-bit support

DPMI_MSDOS_VER  equ     0100h   ;WIN386/DPMI MS-DOS Extensions version 01.00

DPMI_MSDOS_API_GET_VER  equ     0000h   ;Get MS-DOS Extension version call
DPMI_MSDOS_API_GET_LDT  equ     0100h   ;Get LDT Base selector call


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   AllocateSelector:NEAR
        extrn   FreeSelector:NEAR
        extrn   ParaToLinear:NEAR
externFP        NSetSegmentDscr
externNP        NSetSegmentAccess
        extrn   DupSegmentDscr:NEAR
        extrn   XMScontrol:NEAR
IFDEF WOW
        extrn   Wow32IntrRefl:near
ENDIF
        extrn   HookNetBiosHwInt:NEAR

        extrn   AllocateExceptionStack:NEAR

DXSTACK segment

        extrn   rgw2FStack:WORD

DXSTACK ends

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   selPSPChild:WORD
        extrn   segPSPChild:WORD
        extrn   idCpuType:WORD

        extrn   DtaSegment:WORD
        extrn   DtaSelector:WORD
        extrn   DtaOffset:WORD

IFDEF WOW
        extrn   Wow16BitHandlers:WORD
        extrn   selEHStack:WORD
ENDIF
IFDEF WOW_x86
        extrn   FastBop:FWORD
ENDIF

;
; Count of DPMI clients active (that have entered protected mode).
;

        public  cDPMIClients
cDPMIClients    dw      0

        public selCurrentHostData, segCurrentHostData, DpmiFlags, DpmiSegAttr
selCurrentHostData dw 0
segCurrentHostData dw 0
DpmiSegAttr        dw 0
DpmiFlags          dw 0

DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   segDXData:WORD
        extrn   PrevInt2FHandler:DWORD

DXCODE  ends


DXPMCODE  segment

        extrn   selDgroupPM:WORD


        EXTRN   MakeLowSegment:PROC

DXPMCODE  ends

; -------------------------------------------------------

DXPMCODE  segment
        assume  cs:DXPMCODE


; WOW
; -------------------------------------------------------
;
; Simulate VCD API's. DX contains function number.
;
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  VCD_PM_Svc_Call

VCD_PM_Svc_Call:
        DPMIBOP VcdPmSvcCall32
        retf


; -------------------------------------------------------
;   XMSfunc - The following routine provides a protected mode
;       service for XMS Int 2Fh services.  Two services are
;       implemented:  XMS driver installation check, and obtain
;       XMS driver control function address.
;
;   Input:  UserAL      - function request
;   Output: UserAL      - XMS driver installed flag, or
;           UserES:BX   - XMS driver control function address
;   Errors: none
;   Uses:   all registers may be used

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  XMSfunc

XMSfunc proc    near

        cmp     al,XMS_INS_CHK          ;XMS driver installation check?
        jnz     @f

        mov     byte ptr [bp].fnsUserAX,80h     ;indicate driver is installed
        ret

@@:

; It must be an obtain XMS driver control function address request

        mov     [bp].fnsUserBX,offset DXPMCODE:XMScontrol
        mov     [bp].fnsUserES,cs

        ret

XMSfunc endp

; -------------------------------------------------------
        subttl  DPMI MS-DOS Extension API
        page
; -------------------------------------------------------
;           DPMI MS-DOS EXTENSION API
; -------------------------------------------------------
;
; The following routine implements the DPMI MS-DOS Extensions
; API.  This API must be 'detected' by the use of the
; DMPI_MSDOS_EXT Int 2F function (above).

        public  DPMI_MsDos_API
DPMI_MsDos_API  proc    far

        cmp     ax, DPMI_MSDOS_API_GET_VER      ;Get version call?
        jne     DPMI_MsDos_API_Not_Ver

        mov     ax,DPMI_MSDOS_VER
        jmp     short DPMI_MsDos_API_Exit

DPMI_MsDos_API_Not_Ver:

        cmp     ax, DPMI_MSDOS_API_GET_LDT      ;Get LDT Base call?
        jne     DPMI_MsDos_Api_Failed
ifdef WOW_x86
        mov     ax,SEL_WOW_LDT or STD_RING      ;  yup, give it to 'em
else
        mov     ax,SEL_LDT_ALIAS or STD_RING    ;  yup, give it to 'em
endif

DPMI_MsDos_API_Exit:

        clc                                     ;Succss
        ret

DPMI_MsDos_API_Failed:

        stc                                     ;Unsupported function
        ret

DPMI_MsDos_API  endp


DXPMCODE  ends

; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE
; -------------------------------------------------------
;
; -------------------------------------------------------
;
;  DPMI_Client_Pmode_Entry -- This routine is the entry
;       point for a DPMI client to switch to protected mode.
;       Reference: DOS Protected Mode Interface Specification 0.9
;                  Section 5.2: Calling the Real to Protected
;                  Mode Switch Entry Point
;
;  Entry: AX = Flags
;               Bit 0 = 1 if program is a 32-bit application
;         ES = Real mode segment of DPMI host data area.  This is the
;               size of the data area we specified in RMInt2FHandler,
;               below.
;
;  Returns:
;       Success: Carry clear.
;                Program is in protected mode.
;                CS = 16-bit selector with base of real mode
;                       CS and a 64k limit.
;                SS = 16-bit selector with base of real mode
;                       SS and a 64k limit.
;                DS = 16-bit selector with base of real mode
;                       DS and a 64k limit.
;                ES = Selector to program's PSP with a 100h
;                       byte limit.
;                80386, 80486:
;                        FS, GS = 0
;                All other registers preserved.
;
;       Failure: Carry flag set.
;                Program is in real mode.
;
;  Exceptions:
;       32-bit programs not (yet) supported.  Any attempt to load
;       a 32-bit program by this mechanism returns failure.
;
;       The only error that can occur here is a failure to allocate
;       sufficient selectors.
;

;
; Structure of the stack frame used to store the client's registers
; while implementing the DPMI protected mode entry.
;

DPMI_Client_Frame STRUC
        Client_ES       dw      ?       ; Client's ES
        Client_DS       dw      ?       ; Client's DS
        Client_DI       dw      ?       ; Client's DI
        Client_SI       dw      ?       ; Client's SI
        Client_Pusha_BP dw      ?       ; BP at pusha
        Client_Pusha_SP dw      ?       ; SP at pusha
        Client_BX       dw      ?       ; Client's BX
        Client_DX       dw      ?       ; Client's DX
        Client_CX       dw      ?       ; Client's CX
        Client_AX       dw      ?       ; Client's AX
        Client_Flags    dw      ?       ; Client's flags
        Client_IP       dw      ?       ; Client's IP, lsw of return
        Client_CS       dw      ?       ; Client's CS, msw of return
DPMI_Client_Frame ENDS

        public  DPMI_Client_Pmode_Entry
DPMI_Client_Pmode_Entry proc    far
;
; Reject any 32-bit program requests.
;

IFNDEF WOW
        test    ax, DPMI_32BIT          ; 32-bit application?
        stc                             ; yep, refuse to do it
        jz      dcpe_flags_ok           ; no, try to get into Pmode
        jmp     dcpe_x
dcpe_flags_ok:
ENDIF

IFDEF WOW
        stc
ENDIF
        pushf                           ;save client's flags (with carry set)
        pusha                           ;save caller's general registers
        push    ds                      ;save caller's DS
        push    es                      ;save caller's ES
        mov     bp, sp                  ;create the stack frame
        dossvc  62h                     ;now get caller's PSP address
        mov     di, bx                  ;and store it here for a while
        push    es
        dossvc  2fh                     ;get caller's dta address

        mov     ax, segDXData           ;get our DGROUP
        mov     ds, ax                  ;point to it

        mov     DtaSegment,es
        mov     DtaOffset,bx
        pop     es

;
; For now, we only support one DPMI client application at a time.
;
;;        cmp     cDPMIClients,0          ;Any active?
;;        je      @F
;;        jmp     dcpe_return

@@:     mov     ax,[segCurrentHostData]
        mov     es:[HdSegParent],ax     ; save rm link
        mov     ax,es
        mov     [segCurrentHostData],ax
        mov     ax,[bp].Client_AX       ; get dpmi flags
        mov     es:[HdFlags],ax         ; save for future reference
        mov     DpmiFlags,ax
        test    ax,DPMI_32BIT
        jne     cpe10

        mov     DpmiSegAttr,0
        jmp     cpe20

cpe10:  mov     DpmiSegAttr,AB_BIG

cpe20:  mov     si, ss                  ;SI = caller SS

        mov     ax, ds                  ;use a DOSX stack during the mode
                                        ;switch
        FCLI
        mov     ss, ax
        mov     sp, offset DGROUP:rgw2FStack

        SwitchToProtectedMode

        mov     ax, si                  ;make a selector for client's stack
        mov     bx, STD_DATA
        or      bx, DpmiSegAttr
        call    MakeLowSegment
        jnc     got_client_stack_selector
        jmp     dcpe_error_exit         ;back out if error
got_client_stack_selector:

        or      al,STD_TBL_RING

        mov     ss, ax                  ;back to client's stack
.386p
        movzx   esp,bp
.286p

;        push    [bp.Client_Flags]       ;enable interupts if client had
;        npopf                           ;them enabled

;
; After DOSX enters protected mode, convert the caller's segment registers
; to PMODE selectors, replacing the values in the client's register image
; on the stack.  First, allocate the three or four selectors we will need.
;
        xor     ax,ax                   ;an invalid selector
        push    ax                      ;marker

        mov     cx,4                    ;CS, PSP, Environ, Host data
        cmp     si,[bp.Client_DS]       ;Client SS == Client DS ?
        je      dcpe_allocate_loop
        inc     cx
dcpe_allocate_loop:
        call    AllocateSelector
        jnc     @F
        jmp     dcpe_pfail
@@:
        or      al,STD_TBL_RING
        push    ax
        loop    dcpe_allocate_loop

        mov     dx,[bp.Client_CS]       ;get client CS paragraph
        call    ParaToLinear            ;convert to linear address in BX:DX
        mov     cx,0ffffh               ;limit = 64k
        pop     ax                      ;get one of the selectors allocated
        mov     [bp.Client_CS],ax       ;save value for client
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_CODE>


        mov     dx, [bp.Client_DS]
        mov     [bp.Client_DS],ss       ;DS = SS for now
        cmp     dx, si                  ;need separate DS selector?
        je      dcpe_do_child_PSP

        call    ParaToLinear            ;convert to linear address in BL:DX
        mov     cx,0ffffh               ;limit = 64k
        pop     ax                      ;get another selector
        mov     [bp.Client_DS],ax       ;save value for client
        push    di
        mov     di,STD_DATA
        or      di,DpmiSegAttr
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,di>
        pop     di

dcpe_do_child_PSP:
        mov     dx,[bp.Client_ES]       ; get HostData selector
        call    ParaToLinear
        mov     cx,HOST_DATA_SIZE       ; limit = size of HostData
        pop     ax                      ; get another selector
        push    [selCurrentHostData]
        mov     [selCurrentHostData],ax ; save for us
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>
        mov     es,ax
        pop     ax
        mov     es:[HdSelParent],ax
        mov     ax,SelPSPChild
        mov     es:[HdPSPParent],ax

        mov     dx, di                  ;get client PSP paragraph
        mov     segPSPChild, di
        call    ParaToLinear            ;convert to linear address in BL:DX
        mov     cx,100h                 ;limit = 100h
        pop     ax                      ;get another selector
        mov     [bp.Client_ES],ax       ;save value for client
        mov     selPSPChild, ax         ;save a copy for DOSX
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>

        mov     es:[HdSelPSP],ax
        mov     es,ax                   ;point to client's PSP
        mov     dx,es:segEnviron        ;fetch client's environment pointer
        call    ParaToLinear            ;convert to linear address in BL:DX
        mov     cx,0ffffh               ;limit = 32k
        pop     ax                      ;get another selector
        mov     es:segEnviron,ax        ;save client's environment selector
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>

; We need to set up the DTA selector
        mov     dx,DtaSegment
        cmp     dx,segPSPChild
        jne     dcpe_50

        mov     dx,selPSPChild
        mov     DtaSelector,dx
        jmp     dcpe_60

dcpe_50:
        mov     cx,1
        call    AllocateSelector
        jnc     @f

        jmp     dcpe_free_client_stack

@@:     or      al,STD_TBL_RING
        mov     DtaSelector,ax
        call    ParaToLinear
        cCall   NSetSegmentDscr,<ax,bx,dx,0,0ffffh,STD_DATA>

dcpe_60:

        inc     cDPMIClients            ;increment count of Pmode clients
        cmp     cDPMIClients, 1         ; first client?
        jne     @f                      ; already taken care of

        call    AllocateExceptionStack

        call    DpmiStackSizeInit
        call    DpmiSizeInit
        FBOP    BOP_DPMI,DpmiInUse,FastBop
;
@@:
;
; Everything OK.  Clear error flag, and return to caller.
;
        not     byte ptr [bp.Client_Flags]
                                        ;reverse status flags, clearing carry


;       Let 32 bit code know if this is a 32 or 16 bit application
        mov     ax,DpmiFlags
        push    selPSPChild
        push    DtaSelector
        push    DtaOffset
        FBOP    BOP_DPMI,InitApp,FastBop
        add     sp,4

        cmp     cDPMIClients, 1         ; first client?
        jne     @f                      ; already taken care of
        ; Note:  We have to do InitApp before we try to hook the netbios
        ; interrupt.  If we don't, we will fault in the dos extender.
        ; (HookNetBiosHwInt calls int 21, enabling interrupts)
        call    HookNetBiosHwInt
@@:

;       jmp     far ptr dcpe_return     ;avoid need for fix ups
        db      0EAh
        dw      offset DXCODE:dcpe_return
        dw      SEL_DXCODE OR STD_RING
;
; If we get here, it means DOSX failed to allocate enough selectors for the
; client.  Deallocate those which have been allocated, switch back to
; real mode, and return an error to the caller.  Selectors to deallocate
; are on the stack, pushed after a zero word.  Then switch to a DOSX stack,
; deallocate the client stack selector, and switch to real mode.
;
dcpe_pfail:
        pop     ax                      ;any selectors allocated?
        or      ax,ax                   ; (we pushed a zero before allocating)
        jz      dcpe_free_client_stack  ;done
        call    FreeSelector            ;free the selector
        jnc     dcpe_pfail              ;free any more
dcpe_free_client_stack:
        mov     di, ss                  ;make copy of client stack selector
        mov     ax, ds                  ;have to be on a DOSX stack to do this
        FCLI
        mov     ss, ax
        mov     sp, offset DGROUP:rgw2FStack
        mov     ax, di                  ;free client stack selector
        call    FreeSelector
dcpe_error_exit:
;
; Error exit from protected mode.  Any allocated selectors have already
; been freed.  Switch to real mode, restore client stack, pop off client's
; registers, return with the carry flag set.
;
        SwitchToRealMode
        mov     ss, si                  ;restore client stack

        errnz  <dcpe_return-$>

dcpe_return:    ; The next line must restore the stack.

        mov     sp, bp

        jc      dcpe_return_1           ; error return
;
; Pop the client's registers off the stack frame, switch back to the
; client's stack, and return.
;
dcpe_return_1:
        pop     es                      ;pop copy of PSP selector/segment
        pop     ds                      ;pop client DS selector/segment
        popa                            ;pop client's general registers
        npopf                           ;restore interrupt flag, return status
dcpe_x:
        retf                            ;and out of here
DPMI_Client_Pmode_Entry endp

; -------------------------------------------------------
;              REAL MODE FUNCTION HANDLER
; -------------------------------------------------------
;
; RMInt2FHandler -- This routine hooks the real mode Int 2Fh chain
;       and watches for 'interesting' Int 2Fh calls.
;
;       WIN386/DOSX startup broadcast
;       DPMI server detection
;       Switcher API functions
;
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  RMInt2FHandler

RMInt2FHandler  proc    near


        cmp     ah,WIN386_FUNC          ;WIN386/DOSX/DPMI call?
        jz      rm2f_0

rm2f_chain:
        jmp     [PrevInt2FHandler]      ;no, just chain it on...

rm2f_0:

if 0    ; don't claim to be win 3.1 in enhanced mode
        cmp     al,WIN386_INIT          ;WIN386/DOSX startup attempt?
        jnz     rm2f_1                  ;no
        mov     cx,-1                   ;yes, don't let'm load
        jmp     rm2f_x
endif
        cmp     al,W386_Get_Device_API  ;not supported
        jne     rm2f_1

        xor     di,di
        mov     es,di
        jmp     rm2f_x

rm2f_1:
        cmp     al,DPMI_DETECT          ;DPMI detection?
        jnz     rm2f_2                  ;no

        mov     ax,DPMI_SUCCESS         ;yes, return Pmode switch entry
        mov     bx,DPMI_FLAGS           ;flags

        push    segDXData
        pop     es
        assume  es:DXDATA
        mov     cl,byte ptr es:[idCpuType]      ;CPU type
        assume  es:nothing

        mov     dx,DPMI_VER             ;DPMI server version
        mov     si,(HOST_DATA_SIZE + 15) / 16
        push    cs                      ;entry point is in this segment
        pop     es                              ;prospective client wants
        lea     di,DPMI_Client_Pmode_Entry      ;switch entry point in ES:DI
        jmp     rm2f_x                  ;done
rm2f_2:
if 0    ; don't claim to be windows
        cmp     al,WIN386_VER           ;Windows 386 version check?
        jnz     rm2f_chain              ;no, chain the interrupt

        mov     ax, 0a03h
else
        jmp     rm2f_chain
endif
rm2f_x:
        iret

RMInt2FHandler  endp

;--------------------------------------------------------------------------------

DXCODE  ends

IFDEF WOW
DXPMCODE segment
        assume cs:DXPMCODE

;----------------------------------------------------------------------
;
;   DpmiSizeInit -- This routine insures that the appropriately sized
;       interrupt handlers will be called
;
;   Inputs: None
;   Outputs: None
;
        public DpmiSizeInit
        assume ds:dgroup,es:nothing,ss:nothing
DpmiSizeInit proc

        push    ax
        push    bx
        push    cx
        push    si
        push    di
        push    es
        rpushf
        FCLI
        test    DpmiFlags,DPMI_32BIT
        jnz     dsi20

        cCall NSetSegmentAccess,<selDgroupPM,STD_DATA>
        cCall NSetSegmentAccess,<selEHStack,STD_DATA>

        jmp     dsi90
dsi20:
;
; Copy 16 bit handler addresses
;
.386p
        lea     di,Wow16BitHandlers

        mov     ax,ds
        mov     es,ax
        assume es:DGROUP

        push    ds
        mov     ax,SEL_IDT OR STD_RING
        mov     ds,ax
        assume ds:nothing

        mov     si,0
        mov     cx,256
dsi40:  movsd
        add     si,4
        loop    dsi40
        pop     ds
;
; Put 32 bit handlers into IDT
;

        mov     ax,SEL_IDT OR STD_RING
        mov     es,ax

        mov     es:[1h*8].offDest,offset DXPMCODE:Wow32IntrRefl+1h*6
        mov     es:[3h*8].offDest,offset DXPMCODE:Wow32IntrRefl+3h*6
        mov     es:[10h*8].offDest,offset DXPMCODE:Wow32IntrRefl+10h*6
        mov     es:[13h*8].offDest,offset DXPMCODE:Wow32IntrRefl+13h*6
        mov     es:[15h*8].offDest,offset DXPMCODE:Wow32IntrRefl+15h*6
        mov     es:[19h*8].offDest,offset DXPMCODE:Wow32IntrRefl+19h*6

        mov     es:[21h*8].offDest,offset DXPMCODE:Wow32IntrRefl+21h*6
        mov     es:[25h*8].offDest,offset DXPMCODE:Wow32IntrRefl+25h*6
        mov     es:[26h*8].offDest,offset DXPMCODE:Wow32IntrRefl+26h*6
        mov     es:[28h*8].offDest,offset DXPMCODE:Wow32IntrRefl+28h*6
        mov     es:[30h*8].offDest,offset DXPMCODE:Wow32IntrRefl+30h*6
        mov     es:[33h*8].offDest,offset DXPMCODE:Wow32IntrRefl+33h*6
        mov     es:[41h*8].offDest,offset DXPMCODE:Wow32IntrRefl+41h*6

;
; Set up the IDT, and dpmi32 state
;
        mov     ax,es                   ; Idt selector
        mov     bx,VDM_INT_32
        DPMIBOP InitIDT

        assume ds:DGROUP

dsi90:  rpopf
        pop     es
        pop     di
        pop     si
        pop     cx
        pop     bx
        pop     ax
        ret
DpmiSizeInit endp

        assume ds:DGROUP, es:NOTHING, ss:NOTHING
DpmiStackSizeInit proc

        push    ax
        test    DpmiFlags,DPMI_32BIT
        jz      @f
;
; Make the dgroup selector 32 bit
;
; NOTE: The following equ is only necessary to get the cmacro package
;       to pass the correct value to NSetSegmentAccess

NEW_DX_DATA equ STD_DATA OR AB_BIG
        cCall NSetSegmentAccess,<selDgroupPM,NEW_DX_DATA>
        cCall NSetSegmentAccess,<selEHStack,NEW_DX_DATA>
.286p

@@:
        pop     ax
        ret

DpmiStackSizeInit endp

DXPMCODE ends
ENDIF
;
;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxmain.asm ===
PAGE    ,132
        TITLE   DXMAIN.ASM -- Main Module for Dos Extender

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXMAIN.ASM      -   Dos Extender Main Module            *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains the main routines for the Dos          *
;*  Extender.  This is based on code written for Microsoft      *
;*  by Murray Sargent of Scroll Systems from Tucson Arizona.    *
;*                                                              *
;*  The Dos Extender provides support to allows specially       *
;*  written programs to run in protected mode mode on the       *
;*  80286 and 80386 under MS-DOS.  The following areas of       *
;*  support are provided to accomplish this:                    *
;*                                                              *
;*  Program Loading and Initialization                          *
;*      This involves creating a program segment prefix and     *
;*      then loading and relocating the exe file.  When         *
;*      loading an exe for protected mode operation, it is      *
;*      necessary to create segment descriptors for all         *
;*      segments used by the program and to then substitute     *
;*      the corresponding selectors when fixing up the segment  *
;*      references in the code.                                 *
;*                                                              *
;*  Dos Function Call Support                                   *
;*      Since Dos must execute in real mode, it is necessary    *
;*      to perform mode switching into real mode and the back   *
;*      to protected mode when the application makes Dos calls. *
;*      Also, any far pointers that are parameters to the       *
;*      function must be converted from the selector:offset     *
;*      form that the application uses to a segment:offset form *
;*      that Dos can use, with the corresponding data being     *
;*      buffered from the application's extended memory address *
;*      space to Dos's real mode address space.                 *
;*                                                              *
;*  Other Interrupt Support                                     *
;*      Hardware interrupts are processed in real mode, and     *
;*      so the Dos Extender performs mode switching on each     *
;*      interrupt.  Also other system resources (such as the    *
;*      mouse driver and the bios) are entered through software *
;*      interrupts, and require the same kind of buffering      *
;*      and parameter translation that the Dos functions        *
;*      require.                                                *
;*                                                              *
;*  Extended Memory Management                                  *
;*      The protected mode application has access to the full   *
;*      address space of the machine, and a memory manager is   *
;*      provided that duplicates the functions of the Dos       *
;*      memory manager over the entire address space of the     *
;*      machine.                                                *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  08/08/90 earleh DOSX and Client privilege ring determined   *
;*      by equate in pmdefs.inc                                 *
;*  03/23/90 davidw   Added the reflecting of it 23h, ^C.       *
;*  11/09/89 jimmat   Added more IOCTL 0Dh support for Windows. *
;*  10/11/89 jimmat   Changed hooking of Int 1,2,3 under a      *
;*                    debugger to work better with CVW.         *
;*  07/28/89 jimmat   Fixed Int 21h/56h (Rename), fixed Int 21  *
;*                    calls that just returned a pointer.       *
;*  06/07/89 jimmat   Fixed length of FCB moves and special     *
;*                    case hooking Int 1Eh.                     *
;*  05/30/89 jimmat   Completed Int 21h/5Ah processing.         *
;*  04/25/89 jimmat   Added support for undocumented INT 21h    *
;*                    5Fh/05 DOS call.                          *
;*  04/12/89 jimmat   Allow one level of nested DOS calls to    *
;*                    support PM critical error handlers        *
;*  04/10/89 jimmat   Supported INT 21h/5Eh & 5Fh--also small   *
;*                    clean-up of the dosentry/dosexit code.    *
;*  04/05/89 jimmat   Fixed MOVDAT FCB length check.            *
;*  04/04/89 jimmat   Stop reflecting real mode software ints   *
;*                    to protect mode.  This is how Windows/386 *
;*                    works, and it fixes a problem with DOS    *
;*                    networks since the real mode redirector   *
;*                    expects to have access to the DOS stack,  *
;*                    not a DOS extender interrupt stack frame. *
;*  03/28/89 jimmat   Incorporated bug fixes from GeneA         *
;*  03/17/89 jimmat   Some code clean-up and debugging checks   *
;*  03/15/89 jimmat   Minor changes to run child in ring 1      *
;*  02/22/89 (GeneA): removed dead code and data left over      *
;*      from the Murray Sargent/SST days.                       *
;*  02/22/89 (GeneA): moved handlers for all interrupts but     *
;*      Int 21h to DXINTR.ASM.  Fixed problem with re-entrancy  *
;*      caused when the other interrupts were executed while    *
;*      in DOS.  (int 15h was causing the specific problem).    *
;*  02/14/89 (GeneA): fixed bug in IntExitMisc.  Was storing    *
;*      return value in rmrg.xes, changed to pmrg.xes.          *
;*  02/10/89 (GeneA): changed Dos Extender from small model to  *
;*      medium model.                                           *
;*  12/01/88 (GeneA): Changed name of mentry and mexit to       *
;*      IntEntryMouse and IntExitMouse.  Added functions        *
;*      IntEntryMisc and IntExitMisc to handle entry and        *
;*      exit processing for BIOS INT 15h.                       *
;*  11/20/88 (GeneA): modified DFSetVector so that is checks to *
;*      see if a vector has already been hooked before saving   *
;*      the old value in the real mode interrupt vector shadow  *
;*      buffer.                                                 *
;*  09/15/88 (GeneA):   created by extracting code from the     *
;*      SST debugger modules DOSXTND.ASM, VIRTMD.ASM,           *
;*      VRTUTIL.ASM, and INTERRPT.ASM                           *
;*                                                              *
;****************************************************************

        .286p
        .287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include intmac.inc
include bop.inc
include dpmi.inc
include hostdata.inc
        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

; STKSTR  -- stack layout structure for user registers in the pmrg and
; rmrg arrays in the data segment DXDATA.  pmrg is an exact replica of the pm
; user registers on entry to the Dos Extender (DE).  rmrg is a translated
; version used to communicate with the real-mode world.  The rmrg array is
; initially set equal to the pm user values by the instructions push ds, push
; es, pusha.  The pmrg array es and ds are inevitably set equal to the pm user
; values and its general register values are defined if data translations may be
; required (int-10/21).

stkstr  struc           ;Level-0 Stack structure. bp is set = sp here
xdi     dw      ?
xsi     dw      ?
xbp     dw      ?
xasp    dw      ?       ;Alternate sp
xbx     dw      ?
xdx     dw      ?
xcx     dw      ?
xax     dw      ?       ;pusha pushes xax to xdi
xes     dw      ?
xds     dw      ?
stkstr  ends


; -------------------------------------------------------
;   This structure describes the EXEC parameter block used
;   by MS-DOS function 4Bh.

execblk struc           ;INT-21 ah=4bh EXEC parameter block
evrnmt  dw      ?       ;Paragraph of environment string to be passed
cmdptr  dd      ?       ;Ptr to command line to be placed at PSP+80h
fcb1ptr dd      ?       ;Ptr to default FCB to be passed at PSP+5ch
fcb2ptr dd      ?       ;Ptr to default FCB to be passed at PSP+6ch
xsssp   dd      ?       ;Initial program stack ss:sp
xcsip   dd      ?       ;Program entry point cs:ip
execblk ends

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   gtpara:NEAR
        extrn   GetSegmentAddress:NEAR
        extrn   EnterRealMode:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   SelOff2SegOff:NEAR
        extrn   ParaToLDTSelector:NEAR
        extrn   NSetSegmentDscr:FAR
        extrn   ChildTerminationHandler:NEAR

; -------------------------------------------------------
;               DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   selGDT:WORD
        extrn   segPSPChild:WORD
        extrn   npXfrBuf1:WORD
        extrn   rgbXfrBuf0:BYTE
IFDEF WOW_x86
        extrn   FastBop:FWORD
ENDIF

        extrn   segDXCode:word
        extrn   segCurrentHostData:word
; -------------------------------------------------------
;           General DOS EXTENDER Variables
; -------------------------------------------------------

pmdta   dw      2 dup(?)    ;PM DTA.  Used for getting dir info

EntryFlag db    -1          ;Flag to check for nested DOS interrupts

rcount  dw      ?       ;Remaining requested file byte count to read/write
ccount  dw      ?       ;Current count of total read/written

;=======================================================================
;Keep from here thru Iend in the following order:

        align   2
Ibegin  label   byte            ;start of PMIntrDos nested 'Instance' data

        dw      128 dup(?)      ;Extra stack for real mode

rmrg    stkstr  <>              ;Corresponding real-mode set
rmivip  dw      ?               ;Real-mode interrupt-vector offset
rmivcs  dw      ?               ;Real-mode interrupt-vector segment
rmivfl  dw      ?               ;Real-mode interrupt flags to be used
rmroff  dw      ?               ;Real-mode return address offset
rmrseg  dw      ?               ;Real-mode return address segment
rmflags dw      ?               ;flags

pmrg    stkstr  <>              ;Protected-mode user registers

        public  pmusrss, pmusrsp

pmusrsp dw      ?       ;PM user sp
pmusrss dw      ?       ;PM user ss

enxseg  dw      ?       ;transfer segment used on dos function exit

Iend    label   byte    ;end of PMIntrDos nested 'Instance' data
;=======================================================================

ILENGTH equ     Iend - Ibegin   ;length of instance data

Isave   db      ILENGTH dup (?) ;instance data save area

DXDATA  ends


; -------------------------------------------------------
;               CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   segDXData:WORD
        extrn   selDgroup:WORD

DXCODE  ends

DXPMCODE    segment

        extrn   selDgroupPM:WORD
        extrn   segDXCodePM:WORD
        extrn   segDXDataPM:WORD

; -------------------------------------------------------
;           Dos Function Parameter Tables
; -------------------------------------------------------

; The Dos Extender provides parameter buffering and translation
; on entry to and exit from Dos system calls.  The following table
; is used to describe the operations to be performed for this process.
; The basic idea is that there is an entry parameter code and an
; exit paramter code.  This code describes whether any data buffering
; is necessary.  If buffering is necessary, it describes the nature of
; the data being transferred (e.g. ASCIIZ string, FCB, etc.) which is
; used to determine the transfer length.  The entry/exit code also
; describes which temporary buffer to use for the transfer, and which
; user register (e.g. DS:DX, ES:BX, etc) points to the data to transfer.
;
; The data transfers described by this table is sufficient to handle
; the majority of the Dos system calls.  However, any Dos call which
; requires the transfer of more than one buffer of data, or which requires
; that additional processing be performed other than simply copying a
; buffer is handled with special case code.


; The following symbols define various parts of the entry/exit codes
; used in the parameter table.

; Nibble 0 of a transfer word is a code that specifies the length of the
; transfer as follows:

; 0       no xfer
; 1       FCB                     to/from         (f,10,11,12,13,16,17,23,24,29
; 2       PTR$                    from            (1b,1c,34)
; 3       ASCZ                    to/from         (39,3a,3b,3c,3d,41,43,4b,4e,56
;                                                  5a,5b)
; 4       DOLLAR terminated       to DOS          (9)
; 5       AX$                     from            (3f)
; 6       CX$                     to/from         (3f,40,44)
; 7       KEYBUF                  to/from DOS     (a)
; 8       Country INFO (34)       to/from         (38)
; 9       EXTERR (22)             to              (5d)
; a       DIRectory (64)          from            (47)
; b       EXEC parm (14)          to              (4b)
; c       file MATCH (43)         to/from         (4e,4f)
; d       CMND line (128)         to              (29)
; e       PALETTE (17)            to              (int-10/1002)
; f       VBIOS (64)              from            (int-10/1b)
;
;
; Nibble 1 specifies the segment value transferred as follows (DOS entries
; affected are listed in parentheses):
;
; Segment ptr
;
; 0       none
; 1       ds:dx   to/from DOS     (9,a,f,10,11,12,13,14,16,17,21,22,23,24,25,27
;                                  28,39,3a,3b,3c,3d,3f,40,41,43,44,4b,4e,4f,56
;                                  5a,5b)
; 2       DTA     to/from         (11,12,14,15,21,22,27,28,4e)
; 3       ds:bx   from            (1b,1c)         (Allocation table info)
; 4       ds:si   to/from         (29,47)         (Parse FN, get dir)
; 5       es:di   to/from         (29,56)         (Parse FN, rename)
; 6       es:bx   to/from         (2f,35,4b)      (Get DTA, intvct, EXEC)
; 7       es      to              (49,4a)         (RAM allocation)
;
; Byte 1 (high byte) on has meanings:
;
; bit 0 = 1       (A0) use small data area 0 (limited to 60h bytes)
; bit 1 = 1       (A1) use large area 1 (4K)
; bit 2 = 1       (RP) Real/Protect mode transfer needed (for int 21 ah = 3f/40)
; bit 7 = 1/0     (EX) exitcd/entrycd


entrycd record  EnArea:4,EnSegCod:4,EnLenCod:4
exitcd  record  ExArea:8,ExSegCod:4,ExLenCod:4

;Length codes:

FCB     equ     1
PTR$    equ     2       ;only supports DSBX & ESBX for now (and DSSI if DBCS)
ASCZ    equ     3
DOL     equ     4
AX$     equ     5
CX$     equ     6
KYB     equ     7
INFO    equ     8       ;Constant length transfers from here down vvvvvvvv
EXTERR  equ     9
DIR     equ     0Ah
EXEC    equ     0Bh
MTCH    equ     0Ch
CMD     equ     0Dh
PALETTE equ     0Eh
VBIOS   equ     0Fh     ;Constant length transfers from here up ^^^^^^^^^^

;Segment codes:

DSDX    equ     1
DTA     equ     2
DSBX    equ     3
DSSI    equ     4
ESDI    equ     5       ;Also used by int-10/ah=1bh
ESBX    equ     6       ;Also used by int-10/ah=1ch
ES$     equ     7
ESDX    equ     8       ;Used by int-10/ah=10,12, int-33/ah=22,23
ESBP    equ     9       ;Used by int-10/ah=11,13


;RAM area codes:

A0      equ     1
A1      equ     2
RP      equ     4
EX      equ     80h


pmrmxfr entrycd <>              ;0 - Program Terminate
        exitcd  <>
        entrycd <>              ;1 - Keyboard Input
        exitcd  <>
        entrycd <>              ;2 - Display output
        exitcd  <>
        entrycd <>              ;3 - Auxiliary Input
        exitcd  <>
        entrycd <>              ;4 - Auxiliary Output
        exitcd  <>
        entrycd <>              ;5 - Printer Output
        exitcd  <>
        entrycd <>              ;6 - Direct Console I/O
        exitcd  <>
        entrycd <>              ;7 - Direct Console Input Without Echo
        exitcd  <>
        entrycd <>              ;8 - Console Input Without Echo
        exitcd  <>
        entrycd <A1,DSDX,DOL>   ;9 - Print string
        exitcd  <>
        entrycd <A1,DSDX,KYB>   ;0A - Buffered Keyboard Input
        exitcd  <EX+A0,DSDX,KYB>
        entrycd <>              ;0B - Check Standard Input Status
        exitcd  <>
        entrycd <>              ;0C - Clear Kbd Buffer and Invoke Kbd Function
        exitcd  <>
        entrycd <>              ;0D - Disk Reset
        exitcd  <>
        entrycd <>              ;0E - Select Disk
        exitcd  <>
        entrycd <>              ;0F - Open File        ** Unsupported! **
        exitcd  <>
        entrycd <>              ;10 - Close File       ** Unsupported! **
        exitcd  <>
        entrycd <A0,DSDX,FCB>   ;11 - Search for First Entry
        exitcd  <EX+A1,DTA,FCB>
        entrycd <A0,DSDX,FCB>   ;12 - Search for Next Entry
        exitcd  <EX+A1,DTA,FCB>
        entrycd <A0,DSDX,FCB>   ;13 - Delete File
        exitcd  <>
        entrycd <>              ;14 - Sequential Read  ** Unsupported! **
        exitcd  <>
        entrycd <>              ;15 - Sequential Write ** Unsupported! **
        exitcd  <>
        entrycd <>              ;16 - Create File      ** Unsupported! **
        exitcd  <>
        entrycd <A0,DSDX,FCB>   ;17 - Rename File
        exitcd  <>
        entrycd <>              ;18 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;19 - Current Disk
        exitcd  <>
        entrycd <A1,DSDX,>      ;1A - Set Disk Transfer Address
        exitcd  <>
        entrycd <>              ;1B - Allocation Table Info
        exitcd  <,DSBX,PTR$>
        entrycd <>              ;1C - Alloc Table Info for Specific Device
        exitcd  <,DSBX,PTR$>
        entrycd <>              ;1D - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;1E - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;1F - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;20 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;21 - Random Read      ** Unsupported! **
        exitcd  <>
        entrycd <>              ;22 - Random Write     ** Unsupported! **
        exitcd  <>
        entrycd <>              ;23 - File Size        ** Unsupported! **
        exitcd  <>
        entrycd <>              ;24 - Set Relative Record Field ** Unsupported! **
        exitcd  <>
        entrycd <,DSDX,>        ;25 - Set Interrupt Vector (0/ds:dx/0)
        exitcd  <>
        entrycd <,DSDX,>        ;26 - Create new PSP
        exitcd  <>
        entrycd <>              ;27 - Random Block Read  ** Unsupported! **
        exitcd  <>
        entrycd <>              ;28 - Random Block Write ** Unsupported! **
        exitcd  <>
        entrycd <A0,DSSI,ASCZ>  ;29 - Parse Filename
        exitcd  <EX+A1,ESDI,FCB>
        entrycd <>              ;2A - Get Date
        exitcd  <>
        entrycd <>              ;2B - Set Date
        exitcd  <>
        entrycd <>              ;2C - Get Time
        exitcd  <>
        entrycd <>              ;2D - Set Time
        exitcd  <>
        entrycd <>              ;2E - Set/Reset Verify Switch
        exitcd  <>
        entrycd <>              ;2F - Get Disk Transfer Address
        exitcd  <EX+A0,ESBX,>
        entrycd <>              ;30 - Get DOS Version Number
        exitcd  <>
        entrycd <>              ;31 - Terminate and Stay Resident
        exitcd  <>
        entrycd <>              ;32 - Get Drive Parameter Block
        exitcd  <,DSBX,PTR$>
        entrycd <>              ;33 - Ctrl-Break Check
        exitcd  <>
        entrycd <>              ;34 - Get InDOS flag address
        exitcd  <,ESBX,PTR$>
        entrycd <>              ;35 - Get Interrupt Vector
        exitcd  <EX,ESBX,>
        entrycd <>              ;36 - Get Disk Free Space
        exitcd  <>
        entrycd <>              ;37 - Used Internally by DOS
        exitcd  <>
        entrycd <A1,DSDX,>      ;38 - Set/Get Country Dependent Info
        exitcd  <EX+A1,DSDX,INFO>
        entrycd <A0,DSDX,ASCZ>  ;39 - MKDIR
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;3A - RMDIR
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;3B - CHDIR
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;3C - Create a File
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;3D - Open a File
        exitcd  <>
        entrycd <>              ;3E - Close a File Handle
        exitcd  <>
        entrycd <RP,DSDX,>      ;3F - Read from a File or Device
        exitcd  <EX+RP,DSDX,AX$>
        entrycd <RP,DSDX,CX$>   ;40 - Write to a File or Device
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;41 - Delete a File from a Specified Directory
        exitcd  <>
        entrycd <>              ;42 - Move File Read/Write Pointer
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;43 - Change File Mode
        exitcd  <>
        entrycd <>              ;44 - I/O Control for Devices
        exitcd  <>               ;See ioctlw for write
        entrycd <>              ;45 - Duplicate a File Handle
        exitcd  <>
        entrycd <>              ;46 - Force a Duplicate of a File Handle
        exitcd  <>
        entrycd <A0,DSSI,>      ;47 - Get Current Directory
        exitcd  <EX+A0,DSSI,ASCZ>
        entrycd <>              ;48 - Allocate Memory
        exitcd  <>
        entrycd <,ES$,>         ;49 - Free Allocated Memory
        exitcd  <>
        entrycd <,ES$,>         ;4A - Modify Allocated Memory Blocks
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;4B - Load or Execute a Program (EXEC)
        exitcd  <>
        entrycd <>              ;4C - Terminate a Process
        exitcd  <>
        entrycd <>              ;4D - Get Return Code of a Sub-process
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;4E - Find First Matching File
        exitcd  <EX+A1,DTA, MTCH>
        entrycd <A1,DTA,MTCH>   ;4F - Find Next Matching File
        exitcd  <EX+A1,DTA, MTCH>
        entrycd <,ESBX,>        ;50 - Set current PSP (code restores bx)
        exitcd  <>
        entrycd <>              ;51 - Get current PSP
        exitcd  <>
        entrycd <>              ;52 - Get Pointer to SysInit Variables
        exitcd  <,ESBX,PTR$>
        entrycd <A1,DSSI,DIR>   ;53 - Set Drive Parameter Block
        exitcd  <>
        entrycd <>              ;54 - Get Verify Setting
        exitcd  <>
        entrycd <,DSDX,>        ;55 - Duplicate PSP
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;56 - Rename a File
        exitcd  <>
        entrycd <>              ;57 - Get/Set a File's Date and Time
        exitcd  <>
        entrycd <>              ;58 - Get/Set Allocation Strategy
        exitcd  <>
        entrycd <>              ;59 - Get Extended Error
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;5A - Create Temporary File
        exitcd  <EX+A0,DSDX,ASCZ>
        entrycd <A0,DSDX,ASCZ>  ;5B - Create New File
        exitcd  <>
        entrycd <>              ;5C - Lock/Unlock File Access
        exitcd  <>
        entrycd <A0,DSDX,EXTERR>  ;5D - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;5E - Network Machine Name/Printer Setup
        exitcd  <>
        entrycd <>              ;5F - Get/Make Assign-List Entry
        exitcd  <>
        entrycd <>              ;60 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;61 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;62 - Get PSP Address
        exitcd  <>
        entrycd <>              ;63 - Get Lead Byte Table  ** Unsupported! **
        exitcd  <>
        entrycd <>              ;64 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;65 - Get Extended Country Info
        exitcd  <EX+A1,ESDI,CX$>;     ** Only Partially Supported **
        entrycd <>              ;66 - Get/Set Code Page
        exitcd  <>
        entrycd <>              ;67 - Set Handle Count
        exitcd  <>
        entrycd <>              ;68 - Commit File
        exitcd  <>
        entrycd <>              ;69 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;6A - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;6B - Used Internally by DOS
        exitcd  <>
        entrycd <A0,DSSI,ASCZ>  ;6C - Extended Open File
        exitcd  <>

MaxInt21 equ    06Ch            ;max supported Int 21h function

UnSupported entrycd <>          ;for unsupported DOS calls
            exitcd  <>

if DEBUG   ;------------------------------------------------------------

; Table of partially supported/unsupported/unknown Int 21h functions

ifdef DBCS
tblBad21  db    18h,1Dh,1Eh,1Fh,20h,37h,5Dh,60h,61h
          db    64h,65h,6Ah,6Bh,0
else
tblBad21  db    18h,1Dh,1Eh,1Fh,20h,37h,5Dh,60h,61h,63h
          db    64h,65h,6Ah,6Bh,0
endif
endif   ;DEBUG  --------------------------------------------------------
;
; For compatibility with WIN386, the following FCB calls are failed
; unconditionally.
;
MIN_REAL_BAD_21 equ     0fh
MAX_REAL_BAD_21 equ     28h

tblRealBad21    db 0fh,10h,14h,15h,16h,21h,22h,23h,24h,27h,28h,0



; Special codes for special INT 21h functions

int215E         entrycd <A0,DSDX,>              ;5E/00 - Get Machine Name
                exitcd  <EX+A0,DSDX,ASCZ>
                entrycd <A0,DSDX,ASCZ>          ;5E/01 - Set Machine name
                exitcd  <>
                entrycd <A0,DSSI,CX$>           ;5E/02 - Set Printer Setup Str
                exitcd  <>
                entrycd <A0,ESDI,>              ;5E/03 - Get Printer Setup Str
                exitcd  <EX+A0,ESDI,CX$>

int215F02       entrycd <A0,DSSI>               ;5F/02 - Get Redir List Entry
                exitcd  <EX+A0,DSSI,ASCZ>
                entrycd <A0,DSSI,ASCZ>          ;5F/03 - Set Redir List Entry
                exitcd  <>
                entrycd <A0,DSSI,ASCZ>          ;5F/04 - Cancel Redirection
                exitcd  <>
                entrycd <A0,DSSI>               ;5F/05 - Get Redir List Entry
                exitcd  <EX+A0,DSSI,ASCZ>

ifdef DBCS
int2163         entrycd <>              ;63/00 - Get Lead Byte Table Entry
                exitcd  <,DSSI,PTR$>
endif ; DBCS

int21esdi       entrycd <A1,ESDI,ASCZ>          ;56 & 5F/02&03&05 eXtra buffer
                exitcd  <EX+A1,ESDI,ASCZ>


;
; We only use the entry code from the following.  If we don't
; we trash the stack in applications like borland c++
;
int21pfn        entrycd <A1,ESDI,FCB>           ;29, fcb buffer
                exitcd  <>


; Additional tables for run time support associated with register
; translation and buffering.

;                 8   9       a    b    c     d     e      f
;               INFO EXTERR  DIR  EXEC MATCH CMND PALETTE VBIOS
mvcnt   db      34,   22,    40h, 0Eh,  43,   80h,  17,    64

;                 1    2     3     4     5     6    7     8     9
;               DSDX, DTA, DSBX, DSSI, ESDI, ESBX, ES$, esdx, esbp
regoffs dw       xdx,  0,   xbx,  xsi,  xdi,  xbx,  0,   xdx,  xbp

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Main Program
        page
; -------------------------------------------------------
;               MAIN PROGRAM
; -------------------------------------------------------


DXPMCODE  segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntrDos -- This function is the main handler for int 21h calls
;       that require special case processing.  Most interrupts
;       go through the interrupt reflector (PMIntrReflector in
;       dxintr.asm).  DOS int 21h interrupts are vectored here.
;
;       This routine performs any register manipulation, data buffering
;       etc. needed to pass the interrupt parameters from the
;       protected mode caller to the real mode handler.  Register
;       manipulation and data transfers can occur either on entry
;       to the interrupt handler or on exit from the interrupt
;       handler (to fix up return values.)
;
;   Input:  normal registers for Dos calls
;   Output: normal register returns for Dos calls
;   Errors: normal Dos errors
;   Uses:   In general, all registers are preserved.  For interrupts where
;           register translation or buffering occurs, some registers may
;           be changed, depending on the interrupt and its parameters.

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrDos

PMIntrDos       proc    far

        push    ds
        push    ax
        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax
        assume  ds:DGROUP
        mov     ax,ss
        mov     pmusrss,ax
        mov     ax,sp
        add     ax,4
        mov     pmusrsp,ax
        pop     ax

        FBOP    BOP_DPMI,XlatInt21Call,FastBop
; If we get here, the api wasn't translated.  The translation code will
; simulate the iret
        assume  ds:nothing

NotXlated:
        cld                     ;Code assumes direction flag is cleared

; Save PM user ds, es, and flags, and switch to DOS extender stack

        push    ax              ;Save caller's AX
        push    bp
        mov     bp,sp           ;[bp] = bp ax ip cs fl - 286 int gates assumed
                                ;        0  2  4  6  8
        push    es

        mov     es,selDgroupPM          ;Address our DGROUP
        assume  es:DGROUP


; Check for nested DOS interrupts--this code was written with the assumption
; that we would never be reentered, but it turns out that we may need to
; support nested DOS calls from a critical error handler.  If this is one
; of those ultra-rare occasions, save our previous 'instance' data in Isave.

        inc     EntryFlag       ;The normal case will be to jump
        jz      @f

        push    cx              ;Being reentered, save last instance data
        push    di
        push    si

        mov     cx,ILENGTH                      ;NOTE!!!  The next movs has
        mov     si,offset DGROUP:Ibegin         ;  an es override, if ints
        mov     di,offset DGROUP:Isave          ;  are enabled, an interrupt
        rep movs byte ptr [di],byte ptr es:[si] ;  on this instr can 'forget'
                                                ;  about the es override with
        pop     si                              ;  some processors
        pop     di
        pop     cx
@@:

; Start saving callers state.

        mov     pmrg.xds,ds     ;Save PM user ds
        mov     ax,[bp+8]       ;Get ax = flags when int occurred
        mov     rmflags,ax      ;Store flags for real-mode handler

        pop     pmrg.xes        ;Save PM user es

        pop     bp
        pop     ax              ;Recover user ax. [sp] = ip cs fl

; At this point all general registers (but not ES) have the user's values

        push    es              ;Address DGROUP, user's DS already
        pop     ds              ;  saved in pmrg.xds
        assume  ds:DGROUP

        mov     pmusrss,ss      ;Save PM user stack ptr
        mov     pmusrsp,sp      ;[sp] = ds ip cs fl
                                ;        0  2  4  6
        mov     pmrg.xsi,si     ;Save PM si since need to use before pusha

        push    ds              ;Switch to rmrg stack for this routine
        pop     ss
        mov     sp,offset DGROUP:rmflags        ;PM flags already on stack
        FSTI                     ;We don't really need interrupts disabled


; Setup iret frames for iret'ing to real-mode handler and for that handler
; returning to the DOS extender

        pop     si              ;Get rmflags
        and     si,not 4100h    ;Kill NT, TF
        push    si              ;Push flags for iret to BackFromDOS
        push    segDXCodePM     ;Push return cs:ip for iret
        push    offset BackFromDOS

        and     si,not 0200h    ;Kill IF
        push    si              ;Push flags for iret to real-mode handler

        sub     sp,4                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        mov     ax,es:[21h*4]
        mov     [bp + 2],ax
        mov     ax,es:[21h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp


; Setup protected mode and real mode copies of registers.

        mov     si,pmrg.xsi     ;Restore si
        push    ds              ;Save space for real mode ds
        push    es              ;  and es
        pusha                   ;Save user general registers

        mov     si,offset DGROUP:rmrg   ;Copy user values to PM set for
        mov     di,offset DGROUP:pmrg   ;  reference (real-mode set may change)
        mov     cx,8            ;8 general registers (es and ds already stored)
        rep     movsw

        mov     ax,segDXDataPM  ;ax = DOS extender real-mode dgroup segment
        mov     rmrg.xds,ax     ;Default real-mode data segments
        mov     rmrg.xes,ax     ;  (dosentry may change them)

        mov     ax,rmrg.xax

if DEBUG   ;------------------------------------------------------------

; Check for partially supported/unsupported/unknown DOS calls

        cmp     ah,0DCh                 ;krnl286 is doing this now, quit
        jz      goodfunc                ;  complaining about it

        cmp     ax,5D0Ah                ;Set Extended Error is the only
        jz      goodfunc                ;5Dh function handled properly!

        cmp     ah,MaxInt21             ;is the request within our range?
        ja      badfunc

        mov     bx,offset DXPMCODE:tblBad21
@@:
        cmp     ah,cs:[bx]
        jb      goodfunc
        jz      badfunc
        inc     bx
        jmp     short @b

badfunc: Trace_Out "Possible Unsupported DOS Call! AX=#AX"

goodfunc:

endif   ;DEBUG  --------------------------------------------------------

; Check for FCB calls that we fail unconditionally (because WIN386 does.)

        cmp     ah,MIN_REAL_BAD_21
        jb      goodfunc1
        cmp     ah,MAX_REAL_BAD_21
        ja      goodfunc1

mov     bx,offset DXPMCODE:tblRealBad21
@@:
        cmp     ah,cs:[bx]
        je      badfunc1
        inc     bx
        cmp     byte ptr cs:[bx],0
        jz      goodfunc1               ; Ran off end of table.
        jmp     short @b

badfunc1:

if DEBUG
        Debug_Out "Unsupported DOS Call! AX=#AX"
endif   ;DEBUG

        or      byte ptr rmflags,1      ; Set CF
        call    xfrflg
        jmp     LeaveDOSExtender

goodfunc1:


; int 21 entry register translations and data transfers
        cmp     ah,00h          ;old style DOS Exit call?
        jnz     @f
        call    DosExitCall     ;sets CY if it handles the call, otherwise
        jnc     @f              ;  do it normally...
        jmp     LeaveDOSExtender
@@:
        ;
        ; Handle terminate specially.  We mess with the PSP here to set
        ; up a terminate vector we like.  We don't do anything special for
        ; TSR (31h)
        ;
        cmp     ah,4ch          ; terminate?
        jnz     @f

        call    TerminateProcess
@@:

        cmp     ah, 5dh         ; check for unsupported 5d codes
        jnz     short @f
        cmp     al, 0ah
        jz      short @f
        jmp     LeaveDOSExtender
@@:

        mov     rcount,0        ;Default no remaining bytes to read/write
        mov     ccount,0        ;No bytes read or written yet

        cmp     ah,3Fh          ;If read
        jz      @f
        cmp     ah,40h          ;  or write,
        jnz     TransferLoop
@@:
        mov     cx,pmrg.xcx     ;  initialize remaining count = requested value
        mov     rcount,cx


; Start of loop for doing large read/write transfers

TransferLoop:

        call    dosentry        ;Do selector translations, data buffering


; Come here after entry register translations and data transfers are complete

        SwitchToRealMode        ;Switch back to real mode.  ds = es = rm dgroup
                                ;Stack is at same place in memory

; Set registers to possibly translated values and iret to real-mode DOS.
; DOS then irets to BackFromDOS.

        popa                    ;Set appropriate general register values

        pop     es
        pop     ds

        public  GoingToDOS

GoingToDOS:                     ;for debugging, etc.

        iret                    ;invoke real mode DOS

        assume  ds:NOTHING, es:NOTHING, ss:NOTHING


; Return here from real-mode interrupt handler (DOS)

        public  BackFromDOS

BackFromDOS:

        pushf                   ;Save return flags (to rmflags)
        cld                     ;  (better safe than sorry)

        push    cs              ;Push return cs:ip for multiple xfers
        push    offset BackFromDOS

        sub     sp,2*3          ;Bypass room for iret to interrupt handler
                                ; (to keep stack layout the same as on entry)

        push    ds              ;Save register set
        push    es
        pusha

        mov     ds,segDXData
        assume  ds:DGROUP


;  "push" iret frame for real mode int 21 rtn in case we need to do it again

        mov     ax,rmflags
        and     ax,not 4300h    ;Kill NT, TF, and IF
        mov     rmivfl,ax

        xor     ax,ax
        mov     es,ax
        mov     ax,word ptr es:[21h*4+2]
        mov     rmivcs,ax
        mov     ax,word ptr es:[21h*4]
        mov     rmivip,ax


; Switch back to protected mode

        SwitchToProtectedMode   ;Switch back to protected mode
        assume  ds:DGROUP,es:DGROUP

        FSTI                     ;Don't need ints disabled

        call    xfrflg          ;Transfer relevant return flags over to pm iret frame

        mov     ax,pmrg.xax     ;Recover AX from caller


; Perform any int-21 selector translations, data buffering

        call    dosexit


; Check for large xfers (Read File 3Fh, Write File 40h, some IOCTL 44h)

        cmp     rcount,0        ;Read/write more bytes?
        jz      TransferDone

        mov     cx,rmrg.xax     ;Maybe. cx = count transferred (if 3Fh or 40h)
        mov     ax,pmrg.xax     ;Restore entry code
        mov     rmrg.xax,ax

        cmp     ah,40h          ;Write?
        jnz     @f

        sub     rcount,cx       ;Yes. Written all originally requested?
        jz      TransferDone

        cmp     cx,rmrg.xcx     ;  No. Written all last specified?
        jz      @f              ;    Yes. Go do some more

        mov     ax,ccount       ;A large write has failed!  ccount has already
        sub     ax,rmrg.xcx     ;  been updated assuming success, back out the
        add     ax,cx                   ;  attempted xfer amount, and add in
        jmp     short TransferCount     ;  the actual, then split
@@:
        jmp     TransferLoop    ;Yep (or 3Fh or 44h). Do another xfer

TransferDone:
        mov     ax,ccount       ;Multiple count xfer?
        or      ax,ax
        jz      LeaveDOSExtender

TransferCount:
        mov     rmrg.xax,ax     ;Yes update return amount
        mov     ax,pmrg.xcx
        mov     rmrg.xcx,ax     ;Restore initial request count


; Restore possibly translated registers and to return to pm caller

        public  LeaveDOSExtender

LeaveDOSExtender:

        popa                    ;Restore possibly changed user registers

        mov     ss,pmusrss      ;Restore pm user stack
        mov     sp,pmusrsp
        assume  ss:NOTHING

        push    pmrg.xds        ;push user seg regs on user stack
        push    pmrg.xes

        dec     EntryFlag       ;dec nested entry flag - normal case is to jmp
        jnz     NotNested
                                ;If this was a nested DOS call (from
        push    cx              ;  a critical error handler), restore
        push    si              ;  the state for the prior DOS call
        push    di              ;  which is still in progress

        mov     cx,ds           ;make darn sure es -> DGROUP
        mov     es,cx

        cld                                     ;NOTE: we need to retreive
        mov     cx,ILENGTH                      ;  all current user registers
        mov     di,offset DGROUP:Ibegin         ;  before moving this data
        mov     si,offset DGROUP:Isave
        rep movsb

        pop     di
        pop     si
        pop     cx

NotNested:
        pop     es              ;restore user seg regs
        pop     ds
        assume  ds:NOTHING,es:NOTHING

        public  DOSXiret
DOSXiret:                       ;for debugging, etc.

        iret                    ;return to caller

PMIntrDos       endp


; -------------------------------------------------------
;   DOSENTRY    -- This function performs buffering and register
;       translation for entry into MS-DOS functions.
;
;   Input:      AX:  AX value at time of INT 21h
;   Output:
;   Errors:
;   Uses:

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP

dosentry:

        cmp     ah,26h          ;Create new PSP?
        jnz     @f
        mov     si,rmrg.xdx     ;yes, translate selector to paragraph
        call    gtpara
        mov     rmrg.xdx,ax
        return
@@:
        cmp     ah,53h          ;Set drive parameter block?
        jnz     @f
        push    ax
        mov     si,pmrg.xes     ;int 21h/53h has an extra parameter in ES:BP
        call    gtpara          ;  we change the selector to a segment, but
        mov     rmrg.xes,ax     ;  the segment had better already be in
        pop     ax              ;  conventional memory
        jmp     short dentr2b
@@:
        cmp     ah,50h          ;Set current PSP?
        jnz     dentr1
        mov     si,rmrg.xbx     ;Yes. Translate selector to paragraph
        call    gtpara
        mov     rmrg.xbx,ax
        return

dentr1: cmp     ah,55h          ;Duplicate PSP?
        jnz     dentr2
        mov     si,rmrg.xbx     ;Translate selector bx to paragraph
        call    gtpara
        mov     rmrg.xbx,ax
        mov     si,rmrg.xdx     ;  and dx also
        call    gtpara
        mov     rmrg.xdx,ax
        return

dentr2:
        cmp     ah,56h          ;Rename?
        jnz     dentr2a
        push    ax              ;rename has a second ASCIIZ buffer
        push    pmrg.xes        ;  pointed to by es:di -- move that
        pop     enxseg          ;  now, the ds:dx one below
        mov     ax,int21esdi
        call    gtarea          ;let the 'standard' gtarea/movdat
        mov     dx,enxseg       ;  routines take care of it
        call    movdat
        pop     ax
        jmp     short dentr2b

dentr2a:
        cmp     ah,5Fh          ;Get/Make Assign-List Entry?
        jne     dentr2a1
        call    net5Fenter      ;  Yes, may require extra buffering
        jmp     short dentr2b

dentr2a1:
        cmp     ah,29h          ; parse filename?
        jne     dentr2b

        push    ax
        push    pmrg.xes
        pop     enxseg
        mov     ax,int21pfn
        call    gtarea
        mov     dx,enxseg
        call    movdat
        pop      ax
;;        jmp     short dentr2b

dentr2b:
        call    GetEntryCd      ;ax = func entry code, di = ptr to entry cd

        or      ax,ax           ;Entry code specify something to do?
        rz

        cmp     byte ptr pmrg.xax+1,1Ah ;Store DTA?
        jnz     dentr3

        mov     pmdta,dx                ;  Yes. Save it for data returns
        push    pmrg.xds
        pop     pmdta+2
        jmp     short dentr4

dentr3: cmp     byte ptr pmrg.xax+1,4Bh ;EXEC program?
        callz   dosxec

; DENTR4 - enter with ax = entrycd/exitcd.  Translate ptr's for real-
; mode calls and transfer any data indicated.

dentr4: push    pmrg.xds
        pop     enxseg
        call    gtarea          ;Get es:di = area for transfer
        rz                      ;Something to xfer?
        mov     dx,enxseg       ;Yes. Fall thru to movdat

        errnz  <movdat-$>


; -------------------------------------------------------
;   MOVDAT      --  This routine performs the buffer transfer
;       for entry into or exit from an MS-DOS function.  The data
;       is copied from DX:SI to ES:DI.  The code in CX determines
;       the type of data being transferred, which is used to determine
;       the length.
;
;   Input:  DX:SI       - far pointer to source buffer
;           ES:DI       - far pointer to destination buffer
;           CX          - transfer length code
;   Output: none
;   Errors: none
;   Uses:   AX, BX, CS, SI, DI modified

        assume  ds:DGROUP,es:NOTHING,ss:DGROUP
        public  movdat

movdat:
        push    ds
        mov     bx,cx           ;Simple count?
        sub     bl,INFO
        jc      movda2
        cmp     bl,PALETTE-INFO ;Yes. Use pm es?
        jc      movda0
        mov     dx,pmrg.xes     ;Yes
movda0: mov     cl,mvcnt[bx]    ;cx = count
movda1: mov     ds,dx

if DEBUG   ;------------------------------------------------------------

        push    ax
        mov     ax,es
        lsl     ax,ax
        sub     ax,di
        jc      movbad
        cmp     ax,cx
        jnc     @f
movbad:
        Debug_Out "Movdat: copy beyond end of dest seg!"
@@:
        pop     ax

endif   ;DEBUG  --------------------------------------------------------

movd1a: rep     movsb           ;Move data
        pop     ds
        return

movda2: cmp     cl,CX$          ;Use pmrg.xcx?
        jnz     movda3
        mov     cx,rmrg.xcx     ;cx usually = pmrg.xcx, but in any event
                                ;  cx < CB_XFRBUF1
movd21: add     ccount,cx
        jmp     short movda1

movda3: mov     ah,0
        cmp     cl,ASCZ
        jz      movda4
        cmp     cl,DOL
        jnz     movda5
        mov     ah,"$"
movda4: mov     ds,dx
movd42: lodsb
        stosb
        cmp     al,ah
        jnz     movd42
        pop     ds
        return

movda5: cmp     cl,AX$  ;Use rmrg.xax?
        jnz     movda6
        mov     cx,rmrg.xax     ;Yes (only occurs for ah=3fh - read - on exit)
        jmp     short movd21

movda6:
        cmp     cl,FCB
        jnz     movda7
        mov     ds,dx
        mov     cl,byte ptr ds:[si]
        cmp     cl,0ffh                 ;standard or extended FCB?
        mov     cx,37                   ;standard FCB len
        jnz     movd1a
        mov     cx,44                   ;extended FCB len
        jmp     short movd1a

movda7:                         ;KYB remains
        pop     ds
        return


; -------------------------------------------------------
;   DOSEXIT     -- This function is called on exit from the MS-DOS
;       functions to perform any data buffering and register translation
;       needed.
;
;   Input:      AX: AX value at time of INT 21h
;   Output:
;   Errors:
;   Uses:

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  dosexit

dosexit:
        cmp     ah,51h          ;Get current PSP?
        jz      dose0a
        cmp     ah,62h          ;Get PSP address?
        jnz     dose00
dose0a:
        mov     ax,rmrg.xbx     ;Yes. Translate segment to selector
        mov     bx,STD_DATA
        call    ParaToLDTSelector
        mov     rmrg.xbx,ax
        return

dose00: cmp     ah,2fh          ;Get current DTA?
        jnz     dose01
        mov     ax,pmdta        ;Yes. Load PM DTA into caller's registers
        mov     rmrg.xbx,ax
        mov     ax,pmdta+2
        verr    ax              ; if the dta selector is no longer valid,
        jz      @f              ; return the NULL selector instead (so we
        xor     ax,ax           ; don't GP fault in DOSX).
@@:     mov     pmrg.xes,ax
        return

dose01: cmp     ah,55h          ;Duplicate PSP?
        jnz     dosex1
        mov     ax,rmrg.xbx     ;Yes, translate segments to selectors
        mov     bx,STD_DATA
        call    ParaToLDTSelector
        mov     rmrg.xbx,ax
        mov     ax,rmrg.xdx
        mov     bx,STD_DATA
        call    ParaToLDTSelector
        mov     rmrg.xdx,ax
        return

dosex1: cmp     ah,56h          ;Rename?
        jnz     dosex2
        push    pmrg.xdi        ;Rename has a second pointer in ES:DI--we
        pop     rmrg.xdi        ;  need to restore DI here, DX below
        jmp     short dosex3

dosex2: cmp     ah,5Fh          ;Get/Make Assign-List Entry?
        callz   net5Fexit       ;  Yes, extra buffering may be needed

dosex3:
        call    GetEntryCd      ;ax=func entry code, di=ptr to entry code

        call    rstreg          ;Restore entry register?
        jz      dosex6

        cmp     byte ptr pmrg.xax+1,29h   ;Yes, Parse filename?
        jnz     dosex4

        add     ax,rmrg.xsi                   ;Yes. Increment past string
        sub     ax,offset DGROUP:rgbXfrBuf0   ;     that was parsed
        push    pmrg.xdi
        pop     rmrg.xdi                ;Restore pm di (for es:di ptr)

dosex4: mov     word ptr rmrg[si],ax    ;Restore register

        cmp     byte ptr pmrg.xax+1,4Bh ;EXEC program
        jnz     dosex6

        push    di
        mov     di,pmrg.xbx         ;Yes, restore bx too (dx restored above)
        mov     rmrg.xbx,di         ;es and ds are restored automatically
        cmp     byte ptr pmrg.xax,1 ;INT-21/4b01h (undocumented debug)?
        jnz     @f

        mov     si,npXfrBuf1       ;Yes. Pass back user ss:sp and cs:ip
        lea     si,[si].xsssp
        lea     di,[di].xsssp
        mov     es,pmrg.xes
        movsw                   ;Move ss:sp
        movsw
        movsw                   ;Move cs:ip
        movsw
@@:
        pop     di

dosex6: mov     ax,cs:[di+2]    ;Exit xfer?
        or      ax,ax
        rz

dosex7: call    CheckStatus     ;Check the DOS return status to see if the
        rnz                     ;  data should be transfered back to PM

        mov     cx,ax           ;Is a pointer being returned? (no data
        and     cl,0fh          ;  transfer)
        cmp     cl,PTR$
        jnz     dosex8

        shr     al,4            ;  yes, isolate pointer type
        mov     si,offset rmrg.xds
        mov     di,offset pmrg.xds
        cmp     al,DSBX
        jz      dosex7a
ifdef DBCS                      ; for function 63h (Get Lead Byte)
        cmp     al,DSSI
        jz      dosex7a
endif ; DBCS
        mov     si,offset rmrg.xes
        mov     di,offset pmrg.xes
dosex7a:
        mov     ax,[si]         ;  get a selector for the segment, and
        mov     bx,STD_DATA     ;  setup to return it to caller
        call    ParaToLDTSelector
        mov     [di],ax
        return

dosex8:
        push    pmrg.xds
        pop     enxseg
        call    gtarea          ;Get area for xfer from PM to DOS
        rz                      ;Something to move?

        xchg    si,di           ;Turn pointers around
        mov     dx,ds           ;dx:si -> DOS xfer area in dgroup
        mov     es,enxseg       ;es:di -> PM-caller data area
        jmp     movdat          ;Yes

; -------------------------------------------------------
;   DosExitCall -- Special processing for DOS exit call service (Int 21h/00h)
;
;       This procedure handles the obsolete Int 21h/00h terminate process
;       call in a special slimy way for Windows.  Instead of doing a 00h
;       DOS call in real mode, it hacks up the parent's PSP and does a 4Ch
;       that causes control to return to the extender, who then RETURNS TO
;       THE CALLER!!!  The caller must then do appropriate set PSP calls, etc.
;       This was implemented so pMode Windows kernel could have DOS clean up
;       after a Windows app terminates, but still have kernel get control
;       back.
;
;       Note:   This code assumes that the Parent PID field contains a
;               SELECTOR!
;
;       Note^2: If for some reason it's the DOS Extender's child that's 1800doing
;               the terminate call, we let it go through normally.
;
;   Input:      none
;   Output:     CY set if exit call processed by this routine, clear otherwise
;   Errors:
;   Uses:       none

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  DosExitCall

DosExitCall     proc    near

        push    ax
        push    bx
        push    dx
        push    es

        SwitchToRealMode                ;much of this is easier in real mode
        FSTI                             ;allow interrupts

        mov     ah,51h                  ;get PSP of current task
        pushf
        FCLI
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     [bp + 6],word ptr (offset dec_10)
        mov     ax,es:[21h*4]
        mov     [bp + 2],ax
        mov     ax,es:[21h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

dec_10: cmp     bx,segPSPChild          ;is this our child terminating?
        jnz     @f                      ;if not, go process the call ourselves
        jmp     decTermChild            ;  yes...
@@:
        FCLI                             ;we want to preserve the current
        xor     ax,ax                   ;  rMode Int 24h handler across this
        mov     es,ax                   ;  exit call (the terminating PSP
        mov     ax,es:[24h*4]           ;  has the pMode handler address).
        mov     dx,es:[24h*4+2]         ;  So get the current Int 24h handler
        FSTI                             ;  address from the rMode IDT.

        mov     es,bx                   ;address terminating PSP
        assume  es:PSPSEG

        mov     word ptr [lpfnInt24],ax         ;point PSP to same Int 24h
        mov     word ptr [lpfnInt24+2],dx       ;  handler

        mov     ax,offset DXCODE:decTermHandler ;point PSP to our termination
        mov     word ptr [lpfnParent],ax        ;  handler
        mov     word ptr [lpfnParent+2],cs

        push    es
        mov     ax,segParentPSP         ;Windows has the PSP's parent
        push    ax                      ;  field as a selector, we need the seg
        mov     dx, [segEnviron]
        push    dx
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP

        FSTI
        pop     ax                          ;get selector for environment
        or      ax,ax                       ; NULL selector (krnl386 does this)
        jnz     @f
        xor     bx,bx                       ; zero environment segment
        jmp     dec_HaveEnvSeg
@@:
        call    GetSegmentAddress
        test    bx,0fff0h                   ; >1mb?
        jz      @f                          ;   no
        xor     bx,bx                       ;   yes, zero environment segment
        xor     dx,dx
@@:
        shr     dx, 4
        shl     bx, 12
        or      bx, dx                      ;seg of environment

dec_HaveEnvSeg:
        pop     ax                          ;get parent psp off stack
        push    bx                          ;save seg of environment

        call    GetSegmentAddress       ;returns BX:DX = lma of segment
        shr     dx,4
        shl     bx,12
        or      bx,dx                   ;bx now = seg of parent psp

        SwitchToRealMode                ;back to the shadows again...
        FSTI
        pop     cx                          ;seg of environment

        pop     dx                      ;terminating PSP segment from stack
        mov     es,bx                   ;address the parent's PSP
        assume  es:PSPSEG

        mov     ax,sp
        sub     ax,12*2                 ;some magic for DOS
        mov     word ptr [lpStack],ax   ;set our stack in parent's PSP
        mov     word ptr [lpStack+2],ss

        mov     es,dx                   ;(re)address terminating PSP
        assume  es:PSPSEG
        mov     [segEnviron], cx

        mov     segParentPSP,bx         ;real DOS doesn't like selectors in
                                        ;  parent PSP field, zap it to segment

        mov     ax,pmrg.xax             ;terminate the process
        mov     ah,4Ch                  ;  with a 4Ch DOS call
        pushf
        FCLI
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     word ptr [bp + 6],offset decTermHandler
        mov     ax,es:[21h*4]
        mov     [bp + 2],ax
        mov     ax,es:[21h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        ;play it safe

decTermHandler:                         ;should return back here

        push    ss
        pop     ds

        SwitchToProtectedMode           ;back to pMode
        assume  ds:DGROUP,es:DGROUP

        FSTI

        les     bx,dword ptr pmusrsp            ;es:bx -> ip cs flag
        and     byte ptr es:[bx+2*2],not 1      ;clear CY in caller's flags

        stc                             ;exit call has been processed

dec90:
        pop     es
        pop     dx
        pop     bx
        pop     ax

        ret

EndHighSegment

BeginLowSegment

decTermChild:

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP

        FSTI
        clc

        jmp     short dec90

DosExitCall     endp


; -------------------------------------------------------
;   net5Fenter  -- Additional entry processing for INT 21h/5Fh
;       functions.
;
;       INT 21h/5Fh subfunctions 2, 3, and 5 have two buffers of data to
;       transfer.  The normal DOSENTRY processing only does one, so we
;       setup the other buffer here.

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  net5Fenter

net5Fenter      proc    near

        cmp     al,2                    ;This routine only works on
        rc                              ;  subfunctions 2, 3, and 5
        cmp     al,4
        rz
        cmp     al,6
        rnc

        push    ax
        mov     ax,int21esdi            ;entry code for INT 21h/5Fh extra buff
        call    gtarea                  ;let gtarea set it up
        pop     ax

        cmp     al,3                    ;Make redirection function?
        rnz

; 5F/03 needs a buffer copied down to A1, but it's non standard in that
; the buffer contains two (count'em 2) asciiz strings

        push    ax
        push    cx
        push    ds

        mov     ds,pmrg.xes             ;user's ES:DI -> buffer, gtarea sets
        xor     ah,ah                   ;  up our si to have user's di
        mov     cl,2

@@:     lodsb                           ;copy one asciiz string
        stosb
        cmp     al,ah
        jnz     @b

        dec     cl                      ;   and then the other
        jnz     @b

        pop     ds
        pop     cx
        pop     ax
        return

net5Fenter      endp


; -------------------------------------------------------
;   net5Fexit  -- Additional exit processing for INT 21h/5Fh
;       functions.
;
;       INT 21h/5Fh subfunctions 2, 3, & 5 have 2 buffers of data to transfer.
;       The normal DOSENTRY processing only does one, so do the other
;       buffer here.

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  net5Fexit

net5Fexit       proc    near

        cmp     al,2                    ;This routine only works on
        rc                              ;  subfunctions 2, 3 and 5
        cmp     al,4
        rz
        cmp     al,6
        rnc

        push    pmrg.xdi                ;Restore protected mode DI register
        pop     rmrg.xdi

        cmp     al,2                    ;Get redirection function?
        jz      @f
        cmp     al,5
        rnz
@@:

; 5F/02 & 05 need a buffer copied from A1

        test    byte ptr rmflags,1      ;Success? (carry flag)
        rnz                             ;  No, don't transfer anything

        push    ax

        mov     ax,int21esdi+2          ;exit code for int 21/5F extra buffer
        push    pmrg.xes
        pop     enxseg
        call    gtarea                  ;let gtarea setup the move
        xchg    si,di
        mov     dx,ds
        mov     es,enxseg
        call    movdat                  ;  and let movdat move it

        pop     ax
        return

net5Fexit       endp


; -------------------------------------------------------
;   RSTREG      -- This function sets up to restore the original
;       protected-mode registers.  This cleans up after register
;       translations performed when going into the or returning
;       from an MS-DOS call.  On entry, AX contains the entry code
;       value from the entry/exit operations table.  If this code
;       implies that a register needs to be restored this function
;       will return with NZ true and AX = original register value
;       and SI pointing to the appropriate location in the PMRG array.
;       If no register needs to be restored, return with Z true.
;
;   Input:  AX      - entry code value
;   Output: NZ true if register needs to be restores
;           AX      - register value to restore
;           SI      - pointer into PMRG to the register image
;           ZR true if no restoration needed
;   Errors: none
;   Uses:   AX, SI modified

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  rstreg

rstreg: or      ax,ax
        rz

        shr     ax,3
        and     ax,1Eh
        rz

        cmp     al,2*DTA        ;DTA?
        rz

        xchg    si,ax           ;No. Restore appropriate register, e.g., dx
        mov     si,regoffs[si-2]
        mov     ax,word ptr pmrg[si]
        return


; -------------------------------------------------------
;   GTAREA      -- This function examines the entry code/exit code
;       parameter and determines if any data transfer needs to be
;       performed.  If so, it sets up pointers and length codes for
;       the transfer.
;       There are two transfer buffers used.  The A0 buffer is 60h bytes
;       long and the A1 buffer is CB_XFRBUF1 bytes (about 4k) long.
;
;   Input:  AX      - entry code/exit code
;   Output: NZ true if something needs to be transferred
;           SI      - offset of source pointer
;           DI      - offset of destination pointer
;           ENXSEG  - segment for caller's buffer
;                     (source on entry, destination on exit)
;           CX      - transfer length/type code
;   Errors: none
;   Uses:   AX, CX, SI, DI, ES modified
;           ENXSEG modified

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  gtarea

gtarea:
        test    ah,RP           ;Real/PM xfer (ah = 3f/40)?
        jz      gtare2

        mov     si,pmrg.xds     ;Yes. *si:pmrg.xdx = pm caller's xfer area
        and     si,SELECTOR_INDEX
        test    ah,EX           ;Exit call?
        jz      gtare1
        push    es
        push    ax
        mov     es,selGDT
        mov     al,es:[si].adrBaseHigh
        mov     ah,es:[si].adrbBaseHi386
        test    ax,0FFF0h                   ; check for transfer to extended
                                            ; memory
        pop     ax
        pop     es
        jnz     @f
        jmp     gtar54
@@:
        mov     cx,rmrg.xax     ;Yes. cx = amount read/written
        sub     rcount,cx       ;Update remaining count
        cmp     cx,rmrg.xcx     ;All that was requested?
        jnc     gtare3
        mov     rcount,0        ;No: done
        jmp     short gtare3

gtare1: push    ax              ;Read/Write entry
        mov     ax,si
        mov     dx,pmrg.xdx     ;ax:dx = selector:offset of buffer
        call    SelOff2SegOff   ;translate to seg:off if in conventional mem
        jnz     gtar12
        mov     rmrg.xds,ax     ;store corresponding paragraph
        mov     rmrg.xdx,dx     ;  and offset
        pop     ax
        jmp     short gtar54    ;No more setup needed

gtar12: pop     ax              ;XRAM/RRAM read/write entry
        mov     cx,rcount       ;Try to xfer remaining amount
        cmp     cx,CB_XFRBUF1   ;Too much to fit in buffer?
        jbe     gtar14
        mov     cx,CB_XFRBUF1   ;Yes, only transfer a buffer size
gtar14: mov     rmrg.xcx,cx
        jmp     short gtare3

gtare2: test    ah,A0+A1        ;xfer area?
        jz      gtare4

gtare3: mov     di,offset DGROUP:rgbXfrBuf0     ;Point at small buffer (90h bytes)
        test    ah,1            ;Area 0 (small area) ?
        jnz     gtare4
        mov     di,npXfrBuf1       ;No. Point at large buffer (4K)

gtare4: push    ax              ;Store ptr to communication area for DOS
        mov     si,di
        shr     al,3            ;Get al = 2 * data ptr type, e.g., DSDX (ds:dx)
        and     al,1Eh          ;al = word offset for data ptr type
        jz      gtare7
        cmp     al,2*DTA        ;DOS Data Transfer Area?
        jnz     gtare5
        mov     si,pmdta        ;Yes, load DTA offset
        push    pmdta+2         ;and the segment
        pop     enxseg
        jmp     short gtare7

gtare5: cmp     al,2*ES$
        jnz     gtare6
        test    ah,80h          ;INT-21 49/4A. Ignore exit call
        mov     ax,0
        jnz     gtar52
        mov     si,pmrg.xes     ;Entry call. si = RAM xfer selector
        call    gtpara          ;Get paragraph given by [si].gdt
        jnz     gtar52          ;XRAM?
        mov     rmrg.xes,ax     ;No, store RRAM paragraph
gtar52: pop     cx              ;Kill saved ptr

gtar54: xor     cx,cx   ;RZ with zero count, i.e., no RM/PM xfer needed
        mov     rcount,cx
        return

gtare6: test    ah,80h          ;Entry?
        cbw
        push    ax
        xchg    di,ax           ;Save real-mode area offset
        mov     di,regoffs[di-2]        ;di = offset of saved register value
        mov     si,word ptr pmrg[di]    ;si = saved value
        jnz     gtar62
        mov     word ptr rmrg[di],ax    ;Entry. Store real-mode area offset
        cmp     byte ptr pmrg.xax+1,29h ;Parse filename?
        jnz     gtar62
        mov     cx,npXfrBuf1       ;Yes. Use npXfrBuf1 for FCB info
        mov     word ptr rmrg.xdi,cx
gtar62: xchg    di,ax           ;Restore di = real-mode area offset

        pop     ax
        cmp     ax,ESDI*2
        jne     gtare7

        push    pmrg.xes
        pop     enxseg

gtare7: pop     cx              ;Recover entrycd/exitcd
        and     cx,0Fh          ;RNZ if something to xfer
        rz                      ;No

        mov     dx,pmrg.xds     ;Xfer needed. dx = original XRAM data selector
        cmp     cl,AX$          ;Use rmrg.xax?
        jz      gtare8
        cmp     cl,CX$          ;Use pmrg.xcx?
        rnz                     ;No, just RNZ


;Return dx:0 = pmrg.xds:si+ccount, where dx is a scratch selector
;and si = 0.  This ensures that dx:si can address a bufferful of bytes
;without overflowing si (sort of like a huge ptr).

gtare8: xchg    ax,si           ;ax = original offset
        mov     si,dx           ;si = pmrg.xds (PM data selector)
        and     si,SELECTOR_INDEX
        xor     dx,dx           ;dxax = original offset in 32-bit form
        add     ax,ccount
        adc     dx,0            ;dxax += ccount (current xfer count)
        push    es
        mov     es,selGDT       ;Point at GDT
        add     ax,es:[si].adrBaseLow
        adc     dl,es:[si].adrBaseHigh  ;dxax absolute XRAM address
        adc     dh,es:[si].adrbBaseHi386
        mov     si,SEL_DOSSCR
        cCall   NSetSegmentDscr,<si,dx,ax,0,0ffffh,STD_DATA>
        pop     es

; original code... changed to line below to fix file read problem.
; may cause other bugs.....
;       mov     dx,si           ;Return scratch selector with 0 offset since
;
        or      si,SELECTOR_TI
        mov     enxseg,si       ;Return scratch selector with 0 offset since
        xor     si,si           ; it points directly to the transfer location
        or      sp,sp           ;RNZ to indicate xfer needed
        return

; -------------------------------------------------------
;   GetEntryCd  --  This routine puts the entry code for the
;                   DOS function into ax.
;
;   Input:  AH      - MS-DOS function number
;   Output: AX      - entry code for function
;           DI      - address of entry code returned
;
;   Errors: none
;   Uses:   AX, DI modified

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  GetEntryCd

GetEntryCd      proc    near

        push    bx

        cmp     ah,MaxInt21     ;Check for unsupported DOS call
        jbe     @f
        mov     di,offset DXPMCODE:Unsupported
        jmp     gec90
@@:
        mov     di,offset DXPMCODE:pmrmxfr

ifdef DBCS
        cmp     ah,63h          ;Get Lead Byte Table?
        jnz     gec10

if DEBUG   ;------------------------------------------------------------

        cmp     al,2
        jbe     gec15

        Debug_Out "Int 21h/63h Unsupported Function (#AX)"
        jmp     short gec80
gec15:

endif   ;DEBUG  --------------------------------------------------------

        cmp     al,0            ;Int 21/63/00 is special
        jne     gec80

        mov     di,offset DXPMCODE:int2163
        jmp     short gec90
gec10:
ENDIF ; DBCS

gec20:  cmp     ah,5Eh          ;Network Machine Name/Printer Setup Str?
        jnz     gec40

if DEBUG   ;------------------------------------------------------------

        cmp     al,3
        jna     gec25

        Debug_Out "Int 21h/5Eh Unsupported Function (#AX)"
        jmp     short gec80
gec25:

endif   ;DEBUG  --------------------------------------------------------

        cmp     al,3            ;Int 21-5E/00-03 are special
        ja      gec80

        mov     bl,al
        mov     di,offset DXPMCODE:int215E
        jmp     short gec85


gec40:  cmp     ah,5Fh          ;Get/Make Assign-List Entry?
        jnz     gec80

if DEBUG   ;------------------------------------------------------------

        cmp     al,5
        ja      @f
        cmp     al,2
        jnb     gec45
@@:
        cmp     al,30h          ;Register based.  Get Redirector version
                                ;used by Lanman Enhanced.
        je      gec80
        Debug_Out "Int 21h/5Fh Unsupported Function (#AX)"
        jmp     short gec80
gec45:

endif   ;DEBUG  --------------------------------------------------------

        cmp     al,2            ;Int 21/5F/02-05 are special
        jb      gec80
        cmp     al,5
        ja      gec80

        mov     bl,al
        sub     bl,2
        mov     di,offset DXPMCODE:int215F02
        jmp     short gec85


gec80:  mov     bl,ah
gec85:  xor     bh,bh
        shl     bx,2

        add     di,bx                   ;Address of entry code
gec90:
        mov     ax,word ptr cs:[di]     ;The entry code itself
        pop     bx
        return

GetEntryCd      endp


; -------------------------------------------------------
;   CheckStatus --  This routine determines if data should be copied
;                   back to protect mode by checking the DOS function
;                   return status.
;
;   Input:  none
;   Output: NZ    - if data should NOT be copied, Z otherwise
;
;   Errors: none
;   Uses:   none

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  CheckStatus

CheckStatus     proc    near

; For now, only worry about the functions that return variable length
; results, like ASCIIZ strings.

        cmp     byte ptr pmrg.xax+1,32h
        jz      @f
        cmp     byte ptr pmrg.xax+1,47h         ;Get Current Directory
        jz      @f
        cmp     byte ptr pmrg.xax+1,5Ah         ;Create Temporary File
        jz      @f
        cmp     byte ptr pmrg.xax+1,5Eh         ;Get Machine Name/Printer Str
        jc      cks90
        cmp     byte ptr pmrg.xax+1,5Fh         ;Get Redirection Entry
        ja      cks90
@@:
        test    byte ptr rmflags,1      ;Carry set?
        return

cks90:  cmp     al,al                   ;Assume status is okay (or doesn't
        return                          ;  matter) -- set Z and return

CheckStatus     endp


; -------------------------------------------------------
;   DOSXEC      -- This function performs the transfer of the
;       DOS exec parameter block on entry to DOS function 4Bh.
;
; transfer int-21 ah = 4b0x EXEC block and associated strings
; to Area 1.  This area is laid out partly analogously to a PSP as follows:
;
; 0-1f    EXEC block defined according to the execblk struc above
; 20-2f   FCB1
; 30-3f   FCB2
; 40-bf   command line
;
; cx, si, di changed.

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  dosxec

dosxec:
        push    ax              ;Save entrcd code
        push    bx
        push    dx

        mov     cx,10h          ;Setup parameter block.  Xfer pm user block first
        mov     bx,npXfrBuf1    ;Point at larger buffer
        mov     di,bx
        mov     dx,segDXDataPM
        mov     rmrg.xbx,di     ;int-21 4b0x expects es:bx -> exec block
        mov     si,pmrg.xbx     ;npXfrBuf1:0 - 1f (xtra room for undocumented)
        mov     ds,pmrg.xes
        rep     movsw           ;copy caller's exec param block to our buffer

; Copy FCB1 down if the user has specified one.

dsxc20: mov     ax,word ptr es:[bx].fcb1ptr
        cmp     ax,0FFFFh
        jz      dsxc22
        or      ax,word ptr es:[bx].fcb1ptr+2
        jz      dsxc22

        lds     si,es:[bx].fcb1ptr      ;Get pointer to FCB1
        mov     word ptr es:[bx].fcb1ptr,di      ;store new pointer in the copy of the
        mov     word ptr es:[bx].fcb1ptr+2,dx    ; exec block we are building
        mov     cl,8                    ;copy FCB1 down to our buffer
        rep     movsw
        jmp     short dsxc24
dsxc22: add     di,10h

; Copy FCB2 down if the user has specified one.

dsxc24: mov     ax,word ptr es:[bx].fcb2ptr
        cmp     ax,0FFFFh
        jz      dsxc26
        or      ax,word ptr es:[bx].fcb2ptr+2
        jz      dsxc26

        lds     si,es:[bx].fcb2ptr      ;Move FCB2
        mov     word ptr es:[bx].fcb2ptr,di
        mov     word ptr es:[bx].fcb2ptr+2,dx
        mov     cl,8
        rep     movsw
        jmp     short dsxc30
dsxc26: add     di,10h

; Copy the command line down.

dsxc30: lds     si,es:[bx].cmdptr       ;Move command line
        mov     word ptr es:[bx].cmdptr,di
        mov     word ptr es:[bx].cmdptr+2,dx
        mov     cl,[si]
        inc     cx              ;Include count
        inc     cx              ;Include final CR not included in count
        rep     movsb

; Now, we need to set up the enviroment table to be passed to the
; child program.

        mov     di,bx           ;di = npXfrBuf1
        mov     dx,es:[di]      ;Setup desired environment
        or      dx,dx           ;Use parent's environment?
        jnz     dosxegotenv

; pick up the environment segment from the current PDB. It's a selector,
; so it has to be translated.
        push    bx
        push    di
        push    es
        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax

        SwitchToRealMode                    ;much of this is easier in real mode

        mov     ah,51h                      ;get PSP of current task
        pushf
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     [bp + 6],word ptr (offset dosxeret)
        mov     ax,es:[21h*4]
        mov     [bp + 2],ax
        mov     ax,es:[21h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf
dosxeret:
        assume  es:PSPSEG
        mov     es, bx                      ;current PSP
        mov     dx, es:[segEnviron]         ;get environment (currently selector)
        push    dx                          ;save over call (bugbug is this needed?)
        SwitchToProtectedMode
        pop     dx                          ;bugbug is this needed?

        pop     es
        pop     di
        pop     bx


dosxegotenv:
        xor     si,si           ;No. Setup to copy desired environment down
        mov     ds,dx           ;ds = dx has caller's selector. Use 0 offset
        add     di,100h
        shr     di,4            ;Convert offset to paragraph
        mov     dx,segDXDataPM
        add     dx,di           ;dx = absolute paragraph within larger buffer
        shl     di,4            ;Convert back (with low nibble cleared)
        mov     cx,CB_XFRBUF1   ;Max room available for environment
        sub     cx,100h

dosxe2: lodsw                   ;Copy environment down
        stosw
        or      ax,ax
        jz      dosxe4
        dec     si              ;Check every byte offset in environment for double 0
        dec     di
        loop    dosxe2
        xor     dx,dx           ;Environment too large for buffer: use parent's
                                ;Issue error message? Program might run with parent's
                                ; and not with desired monster environment
dosxe4: push    es              ;Fix up parameter block entry
        pop     ds              ;ds:dgroup
        mov     [bx].evrnmt,dx

        pop     dx
        pop     bx
        pop     ax              ;Restore entrcd code
        return


; -------------------------------------------------------
;   XFRFLG      -- This function will transfer the relevant real-mode
;       flags to the protected mode IRET return information on the
;       stack for returning to the protected mode caller.
;
;   Input:
;   Output:
;   Errors:
;   Uses:   AX, CX, DI modified

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  xfrflg

xfrflg: push    es
        les     di,dword ptr pmusrsp    ;es:[di] = ip cs fl (assume 80286)
        mov     ax,rmflags
        mov     cx,es:[di+2*2]          ;Get pm user entry flags
        and     ch,not 19h              ;Only allow real-mode program to
        and     ah,18h                  ; change OF and DF in high byte of flags
        or      ah,ch
        mov     es:[di+2*2],ax
        pop     es
        return

; -------------------------------------------------------
        subttl      Handlers for Special Case Dos Functions
        page
; -------------------------------------------------------
;       HANDLERS FOR SPECIAL CASE DOS FUNCTIONS
; -------------------------------------------------------

; -------------------------------------------------------
;   Terminate process -- This routine replaces the apps
;       termination vector in the PSP with ours.  This allows
;       us to clean up the dos extender.
;
;   Entry: nothing
;   Exit: nothing
;   Uses: none
;
        assume  ds:dgroup,es:nothing
        public TerminateProcess
TerminateProcess proc near
        pusha
        push    es
        ;
        ; Get the childs PSP (bugbug do we need to get the current psp?)
        ;

        SwitchToRealMode

        mov     ah,51h
        pushf
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     [bp + 6],offset tp_10
        mov     ax,es:[21h*4]
        mov     [bp + 2],ax
        mov     ax,es:[21h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

tp_10:  FSTI

        ;
        ; Change the termination vector to point to the dos extender
        ;
        mov     es,bx
        mov     bx,es:[0ah]
        mov     ax,es:[0ch]
        mov     cx,offset ChildTerminationHandler
        mov     es:[0ah],cx
        mov     cx,segDXCode
        mov     es:[0ch],cx

        ;
        ; Save the old termination vector for restoration later
        ;
        mov     cx,segCurrentHostData
        mov     es,cx
        mov     word ptr es:[HdPspTerminate],bx
        mov     word ptr es:[HdPspTerminate+2],ax

        SwitchToProtectedMode

        pop     es
        popa
        ret

TerminateProcess endp

DXPMCODE  ends

;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxstrt.asm ===
PAGE    ,132
        TITLE   DXSTRT.ASM -- Dos Extender Startup Code

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXSTRT.ASM      -   Dos Extender Startup Code           *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains the executive initialization code for  *
;*  the Dos Extender.  The module DXBOOT.ASM contains the code  *
;*  specific to starting up the Dos Extender.  The module       *
;*  DXINIT.ASM contains the code specific to starting up the    *
;*  child program of the Dos Extender.  The code in these       *
;*  two modules is discarded at the end of the initialization.  *
;*  The code in this module calls the initialization routines   *
;*  in the other to init modules, and then performs the final   *
;*  juggling of things to throw away the low memory init code,  *
;*  and transfer control to start up the child program.         *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  01/09/91 amitc  At exit time Co-Processor being reset       *
;*  08/08/90 earleh DOSX and client privilege ring determined   *
;*      by equate in pmdefs.inc                                 *
;*  12/08/89 jimmat  Added call to reenable EMM driver.         *
;*  08/29/89 jimmat  Restores Int 2Fh vector at exit            *
;*  08/20/89 jimmat  Removed A20 code, since HIMEM version 2.07 *
;*                   A20 code now works properly.               *
;*  06/28/89 jimmat  Now calls OEM layer instead of NetMapper   *
;*  06/16/89 jimmat  Implemented Windows/386 startup/exit Int   *
;*                   2Fh calls and ifdef'd combined EXE code    *
;*  05/17/89 jimmat  ChildTerminationHandler sets its SS:SP     *
;*  04/18/89 jimmat  Added calls to init/term NetBIOS mapper    *
;*  03/28/89 jimmat  Incorporated bug fix from GeneA related    *
;*                   to nested GP faults in ChildTermHandler    *
;*  03/11/89 jimmat  Added support for TSS & LDT                *
;*  03/07/89 jimmat   converted to use WDEB386                  *
;*  02/27/89 (GeneA): shrink initial memory block size on entry *
;*  02/25/89 (GeneA): added support for combined exe file where *
;*      the Dos Extender and the child reside in the same exe   *
;*      file.                                                   *
;*  02/17/89 (GeneA): fixed error termination code for startup  *
;*      errors that occur while in protected mode               *
;*  02/14/89 (GeneA): added code to reduce size of real mode    *
;*      code segment to throw away initialization code.         *
;*  01/31/89 (GeneA):   created by copying code from the old    *
;*      DXINIT.ASM                                              *
;*  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;****************************************************************

.286p

; -------------------------------------------------------
;               INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

.sall
.xlist
include segdefs.inc
include gendefs.inc
include pmdefs.inc

include hostdata.inc
include dpmi.inc
include intmac.inc
.list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------


WIN386_INIT     equ     1605h           ;Win/386 startup Int 2Fh
WIN386_EXIT     equ     1606h           ;Win/386 shutdown Int 2Fh

WIN386_DOSX     equ     0001h           ;Win/386 init/exit really DOSX flag


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   InitDosExtender:NEAR
        extrn   RestoreRMIntrVectors:NEAR
        extrn   SaveRMIntrVectors:NEAR
        extrn   EnterRealMode:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   InitializeOEM:NEAR
        extrn   TerminateOEM:NEAR
externNP        NSetSegmentAccess
        extrn   DupSegmentDscr:NEAR

        extrn   EMMEnable:NEAR

ifdef WOW_x86
        externFP NSetSegmentDscr
else
        externFP NSetGDTSegmentDscr
ENDIF; WOW_x86

        extrn   PMIntr19:NEAR
        extrn   PMIntr13:NEAR
        extrn   PMIntr31:NEAR
        extrn   PMIntr28:NEAR
        extrn   PMIntr25:NEAR
        extrn   PMIntr26:NEAR
        extrn   PMIntr4B:NEAR
        extrn   PMIntrDos:NEAR
        extrn   PMIntrMisc:NEAR
        extrn   PMIntrVideo:NEAR
        extrn   PMIntrMouse:NEAR
        extrn   PMIntrIgnore:NEAR
        extrn   PMIntrEntryVector:NEAR
        extrn   PMFaultEntryVector:NEAR
ifdef      NEC_98    ;
        extrn   PMIntr11dummy:NEAR
        extrn   PMIntrPrinter:NEAR
        extrn   PMIntrCalTi:NEAR
        extrn   PMIntrGraph:NEAR
endif   ;NEC_98   ;

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

; -------------------------------------------------------

DXDATA  segment
        extrn   A20EnableCount:WORD
        extrn   lpfnUserMouseHandler:DWORD
        extrn   lpfnUserPointingHandler:DWORD
        extrn   f286_287:BYTE

        extrn   cDPMIClients:WORD
        extrn   selCurrentHostData:WORD
        extrn   segCurrentHostData:WORD

ifdef WOW_x86
        extrn   FastBop:fword
endif
        extrn   DpmiFlags:WORD

        org     0

        public  rgwStack,npEHStackLimit,npEHStacklet, selEHStack,
;
; Pmode fault handler stack used during initialization only.
;
            dw      80h dup (?)
rgwStack    label   word

;
; This is the stack area used while running in the interrupt reflector.
; This is divided up into a number of stack frames to allow reentrant
; execution of the interrupt reflector.  The stack pointer pbReflStack
; indicates the current stack frame to use.  Each entry into the interrupt
; reflector decrements this variable by the size of the stack frame, and
; each exit from the interrupt reflector increments it.

C_STKFRAME      =   36
CB_REFLSTACK    =   C_STKFRAME * CB_STKFRAME

if  DEBUG       ;--------------------------------------------------------
        public  StackGuard
StackGuard      dw  1022h       ;unlikely value to check for stk overrun
endif           ;--------------------------------------------------------

        public  pbReflStack,bReflStack
if DBG
bReflStack      db  CB_REFLSTACK dup (0AAh)
else
bReflStack      db  CB_REFLSTACK dup (?)
endif

;----------------------------------------------------------------------------
; The following stack is used for hw interrupts while booting where
; the kernel or ntvdm switches the stack before an interrupt is reflected.
;----------------------------------------------------------------------------
CB_HWINTRSTACK  =   1000h
if DBG
bHwIntrStack    db  CB_HWINTRSTACK dup (0AAh)
else
bHwIntrStack    db  CB_HWINTRSTACK dup (?)
endif
        public  pbHwIntrStack
pbHwIntrStack   dw  bHwIntrStack + CB_HWINTRSTACK

pbReflStack     dw  bReflStack + CB_REFLSTACK

npEHStackLimit  dw      offset DGROUP:rgwStack
npEHStacklet    dw      offset DGROUP:rgwStack
selEHStack      dw      0

        public  cdscGDTMax, selGDTFree, segGDT, selGDT

cdscGDTMax      dw      CDSCGDTDEFAULT

selGDTFree      dw      ?       ;head of list of free descriptors in GDT

segGDT          dw      0       ;real mode paragraph address of the GDT
                                ; This variable always stores the real mode
                                ; paragraph address

selGDT          dw      0       ;current mode segment/selector for the GDT
                                ; segment.  This variable holds the real
                                ; mode paragraph address during initialization
                                ; and then holds the protected mode selector
                                ; when running in protected mode.

        public  bpGDT, bpGDTcb, bpGDTbase

bpGDT           label   fword
bpGDTcb         dw      ?
bpGDTbase       dd      ?


        public  segIDT, selIDT

segIDT          dw      0
selIDT          dw      0

        public  bpIDT, bpIDTcb, bpIDTbase

bpIDT           label   fword
bpIDTcb         dw      ?
bpIDTbase       dd      ?

        public  bpRmIVT

bpRmIVT         dq      0FFFFh  ;This is the segment descriptor for the real
                                ; mode interrupt vector table.

        public  lpfnXMSFunc

lpfnXMSFunc     dd      0       ;far pointer to XMS memory driver entry point

        public  idCpuType

idCpuType       dw      0

        public  segPSP, selPSP

segPSP          dw      ?       ;segment address of Dos Extender PSP
selPSP          dw      ?       ;selector for Dos Extender PSP
                                ; code during processing of GP faults

        public  selPSPChild, segPSPChild

segPSPChild     dw      ?       ;real mode segment address of child's PSP
; note the following in 1, so that in low mem heap management, we can use
; selPSPChild to mark the owner of the memory.
selPSPChild     dw      1       ;selector of child program's PSP


        public  DtaSegment, DtaOffset, DtaSelector
DtaSegment dw 0
DtaSelector dw 0
DtaOffset dw 0


        public  regChildSP,  regChildSS,  regChildIP,  regChildCS

regChildSP      dw      ?       ;initial user stack pointer from exe file
regChildSS      dw      ?       ;initial user stack segment from exe file
regChildIP      dw      ?       ;initial user program counter from exe file
regChildCS      dw      ?       ;initial user code segment from exe file

        public  hmemDOSX

hmemDOSX        dw      0

IFDEF   ROM
                public  segDXCode, segDXData

segDXCode       dw      ?               ;holds real mode paragraph address
                                        ; of the code segment
segDXData       dw      ?               ;holds real mode paragraph address
                                        ; of the data segment
ENDIF

ifdef      NEC_98
        public  fPCH98

fPCH98          db      0       ;NZ if running on a Micro Channel system

        public  fNHmode

fNHmode         db      0       ;NZ if running on a Hmode system
endif   ;!NEC_98
        public  fFaultAbort, ExitCode

fFaultAbort     db      0       ;NZ if terminating due to unrecoverable fault
ExitCode        db      0FFh    ;exit code to use when terminating
fQuitting       db      0

fEMbit          db      0FFh    ;MSW EM bit at startup (FF = not checked yet)

        public fUsingHMA
fUsingHMA       db      0

; The one and only Task State Segment is here (it's too small to allocate
; a block for it in extended memory)

        public  sysTSS

sysTSS  TSS286  <>

; After initialization is complete, the following buffers (rgbXfrBuf0 and
; rgbXfrBuf1) are used to transfer data between real mode address space
; and protected mode address space during the processing of various interrupt
; function calls.  During the initialization process, these buffers are also
; used as temporary work space as described below:
;   CheckCPUType uses the first 6 bytes of rgbXfrBuf0 as scratch space.
;   The functions for moving the Dos Extender protected mode code segment
;   and the GDT and IDT use rgbXfrBuf0 as buffer space for building a
;   parameter block.  The child loading code in DXINIT.ASM uses the buffer
;   RELOC_BUFFER for holding the base part of the file name (name.exe portion)
;   of the child exe file while determining the complete path to the child
;   in the case where the child name is specified on the command line.  Note,
;   this buffer is also used for holding sectors from the relocation table
;   while loading the program, but that occurs after the child exe file name
;   has been determined.
;   The child loading code in DXINIT.ASM also uses rgbXfrBuf1 to hold several
;   buffers as well.  The locations and purposes of these buffers are
;   described in GENDEFS.INC.  All of the buffers are defined with equates
;   named EXEC_?????
;
;   The file search logic in DXFIND.ASM assumes some parameters are setup in
;   the rgbXfrBuf1 file name buffers.  Some of the code was moved from
;   DXINIT.ASM to DXFIND.ASM.

        public      rgbXfrBuf0, rgbXfrBuf1
        public      npXfrBuf0,  npXfrBuf1

        align       2

rgbXfrBuf0  db      CB_XFRBUF0 dup (?)
rgbXfrBuf1  db      CB_XFRBUF1 dup (?)

npXfrBuf0   dw      offset DGROUP:rgbXfrBuf0
npXfrBuf1   dw      offset DGROUP:rgbXfrBuf1

DtaBuffer   dw      128 dup (0) ; used as the dta for PM if dta changed

; Parameter block for passing to DOS EXEC call to run the child
; program.
;
public  exec_par_blk

exec_par_blk    dw  0
cmd_off         dw  OFFSET EXEC_CMNDLINE
cmd_seg         dw  DXDATA
                dw  OFFSET EXEC_FCB0
fcb1_seg        dw  DXDATA
                dw  OFFSET EXEC_FCB1
fcb2_seg        dw  DXDATA


; The following variables are used during reading the relocation table
; from the exe file and relocating the child program.

        public  fhExeFile
        public  clpRelocItem
        public  plpRelocItem

fhExeFile       dw      ?       ;DOS file handle for the exe file
clpRelocItem    dw      ?       ;number of relocation items in the exe file
plpRelocItem    dw      ?       ;pointer to next relocation item in the table

szDebugHello    label   byte
if      DEBUG
        db      'DOSX: Beginning protected mode initialization.',13,10,0
endif
        db      0

FreeMem dw      0

DXDATA  ends

; -------------------------------------------------------
        page
; -------------------------------------------------------
;               CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   CodeEnd:NEAR
        extrn   ER_DXINIT:BYTE
        extrn   ER_REALMEM:BYTE
        extrn   RMDefaultInt24Handler:FAR

        public  segDXCode, segDXData, selDgroup

segDXCode       dw      ?       ;holds the real mode paragraph address
                                ; of the code segment
segDXData       dw      ?       ;holds the real mode paragraph address
                                ; of the data segment

selDgroup       dw      ?       ;holds the paragraph address/selector for
                                ; DGROUP depending on the current mode

        public  PrevInt2FHandler

PrevInt2FHandler dd     ?       ;previous real mode Int 2F handler

DXCODE  ends


DXPMCODE    segment

        extrn   CodeEndPM:NEAR

        org     0

        public  selDgroupPM, segDXCodePM, segDXDataPM

selDgroupPM     dw      ?       ;This variable always contains the
                                ; data segment selector
segDXCodePM     dw      ?       ;This variable contains the paragraph
                                ; address of the real mode code segment
segDXDataPM     dw      ?       ;This variable contains the paragraph
                                ; address of the data segment
externFP        NSetSegmentDscr

DXPMCODE    ends

; -------------------------------------------------------

BeginLowSegment

; -------------------------------------------------------
;               DOS EXTENDER ENTRY FUNCTION
; -------------------------------------------------------
;
; This is the program entry point for the Dos Extender.  This
; function decides if the Dos Extender is being run as a single
; time operation to extend a single program, or if it is being
; run as a TSR to wait for programs to request its services
; later on.
;

        assume  ds:PSPSEG,es:PSPSEG,ss:NOTHING
        public  start

start:

; Set up the initial segment registers.

        mov     ax,DGROUP
        mov     ds,ax
        assume  ds:DGROUP

        mov     segPSP,es       ;save the PSP segment address

        mov     ss,ax
        mov     sp,offset DGROUP:rgwStack
        assume  ss:DGROUP

;
; Set up the INT 24h handler.  The default INT 24h handler fails the
; system call in progress, for DPMI compatibility.
;

        push    ds
        mov     ax,cs
        mov     ds,ax
        mov     dx,offset DXCODE:RMDefaultInt24Handler
        mov     ax,2524h
        int     21h
        pop     ds

; Issue the Win/386 startup Int 2Fh (almost) first thing

        push    ds

        mov     ax,WIN386_INIT  ;gives other PM software a chance
        xor     bx,bx           ;  to disable itself, release XMS, etc.
        mov     cx,bx
        mov     si,bx
        mov     ds,bx
        mov     es,bx
        assume  ds:NOTHING, es:NOTHING
        mov     dx,WIN386_DOSX
        mov     di,DXVERSION
        int     2Fh

        pop     ax              ;restore ds/es DGROUP addressability
        mov     ds,ax
        mov     es,ax
        assume  ds:DGROUP, es:DGROUP


        jcxz    Allow_Startup   ;if cx still == 0, keep going (we ignore
                                ;  all the other possible return values)

        mov     ExitCode,2      ;  otherwise we should abort now
        jmp     RealModeCleanUp

Allow_Startup:

; Initialize the Dos Extender

        call    InitDosExtender         ;NOTE: passes data to InitChildProgram
        jnc     @F                      ;  in rgbXfrBuf1 -- don't overwrite it!
        jmp     strt88
@@:

; Save the state of the MSW EM bit (Emulate Math coprocessor), and turn
; it off (win87em wants it off).

ifndef WOW_x86
        smsw    ax

        out1    <What to do about this?>

        test    al,01h                  ;in V86 mode?
        jnz     @f                      ;  can't do the lmsw if so

        push    ax
        and     al,04h
        mov     fEMbit,al
        pop     ax
        and     al,not 04h
        lmsw    ax
@@:
endif ; WOW_x86
; Switch the machine into protected mode.

        FCLI
        call    SaveRMIntrVectors

        SwitchToProtectedMode

        public  DXPMInit
DXPMInit        LABEL   BYTE

if      DEBUG
        Trace_Out "*******************************************************************************"
        Trace_Out "*******************************************************************************"
        Trace_Out "****                                                                       ****"
        Trace_Out "****            THIS IS A DEBUG RELEASE THIS IS A DEBUG RELEASE            ****"
        Trace_Out "****                                                                       ****"
        Trace_Out "*******************************************************************************"
        Trace_Out "*******************************************************************************"
endif

        assume  ds:DGROUP,es:NOTHING

        mov     ax,SEL_IDT or STD_RING
        mov     selIDT,ax
        mov     ax,SEL_LDT_ALIAS OR STD_RING
        mov     selGDT,ax

; Initialize the LDT now that we are in protected mode.  First, set the
; contents to zero.

        mov     es,selGDT               ; actually LDT
        assume  es:NOTHING
        mov     cx,cdscGDTMax
IFDEF WOW
        mov     di,GDT_SIZE
        sub     cx,di
ENDIF
        shl     cx,2                    ; CX = words in LDT segment
        xor     ax,ax                   ; AX = 0
IFNDEF WOW
        mov     di,ax
ENDIF
        cld
        rep     stosw                   ; CX = 0

        dec     cx                      ; CX = 0FFFFh

        push    ax
        push    cx
        mov     ax,es                   ; LDT selector
        lsl     cx,ax                   ; LDT size
        mov     di,SEL_USER and SELECTOR_INDEX
        DPMIBOP InitLDT
        pop     cx
        pop     ax

;
; Set the two scratch selectors to 64k data starting at zero.  Actual
; addresses set as used.
;
        cCall   NSetSegmentDscr,<SEL_SCR0,ax,ax,ax,cx,STD_DATA>
        cCall   NSetSegmentDscr,<SEL_SCR1,ax,ax,ax,cx,STD_DATA>
ifndef WOW_x86
        mov     dx,40h*16
        cCall   NSetGDTSegmentDscr,<040h,ax,dx,ax,cx,STD_DATA>
endif

; Bop to initialize 32 bit support.

        push    es
        mov     ax,SEL_DXCODE OR STD_RING
        mov     es,ax
        assume  es:DXCODE
        mov     di, sp                          ;original stack offset

        push    ds
        push    offset DGROUP:DtaBuffer
        push    ds
        push    offset DGROUP:pbReflStack
        push    ds
        push    offset DGROUP:rgbXfrBuf1
        push    ds
        push    offset DGROUP:rgbXfrBuf0

        mov     si,sp                           ;pass stack offset
        FBOP    BOP_DPMI,InitDosx,FastBop
        mov     sp, di                          ;restore stack
        pop     es
        assume es:nothing

        call    AllocateExceptionStack
        FSTI                             ;don't need ints disabled

; Shrink the size of our real mode code segment to throw away init code.

        SwitchToRealMode

        mov     bx,(offset CodeEnd) + 15
        shr     bx,4
        add     bx,segDXCode
        sub     bx,segPSP
        push    es
        mov     es,segPSP
        dossvc  4Ah
        pop     es

        call    DetermineFreeMemory
        mov     FreeMem,bx
        SwitchToProtectedMode

; Initialize the OEM layer.  This can allocate DOS memory, so it goes
; after the final program shrink.

        call    InitializeOEM           ;currently initializes NetBIOS mapper

if1
%OUT    InitializeOEM can fail!!!!!
endif

        FBOP    BOP_DPMI,ResetLDTUserBase,FastBop

; Exec the child application

        SwitchToRealMode
        FSTI
;; bugbug hack ...... williamh
;; turn off A20 line before we terminate and keep resident.
        cmp     A20EnableCount, 0
        jz      A20IsOff
@@:
        xmssvc  6
        dec     A20EnableCount
        jnz     @B
A20IsOff:

        mov     ax,segPSP
        mov     es,ax
        assume es:nothing
        mov     ax,es:[2ch]
        mov     es,ax
        dossvc  49h                     ; free env block

        call    DetermineFreeMemory
        mov     dx,(offset CodeEnd) + 15
        shr     dx,4
        add     dx,FreeMem
        sub     dx,bx
        add     dx,segDXCode
        sub     dx,segPSP
        mov     al,0
        dossvc  31h                     ; tsr.
help:   int     3                       ; should never get here
        jmp     help

        lea     bx, exec_par_blk
        lea     dx, EXEC_PROGNAME
        xor     al, al
        dossvc  4bh

; If we get here, the EXEC failed for some reason!

        mov     bx,offset DXCODE:ER_REALMEM     ;assume insufficient memory
        xchg    ax,bx
        cmp     bx,8                            ;is it really?
        jz      strt88
        mov     ax,offset DXCODE:ER_DXINIT      ;no, use generic msg

strt88:
        mov     ExitCode,1              ;return NZ exit code

        mov     dx,cs                   ;pass msg ptr in DX:AX (ax already set)

        push    cs                              ;fake a far call so no fixup
        push    offset DXCODE:RealModeCleanUp   ;  needed -- return to clean up
        jmp     near ptr DisplayErrorMsg

; -------------------------------------------------------
;   ChildTerminationHandler --  This routine receives control
;       when the child program running under the Dos Extender
;       terminates.  It will free all resources being used by
;       the child.  If we were not running TSR, then the Dos
;       Extender will complete cleaning up and terminate itself.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

        public  DosxTerminationHandler
DosxTerminationHandler:

        mov     ds,selDgroup
        mov     es,selDgroup
        mov     ss,selDgroup                    ;make sure we know where the
        mov     sp,offset DGROUP:rgwStack       ;  stack is when we get here

        assume  ds:DGROUP,es:DGROUP

; Check if we are already in the middle of a termination sequence and
; bail out if so.  This will prevent us from hanging up in an infinite
; loop if we get a GP fault while we are quitting.

        cmp     fQuitting,0
        jz      @f
        jmp     chtm90
@@:
        mov     fQuitting,1

; Terminate the OEM layer

        call    TerminateOEM    ;current term's NetBIOS mapper & low net heap

; Make sure that no interrupt vectors still point to us.

        call    RestoreRMIntrVectors

; if this is a 80286 & 80287 configuration, we should reset the Co-Processor.

        cmp     [f286_287],0            ;286 and 287 config ?
        jz      CTH_Not286And287        ;no.

; reset the 80287 Co-Processor to make sure that it gets out of protected
; mode.

        xor     al,al                   ;need to out 0
        out     0F1H,al                 ;reset the coprocessor

CTH_Not286And287:

; If we're aborting due to a processor fault, do some extra clean-up on
; the mouse (just to be nice).  If this is a normal termination, we leave
; it up to the child to save/restore the mouse state.

        test    fFaultAbort,0FFh
        jz      normal_exit

; Check if the mouse driver callback function has been set, and
; reset the mouse driver if so.

        mov     ax,word ptr lpfnUserMouseHandler
        or      ax,word ptr lpfnUserMouseHandler+2
        jz      @F
        xor     ax,ax
        int     33h
@@:

; Check if the PS/2 Pointing Device Handler Address has been set and
; disable it if so.

ifndef NEC_98
        mov     ax,word ptr lpfnUserPointingHandler
        or      ax,word ptr lpfnUserPointingHandler+2
        jz      @f
        mov     ax,0C200h
        xor     bh,bh
        int     15h
@@:
endif   ;!NEC_98

; Hmmm, we have HP mouse code in dxhpbios.asm, but no clean up here...

normal_exit:

; Release the extended memory heap.

;        call    ReleaseXmemHeap

; Release the space being used for the descriptor tables and
; the protected mode code segment.

;
; If we have allocated an extended memory block, then free it.
; If we have allocated the HMA, then free it.
;
        mov     dx,hmemDOSX
        or      dx,dx
        jz      @F
        xmssvc  0Dh
        xmssvc  0Ah
@@:
        cmp     fUsingHMA,0
        je      @F
        xmssvc  2
@@:

; Clean up after real mode code (and possible real mode incomplete
; initialization) -- restore real mode interrupt vectors.

chtm90:
RealModeCleanUp:

; Disable A20 if it was left enabled (normally 1 on 386 systems, 0 on 286)

        mov     cx,A20EnableCount
        jcxz    A20Okay
@@:     xmssvc  6
        loop    @b
A20Okay:

; Restore the MSW EM bit (Emulate Math coprocessor) to its initial state
ifndef WOW_x86
        inc     fEMbit          ;if fEMbit = FF, we never got far 'nuff to
        jz      @f              ;  change it
        dec     fEMbit

        smsw    ax
        test    al,01h                  ;in V86 mode?
        jnz     @f                      ;  can't do the lmsw if so
        or      al,fEMbit
        lmsw    ax
@@:
endif
; Make sure DOS knows that the DOS extender is the current process

        mov     bx,segPSP
        dossvc  50h

; Reenable a friendly EMM driver if we disabled it at startup

        call    EMMEnable

; Restore real mode interrupt vectors

        push    ds

        lds     dx,PrevInt2FHandler     ;Int 2Fh handler
        assume  ds:NOTHING

        mov     ax,ds                   ;may not have gotten far enough to
        or      ax,dx                   ;  set interrupt vectors, so make
        jz      @f                      ;  sure before resotring.

        mov     ax,252Fh
        int     21h

@@:
        pop     ds
        assume  ds:DGROUP


; We have cleaned up after ourselves, so now we can quit.

        mov     ax,WIN386_EXIT  ;use Win/386 exit Int 2Fh to tell any
        mov     dx,WIN386_DOSX  ;  interested parties that we are
        int     2Fh             ;  terminating

        mov     al,ExitCode     ;exit the extender with either the exit
        cmp     al,0FFH         ;  status from the child, or a status
        jnz     @f              ;  that we have forced
        dossvc  4Dh             ;get child exit status if we haven't forced it
@@:
ifdef      NEC_98
        push    ax
        push    es                      ; Dec IN_BIOS(0:456)
        mov     ax, 0040h
        mov     es, ax
        test    byte ptr es:[0], 20h    ; check suspend/redume
        jz      @f
        dec     byte ptr es:[056h]      ; for Y55
@@:
        pop     es
        pop     ax
endif   ;NEC_98
        dossvc  4Ch             ;say goodnight Gracy...

; -------------------------------------------------------
;   ChildTerminationHandler --
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  ChildTerminationHandler

ChildTerminationHandler:
        sub     sp,4                            ; room for far ret
        push    ds
        push    es
        pusha
        mov     si,ss
        mov     di,sp

        mov     ds,selDgroup
        mov     es,selDgroup
        mov     ss,selDgroup                    ;make sure we know where the

        mov     sp,offset DGROUP:rgwStack       ;  stack is when we get here

        assume  ds:DGROUP,es:DGROUP

        ;bugbug less than zero?
        dec     cDPMIClients

        test    DpmiFlags,DPMI_32BIT
        jz      cth05

;
; Return the stack frame used by the Wow32Intr16 interrupt handler
;
        add     pbReflStack,CB_STKFRAME
cth05:  cmp     cDPMIClients,0
        jne     cth20

        SwitchToProtectedMode

        mov     dx, selPspChild
        mov     cx, 0                           ; No parent
        FBOP    BOP_DPMI,TerminateApp,FastBop

;
; Reset the exception stack pointer to indicate free'd memory
;
        mov     selEHStack,0

;
; Give back the xms memory
;
        FCLI

        call    ReInitIdt
        push    0
        pop     es
        call    ReInitGdt
        FBOP    BOP_DPMI,DpmiNoLongerInUse,FastBop

        SwitchToRealMode

cth20:  mov     ax,[SegCurrentHostData]
        mov     es,ax
        mov     ax,es:[HdSegParent]
        mov     [SegCurrentHostData],ax
        mov     ax,es:[HdSelParent]
        mov     [SelCurrentHostData],ax
        mov     ax,es:[HdPSPParent]
        mov     dx, selPspChild                 ; save outging psp in dx
        mov     SelPSPChild,ax                  ; set new psp

        cmp     CDPMIClients, 0
        je      short @f

        push    es                              ; We need to preserve es.  The SwitchToRealMode
                                                ; somehow trashes es. (bug?)
        push    dx
        push    ax

        ; free xmem allocated to this client

        SwitchToProtectedMode
        pop     cx
        pop     dx
        FBOP    BOP_DPMI,TerminateApp,FastBop
        SwitchToRealMode
        pop     es
@@:
        mov     ax,word ptr es:[HdPspTerminate + 2]
        mov     bx,word ptr es:[HdPspTerminate]
        mov     cx,segPSPChild
        mov     ds,cx
        assume  ds:nothing
        ;
        ; Restore termination vector (app may think it knows what's here)
        ;
        mov     ds:[0ah],bx
        mov     ds:[0ch],ax
        xor     cx,cx
        mov     ds,cx
        ;
        ; Restore int 22 vector (terminate) Just in case
        ;
        mov     ds:[22h * 4],bx
        mov     ds:[22h * 4 + 2],ax
        mov     es,si
        mov     es:[di+20],bx
        mov     es:[di+22],ax
        mov     ss,si
        mov     sp,di
        popa
        pop     es
        pop     ds
        retf

; -------------------------------------------------------
;  DisplayErrorMsg -- Display an error message on the screen.  We set the
;       video adapter to a text mode so the msg is visable (and gets rid
;       of any bizarre mode that others may have set (like WIN.COM)).
;
;  Note: This routine can be executed in real OR protected mode, so
;        don't do anything mode specific--keep is short and sweet.
;
;  Input:   AX - offset of msg to display
;           DX - segment of msg to display
;  Output:  None.
;  Uses:    AX, DX modified, all else preserved

        assume  ds:NOTHING, es:NOTHING
        public  DisplayErrorMsg

DisplayErrorMsg proc    far

        push    ds              ;save current DS
        push    ax              ;save msg offset

; Set a text mode (normally 3, but possibly 7)

ifdef      NEC_98
        mov     ah,41h          ;
        int     18h
        mov     ah,0Ch          ;
        int     18h
else    ;!NEC_98
        mov     ax,0003h        ;set video mode 3
        int     10h
        mov     ah,0Fh          ;get video mode
        int     10h
        cmp     al,03h          ;did we change to 3?
        jz      @f
        mov     ax,0007h        ;no, must be mode 7
        int     10h
@@:
endif   ;!NEC_98

; Display the msg

        mov     ds,dx
        pop     dx
        dossvc  9

        pop     ds

        ret

DisplayErrorMsg endp

; -------------------------------------------------------
; DetermineFreeMemory -- Determine how much memory is free
;
; Input:   none
; Output:  bx = #paragraphs free memory
; Uses:    bx
;
        assume ds:dgroup,es:nothing
        public DetermineFreeMemory

DetermineFreeMemory proc near
        push    ax
        mov     bx,0ffffh               ; allocate all of memory
        dossvc  48h
        jnc     @f

        pop     ax
        ret

;bugbug report error
@@:     mov     bx,0ffffh
        pop     ax
        ret
DetermineFreeMemory endp
EndLowSegment

DXPMCODE segment
        assume cs:DXPMCODE
;--------------------------------------------------------
; ReInitIdt -- Set Idt entries back to default values
;
; Input:   none
; Output:  none
; uses:    none
;
        assume ds:dgroup,es:nothing
        public ReInitIdt

ReInitIdt proc near

        push    bx
        push    cx
        push    dx
        push    si
        push    di
        push    es
        mov     ax,SEL_IDT OR STD_RING
        mov     es,ax

; Fill the IDT with interrupt gates that point to the fault handler and
; interrupt reflector entry vector.

        xor     di,di

        mov     dx,offset DXPMCODE:PmIntrEntryVector
        mov     cx,256
iidt23: mov     es:[di].offDest,dx
        mov     es:[di].selDest,SEL_DXPMCODE or STD_RING
        mov     es:[di].cwParam,0
        mov     es:[di].arbGate,STD_TRAP   ; BUGBUG- int gates not set up
        mov     es:[di].rsvdGate,0
        add     dx,5
        add     di,8
        loop    iidt23

; Now, fix up the ones that don't point to the interrupt reflector.
IFDEF WOW_x86
        mov     es:[1h*8].offDest,offset PMIntrIgnore
        mov     es:[3h*8].offDest,offset PMIntrIgnore
ifdef      NEC_98
        mov     es:[11h*8].offDest,offset PMIntr11dummy
        mov     es:[18h*8].offDest,offset PMIntrVideo
        mov     es:[1ah*8].offDest,offset PMIntrPrinter
        mov     es:[1bh*8].offDest,offset PMIntr13
        mov     es:[1ch*8].offDest,offset PMIntrCalTi
        mov     es:[1dh*8].offDest,offset PMIntrGraph
        mov     es:[1fh*8].offDest,offset PMIntrMisc
else    ;!NEC_98
        mov     es:[10h*8].offDest,offset PMIntrVideo
        mov     es:[13h*8].offDest,offset PMIntr13
        mov     es:[15h*8].offDest,offset PMIntrMisc
        mov     es:[19h*8].offDest,offset PMIntr19
endif   ;!NEC_98
ENDIF

        mov     es:[21h*8].offDest,offset DXPMCODE:PMIntrDos
        mov     es:[25h*8].offDest,offset DXPMCODE:PMIntr25
        mov     es:[26h*8].offDest,offset DXPMCODE:PMIntr26
        mov     es:[28h*8].offDest,offset DXPMCODE:PMIntr28
        mov     es:[30h*8].offDest,offset DXPMCODE:PMIntrIgnore
        mov     es:[31h*8].offDest,offset DXPMCODE:PMIntr31
        mov     es:[33h*8].offDest,offset DXPMCODE:PMIntrMouse
        mov     es:[41h*8].offDest,offset DXPMCODE:PMIntrIgnore

ifndef WOW_x86
        mov     es:[4Bh*8].offDest,offset DXPMCODE:PMIntr4B
ifdef      NEC_98
;  Sound BIOS Int D2h handler
        mov     es:[0D2h*8].offDest,offset DXPMCODE:PMIntrSound

;  extended DOS Int DCh handler (KANA/KANJI)
        mov     es:[0DCh*8].offDest,offset DXPMCODE:PMIntrExDos
endif   ;!NEC_98
endif
;
; Set up the IDT, and dpmi32 state
;
        mov     ax,es                   ; Idt selector
        mov     bx,VDM_INT_16
        DPMIBOP InitIDT

        mov     ax,5                    ; handler increment
        mov     cx,SEL_DXPMCODE OR STD_RING
        mov     dx,offset DXPMCODE:PmFaultEntryVector

        DPMIBOP InitExceptionHandlers

IFDEF WOW_x86
; make the stacks 16 bit again

        cCall NSetSegmentAccess,<selDgroupPM,STD_DATA>
        cCall NSetSegmentAccess,<selEHStack,STD_DATA>
ENDIF
; All done

iidt90: pop     es
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        ret
ReInitIdt endp

        assume ds:DGROUP,es:NOTHING
        public ReInitGdt
ReInitGdt proc near

        push    ax
        push    cx
        push    di

        mov     ax,selGDT               ; LDT selector
        lsl     cx,ax                   ; LDT size
        mov     di,SEL_USER and SELECTOR_INDEX
        DPMIBOP InitLDT

        pop     di
        pop     cx
        pop     ax
        ret
ReInitGdt endp

;--------------------------------------------------------
; AllocateExceptionStack -- Get space for exception handler
;
; Input:   none
; Output:  none
;       carry set on error
; uses: AX, BX, CX, DX, SI, DI
;
        assume ds:dgroup,es:nothing
        public  AllocateExceptionStack
AllocateExceptionStack proc near

        cmp     selEHStack, 0           ;have we allocated one already
        jnz     aes_ok                  ;yes, return no carry

        xor     bx,bx
        mov     dx,bx
        mov     cx,1000h                ;length of block
        mov     ax, 501h
        push    ds
        FBOP    BOP_DPMI, Int31Call, FastBop
        jc      @F

        mov     ax, SEL_USER_STACK or STD_RING
        mov     selEHStack,ax

        cCall   NSetSegmentDscr,<ax,bx,cx,0,0fffh,STD_DATA>
        mov     ax,selEHStack

        mov     cx,1000h                ;reload length
        dec     cx
        and     cx,0fffeh                ; Make sure SP is WORD aligned
        mov     npEHStackLimit,cx

        ;; mark the stack with 0DEADh
        mov     bx, cx
        push    ds
        mov     ds,ax
        sub     bx,2
        mov     word ptr [bx],0DEADh
        pop     ds
        mov     npEHStacklet, bx

        push    es
        mov     ax, selEHStack
        mov     es, ax
        mov     bx, npEHStackLimit
        DPMIBOP InitPmStackInfo
        pop     es

aes_ok:
        clc
@@:
        ret

AllocateExceptionStack endp

DXPMCODE ends

;****************************************************************

        end     start
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxoem.asm ===
PAGE    ,132
        TITLE   DXOEM.ASM  -- Dos Extender OEM Interface

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;***********************************************************************
;
;       DXOEM.ASM       - DOS Extender OEM Interface
;
;-----------------------------------------------------------------------
;
; This module contains the routines that may need to be modified by OEMs
; when adding new device/interface support to the Microsoft 286 DOS
; Extender portion of Windows/286.  There are four routines contained
; in this module:
;
;       InitializeOEM   - called during DOSX initialization
;
;       SuspendOEM      - called when the protected mode app is about
;                         to be suspended (currently when running a
;                         standard DOS 'old' app from Windows).
;
;       ResumeOEM       - called when the protected mode app is about
;                         to be resumed (currently when returning from
;                         a standard DOS 'old' app to Windows).
;
;       TerminateOEM    - called during DOSX termination
;
; Note: when this module refers to the 'OEM layer,' it is refering to
; the 286 DOS Extender device drivers, API mappers, etc., not the
; Windows OEM layer.
;
;-----------------------------------------------------------------------
;
;  06/28/89 jimmat  Original version.
;  11/29/90 amitc   Removed SuspendOEM/ResumeOEM - not required for 3.1
;  11/29/90 amitc   Moved call to 'InitLowHeap' from here to DXNETBIO.ASM
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
include     pmdefs.inc
        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   InitNetMapper:NEAR
        extrn   TermNetMapper:NEAR

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA	segment

        extrn   NetHeapSize:WORD

DXDATA	ends


; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

DXCODE  ends

DXPMCODE    segment

DXPMCODE    ends

; -------------------------------------------------------
        subttl OEM Initialization Routine
        page
; -------------------------------------------------------
;           OEM INITIALIZATION ROUTINE
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

;--------------------------------------------------------
;   InitializeOEM --  This routine is called during DOSX initialization
;       in order to initialize the OEM layer (device drivers, API
;       mappers, etc.).  It expectes to be called late enough in the
;       initialization process that other interrupt mapping functions
;       (like Int 21h) are available.
;
;       This routine is called in protected mode, and can enable/disable
;       interrupts if it so requires.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   ax, all others preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  InitializeOEM

InitializeOEM	proc	near

; Initialize the NetBios mapper.


;                    ;;bugbug NetHeapSize isn't actually being used, other
;                    ;; than possibly to turn off the NETBIOS mapper


        mov     ax,NetHeapSize          ;don't initialize if net heap
        or      ax,ax                   ;  size set to zero
        jz      @f

        call    InitNetMapper           ;initialize the NetBIOS mapper--CY set
                                        ;  if NetBIOS not installed
@@:
        ret

InitializeOEM	endp

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl OEM Termination Routine
        page
; -------------------------------------------------------
;              OEM TERMINATION ROUTINE
; -------------------------------------------------------

DXCODE	segment
        assume  cs:DXCODE

; -------------------------------------------------------
;   TerminateOEM --  This routine is called during DOSX termination
;       to disable the OEM layer.
;
;   Note:  This routine must is called in REAL MODE!  If some termination
;       code must run in protected mode, the routine must switch to
;       protected mode itself, and switch back to real mode before
;       returning.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   ax,bx,cx,dx,si,di,es
;

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  TerminateOEM

TerminateOEM	proc	near

        call    TermNetMapper           ;terminate the NetBIOS mapper

        ret

TerminateOEM	endp

; -------------------------------------------------------

DXCODE	ends
;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxvcpi.inc ===
;*** dxvcpi.inc - include file for vcpi functions/maintenance
;
;   Copyright <C> 1990-1991, Microsoft Corporation
;
;   Purpose:
;
;   Revision History:
;
;  08-07-90 earleh rearranged things to allow building Pmode data
;	    structures with total size exceeding that of LIM 3.2 page
;	    frame
;  05/09/90 jimmat Started incorporating VCPI changes from languages group.
;
;   []      20-Feb-1990 Dans    Created
;
;************************************************************************/

CurrentCpu	=	@Cpu		;select 386 assembly if not already
ife (CurrentCpu AND 0008h)
	.386
endif

;
; Hungarian used:
;       la      Linear Address
;       za      Physical Address
;

;
;
; Miscellaneous equates
;
EMS_INT         =       067h
VCPIINT         =       067h
CBEMMSTR        =       8h
CPTDX		=	1h		; count of user page tables dx uses
CPTDXEXT	=	(CPTDX+1)	; count of total page tables dx uses
CBPAGE386	=	1000h		; bytes in 386 page
CBPAGE386LIM	=	1000h-1

DXINDOS 	=	00000001b
DXINEMS 	=	00000010b	; obsolete
DXINVCPI	=	00000100b
DXINXMS 	=	00001000b

;
; See dxvcpi.asm for a rough sketch of the memory block that the
;   following variables describe

DXLINEARBASE	=	80000000h	; Linear base of DX system memory

VCPIPTOFF	=	0 * CBPAGE386	; vcpi's 0th page table
DXPT1OFF	=	1 * CBPAGE386	; dx's first user page table
DXPTSYSOFF	=	DXPT1OFF + (CPTDX * CBPAGE386)
					; dx's system page table
DXPDOFF 	=	DXPTSYSOFF + CBPAGE386	; page directory
DXLASTPTOFF	=	DXPDOFF
DXBOOTPTOFF	=	DXPTSYSOFF
;
; Last user page table is used to bootstrap our protected mode
; data into extended memory.
;
DXTEMPPTOFF		=	DXPTSYSOFF - CBPAGE386
DX_TEMP_LINEARBASE	=	(DXTEMPPTOFF - VCPIPTOFF) shl	10

;
; The next number comes from the dosx.map file, and is equal to the
; offset of the CODEENDPM symbol, plus whatever padding we want to use
; so we don't have to update this include file too often.
;
if DEBUG
DXPMCODESIZE	=	04900H
else ; DEBUG
DXPMCODESIZE	=	04000H
endif ; DEBUG

IDTOFF		=	DXLASTPTOFF + CBPAGE386
IDTSIZE         =       CDSCIDTDEFAULT * 8
IDTLIM          =       IDTSIZE - 1

TSSOFF		=	IDTOFF + IDTSIZE
TSSTOP		=	TSSOFF + (type TSS386)

GDTOFF		=	((TSSTOP + 0fh) shr 4) shl 4   ; paragraph align
GDTLIM		=	GDT_SIZE - 1
GDTTOP		=	GDTOFF + GDT_SIZE

DXPMCODEOFF	=	((GDTTOP + 0fh) shr 4) shl 4	; paragraph align

LDTOFF		=	((DXPMCODEOFF + DXPMCODESIZE + CBPAGE386 - 1) shr 12) shl 12
LDTSIZE 	=	CDSCMAXLDT * 8
LDTLIM		=	LDTSIZE - 1
LDTTOP		=	LDTOFF + LDTSIZE

;
; Final place where page tables are mapped in Protected mode is
; at the first linear page boundary after the end of the LDT.
;

USERPT		=	(LDTTOP + CBPAGE386 - 1) shr 12
USERPTOFF	=	((LDTTOP + CBPAGE386 - 1) shr 12) shl 12

;
; The total number of 386 pages we need for the block that holds our
; system tables and protected mode code.
;
DXPMPAGES	=	(LDTTOP + (CBPAGE386 - 1)) shr 12
DXPMBYTES	=	DXPMPAGES shl 12
DXPMPARAGRAPHS	=	DXPMBYTES shr 4

;
; compile time asserts for sizes/offsets/alignment
;
.ERRE	(type TSS386) GE 104
.ERRE	TSSTOP LE GDTOFF
.ERRE	IDTOFF EQ ((IDTOFF SHR 4) SHL 4)

;
; Limits of tables
;
DXPTMAX         =       CPTDX * CBPAGE386       ; space we allocate for
						; user page tables

;
; Linear pointers to bases of various tables when running under vcpi
;

; For a selDXPD descriptor (dos extender's page directory)
;
LADXPDBASE	=	DXLINEARBASE + DXPDOFF

; For a selDXPT descriptor (dos extender's page tables)
;
LADXPTBASE	=	DXLINEARBASE + USERPTOFF	; (Plus runtime value.)

; For a selGDT descriptor
;
LADXGDTBASE     =       DXLINEARBASE + GDTOFF

; For a selLDT descriptor
;
LADXLDTBASE     =       DXLINEARBASE + LDTOFF

; For a selIDT descriptor
;
LADXIDTBASE     =       DXLINEARBASE + IDTOFF

; For a selTSS descriptor
;
LADXTSS1BASE    =       DXLINEARBASE + TSSOFF
LADXTSS2BASE    =       DXLINEARBASE + TSSOFF + type TSS386

; For a SEL_DXPMCODE descriptor
;
LADXPMCODEBASE  =       DXLINEARBASE + DXPMCODEOFF


;
; vcpi/ems service macros
;
RMvcpi  macro fCode
        ifnb    <fCode>
        mov     ax, fCode
        endif
        int     VCPIINT
        endm

PMvcpi  macro fCode
        ifnb    <fCode>
        mov     ax, fCode
	endif
	cCall	CallVCPIPM
        endm

emscall macro   fCode
        ifnb    <fCode>
        mov     ax, fCode
        endif
        int     EMS_INT
        endm

; EMS functions/subfunctions

GETFRAMEADDRESS =	04100h

ALLOCATEPAGES	=	05A00h
GETNUMOFPAGES	=	04200h
MAPHANDLEPAGE   =       04400h
DEALLOCATEPAGES =       04500h
GETEMSVER       =       04600h
SETHANDLENAME   =       05301h
GETPAGEADDRS	=	05800h
GETNUMPAGEMAP	=	05801h

page
;
; VCPI functions/subfunctions
;       all functions take the vcpi function code in ax as input
;       all functions return ah=0 if successful, ah != 0 if failure
;       if function return has no ah value, it can't fail (ah == 0)
;
;

; vcpi version, presence
;
vcpiVER         =       0de00h
        ;
        ; input:
        ; return:       ah = 0, bl = vcpi minor revision, bh = major revision
        ;

; get protect mode interface
;
vcpiPMINTERFACE =       0de01h
        ;
        ; input:        es:di = ptr to 4k page table,
        ;               ds:si = ptr to 3 entries in GDT
        ; return:       di = 1st unused page table entry,
        ;               ebx = offset in server CS of PM entry point
        ;

; get max physical address in system
;
vcpiMAXPHYSADDR =       0de02h
        ;
        ; input:
        ; return:       edx = physical addr of highest 4k page that
        ;                       could ever be allocated
        ;

; count of free 4k pages
;
; Note:  This call gives the total 386 pages available to all tasks
; in the system from the VCPI server.  According to VCPI version 1.0,
; however, we should only allocate as much memory as there is EMS
; memory available.  The following call, therefore, is not real useful
; to us.
;
vcpiCFREEPAGES  =       0de03h
        ;
        ; input:
        ; return:       edx = number of free 4k pages
        ;

; allocate a 4k page
;
vcpiALLOCPAGE   =       0de04h
        ;
        ; input:
        ; return:       ah = 0, edx = physical address of allocated 4k page
        ;               ah != 0, edx = trashed
        ;

; free a 4k page
;
vcpiFREEPAGE    =       0de05h
        ;
        ; input:        edx = physical address of page to free
        ; return:       ah = 0
        ;               ah != 0
        ;

; physical address of page in 1st meg
;
vcpiPHYSADDRPAGE=       0de06h
        ;
        ; input:        cx = page number (linear addr of page SHR by 12)
        ; return:       ah = 0, edx = physical address of 4k page
        ;               ah != 0
        ;

; read cr0
;
vcpiREADCR0     =       0de07h
        ;
        ; input:
        ; return:       ebx = cr0 value
        ;

; read debug registers
;
vcpiREADDRx     =       0de08h
        ;
        ; input:        es:di = ptr to 8 dwords, dr0 first, dr4, dr5 not present
        ; return:
        ;

; load debug registers
;
vcpiLOADDRx     =       0de09h
        ;
        ; input:        es:di = ptr to 8 dwords, dr0 first, dr4, dr5 not present
        ; return:
        ;

; get mapping of hardware interrupts
;
vcpiGET8259MAP  =       0de0ah
        ;
        ; input:
        ; return:       bx = 1st vector mapping for master 8259a
        ;               cx = 1st vector mapping for slave  8259a

; set mapping of hardware interrupts
;
vcpiSET8259MAP  =       0de0bh
        ;
        ; input:        interrupts disabled
        ;               bx = 1st vector mapping for master 8259a
        ;               cx = 1st vector mapping for slave  8259a
        ; return:
        ;

; switch from v86 mode to protect mode or protect mode to v86 mode
;
vcpiSWITCHTOPM  =       0de0ch
        ;
        ; input:        interrupts disabled
        ;               esi = linear address (in first megabyte) of data
        ;                       structure (v86topm struc)
        ;
        ; return:       (output in pm)
        ;               gdtr, idtr, ldtr, tr loaded
        ;               ss:esp must have 16 bytes of space on it, pm must
        ;                       set up it's stack
        ;               eax = trashed
        ;               esi = trashed
        ;               ds, es, fs, gs all modified
        ;               interrupts disabled
        ;

vcpiSWITCHTOV86 =       0de0ch
        ;
        ; input:        interrupts disabled
        ;               STACK:  28  dword   gs
        ;                       24  dword   fs
        ;                       20  dword   ds
        ;                       1c  dword   es
        ;                       18  dword   ss
        ;                       14  dword   esp
        ;                       10  dword   eflags reserved
        ;                       0c  dword   cs xfer to
        ;                       08  dword   eip xfer to
        ;                       00  qword   far32 return (garbage)
        ;
        ;
        ; return:       (output in rm)
        ;               ss:esp loaded with values from stack
        ;               segment registers loaded with stack values
        ;               eax = trashed
        ;               interrupts disabled

;
; structures
;
VTP     struc
        zaCr3VTP        dd      0       ; physical addr of page directory
        laGdtrVTP       dd      0       ; linear addr in first meg of gdtr
        laIdtrVTP       dd      0       ; linear addr in first meg of idtr
        selLdtVTP       dw      0       ; selector of ldt
        selTrVTP        dw      0       ; selector of tr
        ipVTP           dw      0       ; 48-bit address of protect
        unusedVTP       dw      0       ;   mode entry point to xfer to
        csVTP           dw      0       ;
VTP     ends


ife (CurrentCpu AND 0008h)		;restore cpu type if not 386
   if (CurrentCpu AND 0080h)
      .286p
   else
      .286
   endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\hostdata.inc ===
;*++
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    Hostdata.inc
;
;Abstract:
;
;    This module contains definitions associated with the host private data
;    for the NT vdm dpmi host
;
;Author:
;
;    Dave Hastings (daveh) 18-Mar-1992
;
;
;Revision History:
;*++

;
; Note: the following structure should match the pmUser portion of the
;       INTRSTACK structure.
;
AppState struc
IFDEF DPMI32
AsES    dd      ?
AsDS    dd      ?
AsDI    dd      ?
AsSI    dd      ?
AsBP    dd      ?
AsSPx   dd      ?
AsBX    dd      ?
AsDX    dd      ?
AsCX    dd      ?
AsAX    dd      ?
AsFL    dd      ?
AsSS    dd      ?
AsSP    dd	?
ELSE
AsES    dw      ?
AsDS    dw      ?
AsDI    dw      ?
AsSI    dw      ?
AsBP    dw      ?
AsSPx   dw      ?
AsBX    dw      ?
AsDX    dw      ?
AsCX    dw      ?
AsAX    dw      ?
AsFL    dw      ?
AsSS    dw      ?
AsSP    dw	?
ENDIF
AppState ends

IFDEF DPMI32
APPSTATE_SIZE equ 52
ELSE
APPSTATE_SIZE equ 26
ENDIF

HostData struc
Hdflags         dw      0
HdSelParent     dw      0
HdSegParent     dw      0
HdSelPSP        dw      0
HdPSPParent     dw      0
HdPspTerminate  dd      0
HdState         db      APPSTATE_SIZE dup (0)
HostData ends

IFDEF DPMI32
HOST_DATA_SIZE equ 58
ELSE
HOST_DATA_SIZE equ 36
ENDIF

HD_32BITAPP     equ     1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\gendefs.inc ===
; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*  GENDEFS.INC  -- General Symbol Defintions for Dos Extender  *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  05/08/90 jimmat Changes for VCPI support.                   *
;*  01/07/90 jimmat Make DOSX version 03.00.                    *
;*   7/28/89 jimmat Increased GDT/LDT size yet again.           *
;*   4/01/89 jimmat Increased size of GDT/LDT (again)           *
;*   3/30/89 jimmat Added ChkPoint macro for debugging          *
;*   3/11/89 jimmat Added support for LDT & TSS                 *
;*   3/09/89 jimmat Added DX_DYNALINK function                  *
;*  02/22/89 (GeneA): increased size of interrupt reflector     *
;*      stack frames (CB_STKFRAME) from 128 to 256 bytes        *
;*  02/17/89 (GeneA): removed ERC_??? equates                   *
;*  02/10/89 (GeneA): changed form of definitions for the       *
;*      EXEC_??? symbols, and added ERC_??? error code symbols. *
;*  12/13/88 (GeneA): moved definitions for EXEC_??? symbols    *
;*      and RELOC_BUFFER here from dxinit.asm
;*  12/08/88 (GeneA): added npopf function                      *
;*  12/08/88 (GeneA): added HMMFUNC definition                  *
;*                                                              *
;****************************************************************

ifndef DEBUG                    ;define DEBUG switch if it isn't already
DEBUG   =       0
endif
ifndef MINBUG
MINBUG  =       0
endif
ifndef VCPI
VCPI    =       0
endif
ifndef NO386
NO386   =       0
endif

; -------------------------------------------------------
;               MISC. PROGRAM CONSTANTS
; -------------------------------------------------------

DXVERSION       =   030Ah   ;Version 03.10
DPMI_32BIT      equ     0000000000000001b

if VCPI
CDSCGDTDEFAULT  =   3072          ;default size of GDT **** temp for VCPI **** !!!
CDSCLDTDEFAULT  =   2
else
CDSCGDTDEFAULT  =   3072    ;default size of GDT
endif

CDSCMAXLDT      =   8190    ;maximum possible LDT selectors

CDSCIDTDEFAULT  =   256     ;default size of IDT

CB_XFRBUF0  =       128     ;size of small transfer buffer
;
; Performance enhancement, by RalphL
;
CB_XFRBUF1  =       8192        ;size of large transfer buffer

CB_STKFRAME     =   384     ;size of a stack frame

CB_MEMHDR       =       16      ; size of memory block header (1 paragraph)

CXMSBLOCKSDX    =       16      ; number of XMS blocks to allocate

INTA00      =   20h         ;i/o address of master 8259
INTA01      =   21h
INTB00      =   0A0h        ;i/o address of slave 8259
INTB01      =   0A1h

CMOSLoc     =   70h         ;CMOS ram/Real-Time Clock location port
CMOSValue   =   71h         ;CMOS ram/Real-Time Clock value port

HP_VECTRA   =   01h         ;Running on an HP Vectra
HP_CLASSIC  =   02h         ;Running on a 'Classic' Vectra (A & A+)

CRESERVED   =   32          ;Reserved interrupt numbers

; The following equates define the DOS Extender DynaLink services

if DEBUG

OutDebugStr     =       0       ;debugging text out service
TestDebugIns    =       1       ;debugger installation check service

NUM_DYNALINK    =       2

else ;  !DEBUG

NUM_DYNALINK    =       0

endif



; This structure defines the format of the Exec paramter block used
; by the MS-DOS exec function (ah=4Bh, al=01).

XBLK    struc

segEnv          dw      ?       ;segment address of environment to use
lpchCmnd        dd      ?       ;far pointer to command line
lpFCB0          dd      ?       ;far pointer to first default fcb
lpFCB1          dd      ?       ;far pointer to second default fcb
lpChildStack    dd      ?       ;return value, far pointer to child stack
lpChildCode     dd      ?       ;return value, far pointer to child code

XBLK    ends


; The following symbols define locations in rgbXfrBuf1 used
; during initialization.  ParseCommandLine places this information
; into the buffer to be used by later programs.

BUFTMP  = CB_XFRBUF1 - 1024         ;use the top 1k for the temporary buffers

EXEC_PROGNAME   equ <DGROUP:rgbXfrBuf1+BUFTMP+0000h> ;child program's exe file name
EXEC_DXNAME     equ <DGROUP:rgbXfrBuf1+BUFTMP+0080h> ;Dos Extender program name
EXEC_CMNDLINE   equ <DGROUP:rgbXfrBuf1+BUFTMP+0100h> ;command line to pass to the child
EXEC_EXEHDR     equ <DGROUP:rgbXfrBuf1+BUFTMP+0180h> ;buffer for holding exe header for
                                                     ; the overlay currently being
                                                     ; loaded
EXEC_FCB0       equ <DGROUP:rgbXfrBuf1+BUFTMP+01A0h> ;FCB0 to pass to the child
EXEC_FCB1       equ <DGROUP:rgbXfrBuf1+BUFTMP+01D0h> ;FCB1 to pass to the child
RELOC_BUFFER    equ <DGROUP:rgbXfrBuf1+BUFTMP+0200h> ;file input buffer used to hold
                                                     ; pages of the relocation table
                                                     ; while relocating the current
                                                     ; overlay
;
; This structure defines the stack frame used to hold the entry
; values and automatic variables for Dos Extender functions.

FUNCSTACK   struc

fnsUserES   dw      ?
fnsUserDS   dw      ?
fnsUserDI   dw      ?
fnsUserSI   dw      ?
fnsUserBP   dw      ?
fnsUserSPx  dw      ?
fnsUserBX   dw      ?
fnsUserDX   dw      ?
fnsUserCX   dw      ?
fnsUserAX   dw      ?

fnsUserIP   dw      ?
fnsUserCS   dw      ?
fnsUserFL   dw      ?

fnsUserSS   dw      ?
fnsUserSP   dw      ?

FUNCSTACK   ends

; -------------------------------------------------------
;               DEFINITIONS FOR MACROS
; -------------------------------------------------------

; These macros are used to switch between the protected mode
; only code segment and the mixed protected/real mode code segment.
; They are intended to be used for switching between modes in-line
; within a routine.  They must be used in pairs, bracketing the
; code that needs to be in the other mode (from the initial or 'native'
; mode of the function.)

; -------------------------------------------------------
;
; This macro switches the processor and the local segment context
; to the dos extender protected mode segment.

SwitchToProtectedMode   macro
        local   foo

        ifndef  EnterProtectedMode
        extrn   EnterProtectedMode:NEAR
        endif

        call    EnterProtectedMode
        % ifidni  <@CURSEG>,<DXCODE>
;       jmp     far ptr foo
        db      0EAh                            ;avoid need for fixups
        dw      offset DXPMCODE:foo
        dw      SEL_DXPMCODE OR STD_RING
DXCODE  ends

DXPMCODE    segment
        assume  cs:DXPMCODE
        endif
foo:
        endm

; -------------------------------------------------------
;
; This macro switches the processor and the local segment context
; to the dos extender mixed protected/real mode segment.

SwitchToRealMode    macro
        local   foo

        % ifidni  <@CURSEG>,<DXPMCODE>
;       jmp     far ptr foo
        db      0EAh                            ;avoid need for fixups
        dw      offset DXCODE:foo
        dw      SEL_DXCODE OR STD_RING
DXPMCODE    ends


DXCODE  segment
        assume  cs:DXCODE
        endif

        ifndef  EnterRealMode
        extrn   EnterRealMode:NEAR
        endif

foo:
        call    EnterRealMode

        endm


; -------------------------------------------------------
;

BeginLowSegment macro

DXCODE  segment
        assume  cs:DXCODE

        endm

EndLowSegment   macro

DXCODE  ends

        endm


BeginHighSegment    macro

DXPMCODE    segment
        assume  cs:DXPMCODE

        endm

EndHighSegment  macro

DXPMCODE    ends

        endm

; -------------------------------------------------------
;
; This macro switches the local segment context
; to the dos extender protected mode segment.

ChangeToHighSegment     macro
        local   foo

        % ifidni  <@CURSEG>,<DXCODE>
        .err
        %out Switch to high segment when already in high segment
        endif
        jmp     far ptr foo
DXCODE  ends

DXPMCODE    segment
        assume  cs:DXPMCODE
foo:
        endm

; -------------------------------------------------------
;
; This macro switches the local segment context
; to the dos extender mixed protected/real mode segment.

ChangeToLowSegment  macro
        local   foo
        % ifidni  <@CURSEG>,<DXCODE>
        .err
        %out Switch to low segment when already in low segment
        endif

        jmp     far ptr foo
DXPMCODE    ends

DXCODE  segment
        assume  cs:DXCODE
foo:
        endm


; -------------------------------------------------------
;

PushCParams MACRO P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
        IRP Param, <P10, P9, P8, P7, P6, P5, P4, P3, P2, P1>
        IFNB <Param>
        push    Param
        ENDIF
        ENDM
        ENDM

ClearCParams MACRO Count, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
IFNB <P1>
        ClearCParams %(Count+1), <P2>, <P3>, <P4>, <P5>, <P6>, <P7>, <P8>, <P9>, <P10>
ELSE
IF Count
        add     sp, Count*2
ENDIF
ENDIF
        ENDM


; -------------------------------------------------------
; This macro calls one of the DX services

DXcall  MACRO Procedure, Param_List
IFNDEF  WOW_x86                             ; BUGBUG
        PushCParams Param_List
        db      9Ah                     ;call sel:0
        dw      0
        dw      SEL_DYNALINK + (Procedure SHL 3)
        ClearCParams 0, Param_List
ENDIF
        ENDM

; -------------------------------------------------------
; This macro displays a string if DEBUG
;
; Note: This macro only works in PROTECT MODE! **********

Trace_Out MACRO String, nocrlf
        LOCAL   String_Offset
ifndef WOW_x86      ;bugbug
IF DEBUG

DXDATA SEGMENT
String_Offset LABEL BYTE
        db      String
IFB <nocrlf>
        db      0Ah, 0Dh
ENDIF
        db      0
DXDATA ENDS

        push    ds
        pushf
        cli
        pusha                           ; save our registers
        pusha                           ; copy them for print routine

        mov     ax,SEL_DXDATA           ; make sure string is addressable
        mov     ds,ax

        mov     si,OFFSET DGROUP:String_Offset
        DXcall  OutDebugStr

        popa                            ; restore our registers

        npopf
        pop     ds
ENDIF
endif   ;WOW_x86
        ENDM

; -------------------------------------------------------
; This macro displays a string and breaks if DEBUG
;
; Note: This macro only works in PROTECT MODE! **********

Debug_Out MACRO String
        LOCAL   Skip_Int1
IF DEBUG
        pushf
        Trace_Out   <String>
        DXcall  TestDebugIns
        jz      SHORT Skip_Int1
        int     1
Skip_Int1:
        npopf
ENDIF
        ENDM

; -------------------------------------------------------
; This macro displays a string if DEBUG
;
; Note: This macro only works in REAL MODE! **********
;
; DS must be set to the DOS Extender's DS before using, too.
;

Real_Trace_Out MACRO String, nocrlf
        LOCAL   String_Offset
IF DEBUG

ifndef DXOutDebugStr
        EXTRN DXOutDebugStr:FAR
endif

DXDATA SEGMENT
String_Offset LABEL BYTE
        db      String
IFB <nocrlf>
        db      0Ah, 0Dh
ENDIF
        db      0
DXDATA ENDS

        pushf
        cli
        pusha                           ; save our registers
        pusha                           ; copy them for print routine

        mov     si,OFFSET DGROUP:String_Offset
        call    DXOutDebugStr

        popa                            ; restore our registers

        npopf
ENDIF
        ENDM

; -------------------------------------------------------
; This macro displays a string and breaks if DEBUG
;
; Note: This macro only works in REAL MODE! **********
;
; DS must be set to the DOS Extender's DS before using, too.
;

Real_Debug_Out MACRO String
        LOCAL   Skip_Int1
IF DEBUG
        pushf
        Real_Trace_Out  <String>
        cmp     fDebug,0
        jz      SHORT Skip_Int1
        int     1
Skip_Int1:
        npopf
ENDIF
        ENDM

; -------------------------------------------------------
; Delay for I/O Instructions...

IO_Delay MACRO
        jmp     short $+2
        jmp     short $+2
        jmp     short $+2
        ENDM

; -------------------------------------------------------
;8080-style return macros due to Greg Whitten

genrcc  macro   cc
r&cc    &macro  labl
if      $-___ret gt 126d
        jn&cc   $+3     ;;Skip around ret
___ret  = $
        ret
else
        j&cc    ___ret  ;;jmp to last ret
endif
        &endm

rn&cc   &macro  labl
if      $-___ret gt 126d
        j&cc    $+3     ;;Skip around ret
___ret  = $
        ret
else
        jn&cc   ___ret  ;;jmp to last ret
endif
        &endm

call&cc &macro  labl
        jn&cc   $+5     ;;Skip around call
        call    labl
        &endm

calln&cc        &macro  labl
        j&cc    $+5     ;;Skip around call
        call    labl
        &endm

jmp&cc  &macro  labl
        jn&cc   $+5     ;;Skip around jmp
        jmp     labl
        &endm

jmpn&cc &macro  labl
        j&cc    $+5     ;;Skip around jmp
        jmp     labl
        &endm

        endm

; -------------------------------------------------------
;       rcc and rncc macro generators

genrcc  a
genrcc  ae
genrcc  b
genrcc  be
genrcc  c
genrcc  e
genrcc  g
genrcc  ge
genrcc  l
genrcc  le
genrcc  o
genrcc  s
genrcc  z

return  macro
___ret  = $
        ret
        endm

; -------------------------------------------------------
;
; This macro is used to get around the bug in the POPF instruction in
; some early 80286 chips.
IFDEF WOW
npopf   macro
        rpopf
        endm
ELSE
npopf   macro
        local   a
        jmp     $+3             ; Fix for bug in POPF on IBM AT
a:      iret                   ; This simulates a POPF instruction
        push    cs
        call    a
endm
ENDIF
; -------------------------------------------------------
;
; MS-DOS function call macros

dossvc  macro   fcn
        ifnb    <fcn>
        mov     ah,fcn
        endif
        int     21h
        endm

pmdossvc macro  fcn
        ifnb    <fcn>
        mov     ah,fcn
        endif
        pushf                   ;don't do Int 21h in case child has Int 21h
        cli                     ;  hooked (like Windows)
        push    cs
        call    PmIntrDos
        endm

; -------------------------------------------------------
; This macro will request a Dos Extender funtion.

dxsvc   macro   fcn
        ifnb    <fcn>
        mov     al,fcn
        endif
        mov     ah,DXFUNC
        int     2Fh
        endm

; -------------------------------------------------------
; This macro is used to make calls to the XMS driver for
; extended memory management.

HMMFUNC =       43h             ;Himem driver Int 2Fh function code

xmssvc  macro   fcn
        ifnb    <fcn>
        mov     ah,fcn
        endif
        call    [lpfnXMSFunc]
        endm

; -------------------------------------------------------

out1    macro   p
        if1
        %out p
        endif
        endm

; -------------------------------------------------------

errnz   macro   p
        if2
        .errnz  p
        endif
        endm

; -------------------------------------------------------
; -------------------------------------------------------
; -------------------------------------------------------

;****************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxnetbio.asm ===
PAGE    ,132
        TITLE   DXNETBIO.ASM  -- Dos Extender NetBIOS API Mapper

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXNETBIO.ASM    -   DOS Extender NetBIOS API Mapper
;
;-----------------------------------------------------------------------
;
; This module provides the 286 DOS Extender's API mapping of Int 2Ah and
; 5Ch NetBIOS requests.  It allows a protected mode application to
; issue NetBIOS requests without worrying about segment to selector
; translations and mapping of buffers between extended and conventional
; memory.
;
;-----------------------------------------------------------------------
;
;  11/29/90 amitc    Modified code to have the POST routine in GlobalMemory
;                    and queue the POST when DOSX is not around.
;  11/29/90 amitc    Call to InitLowHeap moved to this file from DXOEM.ASM
;  02/01/90 jimmat   Update Api mapping table for Ungerman-Bass extensions
;                    as per new data from UB.
;  06/15/89 w-glenns Finished TermNetMapper, added Delay/ResumeNetPosting
;  04/18/89 jimmat   Original version.
;  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include interupt.inc
include netbios.inc
include intmac.inc
include stackchk.inc

include bop.inc
include rdrsvc.inc
include dpmi.inc
include rdrsvc.inc

        .list

; -------------------------------------------------------
;           FLAG FOR PM NCB HANDLING
; -------------------------------------------------------

PM_NCB_HANDLING equ     1       ; set to 0 for NCB handling in VM

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

; The following equates define the codes that map between a NCB Command code
; and the mapping flags used to process it.  To be compatible with Windows/386,
; these values are all increments of 4 (they use 32 bit offsets).  These
; values should always correspond to the values used by the Windows/386
; NetBIOS mapping!

ApiMapUnknown   EQU     00h
ApiMapNone      EQU     04h
ApiMapIn        EQU     08h
ApiMapOut       EQU     0Ch
ApiMapInOut     EQU     10h
ApiChainSend    EQU     14h
ApiCancel       EQU     18h
ApiBufferIn     EQU     1Ch
ApiBufferOut    EQU     20h
ApiBufferInOut  EQU     24h


; The following equates define the bit flags which identify the actions
; to take on entry and exit of a NetBIOS request.

BUFF_IN         EQU     01h             ;Buffer data to the int handler
BUFF_OUT        EQU     02h             ;Buffer data from the int handler
BUFF_CHAIN      EQU     04h             ;Special chain send buffering
BUFF_CANCEL     EQU     08h             ;Special cancel buffering

REPLACE_MAP_TABLE EQU   1607h           ;Int2fh replace net map table service
VNETBIOS_DEV_ID   EQU   14h             ;VNETBIOS device ID

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   EnterIntHandler:NEAR
        extrn   LeaveIntHandler:NEAR
        extrn   EnterRealMode:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   GetSegmentAddress:NEAR
externFP   NSetSegmentDscr
        extrn   Lma2SegOff:NEAR

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

ifdef      NEC_98
        extrn   fNHmode:BYTE
endif   ;NEC_98
        extrn   pbReflStack:WORD
        extrn   bReflStack:WORD
        extrn   regUserSS:WORD
        extrn   regUserSP:WORD
        extrn   rgbXfrBuf1:BYTE
        extrn   segDXCode:WORD
        extrn   NetHeapSize:WORD

ifdef WOW_x86
        extrn   FastBop:fword
endif

OldInt73 dd 0
        public  HCB_List

Cancel_NCB      EQU     rgbXfrBuf1      ;Easier for commenting/readability

HCB_List        dw      0               ;linked list of low HCB/NCB/Buffers

lpfnOldInt2A    dd      ?               ;old int vector 2Ah & 5Ch routines
lpfnOldInt5C    dd      ?

lpfnRmNetIsr    dd      ?               ;Real Mode vector to Network Int Rtn

SelNetStubCode                  dw 0    ;sel for stub code
SegNetStubCode                  dw 0    ;segment for stub code
AddrfStubDelayNetPosting        dw ?    ;address of fStubDelayNetPosting in StubSeg
AddrfStubTermNetRequest         dw ?    ;address of fStubTermNetRequest in StubSeg

NBPSp           dw      0

; The ApiMapTbl converts an NCB Command code (0-7F) into a code that
; identifies the particular mapping routine to execute.

ApiMapTbl       label   byte
        db      ApiMapUnknown           ; 00h -
        db      ApiMapUnknown           ; 01h -
        db      ApiMapUnknown           ; 02h -
        db      ApiMapUnknown           ; 03h -
        db      ApiMapUnknown           ; 04h -
        db      ApiMapUnknown           ; 05h -
        db      ApiMapUnknown           ; 06h -
        db      ApiMapUnknown           ; 07h -
        db      ApiMapUnknown           ; 08h -
        db      ApiMapUnknown           ; 09h -
        db      ApiMapUnknown           ; 0Ah -
        db      ApiMapUnknown           ; 0Bh -
        db      ApiMapUnknown           ; 0Ch -
        db      ApiMapUnknown           ; 0Dh -
        db      ApiMapUnknown           ; 0Eh -
        db      ApiMapUnknown           ; 0Fh -
        db      ApiMapNone              ; 10h - Call
        db      ApiMapNone              ; 11h - Listen
        db      ApiMapNone              ; 12h - Hang up
        db      ApiMapUnknown           ; 13h -
        db      ApiBufferIn             ; 14h - Send
        db      ApiBufferOut            ; 15h - Receive
        db      ApiBufferOut            ; 16h - Receive any
        db      ApiChainSend            ; 17h - Chain send
        db      ApiMapUnknown           ; 18h -
        db      ApiMapUnknown           ; 19h -
        db      ApiMapUnknown           ; 1Ah -
        db      ApiMapUnknown           ; 1Bh -
        db      ApiMapUnknown           ; 1Ch -
        db      ApiMapUnknown           ; 1Dh -
        db      ApiMapUnknown           ; 1Eh -
        db      ApiMapUnknown           ; 1Fh -
        db      ApiBufferIn             ; 20h - Send datagram
        db      ApiBufferOut            ; 21h - Receive datagram
        db      ApiBufferIn             ; 22h - Send broadcast datagram
        db      ApiBufferOut            ; 23h - Receive broadcast dgram
        db      ApiMapUnknown           ; 24h -
        db      ApiMapUnknown           ; 25h -
        db      ApiMapUnknown           ; 26h -
        db      ApiMapUnknown           ; 27h -
        db      ApiMapUnknown           ; 28h -
        db      ApiMapUnknown           ; 29h -
        db      ApiMapUnknown           ; 2Ah -
        db      ApiMapUnknown           ; 2Bh -
        db      ApiMapUnknown           ; 2Ch -
        db      ApiMapUnknown           ; 2Dh -
        db      ApiMapUnknown           ; 2Eh -
        db      ApiMapUnknown           ; 2Fh -
        db      ApiMapNone              ; 30h - Add name
        db      ApiMapNone              ; 31h - Delete name
        db      ApiMapNone              ; 32h - Reset
        db      ApiMapOut               ; 33h - Adapter status
        db      ApiMapOut               ; 34h - Session status
        db      ApiCancel               ; 35h - Cancel
        db      ApiMapNone              ; 36h - Add group name
        db      ApiMapUnknown           ; 37h -
        db      ApiMapUnknown           ; 38h -
        db      ApiMapUnknown           ; 39h -
        db      ApiMapUnknown           ; 3Ah -
        db      ApiMapUnknown           ; 3Bh -
        db      ApiMapUnknown           ; 3Ch -
        db      ApiMapUnknown           ; 3Dh -
        db      ApiMapUnknown           ; 3Eh -
        db      ApiMapUnknown           ; 3Fh -
        db      ApiMapUnknown           ; 40h -
        db      ApiMapUnknown           ; 41h -
        db      ApiMapUnknown           ; 42h -
        db      ApiMapUnknown           ; 43h -
        db      ApiMapUnknown           ; 44h -
        db      ApiMapUnknown           ; 45h -
        db      ApiMapUnknown           ; 46h -
        db      ApiMapUnknown           ; 47h -
        db      ApiMapUnknown           ; 48h -
        db      ApiMapUnknown           ; 49h -
        db      ApiMapUnknown           ; 4Ah -
        db      ApiMapUnknown           ; 4Bh -
        db      ApiMapUnknown           ; 4Ch -
        db      ApiMapUnknown           ; 4Dh -
        db      ApiMapUnknown           ; 4Eh -
        db      ApiMapUnknown           ; 4Fh -
        db      ApiMapUnknown           ; 50h -
        db      ApiMapUnknown           ; 51h -
        db      ApiMapUnknown           ; 52h -
        db      ApiMapUnknown           ; 53h -
        db      ApiMapUnknown           ; 54h -
        db      ApiMapUnknown           ; 55h -
        db      ApiMapUnknown           ; 56h -
        db      ApiMapUnknown           ; 57h -
        db      ApiMapUnknown           ; 58h -
        db      ApiMapUnknown           ; 59h -
        db      ApiMapUnknown           ; 5Ah -
        db      ApiMapUnknown           ; 5Bh -
        db      ApiMapUnknown           ; 5Ch -
        db      ApiMapUnknown           ; 5Dh -
        db      ApiMapUnknown           ; 5Eh -
        db      ApiMapUnknown           ; 5Fh -
        db      ApiMapUnknown           ; 60h -
        db      ApiMapUnknown           ; 61h -
        db      ApiMapUnknown           ; 62h -
        db      ApiMapUnknown           ; 63h -
        db      ApiMapUnknown           ; 64h -
        db      ApiMapUnknown           ; 65h -
        db      ApiMapUnknown           ; 66h -
        db      ApiMapUnknown           ; 67h -
        db      ApiMapUnknown           ; 68h -
        db      ApiMapUnknown           ; 69h -
        db      ApiMapUnknown           ; 6Ah -
        db      ApiMapUnknown           ; 6Bh -
        db      ApiMapUnknown           ; 6Ch -
        db      ApiMapUnknown           ; 6Dh -
        db      ApiMapUnknown           ; 6Eh -
        db      ApiMapUnknown           ; 6Fh -
        db      ApiMapNone              ; 70h - Unlink
        db      ApiMapUnknown           ; 71h -
        db      ApiMapNone              ; 72h - Ungerman Bass Register
        db      ApiBufferIn             ; 73h - Ungerman Bass SendNmc
        db      ApiMapNone              ; 74h - Ungerman Bass Callniu
        db      ApiMapNone              ; 75h - Ungerman Bass Calladdr
        db      ApiMapNone              ; 76h - Ungerman Bass Listenaddr
        db      ApiBufferIn             ; 77h - Ungerman Bass SendPkt
        db      ApiBufferOut            ; 78h - Ungerman Bass RcvPkt
        db      ApiBufferIn             ; 79h - Ungerman Bass SendAttn
        db      ApiBufferOut            ; 7Ah - Ungerman Bass RcvAttn
        db      ApiBufferOut            ; 7Bh - Ungerman Bass Listenniu
        db      ApiBufferOut            ; 7Ch - Ungerman Bass RcvRaw
        db      ApiBufferIn             ; 7Dh - Ungerman Bass SendNmc2
        db      ApiMapUnknown           ; 7Eh -
        db      ApiMapNone              ; 7Fh - Install check

; The next table maps the (Windows/386 compatible) code from ApiMapTbl
; to the bit flags which control our entry/exit mapping.

EntryExitFlags  label   byte
        db      BUFF_IN+BUFF_OUT        ;ApiMapUnknown
        db      0                       ;ApiMapNone
        db      BUFF_IN                 ;ApiMapIn
        db      BUFF_OUT                ;ApiMapOut
        db      BUFF_IN+BUFF_OUT        ;ApiMapInOut
        db      BUFF_CHAIN              ;ApiChainSend
        db      BUFF_CANCEL             ;ApiCancel
        db      BUFF_IN                 ;ApiBufferIn
        db      BUFF_OUT                ;ApiBufferOut
        db      BUFF_IN+BUFF_OUT        ;ApiBufferInOut

DXDATA  ends


; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   selDgroup:WORD

DXCODE  ends

DXPMCODE    segment

        extrn   selDgroupPM:WORD

DXPMCODE    ends

        page
; ----------------------------------------------------------------------
;
;   The following routines handle INT 2Ah and 5Ch interrupts that
;   request NetBIOS services.  Typically, these interrupts require
;   that a NCB and/or buffer be copied between conventional and
;   extended memory, and register values be modified due to real-
;   mode/protected-mode addressing differences.
;
;   (Note: this comment copied almost unchanged from DXINTR.ASM)
;
;   The following conventions are used:
;
;   A stack is allocated from the interrupt reflector stack for these
;   routines to use.  This allows nested servicing of interrupts.
;   A stack frame is built in the allocated stack which contains the
;   following information:
;
;           original caller's stack address
;           caller's original flags and general registers (in pusha form)
;           caller's original segment registers (DS & ES)
;           flags and general registers to be passed to interrupt routine
;               (initially the same as caller's original values)
;           segment registers (DS & ES) to be passed to interrupt routine
;               (initially set to the Dos Extender data segment address)
;
;   This stack frame is built by the routine EnterIntHandler, and its
;   format is defined by the structure INTRSTACK.  The stack frame is
;   destroyed and the processor registers set up for return to the user
;   by the function LeaveIntHandler.
;
;   There are two sets of general registers and two sets of segment
;   registers (DS & ES) on the stack frame.  One set of register values
;   has member names of the form intUserXX.  The values in these stack
;   frame members will be passed to the interrupt service routine when
;   it is called, and will be loaded with the register values returned
;   by the interrupt service routine.  The other set of registers values
;   has member names of the form pmUserXX.  These stack frame members
;   contain the original values in the registers on entry from the
;   user program that called the interrupt.
;
;   When we return to the original caller, we want to pass back the
;   general registers as returned by the interrupt routine (and possibly
;   modified by the exit handler), and the same segment registers as
;   on entry, unless the interrupt routine returns a value in a segment
;   register. (in this case, there must be some code in the exit routine
;   to handle this).  This means that when we return to the caller, we
;   return the general register values from the intUserXX set of stack
;   frame members, but we return the segment registers from the pmUserXX
;   set of frame members.  By doing it this way, we don't have to do
;   any work for the case where the interrupt subfuntion doesn't require
;   any parameter manipulation.  NOTE however, this means that when
;   manipulating register values to be returned to the user, the segment
;   registers are treated opposite to the way the general registers are
;   treated.  For general registers, to return a value to the user,
;   store it in a intUserXX stack frame member.  To return a segment
;   value to the user, store it in a pmUserXX stack frame member.
;


; -------------------------------------------------------
        subttl NetBIOS API Mapper Initialization Routine
        page
; -------------------------------------------------------
;        NetBIOS API MAPPER INITIALIZATION ROUTINE
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

;--------------------------------------------------------
;   InitNetMapper -- This routine initializates the NetBIOS API mapper.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   all registers preserved
;
;   Note:   This routine expects to be called late enough in the DOS
;           extender initialization cycle that it can use other interrupt
;           mapping functions (like INT 21h).  It must be called in
;           PROTECTED MODE!
;           And, assumes interrupts are to be enabled.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  InitNetMapper

InitNetMapper   proc near

        pusha
        push    es

; Do an installation check before doing anything else

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP
        FSTI

        mov     ax,355Ch                ;make sure the Int 5Ch vector
        int     21h                     ;  really points somewhere
        assume  es:NOTHING

ifdef      NEC_98
        mov     ax,es

        test    fNHmode, 0FFh            ;N/Hmode no kiriwake
        jz      NetBios_Nmode

        cmp     ax,60h                  ;Hmode default(not install)
;coading no tameni toriaezu 60h wo ireteoku node debug no tokini
;60h no ataiwo Hmode youni change surukoto!!!!!

        jz      inm20
        jmp     NetBio_Install

NetBios_Nmode:
        cmp     ax,60h                  ;Nmode default(not install)
        jz      inm20
NetBio_Install:
endif   ;NEC_98
        mov     ax,es                   ;can't be installed if 0 vector
        or      ax,bx
        jz      inm20

        push    ds
        pop     es
        assume  es:DGROUP

        mov     cx,(size NCB_Struc)/2   ;build a dummy NCB with an invalid
        mov     di,offset rgbXfrBuf1    ;  7Fh (Install) command code
        mov     bx,di
        xor     ax,ax
        cld
        rep stosw

        mov     [bx].NCB_Command,Install        ;issue invalid request
        int     5Ch

        xor     bx,bx                   ;assume not installed
        cmp     al,RC_Invalid_Cmd       ;if it says invalid command, then
        jnz     inm20                   ;  it must be installed

        dec     bx                      ;bx !=0 means NetBIOS is installed

inm20:
        SwitchToProtectedMode
        FSTI

        or      bx,bx                   ;skip install if no NetBIOS
        jnz     inm20A                  ;net bios is there
        jmp     inm80                   ;no NetBios

inm20A:

; we need to allocate a block of memory in the low heap and copy some code
; down there which would handle the POST calls from the NetWork. It is
; necessary to have a piece in global memory do the POST handling because
; DOSX might have been swapped out by the Switcher when a POST request
; comes in.
;
; -----
; CAVEAT:
; This archaic piece of code was only necessary on the real DOSX running
; standard mode Windows 3.0. On NT, dosx is never switched out. So the
; relocation performed here could be just thrown away and replaced with a
; normal piece of RM code.
;
        mov     bx,(SIZE_OF_GLOBAL_NET_STUB_CODE+15) SHR 4
        mov     ax,100h                         ;allocate block
        push    ds
        FBOP    BOP_DPMI, Int31Call, FastBop

        jnc     inm20C                          ;allocation succeeded
        jmp     inm80                           ;fail the initialization

inm20C:
        xchg    ax,dx
        mov     [SegNetStubCode],dx             ;save it

; DX has a selector pointing to the start of the block. Copy the stub routine
; down into the block.

        push    es                              ;save
        mov     [SelNetStubCode],ax             ;save the selector value
        push    ds                              ;save
        mov     es,ax                           ;destination sel of the xfer
        push    cs
        pop     ds
        xor     di,di                           ;destination offset
        lea     si,NetBiosStubCode              ;source offset of xfer
        mov     cx,SIZE_OF_GLOBAL_NET_STUB_CODE ;size of the block
        cld
        rep     movsb                           ;copy the block down
        pop     ds                              ;restore our DS


; now copy the FAR address of the RMPostRtn into the stub code segment

        lea     di,FarAddrOfRMPostRtn           ;variable where address to be saved
        lea     ax,NetBiosStubCode              ;offset of the routine
        sub     di,ax                           ;DI has the offset in the stub
        mov     ax,segDXCode                    ;segment of real mode DosX
        mov     es:[di][2],ax                   ;save the segment
        lea     ax,RMPostRtn                    ;offset of the POST routine
        mov     es:[di][0],ax                   ;save the offset

; patch the address 'NBS_Patch_CalFarAddr' with the address in DI

        mov     si,NBS_Patch_CallFarAddr        ;address to patch
        mov     es:[si],di                      ;patch it.

; calculate the offset to the other flag bytes in the stub code area that
; we will have to access.

        lea     di,fStubDelayNetPosting         ;address when assembled
        lea     ax, NetBiosStubCode             ;address of start of routine
        sub     di,ax                           ;address after move
        mov     [AddrfStubDelayNetPosting],di   ;save it

; patch the address 'NBS_Patch_fsDelayNetPosting' with the value in DI

        mov     si,NBS_Patch_fsDelayNetPosting  ;address to patch
        mov     es:[si],di                      ;patch it.

        lea     di,fStubTermNetRequests         ;address when assembled
        sub     di,ax                           ;address after move
        mov     [AddrfStubTermNetRequest],di    ;save it

; patch the address 'NBS_Patch_fsTermNetRequests' with the value in DI

        mov     si,NBS_Patch_fsTermNetRequests  ;address to patch
        mov     es:[si],di                      ;patch it.
        pop     es

; The stub routine in global memory has now been put in place to handle POST
; calls. We now need to hook the INT 2AH and 5CH PM vectors to trap the network
; calls.

; The network seems to be installed, hook the INT 2Ah & 5Ch PM vectors

        mov     ax,352Ah        ;get/store old Int 2Ah vector
        int     21h
        assume  es:NOTHING

        mov     word ptr lpfnOldInt2A,bx
        mov     word ptr [lpfnOldInt2A+2],es

        mov     ax,355Ch        ;get/store old Int 5Ch vector
        int     21h

        mov     word ptr lpfnOldInt5C,bx
        mov     word ptr [lpfnOldInt5C+2],es

        push    ds
        pop     es

        push    cs
        pop     ds
        assume  ds:NOTHING,es:DGROUP

        mov     ax,252Ah                        ;set new Int 2Ah handler
        mov     dx,offset DXPMCODE:PMIntr2A
        int     21h

        mov     ax,255Ch                        ;set new Int 5Ch handler
        mov     dx,offset DXPMCODE:PMIntr5C
        int     21h

        push    es
        pop     ds
        assume  ds:DGROUP

; See if anybody wants to provide a different NetBIOS mapping table

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP

        FSTI                             ;don't need 'em disabled

        xor     cx,cx                   ;subf'n zero
        mov     es,cx                   ;preset address to copy to NULL
        mov     di,cx
        mov     ax,REPLACE_MAP_TABLE
            ; DOSX net extender API call to substitute alternate NETBIOS
            ; mapping table
        mov     bx,VNETBIOS_DEV_ID      ;VNETBIOS device ID
        int     2Fh
            ; ES:DI contains address of alternate mapping table or NULL

        mov     cx,es                   ;Q: valid table pointer ?
        jcxz    inm70                   ;N: NULL...keep current table

        ;Y: copy table pointed to by es:di to table area (simple replace)

        mov     ax,ds           ; string move source (int 2F provided) table
        mov     es,ax           ; in ds:si, and destination ApiMapTbl in the
        mov     ds,cx           ; data segment now in es:di
        mov     si,di
        mov     di,offset ApiMapTbl     ;ptr to table
        mov     cx,64                   ;copy over 128 byte table
        cld
        rep     movsw
        mov     ds,ax           ;recall data segment

inm70:
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        FSTI
        clc
        jmp     short inm90

inm80:
        stc                             ;tell caller we didn't install

inm90:
        pop     es
        popa

        ret

InitNetMapper   endp

;-----------------------------------------------------------------------------
; NetBiosStubCode
;
; DESCRIPTION   This routine is actually relocated to a block of Global Memory
;               obtained from the Switcher. It handles the POST calls from the
;               NETBIOS layer. If DosX has been swapped out, fStubDelayPosting
;               would be true and this routine would set a flag in the HCB
;               to imply that the POSTing must be done. If DosX is active, this
;               routine will call off to the RMPostRtn in DosX via a far call
;               pointer.
;
; ENTRY:
;    ES:BX      - HCB
;
; EXIT:
;    All registers preserved but for flags.
;
; USES:
;    Flags
;
; NOTE:
;    This routine will actually be copied to a global memory stub segment
;    and will execute from there. However, since the routine would be moved
;    while we are in protected mode, the routine is being assembled in the
;    protected mode code segment.
;-----------------------------------------------------------------------------
NetBiosStubCode proc far


        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

        FCLI                             ;just to be sure

; Don't post anything if in the process of terminating

;-----------------------------------------------------------------------------
; The following instruction will have to be patched after the move:
;
;       cmp     cs:[fStubTermNetRequests],1
;
; we will mark the place that has to be patched.
;-----------------------------------------------------------------------------

        db      2eh, 80h, 3eh           ;CS: CMP BYTE PTR

NBS_Patch_fsTermNetRequests equ $ - NetBiosStubCode

        dw      ?                       ;address to compare
        db      1                       ;value to comapare
;-----------------------------------------------------------------------------

        je      NBSC_post_done

; Check if posting should be delayed

;-----------------------------------------------------------------------------
; The following instruction will have to be patched after the move:
;
;       cmp     cs:[fStubDelayNetPosting],0;Q: delay postings ?
;
; we will mark the place that has to be patched.
;-----------------------------------------------------------------------------

        db      2eh, 80h, 3eh           ;CS: CMP BYTE PTR

NBS_Patch_fsDelayNetPosting equ $ - NetBiosStubCode

        dw      ?                       ;address to compare
        db      0                       ;value to comapare
;-----------------------------------------------------------------------------

        je      NBSC_post_no_delay      ;N: don't delay this posting

; we can do no posting. DosX has been swapped out. Set a flag in the HCB to
; imply that POSTing must be done later.

        or      byte ptr es:[bx.HCB_Flags],HCB_DELAY    ;Y: mark as delayed
        jmp     short NBSC_post_done

NBSC_post_no_delay:

;-----------------------------------------------------------------------------
; call off to RMPostRtn in DosX. We will have to patch the following
; instruction after the move.
;
;       call    cs:[FarAddrOfRMPostRtn] ;call routine in DosX proper
;
; we will mark the place to match
;-----------------------------------------------------------------------------

        db      2eh,0ffh,1eh            ;CALL CS: DWORD PTR

NBS_Patch_CallFarAddr equ $ - NetBiosStubCode

        dw      ?                       ;call far address
;------------------------------------------------------------------------------

NBSC_post_done:

        riret

NetBiosStubCode  endp
;----------------------------------------------------------------------------;
; allocate space for some of the variables that the Stub Code uses. These    ;
; will be filled in by PMODE code in the DosX.                               ;
;----------------------------------------------------------------------------;

fStubTermNetRequests    db      0               ;DosX is terminating
fStubDelayNetPosting    db      0               ;delay posting, DosX swapped
FarAddrOfRMPostRtn      dd      ?               ;address of the actual POST rtn

SIZE_OF_GLOBAL_NET_STUB_CODE equ $ - NetBiosStubCode
;-----------------------------------------------------------------------------;

DXPMCODE    ends

; -------------------------------------------------------
        subttl NetBIOS API Mapper Termination Routine
        page
; -------------------------------------------------------
;          NetBIOS API MAPPER TERMINATION ROUTINE
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

;   TermNetMapper --  This routine is called when the 286 DOS extender
;       is winding down so that any pending network requests from the
;       protected mode application can be canceled.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   ax,bx,cx,dx,si,di,es
;
;   Note:  This routine must be called in REAL MODE!

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  TermNetMapper

TermNetMapper   proc  near

; set a flag in the stub code to imply that DosX is terminating and no more
; POSTs to be done.

        mov     di,[SelNetStubCode]     ;selector for the stub area
        or      di,di                   ;is global heap in place ?
        jnz     @f                      ;yes.
        ret
@@:

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        push    es
        mov     es,di
        assume  es:nothing

; get the address of the flag byte fStubTermNetRequest after the block was
; relocated

        mov     di,[AddrfStubTermNetRequest]

; ES:DI has the flag byte address. Set the flag

        mov     byte ptr es:[di],1      ;set flag to delay posting
        pop     es
        assume  es:dgroup

        ; terminating the net driver interface...no more postings allowed

        FSTI

        mov     cx,size NCB_Struc / 2
        mov     si,offset Cancel_NCB    ;cancel control block buffer
        mov     di,si
        xor     ax,ax                   ;zero fill structure
        cld
        rep     stosw

        mov     ds:[si.NCB_Command],Cancel  ;Cancel command NCB

; We don't need to release the NCB/buffer(s) from the low heap because
; the entire low heap will soon be released.

; Search low heap list looking for copy of target NCB

        mov     cx,HCB_List
        mov     di,HCB_Header_Size      ;offset of NCB in low heap block

term_next:
        jcxz    term_done

        mov     ax,cx
        call    GetSegmentAddress
        add     dx,di
        adc     bx,0                    ;BX:DX = lma of low target NCB

        call    Lma2SegOff              ;BX:DX = normalized SEG:OFF

        dec     bx                      ;return the same slightly unnormalized
        add     dx,10h                  ;  SEG:OFF that was used initially

        mov     ds:[si.NCB_Buffer_Seg],bx   ; point to NCB to cancel
        mov     ds:[si.NCB_Buffer_Off],dx

        SwitchToRealMode                ;also disables ints for us
        assume  ds:DGROUP,es:DGROUP

        mov     bx,si                   ;ES:BX points to cancelling NCB

        pushf
        call    lpfnRmNetIsr            ;do the cancel call
        ; return code in AL

        SwitchToProtectedMode
        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

        FSTI
        mov     es,cx
        mov     cx,es:[di.HCB_Next]
        jmp     short term_next

term_done:

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP

        FSTI
        ret

TermNetMapper   endp

; -------------------------------------------------------

DXCODE  ends

; -------------------------------------------------------
        subttl NetBIOS API Int 2Ah Mapper Interrupt Hook
        page
; -------------------------------------------------------
;        NetBIOS API INT 2Ah MAPPER INTERRUPT HOOK
; -------------------------------------------------------

DXPMCODE    segment
        assume cs:DXPMCODE

; -------------------------------------------------------
;   PMIntr2A -- This routine traps Int 2Ah requests from a
;       protected mode application.  NetBIOS requests (ah =
;       1 or 4) are passed on to the Int 5Ch handler for
;       further processing.  Other requests are passed on
;       to the next Int 2Ah handler in the interrupt chain.
;
;   Input:  User regs at time of interrupt
;   Output: none
;   Errors: none
;   Uses:   none
;

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntr2A

PMIntr2A  proc  near

        cld                             ;cya...

        cmp     ah,1                    ;we only need to map the Int 2Ah
        jz      @f                      ;  ah = 1 & 4 services--if it's
        cmp     ah,4                    ;  not one of those, just pass it
        jz      @f                      ;  on down the chain...

        sub     sp,4                    ; build a stack frame
        push    bp
        mov     bp,sp
        push    ax
        push    ds
        mov     ds,selDgroupPM
        assume  ds:DGROUP
        mov     ax,word ptr [lpfnOldInt2A+2]    ; store previous INT 2A
        mov     word ptr [bp+4],ax              ; handler
        mov     ax,word ptr [lpfnOldInt2A]
        mov     word ptr [bp+2],ax
        pop     ds
        assume  ds:NOTHING
        pop     ax
        pop     bp                      ; SS:SP -> previous handler
                                        ;let someone else deal with it
        retf                            ;  (most likely PMIntrReflector)
@@:

if PM_NCB_HANDLING

;
; if this is NT then we have decided we are making a NetBIOS call (es:bx points
; to an NCB in protect-mode memory). INT 0x2A, ah=1 or ah=4 just ends up calling
; the 0x5C entry point; ah is returned as 1 or 0, depending on whether an error
; is returned from 0x5C or not
;

        push    dx
        mov     dl,2ah

else

        push    bx                      ;save caller's bx
        mov     bx,4*2Ah                ;indicate we came from int 2A handler

endif ; PM_NCB_HANDLING

        jmp     short DoNetRqst         ;int 2Ah/5Ch common code

PMIntr2A  endp


; -------------------------------------------------------
        subttl NetBIOS API Int 5Ch Mapper Interrupt Hook
        page
; -------------------------------------------------------
;        NetBIOS API INT 5Ch MAPPER INTERRUPT HOOK
; -------------------------------------------------------
;   PMIntr5C -- This routine maps Int 5Ch (and selected Int 2Ah)
;       NetBIOS requests between a protected mode application, and
;       the real mode interrupt handler.
;
;   Input:  User regs at time of interrupt
;   Output: regs as returned by interrupt handler
;   Errors:
;   Uses:   none
;

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntr5C

PMIntr5C  proc  near

if PM_NCB_HANDLING
;
; we no longer want to make the call through the real-mode handler, since all
; it does is make the BOP
;

        cld                             ; just in case
        push    dx
        mov     dl,5ch

DoNetRqst:

;
; Do a  sync/async NETBIOS presence check. Don't BOP for this simple case.
; Also don't do the async call because Delrina WinFax Pro hasn't initialized
; The post address in the NCB.
;
        cmp     byte ptr es:[bx],7fh    ; sync NETBIOS presence check
        je      skip_bop
        cmp     byte ptr es:[bx],0ffh   ; async NETBIOS presence check
        je      skip_bop
ifdef WOW_x86
.386p
        push    ds
        mov     ds,selDgroupPM

        assume  ds:DGROUP

        FBOP    BOP_REDIR, SVC_NETBIOS5C, FastBop
        pop     ds
.286p
else
        SVC     SVC_NETBIOS5C
endif ; WOW_x86

        cmp     dl,2ah
        jne     @f

;
; this was a 0x2A call. Return ah = 0 if NetBIOS returned al = 0, else return
; ah = 1
;

        sub     ah,ah
        or      al,al
        jz      @f
        inc     ah
@@:     pop     dx
        riret

skip_bop:
        mov     al,3                    ; INVALID COMMAND error
        mov     es:[bx].ncb_retcode,al  ; returned in NCB_RETCODE && al
        mov     es:[bx].ncb_cmd_cplt,al ; and NCB_CMD_CPLT
        pop     dx
        riret


else

        cld                             ;cya...

        push    bx                      ;save caller's bx
        mov     bx,4*5Ch                ;indicate we came from int 5C

DoNetRqst       label   near            ;start of int 2Ah/5Ch common code

        push    ax                      ;move the address of the
        push    ds                      ;  proper real mode interrupt
        mov     ds,selDgroupPM          ;  handler (2A or 5C) to global var
        assume  ds:DGROUP
        push    es

        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        mov     ax,word ptr es:[bx]
        mov     word ptr lpfnRmNetIsr,ax
        mov     ax,word ptr es:[bx+2]
        mov     word ptr [lpfnRmNetIsr+2],ax

        pop     es
        pop     ds                      ;restore caller's environment
        assume  ds:NOTHING
        pop     ax
        pop     bx

        call    EnterIntHandler         ;build an interrupt stack frame
        assume  ds:DGROUP,es:NOTHING

        FSTI             ;-----------------------------------------------

; Allocate space in the low heap for the HCB/NCB and maybe a buffer

        xor     dx,dx
        mov     cx,HCB_SIZE             ;DX:CX = # bytes low heap required

        call    GetEntryExitFlags       ;AX=Entry flags / ES:BX -> PM NCB

        test    al,BUFF_IN+BUFF_OUT+BUFF_CHAIN  ;need to allocate a low buffer?
        jz      i5c_alloc

;
; RLF 06/09/93
;
; from the command type, we think we have a buffer address and size. If either
; of these is 0, then we actually don't have a buffer; skip it
;

        mov     ah,al                   ; set default no buffer
        and     al,not (BUFF_IN or BUFF_OUT)
        mov     dx,es:[bx.NCB_Buffer_Off]
        or      dx,es:[bx.NCB_Buffer_Seg]
        jz      i5c_alloc
        mov     dx,es:[bx.NCB_Length]
        or      dx,dx
        jz      i5c_alloc
        xor     dx,dx                   ; restore dx to 0
        mov     al,ah                   ; restore buffer flags

        add     cx,es:[bx.NCB_Length]   ;if so, add in it's length
        adc     dx,0
        add     cx,1fh                  ;allow space to align buffer
        adc     dx,0                    ;  on a paragraph boundry
        and     cx,not 0fh

        test    al,BUFF_CHAIN           ;a 2nd weird-o buffer?
        jz      i5c_alloc

        add     cx,word ptr es:[bx.NCB_CallName]    ;yes, add in it's len also
        adc     dx,0
        add     cx,1fh                  ;allow space to align buffer
        adc     dx,0                    ;  on a paragraph boundry
        and     cx,not 0fh

i5c_alloc:
        push    ax                      ;save entry/exit flags

        FCLI             ;treat allocate as critical section ------------

        push    bx
        mov     bx,cx                           ;loword length
        mov     ax,dx                           ;hiword length

        add     bx,15                           ;round up
        shr     bx,4                            ;discard last 4 bits
        and     ax,0fh                          ;discarded bits were 0
        shl     al,4                            ;get it in MS nibble
        or      bh,al                           ;BX has the size in paragraphs

        mov     ax,100h                         ;allocate block
        push    ds
        FBOP    BOP_DPMI, Int31Call, FastBop
        pop     bx
        jnc     @f                      ;  HCB/NCB and maybe buffer

        Debug_Out "Low heap allocation failed!"

        pop     ax                      ;clear stack

        mov     byte ptr [bp].intUserAX,RC_Resources
        mov     es:[bx.NCB_RetCode],RC_Resources
        mov     es:[bx.NCB_Cmd_Cplt],RC_Resources
        jmp     i5c_done
@@:
        mov     ax,dx                   ;get the selector

; Copy the PM NCB to the low heap and add our extra HCB fields

        mov     es,ax
        xor     di,di                   ;es:di -> low heap block

        cld
        stosw                           ;HCB_Handle
        mov     ax,bx
        stosw                           ;HCB_PM_NCB_Off
        mov     ax,[bp].pmUserES
        stosw                           ;HCB_PM_NCB_Seg
        mov     ax,HCB_List
        stosw                           ;HCB_Next
        xor     ax,ax
        stosw                           ;HCB_Flags = 0

        mov     HCB_List,es             ;link HCB to head of list

        FSTI             ;-----------------------------------------------

        push    ds
        mov     ds,[bp].pmUserES
        assume  ds:NOTHING

        errnz   <size NCB_Struc and 1>  ;if odd # bytes, can't just movsw

        mov     si,bx                   ;ES:DI->low NCB, DS:SI->PM NCB
        mov     cx,size NCB_Struc / 2
        rep     movsw

        pop     ds
        assume  ds:DGROUP


; Update the interrupt handler's registers to point to the low NCB

        mov     ax,es
        call    GetSegmentAddress
        add     dx,HCB_Header_Size
        adc     bx,0                    ;BX:DX = lma of low NCB

        pop     ax                      ;refresh entry flags
        push    ax

        push    bx                      ;save lma of NCB
        push    dx

        call    Lma2SegOff              ;BX:DX = normalized SEG:OFF of low NCB

        dec     bx                      ;we want to do a negative offset on the
        add     dx,10h                  ;  NCB segment, so un-normalize it some

        mov     [bp].intUserES,bx       ;point int handler's ES:BX to low NCB
        mov     [bp].intUserBX,dx


; If this is a cancel request, find the target NCB in the low heap

        test    al,BUFF_CANCEL          ;cancel request?
        jz      i5c_not_cancel

        mov     di,HCB_Header_Size      ;ES:DI -> low heap Cancel NCB

        FCLI             ;don't want list changing while looking --------

        call    FindTargetNCB           ;BX:DX = SEG:OFF of target NCB

        FSTI             ;-----------------------------------------------

if DEBUG   ;------------------------------------------------------------
        jnc     @f
        Debug_Out "FindTargetNCB didn't!"
@@:
endif   ;DEBUG  --------------------------------------------------------

        jc      @f

        mov     es:[di.NCB_Buffer_Off],dx       ;point cancel NCB to low
        mov     es:[di.NCB_Buffer_Seg],bx       ;  heap target NCB
@@:

i5c_not_cancel:

        pop     dx                      ;restore lma of NCB
        pop     bx


; If necessary, update NCB buffer pointer(s) and copy buffer(s) to low heap

        pop     ax                      ;recover entry flags

        test    al,BUFF_IN+BUFF_OUT+BUFF_CHAIN  ;a buffer to point to?
        jnz     @f
        jmp     i5c_no_buf_in
@@:

        add     dx,size NCB_Struc + 0fh ;get lma of buffer, rounded up
        adc     bx,0                    ;  to the next higher paragraph
        and     dx,not 0fh

        push    ds
        mov     ds,[bp].pmUserES
        mov     si,[bp].pmUserBX        ;DS:SI -> PM NCB
        assume  ds:NOTHING

        push    bx
        push    dx

        call    Lma2SegOff              ;BX:DX = SEG:OFF of low buffer

        mov     di,HCB_Header_Size      ;ES:DI -> low NCB
        mov     es:[di.NCB_Buffer_Off],dx
        mov     es:[di.NCB_Buffer_Seg],bx

        pop     dx
        pop     bx

        test    al,BUFF_IN+BUFF_CHAIN   ;actually need to copy buffer?
        jz      i5c_buf_in_done

        mov     cx,ds:[si.NCB_Length]                   ;CX = buffer len
        lds     si,dword ptr ds:[si.NCB_Buffer_Off]     ;DS:SI -> buffer

        push    ax
        xor     ax,ax
        call    CopyBuffer              ;copies DS:SI to lma BX:DX len CX
        pop     ax

        test    al,BUFF_CHAIN
        jz      i5c_buf_in_done

        add     dx,es:[di.NCB_Length]   ;BX:DX = lma of 2nd low heap buffer
        adc     bx,0
        add     dx,0fh
        adc     bx,0
        and     dx,not 0fh

        push    bx                      ;update low heap NCB with SEG:OFF
        push    dx                      ;  of 2nd buffer

        call    Lma2SegOff

        mov     word ptr es:[di.NCB_CallName+2],dx      ;2nd buffer loc stored
        mov     word ptr es:[di.NCB_CallName+4],bx      ;  at callname + 2

        pop     dx
        pop     bx

        mov     ds,[bp].pmUserES
        mov     si,[bp].pmUserBX        ;DS:SI -> PM NCB

        mov     cx,word ptr ds:[si.NCB_CallName]        ;CX = buffer len
        lds     si,dword ptr ds:[si.NCB_CallName+2]     ;DS:SI -> buffer

        xor     ax,ax
        call    CopyBuffer              ;copies DS:SI to lma BX:DX len CX


i5c_buf_in_done:

        pop     ds
        assume  ds:DGROUP

i5c_no_buf_in:

; Switch to real mode, and load the mapped real mode registers.

        SwitchToRealMode                ;also disables ints
        assume  ss:DGROUP

; --------------- START OF REAL MODE CODE ------------------------------

        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING
        popa                            ;restore all the other registers

; If this is a NoWait command, hook the mapped NCB to point to our post
; routine.  At this time ES:BX -> mapped NCB

        test    byte ptr es:[bx.NCB_Command],NoWait
        jz      @f

        push    ax                      ;save

;
; RLF 06/09/93
;
; although this is an async command, there may be no post address (app just
; polls return code until it goes non-0xff). In this case, don't set up our
; asynchronous notification routine
;

        mov     ax,es:[bx.NCB_Post_Off]
        or      ax,es:[bx.NCB_Post_Seg]
        jz      no_post_routine

        assume  ss:DGROUP               ;ss has DOSX's data seg
        mov     ax,[SegNetStubCode]     ;get segment of stub code

; the address of the stub code that will handle the POST is AX:0. Save this
; in the HCB.

        mov     word ptr es:[bx.NCB_Post_Off],0
        mov     word ptr es:[bx.NCB_Post_Seg],ax

no_post_routine:
        pop     ax                      ;restore
@@:
        or      byte ptr es:[bx.HCB_FLAGS],HCB_ISSUED

; Invoke the appropriate real mode interrupt handler (2Ah or 5Ch),
; reestablish our stack frame with the handler's returned registers,
; and then back to protected mode

        call    lpfnRmNetIsr            ;exectue real mode interrupt handler
        pushf
        FCLI
        pusha
        push    ds
        push    es

        mov     bp,sp                   ;restore stack frame pointer

        mov     ax,es:[bx.HCB_Handle]   ;recover selector to current NCB/buff
        push    ax

        SwitchToProtectedMode
        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

; --------------- START OF PROTECTED MODE CODE -------------------------

; With some network drivers, and some NoWait commands, the operation may
; get 'posted' even before the driver IRETs from the issue call.  If this
; has happened, the HCB_POSTED flag will be set.  In this case, the caller's
; NCB and (possibly) buffer has already been updated, so we just discard
; the low heap block and exit.  If the operation hasn't been posted already,
; we copy back the updated NCB info, and maybe a buffer.  Note that interrupts
; are disabled, so we don't get 'posted' half way through this operation--
; that would be bad.

        pop     ax                      ;handle (selector) of low heap block
        mov     es,ax
        mov     di,HCB_Header_Size      ;es:di -> low heap NCB

        test    byte ptr es:[di.HCB_Flags],HCB_POSTED   ;already posted?
        jnz     i5c_release                             ;  yes, just discard

        and     byte ptr es:[di.HCB_Flags],not HCB_ISSUED   ;so post rtn knows
                                                            ;we updated already

        push    ax                      ;save handle for later

        call    UpdateNCB               ;update the caller's NCB

        call    GetEntryExitFlags       ;AX=Exit Flags / ES:BX->PM NCB

        test    es:[bx.NCB_Command],NoWait      ;don't copy buff now if NoWait
        jnz     i5c_no_buf_out

        test    al,BUFF_OUT
        jz      i5c_no_buf_out

;
; RLF 06/09/93
;
; although the flags for this command say we have an output buffer, we may
; not have one - address or length is 0; check it out
;

        mov     ax,es:[bx.NCB_Buffer_Off]
        or      ax,es:[bx.NCB_Buffer_Seg]
        jz      i5c_no_buf_out
        mov     ax,es:[bx.NCB_Length]
        or      ax,ax
        jz      i5c_no_buf_out

        pop     ax                      ;handle to low block back
        push    ax

        call    CopyBufferOut           ;copy low heap buffer to pm app buffer

i5c_no_buf_out:


; If this was a Wait operation (or NoWait that failed), we are finished with
; the low heap block and can release it now.

        pop     ax                      ;recover handle to low heap block

        test    es:[bx.NCB_Command],NoWait      ;if Wait, go release now
        jz      i5c_release

        cmp     es:[bx.NCB_RetCode],RC_Pending
        jz      i5c_done

; Most NetBIOS implementations seem to (correctly) set the RetCode to
; RC_Pending on NoWait requests.  However, it seems that some Novell
; NetBIOS implementations can return RetCode == 00 but Cmd_Cplt ==
; RC_Pending (FFh).  So, if it is a NoWait request, and RetCode isn't
; Pending, also check the Cmd_Cplt code.

        cmp     es:[bx.NCB_Cmd_Cplt],RC_Pending
        jz      i5c_done

        Debug_Out "NoWait cmd with non Pending retcode!"


i5c_release:

        push    ds                      ;make sure es != low heap block sel
        pop     es                      ;  (else FreeLowBlock will GP fault)

        call    DeLink                  ;DeLink HCB/NCB/Buffers from lnk list

        push    dx
        mov     dx,ax                   ;selector to free
        mov     ax,101h                 ;free block
        push    ds
        FBOP    BOP_DPMI, Int31Call, FastBop
        pop     dx

; Finished! (at least for now)  Restore caller's regs/stack and return

i5c_done:
        mov     ax,[bp].pmUserBX        ;restore possibly modified BX to
        mov     [bp].intUserBX,ax       ;  PM NCB offset

        call    LeaveIntHandler

        riret

endif ; if PM_NCB_HANDLING

PMIntr5C  endp

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl NetBIOS API Mapper Post Routine
        page
; -------------------------------------------------------
;             NetBIOS API MAPPER POST ROUTINE
; -------------------------------------------------------

;*******************************************************************************
;*
;*  The code from here on down is only used if we are switching between real
;*  and protect mode when making NetBIOS requests. It is ifdef'd out for WOW
;*  because we now BOP the NetBIOS requests without switching modes
;*
;******************************************************************************/

;ife PM_NCB_HANDLING

DXCODE  segment
        assume  cs:DXCODE

; -------------------------------------------------------
;   RMPostRtn -- This REAL MODE routine is invoked by the network
;       software when a NoWait NetBIOS command completes.  This
;       routine must update the applications copy of the NCB,
;       possibly copy a buffer of data to the application, and
;       possibly invoke the application's own post routine.
;
;       Note, this will now be called when it is OK to POST the request
;       back to the application. The Stub Code in global mrmory makes
;       sure that this is OK to do.
;
;   Input:
;   Output:
;   Errors:
;   Uses:

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  RMPostRtn

RMPostRtn  proc far

        FCLI                             ;just to be sure
        cld                             ;cya...

        push    ax
        push    bx
        push    es
        push    ds                      ; NBP assumes ds saved, greaseballs

        mov     ds,selDgroup
        assume  ds:DGROUP


; Allocate a new stack frame, and then switch to the reflector stack
; frame.

        mov     regUserSP,sp
        mov     regUSerSS,ss
        mov     ss,selDgroup
        mov     sp,pbReflStack

        sub     pbReflStack,CB_STKFRAME ;adjust pointer to next stack frame

        FIX_STACK
        push    regUserSS               ;save current stack loc on our stack
        push    regUserSP               ;  so we can restore it later

        push    es:[bx.HCB_Handle]      ;selector to low heap block

; We are now running on our own stack, so we can switch into protected mode.

        SwitchToProtectedMode           ;destroys ax

; --------------- START OF PROTECTED MODE CODE -------------------------

        pop     ax                      ;ax = selector to low heap block

        call    NetBiosPostRoutine      ;do the actual posting

        pop     regUserSP               ;recover previous stack location
        pop     regUserSS

        SwitchToRealMode                ; Switch back to real mode.

; --------------- START OF REAL MODE CODE ------------------------------

; Switch back to the original stack, deallocate the interrupt stack frame,
; and return to the network software

        CHECK_STACK
        mov     ss,regUserSS
        mov     sp,regUserSP
        add     pbReflStack,CB_STKFRAME

        pop     ds                      ; give ds back to NBP/XNS
        pop     es
        pop     bx
        pop     ax
        ret

RMPostRtn  endp

DXCODE  ends

; -------------------------------------------------------
        subttl NetBIOS API Mapper Utility Routines
        page
; -------------------------------------------------------
;          NetBIOS API MAPPER UTILITY ROUTINES
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   NetBiosPostRoutine -- local routine
;       This PROTECT MODE routine is called when the network
;       software completes a NoWait NetBIOS command.  This
;       routine must update the applications copy of the NCB,
;       possibly copy a buffer of data to the application, and
;       possibly invoke the application's own post routine.
;
;   Input:  ax --> selector to low heap block
;   Output:
;   Errors:
;   Uses: ax,bx,es

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  NetBiosPostRoutine

NetBiosPostRoutine proc near

IFNDEF WOW_x86
        pusha
else
.386p
        pushad
        push    fs
        push    gs
.286p
endif

; Update the protected mode copy of the NCB and copy buffer if required

        push    ax                      ;handle (selector) of low heap block

        call    UpdateNCB               ;always update the caller's NCB

        mov     es,ax
        mov     bx,HCB_Header_Size                  ;ES:BX -> low heap NCB
        les     bx,dword ptr es:[bx.HCB_PM_NCB_Off] ;ES:BX -> PM NCB

        call    GetExitFlags2           ;AX=Exit Flags

        test    al,BUFF_OUT
        jz      postsub_no_buf

;
; RLF 06/09/93
;
; once more unto the breach dear friends: although we think this command has
; an output buffer, the app may think otherwise; let's check...
;

        mov     ax,es:[bx.NCB_Buffer_Off]
        or      ax,es:[bx.NCB_Buffer_Seg]
        jz      postsub_no_buf
        mov     ax,es:[bx.NCB_Length]
        or      ax,ax
        jz      postsub_no_buf

        pop     ax                      ;handle to low block back
        push    ax

        call    CopyBufferOut           ;copy low heap buffer to pm app buffer

postsub_no_buf:

; Release the low heap space, unless the HCB_ISSUED flag is set (meaning
; that the net driver called us before returning from the initial Int 5Ch).
; In that case, the low heap block will be released by the Int 5Ch mapper.

        pop     ax                      ;recover handle to low heap block
        push    ax

        push    es
        mov     es,ax
        mov     di,HCB_Header_Size
        or      byte ptr es:[di.HCB_Flags],HCB_POSTED   ;mark as posted
        pop     es

; Invoke the user's PM post routine, if there is one - AL=retcode, ES:BX->NCB

        mov     ax,es:[bx.NCB_Post_Off] ;did user specify a post routine?
        or      ax,es:[bx.NCB_Post_Seg]
        jnz     @f
        jmp     postsub_done
@@:

        mov     [NBPSp],sp
        rpushf                          ;build iret frame for user's
        push    cs                      ; routine to return to us
        push    offset postsub_ret

        mov     al,es:[bx.NCB_RetCode]  ;pass ret code in al

        push    es:[bx.NCB_Post_Seg]    ;invoke the user's post routine
        push    es:[bx.NCB_Post_Off]

        retf

; PM app's post routine returns here when finished

postsub_ret:
        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax
        mov     sp,[NBPSp]

postsub_done:
        pop     ax
        mov     es,ax
        test    byte ptr es:[di.HCB_Flags],HCB_ISSUED   ;still in Int 5C code?
        jnz     postsub_no_release                      ;  yes, don't release

        push    ds                      ;make sure es != low heap block sel
        pop     es                      ;  (else FreeLowBlock will GP fault)

        call    DeLink                  ;DeLink HCB/NCB/Buffers from lnk list

        push    dx
        mov     dx,ax                   ;selector to free
        mov     ax,101h                 ;free block
        push    ds
        FBOP    BOP_DPMI, Int31Call, FastBop
        pop     dx
postsub_no_release:

IFNDEF WOW_x86
        popa
ELSE
.386p
        pop     gs
        pop     fs
        popad
.286p
ENDIF
        ret

NetBiosPostRoutine endp

; -------------------------------------------------------
;   DelayNetPostings -- This function is called when NetBIOS completions
;       are to be delayed.  We simply set a flag that causes the async
;       post routine not to post to the application.
;
;   Input: none
;   Output: none
;   Errors: none
;   Uses: none

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  DelayNetPosting

DelayNetPosting proc near

; Make sure posting is delayed. We need to set a flag in the StubCode area.

        push    es                      ;save
        push    di
        mov     di,[SelNetStubCode]     ;selector for the stub area
        or      di,di                   ;did we copy to global memory ?
        jz      DelayNetPostingRet      ;no, nothing to do.
        mov     es,di

; get the address of the flag byte fStubDelayNetPosting after the block was
; relocated

        mov     di,[AddrfStubDelayNetPosting]

; ES:DI has the flag byte address. Set the flag

        mov     byte ptr es:[di],1      ;set flag to delay posting

DelayNetPostingRet:

        pop     di
        pop     es                      ;restore
        ret

DelayNetPosting endp


; -------------------------------------------------------
;   ResumeNetPostings -- This function is called when completed NetBIOS
;       postings can be resumed to the application.  We traverse the
;       list of NetBIOS requests, and 'post' the application on any that
;       completed while posting were delayed.
;
;   Input: none
;   Output: none
;   Errors: none
;   Uses: none

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  ResumeNetPosting

ResumeNetPosting proc near

        push    es
        push    di
        push    bx                      ; used by NetBiosPostRoutine
        push    ax

; set a flag in the StubCode area to imply that POSTing need not be delayed.

        mov     di,[SelNetStubCode]     ;selector for the stub area
        or      di,di                   ;global heap in place ?
        jnz     dummy1
        jmp     ResumeNetPostingRet     ;no.
dummy1:
        mov     es,di

; get the address of the flag byte fStubDelayNetPosting after the block was
; relocated

        mov     di,[AddrfStubDelayNetPosting]

; ES:DI has the flag byte address. ReSet the flag

        mov     byte ptr es:[di],0      ;reset the flag


        FCLI                             ;protect access to linked list

        mov     cx,HCB_List
        mov     di,HCB_Header_Size      ;offset of NCB in low heap block

resume_next:
        jcxz    resume_done

        mov     es,cx
        mov     cx,es:[di.HCB_Next]

        test    byte ptr es:[di.HCB_Flags],HCB_DELAY  ;Has this one completed?
        jz      resume_next                           ;  no, skip it

        ;Y: this packet was delayed...post it NOW !

        mov     ax,es:[di.HCB_Handle]   ;selector to low heap block

        FSTI

        call    NetBiosPostRoutine      ;post the NCB finally

        FCLI

        ; *** modification warning ***
        ; note: block has just been de-linked from list, so we MUST
        ; get the pointer to the next block before NetBiosPostRoutine
        ; is called (which calls DeLink)!

        jmp     short resume_next

resume_done:

        FSTI


ResumeNetPostingRet:

        pop     ax
        pop     bx
        pop     di
        pop     es
        ret

ResumeNetPosting endp


; ------------------------------------------------------
;   CopyBufferOut -- This routine copies a buffer from the low heap
;       block up to the PM app's buffer area.
;
;   Input:  AX    =  Selector to low heap block
;           ES:BX -> PM NCB
;   Output: none
;   Errors: none
;   Uses:   none

        assume  ds:DGROUP,es:NOTHING
        public  CopyBufferOut

CopyBufferOut   proc    near

        pusha

        mov     cx,es:[bx.NCB_Buffer_Seg]
        or      cx,es:[bx.NCB_Buffer_Off]
        jz      CBO_Buffer_Is_Null

        push    ds

        mov     di,bx                   ;ES:DI -> PM NCB
        call    GetSegmentAddress       ;BX:DX = lma of low heap block

        lds     si,dword ptr es:[di.NCB_Buffer_Off]     ;DS:SI -> PM buffer
        assume  ds:NOTHING

        add     dx,size NCB_Struc + HCB_Header_Size + 0fh
        adc     bx,0
        and     dx,not 0fh              ;BX:DX = lma of low heap buffer

        mov     cx,es:[di.NCB_Length]   ;CX = buffer length

        mov     al,1
        call    CopyBuffer              ;copies from lma BX:DX to DS:SI, len CX

        pop     ds
        assume  ds:DGROUP

CBO_Buffer_Is_Null:
        popa

        ret

CopyBufferOut   endp


; ------------------------------------------------------
;   CopyBuffer -- This routine copies a buffer of length CX
;       from DS:SI to the lma in BX:DX _or_ from the lma in
;       BX:DX to DS:SI.
;
;   Input:  AX    = direction flag, Z = from DS:SI -> lma,
;                                  NZ = from lma   -> DS:SI
;           BX:DX = lma of source or dest
;           CX    = length in bytes
;           DS:SI = pointer to source or dest
;   Output: none
;   Errors: none
;   Uses:   none

        assume  ds:NOTHING,es:NOTHING
        public  CopyBuffer

CopyBuffer      proc    near

        pusha
        push    ds
        push    es


        rpushf
        FCLI

; Setup a selector/descriptor for the linear memory address

        push    ax                      ;save direction flag

        push    ds
        mov     ds,selDgroupPM          ;temp dgroup addressability
        assume  ds:DGROUP

        mov     ax,SEL_NBSCRATCH or STD_RING ;our scratch selector to use
        dec     cx                      ;length to limit


        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>

        pop     ds
        assume  ds:NOTHING

        inc     cx                      ;back to length

; If necessary, adjust the length so we don't fault due by overrunning the
; DS segment

        mov     bx,ds                   ;get limit for DS segment
        lsl     bx,bx
        sub     bx,si                   ;less the DS offset
        inc     bx                      ;  (limit is len - 1)
        cmp     bx,cx                   ;at least CX bytes left in segment?
        jae     @f
        mov     cx,bx                   ;  no, only do # remaining
@@:

; Copy the buffer

        xor     di,di                   ;AX:DI is now SEL:OFF to lma

        pop     bx                      ;recover direction flag
        or      bx,bx
        jnz     @f

        mov     es,ax                   ;from DS:SI -> AX:DI, almost ready
        jmp     short cb_copy
@@:
        xchg    si,di                   ;from AX:DI -> DS:SI, adjust
        push    ds                      ;  regs for movs instruction
        pop     es
        mov     ds,ax

cb_copy:
        cld
        shr     cx,1                    ;byte count to words, low bit to CY
        rep movsw
        jnc     @f
        movsb                           ;get any odd byte
@@:
        npopf

        pop     es
        pop     ds
        popa

        ret

CopyBuffer      endp


; ------------------------------------------------------
;   DeLink -- This routine will unlink a HCB/NCB/Buffer low heap
;       block from the HCB_List linked list.
;
;   Input:  AX = selector to block to unlink
;   Output: block unlinked
;   Uses:   none

        assume  ds:DGROUP,es:NOTHING
        public  DeLink

DeLink  proc    near

        push    bx
        push    cx
        push    es

        mov     bx,HCB_Header_Size

        cmp     ax,HCB_List             ;special case likely condition
        jnz     ul_search

        mov     es,ax                   ;ES:BX -> block to unlink

        mov     cx,es:[bx.HCB_Next]     ;block is first in linked list
        mov     HCB_List,cx
        jmp     short ul_done

ul_search:
        mov     es,HCB_List             ;ES:BX -> first block in list

ul_loop:
        mov     cx,es:[bx.HCB_Next]     ;is this just before the block?
        cmp     ax,cx
        jz      ul_got_it

        mov     es,cx                   ;  no, try the next one
        jmp     short ul_loop

ul_got_it:
        push    es                      ;okay, cut the selected block
        mov     es,cx                   ;  out of the linked list
        mov     cx,es:[bx.HCB_Next]
        pop     es
        mov     es:[bx.HCB_Next],cx

ul_done:
        pop     es
        pop     cx
        pop     bx

        ret

DeLink  endp


; ------------------------------------------------------
;   FindTargetNCB -- This routine searches the low memory heap
;       to locate an NCB pointed to by another user PM NCB.
;
;   Input:  ES:DI -> Cancel NCB pointing to PM target NCB
;   Output: BX:DX =  RM SEG:OFF of target NCB in low heap
;   Error:  CY if target NCB can't be found
;   Uses:   none

        assume  ds:DGROUP,es:NOTHING
        public  FindTargetNCB

FindTargetNCB   proc    near

        push    ax
        push    cx
        push    di
        push    es

        mov     bx,es:[di.NCB_Buffer_Seg]       ;get selector:offset of PM
        mov     dx,es:[di.NCB_Buffer_Off]       ;  target NCB to cancel


; Search low heap list looking for copy of target NCB

        mov     cx,HCB_List
        mov     di,HCB_Header_Size      ;offset of NCB in low heap block

ft_next:
        jcxz    ft_err

        mov     es,cx                   ;ES:DI -> first/next HCB/NCB in list

        cmp     bx,es:[di.HCB_PM_NCB_Seg]       ;is this the one?
        jnz     ft_not_it
        cmp     dx,es:[di.HCB_PM_NCB_Off]
        jz      ft_got_it

ft_not_it:                                      ;  no, get ptr to next one
        mov     cx,es:[di.HCB_Next]
        jmp     short ft_next

ft_got_it:

; ES:DI now points at the low heap copy of the target NCB, convert to SEG:OFF

        mov     ax,es
        call    GetSegmentAddress
        add     dx,di
        adc     bx,0                    ;BX:DX = lma of low target NCB

        call    Lma2SegOff              ;BX:DX = normalized SEG:OFF

        dec     bx                      ;return the same slightly unnormalized
        add     dx,10h                  ;  SEG:OFF that was used initially

        clc                             ;found it!
        jmp     short ft_done

ft_err: stc                             ;couldn't find the target ?!

ft_done:
        pop     es
        pop     di
        pop     cx
        pop     ax

        ret

FindTargetNCB   endp


;--------------------------------------------------------
;   GetEntryExitFlags -- This routine looks up the entry/exit mapping
;       flags for the current NetBIOS command.
;
;   Input:  user regs on stack frame
;   Output: AX = flags
;           ES:BX -> caller's PM NCB
;   Errors: none
;   Uses:

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  GetEntryExitFlags

GetEntryExitFlags  proc near

        mov     es,[bp].pmUserES        ;point ES:BX to pm app's NCB
        mov     bx,[bp].pmUserBX        ;  and get command code

GetExitFlags2   label   near

        push    di

        mov     al,es:[bx.NCB_Command]
        and     al,7Fh
        cbw

        mov     di,ax                   ;map NCB command code to API
        mov     al,ApiMapTbl[di]        ;  mapping code via ApiMapTbl

        shr     ax,2                    ;use map code to select entry/exit
        mov     di,ax                   ;  flags via EntryExitCode
        mov     al,EntryExitFlags[di]

        pop     di
        ret

GetEntryExitFlags  endp


; ------------------------------------------------------
;   UpdateNCB -- This routine updates the user's PM NCB copy from the
;       low heap real mode copy.
;
;   Input:  AX = selector pointing to low heap HCB/NCB
;   Output: User's PM NCB updated
;   Errors: none
;   Uses:   none

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  UpdateNCB

UpdateNCB       proc    near

        push    ax
        push    cx
        push    si
        push    di
        push    ds
        push    es

        mov     ds,ax
        mov     si,HCB_Header_Size      ;DS:SI -> low heap NCB

        les     di,dword ptr [si.HCB_PM_NCB_Off]  ;ES:DI -> protect mode NCB

        mov     al,[si.NCB_Command]     ;want to check the command code later
        and     al,not NoWait

        cld
        movsw
        movsw                           ;copy command, retcode, LSN, Num

        add     si,4                    ;skip the buffer pointer
        add     di,4

        movsw                           ;move the length

        mov     cx,34 / 2               ;len of callname, name, rto, sto (words)

        cmp     al,ChainSend            ;funkey chain send command?
        jnz     @f

        add     si,16                   ;  yes, skip callname
        add     di,16
        sub     cx,16 / 2
@@:
        rep movsw                       ;move name, rto, sto, maybe callname

        add     si,4                    ;skip the post address
        add     di,4

        mov     cx,16 / 2               ;move the rest
        rep movsw

        pop     es
        pop     ds
        pop     di
        pop     si
        pop     cx
        pop     ax

        ret

UpdateNCB       endp

; -------------------------------------------------------

DXPMCODE    ends

;endif   ; ife PM_NCB_HANDLING

DXDATA  segment

my_sp   dw      ?

DXDATA  ends

DXPMCODE segment
        assume  cs:DXPMCODE

;*******************************************************************************
;*
;*  HandleNetbiosAnr
;*
;*      Called when a simulated h/w interrupt for net callback functions occurs.
;*      Checks if the call is a PM netbios ANR. If it is, we get the NCB
;*      information and call the PM post routine
;*
;*  ENTRY       Nothing
;*
;*  EXIT        Nothing
;*
;*  RETURNS     Nothing
;*
;*  ASSUMES     Nothing
;*
;******************************************************************************/

        public HandleNetbiosAnr
HandleNetbiosAnr proc

        assume  cs:DXPMCODE
        assume  ds:DGROUP
        assume  es:nothing
        assume  ss:nothing

;
; perform a BOP to discover if this is a protect mode netbios ANR. If it is then
; es and bx will point to the NCB
;

        push    ds
        push    SEL_DXDATA OR STD_RING
        pop     ds

ifdef WOW_x86
.386p
        FBOP    BOP_REDIR, SVC_NETBIOSCHECK, FastBop
.286p
else
        SVC     SVC_NETBIOSCHECK
endif ; WOW_x86

        jnz     @f
        jmp     chain_previous_int      ; not PM Netbios ANR

@@:

;
; this is a PM Netbios ANR. Save state and call the post routine. There MUST be
; a post routine if we're here
;

IFNDEF WOW_x86
        pusha
ELSE
.386p
        pushad                          ; save all 32 bits
        push    fs
        push    gs
.286p
ENDIF
        push    es

ifdef WOW_x86
.386p
        FBOP    BOP_REDIR, SVC_NETBIOS5CINTERRUPT, FastBop
.286p
else
        SVC     SVC_NETBIOS5CINTERRUPT
endif ; WOW_x86

;
; save the stack pointer - apparently some apps will RETF, not IRET from the
; ANR. NB - this ISR cannot be re-entered since we only have the one previous
; stack pointer saved. This should be okay as long as the EOI is issued at the
; end of the ISR
;

        mov     my_sp,sp

;
; perform a fake interrupt to the PM post routine. ES:BX point at the NCB, AL is
; the return code. Post routine will IRET back (supposedly)
;

        mov     al,es:[bx.NCB_RetCode]  ; pass ret code in al
        pushf
        call    dword ptr es:[bx.NCB_Post_Off]

;
; restore our data segment and stack pointer, lest the app didn't IRET
;

        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax
        mov     sp,my_sp

;
; restore the interrupted state, then perform a BOP to reset the PIC and clean
; up any interrupt state
;

        pop     es
IFNDEF WOW_x86
        popa
ELSE
.386p
        pop     gs
        pop     fs
        popad
.286p
ENDIF

;
; this BOP will clear the emulated PICs (sends non-specific EOIs), and cause the
; next NET interrupt to be generated, if one is queued
;

ifdef WOW_x86
.386p
        FBOP    BOP_REDIR, SVC_RDRINTACK2, FastBop
.286p
else
        SVC     SVC_RDRINTACK2
endif ; WOW_x86

;
; restore the rest of the interrupted context and resume
;

        pop     ds
        riret

chain_previous_int:
        push    word ptr OldInt73+2     ; selector of previous handler
        push    word ptr OldInt73       ; offset of previous handler
        push    bp
        mov     bp,sp
        mov     ds,[bp+6]               ; retrieve interrupted ds
        pop     bp
        retf    2                       ; chain previous handler, removing space
                                        ; used for ds

HandleNetbiosAnr endp

        public  HookNetBiosHwInt

HookNetBiosHwInt proc near

        ;
        ; Save everything!!
        ;
        pusha
        push    ds
        push    es

ifdef      NEC_98                       ; '98/6/2 RAID #178452
        mov     ax,350dh                ; get old handler
else
        mov     ax,3500h + NETWORK_VECTOR ; get old handler
endif      ;NEC_98
        int     21h

        mov     word ptr [OldInt73],bx
        mov     word ptr [OldInt73 + 2],es

        mov     dx,SEL_NBPMCODE OR STD_RING
        mov     ds,dx
        mov     dx,offset HandleNetbiosAnr
        mov     ah,25h
        int     21h                     ; set new handler

        pop     es
        pop     ds
        popa

        ret
HookNetBiosHwInt endp




DXPMCODE    ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\interupt.inc ===
; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;	INTERUPT.INC - Definitions for 286 DOS Exterder Interrupt Handlers
;
;-----------------------------------------------------------------------
;
;  04/18/89 jimmat  Original version.
;
;***********************************************************************

; This structure defines the stack frame used to hold the register
; values Interrupt Reflector functions.

INTRSTACK   struc

intUserES   dw      ?
intUserDS   dw      ?
intUserDI   dw      ?
intUserSI   dw      ?
intUserBP   dw      ?
intUserSPx  dw      ?
intUserBX   dw      ?
intUserDX   dw      ?
intUserCX   dw      ?
intUserAX   dw      ?

intUserFL   dw      ?

pmUserES    dw      ?
pmUserDS    dw      ?
pmUserDI    dw      ?
pmUserSI    dw      ?
pmUserBP    dw      ?
pmUserSPx   dw      ?
pmUserBX    dw      ?
pmUserDX    dw      ?
pmUserCX    dw      ?
pmUserAX    dw      ?

pmUserFL    dw      ?

pmUserSS    dw      ?
pmUserSP    dw	    ?

wParam1     dw	    ?
wParam2     dw	    ?
lParam	    dd	    ?

INTRSTACK   ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\dxutil.asm ===
PAGE    ,132
        TITLE   DXUTIL.ASM -- Dos Extender Miscellaneous Routines

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXUTIL.ASM      -   Dos Extender Miscellaneous          *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains miscellaneous routines for the Dos     *
;*  Extender.                                                   *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  08/08/90 earleh DOSX and client privilege ring determined   *
;*      by equate in pmdefs.inc                                 *
;*  04/09/90 jimmat   If 286 with 287, put 287 into pMode too.  *
;*  08/20/89 jimmat   Removed local A20 code since HIMEM 2.07   *
;*                    works properly across processor resets    *
;*  07/28/89 jimmat   Added A20 check/set routines, added       *
;*                    SelOff2SegOff & Lma2SegOff routines.      *
;*  06/19/89 jimmat   Set direction flag before REP MOVS        *
;*  05/25/89 jimmat   Added GetSegmentAccess routine            *
;*  03/30/89 jimmat   Set IOPL = 3 when entering protect mode   *
;*  03/16/89 jimmat   Added more debug sanity checks            *
;*  03/15/89 jimmat   Minor changes to run child in ring 1      *
;*  03/13/89 jimmat   Added support for LDT & TSS               *
;*  02/10/89 (GeneA): changed Dos Extender from small model to  *
;*      medium model.  Also added MoveMemBlock function.        *
;*  01/25/89 (GeneA): changed initialization of real mode code  *
;*      segment address in EnterRealMode.  caused by adding     *
;*      new method of relocationg dos extender for PM operation *
;*  12/13/88 (GeneA): moved EnterProtectedMode and EnterReal-   *
;*      Mode here from dxinit.asm                               *
;*  09/16/88 (GeneA):   created by extracting code from the     *
;*      SST debugger modules DOSXTND.ASM, VIRTMD.ASM,           *
;*      VRTUTIL.ASM, and INTERRPT.ASM                           *
;*  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI     *
;*  24-Jan-1992 v-simonf Added WOW callout when INT 8 hooked    *
;*                                                              *
;****************************************************************

.286p
.287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

; .sall
; .xlist
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include dpmi.inc
include intmac.inc
.list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

SHUT_DOWN   =   8Fh         ;address in CMOS ram of the shutdown code
CMOS_ADDR   =   70h         ;i/o address of the cmos ram address register
CMOS_DATA   =   71h         ;i/o address of the cmos ram data register

DMAServiceSegment       equ     040h    ;40:7B bit 5 indicates DMA services
DMAServiceByte          equ     07Bh    ;  are currently required
DMAServiceBit           equ     020h

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   segGDT:WORD
        extrn   segIDT:WORD
        extrn   selGDT:WORD
        extrn   selIDT:WORD
        extrn   selGDTFree:WORD
        extrn   bpGDT:FWORD
        extrn   bpIDT:FWORD
        extrn   bpRmIVT:FWORD
        extrn   rgbXfrBuf1:BYTE
        extrn   PMFaultVector:DWORD
        extrn   lpfnXMSFunc:DWORD


        extrn   pbReflStack:WORD

bIntMask        db      0

bpBogusIDT      df      0       ;This is loaded into the IDT register to
                                ; force a bogus IDT to be defined.  When we
                                ; then do an interrupt a triple fault will
                                ; occur forcing the processor to reset.  This
                                ; is when doing a mode switch to real mode.

IDTSaveArea     dw      3 DUP (?)       ;save area for IDT during mode switch

        public  A20EnableCount

A20EnableCount  dw      0

ShutDownSP      dw      0       ;stack pointer during 286 reset

        public  f286_287

f286_287        db      0       ;NZ if this is a 286 with 287 coprocessor


if DEBUG   ;------------------------------------------------------------

        extrn   fTraceA20:WORD
        extrn   fTraceMode:WORD

        public  fA20

fA20    db      0

endif   ;DEBUG  --------------------------------------------------------

        public HighestSel
HighestSel dw 0

ifndef WOW_x86
        public IretBopTable
IretBopTable label byte
        irp x,<0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15>
        db  0c4h, 0c4h, 05dh, x
        endm
else
        public FastBop
FastBop         df 0

IretBopTable label byte
        irp x,<0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15>
        db  02eh, 066h, 0FFh, 01eh, 00h, 00h, 05dh, x
        endm

NullSel dd      0
        dd      0
endif
        extrn   DpmiFlags:WORD
DXDATA  ends

; -------------------------------------------------------
;               CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   segDXData:WORD
        extrn   segDXCode:WORD
        extrn   selDgroup:WORD

DXCODE  ends


DXPMCODE    segment

        extrn selDgroupPM:WORD

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Real/Protected Mode Switch Routines
        page

; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

; -------------------------------------------------------
;       REAL/PROTECTED MODE SWITCH ROUTINES
; -------------------------------------------------------
;
;  EnterProtectedMode   -- This routine will switch the processor
;       into protected mode.  It will return with the processor
;       in protected mode and all of the segment registers loaded
;       with the selectors for the protected mode segments.
;       (CS with the selector for DXCODE and DS,ES,SS with the
;       selector for DXDATA)
;       It will also switch mode dependent memory variables.
;       It assumes that InitGlobalDscrTable and InitIntrDscrTable
;       have been called to set up the descriptor tables appropriately.
;
;   Note:   Except for a very brief time in this routine and in
;           EnterRealMode, the DOS Extender runs in the same ring along
;           with it's child app.  This has the benefit of eliminating
;           ring transitions on hardware and software interrupts.
;           It also makes it possible for the child to hook their
;           own interrupt routine into the IDT.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   AX, DS, ES, SS, CS modified, all others preserved
;
;   NOTE:   This routine turns interrupts of and does not turn them
;           back on.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  EnterProtectedMode

EnterProtectedMode  proc  near

        FCLI

; Update the mode dependent variables.

        mov     ax,SEL_DXDATA or STD_RING
        mov     selDgroup,ax

; Set the DMA services required bit for pMode users.

        mov     ax,DMAServiceSegment
        mov     es,ax
        or      byte ptr es:[DMAServiceByte],DMAServiceBit


; 'local enable' the A20 line via HIMEM before switching to pMode.
; This is more complicated than you might think.  Some real mode code
; (like old versions of SMARTDRV.SYS) may diddle with A20 on their own.
; These programs may not want us to change A20 on them.  RMIntrReflector
; may do a XMS 'local enable' to turn A20 back on for one of these pgms.
; Also, on a 386 where we actually do the mode switch, we try to leave
; A20 enabled so as to not waste time diddling for nothing.  The
; A20EnabledCount variable tracks if we've 'local enabled' A20 or not.
; Since we can't really trust real mode to leave A20 alone, we double
; check that it's really really on when we think it should be.

        push    bx                      ;save bx around XMS calls

        cmp     A20EnableCount,0        ;should A20 already be enabled?
        jz      enpm10                  ;  no, (normal 4 286) just go enable it

        xmssvc  7                       ;  yes, is it really enabled?
        or      ax,ax
        jnz     enpm15                  ;  yes, we be done!

if DEBUG   ;------------------------------------------------------------
        or      fA20,1                  ;  somebody done us wrong
endif   ;---------------------------------------------------------------

        xmssvc  6                       ;keep enable/disable calls balanced
        dec     A20EnableCount
enpm10:
        xmssvc  5                       ;local enable A20
        inc     A20EnableCount

if DEBUG   ;------------------------------------------------------------

        or      ax,ax
        jnz     @f
        or      fA20,2                  ;enable failed!
@@:
        cmp     fTraceA20,0
        jz      @f
        xmssvc  7                       ;in debug mode, make double sure
        or      ax,ax                   ;  A20 was enabled.  Slows things
        jnz     @f                      ;  down, but it's better to know.
        or      fA20,2
@@:
endif   ;DEBUG  --------------------------------------------------------

enpm15: pop     bx

ifndef WOW_x86
        DPMIBOP SetAltRegs
; Make sure that the nested task flag is clear

        pushf
        pop     ax
        and     ax,NOT 4000h
        push    ax
        npopf

; Make sure that we have the appropriate descriptor tables in effect,
; and switch the machine into protected mode

enpr20: smsw    ax              ;get current machine state
        or      ax,1            ;set the protected mode bit
        lgdt    bpGDT
        lidt    bpIDT
        lmsw    ax              ;and away we go

; Flush the instruction queue and load the code segment selector
; by doing a far jump.

        db      0EAh            ;jump far opcode
        dw      offset enpm40   ;offset of far pointer
        dw      SEL_DXCODE0     ;selector part of PM far pointer (ring 0)

; Load the other segment registers with valid selectors (not under VCPI)

enpm40: mov     ax,SEL_DXDATA0  ;stack has gotta be ring 0 also
        mov     ss,ax

; Load the LDT register and the Task Register

        mov     ax,SEL_LDT
        lldt    ax                      ;load the LDT register

        mov     ax,SEL_DXDATA or STD_RING
        mov     ds,ax                           ;ds to our DGROUP

        mov     ax,SEL_GDT
        mov     es,ax                           ;es to GDT

        push    si                              ;make sure busy bit is off
        mov     si,SEL_TSS                      ;  in the TSS descriptor
        mov     es:[si].arbSegAccess,STD_TSS    ;    before trying to load it
        ltr     si                              ;now load the task register
        pop     si
else
        .386p
        push    ebp
        mov     ebp,esp
        push    SEL_DXCODE or STD_RING  ; new cs
        push    0                       ; high half eip
        push    offset epmwow           ; new eip
        push    SEL_DXDATA or STD_RING  ; new ss
        push    ebp
        push    SEL_DXDATA or STD_RING  ; new ds
        DPMIBOP DPMISwitchToProtectedMode
epmwow:
        pop     ebp
        .286p
endif

        push    ds                      ;point es to DGROUP
        pop     es

; If this is a 286 machine with a 287 math coprocessor, put the coprocessor
; into protected mode also.

        cmp     f286_287,0              ;286 and 287?
        jz      @f

ifndef NEC_98
        xor     al,al                   ;  yup, clear co-processor busy line
        out     0F0h,al
endif   ;!NEC_98
        fsetpm                          ;     and put it in pMode
@@:

; We're currently running in ring 0.  Setup an interlevel iret frame
; to switch to our normal ring, and also force IOPL=3.  I spent 1+ day
; debugging on a 286 system (with no debugger!) because the 286 seemed
; switch into protected mode with IOPL=0, and once we got to an outer
; ring, we would fault on things like CLI instructions.

enpmSwitchRing:
ifndef WOW_x86
        mov     ax,sp                   ;still points to return address
        push    SEL_DXDATA or STD_RING  ;new ss
        push    ax                      ;new sp
        pushf
        pop     ax
        or      ah,30h
        push    ax                      ;new flags, with IOPL=3
        push    SEL_DXCODE or STD_RING  ;new cs
        push    offset DXCODE:epm_ret   ;new ip
        iret
endif
; When we get here, we are now in an outer ring.

epm_ret:

        ret                     ;near return to caller in pMode

EnterProtectedMode endp





; -------------------------------------------------------
; EnterRealMode     -- This routine will switch the processor
;       from protected mode back into real mode.  It will also
;       reset the various mode dependent variables to their
;       real mode values and load the segment registers with
;       the real mode segment addresses.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   AX, DS, ES, SS, CS modified
;
;   NOTE:   This routine must be called with the stack segment set
;           to the Dos Extender data segment, as it resets the stack
;           segment register to the Dos Extender real mode data segment
;           but does not modify the stack pointer.
;   NOTE:   This routine turns interrupts off and and does not turn
;           them back on.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  EnterRealMode

EnterRealMode   proc    near

        FCLI

        mov     es,selDgroup

        push    SegDxCode
        push    offset DXCODE:enrmwow
        push    SegDxData
        push    sp
        push    SegDxData
.386p
        DPMIBOP DPMISwitchToRealMode
.286p
enrmwow: add    sp,6                    ; remove rest of parameters
        push    ds
        pop     es                      ; es not set by mode switch

enrm70:
        push    es                              ;clear DMA services required
        mov     ax,DMAServiceSegment            ;  bit for real mode
        mov     es,ax
        and     byte ptr es:[DMAServiceByte],not DMAServiceBit
        pop     es

        mov     ax,segDXData
        mov     selDgroup,ax

        ret

EnterRealMode   endp

; -------------------------------------------------------
        public RmUnsimulateProc

RmUnsimulateProc proc far
        BOP     BOP_UNSIMULATE
RmUnsimulateProc endp

; -------------------------------------------------------
DXCODE ends

DXPMCODE    segment
        assume cs:DXPMCODE

        public PmUnsimulateProc

PmUnsimulateProc proc far
        BOP     BOP_UNSIMULATE
PmUnsimulateProc endp

; -------------------------------------------------------
;       RAW MODE SWITCH ROUTINES
; -------------------------------------------------------

; ------------------------------------------------------
; PmRawModeSwitch       -- This routine performs a raw mode switch from
;       protected mode to real mode.  NOTE: applications will JUMP at this
;       routine
;
;   Input:   ax - new DS
;            cx - new ES
;            dx - new SS
;            bx - new sp
;            si - new CS
;            di - new ip
;    Output: DS, ES, SS, sp, CS, ip contain new values
;    Errors: none
;    Uses:
;
;
;
        assume ds:nothing, ss:nothing, es:nothing
        public PmRawModeSwitch
PmRawModeSwitch proc far

        push    ss
        pop     ds
        push    bx
.386p
        mov     bx,ss
        movzx   ebx,bx
        lar     ebx,ebx
        test    ebx,(AB_BIG SHL 8)
        mov     ebx,esp
        jnz     prms10

        movzx   ebx,bx
prms10:
.286p

; Switch to dosx stack (since switch to real mode will do that to us anyway
; NOTE: no-one can call EnterIntHandler or ExitIntHandler until we switch to
;       the user's new stack.  If they do, they will use the area we stored
;       the parameters for this call for a stack frame

        rpushf
        FCLI
        push    SEL_DXDATA OR STD_RING
        pop     ss
        assume ss:DGROUP
.386p
        movzx   esp,word ptr pbReflStack
.286p

; Save user registers

        push    dx              ; ss
.386p
        push    word ptr [ebx]
        push    word ptr [ebx - 2]; flags pushed before cli
.286p
        push    si              ; cs
        push    di              ; ip
        push    ax              ; ds
        push    cx              ; es

; switch modes

        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax
        SwitchToRealMode

; set the registers, switch stacks, and return to the user

        pop     es
        pop     ds
        pop     ax              ; ip
        pop     bx              ; cs
        pop     cx              ; flags
        pop     si              ; sp
        pop     ss
        assume ss:nothing
        mov     sp,si
        push    cx
        popf
        push    bx
        push    ax
        ret

PmRawModeSwitch endp

; NOTE: this is now the DXCODE segment, NOT the DXPMCODE segment (courtesy
;       of SwitchToRealMode

; ------------------------------------------------------
; RmRawModeSwitch       -- This routine performs a raw mode switch from
;       protected mode to real mode.  NOTE: applications will JUMP at this
;       routine
;
;   Input:   ax - new DS
;            cx - new ES
;            dx - new SS
;            bx - new sp
;            si - new CS
;            di - new ip
;    Output: DS, ES, SS, sp, CS, ip contain new values
;    Errors: none
;    Uses:
;
;
;
        assume ds:nothing, ss:nothing, es:nothing
        public RmRawModeSwitch
RmRawModeSwitch proc far
        push    ss
        pop     ds
        push    bx
        mov     bx,sp

; Switch to dosx stack (since switch to real mode will do that to us anyway
; NOTE: no-one can call EnterIntHandler or ExitIntHandler until we switch to
;       the user's new stack.  If they do, they will use the area we stored
;       the parameters for this call for a stack frame

        pushf
        FCLI
        push    segDxData
        pop     ss
        assume ss:DGROUP
        mov     sp,pbReflStack

; Save user registers

        push    dx              ; ss
        push    word ptr [bx]   ; sp
        push    word ptr [bx - 2] ; flags from before cli
        push    si              ; cs
        push    di              ; ip
        push    ax              ; ds
        push    cx              ; es

; switch modes

        mov     ax,segDxData
        mov     ds,ax
        SwitchToProtectedMode

; set the registers, switch stacks, and return to the user
        pop     es
        pop     ds
.386p
        test    DpmiFlags,DPMI_32BIT
        jnz     rrms10

        xor     eax,eax         ; clear high 16 bits
        xor     edi,edi         ; clear high 16 bits
.286p
rrms10: pop     di              ; ip
        pop     ax              ; cs
        pop     cx              ; flags from before cli
        pop     bx              ; sp
        assume ss:nothing
        pop     ss
.386p
        mov     esp,ebx
        push    cx
        rpopf386

        push    eax
        push    edi
        db      066h
        retf
.286p

RmRawModeSwitch endp

DXPMCODE ENDS

DXCODE SEGMENT

; -------------------------------------------------------
;       STATE SAVE/RESTORE ROUTINES
; -------------------------------------------------------

; -------------------------------------------------------
; RmSaveRestoreState     -- This routine exists as a placeholder.  It
;       is not currently necessary to perform any state saving/restoring
;       for raw mode switch.  The DPMI spec states that the user can call
;       this routine with no adverse effect.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   none
;
        assume ds:nothing, ss:nothing, es:nothing
        public RmSaveRestoreState
RmSaveRestoreState proc far
        ret
RmSaveRestoreState endp

DXCODE  ends

; -------------------------------------------------------

DXPMCODE  segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
; RmSaveRestoreState     -- This routine exists as a placeholder.  It
;       is not currently necessary to perform any state saving/restoring
;       for raw mode switch.  The DPMI spec states that the user can call
;       this routine with no adverse effect.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   none
;
        assume ds:DGROUP, ss:nothing, es:nothing
        public PmSaveRestoreState
PmSaveRestoreState proc far
        push    ax
        push    ds
        mov     ax, SEL_DXDATA or STD_RING
        mov     ds, ax
        test    DpmiFlags,DPMI_32BIT
        pop     ds
        pop     ax
        jnz     short @f                ; 32-bit return
        ret
@@:
        db      66h
        ret

PmSaveRestoreState endp

ifdef      NEC_98
        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  IncInBios
        public  DecInBios

;
;       IncInBios / DecInBios
;
;       IN_BIOS Inc/Dec SubRoutine
;
IncInBios       proc    near
                push    ax
                push    es
                mov     ax, 0040h
                mov     es, ax
                test    byte ptr es:[0], 20h
                jz      @f
                inc     byte ptr es:[056h]
@@:
                pop     es
                pop     ax
                ret
IncInBios       endp

DecInBios       proc    near
                push    ax
                push    es
                mov     ax, 0040h
                mov     es, ax
                test    byte ptr es:[0], 20h
                jz      @f
                dec     byte ptr es:[056h]
@@:
                pop     es
                pop     ax
                ret
DecInBios       endp
endif   ;NEC_98


; -------------------------------------------------------
;   GTPARA      -- This routine will return the real mode paragraph
;       address of the specified protected mode memory segment.
;
;   Input:  SI      - selector of the segment
;   Output: returns ZR true if segment is in lower 1MB range
;           AX      - real mode paragraph address
;           returns ZR false if segment is in extended memory
;   Errors: returns CY true if selector isn't valid
;   Uses:   AX modified, all else preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  gtpara

gtpara:
        push    cx
        push    es
        push    si

        push    bx
        mov     bx,selGDT           ;selector for the GDT segment
        mov     es,bx
        lsl     bx,bx
        and     bx,SELECTOR_INDEX
        and     si,SELECTOR_INDEX
        cmp     si,bx   ;check the given selector against
                                    ; the GDT segment limit
        pop     bx
        jc      gtpr20

; The given selector is beyond the end of the GDT, so return error.

        or      sp,sp
        stc

        Debug_Out "gtpara: invalid selector (#si)"

        jmp     short gtpr90

; The selector specified is inside the range of defined descriptors in
; the GDT.  Get the address from the descriptor.

gtpr20: mov     cl,es:[si].adrBaseHigh
        test    cl,0F0h
        jnz     gtpr90

        shl     cl,4
        mov     ax,es:[si].adrBaseLow

if DEBUG   ;------------------------------------------------------------
        test    al,0Fh
        jz      @f
        Debug_Out "gtpara: segment not on para boundry, sel #si at #cl#ax"
@@:
endif   ;DEBUG  --------------------------------------------------------

        shr     ax,4
        or      ah,cl
        cmp     ax,ax
;
gtpr90:
        pop     si
        pop     es
        pop     cx
        ret


; -------------------------------------------------------
;   SelOff2SegOff  -- This routine will return will translate a
;       protected mode selector:offset address to the corresponding
;       real mode segment:offset address.
;
;   Input:  AX      - PM selector
;           DX      - PM offset
;   Output: if Z set:
;           AX      - RM segment
;           DX      - RM offset
;           if NZ set, address is not in conventional memory, and
;             cannot be translated
;
;   Errors: none
;   Uses:   AX, DX; all else preserved
;
;   Note:  This routine is very similar to gtpara, and could replace it!

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  SelOff2SegOff

SelOff2SegOff   proc    near

        push    bx
        push    cx
        push    dx

        call    GetSegmentAddress       ;bx:dx = lma of segment

        pop     cx                      ;cx = offset

        test    bl,0f0h                 ;above 1 Meg line?
        jnz     @f                      ;  yes, cut out now

        add     dx,cx
        adc     bx,0                    ;bx:dx = lma of segment:offset

        call    Lma2SegOff              ;bx:dx = seg:off
        mov     ax,bx                   ;dx:ax = seg:off

        cmp     ax,ax                   ;under 1 Meg, set Z flag
@@:
        pop     cx
        pop     bx

        ret

SelOff2SegOff   endp


; ------------------------------------------------------
;   Lma2SegOff -- This routine converts a linear memory address
;       in BX:DX to a normalized SEG:OFF in BX:DX.
;
;   Input:  BX:DX = lma
;   Output: BX:DX = normalized SEG:OFF
;   Uses:   none


        public  Lma2SegOff

Lma2SegOff      proc    near

        push    dx
        shl     bx,12
        shr     dx,4
        or      bx,dx
        pop     dx
        and     dx,0fh

        ret

Lma2SegOff      endp


; -------------------------------------------------------
;   GetSegmentAddress   -- This routine will return with
;       the linear address of the specified segment.
;
;   Input:  AX      - segment selector
;   Output: DX      - low word of segment address
;           BX      - high word of segment address
;   Errors: none
;   Uses:   BX, DX, all else preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  GetSegmentAddress

GetSegmentAddress:
        push    es
        push    di

        mov     es,selGDT
        mov     di,ax
        and     di,SELECTOR_INDEX
        mov     dx,es:[di].adrBaseLow
        mov     bl,es:[di].adrBaseHigh
        mov     bh,es:[di].adrbBaseHi386

        pop     di
        pop     es
        ret

; -------------------------------------------------------
;   SetSegmentAddress   -- This routine will modify the
;       segment base address of the specified segment.
;
;   Input:  AX      - segment selector
;   Output: DX      - low word of segment address
;           BX      - high word of segment address
;   Errors: None
;   Uses:   All registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  SetSegmentAddress

SetSegmentAddress:
        push    si
        push    es

        mov     es,selGDT
        mov     si,ax
        and     si,SELECTOR_INDEX
        mov     es:[si].adrBaseLow,dx
        mov     es:[si].adrBaseHigh,bl
        mov     es:[si].adrbBaseHi386,bh
        push    ax
        push    bx
        push    cx
        mov     ax,si
        mov     cx,1
        mov     bx,si
.386p
        FBOP BOP_DPMI,<SetDescriptorTableEntries>,FastBop
.286p
        pop     cx
        pop     bx
        pop     ax
        pop     es
        pop     si
        ret

; -------------------------------------------------------
;   NSetSegmentAccess   -- This routine will modify the
;       access rights byte of a specified segment.
;
;   Input:  Selector    - segment selector
;           Access      - Access rights byte value
;   Output: none
;   Errors: Carry set, AX = error code
;   Uses:   All registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
cProc   NSetSegmentAccess,<PUBLIC,NEAR>,<es,si>
        parmW   Selector
        parmW   Access
cBegin
        mov     es,selGDT
        mov     si,Selector
        and     si,SELECTOR_INDEX
        mov     ax,Access
        mov     es:[si].arbSegAccess,al      ; Set access byte.
        and     ah,0F0h                      ; Mask off reserved bits.
        and     es:[si].cbLimitHi386,0fh     ; Clear old extended bits.
        or      es:[si].cbLimitHi386,ah      ; Set new extended bits.
IFDEF WOW_x86
        push    ax
        push    bx
        push    cx
        mov     ax,si
        mov     cx,1
        mov     bx,si
.386p
        FBOP    BOP_DPMI,<SetDescriptorTableEntries>,FastBop
.286p
        pop     cx
        pop     bx
        pop     ax
ENDIF

cEnd

; -------------------------------------------------------
;   ParaToLDTSelector    -- This routine will convert a segment
;       address relative to the start of the exe file into the
;       corresponding selector for the segment.  It searches the
;       LDT to see if a segment is already defined at that address.
;       If so, its selector is returned.  If not, a new segment
;       descriptor will be defined.
;
;   Note:   The LDT and GDT are currently one and the same.
;
;   Input:  AX      - paragraph aaddress of real mode segment
;           BX      - access rights byte for the segment
;   Output: AX      - selector for the segment
;   Errors: returns CY set if unable to define a new segment
;   Uses:   AX, all other registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  ParaToLDTSelector

ParaToLDTSelector  proc near

        push    bx
        push    cx
        push    dx

; Convert the paragraph address to a linear address and see if there
; is a segment defined at that address.

        mov     dx,ax
        call    FindLowSelector
        jnc     @f                      ;if so, we don't need to make one

; This segment isn't defined, so we need to create a descriptor for it.

        mov     ax,dx
        call    MakeLowSegment

if DEBUG   ;------------------------------------------------------------
        jnc     ptos80
        Debug_Out "ParaToLDTSelector: can't make selector!"
ptos80:
endif   ;DEBUG  --------------------------------------------------------

        jc      ptos90

@@:     or      al,SELECTOR_TI or STD_RING      ;look like LDT selector

; All done

ptos90: pop     dx
        pop     cx
        pop     bx
        ret

ParaToLDTSelector       endp

        public FarParaToLDTSelector
FarParaToLDTSelector proc far
        call ParaToLDTSelector
        ret
FarParaToLDTSelector endp

; -------------------------------------------------------
        page
; -------------------------------------------------------
;       DESCRIPTOR TABLE MANIPULATION ROUTINES
; -------------------------------------------------------

; -------------------------------------------------------
;   AllocateSelector    -- This function will obtain the
;       next free descriptor in the global descriptor table.
;       The descriptors in the GDT are stored on a linked list
;       of free descriptors.  The cbLimit field of the descriptor
;       is used as the link to the next element of the list. In
;       addition, free descriptors have the access rights byte
;       set to 0.
;
;   Note:   The function InitGlobalDscrTable must have been
;           called before calling this function.
;
;   Input:  none
;   Output: AX      - selector if one is available
;   Errors: CY clear if successful, AX=0 and CY set if not free selectors
;   Uses:   AX, all else preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  AllocateSelector

AllocateSelector  proc  near

; Get the next free descriptor on the list.

        push    cx
        mov     cx, 1                   ; # of selectors needed
        mov     ax, 0
        push    ds
        FBOP    BOP_DPMI,Int31Call,FastBop
        pop     cx
        ret


AllocateSelector  endp


; -------------------------------------------------------
;   FreeSelector        --  This routine will mark the segment
;       descriptor for the specified selector as free.  This
;       is used to release a temporary selector when no longer
;       needed.  The descriptor is marked as free by setting the
;       access rights byte to 0 and placing it on the free list.
;
;   Note:   This routine can only be called in protected mode.
;
;   Input:  AX      - selector to free
;   Output: none
;   Errors: CY clear if no error, set if selector is invalid
;   Uses:   AX used, all other registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  FreeSelector

FreeSelector    proc    near

        push    bx
        mov     bx,ax
        mov     ax,1
        push    ds
        FBOP    BOP_DPMI,Int31Call,FastBop
        pop     bx
        ret


FreeSelector    endp


; -------------------------------------------------------
;   FindLowSelector  -- This function will search the global
;       descriptor table for a descriptor matching the given
;       address.
;
;   Input:  AX      - real mode paragraph to search for
;           BX      - access rights byte for the segment
;   Output: AX      - selector corresponding to input paragraph address
;   Errors: returns CY set if specified descriptor not found
;   Uses:   AX, all else preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  FindLowSelector

FindLowSelector:
        push    bx
        push    dx
;
        mov     dx,ax
        push    bx
        call    ParaToLinear
        pop     ax
        mov     bh,al
        call    FindSelector
;
        pop     dx
        pop     bx
        ret


; -------------------------------------------------------
;   FindSelector    -- This function will search the global
;       descriptor table for a segment descriptor matching
;       the specified linear byte address.
;
;       Note that this routine cannot be used to find
;       selectors pointing to addresses above 16 Megabytes.
;       This is not really a problem, since the routine
;       is used to find selectors in real mode DOS land
;       most of the time.
;
;   Input:  DX      - low word of linear byte address
;           BL      - high byte of linear address
;           BH      - access rights byte for the segment
;   Output: AX      - selector of corresponding segment
;   Errors: returns CY set if specified descriptor not found
;   Uses:   AX used, all other registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  FindSelector

FindSelector    proc    near

        push    si
        push    di
        push    es
        push    cx

; Get segment limit of the GDT to use as a limit on the search.

        lsl     di,selGDT
        mov     es,selGDT

; Look for a descriptor matching the address in BL:AX

        mov     si,SEL_USER     ;search starting here
if 0
fnds20: cmp     es:[si].arbSegAccess,0
else
fnds20: cmp     word ptr es:[si].arbSegAccess,0
endif
        jz      fnds28          ;skip if unused descriptor
        cmp     bl,es:[si].adrBaseHigh
        jnz     fnds28
        cmp     dx,es:[si].adrBaseLow
        jnz     fnds28
if      0
        cmp     es:[si].cbLimit,0
        jz      fnds28          ;skip if dscr has 0 limit
else
        cmp     es:[si].cbLimit,0ffffh
        jnz     fnds28          ;skip unless dscr has 64k limit
endif
        mov     cl,bh
        xor     cl,es:[si].arbSegAccess
        and     cl,NOT AB_ACCESSED
        jz      fnds90
fnds28: add     si,8            ;bump to next descriptor
        jc      fnds80
        cmp     si,di           ;check against end of GDT
        jc      fnds20          ;if still less, continue on.

; Hit the end of the GDT and didn't find one.  So return error.

fnds80: stc
        jmp     short fnds99

; We found it, so return the selector

fnds90: mov     ax,si
fnds99: pop     cx
        pop     es
        pop     di
        pop     si
        ret

FindSelector    endp



; -------------------------------------------------------
; DupSegmentDscr        -- This function will duplicate the specified
;   segment descriptor into the specified destination descriptor.  The
;   end result is a second segment descriptor pointing to the same place
;   in memory as the first.
;
;   Input:  AX      - selector of segment descriptor to duplicate
;           BX      - selector of the segment descriptor to receive duplicate
;   Output: none
;   Errors: none
;   Uses:   All registers preserved.    Modifies the segment
;           descriptor for the specified segment.  If this selector happens
;           to be in a segment register when this routine is called, that
;           segment register may end up pointing to the new location.

        assume  ds:DGROUP,es:NOTHING
        public  DupSegmentDscr

DupSegmentDscr  proc    near

        push    cx
        push    si
        push    di
        push    ds
        push    es

        mov     si,ax
        mov     di,bx
        and     si,SELECTOR_INDEX
        and     di,SELECTOR_INDEX
        mov     es,selGDT
        mov     ds,selGDT
        assume  ds:NOTHING
        mov     cx,4
        cld
        rep     movs word ptr [di],word ptr [si]

        pop     es
        pop     ds
        pop     di
        pop     si
        pop     cx
        ret

DupSegmentDscr  endp

IFDEF   ROM
; -------------------------------------------------------

DXPMCODE ends

; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE
ENDIF

; -------------------------------------------------------
; NSetSegmentDscr    -- This function will initialize the
;       specified descriptor table entry with the specified data.
;
;   This function can be called in real mode or protected mode.
;
;   Input:
;               Param1  - WORD segment selector
;               Param2  - DWORD 32-bit segment base address
;               Param3  - DWORD 32-bit segment limit
;               param4  - WORD segment access/type
;   Output: returns selector for the segment
;   Errors: none
;   Uses:   Flags

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
cProc   NSetSegmentDscr,<PUBLIC,FAR>,<es,di,ax,bx>
        parmW   Selector
        parmD   Base
        parmD   Limit
        parmW   Access
cBegin
        mov     es,selGDT
        mov     di,Selector
        and     di,SELECTOR_INDEX

        mov     ax,off_Base                     ; Set segment base
        mov     es:[di].adrBaseLow,ax
        mov     ax,seg_Base
        mov     es:[di].adrBaseHigh,al
        mov     es:[di].adrbBaseHi386,ah

        mov     ax,word ptr Access
        and     ax,070ffh                       ; clear 'G' bit and
                                                ; extended limit bits
        mov     word ptr es:[di].arbSegAccess,ax
                                                ; set access
        mov     ax,seg_Limit
        mov     bx,off_Limit                    ; AX:BX = segment limit
        test    ax,0fff0h                       ; big?
        jz      ssd_0                           ; No
        shr     bx,12d                          ; Yes, make it page granular.
        shl     ax,4d
        or      bx,ax
        mov     ax,seg_Limit
        shr     ax,12d
        or      al,080h                         ; set 'G' bit
ssd_0:
        or      es:[di].cbLimitHi386,al         ; set high limit
        mov     es:[di].cbLimit,bx              ; set low limit
        push    ax
        push    bx
        push    cx
        mov     ax,di
        mov     cx,1
        mov     bx,di
.386p
        FBOP    BOP_DPMI,<SetDescriptorTableEntries>,FastBop
.286p
        pop     cx
        pop     bx
        pop     ax
cEnd

ifndef WOW_x86
; -------------------------------------------------------
; NSetGDTSegmentDscr    -- This function will initialize the
;       specified descriptor table entry with the specified data.
;
;   This function can be called in real mode or protected mode.
;
;   Input:
;               Param1  - WORD segment selector
;               Param2  - DWORD 32-bit segment base address
;               Param3  - DWORD 32-bit segment limit
;               param4  - WORD segment access/type
;   Output: returns selector for the segment
;   Errors: none
;   Uses:   Flags

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
cProc   NSetGDTSegmentDscr,<PUBLIC,FAR>,<es,di,ax,bx>
        parmW   Selector
        parmD   Base
        parmD   Limit
        parmW   Access
cBegin
        mov     ax,SEL_GDT
        mov     es,ax
        mov     di,Selector
        and     di,SELECTOR_INDEX

        mov     ax,off_Base                     ; Set segment base
        mov     es:[di].adrBaseLow,ax
        mov     ax,seg_Base
        mov     es:[di].adrBaseHigh,al
        mov     es:[di].adrbBaseHi386,ah

        mov     ax,word ptr Access
        and     ax,070ffh                       ; clear 'G' bit and
                                                ; extended limit bits
        mov     word ptr es:[di].arbSegAccess,ax
                                                ; set access
        mov     ax,seg_Limit
        mov     bx,off_Limit                    ; AX:BX = segment limit
        test    ax,0fff0h                       ; big?
        jz      @f                              ; No
        shr     bx,12d                          ; Yes, make it page granular.
        shl     ax,4d
        or      bx,ax
        mov     ax,seg_Limit
        shr     ax,12d
        or      al,080h                         ; set 'G' bit
@@:
        or      es:[di].cbLimitHi386,al         ; set high limit
        mov     es:[di].cbLimit,bx              ; set low limit
cEnd
endif ; WOW_x86


IFDEF   ROM
; -------------------------------------------------------

DXCODE  ends

; -------------------------------------------------------

DXPMCODE  segment
        assume  cs:DXPMCODE
ENDIF

; -------------------------------------------------------
;   MakeLowSegment      -- This function will create a segment
;       descriptor for the specified low memory paragraph address.
;       The segment length will be set to 64k.  The difference
;       between this and MakeScratchSelector is that this function
;       allocates a new segment descriptor in the user area of
;       the global descriptor table, thus creating a more or less
;       permanent selector.  MakeScratchSelector always uses the
;       same descriptor location in the descriptor table, thus
;       creating a very temporary selector.
;
;   Input:  AX      - paragraph address in low memory
;           BX     - access rights word for the segment
;   Output: AX      - selector to use to access the memory
;   Errors: returns CY clear if no error, CY set if unable to
;           allocate a segment descriptor
;   Uses:   AX used, all else preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  MakeLowSegment

MakeLowSegment  proc    near

; We need to allocate a segment descriptor, convert the paragraph address
; to a linear byte address, and then initialize the allocated segment
; descriptor.

        push    dx
        push    cx

        mov     cx,bx
        mov     dx,ax               ;paragraph address to DX
        call    AllocateSelector    ;get a segment descriptor to use
        jc      mksl90              ;get out if error
        call    ParaToLinear
        cCall   NSetSegmentDscr,<ax,bx,dx,0,0FFFFh,cx>

        clc
mksl90:
        pop     cx
        pop     dx
        ret

MakeLowSegment  endp

; -------------------------------------------------------
;   ParaToLinear
;
;   This function will convert a paragraph address in the lower
;   megabyte of memory space into a linear address for use in
;   a descriptor table.
;
;   Input:  DX      - paragraph address
;   Output: DX      - lower word of linear address
;           BX     - high word of linear address
;   Errors: none
;   Uses:   DX, BL used, all else preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  ParaToLinear

ParaToLinear    proc    near

        mov     bl,dh
        shr     bl,4
        shl     dx,4
        xor     bh,bh
        ret

ParaToLinear    endp

; -------------------------------------------------------
;   RZCall -- Utility routine to call a Ring
;       Zero procedure.  Stack parameter is the NEAR
;       address of the routine in the DXPMCODE segment to
;       call.  The called routine must be declared FAR
;       and take no stack parameters.
;
;   USES:       Whatever Ring 0 routine uses
;               +Flags
;   RETURNS:    Whatever Ring 0 routine returns
;
;   NOTE:       Assumes that interrupts must be disabled
;               for the Ring 0 routine.
;
;   History:
;       12-Feb-1991 -- ERH wrote it!!!
; -------------------------------------------------------

My_Call_Gate    dd      (SEL_SCR0 or STD_TBL_RING) shl 10h

        public  RZCall
RZCall proc near

        pushf
        FCLI
        push    bp
        mov     bp,sp
        cCall   NSetSegmentDscr,<SEL_SCR0,0,SEL_EH,0,[bp+6],STD_CALL>
        pop     bp

        call    dword ptr My_Call_Gate

        cCall   NSetSegmentDscr,<SEL_SCR0,0,0,0,-1,STD_DATA>

        npopf

        retn    2

RZCall endp

; -------------------------------------------------------
; -------------------------------------------------------

DXPMCODE    ends

;
;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\intmac.inc ===
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    intmac.inc
;
; Abstract:
;
;    This module contains macros to allow code running in 16 bit protected
;    mode to manipulate the virtual interrupt flag
;
; Author:
;
;   Dave Hastings (daveh) 24-Apr-1992
;
; Revision History:
;
;--


VDM_INT_TRAP_GATE EQU 00000000h
VDM_INT_INT_GATE  EQU 00000001h
VDM_INT_32        EQU 00000002h
VDM_INT_16        EQU 00000000h
EFLAGS_VIF equ 080000H

ifdef WOW_x86
include vint.inc
riret macro
    local   a,b,c,d
    push    bp
    mov     bp,sp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,[bp+6]
    test    ax,200h
    jz      a
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      c
    sti
c:  lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    jmp     short b
a:
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      d
    cli
d:  lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
b:
    pop     ds
    pop     ax
    pop     bp
    iret
    endm

riretd macro
    local   a,b,c,d
    push    bp
    mov     bp,sp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,[bp+10]
    test    ax,200h
    jz      a
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      c
    sti
c:  lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    jmp     short b
a:
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      d
    cli
d:  lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
b:
    pop     ds
    pop     ax
    pop     bp
    iretd
    endm

riretd32 macro
    local   a,b,c,d
    push    ebp
    mov     ebp,esp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,[ebp+0ch]
    test    ax,200h
    jz      a
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      c
    sti
c:  lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    jmp     short b
a:
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      d
    cli
d:  lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
b:
    pop     ds
    pop     ax
    pop     ebp
    iretd
    endm

rpopf386 macro
    local a,b,c,d
    push    ebp
    mov     ebp,esp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,[ebp+4]
    test    ax,200h
    jz      a
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      c
    sti
c:  lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    jmp     short b
a:
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      d
    cli
d:  lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
b:
    pop     ds
    pop     ax
    pop     ebp
    popf
    endm

rpopf macro
    local a,b,c,d
    push    bp
    mov     bp,sp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,[bp+2]
    test    ax,200h
    jz      a
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      c
    sti
c:  lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    jmp     short b
a:
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      d
    cli
d:  lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
b:
    pop     ds
    pop     ax
    pop     bp
    popf
    endm

rpopfd macro
    local a,b,c,d
    push    bp
    mov     bp,sp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,[bp+2]
    test    ax,200h
    jz      a
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      c
    sti
c:  lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    jmp     short b
a:
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      d
    cli
d:  lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
b:
    pop     ds
    pop     ax
    pop     bp
    popfd
    endm

;
; The following assume that the RI bit implies a virtual interrupt flag
; in eflags.   See appendix h of the Pentium user's manual
;
rpushf macro
    local a,b,c,d
    .386p
    pushf
    push    ebp
    mov     ebp,esp
    push    eax
    push    ds

    mov     ax,ss
    movzx   eax,ax
    lar     eax,eax
    test    eax,(AB_BIG SHL 8)
    jnz     @f
    movzx   ebp,bp
@@:

    mov     ax,40h
    mov     ds,ax
    mov     ax,word ptr ds:FIXED_NTVDMSTATE_REL40
    test    ax,RI_BIT_MASK
    jz      c
    pushfd
    test    dword ptr [ebp-10],EFLAGS_VIF
    jz      d
    or      word ptr [ebp+4],200h
    popfd
    jmp     b
d:
    and     word ptr [ebp+4],NOT 200h
    popfd
    jmp     b
c:
    test    ax,VIRTUAL_INTERRUPT_BIT
    jz      a
    or      word ptr [ebp+4],200h
    jmp     b
a:
    and     word ptr [ebp+4],NOT 200h
b:
    pop     ds
    pop     eax
    pop     ebp
    .286p
    endm

rpushfd macro
    local a,b,c,d
    pushfd
    push    bp
    mov     bp,sp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,word ptr ds:FIXED_NTVDMSTATE_REL40
    test    ax,RI_BIT_MASK
    jz      c
    test    dword ptr [bp+2],EFLAGS_VIF
    jz      d
    or      word ptr [bp+2],200h
    jmp     b
d:
    and     word ptr [bp+2],NOT 200h
    jmp     b
c:
    test    ax,VIRTUAL_INTERRUPT_BIT
    jz      a
    or      word ptr [bp+2],200h
    jmp     b
a:
    and     word ptr [bp+2],NOT 200h
b:
    pop     ds
    pop     ax
    pop     bp
    endm


rpushfd32 macro
    local a,b,c,d
    pushfd
    push    ebp
    mov     ebp,esp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,word ptr ds:FIXED_NTVDMSTATE_REL40
    test    ax,RI_BIT_MASK
    jz      c
    test    dword ptr [ebp+4],EFLAGS_VIF
    jz      d
    or      word ptr [ebp+4],200h
    jmp     b
d:
    and     word ptr [ebp+4],NOT 200h
    jmp     b
c:
    test    ax,VIRTUAL_INTERRUPT_BIT
    jz      a
    or      word ptr [ebp+4],200h
    jmp     b
a:
    and     word ptr [ebp+4],NOT 200h
b:
    pop     ds
    pop     ax
    pop     ebp
    endm
ELSE
riret macro
    iret
    endm

riretd macro
    iretd
    endm

riretd32 macro
    iretd
    endm

rpopf macro
    popf
    endm

rpopfd macro
    popfd
    endm

rpushf macro
    pushf
    endm

rpushfd macro
    pushfd
    endm

rpushfd32 macro
    pushfd
    endm

FCLI macro
    cli
    endm

FSTI macro
    sti
    endm

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\netbios.inc ===
; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;	NETBIOS.INC	-   NetBIOS Definitions for 286 DOS Extender
;
;-----------------------------------------------------------------------
;
;  04/18/89 jimmat  Original version.
;
;***********************************************************************

; NetBIOS return codes

RC_Good 	EQU	000h
RC_Invalid_Cmd	EQU	003h
RC_Max_Cmd	EQU	022h
RC_In_Progress	EQU	024h
RC_Pending	EQU	0FFh

RC_Resources	EQU	035h	; OS/2 (!) Required OS Resources Exhausted


; Some NetBIOS command codes

SessCall	EQU	10h		; Call command
SessListen	EQU	11h		; Listen command
HangUp		EQU	12h		; Hang up command
Send		EQU	14h		; Send command
Recv		EQU	15h		; Recv command
RecvAny 	EQU	16h		; Recv any command
ChainSend	EQU	17h		; Chain send command
SendGram	EQU	20h		; Send datagram
RecvGram	EQU	21h		; Recv datagram
SendBroad	EQU	22h		; Send broadcast datagram
RecvBroad	EQU	23h		; Recv broadcast datagram
AddName 	EQU	30h		; Add name command
DelName 	EQU	31h		; Delete name command
Reset		EQU	32h		; Reset command
AdptStat	EQU	33h		; Adapter status command
SessStat	EQU	34h		; Session status command
Cancel		EQU	35h		; Cancel command
AddGName	EQU	36h		; Add group name command
Unlink		EQU	70h		; Unlink command
Install 	EQU	7Fh		; Install check  (?)

NoWait		EQU	80h		; APPLIES TO MOST COMMANDS (High bit)


; some UB netbios command codes

UBNB_Register   EQU     72h
UBNB_SendNmc    EQU     73h
UBNB_Callniu    EQU     74h
UBNB_Calladdr   EQU     75h
UBNB_Listenaddr EQU     76h
UBNB_SendPkt    EQU     77h
UBNB_RcvPkt     EQU     78h
UBNB_SendAttn   EQU     79h
UBNB_RcvAttn    EQU     7Ah
UBNB_Listenniu  EQU     7Bh
UBNB_RcvRaw     EQU     7Ch
UBNB_SendNmc2   EQU     7Dh


;******************************************************************************
;			     S T R U C T U R E S
;******************************************************************************
;
;   Network Control Block structure
;
NCB_Struc	STRUC
NCB_Command	db	?		; Command
NCB_RetCode	db	?		; Return code
NCB_LSN 	db	?		; Local session #
NCB_Num 	db	?		; Name #
NCB_Buffer_Off	dw	?		; Buffer offset
NCB_Buffer_Seg	dw	?		; Buffer segment
NCB_Length	dw	?		; Buffer length
NCB_CallName	db 16 dup (?)		; Name on local or remote adapter
NCB_Name	db 16 dup (?)		; Name on local adapter
NCB_RTO 	db	?		; Receive timeout
NCB_STO 	db	?		; Send timeout
NCB_Post_Off	dw	?		; Post routine offset
NCB_Post_Seg	dw	?		; Post routine segment
NCB_LanA_Num	db	?		; Adapter #
NCB_Cmd_Cplt	db	?		; Command status field
NCB_Reserved	db 14 dup (?)		; Reserved
NCB_Struc	ENDS


HCB_Flags	EQU	WORD PTR [-02h]
HCB_Next	EQU	WORD PTR [-04h]
HCB_PM_NCB_Seg	EQU	WORD PTR [-06h]
HCB_PM_NCB_Off	EQU	WORD PTR [-08h]
HCB_Handle	EQU	WORD PTR [-0Ah]

HCB_Header_Size EQU	0Ah
HCB_Size	EQU	SIZE NCB_Struc + HCB_Header_Size

; HCB_Flags defines

HCB_DELAY	EQU	001h
HCB_ISSUED	EQU	002h
HCB_POSTED	EQU	004h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\stackchk.inc ===
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    stackchk.inc
;
; Abstract:
;
;    This module implements stack checking for the dos extender
;
; Author:
;
;    Dave Hastings (daveh) 20-Apr-1993
;
;--

if DBG

FIX_STACK macro
        local foo,foo1
        push    bp
        mov     bp,pbReflStack
        cmp     bp,offset DGROUP:bReflStack
        ja      foo1

        BOP BOP_DBGBREAKPOINT

foo1:   mov     bp,sp
;        cmp     word ptr [bp - CB_STKFRAME + 2],0AAAAH
;        je      foo

;        BOP BOP_DBGBREAKPOINT

foo:    mov     word ptr [bp - CB_STKFRAME + 2],0AAAAH
        pop     bp
        endm

CHECK_STACK macro
        local foo
        push    bp
        mov     bp,pbReflStack
;        cmp     word ptr [bp + 2],0AAAAh
;        je      foo

;        BOP BOP_DBGBREAKPOINT

foo:    pop     bp
        endm

ifdef NEC_98

ASSERT_CLI macro
        endm

else

ASSERT_CLI macro
        local foo1

        push    ds
        push    40h
        pop     ds
        test    ds:[314h],0200h
        jz      foo1

        BOP BOP_DBGBREAKPOINT
foo1:   pop     ds
        endm

endif ;!NEC_98


ASSERT_REFLSTK_OK macro
        local   foo1
        cmp     pbReflStack,offset DGROUP:pbReflStack
        jna     foo1

        BOP BOP_DBGBREAKPOINT
foo1:
        endm
else
FIX_STACK macro
        endm

CHECK_STACK macro
        endm

ASSERT_CLI macro
        endm

ASSERT_REFLSTK_OK macro
        endm
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\ntnpxem.asm ===
PAGE    ,132
        TITLE   NTNPXEM.ASM -- Support for fielding exceptions from npx em

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      NTNPXEM.ASM     -   Exception handler for npx emulation *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*      This module contains code to field exceptions from the  *
;*      Nt NPX emulator.   These exceptions will only be        *
;*      received on machines without 387's, on which the app    *
;*      has set the EM bit.                                     *
;****************************************************************

        .286p
        .287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include ks386.inc
include intmac.inc
        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   PmFaultEntryVector:near

; -------------------------------------------------------
;               DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   rgw0stack:word

DXDATA  ends

; -------------------------------------------------------
;               Exception Handler
; -------------------------------------------------------


DXPMCODE segment
        assume cs:DXPMCODE
        .386p
;
; N.B.  The following routine will be executed on a special
;       code selector.  The following routine must ALWAYS
;       appear at offset zero in this code selector.
;

; -------------------------------------------------------
;   NpxExceptionHandler -- This function switches to the
;       exception handler stack, pushes an exception frame,
;       and restores the registers.  It then transfers control
;       the trap 7 fault handler.
;
;   Input:      ss:esp -> an NT CONTEXT record
;   Output:     all registers restored to fault time
;               values, and exception frame pushed.
;   Errors:     none
;   Uses:       all

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING,fs:NOTHING
        public NpxExceptionHandler,EndNpxExceptionHandler

NpxExceptionHandler proc far

	FCLI
        mov     ax,ss
        mov     ds,ax
        mov     ebx,esp                         ; ds:ebx->CONTEXT
        mov     ax,SEL_DXDATA OR STD_RING
        mov     ss,ax
        mov     esp,offset DXDATA:rgw0Stack     ; ss:esp->exception stack

;
; Push exception frame on exception stack
;
        movzx   eax,word ptr [ebx].CsSegSs
        push    eax
        push    dword ptr [ebx].CsEsp
        push    dword ptr [ebx].CsEFlags
        movzx   eax,word ptr [ebx].CsSegCs
        push    eax
        push    dword ptr [ebx].CsEip
;
; Restore registers
;
        mov     gs,[ebx].CsSegGs
        mov     fs,[ebx].CsSegFs
        mov     es,[ebx].CsSegEs
        mov     ebp,[ebx].CsEbp
        mov     edi,[ebx].CsEdi
        mov     esi,[ebx].CsEsi
        mov     edx,[ebx].CsEdx
        mov     ecx,[ebx].CsEcx
        mov     ax,[ebx].CsSegDs
        push    ax
        push    dword ptr [ebx].CsEbx
        mov     eax,[ebx].CsEax
        pop     ebx
        pop     ds
        db      0eah
        dw      (offset PmFaultEntryVector + 21)
        dw      SEL_DXPMCODE OR STD_RING
EndNpxExceptionHandler:
NpxExceptionHandler endp

DXPMCODE ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\br\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  O extensor do DOS detectou um erro de incompatibilidade de CPU.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  O extensor do DOS detectou um conflito com outro software ',13,10
                db      '  no modo protegido.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  O extensor do DOS encontrou um erro ao inicializar o ',13,10
                db      '  gerenciador de memria estendida.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  O extensor do DOS encontrou um erro no-especfico.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  No h memria convencional suficiente.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  No h memria estendida suficiente.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  O extensor do DOS no pde encontrar os arquivos de',13,10
                db      '  sistema necessrios.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  No  possvel executar no modo padro devido a um',13,10,13,10
                db      '  problema de gerenciamento de memria.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Um driver de dispositivo ou um programa residente na memria'
                db      13,10
                db      '            solicitou que no se carregue agora o Windows no modo padro.'
                db      13,10
                db      '            Remova este programa ou obtenha uma verso mais atualizada'
                db      13,10
                db      '            compatvel com o modo padro do Windows.'
                db      13,10
                db      13,10
                db      '            Pressione "s" para carregar o Windows no modo padro.'
                db      13,10
                db      13,10
                db      '            Pressione qualquer outra tecla para voltar ao DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  Extensor do DOS: Exceo de modo protegido no-capturada.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  Extensor do DOS: Erro interno.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\segdefs.inc ===
; Copyright (c) Microsoft Coropration 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      SEGDEFS.INC  -- Segment Declarations for Dos Extender   *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  12/13/88 (GeneA): reordered segments so that the code       *
;*      segment is last.                                        *
;*                                                              *
;****************************************************************
;
; -------------------------------------------------------
;               DOS EXTENDER SEGMENTS
; -------------------------------------------------------

;; Touch here to force rebuild of DOSX!  EarleH

?DF=1
?PLM=1
?WIN=0
?MEDIUM=1
DOS5=1
IFNDEF WHEN_COMMAND_COM_WORKS
WINDOWS=1
ELSE
WINDOWS=0
ENDIF
include .\cmacros.inc

DXDATA  segment para public 'DATA'

DXDATA  ends


DXSTACK segment para stack 'STACK'

DXSTACK ends


;
; This segment contains both real mode and protected mode code and
; resides in low memory.
DXCODE  segment para public 'CODE'

DXCODE  ends

;
; This segment contains protected mode code only, and is moved up
; into extended memory during the initialization process.

DXPMCODE    segment para public 'PMCODE'

DXPMCODE    ends

; -------------------------------------------------------
;               GROUP DECLARATIONS
; -------------------------------------------------------

DGROUP  group   DXDATA, DXSTACK

; -------------------------------------------------------
;       MS-DOS PROGRAM SEGMENT PREFIX DEFINITION
; -------------------------------------------------------

PSPSEG  segment at  0

fnExit          dw      ?       ;INT 20h instruction for termination linkage
segMemEnd       dw      ?       ;segment address of end of program's memory
rsvd1           db      ?       ;undefined
fnDosFunc       db      5 dup (?)   ;far call to DOS function dispatcher
lpfnParent      dd      ?       ;far pointer to parent program
lpfnInt23       dd      ?       ;previous contents of INT 23h vector (^C)
lpfnInt24       dd      ?       ;previous contents of INT 24h vector
segParentPSP    dw      ?       ;segment address of parent PSP
bFileTable      db      20 dup (?)  ;process file table
segEnviron      dw      ?       ;segment address of environment
lpStack         dd      ?       ;application's SS:SP (updated on each dos call)
cbFileTable     dw      ?       ;size of process file table
lpFileTable     dd      ?       ;far pointer to process file table

        org     5Ch

fcbDefault1     db      10h dup (?) ;default FCB 1
fcbDefault2     db      10h dup (?) ;default FCB 2

        org     80h

cbCommand       db      ?       ;lenght of command string
chCommand       db      7Fh dup (?) ;command string

PSPSEG      ends

; -------------------------------------------------------
;           BIOS DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

BIOS_DATA   segment at  40h     ;BIOS Data segment

        org     67h
IO_ROM_INIT     dw      ?       ;Shutdown code 0Ah will cause the
IO_ROM_SEG      dw      ?       ; bios to return control to the far
                                ; address stored here.
                                ;Shutdown code 09h will cause the
                                ; bios to load SS:SP from here and
                                ; do an IRET.
INTR_FLAG       db      ?

        org     72h
RESET_FLAG      dw      ?       ;For Ctrl-Alt-Del

BIOS_DATA   ends

; -------------------------------------------------------

;****************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\pmdefs.inc ===
; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      PMDEFS.INC      --  80286 Protected Mode Definitions    *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*   7/28/89 jimmat   Changes selectors for Wdeb386 (it now     *
;*                    needs 4, not 2)                           *
;*   3/11/89 jimmat   Added selector for TSS                    *
;*   3/09/89 jimmat   Added selectors for DynaLink call gates   *
;*  02/10/89 (GeneA): reorganized selector definitions for      *
;*      change from small model to medium model                 *
;*  12/01/88 (GeneA): added definitions for SEL_BIOSCODE and    *
;*      SEL_USERSCR                                             *
;*                                                              *
;****************************************************************
;
; -------------------------------------------------------
;                  SELECTOR FIELDS
; -------------------------------------------------------

SELECTOR_RPL    =   00000011b           ;Requested Privilege Level mask
SELECTOR_TI     =   00000100b           ;Table Indicator mask
SELECTOR_INDEX  =   0fff8h              ;Index mask

SELECTOR_PL0    =   00000000b           ;Ring 0 privilege level
SELECTOR_PL1    =   00000001b           ;Ring 1 privilege level
SELECTOR_PL2    =   00000010b           ;Ring 2 privilege level
SELECTOR_PL3    =   00000011b           ;Ring 3 privilege level

SELECTOR_PL_DX  =   SELECTOR_PL3        ;Privilege level used by DOSX

; -------------------------------------------------------
;           ACCESS RIGHTS BIT DEFINITIONS
; -------------------------------------------------------
;
; These are the access rights byte bit position definitions.

; These fields are common to all descriptors
AB_PRESENT  =   10000000b   ;segment present bit
AB_DPL0     =   00000000b   ;ring 0 DPL
AB_DPL1     =   00100000b   ;ring 1 DPL
AB_DPL2     =   01000000b   ;ring 2 DPL
AB_DPL3     =   01100000b   ;ring 3 DPL
AB_DPL      =   01100000b   ;mask for DPL field

;AB_DPL_DX   =  AB_DPL3     ;DPL used by DOSX
AB_DPL_DX   =   (SELECTOR_PL_DX shl 5)      ;DPL used by DOSX

; These fields are relevant to code and data segment descriptors
;   (non-system descriptors)
AB_DATA     =   00010000b   ;data segment
AB_CODE     =   00011000b   ;code segment
AB_STACK    =   00010100b   ;expand down (stack) segment
AB_WRITE    =   00000010b   ;writable data
AB_READ     =   00000010b   ;readable code
AB_CONFORM  =   00000100b   ;conforming code
AB_ACCESSED =   00000001b   ;segment has been accessed
AB_BIG      =   0100000000000000b ; 32 bit segment

; These fields are relevant to system descriptors
AB_INVALID  =   00000000b   ;invalid descriptor
AB_TSS      =   00000001b   ;task state segment descriptor
AB_TSS386   =   00001001b   ;task state segment descriptor 386
AB_BUSY     =   00000010b   ;busy bit for task state descriptor
AB_LDT      =   00000010b   ;local descriptor table descriptor
AB_CALLGATE =   00000100b   ;call gate descriptor
AB_TASKGATE =   00000101b   ;task gate descriptor
AB_INTRGATE =   00000110b   ;interrupt gate descriptor
AB_TRAPGATE =   00000111b   ;trap gate descriptor
AB_IGATE386 =   00001110b   ;80386 interrupt gate descriptor

; These are some common combinations of the above fields making up
; useful access rights bytes.

ARB_CODE0   =   AB_PRESENT+AB_DPL0+AB_CODE+AB_READ      ;ring 0 code segment
ARB_CODE1   =   AB_PRESENT+AB_DPL1+AB_CODE+AB_READ      ;ring 1 code segment
ARB_CODE3   =   AB_PRESENT+AB_DPL3+AB_CODE+AB_READ      ;ring 3 code segment
ARB_CODE_DX =   AB_PRESENT+AB_DPL_DX+AB_CODE+AB_READ    ;DOSX ring code segment

ARB_DATA0NP =              AB_DPL0+AB_DATA+AB_WRITE     ;illegal segment
ARB_DATA0   =   AB_PRESENT+AB_DPL0+AB_DATA+AB_WRITE     ;ring 0 read/write data
ARB_DATA1   =   AB_PRESENT+AB_DPL1+AB_DATA+AB_WRITE     ;ring 1 read/write data
ARB_DATA3   =   AB_PRESENT+AB_DPL3+AB_DATA+AB_WRITE     ;ring 3 read/write data
ARB_DATA_DX =   AB_PRESENT+AB_DPL_DX+AB_DATA+AB_WRITE   ;DOSX ring read/write data

ARB_STACK0  =   AB_PRESENT+AB_DPL0+AB_STACK+AB_WRITE    ;ring 0 stack
ARB_STACK1  =   AB_PRESENT+AB_DPL1+AB_STACK+AB_WRITE    ;ring 1 stack
ARB_STACK3  =   AB_PRESENT+AB_DPL3+AB_STACK+AB_WRITE    ;ring 3 stack
ARB_STACK_DX =  AB_PRESENT+AB_DPL_DX+AB_STACK+AB_WRITE  ;DOSX ring stack

ARB_TRAP0   =   AB_PRESENT+AB_DPL0+AB_TRAPGATE          ;ring 0 trap gate
ARB_TRAP1   =   AB_PRESENT+AB_DPL1+AB_TRAPGATE          ;ring 1 trap gate
ARB_TRAP3   =   AB_PRESENT+AB_DPL3+AB_TRAPGATE          ;ring 3 trap gate
ARB_TRAP_DX =   AB_PRESENT+AB_DPL_DX+AB_TRAPGATE        ;DOSX ring trap gate

ARB_INTR0   =   AB_PRESENT+AB_DPL0+AB_INTRGATE          ;ring 0 interrupt gate
ARB_INTR1   =   AB_PRESENT+AB_DPL1+AB_INTRGATE          ;ring 1 interrupt gate
ARB_INTR3   =   AB_PRESENT+AB_DPL3+AB_INTRGATE          ;ring 3 interrupt gate
ARB_INTR_DX =   AB_PRESENT+AB_DPL_DX+AB_INTRGATE        ;DOSX ring interrupt gate

ARB_INTR0386=   AB_PRESENT+AB_DPL0+AB_IGATE386          ;ring 0 386 int gate
ARB_INTR1386=   AB_PRESENT+AB_DPL1+AB_IGATE386          ;ring 1 386 int gate
ARB_INTR3386=   AB_PRESENT+AB_DPL3+AB_IGATE386          ;ring 3 386 int gate
ARB_INTR_DX386= AB_PRESENT+AB_DPL_DX+AB_IGATE386        ;DOSX ring 386 int gate

ARB_CALL0   =   AB_PRESENT+AB_DPL0+AB_CALLGATE          ;ring 0 call gate
ARB_CALL1   =   AB_PRESENT+AB_DPL1+AB_CALLGATE          ;ring 1 call gate
ARB_CALL3   =   AB_PRESENT+AB_DPL3+AB_CALLGATE          ;ring 3 call gate
ARB_CALL_DX =   AB_PRESENT+AB_DPL_DX+AB_CALLGATE        ;DOSX ring call gate

ARB_TSS1    =   AB_PRESENT+AB_DPL1+AB_TSS               ;ring 1 task state seg
ARB_TSS3    =   AB_PRESENT+AB_DPL3+AB_TSS               ;ring 3 task state seg
ARB_TSS_DX  =   AB_PRESENT+AB_DPL_DX+AB_TSS             ;DOSX ring task state seg

ARB_TSS1386 =   AB_PRESENT+AB_DPL1+AB_TSS386            ;ring 1 386 TSS
ARB_TSS3386 =   AB_PRESENT+AB_DPL3+AB_TSS386            ;ring 3 386 TSS
ARB_TSS_DX386 = AB_PRESENT+AB_DPL_DX+AB_TSS386          ;DOSX ring 386 TSS

ARB_LDT1    =   AB_PRESENT+AB_DPL1+AB_LDT               ;ring 1 local dscr tbl
ARB_LDT3    =   AB_PRESENT+AB_DPL3+AB_LDT               ;ring 3 local dscr tbl
ARB_LDT_DX  =   AB_PRESENT+AB_DPL_DX+AB_LDT             ;DOSX ring local dscr tbl

;--------------------------------------------------------
;       STANDARD DESCRIPTOR TABLE/RING EQUATES
;--------------------------------------------------------

; Currently DOSX is setup to run most of itself and the child app in
; ring 1.  However this may be changed by changing the following equates.

STD_DPL         =       AB_DPL_DX
STD_DATA        =       ARB_DATA_DX
STD_CODE        =       ARB_CODE_DX
STD_STACK       =       ARB_STACK_DX
STD_TRAP        =       ARB_TRAP_DX
STD_INTR        =       ARB_INTR_DX
STD_INTR386     =       ARB_INTR_DX386
STD_CALL        =       ARB_CALL_DX
STD_TSS         =       ARB_TSS_DX
STD_TSS386      =       ARB_TSS_DX386
STD_LDT         =       ARB_LDT_DX

STD_TBL         =       SELECTOR_TI
STD_RING        =       SELECTOR_PL_DX OR SELECTOR_TI
STD_TBL_RING    =       (STD_TBL or STD_RING)

;
; Code descriptor type for handling processor exceptions.
;
EH_CODE         =       ARB_CODE0
EH_RING         =       SELECTOR_PL0
EH_RING_MASK    =       NOT 3
EH_DATA         =       ARB_DATA0

; -------------------------------------------------------
;           DESCRIPTOR STRUCTURE DEFINITIONS
; -------------------------------------------------------

; This structure defines the layout of a segment descriptor on the '286
; These can appear in either the local descriptor table or the global
; descriptor table.  The local descriptor table descriptors also fit into
; this format, but they can only appear in the global descriptor table.

SEGDSCR     struc
cbLimit         dw      0       ;segment size limit
adrBaseLow      dw      0       ;low word of segment base address
adrBaseHigh     db      0       ;high byte of segment base address
arbSegAccess    db      0       ;access rights byte
rsvdSeg         dw      0       ;Intel reserved, must be 0
SEGDSCR     ends

SEGDSCR386      struc
cbLimit386      dw      0       ;segment size limit
adrwBaseLow386  dw      0       ;low word of segment base address
adrbBaseMid386  db      0       ;mid byte of segment base address
arbSegAccess386 db      0       ;access rights byte
cbLimitHi386    db      0       ;hi nybble of size limit
adrbBaseHi386   db      0       ;high byte of segment base address
SEGDSCR386      ends

; This structure defines the layout of gate descriptors.  These can appear
; in any of the descriptor tables.  Only Interrupt Gate, Trap Gate, and
; Task Gate descriptors can appear in the interrupt descriptor table.

GATEDSCR    struc
offDest         dw      0       ;destination function offset (not used in
                                ; task gates)
selDest         dw      0       ;destination function segment selector
cwParam         db      0       ;count of parameter words to transfer
arbGate         db      0       ;access rights byte
rsvdGate        dw      0       ;Intel reserved, must be 0
GATEDSCR    ends

; This is the structure defines the layout of a Task State Segment
; descriptor.  This can only appear in the Global Descriptor Table

TSSDSCR     struc
cbTssLimit      dw  0           ;segment size limit
adrTssBaseLow   dw  0           ;low word of segment base address
adrTssBaseHigh  db  0           ;high byte of segment base address
arbTssAccess    db  0           ;access rights byte
rsvdTss         dw  0           ;Intel reserved, must be 0
TSSDSCR     ends

; -------------------------------------------------------
;               80286 TASK STATE SEGMENT
; -------------------------------------------------------
;
; This structure describes the layout of an 80286 task state
; segment.

TSS286  struc
tss_backlink    dw  ?           ;backlink to previous task
tss_sp0         dw  ?           ;privelege level 0 stack pointer
tss_ss0         dw  ?           ;privelege level 0 stack segment
tss_sp1         dw  ?           ;privelege level 1 stack pointer
tss_ss1         dw  ?           ;privelege level 1 stack segment
tss_sp2         dw  ?           ;privelege level 2 stack pointer
tss_ss2         dw  ?           ;privelege level 2 stack segment
tss_ip          dw  ?           ;initial instruction pointer
tss_flags       dw  ?
tss_ax          dw  ?
tss_cx          dw  ?
tss_dx          dw  ?
tss_bx          dw  ?
tss_sp          dw  ?
tss_bp          dw  ?
tss_si          dw  ?
tss_di          dw  ?
tss_es          dw  ?
tss_cs          dw  ?
tss_ss          dw  ?
tss_ds          dw  ?
tss_ldt         dw  ?           ;local descriptor table for this task

TSS286  ends

; -------------------------------------------------------
;               80386 TASK STATE SEGMENT
; -------------------------------------------------------
;
; This structure describes the layout of an 80386 task state
; segment.

TSS386  struc
ts3_backlink    dw  0           ;backlink to previous task
                dw  0
ts3_esp0        dd  0           ;privelege level 0 stack pointer
ts3_ss0         dw  0           ;privelege level 0 stack segment
                dw  0
ts3_esp1        dd  0           ;privelege level 1 stack pointer
ts3_ss1         dw  0           ;privelege level 1 stack segment
                dw  0
ts3_esp2        dd  0           ;privelege level 2 stack pointer
ts3_ss2         dw  0           ;privelege level 2 stack segment
                dw  0
ts3_eip         dd  0           ;initial instruction pointer
ts3_cr3         dd  0
ts3_eflags      dd  0
ts3_eax         dd  0
ts3_ecx         dd  0
ts3_edx         dd  0
ts3_ebx         dd  0
ts3_esp         dd  0
ts3_ebp         dd  0
ts3_esi         dd  0
ts3_edi         dd  0
ts3_es          dw  0
                dw  0
ts3_cs          dw  0
                dw  0
ts3_ss          dw  0
                dw  0
ts3_ds          dw  0
                dw  0
ts3_fs          dw  0
                dw  0
ts3_gs          dw  0
                dw  0
ts3_ldt         dw  0           ;local descriptor table for this task
                dw  0
ts3_iomap       dw  0
                dw  0

TSS386  ends


; -------------------------------------------------------
;               EXCEPTION VECTORS
; -------------------------------------------------------

; These are the interrupt vector numbers for the exception
; interrupts reserved by the 80286/80386.

EXC_DIV0        =   0           ;divide error
EXC_SINGLESTEP  =   1           ;single step
EXC_NMI         =   2           ;NMI interrupt
EXC_BREAKPOINT  =   3           ;breakpoint interrupt
EXC_INTO        =   4           ;overflow interrupt
EXC_BOUND       =   5           ;bounds overflow exception
EXC_OPCODE      =   6           ;invalid opcode exception
EXC_COPROCESSOR =   7           ;processor extension not available
EXC_DOUBLE      =   8           ;double fault
EXC_XOVERRUN    =   9           ;coprocessor segment overrun
EXC_TSS         =   10          ;invalid task state segment exception
EXC_NOTPRESENT  =   11          ;segment not present exception
EXC_STACK       =   12          ;stack overrun, or stack segment not present
EXC_GP          =   13          ;general protection exception
EXC_PF          =   14          ;page fault

; -------------------------------------------------------
;           GLOBAL DESCRIPTOR DECLARATIONS
; -------------------------------------------------------
;
;   The following symbols define the segment descriptors that
;   are statically defined in the Dos Extender.
;
;   NOTE:
;   These selector definitions assume that codeview is running
;   at privelege level 0.  If codeview is running at another
;   privelege level, the RPL fields must be adjusted.
;
;   Global Descriptor Table Conventions used in the Dos Extender

SEL_NULL        = 00h           ;null selector

SEL_GDT         = 80h           ;read/write data segment pointing to the
                                ; global descriptor table
SEL_IDT         = 88h           ;read/write data segment pointing to the
                                ; protected mode interrupt descriptor table
SEL_RMIVT       = 90h           ;read/write data segment pointing to the
                                ; real mode interrupt vector table
SEL_PSP         = 98h           ;Dos Extender PSP
SEL_ENVIRON     = 0A0h          ;Dos Extender Environment
SEL_BIOSCODE    = 0A8h          ;points at segment F000
SEL_DXDATA      = 0B0h          ;Dos Extender data segment
SEL_BIOSDATA    = 0B8h          ;PC BIOS data segment
SEL_DXPMCODE    = 0C0h          ;Dos Extender extended memory code segment
SEL_DXCODE      = 0C8h          ;Dos Extender low memory code segment
SEL_LDT_ALIAS   = 0D0h          ;read/write alias to LDT

;SEL_VDMTIB      = 0D8h          ;used by DOSX to access TIB

SEL_EH          = 0E0h          ;Ring 0 segment code for handling processor
                                ;exceptions in PMODE

SEL_DOSSCR      = 0E8h

SEL_DXDATA0     = 0f0h
SEL_DXCODE0     = 0f8h
;SEL_RZIRET      = 0100h
SEL_LDT         = 0108h
;SEL_RESET       = 0110h
SEL_TSS         = 0118h
SEL_TSS_ALIAS   = 0120h

SEL_NBSCRATCH   = 0128h   

SEL_WOW_LDT     = 0130h         ; readonly LDT selector for WOW kernel

SEL_NPXHDLR     = 0138h         ; selector for NpxExceptionHandler

SEL_IRETHOOK    = 0140h
SEL_NBPMCODE    = 0148H          ; net bios anr handler cs
;
; Size of the GDT.
;
GDT_SIZE        = (SEL_NBPMCODE + 8)
GDT_SELECTORS   = (GDT_SIZE shr 3)

;
; Special LDT selectors.
;

SEL_DPMI_FIRST  =      0        ; first reserved DPMI LDT selector
C_DPMI_RESERVED =      10h      ; count of reserved DPMI LDT selectors
SEL_DPMI_LAST   =      (C_DPMI_RESERVED - 1) * 8
                                ; last reserved DPMI LDT selector

SEL_SCR0        = SEL_NBPMCODE + 8

                                ;scratch selector 0
SEL_SCR1        = SEL_SCR0 + 8  ;scratch selector 1
SEL_USERSCR     = SEL_SCR1 + 8  ;user scratch selector. This is used for
                                ; temporary return values to user from
                                ; system and bios calls
SEL_USER_STACK  = SEL_USERSCR + 8
SEL_USER        = SEL_USER_STACK + 8
; -------------------------------------------------------
; -------------------------------------------------------
; -------------------------------------------------------

;****************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\chp\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\fi\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\cs\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Rozen systm DOS detekoval neshodn procesory (CPU).',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Rozen systm DOS detekoval konflikt s dalm softwarem ',13,10
                db      '  pro chrnn reim.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Rozen systm DOS narazil na chybu pi inicializaci sprvce ',13,10
                db      '  rozen pamti.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Rozen systm DOS narazil na nespecifikovanou chybu.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Nen dostatek konvenn pamti.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Nen dostatek rozen pamti.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Rozen systm DOS nenalezl potebn systmov soubory.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Nebylo mon spustit ve standardnm reimu: Problm sprvce pamti.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Ovlada zazen i program TSR vyaduje, aby se systm Windows'
                db      13,10
                db      '            ve standardnm reimu nespustil nyn. Bu tento program odstrate,'
                db      13,10
                db      '            nebo si od dodavatele vydejte aktualizaci kompatibiln'
                db      13,10
                db      '            se standardnm reimem systmu Windows.'
                db      13,10
                db      13,10
                db      '            Stiskem "y" mete spustit Windows ve standardnm reimu.'
                db      13,10
                db      13,10
                db      '            Jakoukoliv jinou klvesou se vrtte do systmu DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  Rozen DOS: Nezachycen vyjmka chrnnho reimu.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  Rozen DOS: Intern chyba.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\da\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\chs\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\cht\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\es\dxmsg.asm ===
PAGE    ,132
	TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

	public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
	public  ER_EXTMEM, ER_NOEXE

if      VCPI
	public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10                
		db      '  El DOS extendido ha detectado un conflicto de la CPU.',13,10
                                    db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  El DOS extendido ha detectado un conflicto con otro programa ',13,10
		db      '  en modo protegido.',13,10
		db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  El DOS extendido ha encontrado un error al inicializar el ',13,10
		db      '  administrador de memoria extendida.',13,10
		db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  El DOS extendido ha encontrado un error no especificado.'
		db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  Memoria convencional insuficiente.',13,10,13,10
		db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  Memoria extendida insuficiente.',13,10,13,10
		db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  El DOS extendido no ha podido encontrar los archivos de sistema necesarios.',13,10,13,10
		db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
		db      '  No se puede utilizar el Modo estndar debido a un problema de gestin de memoria.'
		db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
		db      '            Un controlador de dispositivo o un programa residente en memoria'
		db      13,10
		db      '            ha solicitado que no se cargue Windows en Modo estndar. Quite'
		db      13,10
		db      '            este programa o consiga una versin actualizada que sea compatible'
		db      13,10
		db      '            con Windows en Modo estndar.'
		db      13,10
		db      13,10
		db      '            Presione "s" para cargar Windows en Modo estndar de todas formas.'
		db      13,10
		db      13,10
		db      '            Presione cualquier otra tecla para volver a DOS.'
		db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
	public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
		db      '  DOS extendido: excepcin en modo protegido no capturada.',13,10,'$'

	public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
		db      '  DOS Extender: error interno.',13,10,'$'

DXPMCODE ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\jpn\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\el\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\kor\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\fr\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  L''unit d''extension DOS a dtect une UC qui ne correspond pas.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  L''unit d''extension DOS a dtect un conflit avec un autre logiciel',13,10
                db      '  en mode protg.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  L''unit d''extension DOS a rencontr une erreur',13,10
                db      '  d''initialisation dans le gestionnaire de mmoire tendue.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  L''unit d''extension DOS a rencontr une erreur non-spcifique.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  Il n''y a pas suffisamment de mmoire conventionnelle.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  Il n''y a pas suffisamment de mmoire tendue.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  L''unit d''extension DOS n''a pas pu trouver les fichiers systme',13,10,13,10
                db      '  ncessaires  son excution.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Une erreur du gest. de mmoire empche l''excution en mode standard.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Un pilote de priphrique ou un TSR a demand que le mode standard'
                db      13,10
                db      '            de Windows ne soit pas charg maintenant. Supprimez ce programme, ou'
                db      13,10
                db      '            procurez vous une mise  jour compatible avec le mode standard de'
                db      13,10
                db      '            Windows auprs de votre fournisseur.'
                db      13,10
                db      13,10
                db      '            Appuyez sur "o" pour charger quand mme le mode standard de Windows.'
                db      13,10
                db      13,10
                db      '            Appuyez sur n''importe quelle autre touche pour sortir du DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  Unit d''extension DOS: Exception en mode protg non capture.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  Unit d''extension DOS: Erreur interne.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\no\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\psu\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\ger\dxmsg.asm ===
PAGE    ,132
	TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

	public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
	public  ER_EXTMEM, ER_NOEXE

if      VCPI
	public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Es wurde eine CPU-Unvertrglichkeit entdeckt.',13,10
		db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Es ist ein Konflikt mit anderer im geschtzten Modus ',13,10
		db      '  ausgefhrten Software aufgetreten.',13,10
		db      13,10,'$'

;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Bei der Initialisierung des Erweiterungsspeichers ist',13,10
		db      '  ein Fehler aufgetreten.',13,10
		db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Es ist ein nicht zu bestimmender Fehler aufgetreten.'
		db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Es steht nicht gengend konventioneller Arbeitsspeicher ',13,10
		db      '  zur Verfgung.',13,10,13,10
		db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Es steht nicht gengend Erweiterungsspeicher ',13,10
		db      '  zur Verfgung.',13,10,13,10
		db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Bentigte Systemdateien konnten nicht gefunden werden.',13,10,13,10
		db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
		db      '  Wegen eines Speichermanager-Problems kann der Standard-Modus ',13,10,13,10
		db      '  nicht verwendet werden.'
		db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
		db      '            Ein Gertetreiber oder TSR hat verlangt, dass Windows'
		db      13,10
		db      '            jetzt nicht im Standard-Modus gestartet wird.'
		db      13,10
		db      '            Entfernen Sie dieses Programm, oder verlangen Sie'
		db      13,10
		db      '            von Ihrem Hersteller ein Programm, das mit '
		db      13,10
		db      '            Windows im Standard-Modus kompatibel ist.'
		db      13,10
		db      13,10
		db      '            Drcken Sie die Y-TASTE, um Windows dennoch'
		db      '            im Standard-Modus zu starten.'
		db      13,10
		db      13,10
		db      '            Drcken Sie eine andere Taste, um abzubrechen und '
		db      '            zu DOS zu gelangen.'
		db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
	public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
		db      '  DOS Extender: Nicht behebbare Ausnahme im geschtzten Modus.',13,10,'$'

	public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
		db      '  DOS Extender: Interner Fehler.',13,10,'$'

DXPMCODE ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\nl\dxmsg.asm ===
PAGE    ,132
	TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

	public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
	public  ER_EXTMEM, ER_NOEXE

if      VCPI
	public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Verkeerd type CPU.',13,10
		db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Er is een conflict met andere software die in protected-modus ',13,10
		db      '  wordt uitgevoerd.',13,10
		db	13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Er is een fout opgetreden bij het initialiseren van de ',13,10
		db      '  Extended Memory Manager (XMS-stuurprogramma).',13,10
		db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Er is een algemene fout opgetreden.'
		db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Er is onvoldoende conventioneel geheugen beschikbaar.',13,10,13,10
		db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Er is onvoldoende extended memory beschikbaar.',13,10,13,10
		db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  De voor het starten benodigde systeembestanden zijn niet gevonden.',13,10,13,10
		db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
		db      '  Kan niet in de standaardmodus starten vanwege een probleem met ',13,10
		db      '  het geheugenbeheerprogramma.'
		db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
		db      '            Een stuurprogramma of TSR heeft opdracht gegeven dat Windows'
		db      13,10
		db      '            nu niet in de standaardmodus kan worden geladen. Verwijder dit'
		db      13,10
		db      '            programma of gebruik een bijgewerkte versie van de fabrikant'
		db      13,10
		db      '            die compatibel is met Windows in standaardmodus.'
		db      13,10
		db      13,10
		db      '            Druk op "j" als u Windows toch in de standaardmodus wilt laden.'
		db      13,10
		db      13,10
		db      '            Druk op een willekeurige toets als u DOS wilt afsluiten.'
		db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
	public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
		db      '  DOS Extender: niet-afgevangen uitzondering van protected-modus.',13,10,'$'

	public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
		db      '  DOS Extender: interne fout.',13,10,'$'

DXPMCODE ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\it\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  DOS extender ha rilevato un''incompatibilit della CPU.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  DOS extender ha rilevato un conflitto con altro software ',13,10
                db      '  in modalit protetta.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  DOS extender ha rilevato un errore durante l''inizializzazione',13,10
                db      '  del gestore di memoria estesa.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  DOS extender ha rilevato un errore non specifico.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  Memoria convenzionale insufficiente.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  Memoria estesa insufficiente.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  DOS extender non ha trovato i file di sistema necessari',13,10
                db      '  per l''esecuzione.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Impossibile eseguire in modalit Standard per un problema di gestione memoria.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Un driver o TSR di periferica ha impedito il caricamento'
                db      13,10
                db      '            di Windows in questa modalit standard.  Rimuovere questo'
                db      13,10
                db      '            programma, o richiedere un aggiornamento che sia compatibile'
                db      13,10
                db      '            con Windows in modalit standard.'
                db      13,10
                db      13,10
                db      '            Premere "s" per caricare ugualmente Windows in modalit standard.'
                db      13,10
                db      13,10
                db      '            Premere un altro tasto per ritornare a DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS extender: exception senza trap in modalit protetta.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS extender: errore interno.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\hu\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  A DOS vdett md bvtje CPU hibt szlelt.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  Az alkalmazs tkzik egy msik vdett md  ',13,10
                db      '  programmal.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  A DOS vdett md bvt nem tudta alaphelyzetbe hozni a ',13,10
                db      '  kiterjesztettmemria-kezelt.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  A DOS vdett md bvt meghatrozatlan hibt szlelt.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  Nincs elegend hagyomnyos memria.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  Nincs elegend kiterjesztett memria.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  DOS vdett md bvt nem tallja a futtatshoz szksges rendszerfjlokat.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  A memriakezel hibja miatt a programot nem lehet Standard zemmdban futtatni.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Az illesztprogram vagy TSR nem engedi, hogy a Windows '
                db      13,10
                db      '            standard zemmdban tltdjn be. Tvoltsa el a programot, vagy '
                db      13,10
                db      '            szerezze be egy jabb vltozatt, amely kompatbilis a '
                db      13,10
                db      '            Windows standard zemmdjval.'
                db      13,10
                db      13,10
                db      '            Az "y" billentyt letve a Windows standard mdban indul.'
                db      13,10
                db      13,10
                db      '            Brmely ms billentyt letve visszajut a DOS-hoz.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS vdett md bvt: nem kezelt vdett md kivtel.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      ' DOS vdett md bvt: bels hiba.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\pl\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Extender DOS wykry niezgodno procesora.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Extender DOS wykry konflikt z innym oprogramowaniem  ',13,10
                db      '  trybu chronionego.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Extender DOS napotka bd podczas inicjowania menedera ',13,10
                db      '  pamici rozszerzonej typu extended.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Extender DOS napotka nieokrelony bd.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Za mao pamici konwencjonalnej.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Za mao pamici rozszerzonej typu extended.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Extender DOS nie znalaz niezbdnych plikw systemowych.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      ' Nie mona uruchomi w trybie standardowym z powodu problemu'
                db      13,10
                db      ' z menederem pamici.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Sterownik urzdzenia lub program TSR zabroni zaadowania trybu'
                db      13,10
                db      '            standardowego Windows. Usu ten program lub uzyskaj uaktualnienie'
                db      13,10
                db      '            zgodne z trybem standardowym systemu Windows od producenta tego'
                db      13,10
                db      '            programu.'
                db      13,10
                db      13,10
                db      '            Nacinij "t", aby mimo wszystko zaadowa tryb standardowy Windows.'
                db      13,10
                db      13,10
                db      '            Nacinij dowolny inny klawisz, aby wyj do systemu DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Nieznany wyjtek trybu chronionego.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Bd wewntrzny.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\tst\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\pt\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  O expansor de DOS detectou uma discordncia de CPU.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  O expansor de DOS detectou um coflito com outro software ',13,10
                db      '  de modo protegido.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  O expansor de DOS encontrou um erro ao inicializar o gestor de ',13,10
                db      '  memria de extenso.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  O expansor de DOS encontrou um erro no especificado.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  A memria convencional  insuficiente.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  A memria de extenso  insuficiente.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  O expansor de DOS no encontrou ficheiros de sistema necessrios.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Impossvel executar em modo padro dado um problema no gestor de memria.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Um controlador de dispositivo ou TSR exigiu que o Windows em modo'
                db      13,10
                db      '            padro no fosse agora carregado. Remova este programa ou'
                db      13,10
                db      '            obtenha uma actualizao que seja compatvel com o Windows em'
                db      13,10
                db      '            modo padro.'
                db      13,10
                db      13,10
                db      '            Prima "s" para carregar o Windows em modo padro de qq. forma.'
                db      13,10
                db      13,10
                db      '            Prima qq. outra tecla para sair para DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  Expansor de DOS: excepo de modo protegido no capturada.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  Expansor de DOS: erro interno.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\usa\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\ru\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '  ७ DOS 㦥  ᮮ⢥騩 ⨯ CPU.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '  ७ DOS 㦥 䫨  㣨 ணࠬ ',13,10
                db      '  ᯥ祭, ࠡ饬  饭 ०.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '  ७ DOS 㦨 訡  樠樨',13,10
                db      '  ᯥ ⥫쭮  (XMS).',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '  ७ DOS 㦨  訡.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '   ꥬ 筮 .',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '   ꥬ ⥫쭮  (XMS).',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '  ७ DOS  㦨 室  ᪠ ⥬ 䠩.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '    ⠭ ० - 訡 ᯥ .'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            ࠩ ன⢠  १⭠ ணࠬ (TSR) ॡ,'
                db      13,10
                db      '            ⮡ ⠭ ० Windows ᥩ  㦠.'
                db      13,10
                db      '              ணࠬ     ᮢ⨬'
                db      13,10
                db      '             ⠭ ० Windows.'
                db      13,10
                db      13,10
                db      '              "Y", ⮡  ࠢ 㧨'
                db      13,10
                db      '            ⠭ ० Windows.'
                db      13,10
                db      '               , ⮡   DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  ७ DOS:  訡 饭 ०.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  ७ DOS: ७ 訡.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\sv\dxmsg.asm ===
PAGE    ,132
	TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

	public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
	public  ER_EXTMEM, ER_NOEXE

if      VCPI
	public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge;',13,10,13,10
		db      '  DOS-utkaren upptckte en avvikelse i CPU:n.',13,10
		db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge;',13,10,13,10
		db      '  DOS-utkaren har upptckt en konflikt med andra programvaror',13,10
		db      '  i skyddat lge.',13,10
		db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge;',13,10,13,10
		db      '  Det uppstod ett fel med DOS-utkaren vid initiering av',13,10
		db      '  utkad minneshanteraren.',13,10
		db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge:',13,10,13,10
		db      '  Det uppstod ett ospecificerat fel med DOS-utkaren.'
		db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge:',13,10,13,10
		db      '  Det finns inte tillrckligt med konventionellt minne.',13,10,13,10
		db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge:',13,10,13,10
		db      '  Det finns inte tillrckligt med utkat minne.',13,10,13,10
		db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge:',13,10,13,10
		db      '  DOS-utkaren kunde inte hitta systemfilerna som behvs fr att kra.',13,10,13,10
		db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
		db      '  Det gr inte att kra i standardlge pga problem med minneshanteraren.'
		db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
		db      '            En drivrutin eller TSR har efterfrgat standardlge, vilket Windows'
		db      13,10
		db      '            fr tillfllet inte kr. Ta bort programmet eller'
		db      13,10
		db      '            anskaffa en uppdatering som r kompatibel med Windows'
		db      13,10
		db      '            standardlge frn din leverantr.'
		db      13,10
		db      13,10
		db      '            Tryck p "j" fr att lsa in standardlge.'
		db      13,10
		db      13,10
		db      '            Tryck p valfri annan tangent fr att avsluta DOS.'
		db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
	public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
		db      '  DOS-utkare: Undantagsfall, skyddat lge.',13,10,'$'

	public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
		db      '  DOS-utkare: Internt fel.',13,10,'$'

DXPMCODE ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi\tr\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      ' DOS uzatcs bir CPU uyumazl alglad.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      ' DOS uzatcs dier korumal yazlmla ',13,10
                db      ' bir akma alglad.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      ' DOS uzatcs uzatlm bellek yneticisini balatrken bir',13,10
                db      '  hatayla karlat.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      '  DOS uzatcs belirli olmayan bir hatayla karlat.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      '  Yeterli geleneksel bellek yok.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      '  Yeterli uzatlm bellek yok.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      '  DOS uzatcs altrmak iin gerekli sistem dosyalarn bulamad.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Bellek yneticisi sorunu nedeniyle Standart Kip''te altrlamyor.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Bir aygt srcs veya TSR imdi Standart Kipte'
                db      13,10
                db      '            Windows yklenmemesini istedi.  Bu program kaldrn veya'
                db      13,10
                db      '            salaycnzdan Standart Kip Windows ile uyumlu bir'
                db      13,10
                db      '            gncelletirme edinin.'
                db      13,10
                db      13,10
                db      '            Yine de Standart Kip Windows''u yklemek iin "e"ye basn.'
                db      13,10
                db      13,10
                db      '            DOS''a dnmek iin herhangi bir tua basn.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Uzatcs: Yakalanmam korumal kip zel durumu.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Uzatcs:  hata.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\buffer.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Buffer.c

Abstract:

    This module contains routines to perform the actual buffering of data
    for dpmi api translation support.

Author:

    Dave Hastings (daveh) 30-Nov-1992

Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 - Updates for the 486 emulator

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include "..\softpc.new\host\inc\host_rrr.h"
#include "..\softpc.new\host\inc\nt_uis.h"

PUCHAR
DpmiMapAndCopyBuffer(
    PUCHAR Buffer,
    USHORT BufferLength
    )
/*++

Routine Description:

    This routine selects the appropriate buffer for the translation,
    and copies the high memory buffer to it.

Arguments:

    Buffer -- Supplies buffer in high memory
    BufferLength -- Supplies the length of the buffer

Return Value:

    Returns a pointer to the translation buffer

--*/
{
    PUCHAR NewBuffer;

    //
    // if the buffer is already in low memory, don't do anything
    //

    if ((ULONG)(Buffer + BufferLength - IntelBase) < MAX_V86_ADDRESS) {
        return Buffer;
    }

    NewBuffer = DpmiAllocateBuffer(BufferLength);
    CopyMemory(NewBuffer, Buffer, BufferLength);

    return NewBuffer;
}

VOID
DpmiUnmapAndCopyBuffer(
    PUCHAR Destination,
    PUCHAR Source,
    USHORT BufferLength
    )
/*++

Routine Description:

    This routine copies the information back to the high memory buffer

Arguments:

    Destination -- Supplies the destination buffer
    Source -- Supplies the source buffer
    BufferLength -- Supplies the length of the information to copy

Return Value:

    None.

--*/
{

    //
    // If the addresses are the same, don't do anything
    //
    if (Source == Destination) {
        return;
    }

    CopyMemory(Destination, Source, BufferLength);

    //
    // Free the buffer
    //

    DpmiFreeBuffer(Source, BufferLength);
}


USHORT
DpmiCalcFcbLength(
    PUCHAR FcbPointer
    )
/*++

Routine Description:

    This routine calculates the length of an FCB.

Arguments:

    FcbPointer -- Supplies the Fcb

Return Value:

    Length of the fcb in bytes

--*/
{
    if (*FcbPointer == 0xFF) {
        return 0x2c;
    } else {
        return 0x25;
    }
}

PUCHAR
DpmiMapString(
    USHORT StringSeg,
    ULONG StringOff,
    PWORD16 Length
    )
/*++

Routine Description:

    This routine maps an asciiz string to low memory

Arguments:

    StringSeg -- Supplies the segment of the string
    StringOff -- Supplies the offset of the string

Return Value:

    Pointer to the buffered string or NULL in error case

;   NOTE:
;       DOS has a tendency to look one byte past the end of the string "\"
;       to look for ":\" followed by a zero.  For this reason, we always
;       map three extra bytes of every string.

--*/
{
    USHORT CurrentChar = 0;
    PUCHAR String, NewString = NULL;
    ULONG Limit;
    BOOL SetNull = FALSE;

    String = VdmMapFlat(StringSeg, StringOff, VDM_PM);

    //
    // Scan string for NULL
    //

    GET_SHADOW_SELECTOR_LIMIT(StringSeg, Limit);
    if (Limit == 0 || StringOff >= Limit) {
        return NULL;
    }

    Limit -= StringOff;
    while (CurrentChar <= (USHORT)Limit) {
        if (String[CurrentChar] == '\0') {
            break;
        }
        CurrentChar++;
    }

    if (CurrentChar > (USHORT)Limit) {

        //
        // If we didn't find the end, move CurrentChar back to the end
        // of the segmen and only copy 100h bytes maximum.
        //

        SetNull = TRUE;
        CurrentChar--;
        if (CurrentChar > 0x100) {
            CurrentChar = 0x100;
        }
    }

    //
    // CurrentChar points to the last char that we need to copy and
    // most importantly CurrentChar is still within the segment.
    //

    ASSERT (CurrentChar <= (USHORT)Limit);

    //
    // If there are 3 bytes after the string, copy the extra 3 bytes
    //
    if ((CurrentChar + 3) <= (USHORT)Limit) {
        CurrentChar += 3;
    } else {
        CurrentChar = (USHORT)Limit;
    }

    //
    // The length is one based.  The index is zero based
    //
    *Length = CurrentChar + 1;

    NewString = DpmiMapAndCopyBuffer(String, (USHORT) (CurrentChar + 1));
    if (SetNull) {
        NewString[CurrentChar] = '\0';
    }
    return NewString;

}

PUCHAR
DpmiAllocateBuffer(
    USHORT Length
    )
/*++

Routine Description:

    This routine allocates buffer space from the static buffer in low
    memory.

Arguments:

    Length -- Length of the buffer needed

Return Value:

    Returns pointer to the buffer space allocated
    Note, this routine never fails.  If we are out of buffer space, this is
    considered as a BugCheck condition for NTVDM.  NtVdm will be terminated.

--*/
{
    //
    // If the data fits in the small buffer, use it
    //
    if ((Length <= SMALL_XLAT_BUFFER_SIZE) && !SmallBufferInUse) {
        SmallBufferInUse = TRUE;
        return SmallXlatBuffer;
    }

    if (Length <= (LARGE_XLAT_BUFFER_SIZE - LargeBufferInUseCount)) {
        LargeBufferInUseCount += Length;
        return (LargeXlatBuffer + LargeBufferInUseCount - Length);
    }

    //
    // Whoops!  No buffer space available.
    // This is an internal error.  Terminate ntvdm.
    //
    ASSERT(0);      // this is an internal error
    DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
    return (PUCHAR)0xf00df00d;
}

VOID
DpmiFreeBuffer(
    PUCHAR Buffer,
    USHORT Length
    )
/*++

Routine Description:

    Frees buffer space allocated using DpmiAllocateBuffer

Arguments:

    Buffer -- Supplies a pointer to the buffer allocated above
    Length -- Length of the buffer allocated

Return Value:

    None.

--*/
{
    //
    // Free the buffer
    //

    if (Buffer == SmallXlatBuffer) {
        SmallBufferInUse = FALSE;
    }

    if ((Buffer >= LargeXlatBuffer) &&
        (Buffer < (LargeXlatBuffer + LARGE_XLAT_BUFFER_SIZE))
    ) {
        LargeBufferInUseCount -= Length;
    }
}

VOID
DpmiFreeAllBuffers(
    VOID
    )
/*++

Routine Description:

    This routine frees all of the currently allocated buffer space.

Arguments:


Return Value:

    None.

--*/
{
    SmallBufferInUse = FALSE;
    LargeBufferInUseCount = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\data.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This module contains the x86 specific data for the dpmi library.
    Common data is found in dpmi32.c

Author:

    Dave Hastings (daveh) creation-date 09-Feb-1994

Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 Updates for the 486 emulator

--*/
#include "precomp.h"
#pragma hdrstop

//
// Information about the current PSP
//
USHORT CurrentPSPSelector;
ULONG  CurrentPSPXmem;

//
// Table of selector bases and limits
//
ULONG FlatAddress[LDT_SIZE];

//
// LDT information
//

PLDT_ENTRY Ldt;
USHORT LdtSel;
USHORT LdtMaxSel = 0;
USHORT LdtUserSel = 0;

//
// Address of 16 bit Idt
//
PIDT_ENTRY Idt;


//
// Pointers to the low memory buffers
//
PUCHAR SmallXlatBuffer;
PUCHAR LargeXlatBuffer;
BOOL SmallBufferInUse;
USHORT LargeBufferInUseCount = 0;
//
// Segment of realmode dosx stack
//
USHORT DosxStackSegment;

//
// segment of realmode dosx code
//
USHORT DosxRmCodeSegment;

//
// selector of realmode code
//
USHORT DosxRmCodeSelector;

//
// Address of pointer to next frame on Dosx stack
//
PWORD16 DosxStackFramePointer;

//
// Size of dosx stack frame
//
USHORT DosxStackFrameSize;

//
// Dpmi flags for the current application
//
USHORT CurrentAppFlags;

//
// Address of Bop fe for ending interrupt simulation
//
ULONG RmBopFe;
ULONG PmBopFe;

//
// Address of buffer for DTA in Dosx
//
PUCHAR DosxDtaBuffer;

//
// Information about the current DTA
//
// N.B.  The selector:offset, and CurrentDta following MAY point to
//       different linear addresses.  This will be the case if the
//       dta selector is in high memory.
//       CurrentDosDta holds the "cached" value of the Dta that has
//       actually been issued to DOS.
PUCHAR CurrentDta;
PUCHAR CurrentPmDtaAddress;
PUCHAR CurrentDosDta;
USHORT CurrentDtaSelector;
USHORT CurrentDtaOffset;

//
// These are the functions in WOW (GlobalDOSAlloc, GlobalDOSFree)
// that are used as helper functions to perform DPMI func's 100,101
// when we are running under WOW.
//

USHORT WOWAllocSeg = 0;
USHORT WOWAllocFunc;
USHORT WOWFreeSeg = 0;
USHORT WOWFreeFunc;

//
// Selector limits
//
#if DBG
ULONG SelectorLimit[LDT_SIZE];
PULONG ExpSelectorLimit = SelectorLimit;
#else
PULONG ExpSelectorLimit = NULL;
#endif

//
// Start of intel address space in process memory
//
ULONG IntelBase = 0;

//
// Variables used for supporting stack switching
// (on x86, these are in the vdmtib)
//
#ifndef i386
USHORT LockedPMStackSel;
ULONG LockedPMStackCount;
ULONG PMLockOrigEIP;
ULONG PMLockOrigSS;
ULONG PMLockOrigESP;

ULONG DosxFaultHandlerIret;
ULONG DosxFaultHandlerIretd;
ULONG DosxIntHandlerIret;
ULONG DosxIntHandlerIretd;
ULONG DosxRMReflector;

#endif

VDM_INTERRUPTHANDLER DpmiInterruptHandlers[256] = {0};
VDM_FAULTHANDLER DpmiFaultHandlers[32] = {0};

ULONG DosxIret;
ULONG DosxIretd;

USHORT PMReflectorSeg;

ULONG DosxRmSaveRestoreState;
ULONG DosxPmSaveRestoreState;
ULONG DosxRmRawModeSwitch;
ULONG DosxPmRawModeSwitch;

ULONG DosxVcdPmSvcCall;
ULONG DosxMsDosApi;
ULONG DosxXmsControl;
ULONG DosxHungAppExit;

//
// WORKITEM: should be in VDMTIB
//
ULONG LastLockedPMStackSS;
ULONG LastLockedPMStackESP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\dosmem.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dosmem.c

Abstract:

    This module contains routines for allocating and freeing DOS memory.

Author:

    Neil Sandlin (neilsa) 12-Dec-1996

Notes:


Revision History:


--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include <malloc.h>
#include <xlathlp.h>

#define DOSERR_NOT_ENOUGH_MEMORY 8
#define DOSERR_INVALID_BLOCK     9

MEM_DPMI DosMemHead = { NULL, 0, &DosMemHead, &DosMemHead, 0};


VOID
DpmiAllocateDosMem(
    VOID
    )
/*++

Routine Description:

    This routine allocates a block of DOS memory. The client is switched
    to V86 mode, and DOS is called to allocate the memory. Then a selector
    is allocated for the PM app to reference the memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI DosMemBlock;
    CLIENT_REGS SaveRegs;
    USHORT Sel;
    USHORT Seg;
    ULONG ParaSize = getBX();
    ULONG MemSize = ((ULONG)ParaSize) << 4;
    USHORT DosError = 0;
    USHORT SizeLargest = 0;

    SAVE_CLIENT_REGS(SaveRegs);

    if (WOWAllocSeg) {
        PUCHAR VdmStackPointer;
        ULONG NewSP;

        //
        // WOW is doing the allocation
        //

        BuildStackFrame(4, &VdmStackPointer, &NewSP);

        setCS(WOWAllocSeg);
        setIP(WOWAllocFunc);

        *(PDWORD16)(VdmStackPointer-4) = MemSize;
        *(PWORD16)(VdmStackPointer-6) =  (USHORT) (PmBopFe >> 16);
        *(PWORD16)(VdmStackPointer-8) =  (USHORT) PmBopFe;
        setSP((WORD)NewSP);

        host_simulate();

        Sel = getAX();
        Seg = getDX();
        if (!Sel) {
            DosError = DOSERR_NOT_ENOUGH_MEMORY;
        }

    } else {
        USHORT SelCount;

        //
        // DOS is doing the allocation
        // First get a mem_block to track the allocation
        //

        DosMemBlock = malloc(sizeof(MEM_DPMI));

        if (!DosMemBlock) {

            // Couldn't get the MEM_DPMI
            DosError = DOSERR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // Next allocate the selector array
            //

            SelCount = (USHORT) ((MemSize+65535)>>16);
            Sel = ALLOCATE_SELECTORS(SelCount);

            if (!Sel) {

                // Couldn't get the selectors
                DosError = DOSERR_NOT_ENOUGH_MEMORY;
                free(DosMemBlock);

            } else {

                //
                // Now have DOS allocate the memory
                //

                DpmiSwitchToRealMode();

                setBX((WORD)ParaSize);
                setAX(0x4800);

                DPMI_EXEC_INT(0x21);

                if (getCF()) {
                    USHORT i;

                    // Couldn't get the memory
                    DosError = getAX();
                    SizeLargest = getBX();
                    for (i = 0; i < SelCount; i++, Sel+=8) {
                        FreeSelector(Sel);
                    }
                    free(DosMemBlock);

                } else {
                    ULONG Base;

                    //
                    // Got the block. Save the allocation info, and set
                    // up the descriptors
                    //

                    Seg = getAX();
                    Base = ((ULONG)Seg) << 4;

                    DosMemBlock->Address = (PVOID)Seg;
                    DosMemBlock->Length = (ULONG)ParaSize;
                    DosMemBlock->Sel = Sel;
                    DosMemBlock->SelCount = SelCount;
                    DosMemBlock->Owner = 0;
                    INSERT_BLOCK(DosMemBlock, DosMemHead);

                    SetDescriptorArray(Sel, Base, MemSize);
                }

                DpmiSwitchToProtectedMode();
            }
        }
    }

    SET_CLIENT_REGS(SaveRegs);

    if (DosError) {
        setAX(DosError);
        setBX(SizeLargest);
        setCF(1);
    } else {
        setDX(Sel);
        setAX(Seg);
        setCF(0);
    }
}

VOID
DpmiFreeDosMem(
    VOID
    )
/*++

Routine Description:

    This routine frees a block of DOS memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI DosMemBlock;
    CLIENT_REGS SaveRegs;
    USHORT Sel = getDX();
    USHORT DosError = 0;

    SAVE_CLIENT_REGS(SaveRegs);

    if (WOWFreeSeg) {
        PUCHAR VdmStackPointer;
        ULONG NewSP;

        //
        // WOW is doing the free
        //

        BuildStackFrame(3, &VdmStackPointer, &NewSP);

        setCS(WOWFreeSeg);
        setIP(WOWFreeFunc);

        *(PWORD16)(VdmStackPointer-2) = Sel;
        *(PWORD16)(VdmStackPointer-4) =  (USHORT) (PmBopFe >> 16);
        *(PWORD16)(VdmStackPointer-6) =  (USHORT) PmBopFe;
        setSP((WORD)NewSP);

        host_simulate();

        Sel = getAX();
        if (!Sel) {
            DosError = DOSERR_INVALID_BLOCK;
        }

    } else {
        USHORT i;

        DosError = DOSERR_INVALID_BLOCK;    // assume failure
        //
        // DOS is doing the free
        // First find the mem_block for this allocation
        //
        DosMemBlock = DosMemHead.Next;

        while(DosMemBlock != &DosMemHead) {

            if (DosMemBlock->Sel == Sel) {

                DpmiSwitchToRealMode();

                setES((WORD)DosMemBlock->Address);
                setAX(0x4900);

                DPMI_EXEC_INT(0x21);

                if (getCF()) {

                    // Couldn't free the memory
                    DosError = getAX();

                } else {

                    for (i = 0; i < DosMemBlock->SelCount; i++, Sel+=8) {
                        FreeSelector(Sel);
                    }
                    DELETE_BLOCK(DosMemBlock);
                    free(DosMemBlock);
                    DosError = 0;
                }

                DpmiSwitchToProtectedMode();

                break;
            }
            DosMemBlock = DosMemBlock->Next;
        }
    }

    SET_CLIENT_REGS(SaveRegs);

    if (DosError) {
        setAX(DosError);
        setCF(1);
    } else {
        setCF(0);
    }
}

VOID
DpmiSizeDosMem(
    VOID
    )
/*++

Routine Description:

    This routine calls DOS to resize a DOS memory block, or to get
    the largest available block.

Arguments:

    None.

Return Value:

    None.

--*/
{

    DECLARE_LocalVdmContext;
    PMEM_DPMI DosMemBlock;
    CLIENT_REGS SaveRegs;
    USHORT Sel = getDX();
    ULONG ParaSize = getBX();
    ULONG MemSize = ((ULONG)ParaSize) << 4;
    USHORT DosError = 0;

    SAVE_CLIENT_REGS(SaveRegs);

    if (WOWFreeSeg) {

        //
        // WOW is doing the resize
        //

        // Not implemented
        DosError = DOSERR_NOT_ENOUGH_MEMORY;

    } else {
        USHORT SelCount;
        USHORT i;

        //
        // DOS is doing the resize
        // Find the mem_block for this allocation
        // First see if we need a new selector array
        //

        DosError = DOSERR_INVALID_BLOCK;    // assume failure
        DosMemBlock = DosMemHead.Next;

        while(DosMemBlock != &DosMemHead) {

            if (DosMemBlock->Sel == Sel) {
                USHORT NewSel = 0;
                USHORT NewSelCount = 0;

                //
                // If we have to grow the selector array, make sure
                // we can grow it in place
                //
                SelCount = (USHORT) ((MemSize+65535)>>16);

                if (SelCount > DosMemBlock->SelCount) {
                    USHORT TmpSel;

                    NewSel = Sel+(DosMemBlock->SelCount*8);
                    NewSelCount = SelCount - DosMemBlock->SelCount;

                    //
                    // First check to see if the selectors are really all free
                    //
                    for (i=0,TmpSel = NewSel; i < NewSelCount; i++, TmpSel+=8) {
                        if (!IS_SELECTOR_FREE(TmpSel)) {
                            DosError = DOSERR_NOT_ENOUGH_MEMORY;
                            goto dpmi_size_error;
                        }
                    }
                    //
                    // Now attempt to remove them off the free list
                    //
                    for (i=0; i < NewSelCount; i++, NewSel+=8) {
                        if (!RemoveFreeSelector(NewSel)) {
                            // If this happens, we must have a bogus free
                            // selector list
                            DosError = DOSERR_NOT_ENOUGH_MEMORY;
                            goto dpmi_size_error;
                        }
                    }
                }

                DpmiSwitchToRealMode();

                setBX((WORD)ParaSize);
                setES((WORD)DosMemBlock->Address);
                setAX(0x4A00);

                DPMI_EXEC_INT(0x21);

                if (getCF()) {

                    // Couldn't resize the memory
                    DosError = getAX();

                    // Free selectors, if we got new ones
                    if (NewSelCount) {
                        for (i = 0; i < NewSelCount; i++, NewSel+=8) {
                            FreeSelector(NewSel);
                        }
                    }

                } else {
                    ULONG Base;

                    //
                    // Resized the block. Update the allocation info, and set
                    // up the descriptors
                    //


                    if (SelCount < DosMemBlock->SelCount) {
                        USHORT OldSel = Sel+SelCount*8;
                        USHORT OldSelCount = DosMemBlock->SelCount - SelCount;
                        //
                        // Count of selectors has shrunk. Free 'em up.
                        //

                        for (i = 0; i < OldSelCount; i++, OldSel+=8) {
                            FreeSelector(OldSel);
                        }

                    }

                    DosMemBlock->Length = (ULONG)ParaSize;
                    DosMemBlock->SelCount = SelCount;

                    Base = ((ULONG)DosMemBlock->Address) << 4;

                    SetDescriptorArray(Sel, Base, MemSize);
                    DosError = 0;

                }

                DpmiSwitchToProtectedMode();

                break;
            }
            DosMemBlock = DosMemBlock->Next;
        }
    }

dpmi_size_error:
    SET_CLIENT_REGS(SaveRegs);

    if (DosError) {
        setAX(DosError);
        setCF(1);
    } else {
        setCF(0);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\debug.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains debugging routines for dpmi.

Revision History:

    Neil Sandlin (neilsa) Nov. 1, 95 - wrote it

--*/

#include "precomp.h"
#pragma hdrstop
#include "softpc.h"


#if DBG

#define MAX_TRACE_ENTRIES 100

DPMI_TRACE_ENTRY DpmiTraceTable[MAX_TRACE_ENTRIES];

const int DpmiMaxTraceEntries = MAX_TRACE_ENTRIES;
int DpmiTraceIndex = 0;
int DpmiTraceCount = 0;
BOOL bDpmiTraceOn = TRUE;

VOID
DpmiDbgTrace(
    int Type,
    ULONG v1,
    ULONG v2,
    ULONG v3
    )

{
    if (!bDpmiTraceOn) {
        return;
    }

    DpmiTraceTable[DpmiTraceIndex].Type = Type;
    DpmiTraceTable[DpmiTraceIndex].v1 = v1;
    DpmiTraceTable[DpmiTraceIndex].v2 = v2;
    DpmiTraceTable[DpmiTraceIndex].v3 = v3;

    DpmiTraceTable[DpmiTraceIndex].eax = getEAX();
    DpmiTraceTable[DpmiTraceIndex].ebx = getEBX();
    DpmiTraceTable[DpmiTraceIndex].ecx = getECX();
    DpmiTraceTable[DpmiTraceIndex].edx = getEDX();
    DpmiTraceTable[DpmiTraceIndex].esi = getESI();
    DpmiTraceTable[DpmiTraceIndex].edi = getEDI();
    DpmiTraceTable[DpmiTraceIndex].ebp = getEBP();
    DpmiTraceTable[DpmiTraceIndex].esp = getESP();
    DpmiTraceTable[DpmiTraceIndex].eip = getEIP();
    DpmiTraceTable[DpmiTraceIndex].eflags = getEFLAGS();

    DpmiTraceTable[DpmiTraceIndex].cs = getCS();
    DpmiTraceTable[DpmiTraceIndex].ds = getDS();
    DpmiTraceTable[DpmiTraceIndex].es = getES();
    DpmiTraceTable[DpmiTraceIndex].fs = getFS();
    DpmiTraceTable[DpmiTraceIndex].gs = getGS();
    DpmiTraceTable[DpmiTraceIndex].ss = getSS();


    DpmiTraceIndex++;
    if (DpmiTraceIndex >= MAX_TRACE_ENTRIES) {
        DpmiTraceIndex = 0;
    }
    if (DpmiTraceCount < MAX_TRACE_ENTRIES) {
        DpmiTraceCount++;
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\dpmi32.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dpmi32.c

Abstract:

    This function contains common code such as the dpmi dispatcher,
    and handling for the initialization of the dos extender.

Author:

    Dave Hastings (daveh) 24-Nov-1992

Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 - Updates for the 486 emulator

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include <intapi.h>

//
// DPMI dispatch table
//
VOID (*DpmiDispatchTable[MAX_DPMI_BOP_FUNC])(VOID) = {
    DpmiInitDosxRM,                             // 0
    DpmiInitDosx,                               // 1
    DpmiInitLDT,                                // 2
    DpmiGetFastBopEntry,                        // 3
    DpmiInitIDT,                                // 4
    DpmiInitExceptionHandlers,                  // 5
    DpmiInitApp,                                // 6
    DpmiTerminateApp,                           // 7
    DpmiDpmiInUse,                              // 8
    DpmiDpmiNoLongerInUse,                      // 9

    switch_to_protected_mode,                   // 10 (DPMISwitchToProtectedMode)
    switch_to_real_mode,                        // 11 (DPMISwitchToRealMode)
    DpmiSetAltRegs,                             // 12

    DpmiIntHandlerIret16,                       // 13
    DpmiIntHandlerIret32,                       // 14
    DpmiFaultHandlerIret16,                     // 15
    DpmiFaultHandlerIret32,                     // 16
    DpmiUnhandledExceptionHandler,              // 17

    DpmiRMCallBackCall,                         // 18
    DpmiReflectIntrToPM,                        // 19
    DpmiReflectIntrToV86,                       // 20

    DpmiInitPmStackInfo,                        // 21
    DpmiVcdPmSvcCall32,                         // 22
    DpmiSetDescriptorEntry,                     // 23
    DpmiResetLDTUserBase,                       // 24

    DpmiXlatInt21Call,                          // 25
    DpmiInt31Entry,                             // 26
    DpmiInt31Call,                              // 27

    DpmiHungAppIretAndExit                      // 28
};


VOID
DpmiDispatch(
    VOID
    )
/*++

Routine Description:

    This function dispatches to the appropriate subfunction

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    ULONG Index;
    static USHORT NestLevel = 0;

    Index = *(PUCHAR)VdmMapFlat(getCS(), getIP(), getMODE());

    setIP((getIP() + 1));           // take care of subfn.

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_DISPATCH_ENTRY, NestLevel++, Index);

    if (Index >= MAX_DPMI_BOP_FUNC) {
        //BUGBUG IMHO, we should fatal exit here
#if DBG
        DbgPrint("NtVdm: Invalid DPMI BOP %lx\n", Index);
#endif
        return;
    }

    (*DpmiDispatchTable[Index])();

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_DISPATCH_EXIT, --NestLevel, Index);
}

#if 0   // This probably is for private debugging only
VOID
DpmiIllegalFunction(
    VOID
    )
/*++

Routine Description:

    This routine ignores any Dpmi bops that are not implemented on a
    particular platform. It is called through the DpmiDispatchTable
    by #define'ing individual entries to this function.
    See dpmidata.h and dpmidatr.h.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
   char szFormat[] = "NtVdm: Invalid DPMI BOP from CS:IP %4.4x:%4.4x (%s mode), could be i386 dosx.exe.\n";
   char szMsg[sizeof(szFormat)+64];

   wsprintf(
       szMsg,
       szFormat,
       (int)getCS(),
       (int)getIP(),
       (getMSW() & MSW_PE) ? "prot" : "real"
       );

   OutputDebugString(szMsg);
}
#endif

VOID
DpmiInitDosxRM(
    VOID
    )
/*++

Routine Description:

    This routine handles the RM initialization bop for the dos extender.
    It get the addresses of the structures that the dos extender and
    32 bit code share.

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PDOSX_RM_INIT_INFO pdi;

    ASSERT(!(getMSW() & MSW_PE));

    pdi = (PDOSX_RM_INIT_INFO) VdmMapFlat(getDS(), getSI(), VDM_V86);

    DosxStackFrameSize    = pdi->StackFrameSize;

    RmBopFe = pdi->RmBopFe;
    PmBopFe = pdi->PmBopFe;

    DosxStackSegment      = pdi->StackSegment;
    DosxRmCodeSegment     = pdi->RmCodeSegment;
    DosxRmCodeSelector    = pdi->RmCodeSelector;

    DosxFaultHandlerIret  = pdi->pFaultHandlerIret;
    DosxFaultHandlerIretd = pdi->pFaultHandlerIretd;
    DosxIntHandlerIret    = pdi->pIntHandlerIret;
    DosxIntHandlerIretd   = pdi->pIntHandlerIretd;
    DosxIret              = pdi->pIret;
    DosxIretd             = pdi->pIretd;
    DosxRMReflector       = pdi->RMReflector;

    RMCallBackBopOffset   = pdi->RMCallBackBopOffset;
    RMCallBackBopSeg      = pdi->RMCallBackBopSeg;
    PMReflectorSeg        = pdi->PMReflectorSeg;

    DosxRmSaveRestoreState= pdi->RmSaveRestoreState;
    DosxPmSaveRestoreState= pdi->PmSaveRestoreState;
    DosxRmRawModeSwitch   = pdi->RmRawModeSwitch;
    DosxPmRawModeSwitch   = pdi->PmRawModeSwitch;

    DosxVcdPmSvcCall      = pdi->VcdPmSvcCall;
    DosxMsDosApi          = pdi->MsDosApi;
    DosxXmsControl        = pdi->XmsControl;

    DosxHungAppExit       = pdi->HungAppExit;

    //
    // Load the temporary LDT info (updated in DpmiInitLDT())
    //
    Ldt       = VdmMapFlat(pdi->InitialLDTSeg, 0, VDM_V86);
    LdtMaxSel = pdi->InitialLDTSize;

#ifdef _X86_
    //
    // On x86 platforms, return the fast bop address
    //
    GetFastBopEntryAddress(&((PVDM_TIB)NtCurrentTeb()->Vdm)->VdmContext);
#endif

}

VOID
DpmiInitDosx(
    VOID
    )
/*++

Routine Description:

    This routine handles the PM initialization bop for the dos extender.
    It get the addresses of the structures that the dos extender and
    32 bit code share.

    Note: These values are initialized here since they are FLAT pointers,
    and are thus not easily computed at the time of InitDosxRM.

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PDOSX_INIT_INFO pdi;

    ASSERT((getMSW() & MSW_PE));

    pdi = (PDOSX_INIT_INFO) VdmMapFlat(getDS(), getSI(), VDM_PM);

    SmallXlatBuffer = Sim32GetVDMPointer(pdi->pSmallXlatBuffer, 4, TRUE);
    LargeXlatBuffer = Sim32GetVDMPointer(pdi->pLargeXlatBuffer, 4, TRUE);
    DosxDtaBuffer   = Sim32GetVDMPointer(pdi->pDtaBuffer, 4, TRUE);

    DosxStackFramePointer = (PWORD16)((PULONG)Sim32GetVDMPointer(
                                     pdi->pStackFramePointer, 4, TRUE));

}

VOID
DpmiInitApp(
    VOID
    )
/*++

Routine Description:

    This routine handles any necessary 32 bit initialization for extended
    applications.

Arguments:

    None.

Return Value:

    None.

Notes:

    This function contains a number of 386 specific things.
    Since we are likely to expand the 32 bit portions of DPMI in the
    future, this makes more sense than duplicating the common portions
    another file.

--*/
{
    DECLARE_LocalVdmContext;
    PWORD16 Data;

    Data = (PWORD16) VdmMapFlat(getSS(), getSP(), VDM_PM);

    // Only 1 bit defined in dpmi
    CurrentAppFlags = getAX() & DPMI_32BIT;
#ifdef _X86_
    ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.Flags = CurrentAppFlags;
    if (CurrentAppFlags & DPMI_32BIT) {
        *pNtVDMState |= VDM_32BIT_APP;
    }
#endif

    DpmiInitRegisterSize();

    CurrentDta = Sim32GetVDMPointer(
        *(PDWORD16)(Data),
        1,
        TRUE
        );

    CurrentDosDta = (PUCHAR) NULL;

    CurrentDtaOffset = *Data;
    CurrentDtaSelector = *(Data + 1);
    CurrentPSPSelector = *(Data + 2);
    CurrentPSPXmem = 0;
}

VOID
DpmiTerminateApp(
    VOID
    )
/*++

Routine Description:

    This routine handles any necessary 32 bit destruction for extended
    applications.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/
{
    DECLARE_LocalVdmContext;

    DpmiFreeAppXmem(getDX());
    CurrentPSPXmem = 0;                               // DpmiFreeAppXmem should also zero it
    CurrentPSPSelector = getCX();                     // indicate no running app
}


VOID
DpmiEnableIntHooks(
    VOID
    )

/*++

Routine Description:

    This routine is called very early on in NTVDM initialization. It
    gives the dpmi code a chance to do some startup stuff before any
    client code has run.

    This is not called via bop.

Arguments:

    None

Return Value:

    None.

--*/

{
#ifndef _X86_
    IntelBase = (ULONG) VdmMapFlat(0, 0, VDM_V86);
    VdmInstallHardwareIntHandler(DpmiHwIntHandler);
    VdmInstallSoftwareIntHandler(DpmiSwIntHandler);
    VdmInstallFaultHandler(DpmiFaultHandler);
#endif // _X86_
}

#ifdef DBCS
VOID
DpmiSwitchToDosxStack(
    VOID
    )
{
    DECLARE_LocalVdmContext;

    SWITCH_TO_DOSX_RMSTACK();
}
VOID
DpmiSwitchFromDosxStack(
    VOID
    )
{
    DECLARE_LocalVdmContext;

    SWITCH_FROM_DOSX_RMSTACK();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\dpmi32.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dpmi32.h

Abstract:

    This is the private include file for the 32 bit dpmi and protected mode
    support

Author:

    Dave Hastings (daveh) 24-Nov-1992

Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 - Updates for the 486 emulator
    Neil Sandlin (neilsa) 15-Sep-1996 - Merged dpmi32p.h, dpmidata.h

--*/

#define FAST_VDM_REGISTERS

//
// DPMI structures and definitions
//

#define I31VERSION 90           // Int 31 services major/minor version #'s
#define I31FLAGS 0x000D         // 386 extender, pMode NetBIOS
#define idCpuType 3             // LATER: conceivably, we could return the real proc type
#define I31MasterPIC    0x08    // Master PIC Interrupts start at 08h
#define I31SlavePIC     0x70    // Slave PIC Interrupts start at 70h
#define MAX_APP_XMEM    0x2000000  // 32 MB = max DPMI mem + max XMS from pif

#pragma pack(1)
typedef struct _DPMIMEMINFO {
    DWORD LargestFree;
    DWORD MaxUnlocked;
    DWORD MaxLocked;
    DWORD AddressSpaceSize;
    DWORD UnlockedPages;
    DWORD FreePages;
    DWORD PhysicalPages;
    DWORD FreeAddressSpace;
    DWORD PageFileSize;
} DPMIMEMINFO, *PDPMIMEMINFO;
#pragma pack()

#pragma pack(1)
typedef struct _DPMI_RMCALLSTRUCT {
    DWORD Edi;
    DWORD Esi;
    DWORD Ebp;
    DWORD Reserved;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    WORD Flags;
    WORD Es;
    WORD Ds;
    WORD Fs;
    WORD Gs;
    WORD Ip;
    WORD Cs;
    WORD Sp;
    WORD Ss;
} DPMI_RMCALLSTRUCT, *PDPMI_RMCALLSTRUCT;
#pragma pack()


//
// dpmi32 init structure
//

#pragma pack(1)
typedef struct _DOSX_RM_INIT_INFO {
    USHORT StackSegment;
    USHORT StackFrameSize;
    ULONG  RmBopFe;
    ULONG  PmBopFe;
    USHORT RmCodeSegment;
    USHORT RmCodeSelector;
    ULONG  pFaultHandlerIret;
    ULONG  pFaultHandlerIretd;
    ULONG  pIntHandlerIret;
    ULONG  pIntHandlerIretd;
    ULONG  pIret;
    ULONG  pIretd;
    USHORT RMCallBackBopOffset;
    USHORT RMCallBackBopSeg;
    ULONG  RMReflector;
    USHORT PMReflectorSeg;
    USHORT InitialLDTSeg;
    USHORT InitialLDTSize;
    ULONG  RmSaveRestoreState;
    ULONG  PmSaveRestoreState;
    ULONG  RmRawModeSwitch;
    ULONG  PmRawModeSwitch;
    ULONG  VcdPmSvcCall;
    ULONG  MsDosApi;
    ULONG  XmsControl;
    ULONG  HungAppExit;
} DOSX_RM_INIT_INFO;
typedef DOSX_RM_INIT_INFO UNALIGNED* PDOSX_RM_INIT_INFO;

typedef struct _DOSX_INIT_INFO {
    ULONG  pSmallXlatBuffer;
    ULONG  pLargeXlatBuffer;
    ULONG  pStackFramePointer;
    ULONG  pDtaBuffer;
} DOSX_INIT_INFO;
typedef DOSX_INIT_INFO UNALIGNED* PDOSX_INIT_INFO;
#pragma pack()


#define SWITCH_TO_DOSX_RMSTACK() {                          \
            setSS(DosxStackSegment);                        \
            setSP(*DosxStackFramePointer);                  \
            *DosxStackFramePointer -= DosxStackFrameSize;   \
            }

#define SWITCH_FROM_DOSX_RMSTACK() {                        \
            *DosxStackFramePointer += DosxStackFrameSize;   \
            }

//
// Defines to allow us to use a common dispatch table without having
// to add a bunch of stub functions
//

extern VDM_INTERRUPTHANDLER DpmiInterruptHandlers[256];
extern VDM_FAULTHANDLER DpmiFaultHandlers[32];

#ifdef _X86_

#ifdef FAST_VDM_REGISTERS

#define LockedPMStackSel      (_LocalVdmTib->DpmiInfo.SsSelector)
#define LockedPMStackCount    (_LocalVdmTib->DpmiInfo.LockCount)

#define PMLockOrigEIP         (_LocalVdmTib->DpmiInfo.SaveEip)
#define PMLockOrigESP         (_LocalVdmTib->DpmiInfo.SaveEsp)
#define PMLockOrigSS          (_LocalVdmTib->DpmiInfo.SaveSsSelector)

#define DosxFaultHandlerIret  (_LocalVdmTib->DpmiInfo.DosxFaultIret)
#define DosxFaultHandlerIretd (_LocalVdmTib->DpmiInfo.DosxFaultIretD)
#define DosxIntHandlerIret    (_LocalVdmTib->DpmiInfo.DosxIntIret)
#define DosxIntHandlerIretd   (_LocalVdmTib->DpmiInfo.DosxIntIretD)
#define DosxRMReflector       (_LocalVdmTib->DpmiInfo.DosxRmReflector)


#else   //FAST_VDM_REGISTERS

// Temporary only.  Doing this so I can switch back to the old way in case ...

#define LockedPMStackSel      ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.SsSelector
#define LockedPMStackCount    ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.LockCount

#define PMLockOrigEIP         ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.SaveEip
#define PMLockOrigESP         ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.SaveEsp
#define PMLockOrigSS          ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.SaveSsSelector

#define DosxFaultHandlerIret  ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.DosxFaultIret
#define DosxFaultHandlerIretd ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.DosxFaultIretD
#define DosxIntHandlerIret    ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.DosxIntIret
#define DosxIntHandlerIretd   ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.DosxIntIretD
#define DosxRMReflector       ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.DosxRmReflector

#endif //FAST_VDM_REGISTERS

#else  // _X86_

extern USHORT LockedPMStackSel;
extern ULONG LockedPMStackCount;
extern ULONG PMLockOrigEIP;
extern ULONG PMLockOrigSS;
extern ULONG PMLockOrigESP;

extern ULONG DosxFaultHandlerIret;
extern ULONG DosxFaultHandlerIretd;
extern ULONG DosxIntHandlerIret;
extern ULONG DosxIntHandlerIretd;
extern ULONG DosxRMReflector;

//
// Ldt entry definition
//
// This appears in nti386.h, and winnt.h.  The definitions in
// winnt.h are not included if the nt include files are included.
// The simple solution, since this structure will never change
// is to put the definition here.
//

typedef struct _LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     // Declare as bytes to avoid alignment
            BYTE    Flags2;     // Problems.
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;


//
// Data items
//

extern VOID force_yoda(VOID);
extern VOID DisableEmulatorIretHooks(VOID);
extern VOID EnableEmulatorIretHooks(VOID);

#endif

typedef struct _IDT_ENTRY {
    WORD    OffsetLow;
    WORD    Selector;
    BYTE    Reserved;
    union {
        struct {
            BYTE Flags;
        } Bytes;
        struct {
            BYTE   Type : 5;
            BYTE   Dpl : 2;
            BYTE   Pres : 1;
        } Bits;
    } u;
    WORD    OffsetHi;
} IDT_ENTRY, *PIDT_ENTRY;


#define GET_SELECTOR_BASE(Sel) ( (ULONG) (              \
            Ldt[Sel>>3].BaseLow |                       \
            Ldt[Sel>>3].HighWord.Bytes.BaseMid << 16 |  \
            Ldt[Sel>>3].HighWord.Bytes.BaseHi << 24     \
            ))

#define GET_SELECTOR_LIMIT(Sel) ( (ULONG) (                                     \
            ((Ldt[Sel>>3].HighWord.Bits.LimitHi << 16 | Ldt[Sel>>3].LimitLow)   \
                 << (12 * Ldt[Sel>>3].HighWord.Bits.Granularity)) +             \
                    Ldt[Sel>>3].HighWord.Bits.Granularity * 0xFFF               \
            ))

#if DBG
#define GET_SHADOW_SELECTOR_LIMIT(Selector, Limit) \
            Limit = SelectorLimit[Selector>>3]
#else
#ifdef _X86_
#define GET_SHADOW_SELECTOR_LIMIT(Selector, Limit) _asm      \
         {                                          \
            _asm    xor     eax, eax                \
            _asm    xor     ecx, ecx                \
            _asm    mov     ax, Selector            \
            _asm    or      eax, 7                  \
            _asm    lsl     ecx, eax                \
            _asm    mov     [Limit], ecx            \
         }
#else
#define GET_SHADOW_SELECTOR_LIMIT(Selector, Limit)  \
            Limit = GET_SELECTOR_LIMIT(Selector)
#endif
#endif

#define SET_SELECTOR_LIMIT(Sel, Limit) {                                    \
            USHORT i = Sel>>3;                                              \
            if (!Ldt[i].HighWord.Bits.Granularity) {                        \
                Ldt[i].LimitLow = (USHORT)(Limit & 0x0000FFFF);             \
                Ldt[i].HighWord.Bits.LimitHi =                              \
                    (Limit & 0x000f0000) >> 16;                             \
            } else {                                                        \
                Ldt[i].LimitLow = (USHORT)((Limit >> 12) & 0xFFFF);         \
                Ldt[i].HighWord.Bits.LimitHi =                              \
                    ((Limit >> 12) & 0x000f0000) >> 16;                     \
            }                                                               \
        }

#define SET_SELECTOR_ACCESS(Sel, Access) {                                  \
            Ldt[Sel>>3].HighWord.Bytes.Flags1 = LOBYTE(Access);             \
            Ldt[Sel>>3].HighWord.Bytes.Flags2 = (HIBYTE(Access) & 0xd0) +   \
           (Ldt[Sel>>3].HighWord.Bytes.Flags2 & 0x0f);                      \
            }


#define IS_SELECTOR_FREE(Sel) ((Ldt[Sel>>3].HighWord.Bytes.Flags1 == 0) &&  \
                               (Ldt[Sel>>3].HighWord.Bytes.BaseHi == 0x80))

#define IS_SELECTOR_READABLE(Sel) (                                         \
            ((Ldt[Sel>>3].HighWord.Bytes.Flags1 &                           \
              (AB_DPL3|AB_PRESENT|AB_DATA)) ==                              \
                                      (AB_DPL3|AB_PRESENT|AB_DATA))         \
            )

#ifdef _X86_
#define FLUSH_SELECTOR_CACHE(SelStart, SelCount) TRUE
#else
#define FLUSH_SELECTOR_CACHE(SelStart, SelCount) FlushSelectorCache(SelStart, SelCount)
#endif

//
// These values define the range of the reserved DPMI selectors, given
// out by Int31, func 000d.
//
#define SEL_DPMI_FIRST 0
#define SEL_DPMI_LAST 0x78

// Whenever we allocate a descriptor, the access rights byte is set
// to 0Fh.  This marks it as a '386 task gate, which is not legal to
// have in the GDT.  We need to stick something in this byte, because
// having the access rights byte be 0 means that it is free, which is
// no longer the case.

#define MARK_SELECTOR_ALLOCATED(Sel) {                  \
            Ldt[Sel>>3].HighWord.Bytes.Flags1 = 0xf;    \
            Ldt[Sel>>3].HighWord.Bytes.BaseHi = 0;      \
            }

#define MARK_SELECTOR_FREE(Sel) {                       \
            Ldt[Sel>>3].HighWord.Bytes.Flags1 = 0;      \
            Ldt[Sel>>3].HighWord.Bytes.BaseHi = 0x80;   \
            }

#define NEXT_FREE_SEL(Sel) (Ldt[Sel>>3].LimitLow)

#define ALLOCATE_SELECTOR() AllocateSelectors(1, FALSE)
#define ALLOCATE_SELECTORS(Count) AllocateSelectors(Count, FALSE)
#define ALLOCATE_WOW_SELECTORS(Count) AllocateSelectors(Count, TRUE)



#define SEGMENT_IS_BIG(sel) ((sel<LdtMaxSel) && (Ldt[(sel & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Default_Big))
#define SEGMENT_IS_PRESENT(sel) ((sel<LdtMaxSel) && (Ldt[(sel & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Pres))

// This checks for S, Data, W
#define SEGMENT_IS_WRITABLE(sel) ((sel<LdtMaxSel) && ( (Ldt[(sel & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Type & 0x1a) == 0x12))


#define SEL_INDEX_MASK ~7
// Ldt, ring 3 bits
#define SEL_LDT3 7

//
// Descriptor Access Byte constants
//

#define AB_ACCESSED     0x01    //segment has been accessed
#define AB_WRITE        0x02    //writable data

#define AB_DATA         0x10    //data segment
#define AB_CODE         0x18    //code segment
#define AB_DPL3         0x60    //ring 3 DPL
#define AB_PRESENT      0x80    //segment present bit

#define AB_TRAPGATE     0x07    //trap gate descriptor
#define AB_INTRGATE     0x0e    //80386 interrupt gate descriptor

#define STD_DATA AB_PRESENT+AB_DPL3+AB_DATA+AB_WRITE
#define STD_TRAP AB_PRESENT+AB_DPL3+AB_TRAPGATE
#define STD_INTR AB_PRESENT+AB_DPL3+AB_INTRGATE

//
// Internal Constants
//

#define MAX_V86_ADDRESS         64 * 1024 + 1024 * 1024
#define ONE_MB                  1024 * 1024

// bugbug
#define SMALL_XLAT_BUFFER_SIZE  128
// bugbug
#define LARGE_XLAT_BUFFER_SIZE  8192

#define DPMI_32BIT              0x1

#define Frame32 ((BOOL)CurrentAppFlags)
#define LockedPMStackOffset 0x1000

//
// Internal types
//
typedef ULONG (*GETREGISTERFUNCTION)(VOID);
typedef VOID (*SETREGISTERFUNCTION)(ULONG);

#define SAVE_CLIENT_REGS(Regs) {\
    Regs.Eax = getEAX();        \
    Regs.Ebx = getEBX();        \
    Regs.Ecx = getECX();        \
    Regs.Edx = getEDX();        \
    Regs.Edi = getEDI();        \
    Regs.Esi = getESI();        \
    Regs.Ebp = getEBP();        \
    Regs.Eip = getEIP();        \
    Regs.Esp = getESP();        \
    Regs.Eflags = getEFLAGS();  \
    Regs.Cs = getCS();          \
    Regs.Ds = getDS();          \
    Regs.Es = getES();          \
    Regs.Fs = getFS();          \
    Regs.Gs = getGS();          \
    Regs.Ss = getSS();          \
    }

#define SET_CLIENT_REGS(Regs) { \
    setEAX(Regs.Eax);           \
    setEBX(Regs.Ebx);           \
    setECX(Regs.Ecx);           \
    setEDX(Regs.Edx);           \
    setEDI(Regs.Edi);           \
    setESI(Regs.Esi);           \
    setEBP(Regs.Ebp);           \
    setEIP(Regs.Eip);           \
    setESP(Regs.Esp);           \
    setEFLAGS(Regs.Eflags);     \
    setCS(Regs.Cs);             \
    setDS(Regs.Ds);             \
    setES(Regs.Es);             \
    setFS(Regs.Fs);             \
    setGS(Regs.Gs);             \
    setSS(Regs.Ss);             \
    }

typedef struct _CLIENT_REGS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Edi;
    ULONG Esi;
    ULONG Ebp;
    ULONG Eip;
    ULONG Esp;
    ULONG Eflags;
    USHORT Cs;
    USHORT Ss;
    USHORT Es;
    USHORT Ds;
    USHORT Fs;
    USHORT Gs;
} CLIENT_REGS, *PCLIENT_REGS;

//
// Memory management definitions
//

#define DELETE_BLOCK(BLK)             \
        (BLK->Prev)->Next = BLK->Next;\
        (BLK->Next)->Prev = BLK->Prev;\
        if (CurrentPSPSelector != 0 && BLK->Owner != 0) CurrentPSPXmem -= BLK->Length


#define INSERT_BLOCK(BLK, HEAD)    \
        BLK->Next = HEAD.Next;     \
        BLK->Prev= HEAD.Next->Prev;\
        (HEAD.Next)->Prev = BLK;   \
        HEAD.Next = BLK;           \
        if (CurrentPSPSelector != 0 && BLK->Owner != 0) CurrentPSPXmem += BLK->Length

#define RESIZE_BLOCK(BLK, ADDR, SIZE)      \
        if (CurrentPSPSelector != 0 && BLK->Owner != 0) {     \
            CurrentPSPXmem -= BLK->Length; \
            CurrentPSPXmem += SIZE;        \
        }                                  \
        BLK->Address = (PVOID)ADDR;        \
        BLK->Length  = SIZE

//
// Visible structure for save state stuff
//
typedef struct _VSavedState {
    UCHAR Misc[28];
} VSAVEDSTATE, PVSAVEDSTATE;

//
// Descriptor mapping (for dib.drv)
//

#ifndef _X86_
ULONG
GetDescriptorMapping(
    USHORT Sel,
    ULONG LdtBase
    );

typedef struct _DESC_MAPPING {
    USHORT Sel;
    USHORT SelCount;
    ULONG LdtBase;
    ULONG FlatBase;
    struct _DESC_MAPPING* pNext;
} DESC_MAPPING, *PDESC_MAPPING;
#endif

//
// Dpmi32 data
//

//SLT: these two should be per-thread
extern ULONG LastLockedPMStackSS;
extern ULONG LastLockedPMStackESP;

extern PUCHAR SmallXlatBuffer;
extern PUCHAR LargeXlatBuffer;
extern BOOL SmallBufferInUse;
extern USHORT LargeBufferInUseCount;
extern USHORT DosxStackSegment;
extern USHORT DosxRmCodeSegment;
extern USHORT DosxRmCodeSelector;
extern PWORD16 DosxStackFramePointer;
extern USHORT DosxStackFrameSize;
extern USHORT CurrentAppFlags;
extern ULONG RmBopFe;
extern ULONG PmBopFe;
extern USHORT RMCallBackBopSeg;
extern USHORT RMCallBackBopOffset;
extern USHORT PMReflectorSeg;
extern PUCHAR DosxDtaBuffer;
extern ULONG IntelBase;
extern PLDT_ENTRY Ldt;
extern USHORT LdtSel;
extern USHORT LdtMaxSel;
extern USHORT LdtUserSel;
extern PIDT_ENTRY Idt;
extern USHORT WOWAllocSeg;
extern USHORT WOWAllocFunc;
extern USHORT WOWFreeSeg;
extern USHORT WOWFreeFunc;

//
// Information about the current DTA
//
// N.B.  The selector:offset, and flat pointer following MAY point to
//       different linear addresses.  This will be the case if the
//       dta selector is in high memory
extern PUCHAR CurrentDta;
extern PUCHAR CurrentPmDtaAddress;
extern PUCHAR CurrentDosDta;
extern USHORT CurrentDtaSelector;
extern USHORT CurrentDtaOffset;

#if DBG
extern ULONG SelectorLimit[LDT_SIZE];
#endif


//
// Register manipulation functions (for register that might be 16 or 32 bits)
//
extern GETREGISTERFUNCTION GetCXRegister;
extern GETREGISTERFUNCTION GetDXRegister;
extern GETREGISTERFUNCTION GetDIRegister;
extern GETREGISTERFUNCTION GetSIRegister;
extern GETREGISTERFUNCTION GetBXRegister;
extern GETREGISTERFUNCTION GetAXRegister;
extern GETREGISTERFUNCTION GetSPRegister;

extern SETREGISTERFUNCTION SetCXRegister;
extern SETREGISTERFUNCTION SetDXRegister;
extern SETREGISTERFUNCTION SetDIRegister;
extern SETREGISTERFUNCTION SetSIRegister;
extern SETREGISTERFUNCTION SetBXRegister;
extern SETREGISTERFUNCTION SetAXRegister;
extern SETREGISTERFUNCTION SetSPRegister;


extern USHORT CurrentPSPSelector;
extern ULONG CurrentPSPXmem;
extern ULONG FlatAddress[LDT_SIZE];

extern ULONG DosxIret;
extern ULONG DosxIretd;

extern ULONG DosxRmSaveRestoreState;
extern ULONG DosxPmSaveRestoreState;
extern ULONG DosxRmRawModeSwitch;
extern ULONG DosxPmRawModeSwitch;

extern ULONG DosxVcdPmSvcCall;
extern ULONG DosxMsDosApi;
extern ULONG DosxXmsControl;
extern ULONG DosxHungAppExit;

//
// Monitor functions
//
VOID
GetFastBopEntryAddress(
    PCONTEXT VdmContext
    );

//
// Dispatched functions (via bop)
//

VOID DpmiInitDosxRM(VOID);
VOID DpmiInitDosx(VOID);
VOID DpmiInitLDT(VOID);
VOID DpmiGetFastBopEntry(VOID);
VOID DpmiInitIDT(VOID);
VOID DpmiInitExceptionHandlers(VOID);
VOID DpmiInitPmStackInfo(VOID);
VOID DpmiInitApp(VOID);
VOID DpmiTerminateApp(VOID);
VOID DpmiDpmiInUse(VOID);
VOID DpmiDpmiNoLongerInUse(VOID);

VOID switch_to_protected_mode(VOID);
VOID switch_to_real_mode(VOID);
VOID DpmiSetAltRegs(VOID);

VOID DpmiVcdPmSvcCall32(VOID);
VOID DpmiFreeAppXmem(USHORT);
VOID DpmiFreeAllXmem(VOID);

VOID DpmiIntHandlerIret16(VOID);
VOID DpmiIntHandlerIret32(VOID);
VOID DpmiFaultHandlerIret16(VOID);
VOID DpmiFaultHandlerIret32(VOID);
VOID DpmiUnhandledExceptionHandler(VOID);

VOID DpmiRMCallBackCall(VOID);
VOID DpmiReflectIntrToPM(VOID);
VOID DpmiReflectIntrToV86(VOID);

VOID DpmiSetDescriptorEntry(VOID);
VOID DpmiAllocateSelectors(VOID);
VOID DpmiFreeSelector(VOID);
VOID DpmiResetLDTUserBase(VOID);

VOID DpmiXlatInt21Call(VOID);
VOID DpmiInt31Entry(VOID);
VOID DpmiInt31Call(VOID);

VOID DpmiHungAppIretAndExit(VOID);

//
// Internal functions
//

VOID
BeginUseLockedPMStack(
    VOID
    );

BOOL
EndUseLockedPMStack(
    VOID
    );

BOOL
BuildStackFrame(
    ULONG StackUnits,
    PUCHAR *pVdmStackPointer,
    ULONG *pNewSP
    );

VOID
EmulateV86Int(
    UCHAR InterruptNumber
    );

typedef enum {
    RESTORE_FLAGS,
    PASS_FLAGS,
    PASS_CARRY_FLAG,
    PASS_CARRY_FLAG_16
} IRET_BEHAVIOR;

VOID
SimulateIret(
    IRET_BEHAVIOR fdsp
    );

VOID
SimulateFarCall(
    USHORT Seg,
    ULONG Offset
    );

VOID
SimulateCallWithIretFrame(
    USHORT Seg,
    ULONG Offset
    );

BOOL
DpmiSwIntHandler(
    ULONG IntNumber
    );

BOOL
DpmiHwIntHandler(
    ULONG IntNumber
    );

BOOL
DpmiFaultHandler(
    ULONG IntNumber,
    ULONG ErrorCode
    );

BOOL
SetProtectedModeInterrupt(
    USHORT IntNumber,
    USHORT Sel,
    ULONG Offset,
    USHORT Flags
    );

BOOL
SetFaultHandler(
    USHORT IntNumber,
    USHORT Sel,
    ULONG Offset
    );

BOOL
DispatchPMInt(
    UCHAR InterruptNumber
    );

VOID
DpmiRMCall(
    UCHAR mode
    );

VOID
DpmiAllocateRMCallBack(
    VOID
    );

VOID
DpmiFreeRMCallBack(
    VOID
    );

BOOL
PMInt2fHandler(
    VOID
    );

VOID
GetVxDApiHandler(
    USHORT VxdId
    );

BOOL
DpmiSetDebugRegisters(
    PULONG RegisterPointer
    );

BOOL
DpmiGetDebugRegisters(
    PULONG RegisterPointer
    );
//
// Descriptor managagment
//

#ifdef _X86_
BOOL
DpmiSetX86Descriptor(
    USHORT  SelStart,
    USHORT  SelCount
    );
#else
VOID
FlushSelectorCache(
    USHORT  SelStart,
    USHORT  SelCount
    );
#endif

VOID
SetShadowDescriptorEntries(
    USHORT SelStart,
    USHORT SelCount
    );

VOID
SetDescriptorBase(
    USHORT Sel,
    ULONG Base
    );

VOID
SetDescriptor(
    USHORT Sel,
    ULONG Base,
    ULONG Limit,
    USHORT Access
    );

USHORT
AllocateSelectors(
    USHORT Count,
    BOOL bWow
    );

BOOL
FreeSelector(
    USHORT Sel
    );

USHORT
FindSelector(
    ULONG Base,
    UCHAR Access
    );

BOOL
RemoveFreeSelector(
    USHORT Sel
    );

USHORT
SegmentToSelector(
    USHORT Segment,
    USHORT Access
    );

VOID
SetDescriptorArray(
    USHORT Sel,
    ULONG Base,
    ULONG MemSize
    );

//
// Memory management
//

NTSTATUS
DpmiAllocateVirtualMemory(
    PVOID *Address,
    PULONG Size
    );

NTSTATUS
DpmiFreeVirtualMemory(
    PVOID *Address,
    PULONG Size
    );

NTSTATUS
DpmiReallocateVirtualMemory(
    PVOID OldAddress,
    ULONG OldSize,
    PVOID *NewAddress,
    PULONG NewSize
    );

VOID
DpmiGetMemoryInfo(
    VOID
    );

PMEM_DPMI
DpmiAllocateXmem(
    ULONG Size
    );

BOOL
DpmiFreeXmem(
    PMEM_DPMI XmemBlock
    );

BOOL
DpmiIsXmemHandle(
    PMEM_DPMI XmemBlock
    );

BOOL
DpmiReallocateXmem(
    PMEM_DPMI XmemBlock,
    ULONG Size
    );

PMEM_DPMI
DpmiFindXmem(
    USHORT Sel
    );

ULONG
DpmiCalculateAppXmem(
    VOID
    );

VOID
DpmiAllocateDosMem(
    VOID
    );

VOID
DpmiFreeDosMem(
    VOID
    );

VOID
DpmiSizeDosMem(
    VOID
    );

//
// Utility functions
//

VOID
DpmiInitRegisterSize(
    VOID
    );

VOID
DpmiSwitchToProtectedMode(
    VOID
    );

VOID
DpmiSwitchToRealMode(
    VOID
    );

VOID
DpmiPushRmInt(
    USHORT InterruptNumber
    );

VOID
DpmiSaveSegmentsAndStack(
    PVOID ContextPointer
    );

PVOID
DpmiRestoreSegmentsAndStack(
    VOID
    );

//
// Int21 translation
//

VOID
SetVector(
    VOID
    );

VOID
GetVector(
    VOID
    );

PUCHAR
DpmiMapAndCopyBuffer(
    PUCHAR Buffer,
    USHORT BufferLength
    );

VOID
DpmiUnmapAndCopyBuffer(
    PUCHAR Destination,
    PUCHAR Source,
    USHORT BufferLength
    );

USHORT
DpmiCalcFcbLength(
    PUCHAR FcbPointer
    );

PUCHAR
DpmiMapString(
    USHORT StringSeg,
    ULONG StringOff,
    PWORD16 Length
    );

PUCHAR
DpmiAllocateBuffer(
    USHORT Length
    );

#define DpmiUnmapString DpmiFreeBuffer
#define DpmiUnmapBuffer DpmiFreeBuffer

VOID
DpmiFreeBuffer(
    PUCHAR Buffer,
    USHORT Length
    );

VOID
DpmiFreeAllBuffers(
    VOID
    );

#ifdef DBCS
VOID
DpmiSwitchToDosxStack(
    VOID
    );

VOID
DpmiSwitchFromDosxStack(
    VOID
    );
#endif //DBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\dpmiint.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dpmiint.h

Abstract:

    This is the private include file for the 32 bit dpmi and protected mode
    support

Author:

    Neil Sandlin (neilsa) 31-Jul-1995

Revision History:

--*/


#ifndef _X86_

GETREGISTERFUNCTION GetRegisterByIndex[8] = {getEAX, getECX, getEDX, getECX,
                                             getESP, getEBP, getESI, getEDI};
SETREGISTERFUNCTION SetRegisterByIndex[8] = {setEAX, setECX, setEDX, setECX,
                                             setESP, setEBP, setESI, setEDI};

#endif // _X86_

#define STACK_FAULT 12

VOID
DpmiFatalExceptionHandler(
    UCHAR XNumber,
    PCHAR VdmStackPointer
    );

BOOL
DpmiFaultHandler(
    ULONG IntNumber,
    ULONG ErrorCode
    );

BOOL
DpmiEmulateInstruction(
    VOID
    );

BOOL
DpmiOp0f(
    PUCHAR pCode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\dpmimscr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dpmimscr.c

Abstract:

    This module contains misc dpmi functions for risc.

Author:

    Dave Hart (davehart) creation-date 11-Apr-1993

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include "softpc.h"

VOID
DpmiGetFastBopEntry(
    VOID
    )
/*++

Routine Description:

    This routine is the front end for the routine that gets the address.  It
    is necessary to get the address in asm, because the CS value is not
    available in c

Arguments:

    None

Return Value:

    None.

--*/
{
#ifdef _X86_
    GetFastBopEntryAddress(&((PVDM_TIB)NtCurrentTeb()->Vdm)->VdmContext);
#else
    //
    // krnl286 does a DPMIBOP GetFastBopAddress even on
    // risc, so just fail the call since fast-bopping
    // will only ever work on x86.
    //

    setBX(0);
    setDX(0);
    setES(0);
#endif
}



VOID
DpmiDpmiInUse(
    VOID
    )
/*++

Routine Description:

    This routine currently does nothing.

Arguments:

    None.

Return Value:

    None.

--*/
{

}

VOID
DpmiDpmiNoLongerInUse(
    VOID
    )
/*++

Routine Description:

    This routine notifies the CPU that the NT dpmi server is no longer in use.

Arguments:

    None.

Return Value:

    None.

--*/
{

    DpmiFreeAllXmem();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\dpmimemr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    name-of-module-filename

Abstract:

    This module contains the code for actually allocating memory for dpmi.
    It uses the same suballocation pool as the xms code

Author:

    Dave Hastings (daveh) creation-date 09-Feb-1994

Notes:

    These functions claim to return NTSTATUS.  This is for commonality on
    x86 where we actually have an NTSTATUS to return.  For this file, we
    simply logically invert the bool and return that.  Callers of these 
    functions promise not to attach significance to the return values other
    than STATUS_SUCCESS.
    
Revision History:


--*/
#include "precomp.h"
#pragma hdrstop
#include <softpc.h>
#include <suballoc.h>
#include <xmsexp.h>
#include "memapi.h"


NTSTATUS
DpmiAllocateVirtualMemory(
    PVOID *Address,
    PULONG Size
    )
/*++

Routine Description:

    This routine allocates a chunk of extended memory for dpmi.

Arguments:

    Address -- Supplies a pointer to the Address.  This is filled in 
        if the allocation is successfull
    Size -- Supplies the size to allocate
    
Return Value:

    STATUS_SUCCESS if successfull.

--*/
{
    BOOL Success;
    NTSTATUS Status;

    Status = VdmAllocateVirtualMemory((PULONG)Address, *Size, TRUE);

    if (Status == STATUS_NOT_IMPLEMENTED) {
    
        ASSERT(STATUS_SUCCESS == 0);
        Success = SAAllocate(
            ExtMemSA,
            *Size,
            (PULONG)Address
            );
        
        //
        // Convert boolean to NTSTATUS (sort of)
        //
        if (Success) {
            Status = STATUS_SUCCESS;
        } else {
            Status = -1;
        }
    }

    return(Status);
}

NTSTATUS 
DpmiFreeVirtualMemory(
    PVOID *Address,
    PULONG Size
    )
/*++

Routine Description:

    This function frees memory for dpmi.  It is returned to the suballocation
    pool.

Arguments:

    Address -- Supplies the address of the block to free
    Size -- Supplies the size of the block to free
    
Return Value:

    STATUS_SUCCESS if successful
--*/
{
    BOOL Success;
    NTSTATUS Status;

    Status = VdmFreeVirtualMemory(*(PULONG)Address);

    if (Status == STATUS_NOT_IMPLEMENTED) {

        Success = SAFree(
            ExtMemSA,
            *Size,
            (ULONG)*Address
            );
               
        //
        // Convert boolean to NTSTATUS (sort of)
        //
        if (Success) {
            Status = STATUS_SUCCESS;
        } else {
            Status = -1;
        }
    }

    return(Status);
}

NTSTATUS
DpmiReallocateVirtualMemory(
    PVOID OldAddress,
    ULONG OldSize,
    PVOID *NewAddress,
    PULONG NewSize
    )
/*++

Routine Description:

    This function reallocates a block of memory for DPMI.

Arguments:

    OldAddress -- Supplies the original address for the block
    OldSize -- Supplies the original size for the address
    NewAddress -- Supplies the pointer to the place to return the new
        address
    NewSize -- Supplies the new size
    
Return Value:

    STATUS_SUCCESS if successfull
--*/
{
    NTSTATUS Status;
    BOOL Success;

    Status = VdmReallocateVirtualMemory((ULONG)OldAddress,
                                        (PULONG)NewAddress,
                                        *NewSize);

    if (Status == STATUS_NOT_IMPLEMENTED) {

        Success = SAReallocate(
            ExtMemSA,
            OldSize,
            (ULONG)OldAddress,
            *NewSize,
            (PULONG)NewAddress
            );
        
        //
        // Convert boolean to NTSTATUS (sort of)
        //
        if (Success) {
            Status = STATUS_SUCCESS;
        } else {
            Status = -1;
        }
    }

    return(Status);
    
}

VOID
DpmiGetMemoryInfo(
    VOID
    )
/*++

Routine Description:

    This routine returns information about memory to the dos extender

Arguments:

    None

Return Value:

    None.

--*/
{
    PDPMIMEMINFO UNALIGNED MemInfo;
    MEMORYSTATUS MemStatus;
    ULONG TotalFree, LargestFree;
    NTSTATUS Status;

    //
    // Get a pointer to the return structure
    //
    MemInfo = (PDPMIMEMINFO)Sim32GetVDMPointer(
        ((ULONG)getES()) << 16,
        1,
        TRUE
        );

    (CHAR *)MemInfo += (*GetDIRegister)();

    //
    // Initialize the structure
    //
    RtlFillMemory(MemInfo, sizeof(DPMIMEMINFO), 0xFF);

    //
    // Get the information on memory
    //
    Status = VdmQueryFreeVirtualMemory(
                &TotalFree,
                &LargestFree
                );

    if (Status == STATUS_NOT_IMPLEMENTED) {
        SAQueryFree(
            ExtMemSA,
            &TotalFree,
            &LargestFree
            );
    }
    
    //
    // Return the information.
    //
    // Filled in MaxUnlocked,MaxLocked,UnlockedPages fields in this structute.
    // Director 4.0 get completlely confused if these fields are -1.
    // MaxUnlocked is correct based on LargestFree. The other two are fake
    // and match values on a real WFW machine. I have no way of making them
    // any better than this at this point. who cares it makes director happy.
    //
    // sudeepb 01-Mar-1995.

    MemInfo->LargestFree = LargestFree;
    MemInfo->MaxUnlocked = LargestFree/4096;
    MemInfo->MaxLocked = 0xb61;
    MemInfo->AddressSpaceSize = 1024 * 1024 * 16 / 4096;
    MemInfo->UnlockedPages = 0xb68;
    MemInfo->FreePages = TotalFree / 4096;
    MemInfo->PhysicalPages = 1024 * 1024 * 16 / 4096;
    MemInfo->FreeAddressSpace = MemInfo->FreePages;
    
    //
    // Get the information on the page file
    //
    MemStatus.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus(&MemStatus);

    MemInfo->PageFileSize = MemStatus.dwTotalPageFile / 4096;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\int21map.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    int21map.h

Abstract:

    This is the private include file for int21 translation support

Author:

    Neil Sandlin (neilsa) 4-Dec-1996

Revision History:


--*/


VOID
NoTranslation(
    VOID
    );

VOID
DisplayString(
    VOID
    );

VOID
BufferedKeyboardInput(
    VOID
    );

VOID
FlushBuffReadKbd(
    VOID
    );

VOID
NotSupportedFCB(
    VOID
    );

VOID
FindFileFCB(
    VOID
    );

VOID
MapFCB(
    VOID
    );

VOID
RenameFCB(
    VOID
    );

VOID
SetDTA(
    VOID
    );

VOID
SetDTAPointers(
    VOID
    );

VOID
SetDosDTA(
    VOID
    );

VOID
GetDriveData(
    VOID
    );

VOID
CreatePSP(
    VOID
    );

VOID
ParseFilename(
    VOID
    );

VOID
GetDTA(
    VOID
    );

VOID
TSR(
    VOID
    );

VOID
GetDevParamBlock(
    VOID
    );

VOID
ReturnESBX(
    VOID
    );

VOID
GetSetCountry(
    VOID
    );

VOID
MapASCIIZDSDX(
    VOID
    );

VOID
ReadWriteFile(
    VOID
    );

VOID
MoveFilePointer(
    VOID
    );

VOID
IOCTL(
    VOID
    );

VOID
GetCurDir(
    VOID
    );

VOID
AllocateMemoryBlock(
    VOID
    );

VOID
FreeMemoryBlock(
    VOID
    );

VOID
ResizeMemoryBlock(
    VOID
    );

VOID
LoadExec(
    VOID
    );

VOID
Terminate(
    VOID
    );

VOID
FindFirstFileHandle(
    VOID
    );

VOID
FindNextFileHandle(
    VOID
    );

VOID
SetPSP(
    VOID
    );

VOID
GetPSP(
    VOID
    );

VOID
TranslateBPB(
    VOID
    );

VOID
RenameFile(
    VOID
    );

VOID
CreateTempFile(
    VOID
    );

VOID
Func5Dh(
    VOID
    );

VOID
Func5Eh(
    VOID
    );

VOID
Func5Fh(
    VOID
    );

VOID
NotSupportedBad(
    VOID
    );

VOID
ReturnDSSI(
    VOID
    );

VOID
NotSupportedBetter(
    VOID
    );

VOID
GetExtendedCountryInfo(
    VOID
    );

VOID
MapASCIIZDSSI(
    VOID
    );

VOID
IOCTLControlData(
    VOID
    );

VOID
MapDSDXLenCX(
    VOID
    );

VOID
IOCTLMap2Bytes(
    VOID
    );

VOID
IOCTLBlockDevs(
    VOID
    );

VOID
MapDPL(
    VOID
    );

VOID
GetMachineName(
    VOID
    );

VOID
GetPrinterSetup(
    VOID
    );

VOID
SetPrinterSetup(
    VOID
    );

VOID
IoctlReadWriteTrack(
    VOID
    );

VOID
GetDate(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\int21map.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Int21Map.c

Abstract:

    This module performs int 21 API translation for dpmi

Author:

    Dave Hastings (daveh) 23-Nov-1992


Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 - Updates for the 486 emulator

--*/
#include "precomp.h"
#pragma hdrstop
#include "int21map.h"
#include "softpc.h"
#include "xlathlp.h"
//
// Local constants
//
//#define Verbose 1
#define MAX_SUPPORTED_DOS_CALL 0x6d
#define DosxTranslated NULL

typedef VOID (*APIXLATFUNCTION)(VOID);
APIXLATFUNCTION ApiXlatTable[MAX_SUPPORTED_DOS_CALL] = {

    DosxTranslated                 , // 00h - Terminate process
    NoTranslation                  , // 01h - Char input with echo
    NoTranslation                  , // 02h - Character output
    NoTranslation                  , // 03h - Auxiliary input
    NoTranslation                  , // 04h - Auxiliary output
    NoTranslation                  , // 05h - Print character
    NoTranslation                  , // 06h - Direct console I/O
    NoTranslation                  , // 07h - Unfiltered char input
    NoTranslation                  , // 08h - Char input w/o echo
    DisplayString                  , // 09h - Display "$" term string
    BufferedKeyboardInput          , // 0Ah - Buffered keyboard input
    NoTranslation                  , // 0Bh - Check keyboard status
    FlushBuffReadKbd               , // 0Ch - Flush buff, Read kbd
    NoTranslation                  , // 0Dh - Disk reset
    NoTranslation                  , // 0Eh - Select disk
    NotSupportedFCB                , // 0Fh * Open file with FCB
    NotSupportedFCB                , // 10h * Close file with FCB
    FindFileFCB                    , // 11h - Find First File
    FindFileFCB                    , // 12h - Find Next File
    MapFCB                         , // 13h - Delete File
    NotSupportedFCB                , // 14h * Sequential Read
    NotSupportedFCB                , // 15h * Sequential Write
    NotSupportedFCB                , // 16h * Create File With FCB
    RenameFCB                      , // 17h - Rename File With FCB
    NoTranslation                  , // 18h - UNUSED
    NoTranslation                  , // 19h - Get Current Disk
    SetDTA                         , // 1Ah - Set DTA Address
    GetDriveData                   , // 1Bh - Get Default Drive Data
    GetDriveData                   , // 1Ch - Get Drive Data
    NoTranslation                  , // 1Dh - UNUSED
    NoTranslation                  , // 1Eh - UNUSED
    GetDriveData                   , // 1Fh - Get Drive Parameter Blk
    NoTranslation                  , // 20h - UNUSED
    NotSupportedFCB                , // 21h * Random Read
    NotSupportedFCB                , // 22h * Random Write
    NotSupportedFCB                , // 23h * Get File Size
    NotSupportedFCB                , // 24h * Set Relative Record
    SetVector                      , // 25h - Set interrupt vector
    CreatePSP                      , // 26h - Create PSP
    NotSupportedFCB                , // 27h * Random block read
    NotSupportedFCB                , // 28h * Random block write
    ParseFilename                  , // 29h - Parse filename
    GetDate                        , // 2Ah - Get date
    NoTranslation                  , // 2Bh - Set date
    NoTranslation                  , // 2Ch - Get time
    NoTranslation                  , // 2Dh - Set time
    NoTranslation                  , // 2Eh - Set/Reset verify flag
    GetDTA                         , // 2Fh - Get DTA address
    NoTranslation                  , // 30h - Get DOS version
    TSR                            , // 31h - Terminate and Stay Res
    GetDevParamBlock               , // 32h - Get device parameter blk
    NoTranslation                  , // 33h - Get/Set Control-C Flag
    ReturnESBX                     , // 34h - Get Address of InDOS
    GetVector                      , // 35h - Get Interrupt Vector
    NoTranslation                  , // 36h - Get Disk Free Space
    NoTranslation                  , // 37h - Char Oper
    GetSetCountry                  , // 38h - Get/Set Current Country
    MapASCIIZDSDX                  , // 39h - Create Directory
    MapASCIIZDSDX                  , // 3Ah - Remove Directory
    MapASCIIZDSDX                  , // 3Bh - Change Current Directory
    MapASCIIZDSDX                  , // 3Ch - Create File with Handle
    MapASCIIZDSDX                  , // 3Dh - Open File with Handle
    NoTranslation                  , // 3Eh - Close File with Handle
    ReadWriteFile                  , // 3Fh - Read File or Device
    ReadWriteFile                  , // 40h - Write File or Device
    MapASCIIZDSDX                  , // 41h - Delete File
    NoTranslation                  , // 42h - Move file pointer
    MapASCIIZDSDX                  , // 43h - Get/Set File Attributes
    IOCTL                          , // 44h - IOCTL
    NoTranslation                  , // 45h - Duplicate File Handle
    NoTranslation                  , // 46h - Force Duplicate Handle
    GetCurDir                      , // 47h - Get Current Directory
    AllocateMemoryBlock            , // 48h - Allocate Memory Block
    FreeMemoryBlock                , // 49h - Free Memory Block
    ResizeMemoryBlock              , // 4Ah - Resize Memory Block
    LoadExec                       , // 4Bh - Load and Exec Program
    DosxTranslated                 , // 4Ch - Terminate with Ret Code
    NoTranslation                  , // 4Dh - Get Ret Code Child Proc
    FindFirstFileHandle            , // 4Eh - Find First File
    FindNextFileHandle             , // 4Fh - Find Next File
    SetPSP                         , // 50h - Set PSP Segment
    GetPSP                         , // 51h - Get PSP Segment
    ReturnESBX                     , // 52h - Get List of Lists (invars)
    TranslateBPB                   , // 53h - Translate BPB
    NoTranslation                  , // 54h - Get Verify Flag
    CreatePSP                      , // 55h - Create PSP
    RenameFile                     , // 56h - Rename File
    NoTranslation                  , // 57h - Get/Set Date/Time File
    NoTranslation                  , // 58h - Get/Set Alloc Strategy
    NoTranslation                  , // 59h - Get Extended Error Info
    CreateTempFile                 , // 5Ah - Create Temporary File
    MapASCIIZDSDX                  , // 5Bh - Create New File
    NoTranslation                  , // 5Ch - Lock/Unlock File Region
    Func5Dh                        , // 5Dh - Server DOS call
    Func5Eh                        , // 5Eh - Net Name/Printer Setup
    Func5Fh                        , // 5Fh - Network redir stuff
    NotSupportedBad                , // 60h - NameTrans
    NoTranslation                  , // 61h - UNUSED
    GetPSP                         , // 62h - Get PSP Address
#ifdef DBCS
    ReturnDSSI                     , // 63h - Get DBCS Vector
#else
    NotSupportedBetter             , // 63h - Hangool call
#endif
    NotSupportedBad                , // 64h - Set Prn Flag
    GetExtendedCountryInfo         , // 65h - Get Extended Country Info
    NoTranslation                  , // 66h - Get/Set Global Code Page
    NoTranslation                  , // 67h - Set Handle Count
    NoTranslation                  , // 68h - Commit File
    NoTranslation                  , // 69h -
    NoTranslation                  , // 6Ah -
    NoTranslation                  , // 6Bh -
    MapASCIIZDSSI                    // 6Ch - Extended open
};

VOID
DpmiXlatInt21Call(
    VOID
    )
/*++

Routine Description:

    This routine dispatches to the appropriate routine to perform the
    actual translation of the api

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    ULONG DosMajorCode;
    PUCHAR StackPointer;

    //
    // Pop ds from stack
    //
    StackPointer = Sim32GetVDMPointer(
        ((ULONG)getSS() << 16),
        1,
        TRUE
        );

    StackPointer += (*GetSPRegister)();

    setDS(*(PWORD16)StackPointer);

    (*SetSPRegister)((*GetSPRegister)() + 2);

    DosMajorCode = getAH();

    if (DosMajorCode >= MAX_SUPPORTED_DOS_CALL) {
        return;
    }

    if (ApiXlatTable[DosMajorCode]) {

        ULONG Eip, Esp;
        USHORT Cs, Ss;

        Eip = getEIP();
        Esp = getESP();
        Cs = getCS();
        Ss = getSS();

        (*ApiXlatTable[DosMajorCode])();

        setEIP(Eip);
        setESP(Esp);
        setCS(Cs);
        setSS(Ss);

        SimulateIret(PASS_CARRY_FLAG_16);
    }

    // put this back in after beta 2.5
    DpmiFreeAllBuffers();

}

VOID
NoTranslation(
    VOID
    )
/*++

Routine Description:

    This routine handles int 21 functions which don't need any translation.
    It simply executes the int 21 in real/v86 mode

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    DpmiSwitchToRealMode();
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();
}

VOID
DisplayString(
    VOID
    )
/*++

Routine Description:

    This routine translates the int 21 display string function.

    N.B. Win 3.1 does this by calling int 21 function 2 repeatedly.
         We do it this way because Win 3.1 does.  If this function is
         frequently used, we should actually buffer the string and
         call the dos display string function.

Arguments:

    None

Return Value:

    None.

--*/
{   PUCHAR String;
    DECLARE_LocalVdmContext;
    USHORT ClientAX, ClientDX;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();

    String = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
             + (*GetDXRegister)();

    //
    // Repeatedly call int 21 function 2 to display the characters
    //
    ClientAX = getAX();
    ClientDX = getDX();
    setAH(2);
    while (*(String) != '$') {
        setDL(*(String));
        DPMI_EXEC_INT(0x21);
        String++;
    }
    setAX(ClientAX);
    setDX(ClientDX);

    DpmiSwitchToProtectedMode();
}

VOID
BufferedKeyboardInput(
    VOID
    )
/*++

Routine Description:

    This routine performs the tranlation for the int 21 function Ah

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR PmInputBuffer, RmInputBuffer;
    USHORT BufferSeg, BufferOff, BufferLen;
    USHORT ClientDX;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    //
    // Get a pointer to the PM buffer
    //
    PmInputBuffer = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                    + (*GetDXRegister)();

    //
    // Get the buffer length (there are two bytes in addition to the
    // buffer)
    //
    BufferLen = *PmInputBuffer + 2;

    //
    // Move the buffer to low memory
    //
    RmInputBuffer = DpmiMapAndCopyBuffer(PmInputBuffer, BufferLen);

    //
    // Set up the registers for the int 21 call
    //
    DPMI_FLAT_TO_SEGMENTED(RmInputBuffer, &BufferSeg, &BufferOff);
    setDS(BufferSeg);
    setDX(BufferOff);

    DPMI_EXEC_INT(0x21);

    //
    // Copy the data back
    //
    DpmiUnmapAndCopyBuffer(PmInputBuffer, RmInputBuffer, BufferLen);

    setDX(ClientDX);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);

}

VOID
FlushBuffReadKbd(
    VOID
    )
/*++

Routine Description:

    This routine performs translation for the flush keyboard routines.
    It calls the appropriate xlat routine.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    if (getAL() == 0x0a) {
        BufferedKeyboardInput();
    } else {
        NoTranslation();
    }
}

VOID
NotSupportedFCB(
    VOID
    )
/*++

Routine Description:

    This routine does not do any translation.  It prints a warning to
    the debugger

Arguments:

    None.

Return Value:

    None.

--*/
{
#if DBG
    DECLARE_LocalVdmContext;

    DbgPrint(
        "WARNING: DOS INT 21 call AH = %x will not be translated.\n", getAH());
    DbgPrint(
        "         Protected mode applications should not be using\n");
    DbgPrint(
        "         this type of FCB call. Convert this application\n");
    DbgPrint(
        "         to use the handle calls.\n"
    );
#endif
    NoTranslation();
}

VOID
FindFileFCB(
    VOID
    )
/*++

Routine Description:

    This function translates the find first/find next FCB calls.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR FcbAddress, FcbBufferedAddress;
    USHORT FcbSegment, FcbOffset;
    USHORT ClientDX;
    USHORT FcbLength;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    SetDTAPointers();
    ClientDX = getDX();

    FcbAddress = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                 + (*GetDXRegister)();

    //
    // Calculate the size of the FCB
    //
    FcbLength = DpmiCalcFcbLength(FcbAddress);

    //
    // Buffer the FCB
    //
    FcbBufferedAddress = DpmiMapAndCopyBuffer(FcbAddress, FcbLength);

    //
    // Check to see if we need to set the real dta
    //
    if (CurrentDosDta != CurrentDta)
        SetDosDTA();

    //
    // Make the int 21 call
    //

    DPMI_FLAT_TO_SEGMENTED(FcbBufferedAddress, &FcbSegment, &FcbOffset);
    setDS(FcbSegment);
    setDX(FcbOffset);
    DPMI_EXEC_INT(0x21);

    //
    // If the call was successful and the PM dta is in high memory
    //  copy the dta to high memory
    //
    if ((getAL() == 0) && (CurrentPmDtaAddress != CurrentDta)) {
        MoveMemory(CurrentPmDtaAddress, CurrentDta, FcbLength);
        DpmiUnmapAndCopyBuffer(FcbAddress, FcbBufferedAddress, FcbLength);
    } else {
        DpmiUnmapBuffer(FcbBufferedAddress, FcbLength);
    }

    setDX(ClientDX);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);
}

VOID
MapFCB(
    VOID
    )
/*++

Routine Description:

    This routine translates the delete file fcb int 21 call

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT FcbLength, FcbSegment, FcbOffset;
    PUCHAR FcbAddress, FcbBufferedAddress;
    USHORT ClientDX;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    FcbAddress = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                 + (*GetDXRegister)();

    //
    // Get the length of the FCB
    //
    FcbLength = DpmiCalcFcbLength(FcbAddress);

    //
    // Copy the FCB
    //
    FcbBufferedAddress = DpmiMapAndCopyBuffer(FcbAddress,  FcbLength);

    //
    // Make the int 21 call
    //
    DPMI_FLAT_TO_SEGMENTED(FcbBufferedAddress, &FcbSegment, &FcbOffset);
    setDS(FcbSegment);
    setDX(FcbOffset);
    DPMI_EXEC_INT(0x21);

    //
    // Copy the FCB back
    //
    DpmiUnmapAndCopyBuffer(FcbAddress, FcbBufferedAddress, FcbLength);

    //
    // Clean up
    //
    setDX(ClientDX);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);
}

VOID
RenameFCB(
    VOID
    )
/*++

Routine Description:

    This routine translates the rename fcb int 21 function

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT FcbSegment, FcbOffset;
    PUCHAR FcbAddress, FcbBufferedAddress;
    USHORT ClientDX;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    FcbAddress = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                 + (*GetDXRegister)();

    //
    // Copy the FCB (The fcb for rename is a special format, fixed size)
    //
    FcbBufferedAddress = DpmiMapAndCopyBuffer(FcbAddress,  0x25);

    //
    // Make the int 21 call
    //
    DPMI_FLAT_TO_SEGMENTED(FcbBufferedAddress, &FcbSegment, &FcbOffset);
    setDS(FcbSegment);
    setDX(FcbOffset);
    DPMI_EXEC_INT(0x21);

    //
    // Copy the FCB back
    //
    DpmiUnmapAndCopyBuffer(FcbAddress, FcbAddress, 0x25);

    //
    // Clean up
    //
    setDX(ClientDX);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);
}

VOID
GetDriveData(
    VOID
    )
/*++

Routine Description:

    Translates the drive data int 21 calls

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Selector;

    DpmiSwitchToRealMode();
    DPMI_EXEC_INT(0x21);
    Selector = getDS();
    DpmiSwitchToProtectedMode();

    setDS(SegmentToSelector(Selector, STD_DATA));
    (*SetBXRegister)((ULONG)getBX());

}

VOID
SetVector(
    VOID
    )
/*++

Routine Description:

    This function translates int 21 function 25

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    SetProtectedModeInterrupt(getAL(), getDS(), (*GetDXRegister)(),
                              (USHORT)(Frame32 ? VDM_INT_32 : VDM_INT_16));

}

VOID
CreatePSP(
    VOID
    )
/*++

Routine Description:

    This routine translates the selector to a segment and reflects the
    calls

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    ULONG Segment;
    USHORT ClientDX;

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    Segment = SELECTOR_TO_INTEL_LINEAR_ADDRESS(ClientDX);

    if (Segment > ONE_MB) {
        //
        // Create PSP doesn't do anything on error
        //
    } else {
        setDX((USHORT) (Segment >> 4));
        DPMI_EXEC_INT(0x21);
    }

    setDX(ClientDX);
    DpmiSwitchToProtectedMode();

}

VOID
ParseFilename(
    VOID
    )
/*++

Routine Description:

    This routine translates the int 21 parse filename api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientSI, ClientDI, FcbLength, StringOff, Seg, Off;
    PUCHAR Fcb, BufferedFcb, String, BufferedString;
    USHORT ClientDS = getDS();
    USHORT ClientES = getES();

    DpmiSwitchToRealMode();
    ClientSI = getSI();
    ClientDI = getDI();

    Fcb = Sim32GetVDMPointer(((ULONG)ClientES << 16), 1, TRUE)
          + (*GetDIRegister)();

    FcbLength = DpmiCalcFcbLength(Fcb);

    BufferedFcb = DpmiMapAndCopyBuffer(Fcb, FcbLength);

    String = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
             + (*GetSIRegister)();

    BufferedString = DpmiMapAndCopyBuffer(String, 20);

    DPMI_FLAT_TO_SEGMENTED(BufferedFcb, &Seg, &Off);
    setES(Seg);
    setDI(Off);
    DPMI_FLAT_TO_SEGMENTED(BufferedString, &Seg, &StringOff);
    setDS(Seg);
    setSI(StringOff);

    DPMI_EXEC_INT(0x21);

    DpmiUnmapAndCopyBuffer(Fcb, BufferedFcb, FcbLength);
    DpmiUnmapAndCopyBuffer(String, BufferedString, 20);

    setDI(ClientDI);
    setSI(ClientSI + (getSI() - StringOff));
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);
    setES(ClientES);
}

VOID
GetDTA(
    VOID
    )
/*++

Routine Description:

    This routine returns the current DTA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    //
    // Win31 compatibility:
    //
    // Some hosebag programs set the DTA to a selector that they later free!
    // This test makes sure that this does not cause us to crash.
    //

    if (!SEGMENT_IS_WRITABLE(CurrentDtaSelector)) {
        CurrentDtaSelector = 0;
        CurrentDtaOffset = 0;
    }

    setES(CurrentDtaSelector);
    setBX(CurrentDtaOffset);
    setCF(0);

}

VOID
SetDTA(
    VOID
    )
/*++

Routine Description:

    This routine sets the PM dta address.  If the buffer is usable directly,
    CurrentDta is set to the translated address. Otherwise, it is set to
    the dosx dta.

    N.B.  The Set Dta call is not actually reflected to Dos until a function
          call is made that actually uses the Dta, e.g. the Find First/Next
          functions. This techique was implemented to match what is done in
          Win 3.1.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX;

    ClientDX = getDX();
    CurrentDtaOffset = ClientDX;
    CurrentDtaSelector = getDS();

    //
    // Make sure real DTA is updated later
    //
    CurrentDosDta = (PUCHAR) NULL;

}

VOID
SetDTAPointers(
    VOID
    )
/*++

Routine Description:

    This routine sets up the flat address values used elsewhere to
    reference the current DTA.

    N.B. This must be done on every entry to handle function calls because
    the PM dta may have been GlobalRealloc'd. This may change the base
    address of the PM selector (which invalidates the flat addresses),
    but not the selector/offset itself.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PUCHAR NewDta;

    NewDta = Sim32GetVDMPointer(
        (CurrentDtaSelector << 16),
        1,
        TRUE
        );

    NewDta += CurrentDtaOffset;
    CurrentPmDtaAddress = NewDta;

    //
    // If the new dta is not accessible in v86 mode, use the one
    // supplied by Dosx
    //
    if ((ULONG)(NewDta + 128 - IntelBase) > MAX_V86_ADDRESS) {
        NewDta = DosxDtaBuffer;
    }

    //
    // Update Current DTA information
    //
    CurrentDta = NewDta;
}


VOID
SetDosDTA(
    VOID
    )
/*++

Routine Description:

    This routine is called internally by other functions in this module
    to reflect a Set Dta call to Dos.

    WARNING: The client must be in REAL mode


Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientAX, ClientDX, ClientDS, NewDtaSegment, NewDtaOffset;

    ASSERT((getMSW() & MSW_PE) == 0);

    ClientAX = getAX();
    ClientDX = getDX();
    ClientDS = getDS();

    DPMI_FLAT_TO_SEGMENTED(CurrentDta, &NewDtaSegment, &NewDtaOffset);
    setDS(NewDtaSegment);
    setDX(NewDtaOffset);
    setAH(0x1a);

    DPMI_EXEC_INT(0x21);

    setAX(ClientAX);
    setDX(ClientDX);
    setDS(ClientDS);
    CurrentDosDta = CurrentDta;

}

VOID
TSR(
    VOID
    )
/*++

Routine Description:

    This function translates int 21h tsr.  Win 3.1 does some
    magic here.  We didn't before and it worked fine.  Maybe
    we will later.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NoTranslation();
}

VOID
GetDevParamBlock(
    VOID
    )
/*++

Routine Description:

    This routine translates the Device Parameter Block apis

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Selector;

    DpmiSwitchToRealMode();
    DPMI_EXEC_INT(0x21);
    Selector = getDS();
    DpmiSwitchToProtectedMode();

    setDS(SegmentToSelector(Selector, STD_DATA));
    (*SetBXRegister)((ULONG)getBX());

}

VOID
ReturnESBX(
    VOID
    )
/*++

Routine Description:

    This function translates api that return information in es:bx

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Selector;

    DpmiSwitchToRealMode();
    DPMI_EXEC_INT(0x21);
    Selector = getES();
    DpmiSwitchToProtectedMode();

    (*SetBXRegister)((ULONG)getBX());
    setES(SegmentToSelector(Selector, STD_DATA));

}

VOID
GetVector(
    VOID
    )
/*++

Routine Description:

    This function translates int 21 function 35

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;
    USHORT IntNumber = getAL();

    setES(Handlers[IntNumber].CsSelector);
    (*SetBXRegister)(Handlers[IntNumber].Eip);

}

VOID
GetSetCountry(
    VOID
    )
/*++

Routine Description:

    This function translates int 21 function 38

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    if (getDX() == 0xFFFF) {
        NoTranslation();
    } else {

        USHORT ClientDX, Seg, Off;
        PUCHAR Country, BufferedCountry;
        USHORT ClientDS = getDS();

        DpmiSwitchToRealMode();
        ClientDX = getDX();

        Country = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                  + (*GetDXRegister)();

        BufferedCountry = DpmiMapAndCopyBuffer(Country, 34);

        DPMI_FLAT_TO_SEGMENTED(BufferedCountry, &Seg, &Off);
        setDS(Seg);
        setDX(Off);

        DPMI_EXEC_INT(0x21);
        DpmiSwitchToProtectedMode();

        DpmiUnmapAndCopyBuffer(Country, BufferedCountry, 34);

        setDX(ClientDX);
        setDS(ClientDS);
    }
}

VOID
MapASCIIZDSDX(
    VOID
    )
/*++

Routine Description:

    This routine maps the int 21 functions that pass file names in
    ds:dx

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR BufferedString;
    USHORT ClientDX, StringSeg, StringOff, Length;
    USHORT ClientDS = getDS();

    BufferedString = DpmiMapString(ClientDS, (GetDXRegister)(), &Length);
    if (BufferedString == NULL) {
        setCF(1);
        setAX(3);
    } else {
        DpmiSwitchToRealMode();
        ClientDX = getDX();

        DPMI_FLAT_TO_SEGMENTED(BufferedString, &StringSeg, &StringOff);
        setDS(StringSeg);
        setDX(StringOff);
        DPMI_EXEC_INT(0x21);
        DpmiSwitchToProtectedMode();

        DpmiUnmapString(BufferedString, Length);
        setDX(ClientDX);
        setDS(ClientDS);
    }
}

VOID
ReadWriteFile(
    VOID
    )
/*++

Routine Description:

    This routine translates the read/write file int 21 calls.  Large reads
    are broken down into 4k chunks.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientCX, ClientDX, ClientAX, Function, DataSeg, DataOff, BytesToRead;
    ULONG BytesRead, TotalBytesToRead;
    PUCHAR ReadWriteData, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();

    ClientCX = getCX();
    ClientDX = getDX();
    Function = getAH();
    ClientAX = getAX();

    TotalBytesToRead = (*GetCXRegister)();
    BytesRead = 0;

    ReadWriteData = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                    + (*GetDXRegister)();

//    while (TotalBytesToRead != BytesRead) {
    do {

        if ((TotalBytesToRead - BytesRead) > 1024 * 4) {
            BytesToRead = 4 * 1024;
        } else {
            BytesToRead = (USHORT)(TotalBytesToRead - BytesRead);
        }

        BufferedData = DpmiMapAndCopyBuffer(ReadWriteData, BytesToRead);

        DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);
        setDS(DataSeg);
        setDX(DataOff);
        setCX(BytesToRead);
        setAX(ClientAX);

        DPMI_EXEC_INT(0x21);

        if (getCF()) {
            DpmiUnmapBuffer(BufferedData, BytesToRead);
            break;
        }

        if (getAX() == 0) {
            DpmiUnmapBuffer(BufferedData, BytesToRead);
            break;
        } else if (getAX() < BytesToRead) {
            CopyMemory(ReadWriteData, BufferedData, getAX());
            DpmiUnmapBuffer(BufferedData, BytesToRead);
            BytesRead += getAX();
            break;
        } else {
            DpmiUnmapAndCopyBuffer(
                ReadWriteData,
                BufferedData,
                BytesToRead
                );
        }

        ReadWriteData += getAX();
        BytesRead += getAX();
//    }
    } while (TotalBytesToRead != BytesRead);
    setDX(ClientDX);
    setCX(ClientCX);
    if (!getCF()) {
        (*SetAXRegister)(BytesRead);
    }
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);
}

#define MAX_SUPPORTED_DOS_IOCTL_CALL 0x10

//
// Note:  The translations here differ from those in the windows dpmi vxd,
//        because we do not have to lock memory, and we don't support block
//        device drivers.
//

APIXLATFUNCTION IOCTLXlatTable[MAX_SUPPORTED_DOS_IOCTL_CALL] = {
         NoTranslation    , // 00 - Get Device Data
         NoTranslation    , // 01 - Set Device Data
         MapDSDXLenCX     , // 02 - Receive Ctrl Chr Data
         MapDSDXLenCX     , // 03 - Send Ctrl Chr Data
         MapDSDXLenCX     , // 04 - Receive Ctrl Block Data
         MapDSDXLenCX     , // 05 - Send Ctrl Block Data
         NoTranslation    , // 06 - Check Input Status
         NoTranslation    , // 07 - Check Output Status
         NoTranslation    , // 08 - Check Block Dev Removable
         NoTranslation    , // 09 - Check Block Dev Remote
         NoTranslation    , // 0A - Check if Handle Remote
         NoTranslation    , // 0B - Change sharing retry cnt
         IOCTLMap2Bytes   , // 0C - MAP DS:DX LENGTH 2!
         IOCTLBlockDevs   , // 0D - Generic IOCTL to blk dev
         NoTranslation    , // 0E - Get Logical Drive Map
         NoTranslation      // 0F - Set Logical Drive Map
};

VOID
IOCTL(
    VOID
    )
/*++

Routine Description:

    This function translates the int 21 ioctl function.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT IoctlMinor;

    IoctlMinor = getAL();

    if (IoctlMinor >= MAX_SUPPORTED_DOS_IOCTL_CALL) {
#if DBG
        OutputDebugString("DPMI: IOCTL DOS CALL NOT SUPPORTED\n");
#endif
        NoTranslation();
        return;
    }

    (*IOCTLXlatTable[IoctlMinor])();
}

VOID
GetCurDir(
    VOID
    )
/*++

Routine Description:

    This routine translates the get current directory call

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR DirInfo, BufferedDirInfo;
    USHORT ClientSI, Seg, Off;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientSI = getSI();

    DirInfo = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
              + (*GetSIRegister)();

    BufferedDirInfo = DpmiMapAndCopyBuffer(DirInfo, 64);
    DPMI_FLAT_TO_SEGMENTED(BufferedDirInfo, &Seg, &Off);
    setDS(Seg);
    setSI(Off);

    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(DirInfo, BufferedDirInfo, 64);
    setSI(ClientSI);
    setDS(ClientDS);
}

VOID
AllocateMemoryBlock(
    VOID
    )
/*++

Routine Description:

    This routine translates the AllocateMemory Int 21 api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI pMem;
    ULONG MemSize = ((ULONG)getBX()) << 4;

    pMem = DpmiAllocateXmem(MemSize);

    if (pMem) {

        pMem->SelCount = (USHORT) ((MemSize>>16) + 1);
        pMem->Sel = ALLOCATE_SELECTORS(pMem->SelCount);

        if (!pMem->Sel) {
            pMem->SelCount = 0;
            DpmiFreeXmem(pMem);
            pMem = NULL;
        } else {

            SetDescriptorArray(pMem->Sel, (ULONG)pMem->Address, MemSize);

        }
    }

    if (!pMem) {
        setCF(1);
        setAX(8);
        setBX(0);
    } else {
        setCF(0);
        setAX(pMem->Sel);
    }
}

VOID
FreeMemoryBlock(
    VOID
    )
/*++

Routine Description:

    This routine translates the ResizeMemory Int 21 api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI pMem;
    USHORT Sel = getES();

    if (pMem = DpmiFindXmem(Sel)) {

        while(pMem->SelCount--) {
            FreeSelector(Sel);
            Sel+=8;
        }

        DpmiFreeXmem(pMem);
        setCF(0);

    } else {

        setCF(1);
        setAX(9);

    }
}

VOID
ResizeMemoryBlock(
    VOID
    )
/*++

Routine Description:

    This routine translates the ResizeMemory int 21 api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI pMem;
    ULONG MemSize = ((ULONG)getBX()) << 4;
    USHORT Sel = getES();

    if (pMem = DpmiFindXmem(Sel)) {

        if (DpmiReallocateXmem(pMem, MemSize)) {

            SetDescriptorArray(pMem->Sel, (ULONG)pMem->Address, MemSize);
            setCF(0);

        } else {

            // not enough memory
            setCF(1);
            setAX(8);

        }
    } else {

        // invalid block
        setCF(1);
        setAX(9);

    }
}

VOID
LoadExec(
    VOID
    )
/*++

Routine Description:

    This function translates the int 21 load exec function.  Load overlay
    is not supported.

    The child always inherits the environment, and the fcbs in the parameter
    block are ignored. (win 3.1 does this)

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR CommandTail, BufferedString, Environment;
    USHORT ClientDX, ClientBX, Seg, Off, Length, i, EnvironmentSel;
    USHORT ClientDS = getDS();
    USHORT ClientES = getES();

    DpmiSwitchToRealMode();
    ClientDX = getDX();
    ClientBX = getBX();

    if (getAL() == 3) {
        setCF(1);
        setAX(1);
    } else {

        //
        // Map the command string
        //
        BufferedString = DpmiMapString(ClientDS, (*GetDXRegister)(), &Length);
        if (BufferedString == NULL) {
            setCF(1);
            setAX(3);
        } else {
            //
            // Make sure real DTA is updated later
            //
            CurrentDosDta = (PUCHAR) NULL;

            //
            // Set up the Parameter block
            //
            // We use the large xlat buffer.  The parameter block comes
            // first, and we fill in the command tail after
            //
            ZeroMemory(LargeXlatBuffer, 512);

            //
            // The environment segment address is now set
            //

            //
            // Set the command tail address, and copy the command tail (all
            // 128 bytes
            //
            DPMI_FLAT_TO_SEGMENTED((LargeXlatBuffer + 0x10), &Seg, &Off)
            *(PWORD16)(LargeXlatBuffer + 2) = Off;
            *(PWORD16)(LargeXlatBuffer + 4) = Seg;

            //
            // CommandTail = FLAT(es:bx)
            //
            CommandTail = Sim32GetVDMPointer(((ULONG)ClientES << 16), 1, TRUE)
                          + (*GetBXRegister)();

            if (CurrentAppFlags & DPMI_32BIT) {
                //
                // CommandTail -> string
                //
                CommandTail = Sim32GetVDMPointer((*(PWORD16)(CommandTail + 4)) << 16, 1, TRUE)
                              + *(PDWORD16)(CommandTail);

            } else {
                //
                // CommandTail -> string
                //
                CommandTail = Sim32GetVDMPointer(*(PDWORD16)(CommandTail + 2), 1, TRUE);
            }

            CopyMemory((LargeXlatBuffer + 0x10), CommandTail, 128);

            //
            // Set FCB pointers and put spaces in the file names
            //
            DPMI_FLAT_TO_SEGMENTED((LargeXlatBuffer + 144), &Seg, &Off)
            *(PWORD16)(LargeXlatBuffer + 6) = Off;
            *(PWORD16)(LargeXlatBuffer + 8) = Seg;
            for (i = 0; i < 11; i++) {
                (LargeXlatBuffer + 144 + 1)[i] = ' ';
            }

            DPMI_FLAT_TO_SEGMENTED((LargeXlatBuffer + 188), &Seg, &Off)
            *(PWORD16)(LargeXlatBuffer + 0xA) = Off;
            *(PWORD16)(LargeXlatBuffer + 0xC) = Seg;
            for (i = 0; i < 11; i++) {
                (LargeXlatBuffer + 188 + 1)[i] = ' ';
            }

            //
            // Save the environment selector, and make it a segment
            //

            Environment = Sim32GetVDMPointer(((ULONG)CurrentPSPSelector << 16) | 0x2C, 1, TRUE);

            EnvironmentSel = *(PWORD16)Environment;

            *(PWORD16)Environment =
                (USHORT)(SELECTOR_TO_INTEL_LINEAR_ADDRESS(EnvironmentSel) >> 4);

            //
            // Set up registers for the exec
            //
            DPMI_FLAT_TO_SEGMENTED(BufferedString, &Seg, &Off);
            setDS(Seg);
            setDX(Off);
            DPMI_FLAT_TO_SEGMENTED(LargeXlatBuffer, &Seg, &Off);
            setES(Seg);
            setBX(Off);

            DPMI_EXEC_INT(0x21);

            //
            // Restore the environment selector
            //
            Environment = Sim32GetVDMPointer(((ULONG)CurrentPSPSelector << 16) | 0x2C, 1, TRUE);

            *(PWORD16)Environment = EnvironmentSel;

            //
            // Free translation buffer
            //

            DpmiUnmapString(BufferedString, Length);
        }
    }
    setDX(ClientDX);
    setBX(ClientBX);
    DpmiSwitchToProtectedMode();
    setES(ClientES);
    setDS(ClientDS);
}

VOID
Terminate(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    // bugbug We're currently mapping this one in the dos extender
}

VOID
FindFirstFileHandle(
    VOID
    )
/*++

Routine Description:

    This routine translates the find first api.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, Seg, Off, StringLength;
    PUCHAR BufferedString;
    USHORT ClientDS = getDS();

    //
    // map the string
    //
    BufferedString = DpmiMapString(ClientDS, (GetDXRegister)(), &StringLength);
    if (BufferedString == NULL) {
        setCF(1);
        setAX(3);
    } else {
        DpmiSwitchToRealMode();
        SetDTAPointers();
        ClientDX = getDX();

        //
        // Copy the DTA (if necessary)
        //
        if (CurrentDta != CurrentPmDtaAddress) {
            CopyMemory(CurrentDta, CurrentPmDtaAddress, 43);
        }

        //
        // Check to see if we need to set the real dta
        //
        if (CurrentDosDta != CurrentDta)
            SetDosDTA();

        DPMI_FLAT_TO_SEGMENTED(BufferedString, &Seg, &Off);
        setDS(Seg);
        setDX(Off);

        DPMI_EXEC_INT(0x21);
        DpmiSwitchToProtectedMode();
        setDS(ClientDS);

        DpmiUnmapString(BufferedString, StringLength);

        //
        // Copy the DTA back (if necessary)
        //
        if (CurrentDta != CurrentPmDtaAddress) {
            CopyMemory(CurrentPmDtaAddress, CurrentDta, 43);
        }

        setDX(ClientDX);
    }

}


VOID
FindNextFileHandle(
    VOID
    )
/*++

Routine Description:

    This routine translates the find next api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    DpmiSwitchToRealMode();
    SetDTAPointers();

    //
    // Copy the DTA (if necessary)
    //
    if (CurrentDta != CurrentPmDtaAddress) {
        CopyMemory(CurrentDta, CurrentPmDtaAddress, 43);
    }

    //
    // Check to see if we need to set the real dta
    //
    if (CurrentDosDta != CurrentDta)
        SetDosDTA();

    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    //
    // Copy the DTA back (if necessary)
    //
    if (CurrentDta != CurrentPmDtaAddress) {
        CopyMemory(CurrentPmDtaAddress, CurrentDta, 43);
    }

}

VOID
SetPSP(
    VOID
    )
/*++

Routine Description:

    This routine translates the set psp api.  This is substantially the
    same as CreatePSP, except that this can fail (and return carry).  It
    also remembers the PSP selector, so we can return it on request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    ULONG Segment;
    USHORT ClientBX;

    DpmiSwitchToRealMode();
    ClientBX = getBX();

    if (ClientBX == 0) {
        CurrentPSPSelector = ClientBX;
    } else {
        Segment = SELECTOR_TO_INTEL_LINEAR_ADDRESS(ClientBX);

        if (Segment > ONE_MB) {

            setCF(1);

        } else {
            setBX((USHORT) (Segment >> 4));
            DPMI_EXEC_INT(0x21);
            CurrentPSPSelector = ClientBX;
        }
    }

    setBX(ClientBX);
    DpmiSwitchToProtectedMode();
}

VOID
GetPSP(
    VOID
    )
/*++

Routine Description:

    This routine returns the current PSP selector

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    DpmiSwitchToRealMode();
    //
    // Get the current psp segment to see if it changed
    //
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    //
    // If it changed get a new selector for the psp
    //
    if (getBX() !=
        (USHORT)(SELECTOR_TO_INTEL_LINEAR_ADDRESS(CurrentPSPSelector) >> 4)
    ){
        CurrentPSPSelector = SegmentToSelector(getBX(), STD_DATA);
    }

    setBX(CurrentPSPSelector);
    setCF(0);

}

VOID
TranslateBPB(
    VOID
    )
/*++

Routine Description:

    This function fails and returns.  On NT we do not support this dos
    call.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

#if DBG
    OutputDebugString("DPMI:  Int 21 function 53 is not supported\n");
#endif
    setCF(1);
}

VOID
RenameFile(
    VOID
    )
/*++

Routine Description:

    This routine translates the rename int 21 api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR SourceString, DestinationString;
    USHORT ClientDX, ClientDI, Seg, Off, SourceLength, DestinationLength;
    USHORT ClientDS = getDS();
    USHORT ClientES = getES();

    SourceString = DpmiMapString(ClientDS, (*GetDXRegister)(), &SourceLength);
    if (SourceString == NULL) {
        setCF(1);
        setAX(3);
    } else {
        DestinationString = DpmiMapString(ClientES, (*GetDIRegister)(), &DestinationLength);
        if (DestinationString == NULL) {
            setCF(1);
            setAX(3);
            DpmiUnmapString(SourceString, SourceLength);
        } else {
            DpmiSwitchToRealMode();
            ClientDX = getDX();
            ClientDI = getDI();


            DPMI_FLAT_TO_SEGMENTED(SourceString, &Seg, &Off);
            setDX(Off);
            setDS(Seg);
            DPMI_FLAT_TO_SEGMENTED(DestinationString, &Seg, &Off);
            setDI(Off);
            setES(Seg);

            DPMI_EXEC_INT(0x21);

            setDX(ClientDX);
            setDI(ClientDI);
            DpmiSwitchToProtectedMode();
            setDS(ClientDS);
            setES(ClientES);
            DpmiUnmapString(SourceString, SourceLength);
            DpmiUnmapString(DestinationString, DestinationLength);
        }
    }
}

VOID
CreateTempFile(
    VOID
    )
/*++

Routine Description:

    This function maps the int 21 create temp file api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR String, BufferedString;
    USHORT ClientDX, Seg, Off, Length;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();


    String = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
             + (*GetDXRegister)();

    Length = 0;
    while (String[Length] != '\0') {
        Length++;
    }

    Length += 13;

    BufferedString = DpmiMapAndCopyBuffer(String, Length);

    DPMI_FLAT_TO_SEGMENTED(BufferedString, &Seg, &Off);
    setDS(Seg);
    setDX(Off);

    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(String, BufferedString, Length);

    setDX(ClientDX);
    setDS(ClientDS);
}

#define MAX_SUPPORTED_DOS_5D_CALL 12

APIXLATFUNCTION Func5DXlatTable[MAX_SUPPORTED_DOS_5D_CALL] = {
         NotSupportedBad    , // 0
         MapDPL             , // 1
         NotSupportedBad    , // 2
         MapDPL             , // 3
         MapDPL             , // 4
         NotSupportedBad    , // 5
         NotSupportedBad    , // 6
         NoTranslation      , // 7
         NoTranslation      , // 8
         NoTranslation      , // 9
         MapDPL             , // 10
         NotSupportedBad      // 11
};

VOID
Func5Dh(
    VOID
    )
/*++

Routine Description:

    This function translates dos call 5d

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Func5DhMinor;

    Func5DhMinor = getAL();

    if (Func5DhMinor >= MAX_SUPPORTED_DOS_5D_CALL) {
#if DBG
        OutputDebugString("DPMI: DOS FUNCTION 5D UNSUPPORTED\n");
#endif
        NoTranslation();
        return;
    }

    (*Func5DXlatTable[Func5DhMinor])();
}

#define MAX_SUPPORTED_DOS_5E_CALL 4
APIXLATFUNCTION Func5EXlatTable[MAX_SUPPORTED_DOS_5E_CALL] = {
         GetMachineName,
         MapASCIIZDSDX,
         GetPrinterSetup,
         SetPrinterSetup
};

VOID
Func5Eh(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Func5EhMinor;

    Func5EhMinor = getAL();

    if (Func5EhMinor >= MAX_SUPPORTED_DOS_5E_CALL) {
#if DBG
        OutputDebugString("DPMI: DOS FUNCTION 5E UNSUPPORTED\n");
#endif
        NoTranslation();
        return;
    }

    (*Func5EXlatTable[Func5EhMinor])();
}

VOID
Func5Fh(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Func5FMinor;

    Func5FMinor = getAL();

    if (Func5FMinor == 4) {
        MapASCIIZDSSI();
        return;
    } else if ((Func5FMinor == 2) || (Func5FMinor == 3) ||
        (Func5FMinor == 5)
    ){
        USHORT ClientSI, ClientDI, DataOff, DataSeg;
        PUCHAR Data16, BufferedData16, Data128, BufferedData128;
        USHORT ClientDS = getDS();
        USHORT ClientES = getES();

        DpmiSwitchToRealMode();
        ClientDI = getDI();
        ClientSI = getSI();

        Data16 = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                 + (*GetSIRegister)();

        BufferedData16 = DpmiMapAndCopyBuffer(Data16, 16);

        Data128 = Sim32GetVDMPointer(((ULONG)ClientES << 16), 1, TRUE)
                  + (*GetDIRegister)();

        BufferedData128 = DpmiMapAndCopyBuffer(Data128, 128);

        DPMI_FLAT_TO_SEGMENTED(BufferedData16, &DataSeg, &DataOff);
        setDS(DataSeg);
        setSI(DataOff);
        DPMI_FLAT_TO_SEGMENTED(BufferedData128, &DataSeg, &DataOff);
        setES(DataSeg);
        setDI(DataOff);

        DPMI_EXEC_INT(0x21);
        DpmiSwitchToProtectedMode();

        DpmiUnmapAndCopyBuffer(Data16, BufferedData16, 16);
        DpmiUnmapAndCopyBuffer(Data128, BufferedData128, 128);

        setDS(ClientDS);
        setES(ClientES);
        setSI(ClientSI);
        setDI(ClientDI);
    } else {
#if DBG
        OutputDebugString("DPMI: UNSUPPORTED INT 21 FUNCTION 5F\n");
#endif
        NoTranslation();
    }
}

VOID
NotSupportedBad(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
#if DBG
    DECLARE_LocalVdmContext;

    DbgPrint("WARNING: DOS INT 21 call AX= %x will not be translated.\n", getAH());
    DbgPrint("         Use of this call is not supported from Prot\n");
    DbgPrint("         mode applications.\n");
#endif
    NoTranslation();
}

VOID
ReturnDSSI(
    VOID
    )
/*++

Routine Description:

    This function translates api that return information in ds:si

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Selector;

    DpmiSwitchToRealMode();
    DPMI_EXEC_INT(0x21);
    Selector = getDS();
    DpmiSwitchToProtectedMode();

    (*SetSIRegister)((ULONG)getSI());
    setDS(SegmentToSelector(Selector, STD_DATA));

}

VOID
NotSupportedBetter(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
#if DBG
    DECLARE_LocalVdmContext;

    DbgPrint("WARNING: DOS INT 21 call AX= %x will not be translated.", getAH());
    DbgPrint("         Use of this call by a Prot Mode app is not");
    DbgPrint("         appropriate. There is a better INT 21 call, or a");
    DbgPrint("         Windows call which should be used instead of this.");
#endif
    NoTranslation();
}

VOID
GetExtendedCountryInfo(
    VOID
    )
/*++

Routine Description:

    This routine translates the get extended country info int 21 api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR Country, BufferedCountry;
    USHORT ClientDI, Seg, Off, Length;
    USHORT ClientES = getES();

    DpmiSwitchToRealMode();
    ClientDI = getDI();

    Length = getCX();

    Country = Sim32GetVDMPointer(((ULONG)ClientES << 16), 1, TRUE)
              + (*GetDIRegister)();

    BufferedCountry = DpmiMapAndCopyBuffer(Country, Length);

    DPMI_FLAT_TO_SEGMENTED(BufferedCountry, &Seg, &Off);
    setES(Seg);
    setDI(Off);

    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();
    setES(ClientES);

    DpmiUnmapAndCopyBuffer(Country, BufferedCountry, Length);

    setDI(ClientDI);
}

VOID
MapASCIIZDSSI(
    VOID
    )
/*++

Routine Description:

    This function translates the int 21 extended open call

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR BufferedString;
    USHORT ClientSI, StringSeg, StringOff, Length;
    USHORT ClientDS = getDS();

    BufferedString = DpmiMapString(ClientDS, (*GetSIRegister)(), &Length);
    if (BufferedString == NULL) {
        setCF(1);
        setAX(3);
    } else {
        DpmiSwitchToRealMode();
        ClientSI = getSI();

        DPMI_FLAT_TO_SEGMENTED(BufferedString, &StringSeg, &StringOff);
        setDS(StringSeg);
        setSI(StringOff);
        DPMI_EXEC_INT(0x21);
        DpmiSwitchToProtectedMode();

        DpmiUnmapString(BufferedString, Length);
        setSI(ClientSI);
        setDS(ClientDS);
    }
}


VOID
MapDSDXLenCX(
    VOID
    )
/*++

Routine Description:

    This function maps the ioctl calls that pass data in DS:DX, with
    length in cx

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, ClientCX, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();
    ClientCX = getCX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
           + (*GetDXRegister)();

    BufferedData = DpmiMapAndCopyBuffer(Data, ClientCX);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setDS(DataSeg);
    setDX(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, ClientCX);

    setDS(ClientDS);
    setDX(ClientDX);
}

VOID
IOCTLMap2Bytes(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
    + (*GetDXRegister)();

    BufferedData = DpmiMapAndCopyBuffer(Data, 2);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setDS(DataSeg);
    setDX(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, 2);

    setDS(ClientDS);
    setDX(ClientDX);
}

VOID
IOCTLBlockDevs(
    VOID
    )
/*++

Routine Description:

    This function fails the block device ioctls

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT IoctlSubFunction, Seg, Off, ClientDX;
    PUCHAR Data, BufferedData;
    USHORT Length;
    USHORT ClientDS = getDS();

    IoctlSubFunction = getCL();

    if ((IoctlSubFunction < 0x40) || (IoctlSubFunction > 0x42) &&
        (IoctlSubFunction < 0x60) || (IoctlSubFunction > 0x62) &&
        (IoctlSubFunction != 0x68)
    ) {
#if DBG
        OutputDebugString("DPMI: IOCTL DOS CALL NOT SUPPORTED\n");
#endif
        NoTranslation();
        return;
    }

    //
    // Read and write track are special (and a pain)
    //
    if ((IoctlSubFunction == 0x41) || (IoctlSubFunction == 0x61)) {
        IoctlReadWriteTrack();
        return;
    }

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
           + (*GetDXRegister)();

    switch (IoctlSubFunction) {
    case 0x40:
        //
        // Map set device params
        //
        Length = (*(PWORD16)(Data + 0x26));
        Length <<= 2;
        Length += 0x28;
        break;

    case 0x60:
        //
        // Map get device params
        //
        Length = 38;
        break;

    case 0x62:
        //
        // Map format verify
        //
        Length = 5;
        break;

    case 0x68:
        //
        // Map Media sense
        //
        Length = 4;
        break;
    }

    BufferedData = DpmiMapAndCopyBuffer(Data, Length);
    DPMI_FLAT_TO_SEGMENTED(BufferedData, &Seg, &Off);
    setDS(Seg);
    setDX(Off);

    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, Length);

    setDS(ClientDS);
    setDX(ClientDX);
}

VOID
IoctlReadWriteTrack(
    VOID
    )
/*++

Routine Description:

    This routine maps the read/write track ioctl.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, ClientDS, ClientCX, ClientAX;
    USHORT Seg, Off, NumberOfSectors, BytesPerSector;
    USHORT SectorsRead, SectorsToRead;
    PUCHAR ParameterBlock, BufferedPBlock, Data, BufferedData;

    ClientAX = getAX();
    ClientDX = getDX();
    ClientCX = getCX();
    ClientDS = getDS();
    DpmiSwitchToRealMode();

    //
    // Find out how many bytes/sector
    //

    BufferedData = DpmiAllocateBuffer(0x40);
    DPMI_FLAT_TO_SEGMENTED(BufferedData, &Seg, &Off);
    setDS(Seg);
    setDX(Off);

    setAX(0x440D);
    setCX(0x860);

    DPMI_EXEC_INT(0x21);

    if (getCF()) {
        //
        // Failed, we don't know how much data to buffer,
        // so fail read/write track
        //
        DpmiFreeBuffer(BufferedData, 0x40);
        setDX(ClientDX);
        setCX(ClientCX);
        DpmiSwitchToProtectedMode();
        setDS(ClientDS);
        return;
    }

    //
    // Get the number of bytes/sector
    //
    BytesPerSector = *(PWORD16)(BufferedData + 0x7);

    DpmiFreeBuffer(BufferedData, 0x40);

    setDX(ClientDX);

    //
    // First map the parameter block
    //
    ParameterBlock = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                     + (*GetDXRegister)();

    BufferedPBlock = DpmiMapAndCopyBuffer(ParameterBlock, 13);


    //
    // Get the segment and offset of the parameter block
    //
    DPMI_FLAT_TO_SEGMENTED(BufferedPBlock, &Seg, &Off);

    setDS(Seg);
    setDX(Off);

    if (CurrentAppFlags & DPMI_32BIT) {

        Data = Sim32GetVDMPointer(
            (*((PWORD16)(BufferedPBlock + 0xd)) << 16),
            1,
            TRUE
            );

        Data += *((PDWORD16)(BufferedPBlock + 0x9));

    } else {

        Data = Sim32GetVDMPointer(
            (*((PWORD16)(BufferedPBlock + 0xb)) << 16),
            1,
            TRUE
            );

        Data += *((PWORD16)(BufferedPBlock + 0x9));

    }

    NumberOfSectors = *((PWORD16)(BufferedPBlock + 7));

    SectorsRead = 0;

    while (NumberOfSectors != SectorsRead) {

        if ((NumberOfSectors - SectorsRead) * BytesPerSector > 1024 * 4) {
            SectorsToRead = 4 * 1024 / BytesPerSector;
        } else {
            SectorsToRead = (USHORT)(NumberOfSectors - SectorsRead);
        }

        BufferedData = DpmiMapAndCopyBuffer(
            Data,
            (USHORT) (SectorsToRead * BytesPerSector)
            );

        DPMI_FLAT_TO_SEGMENTED(BufferedData, &Seg, &Off);

        *((PWORD16)(BufferedPBlock + 9)) = Off;
        *((PWORD16)(BufferedPBlock + 11)) = Seg;
        *((PWORD16)(BufferedPBlock + 7)) = SectorsToRead;
        setAX(ClientAX);
        setCX(ClientCX);

        DPMI_EXEC_INT(0x21);

        if (getCF()) {
            DpmiUnmapBuffer(
                BufferedData,
                (USHORT) (SectorsToRead * BytesPerSector)
                );
            break;
        }

        DpmiUnmapAndCopyBuffer(
            Data,
            BufferedData,
            (USHORT) (SectorsToRead * BytesPerSector)
            );

        Data += SectorsToRead * BytesPerSector;
        *((PWORD16)(BufferedPBlock + 5)) += SectorsToRead;
        SectorsRead += SectorsToRead;
    }

    DpmiUnmapBuffer(BufferedPBlock,13);
    setDX(ClientDX);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);

}

VOID
MapDPL(
    VOID
    )
/*++

Routine Description:

    This routine maps a DPL for the server call

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
           + (*GetDXRegister)();

    BufferedData = DpmiMapAndCopyBuffer(Data, 22);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setDS(DataSeg);
    setDX(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, 22);

    setDX(ClientDX);
    setDS(ClientDS);
}

VOID
GetMachineName(
    VOID
    )
/*++

Routine Description:

    This routine maps a machine name for int 21 function 5e

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
           + (*GetDXRegister)();

    BufferedData = DpmiMapAndCopyBuffer(Data, 16);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setDS(DataSeg);
    setDX(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, 16);

    setDX(ClientDX);
    setDS(ClientDS);
}

VOID
GetPrinterSetup(
    VOID
    )
/*++

Routine Description:

    This routine maps printer setup data for int 21 function 5e

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientSI, ClientCX, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientSI = getSI();
    ClientCX = getCX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
           + (*GetSIRegister)();

    BufferedData = DpmiMapAndCopyBuffer(Data, ClientCX);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setDS(DataSeg);
    setSI(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, ClientCX);

    setSI(ClientSI);
    setDS(ClientDS);
}

VOID
SetPrinterSetup(
    VOID
    )
/*++

Routine Description:

    This routine maps printer setup data for int 21 function 5e

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDI, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientES = getES();

    DpmiSwitchToRealMode();
    ClientDI = getDI();

    Data = Sim32GetVDMPointer(((ULONG)ClientES << 16), 1, TRUE)
           + (*GetDIRegister)();

    BufferedData = DpmiMapAndCopyBuffer(Data, 64);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setES(DataSeg);
    setDI(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();
    setES(ClientES);
    DpmiUnmapAndCopyBuffer(Data, BufferedData, 64);

    setDI(ClientDI);
}
VOID
GetDate(
    VOID
    )
/*++

Routine Description:

    This routine maps int21 func 2A GetDate

Arguments:

    None.

Return Value:

    Client (DH) - month
    Client (DL) - Day
    Client (CX) - Year
    Client (AL) - WeekDay

--*/
{
    DECLARE_LocalVdmContext;
    SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    setDH((UCHAR)TimeDate.wMonth);
    setDL((UCHAR)TimeDate.wDay);
    setCX(TimeDate.wYear);
    setAL((UCHAR)TimeDate.wDayOfWeek);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\dpmiint.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dpmiint.c

Abstract:

    This file contains the interrupt support for DPMI. Most of this is
    for supporting the 486 emulator on risc platforms, but some code
    is shared with x86.

Author:

    Neil Sandlin (neilsa) 1-Jun-1995

Revision History:

Comments:

    DPMI stack switching is accomplished by keeping a "locked pm stack"
    count, and when the count is zero, a stack switch occurs. This keeps
    track of the situation with recursive interrupts where the client
    may switch to its own stack. So, a stack switch to our locked stack
    occurs on the first level interrupt, and on subsequent nested interrupts,
    only the count is maintained. This is identical to how win31 managed
    the stack.

    If a client specifies that it is a 32-bit dpmi client, this only affects
    the "width" of a stack frame. A 16-bit client gets 16-bit frames, and
    a 32 bit client gets 32-bit frames. It is still necessary to check
    the size of the stack segment to determine if SP or ESP should be used.

--*/

#include "precomp.h"
#pragma hdrstop
#include <softpc.h>
#include <dpmiint.h>

BOOL
SetProtectedModeInterrupt(
    USHORT IntNumber,
    USHORT Sel,
    ULONG Offset,
    USHORT Flags
    )

/*++

Routine Description:

    This function services the SetProtectedmodeInterrupt bop.  It retrieves
    the handler information from the Dos application stack, and puts it into
    the VdmTib, for use by instruction emulation.


--*/

{
    DECLARE_LocalVdmContext;

    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;

    if (IntNumber >= 256) {
        return FALSE;
    }

    if ((IntNumber >= 8 && IntNumber <= 0xf) ||
        (IntNumber >= 0x70 && IntNumber <= 0x7f)) {
        //
        // Hardware Interrupt
        //
        Flags |= VDM_INT_INT_GATE;
    } else {
        //
        // Software Interrupt
        //
        Flags |= VDM_INT_TRAP_GATE;
    }

    if (Sel != PMReflectorSeg) {
        //
        // The caller is setting the PM interrupt vector to be something other
        // than the dpmi default "end-of-the-chain" PM handler. Now we check
        // to see if the interrupt needs to be sent up to PM when it is encountered
        // in v86 mode.
        //

        if ((IntNumber == 0x1b) ||      //^Break?
            (IntNumber == 0x1c) ||      //Timer Tick?
            (IntNumber == 0x23) ||      //Ctrl-C?
            (IntNumber == 0x24) ||      //Critical Error Handler?
            (IntNumber == 0x02) ||      //Math co-processor exception used by math library routines!
            ((IntNumber >= 0x08) && (IntNumber <= 0xf)) ||      //Hardware?
            ((IntNumber >= 0x70) && (IntNumber <= 0x77))) {

            // Flag this so that the v86 reflector code will send it to PM
            Flags |= VDM_INT_HOOKED;

            // Mark it down low so NTIO.SYS can do the right thing
            if ( (IntNumber == 0x1c) || (IntNumber == 8) ) {
                *(ULONG *)(IntelBase+FIXED_NTVDMSTATE_LINEAR) |= VDM_INTS_HOOKED_IN_PM;
            }
        }
    }

    Handlers[IntNumber].Flags = Flags;
    Handlers[IntNumber].CsSelector = Sel;
    Handlers[IntNumber].Eip = Offset;

    DBGTRACE((USHORT)(VDMTR_TYPE_DPMI_SI | IntNumber), Sel, Offset);

#ifdef _X86_
    if (IntNumber == 0x21)
    {
        VDMSET_INT21_HANDLER_DATA    ServiceData;
        NTSTATUS Status;

        ServiceData.Selector = Handlers[IntNumber].CsSelector;
        ServiceData.Offset =   Handlers[IntNumber].Eip;
        ServiceData.Gate32 = Handlers[IntNumber].Flags & VDM_INT_32;

        Status = NtVdmControl(VdmSetInt21Handler,  &ServiceData);

#if DBG
        if (!NT_SUCCESS(Status)) {
            OutputDebugString("DPMI32: Error Setting Int21handler\n");
        }
#endif
    }
#endif      //_X86_

    return TRUE;
}


VOID
DpmiInitIDT(
    VOID
    )
/*++

Routine Description:

    This function initializes the state of the IDT. It takes as input the
    IDT set up by DOSX, updates the IDT's access bytes, and sets the DPMI32
    interrupt handlers by calling SetProtectedModeInterrupt.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT IntNumber;
    USHORT Flags = getBX();

    Idt = (PVOID)VdmMapFlat(getAX(), 0, getMODE());

    for (IntNumber = 0; IntNumber<256; IntNumber++) {

        SetProtectedModeInterrupt(IntNumber,
                                  Idt[IntNumber].Selector,
                                  (((ULONG)Idt[IntNumber].OffsetHi)<<16) +
                                           Idt[IntNumber].OffsetLow,
                                           Flags);

    }

}

BOOL
SetFaultHandler(
    USHORT IntNumber,
    USHORT Sel,
    ULONG Offset
    )

/*++

Routine Description:

    This function services the SetFaultHandler bop.  It retrieves
    the handler information from the Dos application stack, and puts it into
    the VdmTib, for use by instruction emulation.


--*/

{
    DECLARE_LocalVdmContext;

    PVDM_FAULTHANDLER Handlers = DpmiFaultHandlers;

    if (IntNumber >= 32) {
        return FALSE;
    }

    Handlers[IntNumber].Flags = VDM_INT_INT_GATE;
    Handlers[IntNumber].CsSelector = Sel;
    Handlers[IntNumber].Eip = Offset;

    Handlers[IntNumber].SsSelector = 0;     //BUGBUG These are obselete
    Handlers[IntNumber].Esp = 0;            //BUGBUG These are obselete


    DBGTRACE((USHORT)(VDMTR_TYPE_DPMI_SF | IntNumber),
             Handlers[IntNumber].CsSelector,
             Handlers[IntNumber].Eip);
    return TRUE;
}

VOID
DpmiInitExceptionHandlers(
    VOID
    )
{
    DECLARE_LocalVdmContext;
    USHORT OffsetIncr = getAX();
    USHORT IntCount = getBX();
    USHORT Selector = getCX();
    ULONG Offset = (ULONG) getDX();
    USHORT IntNumber;

    for (IntNumber = 0; IntNumber < 32; IntNumber++) {
        SetFaultHandler(IntNumber, Selector, Offset);
        Offset += OffsetIncr;
    }

}


VOID
DpmiUnhandledExceptionHandler(
    VOID
    )
/*++

Routine Description:

    This function gets control when a PM fault occurs that isn't handled
    by an installed handler. The body of this function emulates Win31
    DPMI behavior, where a fault that is reflected to the end of the
    PM fault handler chain is then reflected to the PM *interrupt*
    chain.

Arguments:

    client SS:(E)SP points to dpmi fault stack frame


--*/

{
    DECLARE_LocalVdmContext;
    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;
    USHORT SegSs, SegCs;
    UCHAR XNumber;
    PCHAR VdmStackPointer;
    PCHAR VdmCodePointer;
    USHORT FaultingCS;
    ULONG FaultingEip;

    SegSs = getSS();
    VdmStackPointer = Sim32GetVDMPointer(SegSs<<16, 1, TRUE);

    if (SEGMENT_IS_BIG(SegSs)) {
        VdmStackPointer += getESP();
    } else {
        VdmStackPointer += getSP();
    }

    SegCs = getCS();
    VdmCodePointer = Sim32GetVDMPointer(SegCs<<16, 1, TRUE);

    if (SEGMENT_IS_BIG(SegCs)) {
        VdmCodePointer += getEIP();
    } else {
        VdmCodePointer += getIP();
    }

    XNumber = *(VdmCodePointer);

    if ((XNumber > 7) || (XNumber == 6)) {
        DpmiFatalExceptionHandler(XNumber, VdmStackPointer);
        return;
    }


    if (Frame32) {

        PCHAR VdmNewStackPointer;
        ULONG FrameSS, FrameSP, FrameCS, FrameIP, FrameFlags;

        //
        // Build an iret frame on the faulting stack
        //
        FrameSS = *(PDWORD16) (VdmStackPointer+28);
        FrameSP = *(PDWORD16) (VdmStackPointer+24) - 12;
        *(PDWORD16) (VdmStackPointer+24) = FrameSP;
        VdmNewStackPointer = Sim32GetVDMPointer((ULONG)(FrameSS << 16), 1, TRUE);
        VdmNewStackPointer += FrameSP;

        FrameIP = *(PDWORD16) (VdmStackPointer+12);
        *(PDWORD16) (VdmStackPointer+12) = Handlers[XNumber].Eip;
        *(PDWORD16) (VdmNewStackPointer) = FrameIP;

        FrameCS = *(PDWORD16) (VdmStackPointer+16);
        *(PDWORD16) (VdmStackPointer+16) = (ULONG) Handlers[XNumber].CsSelector;
        *(PDWORD16) (VdmNewStackPointer+4) = FrameCS;

        FrameFlags = *(PDWORD16) (VdmStackPointer+20);
        *(PDWORD16) (VdmNewStackPointer+4) = FrameFlags;
        FrameFlags &= ~(EFLAGS_IF_MASK | EFLAGS_TF_MASK);
        *(PDWORD16) (VdmStackPointer+20) = FrameFlags;

        //
        // Simulate a dpmi fault handler retf
        //
        setCS((USHORT)*(PDWORD16)(VdmStackPointer+4));
        setEIP(*(PDWORD16)(VdmStackPointer));
        setESP(getESP() + 8);

    } else {

        USHORT FrameSS, FrameSP, FrameCS, FrameIP, FrameFlags;
        FrameSS = *(PWORD16) (VdmStackPointer+14);
        FrameCS = *(PWORD16) (VdmStackPointer+8);
        FrameFlags = *(PWORD16) (VdmStackPointer+10);

        if (!SEGMENT_IS_BIG(FrameSS) && !SEGMENT_IS_BIG(FrameCS)) {

            PCHAR VdmNewStackPointer;

            //
            // Build an iret frame on the faulting stack
            //
            FrameSP = *(PWORD16) (VdmStackPointer+12) - 6;
            *(PWORD16) (VdmStackPointer+12) = FrameSP;
            VdmNewStackPointer = Sim32GetVDMPointer((ULONG)(FrameSS << 16)+FrameSP, 1, TRUE);

            FrameIP = *(PWORD16) (VdmStackPointer+6);
            *(PWORD16) (VdmStackPointer+6) = (WORD) Handlers[XNumber].Eip;
            *(PWORD16) (VdmNewStackPointer) = FrameIP;

            *(PWORD16) (VdmStackPointer+8) = Handlers[XNumber].CsSelector;
            *(PWORD16) (VdmNewStackPointer+2) = FrameCS;

            *(PWORD16) (VdmNewStackPointer+4) = FrameFlags;
            FrameFlags &= ~(EFLAGS_IF_MASK | EFLAGS_TF_MASK);
            *(PWORD16) (VdmStackPointer+10) = FrameFlags;

            //
            // Simulate a dpmi fault handler retf
            //
            setCS(*(PWORD16)(VdmStackPointer+2));
            setEIP((DWORD)*(PWORD16)(VdmStackPointer));
            setSP(getSP() + 4);

        } else {
            //
            // Build an iret frame on the locked DPMI stack
            //

            FrameCS = *(PWORD16) (VdmStackPointer+2);
            FrameIP = *(PWORD16) (VdmStackPointer);
            FrameFlags &= ~EFLAGS_IF_MASK;

            setSP(getSP() - 2);

            *(PWORD16)(VdmStackPointer-2) = FrameIP;
            *(PWORD16)(VdmStackPointer)   = FrameCS;
            *(PWORD16)(VdmStackPointer+2) = FrameFlags;
            setCS(Handlers[XNumber].CsSelector);
            setEIP((DWORD)LOWORD(Handlers[XNumber].Eip));
            setSTATUS((WORD) FrameFlags & ~EFLAGS_TF_MASK);
        }

    }

}


VOID
DpmiFatalExceptionHandler(
    UCHAR XNumber,
    PCHAR VdmStackPointer
    )
/*++

Routine Description:

    This function gets control when a PM fault 6, 8-1f occurs that isn't
    handled by an installed handler. It pops up an error dialog for the
    user.

Arguments:

    XNumber - exception number (0-1fh)
    VdmStackPointer - flat pointer to stack frame


--*/

{
    DECLARE_LocalVdmContext;
    char szBuffer[255];
    USHORT FaultingCS;
    ULONG FaultingEip;

    if (Frame32) {
        FaultingCS  = (USHORT)*(PDWORD16)(VdmStackPointer+16);
        FaultingEip = *(PDWORD16)(VdmStackPointer+12);
    } else {
        FaultingCS  = *(PWORD16)(VdmStackPointer+8);
        FaultingEip = (ULONG)*(PWORD16)(VdmStackPointer+6);
    }

    wsprintf(szBuffer, "X#=%.02X, CS=%.04X IP=%.08X",
                            XNumber, FaultingCS, FaultingEip);

    RcErrorDialogBox(EG_BAD_FAULT, szBuffer, NULL);

    //
    // Need to try to ignore it. Since we are on a dpmi exception frame
    // we can just simulate a retf.
    //
    if (Frame32) {
        setCS((USHORT)*(PDWORD16)(VdmStackPointer+4));
        setEIP(*(PDWORD16)(VdmStackPointer));
        setESP(getESP() + 8);
    } else {
        setCS(*(PWORD16)(VdmStackPointer+2));
        setEIP((DWORD)*(PWORD16)(VdmStackPointer));
        setSP(getSP() + 4);
    }
}

VOID
DpmiInitPmStackInfo(
    VOID
    )
/*++

Routine Description:

    This routine is called via BOP by DOSX to initialize values related
    to stack handling.

Arguments:

    Client ES = selector of locked PM stack

Return Value:

    None

Notes:

    The offset of the locked pm stack is hard-coded to 0x1000, per dpmi
    and win31.

--*/
{
    DECLARE_LocalVdmContext;

    LockedPMStackSel = getES();
    LockedPMStackCount = 0;

#ifdef _X86_
    ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.Flags = CurrentAppFlags;
#endif
}

BOOL
DpmiSwIntHandler(
    ULONG IntNumber
    )
/*++

Routine Description:

    This routine is called by the emulator to dispatch a SW interrupt.

Arguments:

    IntNumber - interrupt vector number

Return Value:

    TRUE if the interrupt was dispatched, FALSE otherwise

--*/

{
    DECLARE_LocalVdmContext;
    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;
    ULONG SaveEFLAGS;
    ULONG NewSP;

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_SW_INT, (USHORT)IntNumber, 0);

    //
    // If we're here via breakpoint, see if it belongs to NTVDM debug code.
    //
    if ((IntNumber == 3) &&
        (*(ULONG *)(IntelBase+FIXED_NTVDMSTATE_LINEAR) & VDM_BREAK_DEBUGGER) &&
        DbgBPInt()) {
        return TRUE;
    }


    if (!(getMSW() & MSW_PE)) {

        EmulateV86Int((UCHAR)IntNumber);

    } else {
        PUCHAR VdmStackPointer;

        // Protect mode
        SaveEFLAGS = getEFLAGS();
        //BUGBUG turn off task bits
        SaveEFLAGS &= ~EFLAGS_NT_MASK;
        setEFLAGS(SaveEFLAGS & ~EFLAGS_TF_MASK);

        if (!SEGMENT_IS_PRESENT(Handlers[IntNumber].CsSelector)) {
            return FALSE;
        }

        if (!BuildStackFrame(3, &VdmStackPointer, &NewSP)) {
            return FALSE;
        }

        if (Frame32) {

            *(PDWORD16)(VdmStackPointer-4) =  SaveEFLAGS;
            *(PDWORD16)(VdmStackPointer-8) =  getCS();
            *(PDWORD16)(VdmStackPointer-12) = getEIP();
            setEIP(Handlers[IntNumber].Eip);
            setESP(NewSP);

        } else {

            *(PWORD16)(VdmStackPointer-2) = (WORD) SaveEFLAGS;
            *(PWORD16)(VdmStackPointer-4) = (WORD) getCS();
            *(PWORD16)(VdmStackPointer-6) = (WORD) getEIP();
            setEIP((DWORD)LOWORD(Handlers[IntNumber].Eip));
            setSP((WORD)NewSP);

        }

        setCS(Handlers[IntNumber].CsSelector);

#if DBG
        if (Handlers[IntNumber].CsSelector != getCS()) {
            char szFormat[] = "NTVDM Dpmi Error! Can't set CS to %.4X\n";
            char szMsg[sizeof(szFormat)+30];

            wsprintf(szMsg, szFormat, Handlers[IntNumber].CsSelector);
            OutputDebugString(szMsg);
        }
#endif
    }

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_DISPATCH_INT, (USHORT)IntNumber, 0);
    return TRUE;
}

BOOL
DpmiHwIntHandler(
    ULONG IntNumber
    )

/*++

Routine Description:

    This routine is called by the emulator to dispatch a HW interrupt.

Arguments:

    IntNumber - interrupt vector number

Return Value:

    TRUE if the interrupt was dispatched, FALSE otherwise

--*/

{
    DECLARE_LocalVdmContext;
    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;
    ULONG SaveEFLAGS;
    ULONG NewSP;

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_HW_INT, (USHORT)IntNumber, 0);

    if (!(getMSW() & MSW_PE)) {

        EmulateV86Int((UCHAR)IntNumber);

    } else {
        PUCHAR VdmStackPointer;

        SaveEFLAGS = getEFLAGS();
        //BUGBUG turn off task bits
        SaveEFLAGS &= ~0x4000;
        setEFLAGS(SaveEFLAGS & ~(EFLAGS_IF_MASK | EFLAGS_TF_MASK));

        BeginUseLockedPMStack();

        if (!BuildStackFrame(6, &VdmStackPointer, &NewSP)) {
            EndUseLockedPMStack();
            return FALSE;
        }

        if (Frame32) {
            *(PDWORD16)(VdmStackPointer-4) = SaveEFLAGS;
            *(PDWORD16)(VdmStackPointer-8) = getCS();
            *(PDWORD16)(VdmStackPointer-12) = getEIP();
            *(PDWORD16)(VdmStackPointer-16) = getEFLAGS();
            *(PDWORD16)(VdmStackPointer-20) = (DWORD)HIWORD(DosxIntHandlerIretd);
            *(PDWORD16)(VdmStackPointer-24) = (DWORD)LOWORD(DosxIntHandlerIretd);
            setEIP(Handlers[IntNumber].Eip);
            setESP(NewSP);
        } else {
            *(PWORD16)(VdmStackPointer-2) = (WORD)SaveEFLAGS;
            *(PWORD16)(VdmStackPointer-4) = (WORD)getCS();
            *(PWORD16)(VdmStackPointer-6) = (WORD)getIP();
            *(PWORD16)(VdmStackPointer-8) = (WORD)getEFLAGS();
            *(PWORD16)(VdmStackPointer-10) = HIWORD(DosxIntHandlerIret);
            *(PWORD16)(VdmStackPointer-12) = LOWORD(DosxIntHandlerIret);
            setEIP((DWORD)LOWORD(Handlers[IntNumber].Eip));
            setSP((WORD)NewSP);
        }
        setCS(Handlers[IntNumber].CsSelector);
    }

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_DISPATCH_INT, (USHORT)IntNumber, 0);
    return TRUE;
}


VOID
DpmiIntHandlerIret16(
    VOID
    )

/*++

Routine Description:

    This routine is an IRET hook called via a BOP in dosx. It is called
    at the end of a 16-bit HW or SW interrupt. The main reason we want
    to come in here is to maintain the DPMI stack, and know when to restore
    the original values when we pop back out to level zero.


--*/

{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    ULONG NewSP;
    USHORT SegSs;
    BOOL bSsBig;

    SegSs = getSS();
    VdmStackPointer = Sim32GetVDMPointer(SegSs<<16, 1, TRUE);

    if (bSsBig = SEGMENT_IS_BIG(SegSs)) {
        VdmStackPointer += getESP();
    } else {
        VdmStackPointer += getSP();
    }

    //
    // Fast iret (without executing final 16-bit iret)
    //
#ifdef _X86_

    setCS(*(PWORD16)(VdmStackPointer+2));
    setEFLAGS((getEFLAGS()&0xffff0000) | *(PWORD16)(VdmStackPointer+4));

    //
    // if EndUseLockedPMStack fails, then we need to restore EIP and pop
    // the stack frame
    //

    if (!EndUseLockedPMStack()) {

        setEIP((DWORD)*(PWORD16)(VdmStackPointer));

        //
        // Pop iret frame off the stack
        //
        if (bSsBig) {
            setESP(getESP()+6);
        } else {
            setSP(getSP()+6);
        }
    }

    //
    // Slow iret (with executing final 16-bit iret)
    //
#else
    if (EndUseLockedPMStack()) {
        ULONG NewEIP, NewEFLAGS, NewCS;

        NewEIP    = getEIP();
        NewCS     = (ULONG) *(PWORD16)(VdmStackPointer+2);
        NewEFLAGS = (getEFLAGS()&0xffff0000) | *(PWORD16)(VdmStackPointer+4);

        //
        // Since EndUseLockedPMStack() has restored all of EIP, and we may be
        // returning to a 32-bit code segment, build a 32-bit iret frame
        // even if this is a 16-bit client. That way, EIP will be restored
        // correctly.
        // Pass 6 to BuildStackFrame since 6 words = 3 dwords
        //
        if (!BuildStackFrame(6, &VdmStackPointer, &NewSP)) {
#if DBG
            OutputDebugString("NTVDM: Dpmi encountered a stack fault!\n");
#endif
            DpmiFaultHandler(STACK_FAULT, 0);
            return;
        }

        //
        // SS has changed, so we need to check LDT again
        //
        if (SEGMENT_IS_BIG(getSS())) {
            setESP(NewSP);
        } else {
            setSP((WORD)NewSP);
        }

        *(PDWORD16)(VdmStackPointer-4)  = NewEFLAGS;
        *(PDWORD16)(VdmStackPointer-8)  = NewCS;
        *(PDWORD16)(VdmStackPointer-12) = NewEIP;
        setCS(HIWORD(DosxIretd));
        setEIP((ULONG)LOWORD(DosxIretd));

    } else {

        // still on locked stack, just do a real iret (16-bit frame)
        setCS(HIWORD(DosxIret));
        setEIP((ULONG)LOWORD(DosxIret));

    }
#endif // _X86_

}

VOID
DpmiIntHandlerIret32(
    VOID
    )

/*++

Routine Description:

    This routine is an IRET hook called via a BOP in dosx. It is called
    at the end of a 32-bit HW or SW interrupt. The main reason we want
    to come in here is to maintain the DPMI stack, and know when to restore
    the original values when we pop back out to level zero.


--*/

{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    ULONG NewSP;
    USHORT SegSs;
    BOOL bSsBig;

    SegSs = getSS();
    VdmStackPointer = Sim32GetVDMPointer(SegSs<<16, 1, TRUE);

    if (bSsBig = SEGMENT_IS_BIG(SegSs)) {
        VdmStackPointer += getESP();
    } else {
        VdmStackPointer += getSP();
    }

#ifdef _X86_

    setCS(*(PDWORD16)(VdmStackPointer+4));
    setEFLAGS(*(PDWORD16)(VdmStackPointer+8));

    //
    // if EndUseLockedPMStack succeeds, then we don't need to restore EIP
    //

    if (!EndUseLockedPMStack()) {

        setEIP(*(PDWORD16)(VdmStackPointer));

        //
        // Pop iret frame off the stack
        //
        if (bSsBig) {
            setESP(getESP()+12);
        } else {
            setSP(getSP()+12);
        }
    }

#else
    if (EndUseLockedPMStack()) {
        ULONG NewEIP, NewCS, NewEFLAGS;

        NewEIP    = getEIP();
        NewCS     = *(PDWORD16)(VdmStackPointer+4);
        NewEFLAGS = *(PDWORD16)(VdmStackPointer+8);


        if (!BuildStackFrame(3, &VdmStackPointer, &NewSP)) {
#if DBG
            OutputDebugString("NTVDM: Dpmi encountered a stack fault!\n");
#endif
            DpmiFaultHandler(STACK_FAULT, 0);
            return;
        }

        //
        // SS has changed, so we need to check LDT again
        //
        if (SEGMENT_IS_BIG(getSS())) {
            setESP(NewSP);
        } else {
            setSP((WORD)NewSP);
        }

        *(PDWORD16)(VdmStackPointer-4) =  NewEFLAGS;
        *(PDWORD16)(VdmStackPointer-8) =  NewCS;
        *(PDWORD16)(VdmStackPointer-12) = NewEIP;
    }

    setCS(HIWORD(DosxIretd));
    setEIP((ULONG)LOWORD(DosxIretd));
#endif // _X86_

}

#ifndef _X86_

BOOL
DpmiFaultHandler(
    ULONG IntNumber,
    ULONG ErrorCode
    )

/*++

Routine Description:

    This routine is called by the emulator when an exception occurs.

Arguments:

    IntNumber - exception number (0-1f)
    ErrorCode - exception error code to be placed on the stack

Return Value:

    TRUE if the interrupt was dispatched, FALSE otherwise

--*/

{
    DECLARE_LocalVdmContext;
    PVDM_FAULTHANDLER Handlers = DpmiFaultHandlers;
    PUCHAR VdmStackPointer;
    ULONG SaveSS, SaveESP, SaveEFLAGS, SaveCS, SaveEIP;
    ULONG StackOffset;
    ULONG NewSP;

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_FAULT, (USHORT)IntNumber, ErrorCode);

    if ((IntNumber == 1)  &&
        (*(ULONG *)(IntelBase+FIXED_NTVDMSTATE_LINEAR) & VDM_BREAK_DEBUGGER) &&
        DbgTraceInt()) {
        return TRUE;
    }

    if (DbgFault(IntNumber)) {      // try the debugger
        //
        // exception handled via user input
        //
        return TRUE;
    }

    if (!(getMSW() & MSW_PE)) {
        EmulateV86Int((UCHAR)IntNumber);
        return TRUE;
    }

    SaveSS = getSS();
    SaveESP = getESP();
    SaveEFLAGS = getEFLAGS();
    SaveEIP = getEIP();
    SaveCS  = getCS();
    setEFLAGS(SaveEFLAGS & ~(EFLAGS_IF_MASK | EFLAGS_TF_MASK));

    if ((IntNumber == 13) || (IntNumber == 6)) {
        if (DpmiEmulateInstruction()) {
            return TRUE;
        }
    }

    if (!SEGMENT_IS_PRESENT(Handlers[IntNumber].CsSelector)) {
        return FALSE;
    }

    //
    // switch stacks
    //

    BeginUseLockedPMStack();

    //
    // Win31 has an undocumented feature of creating a 32byte area on the
    // stack. Krnl386 sticks stuff in there, so we emulate the behavior here.
    //

    setESP(getESP()-0x20);

    //
    // allocate space on new stack
    //

    if (!BuildStackFrame(8, &VdmStackPointer, &NewSP)) {
        //BUGBUG Check for double fault
        EndUseLockedPMStack();
        return FALSE;
    }

    if (Frame32) {
        *(PDWORD16)(VdmStackPointer-4) = SaveSS;
        *(PDWORD16)(VdmStackPointer-8) = SaveESP;
        *(PDWORD16)(VdmStackPointer-12) = SaveEFLAGS;
        *(PDWORD16)(VdmStackPointer-16) = SaveCS;
        *(PDWORD16)(VdmStackPointer-20) = SaveEIP;
        *(PDWORD16)(VdmStackPointer-24) = ErrorCode;
        *(PDWORD16)(VdmStackPointer-28) = (ULONG) HIWORD(DosxFaultHandlerIretd);
        *(PDWORD16)(VdmStackPointer-32) = (ULONG) LOWORD(DosxFaultHandlerIretd);
        setEIP(Handlers[IntNumber].Eip);
        setESP(NewSP);
    } else {
        *(PWORD16)(VdmStackPointer-2) = (WORD) SaveSS;
        *(PWORD16)(VdmStackPointer-4) = (WORD) SaveESP;
        *(PWORD16)(VdmStackPointer-6) = (WORD) SaveEFLAGS;
        *(PWORD16)(VdmStackPointer-8) = (WORD) SaveCS;
        *(PWORD16)(VdmStackPointer-10) = (WORD) SaveEIP;
        *(PWORD16)(VdmStackPointer-12) = (WORD) ErrorCode;
        *(PDWORD16)(VdmStackPointer-16) = DosxFaultHandlerIret;
        setEIP(LOWORD(Handlers[IntNumber].Eip));
        setSP((WORD)NewSP);
    }

    setCS(Handlers[IntNumber].CsSelector);

#if DBG
    if (Handlers[IntNumber].CsSelector != getCS()) {
        char szFormat[] = "NTVDM Dpmi Error! Can't set CS to %.4X\n";
        char szMsg[sizeof(szFormat)+30];

        wsprintf(szMsg, szFormat, Handlers[IntNumber].CsSelector);
        OutputDebugString(szMsg);
    }
#endif

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_DISPATCH_FAULT, (USHORT)IntNumber, 0);
    return TRUE;
}

#endif // _X86_

VOID
DpmiFaultHandlerIret16(
    VOID
    )

/*++

Routine Description:

    This routine is an IRET hook called via a BOP in dosx. It is called
    at the end of the execution of a 16-bit fault handler.


--*/

{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    USHORT SegSs;

    SegSs = getSS();
    VdmStackPointer = Sim32GetVDMPointer(SegSs<<16, 1, TRUE);
    if (SEGMENT_IS_BIG(SegSs)) {
        VdmStackPointer += getESP();
    } else {
        VdmStackPointer += getSP();
    }

    EndUseLockedPMStack();

    setEIP((DWORD)*(PWORD16)(VdmStackPointer+2));
    setCS(*(PWORD16)(VdmStackPointer+4));
    setSTATUS(*(PWORD16)(VdmStackPointer+6));
    setSP(*(PWORD16)(VdmStackPointer+8));
    setSS(*(PWORD16)(VdmStackPointer+10));

}

VOID
DpmiFaultHandlerIret32(
    VOID
    )

/*++

Routine Description:

    This routine is an IRET hook called via a BOP in dosx. It is called
    at the end of the execution of a 32-bit fault handler.


--*/

{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    USHORT SegSs;

    SegSs = getSS();
    VdmStackPointer = Sim32GetVDMPointer(SegSs<<16, 1, TRUE);
    if (SEGMENT_IS_BIG(SegSs)) {
        VdmStackPointer += getESP();
    } else {
        VdmStackPointer += getSP();
    }


    EndUseLockedPMStack();

    setEIP(*(PDWORD16)(VdmStackPointer+4));
    setCS((USHORT)*(PDWORD16)(VdmStackPointer+8));
    setEFLAGS(*(PDWORD16)(VdmStackPointer+12));
    setESP(*(PDWORD16)(VdmStackPointer+16));
    setSS((USHORT)*(PWORD16)(VdmStackPointer+20));

}


VOID
DpmiHungAppIretAndExit(
    VOID
    )
/*++

Routine Description:

    This routine is called via BOP during hung app processing. The
    Keyboard driver calls this in the context of a hw interrupt in
    order to terminate the app. We need to "unwind" the current
    interrupt, and transfer control to code which will execute
    a DOS exit.

--*/

{
    DECLARE_LocalVdmContext;

    EndUseLockedPMStack();
    setCS(HIWORD(DosxHungAppExit));
    setIP(LOWORD(DosxHungAppExit));
}

BOOL
DispatchPMInt(
    UCHAR IntNumber
    )
/*++

Routine Description:

    This routine is called at the end of a PM int chain. It is provided
    for compatibility to win31/win95. On win31/win95, VMM and VxD's have
    the opportunity to perform some functionality at the point where
    the dpmi host is about to switch the machine to v86 mode to continue
    the interrupt chain. Sometimes, the function is totally handled by
    a hook at this point.

    This routine provides a framework for this mechanism to allow the
    emulation of this behavior.

Arguments:

    IntNumber - the interrupt# that is about to be reflected to v86 mode

Return Value:

    TRUE if the interrupt was handled and control can return to the app
    FALSE otherwise, continue the reflection to v86 mode.

--*/

{
    BOOL bHandled;

    switch(IntNumber) {

    case 0x2f:

        bHandled = PMInt2fHandler();
        break;

    default:
        bHandled = FALSE;
    }

    if (bHandled) {
        SimulateIret(RESTORE_FLAGS);
    }
    return bHandled;

}


BOOL
CheckEIP(
    ULONG Increment
    )
/*++

Routine Description:

    This routine does a limit check on EIP.

Arguments:

    None

Return Value:

    TRUE if EIP is ok, FALSE otherwise

--*/

{
    //BUGBUG NEED TO RETURN FALSE HERE IF EIP WOULD BE OFF THE END OF SEGMENT
    return TRUE;
}

#ifndef _X86_
BOOL
DpmiEmulateInstruction(
    VOID
    )
/*++

Routine Description:

    This routine checks to see if the instruction which caused the
    fault really needs to be emulated. For example, the MS C compiler (v7.00)
    uses instructions to manipulate the FP flags in CR0. The compiler
    expects them to just work as they do on win31, which also emulates them.

Arguments:

    None

Return Value:

    TRUE if the instruction was emulated, FALSE otherwise

--*/

{
    DECLARE_LocalVdmContext;
    PUCHAR pCode;
    UCHAR Opcode;
    ULONG SegCS;
    BOOL bReturn = FALSE;

    SegCS = getCS();
    pCode = Sim32GetVDMPointer(SegCS<<16, 1, TRUE);

    if (Ldt[(SegCS & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Default_Big) {
        pCode += getEIP();
    } else {
        pCode += getIP();
    }

    Opcode = *pCode++;
    switch (Opcode) {
        case 0xf:
            if (!CheckEIP(1)) {
                break;
            }
            bReturn = DpmiOp0f(pCode);
            break;

        case 0x8e:
            //
            // This is WIN31 compatibility. If we are trying to dispatch
            // the client, and we get a fault loading the segment registers,
            // then zero them out.
            // BUGBUG currently only looking for FS, GS
            //
            if (!CheckEIP(2)) {
                break;
            }
            //
            // Look for code in dxutil.asm EnterProtectedMode
            //
            if ((SegCS == DosxRmCodeSelector) &&
                ((*pCode == 0xe0)  ||               // mov fs, ax
                 (*pCode == 0xe8))                  // mov gs, ax
                    ) {
                setEIP(getEIP()+2);
                bReturn = TRUE;
            }
            break;
    }

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_OP_EMULATION, Opcode, (ULONG) bReturn);
    return bReturn;
}

#define MI_GET_CRx_OPCODE 0x20
#define MI_SET_CRx_OPCODE 0x22
#define MI_MODMASK 0xC0
#define MI_MODMOVSPEC 0xC0
#define MI_REGMASK 0x38
#define MI_RMMASK  0x7

BOOL
DpmiOp0f(
    PUCHAR pCode
    )
/*++

Routine Description:

    This routine emulates instructions that have 0x0F as the first byte.

Arguments:

    None

Return Value:

    TRUE if the instruction was emulated, FALSE otherwise

--*/
{
    DECLARE_LocalVdmContext;
    ULONG Value;

    switch (*pCode++) {
        case MI_GET_CRx_OPCODE:

            if (!CheckEIP(2)) {
                break;
            }

            if ((*pCode & MI_MODMASK) != MI_MODMOVSPEC) {
                break;
            }

            if (*pCode & MI_REGMASK) {
                Value = 0;              // not CR0
            } else {
                Value = getCR0();
            }

            SetRegisterByIndex[*pCode & MI_RMMASK](Value);
            setEIP(getEIP()+3);
            return TRUE;

        case MI_SET_CRx_OPCODE:

            if (!CheckEIP(2)) {
                break;
            }

            if ((*pCode & MI_MODMASK) != MI_MODMOVSPEC) {
                break;
            }

            if (*pCode & MI_REGMASK) {
                break;                  // not CR0
            }

            setCR0(GetRegisterByIndex[*pCode & MI_RMMASK]());
            setEIP(getEIP()+3);
            return TRUE;
    }

    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\dpmiselr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dpmiselr.c

Abstract:

    This is the code for maintaining descriptor data for dpmi32.

Author:

    Dave Hart (davehart) 11-Apr-1993

Notes:


Revision History:

    09-Feb-1994 (daveh)
        Moved here from not386.c.
    31-Jul-1995 (neilsa)
        Merged with x86 source
    12-Dec-1995 (neilsa)
        Wrote VdmAddDescriptorMapping(), GetDescriptorMapping

--*/

#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include "malloc.h"

#ifndef _X86_
PDESC_MAPPING pDescMappingHead = NULL;
#endif // _X86_

USHORT selLDTFree = 0;


VOID
DpmiSetDescriptorEntry(
    VOID
    )
/*++

Routine Description:

    This function is called via BOP by dosx to set the flataddress
    array and, if on x86, the real LDT maintained by the kernel.

Arguments:

    None

Return Value:

    None.

--*/

{
    DECLARE_LocalVdmContext;
    USHORT SelCount;
    USHORT SelStart;

    SelStart = getAX();
    if (SelStart % 8) {
        return;
    }
    if (SelStart > LdtMaxSel) {
        return;
    }
    SelCount =  getCX();
    if ((((LdtMaxSel - SelStart) >> 3) + 1) < SelCount) {
        return;
    }
    SetShadowDescriptorEntries(SelStart, SelCount);
    // no need to flush the cache on risc since the ldt was changed
    // from the 16-bit side, and has thus already been flushed
}

VOID
SetDescriptor(
    USHORT Sel,
    ULONG Base,
    ULONG Limit,
    USHORT Access
    )
/*++

Routine Description:


Arguments:

    None

Return Value:

    None.

--*/
{

    SET_SELECTOR_ACCESS(Sel, Access);
    SET_SELECTOR_LIMIT(Sel, Limit);
    SetDescriptorBase(Sel, Base);

}

VOID
SetDescriptorBase(
    USHORT Sel,
    ULONG Base
    )
/*++

Routine Description:


Arguments:

    None

Return Value:

    None.

--*/
{
    LDT_ENTRY UNALIGNED *Descriptor;

    // make it qword aligned
    Sel &= SEL_INDEX_MASK;

    Descriptor = &Ldt[Sel>>3];

    Descriptor->BaseLow = (WORD) Base;
    Descriptor->HighWord.Bytes.BaseMid = (BYTE) (Base >> 16);
    Descriptor->HighWord.Bytes.BaseHi = (BYTE) (Base >> 24);

    SetShadowDescriptorEntries(Sel, 1);
    FLUSH_SELECTOR_CACHE(Sel, 1);
}

VOID
SetShadowDescriptorEntries(
    USHORT SelStart,
    USHORT SelCount
    )
/*++

Routine Description:

    This function takes as a parameter an array of descriptors
    directly out of the LDT in the clients address space.
    For each descriptor in the array, it does three things:

    - It extracts the descriptor base and sets it into the FlatAddress
      array. This value may be adjusted on RISC platforms to account
      for DIB.DRV (see VdmAddDescriptorMapping).
    - It extracts the selector limit, and adjusts the limit in the
      descriptor itself if the values would cause the descriptor to
      be able to access kernel address space (see note below). On debug
      builds, the limit is also copied to the Limit array.
    - On x86 builds, it calls DpmiSetX86Descriptor() to write the
      descriptor down to the real LDT in the kernel. On RISC builds,
      it calls down to the emulator to flush compiled LDT entries.

Arguments:

    SelStart - Selector which identifies the first descriptor
    SelCount - number of descriptors to process
    Descriptors -> first descriptor in LDT

Return Value:

    None.

--*/

{
    USHORT i;
    ULONG  Base;
    ULONG Limit;
    USHORT Sel = SelStart;

    for (i = 0; i < SelCount; i++, Sel+=8) {

        // form Base and Limit values

        Base = GET_SELECTOR_BASE(Sel);
        Limit = GET_SELECTOR_LIMIT(Sel);

        //
        // Do NOT remove the following code.  There are several apps that
        // choose arbitrarily high limits for theirs selectors.  This works
        // under windows 3.1, but NT won't allow us to do that.
        // The following code fixes the limits for such selectors.
        // Note: if the base is > 0x7FFEFFFF, the selector set will fail
        //

        if ((Limit > 0x7FFEFFFF) || (Base + Limit > 0x7FFEFFFF)) {
            Limit = 0x7FFEFFFF - (Base + 0xFFF);
            SET_SELECTOR_LIMIT(Sel, Limit);
        }

        if ((Sel >> 3) != 0) {
#ifndef _X86_
            {
                ULONG BaseOrig = Base;
                Base = GetDescriptorMapping(Sel, Base);
                if (BaseOrig == Base) {
                    Base += (ULONG)IntelBase;
                }
            }
#endif

            FlatAddress[Sel >> 3] = Base;
#if DBG
            SelectorLimit[Sel >> 3] = Limit;
#endif
        }

        //
        // Sanitize the selector
        //
        Ldt[Sel>>3].HighWord.Bits.Dpl = 3;
        Ldt[Sel>>3].HighWord.Bits.Reserved_0 = 0;
    }

#ifdef _X86_
    if (!DpmiSetX86Descriptor(SelStart, SelCount)) {
        return;
    }
#endif
}


#ifndef _X86_
VOID
FlushSelectorCache(
    USHORT  SelStart,
    USHORT  SelCount
    )
{
    DECLARE_LocalVdmContext;
    USHORT SelEnd;
    USHORT Sel;
    USHORT i;

    VdmTraceEvent(VDMTR_TYPE_DPMI | DPMI_GENERIC, SelStart, SelCount);

    //
    // The emulator compiles LDT entries, so we need to flush them
    // out
    //

    for (i = 0, Sel = SelStart; i < SelCount; i++, Sel += 8) {
        VdmFlushCache(LdtSel, Sel & SEL_INDEX_MASK, 8, VDM_PM);
    }

    SelEnd = SelStart + SelCount*8;

    Sel = getCS();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setCS(Sel);
    }

    Sel = getDS();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setDS(Sel);
    }

    Sel = getES();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setES(Sel);
    }

    Sel = getFS();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setFS(Sel);
    }

    Sel = getGS();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setGS(Sel);
    }

    Sel = getSS();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setSS(Sel);
    }


}
#endif



//
// Descriptor Mapping functions (RISC ONLY)
//
#ifndef _X86_

BOOL
VdmAddDescriptorMapping(
    USHORT SelectorStart,
    USHORT SelectorCount,
    ULONG LdtBase,
    ULONG Flat
    )
/*++

Routine Description:

    This function was added to support the DIB.DRV implementation on RISC.
    When an app uses DIB.DRV, then the situation arises where the Intel
    linear base address + the flat address of the start of the Intel address
    space does NOT equal the flat address of the memory. This happens when
    the VdmAddVirtualMemory() api is used to set up an additional layer of
    indirection for memory addressing in the emulator.

    But there is more to the story. When app wants to use CreateDIBSection
    via WinG we also need to map selectors, thus this routine should not
    depend upon DpmiSetDesctriptorEntry being called afterwards. Thus, we go
    and zap the flat address table with the new address.

Arguments:

    SelectorStart, Count - range of selectors involved in the mapping
    LdtBase              - Intel base of start of range
    Flat                 - True flat address base to be used for these selectors

Return Value:

    This function returns TRUE on success, or FALSE for failure (out of mem)

--*/

{
    PDESC_MAPPING pdm;
    USHORT i;

    if ((pdm = (PDESC_MAPPING) malloc(sizeof (DESC_MAPPING))) == NULL)
                return FALSE;

    pdm->Sel         = SelectorStart &= SEL_INDEX_MASK;
    pdm->SelCount    = SelectorCount;
    pdm->LdtBase     = LdtBase;
    pdm->FlatBase    = Flat;
    pdm->pNext       = pDescMappingHead;
    pDescMappingHead = pdm;

    // this code does what essentially desctribed in comment above
    for (i = 0; i < SelectorCount; ++i) {
        FlatAddress[(SelectorStart >> 3) + i] = Flat + 65536 * i;
    }

    return TRUE;
}

ULONG
GetDescriptorMapping(
    USHORT sel,
    ULONG LdtBase
    )
/*++

Routine Description:


Arguments:

    sel     - the selector for which the base should be returned
    LdtBase - the base for this selector as is set currently in the LDT

Return Value:

    The true flat address for the specified selector.

--*/
{
    PDESC_MAPPING pdm, pdmprev;
    ULONG Base = LdtBase;

    sel &= SEL_INDEX_MASK;                  // and off lower 3 bits
    pdm = pDescMappingHead;

    while (pdm) {

        if ((sel >= pdm->Sel) && (sel < (pdm->Sel + pdm->SelCount*8))) {
            //
            // We found a mapping for this selector. Now check to see if
            // the ldt base still matches the base when the mapping was
            // created.
            //
            if (LdtBase == (pdm->LdtBase + 65536*((sel-pdm->Sel)/8))) {
                //
                // The mapping appears still valid. Return the remapped address
                //
                return (pdm->FlatBase + 65536*((sel-pdm->Sel)/8));

            } else {
                //
                // The ldt base doesn't match the mapping, so the mapping
                // must be obselete. Free the mapping here.
                //
                if (pdm == pDescMappingHead) {
                    //
                    // mapping is the first in the list
                    //
                    pDescMappingHead = pdm->pNext;

                } else {
                    pdmprev->pNext = pdm->pNext;
                }
                free(pdm);
            }

            break;
        }
        pdmprev = pdm;
        pdm = pdm->pNext;

    }

    return Base;
}

#endif // _X86_

//
// LDT Management routines
//

VOID
DpmiInitLDT(
    VOID
    )
/*++

Routine Description:

    This routine stores the flat address for the LDT table in the 16bit
    land (pointed to by selGDT in 16bit land).

    It also initializes the free selector chain.

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Sel;

    //
    // Get the new LDT location
    //

    LdtSel = getAX();
    Ldt = (PVOID)VdmMapFlat(LdtSel, 0, VDM_PM);
    LdtMaxSel = getCX();

    if (!LdtUserSel) {
        LdtUserSel = getDI() & SEL_INDEX_MASK;
    }

    //
    // Initialize the LDT free list
    //

    selLDTFree = LdtUserSel;

    for (Sel = selLDTFree; Sel < (LdtMaxSel & SEL_INDEX_MASK); Sel += 8) {
        NEXT_FREE_SEL(Sel) = Sel+8;
        MARK_SELECTOR_FREE(Sel);
    }

    NEXT_FREE_SEL(Sel) = 0xffff;

}

VOID
DpmiResetLDTUserBase(
    VOID
    )
/*++

Routine Description:

    This routine can hopefully be eliminated at a later date. The flow of
    dosx initialization has made this necessary. What happens is this:
    Earlier, dosx has called up to dpmi32 to initialize the LDT (DpmiInitLDT),
    where it sets the start of the user are of the LDT, and from there,
    sets up the linked list of free LDT entries. But after that time, and
    before an app is run, there are pieces of dosx code which allocate
    selectors that are not transient. In particular, DXNETBIO does an
    AllocateLowSegment(), which is totally unecessary on NT, but it a
    bit tricky to rework. So what is happening here is a reset of the
    start of the user area of the LDT to permanently reserve any selectors
    that are not free.

Arguments:

    None

Return Value:

    None.

--*/
{
    LdtUserSel = selLDTFree;
}


VOID
DpmiAllocateSelectors(
    VOID
    )
//
// This routine is called via BOP by those routines in DOSX
// that still need to allocate selectors.
//
{
    DECLARE_LocalVdmContext;
    USHORT Sel;

    Sel = ALLOCATE_SELECTORS(getAX());
    if (!Sel) {
        setCF(1);
    } else {
        setAX(Sel);
        setCF(0);
    }
}

VOID
DpmiFreeSelector(
    VOID
    )
//
// This routine is called via BOP by those routines in DOSX
// that still need to free selectors.
//
{
    DECLARE_LocalVdmContext;

    if (FreeSelector(getAX())) {
        setCF(0);
    } else {
        setCF(1);
    }
}



BOOL
RemoveFreeSelector(
    USHORT Sel
    )
/*++

Routine Description:

    This routine removes a specific selector from the free
    selector chain.

Arguments:

    Sel   - the selector to be aquired

Return Value:

    Returns TRUE if the function was successful, FALSE if it
    was an invalid selector (not free)

--*/
{

    if (!IS_SELECTOR_FREE(Sel)) {
        return FALSE;
    }

    if (Sel == selLDTFree) {
        //
        // we are removing the head of the list
        //
        selLDTFree = NEXT_FREE_SEL(Sel);

    } else {
        USHORT SelTest;
        USHORT SelPrev = 0;

        SelTest = selLDTFree;
        while (SelTest != Sel) {
            if (SelTest == 0xffff) {
                // End of list
                return FALSE;
            }

            SelPrev = SelTest;
            SelTest = NEXT_FREE_SEL(SelTest);
        }
        NEXT_FREE_SEL(SelPrev) = NEXT_FREE_SEL(Sel);
    }

    MARK_SELECTOR_ALLOCATED(Sel);
    return TRUE;

}

USHORT
AllocateSelectors(
    USHORT Count,
    BOOL bWow
    )
/*++

Routine Description:

    This routine allocates selectors from the free selector chain.

Arguments:

    Count - number of selectors needed. If this is more than 1, then
            all selectors will be contiguous
    bWow  - if true, then use an allocation scheme that is more typical
            of win31 behavior. This is to avoid problems where winapps
            accidentally rely on the value of selectors

Return Value:

    Returns the starting selector of the block, or zero if the
    allocation failed.

--*/
{
    USHORT Sel;

    if (!Count || (Count>=(LdtMaxSel>>3))) {
        return 0;
    }

    if (Count == 1) {

        //
        // Allocating 1 selector
        //

        if ((Sel = selLDTFree) != 0xffff) {

            // Move next selector to head of list
            selLDTFree = NEXT_FREE_SEL(Sel);
            MARK_SELECTOR_ALLOCATED(Sel);
            return (Sel | SEL_LDT3);
        }

    } else {

        //
        // Allocating a selector block
        //
        // *******************************************************
        // The strategy of allocating selectors has been modified to
        // give preference to selector values above 1000h. This is an
        // attempt to emulate typical values that are returned by win31.
        //  -neilsa
        //
        // Some DPMI DOS applications demand that all selectors(no matter it comes
        // from AllocateLDTSelector or this function) be contiguous, so
        // the strategy for WOW doesn't work for DPMI DOS applications.
        // For this reason, a new parameter is added so the caller can control
        // where to start searching for free selectors.
        // -williamh
        //
#define SEL_START_HI 0x1000

        USHORT SelTest;
        USHORT SelStart = LdtUserSel;
        USHORT SelEnd = LdtMaxSel;
        BOOL bAllFree;

        if (bWow) {
            SelStart = SEL_START_HI;
        }

asrestart:

        for (Sel = SelStart; Sel < (SelEnd - Count*8); Sel += 8) {

            bAllFree = TRUE;
            for (SelTest = Sel; SelTest < Sel + Count*8; SelTest += 8) {

                if (!IS_SELECTOR_FREE(SelTest)) {
                    bAllFree = FALSE;
                    break;
                }

            }

            if (bAllFree) {
                //
                // Found a block. Now we need to peel off the chain from
                // the free list
                //
                int i;

                for (i = 0, SelTest = Sel; i < Count; i++, SelTest+=8) {

                    RemoveFreeSelector(SelTest);

                }
                return (Sel | SEL_LDT3);
            }
        }

        if (bWow && (SelEnd == LdtMaxSel)) {
            //
            // First pass for WOW complete, do it again
            //
            SelStart = LdtUserSel;
            SelEnd = SEL_START_HI + Count;
            goto asrestart;

        }
    }
    return 0;

}

BOOL
FreeSelector(
    USHORT Sel
    )
/*++

Routine Description:

    This routine returns a selector to the free selector chain.

Arguments:

    Sel   - the selector to be freed

Return Value:

    Returns TRUE if the function was successful, FALSE if it
    was an invalid selector (already free, reserved selector)

--*/
{
    if ((Sel < LdtUserSel) || (Sel > LdtMaxSel) ||
        IS_SELECTOR_FREE(Sel)) {
        //
        // invalid selector
        //
        return FALSE;
    }

    //
    // chain selector to head of free list
    //
    NEXT_FREE_SEL(Sel) = selLDTFree;
    selLDTFree = Sel & SEL_INDEX_MASK;

    MARK_SELECTOR_FREE(Sel);

    return TRUE;
}

USHORT
FindSelector(
    ULONG Base,
    UCHAR Access
    )
/*++

Routine Description:

    This routine looks for a selector that matches the base and access
    rights passed as arguments.

Arguments:

    Base  - Base address to compare.
    Access- Access rights byte to compare.

Return Value:

    Returns the selector that matches, or zero if the
    allocation failed.

--*/
{

    USHORT Sel;
    ULONG Limit;

    for (Sel = LdtUserSel; Sel < LdtMaxSel; Sel+=8) {

        if (!IS_SELECTOR_FREE(Sel)) {

            GET_SHADOW_SELECTOR_LIMIT(Sel, Limit);

            if ((Limit == 0xffff) && (Base == GET_SELECTOR_BASE(Sel)) &&
                ((Access & ~AB_ACCESSED) ==
                 (Ldt[Sel>>3].HighWord.Bytes.Flags1 & ~AB_ACCESSED))) {

                return (Sel | SEL_LDT3);

            }

        }

    }

    return 0;

}

USHORT
SegmentToSelector(
    USHORT Segment,
    USHORT Access
    )
/*++

Routine Description:

    This routine either finds or creates selector that can access the
    specified low memory segment.

Arguments:

    Segment- Paragraph segment address
    Access - Access rights

Return Value:

    Returns the selector that matches, or zero if the
    allocation failed.

--*/
{
    ULONG Base = ((ULONG) Segment) << 4;
    USHORT Sel;

    if (!(Sel = FindSelector(Base, (UCHAR)Access))) {

        if (Sel = ALLOCATE_SELECTOR()) {

            SetDescriptor(Sel, Base, 0xffff, Access);

        }

    }

    return Sel;
}

VOID
SetDescriptorArray(
    USHORT Sel,
    ULONG Base,
    ULONG MemSize
    )
/*++

Routine Description:

    This routine allocates a set of descriptors to cover the specified
    memory block. The descriptors are initialized as follows:
    The first descriptor points at the whole block, then all subsequent
    descriptors have a limit of 64k except for the final one, which has
    a limit of block size MOD 64k.

Arguments:

    Sel, Base, Memsize define the range of the selector array

Return Value:

    none

--*/
{

    USHORT SelCount;

    if (MemSize) {
        MemSize--;          // now a descriptor limit
    }

    SelCount = (USHORT) ((MemSize>>16) + 1);

    SetDescriptor(Sel, Base, MemSize, STD_DATA);
    while(--SelCount) {
        Sel += 8;
        MemSize -= 0x10000;         // subtract 64k
        Base += 0x10000;
        SetDescriptor(Sel,
                      Base,
                      (SelCount==1) ? MemSize : 0xffff,
                      STD_DATA);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\int2f.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Int2f.c

Abstract:

    This module provides the int 2f API for dpmi

Author:

    Neil Sandlin (neilsa) 23-Nov-1996


Revision History:


--*/
#include "precomp.h"
#pragma hdrstop
#include <softpc.h>
#include "xlathlp.h"

//
// Local constants
//
#define MSCDEX_FUNC 0x15
#define WIN386_FUNC 0x16
#define WIN386_IDLE             0x80
#define WIN386_Get_Device_API   0x84
#define WIN386_INT31            0x86
#define WIN386_GETLDT           0x88
#define WIN386_KRNLIDLE         0x89
#define DPMI_MSDOS_EXT          0x8A

#define SEL_LDT 0x137

#define DISPCRIT_FUNC   0x40
#define DISPCRIT_ENTER  0x03
#define DISPCRIT_EXIT   0x04

#define XMS_ID          0x43
#define XMS_INS_CHK     0x00
#define XMS_CTRL_FUNC   0x10

BOOL    nt_mscdex(VOID);

BOOL
PMInt2fHandler(
    VOID
    )
/*++

Routine Description:

    This routine is called at the end of the protect mode PM int chain
    for int 2fh. It is provided for compatibility with win31.

Arguments:

    Client registers are the arguments to int2f

Return Value:

    TRUE if the interrupt was handled, FALSE otherwise

--*/
{
    DECLARE_LocalVdmContext;
    BOOL bHandled = FALSE;
    static char szMSDOS[] = "MS-DOS";
    PCHAR VdmData;

    switch(getAH()) {

    //
    // Int2f Func 15xx - MSCDEX
    //
    case MSCDEX_FUNC:

        bHandled = nt_mscdex();
        break;

    //
    // Int2f Func 16
    //
    case WIN386_FUNC:

        switch(getAL()) {

        case WIN386_KRNLIDLE:
        case WIN386_IDLE:
            bHandled = TRUE;
            break;

        case WIN386_GETLDT:
            if (getBX() == 0xbad) {
                setAX(0);
                setBX(SEL_LDT);
                bHandled = TRUE;
            }
            break;

        case WIN386_INT31:
            setAX(0);
            bHandled = TRUE;
            break;

        case WIN386_Get_Device_API:
            GetVxDApiHandler(getBX());
            bHandled = TRUE;
            break;

        case DPMI_MSDOS_EXT:
            VdmData = VdmMapFlat(getDS(), (*GetSIRegister)(), VDM_PM);
            if (!strcmp(VdmData, szMSDOS)) {

                setES(HIWORD(DosxMsDosApi));
                (*SetDIRegister)((ULONG)LOWORD(DosxMsDosApi));
                setAX(0);
                bHandled = TRUE;
            }
            break;

        }
        break;

    //
    // Int2f Func 40
    //
    case DISPCRIT_FUNC:
        if ((getAL() == DISPCRIT_ENTER) ||
            (getAL() == DISPCRIT_ENTER)) {
            bHandled = TRUE;
        }
        break;

    //
    // Int2f Func 43
    //
    case XMS_ID:
        if (getAL() == XMS_INS_CHK) {
            setAL(0x80);
            bHandled = TRUE;
        } else if (getAL() == XMS_CTRL_FUNC) {
            setES(HIWORD(DosxXmsControl));
            setBX(LOWORD(DosxXmsControl));
            bHandled = TRUE;
        }
        break;
    }

    return bHandled;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\int31.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Int31.c

Abstract:

    This module provides the int 31 API for dpmi

Author:

    Neil Sandlin (neilsa) 23-Nov-1996


Revision History:


--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include "xlathlp.h"

VOID Int31NotImplemented(VOID);
VOID Int31SelectorManagement(VOID);
VOID Int31DOSMemoryManagement(VOID);
VOID Int31InterruptManagement(VOID);
VOID Int31Translation(VOID);
VOID Int31Function4xx(VOID);
VOID Int31MemoryManagement(VOID);
VOID Int31PageLocking(VOID);
VOID Int31DemandPageTuning(VOID);
VOID Int31VirtualIntState(VOID);
VOID Int31DbgRegSupport(VOID);

//
// Local constants
//
#define MAX_DPMI_MAJOR_FUNCTION 0xb

typedef VOID (*APIFUNCTION)(VOID);
APIFUNCTION DpmiMajorFunctionTable[MAX_DPMI_MAJOR_FUNCTION+1] = {

    Int31SelectorManagement , // Selector_Management    ;[0]
    Int31DOSMemoryManagement, // DOS_Mem_Mgt            ;[1]
    Int31InterruptManagement, // Int_Serv               ;[2]
    Int31Translation        , // Trans_Serv             ;[3]
    Int31Function4xx        , // Get_Version            ;[4]
    Int31MemoryManagement   , // Mem_Managment          ;[5]
    Int31PageLocking        , // Page_Lock              ;[6]
    Int31DemandPageTuning   , // Demand_Page_Tuning     ;[7]
    Int31NotImplemented     , // Phys_Addr_Mapping      ;[8]
    Int31VirtualIntState    , // Virt_Interrrupt_State  ;[9]
    Int31NotImplemented     , // Not_Supported          ;[A]
    Int31DbgRegSupport      , // Debug_Register_Support ;[B]

};

VOID
DpmiInt31Entry(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when the caller has issued an int31.

Arguments:

    None

Return Value:

    None.

--*/
{

    DECLARE_LocalVdmContext;
    ULONG DpmiMajorCode = getAH();
    PUCHAR StackPointer;

    //
    // Pop ds from stack
    //
    StackPointer = VdmMapFlat(getSS(), (*GetSPRegister)(), VDM_PM);

    setDS(*(PWORD16)StackPointer);
    (*SetSPRegister)((*GetSPRegister)() + 2);

    //
    // Take the iret frame off the stack before we do the operation. This
    // way we have the stack pointer set up to the same place as we would
    // if this was a kernel mode dpmi host.
    //
    SimulateIret(RESTORE_FLAGS);

    setCF(0);       // assume success

    if (DpmiMajorCode <= MAX_DPMI_MAJOR_FUNCTION) {

        (*DpmiMajorFunctionTable[DpmiMajorCode])();

    } else {
        setCF(1);
    }

}

VOID
DpmiInt31Call(
    VOID
    )
/*++

Routine Description:

    This routine dispatches to the appropriate routine to perform the
    actual translation of the api

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    ULONG DpmiMajorCode = getAH();
    PUCHAR StackPointer;

    //
    // Pop ds from stack
    //
    StackPointer = VdmMapFlat(getSS(), (*GetSPRegister)(), VDM_PM);

    setDS(*(PWORD16)StackPointer);
    (*SetSPRegister)((*GetSPRegister)() + 2);

    setCF(0);       // assume success

    if (DpmiMajorCode <= MAX_DPMI_MAJOR_FUNCTION) {

        (*DpmiMajorFunctionTable[DpmiMajorCode])();

    } else {
        setCF(1);
    }

}

VOID
Int31NotImplemented(
    VOID
    )
/*++

Routine Description:

    This routine handles int 31 functions that aren't implemented on NT.
    It just returns carry to the app.

Arguments:

    None

Return Value:

    TRUE - The function has been completed

--*/
{
    DECLARE_LocalVdmContext;

    setCF(1);
}

VOID
Int31SelectorManagement(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 00xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Sel;
    USHORT NewSel;
    UCHAR Func = getAL();
    LDT_ENTRY UNALIGNED *Descriptor;
    USHORT Access;
    ULONG Base;
    USHORT Count;
    ULONG Limit;
    static UCHAR ReservedSelectors[16] = {0};

    //
    // First, validate the selector
    //
    if ((Func >= 4) && (Func <= 0xC)) {
        Sel = getBX() & SEL_INDEX_MASK;

        //
        // Make sure the selector in question is allocated
        //
        if (((Sel <= SEL_DPMI_LAST) && (!ReservedSelectors[Sel>>3])) ||
             (Sel > LdtMaxSel) ||
            ((Sel > SEL_DPMI_LAST) && IS_SELECTOR_FREE(Sel))) {
            setCF(1);
            return;
        }

    }

    switch(Func) {

    //
    // Allocate Selectors
    //
    case 0:
        Count = getCX();
        Sel = ALLOCATE_SELECTORS(Count);

        if (!Sel || !Count) {
            setCF(1);
            break;
        }

        setAX(Sel);
        while(Count--) {
            SetDescriptor(Sel, 0, 0, STD_DATA);
            Sel+=8;
        }
        break;

    //
    // Free Selector
    //
    case 1:
        Sel = getBX() & SEL_INDEX_MASK;

        if (Sel <= SEL_DPMI_LAST) {
            if (!ReservedSelectors[Sel>>3]) {
                setCF(1);
            } else {
                ReservedSelectors[Sel>>3] = 0;
            }
            break;
        }

        if (!FreeSelector(Sel)) {
            setCF(1);
        }

        if (getCF() == 0) {
            // Zero out segment registers if it contains what we just freed
            // shielint: fs, gs, ss??? kernel will fix fs and gs for us. SS is unlikely
            // to have the freed selector.  If yes, the app is gone anyway.
            if (getBX() == getDS()) {
                setDS(0);
            }
            if (getBX() == getES()) {
                setES(0);
            }
        }
        break;

    //
    // Segment to Descriptor
    //
    case 2:
        Sel = SegmentToSelector(getBX(), STD_DATA);
        if (!Sel) {
            setCF(1);
        } else {
            setAX(Sel);
        }
        break;

    //
    // Get Next Selector Increment value
    //
    case 3:
        setAX(8);
        break;

    //
    // Lock functions unimplemented on NT
    //
    case 4:
    case 5:
        break;

    //
    // Get Descriptor Base
    //
    case 6:
        Base = GET_SELECTOR_BASE(Sel);
        setDX((USHORT)Base);
        setCX((USHORT)(Base >> 16));
        break;

    //
    // Set Descriptor Base
    //
    case 7:
        SetDescriptorBase(Sel, (((ULONG)getCX())<<16) | getDX());
        break;

    //
    // Set Segment Limit
    //
    case 8:
        Limit = ((ULONG)getCX()) << 16 | getDX();

        if (Limit < 0x100000) {         // < 1Mb?
            Ldt[Sel>>3].HighWord.Bits.Granularity = 0;
        } else {
            if ((Limit & 0xfff) != 0xfff) {

                // Limit > 1MB, but not page aligned. Return error
                setCF(1);
                break;
            }

            Ldt[Sel>>3].HighWord.Bits.Granularity = 1;

        }

        SET_SELECTOR_LIMIT(Sel, Limit);
        SetShadowDescriptorEntries(Sel, 1);
        FLUSH_SELECTOR_CACHE(Sel, 1);
        break;

    //
    // Set Descriptor Access
    //
    case 9:
        Access = getCX();
        //
        // verify that they aren't setting "System", and that its ring3
        //
        if ((Access & 0x70) != 0x70) {
            setCF(1);
            break;
        }

        SET_SELECTOR_ACCESS(Sel, Access);
        SetShadowDescriptorEntries(Sel, 1);
        FLUSH_SELECTOR_CACHE(Sel, 1);
        break;

    //
    // Create data alias
    //
    case 0xA:
        if (!IS_SELECTOR_READABLE(Sel)) {
            setCF(1);
            break;
        }

        NewSel = ALLOCATE_SELECTOR();
        if (!NewSel) {
            setCF(1);
            break;
        }

        Ldt[NewSel>>3] = Ldt[Sel>>3];

        Ldt[NewSel>>3].HighWord.Bytes.Flags1 &= (AB_PRESENT | AB_DPL3);
        Ldt[NewSel>>3].HighWord.Bytes.Flags1 |= (AB_DATA | AB_WRITE);
        SetShadowDescriptorEntries(NewSel, 1);
        FLUSH_SELECTOR_CACHE(NewSel, 1);

        setAX(NewSel);
        break;

    //
    // Get Descriptor
    //
    case 0xB:
        Descriptor = VdmMapFlat(getES(), (*GetDIRegister)(), VDM_PM);
        *Descriptor = Ldt[Sel>>3];
        break;

    //
    // Set Descriptor
    //
    case 0xC:
        Descriptor = VdmMapFlat(getES(), (*GetDIRegister)(), VDM_PM);

        //
        // verify that this isn't a System descriptor, and that its ring3
        //
        if (!(Descriptor->HighWord.Bits.Type & 0x10) ||
            ((Descriptor->HighWord.Bits.Dpl & 3) != 3)) {
            setCF(1);
            return;
        }

        Ldt[Sel>>3] = *Descriptor;

        SetShadowDescriptorEntries(Sel, 1);
        FLUSH_SELECTOR_CACHE(Sel, 1);
        break;

    //
    // Allocate Specific Sel
    //
    case 0xD:
        Sel = getBX() & ~7;

        if ((Sel > SEL_DPMI_LAST) || ReservedSelectors[Sel>>3]) {
            setCF(1);
        } else {
            ReservedSelectors[Sel>>3] = 1;
        }
        break;

    default:
        setCF(1);
    }

    return;
}

VOID
Int31DOSMemoryManagement(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 01xx functions.
    The functionality is implemented in dosmem.c.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;

    switch(getAL()) {

    //
    // Allocate DOS memory block
    //
    case 0:
        DpmiAllocateDosMem();
        break;

    //
    // Free DOS memory block
    //
    case 1:
        DpmiFreeDosMem();
        break;

    //
    // Resize DOS memory block
    //
    case 2:
        DpmiSizeDosMem();
        break;

    }
}

VOID
Int31InterruptManagement(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 02xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    UCHAR IntNumber = getBL();
    PWORD16 pIvtEntry;

    switch(getAL()) {

    //
    // Get Real Mode Interrupt Vector
    //
    case 0:
        pIvtEntry = (PWORD16) (IntelBase + IntNumber*4);

        setDX(*pIvtEntry++);
        setCX(*pIvtEntry);
        break;

    //
    // Set Real Mode Interrupt Vector
    //
    case 1:
        pIvtEntry = (PWORD16) (IntelBase + IntNumber*4);

        *pIvtEntry++ = getDX();
        *pIvtEntry = getCX();
        break;

    //
    // Get exception handler Vector
    //
    case 2: {
        PVDM_FAULTHANDLER Handlers = DpmiFaultHandlers;

        if (IntNumber >= 32) {
            setCF(1);
            break;
        }

        setCX(Handlers[IntNumber].CsSelector);
        (*SetDXRegister)(Handlers[IntNumber].Eip);

        break;
    }

    //
    // Set exception handler Vector
    //
    case 3:
        if (!SetFaultHandler(IntNumber, getCX(), (*GetDXRegister)())){
            setCF(1);
        }
        break;

    //
    // Get Protect Mode Interrupt Vector
    //
    case 4: {
        PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;

        setCX(Handlers[IntNumber].CsSelector);
        (*SetDXRegister)(Handlers[IntNumber].Eip);

        break;
    }

    //
    // Set Protect Mode Interrupt Vector
    //
    case 5:
        if (!SetProtectedModeInterrupt(IntNumber, getCX(), (*GetDXRegister)(),
                                       (USHORT)(Frame32 ? VDM_INT_32 : VDM_INT_16))) {
            setCF(1);
        }
        break;

    }

}



VOID
Int31Translation(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 03xx functions.
    The functionality is implemented in modesw.c.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;

    switch(getAL()) {

    //
    // Simulate Real Mode Interrupt
    // Call Real Mode Procedure with Far Return Frame
    // Call Real Mode Procedure with Iret Frame
    //
    case 0:
    case 1:
    case 2:
        DpmiRMCall(getAL());
        break;

    //
    // Allocate Real Mode Call-Back Address
    //
    case 3:
        DpmiAllocateRMCallBack();
        break;

    //
    // Free Real Mode Call-Back Address
    //
    case 4:
        DpmiFreeRMCallBack();
        break;

    //
    // Get State Save/Restore Addresses
    //
    case 5:
        setAX(0);
        setBX((USHORT)(DosxRmSaveRestoreState>>16));
        setCX((USHORT)DosxRmSaveRestoreState);
        setSI((USHORT)(DosxPmSaveRestoreState>>16));
        (*SetDIRegister)(DosxPmSaveRestoreState & 0x0000FFFF);
        break;

    //
    // Get Raw Mode Switch Addresses
    //
    case 6:
        setBX((USHORT)(DosxRmRawModeSwitch>>16));
        setCX((USHORT)DosxRmRawModeSwitch);
        setSI((USHORT)(DosxPmRawModeSwitch>>16));
        (*SetDIRegister)(DosxPmRawModeSwitch & 0x0000FFFF);
        break;

    }

}

VOID
Int31Function4xx(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 04xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Sel;

    switch(getAL()) {

    //
    // Get Version
    //
    case 0:
        setAX(I31VERSION);
        setBX(I31FLAGS);
        setCL(idCpuType);
        setDX((I31MasterPIC << 8) | I31SlavePIC);
        break;


    //
    // INTERNAL NT FUNCTION: WowAllocSelectors
    // This function is equivalent to DPMI func 0000,
    // except that it skips the step of initializing the
    // descriptors.
    //
    case 0xf1:
        Sel = ALLOCATE_WOW_SELECTORS(getCX());


        if (!Sel) {
            setCF(1);
            // We fall thru to make sure AX is set to 0 in the failure case.
        }

        setAX(Sel);

        break;
    //
    // INTERNAL NT FUNCTION: WowSetDescriptor
    // This function assumes that the local LDT has already
    // been set in the client. All that needs to be done
    // is an update of dpmi32 entries, as well as sending
    // it to the x86 ntoskrnl.
    //
    case 0xf2:

        Sel = getBX() & ~7;

        if (Sel > LdtMaxSel) {
            setCF(1);
            break;
        }

        SetShadowDescriptorEntries(Sel, getCX());
        // no need to flush the cache on risc since the ldt was changed
        // from the 16-bit side, and has thus already been flushed
        break;

    //
    // INTERNAL NT FUNCTION: WowSetLowMemFuncs
    // Wow is passing us the address of GlobalDOSAlloc, GlobalDOSFree
    // so that we can support the DPMI Dos memory management functions
    //
    case 0xf3:
        WOWAllocSeg = getBX();
        WOWAllocFunc = getDX();
        WOWFreeSeg = getSI();
        WOWFreeFunc = getDI();
        break;

    }

}

VOID
Int31MemoryManagement(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 05xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI pMem;

    switch(getAL()) {

    //
    // Get Free Memory Information
    //
    case 0:
        DpmiGetMemoryInfo();
        break;

    //
    // Allocate Memory Block
    //
    case 1:
        pMem = DpmiAllocateXmem(((ULONG)getBX() << 16) | getCX());

        if (!pMem) {
            setCF(1);
            break;
        }
        //
        // Return the information about the block
        //
        setBX((USHORT)((ULONG)pMem->Address >> 16));
        setCX((USHORT)((ULONG)pMem->Address & 0x0000FFFF));
        setSI((USHORT)((ULONG)pMem >> 16));
        setDI((USHORT)((ULONG)pMem & 0x0000FFFF));
        break;

    //
    // Free Memory Block
    //
    case 2:
        pMem = (PMEM_DPMI)(((ULONG)getSI() << 16) | getDI());
        if (!DpmiIsXmemHandle(pMem) || !DpmiFreeXmem(pMem)) {
            setCF(1);
        }
        break;

    //
    // Resize Memory Block
    //
    case 3: {

        ULONG ulMemSize;

        ulMemSize = ((ULONG)getBX() << 16) | getCX();

        //
        // Not allowed to resize to 0
        //
        if ( ulMemSize != 0 ) {

            pMem = (PMEM_DPMI)(((ULONG)getSI() << 16) | getDI());

            if (!DpmiReallocateXmem(pMem, ulMemSize) ) {
                setCF(1);
                break;
            }

            //
            // Return the information about the block
            //
            setBX((USHORT)((ULONG)pMem->Address >> 16));
            setCX((USHORT)((ULONG)pMem->Address & 0x0000FFFF));
        }
        else
        {
            setCF(1);
        }

        break;
        }

    }

}

VOID
Int31PageLocking(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 06xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    switch(getAL()) {

    //
    // Lock functions not implemented
    //
    case 0:
    case 1:
    case 2:
    case 3:
        break;

    //
    // Get Page Size
    //
    case 4:
        setBX(0);
        setCX(0x1000);
        break;

    }

}


VOID
Int31DemandPageTuning(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 07xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    ULONG Addr = (getBX()<<16 | getCX()) + IntelBase;
    ULONG Count = getSI()<<16 | getDI();

    if (Count) {

        switch(getAL()) {

        //
        // Mark Page as Demand Paging Candidate
        //

        case 0:
            // Addr, Count expressed in 4k pages
            Addr <<= 12;
            Count <<= 12;
        case 2:

            VirtualUnlock((PVOID)Addr, Count);

            break;

        //
        // Discard Page Contents
        //

        case 1:
            // Addr, Count expressed in 4k pages
            Addr <<= 12;
            Count <<= 12;
        case 3:

            VirtualAlloc((PVOID)Addr, Count, MEM_RESET, PAGE_READWRITE);

            break;

        default:
            setCF(1);
        }

    }

}

VOID
Int31VirtualIntState(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 09xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    BOOL bVIF = *(ULONG *)(IntelBase+FIXED_NTVDMSTATE_LINEAR) & VDM_VIRTUAL_INTERRUPTS;

    switch(getAL()) {

    //
    // Get and disable Virtual Interrupt State
    //

    case 0:
        setEFLAGS(getEFLAGS() & ~EFLAGS_IF_MASK);
        break;

    //
    // Get and enable Virtual Interrupt State
    //

    case 1:
        setEFLAGS(getEFLAGS() | EFLAGS_IF_MASK);
        break;


    case 2:
        break;

    default:
        setCF(1);
        return;
    }

    if (bVIF) {
        setAL(1);
    } else {
        setAL(0);
    }
}


VOID
Int31DbgRegSupport(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 0bxx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;

#ifndef _X86_
    setCF(1);
#else
    ULONG DebugRegisters[6];
    USHORT Handle;
    ULONG Mask;
    ULONG Size;
    ULONG Type;
    UCHAR Func = getAL();

#define DBG_TYPE_EXECUTE 0
#define DBG_TYPE_WRITE 1
#define DBG_TYPE_READWRITE 2
#define DBG_DR6 4
#define DBG_DR7 5

#define DR7_LE 0x100
#define DR7_L0 0x01
#define DR7_L1 0x04
#define DR7_L2 0x10
#define DR7_L3 0x40

//
// Debugging ntvdm under NTSD affects the values of the debug register
// context, so defining the following value turns on some debugging
// code
//
//#define DEBUGGING_DEBUGREGS 1

    if (!DpmiGetDebugRegisters(DebugRegisters)) {
        setCF(1);
        return;
    }

#ifdef DEBUGGING_DEBUGREGS
    {
        char szMsg[256];
        wsprintf(szMsg, " DR0-3=%.8X %.8X %.8X %.8X DR6,7=%.8X %.8X\n",
                        DebugRegisters[0],
                        DebugRegisters[1],
                        DebugRegisters[2],
                        DebugRegisters[3],
                        DebugRegisters[DBG_DR6],
                        DebugRegisters[DBG_DR7]);
        OutputDebugString(szMsg);
    }
#endif

    if (Func != 0) {
        Handle = getBX();
        //
        // point at the local enable bit for this handle in DR7
        //
        Mask = (DR7_L0 << Handle*2);

        if ((Handle >= 4) ||
            (!(DebugRegisters[DBG_DR7] & Mask))) {
            // Invalid Handle
            setCF(1);
            return;
        }

    }


    switch(Func) {

    //
    // Set Debug Watchpoint
    //

    case 0:

        for (Handle = 0, Mask = 3; Handle < 4; Handle++, Mask <<= 2) {
            if (!(DebugRegisters[DBG_DR7] & Mask)) {
                //
                // found a free register
                //

                //
                // Set the linear address
                //
                DebugRegisters[Handle] = (((ULONG)getBX()) << 16) + getCX();

                Size = getDL();
                Type = getDH();

                if (Type == DBG_TYPE_EXECUTE) {
                    // force size to be 1 for execute
                    Size = 1;
                }

                if ((Size > 4) || (Size == 3) || (!Size) || (Type > 2)) {
                    // error: invalid parameter
                    break;
                }

                //
                // convert size to appropriate bits in DR7
                //
                Size--;
                Size <<= (18 + Handle*4);

                //
                // convert type to appropriate bits in DR7
                //
                if (Type == DBG_TYPE_READWRITE) {
                    Type++;
                }
                Type <<= (16 + Handle*4);

                Mask = 0xf << (16 + Handle*4);

                //
                // Set the appropriate Len, R/W, and enable bits in DR7
                // Also set the common global and local enable bits.
                //
                DebugRegisters[DBG_DR7] &= ~Mask;
                DebugRegisters[DBG_DR7] |= (Size | Type | (DR7_L0 << Handle*2));
                DebugRegisters[DBG_DR7] |= DR7_LE;

                //
                // Clear triggered bit for this BP
                //
                DebugRegisters[DBG_DR6] &= ~(1 << Handle);

#ifdef DEBUGGING_DEBUGREGS
                {
                    char szMsg[256];
                    wsprintf(szMsg, "Int31 Setting DBGREG %d, Location %.8X, DR7=%.8X\n",
                            Handle, DebugRegisters[Handle], DebugRegisters[DBG_DR7]);
                    OutputDebugString(szMsg);
                }
#endif

                if (DpmiSetDebugRegisters(DebugRegisters)) {
                    return;
                }
                break;
            }
        }

        setCF(1);
        break;

    //
    // Clear Debug Watchpoint
    //

    case 1:

        //
        // clear enabled and triggered bits for this BP
        //

        DebugRegisters[DBG_DR7] &= ~Mask;
        DebugRegisters[DBG_DR6] &= (1 << Handle);
        DebugRegisters[Handle] = 0;

        //
        // Check to see if this clears all BP's (all local enable bits
        // clear), and disable common enable bit if so
        //
        if (!(DebugRegisters[DBG_DR7] & (DR7_L0 | DR7_L1 | DR7_L2 | DR7_L3))) {
            DebugRegisters[DBG_DR7] &= ~DR7_LE;
        }

#ifdef DEBUGGING_DEBUGREGS
        {
            char szMsg[256];
            wsprintf(szMsg, "Int31 Clearing DBGREG %d, DR7=%.8X\n",
                            Handle, DebugRegisters[DBG_DR7]);
            OutputDebugString(szMsg);
        }
#endif
        if (!DpmiSetDebugRegisters(DebugRegisters)) {
            setCF(1);
        }

        break;

    //
    // Get State of Debug Watchpoint
    //

    case 2:
        if (DebugRegisters[DBG_DR6] & (1 << Handle)) {
            setAX(1);
        } else {
            setAX(0);
        }

#ifdef DEBUGGING_DEBUGREGS
        {
            char szMsg[256];
            wsprintf(szMsg, "Int31 Query on DBGREG %d returns %d\n", Handle, getAX());
            OutputDebugString(szMsg);
        }
#endif
        break;

    //
    // Reset Debug Watchpoint
    //

    case 3:
        DebugRegisters[DBG_DR6] &= ~(1 << Handle);

#ifdef DEBUGGING_DEBUGREGS
        {
            char szMsg[256];
            wsprintf(szMsg, "Int31 Resetting DBGREG %d\n", Handle);
            OutputDebugString(szMsg);
        }
#endif
        if (!DpmiSetDebugRegisters(DebugRegisters)) {
            setCF(1);
        }

        break;

    default:
        setCF(1);
    }


#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\precomp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the private include file for the 32 bit dpmi and protected mode
    support

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include <dpmi.h>
#include <vint.h>
#include <mvdm.h>
#include <dpmi32.h>
#include <dbgsvc.h>
#include <nt_vdd.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\stack.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Stack.c

Abstract:

    This module implements routines for manipulating the 16 bit stack

Author:

    Dave Hastings (daveh) 24-Nov-1992

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"

#if 0   // Disable the code for now
VOID
FreePMStack(
    USHORT Sel
    );

USHORT
AllocatePMStack(
    USHORT MemSize
    );

#endif

VOID
DpmiPushRmInt(
    USHORT InterruptNumber
    )
/*++

Routine Description:

    This routine pushes an interrupt frame on the stack and sets up cs:ip
    for the specified interrupt.

Arguments:

    InterruptNumber -- Specifies the index of the interrupt

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PWORD16 StackPointer;
    ULONG IntHandler;

    // bugbug stack wrap???

    ASSERT((getSP() > 6));
    ASSERT((!(getMSW() & MSW_PE)));

    StackPointer = (PWORD16)VdmMapFlat(getSS(), getSP(), VDM_V86);

    *(StackPointer - 3) = (USHORT)(RmBopFe & 0x0000FFFF);
    *(StackPointer - 2) = (USHORT)(RmBopFe >> 16);
    *(StackPointer - 1) = getSTATUS();

    setSP(getSP() - 6);

    IntHandler = *(PDWORD16) (IntelBase + InterruptNumber*4);
    setIP(LOWORD(IntHandler));
    setCS(HIWORD(IntHandler));
}

VOID
BeginUseLockedPMStack(
    VOID
    )
/*++

Routine Description:

    This routine switches to the protected DPMI stack as specified by
    the DPMI spec. We remember the original values of EIP and ESP in
    global variables if we are at level zero. This allows us to correctly
    return to a 32 bit routine if we are dispatching a 16-bit interrupt
    frame.


--*/

{
    DECLARE_LocalVdmContext;
#if 0  // Disabled for now
    if (LockedPMStackSel == 0) {
        LockedPMStackSel = AllocatePMStack(LockedPMStackOffset);  // LockedPMStackOffset is acturally the size
        LockedPMStackCount = 0;

        //
        // Note the stack allocation may still fail.  In this case, the setSS() will set SS selector
        // to zero and the error will be catched during BuildStackFrame() call
        //

    }
#endif
    if (!LockedPMStackCount++) {

        DBGTRACE(VDMTR_TYPE_DPMI | DPMI_SWITCH_STACKS, (USHORT)LockedPMStackSel, LockedPMStackOffset);

        PMLockOrigEIP = getEIP();
        PMLockOrigSS = getSS();
        PMLockOrigESP = getESP();
        setSS(LockedPMStackSel);
        setESP(LockedPMStackOffset);
    }
}

BOOL
EndUseLockedPMStack(
    VOID
    )
/*++

Routine Description:

    This routine switches the stack back off the protected DPMI stack,
    if we are popping off the last frame on the stack.

Return Value:

    TRUE if the stack was switched back, FALSE otherwise

--*/


{
    DECLARE_LocalVdmContext;

    if (!--LockedPMStackCount) {

        //
        // We probably should free the PM stack except the one passed from DOSX??
        //

        DBGTRACE(VDMTR_TYPE_DPMI | DPMI_SWITCH_STACKS, (USHORT)PMLockOrigSS, PMLockOrigESP);

        setEIP(PMLockOrigEIP);
        setSS((WORD)PMLockOrigSS);
        setESP(PMLockOrigESP);
        return TRUE;
    }
    return FALSE;

}


BOOL
BuildStackFrame(
    ULONG StackUnits,
    PUCHAR *pVdmStackPointer,
    ULONG *pNewSP
    )
/*++

Routine Description:

    This routine builds stack frames for the caller. It figures if it needs
    to use a 16 or 32-bit frame, and adjusts SP or ESP appropriately based
    on the number of "stack units". It also returns a flat pointer to the
    top of the frame to the caller.

Arguments:

    StackUnits = number of registers needed to be saved on the frame. For
                 example, 3 is how many elements there are on an iret frame
                 (flags, cs, ip)

Return Value:

    This function returns TRUE on success, FALSE on failure

    VdmStackPointer - flat address pointing to the "top" of the frame

Notes:

    BUGBUG This routine doesn't check for stack faults or 'UP' direction
           stacks
--*/

{
    DECLARE_LocalVdmContext;
    USHORT SegSs;
    ULONG VdmSp;
    PUCHAR VdmStackPointer;
    ULONG StackOffset;
    ULONG Limit;
    ULONG SelIndex;
    ULONG NewSP;
    BOOL bExpandDown;
    BOOL rc;

    rc = TRUE;
    SegSs = getSS();
    SelIndex = (SegSs & ~0x7)/sizeof(LDT_ENTRY);
    if ((USHORT)SelIndex > (LdtMaxSel >> 3)) {
        ASSERT(0);
        return FALSE;
    }
    Limit = (ULONG) (Ldt[SelIndex].HighWord.Bits.LimitHi << 16) |
                     Ldt[SelIndex].LimitLow;

    //
    // Make it paged aligned if not 4G size stack.
    //
    if (Ldt[SelIndex].HighWord.Bits.Granularity) {
        Limit = (Limit << 12) | 0xfff;
    }
    if (Limit != 0xffffffff) Limit++;


    if (Ldt[SelIndex].HighWord.Bits.Default_Big) {
        VdmSp = getESP();
    } else {
        VdmSp = getSP();
    }

    if (CurrentAppFlags) {
        StackOffset = StackUnits*sizeof(DWORD);
    } else {
        StackOffset = StackUnits*sizeof(WORD);
    }

    NewSP = VdmSp - StackOffset;
    bExpandDown = (BOOL) (Ldt[SelIndex].HighWord.Bits.Type & 4);
    if ((StackOffset > VdmSp) ||
        (!bExpandDown && (VdmSp > Limit)) ||
        (bExpandDown && (NewSP < Limit))) {
        // failed limit check
        ASSERT(0);
        rc = FALSE;
    }

    *pNewSP = NewSP;
    VdmStackPointer = VdmMapFlat(SegSs, VdmSp, VDM_PM);
    *pVdmStackPointer = VdmStackPointer;
    return rc;

}


VOID
EmulateV86Int(
    UCHAR InterruptNumber
    )
/*++

Routine Description:

    This routine is responsible for simulating a real mode interrupt. It
    uses the real mode IVT at 0:0.

Arguments:

    IntNumber - interrupt vector number
    Eflags - client flags to save on the stack


--*/

{
    DECLARE_LocalVdmContext;
    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;
    PUCHAR VdmStackPointer;
    PWORD16 pIVT;
    USHORT VdmSP;
    USHORT NewCS;
    USHORT NewIP;
    ULONG Eflags = getEFLAGS();

    VdmStackPointer = VdmMapFlat(getSS(), 0, VDM_V86);
    VdmSP = getSP() - 2;
    *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) Eflags;
    VdmSP -= 2;
    *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getCS();
    VdmSP -= 2;
    *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getIP();
    setSP(VdmSP);

    //
    // See if this interrupt is hooked in protect mode, and if we should
    // reflect there instead.
    //
    if (Handlers[InterruptNumber].Flags & VDM_INT_HOOKED) {
        NewCS = (USHORT) (DosxRMReflector >> 16);
        NewIP = (USHORT) DosxRMReflector;
        //
        // now encode the interrupt number into CS
        //
        NewCS -= (USHORT) InterruptNumber;
        NewIP += (USHORT) (InterruptNumber*16);
    } else {
        PWORD16 pIvtEntry = (PWORD16) (IntelBase + InterruptNumber*4);

        NewIP = *pIvtEntry++;
        NewCS = *pIvtEntry;
    }

    setIP(NewIP);
    setCS(NewCS);
    //
    // Turn off flags like the hardware would
    //
    setEFLAGS(Eflags & ~(EFLAGS_TF_MASK | EFLAGS_IF_MASK));
}


VOID
SimulateFarCall(
    USHORT Seg,
    ULONG Offset
    )
{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    USHORT VdmSP;

    if (getMODE() == VDM_V86) {

        VdmStackPointer = VdmMapFlat(getSS(), 0, VDM_V86);
        VdmSP = getSP() - 2;
        *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getCS();
        VdmSP -= 2;
        *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getIP();
        setSP(VdmSP);
        setCS(Seg);
        setIP((USHORT)Offset);

    } else {
        DbgBreakPoint();

    }

}

VOID
SimulateCallWithIretFrame(
    USHORT Seg,
    ULONG Offset
    )
{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    USHORT VdmSP;

    if (getMODE() == VDM_V86) {

        VdmStackPointer = VdmMapFlat(getSS(), 0, VDM_V86);
        VdmSP = getSP() - 2;
        *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getEFLAGS();
        VdmSP -= 2;
        *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getCS();
        VdmSP -= 2;
        *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getIP();
        setSP(VdmSP);
        setCS(Seg);
        setIP((USHORT)Offset);

    } else {
        DbgBreakPoint();

    }

}

VOID
SimulateIret(
    IRET_BEHAVIOR fdsp
    )
/*++

Routine Description:

    This routine simulates an IRET. The passed parameter specifies
    how the flags are to be treated. In many situations, we pass the
    value of the flags along, thus throwing away the flags on the stack.

    In the case of PASS_FLAGS, we:
     - clear all but the interrupt and trace flags in the caller's
       original flags
     - combine in the flags returned by the interrupt service routine.
       This will cause us to return to the original routine with
       interrupts on if they were on when the interrupt occured, or
       if the ISR returned with them on.


Arguments:

    fdsp - takes the value RESTORE_FLAGS, PASS_FLAGS or PASS_CARRY_FLAG

        PASS_CARRY_FLAG_16 is a special value to indicate that this
        iret will always be on a 16-bit iret frame.


--*/
{
    DECLARE_LocalVdmContext;
    USHORT SegSs;
    ULONG VdmSp;
    ULONG VdmStackPointer;
    USHORT Flags;

    SegSs = getSS();

    if (getMODE() == VDM_V86) {
        VdmSp = getSP() + 6;
        VdmStackPointer = (ULONG) VdmMapFlat(SegSs, VdmSp, VDM_V86);

        setCS(*(PWORD16)(VdmStackPointer - 4));
        setIP(*(PWORD16)(VdmStackPointer - 6));
        Flags = *(PWORD16)(VdmStackPointer - 2);

    } else {
        if (Frame32 && (fdsp!=PASS_CARRY_FLAG_16)) {
            if (SEGMENT_IS_BIG(SegSs)) {
                VdmSp = getESP();
            } else {
                VdmSp = getSP();
            }
            VdmSp += 12;
            VdmStackPointer = (ULONG) VdmMapFlat(SegSs, VdmSp, VDM_PM);

            setCS(*(PWORD16)(VdmStackPointer - 8));
            setEIP(*(PDWORD16)(VdmStackPointer - 12));
            Flags = *(PWORD16)(VdmStackPointer - 4);

        } else {

            VdmSp = getSP() + 6;
            VdmStackPointer = (ULONG) VdmMapFlat(SegSs, VdmSp, VDM_PM);

            setCS(*(PWORD16)(VdmStackPointer - 4));
            setIP(*(PWORD16)(VdmStackPointer - 6));
            Flags = *(PWORD16)(VdmStackPointer - 2);

        }
    }

    switch(fdsp) {

    case RESTORE_FLAGS:
        break;

    case PASS_FLAGS:
        Flags = (Flags & 0x300) | getSTATUS();
        break;

    case PASS_CARRY_FLAG:
    case PASS_CARRY_FLAG_16:
        Flags = (Flags & ~1) | (getSTATUS() & 1);
        break;
    }

    setSTATUS(Flags);
    setESP(VdmSp);
}

#if 0   // Disable the code for now

USHORT
AllocatePMStack(
    USHORT MemSize
    )
/*++

Routine Description:

    This routine allocates PM stack.

Arguments:

    MemSize - Must be less than 64k

Return Value:

    if successful, selector of the PM stack
    otherwise 0

--*/
{
    PMEM_DPMI pMem;

    pMem = DpmiAllocateXmem(MemSize);

    if (pMem) {

        pMem->SelCount = 1;
        pMem->Sel = ALLOCATE_SELECTORS(1);

        if (!pMem->Sel) {
            pMem->SelCount = 0;
            DpmiFreeXmem(pMem);
            pMem = NULL;
        } else {

            SetDescriptorArray(pMem->Sel, (ULONG)pMem->Address, MemSize);

        }
    }
    if (pMem) {
        return pMem->Sel;
    } else {
        return (USHORT)0;
    }
}

VOID
FreePMStack(
    USHORT Sel
    )
/*++

Routine Description:

    This routine releases PM stack

Arguments:

    Sel - Selector of the PM stack to be freed.

Return Value:

    None.

--*/
{
    PMEM_DPMI pMem;

    if (pMem = DpmiFindXmem(Sel)) {

        while(pMem->SelCount--) {
            FreeSelector(Sel);
            Sel+=8;
        }

        DpmiFreeXmem(pMem);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\modesw.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    modesw.c

Abstract:

    This module provides support for performing mode switching on the 32 bit
    side.

Author:

    Dave Hastings (daveh) 24-Nov-1992

Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 - Updates for the 486 emulator

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"


RMCB_INFO DpmiRmcb[MAX_RMCBS];

USHORT RMCallBackBopSeg;
USHORT RMCallBackBopOffset;

#define SAVE_ALT_REGS(Regs) {   \
    Regs.Eip = getEIP();        \
    Regs.Esp = getESP();        \
    Regs.Cs = getCS();          \
    Regs.Ds = getDS();          \
    Regs.Es = getES();          \
    Regs.Fs = getFS();          \
    Regs.Gs = getGS();          \
    Regs.Ss = getSS();          \
    }

#define SET_ALT_REGS(Regs) {    \
    setEIP(Regs.Eip);           \
    setESP(Regs.Esp);           \
    setCS(Regs.Cs);             \
    setDS(Regs.Ds);             \
    setES(Regs.Es);             \
    setFS(Regs.Fs);             \
    setGS(Regs.Gs);             \
    setSS(Regs.Ss);             \
    }

typedef struct _ALT_REGS {
    ULONG Eip;
    ULONG Esp;
    USHORT Cs;
    USHORT Ss;
    USHORT Es;
    USHORT Ds;
    USHORT Fs;
    USHORT Gs;
} ALT_REGS, *PALT_REGS;


ALT_REGS AltRegs = {0};

VOID
DpmiSetAltRegs(
    VOID
    )
{
    DECLARE_LocalVdmContext;

    SAVE_ALT_REGS(AltRegs);
}

VOID
SetV86Exec(
    VOID
    )
/*++

Routine Description:

    This routine performs a mode switch to real (v86) mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    setMSW(getMSW() & ~MSW_PE);

#ifndef _X86_
    //BUGBUG This is a workaround to reload a 64k limit into SS for the
    // emulator, now that we are in real mode.
    // Not doing this would cause the emulator to do a hardware reset
    setSS_BASE_LIMIT_AR(getSS_BASE(), 0xffff, getSS_AR());

#else

    //
    // If we have v86 mode fast IF emulation set the RealInstruction bit
    //

    if (VdmFeatureBits & V86_VIRTUAL_INT_EXTENSIONS) {
        _asm {
            mov eax,FIXED_NTVDMSTATE_LINEAR             ; get pointer to VDM State
            lock or dword ptr [eax], dword ptr RI_BIT_MASK
        }
    } else {
        _asm {
            mov eax,FIXED_NTVDMSTATE_LINEAR         ; get pointer to VDM State
            lock and dword ptr [eax], dword ptr ~RI_BIT_MASK
        }
    }
    //
    // turn on real mode bit
    //
    _asm {
        mov     eax,FIXED_NTVDMSTATE_LINEAR             ; get pointer to VDM State
        lock or dword ptr [eax], dword ptr RM_BIT_MASK
    }

#endif

    setEFLAGS((getEFLAGS() & ~(EFLAGS_RF_MASK | EFLAGS_NT_MASK)));
    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_IN_V86, 0, 0);

}

VOID
SetPMExec(
    VOID
    )
/*++

Routine Description:

    This routine performs a mode switch to protected mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    setMSW(getMSW() | MSW_PE);

#ifndef _X86_
    //BUGBUG This is a workaround to make sure the emulator goes back
    // to privilege level 3 now that we are in protect mode.
    // Not doing this would cause an access violation in dpmi32.
    setCPL(3);

#else

    //
    // If we have fast if emulation in PM set the RealInstruction bit
    //
    if (VdmFeatureBits & PM_VIRTUAL_INT_EXTENSIONS) {
        _asm {
            mov eax,FIXED_NTVDMSTATE_LINEAR             ; get pointer to VDM State
            lock or dword ptr [eax], dword ptr RI_BIT_MASK
        }
    } else {
        _asm {
            mov eax, FIXED_NTVDMSTATE_LINEAR    ; get pointer to VDM State
            lock and dword ptr [eax], dword ptr ~RI_BIT_MASK
        }
    }

    //
    // Turn off real mode bit
    //
    _asm {
        mov     eax,FIXED_NTVDMSTATE_LINEAR             ; get pointer to VDM State
        lock and dword ptr [eax], dword ptr ~RM_BIT_MASK
    }

#endif

    setEFLAGS((getEFLAGS() & ~(EFLAGS_RF_MASK | EFLAGS_NT_MASK)));

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_IN_PM, 0, 0);
}

VOID
switch_to_protected_mode(
    VOID
    )

/*++

Routine Description:

    This routine is called via BOP from DOSX to transition to
    protected mode.

Arguments:

    None

Return Value:

    None.

--*/

{
    DECLARE_LocalVdmContext;
    PCHAR StackPointer;

    StackPointer = VdmMapFlat(getSS(), getSP(), getMODE());

    setCS(*(PUSHORT)(StackPointer + 12));
    setEIP(*(PULONG)(StackPointer + 8));
    setSS(*(PUSHORT)(StackPointer + 6));
    setESP(*(PULONG)(StackPointer + 2));
    setDS(*(PUSHORT)(StackPointer));

    //
    // don't zero the segment selectors.  If the caller has a bad segment
    // selector, the kernel will fix it for us.  This function may be
    // called directly from app (thru dosx) and the segment registers may
    // have be setup.  We certainly don't want to destroy them.
    // (To make transportation tycoon work.)
    //

//  setES((USHORT)0);
//  setGS((USHORT)0);
//  setFS((USHORT)0);

    SetPMExec();

}


VOID
switch_to_real_mode(
    VOID
    )

/*++

Routine Description:

    This routine services the switch to real mode bop.  It is included in
    DPMI.c so that all of the mode switching services are in the same place

Arguments:

    None

Return Value:

    None.

--*/

{
    DECLARE_LocalVdmContext;
    PCHAR StackPointer;


    StackPointer = VdmMapFlat(getSS(), getSP(), getMODE());

    LastLockedPMStackESP = getESP();
    LastLockedPMStackSS = getSS();

    setDS(*(PUSHORT)(StackPointer));
    setESP((ULONG) *(PUSHORT)(StackPointer + 2));
    setSS(*(PUSHORT)(StackPointer + 4));
    setEIP((ULONG) *(PUSHORT)(StackPointer + 6));
    setCS(*(PUSHORT)(StackPointer + 8));
    SetV86Exec();


}

VOID
DpmiSwitchToRealMode(
    VOID
    )
/*++

Routine Description:

    This routine is called internally from DPMI32 (i.e. Int21map)
    to switch to real mode.

Arguments:

    None.

Return Value:

    None.

--*/
{

    DECLARE_LocalVdmContext;
    PWORD16 Data;

    // HACK ALERT
    Data = (PWORD16) VdmMapFlat(DosxRmCodeSegment, 4, VDM_V86);
    *(Data) = DosxStackSegment;

    LastLockedPMStackESP = getESP();
    LastLockedPMStackSS = getSS();

    setCS(DosxRmCodeSegment);
    SetV86Exec();

}

VOID
DpmiSwitchToProtectedMode(
    VOID
    )
/*++

Routine Description:

    This routine is called internally from DPMI32 (i.e. Int21map)
    to switch to real mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PWORD16 Data;

    // HACK ALERT
    Data = (PWORD16) VdmMapFlat(DosxRmCodeSegment, 4, VDM_V86);
    *(Data) = 0xb7;

    setESP(LastLockedPMStackESP);
    setSS(LastLockedPMStackSS);

    SetPMExec();
}

VOID
DpmiAllocateRMCallBack(
    VOID
    )
/*++

Routine Description:

    Service 03/03 -- Allocate Real Mode Call-Back Address

    In:     ax    =  selector to use to point to rm stack
            ds:si -> pMode CS:IP to be called when rMode
                     call-back address executed
            es:di -> client register structure to be updated
                     when call-back address executed
            NOTE: client's DS and ES register values are on stack

    Out:    cx:dx -> SEGMENT:offset of real mode call-back hook
            CY clear if successful, CY set if can't allocate
            call back

--*/
{
    DECLARE_LocalVdmContext;
    int i;

    for (i=0; i<MAX_RMCBS; i++) {
        if (!DpmiRmcb[i].bInUse) {
            break;
        }
    }

    if (i == MAX_RMCBS) {
        // no more rmcbs
        setCF(1);
        return;
    }

    DpmiRmcb[i].StackSel = ALLOCATE_SELECTOR();
    if (!DpmiRmcb[i].StackSel) {
        // no more selectors
        setCF(1);
        return;
    }
    SetDescriptor(DpmiRmcb[i].StackSel, 0, 0xffff, STD_DATA);

    DpmiRmcb[i].bInUse = TRUE;
    DpmiRmcb[i].StrucSeg = getES();           // get client ES register
    DpmiRmcb[i].StrucOffset = (*GetDIRegister)();
    DpmiRmcb[i].ProcSeg = getDS();
    DpmiRmcb[i].ProcOffset = (*GetSIRegister)();

    setCX(RMCallBackBopSeg - i);
    setDX(RMCallBackBopOffset + (i*16));
    setCF(0);

}

VOID
DpmiFreeRMCallBack(
    VOID
    )
/*++

Routine Description:

    Service 03/04 -- Free Real Mode Call-Back Address

    In:     cx:dx -> SEGMENT:offset of rMode call-back to free

    Out:    CY clear if successful, CY set if failure
            ax = utility selector which should be freed

--*/
{
    DECLARE_LocalVdmContext;
    USHORT i = RMCallBackBopSeg - getCX();

    if ((i >= MAX_RMCBS) || !DpmiRmcb[i].bInUse) {
        // already free or invalid callback address
        setCF(1);
        return;
    }

    DpmiRmcb[i].bInUse = FALSE;
    FreeSelector(DpmiRmcb[i].StackSel);
    setCF(0);

}

VOID
GetRMClientRegs(
    PDPMI_RMCALLSTRUCT pcs
    )
{
    DECLARE_LocalVdmContext;

    pcs->Edi = getEDI();
    pcs->Esi = getESI();
    pcs->Ebp = getEBP();
    pcs->Ebx = getEBX();
    pcs->Edx = getEDX();
    pcs->Ecx = getECX();
    pcs->Eax = getEAX();
    pcs->Flags = (WORD) getEFLAGS();
    pcs->Es = getES();
    pcs->Ds = getDS();
    pcs->Fs = getFS();
    pcs->Gs = getGS();
}

VOID
SetRMClientRegs(
    PDPMI_RMCALLSTRUCT pcs
    )
{
    DECLARE_LocalVdmContext;

    setEDI(pcs->Edi);
    setESI(pcs->Esi);
    setEBP(pcs->Ebp);
    setEBX(pcs->Ebx);
    setEDX(pcs->Edx);
    setECX(pcs->Ecx);
    setEAX(pcs->Eax);
    setEFLAGS((getEFLAGS()&0xffff0000) + (ULONG)pcs->Flags);
    setES(pcs->Es);
    setDS(pcs->Ds);
    setFS(pcs->Fs);
    setGS(pcs->Gs);

}

VOID
DpmiRMCallBackCall(
    VOID
    )
/*++

Routine Description:

    This routine gets control when the application executes the
    callback address allocated by DPMI func 0x303. Its job is
    to switch the processor into protect mode as defined by the
    DPMI spec.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PDPMI_RMCALLSTRUCT pcs;
    ULONG StackBase;
    ULONG CurBase;
    BOOL bStackBaseRestore = FALSE;
    USHORT StackSel;
    PUCHAR VdmStackPointer;
    ULONG NewSP;
    USHORT i = RMCallBackBopSeg - getCS();

    if ((i >= MAX_RMCBS) || !DpmiRmcb[i].bInUse) {
        // already free or invalid callback address
        return;
    }

    //
    // Point ip back to BOP (per dpmi)
    //
    setIP(getIP()-4);

    pcs = (PDPMI_RMCALLSTRUCT) VdmMapFlat(DpmiRmcb[i].StrucSeg,
                                          DpmiRmcb[i].StrucOffset,
                                          VDM_PM);

    GetRMClientRegs(pcs);
    pcs->Ip = getIP();
    pcs->Cs = getCS();
    pcs->Sp = getSP();
    pcs->Ss = getSS();

    // Win31 saves DS-GS on the stack here.

    StackBase = (ULONG)(pcs->Ss<<4);
    StackSel = DpmiRmcb[i].StackSel;

    CurBase = GET_SELECTOR_BASE(StackSel);

    if (StackBase != CurBase) {
        bStackBaseRestore = TRUE;
        SetDescriptorBase(StackSel, StackBase);
    }

    setESI(getSP());
    setEDI(DpmiRmcb[i].StrucOffset);

    DpmiSwitchToProtectedMode();
    BeginUseLockedPMStack();

    setDS(DpmiRmcb[i].StackSel);
    setES(DpmiRmcb[i].StrucSeg);
    BuildStackFrame(3, &VdmStackPointer, &NewSP);

    if (Frame32) {
        *(PDWORD16)(VdmStackPointer-4)  = 0x202;
        *(PDWORD16)(VdmStackPointer-8)  = PmBopFe >> 16;
        *(PDWORD16)(VdmStackPointer-12) = PmBopFe & 0x0000FFFF;
        setESP(NewSP);
    } else {
        *(PWORD16)(VdmStackPointer-2) =  0x202;
        *(PWORD16)(VdmStackPointer-4) =  (USHORT) (PmBopFe >> 16);
        *(PWORD16)(VdmStackPointer-6) =  (USHORT) PmBopFe;
        setSP((WORD)NewSP);
    }

    setEIP(DpmiRmcb[i].ProcOffset);
    setCS(DpmiRmcb[i].ProcSeg);

#ifndef _X86_
    // preserve iopl
    setEFLAGS(getEFLAGS() | 0x3000);
#endif

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_REFLECT_TO_PM, 0, 0);
    host_simulate();            // execute PM callback

    //
    // restore stack descriptor if need be
    //
    if (bStackBaseRestore) {
        SetDescriptorBase(StackSel, CurBase);
    }

    pcs = (PDPMI_RMCALLSTRUCT) VdmMapFlat(getES(),
                                          (*GetDIRegister)(),
                                          VDM_PM);

    // win31 restores GS-DS here. Is this only for End_Nest_Exec?
    EndUseLockedPMStack();
    DpmiSwitchToRealMode();
    SetRMClientRegs(pcs);
    setSP(pcs->Sp);
    setSS(pcs->Ss);
    setCS(pcs->Cs);
    setIP(pcs->Ip);
}



VOID
DpmiReflectIntrToPM(
    VOID
    )
/*++

Routine Description:

    This routine gets control when a real mode interrupt is executed that is hooked
    in protected mode. The responsibility of this routine is to switch into PM, reflect
    the interrupt, and return to real mode.

    The actual interrupt number is encoded into CS by subtracting the interrupt number
    from the normal dosx real mode code segment. IP is then adjusted accordingly to
    point to the same place.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR VdmCodePointer;
    ULONG IntNumber;
    PUCHAR VdmStackPointer;
    ULONG NewSP;
    ULONG ISRFlags;
    ULONG SaveEFlags = getEFLAGS();
    USHORT SaveBP;
    ALT_REGS RMSave;

    IntNumber = (ULONG) (HIWORD(DosxRMReflector) - getCS());

    SAVE_ALT_REGS(RMSave);

    DpmiSwitchToProtectedMode();
    setES((USHORT)0);
    setDS((USHORT)0);
    setFS((USHORT)0);
    setGS((USHORT)0);
    BeginUseLockedPMStack();

    if (DpmiSwIntHandler(IntNumber) && BuildStackFrame(3, &VdmStackPointer, &NewSP)) {
        //
        // Put unsimulate bop on the stack so we get control after the handler's iret
        //

        if (Frame32) {
            *(PDWORD16)(VdmStackPointer-4)  = getEFLAGS();
            *(PDWORD16)(VdmStackPointer-8)  = PmBopFe >> 16;
            *(PDWORD16)(VdmStackPointer-12) = PmBopFe & 0x0000FFFF;
            setESP(NewSP);
        } else {
            *(PWORD16)(VdmStackPointer-2) =  LOWORD(getEFLAGS());
            *(PWORD16)(VdmStackPointer-4) =  (USHORT) (PmBopFe >> 16);
            *(PWORD16)(VdmStackPointer-6) =  (USHORT) PmBopFe;
            setSP((WORD)NewSP);
        }

        // Do special case processing for int24
        if (IntNumber == 0x24) {
            SaveBP = getBP();
            setBP(SegmentToSelector(SaveBP, STD_DATA));
        }

        DBGTRACE(VDMTR_TYPE_DPMI | DPMI_REFLECT_TO_PM, 0, 0);
        host_simulate();            // execute interrupt

        if (IntNumber == 0x24) {
            setBP(SaveBP);
        }

        //
        // simulate an iret for the frame generated by the SwIntHandler
        //

        if (Frame32) {
            setEIP(*(PDWORD16)(VdmStackPointer));
            setCS((USHORT)*(PDWORD16)(VdmStackPointer+4));
            setEFLAGS(*(PDWORD16)(VdmStackPointer+8));
            setESP(getESP()+12);
        } else {
            setIP(*(PWORD16)(VdmStackPointer));
            setCS(*(PWORD16)(VdmStackPointer+2));
            setEFLAGS((getEFLAGS()&0xffff0000) + *(PWORD16)(VdmStackPointer+4));
            setSP(getSP()+6);
        }
        ISRFlags = getEFLAGS();
    }

    EndUseLockedPMStack();
    DpmiSwitchToRealMode();

    //
    // do the final iret back to the app
    //

    setESP(RMSave.Esp);
    setSS(RMSave.Ss);
    setDS(RMSave.Ds);
    setES(RMSave.Es);
    setFS(RMSave.Fs);
    setGS(RMSave.Gs);

    SimulateIret(PASS_FLAGS);
}


VOID
DpmiReflectIntrToV86(
    VOID
    )
/*++

Routine Description:

    This routine gets control when the end of the interrupt chain is reached
    in protected mode. The responsibility of this routine is to switch into V86 mode,
    reflect the interrupt, and return to protected mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR VdmCodePointer;
    ULONG IntNumber;
    PUCHAR VdmStackPointer;
    USHORT SaveSS, SaveSP;
    USHORT SaveCS, SaveIP;
    ALT_REGS PMSave;
    ULONG IntHandler;

    VdmCodePointer = VdmMapFlat(getCS(), getIP(), VDM_PM);
    IntNumber = (ULONG) *VdmCodePointer;

    if (DispatchPMInt((UCHAR)IntNumber)) {
        return;
    }

    SAVE_ALT_REGS(PMSave);
    DpmiSwitchToRealMode();

    //
    // find a safe stack to run on in v86 mode
    //
    SaveSS = getSS();
    SaveSP = getSP();
    SWITCH_TO_DOSX_RMSTACK();

    //
    // Put unsimulate bop on the stack so we get control after the handler's iret
    //
    VdmStackPointer = VdmMapFlat(getSS(), getSP(), VDM_V86);

    SaveCS = getCS();
    SaveIP = getIP();

    *(PWORD16)(VdmStackPointer-2) =  LOWORD(getEFLAGS());
    *(PWORD16)(VdmStackPointer-4) =  (USHORT) (RmBopFe >> 16);
    *(PWORD16)(VdmStackPointer-6) =  (USHORT) RmBopFe;
    setSP(getSP() - 6);

    IntHandler = *(PDWORD16) (IntelBase + IntNumber*4);
    setIP(LOWORD(IntHandler));
    setCS(HIWORD(IntHandler));

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_REFLECT_TO_V86, 0, 0);
    host_simulate();            // execute interrupt

    setIP(SaveIP);
    setCS(SaveCS);
    setSP(SaveSP);
    setSS(SaveSS);
    SWITCH_FROM_DOSX_RMSTACK();

    DpmiSwitchToProtectedMode();

    //
    // do the final iret back to the app
    //
    setESP(PMSave.Esp);
    setSS(PMSave.Ss);
    setDS(PMSave.Ds);
    setES(PMSave.Es);
    setFS(PMSave.Fs);
    setGS(PMSave.Gs);

    SimulateIret(PASS_FLAGS);
}

VOID
DpmiRMCall(
    UCHAR mode
    )
/*++

Routine Description:

    This routine gets control when an Int31 func 300-302 is executed.
    The responsibility of this routine is to switch into V86 mode,
    reflect the interrupt, and return to protected mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    CLIENT_REGS SaveRegs;
    PDPMI_RMCALLSTRUCT pcs;
    BOOL bUsingOurStack;
    PUCHAR RmStackPointer, PmStackPointer;
    USHORT CopyLen;
    ULONG PmSp = (*GetSPRegister)();

    pcs = (PDPMI_RMCALLSTRUCT) VdmMapFlat(getES(),
                                          (*GetDIRegister)(),
                                          VDM_PM);

    SAVE_CLIENT_REGS(SaveRegs);
    DpmiSwitchToRealMode();

    //
    // This bop will get us back from host_simulate
    //
    setCS((USHORT)(RmBopFe >> 16));
    setIP((USHORT)RmBopFe);

    SetRMClientRegs(pcs);

    if (!pcs->Ss && !pcs->Sp) {
        SWITCH_TO_DOSX_RMSTACK();
        bUsingOurStack = TRUE;
    } else {
        setSS(pcs->Ss);
        setSP(pcs->Sp);
        bUsingOurStack = FALSE;
    }


    if (CopyLen = LOWORD(SaveRegs.Ecx)) {
        CopyLen *= 2;
        setSP(getSP() - CopyLen);
        PmStackPointer = VdmMapFlat(SaveRegs.Ss, PmSp, VDM_PM);
        RmStackPointer = VdmMapFlat(getSS(), getSP(), VDM_V86);
        RtlCopyMemory(RmStackPointer, PmStackPointer, CopyLen);
    }

    //
    // switch on MODE
    //
    switch(mode) {

    case 0:
        // Simulate Int
        EmulateV86Int((UCHAR)SaveRegs.Ebx);
        break;
    case 1:
        // Call with FAR return frame
        SimulateFarCall(pcs->Cs, pcs->Ip);
        break;
    case 2:
        // Call with IRET frame
        SimulateCallWithIretFrame(pcs->Cs, pcs->Ip);
        break;

    }
    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_REFLECT_TO_V86, 0, 0);
    host_simulate();            // execute interrupt

    if (bUsingOurStack) {
        SWITCH_FROM_DOSX_RMSTACK();
    }

    GetRMClientRegs(pcs);
    DpmiSwitchToProtectedMode();
    SET_CLIENT_REGS(SaveRegs);
    setCF(0);                   // function successful
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\vxd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vxd.c

Abstract:

    This module contains misc dpmi functions for risc.

Revision History:

    Neil Sandlin (neilsa) Nov. 1, 95 - split off from "misc" source

--*/

#include "precomp.h"
#pragma hdrstop
#include "softpc.h"

#define W386_VCD_ID 0xe

VOID
GetVxDApiHandler(
    USHORT VxdId
    )
{
    DECLARE_LocalVdmContext;

    if (VxdId == W386_VCD_ID) {

        setES(HIWORD(DosxVcdPmSvcCall));
        setDI(LOWORD(DosxVcdPmSvcCall));

    } else {

        setES(0);
        setDI(0);

    }

}


LONG
    VcdPmGetPortArray(
        VOID
    )
/*++

Routine Description:

    Use the registry enteries in HKEY_LOCAL_MACHINE\\HARDWARE\\DEVICEMAP\\SERIALCOMM
    to simulate the Virtual Comm Device API: VCD_PM_Get_Port_Array. See VCD.ASM
    in the Win 3.1 DDK.


Arguments:

    None

Return Value:

    Port Array in LOWORD. Bit array of valid ports:

    Bit Set   -> Port valid
    Bit clear -> Port invalid

    Bit 0 -> COM1, Bit 1 -> COM2, Bit 2 -> COM3...

--*/
{
    HKEY        hSerialCommKey;
    DWORD       dwPortArray;
    DWORD       dwPortNum;
    DWORD       cbPortName;
    DWORD       cbPortValue;
    CHAR        szPortName[64];
    CHAR        szPortValue[64];
    LONG        iPort;
    LONG        iStatus;

    dwPortArray = 0;
    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      "HARDWARE\\DEVICEMAP\\SERIALCOMM",
                      0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                      &hSerialCommKey) == ERROR_SUCCESS){

        cbPortName  = sizeof(szPortName);
        cbPortValue = sizeof(szPortValue);
        for (iPort = 0;
             (iStatus = RegEnumValue(hSerialCommKey,
                                     iPort, szPortName, &cbPortName,
                                     NULL, NULL, szPortValue,
                                     &cbPortValue)) != ERROR_NO_MORE_ITEMS;
             iPort++)
        {
            if ((iStatus == ERROR_SUCCESS) && (cbPortValue > 3)) {

                if (NT_SUCCESS(RtlCharToInteger(szPortValue+3,10,&dwPortNum))) {
                    dwPortArray |= (1 << (dwPortNum - 1));
                }

            }
            cbPortName  = sizeof(szPortName);
            cbPortValue = sizeof(szPortValue);
        }
    // WOW only supports 9 ports. See WU32OPENCOM in WUCOMM.C.
    dwPortArray &= 0x1FF;
    RegCloseKey(hSerialCommKey);
    }
    return(dwPortArray);
}

// The following values taken from Win 3.1 DDK VCD.ASM:

#define VCD_PM_Get_Version          0
#define VCD_PM_Get_Port_Array       1
#define VCD_PM_Get_Port_Behavior    2
#define VCD_PM_Set_Port_Behavior    3
#define VCD_PM_Acquire_Port         4
#define VCD_PM_Free_Port            5
#define VCD_PM_Steal_Port           6

VOID
    DpmiVcdPmSvcCall32(
        VOID
    )
/*++

Routine Description:

    Dispatch VCD API requests to the correct API.

Arguments:

    Client DX contains API function id.

Return Value:

    Depends on API.
--*/
{
    DECLARE_LocalVdmContext;

    switch (getDX()) {
        case VCD_PM_Get_Version:
            setAX(0x30A);
            break;

        case VCD_PM_Get_Port_Array:
            setAX((WORD)VcdPmGetPortArray());
            break;

        default :
            ASSERT(0);
            setCF(1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\register.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Register.c

Abstract:

    This module contains code to allow us to get and set registers that could
    be 16 bits or 32 bits, depending on whether a 16 bit dpmi app is running.

Author:

    Dave Hastings (daveh) 12-Dec-1992

Revision History:

--*/

//
// Note:  We undef the following constant so that we will get the function
//        versions of the register functions.  We can not put a macro into
//        a function pointer
//

#include <precomp.h>
#pragma hdrstop
#undef LINKED_INTO_MONITOR
#include <softpc.h>


//
// Internal functions
//
ULONG
IgetCX(
    VOID
    );

ULONG
IgetDX(
    VOID
    );

ULONG
IgetDI(
    VOID
    );

ULONG
IgetSI(
    VOID
    );

ULONG
IgetBX(
    VOID
    );

ULONG
IgetAX(
    VOID
    );

ULONG
IgetSP(
    VOID
    );

//
// Register manipulation functions (for register that might be 16 or 32 bits)
//
GETREGISTERFUNCTION GetCXRegister = IgetCX;
GETREGISTERFUNCTION GetDXRegister = IgetDX;
GETREGISTERFUNCTION GetDIRegister = IgetDI;
GETREGISTERFUNCTION GetSIRegister = IgetSI;
GETREGISTERFUNCTION GetBXRegister = IgetBX;
GETREGISTERFUNCTION GetAXRegister = IgetAX;
GETREGISTERFUNCTION GetSPRegister = IgetSP;

SETREGISTERFUNCTION SetCXRegister = (SETREGISTERFUNCTION) setCX;
SETREGISTERFUNCTION SetDXRegister = (SETREGISTERFUNCTION) setDX;
SETREGISTERFUNCTION SetDIRegister = (SETREGISTERFUNCTION) setDI;
SETREGISTERFUNCTION SetSIRegister = (SETREGISTERFUNCTION) setSI;
SETREGISTERFUNCTION SetBXRegister = (SETREGISTERFUNCTION) setBX;
SETREGISTERFUNCTION SetAXRegister = (SETREGISTERFUNCTION) setAX;
SETREGISTERFUNCTION SetSPRegister = (SETREGISTERFUNCTION) setSP;

VOID
DpmiInitRegisterSize(
    VOID
    )
/*++

Routine Description:

    This routine sets up the function pointers.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (CurrentAppFlags & DPMI_32BIT) {
        GetCXRegister = getECX;
        GetDXRegister = getEDX;
        GetDIRegister = getEDI;
        GetSIRegister = getESI;
        GetBXRegister = getEBX;
        GetAXRegister = getEAX;
        GetSPRegister = IgetSP;
        SetCXRegister = setECX;
        SetDXRegister = setEDX;
        SetDIRegister = setEDI;
        SetSIRegister = setESI;
        SetBXRegister = setEBX;
        SetAXRegister = setEAX;
        SetSPRegister = setESP;
    } else {
        //
        // Note: we have to call an internal function, because the actual
        //       function only returns 16 bits, the others are undefined
        //
        GetCXRegister = IgetCX;
        GetDXRegister = IgetDX;
        GetDIRegister = IgetDI;
        GetSIRegister = IgetSI;
        GetBXRegister = IgetBX;
        GetAXRegister = IgetAX;
        GetSPRegister = IgetSP;
        //
        // Note: we take advantage of the fact that the compiler always
        //       pushes 32 bits on the stack
        //
        SetCXRegister = (SETREGISTERFUNCTION) setCX;
        SetDXRegister = (SETREGISTERFUNCTION) setDX;
        SetDIRegister = (SETREGISTERFUNCTION) setDI;
        SetSIRegister = (SETREGISTERFUNCTION) setSI;
        SetBXRegister = (SETREGISTERFUNCTION) setBX;
        SetAXRegister = (SETREGISTERFUNCTION) setAX;
        SetSPRegister = (SETREGISTERFUNCTION) setSP;
    }
}

ULONG
IgetCX(
    VOID
    )
{
    return (ULONG)getCX();
}

ULONG
IgetDX(
    VOID
    )
{
    return (ULONG)getDX();
}

ULONG
IgetDI(
    VOID
    )
{
    return (ULONG)getDI();
}

ULONG
IgetSI(
    VOID
    )
{
    return (ULONG)getSI();
}

ULONG
IgetBX(
    VOID
    )
{
    return (ULONG)getBX();
}

ULONG
IgetAX(
    VOID
    )
{
    return (ULONG)getAX();
}

ULONG
IgetSP(
    VOID
    )
{
    //
    // Note: this routine returns the #of bits based on the size (b bit)
    // of ss.  If we don't, bad things happen

    if (Ldt[(getSS() & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Default_Big) {
        return getESP();
    } else {
        return (ULONG)getSP();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\savestat.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Savestate.c

Abstract:

    This module contains routines to save and restore the 16 bit state

Author:

    Dave Hastings (daveh) 27-Nov-1992

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include <malloc.h>

//
// Internal structures
//
typedef struct _SavedState {
    struct _SavedState *Next;
    USHORT SegSs;
    ULONG Esp;
    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;
} SAVEDCONTEXT, *PSAVEDCONTEXT;

PSAVEDCONTEXT StateStack = NULL;

VOID
DpmiSaveSegmentsAndStack(
    PVOID ContextPointer
    )
/*++

Routine Description:

    This routine saves the segment registers, and the sp value.

Arguments:

    None.

Return Value:

    None.

Notes:

    It would be better if the calling routine did not have to have
    any knowlege of what is being saved, but apparently malloc is now
    and always will be much too slow to be useful, so we do this.

--*/
{
    DECLARE_LocalVdmContext;
    PSAVEDCONTEXT SavedState;

    ASSERT((sizeof(SAVEDCONTEXT) < sizeof(VSAVEDSTATE)));
    SavedState = ContextPointer;

    SavedState->Next = StateStack;
    StateStack = SavedState;

    SavedState->SegSs = getSS();
    SavedState->Esp = getESP();
    SavedState->SegDs = getDS();
    SavedState->SegEs = getES();
    SavedState->SegFs = getFS();
    SavedState->SegGs = getGS();

}

PVOID
DpmiRestoreSegmentsAndStack(
    VOID
    )
/*++

Routine Description:

    This routine restores the segment registers, and the sp value.

Arguments:

    None.

Return Value:

    Pointer to state poped off stack.

--*/
{
    DECLARE_LocalVdmContext;
    PSAVEDCONTEXT SavedState;


    SavedState = StateStack;

    ASSERT((SavedState));
    ASSERT((sizeof(SAVEDCONTEXT) < sizeof(VSAVEDSTATE)));

    StateStack = SavedState->Next;

    setSS(SavedState->SegSs);


#if 0
    if (getSS() != SavedState->SegSs) {
        char szFormat[] = "NTVDM Dpmi Error! Can't set SS to %.4X\n";
        char szMsg[sizeof(szFormat)+30];

        wsprintf(szMsg, szFormat, SavedState->SegSs);
        OutputDebugString(szMsg);
        DbgBreakPoint();
    }
#endif

    setESP(SavedState->Esp);
    setDS(SavedState->SegDs);
    setES(SavedState->SegEs);
    setFS(SavedState->SegFs);
    setGS(SavedState->SegGs);
    return SavedState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


MAJORCOMP=mvdm
MINORCOMP=dpmi32

TARGETNAME=dpmi32
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..\.;..\..\inc;..\..\..\inc

SOURCES=        \
        ..\dosmem.c    \
        ..\dpmi32.c \
        ..\dpmiint.c \
        ..\dpmimscr.c  \
        ..\dpmiselr.c \
        ..\buffer.c    \
        ..\data.c         \
        ..\int21map.c  \
        ..\int2f.c     \
        ..\int31.c     \
        ..\modesw.c    \
        ..\register.c     \
        ..\savestat.c     \
        ..\stack.c     \
        ..\vxd.c       \
        ..\xmem.c

i386_SOURCES=..\i386\dpmi386.c ..\i386\dpmimem.c

MIPS_SOURCES=..\dpmimemr.c
PPC_SOURCES=..\dpmimemr.c
ALPHA_SOURCES=..\dpmimemr.c

C_DEFINES=-DLINKED_INTO_MONITOR

UMTYPE=console

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\xlathlp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    xlathlp.h

Abstract:

    This module contains helper macros for the api translation

Author:

    Dave Hastings (daveh) 24-Nov-1992

Revision History:

--*/

#define DPMI_EXEC_INT(x)    SWITCH_TO_DOSX_RMSTACK();       \
                            DpmiPushRmInt(x);               \
                            host_simulate();                \
                            SWITCH_FROM_DOSX_RMSTACK();

//
// VOID
// DPMI_FLAT_TO_SEGMENTED(
//     PUCHAR buffer,
//     PUSHORT seg,
//     PUSHORT off
// )

#define DPMI_FLAT_TO_SEGMENTED(buffer, seg, off) {  \
    *seg = (USHORT)(((ULONG)buffer-IntelBase) >> 4);            \
    *off = (USHORT)(((ULONG)buffer-IntelBase) & 0xf);           \
}

//
// Cast sel to USHORT such that we will never go beyond FlatAddress array.
//

#define SELECTOR_TO_INTEL_LINEAR_ADDRESS(sel) \
    (FlatAddress[((USHORT)(sel) & ~7) / sizeof(LDT_ENTRY)] - IntelBase)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\daytona\precomp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the private include file for the 32 bit dpmi and protected mode
    support

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include <dpmi.h>
#include <vint.h>
#include <mvdm.h>
#include "..\dpmi32.h"
#include <dbgsvc.h>
#include <nt_vdd.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\xmem.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    xmem.c

Abstract:

    This module contains routines for allocating and freeing "extended" memory.
    The memory is allocated directly from NT.

Author:

    Dave Hastings (daveh) 12-Dec-1992

Notes:

    Moved from dpmi32\i386

Revision History:

    09-Feb-1994 (daveh)
        Modified to be the common front end for the memory allocation.  Calls
        processor specific code to do actual allocation

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include <malloc.h>

ULONG
DpmiCalculateAppXmem(
    VOID
    );

MEM_DPMI XmemHead = { NULL, 0, &XmemHead, &XmemHead, 0};

PMEM_DPMI
DpmiAllocateXmem(
    ULONG BlockSize
    )
/*++

Routine Description:

    This routine allocates a block of "extended" memory from NT.  The
    blocks allocated this way will be 64K aligned (for now).  The address
    of the block is returned to the segmented app in bx:cx

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG BlockAddress;
    NTSTATUS Status;
    PMEM_DPMI XmemBlock;
    ULONG size;

    //
    // First check if this app owns more than 16 MB
    //
    size = DpmiCalculateAppXmem();
    if (size + BlockSize > MAX_APP_XMEM) {
        return NULL;
    }

    //
    // Get a block of memory from NT (any base address)
    //
    BlockAddress = 0;
    Status = DpmiAllocateVirtualMemory(
        (PVOID)&BlockAddress,
        &BlockSize
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        OutputDebugString("DPMI: DpmiAllocateXmem failed to get memory block\n");
#endif
        return NULL;
    }
    XmemBlock = malloc(sizeof(MEM_DPMI));
    if (!XmemBlock) {
        DpmiFreeVirtualMemory(
            (PVOID)&BlockAddress,
            &BlockSize
            );
        return NULL;
    }
    XmemBlock->Address = (PVOID)BlockAddress;
    XmemBlock->Length = BlockSize;
    XmemBlock->Owner = CurrentPSPSelector;
    XmemBlock->Sel = 0;
    XmemBlock->SelCount = 0;
    INSERT_BLOCK(XmemBlock, XmemHead);

    return XmemBlock;

}

BOOL
DpmiFreeXmem(
    PMEM_DPMI XmemBlock
    )
/*++

Routine Description:

    This routine frees a block of "extended" memory from NT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PVOID BlockAddress;
    ULONG BlockSize;


    BlockAddress = XmemBlock->Address;
    BlockSize = XmemBlock->Length;

    Status = DpmiFreeVirtualMemory(
        &BlockAddress,
        &BlockSize
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        OutputDebugString("DPMI: DpmiFreeXmem failed to free block\n");
#endif
        return FALSE;
    }

    DELETE_BLOCK(XmemBlock);

    free(XmemBlock);
    return TRUE;
}

BOOL
DpmiIsXmemHandle(
    PMEM_DPMI XmemBlock
    )
/*++

Routine Description:

    This routine verifies that the given handle is a valid xmem handle.

Arguments:

    Handle to be verified.

Return Value:

    TRUE if handle is valid, FALSE otherwise.

--*/
{
    PMEM_DPMI p1;

    p1 = XmemHead.Next;

    while(p1 != &XmemHead) {
        if (p1 == XmemBlock) {
            return TRUE;
        }
        p1 = p1->Next;
    }
    return FALSE;
}

PMEM_DPMI
DpmiFindXmem(
    USHORT Sel
    )
/*++

Routine Description:

    This routine finds a block of "extended" memory based on its Selector
    field.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PMEM_DPMI p1;

    p1 = XmemHead.Next;

    while(p1 != &XmemHead) {
        if (p1->Sel == Sel) {
            return p1;
        }
        p1 = p1->Next;
    }
    return NULL;
}

BOOL
DpmiReallocateXmem(
    PMEM_DPMI OldBlock,
    ULONG NewSize
    )
/*++

Routine Description:

    This routine resizes a block of "extended memory".  If the change in size
    is less than 4K, no change is made.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG BlockAddress;
    NTSTATUS Status;

    if (DpmiCalculateAppXmem() + NewSize - OldBlock->Length > MAX_APP_XMEM) {
            return FALSE;
    }

    BlockAddress = 0;
    Status = DpmiReallocateVirtualMemory(
        OldBlock->Address,
        OldBlock->Length,
        (PVOID)&BlockAddress,
        &NewSize
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        OutputDebugString("DPMI: DpmiAllocateXmem failed to get memory block\n");
#endif
        return FALSE;
    }

    RESIZE_BLOCK(OldBlock, BlockAddress, NewSize);

    return TRUE;
}

VOID
DpmiFreeAppXmem(
    USHORT Owner
    )
/*++

Routine Description:

    This routine frees Xmem allocated for the application

Arguments:

    Client DX = client PSP selector

Return Value:

    TRUE  if everything goes fine.
    FALSE if unable to release the memory
--*/
{
    PMEM_DPMI p1, p2;
    NTSTATUS Status;
    PVOID BlockAddress;
    ULONG BlockSize;

    p1 = XmemHead.Next;

    while(p1 != &XmemHead) {
        if (p1->Owner == Owner) {
            BlockAddress = p1->Address;
            BlockSize = p1->Length;

            Status = DpmiFreeVirtualMemory(
                &BlockAddress,
                &BlockSize
                );

            if (!NT_SUCCESS(Status)) {
#if DBG
                OutputDebugString("DPMI: DpmiFreeXmem failed to free block\n");
#endif
                return;
            }
            p2 = p1->Next;
            DELETE_BLOCK(p1);
            free(p1);
            p1 = p2;
            continue;
        }
        p1 = p1->Next;
    }
    return;
}

ULONG
DpmiCalculateAppXmem(
    VOID
    )
/*++

Routine Description:

    This routine calculates the Xmem allocated to the CURRENT application

Arguments:

    None.

Return Value:

    The size of xmem allocated to the app.
    Note the size will never exceed 2 GB.  We put a cap at about 16MB when
    allocating memory for the app.

--*/
{
    PMEM_DPMI p;
    NTSTATUS Status;
    ULONG Size = 0;

    //
    // If not current APP, we don't keep track of the xmem size
    //
    if (CurrentPSPSelector == 0) {
        return 0;
    }

    //
    // If CurrentPSPXmem is not zero, it is under control.
    // No need to initialize it. Make sure it is not negative value.
    //
    if (CurrentPSPXmem != 0 && CurrentPSPXmem <= MAX_APP_XMEM) {
        return CurrentPSPXmem;
    }
    p = XmemHead.Next;

    while(p != &XmemHead) {
        if (p->Owner == CurrentPSPSelector) {
            Size += p->Length;
        }
        p = p->Next;
    }
    CurrentPSPXmem = Size;
    return Size;
}

VOID
DpmiFreeAllXmem(
    VOID
    )
/*++

Routine Description:

    This function frees all allocated xmem.

Arguments:

    none

Return Value:

    None.

--*/
{
    PMEM_DPMI p1, p2;
    NTSTATUS Status;
    PVOID BlockAddress;
    ULONG BlockSize;

    p1 = XmemHead.Next;
    while(p1 != &XmemHead) {
        BlockAddress = p1->Address;
        BlockSize = p1->Length;

        Status = DpmiFreeVirtualMemory(
            &BlockAddress,
            &BlockSize
            );

        if (!NT_SUCCESS(Status)) {
#if DBG
            OutputDebugString("DPMI: DpmiFreeXmem failed to free block\n");
#endif
            return;
        }
        p2 = p1->Next;
        DELETE_BLOCK(p1);
        free(p1);
        p1 = p2;
    }
    CurrentPSPXmem = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\i386\dpmi386.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dpmi386.c

Abstract:

    This file contains support for 386/486 only dpmi bops

Author:

    Dave Hastings (daveh) 27-Jun-1991

Revision History:

    Matt Felton (mattfe) Dec 6 1992 removed unwanted verification
    Dave Hastings (daveh) 24-Nov-1992  Moved to mvdm\dpmi32
    Matt Felton (mattfe) 8 Feb 1992 optimize getvdmpointer for regular protect mode path.

--*/

#include "precomp.h"
#pragma hdrstop
#include <softpc.h>
#include <memory.h>
#include <malloc.h>
#include <nt_vdd.h>


BOOL
DpmiSetX86Descriptor(
    USHORT  SelStart,
    USHORT  SelCount
    )
/*++

Routine Description:

    This function puts descriptors into the real LDT. It uses the client's
    LDT as a source for the descriptor data.

Arguments:

    SelStart - The first selector in the block of selectors to set
    SelCount - The number of selectors to set

Return Value:

    This function returns TRUE if successful, FALSE otherwise

--*/

{
    LDT_ENTRY UNALIGNED *Descriptors = &Ldt[SelStart>>3];
    PPROCESS_LDT_INFORMATION LdtInformation = NULL;
    NTSTATUS Status;
    ULONG ulLdtEntrySize;
    ULONG Selector0,Selector1;

    ulLdtEntrySize =  SelCount * sizeof(LDT_ENTRY);

    //
    // If there are only 2 descriptors, set them the fast way
    //
    Selector0 = (ULONG)SelStart;
    if ((SelCount <= 2) && (Selector0 != 0)) {
        VDMSET_LDT_ENTRIES_DATA ServiceData;

        if (SelCount == 2) {
            Selector1 = SelStart + sizeof(LDT_ENTRY);
        } else {
            Selector1 = 0;
        }
        ServiceData.Selector0 = Selector0;
        ServiceData.Entry0Low = *((PULONG)(&Descriptors[0]));
        ServiceData.Entry0Hi  = *((PULONG)(&Descriptors[0]) + 1);
        ServiceData.Selector1 = Selector1;
        ServiceData.Entry1Low = *((PULONG)(&Descriptors[1]));
        ServiceData.Entry1Hi  = *((PULONG)(&Descriptors[1]) + 1);
        Status = NtVdmControl(VdmSetLdtEntries, &ServiceData);
        if (NT_SUCCESS(Status)) {
          return TRUE;
        }
        return FALSE;
    }

    LdtInformation = malloc(sizeof(PROCESS_LDT_INFORMATION) + ulLdtEntrySize);

    if (!LdtInformation ) {
      return FALSE;
    } else {
        VDMSET_PROCESS_LDT_INFO_DATA ServiceData;

        LdtInformation->Start = SelStart;
        LdtInformation->Length = ulLdtEntrySize;
        CopyMemory(
            &(LdtInformation->LdtEntries),
            Descriptors,
            ulLdtEntrySize
            );

        ServiceData.LdtInformation = LdtInformation;
        ServiceData.LdtInformationLength =  sizeof(PROCESS_LDT_INFORMATION) + ulLdtEntrySize;
        Status = NtVdmControl(VdmSetProcessLdtInfo, &ServiceData);

        if (!NT_SUCCESS(Status)) {
            VDprint(
                VDP_LEVEL_ERROR,
                ("DPMI: Failed to set selectors %lx\n", Status)
                );
            free(LdtInformation);
            return FALSE;
        }

        free(LdtInformation);

        return TRUE;
    }

}


UCHAR *
Sim32pGetVDMPointer(
    ULONG Address,
    UCHAR ProtectedMode
    )
/*++

Routine Description:

    This routine converts a 16/16 address to a linear address.

    WARNIGN NOTE - This routine has been optimized so protect mode LDT lookup
    falls stright through.   This routine is call ALL the time by WOW, if you
    need to modify it please re optimize the path - mattfe feb 8 92

Arguments:

    Address -- specifies the address in seg:offset format
    Size -- specifies the size of the region to be accessed.
    ProtectedMode -- true if the address is a protected mode address

Return Value:

    The pointer.

--*/

{
    ULONG Selector;
    PUCHAR ReturnPointer;

    if (ProtectedMode) {
        Selector = (Address & 0xFFFF0000) >> 16;
        if (Selector != 40) {
            Selector &= ~7;
            ReturnPointer = (PUCHAR)FlatAddress[Selector >> 3];
            ReturnPointer += (Address & 0xFFFF);
            return ReturnPointer;
    // Selector 40
        } else {
            ReturnPointer = (PUCHAR)0x400 + (Address & 0xFFFF);
        }
    // Real Mode
    } else {
        ReturnPointer = (PUCHAR)(((Address & 0xFFFF0000) >> 12) + (Address & 0xFFFF));
    }
    return ReturnPointer;
}


PUCHAR
ExpSim32GetVDMPointer(
    ULONG Address,
    ULONG Size,
    UCHAR ProtectedMode
    )
/*++
    See Sim32pGetVDMPointer, above

    This call must be maintaned as is because it is exported for VDD's
    in product 1.0.

--*/

{
    return Sim32pGetVDMPointer(Address,(UCHAR)ProtectedMode);
}


PVOID
VdmMapFlat(
    WORD selector,
    ULONG offset,
    VDM_MODE mode
    )
/*++

Routine Description:

    This routine converts a 16/16 address to a linear address.

    WARNIGN NOTE - This routine has been optimized so protect mode LDT lookup
    falls stright through.   This routine is call ALL the time by WOW, if you
    need to modify it please re optimize the path - mattfe feb 8 92

Arguments:

    Address -- specifies the address in seg:offset format
    Size -- specifies the size of the region to be accessed.
    ProtectedMode -- true if the address is a protected mode address

Return Value:

    The pointer.

--*/

{
    PUCHAR ReturnPointer;

    if (mode == VDM_PM) {
        if (selector != 40) {
            selector &= ~7;
            ReturnPointer = (PUCHAR)FlatAddress[selector >> 3] + offset;
            return ReturnPointer;
    // Selector 40
        } else {
            ReturnPointer = (PUCHAR)0x400 + (offset & 0xFFFF);
        }
    // Real Mode
    } else {
        ReturnPointer = (PUCHAR)((((ULONG)selector) << 4) + (offset & 0xFFFF));
    }
    return ReturnPointer;
}


BOOL
DpmiSetDebugRegisters(
    PULONG RegisterPointer
    )
/*++

Routine Description:

    This routine is called by dpmi when an app has issued DPMI debug commands.
    The six doubleword pointed to by the input parameter are the desired values
    for the real x86 hardware debug registers. This routine lets
    ThreadSetDebugContext() do all the work.

Arguments:

    None

Return Value:

    None.

--*/
{
    BOOL bReturn = TRUE;

    if (!ThreadSetDebugContext(RegisterPointer))
        {
        ULONG ClearDebugRegisters[6] = {0, 0, 0, 0, 0, 0};

        //
        // an error occurred. Reset everything to zero
        //

        ThreadSetDebugContext (&ClearDebugRegisters[0]);
        bReturn = FALSE;
        }
    return bReturn;
}

BOOL
DpmiGetDebugRegisters(
    PULONG RegisterPointer
    )
/*++

Routine Description:

    This routine is called by DOSX when an app has issued DPMI debug commands.
    The six doubleword pointed to by the input parameter are the desired values
    for the real x86 hardware debug registers. This routine lets
    ThreadGetDebugContext() do all the work.

Arguments:

    None

Return Value:

    None.

--*/
{
    return (ThreadGetDebugContext(RegisterPointer));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\fe\precomp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the private include file for the 32 bit dpmi and protected mode
    support

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include <dpmi.h>
#include <vint.h>
#include <mvdm.h>
#include "..\dpmi32.h"
#include <dbgsvc.h>
#include <nt_vdd.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\fax\faxcomm.h ===
//************************************************************************
// Common header file for generic Win 3.1 fax printer driver support.
//
// History:
//    02-jan-95   nandurir   created.
//    01-feb-95   reedb      Clean-up, support printer install and bug fixes.
//    14-mar-95   reedb      Use GDI hooks to move most functionality to UI.
//    16-aug-95   reedb      Move to kernel mode. Move many declarations and
//                              definitions to WOWFAXDD.H and WOWFAXUI.H.
//
//************************************************************************

#include "wowfax.h"

// The following structure ID appears as wfax when dumping byte (db) a FAXDEV:
#define FAXDEV_ID         ((DWORD)'xafw')     

//
// This structure is shared between wowfax and wowfaxui - this keeps
// the interface reliable, consistent and easy to maintain
//

typedef  struct _FAXDEV {
    ULONG    id;               // String to verify what we have
    struct _FAXDEV *lpNext;
    struct _FAXDEV *lpClient;  // Pointer to client side FAXDEV
    HDEV     hdev;             // Engine's handle to this structure

    DWORD    idMap;            // Unique ID
    DWORD    cbMapLow;         // Loword of size of mapped area
    HANDLE   hMap;             // Handle to mapped file
    TCHAR    szMap[16];        // Name of mapped file

    LPWOWFAXINFO lpMap;
    DWORD    offbits;

    HBITMAP  hbm;              // Handle to bitmap for drawing
    DWORD    cPixPerByte;
    DWORD    bmFormat;
    DWORD    bmWidthBytes;
    HSURF    hbmSurf;          // Associated surface

    HWND     hwnd;
    DWORD    tid;
    DWORD    lpinfo16;

    HANDLE   hDriver;          // For access to spooler data
    GDIINFO  gdiinfo;
    DEVINFO  devinfo;
    PDEVMODE pdevmode;
}  FAXDEV, *LPFAXDEV;

// Macro to dword align for RISC
//#define DRVFAX_DWORDALIGN(dw)   ((dw) += ((dw) % 4) ? (4 - ((dw) % 4)) : 0)
#define DRVFAX_DWORDALIGN(dw)   ((dw) = (((dw) + 3) & ~3))

// DrvEscape escape/action codes:

#define DRV_ESC_GET_FAXDEV_PTR  0x8000
#define DRV_ESC_GET_DEVMODE_PTR 0x8001
#define DRV_ESC_GET_BITMAP_BITS 0x8002
#define DRV_ESC_GET_SURF_INFO   0x8003
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\fax\wowfax\wowfax.c ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. 32-bit printer driver
// functions. Runs in Explorer.exe context.
//
// History:
//    02-jan-95   nandurir   created.
//    01-feb-95   reedb      Clean-up, support printer install and bug fixes.
//    14-mar-95   reedb      Use GDI hooks to move most functionality to UI.
//    16-aug-95   reedb      Move to kernel mode. Debug output and validate
//                              functions moved from FAXCOMM.C.
//    01-apr-02   cmjones    convert back to usermode.
//
//************************************************************************

#include "wowfaxdd.h"
#include "winbase.h"


//************************************************************************
// Globals
//************************************************************************

DRVFN  DrvFnTab[] = {
                      {INDEX_DrvEnablePDEV,      (PFN)DrvEnablePDEV  },
                      {INDEX_DrvDisablePDEV,     (PFN)DrvDisablePDEV  },
                      {INDEX_DrvCompletePDEV,    (PFN)DrvCompletePDEV  },
                      {INDEX_DrvEnableSurface,   (PFN)DrvEnableSurface  },
                      {INDEX_DrvDisableSurface,  (PFN)DrvDisableSurface  },
                      {INDEX_DrvStartDoc,        (PFN)DrvStartDoc  },
                      {INDEX_DrvStartPage,       (PFN)DrvStartPage  },
                      {INDEX_DrvSendPage,        (PFN)DrvSendPage  },
                      {INDEX_DrvEndDoc,          (PFN)DrvEndDoc  },
                      {INDEX_DrvDitherColor,     (PFN)DrvDitherColor },
                      {INDEX_DrvEscape,          (PFN)DrvEscape},
                   };

#define NO_DRVFN        (sizeof(DrvFnTab) / sizeof(DrvFnTab[0]))

#if DBG
//************************************************************************
// faxlogprintf -
//
//
//************************************************************************
VOID faxlogprintf(PCHAR pszFmt, ...)
{
    va_list ap;
    CHAR buffer[512];

    va_start(ap, pszFmt);

    wvsprintfA(buffer, pszFmt, ap);

    OutputDebugStringA(buffer);

    va_end(ap);
}

#endif

//************************************************************************
// ValidateFaxDev - Validates the FAXDEV structure by checking the DWORD
//      signature, which is a known fixed value.
//
//************************************************************************

BOOL ValidateFaxDev(LPFAXDEV lpFaxDev)
{
    if (lpFaxDev) {
        if (lpFaxDev->id == FAXDEV_ID) {
            return TRUE;
        }
        LOGDEBUG(("ValidateFaxDev failed, bad id, lpFaxDev: %X\n", lpFaxDev));
    }
    else {
        LOGDEBUG(("ValidateFaxDev failed, lpFaxDev: NULL\n"));
    }
    return FALSE;
}

//************************************************************************
// DllInitProc
//************************************************************************

BOOL DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext)
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(Reason);
    UNREFERENCED_PARAMETER(pContext);

    return TRUE;
}


//***************************************************************************
// DrvEnableDriver
//***************************************************************************

BOOL DrvEnableDriver(ULONG iEngineVersion, ULONG cb, DRVENABLEDATA  *pded)
{
    LOGDEBUG(("WOWFAX!DrvEnableDriver, iEngineVersion: %X, cb: %X, pded: %X\n", iEngineVersion, cb, pded));

    if(!pded) {
        return FALSE;
    }

    pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    if (cb < sizeof(DRVENABLEDATA)) {
        LOGDEBUG(("WOWFAX!DrvEnableDriver, failed\n"));
        return FALSE;
    }

    pded->c = NO_DRVFN;
    pded->pdrvfn = DrvFnTab;

    return  TRUE;

}

//***************************************************************************
// DrvDisableDriver
//***************************************************************************

VOID DrvDisableDriver(VOID)
{
    LOGDEBUG(("WOWFAX!DrvDisableDriver\n"));
    return;
}


//***************************************************************************
// DrvEnablePDEV
//***************************************************************************
DHPDEV DrvEnablePDEV(DEVMODEW *pdevmode,        // Driver data, Client FAXDEV
                     PWSTR     pwstrPrtName,    // Printer's name in CreateDC()
                     ULONG     cPatterns,       // Count of standard patterns
                     HSURF    *phsurfPatterns,  // Buffer for standard patterns
                     ULONG     cjGdiInfo,       // Size of buffer for GdiInfo
                     ULONG    *pulGdiInfo,      // Buffer for GDIINFO
                     ULONG     cjDevInfo,       // Number of bytes in devinfo
                     DEVINFO  *pdevinfo,        // Device info
                     HDEV      hdev,
                     PWSTR     pwstrDeviceName, // Device Name - "LaserJet II"
                     HANDLE    hDriver          // Printer handle for spooler access
)
{
    LPFAXDEV   lpCliFaxDev, lpSrvFaxDev = NULL;

    LOGDEBUG(("WOWFAX!DrvEnablePDEV, pdevmode: %X, pwstrPrtName: %S\n", pdevmode, pwstrPrtName));

    if (pdevmode) {
        // Point to the end of the DEVMODE where the FAXDEV is located.
        lpCliFaxDev = (LPFAXDEV) ((PBYTE)pdevmode + pdevmode->dmSize);

        // Allocate a server side FAXDEV to be passed back to GDI. Copy the
        // client side FAXDEV to the server side FAXDEV. Note all pointers in
        // the client FAXDEV reference client side memory and cannot be
        // dereferenced on the server side.
        lpSrvFaxDev = (LPFAXDEV)EngAllocMem(FL_ZERO_MEMORY, sizeof(FAXDEV), FAXDEV_ID);
        LOGDEBUG(("WOWFAX!DrvEnablePDEV, allocated lpSrvFaxDev: %X\n", lpSrvFaxDev));

        if (InitPDEV(lpCliFaxDev, lpSrvFaxDev,
                     cPatterns, phsurfPatterns,
                     cjGdiInfo, pulGdiInfo,
                     cjDevInfo, pdevinfo)) {

            lpSrvFaxDev->hDriver = hDriver;
            return (DHPDEV)lpSrvFaxDev;
        }
        else {
            LOGDEBUG(("WOWFAX!DrvEnablePDEV, failed\n"));
            if (lpSrvFaxDev) {
                EngFreeMem(lpSrvFaxDev);
                lpSrvFaxDev = NULL;
            }
        }
    }
    return (DHPDEV)lpSrvFaxDev;
}



//***************************************************************************
// InitPDEV - Called by DrvEnablePDEV to initialize the server side PDEV/FAXDEV.
//***************************************************************************
BOOL InitPDEV(
    LPFAXDEV  lpCliFaxDev,           // Pointer to the client side FAXDEV
    LPFAXDEV  lpSrvFaxDev,           // Pointer to the server side FAXDEV
    ULONG     cPatterns,            // Count of standard patterns
    HSURF    *phsurfPatterns,       // Buffer for standard patterns
    ULONG     cjGdiInfo,            // Size of buffer for GdiInfo
    ULONG    *pulGdiInfo,           // Buffer for GDIINFO
    ULONG     cjDevInfo,            // Number of bytes in devinfo
    DEVINFO  *pdevinfo              // Device info
)
{
    PGDIINFO pgdiinfo = (PGDIINFO)pulGdiInfo;
    ULONG    uColors[2];

    if (!ValidateFaxDev(lpCliFaxDev)) {
        return FALSE;
    }

    // lpSrvFaxDev hasn't been initialized yet, so just check pointer.
    if (lpSrvFaxDev == NULL) {
        LOGDEBUG(("WOWFAX!InitPDEV, failed, NULL lpSrvFaxDev parameter\n"));
        return FALSE;
    }

    // Copy client FAXDEV to server.
    RtlCopyMemory(lpSrvFaxDev, lpCliFaxDev, sizeof(FAXDEV));

    // Copy GDIINFO from client FAXDEV to the GDI buffer for GDIINFO.
    RtlCopyMemory(pgdiinfo, &(lpCliFaxDev->gdiinfo), sizeof(GDIINFO));

    // Initialize the DEVINFO structure.
    uColors[0] = RGB(0x00, 0x00, 0x00);
    uColors[1] = RGB(0xff, 0xff, 0xff);

    pdevinfo->hpalDefault = EngCreatePalette(PAL_INDEXED, 2, uColors, 0, 0, 0);
    pdevinfo->iDitherFormat = BMF_1BPP;

    // Make sure we don't journal.
    pdevinfo->flGraphicsCaps |= GCAPS_DONTJOURNAL;

    // Make sure we do dither.
    pdevinfo->flGraphicsCaps |= GCAPS_HALFTONE | GCAPS_MONO_DITHER |
                                    GCAPS_COLOR_DITHER;

    // Copy the DEVINFO data to the server side FAXDEV.
    RtlCopyMemory(&(lpSrvFaxDev->devinfo), pdevinfo, sizeof(DEVINFO));

    return TRUE;
}

//***************************************************************************
// DrvCompletePDEV
//***************************************************************************

VOID DrvCompletePDEV(DHPDEV dhpdev, HDEV hdev)
{
    LPFAXDEV lpSrvFaxDev = (LPFAXDEV) dhpdev;

    LOGDEBUG(("WOWFAX!DrvCompletePDEV, dhpdev %X\n", dhpdev));

    if (ValidateFaxDev(lpSrvFaxDev)) {
        // Store the gdi handle.
        lpSrvFaxDev->hdev = hdev;
    }
    else {
         LOGDEBUG(("WOWFAX!DrvCompletePDEV, failed\n"));
    }

    return;
}

//***************************************************************************
// DrvDisablePDEV
//***************************************************************************

VOID DrvDisablePDEV(DHPDEV  dhpdev)
{
    LPFAXDEV lpSrvFaxDev = (LPFAXDEV) dhpdev;

    LOGDEBUG(("WOWFAX!DrvDisablePDEV, dhpdev %X\n", dhpdev));

    if (ValidateFaxDev(lpSrvFaxDev)) {
        if (lpSrvFaxDev->devinfo.hpalDefault) {
            EngDeletePalette(lpSrvFaxDev->devinfo.hpalDefault);
        }
        EngFreeMem(lpSrvFaxDev);
        LOGDEBUG(("WOWFAX!DrvDisablePDEV, deallocated lpSrvFaxDev: %X\n", lpSrvFaxDev));
    }
    else {
        LOGDEBUG(("WOWFAX!DrvDisablePDEV, failed\n"));
    }
    return;
}


//***************************************************************************
// DrvEnableSurface
//***************************************************************************

HSURF DrvEnableSurface(DHPDEV  dhpdev)
{

    LPFAXDEV  lpFaxDev = (LPFAXDEV)dhpdev;
    HBITMAP   hbm = 0;

    LOGDEBUG(("WOWFAX!DrvEnableSurface, lpFaxDev: %X\n", lpFaxDev));

    if (ValidateFaxDev(lpFaxDev)) {
        // GDI will allocate space for the bitmap bits. We'll use a DrvEscape
        // to copy them to the client side.
        hbm = EngCreateBitmap(lpFaxDev->gdiinfo.szlPhysSize,
                              lpFaxDev->bmWidthBytes,
                              lpFaxDev->bmFormat, BMF_TOPDOWN, NULL);
        if (hbm) {
            lpFaxDev->hbm = hbm;
            EngAssociateSurface((HSURF)hbm, lpFaxDev->hdev, 0);
            return  (HSURF)hbm;
        }
        LOGDEBUG(("WOWFAX!DrvEnableSurface, EngCreateBitmap failed\n"));
    }

    return  (HSURF)hbm;
}

//***************************************************************************
// DrvDisableSurface
//***************************************************************************

VOID DrvDisableSurface(
    DHPDEV dhpdev
)
{
    LPFAXDEV  lpFaxDev = (LPFAXDEV)dhpdev;

    LOGDEBUG(("WOWFAX!DrvDisableSurface, lpFaxDev: %X\n", lpFaxDev));

    if (ValidateFaxDev(lpFaxDev)) {
        if (lpFaxDev->hbm) {
            EngDeleteSurface((HSURF)lpFaxDev->hbm);
            lpFaxDev->hbm = 0;
            return;
        }
    }
    return;
}

//***************************************************************************
// DrvStartDoc
//***************************************************************************

BOOL DrvStartDoc(
    SURFOBJ *pso,
    PWSTR pwszDocName,
    DWORD dwJobId
)
{
    LOGDEBUG(("WOWFAX!DrvStartDoc, pso: %X, pwszDocName: %S, dwJobId: %X\n", pso, pwszDocName, dwJobId));
    return  TRUE;
}

//***************************************************************************
// DrvStartPage
//***************************************************************************

BOOL DrvStartPage(
    SURFOBJ *pso
)
{
    LPFAXDEV  lpFaxDev;
    BITMAP bm;
    RECTL rc;

    LOGDEBUG(("WOWFAX!DrvStartPage, pso: %X\n", pso));

    // Calculate the size of the rectangle based on the input data
    // in 'pso' - this will  ensure that the entire bitmap is erased.

    if (pso) { 
        lpFaxDev  = (LPFAXDEV)pso->dhpdev;
        if(ValidateFaxDev(lpFaxDev)) {
            rc.left   = 0;
            rc.top    = 0;
            //rc.right  = pso->lDelta * lpFaxDev->cPixPerByte;
            //rc.bottom = pso->cjBits / pso->lDelta;
            // These should be calc'd the same way that they were for
            // the call to EngCreateBitmp() above.  Otherwise, if the rect
            // specified to EngEraseSurface() is larger than the bitmap rect,
            // EngEraseSurface() will fail -- resulting in a black background.
            rc.right  = lpFaxDev->gdiinfo.szlPhysSize.cx;
            rc.bottom = lpFaxDev->gdiinfo.szlPhysSize.cy;

            EngEraseSurface(pso, &rc, COLOR_INDEX_WHITE);
            return  TRUE;
        }
    }
    return  FALSE;
}       


//***************************************************************************
// DrvSendPage
//***************************************************************************

BOOL DrvSendPage(SURFOBJ *pso)
{
    LOGDEBUG(("WOWFAX!DrvSendPage, pso %X\n", pso));
    return  TRUE;
}


//***************************************************************************
// DrvEndDoc
//***************************************************************************

BOOL DrvEndDoc(SURFOBJ *pso, FLONG fl)
{
    LOGDEBUG(("WOWFAX!DrvEndDoc, pso %X\n", pso));
    return  TRUE;
}

ULONG
DrvDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )

{
    return DCR_HALFTONE;
}

//***************************************************************************
// DrvEscape - Allows client side to get server side data.
//***************************************************************************

ULONG DrvEscape(
    SURFOBJ *pso,
    ULONG   iEsc,
    ULONG   cjIn,
    PVOID   *pvIn,
    ULONG   cjOut,
    PVOID   *pvOut
)
{
    LPFAXDEV lpSrvFaxDev;
    ULONG    ulRet = 0;

    LOGDEBUG(("WOWFAX!DrvEscape, pso %X, iEsc: %X\n", pso, iEsc));
    if (pso) {
        lpSrvFaxDev = (LPFAXDEV)pso->dhpdev;
        if (ValidateFaxDev(lpSrvFaxDev)) {
            LOGDEBUG(("WOWFAX!DrvEscape, lpSrvFaxDev: %X\n", lpSrvFaxDev));
            switch (iEsc) {
                case DRV_ESC_GET_DEVMODE_PTR:
                    return (ULONG) lpSrvFaxDev->pdevmode;

                case DRV_ESC_GET_FAXDEV_PTR:
                    return (ULONG) lpSrvFaxDev->lpClient;

                case DRV_ESC_GET_SURF_INFO:
                    if (pvOut) {
                        if (cjOut == sizeof(LONG)) {
                            (LONG) *pvOut = pso->lDelta;
                            return (ULONG) pso->cjBits;
                        }
                    }
                    break;

                case DRV_ESC_GET_BITMAP_BITS:
                    // Validate the buffer pointer and copy the bits.
                    if (pvOut) {
                        if (cjOut == pso->cjBits) {
                            RtlCopyMemory(pvOut, pso->pvBits, cjOut);
                            return cjOut;
                        }
                        LOGDEBUG(("WOWFAX!DrvEscape, bitmap size mismatch cjIn: %X, pso->cjBits: %X\n", cjIn, pso->cjBits));
                    }
                    break;

//                default:
                    LOGDEBUG(("WOWFAX!DrvEscape, unknown escape: %X\n", iEsc));
            } //switch
        }
    }
    LOGDEBUG(("WOWFAX!DrvEscape, failed\n"));

    return ulRet;
}


//***************************************************************************
// DrvQueryDriverInfo
//      dwMode - Specify the information being queried
//      pBuffer - Points to output buffer
//      cbBuf - Size of output buffer in bytes
//      pcbNeeded - Return the expected size of output buffer
//
//***************************************************************************

 BOOL DrvQueryDriverInfo(
            DWORD   dwMode,
            PVOID   pBuffer,
            DWORD   cbBuf,
            PDWORD  pcbNeeded
            )
{
    UNREFERENCED_PARAMETER(pBuffer);
    UNREFERENCED_PARAMETER(cbBuf);
    UNREFERENCED_PARAMETER(pcbNeeded);

    switch(dwMode) {

        // this is the only one currently supported
        case DRVQUERY_USERMODE:
            return TRUE;

        default:
            LOGDEBUG(("DrvQueryDriverInfo: unexpected case: dwMode = %X\n",
                      dwMode));
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\fax\wowfax\wowfaxdd.h ===
//****************************************************************************
// Generic Win 3.1 fax printer driver support
//
// History:
//    02-jan-95   nandurir   created.
//    14-mar-95   reedb      Use GDI hooks to move most functionality to UI.
//    16-aug-95   reedb      Move to kernel mode. Many declarations and
//                              definitions moved from FAXCOMM.H.
//
//****************************************************************************

#include "string.h"
#include "stddef.h"
#include "windows.h"
#include "winddi.h"
#include "faxcomm.h"

BOOL InitPDEV(
    LPFAXDEV lpCliFaxDev,           // Pointer to the client side FAXDEV
    LPFAXDEV lpSrvFaxDev,           // Pointer to the server side FAXDEV
    ULONG     cPatterns,            // Count of standard patterns
    HSURF    *phsurfPatterns,       // Buffer for standard patterns
    ULONG     cjGdiInfo,            // Size of buffer for GdiInfo
    ULONG    *pulGdiInfo,           // Buffer for GDIINFO
    ULONG     cjDevInfo,            // Number of bytes in devinfo
    DEVINFO  *pdevinfo              // Device info
);

#define COLOR_INDEX_BLACK    0x0
#define COLOR_INDEX_WHITE    0x1

// user server defn.

#define FW_16BIT             0x1  // look for 16bit windows only
LPVOID UserServerDllInitialization(LPVOID);
typedef HWND (*PFNFW)(LPTSTR, LPTSTR, UINT);
typedef LRESULT (*PFNSM)(HWND, UINT, WPARAM, LPARAM);
typedef LRESULT (*PFNSNM)(HWND, UINT, WPARAM, LPARAM);

#if  DBG
#define LOGDEBUG(args) {faxlogprintf args;}
#else
#define LOGDEBUG(args)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dpmi32\i386\dpmimem.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    name-of-module-filename

Abstract:

    This module contains the code for actually allocating memory for dpmi.
    It uses the same suballocation pool as the xms code

Author:

    Dave Hastings (daveh) creation-date 09-Feb-1994

Notes:

    These functions claim to return NTSTATUS.  This is for commonality on
    x86 where we actually have an NTSTATUS to return.  For this file, we
    simply logically invert the bool and return that.  Callers of these
    functions promise not to attach significance to the return values other
    than STATUS_SUCCESS.

Revision History:


--*/
#include "precomp.h"
#pragma hdrstop
#include <softpc.h>
#include <suballoc.h>
#include <xmsexp.h>

PVOID                    gpLastAlloc           = NULL;
BOOL                     gbUseIncrementalAlloc = FALSE;
SYSTEM_BASIC_INFORMATION gSystemBasicInfo;

#define ALIGN_ALLOCATION_GRANULARITY(p) \
    (((p) + gSystemBasicInfo.AllocationGranularity - 1) & ~(gSystemBasicInfo.AllocationGranularity - 1))

VOID
DpmiSetIncrementalAlloc(
    BOOL bUseIncrementalAlloc
    )
{
    NTSTATUS Status;

    gbUseIncrementalAlloc = FALSE;
    gpLastAlloc = NULL;

    // if worse comes to worse -- and we can't query system info,
    // we use conventional allocation strategy

    if (bUseIncrementalAlloc) {
        Status = NtQuerySystemInformation(SystemBasicInformation,
                                          &gSystemBasicInfo,
                                          sizeof(gSystemBasicInfo),
                                          NULL);
        if (NT_SUCCESS(Status)) {
            gbUseIncrementalAlloc = TRUE;
        }
    }

}

PVOID
DpmiFindNextAddress(
    ULONG ulSize
)
{
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T ReturnLength;
    PVOID pMem = gpLastAlloc;
    ULONG ulSizeCheck;

    //
    // adjust size for granularity alignment
    //
    ulSizeCheck = ALIGN_ALLOCATION_GRANULARITY(ulSize);

    do {
        //
        // adjust the address to align on granularity
        //
        pMem = (PVOID)ALIGN_ALLOCATION_GRANULARITY((ULONG_PTR)pMem);


        Status = NtQueryVirtualMemory(NtCurrentProcess(),
                                      pMem,
                                      MemoryBasicInformation,
                                      &mbi,
                                      sizeof(mbi),
                                      &ReturnLength);
        if (!NT_SUCCESS(Status)) {

            return(NULL);
        }

        //
        // after the query -- step forward
        //

        if ((MEM_FREE & mbi.State) && (ulSizeCheck <= mbi.RegionSize)) {

            // try to reserve it then

            Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                             &pMem,
                                             0,
                                             &ulSize,
                                             MEM_RESERVE,
                                             PAGE_READWRITE);
            if (!NT_SUCCESS(Status)) {
                //
                // we can't reserve the memory - get out, use "normal" allocation

                break;
            }

            return(pMem);
        }

        pMem = (PVOID)((ULONG_PTR)mbi.BaseAddress + mbi.RegionSize);

    } while ((ULONG_PTR)pMem < (ULONG_PTR)gSystemBasicInfo.MaximumUserModeAddress);

    return(NULL);
}






NTSTATUS
DpmiAllocateVirtualMemory(
    PVOID *Address,
    PULONG Size
    )
/*++

Routine Description:

    This routine allocates a chunk of extended memory for dpmi.

Arguments:

    Address -- Supplies a pointer to the Address.  This is filled in
        if the allocation is successfull
    Size -- Supplies the size to allocate

Return Value:

    STATUS_SUCCESS if successfull.

--*/
{
    PVOID pMem = NULL;
    NTSTATUS Status;

    if (NULL != gpLastAlloc && gbUseIncrementalAlloc) {

        // try to find a piece of memory that is beyond this gpLastAlloc

        pMem = DpmiFindNextAddress(*Size);

    }

AllocRetry:

    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &pMem,
                                     0,
                                     Size,
                                     MEM_COMMIT,
                                     PAGE_READWRITE);
    if (NT_SUCCESS(Status)) {

        if (gbUseIncrementalAlloc) {
            gpLastAlloc = (PVOID)((ULONG_PTR)pMem + *Size);
        }

        *Address    = pMem;

        return(Status);
    }

    if (pMem != NULL) {

        pMem = NULL;
        goto AllocRetry;
    }


    return(Status);
}

NTSTATUS
DpmiFreeVirtualMemory(
    PVOID *Address,
    PULONG Size
    )
/*++

Routine Description:

    This function frees memory for dpmi.  It is returned to the suballocation
    pool.

Arguments:

    Address -- Supplies the address of the block to free
    Size -- Supplies the size of the block to free

Return Value:

    STATUS_SUCCESS if successful
--*/
{
    return NtFreeVirtualMemory(
        NtCurrentProcess(),
        Address,
        Size,
        MEM_RELEASE
        );

}

VOID
DpmiCopyMemory(
    ULONG NewAddress,
    ULONG OldAddress,
    ULONG Size
    )

/*++

Routine Description:

    This function copies a block of memory from one location to another. It
    assumes that the old block of memory is about to be freed. As it copies,
    it discards the contents of the pages of the original block to reduce
    paging.

Arguments:

    OldAddress -- Supplies the original address for the block
    Size       -- Supplies the size in bytes to be copied
    NewAddress -- Supplies the pointer to the place to return the new address

Return Value:
    none

--*/
{
    ULONG tmpsize;

#define SEGMENT_SIZE 0x4000

    // first page align the copy
    if (OldAddress & (SEGMENT_SIZE-1)) {
        tmpsize = SEGMENT_SIZE - (OldAddress & (SEGMENT_SIZE-1));
        if (tmpsize > Size) {
            tmpsize = Size;
        }

        CopyMemory((PVOID)NewAddress, (PVOID)OldAddress, tmpsize);

        NewAddress += tmpsize;
        OldAddress += tmpsize;
        Size -= tmpsize;
    }

    while(Size >= SEGMENT_SIZE) {
        CopyMemory((PVOID)NewAddress, (PVOID)OldAddress, SEGMENT_SIZE);

        VirtualAlloc((PVOID)OldAddress, SEGMENT_SIZE, MEM_RESERVE, PAGE_READWRITE);

        NewAddress += SEGMENT_SIZE;
        OldAddress += SEGMENT_SIZE;
        Size -= SEGMENT_SIZE;
    }

    if (Size) {
        CopyMemory((PVOID)NewAddress, (PVOID)OldAddress, Size);
    }
}



NTSTATUS
DpmiReallocateVirtualMemory(
    PVOID OldAddress,
    ULONG OldSize,
    PVOID *NewAddress,
    PULONG NewSize
    )
/*++

Routine Description:

    This function reallocates a block of memory for DPMI.

Arguments:

    OldAddress -- Supplies the original address for the block
    OldSize -- Supplies the original size for the address
    NewAddress -- Supplies the pointer to the place to return the new
        address
    NewSize -- Supplies the new size

Return Value:

    STATUS_SUCCESS if successfull
--*/
{
    ULONG SizeChange;
    ULONG BlockAddress;
    ULONG NewPages, OldPages;
    NTSTATUS Status;

    #define FOUR_K (1024 * 4)

    NewPages = (*NewSize + FOUR_K - 1) / FOUR_K;
    OldPages = (OldSize + FOUR_K - 1) / FOUR_K;

    if ((NewPages == OldPages) || (NewPages < OldPages)) {
        *NewAddress = OldAddress;
        return STATUS_SUCCESS;
    }

    BlockAddress = 0;
    Status = NtAllocateVirtualMemory(
        NtCurrentProcess(),
        (PVOID)&BlockAddress,
        0L,
        NewSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        OutputDebugString("DPMI: DpmiAllocateXmem failed to get memory block\n");
#endif
        return Status;
    }

    *NewAddress = (PVOID) BlockAddress;
    //
    // Copy data to new block (choose smaller of the two sizes)
    //
    if (*NewSize > OldSize) {
        SizeChange = OldSize;
    } else {
        SizeChange = *NewSize;
    }

    DpmiCopyMemory((ULONG)BlockAddress, (ULONG)OldAddress, SizeChange);

    //
    // Free up the old block
    //
    BlockAddress = (ULONG) OldAddress;
    SizeChange = OldSize;
    NtFreeVirtualMemory(
        NtCurrentProcess(),
        (PVOID)&(OldAddress),
        &SizeChange,
        MEM_RELEASE
        );

    return Status;
}

VOID
DpmiGetMemoryInfo(
    VOID
    )
/*++

Routine Description:

    This routine returns information about memory to the dos extender

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    MEMORYSTATUS MemStatus;
    PDPMIMEMINFO MemInfo;
    ULONG appXmem, dwLargestFree;

    //
    // Get a pointer to the return structure
    //
    MemInfo = (PDPMIMEMINFO)Sim32GetVDMPointer(
        ((ULONG)getES()) << 16,
        1,
        TRUE
        );

    (CHAR *)MemInfo += (*GetDIRegister)();

    //
    // Initialize the structure
    //
    RtlFillMemory(MemInfo, sizeof(DPMIMEMINFO), 0xFF);

    //
    // Get the information on memory
    //
    MemStatus.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus(&MemStatus);

    //
    // Return the information
    //

    //
    // Calculate the largest free block. This information is not returned
    // by NT, so we take a percentage based on the allowable commit charge for
    // the process. This is really what dwAvailPageFile is. But we limit
    // that value to a maximum of 15meg, since some apps (e.g. pdox45.dos)
    // can't handle more.
    //

    // Filled in MaxUnlocked,MaxLocked,UnlockedPages fields in this structute.
    // Director 4.0 get completlely confused if these fields are -1.
    // MaxUnlocked is correct based on LargestFree. The other two are fake
    // and match values on a real WFW machine. I have no way of making them
    // any better than this at this point. Who cares it makes director happy.
    //
    // sudeepb 01-Mar-1995.

    dwLargestFree = (((MemStatus.dwAvailPageFile*4)/5)/4096)*4096;
    dwLargestFree = (dwLargestFree < MAX_APP_XMEM) ? dwLargestFree : MAX_APP_XMEM;
    appXmem = DpmiCalculateAppXmem();
    if (dwLargestFree > appXmem) {
        dwLargestFree -= appXmem;
    } else {
        dwLargestFree = 0;
    }
    MemInfo->LargestFree = dwLargestFree;
    MemInfo->MaxUnlocked = MemInfo->LargestFree/4096;
    MemInfo->MaxLocked = 0xb61;
    MemInfo->AddressSpaceSize = MemStatus.dwTotalVirtual / 4096;
    MemInfo->UnlockedPages = 0xb68;
    MemInfo->FreePages = MemStatus.dwAvailPhys / 4096;
    MemInfo->PhysicalPages = MemStatus.dwTotalPhys / 4096;
    MemInfo->FreeAddressSpace = MemStatus.dwAvailVirtual / 4096;
    MemInfo->PageFileSize = MemStatus.dwTotalPageFile / 4096;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\fax\wowfaxui\sources.inc ===
!IF 0

Copyright (c) 1989 - 1991  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=wowfaxui
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\user32.lib      \
           $(SDK_LIB_PATH)\gdi32.lib       \
           $(SDK_LIB_PATH)\kernel32.lib    \
           $(SDK_LIB_PATH)\winspool.lib    \
           $(SDK_LIB_PATH)\advapi32.lib

C_DEFINES=-DUNICODE

DLLENTRY=DllInitProc

MSC_WARNING_LEVEL=/W3 /WX

INCLUDES=\
    ..;\
    ..\..;\
    ..\..\wowfax;\
    ..\..\..\inc;\
    $(PRINTSCAN_INC_PATH);\
    $(WINDOWS_INC_PATH)

SOURCES=..\wfhelper.c  \
        ..\wfsheets.c  \
        ..\wfupgrad.c  \
        ..\wowfaxui.c  \
        ..\wowfaxui.rc

UMTYPE=windows

SOURCES_USED=..\sources.inc

CONDITIONAL_INCLUDES=subwtype.h

W32_SB=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\fax\wowfaxui\wfsheets.c ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. User Interface functions
// which are called by WINSPOOL. Support for Two new entry points required
// by the Win 95 printer UI, DrvDocumentPropertySheets and
// DrvDevicePropertySheets
//
// History:
//    24-Apr-96   reedb   created.
//
//************************************************************************

#include "windows.h"
#include "wowfaxui.h"
#include "wfsheets.h"
#include "winspool.h"

//************************************************************************
// Globals
//************************************************************************

extern HINSTANCE ghInst;

DEVMODEW gdmDefaultDevMode;

LONG DrvDocumentProperties(HWND hwnd, HANDLE hPrinter, PWSTR pDeviceName, PDEVMODE pdmOut, PDEVMODE pdmIn, DWORD fMode);
LONG SimpleDocumentProperties(PDOCUMENTPROPERTYHEADER pDPHdr);

//************************************************************************
// NullDlgProc - Procedure for handling "Printer Properties" property
//      sheet page
//************************************************************************

BOOL NullDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}

//************************************************************************
// FaxOptionsProc - Procedure for handling "Fax Options" property
//      sheet page
//************************************************************************

BOOL FaxOptionsProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    PDEVMODE pdmOut = NULL;
    PDEVMODE pdmIn  = NULL;
    PUIDATA pUiData;
    TCHAR  szFeedBack[WOWFAX_MAX_USER_MSG_LEN];

    switch (message) {
        case WM_INITDIALOG:
            if(lParam) {
                SetWindowLong(hDlg, DWL_USER,((PROPSHEETPAGE *)lParam)->lParam);
                return TRUE;
            }

        case WM_COMMAND:
            if (wParam == IDOK) {
                SetWindowText(GetDlgItem(hDlg, IDC_FEEDBACK), L"");

                pUiData = (PUIDATA) GetWindowLong(hDlg, DWL_USER);
                if(pUiData) {
                    DrvDocumentProperties(hDlg,
                                          pUiData->hPrinter,
                                          pUiData->pDeviceName,
                                          pUiData->pdmOut,
                                          pUiData->pdmIn,
                                          pUiData->fMode);

                    //
                    // Provide user with feedback text.
                    //
                    if (LoadString(ghInst, WOWFAX_ENABLE_CONFIG_STR,
                               szFeedBack, sizeof( szFeedBack)/sizeof(TCHAR))) {
                        SetWindowText(GetDlgItem(hDlg, IDC_FEEDBACK), szFeedBack);
                    }
                }
            }
            break;

        case WM_NOTIFY:

            if (lParam && (((NMHDR *)lParam)->code == PSN_APPLY)) {

                pUiData = (PUIDATA) GetWindowLong(hDlg, DWL_USER);

                //
                // HACK: Inform common UI library that user has pressed OK
                //
                if(pUiData) {

                    pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                             CPSFUNC_SET_RESULT,
                                             (LONG) pUiData->hFaxOptsPage,
                                             CPSUI_OK);
                    return TRUE;
                }
            }
            break;
    }

    return FALSE;
}

//************************************************************************
// AddDocPropPages -Add our "Document Properties" pages to the property
//      sheet. Returns RUE if successful, FALSE otherwise.
//************************************************************************

BOOL AddDocPropPages(PUIDATA pUiData)
{
    PROPSHEETPAGE   psp;
    LONG            result;

    if(pUiData == NULL) {
        return(FALSE);
    }
    //
    // "Document Properties" dialog only has one tab - "Fax Options"
    //

    memset(&psp, 0, sizeof(psp));
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = ghInst;
    psp.lParam = (LPARAM) pUiData;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DOCPROP);
    psp.pfnDlgProc = FaxOptionsProc;

    pUiData->hFaxOptsPage = (HANDLE)
        pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                 CPSFUNC_ADD_PROPSHEETPAGE,
                                 (LPARAM) &psp,
                                 0);

    return (pUiData->hFaxOptsPage != NULL);
}


//************************************************************************
// MyGetPrinter - Wrapper function for GetPrinter spooler API. Returns
//      Pointer to a PRINTER_INFO_x structure, NULL if there is an error
//************************************************************************

PVOID MyGetPrinter(HANDLE hPrinter, DWORD level)
{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cbNeeded;

    if (!GetPrinter(hPrinter, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = LocalAlloc(LPTR, cbNeeded)) &&
        GetPrinter(hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded))
    {
        return pPrinterInfo;
    }

    LOGDEBUG(0, (L"GetPrinter failed\n"));
    LocalFree(pPrinterInfo);
    return NULL;
}

//************************************************************************
// FreeUiData - Free the data structure used by the fax driver user
//      interface.
//************************************************************************

PUIDATA FreeUiData(PUIDATA pUiData)
{
    if (pUiData) {
        if (pUiData->pDeviceName) LocalFree(pUiData->pDeviceName);
        if (pUiData->pDriverName) LocalFree(pUiData->pDriverName);
    }
    return NULL;
}

//************************************************************************
// FillUiData - Fill in the data structure used by the fax driver user
//      interface. Returns pointer to UIDATA structure, NULL if error.
//************************************************************************

PUIDATA FillUiData(HANDLE hPrinter, PDEVMODE pdmInput, PDEVMODE pdmOutput, DWORD fMode)
{
    PRINTER_INFO_2 *pPrinterInfo2 = NULL;
    PUIDATA         pUiData;

    //
    // Allocate memory to hold UIDATA structure
    // Get printer info from the spooler. Copy the driver name.
    //

    if (! (pUiData = LocalAlloc(LPTR, sizeof(UIDATA))) ||
        ! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) ||
        ! (pUiData->pDeviceName = DupTokenW(pPrinterInfo2->pPrinterName)) ||
        ! (pUiData->pDriverName = DupTokenW(pPrinterInfo2->pDriverName))) {

        pUiData = FreeUiData(pUiData);
    }
    else {
        pUiData->pdmIn  = pdmInput;
        pUiData->pdmOut = pdmOutput;
        pUiData->fMode  = fMode;

        pUiData->startUiData = pUiData->endUiData = pUiData;
        pUiData->hPrinter    = hPrinter;
    }
    
    if (pPrinterInfo2)
        LocalFree(pPrinterInfo2);

    return pUiData;
}

//************************************************************************
// DrvDocumentPropertySheets - Display "Document Properties" property
//      sheets. Return > 0 if successful, <= 0 if failed.
//************************************************************************

LONG DrvDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    PDOCUMENTPROPERTYHEADER pDPHdr;
    PCOMPROPSHEETUI         pCompstui;
    PUIDATA                 pUiData;
    LONG                    result;

    //
    // Validate input parameters
    //
    if (! (pDPHdr = (PDOCUMENTPROPERTYHEADER) (pPSUIInfo ?  pPSUIInfo->lParamInit : lParam))) {
        return -1;
    }

    if (pPSUIInfo == NULL) {
        return SimpleDocumentProperties(pDPHdr);
    }

    //
    // Create a UIDATA structure if necessary
    //

    pUiData = (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT) ?
                    FillUiData(pDPHdr->hPrinter, pDPHdr->pdmIn, pDPHdr->pdmOut, pDPHdr->fMode) : (PUIDATA) pPSUIInfo->UserData;

    if (! ValidUiData(pUiData))
        return -1;

    //
    // Handle various cases for which this function might be called
    //

    switch (pPSUIInfo->Reason) {

    case PROPSHEETUI_REASON_INIT:

        pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
        pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;

        //
        // Add our page to the property sheet
        //

        if (AddDocPropPages(pUiData)) {

            pPSUIInfo->UserData = (DWORD) pUiData;
            pPSUIInfo->Result = CPSUI_CANCEL;
            return 1;
        }

        //
        // Clean up properly in case of an error
        //

        FreeUiData(pUiData);
        break;

    case PROPSHEETUI_REASON_GET_INFO_HEADER:

        {   PPROPSHEETUI_INFO_HEADER   pPSUIHdr;

            pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
            if(pPSUIHdr == NULL) {
                break;
            }
            pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pPSUIHdr->pTitle = pDPHdr->pszPrinterName;
            pPSUIHdr->hInst = ghInst;
            pPSUIHdr->IconID = IDI_CPSUI_PRINTER2;
        }
        return 1;

    case PROPSHEETUI_REASON_SET_RESULT:

        pPSUIInfo->Result = ((PSETRESULT_INFO) lParam)->Result;
        return 1;

    case PROPSHEETUI_REASON_DESTROY:

        //
        // Cleanup properly before exiting
        //

        FreeUiData(pUiData);
        return 1;
    }
    return -1;
}

//************************************************************************
// DrvDevicePropertySheets - Display "Printer Properties" dialog.
//      Return > 0 if successful, <= 0 if failed.
//************************************************************************

LONG DrvDevicePropertySheets(PPROPSHEETUI_INFO   pPSUIInfo, LPARAM lParam)
{
    PDEVICEPROPERTYHEADER   pDPHdr;
    PCOMPROPSHEETUI         pCompstui;
    PROPSHEETPAGE           psp;
    LONG                    result;

    //
    // Validate input parameters
    //
    LOGDEBUG(1,(L"DrvDevicePropertySheets: %d\n", pPSUIInfo->Reason));

    if (!pPSUIInfo || !(pDPHdr = (PDEVICEPROPERTYHEADER) pPSUIInfo->lParamInit)) {
        return -1;
    }

    //
    // Handle various cases for which this function might be called
    //

    switch (pPSUIInfo->Reason) {

    case PROPSHEETUI_REASON_INIT:
        //
        // "Printer Properties" dialog only has one dummy tab
        //
    
        memset(&psp, 0, sizeof(psp));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = 0;
        psp.hInstance = ghInst;
    
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NULLPROP);
        psp.pfnDlgProc = NullDlgProc;
    
        if (pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                                       CPSFUNC_ADD_PROPSHEETPAGE,
                                       (LPARAM) &psp,
                                       0))
        {
            pPSUIInfo->Result = CPSUI_CANCEL;
            return 1;
        }
        break;
    
    case PROPSHEETUI_REASON_GET_INFO_HEADER:
        {   PPROPSHEETUI_INFO_HEADER   pPSUIHdr;

            pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
            pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pPSUIHdr->pTitle = pDPHdr->pszPrinterName;
            pPSUIHdr->hInst = ghInst;
            pPSUIHdr->IconID = IDI_CPSUI_FAX;
        }
        return 1;

    case PROPSHEETUI_REASON_SET_RESULT:
        pPSUIInfo->Result = ((PSETRESULT_INFO) lParam)->Result;
        return 1;

    case PROPSHEETUI_REASON_DESTROY:
        return 1;
    }

    return -1;
}

LONG
SimpleDocumentProperties(PDOCUMENTPROPERTYHEADER pDPHdr)

/*++

Routine Description:

    Handle simple "Document Properties" where we don't need to display
    a dialog and therefore don't have to have common UI library involved

Arguments:

    pDPHdr - Points to a DOCUMENTPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 otherwise

--*/

{
    LONG lRet;

    if(pDPHdr == NULL) {
        return(-1);
    }

    lRet = DrvDocumentProperties(NULL,
                                 pDPHdr->hPrinter,
                                 pDPHdr->pszPrinterName,
                                 pDPHdr->pdmOut,
                                 pDPHdr->pdmIn,
                                 pDPHdr->fMode);

    if (pDPHdr->fMode == 0 || pDPHdr->pdmOut == NULL) {
        pDPHdr->cbOut = lRet;
    }

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\fax\wowfaxui\wfsheets.h ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. User Interface functions
// which are called by WINSPOOL. Support for Two new entry points required
// by the Win 95 printer UI, DrvDocumentPropertySheets and
// DrvDevicePropertySheets
//
// History:
//    24-Apr-96   reedb   created.
//
//************************************************************************

#include "winddiui.h"

// Data structure maintained by the fax driver user interface
typedef struct {

    PVOID           startUiData;
    HANDLE          hPrinter;
    PDEVMODE        pdmIn;
    PDEVMODE        pdmOut;
    DWORD           fMode;
    LPTSTR          pDriverName;
    LPTSTR          pDeviceName;
    PFNCOMPROPSHEET pfnComPropSheet;
    HANDLE          hComPropSheet;
    HANDLE          hFaxOptsPage;
    PVOID           endUiData;

} UIDATA, *PUIDATA;

#define ValidUiData(pUiData) \
        ((pUiData) && (pUiData) == (pUiData)->startUiData && (pUiData) == (pUiData)->endUiData)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\fax\wowfaxui\wfhelper.c ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. Helper functions which are
//      called in WOWFAXUI.C
//
// History:
//    14-mar-95   reedb      Created. Many of the functions were moved from
//                              FAXCOMM.C, since they're no longer called
//                              from WOWFAX.DLL.
//    16-aug-95   reedb      Move to kernel mode. Debug output and validate
//                              functions moved from FAXCOMM.C.
//
//************************************************************************

#include "wowfaxui.h"
#include "dde.h"

extern LPCRITICAL_SECTION lpCriticalSection;
extern HINSTANCE ghInst;
BOOL InSetupMode(void);

#if DBG

INT     iFaxLogLevel = 20;
INT     iReqFaxLogLevel = 0;

typedef PVOID HANDLE;


//************************************************************************
// faxlogprintf - Two different implementations. One for client side
//      debugging the other for server side.
//
//************************************************************************


// For Debug logging.
#define MAX_DISPLAY_LINE 256                // 128 characters.

TCHAR   szFaxLogFile[] = L"C:\\FAXLOG.LOG";
HANDLE  hfFaxLog = NULL;

// Defines for iFaxLogMode
#define NO_LOGGING     0
#define LOG_TO_FILE    1
#define OPEN_LOG_FILE  2
#define CLOSE_LOG_FILE 3

INT     iFaxLogMode  = NO_LOGGING;

VOID faxlogprintf(LPTSTR pszFmt, ...)
{
    DWORD   lpBytesWritten;
    int     len;
    TCHAR   szText[1024];
    va_list arglist;

    va_start(arglist, pszFmt);
    len = wvsprintf(szText, pszFmt, arglist);

    if (iFaxLogMode > LOG_TO_FILE) {
        if (iFaxLogMode == OPEN_LOG_FILE) {
            if((hfFaxLog = CreateFile(szFaxLogFile,
                               GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL)) != INVALID_HANDLE_VALUE) {
                iFaxLogMode = LOG_TO_FILE;
            }
            else {
                hfFaxLog = NULL;
                iFaxLogMode  = NO_LOGGING;
                OutputDebugString(L"Couldn't open fax log file!\n");
            }
        }
        else {
            FlushFileBuffers(hfFaxLog);
            CloseHandle(hfFaxLog);
            hfFaxLog = NULL;
            iFaxLogMode  = NO_LOGGING;
        }
    }

    if (iFaxLogLevel >= iReqFaxLogLevel) {
        if (iFaxLogMode) {
            WriteFile(hfFaxLog, szText, len, &lpBytesWritten, NULL);
        }
        else {
            OutputDebugString(szText);
        }
    }
}


VOID LogWowFaxInfo(LPWOWFAXINFO lpWowFaxInfo)
{
    faxlogprintf(L"\tlpWowFaxInfo (lpMap): %X\n", lpWowFaxInfo);
    faxlogprintf(L"\t\thwnd: %X\n", lpWowFaxInfo->hwnd);
    faxlogprintf(L"\t\ttid: %X\n", lpWowFaxInfo->tid);
    faxlogprintf(L"\t\tproc16: %X\n", lpWowFaxInfo->proc16);
    faxlogprintf(L"\t\tlpinfo16: %X\n", lpWowFaxInfo->lpinfo16);
    faxlogprintf(L"\t\tmsg: %X\n", lpWowFaxInfo->msg);
    faxlogprintf(L"\t\thdc: %X\n", lpWowFaxInfo->hdc);
    faxlogprintf(L"\t\twCmd: %X\n", lpWowFaxInfo->wCmd);
    faxlogprintf(L"\t\tcData: %X\n", lpWowFaxInfo->cData);
    faxlogprintf(L"\t\thwndui: %X\n", lpWowFaxInfo->hwndui);
    faxlogprintf(L"\t\tretvalue: %X\n", lpWowFaxInfo->retvalue);
    faxlogprintf(L"\t\tstatus: %X\n", lpWowFaxInfo->status);
    if (lpWowFaxInfo->lpDevice) {
        faxlogprintf(L"\t\tlpDevice: %s\n", lpWowFaxInfo->lpDevice);
    }
    else {
        faxlogprintf(L"\t\tlpDevice: %X\n", lpWowFaxInfo->lpDevice);
    }
    if (lpWowFaxInfo->lpDriverName) {
        faxlogprintf(L"\t\tlpDriverName: %s\n", lpWowFaxInfo->lpDriverName);
    }
    else {
        faxlogprintf(L"\t\tlpDriverName: %X\n", lpWowFaxInfo->lpDriverName);
    }
    if (lpWowFaxInfo->lpPortName) {
        faxlogprintf(L"\t\tlpPortName: %s\n", lpWowFaxInfo->lpPortName);
    }
    else {
        faxlogprintf(L"\t\tlpPortName: %X\n", lpWowFaxInfo->lpPortName);
    }
    faxlogprintf(L"\t\tlpIn: %X\n", lpWowFaxInfo->lpIn);
    faxlogprintf(L"\t\tlpOut: %X\n", lpWowFaxInfo->lpOut);
    if (lpWowFaxInfo->szDeviceName) {
        faxlogprintf(L"\t\tszDeviceName: %s\n", lpWowFaxInfo->szDeviceName);
    }
    else {
        faxlogprintf(L"\t\tszDeviceName: %X\n", lpWowFaxInfo->szDeviceName);
    }
    faxlogprintf(L"\t\tbmPixPerByte: %X\n", lpWowFaxInfo->bmPixPerByte);
    faxlogprintf(L"\t\tbmWidthBytes: %X\n", lpWowFaxInfo->bmWidthBytes);
    faxlogprintf(L"\t\tbmHeight: %X\n", lpWowFaxInfo->bmHeight);
    faxlogprintf(L"\t\tlpbits: %X\n", lpWowFaxInfo->lpbits);
}

VOID LogFaxDev(LPTSTR pszTitle, LPFAXDEV lpFaxDev)
{
    DWORD dwTmp;
    CHAR  cTmp0, cTmp1, cTmp2, cTmp3;

    faxlogprintf(L"WOWFAXUI!%s: %X\n", pszTitle, lpFaxDev);
    dwTmp = lpFaxDev->id;
    cTmp3 = (CHAR)  dwTmp & 0xFF;
    cTmp2 = (CHAR) (dwTmp >>  8) & 0xFF;
    cTmp1 = (CHAR) (dwTmp >> 16) & 0xFF;
    cTmp0 = (CHAR) (dwTmp >> 24) & 0xFF;
    faxlogprintf(L"\tid: %c%c%c%c\n", cTmp3, cTmp2, cTmp1, cTmp0);
    faxlogprintf(L"\tlpNext: %X\n", lpFaxDev->lpNext);
    faxlogprintf(L"\tlpClient: %X\n", lpFaxDev->lpClient);
    faxlogprintf(L"\thdev: %X\n", lpFaxDev->hdev);
    faxlogprintf(L"\tidMap: %X\n", lpFaxDev->idMap);
    faxlogprintf(L"\tcbMapLow: %X\n", lpFaxDev->cbMapLow);
    faxlogprintf(L"\thMap: %X\n", lpFaxDev->hMap);
    faxlogprintf(L"\tszMap: %s\n", lpFaxDev->szMap);
    if (lpFaxDev->lpMap) {
        LogWowFaxInfo(lpFaxDev->lpMap);
    }
    else {
        faxlogprintf(L"\tlpMap: %X\n", lpFaxDev->lpMap);
    }
    faxlogprintf(L"\toffbits: %X\n", lpFaxDev->offbits);
    faxlogprintf(L"\thbm: %X\n", lpFaxDev->hbm);
    faxlogprintf(L"\tcPixPerByte: %X\n", lpFaxDev->cPixPerByte);
    faxlogprintf(L"\tbmFormat: %X\n", lpFaxDev->bmFormat);
    faxlogprintf(L"\tbmWidthBytes: %X\n", lpFaxDev->bmWidthBytes);
    faxlogprintf(L"\thbmSurf: %X\n", lpFaxDev->hbmSurf);
    faxlogprintf(L"\thwnd: %X\n", lpFaxDev->hwnd);
    faxlogprintf(L"\ttid: %X\n", lpFaxDev->tid);
    faxlogprintf(L"\tlpinfo16: %X\n", lpFaxDev->lpinfo16);
    faxlogprintf(L"\thDriver: %X\n", lpFaxDev->hDriver);
    faxlogprintf(L"\tStart of gdiinfo: %X\n", (DWORD)&(lpFaxDev->gdiinfo));
    faxlogprintf(L"\tStart of devinfo: %X\n", (DWORD)&(lpFaxDev->devinfo));
    faxlogprintf(L"\tpdevmode: %X\n", lpFaxDev->pdevmode);
}
#endif

//************************************************************************
// ValidateFaxDev - Validates the FAXDEV structure by checking the DWORD
//      signature, which is a known fixed value.
//
//************************************************************************

BOOL ValidateFaxDev(LPFAXDEV lpFaxDev)
{
    if (lpFaxDev) {
        if (lpFaxDev->id == FAXDEV_ID) {
            return TRUE;
        }
        LOGDEBUG(0, (L"ValidateFaxDev failed, bad id, lpFaxDev: %X\n", lpFaxDev));
    }
    else {
        LOGDEBUG(0, (L"ValidateFaxDev failed, lpFaxDev: NULL\n"));
    }
    return FALSE;
}

//***************************************************************************
// WFLocalAlloc - Debug version of LocalAlloc.
//***************************************************************************

LPVOID WFLocalAlloc(DWORD dwBytes, LPWSTR lpszWhoCalled)
{
    LPVOID lpTmp;

    lpTmp = LocalAlloc(LPTR, dwBytes);

    if (lpTmp == NULL){
        LOGDEBUG(0, (L"WOWFAXUI!%s, failed on memory allocation of %d bytes\n", lpszWhoCalled, dwBytes));
    }
    return(lpTmp);
}

//***************************************************************************
// FindWowFaxWindow - Put up a message box if you can't.
//***************************************************************************
HWND FindWowFaxWindow(void)
{
    HWND hwnd;
    PROCESS_INFORMATION ProcessInformation;
    STARTUPINFO StartupInfo;
    DWORD WaitStatus;
    TCHAR szMsg[WOWFAX_MAX_USER_MSG_LEN];
    TCHAR szTitle[WOWFAX_MAX_USER_MSG_LEN];
    WCHAR szWowExec[] = L"WOWEXEC";

    if ((hwnd = FindWindow(WOWFAX_CLASS, NULL)) == NULL) {
        // You can't find the WowFaxWindow, try to start WOW.
        RtlZeroMemory((PVOID)&StartupInfo, (DWORD)sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
        StartupInfo.wShowWindow = SW_NORMAL;

        if (CreateProcess(NULL,
                            szWowExec,
                            NULL,               // security
                            NULL,               // security
                            FALSE,              // inherit handles
                            CREATE_NEW_CONSOLE | CREATE_DEFAULT_ERROR_MODE,
                            NULL,               // environment strings
                            NULL,               // current directory
                            &StartupInfo,
                            &ProcessInformation)) {

            WaitForInputIdle(ProcessInformation.hProcess, 120 * 1000);

            if ((hwnd = FindWindow(WOWFAX_CLASS, NULL)) != NULL) {
                return(hwnd);
            }
        }

        // If WOW failed to start -- let user know. 
        //  -- except during setup mode -- the spooler calls into every printer
        //     driver to update the registry printer settings if needed.
        if(!InSetupMode()) {
            if (LoadString(ghInst, WOWFAX_NAME_STR, szTitle, WOWFAX_MAX_USER_MSG_LEN)) {
                if (LoadString(ghInst, WOWFAX_NOWOW_STR, szMsg, WOWFAX_MAX_USER_MSG_LEN)) {
                    MessageBox(hwnd, szMsg, szTitle, MB_OK);
                }
            }
        }
    }
    return(hwnd);
}

//************************************************************************
// DupTokenW - Helper for Get16BitDriverInfoFromRegistry. Allocate and
//      copy a token, wide format. Allocates storage for duplicate.
//      wcsdup is not present in the run-times we link to.
//************************************************************************

LPTSTR DupTokenW(LPTSTR lpTok)
{
    LPTSTR lpRetVal = NULL;

    if (lpTok != NULL) {
        lpRetVal = WFLOCALALLOC((wcslen(lpTok) + 1) * sizeof(TCHAR), L"DupTokenW");
        if (lpRetVal) {
            wcscpy(lpRetVal, lpTok);
        }
    }
    return(lpRetVal);
}

//************************************************************************
// Get16BitDriverInfoFromRegistry - Get the 16-bit driver info (name, port)
//      from the registry where it is written by the 16-bit fax driver
//      install program using an intercepted WriteProfileString. Storage is
//      allocated for the returned info, and must be freed by the caller
//      using Free16BitDriverInfo. See also Set16BitDriverInfoToRegistry
//      in WOW32FAX.C
//************************************************************************

LPREGFAXDRVINFO16 Get16BitDriverInfoFromRegistry(PWSTR pDeviceName)
{
    TCHAR   szRetBuf[MAX_PATH];
    HKEY    hKey = 0;
    DWORD   dwType, cbBufSize = MAX_PATH;
    LPTSTR  lpTok, lpDevName;

    LPREGFAXDRVINFO16 lpRetVal = WFLOCALALLOC(sizeof(REGFAXDRVINFO16), L"Get16BitDriverInfoFromRegistry");

    if ((pDeviceName != NULL) && (lpRetVal != NULL)) {

        // Extract the 16-bit device name from pDeviceName.
        wcsncpy(szRetBuf, pDeviceName, sizeof(szRetBuf)/sizeof(TCHAR));
        szRetBuf[(sizeof(szRetBuf)/sizeof(TCHAR))-1] = '\0';
        lpDevName = szRetBuf;
        while (lpTok = wcschr(lpDevName, '\\')) {
            lpDevName = ++lpTok;
        }
        if (lpTok = wcschr(lpDevName, ',')) {
            *lpTok = '\0';
        }

        if (lpRetVal->lpDeviceName = DupTokenW(lpDevName)) {

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             L"Software\\Microsoft\\Windows NT\\CurrentVersion\\WOW\\WowFax\\devices",
                             0, KEY_READ, &hKey ) == ERROR_SUCCESS) {

                if (RegQueryValueEx(hKey, lpDevName, 0, &dwType, (LPBYTE)szRetBuf,
                                    &cbBufSize) == ERROR_SUCCESS) {

                    // Parse registry data into driver name and port name.
                    // Make wcstok multi-thread safe, it stores state.
                    EnterCriticalSection(lpCriticalSection);
                    lpTok = wcstok(szRetBuf, L",");
                    lpRetVal->lpDriverName = DupTokenW(lpTok);
                    lpTok = wcstok(NULL, L",");
                    lpRetVal->lpPortName = DupTokenW(lpTok);
                    LeaveCriticalSection(lpCriticalSection);
                }
                RegCloseKey(hKey);
            }
        }
    }

    if (lpRetVal && lpRetVal->lpDeviceName &&
        lpRetVal->lpDriverName && lpRetVal->lpPortName) {
        LOGDEBUG(1, (L"WOWFAXUI!Get16BitDriverInfoFromRegistry, Name: %s, Driver: %s, Port: %s\n", pDeviceName, lpRetVal->lpDriverName, lpRetVal->lpPortName));
        return(lpRetVal);
    }

    LOGDEBUG(0, (L"WOWFAXUI!Get16BitDriverInfoFromRegistry, failed\n"));
    Free16BitDriverInfo(lpRetVal);
    return(NULL);
}

//************************************************************************
// Free16BitDriverInfo - Free the 16-bit driver info allocated by
//      Get16BitDriverInfoFromRegistry.
//************************************************************************

VOID Free16BitDriverInfo(LPREGFAXDRVINFO16 lpRegFaxDrvInfo16)
{
     if (lpRegFaxDrvInfo16) {
         if (lpRegFaxDrvInfo16->lpDeviceName) {
             LocalFree(lpRegFaxDrvInfo16->lpDeviceName);
         }
         if (lpRegFaxDrvInfo16->lpDriverName) {
             LocalFree(lpRegFaxDrvInfo16->lpDriverName);
         }
         if (lpRegFaxDrvInfo16->lpPortName) {
             LocalFree(lpRegFaxDrvInfo16->lpPortName);
         }
         LocalFree(lpRegFaxDrvInfo16);
         return;
     }
}

//***************************************************************************
// InterProcCommHandler - Handles inter-process communication between
//      WOWFAXUI-WOW32 and WOWFAX-WOW32.
//***************************************************************************

BOOL InterProcCommHandler(LPFAXDEV lpdev, UINT iAction)
{
    LPWOWFAXINFO lpT = lpdev->lpMap;
    HANDLE  hMap = 0;
    WNDPROC wndproc;
    MSG     msg;

    switch (iAction)
    {
        case DRVFAX_SETMAPDATA:
            if (lpdev->lpMap) {
                // init map struct
                lpdev->lpMap->status = FALSE;
                lpdev->lpMap->retvalue = (DWORD)-1;
                lpdev->hwnd = FindWowFaxWindow();
                lpdev->lpMap->hwnd = lpdev->hwnd;
                lpdev->lpMap->msg = 0;
                lpdev->lpMap->hdc = (WPARAM)lpdev->idMap;
                (DWORD)lpdev->lpMap->lpinfo16 = lpdev->lpinfo16;
            }
            break;

        case DRVFAX_SENDTOWOW:
            if (lpdev->lpMap->hwnd) {
                SendMessage(lpdev->lpMap->hwnd, lpdev->lpMap->msg, (WPARAM)lpdev->idMap, 0);
            }
            else {
                LOGDEBUG(0, (L"WOWFAXUI!InterProcCommHandler, No hwnd to send to.\n"));
            }
            break;

        case DRVFAX_CALLWOW:
            if (lpdev->lpMap->hwnd) {
                wndproc = (WNDPROC) GetWindowLongA(lpdev->lpMap->hwnd, GWL_WNDPROC);
                CallWindowProc(wndproc, lpdev->lpMap->hwnd, lpdev->lpMap->msg, (WPARAM)lpdev->idMap, 0);
            }
            else {
                LOGDEBUG(0, (L"WOWFAXUI!InterProcCommHandler, No hwnd to call to.\n"));
            }
            break;

        case DRVFAX_SENDNOTIFYWOW:
            if (lpdev->lpMap->hwnd) {
                SendNotifyMessage(lpdev->lpMap->hwnd, lpdev->lpMap->msg, (WPARAM)lpdev->idMap, 0);

                // To simulate app-modal dialog, pass message's to this threads
                // windows to DefWndProc, until 16-bit fax driver UI is dismissed.
                while (!lpdev->lpMap->status) {
                    if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                        // EasyFax ver2.0 & MyTalk ver 2.0
                        // Also Procomm+ 3 cover sheets. Bug #305665
                        if ((msg.message == WM_PAINT) ||
                            (msg.message >= WM_USER)  ||
                            ((msg.message >= WM_DDE_FIRST) && 
                             (msg.message <= WM_DDE_LAST)     )) {
                            DispatchMessage(&msg);
                        }
                        else {
                            DefWindowProc(msg.hwnd, msg.message, msg.wParam, msg.lParam);
                        }
                    }
                }
            }
            break;

        case DRVFAX_CREATEMAP:
        case DRVFAX_DESTROYMAP:
            if (lpdev->lpMap) {

                // destroys the current map - for both iActions
                UnmapViewOfFile(lpdev->lpMap);
                CloseHandle(lpdev->hMap);
                lpdev->lpMap = 0;
                lpdev->hMap = 0;
                lpT = 0;
            }

            if (iAction == DRVFAX_CREATEMAP) {
                // GetFaxDataMapName is WOWFAX_INC_COMMON_CODE in wowfax.h.
                GetFaxDataMapName((DWORD)lpdev->idMap, lpdev->szMap);
                hMap = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE,
                                         0, lpdev->cbMapLow, lpdev->szMap);
                if (hMap) {
                    if (GetLastError() == ERROR_ALREADY_EXISTS) {
                        CloseHandle(hMap);
                    }
                    else {
                        lpT = (LPWOWFAXINFO)MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0);
                        if (lpT) {
                            lpdev->hMap   = hMap;
                            lpdev->lpMap  = lpT;
                        }
                        else {
                            LOGDEBUG(0, (L"WOWFAXUI!InterProcCommHandler, MapViewOfFile failed, LastError = %ld\n", GetLastError()));
                            CloseHandle(hMap);
                        }
                    }
                }
                else {
                    LOGDEBUG(0, (L"WOWFAXUI!InterProcCommHandler, CreateFileMapping failed, LastError = %ld\n", GetLastError()));
                }
            }
            break;

    } //switch

    return((BOOL)lpT);
}


//************************************************************************
// InSetupMode: Checks if this process is running during NT setup.
//
// return:
//  TRUE if in NT setup
//  FALSE otherwise
//************************************************************************
BOOL InSetupMode(void)
{
    DWORD   SetupMode = FALSE;
    LONG    results;
    DWORD   Type, Size = sizeof(DWORD);
    HKEY    Key;

    results = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"System\\Setup", &Key );

    if (results != ERROR_SUCCESS) return FALSE;

    results = RegQueryValueExW(Key, L"SystemSetupInProgress",
                               NULL, &Type, (PBYTE)&SetupMode, &Size);

    RegCloseKey(Key);

    return (!(SetupMode == 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\fax\wowfaxui\wfupgrad.c ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. User Interface helper
// functions which are called in WOWFAXUI.C, helpers used during upgrade.
//
// History:
//    14-mar-95   reedb      Created. These were moved from WOWFAXUI.C.
//
//************************************************************************

#include "windows.h"
#include "wowfaxui.h"
#include "winspool.h"

extern LPCRITICAL_SECTION lpCriticalSection;
extern HINSTANCE ghInst;

//************************************************************************
// AllocPathW - Helper for DrvUpgradePrinter and friends.
//************************************************************************

PWSTR AllocPathW(VOID)
{
    PWSTR   szTmp;

    szTmp = WFLOCALALLOC((MAX_PATH+1) * sizeof(TCHAR), L"AllocPathW");
    return(szTmp);
}

//************************************************************************
// BuildPathW - Helper for DrvUpgradePrinter and friends.
//************************************************************************

PWSTR BuildPathW(PWSTR szPath, PWSTR szFileName)
{
    int     len;
    PWSTR   szTmp;

    //                                                          +slash+NULL
    len = wcslen(szPath);
    len += wcslen(szFileName);
    len += (1 + 1); // slash + NULL
    if ((szTmp = WFLOCALALLOC(len * sizeof(WCHAR), L"BuildPathW")) != NULL) {
        wcscpy(szTmp, szPath);
        wcscat(szTmp, L"\\");
        wcscat(szTmp, szFileName);
        return(szTmp);
    }
    else {
        return(NULL);
    }
}

//************************************************************************
// MyGetFileTime - Helper for DrvUpgradePrinter and friends.
//************************************************************************

BOOL MyGetFileTime(PWSTR szDir, PWSTR szName, LPFILETIME lpFileTime)
{
    LPWIN32_FIND_DATA lpfd;
    HANDLE  hfd;
    PWSTR   szTmp;
    BOOL    bRet = FALSE;


    szTmp = BuildPathW(szDir, szName);
    lpfd  = WFLOCALALLOC(sizeof(WIN32_FIND_DATA), L"MyGetFileTime");

    if ((szTmp) && (lpfd)) {
        LOGDEBUG(1, (L"WOWFAXUI!GetFileTime, szTmp: %s\n", szTmp));
        if ((hfd = FindFirstFile(szTmp, lpfd)) != INVALID_HANDLE_VALUE) {
            memcpy(lpFileTime, &(lpfd->ftLastWriteTime), sizeof(FILETIME));
            FindClose(hfd);
            bRet = TRUE;
            LOGDEBUG(1, (L"WOWFAXUI!GetFileTime, FileTimeHi: %X  FileTimeLo: %X\n", lpFileTime->dwHighDateTime, lpFileTime->dwLowDateTime));
        }
        else {
            LOGDEBUG(0, (L"WOWFAXUI!GetFileTime, file not found: %s\n", szTmp));
        }
    }

    if (szTmp) {
        LocalFree(szTmp);
    }
    if (lpfd) {
        LocalFree(lpfd);
    }
    return(bRet);
}

//************************************************************************
// CheckForNewerFiles - Helper for DrvUpgradePrinter. Compares the date/time
//      of wowfaxui.dll and wowfax.dll in the two passed directories. Returns
//      FALSE if files in szOldDriverDir are the same or newer than those
//      in szSysDir. Otherwise returns non-zero.
//************************************************************************

BOOL CheckForNewerFiles(PWSTR szOldDriverDir, PWSTR szSysDir)
{
    FILETIME ftSourceDriver, ftCurrentDriver;
    BOOL     bRet = FALSE;

    if ((szOldDriverDir) && (szSysDir)) {
        if (MyGetFileTime(szOldDriverDir, L"wowfax.dll", &ftCurrentDriver)) {
            if (MyGetFileTime(szSysDir, L"wowfax.dll", &ftSourceDriver)) {
                // Check time/date to see if we need to update the drivers.
                if (CompareFileTime(&ftSourceDriver, &ftCurrentDriver) > 0) {
                    bRet = TRUE;
                }
            }
        }
        if (MyGetFileTime(szOldDriverDir, L"wowfaxui.dll", &ftCurrentDriver)) {
            if (MyGetFileTime(szSysDir, L"wowfaxui.dll", &ftSourceDriver)) {
                if (CompareFileTime(&ftSourceDriver, &ftCurrentDriver) > 0) {
                    bRet = TRUE;
                }
            }
        }
    }
    else {
        LOGDEBUG(0, (L"WOWFAXUI!CheckForNewerFiles: NULL directory parameters\n"));
    }

    return(bRet);
}

//************************************************************************
// DoUpgradePrinter - Called by DrvUpgradePrinter which is called in the
//      system context by the spooler.
//************************************************************************

BOOL DoUpgradePrinter(DWORD dwLevel, LPDRIVER_UPGRADE_INFO_1W lpDrvUpgradeInfo)
{
    static BOOL bDrvUpgradePrinterLock = FALSE;
    HANDLE hPrinter = NULL;
    DRIVER_INFO_2  DriverInfo, *pDriverInfo = NULL;
    DWORD dwNeeded = 0;
    PWSTR szSysDir  = NULL;
    PWSTR szDstDir  = NULL;
    PWSTR szSrcPath = NULL;
    PWCHAR pwc;
    BOOL  bRet = FALSE;
    TCHAR szName[WOWFAX_MAX_USER_MSG_LEN] = L"";

    // Check for correct level for upgrade.
    if (dwLevel != 1) {
        LOGDEBUG(0, (L"WOWFAXUI!DrvUpgradePrinter, Bad input Level\n"));
        SetLastError(ERROR_INVALID_LEVEL);
        goto DoUpgradePrinterExit;
    }

    szDstDir = AllocPathW();
    szSysDir = AllocPathW();
    if (!szDstDir || !szSysDir) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, work space allocation failed\n"));
        goto DoUpgradePrinterExit;
    }

    if (!GetSystemDirectory(szSysDir, MAX_PATH+1)) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, GetSystemDirectory failed\n"));
        goto DoUpgradePrinterExit;
    }

    if (!lpDrvUpgradeInfo || !lpDrvUpgradeInfo->pPrinterName) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, pPrinterName is NULL\n"));
        goto DoUpgradePrinterExit;
    }

    // Get the paths to the old printer drivers.
    if (!OpenPrinter(lpDrvUpgradeInfo->pPrinterName, &hPrinter, NULL)) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, Unable to open: %s\n", lpDrvUpgradeInfo->pPrinterName));
        goto DoUpgradePrinterExit;
    }

    GetPrinterDriver(hPrinter, NULL, 2, (LPBYTE) pDriverInfo, 0, &dwNeeded);

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, GetPrinterDriver failed\n"));
        goto DoUpgradePrinterExit;
    }

    if ((pDriverInfo = WFLOCALALLOC(dwNeeded, L"DoUpgradePrinter")) == NULL) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, work space allocation failed\n"));
        goto DoUpgradePrinterExit;
    }

    if (!GetPrinterDriver(hPrinter, NULL, 2, (LPBYTE) pDriverInfo, dwNeeded, &dwNeeded)) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, GetPrinterDriver failed, GetLastError: %d\n", GetLastError()));
        goto DoUpgradePrinterExit;
    }
    ClosePrinter(hPrinter);

    // Strip off the file name.
    if ((pwc = wcsrchr(pDriverInfo->pDriverPath, L'\\')) == NULL) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, unable to strip file name\n"));
        goto DoUpgradePrinterExit;
    }
    *pwc = UNICODE_NULL;

    // Install new printer driver if it's more recent than the old one.
    if (CheckForNewerFiles(pDriverInfo->pDriverPath, szSysDir)) {
        LOGDEBUG(1, (L"WOWFAXUI!DoUpgradePrinter, Doing driver update\n"));
        memset(&DriverInfo,  0, sizeof(DRIVER_INFO_2));

        if (!GetPrinterDriverDirectory(NULL, NULL, 1, (LPBYTE) szDstDir, MAX_PATH, &dwNeeded)) {
            LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, GetPrinterDriverDirectory failed\n"));
            goto DoUpgradePrinterExit;
        }
 
        // This is a dummy. We've no data file, but spooler won't take NULL.
        DriverInfo.pDataFile   = BuildPathW(szDstDir, WOWFAX_DLL_NAME);
        DriverInfo.pDriverPath = BuildPathW(szDstDir, WOWFAX_DLL_NAME);
        LOGDEBUG(1, (L"WOWFAXUI!DoUpgradePrinter, pDriverPath = %s\n", DriverInfo.pDataFile));
        if (DriverInfo.pDriverPath) {
            szSrcPath = BuildPathW(szSysDir, WOWFAX_DLL_NAME);
            if (szSrcPath) {
                CopyFile(szSrcPath, DriverInfo.pDriverPath, FALSE);
                LocalFree(szSrcPath);
            }
        }

        DriverInfo.pConfigFile = BuildPathW(szDstDir, WOWFAXUI_DLL_NAME);
        szSrcPath = BuildPathW(szSysDir, WOWFAXUI_DLL_NAME);
        if (DriverInfo.pConfigFile) {
            if (szSrcPath) {
                CopyFile(szSrcPath, DriverInfo.pConfigFile, FALSE);
                LocalFree(szSrcPath);
            }
        }

        // Install the printer driver.
        DriverInfo.cVersion = 1;
        if (LoadString(ghInst, WOWFAX_NAME_STR, szName, WOWFAX_MAX_USER_MSG_LEN)) {
            DriverInfo.pName = szName;
            if (AddPrinterDriver(NULL, 2, (LPBYTE) &DriverInfo) == FALSE) {
                bRet = (GetLastError() == ERROR_PRINTER_DRIVER_ALREADY_INSTALLED);
            }
            else {
                bRet = TRUE;
            }
        }
        if (DriverInfo.pDataFile) {
            LocalFree(DriverInfo.pDataFile);
        }
        if (DriverInfo.pDriverPath) {
            LocalFree(DriverInfo.pDriverPath);
        }
        if (DriverInfo.pConfigFile) {
            LocalFree(DriverInfo.pConfigFile);
        }
    }
    else {
        LOGDEBUG(1, (L"WOWFAXUI!DoUpgradePrinter, No driver update\n"));
        bRet = TRUE;
    }

DoUpgradePrinterExit:
    if (szDstDir) {
         LocalFree(szDstDir);
    }
    if (szSysDir) {
         LocalFree(szSysDir);
    }
    if (pDriverInfo) {
         LocalFree(pDriverInfo);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\fax\wowfaxui\wowfaxui.c ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. User Interface functions
// which are called by WINSPOOL.
//
// I don't think performance is a big issue here.      - nandurir
//
// History:
//    02-jan-95   nandurir   created.
//    01-feb-95   reedb      Clean-up, support printer install and bug fixes.
//    14-mar-95   reedb      Use GDI hooks to move most functionality to UI.
//
//************************************************************************

#define WOWFAX_INC_COMMON_CODE

#include "windows.h"
#include "wowfaxui.h"
#include "winspool.h"

#define DEF_DRV_DOCUMENT_EVENT_DBG_STR
#include "gdispool.h"
#include "winddiui.h"

//************************************************************************
// Globals
//************************************************************************

HINSTANCE ghInst;
FAXDEV gdev;
WORD   gdmDriverExtra = sizeof(DEVMODEW);

DEVMODEW gdmDefaultDevMode;

CRITICAL_SECTION CriticalSection;
LPCRITICAL_SECTION lpCriticalSection = &CriticalSection;

//************************************************************************
// DllInitProc
//************************************************************************

BOOL DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext)
{
    UNREFERENCED_PARAMETER(pContext);

    if (Reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
        InitializeCriticalSection(lpCriticalSection);
    }
    else if (Reason == DLL_PROCESS_DETACH) {
        DeleteCriticalSection(lpCriticalSection);
    }
    ghInst = (HINSTANCE) hModule;

    return(TRUE);
}

//************************************************************************
// PrinterProperties
//************************************************************************

BOOL PrinterProperties(HWND hwnd, HANDLE hPrinter)
{

    TCHAR szMsg[WOWFAX_MAX_USER_MSG_LEN];
    TCHAR szTitle[WOWFAX_MAX_USER_MSG_LEN];

    UNREFERENCED_PARAMETER(hPrinter);

    if (LoadString(ghInst, WOWFAX_NAME_STR, szTitle, WOWFAX_MAX_USER_MSG_LEN)) {
        if (LoadString(ghInst, WOWFAX_SELF_CONFIG_STR, szMsg, WOWFAX_MAX_USER_MSG_LEN)) {
            MessageBox(hwnd, szMsg, szTitle, MB_OK);
        }
    }
    return TRUE;
}

//************************************************************************
// SetupFaxDev - Do some common FaxDev setup: Calculate the size of the
//      mapped file section for use by the inter-process communication
//      handler. Create and set the mapped section. Get the 16-bit driver
//      info from the registry and copy it into the mapped section. Build
//      pointers for variable length stuff we copied to the mapped section.
//      Return zero on failure, or current offset into mapped section.
//************************************************************************

UINT SetupFaxDev(PWSTR pDeviceName, LPFAXDEV lpdev)
{
    LPREGFAXDRVINFO16 lpRegFaxDrvInfo16;
    DWORD iOffset = 0;

    // Get the driver and port names from the registry where they were written
    // by the 16-bit fax driver install program using WriteProfileString.
    if ((lpRegFaxDrvInfo16 = Get16BitDriverInfoFromRegistry(pDeviceName))) {

        //
        // Count dmDriverExtra twice, once for each devmode. Use cached
        // gdmDriverExtra value. Normally winspool/common dialogs and others,
        // call the DocumentProperties with fMode = 0 to get the size. So we
        // update gdmDriverExtra when such a call is made. We leave extra
        // room to DWORD align both In and Out pointers.
        //

        lpdev->cbMapLow =  sizeof(FAXDEV);
        lpdev->cbMapLow += sizeof(DEVMODE) * 2;
        lpdev->cbMapLow += gdmDriverExtra  * 2;
        lpdev->cbMapLow += sizeof(DWORD)   * 2;  // Leave room for DWORD align.
        lpdev->cbMapLow += (lstrlen(lpRegFaxDrvInfo16->lpDriverName) + 1) * sizeof(TCHAR);
        lpdev->cbMapLow += (lstrlen(lpRegFaxDrvInfo16->lpPortName) + 1) * sizeof(TCHAR);

        lpdev->idMap = GetCurrentThreadId();

        if (InterProcCommHandler(lpdev, DRVFAX_CREATEMAP)) {
            if (InterProcCommHandler(lpdev, DRVFAX_SETMAPDATA)) {

                // Copy the printer/device name to the WOWFAXINFO struct.
                lstrcpy(lpdev->lpMap->szDeviceName,
                        lpRegFaxDrvInfo16->lpDeviceName);

                // Calculate the pointers into the mapped file section and copy
                // the variable length data to the mapped file section.

                // Printer driver and port names.
                iOffset = sizeof(*lpdev->lpMap);
                lpdev->lpMap->lpDriverName = (LPTSTR) iOffset;
                (PWSTR)iOffset += lstrlen(lpRegFaxDrvInfo16->lpDriverName) + 1;
                lstrcpy((PWSTR)((LPBYTE)lpdev->lpMap + (DWORD)lpdev->lpMap->lpDriverName), lpRegFaxDrvInfo16->lpDriverName);
                lpdev->lpMap->lpPortName = (LPTSTR) iOffset;
                (PWSTR)iOffset += lstrlen(lpRegFaxDrvInfo16->lpPortName) + 1;
                lstrcpy((PWSTR)((LPBYTE)lpdev->lpMap + (DWORD)lpdev->lpMap->lpPortName), lpRegFaxDrvInfo16->lpPortName);
            }
        }
        Free16BitDriverInfo(lpRegFaxDrvInfo16);
    }
    return iOffset;
}

//************************************************************************
// DrvDocumentProperties
//************************************************************************

LONG DrvDocumentProperties(HWND hwnd, HANDLE hPrinter, PWSTR pDeviceName,
                               PDEVMODE pdmOut, PDEVMODE pdmIn, DWORD fMode)
{
    FAXDEV dev = gdev;
    LPFAXDEV lpdev = &dev;
    LONG    lRet = -1;
    DWORD   iOffset;
    DWORD   cbT;
    DWORD   dwWowProcID, dwCallerProcID;
    PRINTER_INFO_2 *pPrinterInfo2 = NULL;

    LOGDEBUG(1, (L"WOWFAXUI!DrvDocumentProperties, pdmOut: %X, pdmIn: %X, fMode: %X\n", pdmOut, pdmIn, fMode));

    // Check for get default devmode case, use spooler to get it if possible.
    if (!pdmIn && pdmOut && !(fMode & DM_IN_PROMPT)) {
        if (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) {
            if (pPrinterInfo2->pDevMode) {
                LOGDEBUG(1, (L"  Using spooler default devmode\n"));
                cbT = pPrinterInfo2->pDevMode->dmSize +
                        pPrinterInfo2->pDevMode->dmDriverExtra;

                memcpy(pdmOut, pPrinterInfo2->pDevMode, cbT);
                lRet = IDOK;
                goto LeaveDDP;
            }
        }
    }

    if (iOffset = SetupFaxDev(pDeviceName, lpdev)) {
        lpdev->lpMap->msg = WM_DDRV_EXTDMODE;

        // Calculate the pointers into the mapped file section and copy
        // the variable length data to the mapped file section.
        DRVFAX_DWORDALIGN(iOffset);
        lpdev->lpMap->lpIn = (LPDEVMODEW)((pdmIn) ? iOffset : 0);
        iOffset += sizeof(*pdmIn) + gdmDriverExtra;

        DRVFAX_DWORDALIGN(iOffset);
        lpdev->lpMap->lpOut = (LPDEVMODEW)((pdmOut) ? iOffset : 0);
        iOffset += sizeof(*pdmOut) + gdmDriverExtra;

        //
        // if Input is non-null copy the data even if fMode doesn't
        // have the appropriate flag.
        //

        if (pdmIn) {
            // apps don't pass DM_MODIFY even if they mean it - ie
            // pdmIn will be non-null but they won't or this flag.
            // The 32bit rasdd extracts data from pdmIn even if the
            // DM_MODIFY flag is not set. So we need to do the same

            if (fMode != 0) {
                fMode |= DM_IN_BUFFER;
            }

            iOffset = (DWORD)lpdev->lpMap + (DWORD)lpdev->lpMap->lpIn;
            RtlCopyMemory((LPVOID)iOffset, pdmIn,
               sizeof(*pdmIn) + min(gdmDriverExtra, pdmIn->dmDriverExtra));

            // reset dmDriverExtra in pdmIn.
            ((LPDEVMODE)iOffset)->dmDriverExtra =
                                 min(gdmDriverExtra, pdmIn->dmDriverExtra);
        }

        if (!(fMode & (DM_COPY | DM_OUT_BUFFER))) {
            lpdev->lpMap->lpOut = 0;
        }

        lpdev->lpMap->wCmd = (WORD)fMode;

        // valid size of this map
        lpdev->lpMap->cData = lpdev->cbMapLow;


        lpdev->lpMap->hwndui = hwnd;
        if (fMode & DM_IN_PROMPT) {
            GetWindowThreadProcessId(hwnd, &dwCallerProcID);
            GetWindowThreadProcessId(lpdev->lpMap->hwnd, &dwWowProcID);

            if (dwWowProcID == dwCallerProcID) {

                // If the calling process is the same as the 'wowfaxclass' window
                // (WOW/WOWEXEC) use CallWindow instead of SendMessage so we don't
                // deadlock WOW when trying to put up the 16-bit fax driver UI.

                InterProcCommHandler(lpdev, DRVFAX_CALLWOW);
            }
            else {
                InterProcCommHandler(lpdev, DRVFAX_SENDNOTIFYWOW);
            }
        }
        else {
            InterProcCommHandler(lpdev, DRVFAX_SENDTOWOW);
        }

        lRet = (lpdev->lpMap->status) ? (LONG)lpdev->lpMap->retvalue : lRet;
        if (lRet > 0) {
            if ((fMode & DM_OUT_BUFFER) && (lRet == IDOK) && pdmOut) {
                iOffset = (DWORD)lpdev->lpMap + (DWORD)lpdev->lpMap->lpOut;
                RtlCopyMemory(pdmOut, (LPDEVMODE)iOffset,
                               sizeof(*pdmOut)+ ((LPDEVMODE)iOffset)->dmDriverExtra);

                // LATER : what about the formname etc. fields - new on NT
            }
            else if (fMode == 0) {
                // update our dmDriverExtra
                gdmDriverExtra = (WORD)max(lRet, gdmDriverExtra);
            }
        }
        else {
            LOGDEBUG(0, (L"WOWFAXUI!DrvDocumentProperties failed, lpdev->lpMap->status: %X, lpdev->lpMap->retvalue: %X\n", lpdev->lpMap->status, (LONG)lpdev->lpMap->retvalue));
        }
        InterProcCommHandler(lpdev, DRVFAX_DESTROYMAP);
    }

LeaveDDP:
    if (pPrinterInfo2) {
        LocalFree(pPrinterInfo2);
    }

    LOGDEBUG(1, (L"WOWFAXUI!DrvDocumentProperties returning: %X, pdmOut: %X, pdmIn: %X\n", lRet, pdmOut, pdmIn));

    return(lRet);
}

//************************************************************************
// DrvAdvancedDocumentProperties
//************************************************************************

LONG DrvAdvancedDocumentProperties(HWND hwnd, HANDLE hPrinter, PWSTR pDeviceName,
                               PDEVMODE pdmOut, PDEVMODE pdmIn)
{
   // for 16bit drivers this is a NOP.

   return 0;
}

//************************************************************************
// DevQueryPrintEx
//************************************************************************

BOOL DevQueryPrintEx(PDEVQUERYPRINT_INFO pDQPInfo)
{
    return TRUE;
}

//************************************************************************
// DrvDeviceCapabilities
//************************************************************************

DWORD DrvDeviceCapabilities(HANDLE hPrinter, PWSTR pDeviceName,
                               WORD iDevCap, VOID *pOut, PDEVMODE pdmIn)
{
    FAXDEV   dev = gdev;
    LPFAXDEV lpdev = &dev;
    LONG     lRet = -1;
    DWORD    iOffset;
    LPBYTE   lpSrc;

    LOGDEBUG(1, (L"WOWFAXUI!DrvDeviceCapabilities, iDevCap: %X, pdmIn: %X\n", iDevCap, pdmIn));

    if (iDevCap == DC_SIZE) {
        return sizeof(DEVMODEW);
    }

    if (iOffset = SetupFaxDev(pDeviceName, lpdev)) {
        lpdev->lpMap->msg = WM_DDRV_DEVCAPS;

        // Calculate the pointers into the mapped file section and copy
        // the variable length data to the mapped file section.

        lpdev->lpMap->lpIn = (LPDEVMODEW)((pdmIn) ? iOffset : 0);
        iOffset += sizeof(*pdmIn) + gdmDriverExtra;

        // output in lpout: make this the last pointer in the
        // data so that we can use the rest of the mapped area for copy
        // on output.

        lpdev->lpMap->lpOut = (LPDEVMODEW)((pOut) ? iOffset : 0);
        iOffset += sizeof(*pdmIn) + gdmDriverExtra;


        if (pdmIn) {
            iOffset = (DWORD)lpdev->lpMap + (DWORD)lpdev->lpMap->lpIn;
            RtlCopyMemory((LPVOID)iOffset, pdmIn,
               sizeof(*pdmIn) + min(gdmDriverExtra, pdmIn->dmDriverExtra));

            // reset dmDriverExtra in pdmIn.
            ((LPDEVMODE)iOffset)->dmDriverExtra =
                                 min(gdmDriverExtra, pdmIn->dmDriverExtra);
        }

        lpdev->lpMap->wCmd = iDevCap;
        // valid size of this map
        lpdev->lpMap->cData = lpdev->cbMapLow;

        InterProcCommHandler(lpdev, DRVFAX_SENDTOWOW);
        lRet = (lpdev->lpMap->status) ? (LONG)lpdev->lpMap->retvalue : lRet;

        // on return cData is the number of bytes to copy

        if (lpdev->lpMap->lpOut && lpdev->lpMap->cData && lpdev->lpMap->retvalue) {
            lpSrc = (LPBYTE)lpdev->lpMap + (DWORD)lpdev->lpMap->lpOut;
            switch (lpdev->lpMap->wCmd) {
                case DC_PAPERSIZE:
                case DC_MINEXTENT:
                case DC_MAXEXTENT:
                    ((LPPOINT)pOut)->x = ((LPPOINTS)lpSrc)->x;
                    ((LPPOINT)pOut)->y = ((LPPOINTS)lpSrc)->y;
                    break;

                default:
                    RtlCopyMemory(pOut, lpSrc, lpdev->lpMap->cData);
                    break;
            }
        }
        InterProcCommHandler(lpdev, DRVFAX_DESTROYMAP);
    }

    if (lRet < 0) {
        LOGDEBUG(0, (L"WOWFAXUI!DrvDeviceCapabilities Failing\n"));
    }

    LOGDEBUG(1, (L"WOWFAXUI!DrvDeviceCapabilities, returning  pOut: %X\n", pOut));

    return(lRet);
}

//************************************************************************
// DrvUpgradePrinter - Called in the system context by the spooler.
//      Drivers will really only be updated the first time the spooler is
//      started after an upgrade. Calls DoUpgradePrinter to do the work.
//************************************************************************

BOOL DrvUpgradePrinter(DWORD dwLevel, LPBYTE lpDrvUpgradeInfo)
{
    static BOOL bDrvUpgradePrinterLock = FALSE;
    BOOL  bRet;

    LOGDEBUG(1, (L"WOWFAXUI!DrvUpgradePrinter, dwLevel: %X, lpDrvUpgradeInfo: %X\n", dwLevel, lpDrvUpgradeInfo));

    // DrvUpgradePrinter is called during AddPrinterDriver. Don't allow
    // recursion. Protect lock from other threads.
    EnterCriticalSection(lpCriticalSection);
    if (bDrvUpgradePrinterLock) {
        LeaveCriticalSection(lpCriticalSection);
        return(TRUE);
    }

    bDrvUpgradePrinterLock = TRUE;
    LeaveCriticalSection(lpCriticalSection);

    bRet = DoUpgradePrinter(dwLevel, (LPDRIVER_UPGRADE_INFO_1W)lpDrvUpgradeInfo);

    EnterCriticalSection(lpCriticalSection);
    bDrvUpgradePrinterLock = FALSE;
    LeaveCriticalSection(lpCriticalSection);

    return(bRet);
}

//************************************************************************
// DrvDocumentEvent - This exported function is used to hook the GDI
//      Display Driver functions. It unpacks and validates the parameters,
//      then dispatches to the appropriate handler, based on the passed
//      iEsc value. The following table provides a mapping of the
//      DrvDocumentEvent escapes to the server side display driver
//      callbacks, and gives the call time relative to the callback:
//
//      DOCUMENTEVENT_CREATEDCPRE       DrvEnablePDEV, before
//      DOCUMENTEVENT_CREATEDCPOST      DrvEnablePDEV, after
//      DOCUMENTEVENT_RESETDCPRE        DrvRestartPDEV, before
//      DOCUMENTEVENT_RESETDCPOST       DrvRestartPDEV, after
//      DOCUMENTEVENT_STARTDOC          DrvStartDoc, before
//      DOCUMENTEVENT_STARTPAGE         DrvStartPage, before
//      DOCUMENTEVENT_ENDPAGE           DrvSendPage, before
//      DOCUMENTEVENT_ENDDOC            DrvEndDoc, before
//      DOCUMENTEVENT_ABORTDOC          DrvEndDoc, before
//      DOCUMENTEVENT_DELETEDC          DrvDisablePDEV, before
//
//************************************************************************

int DrvDocumentEvent(
    HANDLE  hPrinter,
    HDC     hdc,
    int     iEsc,
    ULONG   cbIn,
    PULONG  pjIn,
    ULONG   cbOut,
    PULONG  pjOut
)
{
    int   iRet = DOCUMENTEVENT_FAILURE;

    if (iEsc < DOCUMENTEVENT_LAST) {
        LOGDEBUG(1, (L"WOWFAXUI!DrvDocumentEvent, iEsc: %s, hdc: %X\n", szDrvDocumentEventDbgStrings[iEsc], hdc));
    }
    // Validate HDC for some of the escapes.
    if ((iEsc >= DOCUMENTEVENT_HDCFIRST) && (iEsc < DOCUMENTEVENT_HDCLAST)) {
        if (hdc == NULL) {
            LOGDEBUG(0, (L"WOWFAXUI!DrvDocumentEvent NULL HDC for escape: %X\n", iEsc));
            return(iRet);
        }
    }

    switch (iEsc)
    {
        case DOCUMENTEVENT_CREATEDCPRE:
            iRet = DocEvntCreateDCpre((LPWSTR)*(pjIn+1),
                                       (DEVMODEW*)*(pjIn+2),
                                       (DEVMODEW**)pjOut);
            break;

        case DOCUMENTEVENT_CREATEDCPOST:
            iRet = DocEvntCreateDCpost(hdc, (DEVMODEW*)*pjIn);
            break;

        case DOCUMENTEVENT_RESETDCPRE:
            iRet = DocEvntResetDCpre(hdc, (DEVMODEW*)*(pjIn),
                                       (DEVMODEW**)pjOut);
            break;

        case DOCUMENTEVENT_RESETDCPOST:
            iRet = DocEvntResetDCpost(hdc, (DEVMODEW*)*pjIn);
            break;

        case DOCUMENTEVENT_STARTDOC:
            // WowFax (EasyFax Ver2.0) support.
            // Also Procomm+ 3 cover sheets.  Bug #305665
            iRet = DocEvntStartDoc(hdc, (DOCINFOW*)*pjIn);
            break;

        case DOCUMENTEVENT_DELETEDC:
            iRet = DocEvntDeleteDC(hdc);
            break;

        case DOCUMENTEVENT_ENDDOC:
            iRet = DocEvntEndDoc(hdc);
            break;

        case DOCUMENTEVENT_ENDPAGE:
            iRet = DocEvntEndPage(hdc);
            break;

        // The following require no client side processing:
        case DOCUMENTEVENT_ESCAPE:
        case DOCUMENTEVENT_ABORTDOC:
        case DOCUMENTEVENT_STARTPAGE:
        case DOCUMENTEVENT_QUERYFILTER:
            // No Client side processing needed.
            goto docevnt_unsupported;

        default :
            LOGDEBUG(0, (L"WOWFAXUI!DrvDocumentEvent unknown escape: %X\n", iEsc));
docevnt_unsupported:
            iRet = DOCUMENTEVENT_UNSUPPORTED;

    } // switch

    LOGDEBUG(1, (L"WOWFAXUI!DrvDocumentEvent return: %X\n", iRet));
    return(iRet);

}

//***************************************************************************
// DocEvntCreateDCpre - Allocate a DEVMODE which contains a FAXDEV as the
//      dmDriverExtra portion. This DEVMODE will be passed to the
//      DrvEnablePDEV function on the server side.
//***************************************************************************

int DocEvntCreateDCpre(
    LPWSTR      lpszDevice,
    DEVMODEW    *pDevModIn,
    DEVMODEW    **pDevModOut
)
{
    DWORD       iOffset = 0;
    LPFAXDEV    lpFaxDev;
    PGDIINFO    pGdiInfo;
    DEVMODEW    *pTmpDevMode;

    LPREGFAXDRVINFO16 lpRegFaxDrvInfo16 = NULL;

    int iRet = DOCUMENTEVENT_FAILURE;

    if ((lpszDevice == NULL)  || (pDevModOut == NULL)) {
        LOGDEBUG(0, (L"WOWFAXUI!DocEvntCreateDCpre, failed, NULL parameters\n"));
        goto DocEvntCreateDCpreFailed;
    }

    LOGDEBUG(1, (L"WOWFAXUI!DocEvntCreateDCpre, Device: %s, pDevModIn: %X pDevModOut: %X\n", lpszDevice, pDevModIn, pDevModOut));

    // Use our global default devmode if a NULL devmode is passed in from the app.
    if (pDevModIn == NULL) {
        gdmDefaultDevMode.dmSize = sizeof(DEVMODEW);
        pDevModIn = &gdmDefaultDevMode;
    }

    pTmpDevMode = (DEVMODEW*)WFLOCALALLOC(sizeof(FAXDEV) + sizeof(DEVMODEW),
                                         L"DocEvntCreateDCpre");

    LOGDEBUG(2, (L"WOWFAXUI!DocEvntCreateDCpre,  pTmpDevMode: %X\n", pTmpDevMode));

    if (pTmpDevMode == NULL) {
        goto DocEvntCreateDCpreFailed;
    }

    // Copy pDevModIn to the new DEVMODE.
    RtlCopyMemory(pTmpDevMode, pDevModIn, sizeof(*pTmpDevMode));
    pTmpDevMode->dmDriverExtra = sizeof(FAXDEV);
    pTmpDevMode->dmSize = sizeof(DEVMODEW);

    // Setup some handy pointers.
    lpFaxDev = (LPFAXDEV) (pTmpDevMode + 1);
    pGdiInfo = &(lpFaxDev->gdiinfo);

    lpFaxDev->id =  FAXDEV_ID;

    // Save a client side pointer to the new DEVMODE and it's embeded FAXDEV.
    // We'll use ExtEscape to get these pointers back any time we need to
    // associate driver context with an HDC.

    lpFaxDev->pdevmode = pTmpDevMode;
    lpFaxDev->lpClient = lpFaxDev;

    // Get the driver and port names from the registry where they were written
    // by the 16-bit fax driver install program using WriteProfileString.

    if ((lpRegFaxDrvInfo16 = Get16BitDriverInfoFromRegistry(lpszDevice)) == NULL) {
        goto DocEvntCreateDCpreFailed;
    }

    if ((lpFaxDev->hwnd = FindWowFaxWindow()) == NULL) {
        goto DocEvntCreateDCpreFailed;
    }
    lpFaxDev->tid   = GetWindowThreadProcessId(lpFaxDev->hwnd, 0);
    lpFaxDev->idMap = (DWORD)lpFaxDev;

    // Calculate the size of the mapped file section for inter process communication.
    lpFaxDev->cbMapLow = sizeof(DWORD) +          // leave room for DWORD align
                            sizeof(*lpFaxDev->lpMap) +
                            sizeof(GDIINFO) +
                            (lstrlen(lpRegFaxDrvInfo16->lpDriverName) + 1) * sizeof(TCHAR) +
                            (lstrlen(lpRegFaxDrvInfo16->lpPortName) + 1) * sizeof(TCHAR) +
                            sizeof(*pDevModIn) +
                            ((pDevModIn) ? pDevModIn->dmDriverExtra : 0);
    DRVFAX_DWORDALIGN(lpFaxDev->cbMapLow);

    InterProcCommHandler(lpFaxDev, DRVFAX_CREATEMAP);

    if (InterProcCommHandler(lpFaxDev, DRVFAX_SETMAPDATA)) {
        lpFaxDev->lpMap->msg = WM_DDRV_ENABLE;

        // Copy the printer/device name to the WOWFAXINFO struct.
        lstrcpy(lpFaxDev->lpMap->szDeviceName, lpszDevice);

        // Calculate the pointers into the mapped file section and copy
        // the variable length data to the mapped file section.

        // output :  gdiinfo

        lpFaxDev->lpMap->lpOut = (LPDEVMODE)(sizeof(*lpFaxDev->lpMap));
        iOffset = sizeof(*lpFaxDev->lpMap) + sizeof(GDIINFO);

        // Device (printer) and port names.

        lpFaxDev->lpMap->lpDriverName = (LPSTR) iOffset;
        (PWSTR)iOffset += lstrlen(lpRegFaxDrvInfo16->lpDriverName) + 1;
        lstrcpy((PWSTR)((LPBYTE)lpFaxDev->lpMap + (DWORD)lpFaxDev->lpMap->lpDriverName), lpRegFaxDrvInfo16->lpDriverName);
        lpFaxDev->lpMap->lpPortName = (LPVOID) iOffset;
        (PWSTR)iOffset += lstrlen(lpRegFaxDrvInfo16->lpPortName) + 1;
        lstrcpy((PWSTR)((LPBYTE)lpFaxDev->lpMap + (DWORD)lpFaxDev->lpMap->lpPortName), lpRegFaxDrvInfo16->lpPortName);

        // input:  devmode

        DRVFAX_DWORDALIGN(iOffset);
        lpFaxDev->lpMap->lpIn = (LPDEVMODE)((pDevModIn) ? iOffset : 0);
        iOffset += ((pDevModIn) ? sizeof(*pDevModIn) + pDevModIn->dmDriverExtra : 0);

        if (pDevModIn) {
            RtlCopyMemory((LPBYTE)lpFaxDev->lpMap + (DWORD)lpFaxDev->lpMap->lpIn,
                            pDevModIn, sizeof(*pDevModIn) + pDevModIn->dmDriverExtra);
        }

        // set the total byte count of data.

        lpFaxDev->lpMap->cData = iOffset;

        // all done - switch to wow
        InterProcCommHandler(lpFaxDev, DRVFAX_SENDTOWOW);
        // values returned from wow.
        lpFaxDev->lpinfo16 = (DWORD)lpFaxDev->lpMap->lpinfo16;
        iRet = lpFaxDev->lpMap->status && lpFaxDev->lpMap->retvalue;
        if (iRet) {
            // Copy GDIINFO from WOW to the client side FAXDEV.
            RtlCopyMemory(pGdiInfo,
                          (LPBYTE)lpFaxDev->lpMap + (DWORD)lpFaxDev->lpMap->lpOut,
                          sizeof(GDIINFO));

            // Fill in some misc. fields in the client FAXDEV.
            pGdiInfo->ulHTPatternSize = HT_PATSIZE_DEFAULT;
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_1BPP;

            lpFaxDev->bmWidthBytes = pGdiInfo->szlPhysSize.cx / 0x8;
            DRVFAX_DWORDALIGN(lpFaxDev->bmWidthBytes);

            lpFaxDev->bmFormat = BMF_1BPP;
            lpFaxDev->cPixPerByte = 0x8;

            // Here if success, make pDevModOut point to the new DEVMODE.
            *pDevModOut = pTmpDevMode;

        }
        else {
            LOGDEBUG(0, (L"WOWFAXUI!DocEvntCreateDCpre, WOW returned error\n"));
        }
    }

    if (iRet) {
        goto DocEvntCreateDCpreSuccess;
    }
    else {
        iRet = DOCUMENTEVENT_FAILURE;
    }

DocEvntCreateDCpreFailed:
    LOGDEBUG(0, (L"WOWFAXUI!DocEvntCreateDCpre, failed!\n"));

DocEvntCreateDCpreSuccess:
    LOGDEBUG(1, (L"WOWFAXUI!DocEvntCreateDCpre, iRet: %X\n", iRet));
    if(lpRegFaxDrvInfo16) {
        Free16BitDriverInfo(lpRegFaxDrvInfo16);
    }
    return(iRet);
}

//***************************************************************************
// DocEvntResetDCpre -
//***************************************************************************

int DocEvntResetDCpre(
    HDC         hdc,
    DEVMODEW    *pDevModIn,
    DEVMODEW    **pDevModOut
)
{
    return(DOCUMENTEVENT_FAILURE);
}

//***************************************************************************
// DocEvntResetDCpost -
//***************************************************************************

int DocEvntResetDCpost(
    HDC         hdc,
    DEVMODEW    *pDevModIn
)
{
    return(DOCUMENTEVENT_SUCCESS);
}

//***************************************************************************
// DocEvntCreateDCpost -
//***************************************************************************

int DocEvntCreateDCpost(
    HDC         hdc,
    DEVMODEW    *pDevModIn
)
{
    LOGDEBUG(1, (L"WOWFAXUI!DocEvntCreateDCpost, hdc: %X, pDevModIn: %X\n", hdc, pDevModIn));

    // hdc was zero indicates DrvEnablePDEV failed. Cleanup.
    if (hdc == NULL) {
        if (pDevModIn) {
            LocalFree(pDevModIn);
            LOGDEBUG(1, (L"WOWFAXUI!DocEvntCreateDCpost, Cleaning up\n"));
        }
    }
    return(DOCUMENTEVENT_SUCCESS);
}

//***************************************************************************
// DocEvntStartDoc - hdc was validated by DrvDocumentEvent.
//***************************************************************************

int DocEvntStartDoc(
HDC       hdc,
DOCINFOW *pDocInfoW
)
{
    LPFAXDEV lpFaxDev = 0;
    HBITMAP  hbm = 0;
    DWORD    cbOld;
    int      iRet = 0;

    lpFaxDev = (LPFAXDEV)ExtEscape(hdc, DRV_ESC_GET_FAXDEV_PTR, 0, NULL, 0, NULL);
    if (ValidateFaxDev(lpFaxDev)) {
        if (InterProcCommHandler(lpFaxDev, DRVFAX_SETMAPDATA)) {
            lpFaxDev->lpMap->msg = WM_DDRV_STARTDOC;

            // WowFax (EasyFax Ver2.0) support.
            // Also Procomm+ 3 cover sheets.  Bug #305665.
            if (pDocInfoW && pDocInfoW->lpszDocName)
                lstrcpyW(lpFaxDev->lpMap->szDocName,pDocInfoW->lpszDocName);
            else
                lstrcpyW(lpFaxDev->lpMap->szDocName,L"");

            InterProcCommHandler(lpFaxDev, DRVFAX_SENDNOTIFYWOW);

            iRet = ((LONG)lpFaxDev->lpMap->retvalue > 0);

            // Calculate new mapsize - the bitmap bits will be written into
            // this map with a call to ExtEscape - thus allowing easy access
            // to the bits from WOW.

            cbOld = lpFaxDev->cbMapLow;
            lpFaxDev->cbMapLow += lpFaxDev->bmWidthBytes *
                                    lpFaxDev->gdiinfo.szlPhysSize.cy;
            if (InterProcCommHandler(lpFaxDev, DRVFAX_CREATEMAP)) {
                lpFaxDev->offbits = cbOld;
                goto DocEvntStartDocSuccess;
            }
        }
    }
    LOGDEBUG(1, (L"WOWFAXUI!DocEvntStartDoc, failed\n"));

DocEvntStartDocSuccess:
    if (iRet == 0) {
        iRet = DOCUMENTEVENT_FAILURE;
    }
    return iRet;
}

//***************************************************************************
// DocEvntDeleteDC - hdc was validated by DrvDocumentEvent.
//***************************************************************************

int DocEvntDeleteDC(
    HDC hdc
)
{
    LPFAXDEV lpFaxDev;
    DEVMODEW *lpDevMode;

    int      iRet = DOCUMENTEVENT_FAILURE;

    lpFaxDev = (LPFAXDEV)ExtEscape(hdc, DRV_ESC_GET_FAXDEV_PTR, 0, NULL, 0, NULL);
    if (ValidateFaxDev(lpFaxDev)) {
        // Validate 16-bit FaxWndProc window handle before sending a message.
        if (lpFaxDev->tid == GetWindowThreadProcessId(lpFaxDev->hwnd, 0)) {
            if (InterProcCommHandler(lpFaxDev, DRVFAX_SETMAPDATA)) {
                lpFaxDev->lpMap->msg = WM_DDRV_DISABLE;
                InterProcCommHandler(lpFaxDev, DRVFAX_SENDTOWOW);
            }
        }
        else {
            LOGDEBUG(0, (L"WOWFAXUI!DocEvntDeleteDC, unable to validate FaxWndProc\n"));
        }

        InterProcCommHandler(lpFaxDev, DRVFAX_DESTROYMAP);
    }
    else {
        LOGDEBUG(0, (L"WOWFAXUI!DocEvntDeleteDC, unable to get lpFaxDev\n"));
    }

    lpDevMode = (DEVMODEW*)ExtEscape(hdc, DRV_ESC_GET_DEVMODE_PTR, 0, NULL, 0, NULL);
    if (lpDevMode) {
        LocalFree(lpDevMode);
        iRet = DOCUMENTEVENT_SUCCESS;
    }
    else {
        LOGDEBUG(0, (L"WOWFAXUI!DocEvntDeleteDC, unable to get lpDevMode\n"));
    }

    return iRet;
}

//***************************************************************************
// DocEvntEndDoc - hdc was validated by DrvDocumentEvent.
//***************************************************************************

int DocEvntEndDoc(
HDC hdc
)
{
    LPFAXDEV lpFaxDev;
    DEVMODEW *lpDevMode;

    int      iRet = DOCUMENTEVENT_FAILURE;

    lpFaxDev = (LPFAXDEV)ExtEscape(hdc, DRV_ESC_GET_FAXDEV_PTR, 0, NULL, 0, NULL);
    if (ValidateFaxDev(lpFaxDev)) {
        if (InterProcCommHandler(lpFaxDev, DRVFAX_SETMAPDATA)) {
            lpFaxDev->lpMap->msg = WM_DDRV_ENDDOC;
            InterProcCommHandler(lpFaxDev, DRVFAX_SENDTOWOW);
            iRet = lpFaxDev->lpMap->status && ((LONG)lpFaxDev->lpMap->retvalue > 0);
            goto DocEvntEndDocSuccess;
        }
    }
    LOGDEBUG(1, (L"WOWFAXUI!DocEvntEndDoc, failed\n"));

DocEvntEndDocSuccess:
    if (iRet == 0) {
        iRet = DOCUMENTEVENT_FAILURE;
    }
    return  iRet;
}

//***************************************************************************
// DocEvntEndPage - hdc was validated by DrvDocumentEvent.
//***************************************************************************

int DocEvntEndPage(
    HDC hdc
)
{
    LPFAXDEV lpFaxDev;
    LONG     lDelta;
    ULONG    cjBits;
    int      iRet = DOCUMENTEVENT_FAILURE;

    lpFaxDev = (LPFAXDEV)ExtEscape(hdc, DRV_ESC_GET_FAXDEV_PTR, 0, NULL, 0, NULL);
    if (ValidateFaxDev(lpFaxDev)) {
        if (InterProcCommHandler(lpFaxDev, DRVFAX_SETMAPDATA)) {
            lpFaxDev->lpMap->msg = WM_DDRV_PRINTPAGE;

            // Get Surface info, cjBits and lDelta.
            cjBits = ExtEscape(hdc, DRV_ESC_GET_SURF_INFO, 0, NULL,
                                4, (PVOID)&lDelta);
            if (cjBits) {
                lpFaxDev->lpMap->bmWidthBytes = lDelta;
                lpFaxDev->lpMap->bmHeight = cjBits / lDelta;
                lpFaxDev->lpMap->bmPixPerByte = lpFaxDev->cPixPerByte;
                (DWORD)lpFaxDev->lpMap->lpbits = lpFaxDev->offbits;
                if (ExtEscape(hdc, DRV_ESC_GET_BITMAP_BITS, 0, NULL, cjBits,
                                (LPBYTE)lpFaxDev->lpMap + lpFaxDev->offbits)) {
                    InterProcCommHandler(lpFaxDev, DRVFAX_SENDTOWOW);
                    iRet = lpFaxDev->lpMap->status &&
                            ((LONG)lpFaxDev->lpMap->retvalue > 0);
                }
                goto DocEvntEndPageSuccess;
            }
        }
    }
    LOGDEBUG(1, (L"WOWFAXUI!DocEvntEndPage, failed\n"));

DocEvntEndPageSuccess:
    if (iRet == 0) {
        iRet = DOCUMENTEVENT_FAILURE;
    }
    return  iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\bop.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990  Microsoft Corporation

Module Name:

    BOP.H

Abstract:

    This module contains macro support for use of Bops in C code.

Author:

    Dave Hastings (daveh) 25-Apr-1991

Revision History:

--*/

//
// Assigned Bop Numbers
//

#define BOP_DOS              0x50
#define BOP_WOW              0x51
#define BOP_XMS              0x52
#define BOP_DPMI             0x53
#define BOP_CMD              0x54
#define BOP_DEBUGGER         0x56
#define BOP_REDIR            0x57    // used to be 55, now goes to MS_bop_7()
#define BOP_NOSUPPORT        0x59    // host warning dialog box
#define BOP_WAITIFIDLE       0x5A    // idle bop
#define BOP_DBGBREAKPOINT    0x5B    // does a 32 bit DbgBreakPoint
#define BOP_DEVICES          0x5C    // Devices internal to host\src
#define BOP_VIDEO            0x5D    // BUGBUG temporary
#define BOP_NOTIFICATION     0x5E    // 16bits to 32 bits notification
#define BOP_UNIMPINT         0x5F    // BUGBUG temporary
#define BOP_SWITCHTOREALMODE 0xFD
#define BOP_UNSIMULATE       0xFE    // end execution of code in a vdm

#define SVC_DEVICES_MSCDEXINIT      0x00
#define SVC_DEVICES_MSCDEX          0x01
#define SVC_DEVICES_LASTSVC         0x02

#define BOP_SIZE         3       // # of bytes in a bop instruction
//
// Bop Macro
//

/* XLATOFF */

#define BOP(BopNumber) _asm db 0xC4, 0xC4, BopNumber

/* XLATON */

/* ASM
BOP macro BopNumber
    db  0C4h, 0C4h, BopNumber
        endm

IFNDEF WOW_x86
FBOP macro BopNumber,BopMinorNumber,FastBopEntry
    BOP BopNumber
ifnb <BopMinorNumber>
    db  BopMinorNumber
endif
    endm
ELSE
FBOP macro BopNumber,BopMinorNumber,FastBopEntry
    local fb10,fb20
    test    word ptr [FastBopEntry + 4],0FFFFh
    jz  fb10
.386p
    push    ds
    push    40h
    pop     ds
    test    ds:[FIXED_NTVDMSTATE_REL40],RM_BIT_MASK
    pop     ds
    jnz     short fb10
	call fword ptr [FastBopEntry]

    db BopNumber            ; indicates which bop
ifnb <BopMinorNumber>
    db BopMinorNumber
endif
	jmp short fb20

.286p
fb10:   BOP BopNumber
ifnb <BopMinorNumber>
    db  BopMinorNumber
endif
fb20:
    endm
endif
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\curdir.h ===
/*      BREAK <Current directory list structure>
 *
 *
 *       Microsoft Confidential
 *       Copyright (C) Microsoft Corporation 1991
 *       All Rights Reserved.
 *
 *
 *     CDS - Current Directory Structure
 *
 * CDS items are used bu the internal routines to store cluster numbers and
 * network identifiers for each logical name.  The ID field is used dually,
 * both as net ID and for a cluster number for local devices.  In the case
 * of local devices, the cluster number will be -1 if there is a potential
 * of the disk being changed or if the path must be recracked.
 *
 *       Some pathnames have special preambles, such as
 *
 *               \\machane\sharename\...
 *       For these pathnames we can't allow ".." processing to back us
 *       up into the special front part of the name.  The CURDIR_END field
 *       holds the address of the seperator character which marks
 *       the split between the special preamble and the regular
 *       path list; ".." processing isn't allowed to back us up past
 *       (i.e., before) CURDIR_END
 *       For the root, it points at the leading /.  For net
 *       assignments it points at the end (nul) of the initial assignment:
 *       A:/     \\foo\bar           \\foo\bar\blech\bozo
 *         ^              ^                   ^
 */


#define DIRSTRLEN   64+3        // Max length in bytes of directory strings
#define TEMPLEN     DIRSTRLEN*2

/* XLATOFF */
#pragma pack(1)
/* XLATON */

typedef struct CURDIR_LIST {
    CHAR    CurDir_Text[DIRSTRLEN];         // text of assignment and curdir
    USHORT  CurDir_Flags;                   // various flags
    USHORT  CurDir_End;                     // index to ".." backup limit -
} CDS;                                      // see above

typedef CDS UNALIGNED *PCDS;

#define curdirLen   sizeof(CURDIR_LIST)     // Needed for
                                            // ASM87 which doesn't allow
                                            // Size directive as a macro
                                            // argument

typedef struct CURDIR_LIST_JPN {
    CHAR    CurDirJPN_Text[DIRSTRLEN];      // text of assignment and curdir
    USHORT  CurDirJPN_Flags;                // various flags
    USHORT  CurDirJPN_End;                  // index to ".." backup limit -
    CHAR    CurDirJPN_Reserve[17];          // Reserved for application compatibility.
                                            // Ichitaro ver5 checks drive type by this structure size.
} CDS_JPN;                                  // see above

typedef CDS_JPN UNALIGNED *PCDS_JPN;

#define curdirLen_Jpn   sizeof(CURDIR_LIST_JPN)     // Needed for
                                                    // ASM87 which doesn't allow
                                                    // Size directive as a macro
                                                    // argument

// Flag values for CURDIR_FLAGS

#define CURDIR_ISNET    0x8000
#define CURDIR_ISIFS    0x8000
#define CURDIR_INUSE    0x4000
#define CURDIR_SPLICE   0x2000
#define CURDIR_LOCAL    0x1000

#define CURDIR_TOSYNC   0x0800              // Directory path to be sync added
#define CURDIR_NT_FIX   0x0400              // fixed disk (includes NETWORK
                                            // drives. Used in $Current_dir perf
                                            // work.



/* XLATOFF */
typedef CDS     UNALIGNED *PCDS;
typedef CDS_JPN UNALIGNED *PCDS_JPN;
/* XLATON */

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\fax\wowfaxui\wowfaxui.h ===
//****************************************************************************
// Generic Win 3.1 fax printer driver support
//
//    02-jan-95   nandurir   created.
//    14-mar-95   reedb      Use GDI hooks to move most functionality to UI.
//    16-aug-95   reedb      Move to kernel mode. Many declarations and
//                              definitions moved from FAXCOMM.H to this file.
//
//****************************************************************************

#include "stddef.h"
#include "windows.h"
#include "winddi.h"

#include "faxcomm.h"
#include "winspool.h"

// The following include is to pickup the definitions for
// the DrvUpgradePrinter private API. These definitions should be in public.

#include <splapip.h>

// WOWFAX component file names.
#define WOWFAX_DLL_NAME L"WOWFAX.DLL"
#define WOWFAXUI_DLL_NAME L"WOWFAXUI.DLL"

// String table constants:
#define WOWFAX_MAX_USER_MSG_LEN 256
 
#define WOWFAX_UNKNOWN_PROB_STR  0x100
#define WOWFAX_NAME_STR          0x101
#define WOWFAX_NOWOW_STR         0x102
#define WOWFAX_SELF_CONFIG_STR   0x103
#define WOWFAX_ENABLE_CONFIG_STR 0x104

// Dialog constants:
#define IDD_NULLPROP            0x200
#define IDD_DOCPROP             0x201

// Text control constants:
#define IDC_STATIC                 -1
#define IDC_FEEDBACK            0x300

// InterProcCommHandler command constants
#define DRVFAX_SETMAPDATA    0x1
#define DRVFAX_SENDTOWOW     0x2
#define DRVFAX_SENDNOTIFYWOW 0x3
#define DRVFAX_CREATEMAP     0x4
#define DRVFAX_DESTROYMAP    0x5
#define DRVFAX_CALLWOW       0x6

// Logging macros
/* XLATOFF */
// #define IFLOG(l)    if (l==iFaxLogLevel && (iFaxLogLevel&1) || l<=iFaxLogLevel && !(iFaxLogLevel&1) || l == 0)

#undef  LOG
#ifdef  NOLOG
#define LOG(l,args)
#define SETREQLOG(l)
#else
#define SETREQLOG(l) iReqFaxLogLevel = l
#define LOG(l,args)  {SETREQLOG(l) ; faxlogprintf args;}
#endif

#if  DBG
extern INT iReqFaxLogLevel;
#define LOGDEBUG(l,args) LOG(l,args)
#else
#define LOGDEBUG(l,args)
#endif
/* XLATON */


//
// This structure is used to hold 16-bit fax driver data  stored
// in the registry.
//

typedef  struct _REGFAXDRVINFO16 {
    LPTSTR lpDeviceName;
    LPTSTR lpDriverName;
    LPTSTR lpPortName;
} REGFAXDRVINFO16, *LPREGFAXDRVINFO16;

// The the escapes in the following escape range all need a valid HDC.
// Range is inclusive lower, exclusive upper bound. See GDISPOOL.H for
// the actual escape definitions.

#define DOCUMENTEVENT_HDCFIRST      5
#define DOCUMENTEVENT_HDCLAST      11

// Prototypes for public functions implemented in WFSHEETS.C:
PVOID MyGetPrinter(HANDLE hPrinter, DWORD level);

// Prototypes for public functions implemented in WFUPGRAD.C:

BOOL DoUpgradePrinter(DWORD dwLevel, LPDRIVER_UPGRADE_INFO_1W lpDrvUpgradeInfo);

// Prototypes for public functions implemented in WFHELPERS.C:

LPREGFAXDRVINFO16 Get16BitDriverInfoFromRegistry(PWSTR pDeviceName);

VOID   faxlogprintf(LPTSTR pszFmt, ...);
VOID   LogFaxDev(LPTSTR pszTitle, LPFAXDEV lpFaxDev);
VOID   LogWowFaxInfo(LPWOWFAXINFO lpWowFaxInfo);
BOOL   ValidateFaxDev(LPFAXDEV lpFaxDev);
VOID   Free16BitDriverInfo(LPREGFAXDRVINFO16 lpRegFaxDrvInfo16);
BOOL   FaxMapHandler(LPFAXDEV lpdev, UINT iAction);
BOOL   InterProcCommHandler(LPFAXDEV lpdev, UINT iAction);
LPVOID WFHeapAlloc(DWORD dwBytes, LPWSTR lpszWhoCalled);
LPVOID WFLocalAlloc(DWORD dwBytes, LPWSTR lpszWhoCalled);
HWND   FindWowFaxWindow(void);
LPTSTR DupTokenW(LPTSTR lpTok);

// Prototypes for functions which DrvDocumentEvent dispatches,
// implemented in WOWFAXUI.C:

int DocEvntCreateDCpre(
    LPWSTR      lpszDevice,
    DEVMODEW    *pDevModIn,
    DEVMODEW    **pDevModOut
);

int DocEvntResetDCpre(
    HDC         hdc,
    DEVMODEW    *pDevModIn,
    DEVMODEW    **pDevModOut
);

int DocEvntCreateDCpost(
    HDC         hdc,
    DEVMODEW    *pDevModIn
);

int DocEvntResetDCpost(
    HDC         hdc,
    DEVMODEW    *pDevModIn
);

int DocEvntStartDoc(
    HDC      hdc,
    DOCINFOW *pDocInfoW
);

int DocEvntDeleteDC(
    HDC hdc
);

int DocEvntEndPage(
    HDC hdc
);

int DocEvntEndDoc(
HDC hdc
);

//
// Memory allocation macro.
//

#if  DBG
#define WFLOCALALLOC(dwBytes, lpszWhoCalled) WFLocalAlloc(dwBytes, lpszWhoCalled)
#else
#define WFLOCALALLOC(dwBytes, lpszWhoCalled) LocalAlloc(LPTR, dwBytes)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\cmdsvc.h ===
/* command.h - This file has all the defines and data structures needed
 *	       for command.com/command.dll communication.
 *
 * Sudeepb 17-Sep-1991 Created
 */

/* ASM
include bop.inc

CMDSVC	macro	func
	BOP	BOP_CMD
	db	func
	endm
*/

#define SVC_CMDEXITVDM		0
#define SVC_CMDGETNEXTCMD	1
#define	SVC_CMDCOMSPEC		2
#define SVC_CMDSAVEWORLD	3
#define SVC_CMDGETCURDIR	4
#define SVC_CMDSETINFO          5
#define SVC_GETSTDHANDLE        6
#define SVC_CMDCHECKBINARY      7
#define SVC_CMDEXEC             8
#define SVC_CMDINITCONSOLE      9
#define SVC_EXECCOMSPEC32       10
#define SVC_RETURNEXITCODE      11
#define SVC_GETCONFIGSYS        12
#define SVC_GETAUTOEXECBAT      13
#define SVC_GETKBDLAYOUT        14
#define SVC_GETINITENVIRONMENT  15
#define SVC_GETSTARTINFO        16
#define SVC_SETWINTITLE         17
#define SVC_GETCURSORPOS        30
#define SVC_CMDLASTSVC          31

#define ALL_HANDLES	7
#define HANDLE_STDIN	0
#define HANDLE_STDOUT	1
#define HANDLE_STDERR	2
#define MASK_STDIN	1
#define MASK_STDOUT	2
#define MASK_STDERR     4


// define extention type for command.com.
// these value must be in sync with 16bits. Please refer to
// tmisc1.asm in mvdm\dos\v86\cmd\command
#define BAD_EXTENTION	    0	    // never returned from 32 bits
#define BAT_EXTENTION	    2
#define EXE_EXTENTION	    4
#define COM_EXTENTION	    8
#define MAX_STD_EXTENTION   COM_EXTENTION

// THIS VALUE IS VERY IMPORTANT.
// 0(zero) means there is no such a program file and command.com would spit out
// well-known "bad command or file name".
// Give it to any value larger than than MAX_STD_EXTENTION) makes command.com
// by-passing any other checking and passing down the program file as is
// to DOS which doesn't have tight executable file extention convention.
// The reason that we allow program file with "non-standard" extention to
// pass through command.com and reach DOS is we receive the program pathname
// from CreateProcess which doesn't limit any file extention.
//


#define UNKNOWN_EXTENTION   MAX_STD_EXTENTION + 1


/* XLATOFF */

typedef struct _SAVEWORLD {
    USHORT  ax;
    USHORT  bx;
    USHORT  cx;
    USHORT  dx;
    USHORT  cs;
    USHORT  ss;
    USHORT  ds;
    USHORT  es;
    USHORT  si;
    USHORT  di;
    USHORT  bp;
    USHORT  sp;
    USHORT  ip;
    USHORT  flag;
    ULONG   ImageSize;
} SAVEWORLD, *PSAVEWORLD;

extern VOID CMDInit (VOID);
extern BOOL CMDRebootVDM (void);

extern BOOL fEnableInt10;

/* XLATON */

/** CMDINFO - Communication record of command.com **/

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _CMDINFO {		/**/
    USHORT	EnvSeg;
    USHORT	EnvSize;
    USHORT	CurDrive;
    USHORT	NumDrives;
    USHORT	CmdLineSeg;
    USHORT	CmdLineOff;
    USHORT	CmdLineSize;
    USHORT	ReturnCode;
    USHORT      bStdHandles;
    ULONG       pRdrInfo;
    USHORT	CodePage;
    USHORT      fTSRExit;
    USHORT      fBatStatus;
    USHORT      ExecPathSeg;
    USHORT      ExecPathOff;
    USHORT      ExecPathSize;
    USHORT	ExecExtType;
} CMDINFO;
typedef CMDINFO UNALIGNED *PCMDINFO;

/* XLATOFF */
#pragma pack()
/* XLATON */


BOOL CmdDispatch (ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\dbginfo.h ===
typedef struct _vdminternalinfo {
    DWORD           dwLdtBase;
    DWORD           dwLdtLimit;
    DWORD           dwIntelBase;
    DWORD           dwReserved;
    WORD            wKernelSeg;
    DWORD           dwOffsetTHHOOK;
    LPVOID          vdmContext;
    LPVOID          lpRemoteAddress;
    DWORD           lpRemoteBlock;
    BOOL            f386;
    LPVOID          lpNtvdmState;
    LPVOID          lpVdmDbgFlags;
    LPVOID          lpNtCpuInfo;
    LPVOID          lpVdmBreakPoints;
} VDMINTERNALINFO;
typedef VDMINTERNALINFO *LPVDMINTERNALINFO;


#define MAX_VDM_BREAKPOINTS 16
#define VDM_TEMPBP 0
typedef struct _VDM_BREAKPOINT {   /* VDMBP */
    BYTE  Flags;
    BYTE  Opcode;
    WORD  Count;
    WORD  Seg;
    DWORD Offset;
} VDM_BREAKPOINT;

//
// Bits defined in Flags
//
#define VDMBP_SET     0x01
#define VDMBP_ENABLED 0x02
#define VDMBP_FLUSH   0x04
#define VDMBP_PENDING 0x08
#define VDMBP_V86     0x10


typedef struct _com_header {
    DWORD           dwBlockAddress;
    DWORD           dwReturnValue;
    WORD            wArgsPassed;
    WORD            wArgsSize;
    WORD            wBlockLength;
    WORD            wSuccess;
} COM_HEADER;
typedef COM_HEADER FAR *LPCOM_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\dbgsvc.h ===
/** SVC Defines
 *
 *  Revision history:
 *
 *  bobday 13-Jan-1992 Created
 */


/* DBGSVC - DBG SVC calls.
 *
 *   This macro is used by Nlddebug.asm (where N=nothing or 2)
 *
 */

/* ASM
include bop.inc

dbgsvc  macro   func
    BOP BOP_DEBUGGER
    db  func
    endm
*/

//
// Debug event codes
// These need to match the public definition in sdk\inc\vdmdbg.h
//

#define DBG_SEGLOAD     0
#define DBG_SEGMOVE     1
#define DBG_SEGFREE     2
#define DBG_MODLOAD     3
#define DBG_MODFREE     4
#define DBG_SINGLESTEP  5
#define DBG_BREAK       6
#define DBG_GPFAULT     7
#define DBG_DIVOVERFLOW 8
#define DBG_INSTRFAULT  9
#define DBG_TASKSTART   10
#define DBG_TASKSTOP    11
#define DBG_DLLSTART    12
#define DBG_DLLSTOP     13
#define DBG_ATTACH      14
#define DBG_TOOLHELP    15
#define DBG_STACKFAULT  16
#define DBG_WOWINIT     17
#define DBG_TEMPBP      18
#define DBG_MODMOVE     19
#define DBG_INIT        20
#define DBG_GPFAULT2    21

//
// Flags used by DemIsDebug
//
#define ISDBG_DEBUGGEE 1
#define ISDBG_SHOWSVC  2


void
DbgSegmentNotice(
    WORD wType,
    WORD  wModuleSeg,
    WORD  wLoadSeg,
    WORD  wNewSeg,
    LPSTR lpModuleName,
    LPSTR lpModulePath,
    DWORD dwImageLen
    );

BOOL
DbgIsDebuggee(
    void
    );

BOOL
DbgInit(
    void
    );

VOID DbgDosAppStart(WORD, WORD);
BOOL DbgBPInt(VOID);
BOOL DbgTraceInt(VOID);
BOOL DbgFault(ULONG);
VOID VdmPrompt(ULONG, ULONG);
VOID VdmTraceEvent(USHORT, USHORT, ULONG);

/* XLATOFF */
#if DBG

#define DBGTRACE(Type, wData, lData) VdmTraceEvent(Type, wData, lData)

#else

#define DBGTRACE(Type, wData, lData) {}

#endif

/* XLATON */

//
// Events for DbgPrompt()
//
#define DBG_EVENT_HW_INT    1
#define DBG_EVENT_SW_INT    2

//
// Definitions for VdmTraceEvent major code types
//

#define VDMTR_TYPE_KERNEL   0
#define VDMTR_TYPE_DPMI     0x100
#define VDMTR_TYPE_DPMI_SF  0x200
#define VDMTR_TYPE_DPMI_SI  0x300
#define VDMTR_TYPE_DEM      0x400
#define VDMTR_TYPE_WOW      0x500
#define VDMTR_TYPE_VSBD     0x600
#define VDMTR_TYPE_DBG      0x700
#define VDMTR_TYPE_MONITOR  0x800


//
// Definitions for VdmTraceEvent minor code types
//

#define DPMI_SWITCH_STACKS          1
#define DPMI_GENERIC                2
#define DPMI_DISPATCH_INT           3
#define DPMI_HW_INT                 4
#define DPMI_SW_INT                 5
#define DPMI_INT_IRET16             6
#define DPMI_INT_IRET32             7
#define DPMI_FAULT                  8
#define DPMI_DISPATCH_FAULT         9
#define DPMI_FAULT_IRET             10
#define DPMI_OP_EMULATION           11
#define DPMI_DISPATCH_ENTRY         12
#define DPMI_IN_PM                  13
#define DPMI_IN_V86                 14
#define DPMI_DISPATCH_EXIT          15
#define DPMI_REFLECT_TO_V86         16
#define DPMI_REFLECT_TO_PM          17

#define DEM_EVENT_DISPATCH          1
#define DEM_EVENT_DISPATCH_EXIT     2

#define MONITOR_EVENT_IO            1
#define MONITOR_EVENT_STRING_IO     2
#define MONITOR_EVENT_MEM_ACCESS    3
#define MONITOR_EVENT_INT_ACK       4
#define MONITOR_EVENT_BOP           5
#define MONITOR_EVENT_ERROR         6
#define MONITOR_EVENT_IRQ_13        7
#define MONITOR_CPU_SIMULATE        8
#define MONITOR_CPU_UNSIMULATE      9
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\apistruc.h ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1990               **/
/*****************************************************************/
/***    apistruc.h
 *
 *      This file contains the structure definitions used to pass parameters
 *      to the loadable APIs in the REDIR 1.5 project
 *
 *      CONTENTS        tr_packet
 *                      NetWkstaSetUIDStruc
 *                      NetWkstaLogonStruc
 *                      NetWkstaReLogonStruc
 *                      NetSpecialSMBStruc
 *                      NetRemoteCopyStruc
 *                      NetMessageBufferSendStruc
 *                      NetMessageNameGetInfoStruc
 *                      NetServiceControlStruc
 *                      NetUseGetInfoStruc
 */

struct tr_packet {
        char FAR *      tr_name;        /* UNC Machine/Transaction name */
        char FAR *      tr_passwd;      /* password */
        char FAR *      tr_spbuf;       /* Send parameter buffer address */
        char FAR *      tr_sdbuf;       /* Send data buffer address */
        char FAR *      tr_rsbuf;       /* Receive set up buffer address */
        char FAR *      tr_rpbuf;       /* Receive parameter buffer address */
        char FAR *      tr_rdbuf;       /* Receive data buffer address */
        unsigned short  tr_splen;       /* Number of send parameter bytes */
        unsigned short  tr_sdlen;       /* Number of send data bytes */
        unsigned short  tr_rplen;       /* Number of receive parameter bytes */
        unsigned short  tr_rdlen;       /* Number of receive data bytes */
        unsigned short  tr_rslen;       /* Number of receive set up bytes */
        unsigned short  tr_flags;       /* Flags */
        unsigned long   tr_timeout;     /* Timeout */
        unsigned short  tr_resvd;       /* RESERVED (MBZ) */
        unsigned short  tr_sslen;       /* Number of send set up bytes */
};/* tr_packet */

/* data structure to simulate Transaction2 SMB.
 */
struct tr2_packet {
        char FAR *      tr2_name;       /* UNC Machine/Transaction name */
        char FAR *      tr2_passwd;     /* password */
        char FAR *      tr2_spbuf;      /* Send parameter buffer address */
        char FAR *      tr2_sdbuf;      /* Send data buffer address */
        char FAR *      tr2_rsbuf;      /* Receive set up buffer address */
        char FAR *      tr2_rpbuf;      /* Receive parameter buffer address */
        char FAR *      tr2_rdbuf;      /* Receive data buffer address */
        unsigned short  tr2_splen;      /* Number of send parameter bytes */
        unsigned short  tr2_sdlen;      /* Number of send data bytes */
        unsigned short  tr2_rplen;      /* Number of receive parameter bytes */
        unsigned short  tr2_rdlen;      /* Number of receive data bytes */
        unsigned short  tr2_rslen;      /* Number of receive set up bytes */
        unsigned short  tr2_flags;      /* Flags */
        unsigned long   tr2_timeout;    /* Timeout */
        unsigned short  tr2_resvd;      /* RESERVED (MBZ) */
        unsigned short  tr2_sslen;      /* Number of send set up bytes */
        unsigned short  tr2_trancode;   /* Transaction code for T2 SMB */
};/* tr2_packet */

struct NetWkstaSetUIDStruc {
        const char FAR *        su_username; /* username to log on/off */
        const char FAR *        su_password; /* password */
        const char FAR *        su_parms; /* OEM-specific parameter string */
};/* NetWkstaSetUIDStruc */

struct NetWkstaLogonStruc {
        char FAR *      ln_username;    /* new user name */
        char FAR *      ln_password;    /* new password */
        char FAR *      ln_parms;       /* OEM-specific parameter string */
        long FAR *      ln_uid;         /* UID returned here */
        char FAR *      ln_buffer;      /* buffer for passkey */
        unsigned short  ln_buflen;      /* length of passkey buffer */
};/* NetWkstaLogonStruc */

struct NetWkstaReLogonStruc {
        char FAR *      rl_username;    /* user name to re-log on */
        char FAR *      rl_password;    /* password to use in re-log on */
        char FAR *      rl_parms;       /* OEM-specific parameters */
        char FAR *      rl_buffer;      /* passkey buffer */
        unsigned short  rl_buflen;      /* length of passkey */
};/* NetWkstaReLogonStruc */

struct NetSpecialSMBStruc {
        char FAR *      sp_uncname;     /* UNC session name for SMB */
        char FAR *      sp_reqbuf;      /* Send SMB request buffer */
        unsigned short  sp_reqlen;      /* Length of send buffer */
        char FAR *      sp_rspbuf;      /* Receive SMB response buffer */
        unsigned short  sp_rsplen;      /* Length of receive buffer */
};/* NetSpecialSMBStruc */

struct NetRemoteCopyStruc {
        char FAR *      sourcepath;     /* ASCIIZ fully specified source path */
        char FAR *      destpath;       /* ASCIIZ fully specified dest path */
        char FAR *      sourcepass;     /* password for source path (NULL for default) */
        char FAR *      destpass;       /* password for dest path (NULL for default) */
        unsigned short  openflags;      /* flags for open of destpath */
        unsigned short  copyflags;      /* flags to control the copy */
        char FAR *      buf;            /* buffer to return error text in */
        unsigned short  buflen;         /* size of buffer on call */
};/* NetRemoteCopyStruc */


struct NetMessageBufferSendStruc {
    char FAR *          NMBSS_NetName;  /* asciz net name. */
    char FAR *          NMBSS_Buffer;   /* pointer to buffer. */
    unsigned int        NMBSS_BufSize;  /* size of buffer. */

}; /* NetMessageBufferSendStruc */

struct NetMessageNameGetInfoStruc {
    const char FAR *    NMNGIS_NetName; /* ASCIZ net name */
    char FAR *          NMNGIS_Buffer;  /* Pointer to buffer */
    unsigned int        NMNGIS_BufSize; /* Buffer size */
}; /* NetMessageNameGetInfoStruc */

struct NetServiceControlStruc {
    char FAR *          NSCS_Service;   /* Service name */
    unsigned short      NSCS_BufLen;    /* Buffer length */
    char FAR *          NSCS_BufferAddr;/* Buffer address */
};      /* NetServiceControlStruc */

struct NetUseGetInfoStruc {
        const char FAR* NUGI_usename;   /* ASCIZ redirected device name */
        short           NUGI_level;     /* level of info */
        char FAR*       NUGI_buffer;    /* buffer for returned info */
        unsigned short  NUGI_buflen;    /* size of buffer */
}; /* NetUseGetInfoStruc */

struct  DosWriteMailslotStruct {
    unsigned long DWMS_Timeout;         /* Timeout value of search */
    const char FAR *DWMS_Buffer;        /* Buffer address for mailslot write*/
}; /* DosWriteMailslotStruct */

struct  NetServerEnum2Struct {
    short          NSE_level;   /* level of information to be returned */
    char FAR      *NSE_buf;     /* buffer to contain returned info */
    unsigned short NSE_buflen;  /* number of bytes available in buffer */
    unsigned long  NSE_type;    /* bitmask of types to find */
    char FAR      *NSE_domain;  /* return servers in this domain */
}; /* NetServerEnum2Struct */

struct I_CDNames {
    char FAR      *CDN_pszComputer;
    char FAR      *CDN_pszPrimaryDomain;
    char FAR      *CDN_pszLogonDomain;
}; /* I_CDNames */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\dbgexp.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991,1992 Microsoft Corporation
 *
 *  DBGEXP.H
 *  DBG exports
 *
 *  History:
 *  13-Jan-1992 Bob Day (bobday)
 *  Created.
--*/

extern BOOL DBGInit( VOID );
extern VOID DBGDispatch( VOID );
extern VOID DBGNotifyNewTask( LPVOID pNTFrame, UINT uFrameSize );
extern VOID DBGNotifyRemoteThreadAddress( LPVOID lpAddress, DWORD lpBlock );
extern VOID DBGNotifyDebugged( BOOL fDebugged );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\demexp.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  DEMEXP.H
 *  DOS emulation exports
 *
 *  History:
 *  22-Apr-1991 Sudeep Bharati (sudeepb)
 *  Created.
--*/

VOID DemInit (VOID);
BOOL DemDispatch(ULONG iSvc);
VOID demCloseAllPSPRecords (VOID);
DWORD demFileDelete (LPSTR lpFile);
DWORD demFileFindFirst (PVOID pDTA, LPSTR lpFile, USHORT usSearchAttr);
DWORD demFileFindNext (PVOID pDTA);
ULONG demClientErrorEx (HANDLE hFile, CHAR chDrive, BOOL bSetRegs);
UCHAR demGetPhysicalDriveType(UCHAR DriveNum);
ULONG demWOWLFNEntry(PVOID pUserFrame);

#define SIZEOF_DOSSRCHDTA 43

#if DEVL
// bit masks to control trace info
#define DEMDOSAPPBREAK 0x80000000
#define DEMDOSDISP     0x40000000
#define DEMFILIO       0x20000000
#define DEMSVCTRACE    0x10000000
#define KEEPBOOTFILES  0x01000000  // if set, no delete temp boot files
#define DEM_ABSDRD     0x02000000
#define DEM_ABSWRT     0x04000000
#define DEMERROR       0x08000000

extern DWORD  fShowSVCMsg;
#endif

#ifdef FE_SB
#define NTIO_411 "\\ntio411.sys"        // LANG_JAPANESE
#define NTIO_409 "\\ntio.sys"           //
#define NTIO_804 "\\ntio804.sys"        // LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED or SUBLANG_CHINESE_HONGKONG
#define NTIO_404 "\\ntio404.sys"        // LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL
#define NTIO_412 "\\ntio412.sys"        // LANG_KOREAN

#define NTDOS_411 "\\ntdos411.sys"      // LANG_JAPANESE
#define NTDOS_409 "\\ntdos.sys"         //
#define NTDOS_804 "\\ntdos804.sys"      // LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED or SUBLANG_CHINESE_HONGKONG
#define NTDOS_404 "\\ntdos404.sys"      // LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL
#define NTDOS_412 "\\ntdos412.sys"      // LANG_KOREAN
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\dpmf_fio.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 2002, Microsoft Corporation
 *
 *  dpmf_fio.h
 *  NTVDM Dynamic Patch Module to support File I/O API family
 *  Definitions & macors to support calls into dpmffio.dll
 *
 *  History:
 *  Created 01-25-2002 by cmjones
--*/
#ifndef _DPMF_FIOAPI_H_
#define _DPMF_FIOAPI_H_ 

#define FIOPFT               (DPMFAMTBLS()[FIO_FAM])
#define FIO_SHIM(ord,typ)    ((typ)((pFT)->pDpmShmTbls[ord]))

// The order of this list must be the same as the lists below
enum FioFam {DPM_OPENFILE=0,         // Win 3.1 set
             DPM__LCLOSE,
             DPM__LOPEN,
             DPM__LCREAT,
             DPM__LLSEEK,
             DPM__LREAD,
             DPM__LWRITE,
             DPM__HREAD,
             DPM__HWRITE,
             DPM_GETTEMPFILENAME,   // End Win 3.1 Set
             DPM_AREFILEAPISANSI,   // Start Win 9x API set
             DPM_CANCELIO,
             DPM_CLOSEHANDLE,
             DPM_COPYFILE,
             DPM_COPYFILEEX,
             DPM_CREATEDIRECTORY,
             DPM_CREATEDIRECTORYEX,
             DPM_CREATEFILE,
             DPM_DELETEFILE,
             DPM_FINDCLOSE,
             DPM_FINDCLOSECHANGENOTIFICATION,
             DPM_FINDFIRSTCHANGENOTIFICATION,
             DPM_FINDFIRSTFILE,
             DPM_FINDNEXTCHANGENOTIFICATION,
             DPM_FINDNEXTFILE,
             DPM_FLUSHFILEBUFFERS,
             DPM_GETCURRENTDIRECTORY,
             DPM_GETDISKFREESPACE,
             DPM_GETDISKFREESPACEEX,
             DPM_GETDRIVETYPE,
             DPM_GETFILEATTRIBUTES,
             DPM_GETFILEATTRIBUTESEX,
             DPM_GETFILEINFORMATIONBYHANDLE,
             DPM_GETFILESIZE,
             DPM_GETFILETYPE,
             DPM_GETFULLPATHNAME,
             DPM_GETLOGICALDRIVES,
             DPM_GETLOGICALDRIVESTRINGS,
             DPM_GETLONGPATHNAME,
             DPM_GETSHORTPATHNAME,
             DPM_GETTEMPPATH,
             DPM_LOCKFILE,
             DPM_MOVEFILE,
             DPM_MOVEFILEEX,
             DPM_QUERYDOSDEVICE,
             DPM_READFILE,
             DPM_READFILEEX,
             DPM_REMOVEDIRECTORY,
             DPM_SEARCHPATH,
             DPM_SETCURRENTDIRECTORY,
             DPM_SETENDOFFILE,
             DPM_SETFILEAPISTOANSI,
             DPM_SETFILEAPISTOOEM,
             DPM_SETFILEATTRIBUTES,
             DPM_SETFILEPOINTER,
             DPM_SETVOLUMELABEL,
             DPM_UNLOCKFILE,
             DPM_WRITEFILE,
             DPM_WRITEFILEEX,
             DPM_GETTEMPFILENAMEW,             // Wide char versions for
             DPM_COPYFILEW,                    // generic thunk support
             DPM_COPYFILEEXW,
             DPM_CREATEDIRECTORYW,
             DPM_CREATEDIRECTORYEXW,
             DPM_CREATEFILEW,
             DPM_DELETEFILEW,
             DPM_FINDFIRSTFILEW,
             DPM_FINDNEXTFILEW,
             DPM_GETCURRENTDIRECTORYW,
             DPM_GETDISKFREESPACEW,
             DPM_GETDISKFREESPACEEXW,
             DPM_GETDRIVETYPEW,
             DPM_GETFILEATTRIBUTESW,
             DPM_GETFILEATTRIBUTESEXW,
             DPM_GETFULLPATHNAMEW,
             DPM_GETLOGICALDRIVESTRINGSW,
             DPM_GETLONGPATHNAMEW,
             DPM_GETSHORTPATHNAMEW,
             DPM_GETTEMPPATHW,
             DPM_MOVEFILEW,
             DPM_MOVEFILEEXW,
             DPM_QUERYDOSDEVICEW,
             DPM_REMOVEDIRECTORYW,
             DPM_SEARCHPATHW,
             DPM_SETCURRENTDIRECTORYW,
             DPM_SETFILEATTRIBUTESW,
             DPM_SETVOLUMELABELW,
             enum_Fio_last};
//             DPM_FILEIOCOMPLETIONROUTINE,  // application defined


// These types will catch misuse of parameters & ret types
typedef HFILE(*typdpmOpenFile)(LPCSTR, LPOFSTRUCT, UINT);
typedef HFILE(*typdpm_lclose)(HFILE);
typedef HFILE(*typdpm_lopen)(LPCSTR, int);
typedef HFILE(*typdpm_lcreat)(LPCSTR, int);
typedef LONG(*typdpm_llseek)(HFILE, LONG, int);
typedef UINT(*typdpm_lread)(HFILE, LPVOID, UINT);
typedef UINT(*typdpm_lwrite)(HFILE, LPCSTR, UINT);
typedef long(*typdpm_hread)(HFILE, LPVOID, long);
typedef long(*typdpm_hwrite)(HFILE, LPCSTR, long);
typedef UINT(*typdpmGetTempFileNameA)(LPCSTR, LPCSTR, UINT, LPSTR);
typedef BOOL(*typdpmAreFileApisANSI)(VOID);
typedef BOOL(*typdpmCancelIo)(HANDLE);
typedef BOOL(*typdpmCloseHandle)(HANDLE);
typedef BOOL(*typdpmCopyFileA)(LPCSTR, LPCSTR, BOOL);
typedef BOOL(*typdpmCopyFileExA)(LPCSTR, LPCSTR, LPPROGRESS_ROUTINE, LPVOID, LPBOOL, DWORD);
typedef BOOL(*typdpmCreateDirectoryA)(LPCSTR, LPSECURITY_ATTRIBUTES); 
typedef BOOL(*typdpmCreateDirectoryExA)(LPCSTR, LPCSTR, LPSECURITY_ATTRIBUTES);
typedef HANDLE(*typdpmCreateFileA)(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
typedef BOOL(*typdpmDeleteFileA)(LPCSTR);
typedef BOOL(*typdpmFindClose)(HANDLE);
typedef BOOL(*typdpmFindCloseChangeNotification)(HANDLE);
typedef HANDLE(*typdpmFindFirstChangeNotificationA)(LPCSTR, BOOL, DWORD);
typedef HANDLE(*typdpmFindFirstFileA)(LPCSTR, LPWIN32_FIND_DATA);
typedef BOOL(*typdpmFindNextChangeNotification)(HANDLE);
typedef BOOL(*typdpmFindNextFileA)( HANDLE, LPWIN32_FIND_DATA);
typedef BOOL(*typdpmFlushFileBuffers)(HANDLE);
typedef DWORD(*typdpmGetCurrentDirectoryA)(DWORD, LPSTR);
typedef BOOL(*typdpmGetDiskFreeSpaceA)(LPCSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD);
typedef BOOL(*typdpmGetDiskFreeSpaceExA)(LPCSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);
typedef UINT(*typdpmGetDriveTypeA)(LPCSTR);
typedef DWORD(*typdpmGetFileAttributesA)(LPCSTR);
typedef BOOL(*typdpmGetFileAttributesExA)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
typedef BOOL(*typdpmGetFileInformationByHandle)(HANDLE, LPBY_HANDLE_FILE_INFORMATION);
typedef DWORD(*typdpmGetFileSize)(HANDLE, LPDWORD);
typedef DWORD(*typdpmGetFileType)(HANDLE);
typedef DWORD(*typdpmGetFullPathNameA)(LPCSTR, DWORD, LPSTR, LPSTR *);
typedef DWORD(*typdpmGetLogicalDrives)(VOID);
typedef DWORD(*typdpmGetLogicalDriveStringsA)(DWORD, LPSTR);
typedef DWORD(*typdpmGetLongPathNameA)(LPCSTR, LPSTR, DWORD);
typedef DWORD(*typdpmGetShortPathNameA)(LPCSTR, LPSTR, DWORD);
typedef DWORD(*typdpmGetTempPathA)(DWORD, LPSTR);
typedef BOOL(*typdpmLockFile)(HANDLE, DWORD, DWORD, DWORD, DWORD);
typedef BOOL(*typdpmMoveFileA)(LPCSTR, LPCSTR);
typedef BOOL(*typdpmMoveFileExA)(LPCSTR, LPCSTR, DWORD);
typedef DWORD(*typdpmQueryDosDeviceA)(LPCSTR, LPSTR, DWORD);
typedef BOOL(*typdpmReadFile)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
typedef BOOL(*typdpmReadFileEx)(HANDLE, LPVOID, DWORD, LPOVERLAPPED, LPOVERLAPPED_COMPLETION_ROUTINE);
typedef BOOL(*typdpmRemoveDirectoryA)(LPCSTR);
typedef DWORD(*typdpmSearchPathA)(LPCSTR, LPCSTR, LPCSTR, DWORD, LPSTR, LPSTR *);
typedef BOOL(*typdpmSetCurrentDirectoryA)(LPCSTR);
typedef BOOL(*typdpmSetEndOfFile)(HANDLE);
typedef VOID(*typdpmSetFileApisToANSI)(VOID);
typedef VOID(*typdpmSetFileApisToOEM)(VOID);
typedef BOOL(*typdpmSetFileAttributesA)(LPCSTR, DWORD);
typedef DWORD(*typdpmSetFilePointer)(HANDLE, LONG, PLONG, DWORD);
typedef BOOL(*typdpmSetVolumeLabelA)(LPCSTR, LPCSTR);
typedef BOOL(*typdpmUnlockFile)(HANDLE, DWORD, DWORD, DWORD, DWORD);
typedef BOOL(*typdpmWriteFile)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED);
typedef BOOL(*typdpmWriteFileEx)(HANDLE, LPCVOID, DWORD, LPOVERLAPPED, LPOVERLAPPED_COMPLETION_ROUTINE);

typedef UINT(*typdpmGetTempFileNameW)(LPCWSTR, LPCWSTR, UINT, LPWSTR);
typedef BOOL(*typdpmCopyFileW)(LPCWSTR, LPCWSTR, BOOL);
typedef BOOL(*typdpmCopyFileExW)(LPCWSTR, LPCWSTR, LPPROGRESS_ROUTINE, LPVOID, LPBOOL, DWORD);
typedef BOOL(*typdpmCreateDirectoryW)(LPCWSTR, LPSECURITY_ATTRIBUTES);
typedef BOOL(*typdpmCreateDirectoryExW)(LPCWSTR, LPCWSTR, LPSECURITY_ATTRIBUTES);
typedef HANDLE(*typdpmCreateFileW)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
typedef BOOL(*typdpmDeleteFileW)(LPCWSTR);
typedef HANDLE(*typdpmFindFirstFileW)(LPCWSTR, LPWIN32_FIND_DATAW);
typedef BOOL(*typdpmFindNextFileW)( HANDLE, LPWIN32_FIND_DATAW);
typedef DWORD(*typdpmGetCurrentDirectoryW)(DWORD, LPWSTR);
typedef BOOL(*typdpmGetDiskFreeSpaceW)(LPCWSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD);
typedef BOOL(*typdpmGetDiskFreeSpaceExW)(LPCWSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);
typedef UINT(*typdpmGetDriveTypeW)(LPCWSTR);
typedef DWORD(*typdpmGetFileAttributesW)(LPCWSTR);
typedef BOOL(*typdpmGetFileAttributesExW)(LPCWSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
typedef DWORD(*typdpmGetFullPathNameW)(LPCWSTR, DWORD, LPWSTR, LPWSTR *);
typedef DWORD(*typdpmGetLogicalDriveStringsW)(DWORD, LPWSTR);
typedef DWORD(*typdpmGetLongPathNameW)(LPCWSTR, LPWSTR, DWORD);
typedef DWORD(*typdpmGetShortPathNameW)(LPCWSTR, LPWSTR, DWORD);
typedef DWORD(*typdpmGetTempPathW)(DWORD, LPWSTR);
typedef BOOL(*typdpmMoveFileW)(LPCWSTR, LPCWSTR);
typedef BOOL(*typdpmMoveFileExW)(LPCWSTR, LPCWSTR, DWORD);
typedef DWORD(*typdpmQueryDosDeviceW)(LPCWSTR, LPWSTR, DWORD);
typedef BOOL(*typdpmRemoveDirectoryW)(LPCWSTR);
typedef DWORD(*typdpmSearchPathW)(LPCWSTR, LPCWSTR, LPCWSTR, DWORD, LPWSTR, LPWSTR *);
typedef BOOL(*typdpmSetCurrentDirectoryW)(LPCWSTR);
typedef BOOL(*typdpmSetFileAttributesW)(LPCWSTR, DWORD);
typedef BOOL(*typdpmSetVolumeLabelW)(LPCWSTR, LPCWSTR);




// Macros to dispatch API calls properly
#define DPM_OpenFile(a,b,c)                                                    \
  ((typdpmOpenFile)(FIOPFT->pfn[DPM_OPENFILE]))(a,b,c)

#define DPM__lclose(a)                                                         \
  ((typdpm_lclose)(FIOPFT->pfn[DPM__LCLOSE]))(a)

#define DPM__lopen(a,b)                                                        \
  ((typdpm_lopen)(FIOPFT->pfn[DPM__LOPEN]))(a,b)

#define DPM__lcreat(a,b)                                                       \
  ((typdpm_lcreat)(FIOPFT->pfn[DPM__LCREAT]))(a,b)

#define DPM__llseek(a,b,c)                                                     \
  ((typdpm_llseek)(FIOPFT->pfn[DPM__LLSEEK]))(a,b,c)

#define DPM__lread(a,b,c)                                                      \
  ((typdpm_lread)(FIOPFT->pfn[DPM__LREAD]))(a,b,c)

#define DPM__lwrite(a,b,c)                                                     \
  ((typdpm_lwrite)(FIOPFT->pfn[DPM__LWRITE]))(a,b,c)

#define DPM__hread(a,b,c)                                                      \
  ((typdpm_hread)(FIOPFT->pfn[DPM__HREAD]))(a,b,c)

#define DPM__hwrite(a,b,c)                                                     \
  ((typdpm_hwrite)(FIOPFT->pfn[DPM__HWRITE]))(a,b,c)

#define DPM_GetTempFileName(a,b,c,d)                                           \
  ((typdpmGetTempFileNameA)(FIOPFT->pfn[DPM_GETTEMPFILENAME]))(a,b,c,d)

#define DPM_AreFileApisANSI()                                                  \
  ((typdpmAreFileApisANSI)(FIOPFT->pfn[DPM_AREFILEAPISANSI]))()

#define DPM_CancelIo(a)                                                        \
  ((typdpmCancelIo)(FIOPFT->pfn[DPM_CANCELIO]))(a)

#define DPM_CloseHandle(a)                                                     \
  ((typdpmCloseHandle)(FIOPFT->pfn[DPM_CLOSEHANDLE]))(a)

#define DPM_CopyFile(a,b,c)                                                    \
  ((typdpmCopyFileA)(FIOPFT->pfn[DPM_COPYFILE]))(a,b,c)

#define DPM_CopyFileEx(a,b,c,d,e,f)                                            \
  ((typdpmCopyFileExA)(FIOPFT->pfn[DPM_COPYFILEEX]))(a,b,c,d,e,f)

#define DPM_CreateDirectory(a,b)                                               \
  ((typdpmCreateDirectoryA)(FIOPFT->pfn[DPM_CREATEDIRECTORY]))(a,b)

#define DPM_CreateDirectoryEx(a,b,c)                                           \
  ((typdpmCreateDirectoryExA)(FIOPFT->pfn[DPM_CREATEDIRECTORYEX]))(a,b,c)

#define DPM_CreateFile(a,b,c,d,e,f,g)                                          \
  ((typdpmCreateFileA)(FIOPFT->pfn[DPM_CREATEFILE]))(a,b,c,d,e,f,g)

#define DPM_DeleteFile(a)                                                      \
  ((typdpmDeleteFileA)(FIOPFT->pfn[DPM_DELETEFILE]))(a)

#define DPM_FindClose(a)                                                       \
  ((typdpmFindClose)(FIOPFT->pfn[DPM_FINDCLOSE]))(a)

#define DPM_FindCloseChangeNotification(a)                                     \
  ((typdpmFindCloseChangeNotification)(FIOPFT->pfn[DPM_FINDCLOSECHANGENOTIFICATION]))(a)

#define DPM_FindFirstChangeNotification(a,b,c)                                 \
  ((typdpmFindFirstChangeNotificationA)(FIOPFT->pfn[DPM_FINDFIRSTCHANGENOTIFICATION]))(a,b,c)

#define DPM_FindFirstFile(a,b)                                                 \
  ((typdpmFindFirstFileA)(FIOPFT->pfn[DPM_FINDFIRSTFILE]))(a,b)

#define DPM_FindNextChangeNotification(a)                                      \
  ((typdpmFindNextChangeNotification)(FIOPFT->pfn[DPM_FINDNEXTCHANGENOTIFICATION]))(a)

#define DPM_FindNextFile(a,b)                                                  \
  ((typdpmFindNextFileA)(FIOPFT->pfn[DPM_FINDNEXTFILE]))(a,b)

#define DPM_FlushFileBuffers(a)                                                \
  ((typdpmFlushFileBuffers)(FIOPFT->pfn[DPM_FLUSHFILEBUFFERS]))(a)

#define DPM_GetCurrentDirectory(a,b)                                           \
  ((typdpmGetCurrentDirectoryA)(FIOPFT->pfn[DPM_GETCURRENTDIRECTORY]))(a,b)

#define DPM_GetDiskFreeSpace(a,b,c,d,e)                                        \
  ((typdpmGetDiskFreeSpaceA)(FIOPFT->pfn[DPM_GETDISKFREESPACE]))(a,b,c,d,e )

#define DPM_GetDiskFreeSpaceEx(a,b,c,d)                                        \
  ((typdpmGetDiskFreeSpaceExA)(FIOPFT->pfn[DPM_GETDISKFREESPACEEX]))(a,b,c,d)

#define DPM_GetDriveType(a)                                                    \
  ((typdpmGetDriveTypeA)(FIOPFT->pfn[DPM_GETDRIVETYPE]))(a)

#define DPM_GetFileAttributes(a)                                               \
  ((typdpmGetFileAttributesA)(FIOPFT->pfn[DPM_GETFILEATTRIBUTES]))(a)

#define DPM_GetFileAttributesEx(a,b,c)                                         \
  ((typdpmGetFileAttributesExA)(FIOPFT->pfn[DPM_GETFILEATTRIBUTESEX]))(a,b,c)

#define DPM_GetFileInformationByHandle(a,b)                                    \
  ((typdpmGetFileInformationByHandle)(FIOPFT->pfn[DPM_GETFILEINFORMATIONBYHANDLE]))(a,b)

#define DPM_GetFileSize(a,b)                                                   \
  ((typdpmGetFileSize)(FIOPFT->pfn[DPM_GETFILESIZE]))(a,b)

#define DPM_GetFileType(a)                                                     \
 ((typdpmGetFileType)(FIOPFT->pfn[DPM_GETFILETYPE]))(a)

#define DPM_GetFullPathName(a,b,c,d)                                           \
 ((typdpmGetFullPathNameA)(FIOPFT->pfn[DPM_GETFULLPATHNAME]))(a,b,c,d)

#define DPM_GetLogicalDrives()                                                 \
 ((typdpmGetLogicalDrives)(FIOPFT->pfn[DPM_GETLOGICALDRIVES]))()

#define DPM_GetLogicalDriveStrings(a,b)                                        \
 ((typdpmGetLogicalDriveStringsA)(FIOPFT->pfn[DPM_GETLOGICALDRIVESTRINGS]))(a,b)

#define DPM_GetLongPathName(a,b,c)                                             \
 ((typdpmGetLongPathNameA)(FIOPFT->pfn[DPM_GETLONGPATHNAME]))(a,b,c)

#define DPM_GetShortPathName(a,b,c)                                            \
 ((typdpmGetShortPathNameA)(FIOPFT->pfn[DPM_GETSHORTPATHNAME]))(a,b,c)

#define DPM_GetTempPath(a,b)                                                   \
 ((typdpmGetTempPathA)(FIOPFT->pfn[DPM_GETTEMPPATH]))(a,b)

#define DPM_LockFile(a,b,c,d,e)                                                \
 ((typdpmLockFile)(FIOPFT->pfn[DPM_LOCKFILE]))(a,b,c,d,e)

#define DPM_MoveFile(a,b)                                                      \
 ((typdpmMoveFileA)(FIOPFT->pfn[DPM_MOVEFILE]))(a,b)

#define DPM_MoveFileEx(a,b,c)                                                  \
 ((typdpmMoveFileExA)(FIOPFT->pfn[DPM_MOVEFILEEX]))(a,b,c)

#define DPM_QueryDosDevice(a,b,c)                                              \
 ((typdpmQueryDosDeviceA)(FIOPFT->pfn[DPM_QUERYDOSDEVICE]))(a,b,c)

#define DPM_ReadFile(a,b,c,d,e)                                                \
   ((typdpmReadFile)(FIOPFT->pfn[DPM_READFILE]))(a,b,c,d,e)

#define DPM_ReadFileEx(a,b,c,d,e)                                              \
 ((typdpmReadFileEx)(FIOPFT->pfn[DPM_READFILEEX]))(a,b,c,d,e)

#define DPM_RemoveDirectory(a)                                                 \
 ((typdpmRemoveDirectoryA)(FIOPFT->pfn[DPM_REMOVEDIRECTORY]))(a)

#define DPM_SearchPath(a,b,c,d,e,f)                                            \
 ((typdpmSearchPathA)(FIOPFT->pfn[DPM_SEARCHPATH]))(a,b,c,d,e,f)

#define DPM_SetCurrentDirectory(a)                                             \
 ((typdpmSetCurrentDirectoryA)(FIOPFT->pfn[DPM_SETCURRENTDIRECTORY]))(a)

#define DPM_SetEndOfFile(a)                                                    \
 ((typdpmSetEndOfFile)(FIOPFT->pfn[DPM_SETENDOFFILE]))(a)

#define DPM_SetFileApisToANSI()                                                \
 ((typdpmSetFileApisToANSI)(FIOPFT->pfn[DPM_SETFILEAPISTOANSI]))()

#define DPM_SetFileApisToOEM()                                                 \
 ((typdpmSetFileApisToOEM)(FIOPFT->pfn[DPM_SETFILEAPISTOOEM]))()

#define DPM_SetFileAttributes(a,b)                                             \
 ((typdpmSetFileAttributesA)(FIOPFT->pfn[DPM_SETFILEATTRIBUTES]))(a,b)

#define DPM_SetFilePointer(a,b,c,d)                                            \
 ((typdpmSetFilePointer)(FIOPFT->pfn[DPM_SETFILEPOINTER]))(a,b,c,d)

#define DPM_SetVolumeLabel(a,b)                                                \
 ((typdpmSetVolumeLabelA)(FIOPFT->pfn[DPM_SETVOLUMELABEL]))(a,b)

#define DPM_UnlockFile(a,b,c,d,e)                                              \
 ((typdpmUnlockFile)(FIOPFT->pfn[DPM_UNLOCKFILE]))(a,b,c,d,e)

#define DPM_WriteFile(a,b,c,d,e)                                               \
 ((typdpmWriteFile)(FIOPFT->pfn[DPM_WRITEFILE]))(a,b,c,d,e)

#define DPM_WriteFileEx(a,b,c,d,e)                                             \
 ((typdpmWriteFileEx)(FIOPFT->pfn[DPM_WRITEFILEEX]))(a,b,c,d,e)

#define DPM_GetTempFileNameW(a,b,c,d)                                          \
  ((typdpmGetTempFileNameW)(FIOPFT->pfn[DPM_GETTEMPFILENAMEW]))(a,b,c,d)

#define DPM_CopyFileW(a,b,c)                                                   \
  ((typdpmCopyFileW)(FIOPFT->pfn[DPM_COPYFILEW]))(a,b,c)

#define DPM_CopyFileExW(a,b,c,d,e,f)                                           \
  ((typdpmCopyFileExW)(FIOPFT->pfn[DPM_COPYFILEEXW]))(a,b,c,d,e,f)

#define DPM_CreateDirectoryW(a,b)                                              \
  ((typdpmCreateDirectoryW)(FIOPFT->pfn[DPM_CREATEDIRECTORYW]))(a,b)

#define DPM_CreateDirectoryExW(a,b,c)                                          \
  ((typdpmCreateDirectoryExW)(FIOPFT->pfn[DPM_CREATEDIRECTORYEXW]))(a,b,c)

#define DPM_CreateFileW(a,b,c,d,e,f,g)                                         \
  ((typdpmCreateFileW)(FIOPFT->pfn[DPM_CREATEFILEW]))(a,b,c,d,e,f,g)

#define DPM_DeleteFileW(a)                                                     \
  ((typdpmDeleteFileW)(FIOPFT->pfn[DPM_DELETEFILEW]))(a)

#define DPM_FindFirstFileW(a,b)                                                \
  ((typdpmFindFirstFileW)(FIOPFT->pfn[DPM_FINDFIRSTFILEW]))(a,b)

#define DPM_FindNextFileW(a,b)                                                 \
  ((typdpmFindNextFileW)(FIOPFT->pfn[DPM_FINDNEXTFILEW]))(a,b)

#define DPM_GetCurrentDirectoryW(a,b)                                          \
  ((typdpmGetCurrentDirectoryW)(FIOPFT->pfn[DPM_GETCURRENTDIRECTORYW]))(a,b)

#define DPM_GetDiskFreeSpaceW(a,b,c,d,e)                                       \
  ((typdpmGetDiskFreeSpaceW)(FIOPFT->pfn[DPM_GETDISKFREESPACEW]))(a,b,c,d,e )

#define DPM_GetDiskFreeSpaceExW(a,b,c,d)                                       \
  ((typdpmGetDiskFreeSpaceExW)(FIOPFT->pfn[DPM_GETDISKFREESPACEEXW]))(a,b,c,d)

#define DPM_GetDriveTypeW(a)                                                   \
  ((typdpmGetDriveTypeW)(FIOPFT->pfn[DPM_GETDRIVETYPEW]))(a)

#define DPM_GetFileAttributesW(a)                                              \
  ((typdpmGetFileAttributesW)(FIOPFT->pfn[DPM_GETFILEATTRIBUTESW]))(a)

#define DPM_GetFileAttributesExW(a,b,c)                                        \
  ((typdpmGetFileAttributesExW)(FIOPFT->pfn[DPM_GETFILEATTRIBUTESEXW]))(a,b,c)

#define DPM_GetFullPathNameW(a,b,c,d)                                          \
 ((typdpmGetFullPathNameW)(FIOPFT->pfn[DPM_GETFULLPATHNAMEW]))(a,b,c,d)

#define DPM_GetLogicalDriveStringsW(a,b)                                       \
 ((typdpmGetLogicalDriveStringsW)(FIOPFT->pfn[DPM_GETLOGICALDRIVESTRINGSW]))(a,b)

#define DPM_GetLongPathNameW(a,b,c)                                            \
 ((typdpmGetLongPathNameW)(FIOPFT->pfn[DPM_GETLONGPATHNAMEW]))(a,b,c)

#define DPM_GetShortPathNameW(a,b,c)                                           \
 ((typdpmGetShortPathNameW)(FIOPFT->pfn[DPM_GETSHORTPATHNAMEW]))(a,b,c)

#define DPM_GetTempPathW(a,b)                                                  \
 ((typdpmGetTempPathW)(FIOPFT->pfn[DPM_GETTEMPPATHW]))(a,b)

#define DPM_MoveFileW(a,b)                                                     \
 ((typdpmMoveFileW)(FIOPFT->pfn[DPM_MOVEFILEW]))(a,b)

#define DPM_MoveFileExW(a,b,c)                                                 \
 ((typdpmMoveFileExW)(FIOPFT->pfn[DPM_MOVEFILEEXW]))(a,b,c)

#define DPM_QueryDosDeviceW(a,b,c)                                             \
 ((typdpmQueryDosDeviceW)(FIOPFT->pfn[DPM_QUERYDOSDEVICEW]))(a,b,c)

#define DPM_RemoveDirectoryW(a)                                                \
 ((typdpmRemoveDirectoryW)(FIOPFT->pfn[DPM_REMOVEDIRECTORYW]))(a)

#define DPM_SearchPathW(a,b,c,d,e,f)                                           \
 ((typdpmSearchPathW)(FIOPFT->pfn[DPM_SEARCHPATHW]))(a,b,c,d,e,f)

#define DPM_SetCurrentDirectoryW(a)                                            \
 ((typdpmSetCurrentDirectoryW)(FIOPFT->pfn[DPM_SETCURRENTDIRECTORYW]))(a)

#define DPM_SetFileAttributesW(a,b)                                            \
 ((typdpmSetFileAttributesW)(FIOPFT->pfn[DPM_SETFILEATTRIBUTESW]))(a,b)

#define DPM_SetVolumeLabelW(a,b)                                               \
 ((typdpmSetVolumeLabelW)(FIOPFT->pfn[DPM_SETVOLUMELABELW]))(a,b)


/*
//#define DPM_FileIOCompletionRoutine(a,b,c)                                   \
//((typdpmFileIOCompletionRoutine)(FIOPFT->pfn[DPM_FILEIOCOMPLETIONROUTINE]))(a,b,c)

*/

// Macros to dispatch Shimed API calls properly from the dpmfxxx.dll
#define SHM_OpenFile(a,b,c)                                                    \
     (FIO_SHIM(DPM_OPENFILE,                                                   \
               typdpmOpenFile))(a,b,c)
#define SHM__lclose(a)                                                         \
     (FIO_SHIM(DPM__LCLOSE,                                                    \
               typdpm_lclose))(a)
#define SHM__lopen(a,b)                                                        \
     (FIO_SHIM(DPM__LOPEN,                                                     \
               typdpm_lopen))(a,b)
#define SHM__lcreat(a,b)                                                       \
     (FIO_SHIM(DPM__LCREAT,                                                    \
               typdpm_lcreat))(a,b)
#define SHM__llseek(a,b,c)                                                     \
     (FIO_SHIM(DPM__LLSEEK,                                                    \
               typdpm_llseek))(a,b,c)
#define SHM__lread(a,b,c)                                                      \
     (FIO_SHIM(DPM__LREAD,                                                     \
               typdpm_lread))(a,b,c)
#define SHM__lwrite(a,b,c)                                                     \
     (FIO_SHIM(DPM__LWRITE,                                                    \
               typdpm_lwrite))(a,b,c)
#define SHM__hread(a,b,c)                                                      \
     (FIO_SHIM(DPM__HREAD,                                                     \
               typdpm_hread))(a,b,c)
#define SHM__hwrite(a,b,c)                                                     \
     (FIO_SHIM(DPM__HWRITE,                                                    \
               typdpm_hwrite))(a,b,c)
#define SHM_GetTempFileName(a,b,c,d)                                           \
     (FIO_SHIM(DPM_GETTEMPFILENAME,                                            \
               typdpmGetTempFileNameA))(a,b,c,d)
#define SHM_AreFileApisANSI()                                                  \
     (FIO_SHIM(DPM_AREFILEAPISANSI,                                            \
               typdpmAreFileApisANSI))()
#define SHM_CancelIo(a)                                                        \
     (FIO_SHIM(DPM_CANCELIO,                                                   \
               typdpmCancelIo))(a)
#define SHM_CloseHandle(a)                                                     \
     (FIO_SHIM(DPM_CLOSEHANDLE,                                                \
               typdpmCloseHandle))(a)
#define SHM_CopyFile(a,b,c)                                                    \
     (FIO_SHIM(DPM_COPYFILE,                                                   \
               typdpmCopyFileA))(a,b,c)
#define SHM_CopyFileEx(a,b,c,d,e,f)                                            \
     (FIO_SHIM(DPM_COPYFILEEX,                                                 \
               typdpmCopyFileExA))(a,b,c,d,e,f)
#define SHM_CreateDirectory(a,b)                                               \
     (FIO_SHIM(DPM_CREATEDIRECTORY,                                            \
               typdpmCreateDirectoryA))(a,b)
#define SHM_CreateDirectoryEx(a,b,c)                                           \
     (FIO_SHIM(DPM_CREATEDIRECTORYEX,                                          \
               typdpmCreateDirectoryExA))(a,b,c)
#define SHM_CreateFile(a,b,c,d,e,f,g)                                          \
     (FIO_SHIM(DPM_CREATEFILE,                                                 \
               typdpmCreateFileA))(a,b,c,d,e,f,g)
#define SHM_DeleteFile(a)                                                      \
     (FIO_SHIM(DPM_DELETEFILE,                                                 \
               typdpmDeleteFileA))(a)
#define SHM_FindClose(a)                                                       \
     (FIO_SHIM(DPM_FINDCLOSE,                                                  \
               typdpmFindClose))(a)
#define SHM_FindCloseChangeNotification(a)                                     \
     (FIO_SHIM(DPM_FINDCLOSECHANGENOTIFICATION,                                \
               typdpmFindCloseChangeNotification))(a)
#define SHM_FindFirstChangeNotification(a,b,c)                                 \
     (FIO_SHIM(DPM_FINDFIRSTCHANGENOTIFICATION,                                \
               typdpmFindFirstChangeNotificationA))(a,b,c)
#define SHM_FindFirstFile(a,b)                                                 \
     (FIO_SHIM(DPM_FINDFIRSTFILE,                                              \
               typdpmFindFirstFileA))(a,b)
#define SHM_FindNextChangeNotification(a)                                      \
     (FIO_SHIM(DPM_FINDNEXTCHANGENOTIFICATION,                                 \
               typdpmFindNextChangeNotification))(a)
#define SHM_FindNextFile(a,b)                                                  \
     (FIO_SHIM(DPM_FINDNEXTFILE,                                               \
               typdpmFindNextFileA))(a,b)
#define SHM_FlushFileBuffers(a)                                                \
     (FIO_SHIM(DPM_FLUSHFILEBUFFERS,                                           \
               typdpmFlushFileBuffers))(a)
#define SHM_GetCurrentDirectory(a,b)                                           \
     (FIO_SHIM(DPM_GETCURRENTDIRECTORY,                                        \
               typdpmGetCurrentDirectoryA))(a,b)
#define SHM_GetDiskFreeSpace(a,b,c,d,e)                                        \
     (FIO_SHIM(DPM_GETDISKFREESPACE,                                           \
               typdpmGetDiskFreeSpaceA))(a,b,c,d,e )
#define SHM_GetDiskFreeSpaceEx(a,b,c,d)                                        \
     (FIO_SHIM(DPM_GETDISKFREESPACEEX,                                         \
               typdpmGetDiskFreeSpaceExA))(a,b,c,d)
#define SHM_GetDriveType(a)                                                    \
     (FIO_SHIM(DPM_GETDRIVETYPE,                                               \
               typdpmGetDriveTypeA))(a)
#define SHM_GetFileAttributes(a)                                               \
     (FIO_SHIM(DPM_GETFILEATTRIBUTES,                                          \
               typdpmGetFileAttributesA))(a)
#define SHM_GetFileAttributesEx(a,b,c)                                         \
     (FIO_SHIM(DPM_GETFILEATTRIBUTESEX,                                        \
               typdpmGetFileAttributesExA))(a,b,c)
#define SHM_GetFileInformationByHandle(a,b)                                    \
     (FIO_SHIM(DPM_GETFILEINFORMATIONBYHANDLE,                                 \
               typdpmGetFileInformationByHandle))(a,b)
#define SHM_GetFileSize(a,b)                                                   \
     (FIO_SHIM(DPM_GETFILESIZE,                                                \
               typdpmGetFileSize))(a,b)
#define SHM_GetFileType(a)                                                     \
     (FIO_SHIM(DPM_GETFILETYPE,                                                \
               typdpmGetFileType))(a)
#define SHM_GetFullPathName(a,b,c,d)                                           \
     (FIO_SHIM(DPM_GETFULLPATHNAME,                                            \
               typdpmGetFullPathNameA))(a,b,c,d)
#define SHM_GetLogicalDrives()                                                 \
     (FIO_SHIM(DPM_GETLOGICALDRIVES,                                           \
               typdpmGetLogicalDrives))()
#define SHM_GetLogicalDriveStrings(a,b)                                        \
     (FIO_SHIM(DPM_GETLOGICALDRIVESTRINGS,                                     \
               typdpmGetLogicalDriveStringsA))(a,b)
#define SHM_GetLongPathName(a,b,c)                                             \
     (FIO_SHIM(DPM_GETLONGPATHNAME,                                            \
               typdpmGetLongPathNameA))(a,b,c)
#define SHM_GetShortPathName(a,b,c)                                            \
     (FIO_SHIM(DPM_GETSHORTPATHNAME,                                           \
               typdpmGetShortPathNameA))(a,b,c)
#define SHM_GetTempPath(a,b)                                                   \
     (FIO_SHIM(DPM_GETTEMPPATH,                                                \
               typdpmGetTempPathA))(a,b)
#define SHM_LockFile(a,b,c,d,e)                                                \
     (FIO_SHIM(DPM_LOCKFILE,                                                   \
               typdpmLockFile))(a,b,c,d,e)
#define SHM_MoveFile(a,b)                                                      \
     (FIO_SHIM(DPM_MOVEFILE,                                                   \
               typdpmMoveFileA))(a,b)
#define SHM_MoveFileEx(a,b,c)                                                  \
     (FIO_SHIM(DPM_MOVEFILEEX,                                                 \
               typdpmMoveFileExA))(a,b,c)
#define SHM_QueryDosDevice(a,b,c)                                              \
     (FIO_SHIM(DPM_QUERYDOSDEVICE,                                             \
               typdpmQueryDosDeviceA))(a,b,c)
#define SHM_ReadFile(a,b,c,d,e)                                                \
     (FIO_SHIM(DPM_READFILE,                                                   \
               typdpmReadFile))(a,b,c,d,e)
#define SHM_ReadFileEx(a,b,c,d,e)                                              \
     (FIO_SHIM(DPM_READFILEEX,                                                 \
               typdpmReadFileEx))(a,b,c,d,e)
#define SHM_RemoveDirectory(a)                                                 \
     (FIO_SHIM(DPM_REMOVEDIRECTORY,                                            \
               typdpmRemoveDirectoryA))(a)
#define SHM_SearchPath(a,b,c,d,e,f)                                            \
     (FIO_SHIM(DPM_SEARCHPATH,                                                 \
               typdpmSearchPathA))(a,b,c,d,e,f)
#define SHM_SetCurrentDirectory(a)                                             \
     (FIO_SHIM(DPM_SETCURRENTDIRECTORY,                                        \
               typdpmSetCurrentDirectoryA))(a)
#define SHM_SetEndOfFile(a)                                                    \
     (FIO_SHIM(DPM_SETENDOFFILE,                                               \
               typdpmSetEndOfFile))(a)
#define SHM_SetFileApisToANSI(a)                                               \
     (FIO_SHIM(DPM_SETFILEAPISTOANSI,                                          \
               typdpmSetFileApisToANSI))(a)
#define SHM_SetFileApisToOEM(a)                                                \
     (FIO_SHIM(DPM_SETFILEAPISTOOEM,                                           \
               typdpmSetFileApisToOEM))(a)
#define SHM_SetFileAttributes(a,b)                                             \
     (FIO_SHIM(DPM_SETFILEATTRIBUTES,                                          \
               typdpmSetFileAttributesA))(a,b)
#define SHM_SetFilePointer(a,b,c,d)                                            \
     (FIO_SHIM(DPM_SETFILEPOINTER,                                             \
               typdpmSetFilePointer))(a,b,c,d)
#define SHM_SetVolumeLabel(a,b)                                                \
     (FIO_SHIM(DPM_SETVOLUMELABEL,                                             \
               typdpmSetVolumeLabelA))(a,b)
#define SHM_UnlockFile(a,b,c,d,e)                                              \
     (FIO_SHIM(DPM_UNLOCKFILE,                                                 \
               typdpmUnlockFile))(a,b,c,d,e)
#define SHM_WriteFile(a,b,c,d,e)                                               \
     (FIO_SHIM(DPM_WRITEFILE,                                                  \
               typdpmWriteFile))(a,b,c,d,e)
#define SHM_WriteFileEx(a,b,c,d,e)                                             \
     (FIO_SHIM(DPM_WRITEFILEEX,                                                \
               typdpmWriteFileEx))(a,b,c,d,e)
#define SHM_GetTempFileNameW(a,b,c,d)                                          \
     (FIO_SHIM(DPM_GETTEMPFILENAMEW,                                           \
               typdpmGetTempFileNameW))(a,b,c,d)
#define SHM_CopyFileW(a,b,c)                                                   \
     (FIO_SHIM(DPM_COPYFILEW,                                                  \
               typdpmCopyFileW))(a,b,c)
#define SHM_CopyFileExW(a,b,c,d,e,f)                                           \
     (FIO_SHIM(DPM_COPYFILEEXW,                                                \
               typdpmCopyFileExW))(a,b,c,d,e,f)
#define SHM_CreateDirectoryW(a,b)                                              \
     (FIO_SHIM(DPM_CREATEDIRECTORYW,                                           \
               typdpmCreateDirectoryW))(a,b)
#define SHM_CreateDirectoryExW(a,b,c)                                          \
     (FIO_SHIM(DPM_CREATEDIRECTORYEXW,                                         \
               typdpmCreateDirectoryExW))(a,b,c)
#define SHM_CreateFileW(a,b,c,d,e,f,g)                                         \
     (FIO_SHIM(DPM_CREATEFILEW,                                                \
               typdpmCreateFileW))(a,b,c,d,e,f,g)
#define SHM_DeleteFileW(a)                                                     \
     (FIO_SHIM(DPM_DELETEFILEW,                                                \
               typdpmDeleteFileW))(a)
#define SHM_FindFirstFileW(a,b)                                                \
     (FIO_SHIM(DPM_FINDFIRSTFILEW,                                             \
               typdpmFindFirstFileW))(a,b)
#define SHM_FindNextFileW(a,b)                                                 \
     (FIO_SHIM(DPM_FINDNEXTFILEW,                                              \
               typdpmFindNextFileW))(a,b)
#define SHM_GetCurrentDirectoryW(a,b)                                          \
     (FIO_SHIM(DPM_GETCURRENTDIRECTORYW,                                       \
               typdpmGetCurrentDirectoryW))(a,b)
#define SHM_GetDiskFreeSpaceW(a,b,c,d,e)                                       \
     (FIO_SHIM(DPM_GETDISKFREESPACEW,                                          \
               typdpmGetDiskFreeSpaceW))(a,b,c,d,e )
#define SHM_GetDiskFreeSpaceExW(a,b,c,d)                                       \
     (FIO_SHIM(DPM_GETDISKFREESPACEEXW,                                        \
               typdpmGetDiskFreeSpaceExW))(a,b,c,d)
#define SHM_GetDriveTypeW(a)                                                   \
     (FIO_SHIM(DPM_GETDRIVETYPEW,                                              \
               typdpmGetDriveTypeW))(a)
#define SHM_GetFileAttributesW(a)                                              \
     (FIO_SHIM(DPM_GETFILEATTRIBUTESW,                                         \
               typdpmGetFileAttributesW))(a)
#define SHM_GetFileAttributesExW(a,b,c)                                        \
     (FIO_SHIM(DPM_GETFILEATTRIBUTESEXW,                                       \
               typdpmGetFileAttributesExW))(a,b,c)
#define SHM_GetFullPathNameW(a,b,c,d)                                          \
     (FIO_SHIM(DPM_GETFULLPATHNAMEW,                                           \
               typdpmGetFullPathNameW))(a,b,c,d)
#define SHM_GetLogicalDriveStringsW(a,b)                                       \
     (FIO_SHIM(DPM_GETLOGICALDRIVESTRINGSW,                                    \
               typdpmGetLogicalDriveStringsW))(a,b)
#define SHM_GetLongPathNameW(a,b,c)                                            \
     (FIO_SHIM(DPM_GETLONGPATHNAMEW,                                           \
               typdpmGetLongPathNameW))(a,b,c)
#define SHM_GetShortPathNameW(a,b,c)                                           \
     (FIO_SHIM(DPM_GETSHORTPATHNAMEW,                                          \
               typdpmGetShortPathNameW))(a,b,c)
#define SHM_GetTempPathW(a,b)                                                  \
     (FIO_SHIM(DPM_GETTEMPPATHW,                                               \
               typdpmGetTempPathW))(a,b)
#define SHM_MoveFileW(a,b)                                                     \
     (FIO_SHIM(DPM_MOVEFILEW,                                                  \
               typdpmMoveFileW))(a,b)
#define SHM_MoveFileExW(a,b,c)                                                 \
     (FIO_SHIM(DPM_MOVEFILEEXW,                                                \
               typdpmMoveFileExW))(a,b,c)
#define SHM_QueryDosDeviceW(a,b,c)                                             \
     (FIO_SHIM(DPM_QUERYDOSDEVICEW,                                            \
               typdpmQueryDosDeviceW))(a,b,c)
#define SHM_RemoveDirectoryW(a)                                                \
     (FIO_SHIM(DPM_REMOVEDIRECTORYW,                                           \
               typdpmRemoveDirectoryW))(a)
#define SHM_SearchPathW(a,b,c,d,e,f)                                           \
     (FIO_SHIM(DPM_SEARCHPATHW,                                                \
               typdpmSearchPathW))(a,b,c,d,e,f)
#define SHM_SetCurrentDirectoryW(a)                                            \
     (FIO_SHIM(DPM_SETCURRENTDIRECTORYW,                                       \
               typdpmSetCurrentDirectoryW))(a)
#define SHM_SetFileAttributesW(a,b)                                            \
     (FIO_SHIM(DPM_SETFILEATTRIBUTESW,                                         \
               typdpmSetFileAttributesW))(a,b)
#define SHM_SetVolumeLabelW(a,b)                                               \
     (FIO_SHIM(DPM_SETVOLUMELABELW,                                            \
               typdpmSetVolumeLabelW))(a,b)

#endif // _DPMF_FIOAPI_H_





// These need to be in the same order as the FioFam enum definitions above and
// the DpmFioTbl[] list below.
// This instantiates memory for DpmFioStrs[] in mvdm\v86\monitor\i386\vdpm.c &
// in mvdm\wow32\wdpm.c
#ifdef _DPM_COMMON_
const char *DpmFioStrs[] = {"OpenFile",
                            "_lclose",
                            "_lopen",
                            "_lcreat",
                            "_llseek",
                            "_lread",
                            "_lwrite",
                            "_hread",
                            "_hwrite",
                            "GetTempFileNameA",
                            "AreFileApisANSI",
                            "CancelIo",
                            "CloseHandle",
                            "CopyFileA",
                            "CopyFileExA",
                            "CreateDirectoryA",
                            "CreateDirectoryExA",
                            "CreateFileA",
                            "DeleteFileA",
                            "FindClose",
                            "FindCloseChangeNotification",
                            "FindFirstChangeNotificationA",
                            "FindFirstFileA",
                            "FindNextChangeNotification",
                            "FindNextFileA",
                            "FlushFileBuffers",
                            "GetCurrentDirectoryA",
                            "GetDiskFreeSpaceA",
                            "GetDiskFreeSpaceExA",
                            "GetDriveTypeA",
                            "GetFileAttributesA",
                            "GetFileAttributesExA",
                            "GetFileInformationByHandle",
                            "GetFileSize",
                            "GetFileType",
                            "GetFullPathNameA",
                            "GetLogicalDrives",
                            "GetLogicalDriveStringsA",
                            "GetLongPathNameA",
                            "GetShortPathNameA",
                            "GetTempPathA",
                            "LockFile",
                            "MoveFileA",
                            "MoveFileExA",
                            "QueryDosDeviceA",
                            "ReadFile",
                            "ReadFileEx",
                            "RemoveDirectoryA",
                            "SearchPathA",
                            "SetCurrentDirectoryA",
                            "SetEndOfFile",
                            "SetFileApisToANSI",
                            "SetFileApisToOEM",
                            "SetFileAttributesA",
                            "SetFilePointer",
                            "SetVolumeLabelA",
                            "UnlockFile",
                            "WriteFile",
                            "WriteFileEx",
                            "GetTempFileNameW",
                            "CopyFileW",
                            "CopyFileExW",
                            "CreateDirectoryW",
                            "CreateDirectoryExW",
                            "CreateFileW",
                            "DeleteFileW",
                            "FindFirstFileW",
                            "FindNextFileW",
                            "GetCurrentDirectoryW",
                            "GetDiskFreeSpaceW",
                            "GetDiskFreeSpaceExW",
                            "GetDriveTypeW",
                            "GetFileAttributesW",
                            "GetFileAttributesExW",
                            "GetFullPathNameW",
                            "GetLogicalDriveStringsW",
                            "GetLongPathNameW",
                            "GetShortPathNameW",
                            "GetTempPathW",
                            "MoveFileW",
                            "MoveFileExW",
                            "QueryDosDeviceW",
                            "RemoveDirectoryW",
                            "SearchPathW",
                            "SetCurrentDirectoryW",
                            "SetFileAttributesW",
                            "SetVolumeLabelW"};
// "FileIOCompletionRoutine",

// These need to be in the same order as the FioFam enum definitions and the
// the DpmFioStrs[] list above.
// This instantiates memory for DpmFioTbl[] in mvdm\v86\monitor\i386\vdpm.c
PVOID DpmFioTbl[] = {OpenFile,
                     _lclose,
                     _lopen,
                     _lcreat,
                     _llseek,
                     _lread,
                     _lwrite,
                     _hread,
                     _hwrite,
                     GetTempFileNameA,
                     AreFileApisANSI,
                     CancelIo,
                     CloseHandle,
                     CopyFileA,
                     CopyFileExA,
                     CreateDirectoryA,
                     CreateDirectoryExA,
                     CreateFileA,
                     DeleteFileA,
                     FindClose,
                     FindCloseChangeNotification,
                     FindFirstChangeNotificationA,
                     FindFirstFileA,
                     FindNextChangeNotification,
                     FindNextFileA,
                     FlushFileBuffers,
                     GetCurrentDirectoryA,
                     GetDiskFreeSpaceA,
                     GetDiskFreeSpaceExA,
                     GetDriveTypeA,
                     GetFileAttributesA,
                     GetFileAttributesExA,
                     GetFileInformationByHandle,
                     GetFileSize,
                     GetFileType,
                     GetFullPathNameA,
                     GetLogicalDrives,
                     GetLogicalDriveStringsA,
                     GetLongPathNameA,
                     GetShortPathNameA,
                     GetTempPathA,
                     LockFile,
                     MoveFileA,
                     MoveFileExA,
                     QueryDosDeviceA,
                     ReadFile,
                     ReadFileEx,
                     RemoveDirectoryA,
                     SearchPathA,
                     SetCurrentDirectoryA,
                     SetEndOfFile,
                     SetFileApisToANSI,
                     SetFileApisToOEM,
                     SetFileAttributesA,
                     SetFilePointer,
                     SetVolumeLabelA,
                     UnlockFile,
                     WriteFile,
                     WriteFileEx,
                     GetTempFileNameW,
                     CopyFileW,
                     CopyFileExW,
                     CreateDirectoryW,
                     CreateDirectoryExW,
                     CreateFileW,
                     DeleteFileW,
                     FindFirstFileW,
                     FindNextFileW,
                     GetCurrentDirectoryW,
                     GetDiskFreeSpaceW,
                     GetDiskFreeSpaceExW,
                     GetDriveTypeW,
                     GetFileAttributesW,
                     GetFileAttributesExW,
                     GetFullPathNameW,
                     GetLogicalDriveStringsW,
                     GetLongPathNameW,
                     GetShortPathNameW,
                     GetTempPathW,
                     MoveFileW,
                     MoveFileExW,
                     QueryDosDeviceW,
                     RemoveDirectoryW,
                     SearchPathW,
                     SetCurrentDirectoryW,
                     SetFileAttributesW,
                     SetVolumeLabelW};
// FileIOCompletionRoutine,

#define NUM_HOOKED_FIO_APIS  ((sizeof DpmFioTbl)/(sizeof DpmFioTbl[0])) 

// This instantiates memory for DpmFioFam in mvdm\v86\monitor\i386\vdpm.c
FAMILY_TABLE DpmFioFam = {NUM_HOOKED_FIO_APIS, 0, 0, 0, 0, DpmFioTbl};

#endif // _DPM_COMMON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\dpmf_reg.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 2002, Microsoft Corporation
 *
 *  dpmf_reg.h
 *  WOW32 Dynamic Patch Module to support Registry API family
 *  Definitions & macors to support calls into dpmfreg.dll
 *
 *  History:
 *  Created 01-10-2002 by cmjones
--*/

#ifndef _DPMF_REGAPI_H_
#define _DPMF_REGAPI_H_ 


#define REGPFT               (DPMFAMTBLS()[REG_FAM])
#define REG_SHIM(ord, typ)   ((typ)((pFT)->pDpmShmTbls[ord]))

// The order of this list must be the same as the lists below
enum RegFam {DPM_REGCLOSEKEY=0,       // Win 3.1 set
             DPM_REGCREATEKEY,
             DPM_REGDELETEKEY,
             DPM_REGENUMKEY,
             DPM_REGOPENKEY,
             DPM_REGQUERYVALUE,
             DPM_REGSETVALUE,         // end Win 3.1 set
             DPM_REGDELETEVALUE,      // Win 9x API's we currently thunk
             DPM_REGENUMVALUE,
             DPM_REGFLUSHKEY,
             DPM_REGLOADKEY,
             DPM_REGQUERYVALUEEX,
             DPM_REGSAVEKEY, 
             DPM_REGSETVALUEEX,
             DPM_REGUNLOADKEY,        // End Win 9x thunked set
             DPM_REGCONNECTREGISTRY,  // Remainder for Generic thunk support
             DPM_REGCREATEKEYEX,
             DPM_REGENUMKEYEX,
             DPM_REGNOTIFYCHANGEKEYVALUE,
             DPM_REGOPENKEYEX,
             DPM_REGQUERYINFOKEY,
             DPM_REGQUERYMULTIPLEVALUES,
             DPM_REGREPLACEKEY,
             DPM_REGCREATEKEYW,
             DPM_REGDELETEKEYW,
             DPM_REGENUMKEYW,
             DPM_REGOPENKEYW,
             DPM_REGQUERYVALUEW,
             DPM_REGSETVALUEW,
             DPM_REGDELETEVALUEW,
             DPM_REGENUMVALUEW,
             DPM_REGLOADKEYW,
             DPM_REGQUERYVALUEEXW,
             DPM_REGSAVEKEYW, 
             DPM_REGSETVALUEEXW,
             DPM_REGUNLOADKEYW,
             DPM_REGCONNECTREGISTRYW,
             DPM_REGCREATEKEYEXW,
             DPM_REGENUMKEYEXW,
             DPM_REGOPENKEYEXW,
             DPM_REGQUERYINFOKEYW,
             DPM_REGQUERYMULTIPLEVALUESW,
             DPM_REGREPLACEKEYW,
             enum_reg_last};



// These types will catch misuse of parameters & ret types
typedef ULONG (*typdpmRegCloseKey)(HKEY);
typedef ULONG (*typdpmRegCreateKey)(HKEY, LPCSTR, PHKEY);
typedef ULONG (*typdpmRegDeleteKey)(HKEY, LPCSTR);
typedef ULONG (*typdpmRegEnumKey)(HKEY, DWORD, LPSTR, DWORD);
typedef ULONG (*typdpmRegOpenKey)(HKEY, LPCSTR, PHKEY);
typedef ULONG (*typdpmRegQueryValue)(HKEY, LPCSTR, LPSTR, PLONG);
typedef ULONG (*typdpmRegSetValue)(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
typedef ULONG (*typdpmRegDeleteValue)(HKEY, LPCSTR);
typedef ULONG (*typdpmRegEnumValue)(HKEY, DWORD, LPSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef ULONG (*typdpmRegFlushKey)(HKEY);
typedef ULONG (*typdpmRegLoadKey)(HKEY, LPCSTR, LPCSTR);
typedef ULONG (*typdpmRegQueryValueEx)(HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef ULONG (*typdpmRegSaveKey)(HKEY, LPCSTR, LPSECURITY_ATTRIBUTES);
typedef ULONG (*typdpmRegSetValueEx)(HKEY, LPCSTR, DWORD, DWORD, CONST BYTE *, DWORD);
typedef ULONG (*typdpmRegUnLoadKey)(HKEY, LPCSTR);
typedef ULONG (*typdpmRegConnectRegistry)(LPCSTR, HKEY, PHKEY);
typedef ULONG (*typdpmRegCreateKeyEx)(HKEY, LPCSTR, DWORD, LPSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
typedef ULONG (*typdpmRegEnumKeyEx)(HKEY, DWORD, LPSTR, LPDWORD, LPDWORD, LPSTR, LPDWORD, PFILETIME);
typedef ULONG (*typdpmRegNotifyChangeKeyValue)(HKEY, BOOL, DWORD, HANDLE, BOOL);
typedef ULONG (*typdpmRegOpenKeyEx)(HKEY, LPCSTR, DWORD, REGSAM, PHKEY);
typedef ULONG (*typdpmRegQueryInfoKey)(HKEY, LPSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, PFILETIME);
typedef ULONG (*typdpmRegQueryMultipleValues)(HKEY, PVALENT, DWORD, LPSTR, LPDWORD);
typedef ULONG (*typdpmRegReplaceKey)(HKEY, LPCSTR, LPCSTR, LPCSTR);
typedef ULONG (*typdpmRegCreateKeyW)(HKEY, LPCWSTR, PHKEY);
typedef ULONG (*typdpmRegDeleteKeyW)(HKEY, LPCWSTR);
typedef ULONG (*typdpmRegEnumKeyW)(HKEY, DWORD, LPWSTR, DWORD);
typedef ULONG (*typdpmRegOpenKeyW)(HKEY, LPCWSTR, PHKEY);
typedef ULONG (*typdpmRegQueryValueW)(HKEY, LPCWSTR, LPWSTR, PLONG);
typedef ULONG (*typdpmRegSetValueW)(HKEY, LPCWSTR, DWORD, LPCWSTR, DWORD);
typedef ULONG (*typdpmRegDeleteValueW)(HKEY, LPCWSTR);
typedef ULONG (*typdpmRegEnumValueW)(HKEY, DWORD, LPWSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef ULONG (*typdpmRegLoadKeyW)(HKEY, LPCWSTR, LPCWSTR);
typedef ULONG (*typdpmRegQueryValueExW)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef ULONG (*typdpmRegSaveKeyW)(HKEY, LPCWSTR, LPSECURITY_ATTRIBUTES);
typedef ULONG (*typdpmRegSetValueExW)(HKEY, LPCWSTR, DWORD, DWORD, CONST BYTE *, DWORD);
typedef ULONG (*typdpmRegUnLoadKeyW)(HKEY, LPCWSTR);
typedef ULONG (*typdpmRegConnectRegistryW)(LPCWSTR, HKEY, PHKEY);
typedef ULONG (*typdpmRegCreateKeyExW)(HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
typedef ULONG (*typdpmRegEnumKeyExW)(HKEY, DWORD, LPWSTR, LPDWORD, LPDWORD, LPWSTR, LPDWORD, PFILETIME);
typedef ULONG (*typdpmRegOpenKeyExW)(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY);
typedef ULONG (*typdpmRegQueryInfoKeyW)(HKEY, LPWSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, PFILETIME);
typedef ULONG (*typdpmRegQueryMultipleValuesW)(HKEY, PVALENTW, DWORD, LPWSTR, LPDWORD);
typedef ULONG (*typdpmRegReplaceKeyW)(HKEY, LPCWSTR, LPCWSTR, LPCWSTR);


// Macros to dispatch API calls properly
#define DPM_RegCloseKey(a)                                                     \
  ((typdpmRegCloseKey)(REGPFT->pfn[DPM_REGCLOSEKEY]))(a)

#define DPM_RegCreateKey(a,b,c)                                                \
  ((typdpmRegCreateKey)(REGPFT->pfn[DPM_REGCREATEKEY]))(a,b,c)

#define DPM_RegDeleteKey(a,b)                                                  \
  ((typdpmRegDeleteKey)(REGPFT->pfn[DPM_REGDELETEKEY]))(a,b)

#define DPM_RegEnumKey(a,b,c,d)                                                \
  ((typdpmRegEnumKey)(REGPFT->pfn[DPM_REGENUMKEY]))(a,b,c,d)

#define DPM_RegOpenKey(a,b,c)                                                  \
  ((typdpmRegOpenKey)(REGPFT->pfn[DPM_REGOPENKEY]))(a,b,c)

#define DPM_RegQueryValue(a,b,c,d)                                             \
  ((typdpmRegQueryValue)(REGPFT->pfn[DPM_REGQUERYVALUE]))(a,b,c,d)

#define DPM_RegSetValue(a,b,c,d,e)                                             \
  ((typdpmRegSetValue)(REGPFT->pfn[DPM_REGSETVALUE]))(a,b,c,d,e)

#define DPM_RegDeleteValue(a,b)                                                \
  ((typdpmRegDeleteValue)(REGPFT->pfn[DPM_REGDELETEVALUE]))(a,b)

#define DPM_RegEnumValue(a,b,c,d,e,f,g,h)                                      \
  ((typdpmRegEnumValue)(REGPFT->pfn[DPM_REGENUMVALUE]))(a,b,c,d,e,f,g,h)

#define DPM_RegFlushKey(a)                                                     \
  ((typdpmRegFlushKey)(REGPFT->pfn[DPM_REGFLUSHKEY]))(a)

#define DPM_RegLoadKey(a,b,c)                                                  \
  ((typdpmRegLoadKey)(REGPFT->pfn[DPM_REGLOADKEY]))(a,b,c)

#define DPM_RegQueryValueEx(a,b,c,d,e,f)                                       \
  ((typdpmRegQueryValueEx)(REGPFT->pfn[DPM_REGQUERYVALUEEX]))(a,b,c,d,e,f)

#define DPM_RegSaveKey(a,b,c)                                                  \
  ((typdpmRegSaveKey)(REGPFT->pfn[DPM_REGSAVEKEY]))(a,b,c)

#define DPM_RegSetValueEx(a,b,c,d,e,f)                                         \
  ((typdpmRegSetValueEx)(REGPFT->pfn[DPM_REGSETVALUEEX]))(a,b,c,d,e,f)

#define DPM_RegUnLoadKey(a,b)                                                  \
  ((typdpmRegUnLoadKey)(REGPFT->pfn[DPM_REGUNLOADKEY]))(a,b)

#define DPM_RegConnectRegistry(a,b,c)                                          \
  ((typdpmRegConnectRegistry)(REGPFT->pfn[DPM_REGCONNECTREGISTRY]))(a,b,c)

#define DPM_RegCreateKeyEx(a,b,c,d,e,f,g,h,i)                                  \
  ((typdpmRegCreateKeyEx)(REGPFT->pfn[DPM_REGCREATEKEYEX]))(a,b,c,d,e,f,g,h,i)

#define DPM_RegEnumKeyEx(a,b,c,d,e,f,g,h)                                      \
  ((typdpmRegEnumKeyEx)(REGPFT->pfn[DPM_REGENUMKEYEX]))(a,b,c,d,e,f,g,h)

#define DPM_RegNotifyChangeKeyValue(a,b,c,d,e)                                 \
  ((typdpmRegNotifyChangeKeyValue)(REGPFT->pfn[DPM_REGNOTIFYCHANGEKEYVALUE]))(a,b,c,d,e)

#define DPM_RegOpenKeyEx(a,b,c,d,e)                                            \
  ((typdpmRegOpenKeyEx)(REGPFT->pfn[DPM_REGOPENKEYEX]))(a,b,c,d,e)

#define DPM_RegQueryInfoKey(a,b,c,d,e,f,g,h,i,j,k,l)                           \
  ((typdpmRegQueryInfoKey)(REGPFT->pfn[DPM_REGQUERYINFOKEY]))(a,b,c,d,e,f,g,h,i,j,k,l)

#define DPM_RegQueryMultipleValues(a,b,c,d,e)                                  \
  ((typdpmRegQueryMultipleValues)(REGPFT->pfn[DPM_REGQUERYMULTIPLEVALUES]))(a,b,c,d,e)

#define DPM_RegReplaceKey(a,b,c,d)                                             \
  ((typdpmRegReplaceKey)(REGPFT->pfn[DPM_REGREPLACEKEY]))(a,b,c,d)

#define DPM_RegCreateKeyW(a,b,c)                                               \
  ((typdpmRegCreateKeyW)(REGPFT->pfn[DPM_REGCREATEKEYW]))(a,b,c)

#define DPM_RegDeleteKeyW(a,b)                                                 \
  ((typdpmRegDeleteKeyW)(REGPFT->pfn[DPM_REGDELETEKEYW]))(a,b)

#define DPM_RegEnumKeyW(a,b,c,d)                                               \
  ((typdpmRegEnumKeyW)(REGPFT->pfn[DPM_REGENUMKEYW]))(a,b,c,d)

#define DPM_RegOpenKeyW(a,b,c)                                                 \
  ((typdpmRegOpenKeyW)(REGPFT->pfn[DPM_REGOPENKEYW]))(a,b,c)

#define DPM_RegQueryValueW(a,b,c,d)                                            \
  ((typdpmRegQueryValueW)(REGPFT->pfn[DPM_REGQUERYVALUEW]))(a,b,c,d)

#define DPM_RegSetValueW(a,b,c,d,e)                                            \
  ((typdpmRegSetValueW)(REGPFT->pfn[DPM_REGSETVALUEW]))(a,b,c,d,e)

#define DPM_RegDeleteValueW(a,b)                                               \
  ((typdpmRegDeleteValueW)(REGPFT->pfn[DPM_REGDELETEVALUEW]))(a,b)

#define DPM_RegEnumValueW(a,b,c,d,e,f,g,h)                                     \
  ((typdpmRegEnumValueW)(REGPFT->pfn[DPM_REGENUMVALUEW]))(a,b,c,d,e,f,g,h)

#define DPM_RegLoadKeyW(a,b,c)                                                 \
  ((typdpmRegLoadKeyW)(REGPFT->pfn[DPM_REGLOADKEYW]))(a,b,c)

#define DPM_RegQueryValueExW(a,b,c,d,e,f)                                      \
  ((typdpmRegQueryValueExW)(REGPFT->pfn[DPM_REGQUERYVALUEEXW]))(a,b,c,d,e,f)

#define DPM_RegSaveKeyW(a,b,c)                                                 \
  ((typdpmRegSaveKeyW)(REGPFT->pfn[DPM_REGSAVEKEYW]))(a,b,c)

#define DPM_RegSetValueExW(a,b,c,d,e,f)                                        \
  ((typdpmRegSetValueExW)(REGPFT->pfn[DPM_REGSETVALUEEXW]))(a,b,c,d,e,f)

#define DPM_RegUnLoadKeyW(a,b)                                                 \
  ((typdpmRegUnLoadKeyW)(REGPFT->pfn[DPM_REGUNLOADKEYW]))(a,b)

#define DPM_RegConnectRegistryW(a,b,c)                                         \
  ((typdpmRegConnectRegistryW)(REGPFT->pfn[DPM_REGCONNECTREGISTRYW]))(a,b,c)

#define DPM_RegCreateKeyExW(a,b,c,d,e,f,g,h,i)                                 \
  ((typdpmRegCreateKeyExW)(REGPFT->pfn[DPM_REGCREATEKEYEXW]))(a,b,c,d,e,f,g,h,i)

#define DPM_RegEnumKeyExW(a,b,c,d,e,f,g,h)                                     \
  ((typdpmRegEnumKeyExW)(REGPFT->pfn[DPM_REGENUMKEYEXW]))(a,b,c,d,e,f,g,h)

#define DPM_RegOpenKeyExW(a,b,c,d,e)                                           \
  ((typdpmRegOpenKeyExW)(REGPFT->pfn[DPM_REGOPENKEYEXW]))(a,b,c,d,e)

#define DPM_RegQueryInfoKeyW(a,b,c,d,e,f,g,h,i,j,k,l)                          \
  ((typdpmRegQueryInfoKeyW)(REGPFT->pfn[DPM_REGQUERYINFOKEYW]))(a,b,c,d,e,f,g,h,i,j,k,l)

#define DPM_RegQueryMultipleValuesW(a,b,c,d,e)                                 \
  ((typdpmRegQueryMultipleValuesW)(REGPFT->pfn[DPM_REGQUERYMULTIPLEVALUESW]))(a,b,c,d,e)

#define DPM_RegReplaceKeyW(a,b,c,d)                                            \
  ((typdpmRegReplaceKeyW)(REGPFT->pfn[DPM_REGREPLACEKEYW]))(a,b,c,d)







// Macros to dispatch Shimed API calls properly from the dpmfxxx.dll
#define SHM_RegCloseKey(a)                                                     \
     (REG_SHIM(DPM_REGCLOSEKEY,                                                \
               typdpmRegCloseKey))(a)
#define SHM_RegCreateKey(a,b,c)                                                \
     (REG_SHIM(DPM_REGCREATEKEY,                                               \
               typdpmRegCreateKey))(a,b,c)
#define SHM_RegDeleteKey(a,b)                                                  \
     (REG_SHIM(DPM_REGDELETEKEY,                                               \
               typdpmRegDeleteKey))(a,b)
#define SHM_RegEnumKey(a,b,c,d)                                                \
     (REG_SHIM(DPM_REGENUMKEY,                                                 \
               typdpmRegEnumKey))(a,b,c,d)
#define SHM_RegOpenKey(a,b,c)                                                  \
     (REG_SHIM(DPM_REGOPENKEY,                                                 \
               typdpmRegOpenKey))(a,b,c)
#define SHM_RegQueryValue(a,b,c,d)                                             \
     (REG_SHIM(DPM_REGQUERYVALUE,                                              \
               typdpmRegQueryValue))(a,b,c,d)
#define SHM_RegSetValue(a,b,c,d,e)                                             \
     (REG_SHIM(DPM_REGSETVALUE,                                                \
               typdpmRegSetValue))(a,b,c,d,e)
#define SHM_RegDeleteValue(a,b)                                                \
     (REG_SHIM(DPM_REGDELETEVALUE,                                             \
               typdpmRegDeleteValue))(a,b)
#define SHM_RegEnumValue(a,b,c,d,e,f,g,h)                                      \
     (REG_SHIM(DPM_REGENUMVALUE,                                               \
               typdpmRegEnumValue))(a,b,c,d,e,f,g,h)
#define SHM_RegFlushKey(a)                                                     \
     (REG_SHIM(DPM_REGFLUSHKEY,                                                \
               typdpmRegFlushKey))(a)
#define SHM_RegLoadKey(a,b,c)                                                  \
     (REG_SHIM(DPM_REGLOADKEY,                                                 \
               typdpmRegLoadKey))(a,b,c)
#define SHM_RegQueryValueEx(a,b,c,d,e,f)                                       \
     (REG_SHIM(DPM_REGQUERYVALUEEX,                                            \
               typdpmRegQueryValueEx))(a,b,c,d,e,f)
#define SHM_RegSaveKey(a,b,c)                                                  \
     (REG_SHIM(DPM_REGSAVEKEY,                                                 \
               typdpmRegSaveKey))(a,b,c)
#define SHM_RegSetValueEx(a,b,c,d,e,f)                                         \
     (REG_SHIM(DPM_REGSETVALUEEX,                                              \
               typdpmRegSetValueEx))(a,b,c,d,e,f)
#define SHM_RegUnLoadKey(a,b)                                                  \
     (REG_SHIM(DPM_REGUNLOADKEY,                                               \
               typdpmRegUnLoadKey))(a,b)
#define SHM_RegConnectRegistry(a,b,c)                                          \
     (REG_SHIM(DPM_REGCONNECTREGISTRY,                                         \
               typdpmRegConnectRegistry))(a,b,c)
#define SHM_RegCreateKeyEx(a,b,c,d,e,f,g,h,i)                                  \
     (REG_SHIM(DPM_REGCREATEKEYEX,                                             \
               typdpmRegCreateKeyEx))(a,b,c,d,e,f,g,h,i)
#define SHM_RegEnumKeyEx(a,b,c,d,e,f,g,h)                                      \
     (REG_SHIM(DPM_REGENUMKEYEX,                                               \
               typdpmRegEnumKeyEx))(a,b,c,d,e,f,g,h)
#define SHM_RegNotifyChangeKeyValue(a,b,c,d,e)                                 \
     (REG_SHIM(DPM_REGNOTIFYCHANGEKEYVALUE,                                    \
               typdpmRegNotifyChangeKeyValue))(a,b,c,d,e)
#define SHM_RegOpenKeyEx(a,b,c,d,e)                                            \
     (REG_SHIM(DPM_REGOPENKEYEX,                                               \
               typdpmRegOpenKeyEx))(a,b,c,d,e)
#define SHM_RegQueryInfoKey(a,b,c,d,e,f,g,h,i,j,k,l)                           \
     (REG_SHIM(DPM_REGQUERYINFOKEY,                                            \
               typdpmRegQueryInfoKey))(a,b,c,d,e,f,g,h,i,j,k,l)
#define SHM_RegQueryMultipleValues(a,b,c,d,e)                                  \
     (REG_SHIM(DPM_REGQUERYMULTIPLEVALUES,                                     \
               typdpmRegQueryMultipleValues))(a,b,c,d,e)
#define SHM_RegReplaceKey(a,b,c,d)                                             \
     (REG_SHIM(DPM_REGREPLACEKEY,                                              \
               typdpmRegReplaceKey))(a,b,c,d)
#define SHM_RegCreateKeyW(a,b,c)                                               \
     (REG_SHIM(DPM_REGCREATEKEYW,                                              \
               typdpmRegCreateKeyW))(a,b,c)
#define SHM_RegDeleteKeyW(a,b)                                                 \
     (REG_SHIM(DPM_REGDELETEKEYW,                                              \
               typdpmRegDeleteKeyW))(a,b)
#define SHM_RegEnumKeyW(a,b,c,d)                                               \
     (REG_SHIM(DPM_REGENUMKEYW,                                                \
               typdpmRegEnumKeyW))(a,b,c,d)
#define SHM_RegOpenKeyW(a,b,c)                                                 \
     (REG_SHIM(DPM_REGOPENKEYW,                                                \
               typdpmRegOpenKeyW))(a,b,c)
#define SHM_RegQueryValueW(a,b,c,d)                                            \
     (REG_SHIM(DPM_REGQUERYVALUEW,                                             \
               typdpmRegQueryValueW))(a,b,c,d)
#define SHM_RegSetValueW(a,b,c,d,e)                                            \
     (REG_SHIM(DPM_REGSETVALUEW,                                               \
               typdpmRegSetValueW))(a,b,c,d,e)
#define SHM_RegDeleteValueW(a,b)                                               \
     (REG_SHIM(DPM_REGDELETEVALUEW,                                            \
               typdpmRegDeleteValueW))(a,b)
#define SHM_RegEnumValueW(a,b,c,d,e,f,g,h)                                     \
     (REG_SHIM(DPM_REGENUMVALUEW,                                              \
               typdpmRegEnumValueW))(a,b,c,d,e,f,g,h)
#define SHM_RegLoadKeyW(a,b,c)                                                 \
     (REG_SHIM(DPM_REGLOADKEYW,                                                \
               typdpmRegLoadKeyW))(a,b,c)
#define SHM_RegQueryValueExW(a,b,c,d,e,f)                                      \
     (REG_SHIM(DPM_REGQUERYVALUEEXW,                                           \
               typdpmRegQueryValueExW))(a,b,c,d,e,f)
#define SHM_RegSaveKeyW(a,b,c)                                                 \
     (REG_SHIM(DPM_REGSAVEKEYW,                                                \
               typdpmRegSaveKeyW))(a,b,c)
#define SHM_RegSetValueExW(a,b,c,d,e,f)                                        \
     (REG_SHIM(DPM_REGSETVALUEEXW,                                             \
               typdpmRegSetValueExW))(a,b,c,d,e,f)
#define SHM_RegUnLoadKeyW(a,b)                                                 \
     (REG_SHIM(DPM_REGUNLOADKEYW,                                              \
               typdpmRegUnLoadKeyW))(a,b)
#define SHM_RegConnectRegistryW(a,b,c)                                         \
     (REG_SHIM(DPM_REGCONNECTREGISTRYW,                                        \
               typdpmRegConnectRegistryW))(a,b,c)
#define SHM_RegCreateKeyExW(a,b,c,d,e,f,g,h,i)                                 \
     (REG_SHIM(DPM_REGCREATEKEYEXW,                                            \
               typdpmRegCreateKeyExW))(a,b,c,d,e,f,g,h,i)
#define SHM_RegEnumKeyExW(a,b,c,d,e,f,g,h)                                     \
     (REG_SHIM(DPM_REGENUMKEYEXW,                                              \
               typdpmRegEnumKeyExW))(a,b,c,d,e,f,g,h)
#define SHM_RegOpenKeyExW(a,b,c,d,e)                                           \
     (REG_SHIM(DPM_REGOPENKEYEXW,                                              \
               typdpmRegOpenKeyExW))(a,b,c,d,e)
#define SHM_RegQueryInfoKeyW(a,b,c,d,e,f,g,h,i,j,k,l)                          \
     (REG_SHIM(DPM_REGQUERYINFOKEYW,                                           \
               typdpmRegQueryInfoKeyW))(a,b,c,d,e,f,g,h,i,j,k,l)
#define SHM_RegQueryMultipleValuesW(a,b,c,d,e)                                 \
     (REG_SHIM(DPM_REGQUERYMULTIPLEVALUESW,                                    \
               typdpmRegQueryMultipleValuesW))(a,b,c,d,e)
#define SHM_RegReplaceKeyW(a,b,c,d)                                            \
     (REG_SHIM(DPM_REGREPLACEKEYW,                                             \
               typdpmRegReplaceKeyW))(a,b,c,d)

#endif // _DPMF_REGAPI_H_




// These need to be in the same order as the RegFam enum definitions above and
// the DpmRegTbl[] list below.
// This instantiates memory for DpmRegStrs[] in mvdm\wow32\wdpm.c
#ifdef _WDPM_C_
const char *DpmRegStrs[] = {"RegCloseKey",
                            "RegCreateKeyA",
                            "RegDeleteKeyA",
                            "RegEnumKeyA",
                            "RegOpenKeyA",
                            "RegQueryValueA",
                            "RegSetValueA",
                            "RegDeleteValueA",
                            "RegEnumValueA",
                            "RegFlushKey",
                            "RegLoadKeyA",
                            "RegQueryValueExA",
                            "RegSaveKeyA",
                            "RegSetValueExA",
                            "RegUnLoadKeyA",
                            "RegConnectRegistryA",
                            "RegCreateKeyExA",
                            "RegEnumKeyExA",
                            "RegNotifyChangeKeyValue",
                            "RegOpenKeyExA",
                            "RegQueryInfoKeyA",
                            "RegQueryMultipleValuesA",
                            "RegReplaceKeyA",
                            "RegCreateKeyW",
                            "RegDeleteKeyW",
                            "RegEnumKeyW",
                            "RegOpenKeyW",
                            "RegQueryValueW",
                            "RegSetValueW",
                            "RegDeleteValueW",
                            "RegEnumValueW",
                            "RegLoadKeyW",
                            "RegQueryValueExW",
                            "RegSaveKeyW",
                            "RegSetValueExW",
                            "RegUnLoadKeyW",
                            "RegConnectRegistryW",
                            "RegCreateKeyExW",
                            "RegEnumKeyExW",
                            "RegOpenKeyExW",
                            "RegQueryInfoKeyW",
                            "RegQueryMultipleValuesW",
                            "RegReplaceKeyW"};

// These need to be in the same order as the RegFam enum definitions and the
// the DpmRegStrs[] list above.
// This instantiates memory for DpmRegTbl[] in mvdm\wow32\wdpm.c
PVOID DpmRegTbl[] = {RegCloseKey,
                     RegCreateKeyA,
                     RegDeleteKeyA,
                     RegEnumKeyA,
                     RegOpenKeyA,
                     RegQueryValueA,
                     RegSetValueA,
                     RegDeleteValueA,
                     RegEnumValueA,
                     RegFlushKey,
                     RegLoadKeyA,
                     RegQueryValueExA,
                     RegSaveKeyA,
                     RegSetValueExA,
                     RegUnLoadKeyA,
                     RegConnectRegistryA,
                     RegCreateKeyExA,
                     RegEnumKeyExA,
                     RegNotifyChangeKeyValue,
                     RegOpenKeyExA,
                     RegQueryInfoKeyA,
                     RegQueryMultipleValuesA,
                     RegReplaceKeyA,
                     RegCreateKeyW,
                     RegDeleteKeyW,
                     RegEnumKeyW,
                     RegOpenKeyW,
                     RegQueryValueW,
                     RegSetValueW,
                     RegDeleteValueW,
                     RegEnumValueW,
                     RegLoadKeyW,
                     RegQueryValueExW,
                     RegSaveKeyW,
                     RegSetValueExW,
                     RegUnLoadKeyW,
                     RegConnectRegistryW,
                     RegCreateKeyExW,
                     RegEnumKeyExW,
                     RegOpenKeyExW,
                     RegQueryInfoKeyW,
                     RegQueryMultipleValuesW,
                     RegReplaceKeyW};

#define NUM_HOOKED_REG_APIS  ((sizeof DpmRegTbl)/(sizeof DpmRegTbl[0])) 

// This instantiates memory for DpmRegFam in mvdm\wow32\wdpm.c
FAMILY_TABLE DpmRegFam = {NUM_HOOKED_REG_APIS, 0, 0, 0, 0, DpmRegTbl};

#endif // _WDPM_C_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\dpmi.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dpmi.h

Abstract:

    This file contains code to implement support for the DPMI bops

Author:

    Dave Hastings (daveh) 27-Jun-1991

Revision History:


--*/

/* ASM
ifdef WOW_x86
include vint.inc
endif
include bop.inc
*/
#define LDT_SIZE 0x1FFF

// DPMI Bop Sub Functions

#define InitDosxRM                  0
#define InitDosx                    1
#define InitLDT                     2
#define GetFastBopAddress           3
#define InitIDT                     4
#define InitExceptionHandlers       5
#define InitApp                     6
#define TerminateApp                7
#define DpmiInUse                   8
#define DpmiNoLongerInUse           9

#define DPMISwitchToProtectedMode   10 /* prefix necessary */
#define DPMISwitchToRealMode        11
#define SetAltRegs                  12

#define IntHandlerIret              13
#define IntHandlerIretd             14
#define FaultHandlerIret            15
#define FaultHandlerIretd           16
#define DpmiUnhandledException      17

#define RMCallBackCall              18
#define ReflectIntrToPM             19
#define ReflectIntrToV86            20

#define InitPmStackInfo             21
#define VcdPmSvcCall32              22
#define SetDescriptorTableEntries   23
#define ResetLDTUserBase            24

#define XlatInt21Call               25
#define Int31Entry                  26
#define Int31Call                   27

#define HungAppIretAndExit          28

#define MAX_DPMI_BOP_FUNC HungAppIretAndExit + 1

/* ASM
DPMIBOP macro SubFun
    BOP BOP_DPMI
    db SubFun
    endm
*/


//
// Definitions for real mode call backs
//

/* XLATOFF */
typedef struct _RMCB_INFO {
    BOOL bInUse;
    USHORT StackSel;
    USHORT StrucSeg;
    ULONG  StrucOffset;
    USHORT ProcSeg;
    ULONG  ProcOffset;
} RMCB_INFO;

// 16 is the minimum defined in the dpmi spec
#define MAX_RMCBS 16


typedef struct _MEM_DPMI {
    PVOID Address;
    ULONG Length;
    struct _MEM_DPMI * Prev;
    struct _MEM_DPMI * Next;
    WORD Owner;
    WORD Sel;
    WORD SelCount;
} MEM_DPMI, *PMEM_DPMI;

VOID
SetShadowDescriptorEntries(
    USHORT SelStart,
    USHORT SelCount
    );

/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\dpmf_prf.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 2002, Microsoft Corporation
 *
 *  dpmf_prf.h
 *  WOW32 Dynamic Patch Module to support Profile API family
 *  Definitions & macors to support calls into dpmfprf.dll
 *
 *  History:
 *  Created 01-10-2002 by cmjones
--*/

#ifndef _DPMF_PRFAPI_H_
#define _DPMF_PRFAPI_H_ 


#define PRFPFT               (DPMFAMTBLS()[PRF_FAM])
#define PRF_SHIM(ord, typ)   ((typ)((pFT)->pDpmShmTbls[ord]))


enum PrfFam {DPM_GETPRIVATEPROFILEINT=0,       // Win 3.1 set
             DPM_GETPRIVATEPROFILESTRING, 
             DPM_GETPROFILEINT,
             DPM_GETPROFILESTRING,
             DPM_WRITEPRIVATEPROFILESTRING, 
             DPM_WRITEPROFILESTRING,           // End Win 3.1 set 
             DPM_WRITEPRIVATEPROFILESECTION,
             DPM_GETPRIVATEPROFILESECTION,
             DPM_GETPRIVATEPROFILESECTIONNAMES,
             DPM_GETPRIVATEPROFILESTRUCT,
             DPM_WRITEPRIVATEPROFILESTRUCT,
             DPM_WRITEPROFILESECTION,
             DPM_GETPROFILESECTION,
             DPM_GETPRIVATEPROFILEINTW,         // WIDE CHAR versions for
             DPM_GETPRIVATEPROFILESTRINGW,      // generic thunk support
             DPM_GETPROFILEINTW,
             DPM_GETPROFILESTRINGW,
             DPM_WRITEPRIVATEPROFILESTRINGW,
             DPM_WRITEPROFILESTRINGW,
             DPM_WRITEPRIVATEPROFILESECTIONW,
             DPM_GETPRIVATEPROFILESECTIONW,
             DPM_GETPRIVATEPROFILESECTIONNAMESW,
             DPM_GETPRIVATEPROFILESTRUCTW,
             DPM_WRITEPRIVATEPROFILESTRUCTW,
             DPM_WRITEPROFILESECTIONW,
             DPM_GETPROFILESECTIONW,
             enum_prf_last
             };



// These types will catch misuse of parameters & ret types
typedef ULONG (*typdpmGetPrivateProfileInt)(LPCSTR, LPCSTR, int, LPCSTR);
typedef ULONG (*typdpmGetPrivateProfileString)(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
typedef ULONG (*typdpmWritePrivateProfileString)(LPCSTR, LPCSTR, LPCSTR, LPCSTR);
typedef ULONG (*typdpmGetProfileInt)(LPCSTR, LPCSTR, int);
typedef ULONG (*typdpmGetProfileString)(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
typedef ULONG (*typdpmWriteProfileString)(LPCSTR, LPCSTR, LPCSTR);
typedef ULONG (*typdpmWritePrivateProfileSection)(LPCSTR, LPCSTR, LPCSTR);
typedef ULONG (*typdpmGetPrivateProfileSection)(LPCSTR, LPSTR, DWORD, LPCSTR);
typedef ULONG (*typdpmGetPrivateProfileSectionNames)(LPSTR, DWORD, LPCSTR);
typedef ULONG (*typdpmGetPrivateProfileStruct)(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);
typedef ULONG (*typdpmWritePrivateProfileStruct)(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);
typedef ULONG (*typdpmWriteProfileSection)(LPCSTR, LPCSTR);
typedef ULONG (*typdpmGetProfileSection)(LPCSTR, LPSTR, DWORD);
typedef ULONG (*typdpmGetPrivateProfileIntW)(LPCWSTR, LPCWSTR, int, LPCWSTR);
typedef ULONG (*typdpmGetPrivateProfileStringW)(LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, int, LPCWSTR);
typedef ULONG (*typdpmWritePrivateProfileStringW)(LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR);
typedef ULONG (*typdpmGetProfileIntW)(LPCWSTR, LPCWSTR, int);
typedef ULONG (*typdpmGetProfileStringW)(LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, int);
typedef ULONG (*typdpmWriteProfileStringW)(LPCWSTR, LPCWSTR, LPCWSTR);
typedef ULONG (*typdpmWritePrivateProfileSectionW)(LPCWSTR, LPCWSTR, LPCWSTR);
typedef ULONG (*typdpmGetPrivateProfileSectionW)(LPCWSTR, LPWSTR, DWORD, LPCWSTR);
typedef ULONG (*typdpmGetPrivateProfileSectionNamesW)(LPWSTR, DWORD, LPCWSTR);
typedef ULONG (*typdpmGetPrivateProfileStructW)(LPCWSTR, LPCWSTR, LPVOID, UINT, LPCWSTR);
typedef ULONG (*typdpmWritePrivateProfileStructW)(LPCWSTR, LPCWSTR, LPVOID, UINT, LPCWSTR);
typedef ULONG (*typdpmWriteProfileSectionW)(LPCWSTR, LPCWSTR);
typedef ULONG (*typdpmGetProfileSectionW)(LPCWSTR, LPWSTR, DWORD);



// Macros to dispatch API calls properly
#define DPM_GetPrivateProfileInt(a,b,c,d)                                      \
  ((typdpmGetPrivateProfileInt)(PRFPFT->pfn[DPM_GETPRIVATEPROFILEINT]))(a,b,c,d)

#define DPM_GetPrivateProfileString(a,b,c,d,e,f)                               \
  ((typdpmGetPrivateProfileString)(PRFPFT->pfn[DPM_GETPRIVATEPROFILESTRING]))(a,b,c,d,e,f)

#define DPM_GetProfileInt(a,b,c)                                               \
  ((typdpmGetProfileInt)(PRFPFT->pfn[DPM_GETPROFILEINT]))(a,b,c)

#define DPM_GetProfileString(a,b,c,d,e)                                        \
  ((typdpmGetProfileString)(PRFPFT->pfn[DPM_GETPROFILESTRING]))(a,b,c,d,e)

#define DPM_WritePrivateProfileString(a,b,c,d)                                 \
  ((typdpmWritePrivateProfileString)(PRFPFT->pfn[DPM_WRITEPRIVATEPROFILESTRING]))(a,b,c,d)

#define DPM_WriteProfileString(a,b,c)                                          \
  ((typdpmWriteProfileString)(PRFPFT->pfn[DPM_WRITEPROFILESTRING]))(a,b,c)

#define DPM_WritePrivateProfileSection(a,b,c)                                  \
  ((typdpmWritePrivateProfileSection)(PRFPFT->pfn[DPM_WRITEPRIVATEPROFILESECTION]))(a,b,c)

#define DPM_GetPrivateProfileSection(a,b,c,d)                                  \
  ((typdpmGetPrivateProfileSection)(PRFPFT->pfn[DPM_GETPRIVATEPROFILESECTION]))(a,b,c,d)

#define DPM_GetPrivateProfileSectionNames(a,b,c)                               \
  ((typdpmGetPrivateProfileSectionNames)(PRFPFT->pfn[DPM_GETPRIVATEPROFILESECTIONNAMES]))(a,b,c)

#define DPM_GetPrivateProfileStruct(a,b,c,d,e)                                 \
  ((typdpmGetPrivateProfileStruct)(PRFPFT->pfn[DPM_GETPRIVATEPROFILESTRUCT]))(a,b,c,d,e)

#define DPM_WritePrivateProfileStruct(a,b,c,d,e)                               \
  ((typdpmWritePrivateProfileStruct)(PRFPFT->pfn[DPM_WRITEPRIVATEPROFILESTRUCT]))(a,b,c,d,e)

#define DPM_WriteProfileSection(a,b)                                           \
  ((typdpmWriteProfileSection)(PRFPFT->pfn[DPM_WRITEPROFILESECTION]))(a,b)

#define DPM_GetProfileSection(a,b,c)                                           \
  ((typdpmGetProfileSection)(PRFPFT->pfn[DPM_GETPROFILESECTION]))(a,b,c)


#define DPM_GetPrivateProfileIntW(a,b,c,d)                                     \
  ((typdpmGetPrivateProfileIntW)(PRFPFT->pfn[DPM_GETPRIVATEPROFILEINTW]))(a,b,c,d)

#define DPM_GetPrivateProfileStringW(a,b,c,d,e,f)                              \
  ((typdpmGetPrivateProfileStringW)(PRFPFT->pfn[DPM_GETPRIVATEPROFILESTRINGW]))(a,b,c,d,e,f)

#define DPM_GetProfileIntW(a,b,c)                                              \
  ((typdpmGetProfileIntW)(PRFPFT->pfn[DPM_GETPROFILEINTW]))(a,b,c)

#define DPM_GetProfileStringW(a,b,c,d,e)                                       \
  ((typdpmGetProfileStringW)(PRFPFT->pfn[DPM_GETPROFILESTRINGW]))(a,b,c,d,e)

#define DPM_WritePrivateProfileStringW(a,b,c,d)                                \
  ((typdpmWritePrivateProfileStringW)(PRFPFT->pfn[DPM_WRITEPRIVATEPROFILESTRINGW]))(a,b,c,d)

#define DPM_WriteProfileStringW(a,b,c)                                         \
  ((typdpmWriteProfileStringW)(PRFPFT->pfn[DPM_WRITEPROFILESTRINGW]))(a,b,c)

#define DPM_WritePrivateProfileSectionW(a,b,c)                                 \
  ((typdpmWritePrivateProfileSectionW)(PRFPFT->pfn[DPM_WRITEPRIVATEPROFILESECTIONW]))(a,b,c)

#define DPM_GetPrivateProfileSectionW(a,b,c,d)                                 \
  ((typdpmGetPrivateProfileSectionW)(PRFPFT->pfn[DPM_GETPRIVATEPROFILESECTIONW]))(a,b,c,d)

#define DPM_GetPrivateProfileSectionNamesW(a,b,c)                              \
  ((typdpmGetPrivateProfileSectionNamesW)(PRFPFT->pfn[DPM_GETPRIVATEPROFILESECTIONNAMESW]))(a,b,c)

#define DPM_GetPrivateProfileStructW(a,b,c,d,e)                                \
  ((typdpmGetPrivateProfileStructW)(PRFPFT->pfn[DPM_GETPRIVATEPROFILESTRUCTW]))(a,b,c,d,e)

#define DPM_WritePrivateProfileStructW(a,b,c,d,e)                              \
  ((typdpmWritePrivateProfileStructW)(PRFPFT->pfn[DPM_WRITEPRIVATEPROFILESTRUCTW]))(a,b,c,d,e)

#define DPM_WriteProfileSectionW(a,b)                                          \
  ((typdpmWriteProfileSectionW)(PRFPFT->pfn[DPM_WRITEPROFILESECTIONW]))(a,b)

#define DPM_GetProfileSectionW(a,b,c)                                          \
  ((typdpmGetProfileSectionW)(PRFPFT->pfn[DPM_GETPROFILESECTIONW]))(a,b,c)




// Macros to dispatch Shimed API calls properly from the dpmfxxx.dll
#define SHM_GetPrivateProfileInt(a,b,c,d)                                      \
     (PRF_SHIM(DPM_GETPRIVATEPROFILEINT,                                       \
                  typdpmGetPrivateProfileInt))(a,b,c,d)
#define SHM_GetPrivateProfileString(a,b,c,d,e,f)                               \
     (PRF_SHIM(DPM_GETPRIVATEPROFILESTRING,                                    \
                  typdpmGetPrivateProfileString))(a,b,c,d,e,f)
#define SHM_GetProfileInt(a,b,c)                                               \
     (PRF_SHIM(DPM_GETPROFILEINT,                                              \
                  typdpmGetProfileInt))(a,b,c)
#define SHM_GetProfileString(a,b,c,d,e)                                        \
     (PRF_SHIM(DPM_GETPROFILESTRING,                                           \
                  typdpmGetProfileString))(a,b,c,d,e)
#define SHM_WritePrivateProfileString(a,b,c,d)                                 \
     (PRF_SHIM(DPM_WRITEPRIVATEPROFILESTRING,                                  \
                  typdpmWritePrivateProfileString))(a,b,c,d)
#define SHM_WriteProfileString(a,b,c)                                          \
     (PRF_SHIM(DPM_WRITEPROFILESTRING,                                         \
                  typdpmWriteProfileString))(a,b,c)
#define SHM_WritePrivateProfileSection(a,b,c)                                  \
     (PRF_SHIM(DPM_WRITEPRIVATEPROFILESECTION,                                 \
                  typdpmWritePrivateProfileSection))(a,b,c)
#define SHM_GetPrivateProfileSection(a,b,c,d)                                  \
     (PRF_SHIM(DPM_GETPRIVATEPROFILESECTION,                                   \
                  typdpmGetPrivateProfileSection))(a,b,c,d)
#define SHM_GetPrivateProfileSectionNames(a,b,c)                               \
     (PRF_SHIM(DPM_GETPRIVATEPROFILESECTIONNAMES,                              \
                  typdpmGetPrivateProfileSectionNames))(a,b,c)
#define SHM_GetPrivateProfileStruct(a,b,c,d,e)                                 \
     (PRF_SHIM(DPM_GETPRIVATEPROFILESTRUCT,                                    \
                  typdpmGetPrivateProfileStruct))(a,b,c,d,e)
#define SHM_WritePrivateProfileStruct(a,b,c,d,e)                               \
     (PRF_SHIM(DPM_WRITEPRIVATEPROFILESTRUCT,                                  \
                  typdpmWritePrivateProfileStruct))(a,b,c,d,e)
#define SHM_WriteProfileSection(a,b)                                           \
     (PRF_SHIM(DPM_WRITEPROFILESECTION,                                        \
                  typdpmWriteProfileSection))(a,b)
#define SHM_GetProfileSection(a,b,c)                                           \
     (PRF_SHIM(DPM_GETPROFILESECTION,                                          \
                  typdpmGetProfileSection))(a,b,c)

#define SHM_GetPrivateProfileIntW(a,b,c,d)                                     \
     (PRF_SHIM(DPM_GETPRIVATEPROFILEINTW,                                      \
                  typdpmGetPrivateProfileIntW))(a,b,c,d)
#define SHM_GetPrivateProfileStringW(a,b,c,d,e,f)                              \
     (PRF_SHIM(DPM_GETPRIVATEPROFILESTRINGW,                                   \
                  typdpmGetPrivateProfileStringW))(a,b,c,d,e,f)
#define SHM_GetProfileIntW(a,b,c)                                              \
     (PRF_SHIM(DPM_GETPROFILEINTW,                                             \
                  typdpmGetProfileIntW))(a,b,c)
#define SHM_GetProfileStringW(a,b,c,d,e)                                       \
     (PRF_SHIM(DPM_GETPROFILESTRINGW,                                          \
                  typdpmGetProfileStringW))(a,b,c,d,e)
#define SHM_WritePrivateProfileStringW(a,b,c,d)                                \
     (PRF_SHIM(DPM_WRITEPRIVATEPROFILESTRINGW,                                 \
                  typdpmWritePrivateProfileStringW))(a,b,c,d)
#define SHM_WriteProfileStringW(a,b,c)                                         \
     (PRF_SHIM(DPM_WRITEPROFILESTRINGW,                                        \
                  typdpmWriteProfileStringW))(a,b,c)
#define SHM_WritePrivateProfileSectionW(a,b,c)                                 \
     (PRF_SHIM(DPM_WRITEPRIVATEPROFILESECTIONW,                                \
                  typdpmWritePrivateProfileSectionW))(a,b,c)
#define SHM_GetPrivateProfileSectionW(a,b,c,d)                                 \
     (PRF_SHIM(DPM_GETPRIVATEPROFILESECTIONW,                                  \
                  typdpmGetPrivateProfileSectionW))(a,b,c,d)
#define SHM_GetPrivateProfileSectionNamesW(a,b,c)                              \
     (PRF_SHIM(DPM_GETPRIVATEPROFILESECTIONNAMESW,                             \
                  typdpmGetPrivateProfileSectionNamesW))(a,b,c)
#define SHM_GetPrivateProfileStructW(a,b,c,d,e)                                \
     (PRF_SHIM(DPM_GETPRIVATEPROFILESTRUCTW,                                   \
                  typdpmGetPrivateProfileStructW))(a,b,c,d,e)
#define SHM_WritePrivateProfileStructW(a,b,c,d,e)                              \
     (PRF_SHIM(DPM_WRITEPRIVATEPROFILESTRUCTW,                                 \
                  typdpmWritePrivateProfileStructW))(a,b,c,d,e)
#define SHM_WriteProfileSectionW(a,b)                                          \
     (PRF_SHIM(DPM_WRITEPROFILESECTIONW,                                       \
                  typdpmWriteProfileSectionW))(a,b)
#define SHM_GetProfileSectionW(a,b,c)                                          \
     (PRF_SHIM(DPM_GETPROFILESECTIONW,                                         \
                  typdpmGetProfileSectionW))(a,b,c)

#endif // _DPMF_PRFAPI_H_



// These need to be in the same order as the PrfFam enum definitions above and
// the DpmPrfTbl[] list below.// This instantiates memory for DpmPrfStrs in mvdm\wow32\wdpm.c
#ifdef _WDPM_C_
const char *DpmPrfStrs[] = {"GetPrivateProfileIntA",                            "GetPrivateProfileStringA",
                            "GetProfileIntA",
                            "GetProfileStringA",
                            "WritePrivateProfileStringA",
                            "WriteProfileStringA",
                            "WritePrivateProfileSectionA",
                            "GetPrivateProfileSectionA",
                            "GetPrivateProfileSectionNamesA",
                            "GetPrivateProfileStructA",
                            "WritePrivateProfileStructA",
                            "WriteProfileSectionA",
                            "GetProfileSectionA",
                            "GetPrivateProfileIntW",
                            "GetPrivateProfileStringW",
                            "GetProfileIntW",
                            "GetProfileStringW",
                            "WritePrivateProfileStringW",
                            "WriteProfileStringW",
                            "WritePrivateProfileSectionW",
                            "GetPrivateProfileSectionW",
                            "GetPrivateProfileSectionNamesW",
                            "GetPrivateProfileStructW",
                            "WritePrivateProfileStructW",
                            "WriteProfileSectionW",
                            "GetProfileSectionW"
                           };

// These need to be in the same order as the PrfFam enum definitions and the
// the DpmPrfStrs[] list above.// This instantiates memory for DpmPrfTbl[] in mvdm\wow32\wdpm.c
PVOID   DpmPrfTbl[] = {GetPrivateProfileIntA,                       GetPrivateProfileStringA,
                       GetProfileIntA,
                       GetProfileStringA,
                       WritePrivateProfileStringA,
                       WriteProfileStringA,
                       WritePrivateProfileSectionA,
                       GetPrivateProfileSectionA,
                       GetPrivateProfileSectionNamesA,
                       GetPrivateProfileStructA,
                       WritePrivateProfileStructA,
                       WriteProfileSectionA,
                       GetProfileSectionA,
                       GetPrivateProfileIntW,
                       GetPrivateProfileStringW,
                       GetProfileIntW,
                       GetProfileStringW,
                       WritePrivateProfileStringW,
                       WriteProfileStringW,
                       WritePrivateProfileSectionW,
                       GetPrivateProfileSectionW,
                       GetPrivateProfileSectionNamesW,
                       GetPrivateProfileStructW,
                       WritePrivateProfileStructW,
                       WriteProfileSectionW,
                       GetProfileSectionW
                      };

#define NUM_HOOKED_PRF_APIS  ((sizeof DpmPrfTbl)/(sizeof DpmPrfTbl[0])) 
// This instantiates memory for DpmPrfFam in mvdm\wow32\wdpm.c
FAMILY_TABLE DpmPrfFam = {NUM_HOOKED_PRF_APIS, 0, 0, 0, 0, DpmPrfTbl};

#endif // _WDPM_C_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\doswow.h ===
/*++ BUILD Version: 0002
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  DOSWOW.H
 *  Shared structures between NTDOS, DEM and WOW32
 *
 *  History:
 *  Created 03-Dec-1993 by Neil Sandlin (neilsa)
--*/

/* XLATOFF */

#pragma pack(2)

/* XLATON */

/*
 * The following structure is used by some of the WOW functions to
 * point to internal DOS data. This is done to emulate some of the more
 * involved functions in WOW32, while still maintaining DOS data integrity.
 */
typedef struct _DOSWOWDATA {           /* DWD */
    DWORD lpCDSCount;
    DWORD lpCDSFixedTable;
    DWORD lpCDSBuffer;
    DWORD lpCurDrv;
    DWORD lpCurPDB;
    DWORD lpDrvErr;
    DWORD lpExterrLocus; // byte
    DWORD lpSCS_ToSync;
    DWORD lpSftAddr;
    DWORD lpExterr;  // word
    DWORD lpExterrActionClass; // 2 bytes -- action and class
} DOSWOWDATA;
typedef DOSWOWDATA UNALIGNED *PDOSWOWDATA;


/* XLATOFF */

#pragma pack(1)

typedef struct _DOSPDB {                        // DOS Process Data Block
    CHAR   PDB_Not_Interested[44];      // Fields we are not interested in
    USHORT PDB_environ;             // segment of environment
    DWORD  PDB_User_stack;
    USHORT PDB_JFN_Length;          // JFT length
    ULONG  PDB_JFN_Pointer;         // JFT pointer
} DOSPDB, *PDOSPDB;


typedef struct _DOSSF {             // DOS header for SFT chain
    ULONG  SFLink;                  // Link to next SF
    USHORT SFCount;                 // number of entries
    USHORT SFTable;                 // beginning of array of the SFTs
} DOSSF;
typedef DOSSF UNALIGNED *PDOSSF;


#define SFT_NAMED_PIPE 0x2000       // named pipe flag

typedef struct _DOSSFT {            // DOS SFT
    USHORT  SFT_Ref_Count;          // Howmany tasks using it
    USHORT  SFT_Mode;               // Mode of access
    UCHAR   SFT_Attr;               // Attribute of file
    USHORT  SFT_Flags;              // Bit 15 = 1 if remote file
                                    //        = 0 if local or device
    ULONG   SFT_Devptr;             // Device pointer
    USHORT  SFT_Time;
    USHORT  SFT_Date;
    ULONG   SFT_Size;
    ULONG   SFT_Position;
    ULONG   SFT_Chain;
    USHORT  SFT_PID;
    ULONG   SFT_NTHandle;           // NT File Handle
} DOSSFT;
typedef DOSSFT UNALIGNED *PDOSSFT;

// execblock
typedef struct _DOSEXECBLOCK {
   USHORT envseg;   // env segment
   ULONG  lpcmdline; // command line tail
   ULONG  lpfcb1;    // fcb1
   ULONG  lpfcb2;    // fcb2
}  DOSEXECBLOCK, UNALIGNED *PDOSEXECBLOCK;

#define NE_FLAGS_OFFSET 0xc
#define NEPROT 0x8   // runs in prot mode only


#define SF_NT_SEEK 0x0200

#pragma pack()

// these are demLFN structures that work with wow and dem

typedef VOID (*PDOSWOWUPDATETDBDIR)(UCHAR, LPSTR);
typedef BOOL (*PDOSWOWGETTDBDIR)(UCHAR Drive, LPSTR pCurrentDirectory);
typedef BOOL (*PDOSWOWDODIRECTHDPOPUP)(VOID);
typedef BOOL (*PDOSWOWGETCOMPATFLAGS)(LPDWORD lpdwCF, LPDWORD lpdwCFEx);


typedef struct tagWOWLFNInit {
   PDOSWOWUPDATETDBDIR pDosWowUpdateTDBDir;
   PDOSWOWGETTDBDIR pDosWowGetTDBDir;
   PDOSWOWDODIRECTHDPOPUP pDosWowDoDirectHDPopup;
#if 0
   PDOSWOWGETCOMPATFLAGS pDosWowGetCompatFlags;
#endif
}  WOWLFNINIT, *PWOWLFNINIT;


/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\dossvc.h ===
/** SVC Defines
 *
 *  Revision history:
 *
 *  sudeepb 27-Feb-1991 Created
 */

/* VHE - Virtual Hard Error packet.
 *
 *   DEM makes fbInt24 to true if an hard error happens.
 */

typedef struct vhe_s {
    char  vhe_fbInt24;      // Was there a hard error?
    char  vhe_HrdErrCode;   // If hard error then this is the error code
    char  vhe_bDriveNum;    // If so on which drive
} VHE;

typedef VHE *PVHE;

/* DEMEXTERR - Extended Error structure. The following structure contains the
 * DOS extended error elements which are loosely coupled in the DOS data
 * segment
 *
 */

/* XLATOFF */
#include <packon.h>

typedef struct _DEMEXTERR {
    UCHAR   ExtendedErrorLocus;
    USHORT  ExtendedError;
    UCHAR   ExtendedErrorAction;
    UCHAR   ExtendedErrorClass;
    PUCHAR  ExtendedErrorPointer;
} DEMEXTERR;

typedef DEMEXTERR* PDEMEXTERR;


/* SYSDEV - Device chain node
 */

typedef struct _SYSDEV {

    ULONG   sdevNext;       // REAL mode pointer to next device.  -1 for end of chain.
    char    sdevIgnore[6];
    UCHAR   sdevDevName[8]; // device name

} SYSDEV;

typedef SYSDEV UNALIGNED *PSYSDEV;

#ifndef _DEMINCLUDED_
extern DECLSPEC_IMPORT PSYSDEV pDeviceChain;
#else
extern PSYSDEV pDeviceChain;
#endif


/* XLATON */

/* XLATOFF */
#include <packoff.h>
/* XLATON */

/* Note : To add a new SVC:
 *      New SVC gets the current value of SVC_LASTSVC. Increment
 *      the SVC_LASTSVC value. Add the appropriate SVC handler
 *      in apfnSVC (file dem\demdisp.c) at the end.
 *    To delete a SVC :
 *      Move each SVC one level up. Appropriatly adjust the
 *      apfnSVC (file dem\demdisp.c).
 */

/* SVC - Supervisory Call macro.
 *
 *   This macro is used by NTDOS and NTBIO to call DEM.
 *
 */

#define NTVDMDBG 1

/* ASM
include bop.inc

svc macro   func
    BOP BOP_DOS
    db  func
    endm
*/
#define SVC_DEMCHGFILEPTR               0x00
#define SVC_DEMCHMOD            0x01
#define SVC_DEMCLOSE            0x02
#define SVC_DEMCREATE           0x03
#define SVC_DEMCREATEDIR        0x04
#define SVC_DEMDELETE           0x05
#define SVC_DEMDELETEDIR        0x06
#define SVC_DEMDELETEFCB        0x07
#define SVC_DEMFILETIMES        0x08
#define SVC_DEMFINDFIRST        0x09
#define SVC_DEMFINDFIRSTFCB     0x0a
#define SVC_DEMFINDNEXT         0x0b
#define SVC_DEMFINDNEXTFCB      0x0c
#define SVC_DEMGETBOOTDRIVE     0x0d
#define SVC_DEMGETDRIVEFREESPACE    0x0e
#define SVC_DEMGETDRIVES        0x0f
#define SVC_DEMGSETMEDIAID      0x10
#define SVC_DEMLOADDOS          0x11
#define SVC_DEMOPEN         0x12
#define SVC_DEMQUERYCURRENTDIR      0x13
#define SVC_DEMQUERYDATE        0x14
#define SVC_DEMQUERYTIME        0x15
#define SVC_DEMREAD         0x16
#define SVC_DEMRENAME           0x17
#define SVC_DEMSETCURRENTDIR        0x18
#define SVC_DEMSETDATE          0x19
#define SVC_DEMSETDEFAULTDRIVE      0x1a
#define SVC_DEMSETDTALOCATION       0x1b
#define SVC_DEMSETTIME          0x1c
#define SVC_DEMSETV86KERNELADDR     0x1d
#define SVC_DEMWRITE            0x1e
#define SVC_GETDRIVEINFO        0x1f
#define SVC_DEMRENAMEFCB        0x20
#define SVC_DEMIOCTL            0x21
#define SVC_DEMCREATENEW        0x22
#define SVC_DEMDISKRESET        0x23
#define SVC_DEMSETDPB           0x24
#define SVC_DEMGETDPB           0x25
#define SVC_DEMSLEAZEFUNC       0x26
#define SVC_DEMCOMMIT           0x27
#define SVC_DEMEXTHANDLE        0x28
#define SVC_DEMABSDRD           0x29
#define SVC_DEMABSDWRT          0x2a
#define SVC_DEMGSETCDPG         0x2b
#define SVC_DEMCREATEFCB        0x2c
#define SVC_DEMOPENFCB          0x2d
#define SVC_DEMCLOSEFCB         0x2e
#define SVC_DEMFCBIO            0x2f
#define SVC_DEMDATE16           0x30
#define SVC_DEMGETFILEINFO      0x31
#define SVC_DEMSETHARDERRORINFO     0x32
#define SVC_DEMRETRY            0x33
#define SVC_DEMLOADDOSAPPSYM        0x34
#define SVC_DEMFREEDOSAPPSYM        0x35
#define SVC_DEMENTRYDOSAPP              0x36
#define SVC_DEMDOSDISPCALL              0x37
#define SVC_DEMDOSDISPRET               0x38
#define SVC_OUTPUT_STRING               0x39
#define SVC_INPUT_STRING        0x3A
#define SVC_ISDEBUG         0x3B
#define SVC_PDBTERMINATE        0x3C
#define SVC_DEMEXITVDM          0x3D
#define SVC_DEMWOWFILES         0x3E
#define SVC_DEMLOCKOPER         0x3F
#define SVC_DEMDRIVEFROMHANDLE  0x40
#define SVC_DEMGETCOMPUTERNAME  0x41
#define SVC_DEMFASTREAD         0x42
#define SVC_DEMFASTWRITE        0x43
#define SVC_DEMCHECKPATH        0x44
#define SVC_DEMSYSTEMSYMBOLOP   0x45
#define SVC_DEMGETDPBLIST       0x46

#define SVC_DEMPIPEFILEDATAEOF  0x47
#define SVC_DEMPIPEFILEEOF      0x48
#define SVC_DEMLFNENTRY         0x49
#define SVC_SETDOSVARLOCATION   0x4A
#define SVC_DEMLASTSVC          0x4B


/*
 *   Equates used in the DEMxxxSYSTEMxxx calls
 */
#define SYMOP_LOAD 1
#define SYMOP_FREE 2
#define SYMOP_MOVE 3
#define SYMOP_CLEANUP 0x80

#define ID_NTIO 1
#define ID_NTDOS 2

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\dpmf_ntd.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 2002, Microsoft Corporation
 *
 *  dpmf_ntd.h
 *  NTVDM Dynamic Patch Module to support misc NTDLL API family
 *  Definitions & macors to support calls into dpmfntd.dll
 *
 *  History:
 *  Created 01-10-2002 by cmjones
--*/

#ifndef _DPMF_NTDAPI_H_
#define _DPMF_NTDAPI_H_ 

typedef DWORD ACCESS_MASK__;  // including winnt.h here causes a mess


#define NTDPFT               (DPMFAMTBLS()[NTD_FAM])
#define NTD_SHIM(ord, typ)   ((typ)((pFT)->pDpmShmTbls[ord]))


enum NtdFam {DPM_NTOPENFILE=0,
             DPM_NTQUERYDIRECTORYFILE, 
             DPM_RTLGETFULLPATHNAME_U,
             DPM_RTLGETCURRENTDIRECTORY_U,
             DPM_RTLSETCURRENTDIRECTORY_U,
             DPM_NTVDMCONTROL,
             enum_ntd_last};

// These types will catch misuse of parameters & ret types
typedef DWORD (*typdpmNtOpenFile)(PHANDLE, ACCESS_MASK__, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, ULONG, ULONG);
typedef DWORD (*typdpmNtQueryDirectoryFile)(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, PVOID, ULONG, FILE_INFORMATION_CLASS, BOOLEAN, PUNICODE_STRING, BOOLEAN);
typedef DWORD (*typdpmRtlGetFullPathName_U)(PCWSTR, ULONG, PWSTR, PWSTR *);
typedef DWORD (*typdpmRtlGetCurrentDirectory_U)(ULONG, PWSTR);
typedef NTSTATUS (*typdpmRtlSetCurrentDirectory_U)(PUNICODE_STRING);
typedef NTSTATUS (*typdpmNtVdmControl)(VDMSERVICECLASS, PVOID);



// Macros to dispatch API calls properly
#define DPM_NtOpenFile(a,b,c,d,e,f)                                            \
  ((typdpmNtOpenFile)(NTDPFT->pfn[DPM_NTOPENFILE]))(a,b,c,d,e,f)

#define DPM_NtQueryDirectoryFile(a,b,c,d,e,f,g,h,i,j,k)                        \
   ((typdpmNtQueryDirectoryFile)(NTDPFT->pfn[DPM_NTQUERYDIRECTORYFILE]))(a,b,c,d,e,f,g,h,i,j,k)

#define DPM_RtlGetFullPathName_U(a,b,c,d)                                      \
   ((typdpmRtlGetFullPathName_U)(NTDPFT->pfn[DPM_RTLGETFULLPATHNAME_U]))(a,b,c,d)

#define DPM_RtlGetCurrentDirectory_U(a,b)                                      \
   ((typdpmRtlGetCurrentDirectory_U)(NTDPFT->pfn[DPM_RTLGETCURRENTDIRECTORY_U]))(a,b)

#define DPM_RtlSetCurrentDirectory_U(a)                                        \
   ((typdpmRtlSetCurrentDirectory_U)(NTDPFT->pfn[DPM_RTLSETCURRENTDIRECTORY_U]))(a)

#define DPM_NtVdmControl(a,b)                                                  \
   ((typdpmNtVdmControl)(NTDPFT->pfn[DPM_NTVDMCONTROL]))(a,b)




// Macros to dispatch Shimed API calls properly from the dpmfxxx.dll
#define SHM_NtOpenFile(a,b,c,d,e,f)                                            \
     (NTD_SHIM(DPM_NTOPENFILE,                                                 \
                  typdpmNtOpenFile))(a,b,c,d,e,f)
#define SHM_NtQueryDirectoryFile(a,b,c,d,e,f,g,h,i,j,k)                        \
     (NTD_SHIM(DPM_NTQUERYDIRECTORYFILE,                                       \
                  typdpmNtQueryDirectoryFile))(a,b,c,d,e,f,g,h,i,j,k)
#define SHM_RtlGetFullPathName_U(a,b,c,d)                                      \
     (NTD_SHIM(DPM_RTLGETFULLPATHNAME_U,                                       \
                  typdpmRtlGetFullPathName_U))(a,b,c,d)
#define SHM_RtlGetCurrentDirectory_U(a,b)                                      \
     (NTD_SHIM(DPM_RTLGETCURRENTDIRECTORY_U,                                   \
                  typdpmRtlGetCurrentDirectory_U))(a,b)
#define SHM_RtlSetCurrentDirectory_U(a)                                        \
     (NTD_SHIM(DPM_RTLSETCURRENTDIRECTORY_U,                                   \
                  typdpmRtlSetCurrentDirectory_U))(a)
#define SHM_NtVdmControl(a,b)                                                  \
     (NTD_SHIM(DPM_NTVDMCONTROL,                                               \
                  typdpmNtVdmControl))(a,b)

#endif // _DPMF_NTDAPI_H_



// These need to be in the same order as the NtdFam enum definitions above and
// the DpmNtdTbl[] list below.
// This instantiates memory for DpmNtdStrs in mvdm\v86\monitor\i386\vdpm.c &
// in mvdm\wow32\wdpm.c
#ifdef _DPM_COMMON_
const char *DpmNtdStrs[] = {"NtOpenFile",
                            "NtQueryDirectoryFile",
                            "RtlGetFullPathName_U",
                            "RtlGetCurrentDirectory_U",
                            "RtlSetCurrentDirectory_U",
                            "NtVdmControl"
                           };

// These need to be in the same order as the NtdFam enum definitions and the
// the DpmNtdStrs[] list above.
// This instantiates memory for DpmNtdTbl[] in mvdm\wow32\wdpm.c
PVOID   DpmNtdTbl[] = {NtOpenFile,
                       NtQueryDirectoryFile,
                       RtlGetFullPathName_U,
                       RtlGetCurrentDirectory_U,
                       RtlSetCurrentDirectory_U,
                       NtVdmControl
                      };

#define NUM_HOOKED_NTD_APIS  ((sizeof DpmNtdTbl)/(sizeof DpmNtdTbl[0])) 

// This instantiates memory for DpmNtdFam in mvdm\v86\monitor\i386\vdpm.c
FAMILY_TABLE DpmNtdFam = {NUM_HOOKED_NTD_APIS, 0, 0, 0, 0, DpmNtdTbl};

#endif // _DPM_COMMON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\dpmtbls.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 2002, Microsoft Corporation
 *
 *  DpmTbls.h
 *  Builds the Dynamic Patch Module global dispatch tables
 *
 *  History:
 *  Created 01-10-2002 by cmjones
 *
 *  NOTE: 
 *   1. This instantiates the memory for DpmFamTbls[] & DpmFamModuleSets[] in 
 *      v86\monitor\i386\thread.c
 *      by that file.
 *   2. If you add to or change this, you must rebuild ntvdm.exe & wow32.dll!!
 *   3. To add new families, follow the instructions for each "!!!EDIT THIS !!!"
 *      section below.
 *
--*/
#include "vdm.h"

#define DPMFAMTBLS()     (((PVDM_TIB)(NtCurrentTeb()->Vdm))->pDpmFamTbls)

// 1. !!! EDIT THIS !!! 
//    - for both VDM and/or WOW!!!
//
// Add the include file for each family here.
#include "dpmf_fio.h"
#include "dpmf_prf.h"
#include "dpmf_reg.h"
#include "dpmf_ntd.h"


#ifndef _DPMTBLS_H_COMMON_
#define _DPMTBLS_H_COMMON_

typedef struct _tagDpmModuleSets {
    const char  *DpmFamilyType;    // Type of DPM patch module.dll (see below)
    const char  *ApiModuleName;    // Name of system.dll patched api's belong to
    const char **ApiNames;         // Array of ptrs to API names we are hooking
} DPMMODULESETS, *PDPMMODULESETS;


// Type prototypes for calling the family table init & destroy functions
// in the various dpmfxxx.dll's.
typedef PFAMILY_TABLE (*LPDPMINIT)(PFAMILY_TABLE, HMODULE, PVOID, PVOID, LPWSTR, PDPMMODULESETS);
typedef PFAMILY_TABLE (*LPDPMDESTROY)(PFAMILY_TABLE, PFAMILY_TABLE);

// 2. !!! EDIT THIS !!! 
//    Add a description for any new associations you add.
//
// DpmFamilyType's:
// This tells the DPM loader which DPM family to associate your dpm .dll with.
// Current associations:
//   DPMFIO - built from dpmf_fio.h
//   DPMNTD - built from dpmf_ntd.h 
//   DPMPRF - built from dpmf_prf.h
//   DPMREG - built from dpmf_reg.h
// These are strings used in the dbu.xml with the WOWCF2_DPM_PATCHES app compat
// flag. For example: 
//  <FLAG NAME="WOWCF2_DPM_PATCHES" COMMAND_LINE="DPMFIO=dpmffio.dll;DPMPRF=dpmprf.dll;DPMREG=dpmfreg.dll"/>
//    where the .dll specified is the .dll you build with the associated 
//    dpmf_xxx.h file shown above.


typedef struct _tagCMDLNPARMS {
    int    argc;    // number of ';' delimited parameters in the command_line
    char **argv;    // array of vectors pointing to each item in command_line
    DWORD  dwFlag;  // App compat flag associated with these parameters
} CMDLNPARMS, *PCMDLNPARMS;


void  BuildGlobalDpmStuffForWow(PFAMILY_TABLE *, PDPMMODULESETS *);
void  InitTaskDpmSupport(int, 
                         PFAMILY_TABLE *, 
                         PCMDLNPARMS, 
                         PVOID, 
                         PVOID, 
                         LPWSTR, 
                         LPWSTR, 
                         LPWSTR);
VOID  FreeTaskDpmSupport(PFAMILY_TABLE *, int, PFAMILY_TABLE *);
void  InitGlobalDpmTables(PFAMILY_TABLE *, int);
PVOID GetDpmAddress(PVOID lpAddress);
PCMDLNPARMS InitVdmSdbInfo(LPCSTR, DWORD *, int *);
VOID  FreeCmdLnParmStructs(PCMDLNPARMS, int);
BOOL  IsDpmEnabledForThisTask(void);

#define MAX_APP_NAME 31+1


// 3.Vdm. !!! EDIT THIS !!!
//        -- add any new VDM familes to this list
//
// NOTE: If you update this list you must update all of the following:
//                                     gDpmVdmFamTbls[]
//                                     gDpmWowFamTbls[]
//                                     gDpmVdmModuleSets[]
//                                     gDpmWowModuleSets[]
enum VdmFamilies {FIO_FAM=0,
                  NTD_FAM,
                  enum_last_VDM_fam}; // this should always be last
#define NUM_VDM_FAMILIES_HOOKED enum_last_VDM_fam
                   


// 4.Wow. !!! EDIT THIS !!!
///       -- add any new WOW Families to this list
//
// NOTE: If you update this list you must update gDpmWowFamTbls[] & 
//       gDpmWowModuleSets[] below.
enum WowFamilies {REG_FAM=enum_last_VDM_fam,
                  PRF_FAM,
                  enum_last_WOW_fam}; // this should always be last
#define NUM_WOW_FAMILIES_HOOKED (enum_last_WOW_fam)
// Note: The WOW families & module sets get appended on the end of the VDM
//       families & module sets for WOW.
#endif  // _DPMTBLS_H_COMMON_




// 5.Common. !!! EDIT THIS !!!
//
// Add a DPMMODULESETS struct for each family created.
// If you add something to this list, be sure to add the new moduleset to the
// appropriate modulesets below.
#ifdef _DPM_COMMON_  // For both VDM & WOW
const DPMMODULESETS FioModSet = {"DPMFIO", "kernel32.dll", DpmFioStrs};
const DPMMODULESETS NtdModSet = {"DPMNTD", "ntdll.dll",    DpmNtdStrs};
#ifdef _WDPM_C_      // For WOW only
const DPMMODULESETS RegModSet = {"DPMREG", "advapi32.dll", DpmRegStrs};
const DPMMODULESETS PrfModSet = {"DPMPRF", "kernel32.dll", DpmPrfStrs};
#endif // _WDPM_C_
#endif // _DPM_COMMON_



#ifdef _VDPM_C_
//
// THIS SECTION IS FOR VDM FAMILIES ONLY!!!!
//
// VDM Patches (Possibly callable by WOW!)
// The following two arrays become part of v86\monitor\i386\thread.c through
// this inclusion.

// 6.Vdm. !!! EDIT THIS !!!
//            -- For VDM Families only!!!
//
// Add the family defined at the end of each VDM dpmf_xxx.h file included above.
// Families added to this list must be in the same order as enum VdmFamilies{}
// above.  If you add something to this list you must also add it to the
// gDpmWowFamTbls[] list below.
const PFAMILY_TABLE gDpmVdmFamTbls[] = {&DpmFioFam,
                                        &DpmNtdFam };


// 7.Vdm. !!! EDIT THIS !!!
//            -- For VDM Families only!!!
//
// Add each DPMMODULESETS struct created above.
// list.
// Names added to this list must be in the same order as enum VdmFamilies{}
// above.  If you add something to this list you must also add it to the
// gDpmWowModuleSets[] list below.
const PDPMMODULESETS gDpmVdmModuleSets[] = {(const PDPMMODULESETS)&FioModSet,
                                            (const PDPMMODULESETS)&NtdModSet};

// END VDM ONLY SECTION!!!!
#endif  // _VDPM_C_




#ifdef _WDPM_C_
//
// THIS SECTION IS FOR WOW FAMILIES!!!!
//
// WOW exclusive Patches
// The following two arrays become part of mvdm\wow32\wdpm.c through
// this inclusion.

// 6.Wow. !!! EDIT THIS !!!
//            -- For WOW Families only!!!
//
// Add the family defined at the end of each WOW dpmf_xxx.h file included above.
// Families added to this list must be in the same order as enum WowFamilies{}
// above. All VDM familes added to this list must be at the head of the list
// and be in the same order as gDpmVdmFamTbls[].
const PFAMILY_TABLE gDpmWowFamTbls[] = {&DpmFioFam,
                                        &DpmNtdFam,
                                        &DpmRegFam, 
                                        &DpmPrfFam };


// 7.Wow. !!! EDIT THIS !!!
//            -- For WOW Families only!!!
//
// Add each DPMMODULESETS struct created above.
// list.
// Families added to this list must be in the same order as enum WowFamilies{}
// above. All VDM familes added to this list must be at the head of the list
// and be in the same order as gDpmVdmModuleSets[].
const PDPMMODULESETS gDpmWowModuleSets[] = {(const PDPMMODULESETS)&FioModSet,
                                            (const PDPMMODULESETS)&NtdModSet,
                                            (const PDPMMODULESETS)&RegModSet, 
                                            (const PDPMMODULESETS)&PrfModSet};
// END WOW ONLY SECTION!!!!
#endif  // _WDPM_C_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\intapi.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    intapi.h

Abstract:

    This header defines the function prototypes for the interrupt
    handler support routines in the 486 emulator.

Author:

    Neil Sandlin (neilsa)

Notes:

    
Revision History:


--*/

NTSTATUS
VdmInstallHardwareIntHandler(
    PVOID HwIntHandler
    );

NTSTATUS
VdmInstallSoftwareIntHandler(
    PVOID SwIntHandler
    );

NTSTATUS
VdmInstallFaultHandler(
    PVOID FaultHandler
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\exterr.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    exterr.h

Abstract:

    Taken from mvdm\dos\v86\inc\error.inc

Author:

    Richard L Firth (rfirth) 17-Oct-1992

Revision History:

--*/

/** ERROR.INC - DOS Error Codes
;
;    The newer (DOS 2.0 and above) "XENIX-style" calls
;    return error codes through AX. If an error occurred then
;    the carry bit will be set and the error code is in AX. If no error
;    occurred then the carry bit is reset and AX contains returned info.
;
;    Since the set of error codes is being extended as we extend the operating
;    system, we have provided a means for applications to ask the system for a
;    recommended course of action when they receive an error.
;
;    The GetExtendedError system call returns a universal error, an error
;    location and a recommended course of action.   The universal error code is
;    a symptom of the error REGARDLESS of the context in which GetExtendedError
;    is issued.
*/

//  2.0 error codes

#define error_invalid_function      1
#define error_file_not_found        2
#define error_path_not_found        3
#define error_too_many_open_files   4
#define error_access_denied         5
#define error_invalid_handle        6
#define error_arena_trashed         7
#define error_not_enough_memory     8
#define error_invalid_block         9
#define error_bad_environment       10
#define error_bad_format            11
#define error_invalid_access        12
#define error_invalid_data          13
/**** reserved          EQU 14  ; *****/
#define error_invalid_drive         15
#define error_current_directory     16
#define error_not_same_device       17
#define error_no_more_files         18

//  These are the universal int 24 mappings for the old INT 24 set of errors

#define error_write_protect         19
#define error_bad_unit              20
#define error_not_ready             21
#define error_bad_command           22
#define error_CRC                   23
#define error_bad_length            24
#define error_Seek                  25
#define error_not_DOS_disk          26
#define error_sector_not_found      27
#define error_out_of_paper          28
#define error_write_fault           29
#define error_read_fault            30
#define error_gen_failure           31

//  the new 3.0 error codes reported through INT 24

#define error_sharing_violation     32
#define error_lock_violation        33
#define error_wrong_disk            34
#define error_FCB_unavailable       35
#define error_sharing_buffer_exceeded   36
#define error_Code_Page_Mismatched  37    // DOS 4.00           ;AN000;
#define error_handle_EOF            38    // DOS 4.00           ;AN000;
#define error_handle_Disk_Full      39    // DOS 4.00           ;AN000;

//  New OEM network-related errors are 50-79

#define error_not_supported         50

#define error_net_access_denied     65    //M028

//  End of INT 24 reportable errors

#define error_file_exists           80
#define error_DUP_FCB               81  // *****
#define error_cannot_make           82
#define error_FAIL_I24              83

//  New 3.0 network related error codes

#define error_out_of_structures     84
#define error_Already_assigned      85
#define error_invalid_password      86
#define error_invalid_parameter     87
#define error_NET_write_fault       88
#define error_sys_comp_not_loaded   90    // DOS 4.00               ;AN000;



//  BREAK <Interrupt 24 error codes>

/** Int24 Error Codes **/

#define error_I24_write_protect     0
#define error_I24_bad_unit          1
#define error_I24_not_ready         2
#define error_I24_bad_command       3
#define error_I24_CRC               4
#define error_I24_bad_length        5
#define error_I24_Seek              6
#define error_I24_not_DOS_disk      7
#define error_I24_sector_not_found  8
#define error_I24_out_of_paper      9
#define error_I24_write_fault       0xA
#define error_I24_read_fault        0xB
#define error_I24_gen_failure       0xC
// NOTE: Code 0DH is used by MT-DOS.
#define error_I24_wrong_disk        0xF


//  THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
//
//  NOTE: ABORT is ALWAYS allowed

#define Allowed_FAIL        0x08    // 00001000B
#define Allowed_RETRY       0x10    // 00010000B
#define Allowed_IGNORE      0x20    // 00100000B

#define I24_operation       0x01    // 00000001B    ;Z if READ,NZ if Write
#define I24_area            0x60    // 00000110B    ; 00 if DOS
                                    //              ; 01 if FAT
                                    //              ; 10 if root DIR
                                    //              ; 11 if DATA
#define I24_class           0x80    // 10000000B    ;Z if DISK, NZ if FAT or char


//  BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>

/** The GetExtendedError call takes an error code and returns CLASS,
;   ACTION and LOCUS codes to help programs determine the proper action
;   to take for error codes that they don't explicitly understand.
*/

//  Values for error CLASS

#define errCLASS_OutRes     1   // Out of Resource
#define errCLASS_TempSit    2   // Temporary Situation
#define errCLASS_Auth       3   // Permission problem
#define errCLASS_Intrn      4   // Internal System Error
#define errCLASS_HrdFail    5   // Hardware Failure
#define errCLASS_SysFail    6   // System Failure
#define errCLASS_Apperr     7   // Application Error
#define errCLASS_NotFnd     8   // Not Found
#define errCLASS_BadFmt     9   // Bad Format
#define errCLASS_Locked     10  // Locked
#define errCLASS_Media      11  // Media Failure
#define errCLASS_Already    12  // Collision with Existing Item
#define errCLASS_Unk        13  // Unknown/other

//  Values for error ACTION

#define errACT_Retry        1   // Retry
#define errACT_DlyRet       2   // Delay Retry, retry after pause
#define errACT_User         3   // Ask user to regive info
#define errACT_Abort        4   // abort with clean up
#define errACT_Panic        5   // abort immediately
#define errACT_Ignore       6   // ignore
#define errACT_IntRet       7   // Retry after User Intervention

//  Values for error LOCUS

#define errLOC_Unk          1   // No appropriate value
#define errLOC_Disk         2   // Random Access Mass Storage
#define errLOC_Net          3   // Network
#define errLOC_SerDev       4   // Serial Device
#define errLOC_Mem          5   // Memory
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\monregs.h ===
extern CONTEXT IntelRegisters;
extern ULONG IntelMSW;
// Flag Register constants

#define FLG_CARRY           0x00000001
#define FLG_CARRY_BIT       0x00000000
#define FLG_PARITY          0x00000004
#define FLG_PARITY_BIT      0x00000003
#define FLG_AUXILIARY       0x00000010
#define FLG_AUXILIARY_BIT   0x00000005
#define FLG_ZERO            0x00000040
#define FLG_ZERO_BIT        0x00000006
#define FLG_SIGN            0x00000080
#define FLG_SIGN_BIT        0x00000007
#define FLG_INTERRUPT       0x00000200
#define FLG_INTERRUPT_BIT   0x00000009
#define FLG_DIRECTION       0x00000400
#define FLG_DIRECTION_BIT   0x0000000A
#define FLG_OVERFLOW        0x00000800
#define FLG_OVERFLOW_BIT    0x0000000B
extern ULONG  getEAX(VOID);
extern USHORT getAX(VOID);
extern UCHAR  getAL(VOID);
extern UCHAR  getAH(VOID);
extern ULONG  getEBX(VOID);
extern USHORT getBX(VOID);
extern UCHAR  getBL(VOID);
extern UCHAR  getBH(VOID);
extern ULONG  getECX(VOID);
extern USHORT getCX(VOID);
extern UCHAR  getCL(VOID);
extern UCHAR  getCH(VOID);
extern ULONG  getEDX(VOID);
extern USHORT getDX(VOID);
extern UCHAR  getDL(VOID);
extern UCHAR  getDH(VOID);
extern ULONG  getESP(VOID);
extern USHORT getSP(VOID);
extern ULONG  getEBP(VOID);
extern USHORT getBP(VOID);
extern ULONG  getESI(VOID);
extern USHORT getSI(VOID);
extern ULONG  getEDI(VOID);
extern USHORT getDI(VOID);
extern ULONG  getEIP(VOID);
extern USHORT getIP(VOID);
extern USHORT getCS(VOID);
extern USHORT getSS(VOID);
extern USHORT getDS(VOID);
extern USHORT getES(VOID);
extern USHORT getFS(VOID);
extern USHORT getGS(VOID);
extern ULONG  getCF(VOID);
extern ULONG  getPF(VOID);
extern ULONG  getAF(VOID);
extern ULONG  getZF(VOID);
extern ULONG  getSF(VOID);
extern ULONG  getIF(VOID);
extern ULONG  getDF(VOID);
extern ULONG  getOF(VOID);
extern USHORT getMSW(VOID);

extern VOID setEAX(ULONG);
extern VOID setAX(USHORT);
extern VOID setAH(UCHAR);
extern VOID setAL(UCHAR);
extern VOID setEBX(ULONG);
extern VOID setBX(USHORT);
extern VOID setBH(UCHAR);
extern VOID setBL(UCHAR);
extern VOID setECX(ULONG);
extern VOID setCX(USHORT);
extern VOID setCH(UCHAR);
extern VOID setCL(UCHAR);
extern VOID setEDX(ULONG);
extern VOID setDX(USHORT);
extern VOID setDH(UCHAR);
extern VOID setDL(UCHAR);
extern VOID setESP(ULONG);
extern VOID setSP(USHORT);
extern VOID setEBP(ULONG);
extern VOID setBP(USHORT);
extern VOID setESI(ULONG);
extern VOID setSI(USHORT);
extern VOID setEDI(ULONG);
extern VOID setDI(USHORT);
extern VOID setEIP(ULONG);
extern VOID setIP(USHORT);
extern VOID setCS(USHORT);
extern VOID setSS(USHORT);
extern VOID setDS(USHORT);
extern VOID setES(USHORT);
extern VOID setFS(USHORT);
extern VOID setGS(USHORT);
extern VOID setCF(ULONG);
extern VOID setPF(ULONG);
extern VOID setAF(ULONG);
extern VOID setZF(ULONG);
extern VOID setSF(ULONG);
extern VOID setIF(ULONG);
extern VOID setDF(ULONG);
extern VOID setOF(ULONG);
extern VOID setMSW(USHORT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\mvdm.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  MVDM.H
 *  Constants, macros, and types common to all of MVDM
 *
 *  History:
 *  Created 14-May-1991 by Jeff Parsons (jeffpar)
--*/


/* Common constants, not defined in NT/WIN32
 */
#define K		1024L


/* Common types, not defined in NT/WIN32
 */
#ifdef H2INC
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef long LONG;
typedef char CHAR;
typedef short SHORT;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef char *PSZ;
typedef void *PVOID;
typedef ULONG *PULONG;
typedef WORD ATOM;
#endif

// typedef int INT;
// typedef DWORD UINT;
typedef short FAR *LPSHORT;
typedef char SZ[];
typedef char FAR *LPSZ;
typedef PBYTE *PPBYTE;
typedef PWORD *PPWORD;
typedef PDWORD *PPDWORD;
// typedef UINT *PUINT;


// unaligned typedefs

typedef WORD  UNALIGNED *PWORD16;
typedef SHORT UNALIGNED *PSHORT16;
typedef DWORD UNALIGNED *PDWORD16;

#define WORDOF16(i,n)	(((PWORD16)&(i))[n])
#define LOW16(l)		WORDOF16(l,0)
#define HIW16(l)		WORDOF16(l,1)

/* Common macros, not defined in NT/WIN32
 */
#define BYTEOF(i,n)	(((PBYTE)&(i))[n])
#define LOB(i)		BYTEOF(i,0)
#define HIB(i)		BYTEOF(i,1)
#define WORDOF(i,n)	(((PWORD)&(i))[n])
#define LOW(l)		WORDOF(l,0)
#define HIW(l)		WORDOF(l,1)
#define INTOF(i,n)	(((PINT)&(i))[n])
#define UINTOF(i,n)	(((PUINT)&(i))[n])
#ifndef MAKEWORD
#define MAKEWORD(l,h)	((WORD)((BYTE)(l)|((BYTE)(h)<<8)))
#endif
#define MAKEDWORD(l0,h0,l1,h1)	((DWORD)MAKEWORD(l0,h0)|((DWORD)MAKEWORD(l1,h1)<<16))
#define GETBYTE(p)	*((PBYTE)p)++
#ifdef	i386
#define FETCHWORD(s)	((WORD)(s))
#define FETCHDWORD(s)	((DWORD)(s))
#define STOREWORD(d,s)	(WORD)d=(WORD)s
#define STOREDWORD(d,s) (DWORD)d=(DWORD)s
#else
#define FETCHWORD(s)  (*(UNALIGNED WORD *)&(s))
#define FETCHDWORD(s) (*(UNALIGNED DWORD *)&(s))
#define STOREWORD(d,s)  *(UNALIGNED WORD *)&(d)=(WORD)s
#define STOREDWORD(d,s) *(UNALIGNED DWORD *)&(d)=(DWORD)s
#endif
#define FETCHSHORT(s)	((SHORT)(FETCHWORD(s)))
#define FETCHLONG(s)	((LONG)(FETCHDWORD(s)))
#define STORESHORT(d,s) STOREWORD(d,s)
#define STORELONG(d,s)	STOREDWORD(d,s)

#define NUMEL(a)	((sizeof a)/(sizeof a[0]))
#define OFFSETOF(t,f)	((INT)&(((t *)0)->f))

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\netb.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrnetb.h

Abstract:

    Contains prototypes and definitions for Vdm netbios support routines

Author:

    Colin Watson (colinw) 09-Dec-1991

Revision History:

    09-Dec-1991 colinw
        Created

--*/

//
//  Internal version of the ncb layout for mvdm.
//

#include <packon.h>

//
//  Use packing to ensure that the cu union is not forced to word alignment.
//  All elements of this structure are naturally aligned.
//

typedef struct _NCBW {
    UCHAR   ncb_command;            /* command code                   */
    volatile UCHAR   ncb_retcode;   /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    union {
        UCHAR   ncb_callname[NCBNAMSZ];/* blank-padded name of remote */
        struct _CHAIN_SEND {
            WORD ncb_length2;
            PUCHAR ncb_buffer2;
        } ncb_chain;
    } cu;
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (*ncb_post)( struct _NCB * ); /* POST routine address        */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    volatile UCHAR   ncb_cmd_cplt;  /* 0xff => commmand pending       */

    // Make driver specific use of the reserved area of the NCB.
    WORD    ncb_reserved;           /* return to natural alignment    */
    union {
        LIST_ENTRY      ncb_next;   /* queued to worker thread        */
        IO_STATUS_BLOCK ncb_iosb;   /* used for Nt I/O interface      */
    } u;

    HANDLE          ncb_event;      /* HANDLE to Win32 event          */

    //  Extra workspace utilized by the mvdm component.

    WORD ncb_es;                    /* 16 bit address of the real NCB */
    WORD ncb_bx;

    PNCB ncb_original_ncb;          /* 32 bit address of the real NCB */
    DWORD ProtectModeNcb;           /* TRUE if NCB originated in PM   */

    } NCBW, *PNCBW;

#include <packoff.h>

VOID
VrNetbios5c(
    VOID
    );


VOID
VrNetbios5cInterrupt(
    VOID
    );

VOID
VrNetbios5cInitialize(
    VOID
    );

BOOLEAN
IsPmNcbAtQueueHead(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\enumapis.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1990		**/ 
/*****************************************************************/ 
/***	enumapis.h
 *
 *	This file contains the subfunctions for the loadable APIs in the
 *	REDIR 1.5 project
 */

#define REDIRBASEFUNCTION		0x5f00
#define BADFUNCTION			0xFFFF
#define UseWkstaPass			0x80

#define Local_API_ReturnMode			0x00
#define Local_API_SetMode			0x01
#define Local_API_GetAsgList			0x02
#define Local_API_Define			0x03
#define Local_API_BREAK_MAC			0x04
#define Local_API_GetAsgList2			0x05

#define Local_API_RedirGetVersion		0x30
#define Local_API_NetWkstaSetUID		0x31
#define Local_API_DosQNmPipeInfo		0x32
#define Local_API_DosQNmPHandState		0x33
#define Local_API_DosSetNmPHandState		0x34
#define Local_API_DosPeekNmPipe 		0x35
#define Local_API_DosTransactNmPipe		0x36
#define Local_API_DosCallNmPipe 		0x37
#define Local_API_DosWaitNmPipe 		0x38
#define Local_API_DosRawReadNmPipe		0x39
#define Local_API_DosRawWriteNmPipe		0x3a
#define Local_API_NetHandleSetInfo		0x3b
#define Local_API_NetHandleGetInfo		0x3c
#define Local_API_NetTransact			0x3d
#define Local_API_NetSpecialSMB 		0x3e
#define Local_API_NetIRemoteAPI 		0x3f
#define Local_API_NetMessageBufferSend		0x40
#define Local_API_NetServiceEnum		0x41
#define Local_API_NetServiceControl		0x42
#define Local_API_DosPrintJobGetID		0x43
#define Local_API_NetWkstaGetInfo		0x44
#define Local_API_NetWkstaSetInfo		0x45
#define Local_API_NetUseEnum			0x46
#define Local_API_NetUseAdd			0x47
#define Local_API_NetUseDel			0x48
#define Local_API_NetUseGetInfo 		0x49
#define Local_API_NetRemoteCopy 		0x4a
#define Local_API_NetRemoteMove 		0x4b
#define Local_API_NetServerEnum 		0x4c
#define Local_API_DosMakeMailslot		0x4d
#define Local_API_DosDeleteMailslot		0x4e
#define Local_API_DosMailslotInfo		0x4f
#define Local_API_DosReadMailslot		0x50
#define Local_API_DosPeekMailslot		0x51
#define Local_API_DosWriteMailslot		0x52
#define Local_API_NetServerEnum2		0x53
#define	Local_API_NullTransact			0x54

/*	NOTE:: Remove_Network_Connections is a private call to allow the
 *	NetSetUserName INT 2F to remove network connections.
 */

#define	Local_API_Remove_Network_Connections	0x55

/*	NOTE:: Process_Interrogate is a private call to allow the
 *	redirector to kick itself from INT 28 and INT 8 to process relogon
 *	requests.
 */
#define	Local_API_Periodic_View_Tasks		0x56
#define Local_API_Set_LongName			0x57
#define Local_API_Start_Redir_On_Net		0x58
#define Local_API_Stop_Redir_per_Net		0x59
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\memapi.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    memapi.h

Abstract:

    This header defines the function prototypes for the memory
    manipulation routines in the 486 emulator.

Author:

    Neil Sandlin (neilsa)

Notes:

    
Revision History:


--*/

NTSTATUS
VdmAllocateVirtualMemory(
    PULONG Address,
    ULONG Size,
    BOOLEAN Commit
    );

NTSTATUS 
VdmFreeVirtualMemory(
    ULONG Address
    );

NTSTATUS
VdmCommitVirtualMemory(
    ULONG Address,
    ULONG Size
    );

NTSTATUS
VdmDeCommitVirtualMemory(
    ULONG Address,
    ULONG Size
    );

NTSTATUS
VdmQueryFreeVirtualMemory(
    PULONG FreeBytes,
    PULONG LargestFreeBlock
    );

NTSTATUS
VdmReallocateVirtualMemory(
    ULONG OldAddress,
    PULONG NewAddress,
    ULONG NewSize
    );

NTSTATUS
VdmAddVirtualMemory(
    ULONG HostAddress,
    ULONG Size,
    PULONG IntelAddress
    );

NTSTATUS
VdmRemoveVirtualMemory(
    ULONG IntelAddress
    );


BOOL
VdmAddDescriptorMapping(
    USHORT SelectorStart,
    USHORT SelectorCount,
    ULONG LdtBase,
    ULONG Flat
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\rdrexp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rdrexp.h

Abstract:

    Definition of Vdm Redir BOP dispatcher

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Revision History:

    13-Sep-1991 rfirth
        Created

--*/



BOOL
VrDispatch(
    IN  ULONG   SvcCode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\pif.h ===
/*
 * Structure and equates of PIF files
 */

#define PIFEDITMAXPIF		1024	 /* maximum PIF file size we support */
#define PIFEDITMAXPIFL		1024L

#define PIFNAMESIZE		30
#define PIFSTARTLOCSIZE 	63
#define PIFDEFPATHSIZE		64
#define PIFPARAMSSIZE		64
#define PIFSHPROGSIZE		64
#define PIFSHDATASIZE		64

#define PIFEXTSIGSIZE		16

#define PIFSIZE 		367 /* two bytes less, this is used for checksum */

#ifndef RC_INVOKED
#pragma pack(1)
#endif
typedef struct {
    char unknown;
    char id;
    char name[PIFNAMESIZE];
    short maxmem;
    short minmem;
    char startfile[PIFSTARTLOCSIZE];
    char MSflags;
    char reserved;
    char defpath[PIFDEFPATHSIZE];
    char params[PIFPARAMSSIZE];
    char screen;
    char cPages;
    unsigned char lowVector;
    unsigned char highVector;
    char rows;
    char cols;
    char rowoff;
    char coloff;
    unsigned short sysmem;
    char shprog[PIFSHPROGSIZE];
    char shdata[PIFSHDATASIZE];
    unsigned char behavior;
    unsigned char sysflags;
    } PIFOLD286STR;
#ifndef RC_INVOKED
#pragma pack()
#endif

#ifndef RC_INVOKED
#pragma pack(1)
#endif
typedef struct {
    char extsig[PIFEXTSIGSIZE];
    unsigned short extnxthdrfloff;
    unsigned short extfileoffset;
    unsigned short extsizebytes;
    } PIFEXTHEADER;
#ifndef RC_INVOKED
#pragma pack()
#endif

#define LASTHEADERPTR		0xFFFF
#define STDHDRSIG		"MICROSOFT PIFEX"

#define W386HDRSIG		"WINDOWS 386 3.0"
#define W286HDRSIG30		"WINDOWS 286 3.0"
#define WNTHDRSIG31		"WINDOWS NT  3.1"
/*
 *#define W286HDRSIG31		  "WINDOWS 286 3.1"
 */

#ifndef RC_INVOKED
#pragma pack(1)
#endif
typedef struct {
    char unknown;
    char id;
    char name[PIFNAMESIZE];
    short maxmem;
    short minmem;
    char startfile[PIFSTARTLOCSIZE];
    char MSflags;
    char reserved;
    char defpath[PIFDEFPATHSIZE];
    char params[PIFPARAMSSIZE];
    char screen;
    char cPages;
    unsigned char lowVector;
    unsigned char highVector;
    char rows;
    char cols;
    char rowoff;
    char coloff;
    unsigned short sysmem;
    char shprog[PIFSHPROGSIZE];
    char shdata[PIFSHDATASIZE];
    unsigned char behavior;
    unsigned char sysflags;
    PIFEXTHEADER stdpifext;
    } PIFNEWSTRUCT;
#ifndef RC_INVOKED
#pragma pack()
#endif

/*
 * Windows/386 PIF file extension
 *
 */
#ifndef RC_INVOKED
#pragma pack(1)
#endif
typedef struct {
    short maxmem;
    short minmem;
    unsigned short PfFPriority;
    unsigned short PfBPriority;
    short PfMaxEMMK;
    unsigned short PfMinEMMK;
    short PfMaxXmsK;
    unsigned short PfMinXmsK;
    unsigned long PfW386Flags;
    unsigned long PfW386Flags2;
    unsigned short PfHotKeyScan;
    unsigned short PfHotKeyShVal;
    unsigned short PfHotKeyShMsk;
    unsigned char PfHotKeyVal;
    unsigned char PfHotKeyPad[9];
    char params[PIFPARAMSSIZE];
    } PIF386EXT;
#ifndef RC_INVOKED
#pragma pack()
#endif

/* Bits of PfW386Flags */
#define fEnableClose		0x00000001L
#define fBackground		0x00000002L
#define fExclusive		0x00000004L
#define fFullScreen		0x00000008L
#define fALTTABdis		0x00000020L
#define fALTESCdis		0x00000040L
#define fALTSPACEdis		0x00000080L
#define fALTENTERdis		0x00000100L
#define fALTPRTSCdis		0x00000200L
#define fPRTSCdis		0x00000400L
#define fCTRLESCdis		0x00000800L
#define fPollingDetect		0x00001000L
#define fNoHMA			0x00002000L
#define fHasHotKey		0x00004000L
#define fEMSLocked		0x00008000L
#define fXMSLocked		0x00010000L
#define fINT16Paste		0x00020000L
#define fVMLocked		0x00040000L

/* Bits of PfW386Flags2 */
/*
 *  NOTE THAT THE LOW 16 BITS OF THIS DWORD ARE VDD RELATED!!!!!!!!
 *
 *	You cannot monkey with these bits locations without breaking
 *	all VDDs as well as all old PIF files. SO DON'T MESS WITH THEM.
 *
 */
#define fVidTxtEmulate		0x00000001L
#define fVidNoTrpTxt		0x00000002L
#define fVidNoTrpLRGrfx 	0x00000004L
#define fVidNoTrpHRGrfx 	0x00000008L
#define fVidTextMd		0x00000010L
#define fVidLowRsGrfxMd 	0x00000020L
#define fVidHghRsGrfxMd 	0x00000040L
#define fVidRetainAllo		0x00000080L
/* NOTE THAT ALL OF THE LOW 16 BITS ARE RESERVED FOR VIDEO BITS */


/*
 * Windows/286 PIF file extension
 *
 *
 * Windows 3.00 extension format
 *
 */
#ifndef RC_INVOKED
#pragma pack(1)
#endif
typedef struct {
    short PfMaxXmsK;
    unsigned short PfMinXmsK;
    unsigned short PfW286Flags;
    } PIF286EXT30;
#ifndef RC_INVOKED
#pragma pack()
#endif

/* Bits of PfW286Flags */
#define fALTTABdis286		0x0001
#define fALTESCdis286		0x0002
#define fALTPRTSCdis286 	0x0004
#define fPRTSCdis286		0x0008
#define fCTRLESCdis286		0x0010
/*
 * Following bit is version >= 3.10 specific
 */
#define fNoSaveVid286		0x0020

#define fCOM3_286		0x4000
#define fCOM4_286		0x8000

/*
 *
 * NEW Windows 3.10 extension format
 *
 *#ifndef RC_INVOKED
 *#pragma pack(1)
 *#endif
 *typedef struct {
 *    short PfMaxEmsK;
 *    unsigned short PfMinEmsK;
 *    } PIF286EXT31;
 *#ifndef RC_INVOKED
 *#pragma pack()
 *#endif
 */

/* Windows NT extension format */
#ifndef RC_INVOKED
#pragma pack (1)                          
#endif
typedef struct                            
   {                                      
   DWORD dwWNTFlags;                      
   DWORD dwRes1;                          
   DWORD dwRes2;                          
   char  achConfigFile[PIFDEFPATHSIZE];   
   char  achAutoexecFile[PIFDEFPATHSIZE]; 
   } PIFWNTEXT;                           
#ifndef RC_INVOKED
#pragma pack()                            
#endif
#define PIFWNTEXTSIZE sizeof(PIFWNTEXT)


// equates for dwWNTFlags
#define NTPIF_SUBSYSMASK        0x0000000F      // sub system type mask
#define SUBSYS_DEFAULT          0
#define SUBSYS_DOS              1
#define SUBSYS_WOW              2
#define SUBSYS_OS2              3
#define COMPAT_TIMERTIC         0x10




/* behavior and sysflags */
#define SWAPS			0x20
#define SWAPMASK		0x20
#define NOTSWAPMASK		0xdf

#define PARMS			0x40
#define PARMMASK		0x40
#define NOTPARMMASK		0xbf

#define SCR			0xC0
#define SCRMASK 		0xC0
#define NOTSCRMASK		0x3f

#define MASK8087		0x20
#define NOTMASK8087		0xdf
#define KEYMASK 		0x10
#define NOTKEYMASK		0xef

/* Microsoft PIF flags */
#define MEMMASK 		0x01
#define NOTMEMMASK		0xfe

#define GRAPHMASK		0x02
#define TEXTMASK		0xfd

#define PSMASK			0x04
#define NOTPSMASK		0xfb

#define SGMASK			0x08
#define NOTSGMASK		0xf7

#define EXITMASK		0x10
#define NOTEXITMASK		0xef

#define DONTUSE 		0x20

#define COM2MASK		0x40
#define NOTCOM2MASK		0xbf

#define COM1MASK		0x80
#define NOTCOM1MASK             0x7f




/*
 *  The pif file formats have been substantially updated since NT4.
 *  The current pif properties is defined in nt\shell\published\inc,
 *  and should be used instead of mvdm\inc\pif.h. Its too late to switch
 *  for XP, do this for next product. For now copy the needed data
 *  structures.
 *
 *  01-Jun-2001 Jonle
 *
 */
#define WENHHDRSIG40     "WINDOWS VMM 4.0"
#define PIFDEFFILESIZE  80

#ifndef LF_FACESIZE
#define LF_FACESIZE     32
#endif

typedef struct tagPIFRECT {
    WORD left;
    WORD top;
    WORD right;
    WORD bottom;
} PIFRECT;
typedef PIFRECT *PPIFRECT;
typedef PIFRECT FAR *LPPIFRECT;


typedef struct PROPTSK {                    /* tsk */
    WORD    flTsk;                          // see TSK_ flags
    WORD    flTskInit;                      // see TSKINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    wReserved4;                     // (reserved, must be zero)
    WORD    wIdleSensitivity;               // %, also affects PfW386Flags & fPollingDetect
} PROPTSK;
typedef UNALIGNED PROPTSK *PPROPTSK;
typedef UNALIGNED PROPTSK FAR *LPPROPTSK;

typedef struct PROPVID {                    /* vid */
    WORD    flVid;                          // see VID_ flags
    WORD    flVidInit;                      // see VIDINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    cScreenLines;                   // ([NonWindowsApp]:ScreenLines)
} PROPVID;
typedef UNALIGNED PROPVID *PPROPVID;
typedef UNALIGNED PROPVID FAR *LPPROPVID;

typedef struct PROPKBD {                    /* kbd */
    WORD    flKbd;                          // see KBD_ flags
    WORD    flKbdInit;                      // see KBDINIT_ flags
    WORD    msAltDelay;                     // ([386Enh]:AltKeyDelay)
    WORD    msAltPasteDelay;                // ([386Enh]:AltPasteDelay)
    WORD    msPasteDelay;                   // ([386Enh]:KeyPasteDelay)
    WORD    msPasteFullDelay;               // ([386Enh]:KeyBufferDelay)
    WORD    msPasteTimeout;                 // ([386Enh]:KeyPasteTimeOut)
    WORD    cPasteSkip;                     // ([386Enh]:KeyPasteSkipCount)
    WORD    cPasteCRSkip;                   // ([386Enh]:KeyPasteCRSkipCount)
} PROPKBD;
typedef UNALIGNED PROPKBD *PPROPKBD;
typedef UNALIGNED PROPKBD FAR *LPPROPKBD;

typedef struct PROPMSE {                    /* mse */
    WORD    flMse;                          // see MSE_ flags
    WORD    flMseInit;                      // see MSEINIT_ flags
} PROPMSE;
typedef UNALIGNED PROPMSE *PPROPMSE;
typedef UNALIGNED PROPMSE FAR *LPPROPMSE;

typedef struct PROPSND {                    /* snd */                       /* ;Internal */
    WORD    flSnd;                          // see SND_ flags               /* ;Internal */
    WORD    flSndInit;                      // see SNDINIT_ flags           /* ;Internal */
} PROPSND;                                                                  /* ;Internal */
typedef UNALIGNED PROPSND *PPROPSND;                                        /* ;Internal */
typedef UNALIGNED PROPSND FAR *LPPROPSND;                                   /* ;Internal */

typedef struct PROPFNT {                    /* fnt */
    WORD    flFnt;                          // see FNT_ flags
    WORD    flFntInit;                      // see FNTINIT_ flags
    WORD    cxFont;                         // width of desired font
    WORD    cyFont;                         // height of desired font
    WORD    cxFontActual;                   // actual width of desired font
    WORD    cyFontActual;                   // actual height of desired font
    CHAR    achRasterFaceName[LF_FACESIZE]; // name to use for raster font
    CHAR    achTTFaceName[LF_FACESIZE];     // name to use for tt font
    WORD    wCurrentCP;                     // Current Codepage
} PROPFNT;
typedef UNALIGNED PROPFNT *PPROPFNT;
typedef UNALIGNED PROPFNT FAR *LPPROPFNT;

typedef struct PROPWIN {                    /* win */
    WORD    flWin;                          // see WIN_ flags
    WORD    flWinInit;                      // see WININIT flags
    WORD    cxCells;                        // width in cells
    WORD    cyCells;                        // height in cells
    WORD    cxClient;                       // width of client window
    WORD    cyClient;                       // height of client window
    WORD    cxWindow;                       // width of entire window
    WORD    cyWindow;                       // height of entire window
    WORD    wLength;
    WORD    wShowFlags;
    WORD    wShowCmd;
    WORD    xMinimize;
    WORD    yMinimize;
    WORD    xMaximize;
    WORD    yMaximize;
    PIFRECT rcNormal;
} PROPWIN;
typedef UNALIGNED PROPWIN *PPROPWIN;
typedef UNALIGNED PROPWIN FAR *LPPROPWIN;


typedef struct PROPENV {                    /* env */
    WORD    flEnv;                          // see ENV_ flags
    WORD    flEnvInit;                      // see ENVINIT_ flags
    CHAR    achBatchFile[PIFDEFFILESIZE];   //
    WORD    cbEnvironment;                  // ([386Enh]:CommandEnvSize)
    WORD    wMaxDPMI;                       // (NEW)
} PROPENV;
typedef UNALIGNED PROPENV *PPROPENV;
typedef UNALIGNED PROPENV FAR *LPPROPENV;


typedef struct WENHPIF40 {                  /* enh */                       /* ;Internal */
    DWORD   dwEnhModeFlagsProp;             // PROPPRG data (subset)        /* ;Internal */
    DWORD   dwRealModeFlagsProp;            // PROPPRG data (subset)        /* ;Internal */
    CHAR    achOtherFileProp[PIFDEFFILESIZE];//PROPPRG data (subset)        /* ;Internal */
    CHAR    achIconFileProp[PIFDEFFILESIZE];// PROPPRG data (subset)        /* ;Internal */
    WORD    wIconIndexProp;                 // PROPPRG data (subset)        /* ;Internal */
    PROPTSK tskProp;                        // PROPTSK data                 /* ;Internal */
    PROPVID vidProp;                        // PROPVID data                 /* ;Internal */
    PROPKBD kbdProp;                        // PROPKBD data                 /* ;Internal */
    PROPMSE mseProp;                        // PROPMSE data                 /* ;Internal */
    PROPSND sndProp;                        // PROPSND data                 /* ;Internal */
    PROPFNT fntProp;                        // PROPFNT data                 /* ;Internal */
    PROPWIN winProp;                        // PROPWIN data                 /* ;Internal */
    PROPENV envProp;                        // PROPENV data                 /* ;Internal */
    WORD    wInternalRevision;              // Internal WENHPIF40 version   /* ;Internal */
} WENHPIF40;                                                                /* ;Internal */
typedef UNALIGNED WENHPIF40 *PWENHPIF40;                                    /* ;Internal */
typedef UNALIGNED WENHPIF40 FAR *LPWENHPIF40;                               /* ;Internal */




#if defined(NEC_98)
#ifndef _PIFNT_NEC98_
#define _PIFNT_NEC98_
/*****************************************************************************/
/*   Windows 3.1 PIF file extension for NEC PC-9800                          */
/*****************************************************************************/
/* For Header signature. */

#define W30NECHDRSIG "WINDOWS NEC 3.0"

/* Real Extended Structire for NEC PC-9800 */

#ifndef RC_INVOKED
#pragma pack (1) 
#endif
typedef struct {
    BYTE cPlaneFlags;     
    BYTE cNecFlags;       // +1
    BYTE cVCDFlags;       // +2
    BYTE EnhExtBit;       // +3
    BYTE Extcont;         // +4 byte
    BYTE cReserved[27];   // reserved
    } PIFNECEXT;          // all = 32bytes
#ifndef RC_INVOKED
#pragma pack() 
#endif
#define PIFNECEXTSIZE sizeof(PIFNECEXT)
/*-----------------------------------------------------------------------------
  cPlaneFlags (8 bit)

         0 0 0 0 X X X X
         | | | | | | | +-- Plane 0{On/Off}
         | | | | | | +---- Plane 1{On/Off}
         | | | | | +------ Plane 2{On/Off}
         | | | | +-------- Plane 3{On/Off}
         +-+-+-+---------- Reserved for 256 color

-----------------------------------------------------------------------------*/

#define P0MASK 0x01                   /* plane 1 <ON>   */
#define NOTP0MASK 0xfe                /* plane 1 <OFF>  */

#define P1MASK 0x02                   /* plane 2 <ON>   */
#define NOTP1MASK 0xfd                /* plane 2 <OFF>  */

#define P2MASK 0x04                   /* plane 3 <ON>   */
#define NOTP2MASK 0xfb                /* plane 3 <OFF>  */

#define P3MASK 0x08                   /* plane 4 <ON>   */
#define NOTP3MASK 0xf7                /* plane 4 <OFF>  */

/*-----------------------------------------------------------------------------
    cNECFLAGS (8 bit)
 
         X 0 0 X X X X X
         | | | | | | | +-- CRTC tracer
         | | | | | | +---- screen info trans.o0:text /1:graph or textp
         | | | | | +------ N/H Dynamic1 (N?H:0 H/N:1)
         | | | | +-------- N/H Dynamic2 (H:0 N:1)
         | | | +---------- graph on window
         | +-+------------ Reserved
         +---------------- EMM large page frame
-----------------------------------------------------------------------------*/

#define CRTCMASK 0x01           /* CRTC <ON>        */
#define NOTCRTCMASK 0xfe        /* CRTC <OFF>        */

#define EXCHGMASK 0x02          /* Screen Exchange <GRPH ON>  */
#define NOTEXCHGMASK 0xfd       /* Screen Exchange <GRPH OFF> */

#define EMMLGPGMASK 0x80        /* EMM Large Page Frame <ON>  */
#define NOTEMMLGPGMASK 0x7f     /* EMM Large Page Frame <OFF> */

#define NH1MASK 0x04            /* N/H Dynamic1  <N/H> (UpdateNECScreen)*/
#define NOTNH1MASK 0xfb         /* N/H Dynamic1  <N?H> (UpdateNECScreen)*/

#define NH2MASK 0x08            /* N/H Dynamic2  < N > (UpdateNECScreen)*/
#define NOTNH2MASK 0xf7         /* N/H Dynamic2  < H > (UpdateNECScreen)*/

#define WINGRPMASK 0x10         /* door mado 1992 9 14 */
#define NOTWINGRPMASK 0xef      /*                     */

/*-----------------------------------------------------------------------------
  cVCDFlags (8 bit)

         0 0 0 0 X X X X
         | | | | | | | +-- 0/1 RS / CS
         | | | | | | +---- 0/1 Xon / Xoff
         | | | | | +------ 0/1 ER/DR
         | | | | +-------- Port(Reserved)
         | | | +---------- Port(Reserved)
         +-+-+-+---------- Reserved

------------------------------------------------------------------------------*/
#define VCDRSCSMASK 0x001                /* 0/1 RS/CS   handshake */
#define NOTVCDRSCSMASK 0xfe

#define VCDXONOFFMASK 0x02               /* 0/1 Xon/off handshake */
#define NOTVCDXONOFFMASK 0xfd

#define VCDERDRMASK 0x04                 /* 0/1 ER/DR   handshake */
#define NOTVCDERDRMASK 0xfb

/* Now Only Reserved */
                                         /* port assign */
#define VCDPORTASMASK 0x18               /* 00:none                */
#define NOTVCDPORTASMASK 0xe7            /* 01:port1port2        */
                                         /* 10:port1port3        */
                                         /* 11:unused              */

/*-----------------------------------------------------------------------------
  EnhExtBit (8 bit)

         X 0 0 X X X X X
         | | | | | | | +-- Mode F/F (Yes:0 No:1)
         | | | | | | +---- Display/Draw (Yes:0 No:1)
         | | | | | +------ ColorPallett (Yes:0 No:1)
         | | | | +-------- GDC (Yes:0 No:1)
         | | | +---------- Font (Yes:0 No:1)
         | +-+-+---------- Reserved
         +---------------- All is set/not(Set:1 No:0)

------------------------------------------------------------------------------*/
#define MODEFFMASK  0x01
#define NOTMODEFFMASK 0xfe

#define DISPLAYDRAWMASK 0x02            /* 0/1 Xon/off handhshake */
#define NOTDISPLAYDRAWMASK 0xfd

#define COLORPALLETTMASK 0x04           /* 0/1 ER/DR   handshake */
#define NOTCOLORPALLETTMASK 0xfb

#define GDCMASK 0x08
#define NOTGDCMASK 0xf7

#define FONTMASK 0x10
#define NOTFONTMASK 0xef

#define VDDMASK  0x80
#define NOTVDDMASK  0x7f

/*-----------------------------------------------------------------------------
  Extcont (8 bit)

        0 0 0 0 X X X X
        | | | | | | | +-- Mode F/F (8Color:0 16Color:1)
        | | | | | | +---- Reserved
        | | | | | +------ GDC TEXT (ON:1 OFF:0)
        | | | | +-------- GDC GRPH (ON:1 OFF:0)
        +-+-+-+---------- Reserved

------------------------------------------------------------------------------*/
#define  MODEFF16   0x01
#define  MODEFF8    0xfe

#define  GDCTEXTMASK    0x04
#define  NOTGDCTEXTMASK  0xfb

#define GDCGRPHMASK    0x08
#define NOTGDCGRPHMASK  0xf7

/*-----------------------------------------------------------------------------
    Reserved(8 bit)
 
         0 0 0 0 0 0 0 0
         | | | | | | | |
         +-+-+-+-+-+-+-+-- Reserved

-----------------------------------------------------------------------------*/
/*        unused        */

/*****************************************************************************/
/*  Windows NT 3.1 PIF file extension for NEC PC-9800                        */
/*****************************************************************************/
/*  For Header signature.  */

#define WNTNECHDRSIG   "WINDOWS NT31NEC"

/* Real Extended Structire for NEC PC-9800 */

#ifndef RC_INVOKED
#pragma pack (1)   
#endif
typedef struct {
 BYTE   cFontFlags;
 BYTE   cReserved[31];   // reserved
 } PIFNTNECEXT;   // all = 32bytes
#ifndef RC_INVOKED
#pragma pack()        
#endif
#define PIFNTNECEXTSIZE sizeof(PIFNTNECEXT)
/*-----------------------------------------------------------------------------
    cFontFlags (8 bit)
 
         0 0 0 0 0 0 0 X
         | | | | | | | +-- N mode compatible font(default:FALSE)
         +-+-+-+-+-+-+---- Reserved
-----------------------------------------------------------------------------*/

#define NECFONTMASK  0x01  /* NEC Font <ON>  */
#define NONECFONTMASK  0xfe  /* NEC Font <OFF>  */

/*-----------------------------------------------------------------------------
    Reserved(8 bit)[31]
 
         0 0 0 0 0 0 0 0
         | | | | | | | |
         +-+-+-+-+-+-+-+-- Reserved

-----------------------------------------------------------------------------*/
/*        unused        */

#endif // !_PIFNT_NEC98_
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\oemuni.h ===
/*
 *  OemUnicode win32 thunk prototypes
 *
 *  14-Jan-1993 Jonle, created
 *
 *  Should be identical to ansi form with "Oem" appended
 *  instead of "A"
 */

HANDLE
WINAPI
CreateFileOem(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

BOOL
APIENTRY
SetVolumeLabelOem(
    LPSTR  pszRootPath,
    LPSTR  pszVolumeName
    );

BOOL
APIENTRY
SetFileAttributesOemSys(
    LPSTR lpFileName,
    DWORD dwFileAttributes,
    BOOL  fSysCall
    );

DWORD
APIENTRY
GetFileAttributesOemSys(
    LPSTR lpFileName,
    BOOL  fSysCall
    );

BOOL
APIENTRY
DeleteFileOem(
    LPSTR lpFileName
    );

BOOL
APIENTRY
MoveFileOem(
    LPSTR lpExistingFileName,
    LPSTR lpNewFileName
    );

BOOL
APIENTRY
MoveFileExOem(
    LPSTR lpExistingFileName,
    LPSTR lpNewFileName,
    DWORD fdwFlags
    );

HANDLE
APIENTRY
FindFirstFileOem(
    LPSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    );

BOOL
APIENTRY
FindNextFileOem(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    );

DWORD
APIENTRY
GetFullPathNameOemSys(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart,
    BOOL  fSysCall
    );

DWORD
APIENTRY
GetCurrentDirectoryOem(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );

BOOL
APIENTRY
SetCurrentDirectoryOem(
    LPSTR lpPathName
    );

BOOL
APIENTRY
CreateDirectoryOem(
    LPSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL
APIENTRY
RemoveDirectoryOem(
    LPSTR lpPathName
    );

UINT
APIENTRY
GetSystemDirectoryOem(
    LPSTR lpBuffer,
    UINT uSize
    );

UINT
APIENTRY
GetWindowsDirectoryOem(
    LPSTR lpBuffer,
    UINT uSize
    );

UINT
APIENTRY
GetDriveTypeOem(
    LPSTR lpRootPathName
    );

DWORD
APIENTRY
SearchPathOem (
    LPCSTR lpPath,
    LPCSTR lpFileName,
    LPCSTR lpExtension,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );

DWORD
APIENTRY
GetTempPathOem(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );

UINT
APIENTRY
GetTempFileNameOem(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
    );

BOOL
APIENTRY
GetDiskFreeSpaceOem(
    LPSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );

BOOL
APIENTRY
GetVolumeInformationOem(
    LPSTR lpRootPathName,
    LPSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );

BOOL
WINAPI
CreateProcessOem(
    LPCSTR lpApplicationName,
    LPCSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

DWORD
WINAPI
GetEnvironmentVariableOem(
    LPSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    );

BOOL
WINAPI
SetEnvironmentVariableOem(
    LPSTR lpName,
    LPSTR lpValue
    );

DWORD
WINAPI
ExpandEnvironmentStringsOem(
    LPSTR lpSrc,
    LPSTR lpDst,
    DWORD cchDst
    );



VOID
APIENTRY
OutputDebugStringOem(
    LPCSTR lpOutputString
    );

BOOL
WINAPI
GetComputerNameOem (
    LPSTR   lpComputerName,
    LPDWORD BufferSize
    );

BOOL
WINAPI
RemoveFontResourceOem(
    LPSTR   lpFileName
    );

UINT
WINAPI
GetShortPathNameOem(
    LPSTR lpSrc,
    LPSTR lpDst,
    DWORD cchDst
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\rdrsvc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rdrsvc.h

Abstract:

    Contains BOP codes for Vdm Redir (Vr) BOP dispatcher

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Revision History:

    13-Sep-1991 rfirth
        Created

--*/



/* ASM
include bop.inc

SVC     macro   SvcNum
        BOP     BOP_REDIR
        db      SvcNum
endm

*/



//
// Note: the order has no bearing on the order of the 5f dispatch table or
// vice versa. However, the order must be contiguous
//

#define SVC_RDRINITIALIZE       0x00    // redir loaded
#define SVC_RDRUNINITIALIZE     0x01    // redir unloaded
#define SVC_RDRQNMPIPEINFO      0x02    // DosQNmPipeInfo
#define SVC_RDRQNMPHANDSTATE    0x03    // DosQNmpHandState
#define SVC_RDRSETNMPHANDSTATE  0x04    // DosSetNmpHandState
#define SVC_RDRPEEKNMPIPE       0x05    // DosPeekNmPipe
#define SVC_RDRTRANSACTNMPIPE   0x06    // DosTransactNmPipe
#define SVC_RDRCALLNMPIPE       0x07    // DosCallNmPipe
#define SVC_RDRWAITNMPIPE       0x08    // DosWaitNmPipe
#define SVC_RDRDELETEMAILSLOT   0x09    // DosDeleteMailslot
#define SVC_RDRGETMAILSLOTINFO  0x0a    // DosMailslotInfo
#define SVC_RDRMAKEMAILSLOT     0x0b    // DosMakeMailslot
#define SVC_RDRPEEKMAILSLOT     0x0c    // DosPeekMailslot
#define SVC_RDRREADMAILSLOT     0x0d    // DosReadMailslot
#define SVC_RDRWRITEMAILSLOT    0x0e    // DosWriteMailslot
#define SVC_RDRTERMINATE        0x0f    // NetResetEnvironment for mailslots
#define SVC_RDRTRANSACTAPI      0x10    // NetTransactAPI
#define SVC_RDRIREMOTEAPI       0x11    // NetIRemoteAPI
#define SVC_RDRNULLTRANSACTAPI  0x12    // NetTransactAPI
#define SVC_RDRSERVERENUM       0x13    // NetServerEnum (remoted)
#define SVC_RDRUSEADD           0x14    // NetUseAdd (local)
#define SVC_RDRUSEDEL           0x15    // NetUseDel (local)
#define SVC_RDRUSEENUM          0x16    // NetUseEnum (local)
#define SVC_RDRUSEGETINFO       0x17    // NetUseGetInfo (local)
#define SVC_RDRWKSTAGETINFO     0x18    // NetWkstaGetInfo (local)
#define SVC_RDRWKSTASETINFO     0x19    // NetWkstaSetInfo (local)
#define SVC_RDRMESSAGEBUFFERSEND 0x1a    // NetMessageBufferSend (local)
#define SVC_RDRGETCDNAMES       0x1b    // NetGetEnumInfo.CDNames
#define SVC_RDRGETCOMPUTERNAME  0x1c    // NetGetEnumInfo.ComputerName
#define SVC_RDRGETUSERNAME      0x1d    // NetGetEnumInfo.UserName
#define SVC_RDRGETDOMAINNAME    0x1e    // NetGetEnumInfo.DomainName
#define SVC_RDRGETLOGONSERVER   0x1f    // NetGetEnumInfo.LogonServer
#define SVC_RDRHANDLEGETINFO    0x20    // NetHandleGetInfo
#define SVC_RDRHANDLESETINFO    0x21    // NetHandleSetInfo
#define SVC_RDRGETDCNAME        0x22    // NetGetDCName
#define SVC_RDRREADASYNCNMPIPE  0x23    // DosReadAsyncNmPipe
#define SVC_RDRWRITEASYNCNMPIPE 0x24    // DosWriteAsyncNmPipe
#define SVC_NETBIOS5C           0x25    // Netbios request handler
#define SVC_NETBIOS5CINTERRUPT  0x26    // Netbios/Dlc post routine request
#define SVC_DLC_5C              0x27    // Dlc request handler
#define SVC_VDM_WINDOW_INIT     0x28    // Inits memory window
#define SVC_RDRRETURN_MODE      0x29    // returns pause/continue state
#define SVC_RDRSET_MODE         0x2a    // sets pause/continue state
#define SVC_RDRGET_ASG_LIST     0x2b    // old NetUseGetInfo
#define SVC_RDRDEFINE_MACRO     0x2c    // old NetUseAdd
#define SVC_RDRBREAK_MACRO      0x2d    // old NetUseDel
#define SVC_RDRSERVICECONTROL   0x2e    // NetServiceControl
#define SVC_RDRINTACK           0x2f    // VrDismissInterrupt
#define SVC_RDRINTACK2          0x30    // VrDismissInterrupt2
#define SVC_NETBIOSCHECK        0x31    // VrCheckPmNetbiosAnr

#define MAX_REDIR_SVC           SVC_NETBIOSCHECK

#define NETWORK_VECTOR          0x73
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\softpc.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990  Microsoft Corporation

Module Name:

    SOFTPC.H

Abstract:

    High-level include file for components interfacing to SoftPC

Author:

    Dave Hastings (daveh) 25-Apr-1991

Revision History:
    Sudeep Bharati        23-Aug-1991  Added SOFTPC_BLD
    Matt Felton            8-FEB-1992  Added getIntelRegistersPointer
    Jonle                 18-Sep-1992  Add popup for unsupported functionality
    Jonle                 21-Nov-1992  Add Standard Resource Error Dialog Box
                                           GetPIFConfigFiles

--*/


/********** COMMON STUFF FOR MIPS AND V86 *************/

/* XLATOFF */
#ifdef i386
#include "v86def.h"
#endif

#include <vdm.h>

extern VOID SbReinitialize(PCHAR, DWORD);

/* XLATON */
extern VOID nt_block_event_thread(ULONG);
extern VOID nt_resume_event_thread(VOID);
/* notification of PDB(Process Data Block, A.K.A PSP) termination */
extern VOID HostTerminatePDB(USHORT pdb);
/* disk subsystem reset notification. These functions will close all
 * outstanding opened handles for DASD(Direct AcceS Disk) */
extern VOID HostFloppyReset(VOID);
extern VOID HostFdiskReset(VOID);

// unsupported services dialog box
extern VOID host_direct_access_error(ULONG);

extern VOID host_lpt_flush_initialize(VOID);

#define NOSUPPORT_FLOPPY      0
#define NOSUPPORT_HARDDISK    1
#define NOSUPPORT_DRIVER      2
#define NOSUPPORT_OLDPIF      3
#define NOSUPPORT_ILLBOP      4
#define NOSUPPORT_NOLIM       5
#define NOSUPPORT_MOUSEDRVR   6

// standard error dialog box using resources
void RcErrorDialogBox(USHORT wId, CHAR *msg1, CHAR *msg2);


/*
 *  RcMessageBox\EditBox stuff
 */
#define RMB_ABORT        1
#define RMB_RETRY        2
#define RMB_IGNORE       4
#define RMB_ICON_INFO    8
#define RMB_ICON_BANG   16
#define RMB_ICON_STOP   32
#define RMB_ICON_WHAT   64
#define RMB_EDIT       128
#define RMB_FLAGS_MASK 0x0000FFFF
#define RMB_EDITBUFFERSIZE_MASK 0xFFFF0000
// hiword of dwOptions is reserved for RMB_EDIT text buffer size

int RcMessageBox(USHORT wId, CHAR *msg1, CHAR *msg2, ULONG dwOptions);


// sudeepb 02-May-1993 these following defines are actually defined
// in host\inc\error.h and host\inc\nt_uis.h. this stuff needs
// major cleanup after product 1.0.

#define EG_MALLOC_FAILURE       7
#define EG_PIF_BAD_FORMAT      18
#define EG_PIF_STARTDIR_ERR    19
#define EG_PIF_STARTFILE_ERR   20
#define EG_PIF_CMDLINE_ERR     21
#define EG_PIF_ASK_CMDLINE     22
#define EG_ENVIRONMENT_ERR     23
#define EG_BAD_FAULT           27
#define EG_DOS_PROG_EXTENSION  28

#define ED_BADSYSFILE           336
#define ED_INITMEMERR           337
#define ED_INITTMPFILE          338


//
// SysErrorBox stuff -- duplicated in usersrv.h *and* kernel.inc
//
#define  SEB_OK         1  /* Button with "OK".     */
#define  SEB_CANCEL     2  /* Button with "Cancel"  */
#define  SEB_YES        3  /* Button with "&Yes"     */
#define  SEB_NO         4  /* Button with "&No"      */
#define  SEB_RETRY      5  /* Button with "&Retry"   */
#define  SEB_ABORT      6  /* Button with "&Abort"   */
#define  SEB_IGNORE     7  /* Button with "&Ignore"  */
#define  SEB_CLOSE      8  /* Button with "&Close"   */

#define  SEB_DEFBUTTON  0x8000  /* Mask to make this button default */

ULONG WOWSysErrorBox(
    LPSTR  szTitle,
    LPSTR  szMessage,
    USHORT wBtn1,
    USHORT wBtn2,
    USHORT wBtn3
    );

// Called by WOW to force VdmAllocateVirtualMemory to alloc blocks of
// memory with ever increasing linear address's.
VOID SetWOWforceIncrAlloc(
    BOOL iEnable
    );

// call out to softpc to get config.sys\autoexec.bat file names

VOID GetPIFConfigFiles(BOOL bConfig, char *pchFileName, BOOL bFreMem);

// exported interfaces
extern VOID    TerminateVDM (VOID);
extern ULONG   DosSessionId;

// VDD idle callouts
void WaitIfIdle(void);
void WakeUpNow(void);


//
// Constants
//
#define MSW_PE              0x1

/* XLATOFF */
#define ISPESET             (UCHAR) (getMSW() & MSW_PE ? 1 : 0)
/* XLATON */

//
// Macros
//

#define EXPORT

// Flag Register constants

#define FLG_CARRY           0x00000001
#define FLG_CARRY_BIT       0x00000000
#define FLG_PARITY          0x00000004
#define FLG_PARITY_BIT      0x00000003
#define FLG_AUXILIARY       0x00000010
#define FLG_AUXILIARY_BIT   0x00000005
#define FLG_ZERO            0x00000040
#define FLG_ZERO_BIT        0x00000006
#define FLG_SIGN            0x00000080
#define FLG_SIGN_BIT        0x00000007
#define FLG_TRAP            0x00000100

#define FLG_INTERRUPT       0x00000200
#define FLG_INTERRUPT_BIT   0x00000009
#define FLG_DIRECTION       0x00000400
#define FLG_DIRECTION_BIT   0x0000000A
#define FLG_OVERFLOW        0x00000800
#define FLG_OVERFLOW_BIT    0x0000000B

EXPORT
VOID
host_cpu_init(
     VOID
     );

//EXPORT
//VOID
//sas_init(
//    IN sys_addr Size
//    );

EXPORT
VOID
host_simulate(
    VOID
    );

HANDLE
host_CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );

VOID
cpu_createthread(
    HANDLE   hThread,
    PVDM_TIB VdmTib
    );

VOID
host_ExitThread(
    DWORD dwExitCode
    );


EXPORT VOID host_com_close(int PortId);
EXPORT int SuspendTimerThread(VOID);
EXPORT int ResumeTimerThread(VOID);

void *ch_malloc(unsigned int NumBytes);


UCHAR *Sim32pGetVDMPointer(ULONG addr, UCHAR pm);
#define Sim32GetVDMPointer(Addr,Size,Mode) Sim32pGetVDMPointer(Addr,Mode)

#ifdef i386

/********** FOR V86 BUILD *************/

BOOL
ThreadSetDebugContext(
    PULONG pDebugRegisters
    );

BOOL
ThreadGetDebugContext(
    PULONG pDebugRegisters
    );

// external data

extern ULONG      IntelBase;        // used by memory access macros
extern X86CONTEXT IntelRegisters;   // used by register access macros
extern ULONG      VdmDebugLevel;    // used to control debugging
extern ULONG      VdmFeatureBits;


// Register access macros

#ifdef LINKED_INTO_MONITOR

#include <vdm.h>

#define DECLARE_LocalVdmContext VDM_TIB * _LocalVdmTib = (VDM_TIB *)(NtCurrentTeb()->Vdm); \
                                CONTEXT * _LocalVdmContext = &(*_LocalVdmTib).VdmContext

#ifndef FAST_VDM_REGISTERS

#define getEAX()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax)
#define getAX()     ((USHORT)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax))
#define getAL()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax))
#define getAH()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax >> 8))
#define getEBX()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx)
#define getBX()     ((USHORT)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx))
#define getBL()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx))
#define getBH()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx >> 8))
#define getECX()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx)
#define getCX()     ((USHORT)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx))
#define getCL()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx))
#define getCH()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx >> 8))
#define getEDX()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx)
#define getDX()     ((USHORT)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx))
#define getDL()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx))
#define getDH()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx >> 8))
#define getESP()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esp)
#define getSP()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esp)
#define getEBP()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebp)
#define getBP()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebp)
#define getESI()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esi)
#define getSI()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esi)
#define getEDI()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edi)
#define getDI()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edi)
#define getEIP()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eip)
#define getIP()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eip)
#define getCS()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegCs)
#define getSS()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegSs)
#define getDS()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegDs)
#define getES()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegEs)
#define getFS()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegFs)
#define getGS()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegGs)
#define getCF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_CARRY) ? 1 : 0)
#define getPF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_PARITY) ? 1 : 0)
#define getAF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_AUXILIARY) ? 1 : 0)
#define getZF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_ZERO) ? 1 : 0)
#define getSF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_SIGN) ? 1 : 0)
#define getTF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_TRAP) ? 1 : 0)
#define getIF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_INTERRUPT) ? 1 : 0)
#define getDF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_DIRECTION) ? 1 : 0)
#define getOF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_OVERFLOW) ? 1 : 0)
#define getMSW()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).IntelMSW)
#define getSTATUS() (USHORT)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags)
#define getEFLAGS() ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags)

#define setEAX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax = val;}

#define setAX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setAH(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setAL(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setEBX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx = val ;}

#define setBX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setBH(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setBL(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setECX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx = val ;}

#define setCX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setCH(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setCL(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setEDX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx = val ;}

#define setDX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setDH(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setDL(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx & 0xFFFFFF00) |                                ((ULONG)val & 0x000000FF);}

#define setESP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esp = val ;}

#define setSP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esp = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esp & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setEBP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebp = val;}

#define setBP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebp = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebp & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setESI(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esi = val ;}

#define setSI(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esi = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esi & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}
#define setEDI(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edi = val ;}

#define setDI(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edi = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edi & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setEIP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eip = val ;}

#define setIP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eip = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eip & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setCS(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegCs = (ULONG) val & 0x0000FFFF ;}

#define setSS(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegSs = (ULONG) val & 0x0000FFFF ;}

#define setDS(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegDs = (ULONG) val & 0x0000FFFF ;}

#define setES(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegEs = (ULONG) val & 0x0000FFFF ;}

#define setFS(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegFs = (ULONG) val & 0x0000FFFF ;}

#define setGS(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegGs = (ULONG) val & 0x0000FFFF ;}

#define setCF(val)  {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_CARRY) |                                (((ULONG)val << FLG_CARRY_BIT) & FLG_CARRY);}

#define setPF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_PARITY) |                                (((ULONG)val << FLG_PARITY_BIT) & FLG_PARITY);}

#define setAF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_AUXILIARY) |                                (((ULONG)val << FLG_AUXILIARY_BIT) & FLG_AUXILIARY);}

#define setZF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_ZERO) |                                (((ULONG)val << FLG_ZERO_BIT) & FLG_ZERO);}

#define setSF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_SIGN) |                                (((ULONG)val << FLG_SIGN_BIT) & FLG_SIGN);}

#define setIF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_INTERRUPT) |                                (((ULONG)val << FLG_INTERRUPT_BIT) & FLG_INTERRUPT);}

#define setDF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_DIRECTION) |                                (((ULONG)val << FLG_DIRECTION_BIT) & FLG_DIRECTION);}

#define setOF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_OVERFLOW) |                                (((ULONG)val << FLG_OVERFLOW_BIT) & FLG_OVERFLOW);}

#define setMSW(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).IntelMSW = val ;}

#define setSTATUS(val) { (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & 0xFFFF0000) | val;}

#define setEFLAGS(val) { (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = val;}

#else // FAST_VDM_REGISTERS

#define getEAX()     (_LocalVdmContext->Eax)
#define getAX()     ((USHORT)(_LocalVdmContext->Eax))
#define getAL()     ((BYTE)(_LocalVdmContext->Eax))
#define getAH()     ((BYTE)(_LocalVdmContext->Eax >> 8))
#define getEBX()    (_LocalVdmContext->Ebx)
#define getBX()     ((USHORT)(_LocalVdmContext->Ebx))
#define getBL()     ((BYTE)(_LocalVdmContext->Ebx))
#define getBH()     ((BYTE)(_LocalVdmContext->Ebx >> 8))
#define getECX()    (_LocalVdmContext->Ecx)
#define getCX()     ((USHORT)(_LocalVdmContext->Ecx))
#define getCL()     ((BYTE)(_LocalVdmContext->Ecx))
#define getCH()     ((BYTE)(_LocalVdmContext->Ecx >> 8))
#define getEDX()    (_LocalVdmContext->Edx)
#define getDX()     ((USHORT)(_LocalVdmContext->Edx))
#define getDL()     ((BYTE)(_LocalVdmContext->Edx))
#define getDH()     ((BYTE)(_LocalVdmContext->Edx >> 8))
#define getESP()    (_LocalVdmContext->Esp)
#define getSP()     ((USHORT)_LocalVdmContext->Esp)
#define getEBP()    (_LocalVdmContext->Ebp)
#define getBP()     ((USHORT)_LocalVdmContext->Ebp)
#define getESI()    (_LocalVdmContext->Esi)
#define getSI()     ((USHORT)_LocalVdmContext->Esi)
#define getEDI()    (_LocalVdmContext->Edi)
#define getDI()     ((USHORT)_LocalVdmContext->Edi)
#define getEIP()    (_LocalVdmContext->Eip)
#define getIP()     ((USHORT)_LocalVdmContext->Eip)
#define getCS()     ((USHORT)_LocalVdmContext->SegCs)
#define getSS()     ((USHORT)_LocalVdmContext->SegSs)
#define getDS()     ((USHORT)_LocalVdmContext->SegDs)
#define getES()     ((USHORT)_LocalVdmContext->SegEs)
#define getFS()     ((USHORT)_LocalVdmContext->SegFs)
#define getGS()     ((USHORT)_LocalVdmContext->SegGs)
#define getCF()     ((_LocalVdmContext->EFlags & FLG_CARRY) ? 1 : 0)
#define getPF()     ((_LocalVdmContext->EFlags & FLG_PARITY) ? 1 : 0)
#define getAF()     ((_LocalVdmContext->EFlags & FLG_AUXILIARY) ? 1 : 0)
#define getZF()     ((_LocalVdmContext->EFlags & FLG_ZERO) ? 1 : 0)
#define getSF()     ((_LocalVdmContext->EFlags & FLG_SIGN) ? 1 : 0)
#define getTF()     ((_LocalVdmContext->EFlags & FLG_TRAP) ? 1 : 0)
#define getIF()     ((_LocalVdmContext->EFlags & FLG_INTERRUPT) ? 1 : 0)
#define getDF()     ((_LocalVdmContext->EFlags & FLG_DIRECTION) ? 1 : 0)
#define getOF()     ((_LocalVdmContext->EFlags & FLG_OVERFLOW) ? 1 : 0)
#define getMSW()     ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).IntelMSW)
#define getSTATUS() (USHORT)(_LocalVdmContext->EFlags)
#define getEFLAGS() (_LocalVdmContext->EFlags)

#define setEAX(val) {    _LocalVdmContext->Eax = val;}

#define setAX(val) {    _LocalVdmContext->Eax = (_LocalVdmContext->Eax & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setAH(val) {    _LocalVdmContext->Eax = (_LocalVdmContext->Eax & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setAL(val) {    _LocalVdmContext->Eax = (_LocalVdmContext->Eax & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setEBX(val) {    _LocalVdmContext->Ebx = val ;}

#define setBX(val) {    _LocalVdmContext->Ebx = (_LocalVdmContext->Ebx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setBH(val) {    _LocalVdmContext->Ebx = (_LocalVdmContext->Ebx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setBL(val) {    _LocalVdmContext->Ebx = (_LocalVdmContext->Ebx & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setECX(val) {    _LocalVdmContext->Ecx = val ;}

#define setCX(val) {    _LocalVdmContext->Ecx = (_LocalVdmContext->Ecx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setCH(val) {    _LocalVdmContext->Ecx = (_LocalVdmContext->Ecx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setCL(val) {    _LocalVdmContext->Ecx = (_LocalVdmContext->Ecx & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setEDX(val) {    _LocalVdmContext->Edx = val ;}

#define setDX(val) {    _LocalVdmContext->Edx = (_LocalVdmContext->Edx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setDH(val) {    _LocalVdmContext->Edx = (_LocalVdmContext->Edx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setDL(val) {    _LocalVdmContext->Edx = (_LocalVdmContext->Edx & 0xFFFFFF00) |                                ((ULONG)val & 0x000000FF);}

#define setESP(val) {    _LocalVdmContext->Esp = val ;}

#define setSP(val) {    _LocalVdmContext->Esp = (_LocalVdmContext->Esp & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setEBP(val) {    _LocalVdmContext->Ebp = val;}

#define setBP(val) {    _LocalVdmContext->Ebp = (_LocalVdmContext->Ebp & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setESI(val) {    _LocalVdmContext->Esi = val ;}

#define setSI(val) {    _LocalVdmContext->Esi = (_LocalVdmContext->Esi & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}
#define setEDI(val) {    _LocalVdmContext->Edi = val ;}

#define setDI(val) {    _LocalVdmContext->Edi = (_LocalVdmContext->Edi & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setEIP(val) {    _LocalVdmContext->Eip = val ;}

#define setIP(val) {    _LocalVdmContext->Eip = (_LocalVdmContext->Eip & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setCS(val) {    _LocalVdmContext->SegCs = (ULONG) val & 0x0000FFFF ;}

#define setSS(val) {    _LocalVdmContext->SegSs = (ULONG) val & 0x0000FFFF ;}

#define setDS(val) {    _LocalVdmContext->SegDs = (ULONG) val & 0x0000FFFF ;}

#define setES(val) {    _LocalVdmContext->SegEs = (ULONG) val & 0x0000FFFF ;}

#define setFS(val) {    _LocalVdmContext->SegFs = (ULONG) val & 0x0000FFFF ;}

#define setGS(val) {    _LocalVdmContext->SegGs = (ULONG) val & 0x0000FFFF ;}

#define setCF(val)  {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_CARRY) |                                (((ULONG)val << FLG_CARRY_BIT) & FLG_CARRY);}

#define setPF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_PARITY) |                                (((ULONG)val << FLG_PARITY_BIT) & FLG_PARITY);}

#define setAF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_AUXILIARY) |                                (((ULONG)val << FLG_AUXILIARY_BIT) & FLG_AUXILIARY);}

#define setZF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_ZERO) |                                (((ULONG)val << FLG_ZERO_BIT) & FLG_ZERO);}

#define setSF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_SIGN) |                                (((ULONG)val << FLG_SIGN_BIT) & FLG_SIGN);}

#define setIF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_INTERRUPT) |                                (((ULONG)val << FLG_INTERRUPT_BIT) & FLG_INTERRUPT);}

#define setDF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_DIRECTION) |                                (((ULONG)val << FLG_DIRECTION_BIT) & FLG_DIRECTION);}

#define setOF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_OVERFLOW) |                                (((ULONG)val << FLG_OVERFLOW_BIT) & FLG_OVERFLOW);}

#define setMSW(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).IntelMSW = val ;}

#define setSTATUS(val) { _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & 0xFFFF0000) | val;}

#define setEFLAGS(val) { _LocalVdmContext->EFlags = val;}

#endif  // FAST_VDM_REGISTERS

#else // not linked into monitor

extern ULONG  getEAX(VOID);
extern USHORT getAX(VOID);
extern UCHAR  getAL(VOID);
extern UCHAR  getAH(VOID);
extern ULONG  getEBX(VOID);
extern USHORT getBX(VOID);
extern UCHAR  getBL(VOID);
extern UCHAR  getBH(VOID);
extern ULONG  getECX(VOID);
extern USHORT getCX(VOID);
extern UCHAR  getCL(VOID);
extern UCHAR  getCH(VOID);
extern ULONG  getEDX(VOID);
extern USHORT getDX(VOID);
extern UCHAR  getDL(VOID);
extern UCHAR  getDH(VOID);
extern ULONG  getESP(VOID);
extern USHORT getSP(VOID);
extern ULONG  getEBP(VOID);
extern USHORT getBP(VOID);
extern ULONG  getESI(VOID);
extern USHORT getSI(VOID);
extern ULONG  getEDI(VOID);
extern USHORT getDI(VOID);
extern ULONG  getEIP(VOID);
extern USHORT getIP(VOID);
extern USHORT getCS(VOID);
extern USHORT getSS(VOID);
extern USHORT getDS(VOID);
extern USHORT getES(VOID);
extern USHORT getFS(VOID);
extern USHORT getGS(VOID);
extern ULONG  getCF(VOID);
extern ULONG  getPF(VOID);
extern ULONG  getAF(VOID);
extern ULONG  getZF(VOID);
extern ULONG  getSF(VOID);
extern ULONG  getIF(VOID);
extern ULONG  getDF(VOID);
extern ULONG  getOF(VOID);
extern USHORT getMSW(VOID);
extern USHORT getSTATUS(VOID);
extern ULONG  getEFLAGS(VOID);

extern VOID setEAX(ULONG);
extern VOID setAX(USHORT);
extern VOID setAH(UCHAR);
extern VOID setAL(UCHAR);
extern VOID setEBX(ULONG);
extern VOID setBX(USHORT);
extern VOID setBH(UCHAR);
extern VOID setBL(UCHAR);
extern VOID setECX(ULONG);
extern VOID setCX(USHORT);
extern VOID setCH(UCHAR);
extern VOID setCL(UCHAR);
extern VOID setEDX(ULONG);
extern VOID setDX(USHORT);
extern VOID setDH(UCHAR);
extern VOID setDL(UCHAR);
extern VOID setESP(ULONG);
extern VOID setSP(USHORT);
extern VOID setEBP(ULONG);
extern VOID setBP(USHORT);
extern VOID setESI(ULONG);
extern VOID setSI(USHORT);
extern VOID setEDI(ULONG);
extern VOID setDI(USHORT);
extern VOID setEIP(ULONG);
extern VOID setIP(USHORT);
extern VOID setCS(USHORT);
extern VOID setSS(USHORT);
extern VOID setDS(USHORT);
extern VOID setES(USHORT);
extern VOID setFS(USHORT);
extern VOID setGS(USHORT);
extern VOID setCF(ULONG);
extern VOID setPF(ULONG);
extern VOID setAF(ULONG);
extern VOID setZF(ULONG);
extern VOID setSF(ULONG);
extern VOID setIF(ULONG);
extern VOID setDF(ULONG);
extern VOID setOF(ULONG);
extern VOID setMSW(USHORT);
extern VOID setSTATUS(USHORT);
extern VOID setEFLAGS(ULONG);
#endif

//
// Sim32 macros
//

// no action is required for this macro.
#define Sim32FlushVDMPointer( address, size, buffer, mode ) TRUE

// no action is required for this macro.
#define Sim32FreeVDMPointer( address, size, buffer, mode) TRUE

#define Sim32GetVDMMemory( address, size, buffer, mode) (memcpy(  \
    buffer, Sim32pGetVDMPointer(address, mode), size), TRUE)

#define Sim32SetVDMMemory( address, size, buffer, mode) (memcpy( \
    Sim32pGetVDMPointer(address, mode), buffer, size), TRUE)

// Address conversion macros

#define RMOFF(address) (WORD)((ULONG)address & 0x0000FFFF)
#define RMSEG(address) (WORD)(((ULONG)address - ((ULONG)address & 0x0000FFFF)) >> 4)
#define RMSEGOFFTOLIN(seg, off) (PVOID)(IntelBase + ((ULONG)(seg) << 4) + (ULONG)(off))

// Debugging Macros

#define VDprint(value, arg) { if (value <= (VdmDebugLevel & VDP_LEVEL_MASK)) {\
                                         DbgPrint arg ; }}

#define VDbreak(value) { if (value <= (VDB_LEVEL_MASK & VdmDebugLevel)) {\
                                         DbgBreakPoint(); }}

#define VDP_LEVEL_MASK          0x0F
#define VDP_LEVEL_NONE          0x0
#define VDP_LEVEL_ERROR         0x2
#define VDP_LEVEL_WARNING       0x4
#define VDP_LEVEL_INFO          0x8

#define VDB_LEVEL_MASK          0xF0
#define VDB_LEVEL_NONE          0x00
#define VDB_LEVEL_ERROR         0x20
#define VDB_LEVEL_WARNING       0x40
#define VDB_LEVEL_INFO          0x80

//
//  Function prototypes
//

ULONG
DbgPrint(
    PCH Format,
    ...
    );

char *nt_fgets(char *buffer, int len, void *input_stream);
char *nt_gets(char *buffer);


#define GetVDMAddr(usSeg,usOff)  (((ULONG)usSeg << 4) + usOff)

PX86CONTEXT getIntelRegistersPointer(VOID);

#else

/*********************** FOR MIPS BUILD ***************************/


#define GetVDMAddr(usSeg,usOff) Sim32pGetVDMPointer((ULONG)(((ULONG)usSeg << 16) | usOff),FALSE)

#define RMSEGOFFTOLIN(seg, off) (PVOID)(((ULONG)(seg) << 4) + (ULONG)(off))

extern BOOL     Sim32FlushVDMPointer (ULONG, USHORT, PBYTE , BOOL);
extern BOOL     Sim32FreeVDMPointer (ULONG, USHORT, PBYTE , BOOL);
extern BOOL     Sim32GetVDMMemory (ULONG, USHORT, PBYTE , BOOL);
extern BOOL     Sim32SetVDMMemory (ULONG, USHORT, PBYTE , BOOL);
extern VOID     sas_overwrite_memory(PBYTE, ULONG);

extern UCHAR getAL(VOID);
extern UCHAR getCL(VOID);
extern UCHAR getDL(VOID);
extern UCHAR getBL(VOID);
extern UCHAR getAH(VOID);
extern UCHAR getCH(VOID);
extern UCHAR getDH(VOID);
extern UCHAR getBH(VOID);

extern VOID setAL(UCHAR val);
extern VOID setCL(UCHAR val);
extern VOID setDL(UCHAR val);
extern VOID setBL(UCHAR val);
extern VOID setAH(UCHAR val);
extern VOID setCH(UCHAR val);
extern VOID setDH(UCHAR val);
extern VOID setBH(UCHAR val);

extern USHORT getAX(VOID);
extern USHORT getCX(VOID);
extern USHORT getDX(VOID);
extern USHORT getBX(VOID);
extern USHORT getSP(VOID);
extern USHORT getBP(VOID);
extern USHORT getSI(VOID);
extern USHORT getDI(VOID);
extern USHORT getIP(VOID);

extern VOID setAX(USHORT val);
extern VOID setCX(USHORT val);
extern VOID setDX(USHORT val);
extern VOID setBX(USHORT val);
extern VOID setSP(USHORT val);
extern VOID setBP(USHORT val);
extern VOID setSI(USHORT val);
extern VOID setDI(USHORT val);
extern VOID setIP(USHORT val);

extern ULONG getEAX(VOID);
extern ULONG getECX(VOID);
extern ULONG getEDX(VOID);
extern ULONG getEBX(VOID);
extern ULONG getESP(VOID);
extern ULONG getEBP(VOID);
extern ULONG getESI(VOID);
extern ULONG getEDI(VOID);
extern ULONG getEIP(VOID);

extern VOID setEAX(ULONG val);
extern VOID setECX(ULONG val);
extern VOID setEDX(ULONG val);
extern VOID setEBX(ULONG val);
extern VOID setESP(ULONG val);
extern VOID setEBP(ULONG val);
extern VOID setESI(ULONG val);
extern VOID setEDI(ULONG val);
extern VOID setEIP(ULONG val);

extern USHORT getES(VOID);
extern USHORT getCS(VOID);
extern USHORT getSS(VOID);
extern USHORT getDS(VOID);
extern USHORT getFS(VOID);
extern USHORT getGS(VOID);

extern VOID setES(USHORT val);
extern VOID setCS(USHORT val);
extern VOID setSS(USHORT val);
extern VOID setDS(USHORT val);
extern VOID setFS(USHORT val);
extern VOID setGS(USHORT val);

extern ULONG getAF(VOID);
extern ULONG getCF(VOID);
extern ULONG getDF(VOID);
extern ULONG getIF(VOID);
extern ULONG getOF(VOID);
extern ULONG getPF(VOID);
extern ULONG getSF(VOID);
extern ULONG getTF(VOID);
extern ULONG getZF(VOID);
extern ULONG getIOPL(VOID);
extern ULONG getNT(VOID);
extern USHORT getSTATUS(VOID);
extern ULONG getEFLAGS(VOID);
extern USHORT getMSW(VOID);

extern VOID setAF(ULONG val);
extern VOID setCF(ULONG val);
extern VOID setDF(ULONG val);
extern VOID setIF(ULONG val);
extern VOID setOF(ULONG val);
extern VOID setPF(ULONG val);
extern VOID setSF(ULONG val);
extern VOID setTF(ULONG val);
extern VOID setZF(ULONG val);
extern VOID setIOPL(ULONG val);
extern VOID setNT(ULONG val);
extern VOID setSTATUS(USHORT val);
extern VOID setEFLAGS(ULONG val);
extern VOID setMSW(USHORT val);

extern ULONG getCR0(VOID);
extern VOID setCR0(ULONG val);
extern ULONG getSS_AR(VOID);
extern ULONG getSS_BASE(VOID);
extern VOID setSS_BASE_LIMIT_AR(ULONG base, ULONG limit, ULONG ar);
extern VOID setCPL(ULONG val);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\tdb16.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  TDB.H
 *  16-bit Kernel Task Data Block
 *
 *  History:
 *  Created 11-Feb-1992 by Matt Felton (mattfe) - from 16 bit tdb.inc
 *       7-apr-1992 mattfe updated to be win 3.1 compatible
 *
--*/

/*
 * NewExeHdr struct offsets. WOW32 uses these for getting expected winversion
 * directly from the exehdr.
 *
 */

#define NE_LOWINVER_OFFSET 0x3e
#define NE_HIWINVER_OFFSET 0x0c
#define FLAG_NE_PROPFONT   0x2000

/*
 * Task Data Block - 16 Bit Kernel Data Structure
 *
 *   Contains all 16 bit task specific data.
 *
 */

#define numTaskInts 7
#define THUNKELEM   8   // (62*8) = 512-16 (low arena overhead)
#define THUNKSIZE   8
#define TDB_DIR_SIZE 64
#define LFN_DIR_LEN 260

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct TDB  {       /* tdb16 */

     WORD TDB_next    ;     // next task in dispatch queue
     WORD TDB_taskSP      ;     // Saved SS:SP for this task
     WORD TDB_taskSS      ;     //
     WORD TDB_nEvents     ;     // Task event counter
     BYTE TDB_priority    ;     // Task priority (0 is highest)
     BYTE TDB_thread_ordinal  ;     // ordinal number of this thread
     WORD TDB_thread_next   ;       // next thread
     WORD TDB_thread_tdb      ; // the real TDB for this task
     WORD TDB_thread_list   ;       // list of allocated thread structures
     WORD TDB_thread_free   ;       // free list of availble thread structures
     WORD TDB_thread_count  ;       // total count of tread structures
     WORD TDB_FCW         ; // Floating point control word
     BYTE TDB_flags   ;     // Task flags
     BYTE TDB_filler      ;     // keep word aligned
     WORD TDB_ErrMode     ;     // Error mode for this task
     WORD TDB_ExpWinVer   ;     // Expected Windows version for this task
     WORD TDB_Module      ;     // Task module handle to free in killtask
     WORD TDB_pModule     ;     // Pointer to the module database.
     WORD TDB_Queue   ;     // Task Event Queue pointer
     WORD TDB_Parent      ;     // TDB of the task that started this up
     WORD TDB_SigAction   ;     // Action for app task signal
     DWORD TDB_ASignalProc   ;      // App's Task Signal procedure address
     DWORD TDB_USignalProc   ;      // User's Task Signal procedure address
     DWORD TDB_GNotifyProc    ; // Task global discard notify proc.
     DWORD TDB_INTVECS[numTaskInts] ;   // Task specfic harare interrupts
     WORD TDB_CompatFlags ;     // Compatibility flags
     WORD TDB_CompatFlags2 ;        // Upper 16 bits
     WORD TDB_CompatHandle ;    // for dBase bug
     WORD TDB_WOWCompatFlagsEx ;     // More WOW Compatibility flags
     WORD TDB_WOWCompatFlagsEx2 ;        // Upper 16 bits
     BYTE TDB_Free[3] ;         // Filler to keep TDB size unchanged
     BYTE TDB_cLibrary    ;     // tracks  add/del of ALL libs in system EMS
     DWORD TDB_PHT        ; // (HANDLE:OFFSET) to private handle table
     WORD TDB_PDB         ; // MSDOS Process Data Block (PDB)
     DWORD TDB_DTA        ; // MSDOS Disk Transfer Address
     BYTE TDB_Drive  ;      // MSDOS current drive
     BYTE TDB_Directory[TDB_DIR_SIZE+1] ; // *** not used starting with win95
     WORD TDB_Validity    ;     // initial AX to be passed to a task
     WORD TDB_Yield_to    ;     // DirectedYield arg stored here
     WORD TDB_LibInitSeg      ; // segment address of libraries to init
     WORD TDB_LibInitOff      ; // MakeProcInstance thunks live here.
     WORD TDB_MPI_Sel     ;     // Code selector for thunks
     WORD TDB_MPI_Thunks[((THUNKELEM*THUNKSIZE)/2)]; //
     BYTE TDB_ModName[8] ;      // Name of Module.
     WORD TDB_sig         ; // Signature word to detect bogus code
     DWORD TDB_ThreadID   ;     // 32-Bit Thread ID for this Task (use TDB_Filler Above)
     DWORD TDB_hThread	  ;	// 32-bit Thread Handle for this task
     WORD  TDB_WOWCompatFlags;  // WOW Compatibility flags
     WORD  TDB_WOWCompatFlags2; // WOW Compatibility flags
#ifdef FE_SB
     WORD  TDB_WOWCompatFlagsJPN;  // WOW Compatibility flags for JAPAN
     WORD  TDB_WOWCompatFlagsJPN2; // WOW Compatibility flags for JAPAN
#endif // FE_SB
     DWORD TDB_vpfnAbortProc;   // printer AbortProc
     BYTE TDB_LFNDirectory[LFN_DIR_LEN]; // Long directory name.

} TDB;
typedef TDB UNALIGNED *PTDB;

// This bit is defined for the TDB_Drive field
#define TDB_DIR_VALID 0x80
#define TDB_SIGNATURE 0x4454

#define TDBF_OS2APP   0x8
#define TDBF_WINOLDAP 0x1


// NOTE TDB_ThreadID MUST be DWORD aligned or else it will fail on MIPS

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

# Make sure this is done before continuing on.
SYNCHRONIZE_BLOCK=1

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\suballoc.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    suballoc.h

Abstract:

    This is the public include file for the suballocation
    package.

Author:

    Dave Hastings (daveh) creation-date 25-Jan-1994

Revision History:


--*/

//
// Constants
//

//
// Minimum granularity for the commit routine
//   this is done as a constant rather than a parameter
//   to make defining data structures easier
//
#ifdef i386
#define COMMIT_GRANULARITY 4096
#else
#define COMMIT_GRANULARITY 65536
#endif

//
// Types
//
//
// Routine for committing a specific region of of the address
// space.  Although the return type is NTSTATUS, the only value
// that is checked is 0 (for STATUS_SUCCESS).  If STATUS_SUCCESS
// is returned, it is assumed that the function worked. If not,
// it is assumed that it failed.  No special meaning is attached to
// particular non-zero values.
//
typedef
NTSTATUS 
(*PSACOMMITROUTINE)(
    ULONG BaseAddress,
    ULONG Size
    );
    
//
// Routine for moving memory around in the address space.
// Note:  This routine MUST correctly handle overlapping
//        source and destination
//
typedef 
VOID
(*PSAMEMORYMOVEROUTINE)(
    ULONG Destination,
    ULONG Source,
    ULONG Size
    );

//
// Public prototypes
//
PVOID
SAInitialize(
    ULONG BaseAddress,
    ULONG Size,
    PSACOMMITROUTINE CommitRoutine,
    PSACOMMITROUTINE DecommitRoutine,
    PSAMEMORYMOVEROUTINE MemoryMoveRoutine
    );
    
BOOL 
SAQueryFree(
    PVOID SubAllocation,
    PULONG FreeBytes,
    PULONG LargestFreeBlock
    );
       
BOOL
SAAllocate(
    PVOID SubAllocation,
    ULONG Size,
    PULONG Address
    );
    
BOOL
SAFree(
    PVOID SubAllocation,
    ULONG Size,
    ULONG Address
    );
    
BOOL
SAReallocate(
    PVOID SubAllocation,
    ULONG OriginalSize,
    ULONG OriginalAddress,
    ULONG NewSize,
    PULONG NewAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\vint.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990  Microsoft Corporation

Module Name:

    VINT.H

Abstract:

    This module contains macro support for manipulating virtual
    interrupt bit from v86 mode and 16bit protect mode. FCLI/FST/FIRET
    result in exact behavior of these instructions on the chip without
    trapping.

Author:

    Sudeepb 08-Dec-1992 Created

Revision History:
    sudeepb 16-Mar-1993 added FIRET

--*/

/*
See \nt\private\inc\vdm.h for a complete list
of the NTVDM state flag bit definitions

INTERRUPT_PENDING_BIT - set if interrupts pending
VIRTUAL_INTERRUPT_BIT - This bit always correctly reflects the interrupt
                        disbale/enable state of the vDM while in 16bit land.

MIPS_BIT_MASK         - tells whether VDM is running on x86/mips
EXEC_BIT_MASK         - tells if DOS is in int21/exec operation.
*/

#define  INTERRUPT_PENDING_BIT      0x0003
#define  VDM_INTS_HOOKED_IN_PM      0x0004
#define  VIRTUAL_INTERRUPT_BIT      0x0200

#define  MIPS_BIT_MASK              0x400
#define  EXEC_BIT_MASK              0x800
#define  RM_BIT_MASK                0x1000
#define  RI_BIT_MASK                0x2000

#if defined(NEC_98)
#define  FIXED_NTVDMSTATE_SEGMENT   0x60                          
#else  // !NEC_98
#define  FIXED_NTVDMSTATE_SEGMENT   0x70
#endif // !NEC_98
#define  FIXED_NTVDMSTATE_OFFSET    0x14
#define  FIXED_NTVDMSTATE_LINEAR    ((FIXED_NTVDMSTATE_SEGMENT << 4) + FIXED_NTVDMSTATE_OFFSET)
#if defined(NEC_98)
#define  FIXED_NTVDMSTATE_REL40     0x214                         
#else  // !NEC_98
#define  FIXED_NTVDMSTATE_REL40     0x314
#endif // !NEC_98

#define  FIXED_NTVDMSTATE_SIZE	    4
#if defined(NEC_98)
#define  NTIO_LOAD_SEGMENT          0x60                          
#else  // !NEC_98
#define  NTIO_LOAD_SEGMENT	    0x70
#endif // !NEC_98
#define  NTIO_LOAD_OFFSET           0
#define  pNtVDMState                ((PULONG)FIXED_NTVDMSTATE_LINEAR)

#define  VDM_TIMECHANGE             0x00400000

/* ASM
; FCLI macro should be used in v86mode/16bit  preotect mode code to replace
; costly cli's. Please note that this macro could destroy the Overflow
; bit in the flag.

FCLI	macro
    local a,b,c
    push    ds
    push    ax
    mov     ax,40h
    mov     ds,ax
    lahf
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, MIPS_BIT_MASK OR RI_BIT_MASK
    jnz     short b
    lock    and	word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
a:
    sahf
    pop     ax
    pop     ds
    jmp     short c
b:
    cli
    jmp     short a
c:
endm

;
; FSTI macro should be used in v86mode or 16bit protectmode code to replace
; costly sti's. Please note that this macro could destroy the Overflow bit
; in the flag.

FSTI   macro
    local a,b,c
    push    ds
    push    ax
    mov     ax,40h
    mov     ds,ax
    lahf
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, INTERRUPT_PENDING_BIT
    jnz     short b
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, MIPS_BIT_MASK OR RI_BIT_MASK
    jnz     short b
    lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
a:
    sahf
    pop     ax
    pop     ds
    jmp     short c
b:
    sti
    jmp     short a
c:
endm

FIRET MACRO
    local a,b,d,e,f,g,i,j,k
    push    ds
    push    ax

;; Do real IRET on MIPS or if interrupts are pending

    mov     ax,40h
    mov     ds,ax
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, MIPS_BIT_MASK OR RI_BIT_MASK
    jnz     short b

;; running on x86 can assume 386 or above instructions
    push    bp
    mov     bp,sp
    mov     ax,[bp+10]      ; get flags
    pop     bp
    test    ax,100h         ; test if trap flag is set
    jnz     short b         ; if so, do iret

    test    ax,200h         ; test if interrupt flag is set
    jz      short i         ; ZR -> flag image has IF not set
    lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, INTERRUPT_PENDING_BIT
    jnz     short b
j:
    xchg    ah,al           ; AH=low byte AL=high byte
    cld
    test    al,4            ; check direction flag
    jnz     short d         ;
e:
    test    al,8            ; check overflow flag
    jnz     short f         ; go to f if flag image has OF set
    jo      short k         ; go to k to reset OF
g:
    sahf                    ; set low byte of flags from ah
    pop     ax
    pop     ds
    retf    2               ; IRET and discard flags
i:
    lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
    jmp     short j
f:
    jo      short g         ; all OK if OF bit set in real flag
    ; set the overflow bit in real flag
    push    ax
    mov     al,127
    add     al,2            ; will set OF
    pop     ax
    jmp     short g

k:
    ; reset the OF
    push    ax
    xor     al,al           ; will reset OF
    pop     ax
    jmp     short g
d:
    std
    jmp     short e
b:
    pop     ax
    pop     ds
    iret
endm

 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\v86def.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990  Microsoft Corporation

Module Name:

    V86PC.H

Abstract:

    This file contains macros, function prototypes, and externs for the
    v86-mode NT version of SoftPC v3.0.

Author:

    Dave Hastings (daveh) 4-11-91

Revision History:

    Jeff Parsons (jeffpar) 14-May-1991
    Added X86CONTEXT, which is identical to CONTEXT when running on an
    x86 platform.

--*/


// Define X86CONTEXT structure

typedef CONTEXT X86CONTEXT, *PX86CONTEXT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\vdmredir.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdmredir.h

Abstract:

    Contains common defines, structures, macros, etc. for VdmRedir. This file
    contains macros to read and write the 3 basic data structures from/to VDM
    memory. We *must* use these macros because the MIPS processor does not like
    unaligned data: a DWORD must be read/written on a DWORD boundary (low two
    bits in address = 00), a WORD must be read/written on a WORD boundary (low
    two bits in address = X0) and a BYTE can be read/written to any address (low
    two bits in address = XX). It is illegal to access a WORD at an address
    whose LSB is not 0, and a DWORD at an address whose 2 least significant bits
    are not both 0. Dos programs don't care much about alignment (smart ones do
    because there is a performance penalty for unaligned data on x86, but it
    still works). So we have to assume the worst case for MIPS and break down
    the read/writes of WORDs and DWORDs in VDM memory into BYTE read/writes

    In order to improve efficiency of load/store to potentially unaligned
    addresses, the following data pointer types are made available from this
    include file:

        ULPBYTE     - unaligned byte pointer (same as LPBYTE)
        ULPWORD     - unaligned word pointer
        ULPDWORD    - unaligned dword pointer

    NB. Dependent upon mvdm.h

Author:

    Richard L Firth (rfirth) 16-Sep-1991

Revision History:

    16-Sep-1991 rfirth
        Created

--*/

#ifndef _VDMREDIR_
#define _VDMREDIR_

#include <softpc.h>

//
// PRIVATE - make a routine/data type inaccessible outside current module, but
// only if not DEBUG version
//

#if DBG
#define PRIVATE
#else
#define PRIVATE static
#endif

//
// unaligned data pointer types. These produce exactly the same code as memory
// accesses through 'aligned' pointers on x86, but generate code specific to
// unaligned read/writes on MIPS (& other RISCs)
//

#ifdef UNALIGNED_VDM_POINTERS
typedef BYTE UNALIGNED * ULPBYTE;
typedef WORD UNALIGNED * ULPWORD;
typedef DWORD UNALIGNED * ULPDWORD;
#else
typedef LPBYTE ULPBYTE;
typedef LPWORD ULPWORD;
typedef LPDWORD ULPDWORD;
#endif

//
// misc. defines
//

#define BITS_IN_A_BYTE      8
#define LOCAL_DEVICE_PREFIX "\\\\."

//
//  Define network interrupt to be on Irql 14.
//  If NETWORK_ICA changes to ICA_MASTER then vrnetb.c should only execute 1 eoi
//  If either change then NETWORK_INTERRUPT in rdrsvc.inc must also change.
//

#if defined(NEC_98)
#define NETWORK_ICA     ICA_MASTER
#define NETWORK_LINE    5
#else
#define NETWORK_ICA     ICA_SLAVE
#define NETWORK_LINE    3
#endif

//
// helper macros
//

//
// MAKE_DWORD - converts 2 16-bit words into a 32-bit double word
//
#define MAKE_DWORD(h, l)                ((DWORD)(((DWORD)((WORD)(h)) << 16) | (DWORD)((WORD)(l))))

//
// DWORD_FROM_WORDS - converts two 16-bit words into a 32-bit dword
//
#define DWORD_FROM_WORDS(h, l)          MAKE_DWORD((h), (l))

//
// HANDLE_FROM_WORDS - converts a pair of 16-bit words into a 32-bit handle
//
#define HANDLE_FROM_WORDS(h, l)         ((HANDLE)(MAKE_DWORD((h), (l))))

//
// POINTER_FROM_WORDS - returns a flat 32-bit VOID pointer (in the VDM) OR the
// NULL macro, given the 16-bit real-mode segment & offset. On x86 this will
// return 0 if we pass in 0:0 because all GetVDMAddr does is seg << 4 + off.
// The MIPS version adds this to the start of the virtual DOS memory. The
// problem arises when we have a NULL pointer, and want to keep it NULL - we
// convert it to non-NULL on not x86
//
//#define POINTER_FROM_WORDS(seg, off)    ((LPVOID)GetVDMAddr((seg), (off)))
//#define POINTER_FROM_WORDS(seg, off)    (((((DWORD)(seg)) << 16) | (off)) ? ((LPVOID)GetVDMAddr((seg), (off))) : ((LPVOID)0))

#define POINTER_FROM_WORDS(seg, off)    _inlinePointerFromWords((WORD)(seg), (WORD)(off))

//
// LPSTR_FROM_WORDS - returns a 32-bit pointer to an ASCIZ string given the
// 16-bit real-mode segment & offset
//
#define LPSTR_FROM_WORDS(seg, off)      ((LPSTR)POINTER_FROM_WORDS((seg), (off)))

//
// LPBYTE_FROM_WORDS - returns a 32-bit byte pointer given the 16-bit
// real-mode segment & offset
//
#define LPBYTE_FROM_WORDS(seg, off)     ((LPBYTE)POINTER_FROM_WORDS((seg), (off)))

//
// READ_FAR_POINTER - read the pair of words in VDM memory, currently pointed at
// by a 32-bit flat pointer and convert them to a 32-bit flat pointer
//
#define READ_FAR_POINTER(addr)          ((LPVOID)(POINTER_FROM_WORDS(GET_SELECTOR(addr), GET_OFFSET(addr))))

//
// READ_BYTE - retrieve a single byte from VDM memory. Both x86 and MIPS can
// handle reading a single byte without pain
//
#define READ_BYTE(addr)                 (*((LPBYTE)(addr)))

//
// READ_WORD - read a single 16-bit little-endian word from VDM memory. x86 can
// handle unaligned data, MIPS (&other RISCs) must be broken down into individual
// BYTE reads & the WORD pieced together by shifting & oring. If we are using
// UNALIGNED pointers then the RISC processor can handle non-aligned data
//
#ifdef i386
#define READ_WORD(addr)                 (*((LPWORD)(addr)))
#else
#ifdef UNALIGNED_VDM_POINTERS
#define READ_WORD(addr)                 (*((ULPWORD)(addr)))
#else
#define READ_WORD(addr)                 (((WORD)READ_BYTE(addr)) | (((WORD)READ_BYTE((LPBYTE)(addr)+1)) << 8))
#endif  // UNALIGNED_VDM_POINTERS
#endif  // i386

//
// READ_DWORD - read a 4-byte little-endian double word from VDM memory. x86 can
// handle unaligned data, MIPS (&other RISCs) must be broken down into individual
// BYTE reads & the DWORD pieced together by shifting & oring. If we are using
// UNALIGNED pointers then the RISC processor can handle non-aligned data
//
#ifdef i386
#define READ_DWORD(addr)                (*((LPDWORD)(addr)))
#else
#ifdef UNALIGNED_VDM_POINTERS
#define READ_DWORD(addr)                (*((ULPDWORD)(addr)))
#else
#define READ_DWORD(addr)                (((DWORD)READ_WORD(addr)) | (((DWORD)READ_WORD((LPWORD)(addr)+1)) << 16))
#endif  // UNALIGNED_VDM_POINTERS
#endif  // i386

//
// WRITE_BYTE - write a single byte in VDM memory. Both x86 and MIPS (RISC) can
// write a single byte to a non-aligned address
//
#define WRITE_BYTE(addr, value) (*(LPBYTE)(addr) = (BYTE)(value))

//
// WRITE_WORD - write a 16-bit little-endian value into VDM memory. x86 can write
// WORD data to non-word-aligned address; MIPS (& other RISCs) cannot, so we
// break down the write into 2 byte writes. If we are using UNALIGNED pointers
// then the MIPS (&other RISCs) can generate code to handle this situation
//
#ifdef i386
#define WRITE_WORD(addr, value)         (*((LPWORD)(addr)) = (WORD)(value))
#else
#ifdef UNALIGNED_VDM_POINTERS
#define WRITE_WORD(addr, value)         (*((ULPWORD)(addr)) = (WORD)(value))
#else
#define WRITE_WORD(addr, value) \
            {\
                ((LPBYTE)(addr))[0] = LOBYTE(value); \
                ((LPBYTE)(addr))[1] = HIBYTE(value); \
            }
#endif  // UNALIGNED_VDM_POINTERS
#endif  // i386

//
// WRITE_DWORD - write a 32-bit DWORD value into VDM memory. x86 can write
// DWORD data to non-dword-aligned address; MIPS (& other RISCs) cannot, so we
// break down the write into 4 byte writes. If we are using UNALIGNED pointers
// then the MIPS (&other RISCs) can generate code to handle this situation
//
#ifdef i386
#define WRITE_DWORD(addr, value)        (*((LPDWORD)(addr)) = (DWORD)(value))
#else
#ifdef UNALIGNED_VDM_POINTERS
#define WRITE_DWORD(addr, value)        (*((ULPDWORD)(addr)) = (DWORD)(value))
#else
#define WRITE_DWORD(addr, value) \
            { \
                ((LPBYTE)(addr))[0] = LOBYTE(LOWORD((DWORD)(value))); \
                ((LPBYTE)(addr))[1] = HIBYTE(LOWORD((DWORD)(value))); \
                ((LPBYTE)(addr))[2] = LOBYTE(HIWORD((DWORD)(value))); \
                ((LPBYTE)(addr))[3] = HIBYTE(HIWORD((DWORD)(value))); \
            }
#endif  // UNALIGNED_VDM_POINTERS
#endif  // i386

//
// WRITE_FAR_POINTER - write a 16:16 pointer into VDM memory. This is the same
// as writing a DWORD
//
#define WRITE_FAR_POINTER(addr, ptr)    WRITE_DWORD((addr), (DWORD)(ptr))

//
// GET_SELECTOR - retrieves the selector word from the intel 32-bit far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//
#define GET_SELECTOR(pointer)           READ_WORD((LPWORD)(pointer)+1)

//
// GET_SEGMENT - same as GET_SELECTOR
//
#define GET_SEGMENT(pointer)            GET_SELECTOR(pointer)

//
// GET_OFFSET - retrieves the offset word from an intel 32-bit far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//
#define GET_OFFSET(pointer)             READ_WORD((LPWORD)(pointer))

//
// SET_SELECTOR - writes a word into the segment word of a real-mode far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//
#define SET_SELECTOR(pointer, word)     WRITE_WORD(((LPWORD)(pointer)+1), (word))

//
// SET_SEGMENT - same as SET_SELECTOR
//
#define SET_SEGMENT(pointer, word)      SET_SELECTOR(pointer, word)

//
// SET_OFFSET - writes a word into the offset word of a real-mode far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//
#define SET_OFFSET(pointer, word)       WRITE_WORD((LPWORD)(pointer), (word))

//
// POINTER_FROM_POINTER - read a segmented pointer in the VDM from an address
// pointed at by a flat 32-bit pointer. Convert the segmented pointer to a
// flat pointer. SAME AS READ_FAR_POINTER
//
#define POINTER_FROM_POINTER(pointer)   POINTER_FROM_WORDS(GET_SELECTOR(pointer), GET_OFFSET(pointer))

//
// LPSTR_FROM_POINTER - perform a POINTER_FROM_POINTER, casting the result to
// a string pointer. SAME AS READ_FAR_POINTER
//
#define LPSTR_FROM_POINTER(pointer)     ((LPSTR)POINTER_FROM_POINTER(pointer))

//
// LPBYTE_FROM_POINTER - perform a POINTER_FROM_POINTER, casting the result to
// a byte pointer. SAME AS READ_FAR_POINTER
//
#define LPBYTE_FROM_POINTER(pointer)    ((LPBYTE)POINTER_FROM_POINTER(pointer))

//
// SET_ERROR - sets the caller's AX register in the VDM context descriptor to
// the value given and sets the caller's VDM carry flag
//
#define SET_ERROR(err)                  {setAX(err); setCF(1);}

//
// SET_SUCCESS - sets the VDM caller's AX register to NERR_Success and clears
// the carry flag
//
#define SET_SUCCESS()                   {setAX(NERR_Success); setCF(0);}

//
// SET_OK - an explicit version of SET_SUCCESS wherein NERR_Success would be
// an inappropriate error, although the right value
//
#define SET_OK(value)                   {setAX(value); setCF(0);}



//
// Miscellaneous macros for working out sizes of things
//

//
// ARRAY_ELEMENTS - gives the number of elements of a particular type in an
// array
//

#define ARRAY_ELEMENTS(a)   (sizeof(a)/sizeof((a)[0]))

//
// LAST_ELEMENT - returns the index of the last element in array
//

#define LAST_ELEMENT(a)     (ARRAY_ELEMENTS(a)-1)

//
// BITSIN - returns the number of bits in a data type or structure. This is
// predicated upon the number of bits in a byte being 8 and all data types
// being composed of a collection of bytes (safe assumption?)
//
#define BITSIN(thing)                   (sizeof(thing) * BITS_IN_A_BYTE)

//
// Miscellaneous other macros
//

//
// IS_ASCII_PATH_SEPARATOR - returns TRUE if ch is / or \. ch is a single
// byte (ASCII) character
//
#define IS_ASCII_PATH_SEPARATOR(ch)     (((ch) == '/') || ((ch) == '\\'))

//
// macros for setting CF and ZF flags for return from hardware interrupt
// callback
//

#define SET_CALLBACK_NOTHING()  {setZF(0); setCF(0);}
#define SET_CALLBACK_NAMEPIPE() {setZF(0); setCF(1);}
#define SET_CALLBACK_DLC()      {setZF(1); setCF(0);}
#define SET_CALLBACK_NETBIOS()  {setZF(1); setCF(1);}

//
// DLC-specific macros etc.
//

extern LPVDM_REDIR_DOS_WINDOW   lpVdmWindow;

//
// setPostRoutine - if dw is not 0 then we write the (DOS segmented) address of
// the post routine into the dwPostRoutine field of the VDM_REDIR_DOS_WINDOW
// structure passed to us at redir DLC initialization. We also set the flags
// to indicate to the redir's hardware interrupt routine there is a DLC post
// routine to run. If dw is 0 then we set the flags to indicate that there is
// no post routine processing
//
#define setPostRoutine( dw )    if (dw) {\
                                    (lpVdmWindow->dwPostRoutine = (DWORD)(dw));\
                                    SET_CALLBACK_DLC();\
                                } else {\
                                    SET_CALLBACK_NOTHING();\
                                }

//
// VR_ASYNC_DISPOSITION - we maintain a serialized list of these structures.
// Used to dispose of VDM redir asynchronous completions in the order in which
// they occurred
//

typedef struct _VR_ASYNC_DISPOSITION {

    //
    // Next - maintains a singly-linked list of dispositions
    //

    struct _VR_ASYNC_DISPOSITION* Next;

    //
    // AsyncDispositionRoutine - pointer to VOID function taking no args which
    // will dispose of the next asynchronous completion - Netbios, named pipe
    // or DLC
    //

    VOID (*AsyncDispositionRoutine)(VOID);
} VR_ASYNC_DISPOSITION, *PVR_ASYNC_DISPOSITION;

//
// _inlinePointerFromWords - the POINTER_FROM_WORDS macro is inefficient if the
// arguments are calls to eg. getES(), getBX() - the calls are made twice if
// the pointer turns out to be non-zero. Use an inline function to achieve the
// same results, but only call function arguments once
//

#ifdef i386

__inline LPVOID _inlinePointerFromWords(WORD seg, WORD off) {

    WORD _seg = seg;
    WORD _off = off;

    return (_seg + _off) ? (LPVOID)GetVDMAddr(_seg, _off) : 0;
}

#else
LPVOID _inlinePointerFromWords(WORD seg, WORD off);
#endif

//
// CONVERT_ADDRESS - convert a segmented (real or protect-mode) address to a
// flat 32-bit address
//

//#define CONVERT_ADDRESS(seg, off, size, mode) !((WORD)(seg) | (WORD)(off)) ? 0 : Sim32GetVDMPointer((((DWORD)seg) << 16) + (DWORD)(off), (size), (mode))
#define CONVERT_ADDRESS(seg, off, size, mode) _inlineConvertAddress((WORD)(seg), (WORD)(off), (WORD)(size), (BOOLEAN)(mode))

#ifdef i386

__inline LPVOID _inlineConvertAddress(WORD Seg, WORD Off, WORD Size, BOOLEAN Pm) {

    WORD _seg = Seg;
    WORD _off = Off;

    return (_seg | _off) ? Sim32GetVDMPointer(((DWORD)_seg << 16) + _off, Size, Pm) : 0;
}

#else
extern LPVOID _inlineConvertAddress(WORD Seg, WORD Off, WORD Size, BOOLEAN Pm);
#endif

#endif  // _VDMREDIR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\vrdefld.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrdefld.h

Abstract:

    Contains offsets in VDM redir code segment for deferred load address info

Author:

    Richard L Firth (rfirth) 21-Oct-1992

Revision History:

--*/

/* XLATOFF */
#include <packon.h>
/* XLATON */

typedef struct _VDM_LOAD_INFO { /* */
    DWORD   DlcWindowAddr;
    BYTE    VrInitialized;
} VDM_LOAD_INFO;

/* XLATOFF */
#include <packoff.h>
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\vrinit.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrinit.h

Abstract:

    Contains function prototypes for Vdm Redir init routines

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Revision History:

    13-Sep-1991 rfirth
        Created

--*/

BOOLEAN
VrInitialized(
    VOID
    );

BOOLEAN
VrInitialize(
    VOID
    );

VOID
VrUninitialize(
    VOID
    );

VOID
VrRaiseInterrupt(
    VOID
    );

VOID
VrDismissInterrupt(
    VOID
    );

VOID
VrQueueCompletionHandler(
    IN VOID (*AsyncDispositionRoutine)(VOID)
    );

VOID
VrHandleAsyncCompletion(
    VOID
    );

VOID
VrCheckPmNetbiosAnr(
    VOID
    );

VOID
VrEoiAndDismissInterrupt(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\vrmisc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrmisc.h

Abstract:

    Contains function prototypes for Vdm Redir miscellaneous routines

Author:

    Richard L Firth (rfirth) 01-Oct-1991

Revision History:

    01-Oct-1991 rfirth
        Created

--*/



VOID
VrTerminateDosProcess(
    VOID
    );

VOID
VrUnsupportedFunction(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\vrdlctab.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrdlctab.h

Abstract:

    Contains structures which are shared between the VDM code and the DOS
    redir code. Separated from VDMREDIR.H

Author:

    Richard L Firth (rfirth) 13-May-1992

Revision History:

--*/

//
// manifests
//

#define DOS_DLC_STATUS_PERM_SLOTS   10
#define DOS_DLC_STATUS_TEMP_SLOTS   5
#define DOS_DLC_MAX_ADAPTERS        2

//
// EXTENDED_STATUS_PARMS - there is one of these per adapter
//

/* XLATOFF */
#pragma pack(1)
/* XLATON */

typedef struct _EXTENDED_STATUS_PARMS { /* */
    BYTE    cbSize;
    BYTE    cbPageFrameSize;
    WORD    wAdapterType;
    WORD    wCurrentFrameSize;
    WORD    wMaxFrameSize;
} EXTENDED_STATUS_PARMS;

typedef EXTENDED_STATUS_PARMS UNALIGNED * PEXTENDED_STATUS_PARMS;

//
// DOS_DLC_STATUS - there is one of these for each of the permanent and temporary
// connections
//

typedef struct _DOS_DLC_STATUS { /* */
    WORD    usStationId;
    WORD    usDlcStatusCode;
    BYTE    uchFrmrData[5];
    BYTE    uchAccessPriority;
    BYTE    uchRemoteNodeAddress[6];
    BYTE    uchRemoteSap;
    BYTE    auchReserved[3];
} DOS_DLC_STATUS;

typedef DOS_DLC_STATUS UNALIGNED * PDOS_DLC_STATUS;

//
// ADAPTER_STATUS_PARMS - In real DOS workstation, this is maintained by the
// adapter software, but is made available to applications through DIR.STATUS.
// Token Ring and Ethernet adapter have different adapter status parameters
//
// Note: some fields prefixed by Tr or Eth because the x86 assembler
// can't handle the same field name in different structures
//

typedef struct _TOKEN_RING_ADAPTER_STATUS_PARMS { /* */
    DWORD   PhysicalAddress;
    BYTE    UpstreamNodeAddress[6];
    DWORD   UpstreamPhysicalAddress;
    BYTE    LastPollAddress[6];
    WORD    AuthorizedEnvironment;
    WORD    TransmitAccessPriority;
    WORD    SourceClassAuthorization;
    WORD    LastAttentionCode;
    BYTE    TrLastSourceAddress[6];
    WORD    LastBeaconType;
    WORD    TrLastMajorVector;
    WORD    TrNetworkStatus;
    WORD    SoftError;
    WORD    FrontEndErrorCount;
    WORD    LocalRingNumber;
    WORD    MonitorErrorCode;
    WORD    BeaconTransmitType;
    WORD    BeaconReceiveType;
    WORD    TrFrameCorrelation;
    BYTE    BeaconingNaun[6];
    DWORD   Reserved;
    DWORD   BeaconingPhysicalAddress;
} TOKEN_RING_ADAPTER_STATUS_PARMS;

typedef TOKEN_RING_ADAPTER_STATUS_PARMS UNALIGNED * PTOKEN_RING_ADAPTER_STATUS_PARMS;

typedef struct _ETHERNET_ADAPTER_STATUS_PARMS { /* */
    BYTE    Reserved1[28];
    BYTE    EthLastSourceAddress[6];
    BYTE    Reserved2[2];
    WORD    EthLastMajorVector;
    WORD    EthNetworkStatus;
    WORD    ErrorReportTimerValue;
    WORD    ErrorReportTimerTickCounter;
    WORD    LocalBusNumber;
    BYTE    Reserved3[6];
    WORD    EthFrameCorrelation;
    BYTE    Reserved4[6];
    WORD    NetworkUtilizationSamples;
    WORD    NetworkBusySamples;
    BYTE    Reserved5[4];
} ETHERNET_ADAPTER_STATUS_PARMS;

typedef ETHERNET_ADAPTER_STATUS_PARMS UNALIGNED * PETHERNET_ADAPTER_STATUS_PARMS;

typedef union _ADAPTER_STATUS_PARMS { /* */
    TOKEN_RING_ADAPTER_STATUS_PARMS TokenRing;
    ETHERNET_ADAPTER_STATUS_PARMS Ethernet;
} ADAPTER_STATUS_PARMS;

typedef ADAPTER_STATUS_PARMS UNALIGNED * PADAPTER_STATUS_PARMS;

//
// VDM_REDIR_DOS_WINDOW - this structure is used by the MVDM DLC code to return
// information to the DOS DLC program via the redir. This is used mainly in
// asynchronous call-backs (aka ANRs, post-routines or DLC appendages). We let
// the redir code know if there is an ANR by setting dwPostRoutine
//

typedef struct _VDM_REDIR_DOS_WINDOW { /* */
    DWORD   dwPostRoutine;
    DWORD   dwDlcTimerTick;
    EXTENDED_STATUS_PARMS aExtendedStatus[DOS_DLC_MAX_ADAPTERS];
    ADAPTER_STATUS_PARMS AdapterStatusParms[DOS_DLC_MAX_ADAPTERS];
    DOS_DLC_STATUS aStatusTables[(DOS_DLC_STATUS_TEMP_SLOTS + DOS_DLC_STATUS_PERM_SLOTS)];
} VDM_REDIR_DOS_WINDOW;

typedef VDM_REDIR_DOS_WINDOW UNALIGNED * LPVDM_REDIR_DOS_WINDOW;

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\vrmslot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrmslot.h

Abstract:

    Prototypes, definitions and structures for VdmRedir mailslot handlers

Author:

    Richard L Firth (rfirth) 16-Sep-1991

Revision History:

    16-Sep-1991 rfirth
        Created

--*/



//
// VDM Mailslot support routines. Prototypes
//

VOID
VrDeleteMailslot(
    VOID
    );

VOID
VrGetMailslotInfo(
    VOID
    );

VOID
VrMakeMailslot(
    VOID
    );

VOID
VrPeekMailslot(
    VOID
    );

VOID
VrReadMailslot(
    VOID
    );

VOID
VrWriteMailslot(
    VOID
    );

VOID
VrTerminateMailslots(
    IN WORD DosPdb
    );



//
// typedefs
//

//
// SELECTOR - in the absence of a standard SELECTOR type, 16-bit selector,
// doubles as SEGMENT (as in ADDRESS16)
//

typedef unsigned short SELECTOR;

//
// ADDRESS16 - an Intel architecture-specific 16:16 address, consisting of a
// 16-bit offset in the low word and a 16-bit segment (real mode) or selector
// (protect mode) in the high word. Both elements are little-endian
// Again, this exists in absence of Intel-specific DWORD structure which has
// correct endian-ness and views address as composed of two parts
//

typedef struct {
    unsigned short  Offset;
    SELECTOR        Selector;
} ADDRESS16;



//
// structures
//

//
// VR_MAILSLOT_INFO - the Dos mailslot subsystem needs some info which we do
// not keep, so we put it in this structure. The structure is linked into a
// list of active mailslot structures for every successful CreateMailslot
// call. The extra info we need is:
//
//      DosPdb          - the PDB (or PSP) of the Dos application. Used for
//                        consistency checks and removing mailslots when the
//                        app dies
//      Handle16        - the handle returned to the Dos app. We have to invent
//                        this
//      BufferAddress   - the Dos app tells us where its buffer is then wants
//                        us to confirm the address in a DosMailslotInfo call
//      Selector        - the Dos app needs a protect mode selector when
//                        running under Windows 3.0 enhanced mode
//      MessageSize     - maximum message size which can be read. Not the same
//                        thing as mailslot size
//
// We also need some information for our own internal wrangling:
//
//      NameLength      - the length of the significant part of the mailslot
//                        name (after \MAILSLOT\). We compare this before
//                        doing a strcmp() on names
//      Name            - the significant part of the mailslot name. When a
//                        mailslot is opened, we store the name after \MAILSLOT\
//                        because DosMailslotWrite uses the symbolic name, even
//                        when writing locally; we need a handle, so we have
//                        to map the name to open mailslot handle.
//
// This structure is allocated from the heap and the Name field will actually
// be large enough to hold the entire string. I put Name[2] because the Mips
// compiler doesn't know about Name[] (Microsoft C compiler extension). 2 at
// least keeps things even. Maybe it should be 4. Maybe it doesn't matter
//

typedef struct _VR_MAILSLOT_INFO *PVR_MAILSLOT_INFO;
typedef struct _VR_MAILSLOT_INFO {
    PVR_MAILSLOT_INFO   Next;       // linked list
    WORD        DosPdb;             // for consistency etc
    WORD        Handle16;           // Dos handle
    HANDLE      Handle32;           // Win32 handle (proper)
    ADDRESS16   BufferAddress;      // Dos app's message buffer
    SELECTOR    Selector;           // Win 3's buffer selector
    DWORD       MessageSize;        // max. message size
    DWORD       NameLength;         // length of name following:
    CHAR        Name[2];            // of mailslot, (after \\.\MAILSLOT\)
} VR_MAILSLOT_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\vrnetapi.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrnetapi.h

Abstract:

    Contains prototypes and definitions for Vdm Redir lanman support routines

Author:

    Richard L Firth (rfirth) 21-Oct-1991

Revision History:

    21-Oct-1991 rfirth
        Created

--*/

//
// the top bit of the api number (word) is used by the dosnet library to
// indicate whether certain APIs should be remoted over a null session
// (according to the code in the dos redir)
//

#define USE_NULL_SESSION_FLAG   0x8000



//
// prototypes
//

VOID
VrNetRemoteApi(
    VOID
    );

VOID
VrNetTransactApi(
    VOID
    );

VOID
VrNetNullTransactApi(
    VOID
    );

VOID
VrNetServerEnum(
    VOID
    );

VOID
VrNetUseAdd(
    VOID
    );

VOID
VrNetUseDel(
    VOID
    );

VOID
VrNetUseEnum(
    VOID
    );

VOID
VrNetUseGetInfo(
    VOID
    );

VOID
VrNetWkstaGetInfo(
    VOID
    );

VOID
VrNetWkstaSetInfo(
    VOID
    );

VOID
VrNetMessageBufferSend(
    VOID
    );

VOID
VrGetCDNames(
    VOID
    );

VOID
VrGetComputerName(
    VOID
    );

VOID
VrGetUserName(
    VOID
    );

VOID
VrGetDomainName(
    VOID
    );

VOID
VrGetLogonServer(
    VOID
    );

VOID
VrNetGetDCName(
    VOID
    );

VOID
VrReturnAssignMode(
    VOID
    );

VOID
VrSetAssignMode(
    VOID
    );

VOID
VrGetAssignListEntry(
    VOID
    );

VOID
VrDefineMacro(
    VOID
    );

VOID
VrBreakMacro(
    VOID
    );

VOID VrNetServiceControl(
    VOID
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowclip.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWCLIP.H
 *
 *  History:
 *  09-22-92 Craig Jones (v-cjones)
 *  Created.
--*/

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct tagMETAFILEPICT16 {    /* mfp16wow32 */
    WORD    mm;
    WORD    xExt;
    WORD    yExt;
    HMEM16  hMF;
} METAFILEPICT16;
typedef METAFILEPICT16 UNALIGNED *LPMETAFILEPICT16;

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\vrremote.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrremote.h

Abstract:

    Prototypes for vrremote module

Author:

    Richard L Firth (rfirth) 28-Oct-1991

Revision History:

    29-Oct-1991 rfirth
        Created

--*/

NET_API_STATUS
VrTransaction(
    IN      LPSTR   ServerName,
    IN      LPBYTE  SendParmBuffer,
    IN      DWORD   SendParmBufLen,
    IN      LPBYTE  SendDataBuffer,
    IN      DWORD   SendDataBufLen,
    OUT     LPBYTE  ReceiveParmBuffer,
    IN      DWORD   ReceiveParmBufLen,
    IN      LPBYTE  ReceiveDataBuffer,
    IN OUT  LPDWORD ReceiveDataBufLen,
    IN      BOOL    NullSessionFlag
    );

NET_API_STATUS
VrRemoteApi(
    IN  DWORD   ApiNumber,
    IN  LPBYTE  ServerNamePointer,
    IN  LPSTR   ParameterDescriptor,
    IN  LPSTR   DataDescriptor,
    IN  LPSTR   AuxDescriptor OPTIONAL,
    IN  BOOL    NullSessionFlag
    );

//
// private routine prototypes
//

DWORD
VrpGetStructureSize(
    IN  LPSTR   Descriptor,
    IN  LPDWORD AuxOffset
    );

DWORD
VrpGetArrayLength(
    IN  LPSTR   type_ptr,
    IN  LPSTR*  type_ptr_addr
    );

DWORD
VrpGetFieldSize(
    IN  LPSTR   Descriptor,
    IN  LPSTR*  pDescriptor
    );

VOID
VrpConvertReceiveBuffer(
    IN  LPBYTE  ReceiveBuffer,
    IN  WORD    BufferSelector,
    IN  WORD    BufferOffset,
    IN  WORD    ConverterWord,
    IN  DWORD   NumberStructs,
    IN  LPSTR   DataDescriptor,
    IN  LPSTR   AuxDescriptor
    );

VOID
VrpConvertVdmPointer(
    IN  ULPWORD TargetPointer,
    IN  WORD    BufferSegment,
    IN  WORD    BufferOffset,
    IN  WORD    ConverterWord
    );

NET_API_STATUS
VrpPackSendBuffer(
    IN OUT  LPBYTE* SendBufferPtr,
    IN OUT  LPDWORD SendBufLenPtr,
    OUT     LPBOOL  BufferAllocFlagPtr,
    IN OUT  LPSTR   DataDescriptor,
    IN      LPSTR   AuxDescriptor,
    IN      DWORD   StructureSize,
    IN      DWORD   AuxOffset,
    IN      DWORD   AuxSize,
    IN      BOOL    SetInfoFlag,
    IN      BOOL    OkToModifyDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\vshimdb.h ===
/*++ BUILD Version: 0001
 *
 *  NTVDM v1.0
 *
 *  Copyright (c) 2002, Microsoft Corporation
 *
 *  vshim.h
 *  Shim definitions common to WOW and NTVDM
 *
 *  History:
 *  Created 01-30-2002 by cmjones
 *
--*/
#define  WOWCOMPATFLAGS        0 
#define  WOWCOMPATFLAGSEX      1
#define  USERWOWCOMPATFLAGS    2
#define  WOWCOMPATFLAGS2       3
#define  WOWCOMPATFLAGSFE      4
#define  MAX_INFO              32 // max # of command line params for flag info

typedef struct _FLAGINFOBITS {   
   struct _FLAGINFOBITS *pNextFlagInfoBits;
   DWORD dwFlag;
   DWORD dwFlagType;
   LPSTR pszCmdLine;
   DWORD dwFlagArgc;
   LPSTR *pFlagArgv;
} FLAGINFOBITS, *PFLAGINFOBITS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\vrnmpipe.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrnmpipe.h

Abstract:

    Prototypes, definitions and structures for VdmRedir named pipe handlers

Author:

    Richard L Firth (rfirth) 10-Sep-1991

Revision History:

    10-Sep-1991 RFirth
        Created

--*/

//
// manifests
//

#define MAXIMUM_ASYNC_PIPES 32

//
// async named pipe request types
//

#define ANP_READ    0x86
#define ANP_READ2   0x90
#define ANP_WRITE   0x8f
#define ANP_WRITE2  0x91

//
// VDM Named Pipe support routines. Prototypes
//

VOID
VrGetNamedPipeInfo(
    VOID
    );

VOID
VrGetNamedPipeHandleState(
    VOID
    );

VOID
VrSetNamedPipeHandleState(
    VOID
    );

VOID
VrPeekNamedPipe(
    VOID
    );

VOID
VrTransactNamedPipe(
    VOID
    );

VOID
VrCallNamedPipe(
    VOID
    );

VOID
VrWaitNamedPipe(
    VOID
    );

VOID
VrNetHandleGetInfo(
    VOID
    );

VOID
VrNetHandleSetInfo(
    VOID
    );

VOID
VrReadWriteAsyncNmPipe(
    VOID
    );

BOOLEAN
VrNmPipeInterrupt(
    VOID
    );

VOID
VrTerminateNamedPipes(
    IN WORD DosPdb
    );

//
// VDM open/close and read/write intercept routines
//

#ifdef VDMREDIR_DLL

BOOL
VrAddOpenNamedPipeInfo(
    IN  HANDLE  Handle,
    IN  LPSTR   lpFileName
    );

BOOL
VrRemoveOpenNamedPipeInfo(
    IN  HANDLE  Handle
    );

BOOL
VrReadNamedPipe(
    IN  HANDLE  Handle,
    IN  LPBYTE  Buffer,
    IN  DWORD   Buflen,
    OUT LPDWORD BytesRead,
    OUT LPDWORD Error
    );

BOOL
VrWriteNamedPipe(
    IN  HANDLE  Handle,
    IN  LPBYTE  Buffer,
    IN  DWORD   Buflen,
    OUT LPDWORD BytesWritten
    );

VOID
VrCancelPipeIo(
    IN DWORD Thread
    );

#else

BOOL
(*VrAddOpenNamedPipeInfo)(
    IN  HANDLE  Handle,
    IN  LPSTR   lpFileName
    );

BOOL
(*VrRemoveOpenNamedPipeInfo)(
    IN  HANDLE  Handle
    );

BOOL
(*VrReadNamedPipe)(
    IN  HANDLE  Handle,
    IN  LPBYTE  Buffer,
    IN  DWORD   Buflen,
    OUT LPDWORD BytesRead,
    OUT LPDWORD Error
    );

BOOL
(*VrWriteNamedPipe)(
    IN  HANDLE  Handle,
    IN  LPBYTE  Buffer,
    IN  DWORD   Buflen,
    OUT LPDWORD BytesWritten
    );

VOID
(*VrCancelPipeIo)(
    IN DWORD Thread
    );

#endif

//
// VDM pipe name to NT pipe name helper routines
//

#ifdef VDMREDIR_DLL

BOOL
VrIsNamedPipeName(
    IN  LPSTR   Name
    );

BOOL
VrIsNamedPipeHandle(
    IN  HANDLE  Handle
    );

LPSTR
VrConvertLocalNtPipeName(
    OUT LPSTR   Buffer OPTIONAL,
    IN  LPSTR   Name
    );

#else

BOOL
(*VrIsNamedPipeName)(
    IN  LPSTR   Name
    );

BOOL
(*VrIsNamedPipeHandle)(
    IN  HANDLE  Handle
    );

LPSTR
(*VrConvertLocalNtPipeName)(
    OUT LPSTR   Buffer OPTIONAL,
    IN  LPSTR   Name
    );

#endif

//
// structures
//

//typedef struct {
//    PDOSNMPINFO Next;           // pointer to next info structure in list
//    WORD    DosPdb;
//    WORD    Handle16;
//    HANDLE  Handle32;           // handle returned from CreateFile call
//    DWORD   NameLength;         // length of ASCIZ pipe name
//    LPSTR   Name;               // ASCIZ pipe name
//    DWORD   Instances;          // current instances
//} DOSNMPINFO, *PDOSNMPINFO;

//
// OPEN_NAMED_PIPE_INFO - this structure contains information recorded when a
// named pipe is opened on behalf of the VDM. DosQNmPipeInfo wants the name
// of the pipe
//

typedef struct _OPEN_NAMED_PIPE_INFO* POPEN_NAMED_PIPE_INFO;
typedef struct _OPEN_NAMED_PIPE_INFO {
    POPEN_NAMED_PIPE_INFO Next; // linked list
    HANDLE  Handle;             // open named pipe handle
    DWORD   NameLength;         // including terminating 0
    WORD    DosPdb;             // the process which owns this named pipe
    CHAR    Name[2];            // full pipe name
} OPEN_NAMED_PIPE_INFO;

//
// DOS_ASYNC_NAMED_PIPE_INFO - in this structure we keep all the information
// required to complete an asynchronous named pipe operation
//

typedef struct _DOS_ASYNC_NAMED_PIPE_INFO {
    struct _DOS_ASYNC_NAMED_PIPE_INFO* Next;  // linked list
    OVERLAPPED Overlapped;      // contains 32-bit event handle
    BOOL    Type2;              // TRUE if request is Read2 or Write2
    BOOL    Completed;          // TRUE if this request has completed
    HANDLE  Handle;             // 32-bit named pipe handle
    DWORD   Buffer;             // 16:16 address of buffer
    DWORD   BytesTransferred;   // actual number of bytes read/written
    LPWORD  pBytesTransferred;  // flat-32 pointer to returned read/write count in VDM
    LPWORD  pErrorCode;         // flat-32 pointer to returned error code in VDM
    DWORD   ANR;                // 16:16 address of ANR
    DWORD   Semaphore;          // 16:16 address of 'semaphore' in VDM
#if DBG
    DWORD   RequestType;
#endif
} DOS_ASYNC_NAMED_PIPE_INFO, *PDOS_ASYNC_NAMED_PIPE_INFO;

//
// DOS_CALL_NAMED_PIPE_STRUCT - this structure is created and handed to the DOS
// CallNmPipe routine because there is too much information to get into a 286's
// registers. This structure should be in apistruc.h, but it aint
//

//#include <packon.h>
#pragma pack(1)
typedef struct {
    DWORD   Timeout;            // Time to wait for pipe to become available
    LPWORD  lpBytesRead;        // pointer to returned bytes read
    WORD    nOutBufferLen;      // size of send data
    LPBYTE  lpOutBuffer;        // pointer to send data
    WORD    nInBufferLen;       // size of receive buffer
    LPBYTE  lpInBuffer;         // pointer to receive buffer
    LPSTR   lpPipeName;         // pointer to pipe name
} DOS_CALL_NAMED_PIPE_STRUCT, *PDOS_CALL_NAMED_PIPE_STRUCT;
//#include <packoff.h>
#pragma pack()

//
// DOS_ASYNC_NAMED_PIPE_STRUCT - as with the above, this structure is used
// to pass all the info to DosReadAsyncNmPipe which won't fit into registers.
// Used for read and write operations. Should be defined in apistruc.h
//

//#include <packon.h>
#pragma pack(1)
typedef struct {
    LPWORD  lpBytesRead;        // pointer to returned bytes read/written
    WORD    BufferLength;       // size of caller's buffer
    LPBYTE  lpBuffer;           // pointer to caller's buffer
    LPWORD  lpErrorCode;        // pointer to returned error code
    LPVOID  lpANR;              // pointer to Asynchronous Notification Routine
    WORD    PipeHandle;         // named pipe handle
    LPBYTE  lpSemaphore;        // pointer to caller's 'semaphore'
} DOS_ASYNC_NAMED_PIPE_STRUCT, *PDOS_ASYNC_NAMED_PIPE_STRUCT;
//#include <packoff.h>
#pragma pack()

//
// The following selectively copied from BSEDOS.H and other Lanman include
// files
//

/*** Data structures and equates used with named pipes ***/

//#include <packon.h>
#pragma pack(1)
typedef struct _PIPEINFO { /* nmpinf */
    USHORT cbOut;
    USHORT cbIn;
    BYTE   cbMaxInst;
    BYTE   cbCurInst;
    BYTE   cbName;
    CHAR   szName[1];
} PIPEINFO;
//#include <packoff.h>
#pragma pack()
typedef PIPEINFO FAR *PPIPEINFO;

/* defined bits in pipe mode */
#define NP_NBLK         0x8000 /* non-blocking read/write */
#define NP_SERVER       0x4000 /* set if server end   */
#define NP_WMESG        0x0400 /* write messages      */
#define NP_RMESG        0x0100 /* read as messages    */
#define NP_ICOUNT       0x00FF /* instance count field    */


/*  Named pipes may be in one of several states depending on the actions
 *  that have been taken on it by the server end and client end.  The
 *  following state/action table summarizes the valid state transitions:
 *
 *  Current state       Action          Next state
 *
 *   <none>         server DosMakeNmPipe    DISCONNECTED
 *   DISCONNECTED       server connect      LISTENING
 *   LISTENING      client open         CONNECTED
 *   CONNECTED      server disconn      DISCONNECTED
 *   CONNECTED      client close        CLOSING
 *   CLOSING        server disconn      DISCONNECTED
 *   CONNECTED      server close        CLOSING
 *   <any other>        server close        <pipe deallocated>
 *
 *  If a server disconnects his end of the pipe, the client end will enter a
 *  special state in which any future operations (except close) on the file
 *  descriptor associated with the pipe will return an error.
 */

/*
 *  Values for named pipe state
 */

#define NP_DISCONNECTED     1 /* after pipe creation or Disconnect */
#define NP_LISTENING        2 /* after DosNmPipeConnect        */
#define NP_CONNECTED        3 /* after Client open             */
#define NP_CLOSING      4 /* after Client or Server close      */

/* DosMakeNmPipe open modes */

#define NP_ACCESS_INBOUND   0x0000
#define NP_ACCESS_OUTBOUND  0x0001
#define NP_ACCESS_DUPLEX    0x0002
#define NP_INHERIT      0x0000
#define NP_NOINHERIT        0x0080
#define NP_WRITEBEHIND      0x0000
#define NP_NOWRITEBEHIND    0x4000

/* DosMakeNmPipe and DosQNmPHandState state */

#define NP_READMODE_BYTE    0x0000
#define NP_READMODE_MESSAGE 0x0100
#define NP_TYPE_BYTE        0x0000
#define NP_TYPE_MESSAGE     0x0400
#define NP_END_CLIENT       0x0000
#define NP_END_SERVER       0x4000
#define NP_WAIT         0x0000
#define NP_NOWAIT       0x8000
#define NP_UNLIMITED_INSTANCES  0x00FF

typedef struct _AVAILDATA   {   /* PeekNMPipe Bytes Available record */
    USHORT  cbpipe;     /* bytes left in the pipe        */
    USHORT  cbmessage;  /* bytes left in current message     */
} AVAILDATA;
typedef AVAILDATA FAR *PAVAILDATA;

//
// handle info level 1 - this is different to the structure in lmchdev.h
//

//#include <packon.h>
#pragma pack(1)
typedef struct _VDM_HANDLE_INFO_1 {
    ULONG   CharTime;
    USHORT  CharCount;
} VDM_HANDLE_INFO_1, *LPVDM_HANDLE_INFO_1;
#pragma pack()
//#include <packoff.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowcmpat.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWCMPAT.H
 *  WOW compatibility flags
 *
 *  History:
 *  11-June-1993 Neil Sandlin (neilsa)
 *  Created.
--*/

////////// NOTE ////////// NOTE ////////// NOTE ////////// NOTE ////////// NOTE
//
// N   N       t
// NN  N  oo  ttt  ee
// N N N o  o  t  eeee  o
// N  NN o  o  t  e        Make sure you update both the string table entry and
// N   N  oo   tt  eee  o  the #define constant if you modify this file!!!
//
////////// NOTE ////////// NOTE ////////// NOTE ////////// NOTE ////////// NOTE


// These string tables only get included by mvdm\vdmexts\wow.c
// See NOTE above about adding anything to these tables!!!!
#ifdef _VDMEXTS_CFLAGS   // this is defined in mvdm\vdmexts\wow.c


// Original WOW compatibility flags.
// Kept in CURRENTPTD->dwWOWCompatFlags.

#ifdef _VDMEXTS_CF
{"WOWCF_GRAINYTICS",             0x80000000},
{"WOWCF_FAKEJOURNALRECORDHOOK",  0x40000000},
{"WOWCF_EDITCTRLWNDWORDS",       0x20000000},
{"WOWCF_SYNCHRONOUSDOSAPP",      0x10000000},

{"WOWCF_NOTDOSSPAWNABLE",        0x08000000},
{"WOWCF_RESETPAPER29ANDABOVE",   0x04000000},
{"WOWCF_4PLANECONVERSION",       0x02000000},
{"WOWCF_MGX_ESCAPES",            0x01000000},

{"WOWCF_CREATEBOGUSHWND",        0x00800000},
{"WOWCF_SANITIZEDOTWRSFILES",    0x00400000},
{"WOWCF_SIMPLEREGION",           0x00200000},
{"WOWCF_NOWAITFORINPUTIDLE",     0x00100000},

{"WOWCF_DSBASEDSTRINGPOINTERS",  0x00080000},
{"WOWCF_LIMIT_MEM_FREE_SPACE",   0x00040000},
{"WOWCF_DONTRELEASECACHEDDC",    0x00020000},
{"WOWCF_FORCETWIPSESCAPE",       0x00010000},

{"WOWCF_LB_NONNULLLPARAM",       0x00008000},
{"WOWCF_FORCENOPOSTSCRIPT",      0x00004000},
{"WOWCF_SETNULLMESSAGE",         0x00002000},
{"WOWCF_GWLINDEX2TO4",           0x00001000},

{"WOWCF_NEEDSTARTPAGE",          0x00000800},
{"WOWCF_NEEDIGNORESTARTPAGE",    0x00000400},
{"WOWCF_NOPC_RECTANGLE",         0x00000200},
{"WOWCF_NOFIRSTSAVE",            0x00000100},

{"WOWCF_ADD_MSTT",               0x00000080},
{"WOWCF_UNLOADNETFONTS",         0x00000040},
{"WOWCF_GETDUMMYDC",             0x00000020},
{"WOWCF_DBASEHANDLEBUG",         0x00000010},

{"WOWCF_NOCBDIRTHUNK",           0x00000008},
{"WOWCF_WMMDIACTIVATEBUG",       0x00000004},
{"WOWCF_UNIQUEHDCHWND",          0x00000002},
{"WOWCF_GWLCLRTOPMOST",          0x00000001},
#endif _VDMEXTS_CF




// Extra WOW compatibility flags bit definitions (WOWCFEX_).
// Kept in CURRENTPTD->dwWOWCompatFlagsEx.
#ifdef _VDMEXTS_CFEX
{"WOWCFEX_SENDPOSTEDMSG",        0x80000000},
{"WOWCFEX_BOGUSPOINTER",         0x40000000},
{"WOWCFEX_GETVERSIONHACK",       0x20000000},
{"WOWCFEX_FIXDCFONT4MENUSIZE",   0x10000000},

{"WOWCFEX_RESTOREEXPLORER",      0x08000000},
{"WOWCFEX_LONGWINEXECTAIL",      0x04000000},
{"WOWCFEX_FORCEINCDPMI",         0x02000000},
{"WOWCFEX_SETCAPSTACK",          0x01000000},

{"WOWCFEX_NODIBSHERE",           0x00800000},
{"WOWCFEX_PIXELMETRICS",         0x00400000},
{"WOWCFEX_DEFWNDPROCNCCALCSIZE", 0x00200000},
{"WOWCFEX_DIBDRVIMAGESIZEZERO",  0x00100000},

{"WOWCFEX_GLOBALDELETEATOM",     0x00080000},
{"WOWCFEX_IGNORECLIENTSHUTDOWN", 0x00040000},
{"WOWCFEX_DIVIDEOVERFLOWPATCH",  0x00020000},
{"WOWCFEX_FAKECLASSINFOFAIL",    0x00010000},

{"WOWCFEX_SAMETASKFILESHARE",    0x00008000},
{"WOWCFEX_SAYITSNOTTHERE",       0x00004000},
{"WOWCFEX_BROKENFLATPOINTER",    0x00002000},
{"WOWCFEX_USEMCIAVI16",          0x00001000},

{"WOWCFEX_SAYNO2DRAWPATTERNRECT",0x00000800},
{"WOWCFEX_FAKENOTAWINDOW",       0x00000400},
{"WOWCFEX_NODIRECTHDPOPUP",      0x00000200},
{"WOWCFEX_ALLOWLFNDIALOGS",      0x00000100},

{"WOWCFEX_THUNKLBSELITEMRANGEEX",0x00000080},
{"WOWCFEX_LIMITFINDFIRSTLEN",    0x00000040},
{"WOWCFEX_USEWINHELP32",         0x00000020},
{"WOWCFEX_PLATFORMVERSIONLIE",   0x00000010},

{"WOWCFEX_WIN31VERSIONLIE",      0x00000008},
{"WOWCFEX_EATDEVMODEMSG",        0x00000004},
{"WOWCFEX_DISPMODE256",          0x00000002},
{"WOWCFEX_FORMFEEDHACK",         0x00000001},
#endif _VDMEXTS_CFEX

// Extra WOW User compatibility flags bit definitions (WOWCF_USER).
// Kept in CURRENTPTD->dwUserWOWCompatFlags.
#ifdef _VDMEXTS_USER
{"WOWCF_USER_DDENOSYNC",         0x00040000},
#endif

// Extra WOW2 compatibility flags bit definitions (WOWCF2_).
// Kept in CURRENTPTD->dwUserWOWCompatFlags2.
#ifdef _VDMEXTS_CF2
{"WOWCF2_HACKWINFLAGS",          0x80000000},
{"WOWCF2_SETFOREGROUND",         0x40000000},
{"WOWCF2_SYNCSYSFILE",           0x20000000},
{"WOWCF2_RESETCURDIR",           0x10000000},

{"WOWCF2_DELAYTIMEGETTIME",      0x08000000},
{"WOWCF2_FIXLUNATRAYRECT",       0x04000000},
{"WOWCF2_USEMINIMALENVIRONMENT", 0x02000000},
{"WOWCF2_DPM_PATCHES",           0x01000000},
{"WOWCF2_HACKPROFILECALL",       0x00800000}
#endif



// Win3.1/Win95/User32 compatibility bits (GACF_).
// Kept in CURRENTPTD->dwCompatFlags.
#ifdef _VDMEXTS_CF31
{"GACF_IGNORENODISCARD",        0x00000001},
{"GACF_FORCETEXTBAND",          0x00000002},
{"GACF_USEPRINTINGESCAPES"
 " aka GACF_ONELANDGRXBAND",    0x00000004},      // re-use GACF_ONELANDGRXBAND
{"GACF_IGNORETOPMOST",          0x00000008},
{"GACF_CALLTTDEVICE",           0x00000010},
{"GACF_MULTIPLEBANDS",          0x00000020},
{"GACF_ALWAYSSENDNCPAINT",      0x00000040},
{"GACF_EDITSETTEXTMUNGE",       0x00000080},
{"GACF_MOREEXTRAWNDWORDS",      0x00000100},
{"GACF_TTIGNORERASTERDUPE",     0x00000200},
{"GACF_HACKWINFLAGS",           0x00000400},
{"GACF_DELAYHWHNDSHAKECHK",     0x00000800},
{"GACF_ENUMHELVNTMSRMN",        0x00001000},
{"GACF_ENUMTTNOTDEVICE",        0x00002000},
{"GACF_SUBTRACTCLIPSIBS",       0x00004000},
{"GACF_FORCERASTERMODE"
    " aka GACF_FORCETTGRAPHICS",0x00008000},      // re-use GACF_FORCETTGRAPHICS
{"GACF_NOHRGN1",                0x00010000},
{"GACF_NCCALCSIZEONMOVE",       0x00020000},
{"GACF_SENDMENUDBLCLK",         0x00040000},
{"GACF_30AVGWIDTH",             0x00080000},
{"GACF_GETDEVCAPSNUMLIE",       0x00100000},

{"GACF_WINVER31",               0x00200000},      //
{"GACF_INCREASESTACK"
 " aka GACF_HEAPSLACK",         0x00400000},      //
{"GACF_FORCEWIN31DEVMODESIZE"
 " aka GACF_PEEKMESSAGEIDLE",   0x00800000},      // (replaces PEEKMESSAGEIDLE)
{"GACF_DISABLEFONTASSOC"
 " aka GACF_JAPANESCAPEMENT",   0x01000000},      // Used in FE only aka GACF_JAPANESCAPEMENT
{"GACF_IGNOREFAULTS",           0x02000000},      //
{"GACF_NOEMFSPOOLING",          0x04000000},      //
{"GACF_RANDOM3XUI",             0x08000000},      //
{"GACF_DONTJOURNALATTACH",      0x10000000},      //
{"GACF_NOBRUSHCACHE"
 " aka GACF_DISABLEDBCSPROPTT", 0x20000000},      // re-use GACF_DISABLEDBCSPROPTT
#endif _VDMEXTS_CF31




#ifdef FE_SB

// Extra WOW compatibility flags for DBCS.
// Kept in CURRENTPTD->dwWOWCompatFlagsFE.
#ifdef _VDMEXTS_CF_IME
{"WOWCF_FE_AMIPRO_PM4J_IME",         0x00000001},
{"WOWCF_FE_FORCEREGQRYLEN",          0x00000002},
{"WOWCF_FE_AUDITNOTEPAD",            0x00000004},
{"WOWCF_FE_USEUPPER",                0x00000008},

{"WOWCF_FE_ASWHELPER",               0x00000010},
{"WOWCF_FE_PPT4J_IME_GETVERSION",    0x00000020},
{"WOWCF_FE_WORDJ_IME_GETVERSION",    0x00000040},
{"WOWCF_FE_FLW2_PRINTING_PS",        0x00000080},

{"WOWCF_FE_ARIRANG20_PRNDLG",        0x00000100},
{"WOWCF_FE_BCW45J_COMMDLG",          0x00000200},
{"WOWCF_FE_DIRECTOR_START",          0x00000400},
{"WOWCF_FE_QPW_FIXINVALIDWINHANDLE", 0x00000800},

{"WOWCF_FE_ICHITARO_ITALIC",         0x00001000},
#endif _VDMEXTS_CF_IME

#endif  // FE_SB


#else  // ! _VDMEXTS_CFLAGS
       // -- end the string tables included by mvdm\vdmexts\wow.c



//
// This part gets included by everything else
//


// Original WOW compatibility flags
// Kept in CURRENTPTD->dwWOWCompatFlags.
#define WOWCF_GRAINYTICS              0x80000000   // For apps that don't trust small GetTickCount deltas
#define WOWCF_FAKEJOURNALRECORDHOOK   0x40000000   // Used for MS Mail's MAILSPL
#define WOWCF_EDITCTRLWNDWORDS        0x20000000   // Used for Clip-Art Window Shopper SHOPPER
#define WOWCF_SYNCHRONOUSDOSAPP       0x10000000   // Used for BeyondMail installation
#define WOWCF_NOTDOSSPAWNABLE         0x08000000   // For apps that can't be spawned by dos as wowapps
#define WOWCF_RESETPAPER29ANDABOVE    0x04000000   // Used for WordPerfect DC_PAPERS
#define WOWCF_4PLANECONVERSION        0x02000000   // Used for PhotoShop 4pl-1bpp to 1pl-4bpp
#define WOWCF_MGX_ESCAPES             0x01000000   // Used for MicroGraphax Escapes
#define WOWCF_CREATEBOGUSHWND         0x00800000   // Explorapedia People has problems with handle recycling -- see bug #189004
#define WOWCF_SANITIZEDOTWRSFILES     0x00400000   // For WordPerfect printing on CONNECTED printers
#define WOWCF_SIMPLEREGION            0x00200000   // used to force simple region from GetClipBox
#define WOWCF_NOWAITFORINPUTIDLE      0x00100000   // InstallShield setup toolkit 3.00.077?.0 - 3.00.099.0 deadlock without this
#define WOWCF_DSBASEDSTRINGPOINTERS   0x00080000   // used for winworks2.0a so that it gets DS based string pointers
#define WOWCF_LIMIT_MEM_FREE_SPACE    0x00040000   // For apps that can't handle huge values returned by GetFreeSpace() (Automap Streets)
#define WOWCF_DONTRELEASECACHEDDC     0x00020000   // improv chart tool uses a released dc to get text extents, the dc is still usable on win3.1

// note: this is no longer set in the registry for PM5APP but users of older
//       versions of PM5 may need to set it manually - a-craigj
#define WOWCF_FORCETWIPSESCAPE        0x00010000   // PM5, force twips in Escape() of DOWNLOADFACE, GETFACENAME
#define WOWCF_LB_NONNULLLPARAM        0x00008000   // SuperProject: sets lParam of LB_GETTEXLEN message
#define WOWCF_FORCENOPOSTSCRIPT       0x00004000   // GetTechnology wont say PostScript.
#define WOWCF_SETNULLMESSAGE          0x00002000   // Winproj Tutorial: sets lpmsg->message = 0 in peekmessage
#define WOWCF_GWLINDEX2TO4            0x00001000   // PowerBuild30 uses index 2 on [S/G]etWindowLong for LISTBOXs, change it to 4 for NT. This is because, it is 16 bits on Win 31. and 32 bits on NT.
#define WOWCF_NEEDSTARTPAGE           0x00000800   // PhotoShop needs it
#define WOWCF_NEEDIGNORESTARTPAGE     0x00000400   // XPress needs it
#define WOWCF_NOPC_RECTANGLE          0x00000200   // QP draws bad if GetDeviceCaps(POLYGONALCAPS) sets PC_RECTANGLE
#define WOWCF_NOFIRSTSAVE             0x00000100   // Wordperfect needs it for meta files
#define WOWCF_ADD_MSTT                0x00000080   // FH4.0 needs to print on PS drivers
#define WOWCF_UNLOADNETFONTS          0x00000040   // Need to track an unload font loaded over net
#define WOWCF_GETDUMMYDC              0x00000020   // Corel Draw passes a NULL hDC to EnumMetaFile, we'll create a dummy to keep GDI32 happy.
#define WOWCF_DBASEHANDLEBUG          0x00000010   // Borland dBase handle bug
#define WOWCF_NOCBDIRTHUNK            0x00000008   // don't thunk CB_DIR lParam when sent to a subclassed window in PagePlus 3.0
#define WOWCF_WMMDIACTIVATEBUG        0x00000004   // Corel Chart doesn't pass correct params for WM_MDIACTIVATE (see ThunkWMMsg16())
#define WOWCF_UNIQUEHDCHWND           0x00000002   // For apps that assume that an hDC != hWnd
#define WOWCF_GWLCLRTOPMOST           0x00000001   // Lotus Approach needs the WS_EX_TOPMOST bit cleared on GWL of NETDDE AGENT window



// Extra WOW compatibility flags bit definitions (WOWCFEX_).  These flags
// are kept in CURRENTPTD->dwWOWCompatFlagsEx.
//
#define WOWCFEX_SENDPOSTEDMSG         0x80000000   // Lotus MM Reader.exe has message synchronization problem -- used to convert PostMessage() calls to SendMessage()
#define WOWCFEX_BOGUSPOINTER          0x40000000   // QuarkExpress v3.31 passes a hard coded 7FFF:0000 as the pointer to a RECT struct in an EM_GETRECT message
#define WOWCFEX_GETVERSIONHACK        0x20000000   // Set for programs we *may* wish to return 3.95 from GetVersion for.  WK32WowShouldWeSayWin95 restricts this further.
#define WOWCFEX_FIXDCFONT4MENUSIZE    0x10000000   // WP tutorial assumes that the font used to draw the menus is the same as the font selected into the hDc for the desktop window (hwnd == 0). This hack forces the use of the correct hDC.
#define WOWCFEX_RESTOREEXPLORER       0x08000000   // Symantec Q&A Install "restores" shell= by restoring saved copy of system.ini, fix it to explorer.exe
#define WOWCFEX_LONGWINEXECTAIL       0x04000000   // Intergraph Transcend setup uses too-long command tail with WinExec, don't fail if this flag is set.
#define WOWCFEX_FORCEINCDPMI          0x02000000   // Power Builder 4.0 needs to see DPMI alloc's with ever increasing linear address's. This is needed by Peachtree's WBT32 engine as well
#define WOWCFEX_SETCAPSTACK           0x01000000   // MS Works has unintialized variable. Hack stack to work around it.
#define WOWCFEX_NODIBSHERE            0x00800000   // PhotoShop 2.5 has bug getting DIB's from clipboard
#define WOWCFEX_PIXELMETRICS          0x00400000   // Freelance Tutorial, BorderWidth: winini metrics should be returned as pixels, not TWIPS
#define WOWCFEX_DEFWNDPROCNCCALCSIZE  0x00200000   // Pass WM_NCCALCSIZE to DefWindowProc for Mavis Beacon so USER 32 will set corect window flags.
#define WOWCFEX_DIBDRVIMAGESIZEZERO   0x00100000   // Return memory DC for dib.drv biSizeImage == 0  - Director 4.01
#define WOWCFEX_GLOBALDELETEATOM      0x00080000   // For Envoy viewer that ships with Word perfect office
#define WOWCFEX_IGNORECLIENTSHUTDOWN  0x00040000   // TurboCAD picks up saved 32-bit FS (x3b) and passes it as msg to DefFrameProc
#define WOWCFEX_DIVIDEOVERFLOWPATCH   0x00020000   // Handle divide overflows for certain apps
#define WOWCFEX_FAKECLASSINFOFAIL     0x00010000   // A bug in PageMaker 50a depends on the GetClassInfo failing in Win3.1 where it succeeds on NT
#define WOWCFEX_SAMETASKFILESHARE     0x00008000   // Broderbund Living Books install opens "install.txt" DENY ALL, and then tries to open it again
#define WOWCFEX_SAYITSNOTTHERE        0x00004000   // CrossTalk 2.2 hangs if it finds Printer/Device entry in xtalk.ini
#define WOWCFEX_BROKENFLATPOINTER     0x00002000   // Adobe Premiere 4.0 has a bug in its aliasing code which can touch unallocated memory
#define WOWCFEX_USEMCIAVI16           0x00001000   // Use 16-bit mciavi.drv for max compatibility
#define WOWCFEX_SAYNO2DRAWPATTERNRECT 0x00000800   // Many apps either don't handle DRP correctly or can't handle the 32-bit ones.
#define WOWCFEX_FAKENOTAWINDOW        0x00000400   // bug #235916 fail IsWindow calls for apps that get burned by handle recycling
#define WOWCFEX_NODIRECTHDPOPUP       0x00000200   // Indicates that we should not do a direct hardware popup for the app
#define WOWCFEX_ALLOWLFNDIALOGS       0x00000100   // Indicates that GetOpenFilename should support LFN
#define WOWCFEX_THUNKLBSELITEMRANGEEX 0x00000080   // Indicates that we should thunk the LB_SELITEMRANGEEX message (LB_ADDSTRING+3 in wow land)
#define WOWCFEX_LIMITFINDFIRSTLEN     0x00000040   // Indicates that we should limit length of findfirst to 64 bytes
#define WOWCFEX_USEWINHELP32          0x00000020   // Forces an app to use Winhlp32 instead of winhelp.
#define WOWCFEX_PLATFORMVERSIONLIE    0x00000010   // Version Lies to the application by returning the value 1 (for Win95, 98, and ME) as the Platform.
#define WOWCFEX_WIN31VERSIONLIE       0x00000008   // Return win31 when for GetVersion
#define WOWCFEX_EATDEVMODEMSG         0x00000004   // Some apps (access2.0 one of them) need to have wm_devmodechange blocked bug 189703
#define WOWCFEX_DISPMODE256           0x00000002   // Some apps need 256 color mode to work
// Note: This was put at 0x00000001 because it was back ported to 3.51 SP5
#define WOWCFEX_FORMFEEDHACK          0x00000001   // For apps that send a final form feed char to printer via Escape(PASSTHROUGH)


// Extra WOW User compatibility flags bit definitions (WOWCF_USER).
// Kept in CURRENTPTD->dwUserWOWCompatFlags.

#define WOWCF_USER_DDENOSYNC          0x00040000   // Winfax doesn't wait for DDE_ACK before sending dde messages

// Extra WOW2 compatibility flags bit definitions (WOWCF2_).
// Kept in CURRENTPTD->dwUserWOWCompatFlags2.
#define WOWCF2_HACKWINFLAGS           0x80000000   // GACF_HACKWINFLAGS is set if this is set
#define WOWCF2_SETFOREGROUND          0x40000000   // wow calls SetForegroundWindow during showwindow if set
#define WOWCF2_SYNCSYSFILE            0x20000000   // wow redirects file open calls for system\user.exe to system32\user.exe
#define WOWCF2_RESETCURDIR            0x10000000   // some apps need to start from exe file's directory
#define WOWCF2_DELAYTIMEGETTIME       0x08000000   // for apps that don't check if TimeGetTime diff is 0 
#define WOWCF2_FIXLUNATRAYRECT        0x04000000   // adjust the Luna tray rect to match Classic tray rect more closely
#define WOWCF2_USEMINIMALENVIRONMENT  0x02000000   // strip most of the NT-specific stuff from environment passed to app
#define WOWCF2_DPM_PATCHES            0x01000000   // link dynamic patch module(s) 
#define WOWCF2_HACKPROFILECALL        0x00800000   // Used for various GetxxxProfilexxx() API hacks (See wow32\wkernel.c)
#ifdef FE_SB

// Extra WOW compatibility flags for DBCS  These flags
// are kept in CURRENTPTD->dwWOWCompatFlagsFE.
//

#define WOWCF_FE_AMIPRO_PM4J_IME         0x00000001   // AMIPRO, set sizeof(DEVMODE of Win3.1) into dmSize , ExtDeviceMode; selectively ignore IME_SETCONVERSIONWINDOW MCW_DEFAULT
                                                   // PM4J, don't pass MCW_DEFAULT to prevent display timing problem
#define WOWCF_FE_FORCEREGQRYLEN          0x00000002   // Lotus 123, set 80 into *lpcb , RegQueryValue
#define WOWCF_FE_AUDITNOTEPAD            0x00000004   // Lotus Freelance Instration program, audit to exit notepad - read.me
#define WOWCF_FE_USEUPPER                0x00000008   // Used for WinWrite "Key name"
#define WOWCF_FE_ASWHELPER               0x00000010   // AutherWare Start, call SetMenu when called AppendMenu( MF_POPUP ) : MSKKBUG 3203
#define WOWCF_FE_PPT4J_IME_GETVERSION    0x00000020   // PPT4J has a bug, expects the ime version to be 3.1 not greater.
// WARNING: For DaytonaJ RC1 Only.  Steal the following US bit for WinwordJ's TrueInLine hangup
#define WOWCF_FE_WORDJ_IME_GETVERSION    0x00000040   // Used for Telling Winword we have OldVersion IME
#define WOWCF_FE_FLW2_PRINTING_PS        0x00000080   // Lotus Freelance printing with PostScript.
                                                   // Between ESCAPE( BEGIN_PATH, CLIP_TO_PATH, END_PATH ), writing POLYGON with NULL_BRUSH
#define WOWCF_FE_ARIRANG20_PRNDLG        0x00000100   // ARiRang word processor print dialg and print setup dialog problem : Korea
#define WOWCF_FE_BCW45J_COMMDLG          0x00000200   // Boland C++ 4.5J, does not open common dialog : Japan
#define WOWCF_FE_DIRECTOR_START          0x00000400   // Director 4.0J, does not start : Japan
#define WOWCF_FE_QPW_FIXINVALIDWINHANDLE 0x00000800   // Quattro Pro Window use null window handle when it call Hanja conversion : Korea
#define WOWCF_FE_ICHITARO_ITALIC         0x00001000   // map System Mincho to MS Mincho instead of Ms P Mincho
#endif // FE_SB





// Win3.1/Win95/User32 compatibility bits (GACF_).  These flags
// are kept in CURRENTPTD->dwCompatFlags, the 16-bit TDB,
// and over in user.
//
#ifndef _WINGDIP_         // these are defined by wingdip.h as well.


#define GACF_IGNORENODISCARD        0x00000001
#define GACF_FORCETEXTBAND          0x00000002
#define GACF_USEPRINTINGESCAPES     0x00000004      // re-use GACF_ONELANDGRXBAND
#define GACF_IGNORETOPMOST          0x00000008
#define GACF_CALLTTDEVICE           0x00000010
#define GACF_MULTIPLEBANDS          0x00000020
#define GACF_ALWAYSSENDNCPAINT      0x00000040
#define GACF_EDITSETTEXTMUNGE       0x00000080
#define GACF_MOREEXTRAWNDWORDS      0x00000100
#define GACF_TTIGNORERASTERDUPE     0x00000200
#define GACF_HACKWINFLAGS           0x00000400
#define GACF_DELAYHWHNDSHAKECHK     0x00000800
#define GACF_ENUMHELVNTMSRMN        0x00001000
#define GACF_ENUMTTNOTDEVICE        0x00002000
#define GACF_SUBTRACTCLIPSIBS       0x00004000
#define GACF_FORCERASTERMODE        0x00008000      // re-use GACF_FORCETTGRAPHICS
#define GACF_NOHRGN1                0x00010000
#define GACF_NCCALCSIZEONMOVE       0x00020000
#define GACF_SENDMENUDBLCLK         0x00040000
#define GACF_30AVGWIDTH             0x00080000
#define GACF_GETDEVCAPSNUMLIE       0x00100000

#define GACF_WINVER31               0x00200000      //
#define GACF_INCREASESTACK          0x00400000      //
#define GACF_FORCEWIN31DEVMODESIZE  0x00800000      // (replaces PEEKMESSAGEIDLE)
#define GACF_DISABLEFONTASSOC       0x01000000      // Used in FE only aka GACF_JAPANESCAPEMENT
#define GACF_IGNOREFAULTS           0x02000000      //
#define GACF_NOEMFSPOOLING          0x04000000      //
#define GACF_RANDOM3XUI             0x08000000      //
#define GACF_DONTJOURNALATTACH      0x10000000      //
#define GACF_NOBRUSHCACHE           0x20000000      // re-use GACF_DISABLEDBCSPROPTT
#define GACF_MIRRORREGFONTS         0x40000000      //


#endif // _WINGDIP_


#endif // ! _VDMEXTS_CFLAGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowcomm.h ===
/*++ BUILD Version: 0002
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWCOMM.H
 *  Constants, macros, etc common to WOW16/WOW32
 *
 *  History:
 *  Created 28-Apr-1993 by Craig Jones (v-cjones)
 *
--*/
#ifndef __WOWCOMM__  // has this been included before?
#define __WOWCOMM__

#ifndef UNALIGNED    // this makes UNALIGNED visible only to 32-bit stuff
#define UNALIGNED    // and invisible to 16-bit stuff
#endif

/* XLATOFF */
#pragma pack(1)
/* XLATON */

// COMDEB - Communications Device Equipment Block.  (copied from ibmcom.inc)
//
// This is essentially a superset of the DCB used outside of this
// module. The DCB is contained within the DEB as the first fields.
// The fields which follow are data and status fields which
// are unique to this implementation.
//
// AltQInAddr and AltQOutAddr are alternate queue pointers which are used when
// in "supervisor" mode.  Supervisor mode is a processor mode other than the
// one which Windows normally runs in.  In standard mode Windows, supervisor
// mode is REAL mode.  In enhanced mode Windows, supervisor mode is RING 0
// protected mode.  For more details see comments in IBMINT.ASM.

// RS232 Data Equip Block
typedef struct _COMDEB16 {  /* cdeb16 */
  BYTE   ComDCB;          // size of this struct
  WORD   ComErr;          // Non-zero if I/O error
  WORD   Port;            // Base I/O Address
  WORD   NotifyHandle;
  WORD   NotifyFlags;
  WORD   RecvTrigger;     // char count threshold for calling
  WORD   SendTrigger;     // char count threshold for calling

// The following fields are specific to com ports only
  WORD   IRQhook;         // ptr to IRQ_Hook_Struc
  WORD   NextDEB;         // ptr to next DEB that is sharing IRQ
  WORD   XOffPoint;       // Q count where XOff is sent
  WORD   EvtMask;         // Mask of events to check for
  WORD   EvtWord;         // Event flags
  DWORD  QInAddr;         // Address of the queue
  DWORD  AltQInAddr;      // Addr of queue in "supervisor" mode
  WORD   QInSize;         // Length of queue in bytes
  DWORD  QOutAddr;        // Address of the queue
  DWORD  AltQOutAddr;     // Addr of queue in "supervisor" mode
  WORD   QOutSize;        // Length of queue in bytes
  WORD   QInCount;        // Number of bytes currently in queue
  WORD   QInGet;          // Offset into queue to get bytes from
  WORD   QInPut;          // Offset into queue to put bytes in
  WORD   QOutCount;       // Number of bytes currently in queue
  WORD   QOutGet;         // Offset into queue to get bytes from
  WORD   QOutPut;         // Offset into queue to put bytes in
  BYTE   EFlags;          // Extended flags
  BYTE   MSRShadow;       // Modem Status Register Shadow
  BYTE   ErrorMask;       // Default error-checking mask
  BYTE   RxMask;          // Character mask
  BYTE   ImmedChar;       // Char to be transmitted immediately
  BYTE   HSFlag;          // Handshake flag
  BYTE   HHSLines;        // 8250 DTR/RTS bits for handshaking
  BYTE   OutHHSLines;     // Lines that must be high to output
  BYTE   MSRMask;         // Mask of Modem Lines to check
  BYTE   MSRInfinite;     // Mask of MSR lines that must be high
  BYTE   IntVecNum;       // Interrupt vector number
  BYTE   LSRShadow;       // Line Status Register shadow
  WORD   QOutMod;         // Characters sent mod xOnLim ENQ/ETX [rkh]
  DWORD  VCD_data;
  BYTE   VCDflags;
  BYTE   MiscFlags;       // still more flags
} COMDEB16;
typedef COMDEB16 UNALIGNED *PCOMDEB16;

// In 3.0 MSRShadow had this relationship to EvtWord and major COM apps all
// use this offset of 35 to get to MSRShadow so that they can determine the
// current status of the Modem Status bits.  We need to maintain this offset
// so that these apps will continue to run.

/* XLATOFF */
#pragma pack()
/* XLATON */

#endif // __WOWCOMM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wow.h ===
/*++ BUILD Version: 0002
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOW.H
 *  Constants, macros, etc common to WOW16/WOW32
 *
 *  History:
 *  Created 25-Jan-1991 by Jeff Parsons (jeffpar)
 *  Added SHELL defines 14-April-92 Chandan Chauhan (ChandanC)
 *   and Win 31 parameter validation support.
 *  Modified 12-May-1992 by Mike Tricker (MikeTri) Added MultiMedia declarations
 *                                                 and callback support
 *
--*/


#define WIN31

#include <mvdm.h>
#include <bop.h>
#ifndef NOEXTERNS
#include <softpc.h>
#endif
#include <wownt32.h>

#ifdef i386
#ifndef DEBUG     // should be DEBUG_OR_WOWPROFILE, but
                  // that won't work for assembler as things are.

//
// Flag to control enable/disable W32TryCall function.
//

#define NO_W32TRYCALL 1
#endif
#endif

/* WOW constants
 */
#define MAX_VDMFILENAME 144 // must be >= 144 (see GetTempFileName)
#define GRAINYTIC_RES   0x3f // will truncate to lower multiple of 64


/* Logging/debugging macros
 */
/* XLATOFF */
#define GRAINYTICS(dwordtickcount)  ((dwordtickcount) & (~GRAINYTIC_RES))
#define IFLOG(l)    if (l==iLogLevel && (iLogLevel&1) || l<=iLogLevel && !(iLogLevel&1) || l == 0)

#define OPENLOG()   (hfLog != (HANDLE)-1?hfLog:(hfLog=CreateFile("log",GENERIC_WRITE,FILE_SHARE_READ,NULL,CREATE_ALWAYS,0,NULL)))
#define APPENDLOG() if (hfLog == (HANDLE)-1) {hfLog=CreateFile("log",GENERIC_WRITE,FILE_SHARE_READ,NULL,OPEN_ALWAYS,0,NULL) ; SetFilePointer (hfLog,0,NULL,FILE_END); }
#define CLOSELOG()  if (hfLog != (HANDLE)-1) {CloseHandle(hfLog); hfLog=(HANDLE)-1;}

#undef  LOG
#ifdef  NOLOG
#define LOG(l,args)
#define SETREQLOG(l)
#else
#define SETREQLOG(l) iReqLogLevel = (l)
#define LOG(l,args)  {SETREQLOG(l) ; logprintf args;}
#endif
#define MODNAME(module)

#ifdef  DEBUG
#define STATIC
#define INT3()      _asm int 3
#define IFDEBUG(f)  if (f)
#define ELSEDEBUG   else
#define LOGDEBUG(l,args) LOG(l,args)
#else
#define STATIC static
#define INT3()
#define IFDEBUG(f)
#define ELSEDEBUG
#define LOGDEBUG(l,args)
#endif
/* XLATON */


/* 16-bit Windows constants
 */
#define CW_USEDEFAULT16 ((SHORT)0x8000)


/* 16-bit Windows types
 */
typedef WORD    HAND16;
typedef WORD    HTASK16;
typedef WORD    HINST16;
typedef WORD    HMOD16;
typedef WORD    HRES16;
typedef WORD    HRESI16;
typedef WORD    HRESD16;
typedef WORD    HWND16;
typedef WORD    HMENU16;
typedef WORD    HDC16;
typedef WORD    HRGN16;
typedef WORD    HICON16;
typedef WORD    HCUR16;
typedef WORD    HBRSH16;
typedef WORD    HPAL16;
typedef WORD    HBM16;
typedef WORD    HFONT16;
typedef WORD    HMEM16;
typedef DWORD   HHOOK16;

typedef WORD    HMMIO16;  // for MultiMedia - MikeTri 12-May-1992
typedef WORD    HMIDIIN16;
typedef WORD    HMIDIOUT16;
typedef WORD    HWAVEIN16;
typedef WORD    HWAVEOUT16;
typedef WORD    HDRVR16;
typedef DWORD   HPSTR16;

typedef SHORT   INT16;
typedef SHORT   BOOL16;

/* 16-bit pointer types (VP == VDM Ptr)
 */
typedef DWORD   VPVOID;     // VDM address (seg:off)
typedef VPVOID  VPBYTE;     //
typedef VPVOID  VPWORD;     //
typedef VPVOID  VPDWORD;    //
typedef VPVOID  VPSHORT;    //
typedef VPVOID  VPLONG;     //
typedef VPVOID  VPSTR;      // should use VPSZ or VPBYTE instead, as approp.
typedef VPVOID  VPSZ;       //
typedef VPVOID  VPPROC;     //
typedef VPVOID  VPWNDPROC;  //
typedef VPVOID  VPINT16;    //
typedef VPVOID  VPBOOL16;   //
typedef VPVOID  *PVPVOID;   // pointer to VDM address

typedef VPVOID  VPCSTR;     // MultiMedia Extensions - MikeTri 12-May-1992
typedef VPVOID  VPMMIOPROC16;
typedef VPVOID  VPHMIDIIN16;
typedef VPVOID  VPHMIDIOUT16;
typedef VPVOID  VPPATCHARRAY16;
typedef VPVOID  VPKEYARRAY16;
typedef VPVOID  VPHWAVEIN16;
typedef VPVOID  VPHWAVEOUT16;
typedef VPVOID  VPTIMECALLBACK16;
typedef VPVOID  VPTASKCALLBACK16;

/* Types
 */
typedef ULONG   (FASTCALL *LPFNW32)(PVDMFRAME);

/* Dispatch table entry
**
 */
typedef struct _W32 {   /* w32 */
    LPFNW32 lpfnW32;    // function address
#ifdef DEBUG_OR_WOWPROFILE
    LPSZ        lpszW32;    // function name (DEBUG version only)
    DWORD       cbArgs;     // # of bytes of arguments (DEBUG version only)
    DWORD       cCalls;     // # of times this API called
    LONGLONG    cTics;      // sum total # of tics ellapsed for all invocations
#endif // DEBUG_OR_WOWPROFILE
} W32, *PW32;

/* XLATOFF */
#pragma pack(1)
/* XLATON */

/* Window proc/dialog box callback function parameter format
 */
typedef struct _PARMWP {    /* wp */
    LONG    lParam;     //
    WORD    wParam;     //
    WORD    wMsg;       //
    WORD    hwnd;       //
    WORD    hInst;      // hInstance of window that we are returning to
} PARMWP;


/* EnumPropsProc callback function parameter format
 */
typedef struct _PARMEPP {   /* epp */
    HAND16  hData;
    VPVOID  vpString;
    HWND16  hwnd;
} PARMEPP;


/* EnumWindows/EnumChildWindows/EnumTaskWindows callback function parameter format
 */
typedef struct _PARMEWP {       /* ewp */
    LONG    lParam;             // app-defined data
    HWND16  hwnd;               // 16-bit window handle
} PARMEWP;


/* EnumFonts callback function parameter format
 */
typedef struct _PARMEFP {       /* efp */
    VPVOID  vpData;     // app-defined data
    SHORT   nFontType;      //
    VPVOID  vpTextMetric;   // pointer to TEXTMETRIC16
    VPVOID  vpLogFont;      // pointer to LOGFONT16
} PARMEFP;


/* EnumObj callback function parameter format
 */
typedef struct _PARMEOP {       /* eop */
    VPVOID  vpData;     // app-defined data
    VPVOID  vpLogObject;
} PARMEOP;


/* EnumMetaFile callback function parameter format
 */
typedef struct _PARMEMP {       /* emp */
    VPVOID  vpData;     // app-defined data
    SHORT   nObjects;       // # objects
    VPVOID  vpMetaRecord;   // pointer to METARECORD16
    VPVOID  vpHandleTable;  // pointer to HANDLETABLE16
    HDC16   hdc;        // hdc
} PARMEMP;

/* Hook Callback function parameter format
 */
typedef struct _PARMHKP {       /* hkp */
    VPVOID  lParam;
    SHORT   wParam;
    SHORT   nCode;          // action code
} PARMHKP;

/* Subclass Callback function parameter format
 */
typedef struct _PARMSCP {       /* scp */
    SHORT    iOrdinal;          // oridnal number;
} PARMSCP;

/* LineDDA Callback function parameter format
 */
typedef struct _PARMDDA {   /* dda */
    VPVOID vpData;
    SHORT  y;
    SHORT  x;
} PARMDDA;

/* Graystring callback function parameter format
 */
typedef struct _PARMGST {   /* gst */
    SHORT n;
    DWORD data;
    HDC16 hdc;
} PARMGST;


typedef struct _PARMDIR { /* cdir */
    SHORT wDrive;
    VPSZ  vpDir;  // directory name
} PARMDIR;

typedef struct _PARMSAP { /* sap */
    SHORT  code;    //
    HAND16 hPr;
} PARMSAP;


/* WordBreakProc callback function parameter format
 */
typedef struct _PARMWBP {       /* wbp */
    SHORT   action;
    SHORT   cbEditText;
    SHORT   ichCurrentWord;
    VPVOID  lpszEditText;
} PARMWBP;


/*++

  MultiMedia callback definitions added, and also to _PARM16 - MikeTri

--*/

/* midiInOpen (MidiInFunc) Callback function parameter format
 */

typedef struct _PARMMIF {       /* mif */
    DWORD     dwParam2;
    DWORD     dwParam1;
    DWORD     dwInstance;
    WORD      wMsg;
    HMIDIIN16 hMidiIn;
} PARMMIF;

/* midiOutOpen (MidiOutFunc) Callback function parameter format
 */

typedef struct _PARMMOF {       /* mof */
    DWORD      dwParam2;
    DWORD      dwParam1;
    DWORD      dwInstance;
    WORD       wMsg;
    HMIDIOUT16 hMidiOut;
} PARMMOF;

/* mmioInstallIOProc (IOProc) Callback function parameter format
 */

typedef struct _PARMIOP {      /* iop */
    LONG      lParam2;
    LONG      lParam1;
    WORD      wMsg;
    VPVOID    lpmmioinfo;
} PARMIOP;

/* timeSetEvent (TimeFunc) Callback function parameter format
 */

typedef struct _PARMTIF {       /* tif */
    DWORD     dw2;
    DWORD     dw1;
    DWORD     dwUser;
    WORD      wMsg;
    WORD      wID;
} PARMTIF;

/* waveInOpen (WaveInFunc) Callback function parameter format
 */

typedef struct _PARMWIF {       /* wif */
    DWORD     dwParam2;
    DWORD     dwParam1;
    DWORD     dwInstance;
    WORD      wMsg;
    HWAVEIN16 hWaveIn;
} PARMWIF;

/* waveOutOpen (WaveOutFunc) Callback function parameter format
 */

typedef struct _PARMWOF {       /* wof */
    DWORD      dwParam2;
    DWORD      dwParam1;
    DWORD      dwInstance;
    WORD       wMsg;
    HWAVEOUT16 hWaveOut;
} PARMWOF;

/* WOWCallback16 function parameter format
 */

typedef struct _PARMWCB16 {       /* wcb16 */
    WORD       wArgs[8];
} PARMWCB16;

typedef struct _PARMLSTRCMP {     /* lstrcmp16 */
    VPVOID     lpstr1;
    VPVOID     lpstr2;
} PARMLSTRCMP;

/* PARM16 is the union of all the callback parameter structures
 */
typedef union _PARM16 {     /* parm16 */
    PARMWP  WndProc;        // for window procs
    PARMEWP EnumWndProc;        // for window enum functions
    PARMEFP EnumFontProc;       // for font enum functions
    PARMEOP EnumObjProc;       // for obj enum functions
    PARMEMP EnumMetaProc;       // for metafile enum functions
    PARMEPP EnumPropsProc;  // for properties
    PARMHKP HookProc;           // for Hooks
    PARMSCP SubClassProc;   // for subclass thunks
    PARMDDA LineDDAProc;    // for LineDDA
    PARMGST GrayStringProc; // for GrayString
    PARMDIR CurDir;
    PARMSAP SetAbortProc;   // for SetAbortProc
    PARMMIF MidiInFunc;         // for midiInOpen functions - MikeTri 27-Mar-1992
    PARMMOF MidiOutFunc;        // for midiOutOpen functions
    PARMIOP IOProc;             // for mmioInstallIOProc functions
    PARMTIF TimeFunc;           // for timeSetEvent functions
    PARMWIF WaveInFunc;         // for waveInOpen functions
    PARMWOF WaveOutFunc;        // for waveOutOpen functions
    PARMWBP WordBreakProc;      // for WordBreakProc
    PARMWCB16 WOWCallback16;    // for WOWCallback16
    PARMLSTRCMP lstrcmpParms;   // for WOWlstrcmp16 (pfnWowIlstrsmp to user32)
} PARM16, *PPARM16;


/* VDMFRAME is built by wow16cal.asm in the kernel, and is utilized
 * by all the WOW32 thunks
 */
typedef struct _VDMFRAME {  /* vf */
    WORD    wTDB;       // 16-bit kernel handle for calling task
    WORD    wRetID;     // internal call-back function ID Do NOT Move
    WORD    wLocalBP;   //
    WORD    wDI;        //
    WORD    wSI;        //
    WORD    wAX;        //
    WORD    wDX;        // keep DX right after AX!!!
    WORD    wAppDS;     // app DS at time of call
    WORD    wGS;
    WORD    wFS;
    WORD    wCX;        // REMOVE LATER
    WORD    wES;        // REMOVE LATER
    WORD    wBX;        // REMOVE LATER
    WORD    wBP;        // BP Chain +1
    VPVOID  wThunkCSIP; // ret addr of THUNK
    DWORD   wCallID;    // internal WOW16 module/function ID
    WORD    cbArgs;     // byte count of args pushed
    VPVOID  vpCSIP;     // far return address to app
    BYTE    bArgs;      // start of arguments from app
} VDMFRAME;
typedef VDMFRAME UNALIGNED *PVDMFRAME;

/* CBVDMFRAME is built by callback16 in wow32.dll and in wow16cal.asm
 * the definition of VDMFRAME and CBACKVDMFRAME must be in sync
 */

typedef struct _CBVDMFRAME {  /* cvf */
    WORD    wTDB;       // must match VDMFRAME
    WORD    wRetID;     // must match VDMFRAME
    WORD    wLocalBP;   // must match VDMFRAME
    PARM16  Parm16;     // space for window/enum proc parameters
    VPVOID  vpfnProc;   // address of window/enum proc
    DWORD   vpStack;    // orginal ss:sp. used in callback16
    WORD    wAX;        //
    WORD    wDX;        // keep DX right after AX!!!
    WORD    wGenUse1;   // extra words for general use. for convenience
    WORD    wGenUse2;   // extra words for general use. for convenience
} CBVDMFRAME;
typedef CBVDMFRAME UNALIGNED *PCBVDMFRAME;

typedef struct _POINT16 {       /* pt16 */
    SHORT   x;
    SHORT   y;
} POINT16;
typedef POINT16 UNALIGNED *PPOINT16;
typedef VPVOID VPPOINT16;

/* POINTL16 is new for Win95 and is identical to Win32 POINT/POINTL structures */

typedef struct _POINTL16 {       /* ptl16 */
    LONG   x;
    LONG   y;
} POINTL16;
typedef POINTL16 UNALIGNED *PPOINTL16;
typedef VPVOID VPPOINTL16;

typedef struct _RASTERIZER_STATUS16 {  /* rs16 */
    INT16   nSize;
    INT16   wFlags;
    INT16   nLanguageID;
} RASTERIZER_STATUS16;
typedef RASTERIZER_STATUS16 UNALIGNED *PRASTERIZER_STATUS16;
typedef VPVOID VPRASTERIZER_STATUS16;

typedef struct _GLYPHMETRICS16 {  /*glyph16 */
    WORD    gmBlackBoxX;
    WORD    gmBlackBoxY;
    POINT16 gmptGlyphOrigin;
    INT16   gmCellIncX;
    INT16   gmCellIncY;
} GLYPHMETRICS16;
typedef GLYPHMETRICS16 UNALIGNED *PGLYPHMETRICS16;
typedef VPVOID VPGLYPHMETRICS16;

typedef struct _ABC16 {        /* abc16 */
    INT16   abcA;
    WORD    abcB;
    INT16   abcC;
} ABC16;
typedef ABC16 UNALIGNED *PABC16;
typedef VPVOID VPABC16;

typedef struct _FIXED16 {        /* fxd16 */
    WORD    fract;
    INT16   value;
} FIXED16;
typedef FIXED16 UNALIGNED *PFIXED16;
typedef VPVOID VPFIXED16;

typedef struct _MAT216 {        /* mat216 */
    FIXED16 eM11;
    FIXED16 eM12;
    FIXED16 eM21;
    FIXED16 eM22;
} MAT216;
typedef MAT216 UNALIGNED *PMAT216;
typedef VPVOID VPMAT216;


/* 16-bit API structures, and their pointers
 */
typedef struct _RECT16 {        /* rc16 */
    SHORT   left;
    SHORT   top;
    SHORT   right;
    SHORT   bottom;
} RECT16;
typedef RECT16 UNALIGNED *PRECT16;
typedef VPVOID VPRECT16;

/* RECTL16 is new for Win95 and is identical to Win32 RECTL structure */

typedef struct _RECTL16 {        /* rcl16 */
    LONG   left;
    LONG   top;
    LONG   right;
    LONG   bottom;
} RECTL16;
typedef RECTL16 UNALIGNED *PRECTL16;
typedef VPVOID VPRECTL16;

typedef struct _KERNINGPAIR16 {        /* k16 */
    WORD   wFirst;
    WORD   wSecond;
    INT16  iKernAmount;
} KERNINGPAIR16;
typedef KERNINGPAIR16 UNALIGNED *PKERNINGPAIR16;
typedef VPVOID VPKERNINGPAIR16;




typedef struct _MSG16 {         /* msg16 */
    HWND16  hwnd;
    WORD    message;
    WORD    wParam;
    LONG    lParam;
    DWORD   time;
    POINT16 pt;
} MSG16;
typedef MSG16 UNALIGNED *PMSG16;
typedef VPVOID VPMSG16;

typedef struct _PAINTSTRUCT16 {     /* ps16 */
    HDC16   hdc;
    BOOL16  fErase;
    RECT16  rcPaint;
    BOOL16  fRestore;
    BOOL16  fIncUpdate;
    BYTE    rgbReserved[16];
} PAINTSTRUCT16;
typedef PAINTSTRUCT16 UNALIGNED *PPAINTSTRUCT16;
typedef VPVOID VPPAINTSTRUCT16;

typedef struct _WNDCLASS16 {        /* wc16 */
    WORD    style;
    VPWNDPROC vpfnWndProc;
    SHORT   cbClsExtra;
    SHORT   cbWndExtra;
    HAND16  hInstance;
    HICON16 hIcon;
    HCUR16  hCursor;
    HBRSH16 hbrBackground;
    VPSZ    vpszMenuName;
    VPSZ    vpszClassName;
} WNDCLASS16;
typedef WNDCLASS16 UNALIGNED *PWNDCLASS16;
typedef VPVOID VPWNDCLASS16;

typedef struct _PALETTEENTRY16 {    /* pe16 */
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY16;
typedef PALETTEENTRY16 UNALIGNED *PPALETTEENTRY16;
typedef VPVOID VPPALETTEENTRY16;

typedef struct _RGBTRIPLE16 {       /* rgbt16 */
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE16;

typedef struct  _BITMAPCOREHEADER16 { /* bmch16 */
    DWORD   bcSize;
    WORD    bcWidth;
    WORD    bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER16;
typedef BITMAPCOREHEADER16 UNALIGNED *PBITMAPCOREHEADER16;

typedef struct  _BITMAPCOREINFO16 {   /* bmci16 */
    BITMAPCOREHEADER16 bmciHeader;
    RGBTRIPLE16 bmciColors[1];
} BITMAPCOREINFO16;
typedef BITMAPCOREINFO16 UNALIGNED *PBITMAPCOREINFO16;


typedef struct  _CLIENTCREATESTRUCT16 { /* ccs16 */
    HMENU16 hWindowMenu;
    WORD    idFirstChild;
} CLIENTCREATESTRUCT16;
typedef CLIENTCREATESTRUCT16 UNALIGNED *PCLIENTCREATESTRUCT16;



typedef struct _LOGPALETTE16 {      /* logpal16 */
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY16 palPalEntry[1];
} LOGPALETTE16;
typedef LOGPALETTE16 UNALIGNED *PLOGPALETTE16;
typedef VPVOID VPLOGPALETTE16;

typedef SHORT CATCHBUF16[9];        /* cb16 */
typedef VPSHORT VPCATCHBUF16;

typedef struct _OFSTRUCT16 {        /* of16 */
    BYTE    cBytes;
    BYTE    fFixedDisk;
    WORD    nErrCode;
    BYTE    reserved[4];
    BYTE    szPathName[128];
} OFSTRUCT16;
typedef OFSTRUCT16 UNALIGNED *POFSTRUCT16;
typedef VPVOID VPOFSTRUCT16;

typedef struct _DCB16 {         /* dcb16 */
    BYTE    Id;             // Internal Device ID
    WORD    BaudRate;           // Baudrate at which runing
    BYTE    ByteSize;           // Number of bits/byte, 4-8
    BYTE    Parity;         // 0-4=None,Odd,Even,Mark,Space
    BYTE    StopBits;           // 0,1,2 = 1, 1.5, 2
    WORD    RlsTimeout;         // Timeout for RLSD to be set
    WORD    CtsTimeout;         // Timeout for CTS to be set
    WORD    DsrTimeout;         // Timeout for DSR to be set
    WORD    wFlags;             // Bitfield flags
  /*+++ These are the bitfield definitions in wFlags above --
    BYTE    fBinary: 1;         // Binary Mode (skip EOF check
    BYTE    fRtsDisable:1;      // Don't assert RTS at init time
    BYTE    fParity: 1;         // Enable parity checking
    BYTE    fOutxCtsFlow:1;     // CTS handshaking on output
    BYTE    fOutxDsrFlow:1;     // DSR handshaking on output
    BYTE    fDummy: 2;          // Reserved
    BYTE    fDtrDisable:1;      // Don't assert DTR at init time

    BYTE    fOutX: 1;           // Enable output X-ON/X-OFF
    BYTE    fInX: 1;            // Enable input X-ON/X-OFF
    BYTE    fPeChar: 1;         // Enable Parity Err Replacement
    BYTE    fNull: 1;           // Enable Null stripping
    BYTE    fChEvt: 1;          // Enable Rx character event.
    BYTE    fDtrflow: 1;        // DTR handshake on input
    BYTE    fRtsflow: 1;        // RTS handshake on input
    BYTE    fDummy2: 1;         //
  ---*/
    CHAR    XonChar;            // Tx and Rx X-ON character
    CHAR    XoffChar;           // Tx and Rx X-OFF character
    WORD    XonLim;             // Transmit X-ON threshold
    WORD    XoffLim;            // Transmit X-OFF threshold
    CHAR    PeChar;             // Parity error replacement char
    CHAR    EofChar;            // End of Input character
    CHAR    EvtChar;            // Recieved Event character
    WORD    TxDelay;            // Amount of time between chars
} DCB16;
typedef DCB16 UNALIGNED *PDCB16;
typedef VPVOID VPDCB16;

typedef struct _COMSTAT16 {     /* cs16 */
    BYTE    status;
  /*+++ These are bitfield definitions defined in status above --
    BYTE    fCtsHold: 1;        // transmit is on CTS hold
    BYTE    fDsrHold: 1;        // transmit is on DSR hold
    BYTE    fRlsdHold: 1;       // transmit is on RLSD hold
    BYTE    fXoffHold: 1;       // received handshake
    BYTE    fXoffSent: 1;       // issued handshake
    BYTE    fEof: 1;            // end of file character found
    BYTE    fTxim: 1;           // character being transmitted
  ---*/
    WORD    cbInQue;            // count of characters in Rx Queue
    WORD    cbOutQue;           // count of characters in Tx Queue
} COMSTAT16;
typedef COMSTAT16 UNALIGNED *PCOMSTAT16;
typedef VPVOID VPCOMSTAT16;

#ifdef FE_SB                     // wowfax support for Japanese
typedef struct _DEV_BITMAP16 {      /* devbm16 */
    SHORT   bmType;
    SHORT   bmWidth;
    SHORT   bmHeight;
    SHORT   bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    VPBYTE  bmBits;
    LONG    bmWidthPlanes;
    LONG    bmlpPDevice;
    SHORT   bmSegmentIndex;
    SHORT   bmScanSegment;
    SHORT   bmFillBytes;
    SHORT   reserved1;
    SHORT   reserved2;
} DEV_BITMAP16;
typedef DEV_BITMAP16 UNALIGNED *PDEV_BITMAP16;
typedef VPVOID VPDEV_BITMAP16;
#endif // FE_SB

typedef struct _BITMAP16 {      /* bm16 */
    SHORT   bmType;
    SHORT   bmWidth;
    SHORT   bmHeight;
    SHORT   bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    VPBYTE  bmBits;
} BITMAP16;
typedef BITMAP16 UNALIGNED *PBITMAP16;
typedef VPVOID VPBITMAP16;

typedef struct _LOGBRUSH16 {        /* lb16 */
    WORD    lbStyle;
    DWORD   lbColor;
    SHORT   lbHatch;
} LOGBRUSH16;
typedef LOGBRUSH16 UNALIGNED *PLOGBRUSH16;
typedef VPVOID VPLOGBRUSH16;

/* ASM
LF_FACESIZE equ 32
 */
typedef struct _LOGFONT16 {     /* lf16 */
    SHORT   lfHeight;
    SHORT   lfWidth;
    SHORT   lfEscapement;
    SHORT   lfOrientation;
    SHORT   lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    BYTE    lfFaceName[LF_FACESIZE];
} LOGFONT16;
typedef LOGFONT16 UNALIGNED *PLOGFONT16;
typedef VPVOID VPLOGFONT16;

/* ASM
LF_FULLFACESIZE equ 64
 */
/* Structure passed to FONTENUMPROC */
typedef struct _ENUMLOGFONT16 { /* elp16 */
    LOGFONT16   elfLogFont;
    char        elfFullName[LF_FULLFACESIZE];
    char        elfStyle[LF_FACESIZE];
} ENUMLOGFONT16;
typedef ENUMLOGFONT16 UNALIGNED *PENUMLOGFONT16;
typedef VPVOID VPENUMLOGFONT16;

typedef struct _LOGPEN16 {      /* lp16 */
    WORD    lopnStyle;
    POINT16 lopnWidth;
    DWORD   lopnColor;
} LOGPEN16;
typedef LOGPEN16 UNALIGNED *PLOGPEN16;
typedef VPVOID VPLOGPEN16;

typedef struct _RGBQUAD16 {      /* rgbq16 */
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD16;
typedef RGBQUAD16 UNALIGNED *PRGBQUAD16;
typedef VPVOID VPRGBQUAD16;

typedef BITMAPINFOHEADER BITMAPINFOHEADER16;
typedef BITMAPINFOHEADER16 UNALIGNED *PBITMAPINFOHEADER16;
typedef VPVOID VPBITMAPINFOHEADER16;

typedef BITMAPINFO BITMAPINFO16;
typedef BITMAPINFO16 UNALIGNED *PBITMAPINFO16;
typedef VPVOID VPBITMAPINFO16;

typedef struct _TEXTMETRIC16 {      /* tm16 */
    SHORT   tmHeight;
    SHORT   tmAscent;
    SHORT   tmDescent;
    SHORT   tmInternalLeading;
    SHORT   tmExternalLeading;
    SHORT   tmAveCharWidth;
    SHORT   tmMaxCharWidth;
    SHORT   tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    SHORT   tmOverhang;
    SHORT   tmDigitizedAspectX;
    SHORT   tmDigitizedAspectY;
} TEXTMETRIC16;
typedef TEXTMETRIC16 UNALIGNED *PTEXTMETRIC16;
typedef VPVOID VPTEXTMETRIC16;

typedef struct _NEWTEXTMETRIC16 {      /* ntm16 */
    SHORT   tmHeight;
    SHORT   tmAscent;
    SHORT   tmDescent;
    SHORT   tmInternalLeading;
    SHORT   tmExternalLeading;
    SHORT   tmAveCharWidth;
    SHORT   tmMaxCharWidth;
    SHORT   tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    SHORT   tmOverhang;
    SHORT   tmDigitizedAspectX;
    SHORT   tmDigitizedAspectY;
    DWORD   ntmFlags;
    WORD    ntmSizeEM;
    WORD    ntmCellHeight;
    WORD    ntmAvgWidth;
} NEWTEXTMETRIC16;
typedef NEWTEXTMETRIC16 UNALIGNED *PNEWTEXTMETRIC16;
typedef VPVOID VPNEWTEXTMETRIC16;

typedef struct _PANOSE16 {              /* pan16 */
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE16;
typedef PANOSE16 UNALIGNED *PPANOSE16;

typedef struct _OUTLINETEXTMETRIC16 {   /* otm16 */
    WORD            otmSize;
    TEXTMETRIC16    otmTextMetrics;
    BYTE            otmFiller;
    PANOSE16        otmPanoseNumber;
    WORD            otmfsSelection;
    WORD            otmfsType;
    SHORT           otmsCharSlopeRise;
    SHORT           otmsCharSlopeRun;
    SHORT           otmItalicAngle;
    WORD            otmEMSquare;
    SHORT           otmAscent;
    SHORT           otmDescent;
    WORD            otmLineGap;
    WORD            otmsCapEmHeight;
    WORD            otmsXHeight;
    RECT16          otmrcFontBox;
    SHORT           otmMacAscent;
    SHORT           otmMacDescent;
    WORD            otmMacLineGap;
    WORD            otmusMinimumPPEM;
    POINT16         otmptSubscriptSize;
    POINT16         otmptSubscriptOffset;
    POINT16         otmptSuperscriptSize;
    POINT16         otmptSuperscriptOffset;
    WORD            otmsStrikeoutSize;
    SHORT           otmsStrikeoutPosition;
    SHORT           otmsUnderscorePosition;
    SHORT           otmsUnderscoreSize;
    WORD            otmpFamilyName;
    WORD            otmpFaceName;
    WORD            otmpStyleName;
    WORD            otmpFullName;
} OUTLINETEXTMETRIC16;
typedef OUTLINETEXTMETRIC16 UNALIGNED *POUTLINETEXTMETRIC16;
typedef VPVOID VPOUTLINETEXTMETRIC16;

typedef struct _HANDLETABLE16 {     /* ht16 */
    HAND16  objectHandle[1];
} HANDLETABLE16;
typedef HANDLETABLE16 UNALIGNED *PHANDLETABLE16;
typedef VPVOID VPHANDLETABLE16;

typedef struct _METARECORD16 {      /* mr16 */
    DWORD   rdSize;
    WORD    rdFunction;
    WORD    rdParm[1];
} METARECORD16;
typedef METARECORD16 UNALIGNED *PMETARECORD16;
typedef VPVOID VPMETARECORD16;

typedef struct _DEVMODE16 {     /* dm16 */
    CHAR    dmDeviceName[32];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    SHORT   dmOrientation;
    SHORT   dmPaperSize;
    SHORT   dmPaperLength;
    SHORT   dmPaperWidth;
    SHORT   dmScale;
    SHORT   dmCopies;
    SHORT   dmDefaultSource;
    SHORT   dmPrintQuality;
    SHORT   dmColor;
    SHORT   dmDuplex;
} DEVMODE16;
typedef DEVMODE16 UNALIGNED *PDEVMODE16;
typedef VPVOID VPDEVMODE16;

typedef struct _DEVMODE31 {     /* dm31 */
    CHAR    dmDeviceName[32];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    SHORT   dmOrientation;
    SHORT   dmPaperSize;
    SHORT   dmPaperLength;
    SHORT   dmPaperWidth;
    SHORT   dmScale;
    SHORT   dmCopies;
    SHORT   dmDefaultSource;
    SHORT   dmPrintQuality;
    SHORT   dmColor;
    SHORT   dmDuplex;
    SHORT   dmYResolution;
    SHORT   dmTTOption;
} DEVMODE31;
typedef DEVMODE31 UNALIGNED *PDEVMODE31;
typedef VPVOID VPDEVMODE31;

typedef struct _CREATESTRUCT16 {    /* cws16 */
    VPBYTE  vpCreateParams;
    HAND16  hInstance;
    HMENU16 hMenu;
    HWND16  hwndParent;
    SHORT   cy;
    SHORT   cx;
    SHORT   y;
    SHORT   x;
    DWORD   dwStyle;
    VPSZ    vpszWindow;
    VPSZ    vpszClass;
    DWORD   dwExStyle;
} CREATESTRUCT16;
typedef CREATESTRUCT16 UNALIGNED *PCREATESTRUCT16;
typedef VPVOID VPCREATESTRUCT16;

typedef struct _DRAWITEMSTRUCT16 {  /* dis16 */
    WORD    CtlType;
    WORD    CtlID;
    WORD    itemID;
    WORD    itemAction;
    WORD    itemState;
    HWND16  hwndItem;
    HDC16   hDC;
    RECT16  rcItem;
    DWORD   itemData;
} DRAWITEMSTRUCT16;
typedef DRAWITEMSTRUCT16 UNALIGNED *PDRAWITEMSTRUCT16;
typedef VPVOID VPDRAWITEMSTRUCT16;

typedef struct _MEASUREITEMSTRUCT16 {   /* mis16 */
    WORD    CtlType;
    WORD    CtlID;
    WORD    itemID;
    WORD    itemWidth;
    WORD    itemHeight;
    DWORD   itemData;
} MEASUREITEMSTRUCT16;
typedef MEASUREITEMSTRUCT16 UNALIGNED *PMEASUREITEMSTRUCT16;
typedef VPVOID VPMEASUREITEMSTRUCT16;

typedef struct _DELETEITEMSTRUCT16 {    /* des16 */
    WORD    CtlType;
    WORD    CtlID;
    WORD    itemID;
    HWND16  hwndItem;
    DWORD   itemData;
} DELETEITEMSTRUCT16;
typedef DELETEITEMSTRUCT16 UNALIGNED *PDELETEITEMSTRUCT16;
typedef VPVOID VPDELETEITEMSTRUCT16;

typedef struct _COMPAREITEMSTRUCT16 {   /* cis16 */
    WORD    CtlType;
    WORD    CtlID;
    HWND16  hwndItem;
    WORD    itemID1;
    DWORD   itemData1;
    WORD    itemID2;
    DWORD   itemData2;
} COMPAREITEMSTRUCT16;
typedef COMPAREITEMSTRUCT16 UNALIGNED *PCOMPAREITEMSTRUCT16;
typedef VPVOID VPCOMPAREITEMSTRUCT16;

typedef struct _MDICREATESTRUCT16 {     /* mcs16 */
    VPSZ    vpszClass;
    VPSZ    vpszTitle;
    HTASK16 hOwner;
    SHORT   x;
    SHORT   y;
    SHORT   cx;
    SHORT   cy;
    LONG    style;
    LONG    lParam;                     // app-defined stuff
} MDICREATESTRUCT16;
typedef MDICREATESTRUCT16 UNALIGNED *PMDICREATESTRUCT16;
typedef VPVOID VPMDICREATESTRUCT16;


typedef struct _WINDOWPOS16 {     /* wp16 */
    HAND16  hwnd;
    HAND16  hwndInsertAfter;
    SHORT   x;
    SHORT   y;
    SHORT   cx;
    SHORT   cy;
    WORD    flags;
} WINDOWPOS16;
typedef WINDOWPOS16 UNALIGNED *PWINDOWPOS16;
typedef VPVOID VPWINDOWPOS16;

typedef struct _NCCALCSIZE_PARAMS16 {    /* nccsz16 */
    RECT16        rgrc[3];
    WINDOWPOS16 UNALIGNED FAR *lppos;
} NCCALCSIZE_PARAMS16;
typedef NCCALCSIZE_PARAMS16 UNALIGNED *PNCCALCSIZE_PARAMS16;
typedef VPVOID VPNCCALCSIZE_PARAMS16;

/*
 * Used by Hook Procs.
 */

typedef struct _EVENTMSG16 {  /* evmsg16 */
    WORD    message;
    WORD    paramL;
    WORD    paramH;
    DWORD   time;
} EVENTMSG16;
typedef EVENTMSG16 UNALIGNED *PEVENTMSG16;
typedef VPVOID VPEVENTMSG16;

typedef struct _DEBUGHOOKINFO16 {   /*dbgi16 */
    HTASK16 hModuleHook;
    DWORD   reserved;
    DWORD   lParam;
    WORD    wParam;
    SHORT   code;
} DEBUGHOOKINFO16;
typedef DEBUGHOOKINFO16 UNALIGNED *PDEBUGHOOKINFO16;
typedef VPVOID VPDEBUGHOOKINFO16;

typedef struct _MOUSEHOOKSTRUCT16 { /* mhs16 */
    POINT16 pt;
    HWND16  hwnd;
    WORD    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT16;
typedef MOUSEHOOKSTRUCT16 UNALIGNED *PMOUSEHOOKSTRUCT16;
typedef VPVOID VPMOUSEHOOKSTRUCT16;

typedef struct _CWPSTRUCT16 {    /* cwps16 */
    LONG    lParam;     //
    WORD    wParam;     //
    WORD    message;    //
    WORD    hwnd;       //
} CWPSTRUCT16;
typedef CWPSTRUCT16 UNALIGNED *PCWPSTRUCT16;
typedef VPVOID VPCWPSTRUCT16;

typedef struct _CBT_CREATEWND16 {  /* cbtcw16 */
    VPCREATESTRUCT16 vpcs;
    HWND16           hwndInsertAfter;
} CBT_CREATEWND16;
typedef CBT_CREATEWND16 UNALIGNED *PCBT_CREATEWND16;
typedef VPVOID VPCBT_CREATEWND16;

typedef struct _CBTACTIVATESTRUCT16 { /* cbtas16 */
    BOOL16    fMouse;
    HWND16    hWndActive;
} CBTACTIVATESTRUCT16;
typedef CBTACTIVATESTRUCT16 UNALIGNED *PCBTACTIVATESTRUCT16;
typedef VPVOID VPCBTACTIVATESTRUCT16;


/* 16-bit resource structures, and their pointers
 *
 * Note that some are the same as the 32-bit definition (eg, menus)
 */

typedef MENUITEMTEMPLATEHEADER     MENUITEMTEMPLATEHEADER16;
typedef MENUITEMTEMPLATE       MENUITEMTEMPLATE16;
typedef MENUITEMTEMPLATEHEADER16 *PMENUITEMTEMPLATEHEADER16;
typedef MENUITEMTEMPLATE16   *PMENUITEMTEMPLATE16;

typedef struct _DLGTEMPLATE16 {     /* dt16 */
    DWORD   style;          //
    BYTE    cdit;           // this is a WORD in WIN32
    WORD    x;              //
    WORD    y;              //
    WORD    cx;             //
    WORD    cy;             //
 // CHAR    szMenuName[];       // potential pad byte in WIN32
 // CHAR    szClassName[];      // potential pad byte in WIN32
 // CHAR    szCaptionText[];        // potential pad byte in WIN32
} DLGTEMPLATE16;
typedef DLGTEMPLATE16 UNALIGNED *PDLGTEMPLATE16;
typedef VPVOID VPDLGTEMPLATE16;

typedef struct _FONTINFO16 {        /* fi16 */
    SHORT   cPoints;            // present if DS_SETFONT in dt16.style
 // CHAR    szTypeFace[];       // potential pad byte in WIN32
} FONTINFO16;
typedef FONTINFO16 UNALIGNED *PFONTINFO16;
typedef VPVOID VPFONTINFO16;

typedef struct _DLGITEMTEMPLATE16 { /* dit16 */
    WORD    x;              // structure dword-aligned in WIN32
    WORD    y;              //
    WORD    cx;             //
    WORD    cy;             //
    WORD    id;             //
    DWORD   style;          // this was moved to the top in WIN32
 // CHAR    szClass[];          // potential pad byte in WIN32
 // CHAR    szText[];           // potential pad byte in WIN32
 // BYTE    cbExtra;            //
 // BYTE    abExtra[];          //
} DLGITEMTEMPLATE16;
typedef DLGITEMTEMPLATE16 UNALIGNED *PDLGITEMTEMPLATE16;
typedef VPVOID VPDLGITEMTEMPLATE16;

typedef struct _RESDIRHEADER16 {    /* hdir16 */
    WORD    reserved;           //
    WORD    rt;             //
    WORD    cResources;         // pad word in WIN32 (for size == 8)
} RESDIRHEADER16;
typedef RESDIRHEADER16 UNALIGNED *PRESDIRHEADER16;
typedef VPVOID VPRESDIRHEADER16;

typedef struct _ICONDIR16 {     /* idir16 */
    BYTE    Width;          // 16, 32, 64
    BYTE    Height;         // 16, 32, 64
    BYTE    ColorCount;         // 2, 8, 16
    BYTE    reserved;           //
} ICONDIR16;
typedef ICONDIR16 UNALIGNED *PICONDIR16;
typedef VPVOID VPICONDIR16;

typedef struct _CURSORDIR16 {       /* cdir16 */
    WORD    Width;          //
    WORD    Height;         //
} CURSORDIR16;
typedef CURSORDIR16 UNALIGNED *PCURSORDIR16;
typedef VPVOID VPCURSORDIR16;

/* XLATOFF */
typedef struct _RESDIR16 {      /* rdir16 */
    union {             //
    ICONDIR16   Icon;       //
    CURSORDIR16 Cursor;     //
    } ResInfo;              //
    WORD    Planes;         //
    WORD    BitCount;           //
    DWORD   BytesInRes;         //
    WORD    idIcon;         // pad word in WIN32 (for size == 16)
} RESDIR16;
typedef RESDIR16 UNALIGNED *PRESDIR16;
typedef VPVOID VPRESDIR16;

typedef struct _COPYDATASTRUCT16 {
    DWORD dwData;
    DWORD cbData;
    PVOID lpData;
} COPYDATASTRUCT16;
typedef COPYDATASTRUCT16 UNALIGNED *PCOPYDATASTRUCT16;
typedef VPVOID VPCOPYDATASTRUCT16;

typedef struct _DROPSTRUCT16 {
    HWND16  hwndSource;
    HWND16  hwndSink;
    WORD    wFmt;
    DWORD   dwData;
    POINT16 ptDrop;
    DWORD   dwControlData;
} DROPSTRUCT16;
typedef DROPSTRUCT16 UNALIGNED *PDROPSTRUCT16;
typedef VPVOID VPDROPSTRUCT16;

typedef struct _DROPFILESTRUCT16 {
    WORD pFiles;
    SHORT x;
    SHORT y;
    BOOL16 fNC;
} DROPFILESTRUCT16;
typedef DROPFILESTRUCT16 UNALIGNED *PDROPFILESTRUCT16;
typedef VPVOID VPDROPFILESTRUCT16;


typedef BITMAPINFOHEADER ICONRESOURCE;
typedef ICONRESOURCE *PICONRESOURCE;
typedef BITMAPINFOHEADER16 ICONRESOURCE16;
typedef ICONRESOURCE16 UNALIGNED *PICONRESOURCE16;
typedef VPVOID VPICONRESOURCE16;

typedef struct _CURSORRESOURCE {    /* cres */
    WORD xHotspot;
    WORD yHotspot;
    BITMAPINFOHEADER bmih;
} CURSORRESOURCE;
typedef CURSORRESOURCE UNALIGNED *PCURSORRESOURCE;

typedef CURSORRESOURCE CURSORRESOURCE16;
typedef CURSORRESOURCE16 UNALIGNED *PCURSORRESOURCE16;
typedef VPVOID VPCURSORRESOURCE16;

// This describes the header of the old 2.x cursor/icon resource format;
// the header should be followed by an AND mask and then an XOR mask, where:
//
//      Bit value   Bit value   Bit value   Bit value
//  AND Mask        0       0       1       1
//  XOR Mask        0       1       0       1
//  ---------------------------------------------------------
//  Result  Black       White   Transparent Inverted
//
// Note that we wouldn't have to worry about this old resource format if apps
// like WinWord (which apparently weren't fully converted to 3.x) didn't use it! -JTP

typedef struct _OLDCURSORICONRESOURCE16 { /* oci16 */
    BYTE    bFigure;            // 1: cursor, 2: bitmap, 3: icon
    BYTE    bIndependent;       // 0: device-dependent, 1: independent
    SHORT   xHotspot;           //
    SHORT   yHotspot;           //
    SHORT   cx;             // x-extent
    SHORT   cy;             // y-extent
    SHORT   cbWidth;            // bytes per row (rows are word-aligned)
    SHORT   clr;            // # color planes (should always be 0)
} OLDCURSORICONRESOURCE16;
typedef OLDCURSORICONRESOURCE16 UNALIGNED *POLDCURSORICONRESOURCE16;
typedef VPVOID VPOLDCURSORICONRESOURCE16;
/* XLATON */

/* XLATOFF */
#pragma pack()
/* XLATON */


/* Undocumented(?) window messages
 */
#define WM_SETVISIBLE       0x0009
#define WM_ALTTABACTIVE     0x0029
#define WM_ISACTIVEICON     0x0035
#define WM_QUERYPARKICON    0x0036
#define WM_SYNCPAINT        0x0088
#define WM_SYSTIMER     0x0118
#define WM_LBTRACKPOINT     0x0131
#define WM_ENTERMENULOOP    0x0211
#define WM_EXITMENULOOP     0x0212
#define WM_NEXTMENU     0x0213
#define WM_DROPOBJECT       0x022A
#define WM_QUERYDROPOBJECT  0x022B
#define WM_BEGINDRAG        0x022C
#define WM_DRAGLOOP     0x022D
#define WM_DRAGSELECT       0x022E
#define WM_DRAGMOVE     0x022F
#define WM_ENTERSIZEMOVE    0x0231
#define WM_EXITSIZEMOVE     0x0232


/* Old window messages (changed from Win 3.x)
 */
#ifndef WM_USER
#define WM_USER 0x0400
#endif

#define OLDEM_GETSEL            (WM_USER+0)
#define OLDEM_SETSEL            (WM_USER+1)
#define OLDEM_GETRECT           (WM_USER+2)
#define OLDEM_SETRECT           (WM_USER+3)
#define OLDEM_SETRECTNP         (WM_USER+4)
#define OLDEM_SCROLL            (WM_USER+5)
#define OLDEM_LINESCROLL        (WM_USER+6)
#define OLDEM_GETMODIFY         (WM_USER+8)
#define OLDEM_SETMODIFY         (WM_USER+9)
#define OLDEM_GETLINECOUNT      (WM_USER+10)
#define OLDEM_LINEINDEX         (WM_USER+11)
#define OLDEM_SETHANDLE         (WM_USER+12)
#define OLDEM_GETHANDLE         (WM_USER+13)
#define OLDEM_GETTHUMB          (WM_USER+14)
#define OLDEM_LINELENGTH        (WM_USER+17)
#define OLDEM_REPLACESEL        (WM_USER+18)
#define OLDEM_SETFONT           (WM_USER+19)
#define OLDEM_GETLINE           (WM_USER+20)
#define OLDEM_LIMITTEXT         (WM_USER+21)
#define OLDEM_CANUNDO           (WM_USER+22)
#define OLDEM_UNDO          (WM_USER+23)
#define OLDEM_FMTLINES          (WM_USER+24)
#define OLDEM_LINEFROMCHAR      (WM_USER+25)
#define OLDEM_SETWORDBREAK      (WM_USER+26)
#define OLDEM_SETTABSTOPS       (WM_USER+27)
#define OLDEM_SETPASSWORDCHAR       (WM_USER+28)
#define OLDEM_EMPTYUNDOBUFFER       (WM_USER+29)
#ifndef WIN31
#define OLDEM_MSGMAX            (WM_USER+30)
#else
#define OLDEM_GETFIRSTVISIBLELINE (WM_USER+30)
#define OLDEM_SETREADONLY       (WM_USER+31)
#define OLDEM_SETWORDBREAKPROC  (WM_USER+32)
#define OLDEM_GETWORDBREAKPROC  (WM_USER+33)
#define OLDEM_GETPASSWORDCHAR   (WM_USER+34)
#define OLDEM_MSGMAX            (WM_USER+35)
#endif

#define OLDBM_GETCHECK          (WM_USER+0)
#define OLDBM_SETCHECK          (WM_USER+1)
#define OLDBM_GETSTATE          (WM_USER+2)
#define OLDBM_SETSTATE          (WM_USER+3)
#define OLDBM_SETSTYLE          (WM_USER+4)

#define OLDCB_GETEDITSEL        (WM_USER+0)
#define OLDCB_LIMITTEXT         (WM_USER+1)
#define OLDCB_SETEDITSEL        (WM_USER+2)
#define OLDCB_ADDSTRING         (WM_USER+3)
#define OLDCB_DELETESTRING      (WM_USER+4)
#define OLDCB_DIR           (WM_USER+5)
#define OLDCB_GETCOUNT          (WM_USER+6)
#define OLDCB_GETCURSEL         (WM_USER+7)
#define OLDCB_GETLBTEXT         (WM_USER+8)
#define OLDCB_GETLBTEXTLEN      (WM_USER+9)
#define OLDCB_INSERTSTRING      (WM_USER+10)
#define OLDCB_RESETCONTENT      (WM_USER+11)
#define OLDCB_FINDSTRING        (WM_USER+12)
#define OLDCB_SELECTSTRING      (WM_USER+13)
#define OLDCB_SETCURSEL         (WM_USER+14)
#define OLDCB_SHOWDROPDOWN      (WM_USER+15)
#define OLDCB_GETITEMDATA       (WM_USER+16)
#define OLDCB_SETITEMDATA       (WM_USER+17)
#define OLDCB_GETDROPPEDCONTROLRECT (WM_USER+18)
#ifndef WIN31
#define OLDCB_MSGMAX            (WM_USER+19)
#else
#define OLDCB_SETITEMHEIGHT     (WM_USER+19)
#define OLDCB_GETITEMHEIGHT     (WM_USER+20)
#define OLDCB_SETEXTENDEDUI     (WM_USER+21)
#define OLDCB_GETEXTENDEDUI     (WM_USER+22)
#define OLDCB_GETDROPPEDSTATE   (WM_USER+23)
#define OLDCB_FINDSTRINGEXACT   (WM_USER+24)
#define OLDCB_MSGMAX            (WM_USER+25)    /* ;Internal */
#define OLDCBEC_SETCOMBOFOCUS   (WM_USER+26)    /* ;Internal */
#define OLDCBEC_KILLCOMBOFOCUS  (WM_USER+27)    /* ;Internal */
#endif

#define OLDLB_ADDSTRING         (WM_USER+1)
#define OLDLB_INSERTSTRING      (WM_USER+2)
#define OLDLB_DELETESTRING      (WM_USER+3)
#define OLDLB_RESETCONTENT      (WM_USER+5)
#define OLDLB_SETSEL            (WM_USER+6)
#define OLDLB_SETCURSEL         (WM_USER+7)
#define OLDLB_GETSEL            (WM_USER+8)
#define OLDLB_GETCURSEL         (WM_USER+9)
#define OLDLB_GETTEXT           (WM_USER+10)
#define OLDLB_GETTEXTLEN        (WM_USER+11)
#define OLDLB_GETCOUNT          (WM_USER+12)
#define OLDLB_SELECTSTRING      (WM_USER+13)
#define OLDLB_DIR           (WM_USER+14)
#define OLDLB_GETTOPINDEX       (WM_USER+15)
#define OLDLB_FINDSTRING        (WM_USER+16)
#define OLDLB_GETSELCOUNT       (WM_USER+17)
#define OLDLB_GETSELITEMS       (WM_USER+18)
#define OLDLB_SETTABSTOPS       (WM_USER+19)
#define OLDLB_GETHORIZONTALEXTENT   (WM_USER+20)
#define OLDLB_SETHORIZONTALEXTENT   (WM_USER+21)
#define OLDLB_SETCOLUMNWIDTH        (WM_USER+22)
#define OLDLB_ADDFILE           (WM_USER+23)    /* ;Internal */
#define OLDLB_SETTOPINDEX       (WM_USER+24)
#define OLDLB_GETITEMRECT       (WM_USER+25)
#define OLDLB_GETITEMDATA       (WM_USER+26)
#define OLDLB_SETITEMDATA       (WM_USER+27)
#define OLDLB_SELITEMRANGE      (WM_USER+28)
#define OLDLB_SETANCHORINDEX        (WM_USER+29)    /* ;Internal */
#define OLDLB_GETANCHORINDEX        (WM_USER+30)    /* ;Internal */
#ifndef WIN31
#define OLDLB_MSGMAX            (WM_USER+33)
#else
#define OLDLB_SETCARETINDEX     (WM_USER+31)
#define OLDLB_GETCARETINDEX     (WM_USER+32)
#define OLDLB_SETITEMHEIGHT     (WM_USER+33)
#define OLDLB_GETITEMHEIGHT     (WM_USER+34)
#define OLDLB_FINDSTRINGEXACT   (WM_USER+35)
#define OLDLBCB_CARETON         (WM_USER+36)     /* ;Internal */
#define OLDLBCB_CARETOFF        (WM_USER+37)     /* ;Internal */
#define OLDLB_MSGMAX            (WM_USER+38)     /* ;Internal */
#endif

#define OLDSBM_SETPOS           (WM_USER+0)
#define OLDSBM_GETPOS           (WM_USER+1)
#define OLDSBM_SETRANGE         (WM_USER+2)
#define OLDSBM_GETRANGE         (WM_USER+3)
#define OLDSBM_ENABLEARROWS     (WM_USER+4)

/* WOW Return IDs - Ordering must match wow16cal.asm table
 */
#define RET_RETURN       0  // return to app

#define RET_DEBUGRETURN      1  // return to app after breakpoint

#define RET_DEBUG        2  // execute breakpoint, return to WOW

#define RET_WNDPROC      3  // IN:all
                // OUT:DX:AX=wndproc return code

#define RET_ENUMFONTPROC     4  // IN:all
                // OUT:DX:AX=wndproc return code

#define RET_ENUMWINDOWPROC   5  // IN:all
                // OUT:DX:AX=wndproc return code

#define RET_LOCALALLOC       6  // IN:wParam=wFlags, lParam=wBytes
                // OUT:AX=hMem (zero if error)

#define RET_LOCALREALLOC     7  // IN:wMsg=hMem, wParam=wFlags, lParam=wBytes
                // OUT:AX=hMem (zero if error)

#define RET_LOCALLOCK        8  // IN:wParam=hMem
                // OUT:DX:AX=address (zero if error), CX=size

#define RET_LOCALUNLOCK      9  // IN:wParam=hMem
                // OUT:AX=TRUE (FALSE if error)

#define RET_LOCALSIZE        10 // IN:wParam=hMem
                // OUT:AX=size (zero if error)

#define RET_LOCALFREE        11 // IN:wParam=hMem
                // OUT:AX=TRUE (FALSE if error)

#define RET_GLOBALALLOCLOCK  12 // IN:wParam=wFlags, lParam=dwBytes
                // OUT:DX:AX=address (zero if error), BX=hMem

#define RET_GLOBALLOCK       13 // IN:wParam=hMem
                // OUT:DX:AX=address (zero if error), CX=size

#define RET_GLOBALUNLOCK     14 // IN:wParam=hMem
                // OUT:AX=TRUE (FALSE if error)

#define RET_GLOBALUNLOCKFREE 15 // IN:lParam=address
                // OUT:AX=TRUE (FALSE if error)

#define RET_FINDRESOURCE     16 // IN:wParam=hTask, lParam=vpName, hwnd/wMsg=vpType
                // OUT:AX=hResInfo (zero if not found)

#define RET_LOADRESOURCE     17 // IN:wParam=hTask, lParam=hResInfo
                // OUT:AX=hResData

#define RET_FREERESOURCE     18 // IN:wParam=hResData
                // OUT:AX=TRUE (zero if failed)

#define RET_LOCKRESOURCE     19 // IN:wParam=hResData
                // OUT:DX:AX=address (zero if error), CX=size

#define RET_UNLOCKRESOURCE   20 // IN:wParam=hResData
                // OUT:AX=TRUE (zero if resource still locked)

#define RET_SIZEOFRESOURCE   21 // IN:wParam=hTask, lParam=hResInfo
                // OUT:DX:AX=size (zero if error)

#define RET_LOCKSEGMENT      22 // IN:wParam=wSeg
                // OUT:AX=TRUE (FALSE if error)

#define RET_UNLOCKSEGMENT    23 // IN:wParam=wSeg
                // OUT:AX=TRUE (zero if segment still locked)

#define RET_ENUMMETAFILEPROC 24 // IN:all
                                // OUT:DX:AX=wndproc return cod

#define RET_TASKSTARTED      25 // None

#define RET_HOOKPROC         26 // IN:all
                                // OUT:DX:AX=hookproc return code

#define RET_SUBCLASSPROC     27 // IN:None
                // OUT: DX:AX=thunkproc return code
#define RET_LINEDDAPROC      28

#define RET_GRAYSTRINGPROC   29

#define RET_FORCETASKEXIT    30 // IN:None
            // OUT: Does not return

#define RET_SETCURDIR        31 // IN:Current Dir
            // OUT: ax
#define RET_ENUMOBJPROC     32  // IN:all
        // OUT:DX:AX=wndproc return code

#define RET_SETCURSORICONFLAG        33 // IN: none

#define RET_SETABORTPROC    34

#define RET_ENUMPROPSPROC   35

#define RET_FORCESEGMENTFAULT 36 //  Make a segment present

#define RET_LSTRCMP          37 // for user32 listbox code

                                //  38 FREE
                                //  39 FREE
                                //  40 FREE
                                //  41 FREE

#define RET_GETEXEPTR        42 // Call KRNL286:GetExePtr

                                //  43 FREE

#define RET_FORCETASKFAULT   44 // Force a Fault
#define RET_GETEXPWINVER     45 // Call KRNL286:GetExpWinVer
#define RET_GETCURDIR        46 //

#define RET_GETDOSPDB        47 // IN:  nothing
                                // OUT: DX:AX = DOS Win_PDB
#define RET_GETDOSSFT        48 // IN:  nothing
                                // OUT: DX:AX = DOS SFT (pFileTable)
#define RET_FOREGROUNDIDLE   49 // IN:  nothing
                                // OUT: NOTHING
#define RET_WINSOCKBLOCKHOOK 50 // IN:  nothing
                                // OUT: DX:AX = BOOL ret value
#define RET_WOWDDEFREEHANDLE 51

#define RET_CHANGESELECTOR   52 // IN: wParam = Segment

#define RET_GETMODULEFILENAME 53 // IN: wParam = hInst, lParam = 16:16 Buffer
                                 //     wMsg = cbBuffer
                                 // OUT: AX = length of returned modulename

#define RET_SETWORDBREAKPROC 54 //

#define RET_WINEXEC          55

#define RET_WOWCALLBACK16    56 // Used by public WOWCallback16 routine

#define RET_GETDIBSIZE       57

#define RET_GETDIBFLAGS      58

#define RET_SETDIBSEL        59

#define RET_FREEDIBSEL       60

#ifdef FE_SB
#define RET_SETFNOTEPAD      61 // sync GetModuleUsage16 API for Lotus FLW
#define RET_MAX              61
#else // !FE_SB
#define RET_MAX              60
#endif // !FE_SB




/* Module IDs
 *
 * Module IDs are OR'ed with API IDs to produce Call IDs
 */
#define MOD_MASK        0xF000
#define FUN_MASK        0x0FFF

#define MOD_KERNEL   0x0000
#define MOD_DKERNEL  0X0000   // for parameter validation layer
#define MOD_USER     0x1000   //
#define MOD_DUSER    0x1000   // for parameter validation layer
#define MOD_GDI      0x2000   //
#define MOD_DGDI     0x2000   // for parameter validation layer
#define MOD_KEYBOARD 0x3000
#define MOD_SOUND    0x4000
#define MOD_SHELL    0x5000   // SHELL APIs
#define MOD_WINSOCK  0x6000
#define MOD_TOOLHELP 0x7000
#define MOD_MMEDIA   0x8000
#define MOD_COMMDLG  0x9000
#ifdef FE_SB
#define MOD_WINNLS   0xA000
#define MOD_WIFEMAN  0xB000
#define MOD_LAST     0xC000   // Add New Module ID before this one
#else // !FE_SB
#define MOD_LAST     0xA000   // Add New Module ID before this one
#endif // !FE_SB


/* Special Function IDs
 *
 * This is used by WIN16 whenever we are returning from a window proc;
 * see the various include files (wowkrn.h, wowgdi.h, etc) for all the other
 * function IDs.
 */
#define FUN_RETURN      0

/*
 * hiword of wcallID in VDMFRAME -
 */

#define HI_WCALLID     0x0000

/* Macros for WOW16 DLLs
 *
 * Note for GDIThunk args is the metafile function number
 * and val denotes if function has a DC
 *
 */

/* ASM
Thunk       macro   mod,func,callfirst,args,val,emptybuf
    ifidni  <args>,<abs>
    public func
    ifb    <val>
        func = 0
    else
        func = val
    endif
    else
    externA  __MOD_KERNEL
    externA  __MOD_DKERNEL
    externA  __MOD_USER
    externA  __MOD_DUSER
    externA  __MOD_GDI
    externA  __MOD_DGDI
    externA  __MOD_KEYBOARD
    externA  __MOD_SOUND
    externA  __MOD_SHELL
    externA  __MOD_WINSOCK
    externA  __MOD_TOOLHELP
    externA  __MOD_MMEDIA
    externA  __MOD_COMMDLG
ifdef FE_SB
    externA  __MOD_WINNLS
    externA  __MOD_WIFEMAN
endif ; FE_SB



    ifidni <mod>,<USER>
        cProc I&func,<PUBLIC,FAR,PASCAL,NODATA,WIN>

        cBegin <nogen>
    else
        ifidni <mod>,<GDI>
        cProc I&func,<PUBLIC,FAR,PASCAL,NODATA,WIN>

        cBegin <nogen>
        else
        ifidni <mod>,<KERNEL>
            cProc I&func,<PUBLIC,FAR,PASCAL,NODATA,WIN>

            cBegin <nogen>
        else
            cProc func,<PUBLIC,FAR,PASCAL,NODATA,WIN>

            cBegin <nogen>
        endif
        endif
    endif

    ; Make the passed in buffer into an empty string by writing null
    ; to the first position. Win 3.1 IGetWindowText does this, and
    ; WinFax Pro depends on this behaviour.
    ifnb   <emptybuf>
        push    bp
        mov     bp, sp
        mov     bx, [bp+8]
        mov     es, [bp+0Ah]
        mov     byte ptr es:[bx], 0
        pop     bp
    endif

    ifdifi <callfirst>,<0>
    call    callfirst
    endif

    ifnb   <args>
        push    args
    else
        ifdef func&16
        push    size func&16
        else
        if1
            %out     Warning: assuming null arg frame for &mod:&func
        endif
        push  0
        endif
    endif
        t_&func:


            push    word ptr HI_WCALLID
            push    __MOD_&mod + FUN_&func
            call   WOW16Call

        ; assert that this is constant size code. 5bytes for 'call wow16call'
        ; and 3bytes each for the 'push ...'. We use this info in wow32
        ; to patchcodewithlpfnw32.

        .erre (($ - t_&func) EQ (05h + 03h + 03h))

    cEnd <nogen>
    endif
endm

KernelThunk macro func,args,val
    Thunk   KERNEL,func,0,args,val
endm

DKernelThunk macro func,args,val
    Thunk   DKERNEL,func,0,args,val
endm

PKernelThunk macro func,callfirst,args,val
    Thunk   KERNEL,func,callfirst,args,val
endm

UserThunk   macro func,args,val
    Thunk   USER,func,0,args,val
endm

DUserThunk  macro func,args,val
    Thunk   DUSER,func,0,args,val
endm

PUserThunk  macro func,callfirst,args,val
    Thunk   USER,func,callfirst,args,val
endm

PDUserThunk  macro func,callfirst,args,val
    Thunk   DUSER,func,callfirst,args,val
endm

EUserThunk  macro func,args,val
    Thunk   USER,func,0,args,val,0
endm

GDIThunk    macro func,args,val
    Thunk   GDI,func,0,args,val
endm

DGDIThunk   macro func,args,val
    Thunk   DGDI,func,0,args,val
endm

PGDIThunk   macro func,callfirst,args,val
    Thunk   GDI,func,callfirst,args,val
endm

KbdThunk    macro func,args,val
    Thunk   KEYBOARD,func,0,args,val
endm

SoundThunk  macro func,args,val
    Thunk   SOUND,func,0,args,val
endm

SHELLThunk  macro func,args,val
    Thunk   SHELL,func,0,args,val
endm

MMediaThunk macro func,args,val
    Thunk   MMEDIA,func,0,args,val
endm

WinsockThunk macro func,args,val
    Thunk   WINSOCK,func,0,args,val
endm

ToolHelpThunk macro func,args,val
    Thunk   TOOLHELP,func,0,args,val
endm

CommdlgThunk macro func,args,val
    Thunk   COMMDLG,func,SetWowCommDlg,args,val
endm

ifdef FE_SB
WINNLSThunk macro func,args,val
    Thunk   WINNLS,func,0,args,val
endm

WifeManThunk macro func,args,val
    Thunk   WIFEMAN,func,0,args,val
endm
endif ; FE_SB

 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowcmdlg.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1993, Microsoft Corporation
 *
 *  WOWCMDLG.H
 *  16-bit Commdlg API argument structures
 *
 *  History:
 *      John Vert (jvert) 30-Dec-1992
 *          Created
--*/

//#include <windows.h>
//#include <winsock.h>

/* XLATOFF */
#pragma pack(2)
/* XLATON */

/*++
 *
 * Commdlg data structures
 *
--*/

typedef struct _FINDREPLACE16 {                         /* fr16 */
    DWORD   lStructSize;
    HWND16  hwndOwner;
    HAND16  hInstance;
    DWORD   Flags;
    VPSZ    lpstrFindWhat;
    VPSZ    lpstrReplaceWith;
    WORD    wFindWhatLen;
    WORD    wReplaceWithLen;
    LONG    lCustData;
    VPPROC  lpfnHook;
    VPCSTR  lpTemplateName;
} FINDREPLACE16;
typedef FINDREPLACE16 UNALIGNED *PFINDREPLACE16;
typedef VPVOID VPFINDREPLACE;

typedef struct _OPENFILENAME16 {                        /* of16 */
    DWORD   lStructSize;
    HWND16  hwndOwner;
    HAND16  hInstance;
    VPCSTR  lpstrFilter;
    VPSZ    lpstrCustomFilter;
    DWORD   nMaxCustFilter;
    DWORD   nFilterIndex;
    VPSZ    lpstrFile;
    DWORD   nMaxFile;
    VPSZ    lpstrFileTitle;
    DWORD   nMaxFileTitle;
    VPCSTR  lpstrInitialDir;
    VPCSTR  lpstrTitle;
    DWORD   Flags;
    USHORT  nFileOffset;
    USHORT  nFileExtension;
    VPCSTR  lpstrDefExt;
    LONG    lCustData;
    VPPROC  lpfnHook;
    VPCSTR  lpTemplateName;
} OPENFILENAME16;
typedef OPENFILENAME16 UNALIGNED *POPENFILENAME16;
typedef VPVOID VPOPENFILENAME;

typedef struct _CHOOSECOLORDATA16 {                     /* cc16 */
    DWORD   lStructSize;
    HWND16  hwndOwner;
    HAND16  hInstance;
    DWORD   rgbResult;
    VPDWORD lpCustColors;
    DWORD   Flags;
    LONG    lCustData;
    VPPROC  lpfnHook;
    VPCSTR  lpTemplateName;
} CHOOSECOLORDATA16;
typedef CHOOSECOLORDATA16 UNALIGNED *PCHOOSECOLORDATA16;
typedef VPVOID VPCHOOSECOLORDATA;

typedef struct _CHOOSEFONTDATA16 {                      /* cf16 */
    DWORD   lStructSize;
    HWND16  hwndOwner;
    HDC16   hDC;
    VPLOGFONT16 lpLogFont;
    SHORT   iPointSize;
    DWORD   Flags;
    DWORD   rgbColors;
    LONG    lCustData;
    VPPROC  lpfnHook;
    VPCSTR  lpTemplateName;
    HAND16  hInstance;
    VPSZ    lpszStyle;
    WORD    nFontType;
    SHORT   nSizeMin;
    SHORT   nSizeMax;
} CHOOSEFONTDATA16;
typedef CHOOSEFONTDATA16 UNALIGNED *PCHOOSEFONTDATA16;
typedef VPVOID VPCHOOSEFONTDATA;

typedef struct _PRINTDLGDATA16 {                        /* pd16 */
    DWORD   lStructSize;
    HWND16  hwndOwner;
    HAND16  hDevMode;
    HAND16  hDevNames;
    HDC16   hDC;
    DWORD   Flags;
    WORD    nFromPage;
    WORD    nToPage;
    WORD    nMinPage;
    WORD    nMaxPage;
    WORD    nCopies;
    HAND16  hInstance;
    LONG    lCustData;
    VPPROC  lpfnPrintHook;
    VPPROC  lpfnSetupHook;
    VPCSTR  lpPrintTemplateName;
    VPCSTR  lpSetupTemplateName;
    HAND16  hPrintTemplate;
    HAND16  hSetupTemplate;
} PRINTDLGDATA16;
typedef PRINTDLGDATA16 UNALIGNED *PPRINTDLGDATA16;
typedef VPVOID VPPRINTDLGDATA;

typedef struct _DEVNAMES16 {                            /* dn16 */
    WORD    wDriverOffset;
    WORD    wDeviceOffset;
    WORD    wOutputOffset;
    WORD    wDefault;
} DEVNAMES16;
typedef DEVNAMES16 UNALIGNED *PDEVNAMES16;
typedef VPVOID VPDEVNAMES;

/*++
 *
 * Commdlg API IDs (equal to ordinal numbers)
 *
--*/
#define FUN_GETOPENFILENAME         1
#define FUN_GETSAVEFILENAME         2
#define FUN_CHOOSECOLOR             5
#define FUN_FINDTEXT                11
#define FUN_REPLACETEXT             12
#define FUN_CHOOSEFONT              15
#define FUN_PRINTDLG                20
#define FUN_WOWCOMMDLGEXTENDEDERROR 26
#define FUN_GETFILETITLE            27


/*++

  Commdlg function prototypes - the seemingly unimportant number in the
  comment on each function MUST match the ones in the list above!!!

  !! BE WARNED !!

--*/

typedef struct _GETOPENFILENAME16 {                 /* cd1  */
    VPOPENFILENAME lpof;
} GETOPENFILENAME16;
typedef GETOPENFILENAME16 UNALIGNED *PGETOPENFILENAME16;

typedef struct _GETSAVEFILENAME16 {                 /* cd2  */
    VPOPENFILENAME lpcf;
} GETSAVEFILENAME16;
typedef GETSAVEFILENAME16 UNALIGNED *PGETSAVEFILENAME16;

typedef struct _CHOOSECOLOR16 {                     /* cd5  */
    VPCHOOSECOLORDATA lpcc;
} CHOOSECOLOR16;
typedef CHOOSECOLOR16 UNALIGNED *PCHOOSECOLOR16;

typedef struct _FINDTEXT16 {                        /* cd11 */
    VPFINDREPLACE lpfr;
} FINDTEXT16;
typedef FINDTEXT16 UNALIGNED *PFINDTEXT16;

typedef struct _REPLACETEXT16 {                       /* cd12 */
    VPFINDREPLACE lpfr;
} REPLACETEXT16;
typedef REPLACETEXT16 UNALIGNED *PREPLACETEXT16;

typedef struct _CHOOSEFONT16 {                      /* cd15 */
    VPCHOOSEFONTDATA lpcf;
} CHOOSEFONT16;
typedef CHOOSEFONT16 UNALIGNED *PCHOOSEFONT16;

typedef struct _PRINTDLG16 {                          /* cd20 */
    VPPRINTDLGDATA lppd;
} PRINTDLG16;
typedef PRINTDLG16 UNALIGNED *PPRINTDLG16;

/* XLATOFF */
#pragma pack()
/* XLATON */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowexp.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWEXP.H
 *  WOW32 exports
 *
 *  History:
 *  10-May-1991 Jeff Parsons (jeffpar)
 *  Created.
--*/

extern VOID FAR PASCAL W32Dispatch(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowddeml.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWDDEML.H
 *  16-bit DDEML API argument structures
 *
 *  History:
 *  Created 28-Dec-1992 by Chandan S. Chauhan (ChandanC)
 *
--*/

/* DDEML API IDs
 */
#define FUN_DDEINITIALIZE                   2
#define FUN_DDEUNINITIALIZE                 3
#define FUN_DDECONNECTLIST                  4
#define FUN_DDEQUERYNEXTSERVER              5
#define FUN_DDEDISCONNECTLIST               6
#define FUN_DDECONNECT                      7
#define FUN_DDEDISCONNECT                   8
#define FUN_DDEQUERYCONVINFO                9
#define FUN_DDESETUSERHANDLE                10
#define FUN_DDECLIENTTRANSACTION            11
#define FUN_DDEABANDONTRANSACTION           12
#define FUN_DDEPOSTADVISE                   13
#define FUN_DDECREATEDATAHANDLE             14
#define FUN_DDEADDDATA                      15
#define FUN_DDEGETDATA                      16
#define FUN_DDEACCESSDATA                   17
#define FUN_DDEUNACCESSDATA                 18
#define FUN_DDEFREEDATAHANDLE               19
#define FUN_DDEGETLASTERROR                 20
#define FUN_DDECREATESTRINGHANDLE           21
#define FUN_DDEFREESTRINGHANDLE             22
#define FUN_DDEQUERYSTRING                  23
#define FUN_DDEKEEPSTRINGHANDLE             24

#define FUN_DDEENABLECALLBACK               26
#define FUN_DDENAMESERVICE                  27

#define FUN_CLIENTWNDPROC                   28   ;Internal
#define FUN_SERVERWNDPROC                   29   ;Internal
#define FUN_SUBFRAMEWNDPROC                 30   ;Internal
#define FUN_DMGWNDPROC                      31   ;Internal
#define FUN_CONVLISTWNDPROC                 32   ;Internal
#define FUN_MONITORWNDPROC                  33   ;Internal
#define FUN_DDESENDHOOKPROC                 34   ;Internal
#define FUN_DDEPOSTHOOKPROC                 35   ;Internal

#define FUN_DDECMPSTRINGHANDLES             36
#define FUN_DDERECONNECT                    37

#define FUN_INITENUM                        38   ;Internal
#define FUN_TERMDLGPROC                     39   ;Internal
#define FUN_EmptyQTimerProc                 40   ;Internal


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _CONVCONTEXT16 {        /* di2 */
    WORD   cb;
    WORD   wFlags;
    WORD   wCountryID;
    INT16  iCodePage;
    DWORD  dwLangID;
    DWORD  dwSecurity;
} CONVCONTEXT16;
typedef CONVCONTEXT16 UNALIGNED *PCONVCONTEXT16;
typedef VPVOID VPCONVCONTEXT16;

typedef struct _DDEINITIALIZE16 {         /* d2 */
    DWORD   f4;
    DWORD   f3;
    VPVOID  f2;
    VPVOID  f1;
} DDEINITIALIZE16;
typedef DDEINITIALIZE16 UNALIGNED *PDDEINITIALIZE16;

typedef struct _DDEUNINITIALIZE16 {       /* d3 */
    DWORD   f1;
} DDEUNINITIALIZE16;
typedef DDEUNINITIALIZE16 UNALIGNED *PDDEUNINITIALIZE16;

typedef struct _DDECONNECTLIST16 {        /* d4 */
    VPVOID  f5;
    DWORD   f4;
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDECONNECTLIST16;
typedef DDECONNECTLIST16 UNALIGNED *PDDECONNECTLIST16;

typedef struct _DDEQUERYNEXTSERVER16 {    /* d5 */
    DWORD   f2;
    DWORD   f1;
} DDEQUERYNEXTSERVER16;
typedef DDEQUERYNEXTSERVER16 UNALIGNED *PDDEQUERYNEXTSERVER16;

typedef struct _DDEDISCONNECTLIST16 {    /* d6 */
    DWORD   f1;
} DDEDISCONNECTLIST16;
typedef DDEDISCONNECTLIST16 UNALIGNED *PDDEDISCONNECTLIST16;

typedef struct _DDECONNECT16 {           /* d7 */
    VPVOID  f4;
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDECONNECT16;
typedef DDECONNECT16 UNALIGNED *PDDECONNECT16;

typedef struct _DDEDISCONNECT16 {        /* d8 */
    DWORD   f1;
} DDEDISCONNECT16;
typedef DDEDISCONNECT16 UNALIGNED *PDDEDISCONNECT16;

typedef struct _DDEQUERYCONVINFO16 {     /* d9 */
    VPVOID  f3;
    DWORD   f2;
    DWORD   f1;
} DDEQUERYCONVINFO16;
typedef DDEQUERYCONVINFO16 UNALIGNED *PDDEQUERYCONVINFO16;

typedef struct _DDESETUSERHANDLE16 {     /* d10 */
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDESETUSERHANDLE16;
typedef DDESETUSERHANDLE16 UNALIGNED *PDDESETUSERHANDLE16;

typedef struct _DDECLIENTTRANSACTION16 {     /* d11 */
    VPVOID  f8;
    DWORD   f7;
    WORD    f6;
    WORD    f5;
    DWORD   f4;
    DWORD   f3;
    DWORD   f2;
    VPVOID  f1;
} DDECLIENTTRANSACTION16;
typedef DDECLIENTTRANSACTION16 UNALIGNED *PDDECLIENTTRANSACTION16;

typedef struct _DDEABANDONTRANSACTION16 {     /* d12 */
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDEABANDONTRANSACTION16;
typedef DDEABANDONTRANSACTION16 UNALIGNED *PDDEABANDONTRANSACTION16;

typedef struct _DDEPOSTADVISE16 {             /* d13 */
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDEPOSTADVISE16;
typedef DDEPOSTADVISE16 UNALIGNED *PDDEPOSTADVISE16;

typedef struct _DDECREATEDATAHANDLE16 {       /* d14 */
    WORD    f7;
    WORD    f6;
    DWORD   f5;
    DWORD   f4;
    DWORD   f3;
    VPVOID  f2;
    DWORD   f1;
} DDECREATEDATAHANDLE16;
typedef DDECREATEDATAHANDLE16 UNALIGNED *PDDECREATEDATAHANDLE16;

typedef struct _DDEADDDATA16 {                /* d15 */
    DWORD   f4;
    DWORD   f3;
    VPVOID  f2;
    DWORD  f1;
} DDEADDDATA16;
typedef DDEADDDATA16 UNALIGNED *PDDEADDDATA16;

typedef struct _DDEGETDATA16 {                /* d16 */
    DWORD   f4;
    DWORD   f3;
    VPVOID  f2;
    DWORD   f1;
} DDEGETDATA16;
typedef DDEGETDATA16 UNALIGNED *PDDEGETDATA16;

typedef struct _DDEACCESSDATA16 {             /* d17 */
    VPVOID  f2;
    DWORD   f1;
} DDEACCESSDATA16;
typedef DDEACCESSDATA16 UNALIGNED *PDDEACCESSDATA16;

typedef struct _DDEUNACCESSDATA16 {           /* d18 */
    DWORD   f1;
} DDEUNACCESSDATA16;
typedef DDEUNACCESSDATA16 UNALIGNED *PDDEUNACCESSDATA16;

typedef struct _DDEFREEDATAHANDLE16 {         /* d19 */
    DWORD   f1;
} DDEFREEDATAHANDLE16;
typedef DDEFREEDATAHANDLE16 UNALIGNED *PDDEFREEDATAHANDLE16;

typedef struct _DDEGETLASTERROR16 {           /* d20 */
    DWORD   f1;
} DDEGETLASTERROR16;
typedef DDEGETLASTERROR16 UNALIGNED *PDDEGETLASTERROR16;

typedef struct _DDECREATESTRINGHANDLE16 {     /* d21 */
    INT16   f3;
    VPVOID  f2;
    DWORD   f1;
} DDECREATESTRINGHANDLE16;
typedef DDECREATESTRINGHANDLE16 UNALIGNED *PDDECREATESTRINGHANDLE16;

typedef struct _DDEFREESTRINGHANDLE16 {       /* d22 */
    DWORD   f2;
    DWORD   f1;
} DDEFREESTRINGHANDLE16;
typedef DDEFREESTRINGHANDLE16 UNALIGNED *PDDEFREESTRINGHANDLE16;

typedef struct _DDEQUERYSTRING16 {            /* d23 */
    INT16   f5;
    DWORD   f4;
    VPVOID  f3;
    DWORD   f2;
    DWORD   f1;
} DDEQUERYSTRING16;
typedef DDEQUERYSTRING16 UNALIGNED *PDDEQUERYSTRING16;

typedef struct _DDEKEEPSTRINGHANDLE16 {       /* d24 */
    DWORD   f2;
    DWORD   f1;
} DDEKEEPSTRINGHANDLE16;
typedef DDEKEEPSTRINGHANDLE16 UNALIGNED *PDDEKEEPSTRINGHANDLE16;

typedef struct _DDEENABLECALLBACK16 {         /* d26 */
    WORD    f3;
    DWORD   f2;
    DWORD   f1;
} DDEENABLECALLBACK16;
typedef DDEENABLECALLBACK16 UNALIGNED *PDDEENABLECALLBACK16;

typedef struct _DDENAMESERVICE16 {            /* d27 */
    WORD    f4;
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDENAMESERVICE16;
typedef DDENAMESERVICE16 UNALIGNED *PDDENAMESERVICE16;

typedef struct _DDECMPSTRINGHANDLES16 {       /* d36 */
    DWORD   f2;
    DWORD   f1;
} DDECMPSTRINGHANDLES16;
typedef DDECMPSTRINGHANDLES16 UNALIGNED *PDDECMPSTRINGHANDLES16;

typedef struct _DDERECONNECT16 {              /* d37 */
    DWORD   f1;
} DDERECONNECT16;
typedef DDERECONNECT16 UNALIGNED *PDDERECONNECT16;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowfax.h ===
//****************************************************************************
// WOW fax support. Common file. Conditionally shared between wow16, wow32,
// wowfax and wowfaxui
//
// 16bit structures are share between wow16 and wow32 only. Though they get
// included while compiling 32bit printdrivers wowfax and wowfaxui, yet they
// are incorrect and inaccessible from those dlls.
//
//
// History:
//    02-jan-95   nandurir   created.
//    01-feb-95   reedb      Clean-up, support printer install and bug fixes.
//
//****************************************************************************

//***************************************************************************
// WM_DDRV_ defines  - Common to wowexec,wow32,wowfax,wowfaxui. If you add
//                     a message, be sure to add it to the debug strings also.
//***************************************************************************

#define WM_DDRV_FIRST              (WM_USER+0x100+1) // begin DDRV range
#define WM_DDRV_LOAD               (WM_USER+0x100+1)
#define WM_DDRV_ENABLE             (WM_USER+0x100+2)
#define WM_DDRV_STARTDOC           (WM_USER+0x100+3)
#define WM_DDRV_PRINTPAGE          (WM_USER+0x100+4)
#define WM_DDRV_ESCAPE             (WM_USER+0x100+5)
#define WM_DDRV_DISABLE            (WM_USER+0x100+6)
#define WM_DDRV_INITFAXINFO16      (WM_USER+0x100+7)
#define WM_DDRV_ENDDOC             (WM_USER+0x100+8)
#define WM_DDRV_SUBCLASS           (WM_USER+0x100+9)
#define WM_DDRV_EXTDMODE           (WM_USER+0x100+10)
#define WM_DDRV_DEVCAPS            (WM_USER+0x100+11)
#define WM_DDRV_FREEFAXINFO16      (WM_USER+0x100+12)
#define WM_DDRV_UNLOAD             (WM_USER+0x100+20)
#define WM_DDRV_LAST               (WM_USER+0x100+20) // end DDRV range

#define CCHDOCNAME 128

#ifdef DEBUG
#ifdef DEFINE_DDRV_DEBUG_STRINGS
char *szWmDdrvDebugStrings[] =
{
    "WM_DDRV_LOAD",
    "WM_DDRV_ENABLE",
    "WM_DDRV_STARTDOC",
    "WM_DDRV_PRINTPAGE",
    "WM_DDRV_ESCAPE",
    "WM_DDRV_DISABLE",
    "WM_DDRV_INITFAXINFO16",
    "WM_DDRV_ENDDOC",
    "WM_DDRV_SUBCLASS",
    "WM_DDRV_EXTDMODE",
    "WM_DDRV_DEVCAPS",
    "WM_DDRV_FREEFAXINFO16",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "WM_DDRV_UNLOAD"
};
#endif
#endif // #define(DEBUG)

// WOWFAX component file names. Unicode and ANSII
#define WOWFAX_DLL_NAME L"WOWFAX.DLL"
#define WOWFAXUI_DLL_NAME L"WOWFAXUI.DLL"
#define WOWFAX_DLL_NAME_A "WOWFAX.DLL"
#define WOWFAXUI_DLL_NAME_A "WOWFAXUI.DLL"

//***************************************************************************
//     wow16 ie  wowfax.c defines WOWFAX16 to include 16bit print.h etc
//
//***************************************************************************

#if  defined(_WOWFAX16_)

#include "..\..\..\mvdm\wow16\inc\print.h"
#include "..\..\..\mvdm\wow16\inc\gdidefs.inc"

#define LPTSTR              LPSTR
#define TEXT(x)             x
#define SRCCOPY             0x00CC0020L

//
// the following UNALIGNED definition is required because this file
// in included in wow16\test\shell\wowfax.h
//

#ifndef UNALIGNED

#if defined(MIPS) || defined(_ALPHA_) // winnt
#define UNALIGNED __unaligned         // winnt
#else                                 // winnt
#define UNALIGNED                     // winnt
#endif                                // winnt

#endif


#endif       // defined(wowfax16)

//***************************************************************************
// WOWFAXINFO16  common to wow16 and wow32
//      Struct cannot be accessed from 32bit wowfax/wowfaxui dlls
//***************************************************************************

#define WFINFO16_ENABLED           0x01

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _WOWFAXINFO16 {  /* winfo16 */
    WORD      hmem;
    WORD      flState;
    WORD      hInst;

    WORD (FAR PASCAL *lpEnable)(LPVOID,short,LPSTR,LPSTR,LPVOID);
    VOID (FAR PASCAL *lpDisable)(LPVOID);
    int (FAR PASCAL *lpControl)(LPVOID, short, LPVOID, LPVOID);
    BOOL (FAR PASCAL *lpBitblt)(LPVOID,WORD,WORD,LPVOID,
                              WORD,WORD,WORD,WORD,long,LPVOID,LPVOID);
    WORD (FAR PASCAL *lpExtDMode)(HWND, HANDLE, LPVOID, LPSTR, LPSTR,
                                               LPVOID, LPSTR , WORD);
    DWORD (FAR PASCAL *lpDevCaps)(LPSTR, LPSTR, WORD, LPSTR, LPVOID);

    WORD        hmemdevice;
    DWORD       cData;
    WORD        hwndui;
    DWORD       retvalue;
    WORD        wCmd;

    // The following pointers provide offsets into the mapped file
    // section used for inter process communication. They point to
    // objects which have a variable length.
    LPVOID      lpDevice;
    LPVOID      lpDriverName;
    LPVOID      lpPortName;
    LPVOID      lpIn;
    LPVOID      lpOut;

    // Since we have a max length (CCHDEVICENAME) we'll pass
    // the printer/device name in this fixed length buffer.
    char        szDeviceName[CCHDEVICENAME+1];
    char        szDocName[CCHDOCNAME+1];

} WOWFAXINFO16;

typedef WOWFAXINFO16 UNALIGNED FAR *LPWOWFAXINFO16;

//***************************************************************************
// GDIINFO16  common to wow16 and wow32
//        - this structure copied from wow16\inc\gdidefs.inc
//        - PTTYPE has been replaced with POINT
//
//      Struct cannot be accessed from 32bit wowfax/wowfaxui dlls. the
//      definition itself will be incorrect.
//
//***************************************************************************

#ifndef _DEF_WOW32_
#define POINT16             POINT
#endif

typedef struct _GDIINFO16{  /* gdii16 */
    short int dpVersion;
    short int dpTechnology;
    short int dpHorzSize;
    short int dpVertSize;
    short int dpHorzRes;
    short int dpVertRes;
    short int dpBitsPixel;
    short int dpPlanes;
    short int dpNumBrushes;
    short int dpNumPens;
    short int futureuse;
    short int dpNumFonts;
    short int dpNumColors;
    short int dpDEVICEsize;
    unsigned short int dpCurves;
    unsigned short int dpLines;
    unsigned short int dpPolygonals;
    unsigned short int dpText;
    unsigned short int dpClip;
    unsigned short int dpRaster;
    short int dpAspectX;
    short int dpAspectY;
    short int dpAspectXY;
    short int dpStyleLen;
    POINT16  dpMLoWin;
    POINT16  dpMLoVpt;
    POINT16  dpMHiWin;
    POINT16  dpMHiVpt;
    POINT16  dpELoWin;
    POINT16  dpELoVpt;
    POINT16  dpEHiWin;
    POINT16  dpEHiVpt;
    POINT16  dpTwpWin;
    POINT16  dpTwpVpt;
    short int dpLogPixelsX;
    short int dpLogPixelsY;
    short int dpDCManage;
    unsigned short int dpCaps1;
    short int futureuse4;
    short int futureuse5;
    short int futureuse6;
    short int futureuse7;
    WORD dpNumPalReg;
    WORD dpPalReserved;
    WORD dpColorRes;
} GDIINFO16;

typedef GDIINFO16 UNALIGNED FAR *LPGDIINFO16;


/* XLATOFF */
#pragma pack()
/* XLATON */

#ifndef _WOWFAX16_

//***************************************************************************
// WOWFAXINFO  - common to wow32,wowfax,wowfaxui. This defines the header of
//      shared memory section.
//
//***************************************************************************

typedef struct _WOWFAXINFO {   /* faxi */
    HWND    hwnd;
    DWORD   tid;
    WNDPROC proc16;
    LPBYTE  lpinfo16;

    UINT    msg;
    WPARAM  hdc;

    WORD    wCmd;
    DWORD   cData;
    HWND    hwndui;
    DWORD   retvalue;
    DWORD   status;

    // The following pointers provide offsets into the mapped file
    // section used for inter process communication. They point to
    // objects which have a variable length.
    LPVOID      lpDevice;
    LPVOID      lpDriverName;
    LPVOID      lpPortName;
    LPVOID      lpIn;
    LPVOID      lpOut;

    // Since we have a max length (CCHDEVICENAME) we'll pass
    // the printer/device name in this fixed length buffer.
    WCHAR       szDeviceName[CCHDEVICENAME+1];

    // EasyFax Ver2.0 support for JAPAN. 
    // Also needed for Procomm+ 3 cover sheets. Bug #305665
    WCHAR       szDocName[CCHDOCNAME+1];

    UINT    bmPixPerByte;
    UINT    bmWidthBytes;
    UINT    bmHeight;
    LPBYTE  lpbits;

} WOWFAXINFO, FAR *LPWOWFAXINFO;

#endif // _WOWFAX16_

#define WOWFAX_CLASS      TEXT("WOWFaxClass")

VOID GetFaxDataMapName(DWORD idMap, LPTSTR lpT);

//***************************************************************************
// Common functions for wow32, wowfax and wowfaxui.
//***************************************************************************

#ifdef WOWFAX_INC_COMMON_CODE

#define WOWFAX_MAPPREFIX  TEXT("wfm")
#define WOWFAX_HEXDIGITS  TEXT("0123456789abcdef")

//***************************************************************************
// GetFaxDataMapName - given idMap, generates the sharedmem Map Name.
//       A process can access the relevant data by opening the file
//       identified by idMap
//***************************************************************************

VOID GetFaxDataMapName(DWORD idMap, LPTSTR lpT)
{
    int i;
    int cb = lstrlen(WOWFAX_MAPPREFIX);
    LPBYTE lpid = (LPBYTE)&idMap;
    LPTSTR lphexT = WOWFAX_HEXDIGITS;

    lstrcpy(lpT, WOWFAX_MAPPREFIX);
    for (i = 0; i < sizeof(idMap)  ; i++) {
         lpT[(i * 2) + cb] = lphexT[lpid[i] & 0xf];
         lpT[(i * 2) + cb + 1] = lphexT[(lpid[i] & 0xf0) >> 4];
    }

    lpT[(i * 2) + cb] = 0;
}

#endif       // WOWFAX_INC_COMMON_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowinfo.h ===
/*++ BUILD Version: 0002
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWINFO.H
 *  16-bit Kernel API argument structures
 *
 *  History:
 *  Created 1-jun-1992 by Matt Felton (mattfe)
--*/

// the following UNALIGNED definition is required because wowinfo.h is
// included in 'wowexec.c'
//
// these lines are from ntdef.h
//

#ifndef UNALIGNED

#if defined(MIPS) || defined(_ALPHA_) // winnt
#define UNALIGNED __unaligned // winnt
#else                         // winnt
#define UNALIGNED             // winnt
#endif                        // winnt

#endif

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _WOWINFO {               /**/
    LPSTR       lpCmdLine;
    LPSTR       lpAppName;
    LPSTR       lpEnv;
    DWORD       iTask;
    USHORT      CmdLineSize;
    USHORT      AppNameSize;
    USHORT      EnvSize;
    USHORT      CurDrive;
    LPSTR       lpCurDir;
    USHORT      CurDirSize;
    USHORT      wShowWindow;
} WOWINFO;
typedef WOWINFO UNALIGNED *PWOWINFO;

#define MAXENVIRONMENTSIZE	2048	// Max Size of Environment coped with.


/* XLATOFF */
#pragma pack()
/* XLATON */

#define WM_WOWEXECSTARTAPP         (WM_USER)    // also in windows\inc\vdmapi.h
#define WM_WOWEXECHEARTBEAT        (WM_USER+1)  // To deliver timer ticks
#define WM_WOWEXEC_START_TASK      (WM_USER+2)  // vdmdbg.dll sends this
#define WM_WOWEXECSTARTTIMER       (WM_USER+3)  // see WK32WowShutdownTimer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowkbd.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWKBD.H
 *  16-bit Keyboard API argument structures
 *
 *  History:
 *  Created 02-Feb-1991 by Jeff Parsons (jeffpar)
--*/


/* Keyboard API IDs
 */
#define FUN_ANSITOOEM           5   //
#define FUN_ANSITOOEMBUFF       134 //
#define FUN_DISABLE         3   // Internal
#define FUN_ENABLE          2   // Internal
#define FUN_ENABLEKBSYSREQ      136 // Internal
#define FUN_GETKBCODEPAGE       132 //
#define FUN_GETKEYBOARDTYPE     130 //
#define FUN_GETKEYNAMETEXT      133 //
#define FUN_GETTABLESEG         126 // Internal
#define FUN_INQUIRE         1   // Internal
#define FUN_KEYBOARD_WEP        0   // Export by name
#define FUN_MAPVIRTUALKEY       131 //
#define FUN_NEWTABLE            127 // Internal
#define FUN_OEMKEYSCAN          128 //
#define FUN_OEMTOANSI           6   //
#define FUN_OEMTOANSIBUFF       135 //
#define FUN_SCREENSWITCHENABLE      100 // Internal
#define FUN_SETSPEED            7   // Internal
#define FUN_TOASCII         4   //
#define FUN_VKKEYSCAN           129 //
#define FUN_GETBIOSKEYPROC      137 //


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _ANSITOOEM16 {           /* kb5 */
    VPSTR f2;
    VPSTR f1;
} ANSITOOEM16;
typedef ANSITOOEM16 UNALIGNED *PANSITOOEM16;

typedef struct _ANSITOOEMBUFF16 {       /* kb134 */
    SHORT f3;
    VPSTR f2;
    VPSTR f1;
} ANSITOOEMBUFF16;
typedef ANSITOOEMBUFF16 UNALIGNED *PANSITOOEMBUFF16;

#ifdef NULLSTRUCT
typedef struct _GETKBCODEPAGE16 {       /* kb132 */
} GETKBCODEPAGE16;
typedef GETKBCODEPAGE16 UNALIGNED *PGETKBCODEPAGE16;
#endif

typedef struct _GETKEYBOARDTYPE16 {     /* kb130 */
    SHORT f1;
} GETKEYBOARDTYPE16;
typedef GETKEYBOARDTYPE16 UNALIGNED *PGETKEYBOARDTYPE16;

typedef struct _GETKEYNAMETEXT16 {      /* kb133 */
    SHORT f3;
    VPSTR f2;
    LONG f1;
} GETKEYNAMETEXT16;
typedef GETKEYNAMETEXT16 UNALIGNED *PGETKEYNAMETEXT16;

typedef struct _MAPVIRTUALKEY16 {       /* kb131 */
    WORD f2;
    WORD f1;
} MAPVIRTUALKEY16;
typedef MAPVIRTUALKEY16 UNALIGNED *PMAPVIRTUALKEY16;

typedef struct _OEMKEYSCAN16 {          /* kb128 */
    WORD f1;
} OEMKEYSCAN16;
typedef OEMKEYSCAN16 UNALIGNED *POEMKEYSCAN16;

typedef struct _OEMTOANSI16 {           /* kb6 */
    VPSTR f2;
    VPSTR f1;
} OEMTOANSI16;
typedef OEMTOANSI16 UNALIGNED *POEMTOANSI16;

typedef struct _OEMTOANSIBUFF16 {       /* kb135 */
    SHORT f3;
    VPSTR f2;
    VPSTR f1;
} OEMTOANSIBUFF16;
typedef OEMTOANSIBUFF16 UNALIGNED *POEMTOANSIBUFF16;

typedef struct _TOASCII16 {         /* kb4 */
    WORD f5;
    VPVOID f4;
    VPSTR f3;
    WORD f2;
    WORD f1;
} TOASCII16;
typedef TOASCII16 UNALIGNED *PTOASCII16;

typedef struct _VKKEYSCAN16 {           /* kb129 */
    WORD f1;
} VKKEYSCAN16;
typedef VKKEYSCAN16 UNALIGNED *PVKKEYSCAN16;

/* XLATOFF */
#pragma pack()
/* XLATON */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowint.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1992, Microsoft Corporation
 *
 *  WOWINT.H
 *  16-bit Internal API argument structures
 *
 *  History:
 *  Created 22-Apr-1992 by FritzS
 *
--*/

#define FUN_SETTABLE		 0 //


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _WOWSETTABLE16 { 	    /* i0 */
    VPSZ f1;
} WOWSETTABLE16, *PWOWSETTABLE16;

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowgdi.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWGDI.H
 *  16-bit GDI API argument structures
 *
 *  History:
 *  Created 02-Feb-1991 by Jeff Parsons (jeffpar)
 *  Added Win 31 19-March-1992 Chandan S. Chauhan (ChandanC)
 *
--*/


/* GDI API IDs
 */
#define FUN_ADDFONTRESOURCE     119 //
#define FUN_ANIMATEPALETTE      367 //
#define FUN_ARC             23  //
#define FUN_BITBLT          34  //
#define FUN_BRUTE           213 // No proto
#define FUN_CHORD           348 //
#define FUN_CLOSEJOB            243 // No proto
#define FUN_CLOSEMETAFILE       126 //
#define FUN_COMBINERGN          47  //
#define FUN_COMPATIBLEBITMAP        157 // Internal
#define FUN_COPY            250 // Internal
#define FUN_COPYMETAFILE        151 //
#define FUN_CREATEBITMAP        48  //
#define FUN_CREATEBITMAPINDIRECT    49  //
#define FUN_CREATEBRUSHINDIRECT     50  //
#define FUN_CREATECOMPATIBLEBITMAP  51  //
#define FUN_CREATECOMPATIBLEDC      52  //
#define FUN_CREATEDC            53  //
#define FUN_CREATEDIBITMAP      442 //
#define FUN_CREATEDIBPATTERNBRUSH   445 //
#define FUN_CREATEDISCARDABLEBITMAP 156 //
#define FUN_CREATEELLIPTICRGN       54  //
#define FUN_CREATEELLIPTICRGNINDIRECT   55  //
#define FUN_CREATEFONT          56  //
#define FUN_CREATEFONTINDIRECT      57  //
#define FUN_CREATEHATCHBRUSH        58  //
#define FUN_CREATEIC            153 //
#define FUN_CREATEMETAFILE      125 //
#define FUN_CREATEPALETTE       360 //
#define FUN_CREATEPATTERNBRUSH      60  //
#define FUN_CREATEPEN           61  //
#define FUN_CREATEPENINDIRECT       62  //
#define FUN_CREATEPOLYGONRGN        63  //
#define FUN_CREATEPOLYPOLYGONRGN    451 //
#define FUN_CREATEPQ            230 // No proto
#define FUN_CREATEREALBITMAP        408 // Internal
#define FUN_CREATEREALBITMAPINDIRECT    406 // Internal
#define FUN_CREATERECTRGN       64  //
#define FUN_CREATERECTRGNINDIRECT   65  //
#define FUN_CREATEROUNDRECTRGN      444 //
#define FUN_CREATESOLIDBRUSH        66  //
#define FUN_CREATEUSERBITMAP        407 // Internal
#define FUN_CREATEUSERDISCARDABLEBITMAP 409 // Internal
#define FUN_DEATH           121 // Internal
#define FUN_DELETEABOVELINEFONTS    186 // Internal
#define FUN_DELETEDC            68  //
#define FUN_DELETEJOB           244 // No proto
#define FUN_DELETEMETAFILE      127 //
#define FUN_DELETEOBJECT        69  //
#define FUN_DELETEPQ            235 // No proto
#define FUN_DEVICECOLORMATCH        449 // Internal
#define FUN_DEVICEMODE          452 //
#define FUN_DMBITBLT            201 // No proto
#define FUN_DMCOLORINFO         202 // No proto
#define FUN_DMENUMDFONTS        206 // No proto
#define FUN_DMENUMOBJ           207 // No proto
#define FUN_DMOUTPUT            208 // No proto
#define FUN_DMPIXEL         209 // No proto
#define FUN_DMREALIZEOBJECT     210 // No proto
#define FUN_DMSCANLR            212 // No proto
#define FUN_DMSTRBLT            211 // No proto
#define FUN_DMTRANSPOSE         220 // No proto
#define FUN_DPTOLP          67  //
#define FUN_DPXLATE         138 // Internal
#define FUN_ELLIPSE         24  //
#define FUN_ENDSPOOLPAGE        247 // No proto
#define FUN_ENUMCALLBACK        158 // Internal
#define FUN_ENUMFONTS           70  //
#define FUN_ENUMMETAFILE        175 //
#define FUN_ENUMOBJECTS         71  //
#define FUN_EQUALRGN            72  //
#define FUN_ESCAPE          38  //
#define FUN_EXCLUDECLIPRECT     21  //
#define FUN_EXCLUDEVISRECT      73  // Internal
#define FUN_EXTDEVICEMODE       453 //
#define FUN_DEVICECAPABILITIES  454
//#define FUN_ADVANCEDSETUPDIALOG 455
#define FUN_EXTFLOODFILL        372 // Internal, proto
#define FUN_EXTRACTPQ           232 // No proto
#define FUN_EXTTEXTOUT          351 //
#define FUN_FASTWINDOWFRAME     400 // Internal
#define FUN_FILLRGN         40  //
#define FUN_FINALGDIINIT        405 // Internal
#define FUN_FLOODFILL           25  //
#define FUN_FRAMERGN            41  //
#define FUN_GDIFLUSH            263 // New Private
#define FUN_GDIINIT2            403 // Internal
#define FUN_GDIMOVEBITMAP       401 // Internal
#define FUN_GDIREALIZEPALETTE       362 // Internal
#define FUN_GDISELECTPALETTE        361 // Internal
#define FUN_GDI_WEP         0   // Export by name
#define FUN_GETASPECTRATIOFILTER    353 //
#define FUN_GETBITMAPBITS       74  //
#define FUN_GETBITMAPDIMENSION      162 //
#define FUN_GETBKCOLOR          75  //
#define FUN_GETBKMODE           76  //
#define FUN_GETBRUSHORG         149 //
#define FUN_GETCHARWIDTH        350 //
#define FUN_GETCLIPBOX          77  //
#define FUN_GETCLIPRGN          173 // Internal
#define FUN_GETCURLOGFONT       411 // Internal
#define FUN_GETCURRENTOBJECT        261 // New Private
#define FUN_GETCURRENTPOSITION      78  //
#define FUN_GETDCORG            79  //
#define FUN_GETDCSTATE          179 // Internal
#define FUN_GETDEVICECAPS       80  //
#define FUN_GETDIBITS           441 //
#define FUN_GETENVIRONMENT      133 //
#define FUN_GETMAPMODE          81  //
#define FUN_GETMETAFILE         124 //
#define FUN_GETMETAFILEBITS     159 //
#define FUN_GETNEARESTCOLOR     154 //
#define FUN_GETNEARESTPALETTEINDEX  370 //
#define FUN_GETOBJECT           82  //
#define FUN_GETOBJECTTYPE       260 // New Private
#define FUN_GETPALETTEENTRIES       363 //
#define FUN_GETPHYSICALFONTHANDLE   352 // Internal
#define FUN_GETPIXEL            83  //
#define FUN_GETPOLYFILLMODE     84  //
#define FUN_GETRELABS           86  // Internal
#define FUN_GETRGNBOX           134 //
#define FUN_GETROP2         85  //
#define FUN_GETSPOOLJOB         245 // No proto
#define FUN_GETSTOCKOBJECT      87  //
#define FUN_GETSTRETCHBLTMODE       88  //
#define FUN_GETSYSTEMPALETTEENTRIES 375 //
#define FUN_GETSYSTEMPALETTEUSE     374 //
#define FUN_GETTEXTALIGN        345 //
#define FUN_GETTEXTCHARACTEREXTRA   89  //
#define FUN_GETTEXTCOLOR        90  //
#define FUN_GETTEXTEXTENT       91  //
#define FUN_GETTEXTFACE         92  //
#define FUN_GETTEXTMETRICS      93  //
#define FUN_GETVIEWPORTEXT      94  //
#define FUN_GETVIEWPORTORG      95  //
#define FUN_GETWINDOWEXT        96  //
#define FUN_GETWINDOWORG        97  //
#define FUN_GSV             137 // Internal
#define FUN_INQUIREVISRGN       131 // Internal
#define FUN_INSERTPQ            233 // No proto
#define FUN_INTERNALCREATEDC        118 // Internal
#define FUN_INTERSECTCLIPRECT       22  //
#define FUN_INTERSECTVISRECT        98  // Internal
#define FUN_INVERTRGN           42  //
#define FUN_ISDCCURRENTPALETTE      412 // Internal
#define FUN_ISDCDIRTY           169 // Internal
#define FUN_ISVALIDMETAFILE     410 // Internal
#define FUN_LINEDDA         100 //
#define FUN_LINETO          19  //
#define FUN_LPTODP          99  //
#define FUN_LVBUNION            171 // Internal
#define FUN_MFDRAWTEXT          347 // Internal
#define FUN_MINPQ           231 // No proto
#define FUN_MOVETO          20  //
#define FUN_MULDIV          128 //
#define FUN_OFFSETCLIPRGN       32  //
#define FUN_OFFSETORG           143 // Internal
#define FUN_OFFSETRGN           101 //
#define FUN_OFFSETVIEWPORTORG       17  //
#define FUN_OFFSETVISRGN        102 // Internal
#define FUN_OFFSETWINDOWORG     15  //
#define FUN_OPENJOB         240 // No proto
#define FUN_PAINTRGN            43  //
#define FUN_PATBLT          29  //
#define FUN_PIE             26  //
#define FUN_PIXTOLINE           164 // Internal
#define FUN_PLAYMETAFILE        123 //
#define FUN_PLAYMETAFILERECORD      176 //
#define FUN_POLYGON         36  //
#define FUN_POLYLINE            37  //
#define FUN_POLYPOLYGON         450 //
#define FUN_POLYPOLYLINEWOW     487 //
#define FUN_PTINREGION          161 //
#define FUN_PTVISIBLE           103 //
#define FUN_QUERYABORT          155 // Internal
#define FUN_QUERYJOB            248 // Internal
#define FUN_RCOS            177 // Internal
#define FUN_REALIZEDEFAULTPALETTE   365 // Internal
#define FUN_RECTANGLE           27  //
#define FUN_RECTINREGION        181 //
#define FUN_RECTSTUFF           142 // Internal
#define FUN_RECTVISIBLE         104 //
#define FUN_REMOVEFONTRESOURCE      136 //
#define FUN_RESIZEPALETTE       368 //
#define FUN_RESTOREDC           39  //
#define FUN_RESTOREVISRGN       130 // Internal
#define FUN_RESURRECTION        122 // Internal
#define FUN_ROUNDRECT           28  //
#define FUN_RSIN            178 // Internal
#define FUN_SAVEDC          30  //
#define FUN_SAVEVISRGN          129 // Internal
#define FUN_SCALEEXT            140 // Internal
#define FUN_SCALEVIEWPORTEXT        18  //
#define FUN_SCALEWINDOWEXT      16  //
#define FUN_SCANLR          135 // Internal
#define FUN_SELECTCLIPRGN       44  //
#define FUN_SELECTOBJECT        45  //
#define FUN_SELECTVISRGN        105 // Internal
#define FUN_SETBITMAPBITS       106 //
#define FUN_SETBITMAPDIMENSION      163 //
#define FUN_SETBKCOLOR          1   //
#define FUN_SETBKMODE           2   //
#define FUN_SETBRUSHORG         148 //
#define FUN_SETDCORG            117 // Internal
#define FUN_SETDCSTATE          180 // Internal
#define FUN_SETDCSTATUS         170 // Internal
#define FUN_SETDIBITS           440 //
#define FUN_SETDIBITSTODEVICE       443 //
#define FUN_SETENVIRONMENT      132 //
#define FUN_SETMAPMODE          3   //
#define FUN_SETMAPPERFLAGS      349 //
#define FUN_SETMETAFILEBITS     160 //
#define FUN_SETPALETTEENTRIES       364 //
#define FUN_SETPIXEL            31  //
#define FUN_SETPOLYFILLMODE     6   //
#define FUN_SETRECTRGN          172 //
#define FUN_SETRELABS           5   // Internal
#define FUN_SETROP2         4   //
#define FUN_SETSTRETCHBLTMODE       7   //
#define FUN_SETSYSTEMPALETTEUSE     373 //
#define FUN_SETTEXTALIGN        346 //
#define FUN_SETTEXTCHARACTEREXTRA   8   //
#define FUN_SETTEXTCOLOR        9   //
#define FUN_SETTEXTJUSTIFICATION    10  //
#define FUN_SETVIEWPORTEXT      14  //
#define FUN_SETVIEWPORTORG      13  //
#define FUN_SETWINDOWEXT        12  //
#define FUN_SETWINDOWORG        11  //
#define FUN_SETWINVIEWEXT       139 // Internal
#define FUN_SHRINKGDIHEAP       354 // Internal
#define FUN_SIZEPQ          234 // No proto
#define FUN_STARTSPOOLPAGE      246 // No proto
#define FUN_STRETCHBLT          35  //
#define FUN_STRETCHDIBITS       439 //
#define FUN_STUFFINREGION       185 // Internal
#define FUN_STUFFVISIBLE        184 // Internal
#define FUN_TEXTOUT         33  //
#define FUN_UNREALIZEOBJECT     150 //
#define FUN_UPDATECOLORS        366 //
#define FUN_WORDSET         141 // Internal
#define FUN_WRITEDIALOG         242 // No proto
#define FUN_WRITESPOOL          241 // No proto
#define FUN_ABORTDOC            382
#define FUN_CREATESCALABLEFONTRESOURCE  310
#define FUN_ENDDOC          378
#define FUN_ENDPAGE         380
#define FUN_ENUMFONTFAMILIES        330
#define FUN_GETASPECTRATIOFILTEREX  486
#define FUN_GETBITMAPDIMENSIONEX    468
#define FUN_GETBOUNDSRECT       194
#define FUN_GETBRUSHORGEX       469
#define FUN_GETCHARABCWIDTHS        307
#define FUN_GETCURRENTPOSITIONEX    470
#define FUN_GETFONTDATA         311
#define FUN_GETGLYPHOUTLINE     309
#define FUN_GETOUTLINETEXTMETRICS   308
#define FUN_GETRASTERIZERCAPS       313
#define FUN_GETEXTEXTENTEX      188
#define FUN_GETEXTEXTENTPOINT       471
#define FUN_GETVIEWPORTEXTEX        472
#define FUN_GETVIEWPORTORGEX        473
#define FUN_GETWINDOWEXTEX      474
#define FUN_GETWINDOWORGEX      475
#define FUN_ISGDIOBJECT         462
#define FUN_MOVETOEX            483
#define FUN_OFFSETVIEWPORTORGEX     476
#define FUN_OFFSETWINDOWORGEX       477
#define FUN_QUERYABORT          155
#define FUN_RESETDC         376
#define FUN_SCALEVIEWPORTEXTEX      484
#define FUN_SCALEWINDOWEXTEX        485
#define FUN_SETABORTPROC        381
#define FUN_SETBITMAPDIMENSIONEX    478
#define FUN_SETBOUNDSRECT       193
#define FUN_SETMETAFILEBITSBETTER   196
#define FUN_SETVIEWPORTEXTEX        479
#define FUN_SETVIEWPORTORGEX        480
#define FUN_SETWINDOWEXTEX      481
#define FUN_SETWINDOWORGEX      482
#define FUN_SPOOLFILE           254
#define FUN_STARTDOC            377
#define FUN_STARTPAGE           379
#define FUN_BITMAPBITS          46
#define FUN_SETDCHOOK           190
#define FUN_GETDCHOOK           191
#define FUN_SETHOOKFLAGS        192
#define FUN_SELECTBITMAP        195
#define FUN_DMEXTTEXTOUT        214
#define FUN_DMGETCHARWIDTH      215
#define FUN_DMSTRETCHBLT        216
#define FUN_DMDIBBITS           217
#define FUN_DMSTRETCHDIBITS     218
#define FUN_DMSETDIBTODEV       219
#define FUN_DELETESPOOLPAGE     253
#define FUN_ENGINEENUMERATEFONT     300     // Internal
#define FUN_ENGINEDELETEFONT        301
#define FUN_ENGINEREALIZEFONT       302
#define FUN_ENGINEGETCHARWIDTH      303
#define FUN_ENGINESETFONTCONTEXT    304
#define FUN_ENGINEGETGLYPHBMP       305
#define FUN_ENGINEMAKEFONTDIR       306
#define FUN_ENGINEEXTTEXTOUT        314  // Internal
#define FUN_GETKERNINGPAIRS     332
#define FUN_FTRAPPING0          355  // Internal
#define FUN_GDISEEGDIDO         452
#define FUN_GDITASKTERMINATION      460
#define FUN_SETOBJECTOWNER      461
#define FUN_MAKEOBJECTPRIVATE       463
#define FUN_FIXUPBOGUSPUBLISHERMETAFILE 464
#define FUN_RECTVISIBLE_EHH     465
#define FUN_RECTINREGION_EHH        466
#define FUN_UNICODETOANSI       467  // Internal
#define FUN_CONVERTOUTLINEFONTFILE  312
#define FUN_GETTEXTEXTENTPOINT      471
#define FUN_CREATEDIBSECTION        489
#define FUN_SETDIBCOLORTABLE        602
#define FUN_GETDIBCOLORTABLE        603

#ifdef  FE_SB
// GetFontAssocStatus @488->459 for Taiwan, Prc and Korea
#define FUN_GETFONTASSOCSTATUS      459

/* EUDC/GAIJI escapes for FE */
#define TTYMODE                      2560
#define GAIJIFIRST                   TTYMODE+0x10
#define GAIJIFONTSIZE                GAIJIFIRST
#define GAIJIAREASIZE                GAIJIFIRST+1
#define GAIJISYSTEMGETFONT           GAIJIFIRST+2
#define GAIJISYSTEMSETFONT           GAIJIFIRST+3
#define GAIJIITOCODE                 GAIJIFIRST+4
#define GAIJILOCALOPEN               GAIJIFIRST+5
#define GAIJILOCALCLOSE              GAIJIFIRST+6
#define GAIJILOCALSETFONT            GAIJIFIRST+7
#define GAIJILOCALSAVE               GAIJIFIRST+8
#define GAIJILOCALRESTORE            GAIJIFIRST+9
#define GAIJIGETFILENAME             GAIJIFIRST+10
#define GAIJISETFILENAME             GAIJIFIRST+11
#define GAIJIGETDESCRIPTIONNAME      GAIJIFIRST+12
#define GAIJIPHYSICALFONTSIZE        GAIJIFIRST+13
#endif  // FE_SB

/* New for NT 5.0 Win95 compatibility */

#define FUN_ABORTPATH               511
#define FUN_ABORTPRINTER            271
#define FUN_ADDLPKTOGDI             614
#define FUN_BEGINPATH               512
#define FUN_BUILDINVERSETABLEDIB    617  // export 650
#define FUN_CLOSEENHMETAFILE        490
#define FUN_CLOSEFIGURE             513
#define FUN_CLOSEPRINTER            274
#define FUN_COPYENHMETAFILE         491
#define FUN_CREATEENHMETAFILE       492
#define FUN_CREATEHALFTONEPALETTE   529
#define FUN_DELETEENHMETAFILE       493
#define FUN_DRVGETPRINTERDATA       282
#define FUN_DRVSETPRINTERDATA       281
#define FUN_ENDDOCPRINTER           272
#define FUN_ENDPAGEPRINTER          270
#define FUN_ENDPATH                 514
#define FUN_ENGINEGETCHARWIDTHEX    299
#define FUN_ENGINEGETCHARWIDTHSTR   316
#define FUN_ENGINEGETGLYPHBMPEXT    305
#define FUN_ENGINEREALIZEFONTEXT    315
#define FUN_ENUMFONTFAMILIESEX      613
#define FUN_EXTCREATEPEN            523
#define FUN_EXTCREATEREGION         608
#define FUN_EXTSELECTCLIPRGN        508
#define FUN_FILLPATH                515
#define FUN_FLATTENPATH             516
#define FUN_GDICOMMENT              495
#define FUN___AVAILABLE_609         609
#define FUN_GDIPARAMETERSINFO       528
#define FUN_GDISIGNALPROC32         610
#define FUN_GETARCDIRECTION         524
#define FUN_GETCHARACTERPLACEMENT   615
#define FUN_GETENHMETAFILE          496
#define FUN_GETENHMETAFILEBITS      497
#define FUN_GETENHMETAFILEDESCRIPTION 498
#define FUN_GETENHMETAFILEHEADER    499
#define FUN_GETENHMETAFILEPALETTEENTRIES 501
#define FUN_GETFONTLANGUAGEINFO     616
#define FUN_GETMITERLIMIT           526
#define FUN_GETPATH                 517
#define FUN_GETRANDOMRGN            611
#define FUN_GETREALDRIVERINFO       280
#define FUN_GETREGIONDATA           607
#define FUN_GETTEXTCHARSET          612
#define FUN_GETTEXTEXTENTEX         188
#define FUN_GETTTGLYPHINDEXMAP      404
#define FUN_ICMCHECKCOLORSINGAMUT   622  // export 824
#define FUN_ICMCREATETRANSFORM      618  // export 820
#define FUN_ICMDELETETRANSFORM      619  // export 821
#define FUN_ICMTRANSLATERGB         620  // export 822
#define FUN_ICMTRANSLATERGBS        621  // export 823
#define FUN_OPENPRINTERA            266
#define FUN_PATHTOREGION            518
#define FUN_PLAYENHMETAFILERECORD   504
#define FUN_POLYBEZIER              502
#define FUN_POLYBEZIERTO            503
#define FUN_SELECTCLIPPATH          519
#define FUN_SETARCDIRECTION         525
#define FUN_SETENHMETAFILEBITS      505
#define FUN_SETMAGICCOLORS          606
#define FUN_SETMETARGN              506
#define FUN_SETMITERLIMIT           527
#define FUN_SETSOLIDBRUSH           604
#define FUN_STARTDOCPRINTERA        267
#define FUN_STARTPAGEPRINTER        268
#define FUN_STROKEANDFILLPATH       520
#define FUN_STROKEPATH              521
#define FUN_SYSDELETEOBJECT         605
#define FUN_WIDENPATH               522
#define FUN_WRITEPRINTER            269


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _ADDFONTRESOURCE16 {     /* g119 */
    VPSZ f1;
} ADDFONTRESOURCE16;
typedef ADDFONTRESOURCE16 UNALIGNED *PADDFONTRESOURCE16;

typedef struct _ANIMATEPALETTE16 {      /* g367 */
    VPPALETTEENTRY16 f4;
    WORD f3;
    WORD f2;
    HPAL16 f1;
} ANIMATEPALETTE16;
typedef ANIMATEPALETTE16 UNALIGNED *PANIMATEPALETTE16;

typedef struct _ARC16 {             /* g23 */
    SHORT f9;
    SHORT f8;
    SHORT f7;
    SHORT f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} ARC16;
typedef ARC16 UNALIGNED *PARC16;

typedef struct _BITBLT16 {          /* g34 */
    DWORD f9;
    SHORT f8;
    SHORT f7;
    HDC16 f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} BITBLT16;
typedef BITBLT16 UNALIGNED *PBITBLT16;

typedef struct _CHORD16 {           /* g348 */
    SHORT f9;
    SHORT f8;
    SHORT f7;
    SHORT f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} CHORD16;
typedef CHORD16 UNALIGNED *PCHORD16;

typedef struct _SETRELABS16 {      /* g5 */
    SHORT f2;
    HDC16 f1;
} SETRELABS16;
typedef SETRELABS16 UNALIGNED *PSETRELABS16;

typedef struct _GETRELABS16 {      /* g86 */
    HDC16 f1;
} GETRELABS16;
typedef GETRELABS16 UNALIGNED *PGETRELABS16;

typedef struct _CLOSEMETAFILE16 {  /* g126 */
    HAND16 f1;
} CLOSEMETAFILE16;
typedef CLOSEMETAFILE16 UNALIGNED *PCLOSEMETAFILE16;

typedef struct _COMBINERGN16 {          /* g47 */
    SHORT f4;
    HRGN16 f3;
    HRGN16 f2;
    HRGN16 f1;
} COMBINERGN16;
typedef COMBINERGN16 UNALIGNED *PCOMBINERGN16;

typedef struct _COPYMETAFILE16 {        /* g151 */
    VPSZ f2;
    HAND16 f1;
} COPYMETAFILE16;
typedef COPYMETAFILE16 UNALIGNED *PCOPYMETAFILE16;

typedef struct _CREATEBITMAP16 {        /* g48 */
    VPBYTE f5;
    WORD f4;
    WORD f3;
    SHORT f2;
    SHORT f1;
} CREATEBITMAP16;
typedef CREATEBITMAP16 UNALIGNED *PCREATEBITMAP16;

typedef struct _CREATEUSERBITMAP16 {        /* g407 */
    VPBYTE f5;
    WORD f4;
    WORD f3;
    SHORT f2;
    SHORT f1;
} CREATEUSERBITMAP16, *PCREATEUSERBITMAP16;

typedef struct _CREATEBITMAPINDIRECT16 {    /* g49 */
    VPBITMAP16 f1;
} CREATEBITMAPINDIRECT16;
typedef CREATEBITMAPINDIRECT16 UNALIGNED *PCREATEBITMAPINDIRECT16;

typedef struct _CREATEBRUSHINDIRECT16 {     /* g50 */
    VPLOGBRUSH16 f1;
} CREATEBRUSHINDIRECT16;
typedef CREATEBRUSHINDIRECT16 UNALIGNED *PCREATEBRUSHINDIRECT16;

typedef struct _CREATECOMPATIBLEBITMAP16 {  /* g51 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} CREATECOMPATIBLEBITMAP16;
typedef CREATECOMPATIBLEBITMAP16 UNALIGNED *PCREATECOMPATIBLEBITMAP16;

typedef struct _CREATECOMPATIBLEDC16 {      /* g52 */
    HDC16 f1;
} CREATECOMPATIBLEDC16;
typedef CREATECOMPATIBLEDC16 UNALIGNED *PCREATECOMPATIBLEDC16;

typedef struct _CREATEDC16 {            /* g53 */
    VPDEVMODE31 f4;
    VPSZ f3;
    VPSZ f2;
    VPSZ f1;
} CREATEDC16;
typedef CREATEDC16 UNALIGNED *PCREATEDC16;

typedef struct _CREATEDIBITMAP16 {      /* g442 */
    WORD f6;
    VPBITMAPINFO16 f5;
    VPBYTE f4;
    DWORD f3;
    VPBITMAPINFOHEADER16 f2;
    HDC16 f1;
} CREATEDIBITMAP16;
typedef CREATEDIBITMAP16 UNALIGNED *PCREATEDIBITMAP16;

typedef struct _CREATEDIBSECTION16 {      /* g489 */
    DWORD f6;
    DWORD f5;
    VPBYTE f4;
    WORD f3;
    VPBITMAPINFO16 f2;
    HDC16 f1;
} CREATEDIBSECTION16;
typedef CREATEDIBSECTION16 UNALIGNED *PCREATEDIBSECTION16;

typedef struct _GETDIBCOLORTABLE16 {      /* g603 */
    VPBYTE f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} GETDIBCOLORTABLE16;
typedef GETDIBCOLORTABLE16 UNALIGNED *PGETDIBCOLORTABLE16;

typedef struct _SETDIBCOLORTABLE16 {      /* g602 */
    VPBYTE f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} SETDIBCOLORTABLE16;
typedef SETDIBCOLORTABLE16 UNALIGNED *PSETDIBCOLORTABLE16;

typedef struct _CREATEDIBPATTERNBRUSH16 {   /* g445 */
    WORD f2;
    VPVOID f1;
} CREATEDIBPATTERNBRUSH16;
typedef CREATEDIBPATTERNBRUSH16 UNALIGNED *PCREATEDIBPATTERNBRUSH16;

typedef struct _CREATEDISCARDABLEBITMAP16 { /* g156 */
    SHORT height;
    SHORT width;
    HDC16 hdc;
} CREATEDISCARDABLEBITMAP16;
typedef CREATEDISCARDABLEBITMAP16 UNALIGNED *PCREATEDISCARDABLEBITMAP16;

typedef struct _CREATEELLIPTICRGN16 {       /* g54 */
    SHORT f4;
    SHORT f3;
    SHORT f2;
    SHORT f1;
} CREATEELLIPTICRGN16;
typedef CREATEELLIPTICRGN16 UNALIGNED *PCREATEELLIPTICRGN16;

typedef struct _CREATEELLIPTICRGNINDIRECT16 {   /* g55 */
    VPRECT16 f1;
} CREATEELLIPTICRGNINDIRECT16;
typedef CREATEELLIPTICRGNINDIRECT16 UNALIGNED *PCREATEELLIPTICRGNINDIRECT16;

typedef struct _CREATEFONT16 {          /* g56 */
    VPSZ f14;
    WORD f13;
    WORD f12;
    WORD f11;
    WORD f10;
    WORD f9;
    WORD f8;
    WORD f7;
    WORD f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    SHORT f1;
} CREATEFONT16;
typedef CREATEFONT16 UNALIGNED *PCREATEFONT16;

typedef struct _CREATEFONTINDIRECT16 {      /* g57 */
    VPLOGFONT16 f1;
} CREATEFONTINDIRECT16;
typedef CREATEFONTINDIRECT16 UNALIGNED *PCREATEFONTINDIRECT16;

typedef struct _CREATEHATCHBRUSH16 {        /* g58 */
    DWORD f2;
    SHORT f1;
} CREATEHATCHBRUSH16;
typedef CREATEHATCHBRUSH16 UNALIGNED *PCREATEHATCHBRUSH16;

typedef struct _CREATEIC16 {            /* g153 */
    VPDEVMODE31 f4;
    VPSZ f3;
    VPSZ f2;
    VPSZ f1;
} CREATEIC16;
typedef CREATEIC16 UNALIGNED *PCREATEIC16;

typedef struct _CREATEMETAFILE16 {      /* g125 */
    VPSZ f1;
} CREATEMETAFILE16;
typedef CREATEMETAFILE16 UNALIGNED *PCREATEMETAFILE16;

typedef struct _CREATEPALETTE16 {       /* g360 */
    VPLOGPALETTE16 f1;
} CREATEPALETTE16;
typedef CREATEPALETTE16 UNALIGNED *PCREATEPALETTE16;

typedef struct _CREATEPATTERNBRUSH16 {      /* g60 */
    HBM16 f1;
} CREATEPATTERNBRUSH16;
typedef CREATEPATTERNBRUSH16 UNALIGNED *PCREATEPATTERNBRUSH16;

typedef struct _CREATEPEN16 {           /* g61 */
    DWORD f3;
    SHORT f2;
    SHORT f1;
} CREATEPEN16;
typedef CREATEPEN16 UNALIGNED *PCREATEPEN16;

typedef struct _CREATEPENINDIRECT16 {       /* g62 */
    VPLOGPEN16 f1;
} CREATEPENINDIRECT16;
typedef CREATEPENINDIRECT16 UNALIGNED *PCREATEPENINDIRECT16;

typedef struct _CREATEPOLYGONRGN16 {        /* g63 */
    SHORT f3;
    SHORT f2;
    VPPOINT16 f1;
} CREATEPOLYGONRGN16;
typedef CREATEPOLYGONRGN16 UNALIGNED *PCREATEPOLYGONRGN16;

typedef struct _CREATEPOLYPOLYGONRGN16 {    /* g451 */
    SHORT f4;
    SHORT f3;
    VPSHORT f2;
    VPPOINT16 f1;
} CREATEPOLYPOLYGONRGN16;
typedef CREATEPOLYPOLYGONRGN16 UNALIGNED *PCREATEPOLYPOLYGONRGN16;

typedef struct _CREATERECTRGN16 {       /* g64 */
    SHORT f4;
    SHORT f3;
    SHORT f2;
    SHORT f1;
} CREATERECTRGN16;
typedef CREATERECTRGN16 UNALIGNED *PCREATERECTRGN16;

typedef struct _CREATERECTRGNINDIRECT16 {   /* g65 */
    VPRECT16 f1;
} CREATERECTRGNINDIRECT16;
typedef CREATERECTRGNINDIRECT16 UNALIGNED *PCREATERECTRGNINDIRECT16;

typedef struct _CREATEROUNDRECTRGN16 {      /* g444 */
    SHORT f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    SHORT f1;
} CREATEROUNDRECTRGN16;
typedef CREATEROUNDRECTRGN16 UNALIGNED *PCREATEROUNDRECTRGN16;

typedef struct _CREATESOLIDBRUSH16 {        /* g66 */
    DWORD f1;
} CREATESOLIDBRUSH16;
typedef CREATESOLIDBRUSH16 UNALIGNED *PCREATESOLIDBRUSH16;

typedef struct _DELETEDC16 {            /* g68 */
    HDC16 f1;
} DELETEDC16;
typedef DELETEDC16 UNALIGNED *PDELETEDC16;

typedef struct _DELETEMETAFILE16 {      /* g127 */
    HAND16 f1;
} DELETEMETAFILE16;
typedef DELETEMETAFILE16 UNALIGNED *PDELETEMETAFILE16;

typedef struct _DELETEOBJECT16 {        /* g69 */
    HAND16 f1;
} DELETEOBJECT16;
typedef DELETEOBJECT16 UNALIGNED *PDELETEOBJECT16;

typedef struct _DEVICEMODE16 {          /* g452 */
    VPSZ    f4;
    VPSZ    f3;
    HAND16  f2;
    HWND16  f1;
} DEVICEMODE16;
typedef DEVICEMODE16 UNALIGNED *PDEVICEMODE16;

typedef struct _EXTDEVICEMODE16 {       /* g453 */
    SHORT   f8;
    VPSZ    f7;
    VPDEVMODE31 f6;
    VPSZ    f5;
    VPSZ    f4;
    VPDEVMODE31 f3;
    HAND16  f2;
    HWND16  f1;
} EXTDEVICEMODE16;
typedef EXTDEVICEMODE16 UNALIGNED *PEXTDEVICEMODE16;

typedef struct _DEVICECAPABILITIES16 {  /* g454 */
    VPDEVMODE31 f5;
    VPSZ    f4;
    SHORT   f3;
    VPSZ    f2;
    VPSZ    f1;
} DEVICECAPABILITIES16;
typedef DEVICECAPABILITIES16 UNALIGNED *PDEVICECAPABILITIES16;

//typedef struct _ADVANCEDSETUPDIALOG16 {  /* g455 */
//    VPSZ    f4;
//    VPSZ    f3;
//    HAND16  f2;
//    HWND16  f1;
//} ADVANCEDSETUPDIALOG16;
//typedef ADVANCEDSETUPDIALOG16 UNALIGNED *PADVANCEDSETUPDIALOG16;

typedef struct _DPTOLP16 {          /* g67 */
    SHORT f3;
    VPPOINT16 f2;
    HDC16 f1;
} DPTOLP16;
typedef DPTOLP16 UNALIGNED *PDPTOLP16;

typedef struct _ELLIPSE16 {         /* g24 */
    SHORT y2;
    SHORT x2;
    SHORT y1;
    SHORT x1;
    HDC16 hdc;
} ELLIPSE16;
typedef ELLIPSE16 UNALIGNED *PELLIPSE16;

typedef struct _ENUMFONTS16 {           /* g70 */
    VPBYTE f4;
    VPPROC f3;
    VPSZ f2;
    HDC16 f1;
} ENUMFONTS16;
typedef ENUMFONTS16 UNALIGNED *PENUMFONTS16;

typedef struct _ENUMMETAFILE16 {        /* g175 */
    VPBYTE  f4;
    VPPROC f3;
    HAND16  f2;
    HDC16   f1;
} ENUMMETAFILE16;
typedef ENUMMETAFILE16 UNALIGNED *PENUMMETAFILE16;

typedef struct _ENUMOBJECTS16 {         /* g71 */
    VPBYTE f4;
    VPPROC f3;
    SHORT f2;
    HDC16 f1;
} ENUMOBJECTS16;
typedef ENUMOBJECTS16 UNALIGNED *PENUMOBJECTS16;

typedef struct _EQUALRGN16 {            /* g72 */
    HRGN16 f2;
    HRGN16 f1;
} EQUALRGN16;
typedef EQUALRGN16 UNALIGNED *PEQUALRGN16;

typedef struct _ESCAPE16 {          /* g38 */
    VPSTR f5;
    VPSTR f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} ESCAPE16;
typedef ESCAPE16 UNALIGNED *PESCAPE16;

typedef struct _EXCLUDECLIPRECT16 {     /* g21 */
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} EXCLUDECLIPRECT16;
typedef EXCLUDECLIPRECT16 UNALIGNED *PEXCLUDECLIPRECT16;

typedef struct _EXTFLOODFILL16 {        /* g372 */
    WORD f5;
    DWORD f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} EXTFLOODFILL16;
typedef EXTFLOODFILL16 UNALIGNED *PEXTFLOODFILL16;

typedef struct _EXTTEXTOUT16 {          /* g351 */
    VPSHORT f8;
    WORD f7;
    VPSTR f6;
    VPRECT16 f5;
    WORD f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} EXTTEXTOUT16;
typedef EXTTEXTOUT16 UNALIGNED *PEXTTEXTOUT16;

typedef struct _FILLRGN16 {         /* g40 */
    HBRSH16 f3;
    HRGN16 f2;
    HDC16 f1;
} FILLRGN16;
typedef FILLRGN16 UNALIGNED *PFILLRGN16;

typedef struct _FLOODFILL16 {           /* g25 */
    DWORD f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} FLOODFILL16;
typedef FLOODFILL16 UNALIGNED *PFLOODFILL16;

typedef struct _FRAMERGN16 {            /* g41 */
    SHORT f5;
    SHORT f4;
    HBRSH16 f3;
    HRGN16 f2;
    HDC16 f1;
} FRAMERGN16;
typedef FRAMERGN16 UNALIGNED *PFRAMERGN16;

typedef struct _GETASPECTRATIOFILTER16 {    /* g353 */
    HDC16 f1;
} GETASPECTRATIOFILTER16;
typedef GETASPECTRATIOFILTER16 UNALIGNED *PGETASPECTRATIOFILTER16;

typedef struct _GETASPECTRATIOFILTEREX16 {  /* g486 */
    VPVOID  f2;
    HDC16 f1;
} GETASPECTRATIOFILTEREX16;
typedef GETASPECTRATIOFILTEREX16 UNALIGNED *PGETASPECTRATIOFILTEREX16;

typedef struct _GETBITMAPBITS16 {       /* g74 */
    VPSTR f3;
    LONG f2;
    HBM16 f1;
} GETBITMAPBITS16;
typedef GETBITMAPBITS16 UNALIGNED *PGETBITMAPBITS16;

typedef struct _GETBITMAPDIMENSION16 {      /* g162 */
    HBM16 f1;
} GETBITMAPDIMENSION16;
typedef GETBITMAPDIMENSION16 UNALIGNED *PGETBITMAPDIMENSION16;

typedef struct _GETBKCOLOR16 {          /* g75 */
    HDC16 f1;
} GETBKCOLOR16;
typedef GETBKCOLOR16 UNALIGNED *PGETBKCOLOR16;

typedef struct _GETBKMODE16 {           /* g76 */
    HDC16 f1;
} GETBKMODE16;
typedef GETBKMODE16 UNALIGNED *PGETBKMODE16;

typedef struct _GETBRUSHORG16 {         /* g149 */
    HDC16 f1;
} GETBRUSHORG16;
typedef GETBRUSHORG16 UNALIGNED *PGETBRUSHORG16;

typedef struct _GETCHARWIDTH16 {        /* g350 */
    VPSHORT lpIntBuffer;
    WORD wLastChar;
    WORD wFirstChar;
    HDC16 hDC;
} GETCHARWIDTH16;
typedef GETCHARWIDTH16 UNALIGNED *PGETCHARWIDTH16;

typedef struct _GETCLIPBOX16 {          /* g77 */
    VPRECT16 f2;
    HDC16 f1;
} GETCLIPBOX16;
typedef GETCLIPBOX16 UNALIGNED *PGETCLIPBOX16;

typedef struct _GETCURRENTOBJECT16 {        /* g261 */
    WORD  f2;
    HDC16 f1;
} GETCURRENTOBJECT16;
typedef GETCURRENTOBJECT16 UNALIGNED *PGETCURRENTOBJECT16;

typedef struct _GETCURRENTPOSITION16 {      /* g78 */
    HDC16 f1;
} GETCURRENTPOSITION16;
typedef GETCURRENTPOSITION16 UNALIGNED *PGETCURRENTPOSITION16;

typedef struct _GETDCORG16 {            /* g79 */
    HDC16 f1;
} GETDCORG16;
typedef GETDCORG16 UNALIGNED *PGETDCORG16;

typedef struct _GETDEVICECAPS16 {       /* g80 */
    SHORT f2;
    HDC16 f1;
} GETDEVICECAPS16;
typedef GETDEVICECAPS16 UNALIGNED *PGETDEVICECAPS16;

typedef struct _GETDIBITS16 {           /* g441 */
    WORD f7;
    VPBITMAPINFO16 f6;
    VPSTR f5;
    WORD f4;
    WORD f3;
    HAND16 f2;
    HDC16 f1;
} GETDIBITS16;
typedef GETDIBITS16 UNALIGNED *PGETDIBITS16;

typedef struct _GETENVIRONMENT16 {      /* g133 */
    WORD f3;
    VPSTR f2;
    VPSTR f1;
} GETENVIRONMENT16;
typedef GETENVIRONMENT16 UNALIGNED *PGETENVIRONMENT16;

typedef struct _GETKERNINGPAIRS16 {      /* g332 */
    VPSTR f3;
    WORD f2;
    WORD f1;
} GETKERNINGPAIRS16;
typedef GETKERNINGPAIRS16 UNALIGNED *PGETKERNINGPAIRS16;


typedef struct _GETMAPMODE16 {          /* g81 */
    HDC16 f1;
} GETMAPMODE16;
typedef GETMAPMODE16 UNALIGNED *PGETMAPMODE16;

typedef struct _GETMETAFILE16 {         /* g124 */
    VPSTR f1;
} GETMETAFILE16;
typedef GETMETAFILE16 UNALIGNED *PGETMETAFILE16;

typedef struct _GETMETAFILEBITS16 {     /* g159 */
    HAND16 f1;
} GETMETAFILEBITS16;
typedef GETMETAFILEBITS16 UNALIGNED *PGETMETAFILEBITS16;

typedef struct _GETNEARESTCOLOR16 {     /* g154 */
    DWORD f2;
    HDC16 f1;
} GETNEARESTCOLOR16;
typedef GETNEARESTCOLOR16 UNALIGNED *PGETNEARESTCOLOR16;

typedef struct _GETNEARESTPALETTEINDEX16 {  /* g370 */
    DWORD f2;
    HPAL16 f1;
} GETNEARESTPALETTEINDEX16;
typedef GETNEARESTPALETTEINDEX16 UNALIGNED *PGETNEARESTPALETTEINDEX16;

typedef struct _GETOBJECT16 {           /* g82 */
    VPSTR f3;
    SHORT f2;
    HAND16 f1;
} GETOBJECT16;
typedef GETOBJECT16 UNALIGNED *PGETOBJECT16;

typedef struct _GETOBJECTTYPE16 {       /* g260 */
    HDC16 f1;
} GETOBJECTTYPE16;
typedef GETOBJECTTYPE16 UNALIGNED *PGETOBJECTTYPE16;

typedef struct _GETPALETTEENTRIES16 {       /* g363 */
    VPPALETTEENTRY16 f4;
    WORD f3;
    WORD f2;
    HPAL16 f1;
} GETPALETTEENTRIES16;
typedef GETPALETTEENTRIES16 UNALIGNED *PGETPALETTEENTRIES16;

typedef struct _GETPIXEL16 {            /* g83 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} GETPIXEL16;
typedef GETPIXEL16 UNALIGNED *PGETPIXEL16;

typedef struct _GETPOLYFILLMODE16 {     /* g84 */
    HDC16 f1;
} GETPOLYFILLMODE16;
typedef GETPOLYFILLMODE16 UNALIGNED *PGETPOLYFILLMODE16;

typedef struct _GETRGNBOX16 {           /* g134 */
    VPRECT16 f2;
    HRGN16 f1;
} GETRGNBOX16;
typedef GETRGNBOX16 UNALIGNED *PGETRGNBOX16;

typedef struct _GETROP216 {         /* g85 */
    HDC16 f1;
} GETROP216;
typedef GETROP216 UNALIGNED *PGETROP216;

typedef struct _GETSTOCKOBJECT16 {      /* g87 */
    SHORT f1;
} GETSTOCKOBJECT16;
typedef GETSTOCKOBJECT16 UNALIGNED *PGETSTOCKOBJECT16;
#define STOCK_MAX 19
/* XLATOFF */
// this is the only way we can tie STOCK_LAST with our assembly code
#if(STOCK_MAX != STOCK_LAST)
#error Must match sdk\inc\wingdi.h\STOCK_LAST
#endif
/* XLATON */

typedef struct _GETSTRETCHBLTMODE16 {       /* g88 */
    HDC16 f1;
} GETSTRETCHBLTMODE16;
typedef GETSTRETCHBLTMODE16 UNALIGNED *PGETSTRETCHBLTMODE16;

typedef struct _GETSYSTEMPALETTEENTRIES16 { /* g375 */
    VPPALETTEENTRY16 f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} GETSYSTEMPALETTEENTRIES16;
typedef GETSYSTEMPALETTEENTRIES16 UNALIGNED *PGETSYSTEMPALETTEENTRIES16;

typedef struct _GETSYSTEMPALETTEUSE16 {     /* g374 */
    HDC16 f1;
} GETSYSTEMPALETTEUSE16;
typedef GETSYSTEMPALETTEUSE16 UNALIGNED *PGETSYSTEMPALETTEUSE16;

typedef struct _GETTEXTALIGN16 {        /* g345 */
    HDC16 f1;
} GETTEXTALIGN16;
typedef GETTEXTALIGN16 UNALIGNED *PGETTEXTALIGN16;

typedef struct _GETTEXTCHARACTEREXTRA16 {   /* g89 */
    HDC16 f1;
} GETTEXTCHARACTEREXTRA16;
typedef GETTEXTCHARACTEREXTRA16 UNALIGNED *PGETTEXTCHARACTEREXTRA16;

typedef struct _GETTEXTCOLOR16 {        /* g90 */
    HDC16 f1;
} GETTEXTCOLOR16;
typedef GETTEXTCOLOR16 UNALIGNED *PGETTEXTCOLOR16;

typedef struct _GETTEXTEXTENT16 {       /* g91 */
    SHORT f3;
    VPSTR f2;
    HDC16 f1;
} GETTEXTEXTENT16;
typedef GETTEXTEXTENT16 UNALIGNED *PGETTEXTEXTENT16;

typedef struct _GETTEXTFACE16 {         /* g92 */
    VPSTR f3;
    SHORT f2;
    HDC16 f1;
} GETTEXTFACE16;
typedef GETTEXTFACE16 UNALIGNED *PGETTEXTFACE16;

typedef struct _GETTEXTMETRICS16 {      /* g93 */
    VPTEXTMETRIC16 f2;
    HDC16 f1;
} GETTEXTMETRICS16;
typedef GETTEXTMETRICS16 UNALIGNED *PGETTEXTMETRICS16;

typedef struct _GETVIEWPORTEXT16 {      /* g94 */
    HDC16 f1;
} GETVIEWPORTEXT16;
typedef GETVIEWPORTEXT16 UNALIGNED *PGETVIEWPORTEXT16;

typedef struct _GETVIEWPORTORG16 {      /* g95 */
    HDC16 f1;
} GETVIEWPORTORG16;
typedef GETVIEWPORTORG16 UNALIGNED *PGETVIEWPORTORG16;

typedef struct _GETWINDOWEXT16 {        /* g96 */
    HDC16 f1;
} GETWINDOWEXT16;
typedef GETWINDOWEXT16 UNALIGNED *PGETWINDOWEXT16;

typedef struct _GETWINDOWORG16 {        /* g97 */
    HDC16 f1;
} GETWINDOWORG16;
typedef GETWINDOWORG16 UNALIGNED *PGETWINDOWORG16;

typedef struct _INTERSECTCLIPRECT16 {       /* g22 */
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} INTERSECTCLIPRECT16;
typedef INTERSECTCLIPRECT16 UNALIGNED *PINTERSECTCLIPRECT16;

typedef struct _INVERTRGN16 {           /* g42 */
    HRGN16 f2;
    HDC16 f1;
} INVERTRGN16;
typedef INVERTRGN16 UNALIGNED *PINVERTRGN16;

typedef struct _LINEDDA16 {         /* g100 */
    VPSTR f6;
    VPPROC f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    SHORT f1;
} LINEDDA16;
typedef LINEDDA16 UNALIGNED *PLINEDDA16;

typedef struct _LINETO16 {          /* g19 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} LINETO16;
typedef LINETO16 UNALIGNED *PLINETO16;

typedef struct _LPTODP16 {          /* g99 */
    SHORT f3;
    VPPOINT16 f2;
    HDC16 f1;
} LPTODP16;
typedef LPTODP16 UNALIGNED *PLPTODP16;

typedef struct _MOVETO16 {          /* g20 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} MOVETO16;
typedef MOVETO16 UNALIGNED *PMOVETO16;

typedef struct _MULDIV16 {          /* g128 */
    SHORT f3;
    SHORT f2;
    SHORT f1;
} MULDIV16;
typedef MULDIV16 UNALIGNED *PMULDIV16;

typedef struct _OFFSETCLIPRGN16 {       /* g32 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} OFFSETCLIPRGN16;
typedef OFFSETCLIPRGN16 UNALIGNED *POFFSETCLIPRGN16;

typedef struct _OFFSETRGN16 {           /* g101 */
    SHORT f3;
    SHORT f2;
    HRGN16 f1;
} OFFSETRGN16;
typedef OFFSETRGN16 UNALIGNED *POFFSETRGN16;

typedef struct _OFFSETVIEWPORTORG16 {       /* g17 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} OFFSETVIEWPORTORG16;
typedef OFFSETVIEWPORTORG16 UNALIGNED *POFFSETVIEWPORTORG16;

typedef struct _OFFSETWINDOWORG16 {     /* g15 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} OFFSETWINDOWORG16;
typedef OFFSETWINDOWORG16 UNALIGNED *POFFSETWINDOWORG16;

typedef struct _PAINTRGN16 {            /* g43 */
    HRGN16 f2;
    HDC16 f1;
} PAINTRGN16;
typedef PAINTRGN16 UNALIGNED *PPAINTRGN16;

typedef struct _PATBLT16 {          /* g29 */
    DWORD dwRop;
    SHORT nHeight;
    SHORT nWidth;
    SHORT y;
    SHORT x;
    HDC16 hdc;
} PATBLT16;
typedef PATBLT16 UNALIGNED *PPATBLT16;

typedef struct _PIE16 {             /* g26 */
    SHORT f9;
    SHORT f8;
    SHORT f7;
    SHORT f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} PIE16;
typedef PIE16 UNALIGNED *PPIE16;

typedef struct _PLAYMETAFILE16 {        /* g123 */
    HAND16 f2;
    HDC16 f1;
} PLAYMETAFILE16;
typedef PLAYMETAFILE16 UNALIGNED *PPLAYMETAFILE16;

typedef struct _PLAYMETAFILERECORD16 {      /* g176 */
    WORD f4;
    VPMETARECORD16 f3;
    VPHANDLETABLE16 f2;
    HDC16 f1;
} PLAYMETAFILERECORD16;
typedef PLAYMETAFILERECORD16 UNALIGNED *PPLAYMETAFILERECORD16;

typedef struct _POLYGON16 {         /* g36 */
    SHORT f3;
    VPPOINT16 f2;
    HDC16 f1;
} POLYGON16;
typedef POLYGON16 UNALIGNED *PPOLYGON16;

typedef struct _POLYLINE16 {            /* g37 */
    SHORT f3;
    VPPOINT16 f2;
    HDC16 f1;
} POLYLINE16;
typedef POLYLINE16 UNALIGNED *PPOLYLINE16;

typedef struct _POLYPOLYGON16 {         /* g450 */
    SHORT f4;
    VPSHORT f3;
    VPPOINT16 f2;
    HDC16 f1;
} POLYPOLYGON16;
typedef POLYPOLYGON16 UNALIGNED *PPOLYPOLYGON16;

typedef struct _POLYPOLYLINEWOW16 {     /* g487 */
    DWORD f4;
    VPDWORD f3;
    VPDWORD f2;
    HDC16 f1;
} POLYPOLYLINEWOW16;
typedef POLYPOLYLINEWOW16 UNALIGNED *PPOLYPOLYLINEWOW16;

typedef struct _PTINREGION16 {          /* g161 */
    SHORT f3;
    SHORT f2;
    HRGN16 f1;
} PTINREGION16;
typedef PTINREGION16 UNALIGNED *PPTINREGION16;

typedef struct _PTVISIBLE16 {           /* g103 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} PTVISIBLE16;
typedef PTVISIBLE16 UNALIGNED *PPTVISIBLE16;

typedef struct _RECTANGLE16 {           /* g27 */
    SHORT y2;
    SHORT x2;
    SHORT y1;
    SHORT x1;
    HDC16 hdc;
} RECTANGLE16;
typedef RECTANGLE16 UNALIGNED *PRECTANGLE16;

typedef struct _RECTINREGION16 {        /* g181 */
    VPRECT16 f2;
    HRGN16 f1;
} RECTINREGION16;
typedef RECTINREGION16 UNALIGNED *PRECTINREGION16;

typedef struct _RECTVISIBLE16 {         /* g104 */
    VPRECT16 f2;
    HDC16 f1;
} RECTVISIBLE16;
typedef RECTVISIBLE16 UNALIGNED *PRECTVISIBLE16;

typedef struct _REMOVEFONTRESOURCE16 {      /* g136 */
    VPSTR f1;
} REMOVEFONTRESOURCE16;
typedef REMOVEFONTRESOURCE16 UNALIGNED *PREMOVEFONTRESOURCE16;

typedef struct _RESIZEPALETTE16 {       /* g368 */
    WORD f2;
    HPAL16 f1;
} RESIZEPALETTE16;
typedef RESIZEPALETTE16 UNALIGNED *PRESIZEPALETTE16;

typedef struct _RESTOREDC16 {           /* g39 */
    SHORT f2;
    HDC16 f1;
} RESTOREDC16;
typedef RESTOREDC16 UNALIGNED *PRESTOREDC16;

typedef struct _ROUNDRECT16 {           /* g28 */
    SHORT f7;
    SHORT f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} ROUNDRECT16;
typedef ROUNDRECT16 UNALIGNED *PROUNDRECT16;

typedef struct _SAVEDC16 {          /* g30 */
    HDC16 f1;
} SAVEDC16;
typedef SAVEDC16 UNALIGNED *PSAVEDC16;

typedef struct _SCALEVIEWPORTEXT16 {        /* g18 */
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SCALEVIEWPORTEXT16;
typedef SCALEVIEWPORTEXT16 UNALIGNED *PSCALEVIEWPORTEXT16;

typedef struct _SCALEWINDOWEXT16 {      /* g16 */
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SCALEWINDOWEXT16;
typedef SCALEWINDOWEXT16 UNALIGNED *PSCALEWINDOWEXT16;

typedef struct _SELECTCLIPRGN16 {       /* g44 */
    HRGN16 f2;
    HDC16 f1;
} SELECTCLIPRGN16;
typedef SELECTCLIPRGN16 UNALIGNED *PSELECTCLIPRGN16;

typedef struct _SELECTOBJECT16 {        /* g45 */
    HAND16 f2;
    HDC16 f1;
} SELECTOBJECT16;
typedef SELECTOBJECT16 UNALIGNED *PSELECTOBJECT16;

typedef struct _SETBITMAPBITS16 {       /* g106 */
    VPSTR f3;
    DWORD f2;
    HBM16 f1;
} SETBITMAPBITS16;
typedef SETBITMAPBITS16 UNALIGNED *PSETBITMAPBITS16;

typedef struct _SETBITMAPDIMENSION16 {      /* g163 */
    SHORT f3;
    SHORT f2;
    HBM16 f1;
} SETBITMAPDIMENSION16;
typedef SETBITMAPDIMENSION16 UNALIGNED *PSETBITMAPDIMENSION16;

typedef struct _SETBKCOLOR16 {          /* g1 */
    DWORD f2;
    HDC16 f1;
} SETBKCOLOR16;
typedef SETBKCOLOR16 UNALIGNED *PSETBKCOLOR16;

typedef struct _SETBKMODE16 {           /* g2 */
    SHORT f2;
    HDC16 f1;
} SETBKMODE16;
typedef SETBKMODE16 UNALIGNED *PSETBKMODE16;

typedef struct _SETBRUSHORG16 {         /* g148 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETBRUSHORG16;
typedef SETBRUSHORG16 UNALIGNED *PSETBRUSHORG16;

typedef struct _SETDIBITS16 {           /* g440 */
    WORD f7;
    VPBITMAPINFO16 f6;
    VPSTR f5;
    WORD f4;
    WORD f3;
    HAND16 f2;
    HDC16 f1;
} SETDIBITS16;
typedef SETDIBITS16 UNALIGNED *PSETDIBITS16;

typedef struct _SETDIBITSTODEVICE16 {       /* g443 */
    WORD f12;
    VPBITMAPINFO16 f11;
    VPSTR f10;
    WORD f9;
    WORD f8;
    WORD f7;
    WORD f6;
    WORD f5;
    WORD f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} SETDIBITSTODEVICE16;
typedef SETDIBITSTODEVICE16 UNALIGNED *PSETDIBITSTODEVICE16;

typedef struct _SETENVIRONMENT16 {      /* g132 */
    WORD f3;
    VPSTR f2;
    VPSTR f1;
} SETENVIRONMENT16;
typedef SETENVIRONMENT16 UNALIGNED *PSETENVIRONMENT16;

typedef struct _SETMAPMODE16 {          /* g3 */
    SHORT f2;
    HDC16 f1;
} SETMAPMODE16;
typedef SETMAPMODE16 UNALIGNED *PSETMAPMODE16;

typedef struct _SETMAPPERFLAGS16 {      /* g349 */
    DWORD f2;
    HDC16 f1;
} SETMAPPERFLAGS16;
typedef SETMAPPERFLAGS16 UNALIGNED *PSETMAPPERFLAGS16;

typedef struct _SETMETAFILEBITS16 {     /* g160 */
    HAND16 f1;
} SETMETAFILEBITS16;
typedef SETMETAFILEBITS16 UNALIGNED *PSETMETAFILEBITS16;

typedef struct _SETPALETTEENTRIES16 {       /* g364 */
    VPPALETTEENTRY16 f4;
    WORD f3;
    WORD f2;
    HPAL16 f1;
} SETPALETTEENTRIES16;
typedef SETPALETTEENTRIES16 UNALIGNED *PSETPALETTEENTRIES16;

typedef struct _SETPIXEL16 {            /* g31 */
    DWORD f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETPIXEL16;
typedef SETPIXEL16 UNALIGNED *PSETPIXEL16;

typedef struct _SETPOLYFILLMODE16 {     /* g6 */
    SHORT f2;
    HDC16 f1;
} SETPOLYFILLMODE16;
typedef SETPOLYFILLMODE16 UNALIGNED *PSETPOLYFILLMODE16;

typedef struct _SETRECTRGN16 {          /* g172 */
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HRGN16 f1;
} SETRECTRGN16;
typedef SETRECTRGN16 UNALIGNED *PSETRECTRGN16;

typedef struct _SETROP216 {         /* g4 */
    SHORT f2;
    HDC16 f1;
} SETROP216;
typedef SETROP216 UNALIGNED *PSETROP216;

typedef struct _SETSTRETCHBLTMODE16 {       /* g7 */
    SHORT f2;
    HDC16 f1;
} SETSTRETCHBLTMODE16;
typedef SETSTRETCHBLTMODE16 UNALIGNED *PSETSTRETCHBLTMODE16;

typedef struct _SETSYSTEMPALETTEUSE16 {     /* g373 */
    WORD f2;
    HDC16 f1;
} SETSYSTEMPALETTEUSE16;
typedef SETSYSTEMPALETTEUSE16 UNALIGNED *PSETSYSTEMPALETTEUSE16;

typedef struct _SETTEXTALIGN16 {        /* g346 */
    WORD f2;
    HDC16 f1;
} SETTEXTALIGN16;
typedef SETTEXTALIGN16 UNALIGNED *PSETTEXTALIGN16;

typedef struct _SETTEXTCHARACTEREXTRA16 {   /* g8 */
    SHORT f2;
    HDC16 f1;
} SETTEXTCHARACTEREXTRA16;
typedef SETTEXTCHARACTEREXTRA16 UNALIGNED *PSETTEXTCHARACTEREXTRA16;

typedef struct _SETTEXTCOLOR16 {        /* g9 */
    DWORD f2;
    HDC16 f1;
} SETTEXTCOLOR16;
typedef SETTEXTCOLOR16 UNALIGNED *PSETTEXTCOLOR16;

typedef struct _SETTEXTJUSTIFICATION16 {    /* g10 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETTEXTJUSTIFICATION16;
typedef SETTEXTJUSTIFICATION16 UNALIGNED *PSETTEXTJUSTIFICATION16;

typedef struct _SETVIEWPORTEXT16 {      /* g14 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETVIEWPORTEXT16;
typedef SETVIEWPORTEXT16 UNALIGNED *PSETVIEWPORTEXT16;

typedef struct _SETVIEWPORTORG16 {      /* g13 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETVIEWPORTORG16;
typedef SETVIEWPORTORG16 UNALIGNED *PSETVIEWPORTORG16;

typedef struct _SETWINDOWEXT16 {        /* g12 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETWINDOWEXT16;
typedef SETWINDOWEXT16 UNALIGNED *PSETWINDOWEXT16;

typedef struct _SETWINDOWORG16 {        /* g11 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETWINDOWORG16;
typedef SETWINDOWORG16 UNALIGNED *PSETWINDOWORG16;

#ifdef NULLSTRUCT
typedef struct _SHRINKGDIHEAP16 {        /* g354 */
} SHRINKGDIHEAP16;
typedef SHRINKGDIHEAP16 UNALIGNED *PSHRINKGDIHEAP16;
#endif

typedef struct _STRETCHBLT16 {          /* g35 */
    DWORD f11;
    SHORT f10;
    SHORT f9;
    SHORT f8;
    SHORT f7;
    HDC16 f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} STRETCHBLT16;
typedef STRETCHBLT16 UNALIGNED *PSTRETCHBLT16;

typedef struct _STRETCHDIBITS16 {       /* g439 */
    DWORD f13;
    WORD f12;
    VPBITMAPINFO16 f11;
    VPSTR f10;
    WORD f9;
    WORD f8;
    WORD f7;
    WORD f6;
    WORD f5;
    WORD f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} STRETCHDIBITS16;
typedef STRETCHDIBITS16 UNALIGNED *PSTRETCHDIBITS16;

typedef struct _TEXTOUT16 {         /* g33 */
    SHORT f5;
    VPSTR f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} TEXTOUT16;
typedef TEXTOUT16 UNALIGNED *PTEXTOUT16;

typedef struct _UNREALIZEOBJECT16 {     /* g150 */
    HBRSH16 f1;
} UNREALIZEOBJECT16;
typedef UNREALIZEOBJECT16 UNALIGNED *PUNREALIZEOBJECT16;

typedef struct _UPDATECOLORS16 {        /* g366 */
    HDC16 f1;
} UPDATECOLORS16;
typedef UPDATECOLORS16 UNALIGNED *PUPDATECOLORS16;

// These are new functions for win 31

typedef struct _ABORTDOC16 {            /* g382 */
    HDC16 f1;
} ABORTDOC16;
typedef ABORTDOC16 UNALIGNED *PABORTDOC16;

typedef struct _CREATESCALABLEFONTRESOURCE16 {  /* g510 */
    VPSZ f4;
    VPSZ f3;
    VPSZ f2;
    WORD  f1;
} CREATESCALABLEFONTRESOURCE16;
typedef CREATESCALABLEFONTRESOURCE16 UNALIGNED *PCREATESCALABLEFONTRESOURCE16;

typedef struct _ENDDOC16 {          /* g378 */
    HDC16 f1;
} ENDDOC16;
typedef ENDDOC16 UNALIGNED *PENDDOC16;

typedef struct _ENDPAGE16 {         /* g380 */
    HDC16 f1;
} ENDPAGE16;
typedef ENDPAGE16 UNALIGNED *PENDPAGE16;

typedef struct _ENUMFONTFAMILIES16 {        /* g330 */
    VPBYTE f4;
    VPPROC f3;
    VPSZ f2;
    HDC16 f1;
} ENUMFONTFAMILIES16;
typedef ENUMFONTFAMILIES16 UNALIGNED *PENUMFONTFAMILIES16;

typedef struct _GETBITMAPDIMENSIONEX16 {            /* g468 */
    VPVOID f2;
    WORD f1;
} GETBITMAPDIMENSIONEX16;
typedef GETBITMAPDIMENSIONEX16 UNALIGNED *PGETBITMAPDIMENSIONEX16;

typedef struct _GETBOUNDSRECT16 {           /* g194 */
    WORD f3;
    VPRECT16 f2;
    HDC16 f1;
} GETBOUNDSRECT16;
typedef GETBOUNDSRECT16 UNALIGNED *PGETBOUNDSRECT16;

typedef struct _GETBRUSHORGEX16 {           /* g469 */
    VPPOINT16 f2;
    HDC16 f1;
} GETBRUSHORGEX16;
typedef GETBRUSHORGEX16 UNALIGNED *PGETBRUSHORGEX16;

typedef struct _GETCHARABCWIDTHS16 {        /* g307 */
    VPVOID f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} GETCHARABCWIDTHS16;
typedef GETCHARABCWIDTHS16 UNALIGNED *PGETCHARABCWIDTHS16;

typedef struct _GETCURRENTPOSITIONEX16 {            /* g470 */
    VPPOINT16 f2;
    HDC16 f1;
} GETCURRENTPOSITIONEX16;
typedef GETCURRENTPOSITIONEX16 UNALIGNED *PGETCURRENTPOSITIONEX16;

typedef struct _GETFONTDATA16 {     /* g311 */
    DWORD f5;
    VPVOID f4;
    DWORD f3;
    DWORD f2;
    HDC16 f1;
} GETFONTDATA16;
typedef GETFONTDATA16 UNALIGNED *PGETFONTDATA16;

typedef struct _GETGLYPHOUTLINE16 {     /* g309 */
    VPVOID f7;
    VPVOID f6;
    DWORD f5;
    VPVOID f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} GETGLYPHOUTLINE16;
typedef GETGLYPHOUTLINE16 UNALIGNED *PGETGLYPHOUTLINE16;

typedef struct _GETOULTLINETEXTMETRICS16 {  /* g1000 */
    VPVOID f3;
    WORD f2;
    HDC16 f1;
} GETOULTLINETEXTMETRICS16;
typedef GETOULTLINETEXTMETRICS16 UNALIGNED *PGETOULTLINETEXTMETRICS16;

typedef struct _GETRASTERIZERCAPS16 {   /* g313 */
    SHORT f2;
    VPVOID f1;
} GETRASTERIZERCAPS16;
typedef GETRASTERIZERCAPS16 UNALIGNED *PGETRASTERIZERCAPS16;

typedef struct _GETTEXTEXTENTPOINT16 {      /* gxx */
    VPVOID f4;
    SHORT f3;
    VPSZ f2;
    HDC16 f1;
} GETTEXTEXTENTPOINT16;
typedef GETTEXTEXTENTPOINT16 UNALIGNED *PGETTEXTEXTENTPOINT16;

typedef struct _GETVIEWPORTEXTEX16 {        /* g472 */
    VPVOID f2;
    HDC16 f1;
} GETVIEWPORTEXTEX16;
typedef GETVIEWPORTEXTEX16 UNALIGNED *PGETVIEWPORTEXTEX16;

typedef struct _GETVIEWPORTORGEX16 {        /* g473 */
    VPPOINT16 f2;
    HDC16 f1;
} GETVIEWPORTORGEX16;
typedef GETVIEWPORTORGEX16 UNALIGNED *PGETVIEWPORTORGEX16;

typedef struct _GETWINDOWEXTEX16 {      /* g474 */
    VPVOID f2;
    HDC16 f1;
} GETWINDOWEXTEX16;
typedef GETWINDOWEXTEX16 UNALIGNED *PGETWINDOWEXTEX16;

typedef struct _GETWINDOWORGEX16 {      /* g475 */
    VPPOINT16 f2;
    HDC16 f1;
} GETWINDOWORGEX16;
typedef GETWINDOWORGEX16 UNALIGNED *PGETWINDOWORGEX16;

typedef struct _ISGDIOBJECT16 {     /* g462 */
    WORD f1;
} ISGDIOBJECT16;
typedef ISGDIOBJECT16 UNALIGNED *PISGDIOBJECT16;

typedef struct _MOVETOEX16 {        /* g483 */
    VPPOINT16 f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} MOVETOEX16;
typedef MOVETOEX16 UNALIGNED *PMOVETOEX16;

typedef struct _OFFSETVIEWPORTORGEX16 {     /* g476 */
    VPPOINT16 f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} OFFSETVIEWPORTORGEX16;
typedef OFFSETVIEWPORTORGEX16 UNALIGNED *POFFSETVIEWPORTORGEX16;

typedef struct _OFFSETWINDOWORGEX16 {       /* g477 */
    VPPOINT16 f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} OFFSETWINDOWORGEX16;
typedef OFFSETWINDOWORGEX16 UNALIGNED *POFFSETWINDOWORGEX16;

typedef struct _QUERTABORT16 {      /* gxxx */
    SHORT f2;
    HDC16 f1;
} QUERTABORT16;
typedef QUERTABORT16 UNALIGNED *PQUERTABORT16;

typedef struct _RESETDC16 {     /* g376 */
    VPVOID f2;
    HDC16 f1;
} RESETDC16;
typedef RESETDC16 UNALIGNED *PRESETDC16;

typedef struct _SCALEVIEWPORTEXTEX16 {      /* g484 */
    VPVOID f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SCALEVIEWPORTEXTEX16;
typedef SCALEVIEWPORTEXTEX16 UNALIGNED *PSCALEVIEWPORTEXTEX16;

typedef struct _SCALEWINDOWEXTEX16 {        /* g485 */
    VPVOID f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SCALEWINDOWEXTEX16;
typedef SCALEWINDOWEXTEX16 UNALIGNED *PSCALEWINDOWEXTEX16;

typedef struct _SETABORTPROC16 {        /* g381 */
    VPVOID f2;
    HDC16 f1;
} SETABORTPROC16;
typedef SETABORTPROC16 UNALIGNED *PSETABORTPROC16;

typedef struct _SETBITMAPDIMENSIONEX16 {        /* g478 */
    VPVOID f4;
    SHORT f3;
    SHORT f2;
    WORD f1;
} SETBITMAPDIMENSIONEX16;
typedef SETBITMAPDIMENSIONEX16 UNALIGNED *PSETBITMAPDIMENSIONEX16;

typedef struct _SETBOUNDSRECT16 {       /* g193 */
    WORD f3;
    VPRECT16 f2;
    HDC16 f1;
} SETBOUNDSRECT16;
typedef SETBOUNDSRECT16 UNALIGNED *PSETBOUNDSRECT16;

typedef struct _SETMETAFILEBITSBETTER16 {       /* g196 */
    WORD f1;
} SETMETAFILEBITSBETTER16;
typedef SETMETAFILEBITSBETTER16 UNALIGNED *PSETMETAFILEBITSBETTER16;

typedef struct _SETVIEWPORTEXTEX16 {        /* g479 */
    VPVOID f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETVIEWPORTEXTEX16;
typedef SETVIEWPORTEXTEX16 UNALIGNED *PSETVIEWPORTEXTEX16;

typedef struct _SETVIEWPORTORGEX16 {        /* g480 */
    VPPOINT16 f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETVIEWPORTORGEX16;
typedef SETVIEWPORTORGEX16 UNALIGNED *PSETVIEWPORTORGEX16;

typedef struct _SETWINDOWEXTEX16 {      /* g481 */
    VPVOID f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETWINDOWEXTEX16;
typedef SETWINDOWEXTEX16 UNALIGNED *PSETWINDOWEXTEX16;

typedef struct _SETWINDOWORGEX16 {      /* g482 */
    VPPOINT16 f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETWINDOWORGEX16;
typedef SETWINDOWORGEX16 UNALIGNED *PSETWINDOWORGEX16;

typedef struct _SPOOLFILE16 {       /* g254 */
    VPSZ f4;
    VPSZ f3;
    VPSZ f2;
    VPSZ f1;
} SPOOLFILE16;
typedef SPOOLFILE16 UNALIGNED *PSPOOLFILE16;

typedef struct _STARTDOC16 {        /* g377 */
    VPVOID f2;
    HDC16 f1;
} STARTDOC16;
typedef STARTDOC16 UNALIGNED *PSTARTDOC16;

typedef struct _STARTPAGE16 {       /* g379 */
    HDC16 f1;
} STARTPAGE16;
typedef STARTPAGE16 UNALIGNED *PSTARTPAGE16;

typedef struct _GETOUTLINETEXTMETRICS16 {       /* g308 */
    VPVOID f3;
    WORD f2;
    HDC16 f1;
} GETOUTLINETEXTMETRICS16;
typedef GETOUTLINETEXTMETRICS16 UNALIGNED *PGETOUTLINETEXTMETRICS16;

typedef struct _DOCINFO16 {                    /* di16wow32 */
    SHORT   cbSize;
    VPSZ    lpszDocName;
    VPSZ    lpszOutput;
} DOCINFO16;
typedef DOCINFO16 UNALIGNED *LPDOCINFO16;

typedef struct _SIZE16 {                       /* sz16wow32 */
    SHORT   cx;
    SHORT   cy;
} SIZE16;
typedef SIZE16 UNALIGNED *PSIZE16;
typedef VPVOID VPSIZE16;

typedef struct _INQUIREVISRGN16 {       /* g131 */
    HDC16 f1;
}INQUIREVISRGN16;
typedef INQUIREVISRGN16 UNALIGNED *PINQUIREVISRGN16;

typedef struct _GETCLIPRGN16 {       /* g173 */
    HDC16   f1;
}GETCLIPRGN16;
typedef GETCLIPRGN16 UNALIGNED *PGETCLIPRGN16;


typedef struct _OPENJOB16 {  /* g240 */
    WORD    f3;
    VPSZ    f2;
    VPSZ    f1;
} OPENJOB16;
typedef OPENJOB16 UNALIGNED *POPENJOB16;

typedef struct _STARTSPOOLPAGE16 {  /* g246 */
    HAND16 f1;
} STARTSPOOLPAGE16;
typedef STARTSPOOLPAGE16 UNALIGNED *PSTARTSPOOLPAGE16;

typedef struct _ENDSPOOLPAGE16 {  /* g247 */
    HAND16 f1;
} ENDSPOOLPAGE16;
typedef ENDSPOOLPAGE16 UNALIGNED *PENDSPOOLPAGE16;

typedef struct _CLOSEJOB16 {  /* g243 */
    HAND16 f1;
} CLOSEJOB16;
typedef CLOSEJOB16 UNALIGNED *PCLOSEJOB16;

typedef struct _WRITESPOOL16 {  /* g241 */
    WORD    f3;
    VPSZ    f2;
    HAND16  f1;
} WRITESPOOL16;
typedef WRITESPOOL16 UNALIGNED *PWRITESPOOL16;

typedef struct _DELETEJOB16 {  /* g244 */
    WORD    f2;
    HAND16  f1;
} DELETEJOB16;
typedef DELETEJOB16 UNALIGNED *PDELETEJOB16;

typedef struct _WRITEDIALOG16 {  /* g242 */
    WORD    f3;
    VPSZ    f2;
    HAND16  f1;
} WRITEDIALOG16;
typedef WRITEDIALOG16 UNALIGNED *PWRITEDIALOG16;

#ifdef FE_SB
// GetFontAssocStatus @488->459 for Taiwan, Prc and Korea
typedef struct _GETFONTASSOCSTATUS16 {          /* g459 */
    HDC16 f1;
} GETFONTASSOCSTATUS16;
typedef GETFONTASSOCSTATUS16 UNALIGNED *PGETFONTASSOCSTATUS16;
#endif  // FE_SB

typedef struct _DMBITBLT16 {  /* g201 */
    VPSZ    pdrawmode;
    VPSZ    pbrush;
    LONG    rop;
    WORD    exty;
    WORD    extx;
    WORD    srcy;
    WORD    srcx;
    VPSZ    pbitmapsrc;
    WORD    desty;
    WORD    destx;
    VPSZ    pbitmapdest;
} DMBITBLT16;
typedef DMBITBLT16 UNALIGNED *PDMBITBLT16;

typedef struct _GETCURLOGFONT16 {        /* g411 */
    HAND16 hDC;
} GETCURLOGFONT16;
typedef GETCURLOGFONT16 UNALIGNED *PGETCURLOGFONT16;


/* New for NT 5.0 Win95 compatibility */


typedef struct _ABORTPATH16 {        /* g511 */
    HDC16 hdc;
} ABORTPATH16;
typedef ABORTPATH16 UNALIGNED *PABORTPATH16;

typedef struct _ABORTPRINTER16 {        /* g271 */
    DWORD hPrinter;
} ABORTPRINTER16;
typedef ABORTPRINTER16 UNALIGNED *PABORTPRINTER16;

typedef struct _ADDLPKTOGDI16 {        /* g614 */
    WORD  iCharset;
    WORD  hlibLPK;
} ADDLPKTOGDI16;
typedef ADDLPKTOGDI16 UNALIGNED *PADDLPKTOGDI16;

typedef struct _BEGINPATH16 {        /* g512 */
    HDC16 hdc;
} BEGINPATH16;
typedef BEGINPATH16 UNALIGNED *PBEGINPATH16;

typedef struct _BUILDINVERSETABLEDIB16 {        /* g617 */
    DWORD  dwUniqueID;
    VPVOID lpbi;
} BUILDINVERSETABLEDIB16;
typedef BUILDINVERSETABLEDIB16 UNALIGNED *PBUILDINVERSETABLEDIB16;

typedef struct _CLOSEENHMETAFILE16 {        /* g490 */
    HDC16 hdc;
} CLOSEENHMETAFILE16;
typedef CLOSEENHMETAFILE16 UNALIGNED *PCLOSEENHMETAFILE16;

typedef struct _CLOSEFIGURE16 {        /* g513 */
    HDC16 hdc;
} CLOSEFIGURE16;
typedef CLOSEFIGURE16 UNALIGNED *PCLOSEFIGURE16;

typedef struct _CLOSEPRINTER16 {        /* g274 */
    DWORD  hPrinter;
} CLOSEPRINTER16;
typedef CLOSEPRINTER16 UNALIGNED *PCLOSEPRINTER16;

typedef struct _COPYENHMETAFILE16 {        /* g491 */
    VPSTR   lpszFile;
    HAND16  hemfSrc;
} COPYENHMETAFILE16;
typedef COPYENHMETAFILE16 UNALIGNED *PCOPYENHMETAFILE16;

typedef struct _CREATEENHMETAFILE16 {        /* g492 */
    VPSTR     lpszDescription;
    VPRECTL16 lprclFrame;
    VPSTR     lpszFile;
    HDC16     hdcRef;
} CREATEENHMETAFILE16;
typedef CREATEENHMETAFILE16 UNALIGNED *PCREATEENHMETAFILE16;

typedef struct _CREATEHALFTONEPALETTE16 {        /* g529 */
    HDC16 hdc;
} CREATEHALFTONEPALETTE16;
typedef CREATEHALFTONEPALETTE16 UNALIGNED *PCREATEHALFTONEPALETTE16;

typedef struct _DELETEENHMETAFILE16 {        /* g493 */
    HAND16 hemf;
} DELETEENHMETAFILE16;
typedef DELETEENHMETAFILE16 UNALIGNED *PDELETEENHMETAFILE16;

typedef struct _DRVGETPRINTERDATA16 {        /* g282 */
    VPDWORD   lpdwNeeded;
    DWORD     cbData;
    VPBYTE    lpData;
    VPDWORD   lpdwType;
    VPSTR     lpszValueName;
    VPSTR     lpszPrinter;
} DRVGETPRINTERDATA16;
typedef DRVGETPRINTERDATA16 UNALIGNED *PDRVGETPRINTERDATA16;

typedef struct _DRVSETPRINTERDATA16 {        /* g281 */
    DWORD     cbData;
    VPBYTE    lpData;
    VPDWORD   lpdwType;
    VPSTR     lpszValueName;
    VPSTR     lpszPrinter;
} DRVSETPRINTERDATA16;
typedef DRVSETPRINTERDATA16 UNALIGNED *PDRVSETPRINTERDATA16;

typedef struct _ENDDOCPRINTER16 {        /* g272 */
    DWORD     hPrinter;
} ENDDOCPRINTER16;
typedef ENDDOCPRINTER16 UNALIGNED *PENDDOCPRINTER16;

typedef struct _ENDPAGEPRINTER16 {        /* g270 */
    DWORD     hPrinter;
} ENDPAGEPRINTER16;
typedef ENDPAGEPRINTER16 UNALIGNED *PENDPAGEPRINTER16;

typedef struct _ENDPATH16 {        /* g514 */
    HDC16 hdc;
} ENDPATH16;
typedef ENDPATH16 UNALIGNED *PENDPATH16;

typedef struct _ENGINEGETCHARWIDTHEX16 {        /* g299 */
    VPWORD    lpwWidths;
    WORD      nLast;
    WORD      nFirst;
    VPVOID    lpEFont;
} ENGINEGETCHARWIDTHEX16;
typedef ENGINEGETCHARWIDTHEX16 UNALIGNED *PENGINEGETCHARWIDTHEX16;

typedef struct _ENGINEGETCHARWIDTHSTR16 {        /* g316 */
    VPWORD    lpwWidths;
    WORD      wCount;
    VPSTR     lpGlyphs;
    VPVOID    lpEFont;
} ENGINEGETCHARWIDTHSTR16;
typedef ENGINEGETCHARWIDTHSTR16 UNALIGNED *PENGINEGETCHARWIDTHSTR16;

typedef struct _ENGINEGETGLYPHBMPEXT16 {        /* g305 */
    VPVOID    lpBmpMetrics;
    DWORD     dwSizeBmp;
    VPVOID    lpBitmap;
    WORD      wQueryType;
    WORD      wChar;
    VPVOID    lpEFont;
    HDC16     hdc;
} ENGINEGETGLYPHBMPEXT16;
typedef ENGINEGETGLYPHBMPEXT16 UNALIGNED *PENGINEGETGLYPHBMPEXT16;

typedef struct _ENGINEREALIZEFONTEXT16 {        /* g315 */
    WORD        wFlags;
    VPVOID      lpFont;
    VPVOID      lpTextTransform;
    VPLOGFONT16 lpLogFont;
    HDC16       hdc;
} ENGINEREALIZEFONTEXT16;
typedef ENGINEREALIZEFONTEXT16 UNALIGNED *PENGINEREALIZEFONTEXT16;

typedef struct _ENUMFONTFAMILIESEX16 {        /* g613 */
    DWORD       dwFlags;
    VPVOID      lpClientData;
    VPPROC      lpfnCallBack;
    VPLOGFONT16 lpLogFont;
    HDC16       hdc;
} ENUMFONTFAMILIESEX16;
typedef ENUMFONTFAMILIESEX16 UNALIGNED *PENUMFONTFAMILIESEX16;

typedef struct _EXTCREATEPEN16 {        /* g523 */
    VPVOID    lpStyle;
    DWORD     dwStyleCount;
    VPVOID    lpntlb;
    DWORD     dwWidth;
    DWORD     dwPenStyle;
} EXTCREATEPEN16;
typedef EXTCREATEPEN16 UNALIGNED *PEXTCREATEPEN16;

typedef struct _EXTCREATEREGION16 {        /* g608 */
    VPVOID    lpRgnData;
    DWORD     dwCount;
    VPBYTE    lpReserved;
} EXTCREATEREGION16;
typedef EXTCREATEREGION16 UNALIGNED *PEXTCREATEREGION16;

typedef struct _EXTSELECTCLIPRGN16 {        /* g508 */
    SHORT     iMode;
    HRGN16    hrgn;
    HDC16     hdc;
} EXTSELECTCLIPRGN16;
typedef EXTSELECTCLIPRGN16 UNALIGNED *PEXTSELECTCLIPRGN16;

typedef struct _FILLPATH16 {        /* g515 */
    HDC16  hdc;
} FILLPATH16;
typedef FILLPATH16 UNALIGNED *PFILLPATH16;

typedef struct _FLATTENPATH16 {        /* g516 */
    HDC16  hdc;
} FLATTENPATH16;
typedef FLATTENPATH16 UNALIGNED *PFLATTENPATH16;

typedef struct _GDICOMMENT16 {        /* g495 */
    VPBYTE  lpData;
    DWORD   cbSize;
    HDC16   hdc;
} GDICOMMENT16;
typedef GDICOMMENT16 UNALIGNED *PGDICOMMENT16;

typedef struct _GDIPARAMETERSINFO16 {        /* g528 */
    WORD   flags;
    VPVOID lParam;
    WORD   wParam;
    WORD   wFlag;
} GDIPARAMETERSINFO16;
typedef GDIPARAMETERSINFO16 UNALIGNED *PGDIPARAMETERSINFO16;

typedef struct _GDISIGNALPROC3216 {        /* g610 */
    WORD  hTask16;
    DWORD dwFlags;
    DWORD dwID;
    DWORD dwSignalID;
} GDISIGNALPROC3216;
typedef GDISIGNALPROC3216 UNALIGNED *PGDISIGNALPROC3216;

typedef struct _GETARCDIRECTION16 {        /* g524 */
    HDC16 hdc;
} GETARCDIRECTION16;
typedef GETARCDIRECTION16 UNALIGNED *PGETARCDIRECTION16;

typedef struct _GCP_RESULTS16                /* gcp_r */
{
    DWORD lStructSize;
    VPSTR lpOutString;
    VPSTR lpOrder;
    VPSTR lpDx;
    VPSTR lpCaretPos;
    VPSTR lpClass;
    VPSTR lpGlyphs;
    SHORT nGlyphs;
    SHORT nMaxFit;
} GCP_RESULTS16;
typedef GCP_RESULTS16 UNALIGNED *PGCP_RESULTS16;

typedef struct _GETCHARACTERPLACEMENT16 {        /* g615 */
    DWORD  dwFlags;
    VPVOID lpResults;
    WORD   wMaxExtent;
    WORD   wCount;
    VPSTR  lpszText;
    HDC16  hdc;
} GETCHARACTERPLACEMENT16;
typedef GETCHARACTERPLACEMENT16 UNALIGNED *PGETCHARACTERPLACEMENT16;

typedef struct _GETENHMETAFILE16 {        /* g496 */
    VPSTR lpszFile;
} GETENHMETAFILE16;
typedef GETENHMETAFILE16 UNALIGNED *PGETENHMETAFILE16;

typedef struct _GETENHMETAFILEBITS16 {        /* g497 */
    VPBYTE  lpBuffer;
    DWORD   cbBuffer;
    HAND16  hemf;
} GETENHMETAFILEBITS16;
typedef GETENHMETAFILEBITS16 UNALIGNED *PGETENHMETAFILEBITS16;

typedef struct _GETENHMETAFILEDESCRIPTION16 {        /* g498 */
    VPSTR   lpszBuffer;
    DWORD   cbBuffer;
    HAND16  hemf;
} GETENHMETAFILEDESCRIPTION16;
typedef GETENHMETAFILEDESCRIPTION16 UNALIGNED *PGETENHMETAFILEDESCRIPTION16;

typedef struct _GETENHMETAFILEHEADER16 {        /* g499 */
    VPVOID  lpmrmf;
    DWORD   cbBuffer;
    HAND16  hemf;
} GETENHMETAFILEHEADER16;
typedef GETENHMETAFILEHEADER16 UNALIGNED *PGETENHMETAFILEHEADER16;

typedef struct _GETENHMETAFILEPALETTEENTRIES16 {        /* g501 */
    VPVOID  lpclr;
    DWORD   cEntries;
    HAND16  hemf;
} GETENHMETAFILEPALETTEENTRIES16;
typedef GETENHMETAFILEPALETTEENTRIES16 UNALIGNED *PGETENHMETAFILEPALETTEENTRIES16;

typedef struct _GETFONTLANGUAGEINFO16 {        /* g616 */
    HDC16 hdc;
} GETFONTLANGUAGEINFO16;
typedef GETFONTLANGUAGEINFO16 UNALIGNED *PGETFONTLANGUAGEINFO16;

typedef struct _GETMITERLIMIT16 {        /* g526 */
    VPLONG lpMiter;
    HDC16  hdc;
} GETMITERLIMIT16;
typedef GETMITERLIMIT16 UNALIGNED *PGETMITERLIMIT16;

typedef struct _GETPATH16 {        /* g517 */
    LONG       cptl;
    VPBYTE     lpby;
    VPPOINTL16 lpptl;
    HDC16      hdc;
} GETPATH16;
typedef GETPATH16 UNALIGNED *PGETPATH16;

typedef struct _GETRANDOMRGN16 {        /* g611 */
    WORD     iType;
    HRGN16   hrgn;
    HDC16    hdc;
} GETRANDOMRGN16;
typedef GETRANDOMRGN16 UNALIGNED *PGETRANDOMRGN16;

typedef struct _GETREALDRIVERINFO16 {        /* g280 */
    VPSTR lpszDriverPath;
    VPSTR lpszDeviceName;
    VPSTR lpszPrinterName;
} GETREALDRIVERINFO16;
typedef GETREALDRIVERINFO16 UNALIGNED *PGETREALDRIVERINFO16;

typedef struct _GETREGIONDATA16 {        /* g607 */
    VPVOID  lpRgnData;
    DWORD   dwCount;
    HDC16   hrgn;
} GETREGIONDATA16;
typedef GETREGIONDATA16 UNALIGNED *PGETREGIONDATA16;

typedef struct _GETTEXTCHARSET16 {        /* g612 */
    HDC16  hdc;
} GETTEXTCHARSET16;
typedef GETTEXTCHARSET16 UNALIGNED *PGETTEXTCHARSET16;

typedef struct _GETTEXTEXTENTEX16 {        /* g188 */
    WORD    wFlags;
    VPWORD  lpDx;
    VPWORD  lpnFit;
    WORD    wMaxExtent;
    WORD    wCount;
    VPSTR   lpszString;
    HDC16   hdc;
} GETTEXTEXTENTEX16;
typedef GETTEXTEXTENTEX16 UNALIGNED *PGETTEXTEXTENTEX16;

typedef struct _GETTTGLYPHINDEXMAP16 {        /* g404 */
    VPVOID  lpEFont;
    WORD    wCharSet;
} GETTTGLYPHINDEXMAP16;
typedef GETTTGLYPHINDEXMAP16 UNALIGNED *PGETTTGLYPHINDEXMAP16;

typedef struct _ICMCHECKCOLORSINGAMUT16 {        /* g622 */
    DWORD  f4;
    VPBYTE f3;
    VPVOID lpRGBQuad;
    DWORD  hcmTransform;
} ICMCHECKCOLORSINGAMUT16;
typedef ICMCHECKCOLORSINGAMUT16 UNALIGNED *PICMCHECKCOLORSINGAMUT16;

typedef struct _ICMCREATETRANSFORM16 {        /* g618 */
    VPBYTE lpdevchar;
    VPBYTE lpdevcharacter;
    VPBYTE lplogcolorspace;
} ICMCREATETRANSFORM16;
typedef ICMCREATETRANSFORM16 UNALIGNED *PICMCREATETRANSFORM16;

typedef struct _ICMDELETETRANSFORM16 {        /* g619 */
    DWORD     huh;
    VPDWORD   lpColorRef;
    RGBQUAD16 rgbQuad;
    DWORD     hcmTransform;
} ICMDELETETRANSFORM16;
typedef ICMDELETETRANSFORM16 UNALIGNED *PICMDELETETRANSFORM16;

typedef struct _ICMTRANSLATERGB16 {        /* g620 */
    DWORD     huh;
    VPDWORD   lpColorRef;
    RGBQUAD16 rgbQuad;
    DWORD     hcmTransform;
} ICMTRANSLATERGB16;
typedef ICMTRANSLATERGB16 UNALIGNED *PICMTRANSLATERGB16;

typedef struct _ICMTRANSLATERGBS16 {        /* g621 */
    DWORD     flags;
    DWORD     destflags;
    VPVOID    lpdest;
    DWORD     nsrcwrap;
    DWORD     nsrcheight;
    DWORD     hsrcwidth;
    DWORD     srcflags;
    VPVOID    lpsrc;
} ICMTRANSLATERGBS16;
typedef ICMTRANSLATERGBS16 UNALIGNED *PICMTRANSLATERGBS16;

typedef struct _OPENPRINTERA16 {        /* g266 */
    VPVOID  lppd;
    VPDWORD hPrinter;
    VPSTR   lpszPrinter;
} OPENPRINTERA16;
typedef OPENPRINTERA16 UNALIGNED *POPENPRINTERA16;

typedef struct _PATHTOREGION16 {        /* g518 */
    HDC16 hdc;
} PATHTOREGION16;
typedef PATHTOREGION16 UNALIGNED *PPATHTOREGION16;

typedef struct _PLAYENHMETAFILERECORD16 {        /* g504 */
    DWORD   dwHandles;
    VPVOID  lpemr;
    VPVOID  lpht;
    HDC16   hdc;
} PLAYENHMETAFILERECORD16;
typedef PLAYENHMETAFILERECORD16 UNALIGNED *PPLAYENHMETAFILERECORD16;

typedef struct _POLYBEZIER16 {        /* g502 */
    SHORT     f3;
    VPPOINT16 f2;
    HDC16     f1;
} POLYBEZIER16;
typedef POLYBEZIER16 UNALIGNED *PPOLYBEZIER16;

typedef struct _POLYBEZIERTO16 {        /* g503 */
    SHORT     f3;
    VPPOINT16 f2;
    HDC16     f1;
} POLYBEZIERTO16;
typedef POLYBEZIERTO16 UNALIGNED *PPOLYBEZIERTO16;

typedef struct _SELECTCLIPPATH16 {        /* g519 */
    SHORT     iMode;
    HDC16     hdc;
} SELECTCLIPPATH16;
typedef SELECTCLIPPATH16 UNALIGNED *PSELECTCLIPPATH16;

typedef struct _SETARCDIRECTION16 {        /* g525 */
    SHORT     iArcDirection;
    HDC16     hdc;
} SETARCDIRECTION16;
typedef SETARCDIRECTION16 UNALIGNED *PSETARCDIRECTION16;

typedef struct _SETENHMETAFILEBITS16 {        /* g505 */
    VPBYTE  lpBuffer;
    DWORD   cbBuffer;
} SETENHMETAFILEBITS16;
typedef SETENHMETAFILEBITS16 UNALIGNED *PSETENHMETAFILEBITS16;

typedef struct _SETMAGICCOLORS16 {        /* g606 */
    WORD   iColor;
    DWORD  c1;
    HDC16  hdc;
} SETMAGICCOLORS16;
typedef SETMAGICCOLORS16 UNALIGNED *PSETMAGICCOLORS16;

typedef struct _SETMETARGN16 {        /* g506 */
    HDC16  hdc;
} SETMETARGN16;
typedef SETMETARGN16 UNALIGNED *PSETMETARGN16;

typedef struct _SETMITERLIMIT16 {        /* g527 */
    VPLONG  lpeMiter;
    LONG    eMiter;
    HDC16   hdc;
} SETMITERLIMIT16;
typedef SETMITERLIMIT16 UNALIGNED *PSETMITERLIMIT16;

typedef struct _SETSOLIDBRUSH16 {        /* g604 */
    DWORD   rgbNewColor;
    HAND16  hbrush;
} SETSOLIDBRUSH16;
typedef SETSOLIDBRUSH16 UNALIGNED *PSETSOLIDBRUSH16;

typedef struct _STARTDOCPRINTERA16 {        /* g267 */
    VPVOID  lpDocInfo;
    DWORD   dwLevel;
    DWORD   hPrinter;
} STARTDOCPRINTERA16;
typedef STARTDOCPRINTERA16 UNALIGNED *PSTARTDOCPRINTERA16;

typedef struct _STARTPAGEPRINTER16 {        /* g268 */
    DWORD   hPrinter;
} STARTPAGEPRINTER16;
typedef STARTPAGEPRINTER16 UNALIGNED *PSTARTPAGEPRINTER16;

typedef struct _STROKEANDFILLPATH16 {        /* g520 */
    HDC16 hdc;
} STROKEANDFILLPATH16;
typedef STROKEANDFILLPATH16 UNALIGNED *PSTROKEANDFILLPATH16;

typedef struct _STROKEPATH16 {        /* g521 */
    HDC16 hdc;
} STROKEPATH16;
typedef STROKEPATH16 UNALIGNED *PSTROKEPATH16;

typedef struct _SYSDELETEOBJECT16 {        /* g605 */
    HAND16 h;
} SYSDELETEOBJECT16;
typedef SYSDELETEOBJECT16 UNALIGNED *PSYSDELETEOBJECT16;

typedef struct _WIDENPATH16 {        /* g522 */
    HDC16 hdc;
} WIDENPATH16;
typedef WIDENPATH16 UNALIGNED *PWIDENPATH16;

typedef struct _WRITEPRINTER16 {        /* g269 */
    VPDWORD lpdwWritten;
    DWORD   cbBuf;
    VPVOID  lpBuf;
    DWORD   hPrinter;
} WRITEPRINTER16;
typedef WRITEPRINTER16 UNALIGNED *PWRITEPRINTER16;

/* XLATOFF */
#pragma pack()

/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowkrn.h ===
/*++ BUILD Version: 0002
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWKRN.H
 *  16-bit Kernel API argument structures
 *
 *  History:
 *  Created 02-Feb-1991 by Jeff Parsons (jeffpar)
 *  01-May-91 Matt Felton (mattfe) added Private Callback CHECKLOADMODULEDRV
--*/


/* Kernel API IDs -- loosely based on kernel export ordinals, attempting to keep the table size
 * down.
 */

#define FUN_FATALEXIT                    1   //
#define FUN_EXITKERNEL                   2   // Internal
#define FUN_WRITEOUTPROFILES             3   // really 315 export 3 GetVersion not thunked
#define FUN_MAPSL                        4   // really 357 export 4 LocalInit not thunked
#define FUN_MAPLS                        5   // really 358 export 5 LocalAlloc not thunked
#define FUN_UNMAPLS                      6   // really 359 export 6 LocalReAlloc not thunked
#define FUN_OPENFILEEX                   7   // really 360 export 7 LocalFree not thunked
#define FUN_FASTANDDIRTYGLOBALFIX        8   // really 365 export 8 LocalLock not thunked
#define FUN_WRITEPRIVATEPROFILESTRUCT    9   // really 406 export 9 LocalUnlock not thunked
#define FUN_GETPRIVATEPROFILESTRUCT      10  // really 407 export 10 LocalSize not thunked
#define FUN_GETCURRENTDIRECTORY          11  // really 411 export 11 LocalHandle not thunked
#define FUN_SETCURRENTDIRECTORY          12  // really 412 export 12 LocalFlags not thunked
#define FUN_FINDFIRSTFILE                13  // really 413 export 13 LocalCompact not thunked
#define FUN_FINDNEXTFILE                 14  // really 414 export 14 LocalNotify not thunked
#define FUN_FINDCLOSE                    15  // really 415 export 15 GlobalAlloc not thunked
#define FUN_WRITEPRIVATEPROFILESECTION   16  // really 416 export 16 GlobalReAlloc not thunked
#define FUN_WRITEPROFILESECTION          17  // really 417 export 17 GlobalFree not thunked
#define FUN_GETPRIVATEPROFILESECTION     18  // really 418 export 18 GlobalLock not thunked
#define FUN_GETPROFILESECTION            19  // really 419 export 19 GlobalUnlock not thunked
#define FUN_GETFILEATTRIBUTES            20  // really 420 export 20 GlobalSize not thunked
#define FUN_SETFILEATTRIBUTES            21  // really 421 export 21 GlobalHandle not thunked
#define FUN_GETDISKFREESPACE             22  // really 422 export 22 GlobalFlags not thunked
#define FUN_ISPEFORMAT                   23  // really 431 export 23 LockSegment not thunked
#define FUN_FILETIMETOLOCALFILETIME      24  // really 432 export 24 UnlockSegment not thunked
#define FUN_UNITOANSI                    25  // really 434 export 25 GlobalCompact not thunked
#define FUN_GETVDMPOINTER32W             26  // really 516 export 26 GlobalFreeAll not thunked
#define FUN_CREATETHREAD                 27  // really 441 export 27 GetModuleName not thunked
#define FUN_ICALLPROC32W                 28  // really 517 export 28 GlobalMasterHandle not thunked
#define FUN_YIELD                        29  //
#define FUN_WAITEVENT                    30  // Internal
#define FUN_POSTEVENT                    31  // Internal
#define FUN_SETPRIORITY                  32  // Internal
#define FUN_LOCKCURRENTTASK              33  // Internal
#define FUN_LEAVEENTERWIN16LOCK          34  // really 447 export 34 formerly SetTaskQueue
#define FUN_REGLOADKEY32                 35  // really 232 export 35 GetTaskQueue not thunked
#define FUN_REGUNLOADKEY32               36  // really 233 export 36 GetCurrentTask not thunked
#define FUN_REGSAVEKEY32                 37  // really 234 export 37 GetCurrentPDB not thunked
#define FUN_GETWIN16LOCK                 38  // really 449 export 38 formerly SetTaskSignalProc
#define FUN_LOADLIBRARY32                39  // really 452 export 39 formerly SetTaskSwitchProc
#define FUN_GETPROCADDRESS32             40  // really 453 export 40 formerly SetTaskInterchange
#define FUN_WOWFINDFIRST                 41  // WOW internal export 41 EnableDOS not thunked
#define FUN_WOWFINDNEXT                  42  // WOW internal export 42 DisableDOS not thunked
#define FUN_CREATEWIN32EVENT             43  // really 457 export 43 formerly IsScreenGrab
#define FUN_SETWIN32EVENT                44  // really 458 export 44 formerly BuildPDB
#define FUN_WOWLOADMODULE                45  // reusing LoadModule export, not thunked to wow32
#define FUN_RESETWIN32EVENT              46  // really 459 export 46 FreeModule not thunked
#define FUN_GETMODULEHANDLE              47  //
#define FUN_WAITFORSINGLEOBJECT          48  // really 460 export 48 GetModuleUsage not thunked
#define FUN_GETMODULEFILENAME            49  //
#define FUN_WAITFORMULTIPLEOBJECTS       50  // really 461 export 50 GetProcAddress not thunked
#define FUN_GETCURRENTTHREADID           51  // really 462 export 51 MakeProcInstance not thunked
#define FUN_SETTHREADQUEUE               52  // really 463 export 52 FreeProcInstance not thunked
#define FUN_CONVERTTOGLOBALHANDLE        53  // really 476 export 53 CallProcInstance not thunked
#define FUN_GETTHREADQUEUE               54  // really 464 export 54 GetInstanceData not thunked
#define FUN_NUKEPROCESS                  55  // really 465 export 55 Catch not thunked
#define FUN_EXITPROCESS                  56  // really 466 export 56 Throw not thunked
#define FUN_GETPROFILEINT                57  //
#define FUN_GETPROFILESTRING             58  //
#define FUN_WRITEPROFILESTRING           59  //
#define FUN_GETCURRENTPROCESSID          60  // really 471 export 60 FindResource not thunked
#define FUN_MAPHINSTLS                   61  // really 472 export 61 LoadResource not thunked
#define FUN_MAPHINSTSL                   62  // really 473 export 62 LockResource not thunked
#define FUN_CLOSEWIN32HANDLE             63  // really 474 export 63 FreeResource not thunked
#define FUN_LOADSYSTEMLIBRARY32          64  // really 482 export 64 AccessResource not thunked
#define FUN_FREELIBRARY32                65  // really 486 export 65 ...Resource not thunked
#define FUN_GETMODULEFILENAME32          66  // really 487 export 66 AllocResource not thunked
#define FUN_GETMODULEHANDLE32            67  // really 488 export 67 SetResourceHandler not thunked
#define FUN_REGISTERSERVICEPROCESS       68  // really 491 export 68 InitAtomTable not thunked
#define FUN_CHANGEALLOCFIXEDBEHAVIOUR    69  // really 501 export 69 FindAtom not thunked
#define FUN_INITCB                       70  // really 560 export 70 AddAtom not thunked
#define FUN_GETSTDCBLS                   71  // really 561 export 71 DeleteAtom not thunked
#define FUN_GETSTDCBSL                   72  // really 562 export 72 GetAtomName not thunked
#define FUN_GETEXISTINGSTDCBLS           73  // really 563 export 73 GetAtomHandle not thunked
#define FUN_GETEXISTINGSTDCBSL           74  // really 564 export 74 OpenFile not thunked
#define FUN_GETFLEXCBSL                  75  // really 566 export 75 OpenPathName not thunked
#define FUN_GETSTDCBLSEX                 76  // really 567 export 76 DeletePathName not thunked
#define FUN_GETSTDCBSLEX                 77  // really 568 export 77 AnsiNext not thunked
#define FUN_CALLBACK2                    78  // really 802 export 78 AnsiPrev not thunked
#define FUN_CALLBACK4                    79  // really 804 export 79 AnsiUpper not thunked
#define FUN_CALLBACK6                    80  // really 806 export 80 AnsiLower not thunked
#define FUN_CALLBACK8                    81  // really 808 export 81 _lclose not thunked
#define FUN_CALLBACK10                   82  // really 810 export 82 _lread not thunked
#define FUN_CALLBACK12                   83  // really 812 export 83 _lcreat not thunked
#define FUN_CALLBACK14                   84  // really 814 export 84 _lseek not thunked
#define FUN_CALLBACK16                   85  // really 816 export 85 _lopen not thunked
#define FUN_CALLBACK18                   86  // really 818 export 86 _lwrite not thunked
#define FUN_CALLBACK20                   87  // really 820 export 87 lstroriginal not thunked
#define FUN_CALLBACK22                   88  // really 822 export 88 lstrcpy not thunked
#define FUN_CALLBACK24                   89  // really 824 export 89 lstrcat not thunked
#define FUN_CALLBACK26                   90  // really 826 export 90 lstrlen not thunked
#define FUN_CALLBACK28                   91  // really 828 export 91 InitTask not thunked
#define FUN_CALLBACK30                   92  // really 830 export 92 GetTempDrive not thunked
#define FUN_CALLBACK32                   93  // really 832 export 93 GetCodeHandle not thunked
#define FUN_CALLBACK34                   94  // really 834 export 94 DefineHandleTable not thunked
#define FUN_CALLBACK36                   95  // really 836 export 95 LoadLibrary not thunked
#define FUN_CALLBACK38                   96  // really 838 export 96 FreeLibrary not thunked
#define FUN_CALLBACK40                   97  // really 840 export 97 GetTempFilename not thunked
#define FUN_CALLBACK42                   98  // really 842 export 98 GetLastDiskChange not thunked
#define FUN_CALLBACK44                   99  // really 844 export 99 GetLPErrMode not thunked
#define FUN_CALLBACK46                   100 // really 846 export 100 ValidateCodeSegments not thunked
#define FUN_CALLBACK48                   101 // really 848 export 101 NoHookDosCall not thunked
#define FUN_CALLBACK50                   102 // really 850 export 102 Dos3Call not thunked
#define FUN_CALLBACK52                   103 // really 852 export 103 NetBiosCall not thunked
#define FUN_CALLBACK54                   104 // really 854 export 104 GetCodeInfo not thunked
#define FUN_CALLBACK56                   105 // really 856 export 105 GetExeVersion not thunked
#define FUN_CALLBACK58                   106 // really 858 export 106 SetSwapAreaSize not thunked
#define FUN_CALLBACK60                   107 // really 860 export 107 SetErrorMode not thunked
#define FUN_CALLBACK62                   108 // really 862 export 108 SwitchStackTo not thunked
#define FUN_CALLBACK64                   109 // really 864 export 109 SwitchStackBack not thunked
#define FUN_WOWKILLTASK                  110 // WOW internal export 110 PatchCodeHandle not thunked
#define FUN_WOWFILEWRITE                 111 // WOW internal export 111 GlobalWire not thunked
#define FUN_WOWGETNEXTVDMCOMMAND         112 // really 502 export 112 GlobalUnWire not thunked
#define FUN_WOWFILELOCK                  113 // WOW internal export 113 is data __AHSHIFT
#define FUN_WOWFREERESOURCE              114 // WOW internal export 114 is data __AHINCR
#define FUN_WOWOUTPUTDEBUGSTRING         115 // export 115 is OutputDebugString, not directly thunked.
#define FUN_WOWINITTASK                  116 // WOW internal export 116 InitLib not thunked
#define FUN_OLDYIELD                     117 //
#define FUN_WOWFILESETDATETIME           118 // WOW internal export 118 GetTaskQueueDS no longer exported
#define FUN_WOWFILECREATE                119 // WOW internal export 119 GetTaskQueueES no longer exported
#define FUN_WOWDOSWOWINIT                120 // WOW internal export 120 UndefDynLink not thunked
#define FUN_WOWCHECKUSERGDI              121 // WOW internal export 121 LocalShrink not thunked
#define FUN_WOWPARTYBYNUMBER             122 // really 273 export 122 IsTaskLocked not thunked
#define FUN_GETSHORTPATHNAME             123 // really 274 export 123 KbdRst not thunked
#define FUN_FINDANDRELEASEDIB            124 // WOW internal export 124 EnableKernel not thunked
#define FUN_WOWRESERVEHTASK              125 // WOW internal export 125 DisableKernel not thunked
#define FUN_WOWFILESETATTRIBUTES         126 // WOW internal export 126 MemoryFreed not thunked
#define FUN_GETPRIVATEPROFILEINT         127 //
#define FUN_GETPRIVATEPROFILESTRING      128 //
#define FUN_WRITEPRIVATEPROFILESTRING    129 //
#define FUN_WOWSETCURRENTDIRECTORY       130 // WOW internal export 130 FileCDR not thunked
#define FUN_WOWWAITFORMSGANDEVENT        131 // really 262 export 131 GetDosEnvironment not thunked
#define FUN_WOWMSGBOX                    132 // really 263 export 132 GetWinFlags not thunked
#define FUN_WOWGETFLATADDRESSARRAY       133 // WOW internal export 133 GetExePtr not thunked
#define FUN_WOWGETCURRENTDATE            134 // WOW internal export 134 GetWindowsDirectory not thunked
#define FUN_WOWDEVICEIOCTL               135 // WOW internal export 135 GetSystemDirectory not thunked
#define FUN_GETDRIVETYPE                 136 //
#define FUN_WOWFILEGETDATETIME           137 // WOW internal export 137 FatalAppExit not thunked
#define FUN_SETAPPCOMPATFLAGS            138 // WOW internal export 138 GetHeapSpaces not thunked
#define FUN_WOWREGISTERSHELLWINDOWHANDLE 139 // really 251 export 139 DoSignal not thunked
#define FUN_FREELIBRARY32W               140 // really 514 export 140 SetSigHandler not thunked
#define FUN_GETPROCADDRESS32W            141 // really 515 export 141 InitTask1 not thunked
#define FUN_GETPROFILESECTIONNAMES       142 //
#define FUN_GETPRIVATEPROFILESECTIONNAMES 143 //
#define FUN_CREATEDIRECTORY              144 //
#define FUN_REMOVEDIRECTORY              145 //
#define FUN_DELETEFILE                   146 //
#define FUN_SETLASTERROR                 147 //
#define FUN_GETLASTERROR                 148 //
#define FUN_GETVERSIONEX                 149 //
#define FUN_DIRECTEDYIELD                150 //
#define FUN_WOWFILEREAD                  151 // WOW internal export 151 WinOldApCall not thunked
#define FUN_WOWFILELSEEK                 152 // WOW internal export 152 GetNumTasks not thunked
#define FUN_WOWKERNELTRACE               153 // WOW internal export 153 DiscardCodeSegment no longer exported
#define FUN_LOADLIBRARYEX32W             154 // really 513 export 154 GlobalNotify not thunked
#define FUN_WOWQUERYPERFORMANCECOUNTER   155 // really 505 export 155 GetTaskDS not thunked
#define FUN_WOWCURSORICONOP              156 // really 507 export 156 LimitEMSPages not thunked
#define FUN_WOWFAILEDEXEC                157 // WOW internal export 157 GetCurPID not thunked
#define FUN_WOWGETFASTADDRESS            158 // WOW internal export 158 IsWinOldApTask not thunked
#define FUN_WOWCLOSECOMPORT              159 // really 509 export 159 GlobalHandleNoRIP not thunked
#define FUN_LOCAL32INIT                  160 // really 208 export 160 EMSCopy not thunked
#define FUN_LOCAL32ALLOC                 161 // really 209 export 161 LocalCountFree not thunked
#define FUN_LOCAL32REALLOC               162 // really 210 export 162 LocalHeapSize not thunked
#define FUN_LOCAL32FREE                  163 // really 211 export 163 GlobalLRUOldest not thunked
#define FUN_LOCAL32TRANSLATE             164 // really 213 export 164 GlobalLRUNewest not thunked
#define FUN_LOCAL32SIZE                  165 // really 214 export 165 A20Proc not thunked
#define FUN_LOCAL32VALIDHANDLE           166 // really 215 export 166 WinExec not thunked
#define FUN_REGENUMKEY32                 167 // really 216 export 167 GetExpWinVer not thunked
#define FUN_REGOPENKEY32                 168 // really 217 export 168 DirectResAlloc not thunked
#define FUN_REGCREATEKEY32               169 // really 218 export 169 GetFreeSpace not thunked
#define FUN_REGDELETEKEY32               170 // really 219 export 170 AllocCStoDSAlias not thunked
#define FUN_REGCLOSEKEY32                171 // really 220 export 171 AllocDStoCSAlias not thunked
#define FUN_REGSETVALUE32                172 // really 221 export 172 AllocAlias not thunked
#define FUN_REGDELETEVALUE32             173 // really 222 export 173 is data __ROMBIOS
#define FUN_REGENUMVALUE32               174 // really 223 export 174 is data __A000h
#define FUN_REGQUERYVALUE32              175 // really 224 export 175 AllocSelector not thunked
#define FUN_REGQUERYVALUEEX32            176 // really 225 export 176 FreeSelector not thunked
#define FUN_REGSETVALUEEX32              177 // really 226 export 177 PrestoChangoSelector not thunked
#define FUN_REGFLUSHKEY32                178 // really 227 export 178 is data __WINFLAGS
#define FUN_COMPUTEOBJECTOWNER           179 // really 228 export 179 is data __D000h
#define FUN_LOCAL32GETSEL                180 // really 229 export 180 LongPtrAdd not thunked
#define FUN_MAPPROCESSHANDLE             181 // really 483 export 181 is data __B000h
#define FUN_INVALIDATENLSCACHE           182 // really 235 export 182 is data __B800h
#define FUN_WOWDELFILE                   183 // WOW internal export 183 is data __0000h
#ifdef  RENAMEVIRTUAL
#define FUN_WOWVIRTUALALLOC              184 // WOW internal export 184 GlobalDOSAlloc not thunked
#define FUN_WOWVIRTUALFREE               185 // WOW internal export 185 GlobalDOSFree not thunked
#else   // RENAMEVIRTUAL
#define FUN_VIRTUALALLOC              184 // WOW internal export 184 GlobalDOSAlloc not thunked
#define FUN_VIRTUALFREE               185 // WOW internal export 185 GlobalDOSFree not thunked
#endif  // else RENAMEVIRTUAL
#define FUN_VIRTUALLOCK                  186 // WOW internal export 186 GetSelectorBase not thunked
#define FUN_VIRTUALUNLOCK                187 // WOW internal export 187 SetSelectorBase not thunked
#define FUN_GLOBALMEMORYSTATUS           188 // WOW internal export 188 GetSelectorLimit not thunked
#define FUN_WOWGETFASTCBRETADDRESS       189 // WOW internal export 189 SetSelectorLimit not thunked
#define FUN_WOWGETTABLEOFFSETS           190 // WOW internal export 190 is data __E000h
#define FUN_WOWKILLREMOTETASK            191 // really 511 export 191 GlobalPageLock not thunked
#define FUN_WOWNOTIFYWOW32               192 // WOW internal export 192 GlobalPageUnlock not thunked
#define FUN_WOWFILEOPEN                  193 // WOW internal export 193 is data __0040h
#define FUN_WOWFILECLOSE                 194 // WOW internal export 194 is data __F000h
#define FUN_WOWSETIDLEHOOK               195 // WOW internal export 195 is data __C000h
#define FUN_KSYSERRORBOX                 196 // WOW internal export 196 SelectorAccessRights not thunked
#define FUN_WOWISKNOWNDLL                197 // WOW internal export 197 GlobalFix not thunked
#define FUN_WOWDDEFREEHANDLE             198 // WOW internal export 198 GlobalUnfix not thunked
#define FUN_WOWFILEGETATTRIBUTES         199 // WOW internal export 199 SetHandleCount not thunked
#define FUN_WOWSETDEFAULTDRIVE           200 // WOW internal export 200 ValidateFreeSpaces not thunked
#define FUN_WOWGETCURRENTDIRECTORY       201 // WOW internal export 201 ReplaceInst not thunked
#define FUN_GETPRODUCTNAME               202 // really 236 export 202 RegisterPTrace not thunked
#define FUN_ISSAFEMODE                   203 // really 237 export 203 DebugBreak not thunked
#define FUN_WOWLFNENTRY                  204 // WOW internal export 204 SwapRecording not thunked
#define FUN_WOWSHUTDOWNTIMER             205 // WOW internal export 205 CVWBreak not thunked
#define FUN_WOWTRIMWORKINGSET            206 // WOW internal export 206 AllocSelectorArray not thunked

#ifdef FE_SB
#define FUN_GETSYSTEMDEFAULTLANGID       207 // really 521 export 207 ISDBCSLEADBYTE not thunked
#endif
#define FUN_TERMSRVGETWINDOWSDIR         208 // internal
#define FUN_WOWPASSENVIRONMENT           209 // internal pass_environment
#define FUN_WOWSYNCTASK                  210 // internal parent/child sync
#define FUN_WOWDIVIDEOVERFLOWEX          211 // internal divide overflow handler


//
// Note the following "special" FUN_ identifiers are not used as offsets
// in a thunk table, but rather as arguments to some WOW private APIs,
// WowCursorIconOp and FindAndReleaseDib.
//

#define FUN_GLOBALFREE                   1000
#define FUN_GLOBALREALLOC                1001
#define FUN_GLOBALLOCK                   1002
#define FUN_GLOBALUNLOCK                 1003


/* XLATOFF */
#pragma pack(2)
/* XLATON */


/* NOTE that the tag (like "/* k1 * /") on each typedef line is used by
 * h2inc when building wowkrn.inc, as a prefix for that structures
 * members, since our assembler has only a single flat namespace. */


typedef struct _FATALEXIT16 {                              /* k1 */
    SHORT f1;
} FATALEXIT16;
typedef FATALEXIT16 UNALIGNED *PFATALEXIT16;

typedef struct _EXITKERNEL16 {                             /* k2 */
    WORD wExitCode;
} EXITKERNEL16;
typedef EXITKERNEL16 UNALIGNED *PEXITKERNEL16;

#ifdef NULLSTRUCT
typedef struct _WRITEOUTPROFILES16 {                       /* k3 */
} WRITEOUTPROFILES16;
typedef WRITEOUTPROFILES16 UNALIGNED *PWRITEOUTPROFILES16;
#endif

typedef struct _MAPSL16 {                                  /* k4 */
    DWORD vp;
} MAPSL16;
typedef MAPSL16 UNALIGNED *PMAPSL16;

typedef struct _MAPLS16 {                                  /* k5 */
    PVOID p;
} MAPLS16;
typedef MAPLS16 UNALIGNED *PMAPLS16;

typedef struct _UNMAPLS16 {                                /* k6 */
    PVOID vp;
} UNMAPLS16;
typedef UNMAPLS16 UNALIGNED *PUNMAPLS16;

typedef struct _OPENFILEEX16 {                             /* k7 */
    WORD  wFlags;
    DWORD lpOFStructEx;
    DWORD lpSrcFile;
} OPENFILEEX16;
typedef OPENFILEEX16 UNALIGNED *POPENFILEEX16;

typedef struct _FASTANDDIRTYGLOBALFIX16 {                  /* k8 */
    WORD  selFix;
    WORD  wAction;
} FASTANDDIRTYGLOBALFIX16;
typedef FASTANDDIRTYGLOBALFIX16 UNALIGNED *PFASTANDDIRTYGLOBALFIX16;

typedef struct _WRITEPRIVATEPROFILESTRUCT16 {              /* k9 */
    DWORD lpszFile;
    WORD  cbStruct;
    DWORD lpStruct;
    DWORD lpszKey;
    DWORD lpszSection;
} WRITEPRIVATEPROFILESTRUCT16;
typedef WRITEPRIVATEPROFILESTRUCT16 UNALIGNED *PWRITEPRIVATEPROFILESTRUCT16;

typedef struct _GETPRIVATEPROFILESTRUCT16 {                /* k10 */
    DWORD lpszFile;
    WORD  cbStruct;
    DWORD lpStruct;
    DWORD lpszKey;
    DWORD lpszSection;
} GETPRIVATEPROFILESTRUCT16;
typedef GETPRIVATEPROFILESTRUCT16 UNALIGNED *PGETPRIVATEPROFILESTRUCT16;

typedef struct _GETCURRENTDIRECTORY16 {                    /* k11 */
    DWORD lpszDir;
    DWORD cchDir;
} GETCURRENTDIRECTORY16;
typedef GETCURRENTDIRECTORY16 UNALIGNED *PGETCURRENTDIRECTORY16;

typedef struct _SETCURRENTDIRECTORY16 {                    /* k12 */
    DWORD lpszDir;
} SETCURRENTDIRECTORY16;
typedef SETCURRENTDIRECTORY16 UNALIGNED *PSETCURRENTDIRECTORY16;

typedef struct _FINDFIRSTFILE16 {                          /* k13 */
    DWORD lpFindData;
    DWORD lpszSearchFile;
} FINDFIRSTFILE16;
typedef FINDFIRSTFILE16 UNALIGNED *PFINDFIRSTFILE16;

typedef struct _FINDNEXTFILE16 {                           /* k14 */
    DWORD lpFindData;
    DWORD hFindFile;
} FINDNEXTFILE16;
typedef FINDNEXTFILE16 UNALIGNED *PFINDNEXTFILE16;

typedef struct _FINDCLOSE16 {                              /* k15 */
    DWORD hFindFile;
} FINDCLOSE16;
typedef FINDCLOSE16 UNALIGNED *PFINDCLOSE16;

typedef struct _WRITEPRIVATEPROFILESECTION16 {             /* k16 */
    DWORD lpszFile;
    DWORD lpKeysAndValues;
    DWORD lpszSection;
} WRITEPRIVATEPROFILESECTION16;
typedef WRITEPRIVATEPROFILESECTION16 UNALIGNED *PWRITEPRIVATEPROFILESECTION16;

typedef struct _WRITEPROFILESECTION16 {                    /* k17 */
    DWORD lpKeysAndValues;
    DWORD lpszSection;
} WRITEPROFILESECTION16;
typedef WRITEPROFILESECTION16 UNALIGNED *PWRITEPROFILESECTION16;

typedef struct _GETPRIVATEPROFILESECTION16 {               /* k18 */
    DWORD lpszFile;
    WORD  cchResult;
    DWORD lpResult;
    DWORD lpszSection;
} GETPRIVATEPROFILESECTION16;
typedef GETPRIVATEPROFILESECTION16 UNALIGNED *PGETPRIVATEPROFILESECTION16;

typedef struct _GETPROFILESECTION16 {                      /* k19 */
    WORD  cchResult;
    DWORD lpResult;
    DWORD lpszSection;
} GETPROFILESECTION16;
typedef GETPROFILESECTION16 UNALIGNED *PGETPROFILESECTION16;

typedef struct _GETFILEATTRIBUTES16 {                      /* k20 */
    DWORD lpszFile;
} GETFILEATTRIBUTES16;
typedef GETFILEATTRIBUTES16 UNALIGNED *PGETFILEATTRIBUTES16;

typedef struct _SETFILEATTRIBUTES16 {                      /* k21 */
    DWORD dwFileAttributes;
    DWORD lpszFile;
} SETFILEATTRIBUTES16;
typedef SETFILEATTRIBUTES16 UNALIGNED *PSETFILEATTRIBUTES16;

typedef struct _GETDISKFREESPACE16 {                       /* k22 */
    DWORD lpdwClusters;
    DWORD lpdwFreeClusters;
    DWORD lpdwBytesPerSector;
    DWORD lpdwSectorsPerCluster;
    DWORD lpszRootPathName;
} GETDISKFREESPACE16;
typedef GETDISKFREESPACE16 UNALIGNED *PGETDISKFREESPACE16;

typedef struct _ISPEFORMAT16 {                             /* k23 */
    WORD  hFile;
    DWORD lpszFile;
} ISPEFORMAT16;
typedef ISPEFORMAT16 UNALIGNED *PISPEFORMAT16;

typedef struct _FILETIMETOLOCALFILETIME16 {                /* k24 */
    DWORD lpLocalFileTime;
    DWORD lpUTCFileTime;
} FILETIMETOLOCALFILETIME16;
typedef FILETIMETOLOCALFILETIME16 UNALIGNED *PFILETIMETOLOCALFILETIME16;

typedef struct _UNITOANSI16 {                              /* k25 */
    WORD  cch;
    DWORD pchDst;
    DWORD pchSrc;
} UNITOANSI16;
typedef UNITOANSI16 UNALIGNED *PUNITOANSI16;

typedef struct _GETVDMPOINTER32W16 {                       /* k26 */
    SHORT  fMode;
    VPVOID lpAddress;
} GETVDMPOINTER32W16;
typedef GETVDMPOINTER32W16 UNALIGNED *PGETVDMPOINTER32W16;

typedef struct _CREATETHREAD16 {                           /* k27 */
    DWORD lpThreadID;
    DWORD dwCreateFlags;
    DWORD lpParameter;
    DWORD lpStartAddress;
    DWORD dwStackSize;
    DWORD lpSecurityAttributes;
} CREATETHREAD16;
typedef CREATETHREAD16 UNALIGNED *PCREATETHREAD16;

typedef struct _ICALLPROC32W16 {                           /* k28 */
    WORD  rbp;
    DWORD retaddr;
    DWORD cParams;
    DWORD fAddressConvert;
    DWORD lpProcAddress;
    DWORD p1;
    DWORD p2;
    DWORD p3;
    DWORD p4;
    DWORD p5;
    DWORD p6;
    DWORD p7;
    DWORD p8;
    DWORD p9;
    DWORD p10;
    DWORD p11;
    DWORD p12;
    DWORD p13;
    DWORD p14;
    DWORD p15;
    DWORD p16;
    DWORD p17;
    DWORD p18;
    DWORD p19;
    DWORD p20;
    DWORD p21;
    DWORD p22;
    DWORD p23;
    DWORD p24;
    DWORD p25;
    DWORD p26;
    DWORD p27;
    DWORD p28;
    DWORD p29;
    DWORD p30;
    DWORD p31;
    DWORD p32;
} ICALLPROC32W16;
typedef ICALLPROC32W16 UNALIGNED *PICALLPROC32W16;

#define CPEX32_DEST_CDECL   0x8000L
#define CPEX32_SOURCE_CDECL 0x4000L

#ifdef NULLSTRUCT
typedef struct _YIELD16 {                                  /* k29 */
} YIELD16;
typedef YIELD16 UNALIGNED *PYIELD16;
#endif

typedef struct _WAITEVENT16 {                              /* k30 */
    WORD    wTaskID;
} WAITEVENT16;
typedef WAITEVENT16 UNALIGNED *PWAITEVENT16;

typedef struct _POSTEVENT16 {                              /* k31 */
    WORD    hTask16;
} POSTEVENT16;
typedef POSTEVENT16 UNALIGNED *PPOSTEVENT16;

typedef struct _SETPRIORITY16 {                            /* k32 */
    WORD    wPriority;
    WORD    hTask16;
} SETPRIORITY16;
typedef SETPRIORITY16 UNALIGNED *PSETPRIORITY16;

typedef struct _LOCKCURRENTTASK16 {                        /* k33 */
    WORD    fLock;
} LOCKCURRENTTASK16;
typedef LOCKCURRENTTASK16 UNALIGNED *PLOCKCURRENTTASK16;

#ifdef NULLSTRUCT
typedef struct _LEAVEENTERWIN16LOCK {                      /* k34 */
} LEAVEENTERWIN16LOCK;
typedef LEAVEENTERWIN16LOCK UNALIGNED *PLEAVEENTERWIN16LOCK;
#endif

typedef struct _REGLOADKEY3216 {                           /* k35 */
    VPSTR lpszFileName;
    VPSTR lpszSubkey;
    DWORD hKey;
} REGLOADKEY3216;
typedef REGLOADKEY3216 UNALIGNED *PREGLOADKEY3216;

typedef struct _REGUNLOADKEY3216 {                         /* k36 */
    VPSTR lpszSubkey;
    DWORD hKey;
} REGUNLOADKEY3216;
typedef REGUNLOADKEY3216 UNALIGNED *PREGUNLOADKEY3216;

typedef struct _REGSAVEKEY3216 {                           /* k37 */
    VPVOID lpSA;
    VPSTR  lpszFile;
    DWORD  hKey;
} REGSAVEKEY3216;
typedef REGSAVEKEY3216 UNALIGNED *PREGSAVEKEY3216;

#ifdef NULLSTRUCT
typedef struct _GETWIN16LOCK16 {                           /* k38 */
} GETWIN16LOCK16;
typedef GETWIN16LOCK16 UNALIGNED *PGETWIN16LOCK16;
#endif

typedef struct _LOADLIBRARY3216 {                          /* k39 */
    DWORD lpszLibrary;
} LOADLIBRARY3216;
typedef LOADLIBRARY3216 UNALIGNED *PLOADLIBRARY3216;

typedef struct _GETPROCADDRESS3216 {                       /* k40 */
    DWORD lpszProc;
    DWORD hLib;
} GETPROCADDRESS3216;
typedef GETPROCADDRESS3216 UNALIGNED *PGETPROCADDRESS3216;

typedef struct _WOWFINDFIRST16 {                           /* k41 */
    DWORD lpDTA;
    WORD  pszPathOffset;
    WORD  pszPathSegment;
    WORD  wAttributes;
} WOWFINDFIRST16;
typedef WOWFINDFIRST16 UNALIGNED *PWOWFINDFIRST16;

typedef struct _WOWFINDNEXT16 {                            /* k42 */
    DWORD lpDTA;
} WOWFINDNEXT16;
typedef WOWFINDNEXT16 UNALIGNED *PWOWFINDNEXT16;

typedef struct _CREATEWIN32EVENT16 {                       /* k43 */
    DWORD bInitialState;
    DWORD bManualReset;
} CREATEWIN32EVENT16;
typedef CREATEWIN32EVENT16 UNALIGNED *PCREATEWIN32EVENT16;

typedef struct _SETWIN32EVENT16 {                          /* k44 */
    DWORD hEvent;
} SETWIN32EVENT16;
typedef SETWIN32EVENT16 UNALIGNED *PSETWIN32EVENT16;

typedef struct _WOWLOADMODULE16 {                          /* k45 */
    VPSTR  lpWinOldAppCmd;
    VPVOID lpParameterBlock;
    VPSTR  lpModuleName;
} WOWLOADMODULE16;
typedef WOWLOADMODULE16 UNALIGNED *PWOWLOADMODULE16;

typedef struct _PARAMETERBLOCK16 {                         /* k45_2 */
    WORD    wEnvSeg;
    VPVOID  lpCmdLine;
    VPVOID  lpCmdShow;
    DWORD   dwReserved;
} PARAMETERBLOCK16;
typedef PARAMETERBLOCK16 UNALIGNED *PPARAMETERBLOCK16;

typedef struct _RESETWIN32EVENT16 {                        /* k46 */
    DWORD hEvent;
} RESETWIN32EVENT16;
typedef RESETWIN32EVENT16 UNALIGNED *PRESETWIN32EVENT16;

typedef struct _WOWGETMODULEHANDLE16 {                     /* k47 */
    VPSTR lpszModuleName;
} WOWGETMODULEHANDLE16;
typedef WOWGETMODULEHANDLE16 UNALIGNED *PWOWGETMODULEHANDLE16;

typedef struct _WAITFORSINGLEOBJECT16 {                    /* k48 */
    DWORD dwTimeout;
    DWORD h;
} WAITFORSINGLEOBJECT16;
typedef WAITFORSINGLEOBJECT16 UNALIGNED *PWAITFORSINGLEOBJECT16;

typedef struct _GETMODULEFILENAME16 {                      /* k49 */
    SHORT f3;
    VPSTR f2;
    HAND16 f1;
} GETMODULEFILENAME16;
typedef GETMODULEFILENAME16 UNALIGNED *PGETMODULEFILENAME16;

typedef struct _WAITFORMULTIPLEOBJECTS16 {                 /* k50 */
    DWORD dwTimeout;
    DWORD bWaitForAll;
    DWORD lphObjects;
    DWORD cObjects;
} WAITFORMULTIPLEOBJECTS16;
typedef WAITFORMULTIPLEOBJECTS16 UNALIGNED *PWAITFORMULTIPLEOBJECTS16;

#ifdef NULLSTRUCT
typedef struct _GETCURRENTTHREADID16 {                     /* k51 */
} GETCURRENTTHREADID16;
typedef GETCURRENTTHREADID16 UNALIGNED *PGETCURRENTTHREADID16;
#endif

typedef struct _SETTHREADQUEUE16 {                         /* k52 */
    WORD  NewQueueSel;
    DWORD dwThreadID;
} SETTHREADQUEUE16;
typedef SETTHREADQUEUE16 UNALIGNED *PSETTHREADQUEUE16;

typedef struct _CONVERTTOGLOBALHANDLE16 {                  /* k53 */
    DWORD dwHandle;
} CONVERTTOGLOBALHANDLE16;
typedef CONVERTTOGLOBALHANDLE16 UNALIGNED *PCONVERTTOGLOBALHANDLE16;

typedef struct _GETTHREADQUEUE16 {                         /* k54 */
    DWORD dwThreadID;
} GETTHREADQUEUE16;
typedef GETTHREADQUEUE16 UNALIGNED *PGETTHREADQUEUE16;

typedef struct _NUKEPROCESS16 {                            /* k55 */
    DWORD ulFlags;
    WORD  uExitCode;
    DWORD ppdb;
} NUKEPROCESS16;
typedef NUKEPROCESS16 UNALIGNED *PNUKEPROCESS16;

typedef struct _EXITPROCESS16 {                            /* k56 */
    WORD wStatus;
} EXITPROCESS16;
typedef EXITPROCESS16 UNALIGNED *PEXITPROCESS16;

typedef struct _GETPROFILEINT16 {                          /* k57 */
    SHORT f3;
    VPSTR f2;
    VPSTR f1;
} GETPROFILEINT16;
typedef GETPROFILEINT16 UNALIGNED *PGETPROFILEINT16;

typedef struct _GETPROFILESTRING16 {                       /* k58 */
    USHORT f5;
    VPSTR f4;
    VPSTR f3;
    VPSTR f2;
    VPSTR f1;
} GETPROFILESTRING16;
typedef GETPROFILESTRING16 UNALIGNED *PGETPROFILESTRING16;

typedef struct _WRITEPROFILESTRING16 {                     /* k59 */
    VPSTR f3;
    VPSTR f2;
    VPSTR f1;
} WRITEPROFILESTRING16;
typedef WRITEPROFILESTRING16 UNALIGNED *PWRITEPROFILESTRING16;

#ifdef NULLSTRUCT
typedef struct _GETCURRENTPROCESSID16 {                    /* k60 */
} GETCURRENTPROCESSID16;
typedef GETCURRENTPROCESSID16 UNALIGNED *PGETCURRENTPROCESSID16;
#endif

#ifdef NULLSTRUCT
typedef struct _MAPHINSTLS {                               /* k61 */
    /* NOTE if you implement this the interface is register-based */
} MAPHINSTLS;
typedef MAPHINSTLS UNALIGNED *PMAPHINSTLS;
#endif

#ifdef NULLSTRUCT
typedef struct _MAPHINSTSL {                               /* k62 */
    /* NOTE if you implement this the interface is register-based */
} MAPHINSTSL;
typedef MAPHINSTSL UNALIGNED *PMAPHINSTSL;
#endif

typedef struct _CLOSEWIN32HANDLE16 {                       /* k63 */
    DWORD h32;
} CLOSEWIN32HANDLE16;
typedef CLOSEWIN32HANDLE16 UNALIGNED *PCLOSEWIN32HANDLE16;

typedef struct _LOADSYSTEMLIBRARY3216 {                    /* k64 */
    VPSTR lpszLibrary;
} LOADSYSTEMLIBRARY3216;
typedef LOADSYSTEMLIBRARY3216 UNALIGNED *PLOADSYSTEMLIBRARY3216;

typedef struct _FREELIBRARY3216 {                          /* k65 */
    DWORD hModule;
} FREELIBRARY3216;
typedef FREELIBRARY3216 UNALIGNED *PFREELIBRARY3216;

typedef struct _GETMODULEFILENAME3216 {                    /* k66 */
    WORD    wBufferSize;
    VPSTR   lpBuffer;
    DWORD   hModule;
} GETMODULEFILENAME3216;
typedef GETMODULEFILENAME3216 UNALIGNED *PGETMODULEFILENAME3216;

typedef struct _GETMODULEHANDLE3216 {                      /* k67 */
    VPSTR lpszModule;
} GETMODULEHANDLE3216;
typedef GETMODULEHANDLE3216 UNALIGNED *PGETMODULEHANDLE3216;

typedef struct _REGISTERSERVICEPROCESS16 {                 /* k68 */
    DWORD dwServiceType;
    DWORD dwProcessID;
} REGISTERSERVICEPROCESS16;
typedef REGISTERSERVICEPROCESS16 UNALIGNED *PREGISTERSERVICEPROCESS16;

typedef struct _CHANGEALLOCFIXEDBEHAVIOUR16 {              /* k69 */
    WORD fWin31Behavior;
} CHANGEALLOCFIXEDBEHAVIOUR16;
typedef CHANGEALLOCFIXEDBEHAVIOUR16 UNALIGNED *PCHANGEALLOCFIXEDBEHAVIOUR16;

typedef struct _INITCB16 {                                 /* k70 */
    DWORD fnStdCBSLDispatch;
    DWORD fnStdCBLSDispatch;
} INITCB16;
typedef INITCB16 UNALIGNED *PINITCB16;

typedef struct _GETSTDCBLS16 {                             /* k71 */
    DWORD CBID;
    DWORD pfnTarg16;
} GETSTDCBLS16;
typedef GETSTDCBLS16 UNALIGNED *PGETSTDCBLS16;

typedef struct _GETSTDCBSL16 {                             /* k72 */
    DWORD CBID;
    DWORD pfnTarg32;
} GETSTDCBSL16;
typedef GETSTDCBSL16 UNALIGNED *PGETSTDCBSL16;

typedef struct _GETEXISTINGSTDCBLS16 {                     /* k73 */
    DWORD CBID;
    DWORD pfnTarg16;
} GETEXISTINGSTDCBLS16;
typedef GETEXISTINGSTDCBLS16 UNALIGNED *PGETEXISTINGSTDCBLS16;

typedef struct _GETEXISTINGSTDCBSL16 {                     /* k74 */
    DWORD CBID;
    DWORD pfnTarg32;
} GETEXISTINGSTDCBSL16;
typedef GETEXISTINGSTDCBSL16 UNALIGNED *PGETEXISTINGSTDCBSL16;

typedef struct _GETFLEXCBSL16 {                            /* k75 */
    DWORD pfnThunk;
    DWORD pfnTarg32;
} GETFLEXCBSL16;
typedef GETFLEXCBSL16 UNALIGNED *PGETFLEXCBSL16;

typedef struct _GETSTDCBLSEX16 {                           /* k76 */
    WORD  wOwner;
    DWORD CBID;
    DWORD pfnTarg16;
} GETSTDCBLSEX16;
typedef GETSTDCBLSEX16 UNALIGNED *PGETSTDCBLSEX16;

typedef struct _GETSTDCBSLEX16 {                           /* k77 */
    WORD  wOwner;
    DWORD CBID;
    DWORD pfnTarg32;
} GETSTDCBSLEX16;
typedef GETSTDCBSLEX16 UNALIGNED *PGETSTDCBSLEX16;

typedef struct _CALLBACK216 {                              /* k78 */
    WORD rgwArgs[1];
} CALLBACK216;
typedef CALLBACK216 UNALIGNED *PCALLBACK216;

typedef struct _CALLBACK416 {                              /* k79 */
    WORD rgwArgs[2];
} CALLBACK416;
typedef CALLBACK416 UNALIGNED *PCALLBACK416;

typedef struct _CALLBACK616 {                              /* k80 */
    WORD rgwArgs[3];
} CALLBACK616;
typedef CALLBACK616 UNALIGNED *PCALLBACK616;

typedef struct _CALLBACK816 {                              /* k81 */
    WORD rgwArgs[4];
} CALLBACK816;
typedef CALLBACK816 UNALIGNED *PCALLBACK816;

typedef struct _CALLBACK1016 {                             /* k82 */
    WORD rgwArgs[5];
} CALLBACK1016;
typedef CALLBACK1016 UNALIGNED *PCALLBACK1016;

typedef struct _CALLBACK1216 {                             /* k83 */
    WORD rgwArgs[6];
} CALLBACK1216;
typedef CALLBACK1216 UNALIGNED *PCALLBACK1216;

typedef struct _CALLBACK1416 {                             /* k84 */
    WORD rgwArgs[7];
} CALLBACK1416;
typedef CALLBACK1416 UNALIGNED *PCALLBACK1416;

typedef struct _CALLBACK1616 {                             /* k85 */
    WORD rgwArgs[8];
} CALLBACK1616;
typedef CALLBACK1616 UNALIGNED *PCALLBACK1616;

typedef struct _CALLBACK1816 {                             /* k86 */
    WORD rgwArgs[9];
} CALLBACK1816;
typedef CALLBACK1816 UNALIGNED *PCALLBACK1816;

typedef struct _CALLBACK2016 {                             /* k87 */
    WORD rgwArgs[10];
} CALLBACK2016;
typedef CALLBACK2016 UNALIGNED *PCALLBACK2016;

typedef struct _CALLBACK2216 {                             /* k88 */
    WORD rgwArgs[11];
} CALLBACK2216;
typedef CALLBACK2216 UNALIGNED *PCALLBACK2216;

typedef struct _CALLBACK2416 {                             /* k89 */
    WORD rgwArgs[12];
} CALLBACK2416;
typedef CALLBACK2416 UNALIGNED *PCALLBACK2416;

typedef struct _CALLBACK2616 {                             /* k90 */
    WORD rgwArgs[13];
} CALLBACK2616;
typedef CALLBACK2616 UNALIGNED *PCALLBACK2616;

typedef struct _CALLBACK2816 {                             /* k91 */
    WORD rgwArgs[14];
} CALLBACK2816;
typedef CALLBACK2816 UNALIGNED *PCALLBACK2816;

typedef struct _CALLBACK3016 {                             /* k92 */
    WORD rgwArgs[15];
} CALLBACK3016;
typedef CALLBACK3016 UNALIGNED *PCALLBACK3016;

typedef struct _CALLBACK3216 {                             /* k93 */
    WORD rgwArgs[16];
} CALLBACK3216;
typedef CALLBACK3216 UNALIGNED *PCALLBACK3216;

typedef struct _CALLBACK3416 {                             /* k94 */
    WORD rgwArgs[17];
} CALLBACK3416;
typedef CALLBACK3416 UNALIGNED *PCALLBACK3416;

typedef struct _CALLBACK3616 {                             /* k95 */
    WORD rgwArgs[18];
} CALLBACK3616;
typedef CALLBACK3616 UNALIGNED *PCALLBACK3616;

typedef struct _CALLBACK3816 {                             /* k96 */
    WORD rgwArgs[19];
} CALLBACK3816;
typedef CALLBACK3816 UNALIGNED *PCALLBACK3816;

typedef struct _CALLBACK4016 {                             /* k97 */
    WORD rgwArgs[20];
} CALLBACK4016;
typedef CALLBACK4016 UNALIGNED *PCALLBACK4016;

typedef struct _CALLBACK4216 {                             /* k98 */
    WORD rgwArgs[21];
} CALLBACK4216;
typedef CALLBACK4216 UNALIGNED *PCALLBACK4216;

typedef struct _CALLBACK4416 {                             /* k99 */
    WORD rgwArgs[22];
} CALLBACK4416;
typedef CALLBACK4416 UNALIGNED *PCALLBACK4416;

typedef struct _CALLBACK4616 {                             /* k100 */
    WORD rgwArgs[23];
} CALLBACK4616;
typedef CALLBACK4616 UNALIGNED *PCALLBACK4616;

typedef struct _CALLBACK4816 {                             /* k101 */
    WORD rgwArgs[24];
} CALLBACK4816;
typedef CALLBACK4816 UNALIGNED *PCALLBACK4816;

typedef struct _CALLBACK5016 {                             /* k102 */
    WORD rgwArgs[25];
} CALLBACK5016;
typedef CALLBACK5016 UNALIGNED *PCALLBACK5016;

typedef struct _CALLBACK5216 {                             /* k103 */
    WORD rgwArgs[26];
} CALLBACK5216;
typedef CALLBACK5216 UNALIGNED *PCALLBACK5216;

typedef struct _CALLBACK5416 {                             /* k104 */
    WORD rgwArgs[27];
} CALLBACK5416;
typedef CALLBACK5416 UNALIGNED *PCALLBACK5416;

typedef struct _CALLBACK5616 {                             /* k105 */
    WORD rgwArgs[28];
} CALLBACK5616;
typedef CALLBACK5616 UNALIGNED *PCALLBACK5616;

typedef struct _CALLBACK5816 {                             /* k106 */
    WORD rgwArgs[29];
} CALLBACK5816;
typedef CALLBACK5816 UNALIGNED *PCALLBACK5816;

typedef struct _CALLBACK6016 {                             /* k107 */
    WORD rgwArgs[30];
} CALLBACK6016;
typedef CALLBACK6016 UNALIGNED *PCALLBACK6016;

typedef struct _CALLBACK6216 {                             /* k108 */
    WORD rgwArgs[31];
} CALLBACK6216;
typedef CALLBACK6216 UNALIGNED *PCALLBACK6216;

typedef struct _CALLBACK6416 {                             /* k109 */
    WORD rgwArgs[32];
} CALLBACK6416;
typedef CALLBACK6416 UNALIGNED *PCALLBACK6416;

typedef struct _WOWFILEWRITE16 {                           /* k111 */
    DWORD lpSFT;
    DWORD lpPDB;
    DWORD  bufsize;
    DWORD lpBuf;
    WORD  fh;
} WOWFILEWRITE16;
typedef WOWFILEWRITE16 UNALIGNED *PWOWFILEWRITE16;

typedef struct _WOWGETNEXTVDMCOMMAND16 {                   /* k112 */
    VPVOID  lpWowInfo;
} WOWGETNEXTVDMCOMMAND16;
typedef WOWGETNEXTVDMCOMMAND16 UNALIGNED *PWOWGETNEXTVDMCOMMAND16;

typedef struct _WOWFILELOCK16 {                            /* k113 */
    DWORD lpSFT;
    DWORD lpPDB;
    DWORD cbRegionLength;
    DWORD cbRegionOffset;
    WORD  fh;
    WORD  ax;
} WOWFILELOCK16;
typedef WOWFILELOCK16 UNALIGNED *PWOWFILELOCK16;

typedef struct _WOWFREERESOURCE16 {                        /* k114 */
    HAND16 f1;
} WOWFREERESOURCE16;
typedef WOWFREERESOURCE16 UNALIGNED *PWOWFREERESOURCE16;

typedef struct _WOWOUTPUTDEBUGSTRING16 {                   /* k115 */
    VPSTR   vpString;
} WOWOUTPUTDEBUGSTRING16;
typedef WOWOUTPUTDEBUGSTRING16 UNALIGNED *PWOWOUTPUTDEBUGSTRING16;

typedef struct _WOWINITTASK16 {                            /* k116 */
    DWORD dwExpWinVer;
} WOWINITTASK16;
typedef WOWINITTASK16 UNALIGNED *PWOWINITTASK16;

typedef struct _WOWFILESETDATETIME16 {                     /* k118 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  date;
    WORD  time;
    WORD  fh;
} WOWFILESETDATETIME16;
typedef WOWFILESETDATETIME16 UNALIGNED *PWOWFILESETDATETIME16;

typedef struct _WOWFILECREATE16 {                          /* k119 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  pszPathOffset;
    WORD  pszPathSegment;
    WORD  wAttributes;
} WOWFILECREATE16;
typedef WOWFILECREATE16 UNALIGNED *PWOWFILECREATE16;

typedef struct _WOWDOSWOWINIT16 {                          /* k120 */
    VPVOID  lpDosWowData;
} WOWDOSWOWINIT16;
typedef WOWDOSWOWINIT16 UNALIGNED *PWOWDOSWOWINIT16;

typedef struct _WOWCHECKUSERGDI16 {                        /* k121 */
    WORD  pszPathOffset;
    WORD  pszPathSegment;
} WOWCHECKUSERGDI16;
typedef WOWCHECKUSERGDI16 UNALIGNED *PWOWCHECKUSERGDI16;

typedef struct _WOWPARTYBYNUMBER16 {                       /* k122 */
    VPSZ  psz;
    DWORD dw;
} WOWPARTYBYNUMBER16;
typedef WOWPARTYBYNUMBER16 UNALIGNED *PWOWPARTYBYNUMBER16;

typedef struct _GETSHORTPATHNAME16 {                       /* k123 */
    WORD  cchShortPath;
    VPSZ  pszShortPath;
    VPSZ  pszLongPath;
} GETSHORTPATHNAME16;
typedef GETSHORTPATHNAME16 UNALIGNED *PGETSHORTPATHNAME16;

typedef struct _FINDANDRELEASEDIB16 {                      /* k124 */
    WORD wFunId;
    HAND16 hdib;     /* handle which we are messing with */
} FINDANDRELEASEDIB16;
typedef FINDANDRELEASEDIB16 UNALIGNED *PFINDANDRELEASEDIB16;

typedef struct _WOWRESERVEHTASK16 {                        /* k125 */
    WORD  htask;
} WOWRESERVEHTASK16;
typedef WOWRESERVEHTASK16 UNALIGNED *PWOWRESERVEHTASK16;

typedef struct _WOWFILESETATTRIBUTES16 {                   /* k126 */
    WORD  pszPathOffset;
    WORD  pszPathSegment;
    WORD  wAttributes;
} WOWFILESETATTRIBUTES16;
typedef WOWFILESETATTRIBUTES16 UNALIGNED *PWOWFILESETATTRIBUTES16;

typedef struct _GETPRIVATEPROFILEINT16 {                   /* k127 */
    VPSTR f4;
    SHORT f3;
    VPSTR f2;
    VPSTR f1;
} GETPRIVATEPROFILEINT16;
typedef GETPRIVATEPROFILEINT16 UNALIGNED *PGETPRIVATEPROFILEINT16;

typedef struct _GETPRIVATEPROFILESTRING16 {                /* k128 */
    VPSTR f6;
    USHORT f5;
    VPSTR f4;
    VPSTR f3;
    VPSTR f2;
    VPSTR f1;
} GETPRIVATEPROFILESTRING16;
typedef GETPRIVATEPROFILESTRING16 UNALIGNED *PGETPRIVATEPROFILESTRING16;

typedef struct _WRITEPRIVATEPROFILESTRING16 {              /* k129 */
    VPSTR f4;
    VPSTR f3;
    VPSTR f2;
    VPSTR f1;
} WRITEPRIVATEPROFILESTRING16;
typedef WRITEPRIVATEPROFILESTRING16 UNALIGNED *PWRITEPRIVATEPROFILESTRING16;

typedef struct _WOWSETCURRENTDIRECTORY16 {                 /* k130 */
    DWORD lpCurDir;
} WOWSETCURRENTDIRECTORY16;
typedef WOWSETCURRENTDIRECTORY16 UNALIGNED *PWOWSETCURRENTDIRECTORY16;

typedef struct _WOWWAITFORMSGANDEVENT16 {                  /* k131 */
    HWND16 hwnd;
} WOWWAITFORMSGANDEVENT16;
typedef WOWWAITFORMSGANDEVENT16 UNALIGNED *PWOWWAITFORMSGANDEVENT16;

typedef struct _WOWMSGBOX16 {                              /* k132 */
    DWORD   dwOptionalStyle;
    VPSZ    pszTitle;
    VPSZ    pszMsg;
} WOWMSGBOX16;
typedef WOWMSGBOX16 UNALIGNED *PWOWMSGBOX16;

typedef struct _WOWDEVICEIOCTL16 {                         /* k135 */
    WORD  wCmd;
    WORD  wDriveNum;
} WOWDEVICEIOCTL16;
typedef WOWDEVICEIOCTL16 UNALIGNED *PWOWDEVICEIOCTL16;

typedef struct _GETDRIVETYPE16 {                           /* k136 */
    SHORT f1;
} GETDRIVETYPE16;
typedef GETDRIVETYPE16 UNALIGNED *PGETDRIVETYPE16;

typedef struct _WOWFILEGETDATETIME16 {                     /* k137 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  fh;
} WOWFILEGETDATETIME16;
typedef WOWFILEGETDATETIME16 UNALIGNED *PWOWFILEGETDATETIME16;

typedef struct _SETAPPCOMPATFLAGS16 {           /* k139 */
    WORD  TDB;
} SETAPPCOMPATFLAGS16;
typedef SETAPPCOMPATFLAGS16 UNALIGNED *PSETAPPCOMPATFLAGS16;

typedef struct _WOWREGISTERSHELLWINDOWHANDLE16 {           /* k139 */
    HWND16 hwndFax;
    VPWORD lpwCmdShow;
    HWND16 hwndShell;
} WOWREGISTERSHELLWINDOWHANDLE16;
typedef WOWREGISTERSHELLWINDOWHANDLE16 UNALIGNED *PWOWREGISTERSHELLWINDOWHANDLE16;

typedef struct _FREELIBRARY32W16 {                         /* k140 */
    DWORD  hLibModule;
} FREELIBRARY32W16;
typedef FREELIBRARY32W16 UNALIGNED *PFREELIBRARY32W16;

typedef struct _GETPROCADDRESS32W16 {                      /* k141 */
    VPVOID lpszProc;
    DWORD  hModule;
} GETPROCADDRESS32W16;
typedef GETPROCADDRESS32W16 UNALIGNED *PGETPROCADDRESS32W16;

typedef struct _GETPROFILESECTIONNAMES16 {                 /* k142 */
    WORD  cbBuffer;
    VPSTR lpszBuffer;
} GETPROFILESECTIONNAMES16;
typedef GETPROFILESECTIONNAMES16 UNALIGNED *PGETPROFILESECTIONNAMES16;

typedef struct _GETPRIVATEPROFILESECTIONNAMES16 {          /* k143 */
    VPSTR lpszFile;
    WORD  cbBuffer;
    VPSTR lpszBuffer;
} GETPRIVATEPROFILESECTIONNAMES16;
typedef GETPRIVATEPROFILESECTIONNAMES16 UNALIGNED *PGETPRIVATEPROFILESECTIONNAMES16;

typedef struct _CREATEDIRECTORY16 {                        /* k144 */
    VPVOID lpSA;
    VPSTR  lpszName;
} CREATEDIRECTORY16;
typedef CREATEDIRECTORY16 UNALIGNED *PCREATEDIRECTORY16;

typedef struct _REMOVEDIRECTORY16 {                        /* k145 */
    VPSTR  lpszName;
} REMOVEDIRECTORY16;
typedef REMOVEDIRECTORY16 UNALIGNED *PREMOVEDIRECTORY16;

typedef struct _DELETEFILE16 {                             /* k146 */
    VPSTR  lpszName;
} DELETEFILE16;
typedef DELETEFILE16 UNALIGNED *PDELETEFILE16;

typedef struct _SETLASTERROR16 {                           /* k147 */
    DWORD dwError;
} SETLASTERROR16;
typedef SETLASTERROR16 UNALIGNED *PSETLASTERROR16;

#ifdef NULLSTRUCT
typedef struct _GETLASTERROR16 {                           /* k148 */
} GETLASTERROR16;
typedef GETLASTERROR16 UNALIGNED *PGETLASTERROR16;
#endif

typedef struct _GETVERSIONEX16 {                           /* k149 */
    VPVOID lpVersionInfo;
} GETVERSIONEX16;
typedef GETVERSIONEX16 UNALIGNED *PGETVERSIONEX16;

typedef struct _DIRECTEDYIELD16 {                          /* k150 */
    WORD    hTask16;
} DIRECTEDYIELD16;
typedef DIRECTEDYIELD16 UNALIGNED *PDIRECTEDYIELD16;

typedef struct _WOWFILEREAD16 {                            /* k151 */
    DWORD lpSFT;
    DWORD lpPDB;
    DWORD bufsize;
    DWORD lpBuf;
    WORD  fh;
} WOWFILEREAD16;
typedef WOWFILEREAD16 UNALIGNED *PWOWFILEREAD16;

typedef struct _WOWFILELSEEK16 {                           /* k152 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  mode;
    DWORD fileOffset;
    WORD  fh;
} WOWFILELSEEK16;
typedef WOWFILELSEEK16 UNALIGNED *PWOWFILELSEEK16;

typedef struct _WOWKERNELTRACE16 {                         /* k153 */
    DWORD lpUserArgs;
    WORD  cParms;
    VPSTR lpRoutineName;
} WOWKERNELTRACE16;
typedef WOWKERNELTRACE16 UNALIGNED *PWOWKERNELTRACE16;

typedef struct _LOADLIBRARYEX32W16 {                       /* k154 */
    DWORD  dwFlags;
    DWORD  hFile;
    VPVOID lpszLibFile;
} LOADLIBRARYEX32W16;
typedef LOADLIBRARYEX32W16 UNALIGNED *PLOADLIBRARYEX32W16;

typedef struct _WOWQUERYPERFORMANCECOUNTER16 {             /* k155 */
    VPVOID lpPerformanceFrequency;
    VPVOID lpPerformanceCounter;
} WOWQUERYPERFORMANCECOUNTER16;
typedef WOWQUERYPERFORMANCECOUNTER16 UNALIGNED *PWOWQUERYPERFORMANCECOUNTER16;

typedef struct _WOWCURSORICONOP16 {                        /* k156 */
    WORD   wFuncId;
    WORD   h16;
} WOWCURSORICONOP16;
typedef WOWCURSORICONOP16 UNALIGNED *PWOWCURSORICONOP16;

typedef struct _WOWCLOSECOMPORT16 {                        /* k159 */
    WORD    wPortId;
} WOWCLOSECOMPORT16;
typedef WOWCLOSECOMPORT16 UNALIGNED *PWOWCLOSECOMPORT16;

typedef struct _LOCAL32INIT16 {                            /* k160 */
    DWORD dwFlags;
    DWORD dwcbMax;
    DWORD dwcbInit;
    WORD  wSel;
} LOCAL32INIT16;
typedef LOCAL32INIT16 UNALIGNED *PLOCAL32INIT16;

typedef struct _LOCAL32ALLOC16 {                           /* k161 */
    DWORD dwFlags;
    WORD  wType;
    DWORD dwcbRequest;
    WORD  wSel;
} LOCAL32ALLOC16;
typedef LOCAL32ALLOC16 UNALIGNED *PLOCAL32ALLOC16;

typedef struct _LOCAL32REALLOC16 {                         /* k162 */
    DWORD dwFlags;
    DWORD dwcbNew;
    WORD  wType;
    DWORD dwMem;
    DWORD dwLinHeader;
} LOCAL32REALLOC16;
typedef LOCAL32REALLOC16 UNALIGNED *PLOCAL32REALLOC16;

typedef struct _LOCAL32FREE16 {                            /* k163 */
    WORD  wType;
    DWORD dwMem;
    DWORD dwLinHeader;
} LOCAL32FREE16;
typedef LOCAL32FREE16 UNALIGNED *PLOCAL32FREE16;

typedef struct _LOCAL32TRANSLATE16 {                       /* k164 */
    WORD  wRetType;
    WORD  wMemType;
    DWORD dwMem;
    DWORD dwLinHeader;
} LOCAL32TRANSLATE16;
typedef LOCAL32TRANSLATE16 UNALIGNED *PLOCAL32TRANSLATE16;

typedef struct _LOCAL32SIZE16 {                            /* k165 */
    WORD  wType;
    DWORD dwMem;
    DWORD dwLinHeader;
} LOCAL32SIZE16;
typedef LOCAL32SIZE16 UNALIGNED *PLOCAL32SIZE16;

typedef struct _LOCAL32VALIDHANDLE16 {                     /* k166 */
    WORD  hMem;
    DWORD dwLinHeader;
} LOCAL32VALIDHANDLE16;
typedef LOCAL32VALIDHANDLE16 UNALIGNED *PLOCAL32VALIDHANDLE16;

typedef struct _REGENUMKEY3216 {                           /* k167 */
    DWORD  cchName;
    VPSTR  lpszName;
    DWORD  iSubKey;
    DWORD  hKey;
} REGENUMKEY3216;
typedef REGENUMKEY3216 UNALIGNED *PREGENUMKEY3216;

typedef struct _REGOPENKEY3216 {                           /* k168 */
    VPVOID  phkResult;
    VPSTR   lpszSubKey;
    DWORD   hKey;
} REGOPENKEY3216;
typedef REGOPENKEY3216 UNALIGNED *PREGOPENKEY3216;

typedef struct _REGCREATEKEY3216 {                         /* k169 */
    VPVOID  phkResult;
    VPSTR   lpszSubKey;
    DWORD   hKey;
} REGCREATEKEY3216;
typedef REGCREATEKEY3216 UNALIGNED *PREGCREATEKEY3216;

typedef struct _REGDELETEKEY3216 {                         /* k170 */
    VPSTR   lpszSubKey;
    DWORD   hKey;
} REGDELETEKEY3216;
typedef REGDELETEKEY3216 UNALIGNED *PREGDELETEKEY3216;

typedef struct _REGCLOSEKEY3216 {                          /* k171 */
    DWORD  hKey;
} REGCLOSEKEY3216;
typedef REGCLOSEKEY3216 UNALIGNED *PREGCLOSEKEY3216;

typedef struct _REGSETVALUE3216 {                          /* k172 */
    DWORD   cbValue;
    VPSTR   lpValue;
    DWORD   dwType;
    VPSTR   lpszSubKey;
    DWORD   hKey;
} REGSETVALUE3216;
typedef REGSETVALUE3216 UNALIGNED *PREGSETVALUE3216;

typedef struct _REGDELETEVALUE3216 {                       /* k173 */
    VPSTR   lpszValue;
    DWORD   hKey;
} REGDELETEVALUE3216;
typedef REGDELETEVALUE3216 UNALIGNED *PREGDELETEVALUE3216;

typedef struct _REGENUMVALUE3216 {                         /* k174 */
    VPVOID lpcbData;
    VPVOID lpbData;
    DWORD  lpdwType;
    DWORD  lpdwReserved;
    DWORD  lpcchValue;
    VPSTR  lpszValue;
    DWORD  iValue;
    DWORD  hKey;
} REGENUMVALUE3216;
typedef REGENUMVALUE3216 UNALIGNED *PREGENUMVALUE3216;

typedef struct _WOWLFNFRAMEPTR16 {                         /* k204 */
    VPVOID lpUserFrame;
} WOWLFNFRAMEPTR16;
typedef WOWLFNFRAMEPTR16 UNALIGNED *PWOWLFNFRAMEPTR16;

typedef struct _REGQUERYVALUE3216 {                        /* k175 */
    DWORD   cbValue;
    VPSTR   lpValue;
    VPSTR   lpszSubKey;
    DWORD   hKey;
} REGQUERYVALUE3216;
typedef REGQUERYVALUE3216 UNALIGNED *PREGQUERYVALUE3216;

typedef struct _REGQUERYVALUEEX3216 {                      /* k176 */
    DWORD   cbBuffer;
    VPSTR   lpBuffer;
    VPDWORD vpdwType;
    VPDWORD vpdwReserved;
    VPSTR   lpszValue;
    DWORD   hKey;
} REGQUERYVALUEEX3216;
typedef REGQUERYVALUEEX3216 UNALIGNED *PREGQUERYVALUEEX3216;

typedef struct _REGSETVALUEEX3216 {                        /* k177 */
    DWORD   cbBuffer;
    VPSTR   lpBuffer;
    DWORD   dwType;
    DWORD   dwReserved;
    VPSTR   lpszValue;
    DWORD   hKey;
} REGSETVALUEEX3216;
typedef REGSETVALUEEX3216 UNALIGNED *PREGSETVALUEEX3216;

typedef struct _REGFLUSHKEY3216 {                          /* k178 */
    DWORD   hKey;
} REGFLUSHKEY3216;
typedef REGFLUSHKEY3216 UNALIGNED *PREGFLUSHKEY3216;

typedef struct _COMPUTEOBJECTOWNER16 {                     /* k179 */
    WORD wSel;
} COMPUTEOBJECTOWNER16;
typedef COMPUTEOBJECTOWNER16 UNALIGNED *PCOMPUTEOBJECTOWNER16;

typedef struct _LOCAL32GETSEL16 {                          /* k180 */
    DWORD dwLinHeader;
} LOCAL32GETSEL16;
typedef LOCAL32GETSEL16 UNALIGNED *PLOCAL32GETSEL16;

typedef struct _MAPPROCESSHANDLE16 {                       /* k181 */
    DWORD dwHandle;
} MAPPROCESSHANDLE16;
typedef MAPPROCESSHANDLE16 UNALIGNED *PMAPPROCESSHANDLE16;

#ifdef NULLSTRUCT
typedef struct _INVALIDATENLSCACHE16 {                     /* k182 */
} INVALIDATENLSCACHE16;
typedef INVALIDATENLSCACHE16 UNALIGNED *PINVALIDATENLSCACHE16;
#endif

typedef struct _WOWDELFILE16 {                             /* k183 */
    VPSTR lpFile;
} WOWDELFILE16;
typedef WOWDELFILE16 UNALIGNED *PWOWDELFILE16;

#ifdef  RENAMEVIRTUAL

typedef struct _WOWVIRTUALALLOC16 {                        /* k184 */
    DWORD fdwProtect;
    DWORD fdwAllocationType;
    DWORD cbSize;
    DWORD lpvAddress;
} WOWVIRTUALALLOC16;
typedef WOWVIRTUALALLOC16 UNALIGNED *PWOWVIRTUALALLOC16;

typedef struct _WOWVIRTUALFREE16 {                         /* k185 */
    DWORD fdwFreeType;
    DWORD cbSize;
    DWORD lpvAddress;
} WOWVIRTUALFREE16;
typedef WOWVIRTUALFREE16 UNALIGNED *PWOWVIRTUALFREE16;

#else   // RENAMEVIRTUAL

typedef struct _VIRTUALALLOC16 {                        /* k184 */
    DWORD fdwProtect;
    DWORD fdwAllocationType;
    DWORD cbSize;
    DWORD lpvAddress;
} VIRTUALALLOC16;
typedef VIRTUALALLOC16 UNALIGNED *PVIRTUALALLOC16;

typedef struct _VIRTUALFREE16 {                         /* k185 */
    DWORD fdwFreeType;
    DWORD cbSize;
    DWORD lpvAddress;
} VIRTUALFREE16;
typedef VIRTUALFREE16 UNALIGNED *PVIRTUALFREE16;

#endif  // else renamevirtual

typedef struct _VIRTUALLOCK16 {                            /* k186 */
    DWORD cbSize;
    DWORD lpvAddress;
} VIRTUALLOCK16;
typedef VIRTUALLOCK16 UNALIGNED *PVIRTUALLOCK16;

typedef struct _VIRTUALUNLOCK16 {                          /* k187 */
    DWORD cbSize;
    DWORD lpvAddress;
} VIRTUALUNLOCK16;
typedef VIRTUALUNLOCK16 UNALIGNED *PVIRTUALUNLOCK16;

typedef struct _GLOBALMEMORYSTATUS16 {                     /* k188 */
    VPVOID lpmstMemStat;
} GLOBALMEMORYSTATUS16;
typedef GLOBALMEMORYSTATUS16 UNALIGNED *PGLOBALMEMORYSTATUS16;

typedef struct _WOWGETTABLEOFFSETS16 {                     /* k190 */
    VPVOID  vpThunkTableOffsets;
} WOWGETTABLEOFFSETS16;
typedef WOWGETTABLEOFFSETS16 UNALIGNED *PWOWGETTABLEOFFSETS16;

typedef struct _WOWKILLREMOTETASK16 {                      /* k191 */
    VPVOID  lpBuffer;
} WOWKILLREMOTETASK16;
typedef WOWKILLREMOTETASK16 UNALIGNED *PWOWKILLREMOTETASK16;

typedef struct _WOWNOTIFYWOW3216 {                         /* k192 */
    VPVOID  Int21Handler;
    VPVOID  lpnum_tasks;
    VPVOID  lpcurTDB;
    VPVOID  lpDebugWOW;
    VPVOID  lpLockTDB;
    VPVOID  lptopPDB;
    VPVOID  lpCurDirOwner;
} WOWNOTIFYWOW3216;
typedef WOWNOTIFYWOW3216 UNALIGNED *PWOWNOTIFYWOW3216;

typedef struct _WOWFILEOPEN16 {                            /* k193 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  wAccess;
    WORD  pszPathOffset;
    WORD  pszPathSegment;
} WOWFILEOPEN16;
typedef WOWFILEOPEN16 UNALIGNED *PWOWFILEOPEN16;

typedef struct _WOWFILECLOSE16 {                           /* k194 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  hFile;
} WOWFILECLOSE16;
typedef WOWFILECLOSE16 UNALIGNED *PWOWFILECLOSE16;

typedef struct _KSYSERRORBOX16 {                           /* k196 */
    SHORT sBtn3;
    SHORT sBtn2;
    SHORT sBtn1;
    VPSZ  vpszCaption;
    VPSZ  vpszText;
} KSYSERRORBOX16;
typedef KSYSERRORBOX16 UNALIGNED *PKSYSERRORBOX16;

typedef struct _WOWISKNOWNDLL16 {                          /* k197 */
    VPVOID lplpszKnownDLLPath;
    VPVOID lpszPath;
} WOWISKNOWNDLL16;

typedef struct _WOWDDEFREEHANDLE16 {                       /* k198 */
    WORD   h16;
} WOWDDEFREEHANDLE16;
typedef WOWDDEFREEHANDLE16 UNALIGNED *PWOWDDEFREEHANDLE16;

typedef struct _WOWFILEGETATTRIBUTES16 {                   /* k199 */
    WORD  pszPathOffset;
    WORD  pszPathSegment;
} WOWFILEGETATTRIBUTES16;
typedef WOWFILEGETATTRIBUTES16 UNALIGNED *PWOWFILEGETATTRIBUTES16;

typedef struct _WOWSETDEFAULTDRIVE16 {                     /* k200 */
    WORD  wDriveNum;
} WOWSETDEFAULTDRIVE16;
typedef WOWSETDEFAULTDRIVE16 UNALIGNED *PWOWSETDEFAULTDRIVE16;

typedef struct _WOWGETCURRENTDIRECTORY16 {                 /* k201 */
    DWORD lpCurDir;
    WORD  wDriveNum;
} WOWGETCURRENTDIRECTORY16;
typedef WOWGETCURRENTDIRECTORY16 UNALIGNED *PWOWGETCURRENTDIRECTORY16;

typedef struct _GETPRODUCTNAME16 {                         /* k202 */
    WORD  cbBuffer;
    VPSTR lpBuffer;
} GETPRODUCTNAME16;
typedef GETPRODUCTNAME16 UNALIGNED *PGETPRODUCTNAME16;

#ifdef NULLSTRUCT
typedef struct _ISSAFEMODE16 {                             /* k203 */
} ISSAFEMODE16;
typedef ISSAFEMODE16 UNALIGNED *PISSAFEMODE16;
#endif

typedef struct _WOWSHUTDOWNTIMER16 {                       /* k205 */
    WORD fEnable;
} WOWSHUTDOWNTIMER16;
typedef WOWSHUTDOWNTIMER16 UNALIGNED *PWOWSHUTDOWNTIMER16;

#ifdef NULLSTRUCT
typedef struct _WOWTRIMWORKINGSET16 {                   /* k206 */
} WOWTRIMWORKINGSET16;
typedef WOWTRIMWORKINGSET16 UNALIGNED *PWOWTRIMWORKINGSET16;
#endif

#ifdef FE_SB
#ifdef NULLSTRUCT
typedef struct _GETSYSTEMDEFAULTLANGID16 {                   /* k207 */
} GETSYSTEMDEFAULTLANGID16;
typedef GETSYSTEMDEFAULTLANGID16 UNALIGNED *PGETSYSTEMDEFAULTLANGID16;
#endif
#endif

typedef struct _TERMSRVGETWINDIR16 {                            /* k208 */
    WORD  usPathLen;
    WORD  pszPathOffset;
    WORD  pszPathSegment;
} TERMSRVGETWINDIR16;
typedef TERMSRVGETWINDIR16 UNALIGNED *PTERMSRVGETWINDIR16;

/*
typedef struct _WOWGETCURRENTDIRECTORYLONG16 {             // k209
    DWORD lpCurDir;
    WORD  wDriveNum;
    WORD  cchDir;
} WOWGETCURRENTDIRECTORYLONG16;
typedef WOWGETCURRENTDIRECTORYLONG16 UNALIGNED *PWOWGETCURRENTDIRECTORYLONG16;
*/

typedef struct _WOWPASSENVIRONMENT16 {                        /* k209 */
    WORD   pExe;    // pointer to exe header
    DWORD  pParmBlk; // parameter block
    WORD   cur_DOS_PDB; // dos pdb
//     WORD   Win_PDB;  // windows pdb not necessary for now
} WOWPASSENVIRONMENT16;
typedef WOWPASSENVIRONMENT16 UNALIGNED *PWOWPASSENVIRONMENT16;

typedef struct _WOWDIVIDEOVERFLOW {            /* k212 */
    DWORD local;
    DWORD csip;
    DWORD edx;
    DWORD eax;
} WOWDIVIDEOVERFLOW;
typedef WOWDIVIDEOVERFLOW UNALIGNED *PWOWDIVIDEOVERFLOW;

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wownls.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWNLS.H
 *  16-bit IME API argument structures
 *
 *  History:
 *  Created 16-Apl-1996 by MSKK
 *
--*/

/* IME API IDs
 */
#define FUN_SENDIMEMESSAGE		6
#define FUN_SENDIMEMESSAGEEX		7

#define	FUN_WINNLSGETIMEHOTKEY		15
#define	FUN_WINNLSENABLEIME		16
#define	FUN_WINNLSGETENABLESTATUS	18

#define	FUN_IMPQUERYIME			22
#define	FUN_IMPGETIME			23
#define	FUN_IMPSETIME			24


#if 0 // NT does not support the following APIs
#define FUN_INQUIREWINNLS		1
#define	FUN_HOOKKEYBOARDMESSAGE		2
#define FUN_CONTROLIMEMESSAGE       	8	// for Taiwan
#define	FUN_WINNLSSETKEYBOARDHOOK	10
#define	FUN_WINNLSSETIMEHANDLE		11
#define	FUN_WINNLSSETIMESTATUS		12
#define	FUN_WINNLSSETIMEHOTKEY		14
#define	FUN_WINNLSGETKEYSTATE		17
#define	FUN_WINNLSSETKEYSTATE		19
#define	FUN_IMPADDIME			20
#define	FUN_IMPDELETEIME		21
#define	FUN_IMPMODIFYIME		25
#define	FUN_IMPGETDEFAULTIME		26
#define	FUN_IMPSETDEFAULTIME		27
#define	FUN_WINNLSSENDSTRING		30
#define	FUN_WINNLSPOSTAPPMESSAGE	31
#define	FUN_WINNLSSENDAPPMESSAGE	32
#define FUN_WINNLSQUERYIMEINFO      	40     // for Taiwan
#endif // 0


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _SENDIMEMESSAGE16 { /* wn6 */
	DWORD	lParam;
	HWND16	hwnd;
} SENDIMEMESSAGE16;
typedef SENDIMEMESSAGE16 UNALIGNED *PSENDIMEMESSAGE16;

typedef struct _SENDIMEMESSAGEEX16 { /* wn7 */
	DWORD	lParam;
	HWND16	hwnd;
} SENDIMEMESSAGEEX16;
typedef SENDIMEMESSAGEEX16 UNALIGNED *PSENDIMEMESSAGEEX16;

typedef struct _WINNLSGETIMEHOTKEY16 { /* wn15 */
	HWND16	hwnd;
} WINNLSGETIMEHOTKEY16;
typedef WINNLSGETIMEHOTKEY16 UNALIGNED *PWINNLSGETIMEHOTKEY16;

typedef struct _WINNLSENABLEIME16 { /* wn16 */
	WORD	fEnabled;
	HWND16	hwnd;
} WINNLSENABLEIME16;
typedef WINNLSENABLEIME16 UNALIGNED *PWINNLSENABLEIME16;

typedef struct _WINNLSGETENABLESTATUS16 { /* wn 18 */
	HWND16	hwnd;
} WINNLSGETENABLESTATUS16;
typedef WINNLSGETENABLESTATUS16 UNALIGNED *PWINNLSGETENABLESTATUS16;

typedef struct _IMPQUERYIME16 { /* wn22 */
        VPVOID  lpIMEPro;
} IMPQUERYIME16;
typedef IMPQUERYIME16 UNALIGNED *PIMPQUERYIME16;

typedef struct _IMPGETIME16 { /* wn23 */
        VPVOID  lpIMEPro;
	HWND16	hwnd;
} IMPGETIME16;
typedef IMPGETIME16 UNALIGNED *PIMPGETIME16;

typedef struct _IMPSETIME16 { /* wn24 */
        VPVOID  lpIMEPro;
	HWND16	hwnd;
} IMPSETIME16;
typedef IMPSETIME16 UNALIGNED *PIMPSETIME16;






#if 0 // NT does not support the following APIs
typedef struct _SETKEYBOARDHOOK16 { /* wn10 */
	WORD    flag;
} SETKEYBOARDHOOK16;
typedef SETKEYBOARDHOOK16 UNALIGNED *PSETKEYBOARDHOOK16;

typedef struct _SETIMEHANDLE16 { /* wn11 */
	VPSTR	lpszName;
	HWND16	hwnd;
} SETIMEHANDLE16;
typedef SETIMEHANDLE16 UNALIGNED *PSETIMEHANDLE16;

typedef struct _SETIMESTATUS16 { /* wn12 */
	WORD	status;
	HWND16	hwnd;
} SETIMESTATUS16;
typedef SETIMESTATUS16 UNALIGNED *PSETIMESTATUS16;

typedef struct _SETIMEHOTKEY16 { /* wn14 */
	WORD	key;
	HWND16	hwnd;
} SETIMEHOTKEY16;
typedef SETIMEHOTKEY16 UNALIGNED *PSETIMEHOTKEY16;
#endif // 0

typedef struct _IMESTRUCT16 { /* imest */
	WORD	fnc;
	WORD	wParam;
	WORD	wCount;
	WORD	dchSource;
	WORD	dchDest;
	LONG	lParam1;
	LONG	lParam2;
	LONG	lParam3;
} IMESTRUCT16;
typedef IMESTRUCT16 UNALIGNED *PIMESTRUCT16;

#if 0
typedef struct _SETKEYSTATE16 { /* wn19 */
	HWND16	hwnd;
	WORD	wState;
} SETKEYSTATE16;
typedef SETKEYSTATE16 UNALIGNED *PSETKEYSTATE16;
#endif // 0

typedef struct _DATETIME16 { /* dt */
    WORD	year;
    WORD	month;
    WORD	day;
    WORD	hour;
    WORD	min;
    WORD	sec;
} DATETIME16;

typedef struct _IMEPRO16 { /* pro */
	HWND16	hWnd;
	DATETIME16 InstDate;
	WORD	wVersion;
	BYTE	szDescription[50];
	BYTE	szName[80];
	BYTE	szOptions[30];
} IMEPRO16;
typedef IMEPRO16 UNALIGNED *PIMEPRO16;

typedef struct _UNDETERMINESTRUCT16 { /* ud16 */
    DWORD    dwSize;
    INT16     uDefIMESize;
    INT16     uDefIMEPos;
    INT16     uUndetTextLen;
    INT16     uUndetTextPos;
    INT16     uUndetAttrPos;
    INT16     uCursorPos;
    INT16     uDeltaStart;
    INT16     uDetermineTextLen;
    INT16     uDetermineTextPos;
    INT16     uDetermineDelimPos;
    INT16     uYomiTextLen;
    INT16     uYomiTextPos;
    INT16     uYomiDelimPos;
} UNDETERMINESTRUCT16;
typedef UNDETERMINESTRUCT16 UNALIGNED *PUNDETERMINESTRUCT16;

typedef struct _STRINGEXSTRUCT16 { /* sx16 */
    DWORD    dwSize;
    INT16     uDeterminePos;
    INT16     uDetermineDelimPos;
    INT16     uYomiPos;
    INT16     uYomiDelimPos;
} STRINGEXSTRUCT16;
typedef STRINGEXSTRUCT16 UNALIGNED *PSTRINGEXSTRUCT16;




/////////// tmp /////////
#if 0
#define IR_DBCSCHAR             0x160   /* New for 3.1 */
#define IR_UNDETERMINE          0x170   /* New for 3.1 */
#define IR_STRINGEX             0x180   /* New for 3.1 */

typedef struct UNDETERMINESTRUCT32 { /* ud32 */
    DWORD    dwSize;
    UINT     uDefIMESize;
    UINT     uDefIMEPos;
    UINT     uUndetTextLen;
    UINT     uUndetTextPos;
    UINT     uUndetAttrPos;
    UINT     uCursorPos;
    UINT     uDeltaStart;
    UINT     uDetermineTextLen;
    UINT     uDetermineTextPos;
    UINT     uDetermineDelimPos;
    UINT     uYomiTextLen;
    UINT     uYomiTextPos;
    UINT     uYomiDelimPos;
} UNDETERMINESTRUCT32;
typedef UNDETERMINESTRUCT32 UNALIGNED *PUNDETERMINESTRUCT32;

typedef struct STRINGEXSTRUCT32 { /* sx32 */
    DWORD    dwSize;
    UINT     uDeterminePos;
    UINT     uDetermineDelimPos;
    UINT     uYomiPos;
    UINT     uYomiDelimPos;
} STRINGEXSTRUCT32;
typedef STRINGEXSTRUCT32 UNALIGNED *PSTRINGEXSTRUCT32;
#endif // 0
//////// end of tmp ///////////

/* XLATOFF */
#pragma pack()
/* XLATON */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowth.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWTH.H
 *  16-bit ToolHelp thunked API argument structures
 *
 *  History:
 *  12-Nov-92 Dave Hart (davehart) created using wowkrn.h as template
--*/


/* ToolHelp API IDs
 */
#define FUN_CLASSFIRST          1
#define FUN_CLASSNEXT           2


/* XLATOFF */
#pragma pack(2)
/* XLATON */


typedef struct _CLASSFIRST16 {      /* th1 */
    VPVOID f1;
} CLASSFIRST16;
typedef CLASSFIRST16 UNALIGNED *PCLASSFIRST16;

typedef struct _CLASSNEXT16 {       /* th2 */
    VPVOID f1;
} CLASSNEXT16;
typedef CLASSNEXT16 UNALIGNED *PCLASSNEXT16;


/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowsnd.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWSND.H
 *  16-bit Sound API argument structures
 *
 *  History:
 *  Created 02-Feb-1991 by Jeff Parsons (jeffpar)
--*/


/* Sound API IDs
 */
#define FUN_CLOSESOUND			2   //
#define FUN_COUNTVOICENOTES		13  //
#define FUN_DOBEEP			17  // Internal
#define FUN_GETTHRESHOLDEVENT		14  //
#define FUN_GETTHRESHOLDSTATUS		15  //
#define FUN_MYOPENSOUND 		18  // Internal
#define FUN_OPENSOUND			1   //
#define FUN_SETSOUNDNOISE		7   //
#define FUN_SETVOICEACCENT		5   //
#define FUN_SETVOICEENVELOPE		6   //
#define FUN_SETVOICENOTE		4   //
#define FUN_SETVOICEQUEUESIZE		3   //
#define FUN_SETVOICESOUND		8   //
#define FUN_SETVOICETHRESHOLD		16  //
#define FUN_SOUND_WEP			0   // Export by name
#define FUN_STARTSOUND			9   //
#define FUN_STOPSOUND			10  //
#define FUN_SYNCALLVOICES		12  //
#define FUN_WAITSOUNDSTATE		11  //


/* XLATOFF */
#pragma pack(2)
/* XLATON */

#ifdef NULLSTRUCT
typedef struct _CLOSESOUND16 {			/* s2 */
} CLOSESOUND16;
typedef CLOSESOUND16 UNALIGNED *PCLOSESOUND16;
#endif

typedef struct _COUNTVOICENOTES16 {		/* s13 */
    SHORT f1;
} COUNTVOICENOTES16;
typedef COUNTVOICENOTES16 UNALIGNED *PCOUNTVOICENOTES16;

#ifdef NULLSTRUCT
typedef struct _GETTHRESHOLDEVENT16 {		/* s14 */
} GETTHRESHOLDEVENT16;
typedef GETTHRESHOLDEVENT16 UNALIGNED *PGETTHRESHOLDEVENT16;
#endif

#ifdef NULLSTRUCT
typedef struct _GETTHRESHOLDSTATUS16 {		/* s15 */
} GETTHRESHOLDSTATUS16;
typedef GETTHRESHOLDSTATUS16 UNALIGNED *PGETTHRESHOLDSTATUS16;
#endif

#ifdef NULLSTRUCT
typedef struct _OPENSOUND16 {			/* s1 */
} OPENSOUND16;
typedef OPENSOUND16 UNALIGNED *POPENSOUND16;
#endif

typedef struct _SETSOUNDNOISE16 {		/* s7 */
    SHORT f1;
    SHORT f2;
} SETSOUNDNOISE16;
typedef SETSOUNDNOISE16 UNALIGNED *PSETSOUNDNOISE16;

typedef struct _SETVOICEACCENT16 {		/* s5 */
    SHORT f1;
    SHORT f2;
    SHORT f3;
    SHORT f4;
    SHORT f5;
} SETVOICEACCENT16;
typedef SETVOICEACCENT16 UNALIGNED *PSETVOICEACCENT16;

typedef struct _SETVOICEENVELOPE16 {		/* s6 */
    SHORT f1;
    SHORT f2;
    SHORT f3;
} SETVOICEENVELOPE16;
typedef SETVOICEENVELOPE16 UNALIGNED *PSETVOICEENVELOPE16;

typedef struct _SETVOICENOTE16 {		/* s4 */
    SHORT f1;
    SHORT f2;
    SHORT f3;
    SHORT f4;
} SETVOICENOTE16;
typedef SETVOICENOTE16 UNALIGNED *PSETVOICENOTE16;

typedef struct _SETVOICEQUEUESIZE16 {		/* s3 */
    SHORT f1;
    SHORT f2;
} SETVOICEQUEUESIZE16;
typedef SETVOICEQUEUESIZE16 UNALIGNED *PSETVOICEQUEUESIZE16;

typedef struct _SETVOICESOUND16 {		/* s8 */
    SHORT f1;
    LONG f2;
    SHORT f3;
} SETVOICESOUND16;
typedef SETVOICESOUND16 UNALIGNED *PSETVOICESOUND16;

typedef struct _SETVOICETHRESHOLD16 {		/* s16 */
    SHORT f1;
    SHORT f2;
} SETVOICETHRESHOLD16;
typedef SETVOICETHRESHOLD16 UNALIGNED *PSETVOICETHRESHOLD16;

#ifdef NULLSTRUCT
typedef struct _STARTSOUND16 {			/* s9 */
} STARTSOUND16;
typedef STARTSOUND16 UNALIGNED *PSTARTSOUND16;
#endif

#ifdef NULLSTRUCT
typedef struct _STOPSOUND16 {			/* s10 */
} STOPSOUND16;
typedef STOPSOUND16 UNALIGNED *PSTOPSOUND16;
#endif

#ifdef NULLSTRUCT
typedef struct _SYNCALLVOICES16 {		/* s12 */
} SYNCALLVOICES16;
typedef SYNCALLVOICES16 UNALIGNED *PSYNCALLVOICES16;
#endif

typedef struct _WAITSOUNDSTATE16 {		/* s11 */
    SHORT f1;
} WAITSOUNDSTATE16;
typedef WAITSOUNDSTATE16 UNALIGNED *PWAITSOUNDSTATE16;

/* XLATOFF */
#pragma pack()
/* XLATON */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowshell.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWSHELL.H
 *  16-bit SHELL API argument structures
 *
 *  History:
 *  Created 14-April-1992 by Chandan S. Chauhan (ChandanC)
 *  Added Win95 exports 17-Oct-1996 Dave Hart (davehart)
 *
--*/

/* SHELL API IDs
 */
#define FUN_REGOPENKEY            1
#define FUN_REGCREATEKEY          2
#define FUN_REGCLOSEKEY           3
#define FUN_REGDELETEKEY          4
#define FUN_REGSETVALUE           5
#define FUN_REGQUERYVALUE         6
#define FUN_REGENUMKEY            7
#define FUN_DRAGACCEPTFILES       9
#define FUN_DRAGQUERYFILE         11
#define FUN_DRAGFINISH            12
#define FUN_DRAGQUERYPOINT        13
#define FUN_SHELLEXECUTE          20
#define FUN_FINDEXECUTABLE        21
#define FUN_SHELLABOUT            22
#define FUN_WCI                   32
#define FUN_ABOUTDLGPROC          33
#define FUN_EXTRACTICON           34
#define FUN_EXTRACTASSOCIATEDICON 36
#define FUN_DOENVIRONMENTSUBST    37
#define FUN_FINDENVIRONMENTSTRING 38
#define FUN_INTERNALEXTRACTICON   39
#define FUN_HERETHARBETYGARS      41  // export 100
#define FUN_FINDEXEDLGPROC        42  // export 101
#define FUN_REGISTERSHELLHOOK     43  // export 102
#define FUN_SHELLHOOKPROC         44  // export 103

/* New for Win95 */

#define FUN_EXTRACTICONEX         40
#define FUN_RESTARTDIALOG         45  // export 157
#define FUN_PICKICONDLG           46  // export 166
#define FUN_DRIVETYPE             47  // export 262
#define FUN_SH16TO32DRIVEIOCTL    48  // export 263
#define FUN_SH16TO32INT2526       49  // export 264
#define FUN_SHGETFILEINFO         50  // export 300
#define FUN_SHFORMATDRIVE         51  // export 400
#define FUN_SHCHECKDRIVE          52  // export 401
#define FUN__RUNDLLCHECKDRIVE     53  // export 402


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _REGOPENKEY16 {		/* s1 */
    VPVOID  f3;
    VPVOID  f2;
    DWORD	f1;
} REGOPENKEY16;
typedef REGOPENKEY16 UNALIGNED *PREGOPENKEY16;

typedef struct _REGCREATEKEY16 {	/* s2 */
    VPVOID  f3;
    VPVOID  f2;
    DWORD   f1;
} REGCREATEKEY16;
typedef REGCREATEKEY16 UNALIGNED *PREGCREATEKEY16;

typedef struct _REGCLOSEKEY16 {		/* s3 */
    DWORD   f1;
} REGCLOSEKEY16;
typedef REGCLOSEKEY16 UNALIGNED *PREGCLOSEKEY16;

typedef struct _REGDELETEKEY16 {	/* s4 */
    VPVOID  f2;
    DWORD   f1;
} REGDELETEKEY16;
typedef REGDELETEKEY16 UNALIGNED *PREGDELETEKEY16;

typedef struct _REGSETVALUE16 {		/* s5 */
    DWORD   f5;
    VPVOID  f4;
    DWORD   f3;
    VPVOID  f2;
    DWORD   f1;
} REGSETVALUE16;
typedef REGSETVALUE16 UNALIGNED *PREGSETVALUE16;

typedef struct _REGQUERYVALUE16 {	/* s6 */
    VPVOID  f4;
    VPVOID  f3;
    VPVOID  f2;
    DWORD   f1;
} REGQUERYVALUE16;
typedef REGQUERYVALUE16 UNALIGNED *PREGQUERYVALUE16;

typedef struct _REGENUMKEY16 {		/* s7 */
    DWORD   f4;
    VPVOID  f3;
    DWORD   f2;
    DWORD   f1;
} REGENUMKEY16;
typedef REGENUMKEY16 UNALIGNED *PREGENUMKEY16;

typedef struct _DRAGACCEPTFILES16 {	/* s9 */
    SHORT   f2;
    HAND16  f1;
} DRAGACCEPTFILES16;
typedef DRAGACCEPTFILES16 UNALIGNED *PDRAGACCEPTFILES16;

typedef struct _DRAGQUERYFILE16 {	/* s11 */
    WORD    f4;
    VPVOID  f3;
    WORD    f2;
    HAND16  f1;
} DRAGQUERYFILE16;
typedef DRAGQUERYFILE16 UNALIGNED *PDRAGQUERYFILE16;

typedef struct _DRAGFINISH16 {		/* s12 */
    HAND16  f1;
} DRAGFINISH16;
typedef DRAGFINISH16 UNALIGNED *PDRAGFINISH16;

typedef struct _DRAGQUERYPOINT16 {	/* s13 */
    VPVOID  f2;
    HAND16  f1;
} DRAGQUERYPOINT16;
typedef DRAGQUERYPOINT16 UNALIGNED *PDRAGQUERYPOINT16;

typedef struct _SHELLABOUT16 {	      /* s22 */
    HAND16  f4;
    VPVOID  f3;
    VPVOID  f2;
    HAND16  f1;
} SHELLABOUT16;
typedef SHELLABOUT16 UNALIGNED *PSHELLABOUT16;

typedef struct _SHELLEXECUTE16 {	/* s20 */
    WORD    f6;
    VPVOID  f5;
    VPVOID  f4;
    VPVOID  f3;
    VPVOID  f2;
    HAND16  f1;
} SHELLEXECUTE16;
typedef SHELLEXECUTE16 UNALIGNED *PSHELLEXECUTE16;

typedef struct _FINDEXECUTABLE16 {	/* s21 */
    VPVOID  f3;
    VPVOID  f2;
    VPVOID  f1;
} FINDEXECUTABLE16;
typedef FINDEXECUTABLE16 UNALIGNED *PFINDEXECUTABLE16;

typedef struct _EXTRACTICON16 {		/* s34 */
    WORD    f3;
    VPVOID  f2;
    HAND16  f1;
} EXTRACTICON16;
typedef EXTRACTICON16 UNALIGNED *PEXTRACTICON16;

typedef struct _EXTRACTASSOCIATEDICON16 {	  /* s36 */
    VPVOID  f3;
    VPVOID  f2;
    HAND16  f1;
} EXTRACTASSOCIATEDICON16;
typedef EXTRACTASSOCIATEDICON16 UNALIGNED *PEXTRACTASSOCIATEDICON16;

typedef struct _DOENVIRONMENTSUBST16 {            /* s37 */
    WORD    cch;
    VPVOID  vpsz;
} DOENVIRONMENTSUBST16;
typedef DOENVIRONMENTSUBST16 UNALIGNED *PDOENVIRONMENTSUBST16;


/* New for Win95 */


typedef struct _EXTRACTICONEX16 {            /* s40 */
    SHORT   nIcons;
    VPWORD  phiconSmall;
    VPWORD  phiconLarge;
    SHORT   nIconIndex;
    VPSZ    lpszExeFileName;
} EXTRACTICONEX16;
typedef EXTRACTICONEX16 UNALIGNED *PEXTRACTICONEX16;

typedef struct _RESTARTDIALOG16 {            /* s45 */
    DWORD  dwReturn;
    VPSTR  lpszPrompt;
    HWND16 hwnd;
} RESTARTDIALOG16;
typedef RESTARTDIALOG16 UNALIGNED *PRESTARTDIALOG16;

typedef struct _PICKICONDLG16 {            /* s46 */
    VPSHORT piIconIndex;
    WORD    cbIconPath;
    VPSZ    pszIconPath;
    HWND16  hwnd;
} PICKICONDLG16;
typedef PICKICONDLG16 UNALIGNED *PPICKICONDLG16;

typedef struct _DRIVETYPE16 {            /* s47 */
    SHORT   iDrive;
} DRIVETYPE16;
typedef DRIVETYPE16 UNALIGNED *PDRIVETYPE16;

typedef struct _SH16TO32DRIVEIOCTL16 {            /* s48 */
    VPVOID  pv;
    SHORT   iCmd;
    SHORT   iDrive;
} SH16TO32DRIVEIOCTL16;
typedef SH16TO32DRIVEIOCTL16 UNALIGNED *PSH16TO32DRIVEIOCTL16;

typedef struct _SH16TO32INT252616 {            /* s49 */
    DWORD   dwSector;
    WORD    wCount;
    VPVOID  lpBuf;
    SHORT   iInt;
    SHORT   iDrive;
} SH16TO32INT252616;
typedef SH16TO32INT252616 UNALIGNED *PSH16TO32INT252616;

typedef struct _SHGETFILEINFO16 {            /* s50 */
    WORD    wFlags;
    WORD    cbFileInfo;
    VPVOID  lpsfi;
    DWORD   dwFileAttributes;
    VPSZ    lpszPath;
} SHGETFILEINFO16;
typedef SHGETFILEINFO16 UNALIGNED *PSHGETFILEINFO16;

typedef struct _SHFORMATDRIVE16 {            /* s51 */
    WORD    wOptions;
    WORD    wFmtID;
    WORD    wDrive;
    HWND16  hwnd;
} SHFORMATDRIVE16;
typedef SHFORMATDRIVE16 UNALIGNED *PSHFORMATDRIVE16;

typedef struct _SHCHECKDRIVE16 {            /* s52 */
    VPWORD lpTLhwnd;
    DWORD  dwDrvList;
    DWORD  dwOptions;
    HWND16 hwnd;
} SHCHECKDRIVE16;
typedef SHCHECKDRIVE16 UNALIGNED *PSHCHECKDRIVE16;

typedef struct __RUNDLLCHECKDRIVE16 {            /* s53 */
    SHORT   nCmdShow;
    VPSZ    lpszCmdLine;
    HINST16 hAppInstance;
    HWND16  hwndStub;
} _RUNDLLCHECKDRIVE16;
typedef _RUNDLLCHECKDRIVE16 UNALIGNED *P_RUNDLLCHECKDRIVE16;


/* XLATOFF */
#pragma pack()
/* XLATON */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowmmed.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWMMED.H
 *  16-bit MultiMedia API argument structures
 *
 *  History:
 *  Created 21-Jan-1992 by Mike Tricker (MikeTri), based on the work by jeffpar
--*/
/*++

  General MultiMedia related information

  Moved all the typedefs for H* and VP* back to WOW.H  - MikeTri 090492

--*/

typedef WORD    MMVER16;      // major (high byte), minor (low byte)

#ifndef _INC_MMSYSTEM
typedef DWORD   FOURCC;         // a four character code
typedef LONG    LPARAM;
#endif

#define MAXPNAMELEN      32     // max product name length (including NULL)

/* XLATOFF */
#pragma pack(1)
/* XLATON */


/*
 * MultiMedia Data Structures - MikeTri 10-Feb-1992
 *
 */


typedef struct _AUXCAPS16 {           /* ac16 */
    WORD        wMid;
    WORD        wPid;
    MMVER16   vDriverVersion;
    char        szPname[MAXPNAMELEN];
    WORD        wTechnology;
    DWORD       dwSupport;
} AUXCAPS16;
typedef AUXCAPS16 UNALIGNED *PAUXCAPS16;
typedef VPVOID  VPAUXCAPS16;

typedef struct _DRVCONFIGINFO16 {        /* dci16 */
    DWORD   dwDCISize;
    VPCSTR  lpszDCISectionName;
    VPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO16;
typedef DRVCONFIGINFO16 UNALIGNED *PDRVCONFIGINFO16;
typedef VPVOID  VPDRVCONFIGINFO16;

typedef struct _JOYCAPS16 {              /* jc16 */
    WORD    wMid;
    WORD    wPid;
    char    szPname[MAXPNAMELEN];
    WORD    wXmin;
    WORD    wXmax;
    WORD    wYmin;
    WORD    wYmax;
    WORD    wZmin;
    WORD    wZmax;
    WORD    wNumButtons;
    WORD    wPeriodMin;
    WORD    wPeriodMax;
} JOYCAPS16;
typedef JOYCAPS16 UNALIGNED *PJOYCAPS16;
typedef VPVOID  VPJOYCAPS16;

typedef struct _JOYINFO16 {              /* ji16 */
    WORD    wXpos;
    WORD    wYpos;
    WORD    wZpos;
    WORD    wButtons;
} JOYINFO16;
typedef JOYINFO16 UNALIGNED *PJOYINFO16;
typedef VPVOID  VPJOYINFO16;

typedef struct _MCI_ANIM_OPEN_PARMS16 {  /* maop16 */
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    VPCSTR  lpstrDeviceType;
    VPCSTR  lpstrElementName;
    VPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND16  hWndParent;    // Keeps consistent, and is equivalent anyway
    WORD    wReserved1;
} MCI_ANIM_OPEN_PARMS16;
typedef MCI_ANIM_OPEN_PARMS16 UNALIGNED *PMCI_ANIM_OPEN_PARMS16;
typedef VPVOID  VPMCI_ANIM_OPEN_PARMS16;

typedef struct _MCI_ANIM_PLAY_PARMS16 {  /* mapp16 */
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS16;
typedef MCI_ANIM_PLAY_PARMS16 UNALIGNED *PMCI_ANIM_PLAY_PARMS16;
typedef VPVOID  VPMCA_ANIM_PLAY_PARMS16;

typedef struct _MCI_ANIM_RECT_PARMS16 {  /* marp16 */
    DWORD   dwCallback;
    RECT16  rc;
} MCI_ANIM_RECT_PARMS16;
typedef MCI_ANIM_RECT_PARMS16 UNALIGNED *PMCI_ANIM_RECT_PARMS16;
typedef VPVOID  VPMCI_ANIM_RECT_PARMS16;

typedef struct _MCI_ANIM_STEP_PARMS16 {  /* masp16 */
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS16;
typedef MCI_ANIM_STEP_PARMS16 UNALIGNED *PMCI_ANIM_STEP_PARMS16;
typedef VPVOID  VPMCI_ANIM_STEP_PARMS16;

typedef struct _MCI_ANIM_UPDATE_PARMS16 { /* maup16 */
    DWORD   dwCalback;
    RECT16  rc;
    HDC16   hDC;
} MCI_ANIM_UPDATE_PARMS16;
typedef MCI_ANIM_UPDATE_PARMS16 UNALIGNED *PMCI_ANIM_UPDATE_PARMS16;
typedef VPVOID  VPMCI_ANIM_UPDATE_PARMS16;

typedef struct _MCI_ANIM_WINDOW_PARMS16 { /* mawp16 */
    DWORD   dwCallabck;
    HWND16  hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    VPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS16;
typedef MCI_ANIM_WINDOW_PARMS16 UNALIGNED *PMCI_ANIM_WINDOW_PARMS16;
typedef VPVOID  VPMCI_ANIM_WINDOW_PARMS16;

typedef struct _MCI_BREAK_PARMS16 {       /* mbp16 */
    DWORD  dwCallback;
    INT16  nVirtKey;
    WORD   wReserved0;
    HWND16 hwndBreak;
    WORD   wReserved1;
} MCI_BREAK_PARMS16;
typedef MCI_BREAK_PARMS16 UNALIGNED *PMCI_BREAK_PARMS16;
typedef VPVOID  VPMCI_BREAK_PARMS16;

typedef struct _MCI_GENERIC_PARMS16 {     /* mgp16 */
    DWORD   dwCallback;
} MCI_GENERIC_PARMS16;
typedef MCI_GENERIC_PARMS16 UNALIGNED *PMCI_GENERIC_PARMS16;
typedef VPVOID  VPMCI_GENERIC_PARMS16;

typedef struct _MCI_GETDEVCAPS_PARMS16 {  /* mgdp16 */
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS16;
typedef MCI_GETDEVCAPS_PARMS16 UNALIGNED *PMCI_GETDEVCAPS_PARMS16;
typedef VPVOID  VPMCI_GETDEVCAPS_PARMS16;

typedef struct _MCI_INFO_PARMS16 {        /* mip16 */
    DWORD   dwCallback;
    VPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS16;
typedef MCI_INFO_PARMS16 UNALIGNED *PMCI_INFO_PARMS16;
typedef VPVOID  VPMCI_INFO_PARMS16;

typedef struct _MCI_LOAD_PARMS16 {        /* mlp16 */
    DWORD   dwCallback;
    VPCSTR  lpfilename;
} MCI_LOAD_PARMS16;
typedef MCI_LOAD_PARMS16 UNALIGNED *PMCI_LOAD_PARMS16;
typedef VPVOID  VPMCI_LOAD_PARMS16;

typedef struct _MCI_OPEN_PARMS16 {        /* mop16 */
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    VPCSTR  lpstrDeviceType;
    VPCSTR  lpstrElementName;
    VPCSTR  lpstrAlias;
} MCI_OPEN_PARMS16;
typedef MCI_OPEN_PARMS16 UNALIGNED *PMCI_OPEN_PARMS16;
typedef VPVOID  VPMCI_OPEN_PARMS16;

typedef struct _MCI_OVLY_LOAD_PARMS16 {   /* molp16 */
    DWORD   dwCallback;
    VPCSTR  lpfilename;
    RECT16  rc;
} MCI_OVLY_LOAD_PARMS16;
typedef MCI_OVLY_LOAD_PARMS16 UNALIGNED *PMCI_OVLY_LOAD_PARMS16;
typedef VPVOID  VPMCI_OVLY_LOAD_PARMS16;

typedef struct _MCI_OVLY_OPEN_PARMS16 {   /* moop16 */
    DWORD   dwCallabck;
    WORD    wDeviceID;
    WORD    wReserved0;
    VPCSTR  lpstrDeviceType;
    VPCSTR  lpstrElementName;
    VPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND16  hWndParent;  // The book is wrong
    WORD    wReserved1;
} MCI_OVLY_OPEN_PARMS16;
typedef MCI_OVLY_OPEN_PARMS16 UNALIGNED *PMCI_OVLY_OPEN_PARMS16;
typedef VPVOID  VPMCI_OVLY_OPEN_PARMS16;

typedef struct _MCI_OVLY_RECT_PARMS16 {   /* morp16 */
    DWORD   dwCallback;
    RECT16  rc;
} MCI_OVLY_RECT_PARMS16;
typedef MCI_OVLY_RECT_PARMS16 UNALIGNED *PMCI_OVLY_RECT_PARMS16;
typedef VPVOID  VPMCI_OVLY_RECT_PARMS16;

typedef struct _MCI_OVLY_SAVE_PARMS16 {   /* mosp16 */
    DWORD   dwCallback;
    VPCSTR  lpfilename;
    RECT16  rc;
} MCI_OVLY_SAVE_PARMS16;
typedef MCI_OVLY_SAVE_PARMS16 UNALIGNED *PMCI_OVLY_SAVE_PARMS16;
typedef VPVOID  VPMCI_OVLY_SAVE_PARMS16;

typedef struct _MCI_OVLY_WINDOW_PARMS16 { /* mowp16 */
    DWORD   dwCallabck;
    HWND16  hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    VPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS16;
typedef MCI_OVLY_WINDOW_PARMS16 UNALIGNED *PMCI_OVLY_WINDOW_PARMS16;
typedef VPVOID  VPMCI_OVLY_WINDOW_PARMS16;

typedef struct _MCI_PLAY_PARMS16 {        /* mplp16 */
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS16;
typedef MCI_PLAY_PARMS16 UNALIGNED *PMCI_PLAY_PARMS16;
typedef VPVOID  VPMCI_PLAY_PARMS16;

typedef struct _MCI_RECORD_PARMS16 {      /* mrecp16 */
    DWORD   dwCallabck;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS16;
typedef MCI_RECORD_PARMS16 UNALIGNED *PMCI_RECORD_PARMS16;
typedef VPVOID  VPMCI_RECORD_PARMS16;

typedef struct _MCI_SAVE_PARMS16 {        /* msavp16 */
    DWORD   dwCallback;
    VPCSTR  lpfilename;   // MMSYSTEM.H differs from the book
} MCI_SAVE_PARMS16;
typedef MCI_SAVE_PARMS16 UNALIGNED *PMCI_SAVE_PARMS16;
typedef VPVOID  VPMCI_SAVE_PARMS16;

typedef struct _MCI_SEEK_PARMS16 {        /* msep16 */
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS16;
typedef MCI_SEEK_PARMS16 UNALIGNED *PMCI_SEEK_PARMS16;
typedef VPVOID  VPMCI_SEEK_PARMS16;

typedef struct _MCI_SEQ_SET_PARMS16 {     /* mssp16 */
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS16;
typedef MCI_SEQ_SET_PARMS16 UNALIGNED *PMCI_SEQ_SET_PARMS16;
typedef VPVOID  VPMCI_SEQ_SET_PARMS16;

typedef struct _MCI_SET_PARMS16 {         /* msetp16 */
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS16;
typedef MCI_SET_PARMS16 UNALIGNED *PMCI_SET_PARMS16;
typedef VPVOID  VPMCI_SET_PARMS16;

typedef struct _MCI_SOUND_PARMS16 {       /* msoup16 */
    DWORD   dwCallback;
    VPCSTR  lpstrSoundName;
} MCI_SOUND_PARMS16;
typedef MCI_SOUND_PARMS16 UNALIGNED *PMCI_SOUND_PARMS16;
typedef VPVOID  VPMCI_SOUND_PARMS16;

typedef struct _MCI_STATUS_PARMS16 {      /* mstp16 */
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS16;
typedef MCI_STATUS_PARMS16 UNALIGNED *PMCI_STATUS_PARMS16;
typedef VPVOID  VPMCI_STATUS_PARMS16;

typedef struct _MCI_SYSINFO_PARMS16 {     /* msyip16 */
    DWORD   dwCallback;
    VPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    WORD    wDeviceType;
    WORD    wReserved0;
} MCI_SYSINFO_PARMS16;
typedef MCI_SYSINFO_PARMS16 UNALIGNED *PMCI_SYSINFO_PARMS16;
typedef VPVOID  VPMCI_SYSINFO_PARMS16;

typedef struct _MCI_VD_ESCAPE_PARMS16 {   /* mvep16 */
    DWORD   dwCallback;
    VPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS16;
typedef MCI_VD_ESCAPE_PARMS16 UNALIGNED *PMCI_VD_ESCAPE_PARMS16;
typedef VPVOID  VPMCI_VD_ESCAPE_PARMS16;

typedef struct _MCI_VD_PLAY_PARMS16 {     /* mvpp16 */
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_VD_PLAY_PARMS16;
typedef MCI_VD_PLAY_PARMS16 UNALIGNED *PMCI_VD_PLAY_PARMS16;
typedef VPVOID  VPMCI_VD_PLAY_PARMS16;

typedef struct _MCI_VD_STEP_PARMS16 {     /* mvsp16 */
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS16;
typedef MCI_VD_STEP_PARMS16 UNALIGNED *PMCI_VD_STEP_PARMS16;
typedef VPVOID  VPMCI_VD_STEP_PARMS16;

typedef struct _MCI_VD_DELETE_PARMS16 {   /* mvdp16 */
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_VD_DELETE_PARMS16;
typedef MCI_VD_DELETE_PARMS16 UNALIGNED *PMCI_VD_DELETE_PARMS16;
typedef VPVOID  VPMCI_VD_DELETE_PARMS16;

typedef struct _MCI_WAVE_OPEN_PARMS16 {   /* mwop16 */
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    VPCSTR  lpstrDeviceType;
    VPCSTR  lpstrElementName;
    VPCSTR  lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS16;
typedef MCI_WAVE_OPEN_PARMS16 UNALIGNED *PMCI_WAVE_OPEN_PARMS16;
typedef VPVOID  VPMCI_WAVE_OPEN_PARMS16;

typedef struct _MCI_WAVE_SET_PARMS16 {    /* mwsp16 */
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    WORD    wInput;
    WORD    wReserved0;
    WORD    wOutput;
    WORD    wReserved1;
    WORD    wFormatTag;
    WORD    wReserved2;
    WORD    nChannels;
    WORD    wReserved3;
    DWORD   nSamplesPerSecond;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
    WORD    wReserved4;
    WORD    wBitsPerSample;
    WORD    wReserved5;
} MCI_WAVE_SET_PARMS16;
typedef MCI_WAVE_SET_PARMS16 UNALIGNED *PMCI_WAVE_SET_PARMS16;
typedef VPVOID  VPMCI_WAVE_SET_PARMS16;

typedef struct _MIDIHDR16 {               /* mhdr16 */
    VPSTR   lpData;
    DWORD   dwBufferLength;
    DWORD   dwBytesRecorded;
    DWORD   dwUser;
    DWORD   dwFlags;
    struct  _MIDIHDR16 far *lpNext;
    DWORD   reserved;
} MIDIHDR16;
typedef MIDIHDR16 UNALIGNED *PMIDIHDR16;
typedef VPVOID  VPMIDIHDR16;

typedef struct _MIDIINCAPS16 {            /* mic16 */
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
} MIDIINCAPS16;
typedef MIDIINCAPS16 UNALIGNED *PMIDIINCAPS16;
typedef VPVOID  VPMIDIINCAPS16;

typedef struct _MIDIOUTCAPS16 {           /* moc16 */
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    WORD    wTechnology;
    WORD    wVoices;
    WORD    wNotes;
    WORD    wChannelMask;
    DWORD   dwSupport;
} MIDIOUTCAPS16;
typedef MIDIOUTCAPS16 UNALIGNED *PMIDIOUTCAPS16;
typedef VPVOID VPMIDIOUTCAPS16;

typedef struct _MMCKINFO16 {              /* mcki16 */
    FOURCC  ckid;
    DWORD   cksize;
    FOURCC  fccType;
    DWORD   dwDataOffset;
    DWORD   dwFlags;
} MMCKINFO16;
typedef MMCKINFO16 UNALIGNED *PMMCKINFO16;
typedef VPVOID VPMMCKINFO16;

typedef struct _MMIOINFO16 {              /* mioi16 */
    DWORD   dwFlags;
    FOURCC  fccIOProc;
    VPMMIOPROC16  pIOProc;
    WORD    wErrorRet;
    HTASK16 htask;        // Header file MMSYSTEM.H differs from book
    LONG    cchBuffer;
    VPSTR   pchBuffer;
    VPSTR   pchNext;
    VPSTR   pchEndRead;
    VPSTR   pchEndWrite;
    LONG    lBufOffset;
    LONG    lDiskOffset;
    DWORD   adwInfo[3];   // The book says [4], MMSYSTEM.H doesn't
    DWORD   dwReserved1;
    DWORD   dwReserved2;
    HMMIO16 hmmio;
} MMIOINFO16;
typedef MMIOINFO16 UNALIGNED *PMMIOINFO16;
typedef VPVOID  VPMMIOINFO16;

typedef struct _MMPACTION16 {             /* mpa16 */
    BYTE    bMenuItem;
    BYTE    bActionCode;
    WORD    wTextOffset;
} MMPACTION16;
typedef MMPACTION16 UNALIGNED *PMMPACTION16;
typedef VPVOID  VPMMPACTION16;

typedef struct _MMPLABEL16 {              /* mpl16 */
    WORD    wFrameNum;
    WORD    wTextOffset;
} MMPLABEL16;
typedef MMPLABEL16 UNALIGNED *PMMPLABEL16;
typedef VPVOID  VPMMPLABEL16;

typedef struct _MMPMOVIEINFO16 {          /* mpmi16 */
    DWORD   dwFileVersion;
    DWORD   dwTotalFrames;
    DWORD   dwInitialFramesPerSecond;
    WORD    wPixelDepth;
    DWORD   dwMovieExtentX;
    DWORD   dwMovieExtentY;
    char    chFullMacName[128];
} MMPMOVIEINFO16;
typedef MMPMOVIEINFO16 UNALIGNED *PMMPMOVIEINFO16;
typedef VPVOID  VPMMPMOVIEINFO16;

/* XLATOFF */
typedef struct _MMTIME16 {                /* mmt16 */
    WORD    wType;
    union {
        DWORD   ms;
        DWORD   sample;
        DWORD   cb;
        struct {
            BYTE    hour;
            BYTE    min;
            BYTE    sec;
            BYTE    frame;
            BYTE    fps;
            BYTE    dummy;
        } smpte;
        struct {
            DWORD   songptrpos;
        } midi;
    } u;
} MMTIME16;
typedef MMTIME16 UNALIGNED *PMMTIME16;
/* XLATON */
typedef VPVOID  VPMMTIME16;

typedef struct _TIMECAPS16 {              /* timc16 */
    WORD    wPeriodMin;
    WORD    wPeriodMax;
} TIMECAPS16;
typedef TIMECAPS16 UNALIGNED *PTIMECAPS16;
typedef VPVOID  VPTIMECAPS16;

typedef struct _WAVEFORMAT16 {            /* wft16 */
    WORD    wFormatTag;
    WORD    nChannels;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
} WAVEFORMAT16;
typedef WAVEFORMAT16 UNALIGNED *PWAVEFORMAT16;
typedef VPVOID  VPWAVEFORMAT16;

typedef struct _PCMWAVEFORMAT16 {         /* pwf16 */
    WAVEFORMAT16  wf;
    WORD          wBitsPerSample;
} PCMWAVEFORMAT16;
typedef PCMWAVEFORMAT16 UNALIGNED *PPCMWAVEFORMAT16;
typedef VPVOID  VPPCMWAVEFORMAT16;

typedef struct _WAVEHDR16 {               /* whd16 */
    VPSTR   lpData;
    DWORD   dwBufferLength;
    DWORD   dwBytesRecorded;
    DWORD   dwUser;
    DWORD   dwFlags;
    DWORD   dwLoops;
    struct _WAVEHDR16 far *lpNext;
    DWORD   reserved;
} WAVEHDR16;
typedef WAVEHDR16 UNALIGNED *PWAVEHDR16;
typedef VPVOID  VPWAVEHDR16;

typedef struct _WAVEINCAPS16 {            /* wic16 */
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    DWORD   dwFormats;
    WORD    wChannels;
} WAVEINCAPS16;
typedef WAVEINCAPS16 UNALIGNED *PWAVEINCAPS16;
typedef VPVOID  VPWAVEINCAPS16;

typedef struct _WAVEOUTCAPS16 {           /* woc16 */
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    DWORD   dwFormats;
    WORD    wChannels;
    DWORD   dwSupport;
} WAVEOUTCAPS16;
typedef WAVEOUTCAPS16 UNALIGNED *PWAVEOUTCAPS16;
typedef VPVOID  VPWAVEOUTCAPS16;

/* XLATOFF */
#pragma pack()
/* XLATON */

/*
 * MultiMedia Window messages - MikeTri 10-Feb-1992
 */

//#define MM_JOY1MOVE         0x03A0   // Joystick
//#define MM_JOY2MOVE         0x03A1
//#define MM_JOY1ZMOVE        0x03A2
//#define MM_JOY2ZMOVE        0x03A3
//#define MM_JOY1BUTTONDOWN   0x03B5
//#define MM_JOY2BUTTONDOWN   0x03B6
//#define MM_JOY1BUTTONUP     0x03B7
//#define MM_JOY2BUTTONUP     0x03B8

//#define MM_MCINOTIFY        0x03B9  // MCI
//#define MM_MCISYSTEM_STRING 0x03CA

//#define MM_WOM_OPEN         0x03BB  // Waveform Output
//#define MM_WOM_CLOSE        0x03BC
//#define MM_WOM_DONE         0x03BD

//#define MM_WIM_OPEN         0x03BE  // Waveform Input
//#define MM_WIM_CLOSE        0x03BF
//#define MM_WIM_DATA         0x03C0

//#define MM_MIM_OPEN         0x03C1  // MIDI Input
//#define MM_MIM_CLOSE        0x03C2
//#define MM_MIM_DATA         0x03C3
//#define MM_MIM_LONGDATA     0x03C4
//#define MM_MIM_ERROR        0x03C5
//#define MM_MIM_LONGERROR    0x03C6

//#define MM_MOM_OPEN         0x03C7  // MIDI Output
//#define MM_MOM_CLOSE        0x03C8
//#define MM_MOM_DONE         0x03C9

/*
 * End of MultiMedia Window messages - MikeTri
 */

/*++

  MultiMedia API IDs - start adding all the other APIs - Mike, 04-Feb-1992

  This is the complete exported list, in MMSYSTEM order

  Well, actually it isn't anymore - various ones have been removed which
  we aren't supporting, and because of the joys of H2INC I can't leave them
  here as comments. So - if they need to be added again check in the
  function prototypes below this list for the correct formats.

  Need to recheck the numbers before compiling this lot... - this raises the
  point that if we add any more they ought to go at the end of the list,
  otherwise we end up juggling numbers, which is a drag.

--*/


#define FUN_MMCALLPROC32                  2 //
#define FUN_MMSYSTEMGETVERSION            5 //

#define FUN_OUTPUTDEBUGSTR                30 //
#define FUN_DRIVERCALLBACK                31 //
#define FUN_NOTIFY_CALLBACK_DATA          32 //

#define FUN_JOYGETNUMDEVS                 101 //
#define FUN_JOYGETDEVCAPS                 102 //
#define FUN_JOYGETPOS                     103 //
#define FUN_JOYGETTHRESHOLD               104 //
#define FUN_JOYRELEASECAPTURE             105 //
#define FUN_JOYSETCAPTURE                 106 //
#define FUN_JOYSETTHRESHOLD               107 //
#define FUN_JOYSETCALIBRATION             109 //

#define FUN_MIDIOUTGETNUMDEVS             201 //
#define FUN_MIDIOUTGETDEVCAPS             202 //
#define FUN_MIDIOUTGETERRORTEXT           203 //
#define FUN_MIDIOUTOPEN                   204 //
#define FUN_MIDIOUTCLOSE                  205 //
#define FUN_MIDIOUTPREPAREHEADER32        206 //
#define FUN_MIDIOUTUNPREPAREHEADER32      207 //
#define FUN_MIDIOUTSHORTMSG               208 //
#define FUN_MIDIOUTLONGMSG                209 //
#define FUN_MIDIOUTRESET                  210 //
#define FUN_MIDIOUTGETVOLUME              211 //
#define FUN_MIDIOUTSETVOLUME              212 //
#define FUN_MIDIOUTCACHEPATCHES           213 //
#define FUN_MIDIOUTCACHEDRUMPATCHES       214 //
#define FUN_MIDIOUTGETID                  215 //
#define FUN_MIDIOUTMESSAGE32              216 //

#define FUN_MIDIINGETNUMDEVS              301 //
#define FUN_MIDIINGETDEVCAPS              302 //
#define FUN_MIDIINGETERRORTEXT            303 //
#define FUN_MIDIINOPEN                    304 //
#define FUN_MIDIINCLOSE                   305 //
#define FUN_MIDIINPREPAREHEADER32         306 //
#define FUN_MIDIINUNPREPAREHEADER32       307 //
#define FUN_MIDIINADDBUFFER               308 //
#define FUN_MIDIINSTART                   309 //
#define FUN_MIDIINSTOP                    310 //
#define FUN_MIDIINRESET                   311 //
#define FUN_MIDIINGETID                   312 //
#define FUN_MIDIINMESSAGE32               313 //

#define FUN_AUXGETNUMDEVS                 350 //
#define FUN_AUXGETDEVCAPS                 351 //
#define FUN_AUXGETVOLUME                  352 //
#define FUN_AUXSETVOLUME                  353 //
#define FUN_AUXOUTMESSAGE32               354 //

#define FUN_WAVEOUTGETNUMDEVS             401 //
#define FUN_WAVEOUTGETDEVCAPS             402 //
#define FUN_WAVEOUTGETERRORTEXT           403 //
#define FUN_WAVEOUTOPEN                   404 //
#define FUN_WAVEOUTCLOSE                  405 //
#define FUN_WAVEOUTPREPAREHEADER32        406 //
#define FUN_WAVEOUTUNPREPAREHEADER32      407 //
#define FUN_WAVEOUTWRITE                  408 //
#define FUN_WAVEOUTPAUSE                  409 //
#define FUN_WAVEOUTRESTART                410 //
#define FUN_WAVEOUTRESET                  411 //
#define FUN_WAVEOUTGETPOSITION            412 //
#define FUN_WAVEOUTGETPITCH               413 //
#define FUN_WAVEOUTSETPITCH               414 //
#define FUN_WAVEOUTGETVOLUME              415 //
#define FUN_WAVEOUTSETVOLUME              416 //
#define FUN_WAVEOUTGETPLAYBACKRATE        417 //
#define FUN_WAVEOUTSETPLAYBACKRATE        418 //
#define FUN_WAVEOUTBREAKLOOP              419 //
#define FUN_WAVEOUTGETID                  420 //
#define FUN_WAVEOUTMESSAGE32              421 //

#define FUN_WAVEINGETNUMDEVS              501 //
#define FUN_WAVEINGETDEVCAPS              502 //
#define FUN_WAVEINGETERRORTEXT            503 //
#define FUN_WAVEINOPEN                    504 //
#define FUN_WAVEINCLOSE                   505 //
#define FUN_WAVEINPREPAREHEADER32         506 //
#define FUN_WAVEINUNPREPAREHEADER32       507 //
#define FUN_WAVEINADDBUFFER               508 //
#define FUN_WAVEINSTART                   509 //
#define FUN_WAVEINSTOP                    510 //
#define FUN_WAVEINRESET                   511 //
#define FUN_WAVEINGETPOSITION             512 //
#define FUN_WAVEINGETID                   513 //
#define FUN_WAVEINMESSAGE32               514 //

#define FUN_TIMEGETSYSTEMTIME             601 //
#define FUN_TIMEGETTIME                   607 //
#define FUN_TIMESETEVENT                  602 //
#define FUN_TIMEKILLEVENT                 603 //
#define FUN_TIMEGETDEVCAPS                604 //
#define FUN_TIMEBEGINPERIOD               605 //
#define FUN_TIMEENDPERIOD                 606 //

#define FUN_MCISENDCOMMAND                701 //
#define FUN_MCISENDSTRING                 702 //
#define FUN_MCIGETDEVICEID                703 //
#define FUN_MCIGETERRORSTRING             706 //
#define FUN_MCIEXECUTE                    712 //
#define FUN_MCISETYIELDPROC               714 //
#define FUN_MCIGETDEVICEIDFROMELEMENTID   715 //
#define FUN_MCIGETYIELDPROC               716 //
#define FUN_MCIGETCREATORTASK             717 //

#define FUN_MMIOOPEN                      1210 //
#define FUN_MMIOCLOSE                     1211 //
#define FUN_MMIOREAD                      1212 //
#define FUN_MMIOWRITE                     1213 //
#define FUN_MMIOSEEK                      1214 //
#define FUN_MMIOGETINFO                   1215 //
#define FUN_MMIOSETINFO                   1216 //
#define FUN_MMIOSETBUFFER                 1217 //
#define FUN_MMIOFLUSH                     1218 //
#define FUN_MMIOADVANCE                   1219 //
#define FUN_MMIOSTRINGTOFOURCC            1220 //
#define FUN_MMIOINSTALLIOPROC             1221 //
#define FUN_MMIOSENDMESSAGE               1222 //

#define FUN_MMIODESCEND                   1223 //
#define FUN_MMIOASCEND                    1224 //
#define FUN_MMIOCREATECHUNK               1225 //
#define FUN_MMIORENAME                    1226 //

/* XLATOFF */
#pragma pack(2)
/* XLATON */

/*++

  Function prototypes - the seemingly unimportant number in the comment on
  each function MUST match the ones in the list above - otherwise you will
  turn into a frog, and 16 bit MultiMedia will wave its feet in the air...

  !! BE WARNED !!

--*/

typedef struct _MMCALLPROC3216 {    /* mm2 */
    DWORD fSetCurrentDirectory;     /* Set the current directory ? */
    DWORD lpProcAddress;            /* function to call */
    DWORD p1;                       /* dwParam2     */
    DWORD p2;                       /* dwParam1     */
    DWORD p3;                       /* dwInstance   */
    DWORD p4;                       /* uMsg         */
    DWORD p5;                       /* uDevId       */
} MMCALLPROC3216;
typedef MMCALLPROC3216 UNALIGNED *PMMCALLPROC3216;


#ifdef NULLSTRUCT
typedef struct _MMSYSTEMGETVERSION16 {         /* mm5 */
} MMSYSTEMGETVERSION16;
typedef MMSYSTEMGETVERSION16 UNALIGNED *PMMSYSTEMGETVERSION;
#endif

typedef struct _OUTPUTDEBUGSTR16 {             /* mm30 */
    VPSTR      f1;
} OUTPUTDEBUGSTR16;
typedef OUTPUTDEBUGSTR16 UNALIGNED *POUTPUTDEBUGSTR16;

typedef struct _DRIVERCALLBACK16 {             /* mm31 */
    DWORD      f7;
    DWORD      f6;
    DWORD      f5;
    DWORD      f4;
    HDRVR16    f3;
    DWORD      f2;
    DWORD      f1;
} DRIVERCALLBACK16;
typedef DRIVERCALLBACK16 UNALIGNED *PDRIVERCALLBACK16;


typedef struct _NOTIFY_CALLBACK_DATA16 {       /* mm32 */
    VPCALLBACK_DATA f1;
} NOTIFY_CALLBACK_DATA16;
typedef NOTIFY_CALLBACK_DATA16 UNALIGNED *PNOTIFY_CALLBACK_DATA16;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NULLSTRUCT
typedef struct _STACKLEAVE16 {                  mm33
} STACKLEAVE16;
typedef STACKLEAVE16 UNALIGNED *PSTACKLEAVE16;
#endif

------------------------------------------------------------------------------*/

#ifdef NULLSTRUCT
typedef struct _JOYGETNUMDEVS16 {              /* mm101 */
} JOYGETNUMDEVS16;
typedef JOYGETNUMDEVS16 UNALIGNED *PJOYGETNUMDEVS16;
#endif

typedef struct _JOYGETDEVCAPS16 {              /* mm102 */
    WORD         f3;
    VPJOYCAPS16  f2;
    WORD         f1;
} JOYGETDEVCAPS16;
typedef JOYGETDEVCAPS16 UNALIGNED *PJOYGETDEVCAPS16;

typedef struct _JOYGETPOS16 {                  /* mm103 */
    VPJOYINFO16  f2;
    WORD         f1;
} JOYGETPOS16;
typedef JOYGETPOS16 UNALIGNED *PJOYGETPOS16;

typedef struct _JOYGETTHRESHOLD16 {            /* mm104 */
    VPWORD     f2;
    WORD       f1;
} JOYGETTHRESHOLD16;
typedef JOYGETTHRESHOLD16 UNALIGNED *PJOYGETTHRESHOLD16;

typedef struct _JOYRELEASECAPTURE16 {          /* mm105 */
    WORD       f1;
} JOYRELEASECAPTURE16;
typedef JOYRELEASECAPTURE16 UNALIGNED *PJOYRELEASECAPTURE16;

typedef struct _JOYSETCAPTURE16 {              /* mm106 */
    BOOL16     f4;
    WORD       f3;
    WORD       f2;
    HWND16     f1;
} JOYSETCAPTURE16;
typedef JOYSETCAPTURE16 UNALIGNED *PJOYSETCAPTURE16;

typedef struct _JOYSETTHRESHOLD16 {            /* mm107 */
    WORD       f2;
    WORD       f1;
} JOYSETTHRESHOLD16;
typedef JOYSETTHRESHOLD16 UNALIGNED *PJOYSETTHRESHOLD16;

typedef struct _JOYSETCALIBRATION16 {          /* mm109 */
    VPWORD     f7;
    VPWORD     f6;
    VPWORD     f5;
    VPWORD     f4;
    VPWORD     f3;
    VPWORD     f2;
    WORD       f1;
} JOYSETCALIBRATION16;
typedef JOYSETCALIBRATION16 UNALIGNED *PJOYSETCALIBRATION16;

#ifdef NULLSTRUCT
typedef struct _MIDIOUTGETNUMDEVS16 {          /* mm201 */
} MIDIOUTGETNUMDEVS16;
typedef MIDIOUTGETNUMDEVS16 UNALIGNED *PMIDIOUTGETNUMDEVS16;
#endif

typedef struct _MIDIOUTGETDEVCAPS16 {          /* mm202 */
    WORD            f3;
    VPMIDIOUTCAPS16 f2;
    WORD            f1;
} MIDIOUTGETDEVCAPS16;
typedef MIDIOUTGETDEVCAPS16 UNALIGNED *PMIDIOUTGETDEVCAPS16;

typedef struct _MIDIOUTGETERRORTEXT16 {        /* mm203 */
    WORD       f3;
    VPSTR      f2;
    WORD       f1;
} MIDIOUTGETERRORTEXT16;
typedef MIDIOUTGETERRORTEXT16 UNALIGNED *PMIDIOUTGETERRORTEXT16;

typedef struct _MIDIOUTOPEN16 {                /* mm204 */
    DWORD         f5;
    DWORD         f4;
    DWORD         f3;
    WORD          f2;
    VPHMIDIOUT16  f1;
} MIDIOUTOPEN16;
typedef MIDIOUTOPEN16 UNALIGNED *PMIDIOUTOPEN16;

typedef struct _MIDIOUTCLOSE16 {               /* mm205 */
    HMIDIOUT16    f1;
} MIDIOUTCLOSE16;
typedef MIDIOUTCLOSE16 UNALIGNED *PMIDIOUTCLOSE16;

typedef struct _MIDIOUTPREPAREHEADER3216 {       /* mm206 */
    WORD         f3;
    VPMIDIHDR16  f2;
    HMIDIOUT16   f1;
} MIDIOUTPREPAREHEADER3216;
typedef MIDIOUTPREPAREHEADER3216 UNALIGNED *PMIDIOUTPREPAREHEADER3216;

typedef struct _MIDIOUTUNPREPAREHEADER3216 {     /* mm207 */
    WORD         f3;
    VPMIDIHDR16  f2;
    HMIDIOUT16   f1;
} MIDIOUTUNPREPAREHEADER3216;
typedef MIDIOUTUNPREPAREHEADER3216 UNALIGNED *PMIDIOUTUNPREPAREHEADER3216;

typedef struct _MIDIOUTSHORTMSG16 {            /* mm208 */
    DWORD      f2;
    HMIDIOUT16 f1;
} MIDIOUTSHORTMSG16;
typedef MIDIOUTSHORTMSG16 UNALIGNED *PMIDIOUTSHORTMSG16;

typedef struct _MIDIOUTLONGMSG16 {             /* mm209 */
    WORD        f3;
    VPMIDIHDR16 f2;
    HMIDIOUT16  f1;
} MIDIOUTLONGMSG16;
typedef MIDIOUTLONGMSG16 UNALIGNED *PMIDIOUTLONGMSG16;

typedef struct _MIDIOUTRESET16 {               /* mm210 */
    HMIDIOUT16  f1;
} MIDIOUTRESET16;
typedef MIDIOUTRESET16 UNALIGNED *PMIDIOUTRESET16;

typedef struct _MIDIOUTGETVOLUME16 {           /* mm211 */
    VPDWORD    f2;
    WORD       f1;
} MIDIOUTGETVOLUME16;
typedef MIDIOUTGETVOLUME16 UNALIGNED *PMIDIOUTGETVOLUME16;

typedef struct _MIDIOUTSETVOLUME16 {           /* mm212 */
    DWORD      f2;
    WORD       f1;
} MIDIOUTSETVOLUME16;
typedef MIDIOUTSETVOLUME16 UNALIGNED *PMIDIOUTSETVOLUME16;

typedef struct _MIDIOUTCACHEPATCHES16 {        /* mm213 */
    WORD            f4;
    VPPATCHARRAY16  f3;
    WORD            f2;
    HMIDIOUT16      f1;
} MIDIOUTCACHEPATCHES16;
typedef MIDIOUTCACHEPATCHES16 UNALIGNED *PMIDIOUTCACHEPATCHES16;

typedef struct _MIDIOUTCACHEDRUMPATCHES16 {    /* mm214 */
    WORD            f4;
    VPKEYARRAY16    f3;
    WORD            f2;
    HMIDIOUT16      f1;
} MIDIOUTCACHEDRUMPATCHES16;
typedef MIDIOUTCACHEDRUMPATCHES16 UNALIGNED *PMIDIOUTCACHEDRUMPATCHES16;

typedef struct _MIDIOUTGETID16 {               /* mm215 */
    VPWORD          f2;
    HMIDIOUT16      f1;
} MIDIOUTGETID16;
typedef MIDIOUTGETID16 UNALIGNED *PMIDIOUTGETID16;

typedef struct _MIDIOUTMESSAGE3216 {             /* mm216 */
    DWORD      f4;
    DWORD      f3;
    WORD       f2;
    HMIDIOUT16 f1;
} MIDIOUTMESSAGE3216;
typedef MIDIOUTMESSAGE3216 UNALIGNED *PMIDIOUTMESSAGE3216;

#ifdef NULLSTRUCT
typedef struct _MIDIINGETNUMDEVS16 {           /* mm301 */
} MIDIINGETNUMDEVS16;
typedef MIDIINGETNUMDEVS16 UNALIGNED *PMIDIINGETNUMDEVS16;
#endif

typedef struct _MIDIINGETDEVCAPS16 {           /* mm302 */
    WORD            f3;
    VPMIDIINCAPS16  f2;
    WORD            f1;
} MIDIINGETDEVCAPS16;
typedef MIDIINGETDEVCAPS16 UNALIGNED *PMIDIINGETDEVCAPS16;

typedef struct _MIDIINGETERRORTEXT16 {         /* mm303 */
    WORD       f3;
    VPSTR      f2;
    WORD       f1;
} MIDIINGETERRORTEXT16;
typedef MIDIINGETERRORTEXT16 UNALIGNED *PMIDIINGETERRORTEXT16;

typedef struct _MIDIINOPEN16 {                 /* mm304 */
    DWORD         f5;
    DWORD         f4;
    DWORD         f3;
    WORD          f2;
    VPHMIDIIN16   f1;
} MIDIINOPEN16;
typedef MIDIINOPEN16 UNALIGNED *PMIDIINOPEN16;

typedef struct _MIDIINCLOSE16 {                /* mm305 */
    HMIDIIN16  f1;
} MIDIINCLOSE16;
typedef MIDIINCLOSE16 UNALIGNED *PMIDIINCLOSE16;

typedef struct _MIDIINPREPAREHEADER3216 {        /* mm306 */
    WORD         f3;
    VPMIDIHDR16  f2;
    HMIDIIN16    f1;
} MIDIINPREPAREHEADER3216;
typedef MIDIINPREPAREHEADER3216 UNALIGNED *PMIDIINPREPAREHEADER3216;

typedef struct _MIDIINUNPREPAREHEADER3216 {      /* mm307 */
    WORD         f3;
    VPMIDIHDR16  f2;
    HMIDIIN16    f1;
} MIDIINUNPREPAREHEADER3216;
typedef MIDIINUNPREPAREHEADER3216 UNALIGNED *PMIDIINUNPREPAREHEADER3216;

typedef struct _MIDIINADDBUFFER16 {            /* mm308 */
    WORD         f3;
    VPMIDIHDR16  f2;
    HMIDIIN16    f1;
} MIDIINADDBUFFER16;
typedef MIDIINADDBUFFER16 UNALIGNED *PMIDIINADDBUFFER16;

typedef struct _MIDIINSTART16 {                /* mm309 */
    HMIDIIN16  f1;
} MIDIINSTART16;
typedef MIDIINSTART16 UNALIGNED *PMIDIINSTART16;

typedef struct _MIDIINSTOP16 {                 /* mm310 */
    HMIDIIN16  f1;
} MIDIINSTOP16;
typedef MIDIINSTOP16 UNALIGNED *PMIDIINSTOP16;

typedef struct _MIDIINRESET16 {                /* mm311 */
    HMIDIIN16  f1;
} MIDIINRESET16;
typedef MIDIINRESET16 UNALIGNED *PMIDIINRESET16;

typedef struct _MIDIINGETID16 {                /* mm312 */
    VPWORD     f2;
    HMIDIIN16  f1;
} MIDIINGETID16;
typedef MIDIINGETID16 UNALIGNED *PMIDIINGETID16;

typedef struct _MIDIINMESSAGE3216 {              /* mm313 */
    DWORD      f4;
    DWORD      f3;
    WORD       f2;
    HMIDIIN16  f1;
} MIDIINMESSAGE3216;
typedef MIDIINMESSAGE3216 UNALIGNED *PMIDIINMESSAGE3216;

#ifdef NULLSTRUCT
typedef struct _AUXGETNUMDEVS16 {              /* mm350 */
} AUXGETNUMDEVS16;
typedef AUXGETNUMDEVS16 UNALIGNED *PAUGGETNUMDEVS16;
#endif

typedef struct _AUXGETDEVCAPS16 {              /* mm351 */
    WORD         f3;
    VPAUXCAPS16  f2;
    WORD         f1;
} AUXGETDEVCAPS16;
typedef AUXGETDEVCAPS16 UNALIGNED *PAUXGETDEVCAPS16;

typedef struct _AUXGETVOLUME16 {               /* mm352 */
    VPDWORD    f2;
    WORD       f1;
} AUXGETVOLUME16;
typedef AUXGETVOLUME16 UNALIGNED *PAUXGETVOLUME16;

typedef struct _AUXSETVOLUME16 {               /* mm353 */
    DWORD      f2;
    WORD       f1;
} AUXSETVOLUME16;
typedef AUXSETVOLUME16 UNALIGNED *PAUXSETVOLUME16;

typedef struct _AUXOUTMESSAGE3216 {              /* mm354 */
    DWORD      f4;
    DWORD      f3;
    WORD       f2;
    WORD       f1;
} AUXOUTMESSAGE3216;
typedef AUXOUTMESSAGE3216 UNALIGNED *PAUXOUTMESSAGE3216;

#ifdef NULLSTRUCT
typedef struct _WAVEOUTGETNUMDEVS16 {          /* mm401 */
} WAVEOUTGETNUMDEVS16;
typedef WAVEOUTGETNUMDEVS16 UNALIGNED *PWAVEOUTGETNUMDEVS16;
#endif

typedef struct _WAVEOUTGETDEVCAPS16 {          /* mm402 */
    WORD             f3;
    VPWAVEOUTCAPS16  f2;
    WORD             f1;
} WAVEOUTGETDEVCAPS16;
typedef WAVEOUTGETDEVCAPS16 UNALIGNED *PWAVEOUTGETDEVCAPS16;

typedef struct _WAVEOUTGETERRORTEXT16 {        /* mm403 */
    WORD       f3;
    VPSTR      f2;
    WORD       f1;
} WAVEOUTGETERRORTEXT16;
typedef WAVEOUTGETERRORTEXT16 UNALIGNED *PWAVEOUTGETERRORTEXT16;

typedef struct _WAVEOUTOPEN16 {                /* mm404 */
    DWORD           f6;
    DWORD           f5;
    DWORD           f4;
    VPWAVEFORMAT16  f3;
    WORD            f2;
    VPHWAVEOUT16   f1;
} WAVEOUTOPEN16;
typedef WAVEOUTOPEN16 UNALIGNED *PWAVEOUTOPEN16;

typedef struct _WAVEOUTCLOSE16 {               /* mm405 */
    HWAVEOUT16 f1;
} WAVEOUTCLOSE16;
typedef WAVEOUTCLOSE16 UNALIGNED *PWAVEOUTCLOSE16;

typedef struct _WAVEOUTPREPAREHEADER3216 {       /* mm406 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEOUT16   f1;
} WAVEOUTPREPAREHEADER3216;
typedef WAVEOUTPREPAREHEADER3216 UNALIGNED *PWAVEOUTPREPAREHEADER3216;

typedef struct _WAVEOUTUNPREPAREHEADER3216 {     /* mm407 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEOUT16   f1;
} WAVEOUTUNPREPAREHEADER3216;
typedef WAVEOUTUNPREPAREHEADER3216 UNALIGNED *PWAVEOUTUNPREPAREHEADER3216;

typedef struct _WAVEOUTWRITE16 {               /* mm408 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEOUT16   f1;
} WAVEOUTWRITE16;
typedef WAVEOUTWRITE16 UNALIGNED *PWAVEOUTWRITE16;

typedef struct _WAVEOUTPAUSE16 {               /* mm409 */
    HWAVEOUT16   f1;
} WAVEOUTPAUSE16;
typedef WAVEOUTPAUSE16 UNALIGNED *PWAVEOUTPAUSE16;

typedef struct _WAVEOUTRESTART16 {             /* mm410 */
    HWAVEOUT16   f1;
} WAVEOUTRESTART16;
typedef WAVEOUTRESTART16 UNALIGNED *PWAVEOUTRESTART16;

typedef struct _WAVEOUTRESET16 {               /* mm411 */
    HWAVEOUT16   f1;
} WAVEOUTRESET16;
typedef WAVEOUTRESET16 UNALIGNED *PWAVEOUTRESET16;

typedef struct _WAVEOUTGETPOSITION16 {         /* mm412 */
    WORD         f3;
    VPMMTIME16   f2;
    HWAVEOUT16   f1;
} WAVEOUTGETPOSITION16;
typedef WAVEOUTGETPOSITION16 UNALIGNED *PWAVEOUTGETPOSITION16;

typedef struct _WAVEOUTGETPITCH16 {            /* mm413 */
    VPDWORD      f2;
    HWAVEOUT16   f1;
} WAVEOUTGETPITCH16;
typedef WAVEOUTGETPITCH16 UNALIGNED *PWAVEOUTGETPITCH16;

typedef struct _WAVEOUTSETPITCH16 {            /* mm414 */
    DWORD        f2;
    HWAVEOUT16   f1;
} WAVEOUTSETPITCH16;
typedef WAVEOUTSETPITCH16 UNALIGNED *PWAVEOUTSETPITCH16;

typedef struct _WAVEOUTGETVOLUME16 {           /* mm415 */
    VPDWORD    f2;
    WORD       f1;
} WAVEOUTGETVOLUME16;
typedef WAVEOUTGETVOLUME16 UNALIGNED *PWAVEOUTGETVOLUME16;

typedef struct _WAVEOUTSETVOLUME16 {           /* mm416 */
    DWORD      f2;
    WORD       f1;
} WAVEOUTSETVOLUME16;
typedef WAVEOUTSETVOLUME16 UNALIGNED *PWAVEOUTSETVOLUME16;

typedef struct _WAVEOUTGETPLAYBACKRATE16 {     /* mm417 */
    VPDWORD      f2;
    HWAVEOUT16   f1;
} WAVEOUTGETPLAYBACKRATE16;
typedef WAVEOUTGETPLAYBACKRATE16 UNALIGNED *PWAVEOUTGETPLAYBACKRATE16;

typedef struct _WAVEOUTSETPLAYBACKRATE16 {     /* mm418 */
    DWORD        f2;
    HWAVEOUT16   f1;
} WAVEOUTSETPLAYBACKRATE16;
typedef WAVEOUTSETPLAYBACKRATE16 UNALIGNED *PWAVEOUTSETPLAYBACKRATE16;

typedef struct _WAVEOUTBREAKLOOP16 {           /* mm419 */
    HWAVEOUT16   f1;
} WAVEOUTBREAKLOOP16;
typedef WAVEOUTBREAKLOOP16 UNALIGNED *PWAVEOUTBREAKLOOP16;

typedef struct _WAVEOUTGETID16 {               /* mm420 */
    VPWORD       f2;
    HWAVEOUT16   f1;
} WAVEOUTGETID16;
typedef WAVEOUTGETID16 UNALIGNED *PWAVEOUTGETID16;

typedef struct _WAVEOUTMESSAGE3216 {             /* mm421 */
    DWORD        f4;
    DWORD        f3;
    WORD         f2;
    HWAVEOUT16   f1;
} WAVEOUTMESSAGE3216;
typedef WAVEOUTMESSAGE3216 UNALIGNED *PWAVEOUTMESSAGE3216;

#ifdef NULLSTRUCT
typedef struct _WAVEINGETNUMDEVS16 {           /* mm501 */
} WAVEINGETNUMDEVS16;
typedef WAVEINGETNUMDEVS16 UNALIGNED *PWAVEINGETNUMDEVS16;
#endif

typedef struct _WAVEINGETDEVCAPS16 {           /* mm502 */
    WORD            f3;
    VPWAVEINCAPS16  f2;
    WORD            f1;
} WAVEINGETDEVCAPS16;
typedef WAVEINGETDEVCAPS16 UNALIGNED *PWAVEINGETDEVCAPS16;

typedef struct _WAVEINGETERRORTEXT16 {         /* mm503 */
    WORD       f3;
    VPSTR      f2;
    WORD       f1;
} WAVEINGETERRORTEXT16;
typedef WAVEINGETERRORTEXT16 UNALIGNED *PWAVEINGETERRORTEXT16;

typedef struct _WAVEINOPEN16 {                 /* mm504 */
    DWORD           f6;
    DWORD           f5;
    DWORD           f4;
    VPWAVEFORMAT16  f3;
    WORD            f2;
    VPHWAVEIN16    f1;
} WAVEINOPEN16;
typedef WAVEINOPEN16 UNALIGNED *PWAVEINOPEN16;

typedef struct _WAVEINCLOSE16 {                /* mm505 */
    HWAVEIN16  f1;
} WAVEINCLOSE16;
typedef WAVEINCLOSE16 UNALIGNED *PWAVEINCLOSE16;

typedef struct _WAVEINPREPAREHEADER3216 {        /* mm506 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEIN16    f1;
} WAVEINPREPAREHEADER3216;
typedef WAVEINPREPAREHEADER3216 UNALIGNED *PWAVEINPREPAREHEADER3216;

typedef struct _WAVEINUNPREPAREHEADER3216 {      /* mm507 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEIN16    f1;
} WAVEINUNPREPAREHEADER3216;
typedef WAVEINUNPREPAREHEADER3216 UNALIGNED *PWAVEINUNPREPAREHEADER3216;

typedef struct _WAVEINADDBUFFER16 {            /* mm508 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEIN16    f1;
} WAVEINADDBUFFER16;
typedef WAVEINADDBUFFER16 UNALIGNED *PWAVEINADDBUFFER16;

typedef struct _WAVEINSTART16 {                /* mm509 */
    HWAVEIN16    f1;
} WAVEINSTART16;
typedef WAVEINSTART16 UNALIGNED *PWAVEINSTART16;

typedef struct _WAVEINSTOP16 {                 /* mm510 */
    HWAVEIN16    f1;
} WAVEINSTOP16;
typedef WAVEINSTOP16 UNALIGNED *PWAVEINSTOP16;

typedef struct _WAVEINRESET16 {                /* mm511 */
    HWAVEIN16    f1;
} WAVEINRESET16;
typedef WAVEINRESET16 UNALIGNED *PWAVEINRESET16;

typedef struct _WAVEINGETPOSITION16 {          /* mm512 */
    WORD       f3;
    VPMMTIME16 f2;
    HWAVEIN16  f1;
} WAVEINGETPOSITION16;
typedef WAVEINGETPOSITION16 UNALIGNED *PWAVEINGETPOSITION16;

typedef struct _WAVEINGETID16 {                /* mm513 */
    VPWORD     f2;
    HWAVEIN16  f1;
} WAVEINGETID16;
typedef WAVEINGETID16 UNALIGNED *PWAVEINGETID16;

typedef struct _WAVEINMESSAGE3216 {              /* mm514 */
    DWORD      f4;
    DWORD      f3;
    WORD       f2;
    HWAVEIN16  f1;
} WAVEINMESSAGE3216;
typedef WAVEINMESSAGE3216 UNALIGNED *PWAVEINMESSAGE3216;

typedef struct _TIMEGETSYSTEMTIME16 {          /* mm601 */
    WORD       f2;
    VPMMTIME16 f1;
} TIMEGETSYSTEMTIME16;
typedef TIMEGETSYSTEMTIME16 UNALIGNED *PTIMEGETSYSTEMTIME16;

#ifdef NULLSTRUCT
typedef struct _TIMEGETTIME16 {                /* mm607 */
} TIMEGETTIME16;
typedef TIMEGETTIME16 UNALIGNED *PTIMEGETTIME16;
#endif

typedef struct _TIMESETEVENT16 {               /* mm602 */
    WORD              f5;
    DWORD             f4;
    VPTIMECALLBACK16  f3;
    WORD              f2;
    WORD              f1;
} TIMESETEVENT16;
typedef TIMESETEVENT16 UNALIGNED *PTIMESETEVENT16;

typedef struct _TIMEKILLEVENT16 {              /* mm603 */
    WORD       f1;
} TIMEKILLEVENT16;
typedef TIMEKILLEVENT16 UNALIGNED *PTIMEKILLEVENT16;

typedef struct _TIMEGETDEVCAPS16 {             /* mm604 */
    WORD          f2;
    VPTIMECAPS16  f1;
} TIMEGETDEVCAPS16;
typedef TIMEGETDEVCAPS16 UNALIGNED *PTIMEGETDEVCAPS16;

typedef struct _TIMEBEGINPERIOD16 {            /* mm605 */
    WORD       f1;
} TIMEBEGINPERIOD16;
typedef TIMEBEGINPERIOD16 UNALIGNED *PTIMEBEGINPERIOD16;

typedef struct _TIMEENDPERIOD16 {              /* mm606 */
    WORD       f1;
} TIMEENDPERIOD16;
typedef TIMEENDPERIOD16 UNALIGNED *PTIMEENDPERIOD16;

typedef struct _MCISENDCOMMAND16 {             /* mm701 */
    DWORD      f4;
    DWORD      f3;
    WORD       f2;
    WORD       f1;
} MCISENDCOMMAND16;
typedef MCISENDCOMMAND16 UNALIGNED *PMCISENDCOMMAND16;

typedef struct _MCISENDSTRING16 {              /* mm702 */
    HWND16     f4;
    WORD       f3;
    VPSTR      f2;
    VPCSTR     f1;
} MCISENDSTRING16;
typedef MCISENDSTRING16 UNALIGNED *PMCISENDSTRING16;

typedef struct _MCIGETDEVICEID16 {             /* mm703 */
    VPCSTR     f1;
} MCIGETDEVICEID16;
typedef MCIGETDEVICEID16 UNALIGNED *PMCIGETDEVICEID16;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef struct _MCIPARSECOMMAND16 {            mm704
    BOOL16     f6;
    VPWORD     f5;
    VPSTR      f4;
    VPCSTR     f3;
    VPSTR      f2;
    WORD       f1;
} MCIPARSECOMMAND16;
typedef MCIPARSECOMMAND16 UNALIGNED *PMCIPARSECOMMAND16;

typedef struct _MCILOADCOMMANDRESOURCE16 {     mm705
    WORD       f3;
    VPCSTR     f2;
    HAND16     f1;
} MCILOADCOMMANDRESOURCE16;
typedef MCILOADCOMMANDRESOURCE16 UNALIGNED *PMCILOADCOMMANDRESOURCE16;

------------------------------------------------------------------------------*/

typedef struct _MCIGETERRORSTRING16 {          /* mm706 */
    WORD       f3;
    VPSTR      f2;
    DWORD      f1;
} MCIGETERRORSTRING16;
typedef MCIGETERRORSTRING16 UNALIGNED *PMCIGETERRORSTRING16;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef struct _MCISETDRIVERDATA16 {           mm707
    DWORD      f2;
    WORD       f1;
} MCISETDRIVERDATA16;
typedef MCISETDRIVERDATA16 UNALIGNED *PMCISETDRIVERDATA16;

typedef struct _MCIGETDRIVERDATA16 {           mm708
    WORD       f1;
} MCIGETDRIVERDATA16;
typedef MCIGETDRIVERDATA16 UNALIGNED *PMCIGETDRIVERDATA16;

typedef struct _MCIDRIVERYIELD16 {             mm710
    WORD       f1;
} MCIDRIVERYIELD16;
typedef MCIDRIVERYIELD16 UNALIGNED *PMCIDRIVERYIELD16;

typedef struct _MCIDRIVERNOTIFY16 {            mm711
    WORD       f3;
    WORD       f2;
    HWND16     f1;
} MCIDRIVERNOTIFY16;
typedef MCIDRIVERNOTIFY16 UNALIGNED *PMCIDRIVERNOTIFY16;

------------------------------------------------------------------------------*/

typedef struct _MCIEXECUTE16 {                 /* mm712 */
    VPCSTR     f1;
} MCIEXECUTE16;
typedef MCIEXECUTE16 UNALIGNED *PMCIEXECUTE16;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef struct _MCIFREECOMMANDRESOURCE16 {     mm713
    WORD       f1;
} MCIFREECOMMANDRESOURCE16;
typedef MCIFREECOMMANDRESOURCE16 UNALIGNED *PMCIFREECOMMANDRESOURCE16;

------------------------------------------------------------------------------*/

typedef struct _MCISETYIELDPROC16 {          /* mm714 */
    DWORD      f3;
    DWORD      f2; //YIELDPROC
    WORD       f1;
} MCISETYIELDPROC16;
typedef MCISETYIELDPROC16 UNALIGNED *PMCISETYIELDPROC16;


typedef struct _MCIGETDEVICEIDFROMELEMENTID16 {     /* mm715 */
    VPCSTR     f2;
    DWORD      f1;
} MCIGETDEVICEIDFROMELEMENTID16;
typedef MCIGETDEVICEIDFROMELEMENTID16 UNALIGNED *PMCIGETDEVICEIDFROMELEMENTID16;

typedef struct _MCIGETYIELDPROC16 {            /* mm716 */
    VPDWORD    f2;
    WORD       f1;
} MCIGETYIELDPROC16;
typedef MCIGETYIELDPROC16 UNALIGNED *PMCIGETYIELDPROC16;


typedef struct _MCIGETCREATORTASK16 {          /* mm717 */
    WORD       f1;
} MCIGETCREATORTASK16;
typedef MCIGETCREATORTASK16 UNALIGNED *PMCIGETCREATORTASK16;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  The following calls have all been zapped for the time being.

typedef struct _MMTASKCREATE16 {               mm900
    DWORD             f3;
    HAND16            f2;
    VPTASKCALLBACK16  f1;
} MMTASKCREATE16;
typedef MMTASKCREATE16 UNALIGNED *PMMTASKCREATE16;

typedef struct _MMTASKBLOCK16 {                mm902
    HAND16     f1;
} MMTASKBLOCK16;
typedef MMTASKBLOCK16 UNALIGNED *PMMTASKBLOCK16;

typedef struct _MMTASKSIGNAL16 {               mm903
    HAND16     f1;
} MMTASKSIGNAL16;
typedef MMTASKSIGNAL16 UNALIGNED *PMMTASKSIGNAL16;

#ifdef NULLSTRUCT
typedef struct _MMGETCURRENTTASK16 {           mm904
} MMGETCURRENTTASK16;
typedef MMGETCURRENTTASK16 UNALIGNED *PMMGETCURRENTTASK16;
#endif

#ifdef NULLSTRUCT
typedef struct _MMTASKYIELD16 {                mm905
} MMTASKYIELD16;
typedef MMTASKYIELD16 UNALIGNED *PMMTASKYIELD16;
#endif

typedef struct _DRVCLOSE16 {                   mm1100
    DWORD         f3;
    DWORD         f2;
    HDRVR16       f1;
} DRVCLOSE16;
typedef DRVCLOSE16 UNALIGNED *PDRVCLOSE16;

typedef struct _DRVOPEN16 {                    mm1101
    DWORD         f3;
    VPSTR         f2;
    VPSTR         f1;
} DRVOPEN16;
typedef DRVOPEN16 UNALIGNED *PDRVOPEN16;

typedef struct _DRVSENDMESSAGE16 {             mm1102
    DWORD         f4;
    DWORD         f3;
    WORD          f2;
    HDRVR16       f1;
} DRVSENDMESSAGE16;
typedef DRVSENDMESSAGE16 UNALIGNED *PDRVSENDMESSAGE16;

typedef struct _DRVGETMODULEHANDLE16 {         mm1103
    HDRVR16       f1;
} DRVGETMODULEHANDLE16;
typedef DRVGETMODULEHANDLE16 UNALIGNED *PDRVGETMODULEHANDLE;

#ifdef NULLSTRUCT
typedef struct _DRVDEFDRIVERPROC16{            mm1104
} DRVDEFDRIVERPROC16;
typedef DRVDEFDRIVERPROC16 UNALIGNED *PDRVDEFDRIVERPROC;
#endif

------------------------------------------------------------------------------*/

typedef struct _MMIOOPEN16 {                   /* mm1210 */
    DWORD         f3;
    VPMMIOINFO16  f2;
    VPSTR         f1;
} MMIOOPEN16;
typedef MMIOOPEN16 UNALIGNED *PMMIOOPEN16;

typedef struct _MMIOCLOSE16 {                  /* mm1211 */
    WORD       f2;
    HMMIO16    f1;
} MMIOCLOSE16;
typedef MMIOCLOSE16 UNALIGNED *PMMIOCLOSE16;

typedef struct _MMIOREAD16 {                   /* mm1212 */
    LONG       f3;
    HPSTR16    f2;
    HMMIO16    f1;
} MMIOREAD16;
typedef MMIOREAD16 UNALIGNED *PMMIOREAD16;

typedef struct _MMIOWRITE16 {                  /* mm1213 */
    LONG       f3;
    HPSTR16    f2;
    HMMIO16    f1;
} MMIOWRITE16;
typedef MMIOWRITE16 UNALIGNED *PMMIOWRITE16;

typedef struct _MMIOSEEK16 {                   /* mm1214 */
    INT16      f3;
    LONG       f2;
    HMMIO16    f1;
} MMIOSEEK16;
typedef MMIOSEEK16 UNALIGNED *PMMIOSEEK16;

typedef struct _MMIOGETINFO16 {                /* mm1215 */
    WORD          f3;
    VPMMIOINFO16  f2;
    HMMIO16       f1;
} MMIOGETINFO16;
typedef MMIOGETINFO16 UNALIGNED *PMMIOGETINFO16;

typedef struct _MMIOSETINFO16 {                /* mm1216 */
    WORD          f3;
    VPMMIOINFO16  f2;
    HMMIO16       f1;
} MMIOSETINFO16;
typedef MMIOSETINFO16 UNALIGNED *PMMIOSETINFO16;

typedef struct _MMIOSETBUFFER16 {              /* mm1217 */
    WORD       f4;
    LONG       f3;
    VPSTR      f2;
    HMMIO16    f1;
} MMIOSETBUFFER16;
typedef MMIOSETBUFFER16 UNALIGNED *PMMIOSETBUFFER16;

typedef struct _MMIOFLUSH16 {                  /* mm1218 */
    WORD       f2;
    HMMIO16    f1;
} MMIOFLUSH16;
typedef MMIOFLUSH16 UNALIGNED *PMMIOFLUSH16;

typedef struct _MMIOADVANCE16 {                /* mm1219 */
    WORD          f3;
    VPMMIOINFO16  f2;
    HMMIO16       f1;
} MMIOADVANCE16;
typedef MMIOADVANCE16 UNALIGNED *PMMIOADVANCE16;

typedef struct _MMIOSTRINGTOFOURCC16 {         /* mm1220 */
    WORD       f2;
    VPCSTR     f1;
} MMIOSTRINGTOFOURCC16;
typedef MMIOSTRINGTOFOURCC16 UNALIGNED *PMMIOSTRINGTOFOURCC16;

typedef struct _MMIOINSTALLIOPROC16 {          /* mm1221 */
    DWORD         f3;
    VPMMIOPROC16  f2;
    FOURCC        f1;
} MMIOINSTALLIOPROC16;
typedef MMIOINSTALLIOPROC16 UNALIGNED *PMMIOINSTALLIOPROC16;

typedef struct _MMIOSENDMESSAGE16 {            /* mm1222 */
    LPARAM     f4;
    LPARAM     f3;
    WORD       f2;
    HMMIO16    f1;
} MMIOSENDMESSAGE16;
typedef MMIOSENDMESSAGE16 UNALIGNED *PMMIOSENDMESSAGE16;

typedef struct _MMIODESCEND16 {                /* mm1223 */
    WORD          f4;
    VPMMCKINFO16  f3;
    VPMMCKINFO16  f2;
    HMMIO16       f1;
} MMIODESCEND16;
typedef MMIODESCEND16 UNALIGNED *PMMIODESCEND16;

typedef struct _MMIOASCEND16 {                 /* mm1224 */
    WORD          f3;
    VPMMCKINFO16  f2;
    HMMIO16       f1;
} MMIOASCEND16;
typedef MMIOASCEND16 UNALIGNED *PMMIOASCEND16;

typedef struct _MMIOCREATECHUNK16 {            /* mm1225 */
    WORD          f3;
    VPMMCKINFO16  f2;
    HMMIO16       f1;
} MMIOCREATECHUNK16;
typedef MMIOCREATECHUNK16 UNALIGNED *PMMIOCREATECHUNK16;

typedef struct _MMIORENAME16 {                 /* mm1226 */
    DWORD        f4;
    VPMMIOINFO16 f3;
    VPCSTR       f2;
    VPCSTR       f1;
} MMIORENAME16;
typedef MMIORENAME16 UNALIGNED *PMMIORENAME16;

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowmmcb.h ===
/* --------------------------------------------------------------------
** Module       : wowmmcb.h
**
** Description  : Interrupt callback stuff for Multi-Media.
**
** History:     : Created 09-Nov-1992 by StephenE
**
** --------------------------------------------------------------------
*/
#ifndef WOWMMCB_H
#define WOWMMCB_H

/*
** This header file will go through both 16 bit and 32 bit compilers.
** In 16 bit land UNALIGNED is not required, on 32 bit land UNALIGNED
** would have been #defined by the time this file was #included because
** this file is always included after wow32.h.  This means the following
** #define is always a no-op with 16 bit compilers and ignored with
** 32 bit compilers.
*/
#ifndef UNALIGNED
#define UNALIGNED
#endif

extern void call_ica_hw_interrupt(int, int, int);

/* --------------------------------------------------------------------
**  Hardware Interrupts:
**
**  IRQ:     Interrupt: ICA: Line: Description:
**  -------------------------------------------------------------------
**  IRQ0     0x08       0    0     Timer Tick every 18.2 times per second.
**  IRQ1     0x09       0    1     Keyboard service required.
**  IRQ2     0x0A       0    2     INT from slave 8259A.
**  IRQ8     0x70       1    0         Real time clock service.
**  IRQ9     0x71       1    1         Software redirected to IRQ2.
**  IRQ10    0x72       1    2         Reserved.
**  IRQ11    0x73       1    3         Reserved.
**  IRQ12    0x74       1    4         Reserved.
**  IRQ13    0x75       1    5         Numeric co-processor
**  IRQ14    0x76       1    6         Fixed disk controller
**  IRQ15    0x77       1    7         Reserved.
**  IRQ3     0x0B       0    3     Com2 service request.
**  IRQ4     0x0C       0    4     Com1 service request.
**  IRQ5     0x0D       0    5     Data request from LPT2:
**  IRQ6     0x0E       0    6     Floppy disk service required.
**  IRQ7     0x0F       0    7     Data request from LPT1:
**
** --------------------------------------------------------------------
*/

#ifdef  NEC_98
#define MULTIMEDIA_LINE         4
#define MULTIMEDIA_ICA          1
#define MULTIMEDIA_INTERRUPT    0x14
#else   // NEC_98
#define MULTIMEDIA_LINE         2
#define MULTIMEDIA_ICA          1
#define MULTIMEDIA_INTERRUPT    0x72
#endif  // NEC_98

#define CALLBACK_ARGS_SIZE      16

typedef struct _CALLBACK_ARGS {   /* cbargs */
    DWORD       dwFlags;        // Flags to identify the type of callback.
    DWORD       dwFunctionAddr; // 16:16 address of the function to be called
    WORD        wHandle;        // The handle or ID of the device
    WORD        wMessage;       // The message to be passed to function
    DWORD       dwInstance;     // User data
    DWORD       dwParam1;       // Device data 1
    DWORD       dwParam2;       // Device data 2
} CALLBACK_ARGS;

typedef struct _CALLBACK_DATA {   /* cbdata */
    WORD            wRecvCount;    // The number of interrupts received
    WORD            wSendCount;    // The number of interrupts sent
    CALLBACK_ARGS   args[CALLBACK_ARGS_SIZE];  // Interrupt arguments
    WORD            wIntsCount;    // The number of interrupts received
} CALLBACK_DATA;

typedef CALLBACK_DATA FAR *VPCALLBACK_DATA;         // 16:16 pointer type
typedef CALLBACK_ARGS FAR *VPCALLBACK_ARGS;         // 16:16 pointer type

typedef CALLBACK_DATA UNALIGNED *PCALLBACK_DATA;    //  0:32 pointer type
typedef CALLBACK_ARGS UNALIGNED *PCALLBACK_ARGS;    //  0:32 pointer type

VOID FAR PASCAL Notify_Callback_Data( VPCALLBACK_DATA vpCallbackData );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\inc\wowusr.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWUSR.H
 *  16-bit User API argument structures
 *
 *  History:
 *  Created 02-Feb-1991 by Jeff Parsons (jeffpar)
 *  Added Win 3.1 APIs on 19-March-1992 Chandan S. Chauhan (ChandanC)
 *
--*/

/* User API IDs
 */
#define FUN_ADJUSTWINDOWRECT        102 //
#define FUN_ADJUSTWINDOWRECTEX      454 //
#define FUN_ANSILOWER               432 //
#define FUN_ANSILOWERBUFF           438 //
#define FUN_ANSINEXT                472 //
#define FUN_ANSIPREV                473 //
#define FUN_ANSIUPPER               431 //
#define FUN_ANSIUPPERBUFF           437 //
#define FUN_ANYPOPUP                52  //
#define FUN_APPENDMENU              411 //
#define FUN_ARRANGEICONICWINDOWS    170 // Internal, proto
#define FUN_BEGINDEFERWINDOWPOS     259 // Internal, proto
#define FUN_BEGINPAINT              39  //
#define FUN_BRINGWINDOWTOTOP        45  //
#define FUN_BROADCASTMESSAGE        355 // Internal
#define FUN_BUILDCOMMDCB            213 //
#define FUN_BUTTONWNDPROC           303 // Internal
#define FUN_CALCCHILDSCROLL         462 // Internal
#define FUN_CALLMSGFILTER           123 //
#define FUN_CALLWINDOWPROC          122 //
#define FUN_CARETBLINKPROC          311 // Internal
#define FUN_CASCADECHILDWINDOWS     198 // Internal
#define FUN_CHANGECLIPBOARDCHAIN    149 //
#define FUN_CHANGEMENU              153 //
#define FUN_CHECKDLGBUTTON          97  //
#define FUN_CHECKMENUITEM           154 //
#define FUN_CHECKRADIOBUTTON        96  //
#define FUN_CHILDWINDOWFROMPOINT    191 //
#define FUN_CLEARCOMMBREAK          211 //
#define FUN_CLIENTTOSCREEN          28  //
#define FUN_CLIPCURSOR              16  //
#define FUN_CLOSECLIPBOARD          138 //
#define FUN_CLOSECOMM               207 //
#define FUN_CLOSEWINDOW             43  //
#define FUN_COMBOBOXCTLWNDPROC      344 // Internal
#define FUN_COMPUPDATERECT          316 // Internal
#define FUN_COMPUPDATERGN           317 // Internal
#define FUN_CONTROLPANELINFO        273 // Internal
#define FUN_CONTSCROLL              310 // Internal
#define FUN_COPYRECT                74  //
#define FUN_COUNTCLIPBOARDFORMATS   143 //
#define FUN_CREATECARET             163 //
#define FUN_CREATECURSOR            406 //
#define FUN_CREATECURSORICONINDIRECT 408 // Internal
#define FUN_CREATEDIALOG            89  //
#define FUN_CREATEDIALOGINDIRECT    219 //
#define FUN_CREATEDIALOGINDIRECTPARAM 242 //
#define FUN_CREATEDIALOGPARAM       241 //
#define FUN_CREATEICON              407 //
#define FUN_CREATEMENU              151 //
#define FUN_CREATEPOPUPMENU         415 //
#define FUN_CREATEWINDOW            41  //
#define FUN_CREATEWINDOWEX          452 //
#define FUN_DEFDLGPROC              308 //
#define FUN_DEFERWINDOWPOS          260 // Internal, proto
#define FUN_DEFFRAMEPROC            445 //
#define FUN_DEFHOOKPROC             235 //
#define FUN_DEFMDICHILDPROC         447 //
#define FUN_DEFWINDOWPROC           107 //
#define FUN_DELETEMENU              413 //
#define FUN_DESKTOPWNDPROC          305 // Internal
#define FUN_DESTROYCARET            164 //
#define FUN_DESTROYCURSOR           458 //
#define FUN_DESTROYICON             457 //
#define FUN_DESTROYMENU             152 //
#define FUN_DESTROYWINDOW           53  //
#define FUN_DIALOGBOX               87  //
#define FUN_DIALOGBOXINDIRECT       218 //
#define FUN_DIALOGBOXINDIRECTPARAM  240 //
#define FUN_DIALOGBOXPARAM          239 //
#define FUN_DISABLEOEMLAYER         4   // Internal
#define FUN_DISPATCHMESSAGE         114 //
#define FUN_DLGDIRLIST              100 //
#define FUN_DLGDIRLISTCOMBOBOX      195 //
#define FUN_DLGDIRSELECT            99  //
#define FUN_DLGDIRSELECTCOMBOBOX    194 //
#define FUN_DRAGDETECT              465 // Internal
#define FUN_DRAGOBJECT              464 // Internal
#define FUN_DRAWFOCUSRECT           466 //
#define FUN_DRAWICON                84  //
#define FUN_DRAWMENUBAR             160 //
#define FUN_DRAWTEXT                85  //
#define FUN_DUMPICON                459 // Internal
#define FUN_EDITWNDPROC             301 // Internal
#define FUN_EMPTYCLIPBOARD          139 //
#define FUN_ENABLEHARDWAREINPUT     331 //
#define FUN_ENABLEMENUITEM          155 //
#define FUN_ENABLEOEMLAYER          3   // Internal
#define FUN_ENABLEWINDOW            34  //
#define FUN_ENDDEFERWINDOWPOS       261 // Internal, proto
#define FUN_ENDDIALOG               88  //
#define FUN_ENDMENU                 187 // Internal
#define FUN_ENDPAINT                40  //
#define FUN_ENUMCHILDWINDOWS        55  //
#define FUN_ENUMCLIPBOARDFORMATS    144 //
#define FUN_ENUMPROPS               27  //
#define FUN_ENUMTASKWINDOWS         225 //
#define FUN_ENUMWINDOWS             54  //
#define FUN_EQUALRECT               244 //
#define FUN_ESCAPECOMMFUNCTION      214 //
#define FUN_EXCLUDEUPDATERGN        238 //
#define FUN_EXITWINDOWS             7   // Internal, proto
#define FUN_FARCALLNETDRIVER        500 // Internal
#define FUN_FILEPORTDLGPROC         346 // Internal
#define FUN_FILLRECT                81  //
#define FUN_FILLWINDOW              324 // Internal
#define FUN_FINALUSERINIT           400 // Internal
#define FUN_FINDWINDOW              50  //
#define FUN_FLASHWINDOW             105 //
#define FUN_FLUSHCOMM               215 //
#define FUN_FRAMERECT               83  //
#define FUN_GETACTIVEWINDOW         60  //
#define FUN_GETASYNCKEYSTATE        249 //
#define FUN_GETCAPTURE              236 //
#define FUN_GETCARETBLINKTIME       169 //
#define FUN_GETCARETPOS             183 //
#define FUN_GETCLASSINFO            404 //
#define FUN_GETCLASSLONG            131 //
#define FUN_GETCLASSNAME            58  //
#define FUN_GETCLASSWORD            129 //
#define FUN_GETCLIENTRECT           33  //
#define FUN_GETCLIPBOARDDATA        142 //
#define FUN_GETCLIPBOARDFORMATNAME  146 //
#define FUN_GETCLIPBOARDOWNER       140 //
#define FUN_GETCLIPBOARDVIEWER      148 //
#define FUN_GETCOMMERROR            203 //
#define FUN_GETCOMMEVENTMASK        209 //
#define FUN_GETCOMMSTATE            202 //
#define FUN_GETCONTROLBRUSH         326 // Internal
#define FUN_GETCURRENTTIME          15  //
#define FUN_GETSYSTEMMSECCOUNT      15  //  This system.drv rtn gets thunked to GetCurrentTime
#define FUN_GETCURSORPOS            17  //
#define FUN_GETDC                   66  //
#define FUN_GETDESKTOPHWND          278 // Internal, proto
#define FUN_GETDESKTOPWINDOW        286 //
#define FUN_GETDIALOGBASEUNITS      243 //
#define FUN_GETDLGCTRLID            277 // Internal, proto
#define FUN_GETDLGITEM              91  //
#define FUN_GETDLGITEMINT           95  //
#define FUN_GETDLGITEMTEXT          93  //
#define FUN_GETDOUBLECLICKTIME      21  //
#define FUN_GETFILEPORTNAME         343 // Internal
#define FUN_GETFOCUS                23  //
#define FUN_GETICONID               455 // Internal
#define FUN_GETINPUTSTATE           335 //
#define FUN_GETINTERNALWINDOWPOS    460 // Internal
#define FUN_GETKEYBOARDSTATE        222 //
#define FUN_GETKEYSTATE             106 //
#define FUN_GETLASTACTIVEPOPUP      287 //
#define FUN_GETMENU                 157 //
#define FUN_GETMENUCHECKMARKDIMENSIONS  417 //
#define FUN_GETMENUITEMCOUNT        263 //
#define FUN_GETMENUITEMID           264 //
#define FUN_GETMENUSTATE            250 //
#define FUN_GETMENUSTRING           161 //
#define FUN_GETMESSAGE              108 //
#define FUN_GETMESSAGE2             323 // Internal
#define FUN_GETMESSAGEPOS           119 //
#define FUN_GETMESSAGETIME          120 //
#define FUN_GETMOUSEEVENTPROC       337 // Internal
#define FUN_GETNEXTDLGGROUPITEM     227 //
#define FUN_GETNEXTDLGTABITEM       228 //
#define FUN_GETNEXTQUEUEWINDOW      274 // Internal
#define FUN_GETNEXTWINDOW           230 //
#define FUN_GETPARENT               46  //
#define FUN_GETPRIORITYCLIPBOARDFORMAT  402 //
#define FUN_GETPROP                 25  //
#define FUN_GETQUEUESTATUS          334 // Internal
#define FUN_GETSCROLLPOS            63  //
#define FUN_GETSCROLLRANGE          65  //
#define FUN_GETSUBMENU              159 //
#define FUN_GETSYSCOLOR             180 //
#define FUN_GETSYSMODALWINDOW       189 //
#define FUN_GETSYSTEMMENU           156 //
#define FUN_GETSYSTEMMETRICS        179 //
#define FUN_GETTABBEDTEXTEXTENT     197 //
#define FUN_GETTICKCOUNT            13  //
#define FUN_GETTIMERRESOLUTION      14  // Internal
#define FUN_GETTOPWINDOW            229 //
#define FUN_GETUPDATERECT           190 //
#define FUN_GETUPDATERGN            237 //
#define FUN_GETWC2                  318 // Internal
#define FUN_GETWINDOW               262 //
#define FUN_GETWINDOWDC             67  //
#define FUN_GETWINDOWLONG           135 //
#define FUN_GETWINDOWRECT           32  //
#define FUN_GETWINDOWTASK           224 //
#define FUN_GETWINDOWTEXT           36  //
#define FUN_GETWINDOWTEXTLENGTH     38  //
#define FUN_GETWINDOWWORD           133 //
#define FUN_GLOBALADDATOM           268 //
#define FUN_GLOBALDELETEATOM        269 //
#define FUN_GLOBALFINDATOM          270 //
#define FUN_GLOBALGETATOMNAME       271 //
#define FUN_GRAYSTRING              185 //
#define FUN_HIDECARET               166 //
#define FUN_HILITEMENUITEM          162 //
#define FUN_ICONSIZE                86  // Internal
#define FUN_INFLATERECT             78  //
#define FUN_INITAPP                 5   // No proto
#define FUN_INSENDMESSAGE           192 //
#define FUN_INSERTMENU              410 //
#define FUN_INTERSECTRECT           79  //
#define FUN_INVALIDATERECT          125 //
#define FUN_INVALIDATERGN           126 //
#define FUN_INVERTRECT              82  //
#define FUN_ISCHARALPHA             433 //
#define FUN_ISCHARALPHANUMERIC      434 //
#define FUN_ISCHARLOWER             436 //
#define FUN_ISCHARUPPER             435 //
#define FUN_ISCHILD                 48  //
#define FUN_ISCLIPBOARDFORMATAVAILABLE  193 //
#define FUN_ISDIALOGMESSAGE         90  //
#define FUN_ISDLGBUTTONCHECKED      98  //
#define FUN_ISICONIC                31  //
#define FUN_ISRECTEMPTY             75  //
#define FUN_ISTWOBYTECHARPREFIX     51  // Internal, proto
#define FUN_ISUSERIDLE              333 // Internal
#define FUN_ISWINDOW                47  //
#define FUN_ISWINDOWENABLED         35  //
#define FUN_ISWINDOWVISIBLE         49  //
#define FUN_ISZOOMED                272 //
#define FUN_KILLSYSTEMTIMER         182 // Internal
#define FUN_KILLTIMER               12  //
#define FUN_KILLTIMER2              327 // Internal
#define FUN_LBOXCARETBLINKER        453 // Internal
#define FUN_LBOXCTLWNDPROC          307 // Internal
#define FUN_LOADACCELERATORS        177 //
#define FUN_LOADBITMAP              175 //
#define FUN_LOADCURSOR              173 //
#define FUN_LOADCURSORICONHANDLER   336 // Internal
#define FUN_LOADDIBCURSORHANDLER    356 // Internal
#define FUN_LOADDIBICONHANDLER      357 // Internal
#define FUN_LOADICON                174 //
#define FUN_LOADICONHANDLER         456 // Internal
#define FUN_LOADMENU                150 //
#define FUN_LOADMENUINDIRECT        220 //
#define FUN_LOADSTRING              176 //
#define FUN_LOCKMYTASK              276 // Internal
#define FUN_LOOKUPMENUHANDLE        217 // Internal
#define FUN_LSTRCMP                 430 //
#define FUN_LSTRCMPI                471 //
#define FUN_MAPDIALOGRECT           103 //
#define FUN_MB_DLGPROC              409 // Internal
#define FUN_MDICLIENTWNDPROC        444 // Internal
#define FUN_MENUITEMSTATE           329 // Internal
#define FUN_MENUWNDPROC             306 // Internal
#define FUN_MESSAGEBEEP             104 //
#define FUN_MESSAGEBOX              1   //
#define FUN_MODIFYMENU              414 //
#define FUN_MOVEWINDOW              56  //
#define FUN_OFFSETRECT              77  //
#define FUN_OLDEXITWINDOWS          2   // Internal
#define FUN_OPENCLIPBOARD           137 //
#define FUN_OPENCOMM                200 //
#define FUN_OPENICON                44  //
#define FUN_PAINTRECT               325 // Internal
#define FUN_PEEKMESSAGE             109 //
#define FUN_POSTAPPMESSAGE          116 //
#define FUN_POSTMESSAGE             110 //
#define FUN_POSTMESSAGE2            313 // Internal
#define FUN_POSTQUITMESSAGE         6   //
#define FUN_PTINRECT                76  //
#define FUN_READCOMM                204 //
#define FUN_REALIZEPALETTE          283 //
#define FUN_REGISTERCLASS           57  //
#define FUN_REGISTERCLIPBOARDFORMAT 145 //
#define FUN_REGISTERWINDOWMESSAGE   118 //
#define FUN_RELEASECAPTURE          19  //
#define FUN_RELEASEDC               68  //
#define FUN_REMOVEMENU              412 //
#define FUN_REMOVEPROP              24  //
#define FUN_REPAINTSCREEN           275 // No proto
#define FUN_REPLYMESSAGE            115 //
#define FUN_SBWNDPROC               304 // Internal
#define FUN_SCREENTOCLIENT          29  //
#define FUN_SCROLLCHILDREN          463 // Internal
#define FUN_SCROLLDC                221 //
#define FUN_SCROLLWINDOW            61  //
#define FUN_SELECTPALETTE           282 //
#define FUN_SENDDLGITEMMESSAGE      101 //
#define FUN_SENDMESSAGE             111 //
#define FUN_SENDMESSAGE2            312 // Internal
#define FUN_SETACTIVEWINDOW         59  //
#define FUN_SETCAPTURE              18  //
#define FUN_SETCARETBLINKTIME       168 //
#define FUN_SETCARETPOS             165 //
#define FUN_SETCLASSLONG            132 //
#define FUN_SETCLASSWORD            130 //
#define FUN_SETCLIPBOARDDATA        141 //
#define FUN_SETCLIPBOARDVIEWER      147 //
#define FUN_SETCOMMBREAK            210 //
#define FUN_SETCOMMEVENTMASK        208 //
#define FUN_SETCOMMSTATE            201 //
#define FUN_SETCURSOR               69  //
#define FUN_SETCURSORPOS            70  //
#define FUN_SETDESKPATTERN          279 // Internal
#define FUN_SETDESKWALLPAPER        285 // Internal
#define FUN_SETDLGITEMINT           94  //
#define FUN_SETDLGITEMTEXT          92  //
#define FUN_SETDOUBLECLICKTIME      20  //
#define FUN_SETEVENTHOOK            321 // Internal
#define FUN_SETFOCUS                22  //
#define FUN_SETGETKBDSTATE          330 // Internal
#define FUN_SETGRIDGRANULARITY      284 // Internal
#define FUN_SETINTERNALWINDOWPOS    461 // Internal
#define FUN_SETKEYBOARDSTATE        223 //
#define FUN_SETMENU                 158 //
#define FUN_SETMENUITEMBITMAPS      418 //
#define FUN_SETMESSAGEQUEUE         266 //
#define FUN_SETPARENT               233 //
#define FUN_SETPROP                 26  //
#define FUN_SETRECT                 72  //
#define FUN_SETRECTEMPTY            73  //
#define FUN_SETSCROLLPOS            62  //
#define FUN_SETSCROLLRANGE          64  //
#define FUN_SETSYSCOLORS            181 //
#define FUN_SETSYSMODALWINDOW       188 //
#define FUN_SETSYSTEMMENU           280 // Internal
#define FUN_SETSYSTEMTIMER          11  // Internal
#define FUN_SETTIMER                10  //
#define FUN_SETTIMER2               328 // Internal
#define FUN_SETWC2                  319 // Internal
#define FUN_SETWINDOWLONG           136 //
#define FUN_SETWINDOWPOS            232 //
#define FUN_SETWINDOWSHOOKINTERNAL  121 // Internal
#define FUN_SETWINDOWTEXT           37  //
#define FUN_SETWINDOWWORD           134 //
#define FUN_SHOWCARET               167 //
#define FUN_SHOWCURSOR              71  //
#define FUN_SHOWOWNEDPOPUPS         265 //
#define FUN_SHOWSCROLLBAR           267 //
#define FUN_SHOWWINDOW              42  //
#define FUN_SIGNALPROC              314 // Internal
#define FUN_SNAPWINDOW              281 // Internal
#define FUN_STATICWNDPROC           302 // Internal
#define FUN_STRINGFUNC              470 // Internal
#define FUN_SWAPMOUSEBUTTON         186 //
#define FUN_SWITCHTOTHISWINDOW      172 // Internal
#define FUN_SWITCHWNDPROC           347 // Internal
#define FUN_SYSERRORBOX             320 // Internal
#define FUN_TABBEDTEXTOUT           196 //
#define FUN_TABTHETEXTOUTFORWIMPS   354 // Internal
#define FUN_TILECHILDWINDOWS        199 // Internal
#define FUN_TITLEWNDPROC            345 // Internal
#define FUN_TRACKPOPUPMENU          416 //
#define FUN_TRANSLATEACCELERATOR    178 //
#define FUN_TRANSLATEMDISYSACCEL    451 //
#define FUN_TRANSLATEMESSAGE        113 //
#define FUN_TRANSMITCOMMCHAR        206 //
#define FUN_UNGETCOMMCHAR           212 //
#define FUN_UNHOOKWINDOWSHOOK       234 //
#define FUN_UNIONRECT               80  //
#define FUN_UNREGISTERCLASS         403 //
#define FUN_UPDATEWINDOW            124 //
#define FUN_USERYIELD               332 // Internal
#define FUN_VALIDATERECT            127 //
#define FUN_VALIDATERGN             128 //
#define FUN_WAITMESSAGE             112 //
#define FUN_WINDOWFROMPOINT         30  //
#define FUN_WINFARFRAME             340 // Internal
#define FUN_WINHELP                 171 //
#define FUN_WINOLDAPPHACKOMATIC     322 // Internal
#define FUN_WNETADDCONNECTION       517 // Internal
#define FUN_WNETBROWSEDIALOG        515 // Internal
#def