_bstrADClassSom =             SysAllocString(L"msWMI-SOM");
  g_bstrADClassPolicyType =      SysAllocString(L"msWMI-PolicyType");
  g_bstrADClassWMIGPO =          SysAllocString(L"msWMI-WMIGPO");

  // **** CIM Attribute Names

  g_bstrAuthor =             SysAllocString(L"Author");
  g_bstrChangeDate =         SysAllocString(L"ChangeDate");
  g_bstrClassDefinition =    SysAllocString(L"ClassDefinition"),
  g_bstrCreationDate =       SysAllocString(L"CreationDate");
  g_bstrDefault =            SysAllocString(L"Default");
  g_bstrDescription =        SysAllocString(L"Description");
  g_bstrDsPath =             SysAllocString(L"DsPath");
  g_bstrDomain =             SysAllocString(L"Domain");
  g_bstrID =                 SysAllocString(L"ID");
  g_bstrMax =                SysAllocString(L"Max");
  g_bstrMin =                SysAllocString(L"Min");
  g_bstrName =               SysAllocString(L"Name");
  g_bstrPolicyType =         SysAllocString(L"PolicyType");
  g_bstrPropertyName =       SysAllocString(L"PropertyName");
  g_bstrQuery =              SysAllocString(L"query");
  g_bstrQueryLanguage =      SysAllocString(L"QueryLanguage");
  g_bstrRangeSettings =      SysAllocString(L"RangeSettings");
  g_bstrRules =              SysAllocString(L"Rules");
  g_bstrSourceOrganization = SysAllocString(L"SourceOrganization");
  g_bstrTargetClass =        SysAllocString(L"TargetClass"),
  g_bstrTargetNameSpace =    SysAllocString(L"TargetNamespace");
  g_bstrTargetObject =       SysAllocString(L"TargetObject"),
  g_bstrTargetPath =         SysAllocString(L"TargetPath"),
  g_bstrTargetType =         SysAllocString(L"TargetType"),
  g_bstrValidValues =        SysAllocString(L"ValidValues");

  // **** CIM class names

  g_bstrClassMergeablePolicy =        SysAllocString(L"MSFT_MergeablePolicyTemplate");
  g_bstrClassRangeParam =    SysAllocString(L"MSFT_RangeParam");
  g_bstrClassRangeSint32 =   SysAllocString(L"MSFT_SintRangeParam");
  g_bstrClassRangeUint32 =   SysAllocString(L"MSFT_UintRangeParam");
  g_bstrClassRangeReal =     SysAllocString(L"MSFT_RealRangeParam");
  g_bstrClassSetSint32 =     SysAllocString(L"MSFT_SintSetParam");
  g_bstrClassSetUint32 =     SysAllocString(L"MSFT_UintSetParam");
  g_bstrClassSetString =     SysAllocString(L"MSFT_StringSetParam");
  g_bstrClassSimplePolicy =  SysAllocString(L"MSFT_SimplePolicyTemplate");
  g_bstrClassRule =          SysAllocString(L"MSFT_Rule");
  g_bstrClassSom =           SysAllocString(L"MSFT_SomFilter");
  g_bstrClassSomFilterStatus = SysAllocString(L"MSFT_SomFilterStatus");
  g_bstrClassPolicyType =    SysAllocString(L"MSFT_PolicyType");
  g_bstrClassWMIGPO =        SysAllocString(L"MSFT_WMIGPO");

  // **** misscelaneious standard names

  g_bstrMISCclassSchema =        SysAllocString(L"classSchema");
  g_bstrMISCContainer =          SysAllocString(L"Container"),
  g_bstrMISCdefaultNamingContext = SysAllocString(L"defaultNamingContext");
  g_bstrMISCschemaNamingContext = SysAllocString(L"schemaNamingContext");
  g_bstrMISCWQL = SysAllocString(L"WQL");
  g_bstrMISCQuery = SysAllocString(L"Query");
  
}

void FreeGlobalNames(void)
{
  // **** misc names

  SysFreeString(g_bstrEmptyString);
  SysFreeString(g_bstrEmptyDate);

  // **** AD schema names

  SysFreeString(g_bstrADAuthor);
  SysFreeString(g_bstrADChangeDate);
  SysFreeString(g_bstrADClassDefinition);
  SysFreeString(g_bstrADCreationDate);
  SysFreeString(g_bstrADIntDefault);
  SysFreeString(g_bstrADInt8Default);
  SysFreeString(g_bstrADID);
  SysFreeString(g_bstrADIntMax);
  SysFreeString(g_bstrADInt8Max);
  SysFreeString(g_bstrADIntMin);
  SysFreeString(g_bstrADInt8Min);
  SysFreeString(g_bstrADIntValidValues);
  SysFreeString(g_bstrADName);
  SysFreeString(g_bstrADNormalizedClass);
  SysFreeString(g_bstrADObjectClass);
  SysFreeString(g_bstrADParam2);
  SysFreeString(g_bstrADPolicyType);
  SysFreeString(g_bstrADPropertyName);
  SysFreeString(g_bstrADQuery);
  SysFreeString(g_bstrADQueryLanguage);
  SysFreeString(g_bstrADStringDefault);
  SysFreeString(g_bstrADStringValidValues);
  SysFreeString(g_bstrADSourceOrganization);
  SysFreeString(g_bstrADTargetClass);
  SysFreeString(g_bstrADTargetNameSpace);
  SysFreeString(g_bstrADTargetObject);
  SysFreeString(g_bstrADTargetPath);
  SysFreeString(g_bstrADTargetType);

  // **** AD class names

  SysFreeString(g_bstrADClassMergeablePolicy);
  SysFreeString(g_bstrADClassRangeParam);
  SysFreeString(g_bstrADClassRangeSint32);
  SysFreeString(g_bstrADClassRangeUint32);
  SysFreeString(g_bstrADClassRangeReal);
  SysFreeString(g_bstrADClassParamUnknown);
  SysFreeString(g_bstrADClassSetSint32);
  SysFreeString(g_bstrADClassSetUint32);
  SysFreeString(g_bstrADClassSetString);
  SysFreeString(g_bstrADClassSimplePolicy);
  SysFreeString(g_bstrADClassRule);
  SysFreeString(g_bstrADClassSom);
  SysFreeString(g_bstrADClassPolicyType);
  SysFreeString(g_bstrADClassWMIGPO);

  // **** CIM Attribute Names

  SysFreeString(g_bstrAuthor);
  SysFreeString(g_bstrChangeDate);
  SysFreeString(g_bstrClassDefinition);
  SysFreeString(g_bstrCreationDate);
  SysFreeString(g_bstrDefault);
  SysFreeString(g_bstrDsPath);
  SysFreeString(g_bstrDomain);
  SysFreeString(g_bstrID);
  SysFreeString(g_bstrMax);
  SysFreeString(g_bstrMin);
  SysFreeString(g_bstrName);
  SysFreeString(g_bstrPolicyType);
  SysFreeString(g_bstrPropertyName);
  SysFreeString(g_bstrQuery);
  SysFreeString(g_bstrQueryLanguage);
  SysFreeString(g_bstrRangeSettings);
  SysFreeString(g_bstrRules);
  SysFreeString(g_bstrSourceOrganization);
  SysFreeString(g_bstrTargetClass);
  SysFreeString(g_bstrTargetNameSpace);
  SysFreeString(g_bstrTargetObject);
  SysFreeString(g_bstrTargetPath);
  SysFreeString(g_bstrTargetType);
  SysFreeString(g_bstrValidValues);

  // **** CIM class names

  SysFreeString(g_bstrClassMergeablePolicy);
  SysFreeString(g_bstrClassRangeParam);
  SysFreeString(g_bstrClassRangeSint32);
  SysFreeString(g_bstrClassRangeUint32);
  SysFreeString(g_bstrClassRangeReal);
  SysFreeString(g_bstrClassSetSint32);
  SysFreeString(g_bstrClassSetUint32);
  SysFreeString(g_bstrClassSetString);
  SysFreeString(g_bstrClassSimplePolicy);
  SysFreeString(g_bstrClassRule);
  SysFreeString(g_bstrClassSom);
  SysFreeString(g_bstrClassSomFilterStatus);
  SysFreeString(g_bstrClassPolicyType);
  SysFreeString(g_bstrClassWMIGPO);

  // **** CIM standard names

  SysFreeString(g_bstrMISCclassSchema);
  SysFreeString(g_bstrMISCContainer);
  SysFreeString(g_bstrMISCschemaNamingContext);
  SysFreeString(g_bstrMISCdefaultNamingContext);
  SysFreeString(g_bstrMISCWQL),
  SysFreeString(g_bstrMISCQuery);
 
}

// TODO: attempt to create namespace if not available.
HRESULT GetNamespace(BSTR namespaceName, IWbemServices*& pNamespace, bool bInProc)
{
    HRESULT hr = WBEM_E_FAILED;

    IWbemLocator* pLoc = NULL;

	if (FAILED(hr = CoCreateInstance(bInProc ? CLSID_WbemAdministrativeLocator : CLSID_WbemLocator, 
        0, CLSCTX_INPROC_SERVER, IID_IWbemLocator,
         (LPVOID*) &pLoc)))
		ERRORTRACE((LOG_ESS, "Could not create wbem locator (0x%08X)\n", hr));
	else
	{
		DEBUGTRACE((LOG_ESS, "Created Locator\n"));
        if (FAILED(hr = pLoc->ConnectServer(namespaceName, NULL,NULL, 0,0,0,0,&pNamespace)))
            ERRORTRACE((LOG_ESS, "ConnectServer(%S) failed (0x%08X)\n", namespaceName, hr));
		else
			DEBUGTRACE((LOG_ESS, "ConnectServer(%S) succeeded (0x%08X)\n", namespaceName, hr));
			
		pLoc->Release();
	}

	return hr;
}

// make sure that the ID property of pObj has a value
// assumes property is a BSTR!
// will generate GUID if not
// if pName == NULL, assumes property name is "ID"
// returns WBEM_S_NO_ERROR if ID generated
//         WBEM_S_FALSE if no ID generated (already has a value)
//         WBEM_E_NOT_FOUND if ID property is not
//         some error if error of some sort
HRESULT EnsureID(IWbemClassObject* pObj, WCHAR* pName)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    WCHAR* pKeyName = (pName == NULL) ? L"ID" : pName;

    CComVariant
      v;

    if (SUCCEEDED(hr = pObj->Get(pKeyName, 0, &v, NULL, NULL)))
    {
        if ((v.vt == VT_NULL) ||  (v.bstrVal == NULL))
        {         
            GUID guid;

            CoCreateGuid(&guid);
            
            BSTR guidStr = SysAllocStringByteLen(NULL, 129);
            if (guidStr == NULL)
                hr = WBEM_E_OUT_OF_MEMORY;
            else
            {
                StringFromGUID2(guid, guidStr, 128);

                VARIANT v;
                VariantInit(&v);
                v.vt = VT_BSTR;
                v.bstrVal = guidStr;
                
                pObj->Put(pKeyName, 0, &v, NULL);

                SysFreeString(guidStr);
            }
        }
        else
        {
            VariantClear(&v);
            hr = (HRESULT)WBEM_S_FALSE;
        }
    }

    return hr;
}

void Init_AdsAttrInfo(ADS_ATTR_INFO *pAdsAttrInfo, 
                        LPWSTR bstrName, 
                        DWORD control, 
                        ADSTYPE type, 
                        PADSVALUE pVals, 
                        DWORD nVals)
{
  unsigned long c1;

  if(NULL == pAdsAttrInfo) return;

  pAdsAttrInfo->pszAttrName = bstrName;
  pAdsAttrInfo->dwControlCode = control;
  pAdsAttrInfo->dwADsType = type;

  if(nVals > 0)
  {
    pAdsAttrInfo->dwNumValues = nVals;

    if(NULL != pVals)
    {
      pAdsAttrInfo->pADsValues = pVals;
    }
    else
    {
      throw L"could not init ADS_ATTR_INFO structure";
    }

    for(c1 = 0; c1 < nVals; c1++)
    { 
      (pAdsAttrInfo->pADsValues + c1)->dwType = type;
    }
  }
  else
  {
    pAdsAttrInfo->dwNumValues = 0;
    pAdsAttrInfo->pADsValues = NULL;
  }
}

HRESULT ADSIToWMIErrorCodes(HRESULT hresAD)
{
  // **** first check that we were handed a wbem error

  if(((hresAD & 0x800FF000) == 0x80041000) ||
     ((hresAD & 0x800FF000) == 0x80042000) ||
     ((hresAD & 0x800FF000) == 0x80044000)) return hresAD;
  
  
  if(hresAD != WBEM_S_NO_ERROR) switch(hresAD)
  {
    case S_ADS_ERRORSOCCURRED          : return WBEM_E_FAILED ;
    case S_ADS_NOMORE_ROWS             : return WBEM_S_NO_MORE_DATA ;
    case S_ADS_NOMORE_COLUMNS          : return WBEM_S_NO_MORE_DATA ;

    case E_ADS_UNKNOWN_OBJECT          : return WBEM_E_NOT_FOUND ;
    case E_ADS_OBJECT_EXISTS           : return WBEM_E_ALREADY_EXISTS;

    case 0x80072014  : return WBEM_E_INVALID_OBJECT; // The requested operation did not 
                                                     // satisfy one or more constraints 
                                                     // associated with the class of the object. 
    case 0x8007202B  : return WBEM_E_NOT_AVAILABLE; // A referral was returned from the server. 
    case 0x80072032  : return WBEM_E_INVALID_SYNTAX;  // LDAP_INVALID_DN_SYNTAX
    case 0x80070005  : return WBEM_E_ACCESS_DENIED; // LDAP_INSUFFICIENT_RIGHTS
    case 0x8007054b  : return WBEM_E_NOT_AVAILABLE; // The specified domain either does not exist 
                                                    // or could not be contacted. 
    case 0x80072030  : return WBEM_E_NOT_FOUND ; // LDAP_NO_SUCH_OBJECT
    case 0x8007200a  : return WBEM_E_FAILED;  //LDAP_NO_SUCH_ATTRIBUTE

    default : return WBEM_E_FAILED;
  }

  return WBEM_S_NO_ERROR;
}

int IsEmpty(VARIANT &v)
{
  if((v.vt == VT_NULL) || (v.vt == VT_EMPTY)) return 1;

  if((v.vt == VT_UNKNOWN) || (v.vt == VT_DISPATCH))
  { if(NULL == v.punkVal)
      return 1;
  }

  return 0;
}

// Creates the default security descriptor for WMI policy *containers*
// Full Control - Domain & Enterprise Admins & GPO Creator-Owner group
// Read Access  - authenticated users
// assumes input pointer is NULL or uninitialized or some such
HRESULT CreateDefaultSecurityDescriptor(CNtSecurityDescriptor& cSD)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    CNtSid sidWorld(L"Authenticated Users");

    CNtSid sidSystem(L"System");
    CNtSid sidAdmins(L"Domain Admins");
    CNtSid sidEnterpriseAdmins(L"Enterprise Admins");
    CNtSid sidAdministrators(L"Administrators");        
    CNtSid sidGPO(L"Group Policy Creator Owners");
    CNtSid sidOwner(L"CREATOR OWNER");

    // hmmm - does six aces beat four aces?
    // a smith and wesson beats four of a kind...
    DWORD full = FULL_CONTROL | DS_GENERIC_ALL;
    CNtAce aceEnterpriseAdmins(full, ACCESS_ALLOWED_ACE_TYPE, ADS_ACEFLAG_INHERIT_ACE, sidEnterpriseAdmins);
    CNtAce            aceOwner(full, ACCESS_ALLOWED_ACE_TYPE, ADS_ACEFLAG_INHERIT_ACE | ADS_ACEFLAG_INHERIT_ONLY_ACE, sidOwner);
    CNtAce     aceAdminsObject(full, ACCESS_ALLOWED_ACE_TYPE, ADS_ACEFLAG_INHERIT_ACE | ADS_ACEFLAG_INHERIT_ONLY_ACE, sidAdmins);    
    

    DWORD write = DS_GENERIC_READ | DS_GENERIC_WRITE | ACTRL_DS_CREATE_CHILD;
    CNtAce         aceAdmins(write | ACTRL_DS_DELETE_CHILD, ACCESS_ALLOWED_ACE_TYPE, 0, sidAdmins);    
    CNtAce aceAdministrators(write,                         ACCESS_ALLOWED_ACE_TYPE, 0, sidAdministrators);    
    CNtAce            aceGPO(write,                         ACCESS_ALLOWED_ACE_TYPE, 0, sidGPO);
    
    DWORD read = DS_GENERIC_READ;
    CNtAce  aceWorld(read, ACCESS_ALLOWED_ACE_TYPE, ADS_ACEFLAG_INHERIT_ACE, sidWorld);
    CNtAce aceSystem(read, ACCESS_ALLOWED_ACE_TYPE, ADS_ACEFLAG_INHERIT_ACE, sidSystem);

    CNtAcl ackl;
    if (!ackl.AddAce(&aceWorld))            hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceSystem))           hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceAdmins))           hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceEnterpriseAdmins)) hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceAdministrators))   hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceGPO))              hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceOwner))            hr = WBEM_E_FAILED;
    if (!ackl.AddAce(&aceAdminsObject))     hr = WBEM_E_FAILED;

    if (!ackl.Resize(CNtAcl::MinimumSize))  hr = WBEM_E_FAILED;

    if (!cSD.SetDacl(&ackl)) hr = WBEM_E_FAILED;
    if (!cSD.SetOwner(&sidEnterpriseAdmins)) hr = WBEM_E_FAILED;

    // prefix: making sure we don't dereference a NULL...
    if (cSD.GetPtr() != NULL)
        if (!SetSecurityDescriptorControl(cSD.GetPtr(), SE_DACL_PROTECTED, SE_DACL_PROTECTED)) hr = WBEM_E_FAILED;

    return hr;
}


// given an input security descriptor
// add owner from thread
HRESULT GetOwnerSecurityDescriptor(CNtSecurityDescriptor& SD)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CNtSid sidOwner(CNtSid::CURRENT_THREAD);
    if (!SD.SetOwner(&sidOwner)) hr = WBEM_E_FAILED;

    
    /***********************
    CNtSid sidOwner(CNtSid::CURRENT_THREAD);
    CNtAcl ackl;

    if (!SD.GetDacl(ackl)) hr = WBEM_E_FAILED;
    if (!SD.SetOwner(&sidOwner)) hr = WBEM_E_FAILED;

    if (SUCCEEDED(hr))
    {
        CNtSid sidGPO(L"Group Policy Creator Owners");

        int nAces = ackl.GetNumAces();
        CNtAce* pAce = NULL;
        CNtSid* pSid = NULL;

        // walk through all the aces, find GPO owner creators & kill them
        for (int i = 0; i < nAces; i++)
            if ((pAce = ackl.GetAce(i)) && (pSid = pAce->GetSid()))
            {
                if ((*pSid == sidGPO) && (pAce->GetType() == ACCESS_ALLOWED_ACE_TYPE))
                {
                    ackl.DeleteAce(i);   

                    delete pAce;
                    delete pSid;
                    break;
                }

                delete pAce;
                delete pSid;
            }
            else
            // 
            {
                hr = WBEM_E_CRITICAL_ERROR;
                break;
            }
    }

    if (SUCCEEDED(hr))
    {
        CNtAce aceOwner(FULL_CONTROL, ACCESS_ALLOWED_ACE_TYPE, 0, sidOwner);

        if (ackl.AddAce(&aceOwner) && SD.SetDacl(&ackl))
            hr = WBEM_S_NO_ERROR;
        else
            hr = WBEM_E_FAILED;


    }
    ******************/
    
   return hr;
}

PSECURITY_DESCRIPTOR GetADSecurityDescriptor(IDirectoryObject *pIDirectoryObject)
{
  HRESULT 
    hres;

  LPWSTR
    pAttrNames[] = { L"ntSecurityDescriptor" };

  ADsStruct<ADS_ATTR_INFO>
    pAttrInfo;

  PSECURITY_DESCRIPTOR
    pSD = NULL;

  DWORD
    dwReturn,
    dwLength;

  hres = pIDirectoryObject->GetObjectAttributes(pAttrNames, 1, &pAttrInfo, &dwReturn);
  
  if(SUCCEEDED(hres) && (1 == dwReturn))
  {
    dwLength = pAttrInfo->pADsValues->SecurityDescriptor.dwLength;

    pSD = new BYTE[dwLength];
    if(NULL == pSD) return NULL;

    ZeroMemory(pSD, dwLength);

    memcpy(pSD, pAttrInfo->pADsValues->SecurityDescriptor.lpValue, dwLength);
  }
  
  return pSD;
}

#define PATH_LENGTH 1024

HRESULT ExecuteWQLQuery(CPolicySOM *a_pSomObj, 
                        wchar_t *wcsWQLStmt, 
                        IWbemObjectSink *pResponseHandler,
                        IWbemServices *pWbemServices, 
                        BSTR bstrADClassName,
                        functTyp pf_ADToCIM)
{
  HRESULT
    hres = WBEM_E_FAILED;

  int
    nRes;

  QL_LEVEL_1_TOKEN
    *pToken = NULL;

  CComPtr<IADsContainer>
    pADsContainer;
    
  CComQIPtr<IDirectorySearch>
    pDirectorySearch;

  CComBSTR
    bstrLDAPQuery;

  wchar_t
    objPath[PATH_LENGTH];

  ADS_SEARCH_HANDLE
    searchHandle;

  ADS_SEARCH_COLUMN
    searchColumn;

  wchar_t
    *pszDistName[] = { L"distinguishedName" };

  // ****  parse WQL expression

  CTextLexSource 
    src(wcsWQLStmt);

  QL1_Parser 
    parser(&src);

  QL_LEVEL_1_RPN_EXPRESSION 
    *pExp = NULL;

  AutoDelete<QL_LEVEL_1_RPN_EXPRESSION>
    AutoExp(&pExp);

  if(nRes = parser.Parse(&pExp))
    return WBEM_E_INVALID_QUERY;

  // **** find domain attribute

  for(int iToken = 0; (iToken < pExp->nNumTokens) && (NULL == pToken); iToken++)
  {
    pToken = &pExp->pArrayOfTokens[iToken];

    if(_wcsicmp(g_bstrDomain, pToken->PropertyName.GetStringAt(pToken->PropertyName.GetNumElements() - 1)))
      pToken = NULL;
  }

  if(NULL == pToken)
    return WBEMESS_E_REGISTRATION_TOO_BROAD;

  if((QL_LEVEL_1_TOKEN::OP_EXPRESSION != pToken->nTokenType) ||
     (QL_LEVEL_1_TOKEN::OP_EQUAL != pToken->nOperator) ||
     (TRUE == pToken->m_bPropComp) ||
     (VT_BSTR != pToken->vConstValue.vt))
    return WBEM_E_INVALID_QUERY;

  if((NULL == bstrADClassName) || (NULL == pf_ADToCIM))
    return WBEM_E_INVALID_QUERY;

  // **** connect to LDAP location

  CComBSTR
    bstrDomain = pToken->vConstValue.bstrVal;
    
  pADsContainer.Attach(a_pSomObj->GetADServices(bstrDomain, hres));
  pDirectorySearch = pADsContainer;
  
  if(FAILED(hres))
  {
    if(WBEM_E_NOT_FOUND == hres)
      return WBEM_S_NO_ERROR;

    return hres;
  }
  else if(pDirectorySearch == NULL)
    return WBEM_E_FAILED;

  VARIANT v1; v1.bstrVal = (BSTR)bstrDomain; v1.vt = VT_BSTR;
  
  // **** build LDAP query to execute on container pADs

  bstrLDAPQuery.Append(L"(objectCategory=");
  bstrLDAPQuery.Append(bstrADClassName);
  bstrLDAPQuery.Append(L")");

  // **** set search preferences

  ADS_SEARCHPREF_INFO
    SearchPreferences[1];

  SearchPreferences[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
  SearchPreferences[0].vValue.dwType = ADSTYPE_INTEGER;
  SearchPreferences[0].vValue.Integer = 1000;

  hres = pDirectorySearch->SetSearchPreference(SearchPreferences, 1);

  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Could not set search preferences, returned error: 0x%08X\n", (BSTR)bstrLDAPQuery, hres));
    return ADSIToWMIErrorCodes(hres);
  }

  // **** execute query

  hres = pDirectorySearch->ExecuteSearch(bstrLDAPQuery, pszDistName, 1, &searchHandle);

  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Could execute query: (%s) returned error: 0x%08X\n", (BSTR)bstrLDAPQuery, hres));
    return ADSIToWMIErrorCodes(hres);
  }

  // **** build result list

  try
  {
    while(SUCCEEDED(hres = pDirectorySearch->GetNextRow(searchHandle)) && (S_ADS_NOMORE_ROWS != hres))
    {
      CComPtr<IDirectoryObject>
        pDirectoryObject;

      CComPtr<IWbemClassObject>
        pWbemClassObject;

      // **** get path to object

      hres = pDirectorySearch->GetColumn(searchHandle, pszDistName[0], &searchColumn);
      if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);

      // **** get pointer to object

      StringCchCopy(objPath, PATH_LENGTH, L"LDAP://");
      StringCchCat(objPath, PATH_LENGTH, bstrDomain);
      StringCchCat(objPath, PATH_LENGTH, L"/");
      StringCchCat(objPath, PATH_LENGTH, searchColumn.pADsValues->CaseIgnoreString);
      pDirectorySearch->FreeColumn(&searchColumn);

      hres = ADsOpenObject(objPath,   
                           NULL, NULL, 
                           ADS_SECURE_AUTHENTICATION | ADS_USE_SEALING | ADS_USE_SIGNING,
                           IID_IDirectoryObject, (void **)&pDirectoryObject);
      if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);

      hres = pf_ADToCIM(&pWbemClassObject, pDirectoryObject, pWbemServices);
      if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
      if(pWbemClassObject == NULL) return WBEM_E_FAILED;

      hres = pWbemClassObject->Put(g_bstrDomain, 0, &v1, 0);
      hres = pResponseHandler->Indicate(1, &pWbemClassObject);
    }
  }
  catch(long hret)
  {
    hres = ADSIToWMIErrorCodes(hret);
    ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from AD to WMI generated HRESULT 0x%08X\n", hres));
  }
  catch(wchar_t *swErrString)
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
    hres = WBEM_E_FAILED;
  }
  catch(...)
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
    hres = WBEM_E_TRANSPORT_FAILURE;  // HACK for RC1
  }

  pDirectorySearch->CloseSearchHandle(searchHandle);

  return hres;
}

void LogExtendedADErrorInfo(HRESULT hres)
{
  DWORD dwLastError;
  WCHAR szErrorBuf[1024], szNameBuf[256];

  if(HRESULT_FACILITY(hres) == FACILITY_WIN32)
  {
    HRESULT hres2;

    hres2 = ADsGetLastError(&dwLastError, szErrorBuf, 1023, szNameBuf, 255);

    if(SUCCEEDED(hres2))
      ERRORTRACE((LOG_ESS, "POLICMAN: Error Code: %d Error Text: %S Provider: %S\n", dwLastError, szErrorBuf, szNameBuf));
    else
      ERRORTRACE((LOG_ESS, "POLICMAN: Type mismatch on date property\n"));
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\policman\loader\loader.cpp ===
// test harness for WMI GPO subsubsystem
// hardcoded for the hhancedom domain in microsoft.com

#include <windows.h>
#include <initguid.h>
#include <prsht.h>
#include <wbemidl.h>
#include <gpedit.h>
#include <stdio.h>

#define LINK_TARGET  L"LDAP://DC=EssCool,DC=com"
#define DOMAIN_NAME  L"LDAP://DC=EssCool,DC=com"

// {AAEAE720-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_CSE = 
    { 0xaaeae720, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

// TODO: attempt to create namespace if not available.
HRESULT GetNamespace(BSTR namespaceName, IWbemServices*& pNamespace)
{
    HRESULT hr = WBEM_E_FAILED;

    IWbemLocator* pLoc = NULL;

	if (FAILED(hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*) &pLoc)))
		printf("Could not create wbem locator (0x%08X)\n", hr);
	else
	{
		if (SUCCEEDED(hr = pLoc->ConnectServer(namespaceName, NULL,NULL, 0,0,0,0,&pNamespace)))
            printf("Retrieved %S namespace\n", namespaceName);
        else
            printf("ConnectServer(%s) failed (0x%08X)\n", namespaceName, hr);

		pLoc->Release();
	}

	return hr;
}

HRESULT GetPolicyNamespace(IWbemServices*& pPolicyNamespace)
{
    HRESULT hr;

    BSTR bstr = SysAllocString(L"\\\\.\\ROOT\\POLICY");
    if (bstr)
    {
        hr = GetNamespace(bstr, pPolicyNamespace);
        SysFreeString(bstr);
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    if (FAILED(hr))
        printf("Failed to retrieve policy namespace (0x%08X)\n", hr);

    return hr;
}

HRESULT DeleteGPO(WCHAR *name)
{
	LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT hr;

	if (SUCCEEDED(hr = DeleteGPOLink(name,LINK_TARGET)))
		printf("deleted link\n");
	else
		printf("DeleteGPOLink failed with 0x%x.\n", hr);


    if (FAILED(hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                          CLSCTX_SERVER, IID_IGroupPolicyObject,
                          (void **)&pGPO)))
       printf("CoCreateInstance failed with 0x%x.\n", hr);
	else
	{
		if (FAILED(hr = pGPO->OpenDSGPO(name, 0)))
			printf("OpenDSGPO failed with 0x%x.\n", hr);
		else
			if (FAILED(hr = pGPO->Delete()))
				printf("Delete failed with 0x%x.\n", hr);
			else
				printf("Deleted %S\n", name);

		pGPO->Release();
	}

	return hr;
}

// communicate with the Group Policy Infrastructure which will
// create a GPO object & return to us the path of the container
// into which we should write our object
HRESULT CreateGPO(const WCHAR* name, WCHAR* domain, WCHAR* szPath)
{
    LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT hr;

    if (FAILED(hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                          CLSCTX_SERVER, IID_IGroupPolicyObject,
                          (void **)&pGPO)))
       printf("CoCreateInstance failed with 0x%x.\n", hr);
	else
	{
	    if (FAILED(hr = pGPO->New(domain, (WCHAR*)name, 0)))
	        printf("New failed with 0x%x.\n", hr);
		else
		    if (FAILED(hr= pGPO->GetDSPath(GPO_SECTION_MACHINE, szPath, MAX_PATH)))
				printf("GetDSPath failed with 0x%x.\n", hr);
			else
			{
				printf("\nGPO machine path: %S\n\n", szPath);
				// pGPO->GetDSPath(GPO_SECTION_USER, szPath, MAX_PATH);
				// printf("GPO user path: %S\n\n", szPath);
				
				WCHAR rootPath[MAX_PATH];
				
				if (FAILED(hr = pGPO->GetPath(rootPath, MAX_PATH)))
					printf("GetPath failed with 0x%x.\n", hr);
				else
				{
					printf("GPO root path: %S\n\n", rootPath);

					if (FAILED(hr = CreateGPOLink(rootPath, domain, FALSE)))
						printf("CreateGPOLink failed with 0x%x.\n", hr);
					else
						if (FAILED(hr = pGPO->Save(TRUE, TRUE, (struct _GUID *)&CLSID_CSE, (struct _GUID *)&CLSID_CSE) ))
							printf("Save failed with 0x%x.\n", hr);
				}
			}

		pGPO->Release();
	}

    return hr;
}

HRESULT PutRangeParams(IWbemServices* pPolicyNamespace, IWbemClassObject* pTemplate)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    SAFEARRAYBOUND
        arrayBounds;
  
    arrayBounds.lLbound = 0;
    arrayBounds.cElements = 1;

    SAFEARRAY* psa = SafeArrayCreate(VT_UNKNOWN, 1, &arrayBounds);
    if (!psa)
    {
        printf("Failed to create safe array\n");
        return WBEM_E_OUT_OF_MEMORY;
    }

    IWbemClassObject* pClass = NULL;
    BSTR bustard = SysAllocString(L"MSFT_SintRangeParam");
    if (SUCCEEDED(hr = pPolicyNamespace->GetObject(bustard, 0, NULL, &pClass, NULL)))
    {
        IWbemClassObject* pRange = NULL;
        if (FAILED(hr = pClass->SpawnInstance(0, &pRange)))
		{
			printf("pClass->SpawnInstance failed, 0x%08X\n", hr);
			return hr;
		}

        VARIANT v;
        VariantInit(&v);
        v.vt = VT_BSTR;
        v.bstrVal = SysAllocString(L"ID");

        pRange->Put(L"PropertyName",0,&v,NULL);
        VariantClear(&v);
        
        v.vt = VT_BSTR;
        v.bstrVal = SysAllocString(L"SINT32");
        pRange->Put(L"TargetClass",0,&v,NULL);
        VariantClear(&v);

        v.vt = VT_I4;
        v.lVal = 5;
        pRange->Put(L"Default",0,&v,NULL);
        VariantClear(&v);

        v.vt = VT_I4;
        v.lVal = CIM_SINT32;
        pRange->Put(L"TargetType",0,&v,NULL);




        v.vt = VT_UNKNOWN | VT_ARRAY;
        v.parray = psa;
        long index = 0;
        SafeArrayPutElement(psa, &index, pRange);
    
        hr = pTemplate->Put(L"RangeSettings", 0, &v, NULL);

        pRange->Release();
        pClass->Release();
    }
    else
        printf("Failed to retrieve MSFT_SintRangeParam, 0x%08X\n", hr);

    printf("PutRangeParams returning 0x%08X\n", hr);

    return hr;
}


// create template based on object
// write it to ds, return key string
HRESULT CreatePolicyTemplate(IWbemServices* pPolicyNamespace, WCHAR* keyString)
{
	HRESULT hr = WBEM_E_FAILED;
    IWbemClassObject* pTemplateTemplate = NULL;
    BSTR bstr = SysAllocString(L"MSFT_MergeablePolicyTemplate");

    if (FAILED(hr = pPolicyNamespace->GetObject(bstr,0,NULL,&pTemplateTemplate,NULL)))
        printf("GetObject on MSFT_MergeablePolicyTemplate failed 0x%08X\n", hr);
    else
    {
        printf("Retrieved MSFT_MergeablePolicyTemplate\n");

        IWbemClassObject* pTemplate = NULL;
        if (FAILED(hr = pTemplateTemplate->SpawnInstance(0, &pTemplate)))
            printf("SpawnInstance on MSFT_MergeablePolicyTemplate failed 0x%08X\n", hr);
        else
        {
            printf("SpawnInstance on MSFT_MergeablePolicyTemplate Succeeded\n");

            VARIANT v;
            VariantInit(&v);
            v.vt = VT_BSTR;
            GUID guid;

            CoCreateGuid(&guid);
            WCHAR guidStr[128];

            StringFromGUID2(guid, guidStr, 128);

            v.bstrVal = SysAllocString(guidStr);
            pTemplate->Put(L"ID", 0, &v, NULL);
            SysFreeString(v.bstrVal);
            
            v.bstrVal = SysAllocString(L"LOCAL");
            pTemplate->Put(L"DsContext", 0, &v, NULL);
            SysFreeString(v.bstrVal);
            
            v.bstrVal = SysAllocString(L"root\\policy");
            pTemplate->Put(L"TargetNamespace", 0, &v, NULL);
            SysFreeString(v.bstrVal);
            
            v.bstrVal = SysAllocString(L"ModemSetting");
            pTemplate->Put(L"TargetClass", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            v.bstrVal = SysAllocString(L"Description");
            pTemplate->Put(L"Description", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            v.bstrVal = SysAllocString(L"ModemSetting.id=5");
            pTemplate->Put(L"TargetPath", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            v.bstrVal = SysAllocString(L"None whatsoever");
            pTemplate->Put(L"SourceOrganization", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            v.bstrVal = SysAllocString(L"20000101000000.000000-480");
            pTemplate->Put(L"ChangeDate", 0, &v, NULL);
            pTemplate->Put(L"CreationDate", 0, &v, NULL);
            SysFreeString(v.bstrVal);
            
            v.bstrVal = SysAllocString(L"Joe Bob");
            pTemplate->Put(L"Name", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            v.bstrVal = SysAllocString(L"Joe Jack");
            pTemplate->Put(L"Author", 0, &v, NULL);
            SysFreeString(v.bstrVal);

            hr = PutRangeParams(pPolicyNamespace, pTemplate);
            if (SUCCEEDED(hr))
            {
                pTemplate->Get(L"__RELPATH", 0, &v, NULL, NULL);
                wcscpy(keyString, v.bstrVal);
                VariantClear(&v);

                if (SUCCEEDED(hr = pPolicyNamespace->PutInstance(pTemplate, WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL)))
                    printf("Successfully put %S\n", keyString);
                else
                    printf("PutInstance on MSFT_MergeablePolicyTemplate failed 0x%08X\n", hr);
            }

            pTemplate->Release();
        }

        pTemplateTemplate->Release();
    }

    SysFreeString(bstr);
	return hr;
}

// write WMIGPO object to DS
// to path specified in szPath
// containing keystring
HRESULT WriteWMIGPO(IWbemServices* pPolicyNamespace, const WCHAR* szPath, const WCHAR* keyString)
{
	HRESULT hr = WBEM_E_FAILED;
    IWbemClassObject* pWmiGpoClass = NULL;
    BSTR bstr = SysAllocString(L"MSFT_WMIGPO");

    if (FAILED(hr = pPolicyNamespace->GetObject(bstr,WBEM_FLAG_USE_AMENDED_QUALIFIERS,NULL,&pWmiGpoClass,NULL)))
        printf("GetObject on MSFT_WMIGPO failed 0x%08X\n", hr);
    else
    {
        IWbemClassObject* pWmiGpo = NULL;
        if (FAILED(hr = pWmiGpoClass->SpawnInstance(0, &pWmiGpo)))
            printf("SpawnInstance on MSFT_WMIGPO failed 0x%08X\n", hr);
        else
        {
            VARIANT v;
            VariantInit(&v);
            v.vt = VT_BSTR;

            v.bstrVal = SysAllocString(szPath);
            pWmiGpo->Put(L"DsPath", 0, &v, NULL);
            
            VariantClear(&v);
            v.vt = VT_BSTR | VT_ARRAY;

            SAFEARRAYBOUND
                arrayBounds;
            SAFEARRAY* pArray = NULL;
     
           arrayBounds.lLbound = 0;
           arrayBounds.cElements = 1;

           long index = 0;
           pArray = SafeArrayCreate(VT_BSTR, 1, &arrayBounds);
           SafeArrayPutElement(pArray, &index, SysAllocString(keyString));
           v.parray = pArray;
           
           pWmiGpo->Put(L"PolicyTemplate", 0, &v, NULL);
           SafeArrayDestroy(pArray);

            
            if (SUCCEEDED(hr = pPolicyNamespace->PutInstance(pWmiGpo, WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL)))
                printf("Successfully put MSFT_WMIGPO\n");
            else
                printf("PutInstance on MSFT_WMIGPO failed 0x%08X\n", hr);

            pWmiGpo->Release();
        }

        pWmiGpoClass->Release();
    }

    SysFreeString(bstr);

	return hr;
}

int __cdecl wmain(int argc, WCHAR *argv[])
{
    CoInitialize(NULL);
    
    CoInitializeSecurity (NULL, -1, NULL, NULL, 
      RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 
      EOAC_NONE, NULL);

    /**********************

//	create deleter with this...
	if (argc==2)
		DeleteGPO(argv[1]);
	else
		printf("one and only one argument, please - that's the path to the root of the gpo\n");
     ******************/

	WCHAR szPath[MAX_PATH];
    IWbemServices* pPolicyNamespace = NULL;

	if (argc==3)
    {
        if (SUCCEEDED(GetPolicyNamespace(pPolicyNamespace))
            &&
            SUCCEEDED(CreateGPO(L"WMI Test Policy", argv[1], szPath)))
			    WriteWMIGPO(pPolicyNamespace, szPath, argv[2]);

        if (pPolicyNamespace)
            pPolicyNamespace->Release();
    }
	else if (argc==4)
	{
		if (SUCCEEDED(GetPolicyNamespace(pPolicyNamespace))
            &&
            SUCCEEDED(CreateGPO(argv[3], argv[1], szPath)))
			    WriteWMIGPO(pPolicyNamespace, szPath, argv[2]);

        if (pPolicyNamespace)
            pPolicyNamespace->Release();
	}
	else
		printf("\nUSAGE:\n\n  Loader [domain path] [Policy Template Path] <optional policy name>\n\nEXAMPLE (line breaks to improve readability):\n\n  Loader LDAP://DC=EssCool,DC=com\n         MSFT_MergeablePolicyTemplate.DsContext=\\\"LOCAL\\\",ID=\\\"{BA34...3471}\\\"\n         MyPolicy\n");


    
	/*********************
    hard coded version
    WCHAR keyString[MAX_PATH];
    if (SUCCEEDED(GetPolicyNamespace(pPolicyNamespace))
        &&
		SUCCEEDED(CreatePolicyTemplate(pPolicyNamespace, keyString))
		&&        
        SUCCEEDED(CreateGPO(L"fribbert", szPath))
        )
			WriteWMIGPO(pPolicyNamespace, szPath, keyString);

    if (pPolicyNamespace)
        pPolicyNamespace->Release();
    *************************/
           
    CoUninitialize();
 
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\policman\provider\policman.cpp ===
#include <windows.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <stdio.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemcomn.h>
#include <ql.h>
#include <sync.h>
#include <Dsrole.h>
#include "utility.h"
#include "PolicMan.h"
#include "PolicSOM.h"
#include "PolicStatus.h"

#include <tchar.h>

#define REG_RUN_KEY L"Software\\Microsoft\\Windows\\CurrentVersion\\Run"

class CMyServer : public CComServer
{
public:
    CMyServer(void) { InitGlobalNames(); }
    ~CMyServer(void) { FreeGlobalNames(); }

    HRESULT Initialize()
    {
        AddClassInfo(CLSID_PolicySOM, 
            new CClassFactory<CPolicySOM>(GetLifeControl()), 
            _T("WMI Policy SOM Provider"), TRUE);

        AddClassInfo(CLSID_PolicyStatus,
            new CClassFactory<CPolicyStatus>(GetLifeControl()),
            _T("WMI Policy Status Provider"), TRUE);

        return S_OK;

    }
    HRESULT InitializeCom()
    {
        return CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }

/*
  void Register(void)
  {
    wchar_t 
      swKeyValue[] = L"RUNDLL32.EXE %systemroot%\\system32\\wbem\\policman.dll,CreateADContainers",
      swExpandedValue[512],
      swRunOnceKey[] = REG_RUN_KEY ;

    HKEY
      hkRunOnce;

    LONG
      lReturnCode;

    lReturnCode = ExpandEnvironmentStrings(swKeyValue, swExpandedValue, 512);

    lReturnCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE, swRunOnceKey, 0, KEY_SET_VALUE, &hkRunOnce);

    if(ERROR_SUCCESS != lReturnCode)
    {
      // error
    }

    lReturnCode = RegSetValueEx(hkRunOnce, L"PolicMan", 0, REG_EXPAND_SZ, (BYTE *)swExpandedValue, 
                                (lstrlen(swExpandedValue)+1) * sizeof(wchar_t));

    if(ERROR_SUCCESS != lReturnCode)
    {
      // error
    }

    RegCloseKey(hkRunOnce);
  }
*/
} Server;

HRESULT GetOrCreateObj(CComQIPtr<IADsContainer, &IID_IADsContainer> &pIADsContainer_In, 
                       CComBSTR &bstrObjName,
                       CComQIPtr<IADsContainer, &IID_IADsContainer> &pIADsContainer_Out)
{
  HRESULT
    hres = WBEM_E_FAILED;

  CComQIPtr<IDispatch, &IID_IDispatch>
    pDisp;

  CComQIPtr<IDirectoryObject, &IID_IDirectoryObject>
    pDirectoryObj;

  CComQIPtr<IADsObjectOptions, &IID_IADsObjectOptions>
    pADsObjectOptions;

  CComVariant
    vSecurityOptions;

  ADSVALUE
    AdsValue[1];

  ADS_ATTR_INFO
    attrInfo[] = { { L"ntSecurityDescriptor", ADS_ATTR_UPDATE, ADSTYPE_NT_SECURITY_DESCRIPTOR, &AdsValue[0], 1} };

  CNtSecurityDescriptor
    cSD;

  DWORD
    dwModified;

  ADS_OBJECT_INFO 
    *pADsInfo = NULL;

  if(NULL == pIADsContainer_In.p) return WBEM_E_FAILED;

  // **** get/create object

  hres = pIADsContainer_In->GetObject(g_bstrMISCContainer, bstrObjName, &pDisp);
  if(FAILED(hres) || (NULL == pDisp.p))
  {
    CComQIPtr<IADs, &IID_IADs>
      pIADs;

    hres = pIADsContainer_In->Create(g_bstrMISCContainer, bstrObjName, &pDisp);
    if(FAILED(hres) || (NULL == pDisp.p))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could create container %S : 0x%x\n", (BSTR)bstrObjName, hres));
      return hres;
    }

    // **** write object to AD

    pIADs = pDisp;
    hres = pIADs->SetInfo();
    if(FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could write container %S to DS : 0x%x\n", (BSTR)bstrObjName, hres));
      return hres;
    }
  }

  // **** set object security option

  pADsObjectOptions = pDisp;
  vSecurityOptions = (ADS_SECURITY_INFO_OWNER | ADS_SECURITY_INFO_DACL);
  hres = pADsObjectOptions->SetOption(ADS_OPTION_SECURITY_MASK, vSecurityOptions);
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could set security options on object : 0x%x\n", hres));
    return hres;
  }

  // **** create security descriptor

  hres = CreateDefaultSecurityDescriptor(cSD);
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could create security descriptor : 0x%x\n", hres));
    return hres;
  }

  // **** set object security descriptor

  AdsValue[0].dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
  AdsValue[0].SecurityDescriptor.dwLength = cSD.GetSize();
  AdsValue[0].SecurityDescriptor.lpValue = (LPBYTE)cSD.GetPtr();

  pDirectoryObj = pDisp;
  hres = pDirectoryObj->SetObjectAttributes(attrInfo, 1, &dwModified);
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could set security on object : 0x%x\n", hres));
    return hres;
  }

  pIADsContainer_Out = pDirectoryObj;

  return WBEM_S_NO_ERROR;
}

#define SYSTEM_PATH L"LDAP://CN=System,"
#define WMIPOLICY_PATH L"CN=WMIPolicy"
#define TEMPLATE_PATH L"CN=PolicyTemplate"
#define TYPE_PATH L"CN=PolicyType"
#define GPO_PATH L"CN=WMIGPO"
#define SOM_PATH L"CN=SOM"

HRESULT InScopeOfCOM_CreateADContainers(void)
{
  HRESULT
    hres = WBEM_E_FAILED;

  PDSROLE_PRIMARY_DOMAIN_INFO_BASIC 
    pBasic;

  CComPtr<IADs>
    pRootDSE;

  CComQIPtr<IADs, &IID_IADs>
    pObj;

  CComQIPtr<IADsContainer, &IID_IADsContainer>
    pWMIPolicyObj,
    pSystemObj,
    pADsContainer;

  CComVariant
    vDomainName;

  CComBSTR
    bstrSystemPath(SYSTEM_PATH),
    bstrWMIPolicy(WMIPOLICY_PATH),
    bstrTemplate(TEMPLATE_PATH),
    bstrType(TYPE_PATH),
    bstrSom(SOM_PATH),
    bstrGPO(GPO_PATH);

  // **** delay until AD is up and running

  DWORD
    dwResult = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic,
                                                 (PBYTE *)&pBasic);

  if(dwResult == ERROR_SUCCESS) 
  {
    // **** Check if this is a DC

    if((pBasic->MachineRole == DsRole_RoleBackupDomainController) || 
       (pBasic->MachineRole == DsRole_RolePrimaryDomainController)) 
    {
      HANDLE 
        hEvent;

      hEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT("NtdsDelayedStartupCompletedEvent") );

      if(hEvent) {
          WaitForSingleObject(hEvent, 50000);
          CloseHandle (hEvent);
      }
    }
  }

  // **** get LDAP name of domain controller

  hres = ADsGetObject(L"LDAP://rootDSE", IID_IADs, (void**)&pRootDSE);
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not get pointer to LDAP://rootDSE : 0x%x\n", hres));
    return hres;
  }
  else
  {
    hres = pRootDSE->Get(g_bstrMISCdefaultNamingContext, &vDomainName);
    if(FAILED(hres) || (V_VT(&vDomainName) != VT_BSTR) || (V_BSTR(&vDomainName) == NULL))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) could not get defaultNamingContext : 0x%x\n", hres));
      return hres;
    }

    bstrSystemPath.Append(vDomainName.bstrVal);
  }

  // **** get system path

  hres = ADsGetObject(bstrSystemPath, IID_IADsContainer, (void **)&pSystemObj);
  if (FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not get pointer to %S : 0x%x\n", (BSTR)bstrSystemPath, hres));
    return hres;
  }

  // **** get/create WMIPolicy containers

  hres = GetOrCreateObj(pSystemObj, bstrWMIPolicy, pWMIPolicyObj);
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not create/get pointer to %S : 0x%x\n", (BSTR)bstrWMIPolicy, hres));
    return hres;
  }
  else
  {
    hres = GetOrCreateObj(pWMIPolicyObj, bstrTemplate, pADsContainer);
    if(FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not create/get pointer to %S : 0x%x\n", (BSTR)bstrTemplate, hres));
      return hres;
    }

    hres = GetOrCreateObj(pWMIPolicyObj, bstrType, pADsContainer);
    if(FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not create/get pointer to %S : 0x%x\n", (BSTR)bstrType, hres));
      return hres;
    }

    hres = GetOrCreateObj(pWMIPolicyObj, bstrSom, pADsContainer);
    if(FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not create/get pointer to %S : 0x%x\n", (BSTR)bstrSom, hres));
      return hres;
    }

    hres = GetOrCreateObj(pWMIPolicyObj, bstrGPO, pADsContainer);
    if(FAILED(hres))
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: (Container Creation) Could not create/get pointer to %S : 0x%x\n", (BSTR)bstrGPO, hres));
      return hres;
    }
  }

  return S_OK;
}

extern "C" STDAPI CreateADContainers(void)
{
  HRESULT
    hres = WBEM_E_FAILED;

  // **** init process context

  CoInitialize(NULL);

  CoInitializeSecurity (NULL, -1, NULL, NULL,
    RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
    EOAC_NONE, NULL);

  try
  {
    hres = InScopeOfCOM_CreateADContainers();
  }
  catch(...)
  {
    // **** error

    return WBEM_E_FAILED;
  }

  // **** if we returned successfully, then remove the run key

  if(SUCCEEDED(hres))
  {
    wchar_t
      swKeyValue[] = L"RUNDLL32.EXE %systemroot%\\system32\\wbem\\policman.dll,CreateADContainers",
      swExpandedKeyValue[512],
      swRunOnceKey[] = REG_RUN_KEY ;

    HKEY
      hkRunOnce;

    LONG
      lReturnCode;

    lReturnCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE, swRunOnceKey, 0, KEY_SET_VALUE, &hkRunOnce);

    if(ERROR_SUCCESS == lReturnCode)
    {
      lReturnCode = RegDeleteValue(hkRunOnce, L"PolicMan");
  
      if(ERROR_SUCCESS != lReturnCode)
      {
        // error
      }

      RegCloseKey(hkRunOnce);
    }
  }
    
  // **** cleanup and shutdown

  CoUninitialize();

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\policman\provider\policman.h ===
#ifndef __WBEM_POLICY_MANAGER__H_
#define __WBEM_POLICY_MANAGER__H_

// {69D76D1B-B12E-4913-8F48-671B90195A2B}
const CLSID CLSID_PolicyStatus = 
    { 0x69d76d1b, 0xb12e, 0x4913, { 0x8f, 0x48, 0x67, 0x1b, 0x90, 0x19, 0x5a, 0x2b } };

// {AAEAE72B-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_PolicyGPO = 
    { 0xaaeae72b, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

// {AAEAE72C-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_PolicyRange = 
    { 0xaaeae72c, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

// {AAEAE72D-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_PolicyTemplate = 
    { 0xaaeae72d, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

// {AAEAE72E-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_PolicyType = 
    { 0xaaeae72e, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

// {AAEAE72F-0328-4763-8ECB-23422EDE2DB5}
const CLSID CLSID_PolicySOM = 
    { 0xaaeae72f, 0x328, 0x4763, { 0x8e, 0xcb, 0x23, 0x42, 0x2e, 0xde, 0x2d, 0xb5 } };

#endif // __WBEM_POLICY_MANAGER__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\policman\provider\policsom.h ===
#ifndef __WBEM_POLICY_SOM__H_
#define __WBEM_POLICY_SOM__H_

class CPolicySOM : public CUnk
{
public:
enum
{
  AD_LOCAL_CONTEXT = 0,
  AD_GLOBAL_CONTEXT,
  AD_MAX_CONTEXT
};

    CPolicySOM(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this), m_XInit(this),
        m_pWMIMgmt(NULL)
    {}
    
	~CPolicySOM();

    void* GetInterface(REFIID riid);

  IWbemServices* GetWMIServices();
  IADsContainer* GetADServices(CComBSTR &, HRESULT &hres);
  bool SetWMIServices(IWbemServices* pServices);
  bool SetADServices(IADsContainer* ,unsigned);

protected:
    class XProvider : public CImpl<IWbemServices, CPolicySOM>
    {
    public:
        /* construction & de- */

        XProvider(CPolicySOM* pObj)
            : CImpl<IWbemServices, CPolicySOM>(pObj)
		{ /* this page intentionally left blank */ }

        ~XProvider() {}
		
        /* Internals */

    protected:
        /* Method support */
        HRESULT Evaluate(IWbemClassObject* pObj, IWbemClassObject* pOutInstance);
        HRESULT BatchEvaluate(IWbemClassObject* pObj, IWbemClassObject* pOutClass, IWbemServices* pPolicyNamespace);
		HRESULT EvaluateRule(IWbemServices*& pNamespace, BSTR& namespaceName, IWbemClassObject* pRule, bool& bResult);

        /* class object management */
        IWbemClassObject* GetSomClass();
        IWbemClassObject* GetSomInstance();

		/* communication w/ winmgmt management */
		HRESULT GetLocator(IWbemLocator*& pLocator);
		HRESULT GetNewNamespace(BSTR namespaceName, IWbemServices*& pNamespace);

        HRESULT ValidateRules(IWbemClassObject* pInst, IWbemClassObject*& pErrorObject);


    private:
       	// templates for each type of object we support
    	// NULL until we need it
	    CComQIPtr<IWbemClassObject> m_pSOMClassObject;

		// NULL until we need it -
		// access through GetLocator;
		CComQIPtr<IWbemLocator> m_pLocator;

        /* IWbemServices */
    public:

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) 
			{return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    } m_XProvider;
    friend XProvider;

    class XInit : public CImpl<IWbemProviderInit, CPolicySOM>
    {
    public:
        XInit(CPolicySOM* pObj)
            : CImpl<IWbemProviderInit, CPolicySOM>(pObj){}
    
        HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
    } m_XInit;
    friend XInit;

private:

    CComPtr<IADsPathname> m_pADPathObj;
    
    // pointer back to win management
    CComPtr<IWbemServices> m_pWMIMgmt; 

    // pointer to AD policy template table
    CComPtr<IADsContainer> m_pADMgmt[AD_MAX_CONTEXT];

  CComVariant
    m_vDsConfigContext,
    m_vDsLocalContext;

    // a little something to keep our threads from getting tangled
    // will use a single critical section to protect all instance variables
    CCritSec m_CS;   
};


#endif // __WBEM_POLICY_SOM__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\policman\provider\policstatus.cpp ===
#include <unk.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <atlbase.h>
#include <sync.h>
#include <activeds.h>
#include <genlex.h>
#include <objpath.h>
#include <Utility.h>
#include <comutil.h>
#include <ql.h>

#include "PolicStatus.h"

#ifdef TIME_TRIALS
#include <StopWatch.h>
#pragma message("!! Including time trial code !!")
	StopWatch EvaluateTimer(L"Somfilter Evaluation", L"C:\\Som.Evaluate.log");
#endif

/******************************\
**** POLICY PROVIDER HELPERS ***
\******************************/

// returns addref'd pointer back to WinMgmt
CComPtr<IWbemServices>& CPolicyStatus::GetWMIServices()
{
  CInCritSec lock(&m_CS);

  return m_pWMIMgmt;
}

UINT NextPattern(wchar_t *a_pString, UINT a_uOffset, wchar_t *a_pPattern);

IADsContainer *CPolicyStatus::GetADServices(CComBSTR &a_bstrIPDomainName, 
                                            CComBSTR &a_bstrADDomainName, 
                                            HRESULT &a_hres)
{
  CInCritSec lock(&m_CS);
  
  CComQIPtr<IADsContainer> 
    pADsContainer;

  CComBSTR
    ObjPath;

  UINT 
    uOffsetS = 0, 
    uOffsetE = 0;

  // **** translate bstrIPServerName to bstrADServerName
    
  if(!a_bstrIPDomainName) 
    return NULL;
  else
  {
    a_bstrADDomainName.Append(L"DC=");

    while((uOffsetS < a_bstrIPDomainName.Length()) && 
          (uOffsetE = NextPattern(a_bstrIPDomainName, uOffsetS, L".")))
    {
      if(uOffsetS && (uOffsetS == uOffsetE)) return NULL;
      
      a_bstrADDomainName.Append(a_bstrIPDomainName + uOffsetS, uOffsetE - uOffsetS);
      uOffsetS = uOffsetE + 1;
      if(uOffsetS < a_bstrIPDomainName.Length()) a_bstrADDomainName.Append(L",DC=");
    }

    if(uOffsetS < a_bstrIPDomainName.Length())
      a_bstrADDomainName.Append(a_bstrIPDomainName + uOffsetS);
  }

  ObjPath.Append(L"LDAP://");
  ObjPath.Append(a_bstrIPDomainName);
  ObjPath.Append(L"/");
  ObjPath.Append(a_bstrADDomainName);

  // **** try and get the AD container 

  a_hres = ADsOpenObject(ObjPath,  
                       NULL, NULL, 
                       ADS_SECURE_AUTHENTICATION | ADS_USE_SEALING | ADS_USE_SIGNING,
                       IID_IADsContainer, (void**) &pADsContainer);
  
  return pADsContainer.Detach();
}

IADsContainer *GetADSchemaContainer(CComBSTR &a_bstrIPDomainName, 
                                    CComBSTR &a_bstrADDomainName, 
                                    HRESULT &hres)
{
  CComQIPtr<IADs>
    pRootDSE;

  CComVariant
    vSchemaPath;

  CComBSTR
    bstrRootPath(L"LDAP://"),
    bstrSchemaPath(L"LDAP://");

  bstrRootPath.Append(a_bstrIPDomainName);
  bstrRootPath.Append(L"/rootDSE");
  
  bstrSchemaPath.Append(a_bstrIPDomainName);
  bstrSchemaPath.Append(L"/");
  
  CComQIPtr<IADsContainer>
    pADsContainer;

  hres = ADsGetObject(bstrRootPath, IID_IADs, (void **)&pRootDSE);
  if(FAILED(hres)) return NULL;

  hres = pRootDSE->Get(g_bstrMISCschemaNamingContext, &vSchemaPath);
  if(FAILED(hres)) return NULL;

  bstrSchemaPath.Append(vSchemaPath.bstrVal);

  hres = ADsGetObject(bstrSchemaPath, IID_IADsContainer, (void **)&pADsContainer);
  if(FAILED(hres)) return NULL;

  return pADsContainer.Detach();
}

// returns false if services pointer has already been set
bool CPolicyStatus::SetWMIServices(IWbemServices* pServices)
{
  CInCritSec lock(&m_CS);
  bool bOldOneNull = FALSE;

  if (bOldOneNull = (m_pWMIMgmt == NULL))
  {
    m_pWMIMgmt = pServices;
  }

  return bOldOneNull;
}

void* CPolicyStatus::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemServices)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}

/*********************************\
***  Specific Implementation ***
\*********************************/

// returns addref'd pointer to class object
IWbemClassObject* CPolicyStatus::GetStatusClass(HRESULT &a_hres)
{
    CInCritSec lock(&m_CS);

    a_hres = WBEM_S_NO_ERROR;
    
    if (m_pStatusClassObject == NULL)
    {
        if (m_pWMIMgmt != NULL)
        {
            a_hres = m_pWMIMgmt->GetObject(g_bstrClassSomFilterStatus, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &m_pStatusClassObject, NULL);
        }
    }

    return m_pStatusClassObject;
}

// returns addref'd pointer to emply class instance
IWbemClassObject* CPolicyStatus::GetStatusInstance(HRESULT &a_hres)
{
    CComPtr<IWbemClassObject> 
      pClass, pObj;

    a_hres = WBEM_S_NO_ERROR;
    
    pClass = GetStatusClass(a_hres);

    if((pClass != NULL) && (SUCCEEDED(a_hres = pClass->SpawnInstance(0, &pObj))))
      return pObj.Detach();

    return NULL;
}

/*************************\
***  IWbemProviderInit  ***
\*************************/

STDMETHODIMP CPolicyStatus::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices* pServices, IWbemContext* pCtxt, 
            IWbemProviderInitSink* pSink)
{
  HRESULT
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume client permissions, 0x%08X\n", hres));
    return WBEM_S_ACCESS_DENIED;
  }
  else
  {
    // **** save WMI name space pointer

    m_pObject->SetWMIServices(pServices);
  }

  hres2 = pSink->SetStatus(hres, 0);
  if(FAILED(hres2))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
    if(SUCCEEDED(hres)) hres = hres2;
  }

  CoRevertToSelf();
  
  return hres;
}

/*******************\
*** IWbemServices ***
\*******************/

STDMETHODIMP CPolicyStatus::XProvider::GetObjectAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
   hres = WBEM_S_NO_ERROR,
   hres2 = WBEM_S_NO_ERROR;

  CComPtr<IWbemServices>
    pNamespace;

  CComPtr<IADsContainer>
    pADsSchemaContainer,
    pADsContainer;

  CComBSTR
    bstrADDomain,
    bstrPath1(L"CN=SOM,CN=WMIPolicy,CN=System"),
    bstrPath2(L"CN=ms-WMI-Som");

  VARIANT
    *pvDomain = NULL;

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if (FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** Check arguments

    if(ObjectPath == NULL || pResponseHandler == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object path and/or return object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** parse object path

      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      ParsedObjectPath
        *pParsedObjectPath = NULL;

      if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
         (0 != _wcsicmp(g_bstrClassSomFilterStatus, pParsedObjectPath->m_pClass)) ||
         (1 != pParsedObjectPath->m_dwNumKeys))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
        hres = WBEM_E_INVALID_QUERY;
      }
      else
      {
        for(int x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
        {
          if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDomain))
            pvDomain = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
        }

        if((!pvDomain) || (pvDomain->bstrVal == NULL))
          hres = WBEM_E_FAILED;
        else
        {
          pNamespace = m_pObject->GetWMIServices();

          CComBSTR
            bstrDomain = ((pvDomain && pvDomain->vt == VT_BSTR) ? pvDomain->bstrVal : NULL);
          
          pADsContainer.Attach(m_pObject->GetADServices(bstrDomain, bstrADDomain, hres));
          if(SUCCEEDED(hres)) pADsSchemaContainer.Attach(GetADSchemaContainer(bstrDomain, bstrADDomain, hres));
        }

        if((FAILED(hres)) || (pNamespace == NULL) || (pADsContainer == NULL))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: WMI and/or AD services not initialized\n"));
          hres = ADSIToWMIErrorCodes(hres);
        }
        else
        {
          try
          {
            CComPtr<IWbemClassObject>
              pStatusObj;

            CComQIPtr<IDispatch, &IID_IDispatch>
              pDisp1, pDisp2;

            CComQIPtr<IDirectoryObject, &IID_IDirectoryObject>
              pDirectoryObj;

            VARIANT
              vContainerPresent = {VT_BOOL, 0, 0, 0},
              vSchemaPresent = {VT_BOOL, 0, 0, 0};

            pStatusObj.Attach(m_pObject->GetStatusInstance(hres));

            if(pStatusObj != NULL)
            {
              // **** test for existence of containers

              hres = pADsContainer->GetObject(g_bstrMISCContainer, bstrPath1, &pDisp1);
              if(SUCCEEDED(hres) && (pDisp1.p != NULL)) vContainerPresent.boolVal = -1;

              // **** test for existence of schema object

              hres = pADsSchemaContainer->GetObject(g_bstrMISCclassSchema, bstrPath2, &pDisp2);
              if(SUCCEEDED(hres) && (pDisp2.p != NULL)) vSchemaPresent.boolVal = -1;

              // **** build status object
              
              hres = pStatusObj->Put(L"Domain", 0, pvDomain, 0);
              hres = pStatusObj->Put(L"ContainerAvailable", 0, &vContainerPresent, 0);
              hres = pStatusObj->Put(L"SchemaAvailable", 0, &vSchemaPresent, 0);

              hres = pResponseHandler->Indicate(1, &pStatusObj);
            }
          }
          catch(long hret)
          {
            hres = ADSIToWMIErrorCodes(hret);
            ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from AD to WMI generated HRESULT 0x%08X\n", hres));
          }
          catch(wchar_t *swErrString)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
            hres = WBEM_E_FAILED;
          }
          catch(...)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught UNKNOWN Exception\n"));
            hres = WBEM_E_FAILED;
          }
        }
      }

      ObjPath.Free(pParsedObjectPath);
      hres2 = pResponseHandler->SetStatus(0,hres, NULL, NULL);
      if(FAILED(hres2))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
        if(SUCCEEDED(hres)) hres = hres2;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\policman\provider\som.cpp ===
#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <wbemtime.h>
#include <activeds.h>
#include <ArrTempl.h>
#include <comutil.h>
#undef _ASSERT
#include <atlbase.h>
#include <activeds.h>
#include <string.h>
#include "Utility.h"

/*********************************************************************
************** Active Directory Methods ******************************
*********************************************************************/

#define MAX_ATTR_SOM 20
#define MAX_ATTR_RULE 5

#define DELIMITER (wchar_t)(L';')
#define DELIMITER_STR (wchar_t*)(L";")

HRESULT Som_CIMToAD(IWbemClassObject *pSrcPolicyObj, IDirectoryObject *pDestContainer, long lFlags)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v[MAX_ATTR_SOM];

  long 
    nArgs_SOM = 0,
    c1;

  CComPtr<IDispatch>
    pDisp; 

  CComPtr<IDirectoryObject>
    pDestSomObj;

  ADsObjAutoDelete
    AutoDelete;

  CComQIPtr<IADsContainer>
    pADsContainer = pDestContainer;

  SafeArray<IUnknown*, VT_UNKNOWN>
    Array1;

  ADSVALUE
    AdsValue[MAX_ATTR_SOM];
 
  ADS_ATTR_INFO 
    attrInfo[MAX_ATTR_SOM];

  WBEMTime
    wtCurrentTime;

  SYSTEMTIME
    SystemTime;

  CComBSTR
    bstrID,
    bstrCurrentTimeDTMF,
    RulesBuffer,
    NULL_STRING(L"\0"),
    SomName(L"CN=");

  // **** get current time
  
  GetSystemTime(&SystemTime);
  wtCurrentTime = SystemTime;
  bstrCurrentTimeDTMF.Attach(wtCurrentTime.GetDMTF(FALSE));
  
  Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                   g_bstrADObjectClass, 
                   ADS_ATTR_UPDATE, 
                   ADSTYPE_CASE_IGNORE_STRING, 
                   &AdsValue[nArgs_SOM], 
                   1);

  AdsValue[nArgs_SOM].CaseIgnoreString = g_bstrADClassSom;
  nArgs_SOM++;

  // **** ID

  hres = pSrcPolicyObj->Get(g_bstrID, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;
  if ((v[nArgs_SOM].vt == VT_BSTR) && (v[nArgs_SOM].bstrVal != NULL))
  {
      bstrID.AppendBSTR(v[nArgs_SOM].bstrVal);
      VariantClear(&v[nArgs_SOM]);
      
      Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                       g_bstrADID, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs_SOM], 
                       1);

      AdsValue[nArgs_SOM].CaseIgnoreString = bstrID;
 
      nArgs_SOM++;
  }
  else
      return WBEM_E_ILLEGAL_NULL;

  SomName.AppendBSTR(bstrID);

  // **** security descriptor

  CNtSecurityDescriptor cSD;

  // flag to indicate whether we're updating an existing object as opposed to creating a new one.
  bool bEditExisting;

  pDisp.Release();
  if(SUCCEEDED(hres = pADsContainer->GetObject(g_bstrADClassSom, SomName, &pDisp)))
  {
    bEditExisting = true;

    if(lFlags & WBEM_FLAG_CREATE_ONLY) return WBEM_E_ALREADY_EXISTS;

    // HACK HACK HACK!
    // okay, at this point we know that we're editing an existing object.
    // therefor, we do *not* want to set the id or type
    // back up the array pointer - all the ATL classes should clean up after themselves with no problem.
    nArgs_SOM = 0;

    
    // we'll simply leave the existing security descriptor in place

    /*************************************************
    CComQIPtr<IDirectoryObject, &IID_IDirectoryObject>
      pDirObj = pDisp;

    PADS_ATTR_INFO pAttrInfo = NULL;

    LPWSTR pAttrName = L"ntSecurityDescriptor";
    DWORD dwReturn;

    hres = pDirObj->GetObjectAttributes(&pAttrName, 1, &pAttrInfo, &dwReturn);
    if((dwReturn != 1) || (pAttrInfo->dwADsType != ADSTYPE_NT_SECURITY_DESCRIPTOR)) return WBEM_E_FAILED;
    SecDescValue = pAttrInfo;
    if(FAILED(hres)) return hres;

    Init_AdsAttrInfo(&attrInfo[nArgs_SOM],
                   L"ntSecurityDescriptor",
                   ADS_ATTR_UPDATE,
                   ADSTYPE_NT_SECURITY_DESCRIPTOR,
                   pAttrInfo->pADsValues,
                   1);
    ***************************************************/
  }
  else
  {
      if(WBEM_FLAG_UPDATE_ONLY & lFlags)
          return WBEM_E_NOT_FOUND;

      bEditExisting = false;

      
      hres = GetOwnerSecurityDescriptor(cSD);
      if (FAILED(hres)) return hres;

    if(CNtSecurityDescriptor::NoError == cSD.GetStatus())
    {

      AdsValue[nArgs_SOM].SecurityDescriptor.dwLength = cSD.GetSize();
      AdsValue[nArgs_SOM].SecurityDescriptor.lpValue = (LPBYTE) cSD.GetPtr();

      Init_AdsAttrInfo(&attrInfo[nArgs_SOM],
                   L"ntSecurityDescriptor",
                   ADS_ATTR_UPDATE,
                   ADSTYPE_NT_SECURITY_DESCRIPTOR,
                   &AdsValue[nArgs_SOM],
                   1);
    }
    else
        return WBEM_E_FAILED;

    nArgs_SOM++;
  }

  pDisp.Release();

  // **** Name

  hres = pSrcPolicyObj->Get(g_bstrName, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs_SOM].vt == VT_BSTR) && (v[nArgs_SOM].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADName, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = V_BSTR(&v[nArgs_SOM]);

    nArgs_SOM++;
  }
  else
      return WBEM_E_ILLEGAL_NULL;

  // **** Description

  hres = pSrcPolicyObj->Get(g_bstrDescription, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs_SOM].vt == VT_BSTR) && (v[nArgs_SOM].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADDescription, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = V_BSTR(&v[nArgs_SOM]);

    nArgs_SOM++;
  }
  else if (bEditExisting)
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADDescription, 
                     ADS_ATTR_CLEAR, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = NULL_STRING;

    nArgs_SOM++;
  }

  // **** SourceOrganization

  hres = pSrcPolicyObj->Get(g_bstrSourceOrganization, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs_SOM].vt == VT_BSTR) && (v[nArgs_SOM].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADSourceOrganization, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = V_BSTR(&v[nArgs_SOM]);

    nArgs_SOM++;
  }
  else if (bEditExisting)
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADSourceOrganization, 
                     ADS_ATTR_CLEAR, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = NULL_STRING;

    nArgs_SOM++;
  }

  // **** Author

  hres = pSrcPolicyObj->Get(g_bstrAuthor, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;

  if ((v[nArgs_SOM].vt == VT_BSTR) && (v[nArgs_SOM].bstrVal != NULL))
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADAuthor, 
                     ADS_ATTR_UPDATE, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = V_BSTR(&v[nArgs_SOM]);

    nArgs_SOM++;
  }
  else if (bEditExisting)
  {
    Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                     g_bstrADAuthor, 
                     ADS_ATTR_CLEAR, 
                     ADSTYPE_CASE_IGNORE_STRING, 
                     &AdsValue[nArgs_SOM], 
                     1);

    AdsValue[nArgs_SOM].CaseIgnoreString = NULL_STRING;

    nArgs_SOM++;

  }

  // **** ChangeDate

  Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                   g_bstrADChangeDate, 
                   ADS_ATTR_UPDATE, 
                   ADSTYPE_CASE_IGNORE_STRING, 
                   &AdsValue[nArgs_SOM], 
                   1);

  AdsValue[nArgs_SOM].CaseIgnoreString = bstrCurrentTimeDTMF;

  nArgs_SOM++;

  // **** CreationDate

  // **** if object already exists, leave it be

  //  CComVariant
  //    vCreationDate;

  if (!bEditExisting)
  {
      Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                       g_bstrADCreationDate, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs_SOM], 
                       1);
      AdsValue[nArgs_SOM].CaseIgnoreString = bstrCurrentTimeDTMF;

      nArgs_SOM++;
  }


  /***********************************
  if(SUCCEEDED(hres = pADsContainer->GetObject(NULL, SomName, &pDisp)))
  {
    CComQIPtr<IADs, &IID_IADs>
      pADsLegacyObj = pDisp;

    hres = pADsLegacyObj->Get(g_bstrADCreationDate, &vCreationDate);
    if (SUCCEEDED(hres))
        creationDate = vCreationDate.bstrVal;
    else if (hres == E_ADS_PROPERTY_NOT_FOUND)
    // support for legacy objects, might not have creation date filled
        creationDate = NULL;
    else return hres;

  }
  else
    creationDate = wtCurrentTime.GetDMTF(FALSE);

  if (creationDate != NULL)
  {
      AdsValue[nArgs_SOM].CaseIgnoreString = creationDate;

      Init_AdsAttrInfo(&attrInfo[nArgs_SOM], 
                       g_bstrADCreationDate, 
                       ADS_ATTR_UPDATE, 
                       ADSTYPE_CASE_IGNORE_STRING, 
                       &AdsValue[nArgs_SOM], 
                       1);
      nArgs_SOM++;
  }
  **********************************/

  // **** Rules

  hres = pSrcPolicyObj->Get(g_bstrRules, 0, &v[nArgs_SOM], NULL, NULL);
  if(FAILED(hres)) return hres;

  if(v[nArgs_SOM].vt != (VT_ARRAY | VT_UNKNOWN)) return WBEM_E_TYPE_MISMATCH;

  Array1 = &v[nArgs_SOM];

  wchar_t
    swArraySize[20];

  _itow(Array1.Size(), swArraySize, 10);
  RulesBuffer.Append((wchar_t*)swArraySize);
  RulesBuffer.Append(DELIMITER_STR);

  for(c1 = 0; c1 < Array1.Size(); c1++)
  {
    CComVariant
      vLanguage,
      vNameSpace,
      vQuery;

    int
      languageLength,
      nameSpaceLength,
      queryLength;

    CComPtr<IWbemClassObject>
      pRuleObj;

    hres = Array1[c1]->QueryInterface(IID_IWbemClassObject, (void **)&pRuleObj);
    if(FAILED(hres)) return hres;
    if(pRuleObj == NULL) return WBEM_E_FAILED;

    // **** QueryLanguage

    hres = pRuleObj->Get(g_bstrQueryLanguage, 0, &vLanguage, NULL, NULL);
    if(FAILED(hres)) return hres;
    if((vLanguage.vt != VT_BSTR) || (vLanguage.bstrVal == NULL))
      return WBEM_E_ILLEGAL_NULL;

    languageLength = SysStringLen(vLanguage.bstrVal);
    _itow(languageLength, swArraySize, 10);
    RulesBuffer.Append((wchar_t*)swArraySize);
    RulesBuffer.Append(DELIMITER_STR);

    // **** NameSpace

    hres = pRuleObj->Get(g_bstrTargetNameSpace, 0, &vNameSpace, NULL, NULL);
    if(FAILED(hres)) return hres;
    if((vNameSpace.vt != VT_BSTR) || (vNameSpace.bstrVal == NULL))
      return WBEM_E_ILLEGAL_NULL;

    nameSpaceLength = SysStringLen(vNameSpace.bstrVal);
    _itow(nameSpaceLength, swArraySize, 10);
    RulesBuffer.Append((wchar_t*)swArraySize);
    RulesBuffer.Append(DELIMITER_STR);

    // **** Query

    hres = pRuleObj->Get(g_bstrQuery, 0, &vQuery, NULL, NULL);
    if(FAILED(hres)) return hres;
    if((vQuery.vt != VT_BSTR) || (vQuery.bstrVal == NULL))
      return WBEM_E_ILLEGAL_NULL;

    queryLength = SysStringLen(vQuery.bstrVal);
    _itow(queryLength, swArraySize, 10);
    RulesBuffer.Append((wchar_t*)swArraySize);
    RulesBuffer.Append(DELIMITER_STR);

    // **** write the contents of the current rule

    RulesBuffer.AppendBSTR(vLanguage.bstrVal);
    RulesBuffer.Append(DELIMITER_STR);
    RulesBuffer.AppendBSTR(vNameSpace.bstrVal);
    RulesBuffer.Append(DELIMITER_STR);
    RulesBuffer.AppendBSTR(vQuery.bstrVal);
    RulesBuffer.Append(DELIMITER_STR);
  }

  Init_AdsAttrInfo(&attrInfo[nArgs_SOM],
                   g_bstrADParam2,
                   ADS_ATTR_UPDATE,
                   ADSTYPE_CASE_IGNORE_STRING,
                   &AdsValue[nArgs_SOM],
                   1);

  AdsValue[nArgs_SOM].CaseIgnoreString = (BSTR)RulesBuffer;
  nArgs_SOM++;

  // **** create AD SOM object

  pDisp.Release();
  if (bEditExisting && SUCCEEDED(hres = pADsContainer->GetObject(g_bstrADClassSom, SomName, &pDisp)))
  {
    if(!pDisp) return WBEM_E_FAILED;
    
    CComQIPtr<IDirectoryObject>
      pDirObj = pDisp;

    DWORD dwAttrsModified;
    hres = pDirObj->SetObjectAttributes(attrInfo, nArgs_SOM, &dwAttrsModified);

    if(FAILED(hres)) 
    {
	    ERRORTRACE((LOG_ESS, "POLICMAN: SetObjectAttributes failed: 0x%08X\n", hres));
	    return hres;
    }
  }
  else
  {
      pDisp.Release(); hres = pDestContainer->CreateDSObject(SomName, attrInfo, nArgs_SOM, &pDisp);

      if(FAILED(hres) || (!pDisp)) 
      {
		    ERRORTRACE((LOG_ESS, "POLICMAN: CreateDSObject failed: 0x%08X\n", hres));
	      return hres;
      }
  }

  return WBEM_S_NO_ERROR;
}

struct ReleaseSearchHandle
{
  ADS_SEARCH_HANDLE
    pHandle;

  CComPtr<IDirectorySearch>
    pDirSrch;

  ReleaseSearchHandle(ADS_SEARCH_HANDLE pIHandle, CComPtr<IDirectorySearch> &pIDirSrch)
  { pDirSrch = pIDirSrch; pHandle = pIHandle; }

  ~ReleaseSearchHandle(void)
  {if(pHandle) pDirSrch->CloseSearchHandle(pHandle); }
};

HRESULT Som_ADToCIM(IWbemClassObject **ppDestSomObj,
                    IDirectoryObject *pSrcSomObj, 
                    IWbemServices *pDestCIM)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR;

  CComVariant
    v1;

  wchar_t
    *AttrNames[] =
    {
      g_bstrADID,
      g_bstrADName,
      g_bstrADDescription,
      g_bstrADSourceOrganization,
      g_bstrADAuthor,
      g_bstrADChangeDate,
      g_bstrADCreationDate
    },
    *AttrNames2[] = 
    {
      g_bstrADParam2
    };

  ADsStruct<ADS_ATTR_INFO>
    pAttrInfo,
    pAttrInfo2;

  unsigned long
    c1, c2, dwReturn, dwReturn2;

  CComQIPtr<IWbemClassObject>
    pClassDef,
    pClassDef_RULE,
    pDestSomObj;

  IWbemContext 
    *pCtx = 0;

  // **** create empty som object

  hres = pDestCIM->GetObject(g_bstrClassSom, 0, pCtx, &pClassDef, NULL);
  if(FAILED(hres)) return hres;
  if(!pClassDef) return WBEM_E_FAILED;

  hres = pClassDef->SpawnInstance(0, ppDestSomObj);
  if(FAILED(hres)) return hres;
  pDestSomObj = *ppDestSomObj;
  if(!pDestSomObj) return WBEM_E_NOT_FOUND;

  // **** get object attributes

  hres = pSrcSomObj->GetObjectAttributes(AttrNames, 7, &pAttrInfo, &dwReturn);
  if(FAILED(hres)) return hres;
  if(pAttrInfo == NULL) return WBEM_E_NOT_FOUND;

  // **** get Param2 attribute

  hres = pSrcSomObj->GetObjectAttributes(AttrNames2, 1, &pAttrInfo2, &dwReturn2);
  if(FAILED(hres)) return hres;

  for(c1 = 0; c1 < dwReturn; c1++)
  {
    if((pAttrInfo + c1) == NULL)
      return WBEM_E_OUT_OF_MEMORY;

    if((pAttrInfo + c1)->dwADsType == ADSTYPE_PROV_SPECIFIC)
      return WBEM_E_NOT_AVAILABLE;
      
    BSTR
      bstrName = (pAttrInfo + c1)->pszAttrName,
      bstrValue = (pAttrInfo + c1)->pADsValues->CaseIgnoreString;

    if((NULL == bstrName) || (NULL == bstrValue))
      return WBEM_E_OUT_OF_MEMORY;

    v1 = bstrValue;

    // **** ID

    if(0 == _wcsicmp(bstrName, g_bstrADID))
    {
      hres = pDestSomObj->Put(g_bstrID, 0, &v1, 0);
    }

    // **** Name

    else if(0 == _wcsicmp(bstrName, g_bstrADName))
    {
      hres = pDestSomObj->Put(g_bstrName, 0, &v1, 0);
    }

    // **** Description

    else if(0 == _wcsicmp(bstrName, g_bstrADDescription))
    {
      hres = pDestSomObj->Put(g_bstrDescription, 0, &v1, 0);
    }

    // **** SourceOrganization

    else if(0 == _wcsicmp(bstrName, g_bstrADSourceOrganization))
    {
      hres = pDestSomObj->Put(g_bstrSourceOrganization, 0, &v1, 0);
    }

    // **** Author

    else if(0 == _wcsicmp(bstrName, g_bstrADAuthor))
    {
      hres = pDestSomObj->Put(g_bstrAuthor, 0, &v1, 0);
    }

    // **** ChangeDate

    else if(0 == _wcsicmp(bstrName, g_bstrADChangeDate))
    {
      hres = pDestSomObj->Put(g_bstrChangeDate, 0, &v1, 0);
    }

    // **** CreationDate

    else if(0 == _wcsicmp(bstrName, g_bstrADCreationDate))
    {
      hres = pDestSomObj->Put(g_bstrCreationDate, 0, &v1, 0);
    }

    if(FAILED(hres)) return hres;
  }

  // **** cache rule class definition
  
  hres = pDestCIM->GetObject(g_bstrClassRule, 0, pCtx, &pClassDef_RULE, NULL);
  if(FAILED(hres)) return hres;
  if(!pClassDef_RULE) return WBEM_E_FAILED;

  // **** now, get Rule objects that are children of this som object

  if(dwReturn2)
  {
    CComBSTR
      RulesBuffer = pAttrInfo2->pADsValues->CaseIgnoreString;

    wchar_t
      *pBeginChar = RulesBuffer,
      *pEndChar = RulesBuffer;

    if(NULL == pEndChar) return WBEM_S_NO_ERROR;

    // **** get number of rules

    pEndChar = wcschr(pEndChar, DELIMITER);
    if(NULL == pEndChar) return WBEM_S_NO_ERROR;
    *pEndChar = L'\0';
    int 
      cElt = 0,
      nElts = _wtoi(pBeginChar);

    for(cElt = 0; (pEndChar) && (cElt < nElts); cElt++)
    {
      CComVariant
        vLanguage,
        vTargetNameSpace,
        vQuery,
        vRules1,
        vRules2;

      int
        numScanned,
        langLength,
        nameSpaceLength,
        queryLength;

      CComPtr<IWbemClassObject>
        pDestRuleObj;

      CComPtr<IUnknown>
        pUnknown;

      // **** get length of fields

      pBeginChar = pEndChar + 1;
      numScanned = swscanf(pBeginChar, L"%d;%d;%d;", &langLength, &nameSpaceLength, &queryLength);
      if(3 != numScanned) break;
      pEndChar = wcschr(pEndChar + 1, DELIMITER);
      pEndChar = wcschr(pEndChar + 1, DELIMITER);
      pEndChar = wcschr(pEndChar + 1, DELIMITER);

      // **** create new rule object 

      hres = pClassDef_RULE->SpawnInstance(0, &pDestRuleObj);
      if(FAILED(hres)) return hres;
      if(pDestRuleObj == NULL) return WBEM_E_NOT_FOUND;

      // **** QueryLanguage

      pBeginChar = pEndChar + 1;
      pEndChar = pBeginChar + langLength;
      if(pEndChar)
      {
        *pEndChar = L'\0';
        vLanguage = pBeginChar;
        hres = pDestRuleObj->Put(g_bstrQueryLanguage, 0, &vLanguage, 0);
        if(FAILED(hres)) return hres;
      }
      else break;

      // **** NameSpace

      pBeginChar = pEndChar + 1;
      pEndChar = pBeginChar + nameSpaceLength;
      if(pEndChar)
      {
        *pEndChar = L'\0';
        vTargetNameSpace = pBeginChar;
        hres = pDestRuleObj->Put(g_bstrTargetNameSpace, 0, &vTargetNameSpace, 0);
        if(FAILED(hres)) return hres;
      }
      else break;

      // **** QueryLanguage

      pBeginChar = pEndChar + 1;
      pEndChar = pBeginChar + queryLength;
      if(pEndChar)
      {
        *pEndChar = L'\0';
        vQuery = pBeginChar;
        hres = pDestRuleObj->Put(g_bstrQuery, 0, &vQuery, 0);
        if(FAILED(hres)) return hres;
      }
      else break;

      // **** stuff new rule object into SOM object

      hres = pDestSomObj->Get(g_bstrRules, 0, &vRules1, NULL, NULL);
      if(FAILED(hres)) return hres;

      SafeArray<IUnknown*, VT_UNKNOWN>
        Rules(&vRules1);

      hres = pDestRuleObj->QueryInterface(IID_IUnknown, (void**)&pUnknown);
      if(FAILED(hres)) return hres;
      if(pUnknown == NULL) return WBEM_E_FAILED;

      Rules.ReDim(0, Rules.Size() + 1);
      Rules[Rules.IndexMax()] = pUnknown;
      Rules[Rules.IndexMax()]->AddRef();

      // **** place array in dest som object

      V_VT(&vRules2) = (VT_ARRAY | Rules.Type());
      V_ARRAY(&vRules2) = Rules.Data();
      hres = pDestSomObj->Put(g_bstrRules, 0, &vRules2, 0);
      if(FAILED(hres)) return hres;
    }
  }
  else
  {
    ADS_SEARCH_HANDLE
      SearchHandle;
 
    ADS_SEARCH_COLUMN
      SearchColumn;

    CComPtr<IDirectorySearch>
      pDirSrch;

    hres = pSrcSomObj->QueryInterface(IID_IDirectorySearch, (void **)&pDirSrch);
    if(FAILED(hres)) return hres;

    CComBSTR
      qsQuery(L"(objectClass=");

    qsQuery.Append(g_bstrADClassRule);
    qsQuery.Append(L")");

    hres = pDirSrch->ExecuteSearch(qsQuery, NULL, -1, &SearchHandle);
    if(FAILED(hres)) return hres;

    ReleaseSearchHandle
      HandleReleaseMe(SearchHandle, pDirSrch);

    while(S_OK == (hres = pDirSrch->GetNextRow(SearchHandle)))
    {
      CComVariant
        vLanguage,
        vNameSpace,
        vQuery,
        vRules1,
        vRules2;
  
      CComPtr<IUnknown>
        pUnknown;
  
      CComPtr<IWbemClassObject>
        pDestRuleObj;
  
      // **** create empty rule object
  
      hres = pClassDef_RULE->SpawnInstance(0, &pDestRuleObj);
      if(FAILED(hres)) return hres;
      if(pDestRuleObj == NULL) return WBEM_E_NOT_FOUND;
  
      // **** QueryLanguage
  
      hres = pDirSrch->GetColumn(SearchHandle, g_bstrADQueryLanguage, &SearchColumn);
      if((SUCCEEDED(hres)) && (ADSTYPE_INVALID != SearchColumn.dwADsType) && (NULL != SearchColumn.pADsValues))
      {
        vLanguage = SearchColumn.pADsValues->CaseIgnoreString;
  
        hres = pDestRuleObj->Put(g_bstrQueryLanguage, 0, &vLanguage, 0);
        pDirSrch->FreeColumn(&SearchColumn);
        if(FAILED(hres)) return hres;
      }
  
      // **** TargetNameSpace
  
      hres = pDirSrch->GetColumn(SearchHandle, g_bstrADTargetNameSpace, &SearchColumn);
      if((SUCCEEDED(hres)) && (ADSTYPE_INVALID != SearchColumn.dwADsType) && (NULL != SearchColumn.pADsValues))
      {
        vNameSpace = SearchColumn.pADsValues->CaseIgnoreString;
  
        hres = pDestRuleObj->Put(g_bstrTargetNameSpace, 0, &vNameSpace, 0);
        pDirSrch->FreeColumn(&SearchColumn);
        if(FAILED(hres)) return hres;
      }
  
      // **** Query
  
      hres = pDirSrch->GetColumn(SearchHandle, g_bstrADQuery, &SearchColumn);
      if((SUCCEEDED(hres)) && (ADSTYPE_INVALID != SearchColumn.dwADsType) && (NULL != SearchColumn.pADsValues))
      {
        vQuery = SearchColumn.pADsValues->CaseIgnoreString;
  
        hres = pDestRuleObj->Put(g_bstrQuery, 0, &vQuery, 0);
        hres = pDirSrch->FreeColumn(&SearchColumn);
        if(FAILED(hres)) return hres;
      }
  
      // **** stuff new rule object into SOM object
  
      hres = pDestSomObj->Get(g_bstrRules, 0, &vRules1, NULL, NULL);
      if(FAILED(hres)) return hres;
  
      SafeArray<IUnknown*, VT_UNKNOWN>
        Rules(&vRules1);
  
      hres = pDestRuleObj->QueryInterface(IID_IUnknown, (void**)&pUnknown);
      if(FAILED(hres)) return hres;
      if(pUnknown == NULL) return WBEM_E_FAILED;
  
      Rules.ReDim(0, Rules.Size() + 1);
      Rules[Rules.IndexMax()] = pUnknown;
      Rules[Rules.IndexMax()]->AddRef();
  
      // **** place array in dest som object
  
      V_VT(&vRules2) = (VT_ARRAY | Rules.Type());
      V_ARRAY(&vRules2) = Rules.Data();
      hres = pDestSomObj->Put(g_bstrRules, 0, &vRules2, 0);
      if(FAILED(hres)) return hres;
    }
  }
  
  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\policman\provider\policstatus.h ===
#ifndef __WBEM_POLICY_STATUS__H_
#define __WBEM_POLICY_STATUS__H_

class CPolicyStatus : public CUnk
{
public:

    CPolicyStatus(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this), m_XInit(this),
        m_pWMIMgmt(NULL) { }
    
	~CPolicyStatus() {};

    void* GetInterface(REFIID riid);

 CComPtr<IWbemServices>& GetWMIServices();
  IADsContainer* GetADServices(CComBSTR &pIPDomain, CComBSTR &pADDomain, HRESULT &hres);
  bool SetWMIServices(IWbemServices* pServices);

  IWbemClassObject* GetStatusClass(HRESULT &hres);
  IWbemClassObject* GetStatusInstance(HRESULT &hres);

protected:
    class XProvider : public CImpl<IWbemServices, CPolicyStatus>
    {
    public:
        /* construction & de- */

        XProvider(CPolicyStatus* pObj) 
            : CImpl<IWbemServices, CPolicyStatus>(pObj) 
        { /* this page intentionally left blank */ }

        ~XProvider() {};
		
    private:
        // NULL until we need it -
        // access through GetLocator;

        CComPtr<IWbemLocator> 
          m_pLocator;

        /* IWbemServices */
    public:

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
			{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) 
			{return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{return WBEM_E_NOT_SUPPORTED;};

    } m_XProvider;
    friend XProvider;

    class XInit : public CImpl<IWbemProviderInit, CPolicyStatus>
    {
    public:
        XInit(CPolicyStatus* pObj)
            : CImpl<IWbemProviderInit, CPolicyStatus>(pObj){}
    
        HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
    } m_XInit;
    friend XInit;

private:

    // NULL until we need it

    CComPtr<IWbemClassObject>
      m_pStatusClassObject;

    // pointer back to win management
    CComPtr<IWbemServices> m_pWMIMgmt; 

  CComVariant
    m_vDsLocalContext;

    // a little something to keep our threads from getting tangled
    // will use a single critical section to protect all instance variables
    CCritSec m_CS;   
};


#endif // __WBEM_POLICY_STATUS__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\policman\provider\policsom.cpp ===
#include <unk.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <atlbase.h>
#include <sync.h>
#include <activeds.h>
#include <genlex.h>
#include <objpath.h>
#include <Utility.h>
#include <ql.h>

#include "PolicSOM.h"

#ifdef TIME_TRIALS
#include <StopWatch.h>
#pragma message("!! Including time trial code !!")
	StopWatch EvaluateTimer(L"Somfilter Evaluation", L"C:\\Som.Evaluate.log");
#endif

/******************************\
**** POLICY PROVIDER HELPERS ***
\******************************/

#define SOM_RDN L"CN=SOM,CN=WMIPolicy,CN=System"

// returns addref'd pointer back to WinMgmt
IWbemServices* CPolicySOM::GetWMIServices()
{
   // CInCritSec lock(&m_CS);

	if (m_pWMIMgmt != NULL)
		((IWbemServices*)m_pWMIMgmt)->AddRef();

	return m_pWMIMgmt;
}

UINT NextPattern(wchar_t *a_pString, UINT a_uOffset, wchar_t *a_pPattern)
{
  wchar_t *start;
  
  start = wcsstr(a_pString + a_uOffset, a_pPattern);
  
  return (start < a_pString ? 0 : (UINT)(start - a_pString));
}

// returns addref'd pointer back to m_pADMgmt
IADsContainer *CPolicySOM::GetADServices(CComBSTR &a_bstrIPDomainName, HRESULT &a_hres)
{
  a_hres = WBEM_S_NO_ERROR;
    
  CComQIPtr<IADsContainer>
    pADsContainer;
    
  CComBSTR
    bstrADDomainName,
    ObjPath;
    
  UINT 
    uOffsetS = 0, 
    uOffsetE = 0;

  // **** if this is the 1st time through, get name of domain controller

  {
    CInCritSec lock(&m_CS);

    if(VT_BSTR != m_vDsLocalContext.vt)
    {
      CComPtr<IADs>
        pRootDSE;
    
      CComVariant
        vDomain;
        
      // **** get pointer to AD policy template table
    
      a_hres = ADsOpenObject(L"LDAP://rootDSE", 
                           NULL, NULL, 
                           ADS_SECURE_AUTHENTICATION | ADS_USE_SEALING | ADS_USE_SIGNING,
                           IID_IADs, (void**)&pRootDSE);
      if(FAILED(a_hres))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: (ADsGetObject) could not get object: LDAP://rootDSE, 0x%08X\n", a_hres));
        return NULL;
      }
      else
      {
        a_hres = pRootDSE->Get(g_bstrMISCdefaultNamingContext,&m_vDsLocalContext);
    
        if(FAILED(a_hres))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: (IADs::Get) could not get defaultNamingContext, 0x%08X\n", a_hres));
          return NULL;
        }
      }
    }
  }
    
  // **** translate bstrADServerName to bstrIPServerName
    
  if(!a_bstrIPDomainName)
  {
    bstrADDomainName = m_vDsLocalContext.bstrVal;
    uOffsetS = 3;
      
    while((uOffsetS < bstrADDomainName.Length()) && 
          (uOffsetE = NextPattern(m_vDsLocalContext.bstrVal, uOffsetS, L",DC=")))
    {
      if(uOffsetS && (uOffsetS == uOffsetE)) return NULL;
      
      a_bstrIPDomainName.Append(m_vDsLocalContext.bstrVal + uOffsetS, uOffsetE - uOffsetS);
      uOffsetS = uOffsetE + 4;
      if(uOffsetS < bstrADDomainName.Length()) a_bstrIPDomainName.Append(L".");
    }

    if(uOffsetS < bstrADDomainName.Length())
      a_bstrIPDomainName.Append(m_vDsLocalContext.bstrVal + uOffsetS);
  }
  
  // **** translate bstrIPServerName to bstrADServerName
    
  else
  {
    bstrADDomainName.Append(L"DC=");

    while((uOffsetS < a_bstrIPDomainName.Length()) && 
          (uOffsetE = NextPattern(a_bstrIPDomainName, uOffsetS, L".")))
    {
      if(uOffsetS && (uOffsetS == uOffsetE)) return NULL;
      
      bstrADDomainName.Append(a_bstrIPDomainName + uOffsetS, uOffsetE - uOffsetS);
      uOffsetS = uOffsetE + 1;
      if(uOffsetS < a_bstrIPDomainName.Length()) bstrADDomainName.Append(L",DC=");
    }

    if(uOffsetS < a_bstrIPDomainName.Length())
      bstrADDomainName.Append(a_bstrIPDomainName + uOffsetS);
  }

  ObjPath.Append(L"LDAP://");
  ObjPath.Append(a_bstrIPDomainName);
  ObjPath.Append(L"/");
  ObjPath.Append(SOM_RDN);
  ObjPath.Append(L",");
  ObjPath.Append(bstrADDomainName);

  if(SUCCEEDED(a_hres))
  {
    a_hres = ADsOpenObject(ObjPath,  
                         NULL, NULL, 
                         ADS_SECURE_AUTHENTICATION | ADS_USE_SEALING | ADS_USE_SIGNING,
                         IID_IADsContainer, (void**) &pADsContainer);

    if(FAILED(a_hres)) a_hres = WBEM_E_INITIALIZATION_FAILURE;
  }

  return pADsContainer.Detach();
}

// returns false if services pointer has already been set
bool CPolicySOM::SetWMIServices(IWbemServices* pServices)
{
  CInCritSec lock(&m_CS);
  bool bOldOneNull = FALSE;

  if (bOldOneNull = (m_pWMIMgmt == NULL))
  {
    m_pWMIMgmt = pServices;
    if(pServices) pServices->AddRef();
  }

  return bOldOneNull;
}

// returns false if services pointer has already been set
bool CPolicySOM::SetADServices(IADsContainer* pServices, unsigned context)
{
  CInCritSec lock(&m_CS);
  bool 
    bOldOneNull = TRUE;

  switch(context)
  {
    case AD_LOCAL_CONTEXT :
    case AD_GLOBAL_CONTEXT :
      m_pADMgmt[context] = pServices;
      bOldOneNull = (m_pADMgmt[context] == NULL);
      break;

    default : ;
  }

  return bOldOneNull;
}

CPolicySOM::~CPolicySOM()
{
  // WMI services object
  
  m_pWMIMgmt= NULL;
  
  // AD services object

  for(int i = 0; i < AD_MAX_CONTEXT; i++)
    m_pADMgmt[i] = NULL;
};

void* CPolicySOM::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemServices)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}
/*********************************\
*** Som Specific Implementation ***
\*********************************/

// returns addref'd pointer to class object
IWbemClassObject* CPolicySOM::XProvider::GetSomClass()
{
    if (m_pSOMClassObject == NULL)
    {
       CInCritSec lock(&m_pObject->m_CS);

      if (m_pSOMClassObject == NULL)
      {
         CComPtr<IWbemServices> pWinMgmt = m_pObject->GetWMIServices();
  
          if (pWinMgmt != NULL)
          {
            pWinMgmt->GetObject(g_bstrClassSom, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &m_pSOMClassObject, NULL);
          }
      }
    }

    return m_pSOMClassObject;
}

// returns addref'd pointer to emply class instance
IWbemClassObject* CPolicySOM::XProvider::GetSomInstance()
{
    CComQIPtr<IWbemClassObject> pObj;
    CComQIPtr<IWbemClassObject> pClass;

    if (pClass = GetSomClass())
    {
        pClass->SpawnInstance(0, &pObj);
    }

    return pObj.Detach();
}

HRESULT CPolicySOM::XProvider::GetLocator(IWbemLocator*& pLocator)
{
  HRESULT hr = WBEM_S_NO_ERROR;
  
  {
    CInCritSec lock(&m_pObject->m_CS);	

    if (!m_pLocator)
      hr = CoCreateInstance(CLSID_WbemAdministrativeLocator, NULL, CLSCTX_INPROC_SERVER, 
                                         IID_IWbemLocator, (void**)&m_pLocator);
  }

    if(SUCCEEDED(hr) && !(!m_pLocator))
      pLocator = m_pLocator;
      
	return hr;
}

// get namespace denoted by namespaceName
// will release pNamespace if non-null on way in
HRESULT CPolicySOM::XProvider::GetNewNamespace(BSTR namespaceName, IWbemServices*& pNamespace)
{
	HRESULT hr = WBEM_E_FAILED;
	
	if (pNamespace)
	{
		pNamespace->Release();
		pNamespace = NULL;
	}

	IWbemLocator* pLocator = NULL;
	if (SUCCEEDED(hr = GetLocator(pLocator)))
	{
		hr = pLocator->ConnectServer(namespaceName, NULL, NULL, NULL, 0, NULL, NULL, &pNamespace);
	}

	return hr;
}

// evaulate a single rule
// pNamespace & namespaceName may be NULL on entry
// may be different upon exit
// this is a rudimentary caching mechanism, 
// assuming that most of the namespaces in the rules will be the same.
HRESULT CPolicySOM::XProvider::EvaluateRule(IWbemServices*& pNamespace, BSTR& namespaceName, IWbemClassObject* pRule, bool& bResult)
{
	VARIANT v;
	VariantInit(&v);

	// assume failure
	HRESULT hr = WBEM_E_FAILED;
	bResult = false;

	// check to see	if we're still on the same namespace
	if (FAILED(hr = pRule->Get(L"TargetNamespace", 0, &v, NULL, NULL)))
		bResult = false;
	else
	{				
		if ((pNamespace == NULL) || (_wcsicmp(namespaceName, v.bstrVal) != 0))
			if (SUCCEEDED(hr = GetNewNamespace(v.bstrVal, pNamespace)))
			{
				// keep copy of name
				if (namespaceName)
				{
					if (!SysReAllocString(&namespaceName, v.bstrVal))
						hr = WBEM_E_OUT_OF_MEMORY;
				}
				else
					if (NULL == (namespaceName = SysAllocString(v.bstrVal)))
						hr = WBEM_E_OUT_OF_MEMORY;
			}
			
		VariantClear(&v);
	}

	// if we're still on track...
	if (SUCCEEDED(hr) && SUCCEEDED(hr = pRule->Get(g_bstrMISCQuery, 0, &v, NULL, NULL)))
	{

#ifdef TIME_TRIALS
	EvaluateTimer.Start(StopWatch::AtomicTimer);
#endif
		IEnumWbemClassObject *pEnumerator = NULL;
		if (SUCCEEDED(hr = pNamespace->ExecQuery(g_bstrMISCWQL, v.bstrVal, 
		                                                                     WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, 
		                                                                     NULL, &pEnumerator)))
		{

#ifdef TIME_TRIALS
	EvaluateTimer.Start(StopWatch::ProviderTimer);
#endif
			ULONG uReturned = 0;
			IWbemClassObject* pWhoCares = NULL;

			if (SUCCEEDED(hr = pEnumerator->Next(30000, 1, &pWhoCares, &uReturned)) && uReturned > 0)
			{
				// we don't care at all about the result set
				// just whether there is anything *in* the result set
				bResult = true;
				pWhoCares->Release();
			}
			if(hr == WBEM_S_TIMEDOUT) hr = WBEM_E_TIMED_OUT; 
			pEnumerator->Release();
		}
#ifdef TIME_TRIALS
		else
			EvaluateTimer.Start(StopWatch::ProviderTimer);
#endif
		VariantClear(&v);
	}

	// s_false returned when no objects are returned from 'next'
	// THIS function has successfully determined that the query failed.
	if (hr == (HRESULT)WBEM_S_FALSE)
		hr = WBEM_S_NO_ERROR;

	return hr;
}
					

// loop through all rules
// grab namespace & try each query
// TODO: Optimize by caching namespace pointers.
HRESULT CPolicySOM::XProvider::Evaluate(IWbemClassObject* pObj, IWbemClassObject* pOutInstance)
{	
	HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrEval = WBEM_S_NO_ERROR;
    
	// innocent until proven guilty
	bool bResult = true;

	VARIANT v;
	VariantInit(&v);

	if (SUCCEEDED(hr = pObj->Get(L"Rules", 0, &v, NULL, NULL)))
	{
		SafeArray<IUnknown*, VT_UNKNOWN> rules(&v);
		long nRules = rules.Size();

		// first run optimization: we'll hold onto each namespace as it comes in
		// in hopes that the NEXT one will be in the same namespace
		// in practice - it probably will be
		IWbemServices* pNamespace = NULL;
		BSTR namespaceName = NULL;

		// with each rule:
		//    get namespace name
		//		if different than the one we're currently playing with
		//			get namespace
		//    issue query
		//    count results
		for(UINT i = 0; (i < nRules) && bResult && SUCCEEDED(hrEval); i++)
		{

			if (rules[i])
			{
				IWbemClassObject* pRule = NULL;

				if (SUCCEEDED(rules[i]->QueryInterface(IID_IWbemClassObject, (void**)&pRule)))
				{
					hrEval = EvaluateRule(pNamespace, namespaceName, pRule, bResult);
					
					pRule->Release();
					pRule = NULL;
				}
				else
				{
					bResult = FALSE;
					hrEval = hr = WBEM_E_INVALID_PARAMETER;                    
				}
			}
		}

		// clean up after yourself
		VariantClear(&v);
		if (pNamespace)
			pNamespace->Release();
		if (namespaceName)
			SysFreeString(namespaceName);
	}

    // we done - tell somebody about it!
    if (SUCCEEDED(hr))
    {
        HRESULT hrDebug;
        
        VARIANT v1;
        VariantInit(&v1);
        v1.vt = VT_I4;

        if (SUCCEEDED(hrEval))
            v1.lVal = bResult ? S_OK : S_FALSE;
        else
            v1.lVal = hrEval;
        
        hrDebug = pOutInstance->Put(L"ReturnValue", 0, &v1, NULL);
    }

    return hr;
}

// loop through each of the references in input obj
// call evaluate for each, 
// TODO: Optimize w/ ExecMethodASYNC
HRESULT CPolicySOM::XProvider::BatchEvaluate(IWbemClassObject* pObj, IWbemClassObject* pOutInstance, IWbemServices* pPolicyNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    if (pObj == NULL)
        return WBEM_E_INVALID_PARAMETER;

    VARIANT vFilters;
    VariantInit(&vFilters);

    BSTR methodName = SysAllocString(L"Evaluate");
    CSysFreeMe freeEvil(methodName);

    SAFEARRAY* pResults = NULL;

    if (SUCCEEDED(hr = pObj->Get(L"filters", 0, &vFilters, NULL, NULL)))
    {        
        if ((vFilters.parray == NULL)    || 
            (vFilters.parray->cDims != 1) ||
            (vFilters.parray->rgsabound[0].cElements == 0))
            hr = WBEM_E_INVALID_PARAMETER;
        else
        {
            long index, lUbound = 0;
            SafeArrayGetUBound(vFilters.parray, 1, &lUbound);

            SAFEARRAYBOUND bounds = {lUbound +1, 0};

            pResults = SafeArrayCreate(VT_I4, 1, &bounds);
            if (!pResults)
                return WBEM_E_OUT_OF_MEMORY;

            for (index = 0; (index <= lUbound) && SUCCEEDED(hr); index++)
            {
                BSTR path = NULL;

                if (SUCCEEDED(hr = SafeArrayGetElement(vFilters.parray, &index, &path)))
                {
                    IWbemClassObject* pGazotta = NULL;
                    if (SUCCEEDED(hr = pPolicyNamespace->ExecMethod(path, methodName, 0, NULL, NULL, &pGazotta, NULL)))
                    {
                        CReleaseMe relGazotta(pGazotta);
                        VARIANT v;
                        VariantInit(&v);

                        hr = pGazotta->Get(L"ReturnValue", 0, &v, NULL, NULL);
                        hr = SafeArrayPutElement(pResults, &index, &v.lVal);
                    }
                }

                SysFreeString(path);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        VARIANT v;
        VariantInit(&v);
        v.vt = VT_I4 | VT_ARRAY;
        v.parray = pResults;
        hr = pOutInstance->Put(L"Results", 0, &v, NULL);

        // no clear - array is deleted separately.
        VariantInit(&v);
        v.vt = VT_I4;
        v.lVal = hr;
        
        hr = pOutInstance->Put(L"ReturnValue", 0, &v, NULL);

    }

    if (pResults)
        SafeArrayDestroy(pResults);

    VariantClear(&vFilters);
    return hr;
}

/*************************\
***  IWbemProviderInit  ***
\*************************/

STDMETHODIMP CPolicySOM::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices* pServices, IWbemContext* pCtxt, 
            IWbemProviderInitSink* pSink)
{
  HRESULT
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume client permissions, 0x%08X\n", hres));
    return WBEM_S_ACCESS_DENIED;
  }
  else
  {
    // **** save WMI name space pointer

    m_pObject->SetWMIServices(pServices);
  }

  hres2 = pSink->SetStatus(hres, 0);
  if(FAILED(hres2))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
    if(SUCCEEDED(hres)) hres = hres2;
  }

  // **** create LDAP name manipulation utility object
  
  {
    CInCritSec lock(&(m_pObject->m_CS));

    if(m_pObject->m_pADPathObj != NULL)
      hres = CoCreateInstance(CLSID_Pathname,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IADsPathname,
                        (void**)&(m_pObject->m_pADPathObj));
  }

  CoRevertToSelf();

  return hres;
}

/*******************\
*** IWbemServices ***
\*******************/

STDMETHODIMP CPolicySOM::XProvider::GetObjectAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
   hres = WBEM_S_NO_ERROR,
   hres2 = WBEM_S_NO_ERROR;

  CComPtr<IWbemServices>
    pNamespace;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IWbemClassObject>
    pObj;

  CComPtr<IDirectoryObject>
    pDirObj;

  VARIANT
    *pvkeyID = NULL,
    *pvDomain = NULL;

  // **** impersonate client for security

  hres = CoImpersonateClient();
  if (FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** Check arguments

    if(ObjectPath == NULL || pResponseHandler == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object path and/or return object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** parse object path

      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      ParsedObjectPath
        *pParsedObjectPath = NULL;

      if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
         (0 != _wcsicmp(g_bstrClassSom, pParsedObjectPath->m_pClass)) ||
         (2 != pParsedObjectPath->m_dwNumKeys))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
        hres = WBEM_E_INVALID_QUERY;
      }
      else
      {
        for(int x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
        {
          if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDomain))
            pvDomain = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
          else if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrID))
            pvkeyID = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
        }

        pNamespace.Attach(m_pObject->GetWMIServices());

        CComBSTR
          bstrDomain = ((pvDomain && pvDomain->vt == VT_BSTR) ? pvDomain->bstrVal : NULL);
          
        pADsContainer.Attach(m_pObject->GetADServices(bstrDomain, hres));

        if((FAILED(hres)) || (pNamespace == NULL) || (pADsContainer == NULL))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: WMI and/or AD services not initialized\n"));
          hres = ADSIToWMIErrorCodes(hres);
        }
        else
        {
          try
          {
            // **** Get pointer to instance in AD

            CComBSTR
              bstrKeyID(L"CN=");

            bstrKeyID.Append(V_BSTR(pvkeyID));
            
            hres = pADsContainer->GetObject(g_bstrADClassSom, bstrKeyID, &pDisp);
            if(FAILED(hres))
              hres = ADSIToWMIErrorCodes(hres);
            else
            {
              hres = pDisp->QueryInterface(IID_IDirectoryObject, (void **)&pDirObj);
              if(SUCCEEDED(hres))
              {
                // **** Get the instance and send it back

                hres = Som_ADToCIM(&pObj, pDirObj, pNamespace);
                if(FAILED(hres)) hres = ADSIToWMIErrorCodes(hres);
                if(pObj == NULL) hres = WBEM_E_FAILED;

                // **** set domain name for object

                if(SUCCEEDED(hres))
                {
                  VARIANT v1; v1.bstrVal = (BSTR)bstrDomain; v1.vt = VT_BSTR;
                  hres = pObj->Put(g_bstrDomain, 0, &v1, 0);
  
                  // **** Set object
  
                  pResponseHandler->Indicate(1, &pObj);
                }
              }
            }
          }
          catch(long hret)
          {
            hres = ADSIToWMIErrorCodes(hret);
            ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from AD to WMI generated HRESULT 0x%08X\n", hres));
          }
          catch(wchar_t *swErrString)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
            hres = WBEM_E_FAILED;
          }
          catch(...)
          {
            ERRORTRACE((LOG_ESS, "POLICMAN: Caught UNKNOWN Exception\n"));
            hres = WBEM_E_FAILED;
          }
        }
      }

      ObjPath.Free(pParsedObjectPath);
      hres2 = pResponseHandler->SetStatus(0,hres, NULL, NULL);
      if(FAILED(hres2))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
        if(SUCCEEDED(hres)) hres = hres2;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicySOM::XProvider::CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    return WBEM_E_NOT_SUPPORTED;
}

// validate that the rules contained in pInst are proper syntax
// if they are not, an error object is created & an error returned
HRESULT CPolicySOM::XProvider::ValidateRules(IWbemClassObject* pInst, IWbemClassObject*& pErrorObject)
{
    // init the toys we'll be playing with
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bBadQuery = false;

    VARIANT vRules;
    VariantInit(&vRules);

    SAFEARRAY* pResults = NULL;

    if (FAILED(pInst->Get(L"Rules", 0, &vRules, NULL, NULL))
        || (vRules.vt != (VT_UNKNOWN | VT_ARRAY)))
        hr = WBEM_E_INVALID_PARAMETER;
    else
    {
        // good to go, we'll create the array to keep logic simple
        long index, lUbound = 0;
        SafeArrayGetUBound(vRules.parray, 1, &lUbound);
        SAFEARRAYBOUND bounds = {lUbound +1, 0};
        pResults = SafeArrayCreate(VT_I4, 1, &bounds);

        if (!pResults)
            hr = WBEM_E_OUT_OF_MEMORY;
        else
            for (index = 0; (index <= lUbound) && SUCCEEDED(hr); index++)
            {
                // get the MSFT_Rule out of the MSFT_SomFilter
                IWbemClassObject* pRule = NULL;
                if (SUCCEEDED(hr = SafeArrayGetElement(vRules.parray, &index, &pRule)))
                {
                    HRESULT hrParse = 0;
                    VARIANT vQueryLanguage;
                    VariantInit(&vQueryLanguage);
 
                    if (SUCCEEDED(hr = pRule->Get(L"QueryLanguage", 0, &vQueryLanguage, NULL, NULL))
                        && (vQueryLanguage.vt == VT_BSTR) && (vQueryLanguage.bstrVal != NULL))
                    {
                        if (0 != _wcsicmp(vQueryLanguage.bstrVal, L"WQL"))
                        {
                            hrParse = WBEM_E_INVALID_QUERY_TYPE;
                            bBadQuery = true;
                        }
                        else
                        {
                            VARIANT vQuery;
                            VariantInit(&vQuery);

                            // get the query out of the MSFT_Rule.
                            if (SUCCEEDED(hr = pRule->Get(L"Query", 0, &vQuery, NULL, NULL))
                                && (vQuery.vt == VT_BSTR) && (vQuery.bstrVal != NULL))
                            {    
                                CTextLexSource src(vQuery.bstrVal);
                                QL1_Parser parser(&src);
                                QL_LEVEL_1_RPN_EXPRESSION *pExp = NULL;
    
                                // if it parses, we good, else we bad.
                                if(parser.Parse(&pExp))
                                {
                                    hrParse = WBEM_E_INVALID_QUERY;
                                    bBadQuery = true;
                                }
                        

                                if (pExp)
                                    delete pExp;
                            }
                            else
                                hrParse = WBEM_E_INVALID_PARAMETER;

                            VariantClear(&vQuery);
                        }
                    }
                    else
                        hrParse = WBEM_E_INVALID_PARAMETER;
                    

                    hr = SafeArrayPutElement(pResults, &index, (void*)&hrParse);
                    pRule->Release();

                    VariantClear(&vQueryLanguage);
                }
            }
    }
    
    // if we found a bad query, we create an error object to hold the info
    if (bBadQuery)
    {
        IWbemServices* pSvc = m_pObject->GetWMIServices();
        IWbemClassObject* pErrorClass = NULL;
        BSTR name = SysAllocString(L"SomFilterPutStatus");

        if (pSvc && 
            name && 
            SUCCEEDED(hr = pSvc->GetObject(name, 0, NULL, &pErrorClass, NULL)) &&
            SUCCEEDED(hr = pErrorClass->SpawnInstance(0, &pErrorObject)))
        {
            hr = WBEM_E_INVALID_PARAMETER;
            HRESULT hrDebug;

            // variant to hold array - don't clear it, the array is destroyed elsewhere
            VARIANT vResultArray;
            VariantInit(&vResultArray);
            vResultArray.vt = VT_I4 | VT_ARRAY;
            vResultArray.parray = pResults;

            hrDebug = pErrorObject->Put(L"RuleValidationResults", 0, &vResultArray, NULL);

            // other interesting error vals.
            VARIANT vTemp;
            vTemp.vt = VT_BSTR;
            
            vTemp.bstrVal = SysAllocString(L"PutInstance");
            hrDebug = pErrorObject->Put(L"Operation",0,&vTemp,NULL);
            SysFreeString(vTemp.bstrVal);
            
            vTemp.bstrVal = SysAllocString(L"PolicSOM");
            hrDebug = pErrorObject->Put(L"ProviderName",0,&vTemp,NULL);
            SysFreeString(vTemp.bstrVal);

            vTemp.vt = VT_I4;
            vTemp.lVal = WBEM_E_INVALID_QUERY;
            hrDebug = pErrorObject->Put(L"StatusCode",0,&vTemp,NULL);

			//BSTR debuggy = NULL;
			//pErrorObject->GetObjectText(0, &debuggy);
            
        }

        if (pSvc)
            pSvc->Release();
        if (name)
            SysFreeString(name);
        if (pErrorClass)
            pErrorClass->Release();
    }

    // cleanup
    VariantClear(&vRules);
    if (pResults)
        SafeArrayDestroy(pResults);

    return hr;
}

STDMETHODIMP CPolicySOM::XProvider::PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT 
        hres = WBEM_S_NO_ERROR,
        hres2 = WBEM_S_NO_ERROR;
    
    CComPtr<IADsContainer>
        pADsContainer;
    
    CComPtr<IDirectoryObject>
        pDirObj;
    
    CComVariant
        v1, vRelPath;
    
    ADsStruct<ADS_OBJECT_INFO>
        pInfo;
    
    // **** impersonate client
    
    hres = CoImpersonateClient();
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
        hres = WBEM_E_ACCESS_DENIED;
    }
    else
    {
        // **** check arguments
        
        if((NULL == pInst) || (NULL == pResponseHandler))
        {
            ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
            hres = WBEM_E_ACCESS_DENIED;
        }
        else
        {
            IWbemClassObject* pErrorObject = NULL;
            if SUCCEEDED(hres = ValidateRules(pInst, pErrorObject))
            {
            
                // **** put policy obj into AD
                try
                {
                    EnsureID(pInst, NULL);
                
                    // **** aquire AD path in which to place object
                
                    hres = pInst->Get(g_bstrDomain, 0, &v1, NULL, NULL);
                    if(FAILED(hres)) return hres;

                    CComBSTR
                      bstrDomain = (v1.vt == VT_BSTR ? v1.bstrVal : NULL);
                      
                    pADsContainer.Attach(m_pObject->GetADServices(bstrDomain, hres));

                    if((FAILED(hres)) || (pADsContainer == NULL))
                    {
                        ERRORTRACE((LOG_ESS, "POLICMAN: Could not find or connect to domain: %S, 0x%08X\n", V_BSTR(&v1), hres));
                        return ADSIToWMIErrorCodes(hres);
                    }
                    else
                    {
                      VARIANT _v; VariantInit(&_v);
                      _v.bstrVal = (BSTR)bstrDomain;
                      _v.vt = VT_BSTR;
                      
                      hres = pInst->Put(g_bstrDomain, 0, &_v, 0);
                    }
                
                    hres = pADsContainer->QueryInterface(IID_IDirectoryObject, (void **)&pDirObj);
                    if(FAILED(hres)) return ADSIToWMIErrorCodes(hres);
                
                    // **** copy policy obj into AD
                
                    hres = Som_CIMToAD(pInst, pDirObj, lFlags);
                    if(FAILED(hres)) 
                    {
                      if((HRESULT)0x8007200a == hres)
                        ERRORTRACE((LOG_ESS, "POLICMAN: Active Directory Schema for MSFT_SomFilter is invalid/missing\n"));

                      return ADSIToWMIErrorCodes(hres);
                    }
                }
                catch(long hret)
                {
                    hres = ADSIToWMIErrorCodes(hret);
                    ERRORTRACE((LOG_ESS, "POLICMAN: Translation of Policy object from WMI to AD generated HRESULT 0x%08X\n", hres));
                }
                catch(wchar_t *swErrString)
                {
                    ERRORTRACE((LOG_ESS, "POLICMAN: Caught Exception: %S\n", swErrString));
                    hres = WBEM_E_FAILED;
                }
                catch(...)
                {
                    ERRORTRACE((LOG_ESS, "POLICMAN: Caught unknown Exception\n"));
                    hres = WBEM_E_FAILED;
                }
            
            }
            
            if(FAILED(hres) && pErrorObject)
            {
                if(FAILED(pResponseHandler->SetStatus(0,hres, NULL, pErrorObject)))
                    ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
            }
            else
            {
                // **** indicate return status            
                pInst->Get(L"__RELPATH", 0, &vRelPath, NULL, NULL);
                if(FAILED(pResponseHandler->SetStatus(0,hres, vRelPath.bstrVal, NULL)))
                    ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
            }
            
            if (pErrorObject)
                pErrorObject->Release();
            
        }
        
        CoRevertToSelf();
    }
    
    return hres;
}

STDMETHODIMP CPolicySOM::XProvider::DeleteInstanceAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT 
    hres = WBEM_S_NO_ERROR,
    hres2 = WBEM_S_NO_ERROR;

  CComPtr<IADsContainer>
    pADsContainer;

  CComPtr<IDispatch>
    pDisp;

  CComPtr<IADsDeleteOps>
    pDelObj;

  VARIANT
    *pvDomain = NULL,
    *pvkeyID = NULL;

  ParsedObjectPath
    *pParsedObjectPath = NULL;

  // **** impersonate client

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    // **** Check arguments

    if(ObjectPath == NULL || pResponseHandler == NULL)
    {
      ERRORTRACE((LOG_ESS, "POLICMAN: object handle and/or return status object are NULL\n"));
      hres = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
      // **** parse object path

      CObjectPathParser
        ObjPath(e_ParserAcceptRelativeNamespace);

      if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) ||
         (0 != _wcsicmp(g_bstrClassSom, pParsedObjectPath->m_pClass)) ||
         (2 != pParsedObjectPath->m_dwNumKeys))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: Parse error for object: %S\n", ObjectPath));
        hres = WBEM_E_INVALID_QUERY;
      }
      else
      {
        int x;

        for(x = 0; x < pParsedObjectPath->m_dwNumKeys; x++)
        {
          if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrDomain))
            pvDomain = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
          else if(0 == _wcsicmp((*(pParsedObjectPath->m_paKeys + x))->m_pName, g_bstrID))
            pvkeyID = &((*(pParsedObjectPath->m_paKeys + x))->m_vValue);
        }

        CComBSTR
          bstrDomain = (pvDomain->vt == VT_BSTR ? pvDomain->bstrVal : NULL);
        
        pADsContainer.Attach(m_pObject->GetADServices(bstrDomain, hres));
        if((FAILED(hres)) || (pADsContainer == NULL))
        {
          ERRORTRACE((LOG_ESS, "POLICMAN: Could not find domain: %S\n", V_BSTR(pvDomain)));
          hres = ADSIToWMIErrorCodes(hres);
        }
        else
        {
          // **** get pointer to instance in AD

          CComBSTR
            bstrKeyID(L"CN=");
  
          bstrKeyID.Append(V_BSTR(pvkeyID));
            
          hres = pADsContainer->GetObject(g_bstrADClassSom, bstrKeyID, &pDisp);
          if(FAILED(hres))
          {
            hres = ADSIToWMIErrorCodes(hres);
            ERRORTRACE((LOG_ESS, "POLICMAN: (IADsContainer::GetObject) could not get object in AD %S, 0x%08X\n", V_BSTR(pvkeyID), hres));
          }
          else
          {
            hres = pDisp->QueryInterface(IID_IADsDeleteOps, (void **)&pDelObj);
            if(FAILED(hres))
            {
              ERRORTRACE((LOG_ESS, "POLICMAN: (IDispatch::QueryInterface) could not get IID_IADsDeleteOps interface on object\n"));
            }
            else
            {
              // **** delete the instance and all its children in AD

              hres = pDelObj->DeleteObject(0);
              if(FAILED(hres))
              {
                ERRORTRACE((LOG_ESS, "POLICMAN: (IADsDeleteOps::DeleteObject) could not delete object (0x%08X)\n", hres));
                hres = WBEM_E_ACCESS_DENIED;
              }
            }
          }
        }
      }

      ObjPath.Free(pParsedObjectPath);
      hres2 = pResponseHandler->SetStatus(0,hres, NULL, NULL);
      if(FAILED(hres2))
      {
        ERRORTRACE((LOG_ESS, "POLICMAN: could not set return status\n"));
        if(SUCCEEDED(hres)) hres = hres2;
      }
    }

    CoRevertToSelf();
  }

  return hres;
}

STDMETHODIMP CPolicySOM::XProvider::ExecQueryAsync( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
  HRESULT
    hres = WBEM_E_FAILED;

  CComPtr<IWbemServices>
    pNameSpace;

  hres = CoImpersonateClient();
  if(FAILED(hres))
  {
    ERRORTRACE((LOG_ESS, "POLICMAN: (CoImpersonateClient) could not assume callers permissions, 0x%08X\n",hres));
    hres = WBEM_E_ACCESS_DENIED;
  }
  else
  {
    pNameSpace.Attach(m_pObject->GetWMIServices());
  
    hres = ExecuteWQLQuery(m_pObject,
                           Query,
                           pResponseHandler,
                           pNameSpace,
                           g_bstrADClassSom,
                           Som_ADToCIM);

    hres = ADSIToWMIErrorCodes(hres);
    
    if(pResponseHandler != NULL)
      pResponseHandler->SetStatus(0, hres, 0, 0);
  }

  CoRevertToSelf();

  return hres;
}

STDMETHODIMP CPolicySOM::XProvider::ExecMethodAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_E_FAILED;

#ifdef TIME_TRIALS
	EvaluateTimer.Start(StopWatch::ProviderTimer);
#endif
    
    enum WhichMethod {Eval, BatchEval};
    WhichMethod whichMethod;

    // check for valid method name
    if (_wcsicmp(strMethodName, L"Evaluate") == 0)
        whichMethod = Eval;
    else if (_wcsicmp(strMethodName, L"BatchEvaluate") == 0)
        whichMethod = BatchEval;
    else
        return WBEM_E_INVALID_METHOD;
    
    // **** impersonate client for security
    hr = CoImpersonateClient();
    if (FAILED(hr))
        return hr;
    
    // retrieve target object
    CComPtr<IWbemServices> 
      pService;

    pService.Attach(m_pObject->GetWMIServices());
    if (pService == NULL)
        hr = WBEM_E_FAILED;
    else
    {
        CComQIPtr<IWbemClassObject> pObj;

#ifdef TIME_TRIALS
	EvaluateTimer.Start(StopWatch::WinMgmtTimer);
#endif

        if (SUCCEEDED(hr = pService->GetObject(strObjectPath, WBEM_FLAG_RETURN_WBEM_COMPLETE, pCtx, &pObj, NULL)))
        {

#ifdef TIME_TRIALS
	EvaluateTimer.Start(StopWatch::ProviderTimer);
#endif
            // retreive class & output param object
            CComQIPtr<IWbemClassObject> pOurClass;
            if (NULL == (pOurClass = GetSomClass()))
                hr = WBEM_E_FAILED;
            else
            {
                CComQIPtr<IWbemClassObject> pOutClass;
                if (SUCCEEDED(hr = pOurClass->GetMethod(strMethodName, 0, NULL, &pOutClass)))
                {        
                    CComQIPtr<IWbemClassObject> pOutInstance;
                    if (SUCCEEDED(pOutClass->SpawnInstance(0, &pOutInstance)))
                    {
                        if (whichMethod == Eval)
                            hr = Evaluate(pObj, pOutInstance);
                        else if (whichMethod == BatchEval)
                            hr = BatchEvaluate(pInParams, pOutInstance, pService);
                        else
                            hr = WBEM_E_INVALID_METHOD;

                        if (SUCCEEDED(hr))
                            hr = pResponseHandler->Indicate(1, &pOutInstance);

                    }
                }
            }                            
        }
        else hr = WBEM_E_NOT_FOUND;
    }    

#ifdef TIME_TRIALS
	EvaluateTimer.Stop();
	EvaluateTimer.LogResults();
	EvaluateTimer.Reset(); // for next time!
#endif

	// difficult call - do we put this before or after we take the timestamp?
    pResponseHandler->SetStatus(0,hr,NULL, NULL);
    CoRevertToSelf();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\adsiclas.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiclas.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the CADSIClass which encapsulates an ADSI class
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
// CADSIClass::CADSIClass
//
// Purpose : Constructor 
//
// Parameters:
//  lpszWBEMClassName : The WBEM name of the Class being created. A copy of this is made
//  lpszADSIClassName : The ADSI name of the Class being created. A copy of this is made
//***************************************************************************
CADSIClass :: CADSIClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszADSIClassName)
	: CRefCountedObject(lpszADSIClassName)
{
	if(lpszWBEMClassName)
	{
		m_lpszWBEMClassName = new WCHAR[wcslen(lpszWBEMClassName) + 1];
		wcscpy(m_lpszWBEMClassName, lpszWBEMClassName);
	}
	else
	{
		m_lpszWBEMClassName = NULL;
	}

	// Set the attributes to theri default values
	m_lpszCommonName = NULL;
	m_lpszSuperClassLDAPName = NULL;
	m_lpszGovernsID = NULL;
	m_pSchemaIDGUIDOctets = NULL;
	m_dwSchemaIDGUIDLength = 0;
	m_lpszRDNAttribute = NULL;
	m_lpszDefaultSecurityDescriptor = NULL;
	m_dwObjectClassCategory = 0;
	m_dwNTSecurityDescriptorLength = 0;
	m_pNTSecurityDescriptor = NULL;
	m_lpszDefaultObjectCategory = NULL;
	m_bSystemOnly = FALSE;

	// Initialize the property book keeping
	m_lppszAuxiliaryClasses = NULL;
	m_dwAuxiliaryClassesCount = 0;
	m_lppszSystemAuxiliaryClasses = NULL;
	m_dwSystemAuxiliaryClassesCount = 0;
	m_lppszPossibleSuperiors = NULL;
	m_dwPossibleSuperiorsCount = 0;
	m_lppszSystemPossibleSuperiors = NULL;
	m_dwSystemPossibleSuperiorsCount = 0;
	m_lppszMayContains = NULL;
	m_dwMayContainsCount = 0;
	m_lppszSystemMayContains = NULL;
	m_dwSystemMayContainsCount = 0;
	m_lppszMustContains = NULL;
	m_dwMustContainsCount = 0;
	m_lppszSystemMustContains = NULL;
	m_dwSystemMustContainsCount = 0;
}


//***************************************************************************
//
// CADSIClass :: ~CADSIClass
// 
// Purpose : Destructor
//***************************************************************************
CADSIClass :: ~CADSIClass()
{
	// Delete the WBEM Name. The ADSI Name is deleted in the base class destructor
	if ( m_lpszWBEMClassName )
	{
		delete [] m_lpszWBEMClassName;
		m_lpszWBEMClassName = NULL;
	}

	// Delete the attributes
	if ( m_lpszCommonName )
	{
		delete [] m_lpszCommonName;
		m_lpszCommonName = NULL;
	}
	if ( m_lpszSuperClassLDAPName )
	{
		delete [] m_lpszSuperClassLDAPName;
		m_lpszSuperClassLDAPName = NULL;
	}
	if ( m_lpszGovernsID )
	{
		delete [] m_lpszGovernsID;
		m_lpszGovernsID = NULL;
	}
	if ( m_pSchemaIDGUIDOctets ) 
	{
		delete [] m_pSchemaIDGUIDOctets;
		m_pSchemaIDGUIDOctets = NULL;
	}
	if ( m_lpszRDNAttribute )
	{
		delete [] m_lpszRDNAttribute;
		m_lpszRDNAttribute = NULL;
	}
	if ( m_lpszDefaultSecurityDescriptor )
	{
		delete [] m_lpszDefaultSecurityDescriptor;
		m_lpszDefaultSecurityDescriptor = NULL;
	}
	if ( m_pNTSecurityDescriptor )
	{
		delete [] m_pNTSecurityDescriptor;
		m_pNTSecurityDescriptor = NULL;
	}
	if ( m_lpszDefaultObjectCategory )
	{
		delete [] m_lpszDefaultObjectCategory;
		m_lpszDefaultObjectCategory = NULL;
	}

	DWORD i;
	// Delete the list of Auxiliary Classes
	if ( m_lppszAuxiliaryClasses )
	{
		for(i=0; i<m_dwAuxiliaryClassesCount; i++)
		{
			delete [] m_lppszAuxiliaryClasses[i];
			m_lppszAuxiliaryClasses[i] = NULL;
		}
		delete[] m_lppszAuxiliaryClasses;
		m_lppszAuxiliaryClasses = NULL;
	}

	// Delete the list of System Auxiliary Classes
	if ( m_lppszSystemAuxiliaryClasses )
	{
		for(i=0; i<m_dwSystemAuxiliaryClassesCount; i++)
		{
			delete [] m_lppszSystemAuxiliaryClasses[i];
			m_lppszSystemAuxiliaryClasses[i] = NULL;
		}
		delete[] m_lppszSystemAuxiliaryClasses;
		m_lppszSystemAuxiliaryClasses = NULL;
	}

	// Delete the list of possible superiors
	if ( m_lppszPossibleSuperiors )
	{
		for(i=0; i<m_dwPossibleSuperiorsCount; i++)
		{
			delete [] m_lppszPossibleSuperiors[i];
			m_lppszPossibleSuperiors[i] = NULL;
		}
		delete[] m_lppszPossibleSuperiors;
		m_lppszPossibleSuperiors = NULL;
	}

	// Delete the list of System possible superiors
	if ( m_lppszSystemPossibleSuperiors )
	{
		for(i=0; i<m_dwSystemPossibleSuperiorsCount; i++)
		{
			delete [] m_lppszSystemPossibleSuperiors[i];
			m_lppszSystemPossibleSuperiors[i] = NULL;
		}
		delete[] m_lppszSystemPossibleSuperiors;
		m_lppszSystemPossibleSuperiors = NULL;
	}

	// Delete the list of may contains
	if ( m_lppszMayContains )
	{
		for(i=0; i<m_dwMayContainsCount; i++)
		{
			delete [] m_lppszMayContains[i];
			m_lppszMayContains[i] = NULL;
		}
		delete[] m_lppszMayContains;
		m_lppszMayContains = NULL;
	}

	// Delete the list of System may contains
	if ( m_lppszSystemMayContains )
	{
		for(i=0; i<m_dwSystemMayContainsCount; i++)
		{
			delete [] m_lppszSystemMayContains[i];
			m_lppszSystemMayContains[i] = NULL;
		}
		delete[] m_lppszSystemMayContains;
		m_lppszSystemMayContains = NULL;
	}

	// Delete the list of Must Contains
	if ( m_lppszMustContains )
	{
		for(i=0; i<m_dwMustContainsCount; i++)
		{
			delete [] m_lppszMustContains[i];
			m_lppszMustContains[i] = NULL;
		}
		delete[] m_lppszMustContains;
		m_lppszMustContains = NULL;
	}

	// Delete the list of System Must Contains
	if ( m_lppszSystemMustContains )
	{
		for(i=0; i<m_dwSystemMustContainsCount; i++)
		{
			delete [] m_lppszSystemMustContains[i];
			m_lppszSystemMustContains[i] = NULL;
		}
		delete[] m_lppszSystemMustContains;
		m_lppszSystemMustContains = NULL;
	}

}


//***************************************************************************
//
// CADSIClass :: GetWBEMClassName
// 
// Purpose : Returns the WBEM  Class name of this Class
//***************************************************************************
LPCWSTR CADSIClass :: GetWBEMClassName()
{
	return m_lpszWBEMClassName;
}

//***************************************************************************
//
// CADSIClass :: GetWBEMClassName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass::SetWBEMClassName(LPCWSTR lpszName)
{
	if ( m_lpszWBEMClassName )
	{
		delete[] m_lpszWBEMClassName;
		m_lpszWBEMClassName = NULL;
	}

	if(lpszName)
	{
		m_lpszWBEMClassName = new WCHAR[wcslen(lpszName) + 1];
		wcscpy(m_lpszWBEMClassName, lpszName);
	}
}

//***************************************************************************
//
// CADSIClass :: GetADSIClassName
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetADSIClassName()
{
	return GetName();
}

//***************************************************************************
//
// CADSIClass :: GetADSIClassName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetADSIClassName(LPCWSTR lpszName)
{
	SetName(lpszName);
}

//***************************************************************************
//
// CADSIClass :: GetCommonName
// 
// Purpose : See Header
//
//***************************************************************************
LPCWSTR CADSIClass :: GetCommonName()
{
	return m_lpszCommonName;
}

//***************************************************************************
//
// CADSIClass :: SetCommonName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetCommonName(LPCWSTR lpszCommonName)
{
	if ( m_lpszCommonName )
	{
		delete[] m_lpszCommonName;
		m_lpszCommonName = NULL;
	}

	if(lpszCommonName)
	{
		m_lpszCommonName = new WCHAR[wcslen(lpszCommonName) + 1];
		wcscpy(m_lpszCommonName, lpszCommonName);
	}
}


//***************************************************************************
//
// CADSIClass :: GetSuperClassLDAPName
// 
// Purpose : See Header
//
//***************************************************************************
LPCWSTR CADSIClass :: GetSuperClassLDAPName()
{
	return m_lpszSuperClassLDAPName;
}

//***************************************************************************
//
// CADSIClass :: SetSuperClassLDAPName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSuperClassLDAPName(LPCWSTR lpszSuperClassLDAPName)
{
	if ( m_lpszSuperClassLDAPName )
	{
		delete[] m_lpszSuperClassLDAPName;
		m_lpszSuperClassLDAPName = NULL;
	}

	if(lpszSuperClassLDAPName)
	{
		m_lpszSuperClassLDAPName = new WCHAR[wcslen(lpszSuperClassLDAPName) + 1];
		wcscpy(m_lpszSuperClassLDAPName, lpszSuperClassLDAPName);
	}
}

//***************************************************************************
//
// CADSIClass :: GetGovernsID
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetGovernsID()
{
	return m_lpszGovernsID;
}

//***************************************************************************
//
// CADSIClass :: SetGovernsID
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetGovernsID(LPCWSTR lpszGovernsID)
{
	if ( m_lpszGovernsID )
	{
		delete[] m_lpszGovernsID;
		m_lpszGovernsID = NULL;
	}

	if(lpszGovernsID)
	{
		m_lpszGovernsID = new WCHAR[wcslen(lpszGovernsID) + 1];
		wcscpy(m_lpszGovernsID, lpszGovernsID);
	}
}

//***************************************************************************
//
// CADSIClass :: GetSchemaIDGUID
// 
// Purpose : See Header
//***************************************************************************
const LPBYTE CADSIClass :: GetSchemaIDGUID(DWORD *pdwLength)
{
	*pdwLength = m_dwSchemaIDGUIDLength;
	return m_pSchemaIDGUIDOctets;
}

//***************************************************************************
//
// CADSIClass :: SetSchemaIDGUID
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSchemaIDGUID(LPBYTE pOctets, DWORD dwLength)
{
	if ( m_pSchemaIDGUIDOctets )
	{
		delete[] m_pSchemaIDGUIDOctets;
		m_pSchemaIDGUIDOctets = NULL;
	}

	m_dwSchemaIDGUIDLength = 0;

	if(pOctets)
	{
		m_dwSchemaIDGUIDLength = dwLength;
		if(m_pSchemaIDGUIDOctets = new BYTE[dwLength])
		{
			for(DWORD i=0; i<dwLength; i++)
				m_pSchemaIDGUIDOctets[i] = pOctets[i];
		}
	}
}

//***************************************************************************
//
// CADSIClass :: GetRDNAttribute
// 
// Purpose : See Header
//
//***************************************************************************
LPCWSTR CADSIClass :: GetRDNAttribute()
{
	return m_lpszRDNAttribute;
}

//***************************************************************************
//
// CADSIClass :: SetRDNAttribute
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetRDNAttribute(LPCWSTR lpszRDNAttribute)
{
	if ( m_lpszRDNAttribute )
	{
		delete[] m_lpszRDNAttribute;
		m_lpszRDNAttribute = NULL;
	}

	if(lpszRDNAttribute)
	{
		m_lpszRDNAttribute = new WCHAR[wcslen(lpszRDNAttribute) + 1];
		wcscpy(m_lpszRDNAttribute, lpszRDNAttribute);
	}
}


//***************************************************************************
//
// CADSIClass :: GetDefaultSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetDefaultSecurityDescriptor()
{
	return m_lpszDefaultSecurityDescriptor;
}

//***************************************************************************
//
// CADSIClass :: SetDefaultSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetDefaultSecurityDescriptor(LPCWSTR lpszDefaultSecurityDescriptor)
{
	if ( m_lpszDefaultSecurityDescriptor )
	{
		delete[] m_lpszDefaultSecurityDescriptor;
		m_lpszDefaultSecurityDescriptor = NULL;
	}

	if( lpszDefaultSecurityDescriptor)
	{
		m_lpszDefaultSecurityDescriptor = new WCHAR[wcslen(lpszDefaultSecurityDescriptor) + 1];
		wcscpy(m_lpszDefaultSecurityDescriptor, lpszDefaultSecurityDescriptor);
	}
}

//***************************************************************************
//
// CADSIClass :: GetObjectClassCategory
// 
// Purpose : See Header
//***************************************************************************
DWORD CADSIClass :: GetObjectClassCategory()
{
	return m_dwObjectClassCategory;
}

//***************************************************************************
//
// CADSIClass :: SetObjectClassCategory
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetObjectClassCategory(DWORD dwObjectClassCategory)
{
	m_dwObjectClassCategory = dwObjectClassCategory;
}

//***************************************************************************
//
// CADSIClass :: GetNTSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
const LPBYTE CADSIClass :: GetNTSecurityDescriptor(DWORD *pdwLength)
{
	*pdwLength = m_dwNTSecurityDescriptorLength;
	return m_pNTSecurityDescriptor;
}

//***************************************************************************
//
// CADSIClass :: SetNTSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetNTSecurityDescriptor(LPBYTE pOctets, DWORD dwLength)
{
	if ( m_pNTSecurityDescriptor )
	{
		delete[] m_pNTSecurityDescriptor;
		m_pNTSecurityDescriptor = NULL;
	}

	m_dwNTSecurityDescriptorLength = 0;

	if(pOctets)
	{
		m_dwNTSecurityDescriptorLength = dwLength;
		if(m_pNTSecurityDescriptor = new BYTE[dwLength])
		{
			for(DWORD i=0; i<dwLength; i++)
				m_pNTSecurityDescriptor[i] = pOctets[i];
		}
	}
}

//***************************************************************************
//
// CADSIClass :: GetDefaultObjectCategory
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetDefaultObjectCategory()
{
	return m_lpszDefaultObjectCategory;
}

//***************************************************************************
//
// CADSIClass :: SetDefaultObjectCategory
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetDefaultObjectCategory(LPCWSTR lpszDefaultObjectCategory)
{
	if ( m_lpszDefaultObjectCategory )
	{
		delete[] m_lpszDefaultObjectCategory;
		m_lpszDefaultObjectCategory = NULL;
	}

	if (lpszDefaultObjectCategory)
	{
		m_lpszDefaultObjectCategory = new WCHAR[wcslen(lpszDefaultObjectCategory) + 1];
		wcscpy(m_lpszDefaultObjectCategory, lpszDefaultObjectCategory);
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemOnly
// 
// Purpose : See Header
//***************************************************************************
BOOLEAN CADSIClass :: GetSystemOnly()
{
	return m_bSystemOnly;
}

//***************************************************************************
//
// CADSIClass :: SetSystemOnly
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemOnly(BOOLEAN bSystemOnly)
{
	m_bSystemOnly = bSystemOnly;
}

//***************************************************************************
//
// CADSIClass :: GetAuxiliaryClasses
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetAuxiliaryClasses(DWORD *pdwCount)
{
	*pdwCount = m_dwAuxiliaryClassesCount;
	return (LPCWSTR *)m_lppszAuxiliaryClasses;
}

//***************************************************************************
//
// CADSIClass :: SetAuxiliaryClasses
// 
// Purpose : See Header

//***************************************************************************
void CADSIClass :: SetAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszAuxiliaryClasses )
	{
		for ( i = 0; i<m_dwAuxiliaryClassesCount; i++ )
		{
			if ( m_lppszAuxiliaryClasses [ i ] )
			{
				delete [] m_lppszAuxiliaryClasses [ i ];
				m_lppszAuxiliaryClasses [ i ] = NULL;
			}
		}

		delete [] m_lppszAuxiliaryClasses;
		m_lppszAuxiliaryClasses = NULL;
		m_dwAuxiliaryClassesCount = 0;
	}

	// Set the new list of values
	m_dwAuxiliaryClassesCount = dwNumValues;
	m_lppszAuxiliaryClasses = new LPWSTR[m_dwAuxiliaryClassesCount];
	for(i=0; i<m_dwAuxiliaryClassesCount; i++)
	{
		try
		{
			m_lppszAuxiliaryClasses[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszAuxiliaryClasses[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszAuxiliaryClasses )
			{
				m_dwAuxiliaryClassesCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszAuxiliaryClasses [ dw ] )
					{
						delete [] m_lppszAuxiliaryClasses [ dw ];
						m_lppszAuxiliaryClasses [ dw ] = NULL;
					}
				}

				delete [] m_lppszAuxiliaryClasses;
				m_lppszAuxiliaryClasses = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemAuxiliaryClasses
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemAuxiliaryClasses(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemAuxiliaryClassesCount;
	return (LPCWSTR *)m_lppszSystemAuxiliaryClasses;
}

//***************************************************************************
//
// CADSIClass :: SetSystemAuxiliaryClasses
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszSystemAuxiliaryClasses )
	{
		for ( i = 0; i<m_dwSystemAuxiliaryClassesCount; i++ )
		{
			if ( m_lppszSystemAuxiliaryClasses [ i ] )
			{
				delete [] m_lppszSystemAuxiliaryClasses [ i ];
				m_lppszSystemAuxiliaryClasses [ i ] = NULL;
			}
		}

		delete [] m_lppszSystemAuxiliaryClasses;
		m_lppszSystemAuxiliaryClasses = NULL;
		m_dwSystemAuxiliaryClassesCount = 0;
	}
	
	// Set the new list of values
	m_dwSystemAuxiliaryClassesCount = dwNumValues;
	m_lppszSystemAuxiliaryClasses = new LPWSTR[m_dwSystemAuxiliaryClassesCount];
	for(i=0; i<m_dwSystemAuxiliaryClassesCount; i++)
	{
		try
		{
			m_lppszSystemAuxiliaryClasses[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszSystemAuxiliaryClasses[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszSystemAuxiliaryClasses )
			{
				m_dwSystemAuxiliaryClassesCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszSystemAuxiliaryClasses [ dw ] )
					{
						delete [] m_lppszSystemAuxiliaryClasses [ dw ];
						m_lppszSystemAuxiliaryClasses [ dw ] = NULL;
					}
				}

				delete [] m_lppszSystemAuxiliaryClasses;
				m_lppszSystemAuxiliaryClasses = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetPossibleSuperiors(DWORD *pdwCount)
{
	*pdwCount = m_dwPossibleSuperiorsCount;
	return (LPCWSTR *)m_lppszPossibleSuperiors;
}

//***************************************************************************
//
// CADSIClass :: SetPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszPossibleSuperiors )
	{
		for ( i = 0; i<m_dwPossibleSuperiorsCount; i++ )
		{
			if ( m_lppszPossibleSuperiors [ i ] )
			{
				delete [] m_lppszPossibleSuperiors [ i ];
				m_lppszPossibleSuperiors [ i ] = NULL;
			}
		}

		delete [] m_lppszPossibleSuperiors;
		m_lppszPossibleSuperiors = NULL;
		m_dwPossibleSuperiorsCount = 0;
	}

	// Set the new list of values
	m_dwPossibleSuperiorsCount = dwNumValues;
	m_lppszPossibleSuperiors = new LPWSTR[m_dwPossibleSuperiorsCount];
	for(i=0; i<m_dwPossibleSuperiorsCount; i++)
	{
		try
		{
			m_lppszPossibleSuperiors[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszPossibleSuperiors[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszPossibleSuperiors )
			{
				m_dwPossibleSuperiorsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszPossibleSuperiors [ dw ] )
					{
						delete [] m_lppszPossibleSuperiors [ dw ];
						m_lppszPossibleSuperiors [ dw ] = NULL;
					}
				}

				delete [] m_lppszPossibleSuperiors;
				m_lppszPossibleSuperiors = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemPossibleSuperiors(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemPossibleSuperiorsCount;
	return (LPCWSTR *)m_lppszSystemPossibleSuperiors;
}

//***************************************************************************
//
// CADSIClass :: SetSystemPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszSystemPossibleSuperiors )
	{
		for ( i = 0; i<m_dwSystemPossibleSuperiorsCount; i++ )
		{
			if ( m_lppszSystemPossibleSuperiors [ i ] )
			{
				delete [] m_lppszSystemPossibleSuperiors [ i ];
				m_lppszSystemPossibleSuperiors [ i ] = NULL;
			}
		}

		delete [] m_lppszSystemPossibleSuperiors;
		m_lppszSystemPossibleSuperiors = NULL;
		m_dwSystemPossibleSuperiorsCount = 0;
	}

	// Set the new list of values
	m_dwSystemPossibleSuperiorsCount = dwNumValues;
	m_lppszSystemPossibleSuperiors = new LPWSTR[m_dwSystemPossibleSuperiorsCount];
	for(i=0; i<m_dwSystemPossibleSuperiorsCount; i++)
	{
		try
		{
			m_lppszSystemPossibleSuperiors[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszSystemPossibleSuperiors[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszSystemPossibleSuperiors )
			{
				m_dwSystemPossibleSuperiorsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszSystemPossibleSuperiors [ dw ] )
					{
						delete [] m_lppszSystemPossibleSuperiors [ dw ];
						m_lppszSystemPossibleSuperiors [ dw ] = NULL;
					}
				}

				delete [] m_lppszSystemPossibleSuperiors;
				m_lppszSystemPossibleSuperiors = NULL;
			}

			throw;
		}

		pValues ++;
	}
}


//***************************************************************************
//
// CADSIClass :: GetMayContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetMayContains(DWORD *pdwCount)
{
	*pdwCount = m_dwMayContainsCount;
	return (LPCWSTR *)m_lppszMayContains;
}

//***************************************************************************
//
// CADSIClass :: SetMayContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetMayContains(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszMayContains )
	{
		for ( i = 0; i<m_dwMayContainsCount; i++ )
		{
			if ( m_lppszMayContains [ i ] )
			{
				delete [] m_lppszMayContains [ i ];
				m_lppszMayContains [ i ] = NULL;
			}
		}

		delete [] m_lppszMayContains;
		m_lppszMayContains = NULL;
		m_dwMayContainsCount = 0;
	}

	// Set the new list of values
	m_dwMayContainsCount = dwNumValues;
	m_lppszMayContains = new LPWSTR[m_dwMayContainsCount];
	for(i=0; i<m_dwMayContainsCount; i++)
	{
		try
		{
			m_lppszMayContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszMayContains[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszMayContains )
			{
				m_dwMayContainsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszMayContains [ dw ] )
					{
						delete [] m_lppszMayContains [ dw ];
						m_lppszMayContains [ dw ] = NULL;
					}
				}

				delete [] m_lppszMayContains;
				m_lppszMayContains = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemMayContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemMayContains(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemMayContainsCount;
	return (LPCWSTR *)m_lppszSystemMayContains;
}

//***************************************************************************
//
// CADSIClass :: SetSystemMayContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemMayContains(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszSystemMayContains )
	{
		for ( i = 0; i<m_dwSystemMayContainsCount; i++ )
		{
			if ( m_lppszSystemMayContains [ i ] )
			{
				delete [] m_lppszSystemMayContains [ i ];
				m_lppszSystemMayContains [ i ] = NULL;
			}
		}

		delete [] m_lppszSystemMayContains;
		m_lppszSystemMayContains = NULL;
		m_dwSystemMayContainsCount = 0;
	}

	// Set the new list of values
	m_dwSystemMayContainsCount = dwNumValues;
	m_lppszSystemMayContains = new LPWSTR[m_dwSystemMayContainsCount];
	for(i=0; i<m_dwSystemMayContainsCount; i++)
	{
		try
		{
			m_lppszSystemMayContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszSystemMayContains[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszSystemMayContains )
			{
				m_dwSystemMayContainsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszSystemMayContains [ dw ] )
					{
						delete [] m_lppszSystemMayContains [ dw ];
						m_lppszSystemMayContains [ dw ] = NULL;
					}
				}

				delete [] m_lppszSystemMayContains;
				m_lppszSystemMayContains = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetMustContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetMustContains(DWORD *pdwCount)
{
	*pdwCount = m_dwMustContainsCount;
	return (LPCWSTR *)m_lppszMustContains;
}

//***************************************************************************
//
// CADSIClass :: SetMustContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetMustContains(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszMustContains )
	{
		for ( i = 0; i<m_dwMustContainsCount; i++ )
		{
			if ( m_lppszMustContains [ i ] )
			{
				delete [] m_lppszMustContains [ i ];
				m_lppszMustContains [ i ] = NULL;
			}
		}

		delete [] m_lppszMustContains;
		m_lppszMustContains = NULL;
		m_dwMustContainsCount = 0;
	}

	// Set the new list of values
	m_dwMustContainsCount = dwNumValues;
	m_lppszMustContains = new LPWSTR[m_dwMustContainsCount];
	for(i=0; i<m_dwMustContainsCount; i++)
	{
		try
		{
			m_lppszMustContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszMustContains[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszMustContains )
			{
				m_dwMustContainsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszMustContains [ dw ] )
					{
						delete [] m_lppszMustContains [ dw ];
						m_lppszMustContains [ dw ] = NULL;
					}
				}

				delete [] m_lppszMustContains;
				m_lppszMustContains = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemMustContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemMustContains(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemMustContainsCount;
	return (LPCWSTR *)m_lppszSystemMustContains;
}

//***************************************************************************
//
// CADSIClass :: SetSystemMustContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemMustContains(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszSystemMustContains )
	{
		for ( i = 0; i<m_dwSystemMustContainsCount; i++ )
		{
			if ( m_lppszSystemMustContains [ i ] )
			{
				delete [] m_lppszSystemMustContains [ i ];
				m_lppszSystemMustContains [ i ] = NULL;
			}
		}

		delete [] m_lppszSystemMustContains;
		m_lppszSystemMustContains = NULL;
		m_dwSystemMustContainsCount = 0;
	}

	// Set the new list of values
	m_dwSystemMustContainsCount = dwNumValues;
	m_lppszSystemMustContains = new LPWSTR[m_dwSystemMustContainsCount];
	for(i=0; i<m_dwSystemMustContainsCount; i++)
	{
		try
		{
			m_lppszSystemMustContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszSystemMustContains[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszSystemMustContains )
			{
				m_dwSystemMustContainsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszSystemMustContains [ dw ] )
					{
						delete [] m_lppszSystemMustContains [ dw ];
						m_lppszSystemMustContains [ dw ] = NULL;
					}
				}

				delete [] m_lppszSystemMustContains;
				m_lppszSystemMustContains = NULL;
			}

			throw;
		}

		pValues ++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\adsihelp.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsihelp.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation the CADSIHelper class. This is
//	a class that has many static helper functions pertaining to ADSI
//***************************************************************************
/////////////////////////////////////////////////////////////////////////



#include <windows.h>
#include <activeds.h>

#include "adsihelp.h"


//***************************************************************************
//
// CADSiHelper::ProcessBSTRArrayProperty
//
// Purpose: Processes a variant containing an array of BSTR or a single BSTR
//
// Parameters:
//	pVariant : The variant to be processed
//	ppStrPropertyValue : The addres of the pointer to a BSTR array where the list of BSTRS representing
//		the ADSI paths of the derived classes will be put
//	lNumber : The number of elements in the retrieved array.
//
//
// Return Value: The COM value representing the return status. It is the responsibility
//	of the caller to release the array that is returned, as well as its contents. The varinat
//	passed in is not cleared
//
//***************************************************************************
HRESULT CADSIHelper :: ProcessBSTRArrayProperty(VARIANT *pVariant, BSTR **ppStrPropertyValues, LONG *lpNumber)
{
	HRESULT result = S_OK;
	VARIANT vTemp;
	if(pVariant->vt == VT_BSTR) // When the number of values is 1
	{
		*lpNumber = 1;
		*ppStrPropertyValues = new BSTR[*lpNumber];
		(*ppStrPropertyValues)[0] = SysAllocString(pVariant->bstrVal);
	}
	else if (pVariant->vt == (VT_VARIANT|VT_ARRAY) )
	{
		SAFEARRAY *pSafeArray = pVariant->parray;
		*lpNumber = 0;
		if(SUCCEEDED(result = SafeArrayGetUBound(pSafeArray, 1, lpNumber)) )
		{
			*ppStrPropertyValues = new BSTR[*lpNumber];
			for(LONG index=0L; index<(*lpNumber); index++)
			{
				if( FAILED( result = SafeArrayGetElement(pSafeArray, &index, (LPVOID)&vTemp) ))
				{
					// Reset the count to the actual number retrieved
					*lpNumber = index;
					break;
				}
				(*ppStrPropertyValues)[index] = SysAllocString(vTemp.bstrVal);
				VariantClear(&vTemp);
			}
		}
	}
	else
		result = E_FAIL;
	return result;
}

//***************************************************************************
//
// CADSiHelper :: DeallocateBSTRArray
//
// Purpose: Deallocates an array of BSTRs and its contents
//
// Parameters:
//	pStrPropertyValue : The pointer to the array to be deallocated
//	lNumber : The number of elements in the array.
//
//
// Return Value: None
//
//***************************************************************************
void CADSIHelper :: DeallocateBSTRArray(BSTR *pStrPropertyValue, LONG lNumber)
{
	for(lNumber--; lNumber>=0; lNumber--)
		SysFreeString(pStrPropertyValue[lNumber]);

	delete [] pStrPropertyValue;
	pStrPropertyValue = NULL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\adsihelp.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsihelp.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIHelper class. This is
//	a class that has many static helper functions pertaining to ADSI
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef ADSI_HELPER_H
#define ADSI_HELPER_H

class CADSIHelper
{
public:

	// Deallocates an array of BSTRs and its contents
	static void DeallocateBSTRArray(BSTR *pStrPropertyValue, LONG lNumber);

private:
	static HRESULT ProcessBSTRArrayProperty(
		VARIANT *pVariant, 
		BSTR **ppStrPropertyValues,
		LONG *pLong);
};

#endif /* ADSI_HELPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\adsiinst.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiinst.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the CADSIInstance which encapsulates an ADSI instance
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
// CADSIInstance::CADSIInstance
//
// Purpose : Constructor 
//
// Parameters:
	//  lpszADSIPath : The ADSI Path to the object
//***************************************************************************
CADSIInstance :: CADSIInstance(LPCWSTR lpszADSIPath, IDirectoryObject *pDirectoryObject)
	: CRefCountedObject(lpszADSIPath)
{
	m_pAttributes = NULL;
	m_dwNumAttributes = 0;
	m_pObjectInfo = NULL;

	m_pDirectoryObject = pDirectoryObject;
	m_pDirectoryObject->AddRef();
}


//***************************************************************************
//
// CADSIInstance :: ~CADSIInstance
// 
// Purpose : Destructor
//***************************************************************************
CADSIInstance :: ~CADSIInstance()
{
	// Free the attributes
	if(m_pAttributes)
		FreeADsMem((LPVOID *) m_pAttributes);

	if(m_pObjectInfo)
		FreeADsMem((LPVOID *) m_pObjectInfo);

	if(m_pDirectoryObject)
		m_pDirectoryObject->Release();
}

IDirectoryObject *CADSIInstance :: GetDirectoryObject()
{
	m_pDirectoryObject->AddRef();
	return m_pDirectoryObject;
}

//***************************************************************************
//
// CADSIInstance :: GetAttributes
// 
// Purpose : See header for details
//***************************************************************************
PADS_ATTR_INFO CADSIInstance :: GetAttributes(DWORD *pdwNumAttributes)
{
	*pdwNumAttributes = m_dwNumAttributes;
	return m_pAttributes;
}

//***************************************************************************
//
// CADSIInstance :: SetAttributes
// 
// Purpose : See header for details
//***************************************************************************
void  CADSIInstance :: SetAttributes(PADS_ATTR_INFO pAttributes, DWORD dwNumAttributes)
{
	// Go thru the attributes and release them
	if(m_pAttributes)
		FreeADsMem((LPVOID *) m_pAttributes);
	m_pAttributes = pAttributes;
	m_dwNumAttributes = dwNumAttributes;
}

//***************************************************************************
//
// CADSIInstance :: GetObjectInfo
// 
// Purpose : See header for details
//***************************************************************************
PADS_OBJECT_INFO CADSIInstance :: GetObjectInfo()
{
	return m_pObjectInfo;
}

//***************************************************************************
//
// CADSIInstance :: SetObjectInfo
// 
// Purpose : See header for details
//***************************************************************************
void  CADSIInstance :: SetObjectInfo(PADS_OBJECT_INFO pObjectInfo)
{
	// Go thru the attributes and release them
	if(m_pObjectInfo)
		FreeADsMem((LPVOID *) m_pObjectInfo);
	m_pObjectInfo = pObjectInfo;
}

//***************************************************************************
//
// CADSIInstance :: GetADSIClassName
// 
// Purpose : See header for details
//***************************************************************************
LPCWSTR CADSIInstance :: GetADSIClassName()
{
	if(m_pObjectInfo)
		return m_pObjectInfo->pszClassName;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\adsiclas.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiclas.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIClass which encapsulates an ADSI class
//
//***************************************************************************

#ifndef ADSI_CLASS_H
#define ADSI_CLASS_H


class CADSIClass : public CRefCountedObject
{

public:
	//***************************************************************************
	//
	// CADSIClass::CADSIClass
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//  lpszWBEMClassName : The WBEM name of the Class being created. A copy of this is made
	//  lpszADSIClassName : The ADSI name of the Class being created. A copy of this is made
	//***************************************************************************
	CADSIClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszADSIClassName);
	virtual ~CADSIClass();

	//***************************************************************************
	//
	// CADSIClass :: GetWBEMClassName
	// 
	// Purpose : Returns the WBEM  Class name of this Class
	//***************************************************************************
	LPCWSTR GetWBEMClassName();
	//***************************************************************************
	//
	// CADSIClass :: GetWBEMClassName
	// 
	// Purpose : Sets the WBEM  Class name of this Class
	//***************************************************************************
	void CADSIClass::SetWBEMClassName(LPCWSTR lpszName);

	//***************************************************************************
	//
	// CADSIClass :: GetADSIClassName
	// 
	// Purpose : Returns the ADSI  Class name of this Class
	//***************************************************************************
	LPCWSTR GetADSIClassName();

	//***************************************************************************
	//
	// CADSIClass :: SetADSIClassName
	// 
	// Purpose : Sets the ADSI  Class name of this Class
	//***************************************************************************
	void SetADSIClassName(LPCWSTR lpszName);

	//***************************************************************************
	//
	// CADSIClass :: GetCommonName
	// 
	// Purpose : Returns the CommonName attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the CommonName attribute name
	//
	//***************************************************************************
	LPCWSTR GetCommonName();

	//***************************************************************************
	//
	// CADSIClass :: SetCommonName
	// 
	// Purpose : Sets the CommonName attribute name for this class
	//
	// Parameters:
	//	The CommonName attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetCommonName(LPCWSTR lpszCommonName);

	//***************************************************************************
	//
	// CADSIClass :: GetSuperClassLDAPName
	// 
	// Purpose : Returns the SuperClassLDAPName name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SuperClassLDAPName name
	//
	//***************************************************************************
	LPCWSTR GetSuperClassLDAPName();

	//***************************************************************************
	//
	// CADSIClass :: SetSuperClassLDAPName
	// 
	// Purpose : Sets the SuperClassLDAPName for this class
	//
	// Parameters:
	//	The SuperClassLDAPName for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSuperClassLDAPName(LPCWSTR lpszSuperClassLDAPName);

	//***************************************************************************
	//
	// CADSIClass :: GetGovernsID
	// 
	// Purpose : Returns the GovernsID attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the GovernsID attribute name
	//
	//***************************************************************************
	LPCWSTR GetGovernsID();

	//***************************************************************************
	//
	// CADSIClass :: SetGovernsID
	// 
	// Purpose : Sets the GovernsID attribute name for this class
	//
	// Parameters:
	//	The GovernsID attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetGovernsID(LPCWSTR lpszGovernsID);

	//***************************************************************************
	//
	// CADSIClass :: GetSchemaIDGUID
	// 
	// Purpose : Returns the SchemaIDGUID attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SchemaIDGUID attribute name
	//
	//***************************************************************************
	const LPBYTE GetSchemaIDGUID(DWORD *pdwLength);

	//***************************************************************************
	//
	// CADSIClass :: SetSchemaIDGUID
	// 
	// Purpose : Sets the SchemaIDGUID attribute name for this class
	//
	// Parameters:
	//	The SchemaIDGUID attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSchemaIDGUID(LPBYTE pOctets, DWORD dwLength);

	//***************************************************************************
	//
	// CADSIClass :: GetRDNAttribute
	// 
	// Purpose : Returns the RDN attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the RDN attribute name
	//
	//***************************************************************************
	LPCWSTR GetRDNAttribute();

	//***************************************************************************
	//
	// CADSIClass :: SetRDNAttribute
	// 
	// Purpose : Sets the RDN attribute name for this class
	//
	// Parameters:
	//	The RDN attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetRDNAttribute(LPCWSTR lpszRDNName);

	//***************************************************************************
	//
	// CADSIClass :: GetDefaultSecurityDescriptor
	// 
	// Purpose : Returns the DefaultSecurityDescriptor attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the DefaultSecurityDescriptor attribute name
	//
	//***************************************************************************
	LPCWSTR GetDefaultSecurityDescriptor();

	//***************************************************************************
	//
	// CADSIClass :: SetDefaultSecurityDescriptor
	// 
	// Purpose : Sets the DefaultSecurityDescriptor attribute name for this class
	//
	// Parameters:
	//	The DefaultSecurityDescriptor attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetDefaultSecurityDescriptor(LPCWSTR lpszDefaultSecurityDescriptor);

	//***************************************************************************
	//
	// CADSIClass :: GetObjectClassCategory
	// 
	// Purpose : Returns the ObjectClassCategory attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the ObjectClassCategory attribute name
	//
	//***************************************************************************
	DWORD GetObjectClassCategory();

	//***************************************************************************
	//
	// CADSIClass :: SetObjectClassCategory
	// 
	// Purpose : Sets the ObjectClassCategory attribute name for this class
	//
	// Parameters:
	//	The ObjectClassCategory attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetObjectClassCategory(DWORD dwObjectClassCategory);

	//***************************************************************************
	//
	// CADSIClass :: GetNTSecurityDescriptor
	// 
	// Purpose : Returns the SchemaIDGUID attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SchemaIDGUID attribute name
	//
	//***************************************************************************
	const LPBYTE GetNTSecurityDescriptor(DWORD *pdwLength);

	//***************************************************************************
	//
	// CADSIClass :: SetNTSecurityDescriptor
	// 
	// Purpose : Sets the SetNTSecurityDescriptor attribute name for this class
	//
	// Parameters:
	//	The SetNTSecurityDescriptor attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetNTSecurityDescriptor(LPBYTE pOctets, DWORD dwLength);

	//***************************************************************************
	//
	// CADSIClass :: GetDefaultObjectCategory
	// 
	// Purpose : Returns the DefaultObjectCategory attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the DefaultObjectCategory attribute name
	//
	//***************************************************************************
	LPCWSTR GetDefaultObjectCategory();

	//***************************************************************************
	//
	// CADSIClass :: SetDefaultObjectCategory
	// 
	// Purpose : Sets the DefaultObjectCategory attribute name for this class
	//
	// Parameters:
	//	The DefaultObjectCategory attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetDefaultObjectCategory(LPCWSTR lpszDefaultObjectCategory);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemOnly
	// 
	// Purpose : Returns the SystemOnly attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SystemOnly attribute name
	//
	//***************************************************************************
	BOOLEAN GetSystemOnly();

	//***************************************************************************
	//
	// CADSIClass :: SetSystemOnly
	// 
	// Purpose : Sets the SystemOnly attribute name for this class
	//
	// Parameters:
	//	The SystemOnly attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemOnly(BOOLEAN bSystemOnly);

	//***************************************************************************
	//
	// CADSIClass :: GetAuxiliaryClasses
	// 
	// Purpose : Gets the list of auxiliary classes for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the auxiliary of this class
	//***************************************************************************
	LPCWSTR *GetAuxiliaryClasses(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetAuxiliaryClasses
	// 
	// Purpose : Sets the list of auxiliary classes for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemAuxiliaryClasses
	// 
	// Purpose : Gets the list of System auxiliary classes for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System auxiliary of this class
	//***************************************************************************
	LPCWSTR *GetSystemAuxiliaryClasses(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemAuxiliaryClasses
	// 
	// Purpose : Sets the list of System auxiliary classes for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetPossibleSuperiors
	// 
	// Purpose : Gets the list of possible superiors for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the possible superiors of this class
	//***************************************************************************
	LPCWSTR *GetPossibleSuperiors(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetPossibleSuperiors
	// 
	// Purpose : Sets the list of possible superiors for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemPossibleSuperiors
	// 
	// Purpose : Gets the list of System possible superiors for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System possible superiors of this class
	//***************************************************************************
	LPCWSTR *GetSystemPossibleSuperiors(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemPossibleSuperiors
	// 
	// Purpose : Sets the list of System possible superiors for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetMayContains
	// 
	// Purpose : Gets the list of May Contains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the May Contains of this class
	//***************************************************************************
	LPCWSTR *GetMayContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetMayContains
	// 
	// Purpose : Sets the list of MayContains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetMayContains(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemMayContains
	// 
	// Purpose : Gets the list of System MayC ontains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System May Contains of this class
	//***************************************************************************
	LPCWSTR *GetSystemMayContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemMayContains
	// 
	// Purpose : Sets the list of System May Contains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemMayContains(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetMustContains
	// 
	// Purpose : Gets the list of Must Contains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the Must Contains of this class
	//***************************************************************************
	LPCWSTR *GetMustContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetMustContains
	// 
	// Purpose : Sets the list of Must Contains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetMustContains(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemMustContains
	// 
	// Purpose : Gets the list of System Must Contains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System Must Contains of this class
	//***************************************************************************
	LPCWSTR *GetSystemMustContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemMustContains
	// 
	// Purpose : Sets the list of System Must Contains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemMustContains(PADSVALUE pValues, DWORD dwNumValues);

protected:
	// The WBEM name of this class
	LPWSTR m_lpszWBEMClassName;

	// The Common Name (cn) of this class
	LPWSTR m_lpszCommonName;

	// The LDAP Name of the super class
	LPWSTR m_lpszSuperClassLDAPName;

	// The GovernsID attribute
	LPWSTR m_lpszGovernsID;

	// The SchemaIDGUID attribute
	LPBYTE m_pSchemaIDGUIDOctets;
	DWORD m_dwSchemaIDGUIDLength;

	// The RDN Attribute for this class
	LPWSTR m_lpszRDNAttribute;

	// The Default Security Descriptor Attribute for this class
	LPWSTR m_lpszDefaultSecurityDescriptor;

	// The Object Class Category
	DWORD m_dwObjectClassCategory;

	// The NT Security Descriptor Attribute for this class
	LPBYTE m_pNTSecurityDescriptor;
	DWORD m_dwNTSecurityDescriptorLength;

	// The system-only attribute
	BOOLEAN m_bSystemOnly;

	// The Default Object Category
	LPWSTR m_lpszDefaultObjectCategory;

	// The list of auxiliary classes and its count
	LPWSTR *m_lppszAuxiliaryClasses;
	DWORD m_dwAuxiliaryClassesCount;

	// The list of System auxiliary classes and its count
	LPWSTR *m_lppszSystemAuxiliaryClasses;
	DWORD m_dwSystemAuxiliaryClassesCount;

	// The list of possible superiors and its count
	LPWSTR *m_lppszPossibleSuperiors;
	DWORD m_dwPossibleSuperiorsCount;

	// The list of System possible superiors and its count
	LPWSTR *m_lppszSystemPossibleSuperiors;
	DWORD m_dwSystemPossibleSuperiorsCount;

	// The list of may contains and its count
	LPWSTR *m_lppszMayContains;
	DWORD m_dwMayContainsCount;

	// The list of System may contains and its count
	LPWSTR *m_lppszSystemMayContains;
	DWORD m_dwSystemMayContainsCount;

	// The list of must contains and its count
	LPWSTR *m_lppszMustContains;
	DWORD m_dwMustContainsCount;

	// The list of System must contains and its count
	LPWSTR *m_lppszSystemMustContains;
	DWORD m_dwSystemMustContainsCount;

};

#endif /* ADSI_CLASS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\adsiinst.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiinst.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIInstance which encapsulates an ADSI instance
//
//***************************************************************************

#ifndef ADSI_INSTANCE_H
#define ADSI_INSTANCE_H


class CADSIInstance : public CRefCountedObject
{

public:
	//***************************************************************************
	//
	// CADSIInstance::CADSIInstance
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//  lpszADSIPath : The ADSI Path to the object
	//***************************************************************************
	CADSIInstance(LPCWSTR lpszADSIPath, IDirectoryObject *pObject);
	virtual ~CADSIInstance();

	//***************************************************************************
	//
	// CADSIInstance::GetDirectoryObject
	//
	// Purpose : Returns the IDirectoryObject interface on the Directory object 
	// It is the responsibility of the caller to Release() it when done.
	//
	//***************************************************************************
	IDirectoryObject *GetDirectoryObject();

	//***************************************************************************
	//
	// CADSIInstance :: GetADSIClassName
	// 
	// Purpose : Returns the class name of this instance
	//***************************************************************************
	LPCWSTR GetADSIClassName();

	PADS_ATTR_INFO GetAttributes(DWORD *pdwNumAttributes);
	void SetAttributes(PADS_ATTR_INFO pAttributes, DWORD dwNumAttributes);

	PADS_OBJECT_INFO GetObjectInfo();
	void SetObjectInfo(PADS_OBJECT_INFO pObjectInfo);

protected:
	// The Attribute list
	PADS_ATTR_INFO m_pAttributes;
	DWORD m_dwNumAttributes;

	// The object info
	PADS_OBJECT_INFO m_pObjectInfo;

	// The IDirectoryObject pointer
	IDirectoryObject *m_pDirectoryObject;
};

#endif /* ADSI_INSTANCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\adsiprop.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiprop.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the CADSIProperty which encapsulates an ADSI property
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
// CADSIProperty::CADSIProperty
//
// Purpose : Constructor 
//
// Parameters:
//	None
//***************************************************************************
CADSIProperty :: CADSIProperty()
	: CRefCountedObject(),

	m_lpszWBEMPropertyName ( NULL ),
	m_lpszSyntaxOID ( NULL ),
	m_bMultiValued ( FALSE ),
	m_lpszAttributeID ( NULL ),
	m_lpszCommonName ( NULL ),
	m_bSystemOnly ( FALSE ),
	m_pDirectoryObject ( NULL ),
	m_bORName ( FALSE )

{
}

//***************************************************************************
//
// CADSIProperty::CADSIProperty
//
// Purpose : Constructor 
//
// Parameters:
//  lpszWBEMPropertyName : The WBEM name of the property being created. A copy of this is made
//  lpszADSIPropertyName : The ADSI name of the property being created. A copy of this is made
//***************************************************************************
CADSIProperty :: CADSIProperty(LPCWSTR lpszWBEMPropertyName, LPCWSTR lpszADSIPropertyName)
	: CRefCountedObject(lpszADSIPropertyName),

	m_lpszWBEMPropertyName ( NULL ),
	m_lpszSyntaxOID ( NULL ),
	m_bMultiValued ( FALSE ),
	m_lpszAttributeID ( NULL ),
	m_lpszCommonName ( NULL ),
	m_bSystemOnly ( FALSE ),
	m_pDirectoryObject ( NULL ),
	m_bORName ( FALSE )

{
	m_lpszWBEMPropertyName = new WCHAR[wcslen(lpszWBEMPropertyName) + 1];
	wcscpy(m_lpszWBEMPropertyName, lpszWBEMPropertyName);
}


//***************************************************************************
//
// CADSIProperty :: ~CADSIProperty
// 
// Purpose : Destructor
//***************************************************************************
CADSIProperty :: ~CADSIProperty()
{
	if (m_lpszWBEMPropertyName)
	{
		delete [] m_lpszWBEMPropertyName;
	}

	if (m_lpszSyntaxOID)
	{
		delete [] m_lpszSyntaxOID;
	}

	if (m_lpszAttributeID)
	{
		delete [] m_lpszAttributeID;
	}

	if (m_lpszCommonName)
	{
		delete [] m_lpszCommonName;
	}

	if(m_pDirectoryObject)
		m_pDirectoryObject->Release();
}


//***************************************************************************
//
// CADSIProperty :: GetWBEMPropertyName
// 
// Purpose : Returns the WBEM  property name of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetWBEMPropertyName()
{
	return m_lpszWBEMPropertyName;
}

//***************************************************************************
//
// CADSIProperty :: SetWBEMPropertyName
// 
// Purpose : Sets the WBEM name of this property
//***************************************************************************
void CADSIProperty :: SetWBEMPropertyName(LPCWSTR lpszWBEMName)
{
	if (m_lpszWBEMPropertyName)
	{
		delete [] m_lpszWBEMPropertyName;
		m_lpszWBEMPropertyName = NULL;
	}

	if(lpszWBEMName)
	{
		m_lpszWBEMPropertyName = new WCHAR[wcslen(lpszWBEMName) + 1];
		wcscpy(m_lpszWBEMPropertyName, lpszWBEMName);
	}
		
}

//***************************************************************************
//
// CADSIProperty :: GetADSIPropertyName
// 
// Purpose : Returns the ADSI  property name of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetADSIPropertyName()
{
	return GetName();
}

//***************************************************************************
//
// CADSIProperty :: SetADSIPropertyName
// 
// Purpose : Sets the ADSI name of this property
//***************************************************************************
void CADSIProperty :: SetADSIPropertyName(LPCWSTR lpszADSIName)
{
	SetName(lpszADSIName);
}

//***************************************************************************
//
// CADSIProperty :: GetSyntaxOID
// 
// Purpose : Returns the ADSI Syntax OID of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetSyntaxOID()
{
	return m_lpszSyntaxOID;
}

//***************************************************************************
//
// CADSIProperty :: SetSyntaxOID
// 
// Purpose : Sets the ADSI Syntax OID of this property
//***************************************************************************
void CADSIProperty :: SetSyntaxOID(LPCWSTR lpszSyntaxOID)
{
	if (m_lpszSyntaxOID)
	{
		delete [] m_lpszSyntaxOID;
		m_lpszSyntaxOID = NULL;
	}

	if(lpszSyntaxOID)
	{
		m_lpszSyntaxOID = new WCHAR[wcslen(lpszSyntaxOID) + 1];
		wcscpy(m_lpszSyntaxOID, lpszSyntaxOID);
	}
}

//***************************************************************************
//
// CADSIProperty :: IsORName
// 
// Purpose : Returns whether the property is m_bORName
//***************************************************************************
BOOLEAN CADSIProperty :: IsORName()
{
	return m_bORName;
}

//***************************************************************************
//
// CADSIProperty :: SetORName
// 
// Purpose : Sets the m_bORName property of this property
//***************************************************************************
void CADSIProperty :: SetORName(BOOLEAN bORName)
{
	m_bORName = bORName;
}


//***************************************************************************
//
// CADSIProperty :: IsMultiValued
// 
// Purpose : Returns whether the property is multi valued
//***************************************************************************
BOOLEAN CADSIProperty :: IsMultiValued()
{
	return m_bMultiValued;
}

//***************************************************************************
//
// CADSIProperty :: SetMultiValued
// 
// Purpose : Sets the multi-valued property of this property
//***************************************************************************
void CADSIProperty :: SetMultiValued(BOOLEAN bMultiValued)
{
	m_bMultiValued = bMultiValued;
}

//***************************************************************************
//
// CADSIProperty :: IsSystemOnly
// 
// Purpose : Returns whether the property is SystemOnly
//***************************************************************************
BOOLEAN CADSIProperty :: IsSystemOnly()
{
	return m_bSystemOnly;
}

//***************************************************************************
//
// CADSIProperty :: SetSystemOnly
// 
// Purpose : Sets the SystemOnly property of this property
//***************************************************************************
void CADSIProperty :: SetSystemOnly(BOOLEAN bSystemOnly)
{
	m_bSystemOnly = bSystemOnly;
}

//***************************************************************************
//
// CADSIProperty :: GetSearchFlags
// 
// Purpose : Returns the SearchFlags property of the property
//***************************************************************************
DWORD CADSIProperty :: GetSearchFlags()
{
	return m_dwSearchFlags;
}

//***************************************************************************
//
// CADSIProperty :: SetSearchFlags
// 
// Purpose : Sets the SearchFlags property of this property
//***************************************************************************
void CADSIProperty :: SetSearchFlags(DWORD dwSearchFlags)
{
	m_dwSearchFlags = dwSearchFlags;
}

//***************************************************************************
//
// CADSIProperty :: GetOMSyntax
// 
// Purpose : Returns the OMSyntax property of the property
//***************************************************************************
DWORD CADSIProperty :: GetOMSyntax()
{
	return m_dwOMSyntax;
}

//***************************************************************************
//
// CADSIProperty :: SetOMSyntax
// 
// Purpose : Sets the OMSyntax property of this property
//***************************************************************************
void CADSIProperty :: SetOMSyntax(DWORD dwOMSyntax)
{
	m_dwOMSyntax = dwOMSyntax;
}

//***************************************************************************
//
// CADSIProperty :: GetMAPI_ID
// 
// Purpose : Returns the MAPI_ID property of the property
//***************************************************************************
DWORD CADSIProperty :: GetMAPI_ID()
{
	return m_dwMAPI_ID;
}

//***************************************************************************
//
// CADSIProperty :: SetMAPI_ID
// 
// Purpose : Sets the MAPI_ID property of this property
//***************************************************************************
void CADSIProperty :: SetMAPI_ID(DWORD dwMAPI_ID)
{
	m_dwMAPI_ID = dwMAPI_ID;
}

//***************************************************************************
//
// CADSIProperty :: GetAttributeID
// 
// Purpose : Returns the Attribute ID of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetAttributeID()
{
	return m_lpszAttributeID;
}

//***************************************************************************
//
// CADSIProperty :: SetAttributeID
// 
// Purpose : Sets the Attribute ID of this property
//***************************************************************************
void CADSIProperty :: SetAttributeID(LPCWSTR lpszAttributeID)
{
	if ( m_lpszAttributeID )
	{
		delete [] m_lpszAttributeID;
		m_lpszAttributeID = NULL;
	}

	if(lpszAttributeID)
	{
		m_lpszAttributeID = new WCHAR[wcslen(lpszAttributeID) + 1];
		wcscpy(m_lpszAttributeID, lpszAttributeID);
	}
}

//***************************************************************************
//
// CADSIProperty :: GetCommonName
// 
// Purpose : Returns the Common Name of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetCommonName()
{
	return m_lpszCommonName;
}

//***************************************************************************
//
// CADSIProperty :: SetCommonName
// 
// Purpose : Sets the CommonName of this property
//***************************************************************************
void CADSIProperty :: SetCommonName(LPCWSTR lpszCommonName)
{
	if (m_lpszCommonName)
	{
		delete [] m_lpszCommonName;
		m_lpszCommonName = NULL;
	}

	if(lpszCommonName)
	{
		m_lpszCommonName = new WCHAR[wcslen(lpszCommonName) + 1];
		wcscpy(m_lpszCommonName, lpszCommonName);
	}
}

//***************************************************************************
//
// CADSIProperty :: GetDirectoryObject
// 
// Purpose : Returns the ADSI object pertaining to this property
//	It is the user's duty to release it when done
// 
// Parameters:
//	None
//
// Return Value:
//	The ADSI object interface pertaining to this property	
//***************************************************************************
IDirectoryObject *CADSIProperty :: GetDirectoryObject()
{
	if(m_pDirectoryObject)
		m_pDirectoryObject->AddRef();
	return m_pDirectoryObject;
}

//***************************************************************************
//
// CADSIProperty :: SetDirectoryObject
// 
// Purpose : Sets the ADSI object pertaining to this property
//
// Parameter : The directory object pertaining to this property
//***************************************************************************
void CADSIProperty :: SetDirectoryObject(IDirectoryObject * pDirectoryObject)
{
	if(m_pDirectoryObject)
		m_pDirectoryObject->Release();
	m_pDirectoryObject = pDirectoryObject;
	m_pDirectoryObject->AddRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\adsiprop.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiprop.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIProperty which encapsulates an ADSI property. The syntax of an ADSI Property
// is based on the values of the following 3 attributes:
// Attribute Syntax : This is an OID
// OMSyntax: This is an integer
// OMObjectClass : This is an octet string
// For all the syntaxes in the AD, the value om Attribute Syntax is enough for our purposes of
// mapping to a CIM Syntax since values of instances of these properties come mapped to the same
// ADS_TYPE if the value of their OMSyntax is same. Except for the syntaxes Object(OR-Name) and DN_With_Binary
// which have the same value for OMSyntax and Attribute Syntax, but are differentiated based on the value
// of the OMObjectClass. Hence instead of storing the value of OMObjectClass (which is an LPBYTE value) for
// every attribute, we just store one BOOLEAN value isORName which tells us whether the syntax is OR-Name or DN_With_Binary.
// Call it a hack, optimization whatever.
//
//***************************************************************************

#ifndef ADSI_PROPERTY_H
#define ADSI_PROPERTY_H


class CADSIProperty : public CRefCountedObject
{

public:

	//***************************************************************************
	//
	// CADSIProperty::CADSIProperty
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//	
	//	None
	//***************************************************************************
	CADSIProperty();

	//***************************************************************************
	//
	// CADSIProperty::CADSIProperty
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//  lpszWBEMPropertyName : The WBEM name of the property being created. A copy of this is made
	//  lpszADSIPropertyName : The ADSI name of the property being created. A copy of this is made
	//***************************************************************************
	CADSIProperty(LPCWSTR lpszWBEMPropertyName, LPCWSTR lpszADSIPropertyName);

	//***************************************************************************
	//
	// CADSIProperty :: ~CADSIProperty
	// 
	// Purpose : Destructor
	//***************************************************************************
	virtual ~CADSIProperty();

	//***************************************************************************
	//
	// CADSIProperty :: GetWBEMPropertyName
	// 
	// Purpose : Returns the WBEM  property name of this property
	//***************************************************************************
	LPCWSTR GetWBEMPropertyName();

	//***************************************************************************
	//
	// CADSIProperty :: SetWBEMPropertyName
	// 
	// Purpose : Sets the WBEM name of this property
	//***************************************************************************
	void SetWBEMPropertyName(LPCWSTR lpszWBEMName);

	//***************************************************************************
	//
	// CADSIProperty :: GetADSIPropertyName
	// 
	// Purpose : Returns the ADSI  property name of this property
	//***************************************************************************
	LPCWSTR GetADSIPropertyName();

	//***************************************************************************
	//
	// CADSIProperty :: SetADSIPropertyName
	// 
	// Purpose : Sets the ADSI name of this property
	//***************************************************************************
	void SetADSIPropertyName(LPCWSTR lpszADSIName);

	//***************************************************************************
	//
	// CADSIProperty :: GetSyntaxOID
	// 
	// Purpose : Returns the ADSI Syntax OID of this property
	//***************************************************************************
	LPCWSTR GetSyntaxOID();

	//***************************************************************************
	//
	// CADSIProperty :: SetSyntaxOID
	// 
	// Purpose : Sets the ADSI Syntax OID of this property
	//***************************************************************************
	void SetSyntaxOID(LPCWSTR lpszSystaxOID);

	//***************************************************************************
	//
	// CADSIProperty :: IsORName
	// 
	// Purpose : Returns whether the property has a syntax of Object(OR-Name).
	//***************************************************************************
	BOOLEAN IsORName();

	//***************************************************************************
	//
	// CADSIProperty :: SetORName
	// 
	// Purpose : Sets the m_bORName property of this property
	//***************************************************************************
	void SetORName(BOOLEAN bORName);


	//***************************************************************************
	//
	// CADSIProperty :: IsMultiValued
	// 
	// Purpose : Returns whether the property is multi valued
	//***************************************************************************
	BOOLEAN IsMultiValued();

	//***************************************************************************
	//
	// CADSIProperty :: SetMultiValued
	// 
	// Purpose : Sets the multi-valued property of this property
	//***************************************************************************
	void SetMultiValued(BOOLEAN bMultiValued);

	//***************************************************************************
	//
	// CADSIProperty :: IsSystemOnly
	// 
	// Purpose : Returns whether the property is SystemOnly
	//***************************************************************************
	BOOLEAN IsSystemOnly();

	//***************************************************************************
	//
	// CADSIProperty :: SetSystemOnly
	// 
	// Purpose : Sets the SystemOnly property of this property
	//***************************************************************************
	void SetSystemOnly(BOOLEAN bSystemOnly);

	//***************************************************************************
	//
	// CADSIProperty :: GetSearchFlags
	// 
	// Purpose : Returns the SearchFlags property of the property
	//***************************************************************************
	DWORD GetSearchFlags();

	//***************************************************************************
	//
	// CADSIProperty :: SetSearchFlags
	// 
	// Purpose : Sets the SearchFlags property of this property
	//***************************************************************************
	void SetSearchFlags(DWORD dwSearchFlags);

	//***************************************************************************
	//
	// CADSIProperty :: GetOMSyntax
	// 
	// Purpose : Returns the OMSyntax property of the property
	//***************************************************************************
	DWORD GetOMSyntax();

	//***************************************************************************
	//
	// CADSIProperty :: SetOMSyntax
	// 
	// Purpose : Sets the OMSyntax property of this property
	//***************************************************************************
	void SetOMSyntax(DWORD dwOMSyntax);

	//***************************************************************************
	//
	// CADSIProperty :: GetMAPI_ID
	// 
	// Purpose : Returns the MAPI_ID property of the property
	//***************************************************************************
	DWORD GetMAPI_ID();

	//***************************************************************************
	//
	// CADSIProperty :: SetMAPI_ID
	// 
	// Purpose : Sets the MAPI_ID property of this property
	//***************************************************************************
	void SetMAPI_ID(DWORD dwMAPI_ID);


	//***************************************************************************
	//
	// CADSIProperty :: GetAttributeID
	// 
	// Purpose : Returns the Attribute ID of this property
	//***************************************************************************
	LPCWSTR GetAttributeID();

	//***************************************************************************
	//
	// CADSIProperty :: SetAttributeID
	// 
	// Purpose : Sets the Attribute ID of this property
	//***************************************************************************
	void SetAttributeID(LPCWSTR lpszAttributeID);

	//***************************************************************************
	//
	// CADSIProperty :: GetCommonName
	// 
	// Purpose : Returns the Common Name of this property
	//***************************************************************************
	LPCWSTR GetCommonName();

	//***************************************************************************
	//
	// CADSIProperty :: SetCommonName
	// 
	// Purpose : Sets the CommonName of this property
	//***************************************************************************
	void SetCommonName(LPCWSTR lpszCommonName);

	//***************************************************************************
	//
	// CADSIProperty :: GetDirectoryObject
	// 
	// Purpose : Returns the ADSI object pertaining to this property
	//	It is the user's duty to release it when done
	// 
	// Parameters:
	//	None
	//
	// Return Value:
	//	The ADSI object interface pertaining to this property	
	//***************************************************************************
	IDirectoryObject *GetDirectoryObject();

	//***************************************************************************
	//
	// CADSIProperty :: SetDirectoryObject
	// 
	// Purpose : Sets the ADSI object pertaining to this property
	//
	// Parameter : The directory object pertaining to this property
	//***************************************************************************
	void SetDirectoryObject(IDirectoryObject *pDirectoryObject);


protected:
	// The WBEM name of this property
	LPWSTR m_lpszWBEMPropertyName;

	// The ADSI interface for the object representing this property
	IDirectoryObject * m_pDirectoryObject;

	// The Syntax OID
	LPWSTR m_lpszSyntaxOID;

	// Used to differentiate between the syntaxes Object(OR-Name) and DN_with_Binary
	// See the beginning of this file for a detailed explanation of this.
	BOOLEAN m_bORName;

	// Whether it is multi valued
	BOOLEAN m_bMultiValued;

	// The Attribute ID
	LPWSTR m_lpszAttributeID;

	// The Common Name
	LPWSTR m_lpszCommonName;

	// Whether this property is SystemOnly
	BOOLEAN m_bSystemOnly;

	// Search Flags
	DWORD m_dwSearchFlags;

	// MAPI ID
	DWORD m_dwMAPI_ID;

	// OM Syntax
	DWORD m_dwOMSyntax;
};

#endif /* ADSI_PROPERTY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\assocprov.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classpro.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the DS Class Associations Provider class. 
//
//***************************************************************************

#include "precomp.h"

/////////////////////////////////////////
// Initialize the static members
/////////////////////////////////////////
LPCWSTR CLDAPClassAsssociationsProvider :: s_LogFileName			= L"wbem\\logs\\ldapascl.txt";
LPCWSTR CLDAPClassAsssociationsProvider :: CHILD_CLASS_PROPERTY		= L"ChildClass";
LPCWSTR CLDAPClassAsssociationsProvider :: PARENT_CLASS_PROPERTY	= L"ParentClass";
LPCWSTR CLDAPClassAsssociationsProvider :: POSSIBLE_SUPERIORS		= L"PossibleSuperiors";
LPCWSTR CLDAPClassAsssociationsProvider :: SCHEMA_NAMING_CONTEXT	= L"schemaNamingContext";
LPCWSTR CLDAPClassAsssociationsProvider :: LDAP_SCHEMA				= L"LDAP://Schema";	
LPCWSTR CLDAPClassAsssociationsProvider :: LDAP_SCHEMA_SLASH		= L"LDAP://Schema/";	

//***************************************************************************
//
// CLDAPClassAsssociationsProvider::CLDAPClassAsssociationsProvider
// CLDAPClassAsssociationsProvider::~CLDAPClassAsssociationsProvider
//
// Constructor Parameters:
//
//  
//***************************************************************************

CLDAPClassAsssociationsProvider :: CLDAPClassAsssociationsProvider ()
{
	InterlockedIncrement(&g_lComponents);

	m_lReferenceCount = 0 ;
	m_IWbemServices = NULL;
	m_pAssociationClass = NULL;

	m_lpszSchemaContainerSuffix = NULL;
	m_pDirectorySearchSchemaContainer = NULL;
	m_bInitializedSuccessfully = FALSE;

	CHILD_CLASS_PROPERTY_STR = SysAllocString(CHILD_CLASS_PROPERTY);
	PARENT_CLASS_PROPERTY_STR = SysAllocString(PARENT_CLASS_PROPERTY);
	CLASS_ASSOCIATION_CLASS_STR = SysAllocString(CLASS_ASSOCIATION_CLASS);
	POSSIBLE_SUPERIORS_STR = SysAllocString(POSSIBLE_SUPERIORS);
}

CLDAPClassAsssociationsProvider::~CLDAPClassAsssociationsProvider ()
{
	g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: DESTRUCTOR\r\n");

	if(m_IWbemServices)
		m_IWbemServices->Release();

	if(m_pDirectorySearchSchemaContainer)
		m_pDirectorySearchSchemaContainer->Release();

	if(m_pAssociationClass)
		m_pAssociationClass->Release();

	if (m_lpszSchemaContainerSuffix)
	{
		delete [] m_lpszSchemaContainerSuffix;
	}

	SysFreeString(CHILD_CLASS_PROPERTY_STR);
	SysFreeString(PARENT_CLASS_PROPERTY_STR);
	SysFreeString(CLASS_ASSOCIATION_CLASS_STR);
	SysFreeString(POSSIBLE_SUPERIORS_STR);

	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CLDAPClassAsssociationsProvider::QueryInterface
// CLDAPClassAsssociationsProvider::AddRef
// CLDAPClassAsssociationsProvider::Release
//
// Purpose: Standard COM routines needed for all COM objects
//
//***************************************************************************

STDMETHODIMP CLDAPClassAsssociationsProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) (IUnknown *)(IWbemProviderInit *)this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) (IWbemServices *)this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) (IWbemProviderInit *)this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CLDAPClassAsssociationsProvider :: AddRef ()
{
	return InterlockedIncrement ( & m_lReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CLDAPClassAsssociationsProvider :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_lReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT CLDAPClassAsssociationsProvider :: Initialize( 
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{

	// Validate the arguments
	if(pNamespace == NULL || lFlags != 0)
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();
		
	// Do LDAP Provider initialization
	if(!InitializeAssociationsProvider(pCtx))
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: InitializeAssociationsProvider FAILED\r\n");
		m_IWbemServices->Release();
		m_IWbemServices = NULL;
		m_bInitializedSuccessfully = FALSE;
	}
	else
		m_bInitializedSuccessfully = TRUE;

	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPClassAsssociationsProvider :: OpenNamespace( 
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CancelAsyncCall( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: QueryObjectSink( 
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: GetObject( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: GetObjectAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{

	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() called for %s \r\n", strObjectPath);

	HRESULT result = S_OK;

	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
		return WBEM_E_FAILED;
	}

	// Validate the arguments
	if(strObjectPath == NULL || lFlags != 0) 
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() argument validation FAILED\r\n");
		return WBEM_E_INVALID_PARAMETER;
	}

	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
			break;
		default:
			g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() object path parsing FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
	}

	// Check whether there are exactly 2 keys specified
	if(theParsedObjectPath->m_dwNumKeys != 2)
		result = WBEM_E_INVALID_PARAMETER;

	// Check whether these keys are 
	KeyRef *pChildKeyRef = *(theParsedObjectPath->m_paKeys);
	KeyRef *pParentKeyRef = *(theParsedObjectPath->m_paKeys + 1);

	if(_wcsicmp(pChildKeyRef->m_pName, CHILD_CLASS_PROPERTY) != 0)
	{
		// Exchange them
		KeyRef *temp = pChildKeyRef;
		pChildKeyRef = pParentKeyRef;
		pParentKeyRef = pChildKeyRef;
	}

	// The status on the sink
	IWbemClassObject *ppReturnWbemClassObjects[1];
	ppReturnWbemClassObjects[0] = NULL;

	if(SUCCEEDED(result))
	{
		if(SUCCEEDED(result = IsContainedIn(pChildKeyRef->m_vValue.bstrVal, pParentKeyRef->m_vValue.bstrVal)))
		{
			if(result == S_OK)
			{
				if(SUCCEEDED(result = CreateInstance(pChildKeyRef->m_vValue.bstrVal, pParentKeyRef->m_vValue.bstrVal, ppReturnWbemClassObjects)))
				{
					result = pResponseHandler->Indicate(1, ppReturnWbemClassObjects);
					ppReturnWbemClassObjects[0]->Release();
				}

			}
			else // the instance was not found
			{
				g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: returning WBEM_E_NOT_FOUND for %s \r\n", strObjectPath);
				result = WBEM_E_NOT_FOUND;
			}
		}
		else
		{
			g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: IsContainedIn() FAILED with %x \r\n", result);
		}
	}

	// Free the parser object path
	theParser.Free(theParsedObjectPath);

	// Set the status of the request
	result = (SUCCEEDED(result)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND);
	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , result, NULL, NULL);
	
	return result;
}

HRESULT CLDAPClassAsssociationsProvider :: PutClass( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: PutClassAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteClass( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteClassAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateClassEnum( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateClassEnumAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: PutInstance( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteInstance( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteInstanceAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateInstanceEnum( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync() called\r\n");

	HRESULT result = S_OK;

	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync() CoImpersonate FAILED with %x\r\n", result);
		return WBEM_E_FAILED;
	}

	// Get all the ADSI classes 
	result = DoEnumeration(pResponseHandler);

			
	if(SUCCEEDED(result))
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync()  enumeration succeeded\r\n");
		return WBEM_S_NO_ERROR;
	}
	else
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync() enumeration FAILED\r\n");
		return WBEM_E_FAILED;
	}	
	
	return result;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecNotificationQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecNotificationQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecMethod( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecMethodAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}


//***************************************************************************
//
// CLDAPClassAsssociationsProvider::IsContainedIn
//
// Purpose: Checks whether a containment is valid
//
// Parameters: 
//	lpszChildClass : The WBEM Name of the child class
//	lpszParentClass : The WBEM Name of the parent class
//
// Return Value: The COM status of the request
//
//***************************************************************************
HRESULT CLDAPClassAsssociationsProvider :: IsContainedIn(LPCWSTR lpszChildClass, LPCWSTR lpszParentClass)
{
	LPWSTR lpszLDAPChildClass = NULL;
	LPWSTR lpszLDAPParentClass = NULL;
	lpszLDAPChildClass = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszChildClass);
	lpszLDAPParentClass = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszParentClass);

	// Check whether these are valid names
	if(!lpszLDAPChildClass || !lpszLDAPParentClass)
	{
		if (lpszLDAPChildClass)
		{
			delete [] lpszLDAPChildClass;
			lpszLDAPChildClass = NULL ;
		}

		if (lpszLDAPParentClass)
		{
			delete [] lpszLDAPParentClass;
			lpszLDAPParentClass = NULL;
		}

		return S_FALSE;
	}

	LPWSTR lpszADSIAbstractSchemaPath = new WCHAR[wcslen(LDAP_SCHEMA_SLASH) + wcslen(lpszLDAPChildClass) + 1];
	wcscpy(lpszADSIAbstractSchemaPath, LDAP_SCHEMA_SLASH);
	wcscat(lpszADSIAbstractSchemaPath, lpszLDAPChildClass);

	IADsClass *pADsChildClass;
	HRESULT result;
	if(SUCCEEDED(result = ADsOpenObject(lpszADSIAbstractSchemaPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsClass, (LPVOID *) &pADsChildClass)))
	{
		// Get the POSSIBLE_SUPERIORS_STR property. This property contains the possible superiors
		VARIANT variant;
		VariantInit(&variant);
		if(SUCCEEDED(result = pADsChildClass->get_PossibleSuperiors(&variant)))
		{
			// Check the lone possible superior
			if(variant.vt == VT_BSTR)
			{
				if(_wcsicmp(variant.bstrVal, lpszLDAPParentClass) == 0)
					result = S_OK;
				else
					result = S_FALSE;
			}
			else
			{
				// Go thru the list of possible superiorsV
				SAFEARRAY *pSafeArray = variant.parray;
				LONG lNumber = 0;
				VARIANT vTmp;
				if(SUCCEEDED(result = SafeArrayGetUBound(pSafeArray, 1, &lNumber)) )
				{
					result = S_FALSE;
					for(LONG index=0L; index<=lNumber; index++)
					{
						if(SUCCEEDED(SafeArrayGetElement(pSafeArray, &index, &vTmp) ))
						{
							if(_wcsicmp(vTmp.bstrVal, lpszLDAPParentClass) == 0)
							{
								result = S_OK;
							}
							VariantClear(&vTmp);
							if(result == S_OK)
								break;
						}
					}
				}
			}

			VariantClear(&variant);
		}
		pADsChildClass->Release();
	}

	delete [] lpszLDAPChildClass;
	delete [] lpszLDAPParentClass;
	delete [] lpszADSIAbstractSchemaPath;

	return result;
}

//***************************************************************************
//
// CLDAPClassAsssociationsProvider::InitializeAssociationsProvider
//
// Purpose: A helper function to do the ADSI LDAP provider specific initialization.
//
// Parameters:
//		pCtx	The context object used in this call initialization
// 
// Return Value: TRUE if the function successfully finishes the initializaion. FALSE
//	otherwise
//***************************************************************************
BOOLEAN CLDAPClassAsssociationsProvider :: InitializeAssociationsProvider(IWbemContext *pCtx)
{
	// Get the class for which instances are provided by the provider
	HRESULT result = m_IWbemServices->GetObject(CLASS_ASSOCIATION_CLASS_STR, 0, pCtx, &m_pAssociationClass, NULL);
	if(SUCCEEDED(result))
	{
		// Get the ADSI path of the schema container and store it for future use
		IADs *pRootDSE = NULL;
		if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pRootDSE)))
		{
			// Get the location of the schema container
			BSTR strSchemaPropertyName = SysAllocString((LPWSTR) SCHEMA_NAMING_CONTEXT);

			// Get the schemaNamingContext property. This property contains the ADSI path
			// of the schema container
			VARIANT variant;
			VariantInit(&variant);
			if(SUCCEEDED(result = pRootDSE->Get(strSchemaPropertyName, &variant)))
			{
				// Store the ADSI path to the schema container
				m_lpszSchemaContainerSuffix = new WCHAR[wcslen(variant.bstrVal) + 1];
				wcscpy(m_lpszSchemaContainerSuffix, variant.bstrVal );
				g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Got Schema Container as : %s\r\n", m_lpszSchemaContainerSuffix);

				// Form the schema container path
				LPWSTR lpszSchemaContainerPath = new WCHAR[wcslen(LDAP_PREFIX) + wcslen(m_lpszSchemaContainerSuffix) + 1];
				wcscpy(lpszSchemaContainerPath, LDAP_PREFIX);
				wcscat(lpszSchemaContainerPath, m_lpszSchemaContainerSuffix);
				if(SUCCEEDED(result = ADsOpenObject(lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
				{
					g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Got IDirectorySearch on Schema Container \r\n");
				}
				else
					g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: FAILED to get IDirectorySearch on Schema Container : %x\r\n", result);

				delete[] lpszSchemaContainerPath;
			}
			else
				g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Get on RootDSE FAILED : %x\r\n", result);

			SysFreeString(strSchemaPropertyName);
			VariantClear(&variant);
			pRootDSE->Release();
		}
		else
			g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: InitializeLDAPProvider ADsOpenObject on RootDSE FAILED : %x\r\n", result);
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: InitializeLDAPProvider GetClass on LDAP Association class FAILED : %x\r\n", result);

	return SUCCEEDED(result);
}

HRESULT CLDAPClassAsssociationsProvider :: DoEnumeration(IWbemObjectSink *pResponseHandler)
{
	HRESULT result = E_FAIL;

	// Get the IADsContainer interface on the schema container
	IADsContainer *pADsContainer = NULL;
	IUnknown *pChild = NULL;

	// An instance of the association
	IWbemClassObject *pInstance = NULL;

	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)LDAP_SCHEMA, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsContainer, (LPVOID *) &pADsContainer)))
	{
		IEnumVARIANT *pEnum = NULL;
		if(SUCCEEDED(result = ADsBuildEnumerator(pADsContainer, &pEnum)))
		{
			IADsClass *pADsChildClass = NULL;
			VARIANT v;
			VariantInit(&v);
			while (SUCCEEDED(result = ADsEnumerateNext(pEnum, 1, &v, NULL)) && result != S_FALSE)
			{
				pChild = v.punkVal;
				if(SUCCEEDED(result = pChild->QueryInterface(IID_IADsClass, (LPVOID *) &pADsChildClass)))
				{
					BSTR strChildClassName;
					if(SUCCEEDED(result = pADsChildClass->get_Name(&strChildClassName)))
					{
						// Mangle the name to WBEM
						LPWSTR szChildName = CLDAPHelper::MangleLDAPNameToWBEM(strChildClassName);
						VARIANT variant;
						VariantInit(&variant);
						if(SUCCEEDED(result = pADsChildClass->get_PossibleSuperiors(&variant)))
						{
							// Check the lone possible superior
							if(variant.vt == VT_BSTR)
							{
								LPWSTR szParentName = CLDAPHelper::MangleLDAPNameToWBEM(variant.bstrVal);
								if(SUCCEEDED(result = CreateInstance(szChildName, szParentName, &pInstance)))
								{
									pResponseHandler->Indicate(1, &pInstance);
									pInstance->Release();
								}
								delete [] szParentName;
							}
							else // It is an array of variants
							{
								// Go thru the list of possible superiorsV
								SAFEARRAY *pSafeArray = variant.parray;
								VARIANT HUGEP *pVar;
								LONG lUbound = 0, lLbound = 0;
								if(SUCCEEDED(result = SafeArrayAccessData(pSafeArray, (void HUGEP* FAR*)&pVar) ) )
								{
									if( SUCCEEDED (result = SafeArrayGetLBound(pSafeArray, 1, &lLbound)) &&
										SUCCEEDED (result = SafeArrayGetUBound(pSafeArray, 1, &lUbound)) )
									{
										for(LONG index=lLbound; index<=lUbound; index++)
										{
											LPWSTR szParentName = CLDAPHelper::MangleLDAPNameToWBEM(pVar[index].bstrVal);
											if(SUCCEEDED(result = CreateInstance(szChildName, szParentName, &pInstance)))
											{
												pResponseHandler->Indicate(1, &pInstance);
												pInstance->Release();
											}
											delete [] szParentName;
										}
									}
									SafeArrayUnaccessData(pSafeArray);
								}
							}
							VariantClear(&variant);
						}
						delete [] szChildName;
						SysFreeString(strChildClassName);
					}
					pADsChildClass->Release();
				}
				VariantClear(&v);
			}
			ADsFreeEnumerator(pEnum);
		}

		pADsContainer->Release();
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: FAILED to get IDirectoryObject on Schema Container : %x\r\n", result);

	return result;

}

HRESULT CLDAPClassAsssociationsProvider :: CreateInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance)
{
	HRESULT result = E_FAIL;
	*ppInstance = NULL;
	if(SUCCEEDED(result = m_pAssociationClass->SpawnInstance(0, ppInstance)))
	{
		// Put the property values
		if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, CHILD_CLASS_PROPERTY_STR, strChildName, FALSE)))
		{
			if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, PARENT_CLASS_PROPERTY_STR, strParentName, FALSE)))
			{
			}
			else
				g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstance() PutBSTRProperty on parent property FAILED %x \r\n", result);
		}
		else
			g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstance() PutBSTRProperty on child property FAILED %x \r\n", result);
	}

	if(FAILED(result) && *ppInstance)
	{
		(*ppInstance)->Release();
		*ppInstance = NULL;
	}
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\attributes.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef ATTRIBUTES_H
#define ATTRIBUTES_H

// The Key used in the registry for logging
static LPCTSTR DSPROVIDER = __TEXT("DSProvider");

// Names of the LDAP class attributes
static LPCWSTR ADS_PATH_ATTR				= L"ADsPath";
static LPCWSTR LDAP_DISPLAY_NAME_ATTR		= L"ldapDisplayName";
static LPCWSTR COMMON_NAME_ATTR				= L"cn";
static LPCWSTR GOVERNS_ID_ATTR				= L"governsID";
static LPCWSTR SUB_CLASS_OF_ATTR			= L"subClassOf";
static LPCWSTR SCHEMA_ID_GUID_ATTR			= L"schemaIDGUID";
static LPCWSTR MAPI_DISPLAY_TYPE_ATTR		= L"mAPIDisplayType";
static LPCWSTR RDN_ATT_ID_ATTR				= L"rDNAttID";
static LPCWSTR SYSTEM_MUST_CONTAIN_ATTR		= L"systemMustContain";
static LPCWSTR MUST_CONTAIN_ATTR			= L"mustContain";
static LPCWSTR SYSTEM_MAY_CONTAIN_ATTR		= L"systemMayContain";
static LPCWSTR MAY_CONTAIN_ATTR				= L"mayContain";
static LPCWSTR SYSTEM_POSS_SUPERIORS_ATTR	= L"systemPossSuperiors";
static LPCWSTR POSS_SUPERIORS_ATTR			= L"possSuperiors";
static LPCWSTR SYSTEM_AUXILIARY_CLASS_ATTR	= L"systemAuxiliaryClass";
static LPCWSTR AUXILIARY_CLASS_ATTR			= L"auxiliaryClass";
static LPCWSTR DEFAULT_SECURITY_DESCRP_ATTR	= L"defaultSecurityDescriptor";
static LPCWSTR OBJECT_CLASS_CATEGORY_ATTR	= L"objectClassCategory";
static LPCWSTR SYSTEM_ONLY_ATTR				= L"systemOnly";
static LPCWSTR NT_SECURITY_DESCRIPTOR_ATTR	= L"nTSecurityDescriptor";
static LPCWSTR DEFAULT_OBJECTCATEGORY_ATTR	= L"defaultObjectCategory";

// Names of properties in WBEM/LDAP classes
static LPCWSTR ADSI_PATH_ATTR				= L"ADSIPath";
static LPCWSTR OBJECT_CLASS_PROPERTY		= L"ds_objectClass";

// Names of the LDAP property attributes
static LPCWSTR ATTRIBUTE_SYNTAX_ATTR		= L"attributeSyntax";
static LPCWSTR ATTRIBUTE_ID_ATTR			= L"attributeID";
static LPCWSTR IS_SINGLE_VALUED_ATTR		= L"isSingleValued";
static LPCWSTR MAPI_ID_ATTR					= L"mAPIID";
static LPCWSTR OM_SYNTAX_ATTR				= L"oMSyntax";
static LPCWSTR OM_OBJECT_CLASS_ATTR			= L"oMObjectClass";
static LPCWSTR SEARCH_FLAGS_ATTR			= L"searchFlags";
static LPCWSTR RANGE_LOWER_ATTR				= L"rangeLower";
static LPCWSTR RANGE_UPPER_ATTR				= L"rangeUpper";

// Names of the LDAP instance attributes
static LPCWSTR OBJECT_CLASS_ATTR				= L"objectClass";
static LPCWSTR DISTINGUISHED_NAME_ATTR			= L"distinguishedName";

// The OIDs for various LDAP syntaxes
// These values are used to map LDAP Syntax to CIM type
static LPCWSTR DISTINGUISHED_NAME_OID		= L"2.5.5.1";
static LPCWSTR OBJECT_IDENTIFIER_OID		= L"2.5.5.2";
static LPCWSTR CASE_SENSITIVE_STRING_OID	= L"2.5.5.3";
static LPCWSTR CASE_INSENSITIVE_STRING_OID	= L"2.5.5.4";
static LPCWSTR PRINT_CASE_STRING_OID		= L"2.5.5.5";
static LPCWSTR NUMERIC_STRING_OID			= L"2.5.5.6";
static LPCWSTR DN_WITH_BINARY_OID			= L"2.5.5.7";
static LPCWSTR BOOLEAN_OID					= L"2.5.5.8";
static LPCWSTR INTEGER_OID					= L"2.5.5.9";
static LPCWSTR OCTET_STRING_OID				= L"2.5.5.10";
static LPCWSTR TIME_OID						= L"2.5.5.11";
static LPCWSTR UNICODE_STRING_OID			= L"2.5.5.12";
static LPCWSTR PRESENTATION_ADDRESS_OID		= L"2.5.5.13";
static LPCWSTR DN_WITH_STRING_OID			= L"2.5.5.14";
static LPCWSTR NT_SECURITY_DESCRIPTOR_OID	= L"2.5.5.15";
static LPCWSTR LARGE_INTEGER_OID			= L"2.5.5.16";
static LPCWSTR SID_OID						= L"2.5.5.17";

// The name of the top classes
static LPCWSTR TOP_CLASS					= L"ds_top";
static LPCWSTR LDAP_BASE_CLASS				= L"DS_LDAP_Root_Class";

// Some WBEM class names 
static LPCWSTR UINT8ARRAY_CLASS				= L"Uint8Array";
static LPCWSTR DN_WITH_STRING_CLASS			= L"DN_With_String";
static LPCWSTR DN_WITH_BINARY_CLASS			= L"DN_With_Binary";
static LPCWSTR ROOTDSE_CLASS				= L"RootDSE";
static LPCWSTR INSTANCE_ASSOCIATION_CLASS	= L"DS_LDAP_Instance_Containment";
static LPCWSTR CLASS_ASSOCIATION_CLASS		= L"DS_LDAP_Class_Containment";
static LPCWSTR DN_CLASS						= L"DN_Class";
static LPCWSTR DN_ASSOCIATION_CLASS			= L"DSClass_To_DNInstance";

// Some othe literals common to the project
static LPCWSTR LDAP_PREFIX				= L"LDAP://";	
static LPCWSTR ROOT_DSE_PATH			= L"LDAP://RootDSE";
static LPCWSTR RIGHT_BRACKET_STR		= L")";
static LPCWSTR LEFT_BRACKET_STR			= L"(";
static LPCWSTR AMPERSAND_STR			= L"&";
static LPCWSTR PIPE_STR					= L"|";
static LPCWSTR SPACE_STR				= L" ";
static LPCWSTR COMMA_STR				= L",";
static LPCWSTR EQUALS_STR				= L"=";

// Prefixes for class names
static LPCWSTR LDAP_CLASS_NAME_PREFIX							= L"DS_";
static const DWORD LDAP_CLASS_NAME_PREFIX_LENGTH				= 3;
static LPCWSTR LDAP_ARTIFICIAL_CLASS_NAME_PREFIX				= L"ADS_";
static const DWORD LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH	= 4;

static LPCWSTR WBEMPERFORMANCEDATAMUTEX		=	L"WbemPerformanceDataMutex";

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\assocprov.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:assocprov.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Class Provider class. This is
//	the base class for all DS Class Providers. Note that an instance of the CLDAPClassAsssociationsProviderInitializer
//	class has to be created to initialize the static members of the CLDAPClassAsssociationsProvider class. Hence exactly
//	one instance of the CLDAPClassAsssociationsProviderInitializer class should be created for this
//	class to function properly.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_ASSOC_PROVIDER_H
#define DS_CLASS_ASSOC_PROVIDER_H


class CLDAPClassAsssociationsProvider : public IWbemProviderInit, public IWbemServices
{

public:

	// Create the object 
    CLDAPClassAsssociationsProvider () ;
    virtual ~CLDAPClassAsssociationsProvider () ;

	////////////////////////////////////////
	//IUnknown members
	////////////////////////////////////////
	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;


	////////////////////////////////////////
	//IWbemProviderInit members
	////////////////////////////////////////
	virtual HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

		
	////////////////////////////////////////
	//IWbemServices members
	////////////////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR strNamespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
    
    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    
    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);




protected:
	// Checks whether a containment is valid
	HRESULT IsContainedIn(LPCWSTR lpszChildClass, LPCWSTR lpszParentClass);

	// A helper function to do the ADSI LDAP provider specific initialization.
	BOOLEAN InitializeAssociationsProvider(IWbemContext *pCtx);

	// The IWbemServices pointer stored from Initialize()
	IWbemServices *m_IWbemServices;

	// Creates an instance of the association class
	HRESULT CreateInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance);

	// Does enumeration of instnaces of the association class
	HRESULT DoEnumeration(IWbemObjectSink *pResponseHandler);

private:

	// The Log File name
	static LPCWSTR s_LogFileName;

	// Indicates whether the call to Initialize() was successful
	BOOLEAN m_bInitializedSuccessfully;

	// The COM Reference count
    long m_lReferenceCount ;

	// The class for which instances are provider
	IWbemClassObject *m_pAssociationClass;

	// The path to the schema container
	LPWSTR m_lpszSchemaContainerSuffix;

	// The IDirectorySearch interface of the schema container
	IDirectorySearch *m_pDirectorySearchSchemaContainer;

	// Some literals
	static LPCWSTR CHILD_CLASS_PROPERTY;
	static LPCWSTR PARENT_CLASS_PROPERTY;
	static LPCWSTR POSSIBLE_SUPERIORS;
	BSTR CHILD_CLASS_PROPERTY_STR;
	BSTR PARENT_CLASS_PROPERTY_STR;
	BSTR CLASS_ASSOCIATION_CLASS_STR;
	BSTR POSSIBLE_SUPERIORS_STR;
	static LPCWSTR SCHEMA_NAMING_CONTEXT;
	static LPCWSTR LDAP_SCHEMA;
	static LPCWSTR LDAP_SCHEMA_SLASH;
};


#endif // DS_CLASS_ASSOC_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\classfac.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Class Provider class factory and
// the DS CLass Associations Provider class factory.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_PROVIDER_CLASS_FACTORY_H
#define DS_CLASS_PROVIDER_CLASS_FACTORY_H


////////////////////////////////////////////////////////////////
//////
//////		The DS Class provider class factory
//////
///////////////////////////////////////////////////////////////
class CDSClassProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	// Initializer objects required by the classes used by the DLL
	static CDSClassProviderInitializer *s_pDSClassProviderInitializer;
	static CLDAPClassProviderInitializer *s_pLDAPClassProviderInitializer;

    CDSClassProviderClassFactory () ;
    ~CDSClassProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;

};

////////////////////////////////////////////////////////////////
//////
//////		The DS Class Associations provider class factory
//////
///////////////////////////////////////////////////////////////
class CDSClassAssociationsProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:


    CDSClassAssociationsProviderClassFactory () ;
    ~CDSClassAssociationsProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};


#endif // DS_CLASS_PROVIDER_CLASS_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\classpro.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classpro.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the DS Class Provider class. THis is the
// base class for all DS class providers
//
//***************************************************************************

#include "precomp.h"


// Initialize the static members
BSTR CDSClassProvider :: CLASS_STR			= NULL;
CWbemCache *CDSClassProvider :: s_pWbemCache = NULL;

//***************************************************************************
//
// CDSClassProvider::CDSClassProvider
// CDSClassProvider::~CDSClassProvider
//
// Constructor Parameters:
//		lpLogFileName : The name of the file used for logging. The log file
//		name will be used in creating the log file path. The log file path
//		will be <SystemDirectory>\logFileName. Hence the logFileName may be relative
//		path. For exaple if this argument is specified as wbem\logs\dsprov.txt, then
//		the actual log file would be c:\winnt\system32\wbem\logs\dsprov.txt on a system
//		where the system directory is c:\winnt\system32
//
//  
//***************************************************************************

CDSClassProvider :: CDSClassProvider ()
{
	InterlockedIncrement(&g_lComponents);

	m_lReferenceCount = 0 ;
	m_IWbemServices = NULL;
	m_bInitializedSuccessfully = FALSE;
}

CDSClassProvider::~CDSClassProvider ()
{
	g_pLogObject->WriteW( L"CDSClassProvider :: DESTRUCTOR\r\n");

	if(m_IWbemServices)
	{
		m_IWbemServices->Release();
		m_IWbemServices = NULL;
	}

	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CDSClassProvider::QueryInterface
// CDSClassProvider::AddRef
// CDSClassProvider::Release
//
// Purpose: Standard COM routines needed for all COM objects
//
//***************************************************************************
STDMETHODIMP CDSClassProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) (IUnknown *)(IWbemProviderInit *)this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) (IWbemServices *)this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) (IWbemProviderInit *)this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSClassProvider :: AddRef ()
{
	return InterlockedIncrement ( & m_lReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSClassProvider :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_lReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT CDSClassProvider :: Initialize( 
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{
	// Validate the arguments
	if( pNamespace == NULL || lFlags != 0 )
	{
		g_pLogObject->WriteW( L"CDSClassProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();
		
	m_bInitializedSuccessfully = TRUE;
	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	return WBEM_S_NO_ERROR;
}

HRESULT CDSClassProvider :: OpenNamespace( 
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CancelAsyncCall( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: QueryObjectSink( 
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: GetObject( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: GetObjectAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CDSClassProvider :: Initialization status is FAILED, hence returning failure\r\n");
		return WBEM_E_FAILED;
	}

	// For exception handling
	//========================
	SetStructuredExceptionHandler seh;
	
	try 
	{
		if(!m_bInitializedSuccessfully)
		{
			g_pLogObject->WriteW( L"CDSClassProvider :: Initialization status is FAILED, hence returning failure\r\n");
			return WBEM_E_FAILED;
		}

		g_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() called for %s \r\n", strObjectPath);

		// Impersonate the client
		//=======================
		HRESULT result;
		if(!SUCCEEDED(result = WbemCoImpersonateClient()))
		{
			g_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
			return WBEM_E_FAILED;
		}

		// Validate the arguments
		//========================
		if(strObjectPath == NULL ) 
		{
			g_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() argument validation FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
		}

		// Parse the object path
		//========================
		CObjectPathParser theParser;
		ParsedObjectPath *theParsedObjectPath = NULL;
		switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
		{
			case CObjectPathParser::NoError:
				break;
			default:
				g_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() object path parsing FAILED\r\n");
				return WBEM_E_INVALID_PARAMETER;
		}

		try
		{
			// Check to see if it one of those classes that we know that dont provide
			//=======================================================================
			if(IsUnProvidedClass(theParsedObjectPath->m_pClass))
			{
				pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_NOT_FOUND, NULL, NULL);
			}
			else
			{
				IWbemClassObject *pReturnObject = NULL;
				if(SUCCEEDED(result = GetClassFromCacheOrADSI(theParsedObjectPath->m_pClass, &pReturnObject, pCtx)))
				{
					result = pResponseHandler->Indicate(1, &pReturnObject);
					pReturnObject->Release();
					pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_S_NO_ERROR, NULL, NULL);
				}
				else
				{
					g_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() GetClassFromCacheOrADSI FAILED for %s with %x\r\n", strObjectPath, result);
					pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_NOT_FOUND, NULL, NULL);
				}
			}
		}
		catch ( ... )
		{
			theParser.Free(theParsedObjectPath);
			throw;
		}

		// Delete the parser allocated structures
		//=======================================
		theParser.Free(theParsedObjectPath);

	}
	catch(Heap_Exception e_HE)
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_OUT_OF_MEMORY, NULL, NULL);
	}

	return WBEM_S_NO_ERROR;

}

HRESULT CDSClassProvider :: PutClass( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: PutClassAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteClass( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteClassAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateClassEnum( 
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateClassEnumAsync( 
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: PutInstance( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteInstance( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteInstanceAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateInstanceEnum( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateInstanceEnumAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecNotificationQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecNotificationQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecMethod( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecMethodAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}



HRESULT CDSClassProvider :: GetClassFromCacheOrADSI(LPCWSTR pszWBEMClassName, 
	IWbemClassObject **ppWbemClassObject,
	IWbemContext *pCtx)
{
	HRESULT result = E_FAIL;
	// The algorithm is as follows:
	// Check whether the classname is present in the list of classes to which this user is granted access
	// If so
	//		See if is present in the WBEM Cache.
	//		If so return it.
	//		If not, get it from ADSI. 
	//			If successful Map it to WBEM class and add the WBEM class to the WBEM cache and return
	//			If not, if the return value is ACCESS_DENIED, remove it from the user's list
	// If not
	//		Get it from ADSI.
	//		if successful
	//			if it is not present in the cache map it to WBEM and add the WBEM class to the cache
	//			else discard it and return the WBEM class in the cache to the user
	//		else
	//			return error
	if(m_AccessAllowedClasses.IsNamePresent(pszWBEMClassName))
	{
		g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Found class in Authenticated list for %s\r\n", pszWBEMClassName);

		// Check the WBEM Cache to see if it there
		//=========================================
		CWbemClass *pWbemClass = NULL;

		try
		{
			if(SUCCEEDED(result = s_pWbemCache->GetClass(pszWBEMClassName, &pWbemClass)))
			{
				g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Found class in cache for %s\r\n", pszWBEMClassName);

				// Get the IWbemClassObject of the cache object
				IWbemClassObject *pCacheObject = pWbemClass->GetWbemClass();

				pWbemClass->Release();
				pWbemClass = NULL;

				// Clone it
				if(!SUCCEEDED(result = pCacheObject->Clone(ppWbemClassObject)))
					g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Clone() FAILED : %x for %s\r\n", result, pszWBEMClassName);

				pCacheObject->Release();
			}
			else // Could not be found in cache. Go to ADSI
				//=========================================
			{
				g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Could not find class in cache for %s. Going to ADSI\r\n", pszWBEMClassName);

				IWbemClassObject *pNewObject = NULL;
				if(SUCCEEDED(result = GetClassFromADSI(pszWBEMClassName, pCtx, &pNewObject)))
				{
					try
					{
						// Add it to the cache
						pWbemClass = NULL;
						if(pWbemClass = new CWbemClass(pszWBEMClassName, pNewObject))
						{
							s_pWbemCache->AddClass(pWbemClass);

							pWbemClass->Release();
							pWbemClass = NULL;

							g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Added %s to cache\r\n", pszWBEMClassName);
							
							// Clone it
							if(!SUCCEEDED(result = pNewObject->Clone(ppWbemClassObject)))
								g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Clone() FAILED : %x for %s\r\n", result, pszWBEMClassName);

							pNewObject->Release();
							pNewObject = NULL;
						}
						else
							result = E_OUTOFMEMORY;
					}
					catch ( ... )
					{
						if ( pNewObject )
						{
							pNewObject->Release ();
							pNewObject = NULL;
						}

						throw;
					}
				}
				else 
				{
					m_AccessAllowedClasses.RemoveName(pszWBEMClassName);
					g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() GetClassFromADSI() FAILED : %x. Removing %s from user list\r\n", result, pszWBEMClassName);
				}
			}
		}
		catch ( ... )
		{
			if ( pWbemClass )
			{
				pWbemClass->Release ();
				pWbemClass = NULL;
			}

			throw;
		}
	}
	else // Get it from ADSI
		//=========================================
	{
		g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Could not find class in Authenticated list for %s. Going to ADSI\r\n", pszWBEMClassName);

		CWbemClass *pWbemClass = NULL;
		IWbemClassObject *pNewObject = NULL;

		try
		{
			if(SUCCEEDED(result = GetClassFromADSI(pszWBEMClassName, pCtx, &pNewObject)))
			{
				// Add it to the cache
				pWbemClass = NULL;
				if(pWbemClass = new CWbemClass(pszWBEMClassName, pNewObject))
				{
					s_pWbemCache->AddClass(pWbemClass);

					pWbemClass->Release();
					pWbemClass = NULL;

					g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() GetClassFromADSI succeeded for %s Added it to cache\r\n", pszWBEMClassName);
					
					// Clone it
					if(!SUCCEEDED(result = pNewObject->Clone(ppWbemClassObject)))
							g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Clone() FAILED : %x for %s\r\n", result, pszWBEMClassName);

					pNewObject->Release();
					pNewObject = NULL;

					// Add it to the list of classnames for this user
					m_AccessAllowedClasses.AddName(pszWBEMClassName);
					g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Also added to Authenticated list : %s \r\n", pszWBEMClassName);
				}
				else
					result = E_OUTOFMEMORY;
			}
			else
				g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() GetClassFromADSI FAILED : %x for %s\r\n", result, pszWBEMClassName);
		}
		catch ( ... )
		{
			if ( pNewObject )
			{
				pNewObject->Release ();
				pNewObject = NULL;
			}

			if ( pWbemClass )
			{
				pWbemClass->Release ();
				pWbemClass = NULL;
			}

			throw;
		}
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\classfac.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the DS Class Provider factory.
// Currently it always creates the LDAP CLass Provider. It remains to be decided as to how this can
// be changed
//
//***************************************************************************

#include "precomp.h"

// Initializer objects required by the classes used by the DLL
CDSClassProviderInitializer *CDSClassProviderClassFactory::s_pDSClassProviderInitializer = NULL;
CLDAPClassProviderInitializer *CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer = NULL;



//***************************************************************************
//
// CDSClassProviderClassFactory::CDSClassProviderClassFactory
// CDSClassProviderClassFactory::~CDSClassProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CDSClassProviderClassFactory :: CDSClassProviderClassFactory ()
{
	m_ReferenceCount = 0 ;
	InterlockedIncrement(&g_lComponents);
}

CDSClassProviderClassFactory::~CDSClassProviderClassFactory ()
{
	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CDSClassProviderClassFactory::QueryInterface
// CDSClassProviderClassFactory::AddRef
// CDSClassProviderClassFactory::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CDSClassProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSClassProviderClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSClassProviderClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CDSClassProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CDSClassProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	// We do not support aggregation
	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else 
	{
		// Check to see if the static members have been initialized
		// Create any initializer objects required for the classes
		EnterCriticalSection(&g_StaticsCreationDeletion);
		if(!s_pDSClassProviderInitializer)
		{
			BOOL bLogObjectAllocated = FALSE;

			try 
			{
				g_pLogObject->WriteW(L"CDSClassProviderClassFactory::CreateInstance() called\r\n");

				s_pDSClassProviderInitializer = new CDSClassProviderInitializer();
				s_pLDAPClassProviderInitializer = new CLDAPClassProviderInitializer();

			}
			catch(Heap_Exception e_HE)
			{
				if ( s_pDSClassProviderInitializer )
				{
					delete s_pDSClassProviderInitializer;
					s_pDSClassProviderInitializer = NULL;
				}

				if ( s_pLDAPClassProviderInitializer )
				{
					delete s_pLDAPClassProviderInitializer;
					s_pLDAPClassProviderInitializer = NULL;
				}

				status = E_OUTOFMEMORY ;
			}
		}
		LeaveCriticalSection(&g_StaticsCreationDeletion);

		if(SUCCEEDED(status))
		{
			CLDAPClassProvider *lpunk = NULL;
			try
			{
				lpunk = new CLDAPClassProvider();
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
			}
			catch(Heap_Exception e_HE)
			{
				if ( lpunk )
				{
					delete lpunk ;
					lpunk = NULL;
				}

				status = E_OUTOFMEMORY ;
			}
		}
	}

	return status ;
}

//***************************************************************************
//
// CDSClassProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CDSClassProviderClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & g_lServerLocks ) ;
	}
	else
	{
		InterlockedDecrement ( & g_lServerLocks ) ;
	}

	return S_OK	;
}



//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::CDSClassAssociationsProviderClassFactory
// CDSClassAssociationsProviderClassFactory::~CDSClassAssociationsProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CDSClassAssociationsProviderClassFactory :: CDSClassAssociationsProviderClassFactory ()
{
	m_ReferenceCount = 0 ;
	InterlockedIncrement(&g_lComponents);
}

CDSClassAssociationsProviderClassFactory::~CDSClassAssociationsProviderClassFactory ()
{
	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::QueryInterface
// CDSClassAssociationsProviderClassFactory::AddRef
// CDSClassAssociationsProviderClassFactory::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CDSClassAssociationsProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSClassAssociationsProviderClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSClassAssociationsProviderClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CDSClassAssociationsProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	// We do not support aggregation
	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else 
	{
		CLDAPClassAsssociationsProvider *lpunk = NULL;
		// Check to see if the static members have been initialized
		// Create any initializer objects required for the classes
		EnterCriticalSection(&g_StaticsCreationDeletion);
		BOOL bLogObjectAllocated = FALSE;

		try 
		{
			g_pLogObject->WriteW(L"CDSClassAssociationsProviderClassFactory::CreateInstance() called\r\n");

			lpunk = new CLDAPClassAsssociationsProvider();
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		catch(Heap_Exception e_HE)
		{
			if ( lpunk )
			{
				delete lpunk;
				lpunk = NULL;
			}

			status = E_OUTOFMEMORY ;
		}
		LeaveCriticalSection(&g_StaticsCreationDeletion);
	}

	return status ;
}

//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CDSClassAssociationsProviderClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & g_lServerLocks ) ;
	}
	else
	{
		InterlockedDecrement ( & g_lServerLocks ) ;
	}

	return S_OK	;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\classpro.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classpro.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Class Provider class. This is
//	the base class for all DS Class Providers. Note that an instance of the CDSClassProviderInitializer
//	class has to be created to initialize the static members of the CDSClassProvider class. Hence exactly
//	one instance of the CDSClassProviderInitializer class should be created for this
//	class to function properly.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_PROVIDER_H
#define DS_CLASS_PROVIDER_H

 
// Forward declaration for the initializer class
class CDSClassProviderInitializer;

class CDSClassProvider : public IWbemProviderInit, public IWbemServices
{
	// The initialization class is a friend of this class
	friend CDSClassProviderInitializer;

public:

	static DWORD dwClassProviderCount;
	// Create the object by passing the log object
    CDSClassProvider () ;
    virtual ~CDSClassProvider () ;

	////////////////////////////////////////
	//IUnknown members
	////////////////////////////////////////
	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;


	////////////////////////////////////////
	//IWbemProviderInit members
	////////////////////////////////////////
	virtual HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

		
	////////////////////////////////////////
	//IWbemServices members
	////////////////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR strNamespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
    
    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    
    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);




protected:

#ifdef PROFILING
	// Used for profiling. Should be removed.
	DWORD dwStartTime;
#endif

	////////////////////////////////////////////////
	// Functions for interacting with ADSI providers
	////////////////////////////////////////////////
	//***************************************************************************
	//
	// CDSClassProvider::GetWBEMProviderName
	//
	// Purpose : Returns the name of the provider. This should be the same as the
	// value of the field Name in the __Win32Provider instance used for registration
	// of the provider
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the provider
	//***************************************************************************
	virtual const BSTR GetWBEMProviderName() = 0;

	//***************************************************************************
	//
	// CDSClassProvider::IsUnProvidedClass
	//
	// Purpose : To check whether a class is one that the provider does not provide
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be checked
	//
	// 
	//	Return Value: TRUE is this is one of the classes not provided by the provider
	//***************************************************************************
	virtual BOOLEAN IsUnProvidedClass(LPCWSTR lpszClassName) = 0;

	//***************************************************************************
	//
	// CDSClassProvider::GetClassFromCacheOrADSI
	//
	// Purpose : To create a WBEM class from an ADSI Class
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be retreived
	//	pCtx : A pointer to the context object that was used in this call. This
	//		may be used by this function to make calls to CIMOM
	//
	// 
	//	Return Value: The COM result representing the status. 
	//***************************************************************************
	virtual HRESULT GetClassFromCacheOrADSI(LPCWSTR pszWBEMClassName, 
		IWbemClassObject **ppReturnObject,
		IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider::GetClassFromADSI
	//
	// Purpose : To create a WBEM class from an ADSI Class
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be retreived
	//	pCtx : A pointer to the context object that was used in this call. This
	//		may be used by this function to make calls to CIMOM
	//	ppWbemClass : The resulting WBEM Class. This has to be released once the
	//		user is done with it.
	//
	// 
	//	Return Value: The COM result representing the status. 
	//***************************************************************************
	virtual HRESULT GetClassFromADSI( 
		LPCWSTR lpszClassName,
		IWbemContext *pCtx,
		IWbemClassObject ** ppWbemClass
		) = 0;	

	//***************************************************************************
	//
	// CDSClassProvider::GetADSIClass
	//
	// Purpose : To Create a CADSIClass from an ADSI classSchema object
	// Parameters:
	//		lpszWBEMClassName : The WBEM Name of the class to be fetched. 
	//		ppADSIClass : The address where the pointer to the CADSIClass will be stored.
	//			It is the caller's responsibility to Release() the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	virtual HRESULT GetADSIClass(LPCWSTR lpszClassName, 
		CADSIClass ** ppADSIClass) = 0;

	//***************************************************************************
	//
	// CDSClassProvider::GetADSIProperty
	//
	// Purpose : To create an CADSIProperty object from an LDAP AttributeSchema object
	// Parameters:
	//		lpszPropertyName : The LDAPDisplayName of the LDAP property to be fetched. 
	//		ppADSIProperty : The address where the pointer to the IDirectoryObject interface will be stored
	//			It is the caller's responsibility to Release() the interface when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request
	//***************************************************************************
	virtual HRESULT GetADSIProperty(
		LPCWSTR lpszPropertyName, 
		CADSIProperty **ppADSIProperty) = 0;

	//***************************************************************************
	//
	// CDSClassProvider::GetWBEMBaseClassName
	//
	// Purpose : Returns the name of the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the base class. NULL if such a class doesnt exist.
	//***************************************************************************
	virtual const BSTR GetWBEMBaseClassName() = 0;
	//***************************************************************************
	//
	// CDSClassProvider::GetWBEMBaseClass
	//
	// Purpose : Returns a pointer to the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The IWbemClassObject pointer to the base class. It is the duty of 
	//	user to release the class when done with using it.
	//***************************************************************************
	virtual IWbemClassObject * GetWBEMBaseClass() = 0;

	// Returns whether the class name is present in the list of classes authorized for this user
	BOOLEAN IsClassAccessible();

	// The IWbemServices pointer stored from Initialize()
	IWbemServices *m_IWbemServices;

	// Indicates whether the call to Initialize() was successful
	BOOLEAN m_bInitializedSuccessfully;

	// Creates a log file using the m_lpszLogFileName member
	BOOLEAN CreateLogFile();

	// Some literals
	static BSTR CLASS_STR;

	// A cache of wbem classes
	static CWbemCache *s_pWbemCache;

	// A list of classes to which access has been granted for this user
	CNamesList m_AccessAllowedClasses;

private:

	// The COM Reference count
    long m_lReferenceCount ;
};


#endif // DS_CLASS_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\clsname.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"


CNamesList :: CNamesList()
{
	m_pListOfClassNames = NULL;
	m_dwElementCount = 0;
	InitializeCriticalSection(&m_AccessibleClassesSection);
}

CNamesList :: ~CNamesList()
{
	EnterCriticalSection(&m_AccessibleClassesSection);
	CLPWSTR *pTemp1 = m_pListOfClassNames;
	CLPWSTR *pNext = m_pListOfClassNames;
	while(pTemp1)
	{
		pNext = pTemp1->pNext;
		delete pTemp1;
		pTemp1 = pNext;
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);
	DeleteCriticalSection(&m_AccessibleClassesSection);
}

BOOLEAN CNamesList :: IsNamePresent(LPCWSTR pszClassName) 
{
	// Get the current impersonation level
	DWORD dwCurrentImpersonationLevel = 0;
	if(FAILED(GetImpersonationLevel(&dwCurrentImpersonationLevel)))
		return FALSE;

	// Look for a name in the list that has an impersonation level of current or greater
	BOOLEAN bRetVal = FALSE;
	EnterCriticalSection(&m_AccessibleClassesSection);
	CLPWSTR *pCurrent = m_pListOfClassNames;
	while(pCurrent)
	{
		if(_wcsicmp(pCurrent->pszVal, pszClassName) == 0 && pCurrent->dwImpersonationLevel <= dwCurrentImpersonationLevel)
		{
			bRetVal = TRUE;
			break;
		}
		pCurrent = pCurrent->pNext;
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return bRetVal;
}

BOOLEAN CNamesList :: RemoveName(LPCWSTR pszClassName)
{
#ifdef NO_WBEM_CACHE
	return FALSE;
#else
	BOOLEAN bRetVal = FALSE;
	EnterCriticalSection(&m_AccessibleClassesSection);
	if(m_pListOfClassNames)
	{
		// Is it the first node ?
		if(_wcsicmp(m_pListOfClassNames->pszVal, pszClassName) == 0)
		{
			bRetVal = TRUE;
			CLPWSTR *pTemp = m_pListOfClassNames->pNext;
			delete m_pListOfClassNames;
			m_pListOfClassNames = pTemp;
			m_dwElementCount--;
		}
		else
		{
			CLPWSTR *pPrev = m_pListOfClassNames;
			CLPWSTR *pCurrent = m_pListOfClassNames->pNext;

			while(pCurrent)
			{
				if(_wcsicmp(pCurrent->pszVal, pszClassName) == 0)
				{
					bRetVal = TRUE;
					pPrev->pNext = pCurrent->pNext;
					delete pCurrent;
					m_dwElementCount --;
					break;
				}
				pPrev = pCurrent;
				pCurrent = pCurrent->pNext;
			}
		}
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return bRetVal;
#endif
}

BOOLEAN CNamesList :: AddName(LPCWSTR pszClassName)
{
#ifdef NO_WBEM_CACHE
	return FALSE;
#else

	// Get the current impersonation level
	DWORD dwCurrentImpersonationLevel = 0;
	if(!SUCCEEDED(GetImpersonationLevel(&dwCurrentImpersonationLevel)))
		return FALSE;
	
	
	// Add it only if it doesnt already exist in the list
	BOOLEAN bFound = FALSE;
	EnterCriticalSection(&m_AccessibleClassesSection);
	CLPWSTR *pCurrent = m_pListOfClassNames;
	while(pCurrent)
	{
		if(_wcsicmp(pCurrent->pszVal, pszClassName) == 0)
		{
			bFound = TRUE;
			break;
		}
		pCurrent = pCurrent->pNext;
	}

	// Add it at the head
	if(!bFound)
	{
		pCurrent = m_pListOfClassNames;
		m_pListOfClassNames = new CLPWSTR;
		m_pListOfClassNames->pszVal = new WCHAR[wcslen(pszClassName) + 1];
		m_pListOfClassNames->dwImpersonationLevel = dwCurrentImpersonationLevel;
		wcscpy(m_pListOfClassNames->pszVal, pszClassName);
		m_pListOfClassNames->pNext = pCurrent;
		m_dwElementCount ++;
	}
	else	// update the impersonation level if necessary
	{
		if(pCurrent->dwImpersonationLevel < dwCurrentImpersonationLevel)
			pCurrent->dwImpersonationLevel = dwCurrentImpersonationLevel;
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return !bFound;
#endif
}

DWORD CNamesList :: GetAllNames(LPWSTR **pppszNames) 
{
	EnterCriticalSection(&m_AccessibleClassesSection);
	DWORD retVal = m_dwElementCount;
	*pppszNames = NULL;
	if(m_dwElementCount)
	{
		if(*pppszNames = new LPWSTR[m_dwElementCount])
		{
			CLPWSTR *pCurrent = m_pListOfClassNames;
			bool bError = false;
			for(DWORD i=0; !bError && (i<m_dwElementCount); i++)
			{
				(*pppszNames)[i] = NULL;
				if((*pppszNames)[i] = new WCHAR[wcslen(pCurrent->pszVal) + 1])
				{
					wcscpy((*pppszNames)[i], pCurrent->pszVal);
					pCurrent = pCurrent->pNext;
				}
				else
					bError = true;
			}

			if(bError)
			{
				retVal = 0;
				delete [] (*pppszNames);
				*pppszNames = NULL;
			}
		}
		else
			retVal = 0;
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return retVal;
}

HRESULT CNamesList :: GetImpersonationLevel(DWORD *pdwImpLevel)
{
	//get implevel...
	HANDLE hThreadTok = NULL;
	HRESULT hr = E_FAIL;

	if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok) )
	{
		DWORD dwBytesReturned = 0;
		DWORD dwThreadImpLevel = 0;

		if (GetTokenInformation(hThreadTok, TokenImpersonationLevel, &dwThreadImpLevel,
									sizeof(DWORD), &dwBytesReturned)) 
		{
			hr = S_OK;

			switch(dwThreadImpLevel)
			{
				case SecurityAnonymous:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
				}
				break;

				case SecurityIdentification:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
				}
				break;

				case SecurityImpersonation:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
				}
				break;

				case SecurityDelegation:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_DELEGATE;
				}
				break;
				
				default:
				{
					hr = E_FAIL;
				}
			}
		}
		CloseHandle(hThreadTok);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\clsname.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:clasname.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for a list of class names. This user
// the templates from SNMPProvider\Common
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef NAME_LIST_H
#define NAME_LIST_H

// Need to encapsulate LPWSTR to avoid conversion to CString

class CLPWSTR
{
	public :
		LPWSTR pszVal;
		DWORD dwImpersonationLevel;
		CLPWSTR * pNext;

		CLPWSTR()
		{
			pszVal = NULL;
			pNext = NULL;
		}

		~CLPWSTR()
		{
			delete [] pszVal;
		}
};

class CNamesList
{

private:
	CRITICAL_SECTION m_AccessibleClassesSection;
	CLPWSTR *m_pListOfClassNames;
	DWORD m_dwElementCount;
	HRESULT GetImpersonationLevel(DWORD *pdwImpLevel);

public:
	CNamesList();
	virtual ~CNamesList();
	BOOLEAN IsNamePresent(LPCWSTR pszClassName);
	BOOLEAN RemoveName(LPCWSTR pszClassName);
	BOOLEAN AddName(LPCWSTR pszClassName);
	DWORD GetAllNames(LPWSTR **ppszNames);

};

#endif /*NAME_LIST_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\dscpguid.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile: guids.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
//	Description: This file is used to generate definitions of the GUIDs in the project
//
// ***************************************************************************

#include <objbase.h>
#include <initguid.h>

#include "dscpguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\clsproi.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:clsproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CDSClassProviderInitializer class. This class
// is used to initialize the static members of the CDSCLassProvider class
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_PROVIDER_INIT_H
#define DS_CLASS_PROVIDER_INIT_H

class CDSClassProviderInitializer
{

public:
	CDSClassProviderInitializer();
	~CDSClassProviderInitializer();
};

#endif /* DS_CLASS_PROVIDER_INIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\clsproi.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:clsproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the class that is used to initialize the
//	CDSClassProvider class
//
//***************************************************************************

#include "precomp.h"


//***************************************************************************
//
// CDSClassProviderInitializer::CDSClassProviderInitializer
//
// Constructor Parameters:
//		None
//
//  
//***************************************************************************

CDSClassProviderInitializer :: CDSClassProviderInitializer ()
{
	CDSClassProvider :: CLASS_STR				= SysAllocString(L"__CLASS");
	CDSClassProvider :: s_pWbemCache			= new CWbemCache();
}

//***************************************************************************
//
// CDSClassProviderInitializer::CDSClassProviderInitializer
//
// Destructor
//
//  
//***************************************************************************
CDSClassProviderInitializer :: ~CDSClassProviderInitializer ()
{
	if (CDSClassProvider::s_pWbemCache)
	{
		delete CDSClassProvider::s_pWbemCache;
		CDSClassProvider::s_pWbemCache = NULL ;
	}

	SysFreeString(CDSClassProvider::CLASS_STR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\dsipguid.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile: dsipguid.cpp $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
//	Description: This file is used to generate definitions of the GUIDs in the project
//
// ***************************************************************************

#include <objbase.h>
#include <initguid.h>

#include "dsipguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\dsipguid.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:dsipguid.h $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains GUID definitions used in this project
//
//***************************************************************************

//
// The CLSID of the DS Instance Provider - {AA527A40-4D9A-11d2-93AD-00805F853771}
//
// {AA527A40-4D9A-11d2-93AD-00805F853771}
DEFINE_GUID(CLSID_DSInstanceProvider, 
0xaa527a40, 0x4d9a, 0x11d2, 0x93, 0xad, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\instfac.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains the implementation of the DS Instance Provider factory.
//
//***************************************************************************

#include "precomp.h"

CDSInstanceProviderInitializer *CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer = NULL;

//***************************************************************************
//
// CDSInstanceProviderClassFactory::CDSInstanceProviderClassFactory
// CDSInstanceProviderClassFactory::~CDSInstanceProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CDSInstanceProviderClassFactory :: CDSInstanceProviderClassFactory ()
{
	m_ReferenceCount = 0 ;
	InterlockedIncrement(&g_lComponents);
}

CDSInstanceProviderClassFactory::~CDSInstanceProviderClassFactory ()
{
	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CDSInstanceProviderClassFactory::QueryInterface
// CDSInstanceProviderClassFactory::AddRef
// CDSInstanceProviderClassFactory::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CDSInstanceProviderClassFactory::QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSInstanceProviderClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSInstanceProviderClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CDSInstanceProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CDSInstanceProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	// We do not support aggregation
	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		// Check to see if the static members have been initialized
		// Create any initializer objects required for the classes
		EnterCriticalSection(&g_StaticsCreationDeletion);
		if(!s_pDSInstanceProviderInitializer)
		{
			BOOL bLocObjectAllocated = FALSE;

			try
			{
				g_pLogObject->WriteW(L"CDSInstanceProviderClassFactory::CreateInstance() called\r\n");
				s_pDSInstanceProviderInitializer = new CDSInstanceProviderInitializer();
			}
			catch(Heap_Exception e_HE)
			{
				if ( s_pDSInstanceProviderInitializer )
				{
					delete s_pDSInstanceProviderInitializer;
					s_pDSInstanceProviderInitializer = NULL;
				}

				status = E_OUTOFMEMORY ;
			}
		}
		LeaveCriticalSection(&g_StaticsCreationDeletion);

		if(SUCCEEDED(status))
		{
			CLDAPInstanceProvider *lpunk = NULL;
			try
			{
				lpunk = new CLDAPInstanceProvider();
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
			}
			catch(Heap_Exception e_HE)
			{
				status = E_OUTOFMEMORY ;
			}

		}
	}

	return status ;
}

//***************************************************************************
//
// CDSInstanceProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CDSInstanceProviderClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & g_lServerLocks ) ;
	}
	else
	{
		InterlockedDecrement ( & g_lServerLocks ) ;
	}

	return S_OK	;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\dscpguid.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:guids.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains GUID definitions used in this project
//
//***************************************************************************

//
// The CLSID of the DS Provider - {1EF94880-01A8-11d2-A90B-00AA00BF3363}
//
DEFINE_GUID(CLSID_DSProvider, 0x1ef94880, 0x1a8, 0x11d2, 0xa9, 0xb, 0x0, 0xaa, 0x0, 0xbf, 0x33, 0x63);

//
// The CLSID of the DS Class ASsociations Provider - {33831ED4-42B8-11d2-93AD-00805F853771}
//
DEFINE_GUID(CLSID_DSClassAssocProvider, 0x33831ed4, 0x42b8, 0x11d2, 0x93, 0xad, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\instproi.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:instproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CDSInstanceProviderInitializer class. This class
// is used to initialize the static members of the CLDAPInstanceProvider class
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_INSTANCE_PROVIDER_INIT_H
#define DS_INSTANCE_PROVIDER_INIT_H

class CDSInstanceProviderInitializer
{

public:
	CDSInstanceProviderInitializer();
	~CDSInstanceProviderInitializer();
};

#endif /* DS_INSTANCE_PROVIDER_INIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\instproi.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:instproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains implementation of the class that is used to initialize the
//	CLDAPInstanceProvider class
//
//***************************************************************************

#include "precomp.h"


//***************************************************************************
//
// CDSInstanceProviderInitializer::CDSInstanceProviderInitializer
//
// Constructor Parameters:
//		None
//
//
//***************************************************************************

CDSInstanceProviderInitializer :: CDSInstanceProviderInitializer ()
{
	CLDAPInstanceProvider :: CLASS_STR						= SysAllocString(L"__CLASS");
	CLDAPInstanceProvider :: DN_PROPERTY					= SysAllocString(L"DN");
	CLDAPInstanceProvider :: ROOT_DN_PROPERTY				= SysAllocString(L"RootDNForSearchAndQuery");
	CLDAPInstanceProvider :: QUERY_LANGUAGE					= SysAllocString(L"WQL");
	CLDAPInstanceProvider :: RELPATH_STR					= SysAllocString(L"__RELPATH");
	CLDAPInstanceProvider :: VALUE_PROPERTY_STR				= SysAllocString(L"value");
	CLDAPInstanceProvider :: DN_STRING_PROPERTY_STR			= SysAllocString(L"dnString");
	CLDAPInstanceProvider :: UINT8ARRAY_STR					= SysAllocString(L"Uint8Array");
	CLDAPInstanceProvider :: DN_WITH_BINARY_CLASS_STR		= SysAllocString(L"DN_With_Binary");
	CLDAPInstanceProvider :: DN_WITH_STRING_CLASS_STR		= SysAllocString(L"DN_With_String");
	CLDAPInstanceProvider :: ADSI_PATH_STR					= SysAllocString(ADSI_PATH_ATTR);
	CLDAPInstanceProvider :: INSTANCE_ASSOCIATION_CLASS_STR	= SysAllocString(INSTANCE_ASSOCIATION_CLASS);
	CLDAPInstanceProvider :: CHILD_INSTANCE_PROPERTY_STR	= SysAllocString(L"ChildInstance");
	CLDAPInstanceProvider :: PARENT_INSTANCE_PROPERTY_STR	= SysAllocString(L"ParentInstance");
	CLDAPInstanceProvider :: ATTRIBUTE_SYNTAX_STR			= SysAllocString(L"attributeSyntax");
	CLDAPInstanceProvider :: DEFAULT_OBJECT_CATEGORY_STR	= SysAllocString(L"defaultObjectCategory");
	CLDAPInstanceProvider :: LDAP_DISPLAY_NAME_STR			= SysAllocString(L"ldapDisplayName");
	CLDAPInstanceProvider :: PUT_EXTENSIONS_STR				= SysAllocString(L"__PUT_EXTENSIONS");
	CLDAPInstanceProvider :: PUT_EXT_PROPERTIES_STR			= SysAllocString(L"__PUT_EXT_PROPERTIES");
	CLDAPInstanceProvider :: CIMTYPE_STR					= SysAllocString(L"Cimtype");

	// LDAP://RootDSE Properties
	CLDAPInstanceProvider :: SUBSCHEMASUBENTRY_STR			= SysAllocString(L"subschemaSubentry");
	CLDAPInstanceProvider :: CURRENTTIME_STR				= SysAllocString(L"currentTime");
	CLDAPInstanceProvider :: SERVERNAME_STR					= SysAllocString(L"serverName");
	CLDAPInstanceProvider :: NAMINGCONTEXTS_STR				= SysAllocString(L"namingContexts");
	CLDAPInstanceProvider :: DEFAULTNAMINGCONTEXT_STR		= SysAllocString(L"defaultNamingContext");
	CLDAPInstanceProvider :: SCHEMANAMINGCONTEXT_STR		= SysAllocString(L"schemaNamingContext");
	CLDAPInstanceProvider :: CONFIGURATIONNAMINGCONTEXT_STR	= SysAllocString(L"configurationNamingContext");
	CLDAPInstanceProvider :: ROOTDOMAINNAMINGCONTEXT_STR	= SysAllocString(L"rootDomainNamingContext");
	CLDAPInstanceProvider :: SUPPORTEDCONTROLS_STR			= SysAllocString(L"supportedControl");
	CLDAPInstanceProvider :: SUPPORTEDVERSION_STR			= SysAllocString(L"supportedLDAPVersion");
	CLDAPInstanceProvider :: DNSHOSTNAME_STR				= SysAllocString(L"dnsHostName");
	CLDAPInstanceProvider :: DSSERVICENAME_STR				= SysAllocString(L"dsServiceName");
	CLDAPInstanceProvider :: HIGHESTCOMMITEDUSN_STR			= SysAllocString(L"highestCommittedUSN");
	CLDAPInstanceProvider :: LDAPSERVICENAME_STR			= SysAllocString(L"LDAPServiceName");
	CLDAPInstanceProvider :: SUPPORTEDCAPABILITIES_STR		= SysAllocString(L"supportedCapabilities");
	CLDAPInstanceProvider :: SUPPORTEDLDAPPOLICIES_STR		= SysAllocString(L"supportedLDAPPolicies");
	CLDAPInstanceProvider :: SUPPORTEDSASLMECHANISMS_STR	= SysAllocString(L"supportedSASLMechanisms");
}

//***************************************************************************
//
// CDSInstanceProviderInitializer::CDSInstanceProviderInitializer
//
// Destructor
//
//
//***************************************************************************
CDSInstanceProviderInitializer :: ~CDSInstanceProviderInitializer ()
{
	SysFreeString(CLDAPInstanceProvider::CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::DN_PROPERTY);
	SysFreeString(CLDAPInstanceProvider::ROOT_DN_PROPERTY);
	SysFreeString(CLDAPInstanceProvider::QUERY_LANGUAGE);
	SysFreeString(CLDAPInstanceProvider::RELPATH_STR);
	SysFreeString(CLDAPInstanceProvider::VALUE_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::DN_STRING_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::UINT8ARRAY_STR);
	SysFreeString(CLDAPInstanceProvider::DN_WITH_STRING_CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::DN_WITH_BINARY_CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::ADSI_PATH_STR);
	SysFreeString(CLDAPInstanceProvider::INSTANCE_ASSOCIATION_CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::CHILD_INSTANCE_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::PARENT_INSTANCE_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::ATTRIBUTE_SYNTAX_STR);
	SysFreeString(CLDAPInstanceProvider::DEFAULT_OBJECT_CATEGORY_STR);
	SysFreeString(CLDAPInstanceProvider::LDAP_DISPLAY_NAME_STR);
	SysFreeString(CLDAPInstanceProvider::PUT_EXTENSIONS_STR);
	SysFreeString(CLDAPInstanceProvider::PUT_EXT_PROPERTIES_STR);
	SysFreeString(CLDAPInstanceProvider::CIMTYPE_STR);

	// LDAP://RootDSE Properties
	SysFreeString(CLDAPInstanceProvider::SUBSCHEMASUBENTRY_STR);
	SysFreeString(CLDAPInstanceProvider::CURRENTTIME_STR);
	SysFreeString(CLDAPInstanceProvider::SERVERNAME_STR);
	SysFreeString(CLDAPInstanceProvider::NAMINGCONTEXTS_STR);
	SysFreeString(CLDAPInstanceProvider::DEFAULTNAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::SCHEMANAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::CONFIGURATIONNAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::ROOTDOMAINNAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDCONTROLS_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDVERSION_STR);
	SysFreeString(CLDAPInstanceProvider::DNSHOSTNAME_STR);
	SysFreeString(CLDAPInstanceProvider::DSSERVICENAME_STR);
	SysFreeString(CLDAPInstanceProvider::HIGHESTCOMMITEDUSN_STR);
	SysFreeString(CLDAPInstanceProvider::LDAPSERVICENAME_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDCAPABILITIES_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDLDAPPOLICIES_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDSASLMECHANISMS_STR);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\instfac.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Instnace Provider class factory
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_INSTANCE_PROVIDER_CLASS_FACTORY_H
#define DS_INSTANCE_PROVIDER_CLASS_FACTORY_H


class CDSInstanceProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	// Initializer objects required by the classes used by the DLL
	static CDSInstanceProviderInitializer *s_pDSInstanceProviderInitializer;

    CDSInstanceProviderClassFactory () ;
    ~CDSInstanceProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};


#endif // DS_INSTANCE_PROVIDER_CLASS_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\instprov.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:instprov.h $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Instance Provider class. 
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_INSTANCE_PROVIDER_H
#define DS_INSTANCE_PROVIDER_H

// Forward declaration for the initializer class
class CDSInstanceProviderInitializer;

class CLDAPInstanceProvider : public IWbemProviderInit, public IWbemServices
{
	// The initialization class is a friend of this class
	friend CDSInstanceProviderInitializer;

public:

	// Create the object 
    CLDAPInstanceProvider () ;
    virtual ~CLDAPInstanceProvider () ;

	////////////////////////////////////////
	//IUnknown members
	////////////////////////////////////////
	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;


	////////////////////////////////////////
	//IWbemProviderInit members
	////////////////////////////////////////
	virtual HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

		
	////////////////////////////////////////
	//IWbemServices members
	////////////////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR strNamespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
    
    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    
    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

protected:

	// The IWbemServices pointer stored from Initialize()
	IWbemServices *m_IWbemServices;

	// SHows whether the call to Initialize() was successful
	BOOLEAN m_bInitializedSuccessfully;

	// The IWbemClassObject pointer to the Uint8ArrayClass
	IWbemClassObject *m_pWbemUin8ArrayClass;

	// The IWbemClassObject pointer to the DNWithBinaryClass
	IWbemClassObject *m_pWbemDNWithBinaryClass;

	// The IWbemClassObject pointer to the DNWithStringClass
	IWbemClassObject *m_pWbemDNWithStringClass;

	// The IWbemClassObject interface to the associations class
	IWbemClassObject *m_pAssociationsClass;

	// The path to the top level container
	LPWSTR m_lpszTopLevelContainerPath;

	// Gets the IDIrectoryObject interface on an ADSI instance
	HRESULT MapPropertyValueToWBEM(BSTR strWbemName, IWbemClassObject *pWbemClass, IWbemClassObject *pWbemObject, PADS_ATTR_INFO pAttribute);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::IsContainedIn
	//
	// Purpose: Checks whether a containment is valid
	//
	// Parameters: 
	//	pszChildInstance : The WBEM Name of the child class
	//	pszParentInstance : The WBEM Name of the parent class
	//
	// Return Value: The COM status of the request
	//
	//***************************************************************************
	HRESULT IsContainedIn(LPCWSTR pszChildInstance, LPCWSTR pszParentInstance);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::CreateInstance
	//
	// Purpose: Checks whether a containment is valid
	//
	// Parameters: 
	//	strChildName : The WBEM Name of the child instance
	//	strParentName : The WBEM Name of the parent instance
	//
	// Return Value: The COM status of the request. THe user should free the returned 
	//	IWbemClassObject when done.
	//
	//***************************************************************************
	HRESULT CreateWBEMInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::ModifyExistingADSIInstance
	//
	// Purpose: Modify an existing ADSI Object using information from the WBEM object
	//
	// Parameters: 
	//	pWbemInstance : The WBEM instance being mapped
	//	pszADSIPath : The path to the ADSI instance
	//	pExistingObject : The CADSIInstance pointer on the existing instance
	//	pszADSIClass : The ADSI class name of the new instance
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT ModifyExistingADSIInstance(IWbemClassObject *pWbemInstance, LPCWSTR pszADSIPath, CADSIInstance *pExistingObject, LPCWSTR pszADSIClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::CreateNewADSIInstance
	//
	// Purpose: To create a new ADSI instance form a WBEM instance
	//
	// Parameters: 
	//	pWbemInstance : The WBEM instance being mapped
	//	pszADSIPath : The path to the new ADSI instance
	//	pszADSIClass : The ADSI class name of the new instance
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT CreateNewADSIInstance(IWbemClassObject *pWbemInstance, LPCWSTR pszADSIPath, LPCWSTR pszADSIClass);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::MapPropertyValueToADSI
	//
	// Purpose: To map a WBEM property to ADSI
	//
	//	strPropertyName : The WBEM name of the property
	//	vPropertyValue : The variant representing the proeprty value
	//	cType : The CIMTYPE of the property
	//	lFlavour : The WBEM flavour of the proeprty
	//	pAttributeEntry : A pointer to an ADS_ATTR_INFO structure that will be filled in.
	//
	//***************************************************************************
	HRESULT MapPropertyValueToADSI(IWbemClassObject *pWbemInstance, BSTR strPropertyName, VARIANT vPropertyValue, CIMTYPE cType, LONG lFlavour,  PADS_ATTR_INFO pAttributeEntry);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::DoChildContainmentQuery
	//
	// Purpose: Find the parent of a given child and create an association class
	//
	// Parameters: 
	//	pszChildPath : The ADSI path of the child instance
	//	pResponseHandler : A sink on which the resulting objects are indicated
	//	pListIndicatedSoFar : To avoid duplicate indications (WinMgmt will lot filter them), a
	//		list of objects indicated so far is kept. Any objects in this list are
	//		not indicated again
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT DoChildContainmentQuery(LPCWSTR pszChildPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::DoParentContainmentQuery
	//
	// Purpose: Enumerate the children of a given parent and create association classes
	//
	// Parameters: 
	//	pszParentPath : The ADSI path of the parent instance
	//	pResponseHandler : A sink on which the resulting objects are indicated
	//	pListIndicatedSoFar : To avoid duplicate indications (WinMgmt will lot filter them), a
	//		list of objects indicated so far is kept. Any objects in this list are
	//		not indicated again
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT DoParentContainmentQuery(LPCWSTR pszParentPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar);

	// Maps an ADSI Instance to WBEM
	HRESULT MapADSIInstance(CADSIInstance *pADSInstance, IWbemClassObject *pWbemClass, IWbemClassObject *pWbemObject);


private:

	// The COM Reference count
    long m_lReferenceCount ;

	// These are the search preferences often used
	ADS_SEARCHPREF_INFO m_pSearchInfo[2];

	// A query for getting the DN associators of a class
    static LPCWSTR QUERY_FORMAT;
    static BSTR QUERY_LANGUAGE;
    static BSTR DN_PROPERTY;
    static BSTR ROOT_DN_PROPERTY;

	// Some literals
	static LPCWSTR DEFAULT_NAMING_CONTEXT_ATTR;
	static LPCWSTR OBJECT_CLASS_EQUALS;
	static BSTR CLASS_STR;
	static BSTR ADSI_PATH_STR;
	static BSTR UINT8ARRAY_STR;
	static BSTR	DN_WITH_BINARY_CLASS_STR;
	static BSTR	DN_WITH_STRING_CLASS_STR;
	static BSTR VALUE_PROPERTY_STR;
	static BSTR DN_STRING_PROPERTY_STR;
	static BSTR INSTANCE_ASSOCIATION_CLASS_STR;
	static BSTR CHILD_INSTANCE_PROPERTY_STR;
	static BSTR PARENT_INSTANCE_PROPERTY_STR;
	static BSTR RELPATH_STR;
	static BSTR ATTRIBUTE_SYNTAX_STR;
	static BSTR DEFAULT_OBJECT_CATEGORY_STR;
	static BSTR LDAP_DISPLAY_NAME_STR;
	static BSTR PUT_EXTENSIONS_STR;
	static BSTR PUT_EXT_PROPERTIES_STR;
	static BSTR CIMTYPE_STR;
	// Properties of LDAP://RootDSE
	static BSTR SUBSCHEMASUBENTRY_STR;
	static BSTR CURRENTTIME_STR;
	static BSTR SERVERNAME_STR;
	static BSTR NAMINGCONTEXTS_STR;
	static BSTR DEFAULTNAMINGCONTEXT_STR;
	static BSTR SCHEMANAMINGCONTEXT_STR;
	static BSTR CONFIGURATIONNAMINGCONTEXT_STR;
	static BSTR ROOTDOMAINNAMINGCONTEXT_STR;
	static BSTR SUPPORTEDCONTROLS_STR;
	static BSTR SUPPORTEDVERSION_STR;
	static BSTR DNSHOSTNAME_STR;
	static BSTR DSSERVICENAME_STR;
	static BSTR HIGHESTCOMMITEDUSN_STR;
	static BSTR LDAPSERVICENAME_STR;
	static BSTR SUPPORTEDCAPABILITIES_STR;
	static BSTR SUPPORTEDLDAPPOLICIES_STR;
	static BSTR SUPPORTEDSASLMECHANISMS_STR;


	// Process query for DS Associations
	HRESULT ProcessAssociationQuery( 
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler,
		SQL1_Parser *pParser);

	// Process Query for DS Instances
	HRESULT ProcessInstanceQuery( 
		BSTR strClass,
		BSTR strQuery,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler,
		SQL1_Parser *pParser);
	
	// COnverts a WQL query to an LDAP Filter. If possible
	HRESULT ConvertWQLToLDAPQuery(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery, int dwLength);

	// Does a query on a specified Root DN
	HRESULT DoSingleQuery(BSTR strClass, IWbemClassObject *pWbemClass, LPCWSTR pszRootDN, LPCWSTR pszLDAPQuery, IWbemObjectSink *pResponseHandler);

	// Gets any static configuration data for enumerating/querying a given class
	HRESULT GetRootDN( LPCWSTR pszClass, LPWSTR **ppszRootDN, DWORD *pdwCount, IWbemContext *pCtx);

	HRESULT MapEmbeddedObjectToWBEM(PADSVALUE pAttribute, LPCWSTR pszQualifierName, IUnknown **ppEmbeddedObject);
	HRESULT MapUint8ArrayToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject);
	HRESULT MapDNWithBinaryToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject);
	HRESULT MapDNWithStringToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject);
	HRESULT MapByteArray(LPBYTE lpBinaryValue, DWORD dwLength, const BSTR strPropertyName, IWbemClassObject *pInstance);

	HRESULT ProcessRootDSEGetObject(BSTR strClassName, IWbemObjectSink *pResponseHandler, IWbemContext *pCtx);
	HRESULT MapRootDSE(IADs *pADSIRootDSE, IWbemClassObject *pWBEMRootDSE);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetBooleanValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetBooleanValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetIntegerValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);

	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetOctetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetOctetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	HRESULT SetDNWithBinaryValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	HRESULT SetDNWithStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetTimeValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);


	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetLargeIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetObjectClassAttribute
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	void SetObjectClassAttribute(PADS_ATTR_INFO pAttributeEntry, LPCWSTR pszADSIClassName);
};


#endif // DS_INSTANCE_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\instprov.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:instprov.cpp $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains implementation of the DS Instance Provider class.
//
//***************************************************************************

#include "precomp.h"
#include <helper.h>

/////////////////////////////////////////
// Initialize the static members
/////////////////////////////////////////
LPCWSTR CLDAPInstanceProvider :: DEFAULT_NAMING_CONTEXT_ATTR	= L"defaultNamingContext";
LPCWSTR CLDAPInstanceProvider :: OBJECT_CLASS_EQUALS			= L"(objectClass=";
LPCWSTR CLDAPInstanceProvider :: QUERY_FORMAT					= L"select * from DSClass_To_DNInstance where DSClass=\"%s\"";
BSTR CLDAPInstanceProvider :: CLASS_STR							= NULL;
BSTR CLDAPInstanceProvider :: DN_PROPERTY						= NULL;
BSTR CLDAPInstanceProvider :: ROOT_DN_PROPERTY					= NULL;
BSTR CLDAPInstanceProvider :: QUERY_LANGUAGE					= NULL;
BSTR CLDAPInstanceProvider :: ADSI_PATH_STR						= NULL;
BSTR CLDAPInstanceProvider :: UINT8ARRAY_STR					= NULL;
BSTR CLDAPInstanceProvider :: DN_WITH_STRING_CLASS_STR			= NULL;
BSTR CLDAPInstanceProvider :: DN_WITH_BINARY_CLASS_STR			= NULL;
BSTR CLDAPInstanceProvider :: VALUE_PROPERTY_STR				= NULL;
BSTR CLDAPInstanceProvider :: DN_STRING_PROPERTY_STR			= NULL;
BSTR CLDAPInstanceProvider :: INSTANCE_ASSOCIATION_CLASS_STR	= NULL;
BSTR CLDAPInstanceProvider :: CHILD_INSTANCE_PROPERTY_STR		= NULL;
BSTR CLDAPInstanceProvider :: PARENT_INSTANCE_PROPERTY_STR		= NULL;
BSTR CLDAPInstanceProvider :: RELPATH_STR						= NULL;
BSTR CLDAPInstanceProvider :: ATTRIBUTE_SYNTAX_STR				= NULL;
BSTR CLDAPInstanceProvider :: DEFAULT_OBJECT_CATEGORY_STR		= NULL;
BSTR CLDAPInstanceProvider :: LDAP_DISPLAY_NAME_STR				= NULL;
BSTR CLDAPInstanceProvider :: PUT_EXTENSIONS_STR				= NULL;
BSTR CLDAPInstanceProvider :: PUT_EXT_PROPERTIES_STR			= NULL;
BSTR CLDAPInstanceProvider :: CIMTYPE_STR						= NULL;

// Names of the RootDSE attributes
BSTR CLDAPInstanceProvider :: SUBSCHEMASUBENTRY_STR							= NULL;
BSTR CLDAPInstanceProvider :: CURRENTTIME_STR								= NULL;
BSTR CLDAPInstanceProvider :: SERVERNAME_STR								= NULL;
BSTR CLDAPInstanceProvider :: NAMINGCONTEXTS_STR							= NULL;
BSTR CLDAPInstanceProvider :: DEFAULTNAMINGCONTEXT_STR						= NULL;
BSTR CLDAPInstanceProvider :: SCHEMANAMINGCONTEXT_STR						= NULL;
BSTR CLDAPInstanceProvider :: CONFIGURATIONNAMINGCONTEXT_STR				= NULL;
BSTR CLDAPInstanceProvider :: ROOTDOMAINNAMINGCONTEXT_STR					= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDCONTROLS_STR							= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDVERSION_STR							= NULL;
BSTR CLDAPInstanceProvider :: DNSHOSTNAME_STR								= NULL;
BSTR CLDAPInstanceProvider :: DSSERVICENAME_STR								= NULL;
BSTR CLDAPInstanceProvider :: HIGHESTCOMMITEDUSN_STR						= NULL;
BSTR CLDAPInstanceProvider :: LDAPSERVICENAME_STR							= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDCAPABILITIES_STR						= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDLDAPPOLICIES_STR						= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDSASLMECHANISMS_STR					= NULL;



//***************************************************************************
//
// CLDAPInstanceProvider::CLDAPInstanceProvider
// CLDAPInstanceProvider::~CLDAPInstanceProvider
//
// Constructor Parameters:
//
//
//***************************************************************************

CLDAPInstanceProvider :: CLDAPInstanceProvider ()
{
	InterlockedIncrement(&g_lComponents);

	// Initialize the search preferences often used
	m_pSearchInfo[0].dwSearchPref		= ADS_SEARCHPREF_SEARCH_SCOPE;
	m_pSearchInfo[0].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[0].vValue.Integer		= ADS_SCOPE_SUBTREE;

	m_pSearchInfo[1].dwSearchPref		= ADS_SEARCHPREF_PAGESIZE;
	m_pSearchInfo[1].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[1].vValue.Integer		= 1024;

	m_lReferenceCount = 0 ;
	m_IWbemServices = NULL;
	m_pWbemUin8ArrayClass = NULL;
	m_pWbemDNWithBinaryClass = NULL;
	m_pWbemDNWithStringClass = NULL;
	m_pAssociationsClass = NULL;
	m_lpszTopLevelContainerPath = NULL;
	m_bInitializedSuccessfully = FALSE;

	if(g_pLogObject)
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CONSTRUCTOR\r\n");
}

CLDAPInstanceProvider::~CLDAPInstanceProvider ()
{
	if(g_pLogObject)
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DESCTRUVTOR\r\n");

	if (m_lpszTopLevelContainerPath)
	{
		delete [] m_lpszTopLevelContainerPath;
	}

	if(m_IWbemServices)
		m_IWbemServices->Release();
	if(m_pWbemUin8ArrayClass)
		m_pWbemUin8ArrayClass->Release();
	if(m_pWbemDNWithBinaryClass)
		m_pWbemDNWithBinaryClass->Release();
	if(m_pWbemDNWithStringClass)
		m_pWbemDNWithStringClass->Release();
	if(m_pAssociationsClass)
		m_pAssociationsClass->Release();

	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CLDAPInstanceProvider::QueryInterface
// CLDAPInstanceProvider::AddRef
// CLDAPInstanceProvider::Release
//
// Purpose: Standard COM routines needed for all COM objects
//
//***************************************************************************

STDMETHODIMP CLDAPInstanceProvider :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) (IUnknown *)(IWbemProviderInit *)this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) (IWbemServices *)this ;
	}
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) (IWbemProviderInit *)this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CLDAPInstanceProvider :: AddRef ()
{
	return InterlockedIncrement ( & m_lReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CLDAPInstanceProvider :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_lReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT CLDAPInstanceProvider :: Initialize(
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{
	// Validate the arguments
	if(pNamespace == NULL || lFlags != 0)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();

	// Get the DefaultNamingContext to get at the top level container
	// Get the ADSI path of the schema container and store it for future use
	IADs *pRootDSE = NULL;
	HRESULT result;

	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pRootDSE)))
	{
		// Get the location of the schema container
		BSTR strDefaultNamingContext = SysAllocString((LPWSTR) DEFAULT_NAMING_CONTEXT_ATTR);

		// Get the DEFAULT_NAMING_CONTEXT property. This property contains the ADSI path
		// of the top level container
		VARIANT variant;
		VariantInit(&variant);
		if(SUCCEEDED(result = pRootDSE->Get(strDefaultNamingContext, &variant)))
		{
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Got Top Level Container as : %s\r\n", variant.bstrVal);

			// Form the top level container path
			m_lpszTopLevelContainerPath = new WCHAR[wcslen(LDAP_PREFIX) + wcslen(variant.bstrVal) + 1];
			wcscpy(m_lpszTopLevelContainerPath, LDAP_PREFIX);
			wcscat(m_lpszTopLevelContainerPath, variant.bstrVal);
			// Get the Uint8Array Class
			if(SUCCEEDED(result = m_IWbemServices->GetObject(UINT8ARRAY_STR, 0, pCtx, &m_pWbemUin8ArrayClass, NULL)))
			{
				// Get the DNWIthBinary Class
				if(SUCCEEDED(result = m_IWbemServices->GetObject(DN_WITH_BINARY_CLASS_STR, 0, pCtx, &m_pWbemDNWithBinaryClass, NULL)))
				{
					// Get the DNWIthBinary Class
					if(SUCCEEDED(result = m_IWbemServices->GetObject(DN_WITH_STRING_CLASS_STR, 0, pCtx, &m_pWbemDNWithStringClass, NULL)))
					{
						// Get the Associations Class
						if(SUCCEEDED(result = m_IWbemServices->GetObject(INSTANCE_ASSOCIATION_CLASS_STR, 0, pCtx, &m_pAssociationsClass, NULL)))
						{
						}
						else
						{
							g_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get Instance Associations class %x\r\n", result);
						}
					}
					else
					{
						g_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get DNWithString class %x\r\n", result);
					}
				}
				else
				{
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get DNWithBinary class %x\r\n", result);
				}
			}
			else
			{
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get Uint8Array class %x\r\n", result);
			}
			VariantClear(&variant);
		}
		SysFreeString(strDefaultNamingContext);
		pRootDSE->Release();
	}

	if(SUCCEEDED(result))
	{
		m_bInitializedSuccessfully = TRUE;
		pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	}
	else
	{
		m_bInitializedSuccessfully = FALSE;
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialize() FAILED \r\n");
		pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	}

	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: OpenNamespace(
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CancelAsyncCall(
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: QueryObjectSink(
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: GetObject(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: GetObjectAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() called for %s \r\n", strObjectPath);

	HRESULT result = S_OK;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
		return WBEM_E_FAILED;
	}

	// Validate the arguments
	if(strObjectPath == NULL)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() argument validation FAILED\r\n");
		return WBEM_E_INVALID_PARAMETER;
	}

	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
			break;
		default:
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() object path parsing FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
	}

	try
	{
		// Check if this is for associations
		if(_wcsicmp(theParsedObjectPath->m_pClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0)
		{
			// Check whether there are exactly 2 keys specified
			if(theParsedObjectPath->m_dwNumKeys != 2)
				result = WBEM_E_INVALID_PARAMETER;

			// Check whether these keys are
			KeyRef *pChildKeyRef = *(theParsedObjectPath->m_paKeys);
			KeyRef *pParentKeyRef = *(theParsedObjectPath->m_paKeys + 1);

			if(_wcsicmp(pChildKeyRef->m_pName, CHILD_INSTANCE_PROPERTY_STR) != 0)
			{
				// Exchange them
				KeyRef *temp = pChildKeyRef;
				pChildKeyRef = pParentKeyRef;
				pParentKeyRef = pChildKeyRef;
			}

			// The status on the sink
			IWbemClassObject *ppReturnWbemClassObjects[1];
			ppReturnWbemClassObjects[0] = NULL;

			if(SUCCEEDED(result))
			{
				// Convert the key values to ADSI paths
				LPWSTR pszChildADSIPath = NULL;
				LPWSTR pszParentADSIPath = NULL;

				try
				{
					pszChildADSIPath = CWBEMHelper::GetADSIPathFromObjectPath(pChildKeyRef->m_vValue.bstrVal);
					pszParentADSIPath = CWBEMHelper::GetADSIPathFromObjectPath(pParentKeyRef->m_vValue.bstrVal);

					if(SUCCEEDED(result = IsContainedIn(pszChildADSIPath, pszParentADSIPath)))
					{
						if(result == S_OK)
						{
							if(SUCCEEDED(result = CreateWBEMInstance(pChildKeyRef->m_vValue.bstrVal, pParentKeyRef->m_vValue.bstrVal, ppReturnWbemClassObjects)))
							{
								result = pResponseHandler->Indicate(1, ppReturnWbemClassObjects);
								ppReturnWbemClassObjects[0]->Release();
							}
						}
						else // the instance was not found
						{
							g_pLogObject->WriteW( L"CLDAPInstanceProvider :: returning WBEM_E_NOT_FOUND for %s \r\n", strObjectPath);
							result = WBEM_E_NOT_FOUND;
						}
					}
					else
					{
						g_pLogObject->WriteW( L"CLDAPInstanceProvider :: IsContainedIn() FAILED with %x \r\n", result);
					}
				}
				catch ( ... )
				{
					if ( pszChildADSIPath )
					{
						delete [] pszChildADSIPath;
						pszChildADSIPath = NULL;
					}

					if ( pszParentADSIPath )
					{
						delete [] pszParentADSIPath;
						pszParentADSIPath = NULL;
					}

					throw;
				}

				if ( pszChildADSIPath )
				{
					delete [] pszChildADSIPath;
					pszChildADSIPath = NULL;
				}

				if ( pszParentADSIPath )
				{
					delete [] pszParentADSIPath;
					pszParentADSIPath = NULL;
				}
			}
		}
		// Check if this is for the RootDSE class
		else if(_wcsicmp(theParsedObjectPath->m_pClass, ROOTDSE_CLASS) == 0)
		{
			result = ProcessRootDSEGetObject(theParsedObjectPath->m_pClass, pResponseHandler, pCtx);
		}
		else // It is for ADSI instances
		{
			// Check whether there is exactly 1 key specified
			if(theParsedObjectPath->m_dwNumKeys != 1 )
				result = WBEM_E_INVALID_PARAMETER;

			// Get the key
			KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);

			// Check to see that the key name is correct, if it is present
			if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_STR) != 0)
				result = WBEM_E_INVALID_PARAMETER;

			// The status on the sink
			IWbemClassObject *ppReturnWbemClassObjects[1];
			ppReturnWbemClassObjects[0] = NULL;

			if(SUCCEEDED(result))
			{
				// Get the ADSI object
				CADSIInstance *pADSIObject = NULL;
				if(SUCCEEDED(result = CLDAPHelper::GetADSIInstance(pKeyRef->m_vValue.bstrVal, &pADSIObject, g_pLogObject)))
				{
					try
					{
						// Get the class to spawn an instance
						IWbemClassObject *pWbemClass = NULL;
						if(SUCCEEDED(result = m_IWbemServices->GetObject(theParsedObjectPath->m_pClass, 0, pCtx, &pWbemClass, NULL)))
						{
							try
							{
								// Spawn a instance of the WBEM Class
								if(SUCCEEDED(result = pWbemClass->SpawnInstance(0, ppReturnWbemClassObjects)))
								{
									// Map it to WBEM
									if(SUCCEEDED(result = MapADSIInstance(pADSIObject, ppReturnWbemClassObjects[0], pWbemClass)))
									{
										// Indicate the result
										if(FAILED(result = pResponseHandler->Indicate(1, ppReturnWbemClassObjects)))
										{
											g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync : Indicate() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
										}
									}
									else
									{
										g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync : MapADSIInstance() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
									}
									ppReturnWbemClassObjects[0]->Release();
								}
								else
								{
									g_pLogObject->WriteW( L"CLDAPInstanceProvider :: SpawnInstance() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
								}
							}
							catch ( ... )
							{
								pWbemClass->Release();
								pWbemClass = NULL;

								throw;
							}

							pWbemClass->Release();
						}
						else
						{
							g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() GetObject() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
						}
					}
					catch ( ... )
					{
						pADSIObject->Release();
						pADSIObject = NULL;

						throw;
					}

					pADSIObject->Release();
				}
				else
				{
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync : GetADSIInstance() FAILED with %x \r\n", result);
				}
			}
			else
			{
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() Argument processing FAILED \r\n");
			}
		}
	}
	catch ( ... )
	{
		theParser.Free(theParsedObjectPath);
		throw;
	}

	// Free the parser object path
	theParser.Free(theParsedObjectPath);

	// Set the status of the request
	result = (SUCCEEDED(result)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND);
	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, result, NULL, NULL);

	if(SUCCEEDED(result))
		g_pLogObject->WriteW( L"XXXXXXXXXXXXXXXXX CLDAPInstanceProvider :: GetObjectAsync() succeeded for %s\r\n", strObjectPath);
	else
		g_pLogObject->WriteW( L"XXXXXXXXXXXXXXXXX CLDAPInstanceProvider :: GetObjectAsync() FAILED for %s\r\n", strObjectPath);
	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: PutClass(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: PutClassAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: DeleteClass(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: DeleteClassAsync(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CreateClassEnum(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CreateClassEnumAsync(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: PutInstance(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstance() called\r\n");
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: PutInstanceAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() called\r\n");

	HRESULT result = WBEM_S_NO_ERROR;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() CoImpersonate FAILED forwith %x\r\n", result);
		return WBEM_E_FAILED;
	}

	// Get the object ref of the instance being put
	BSTR strRelPath = NULL;
	if(SUCCEEDED(CWBEMHelper::GetBSTRProperty(pInst, RELPATH_STR, &strRelPath)))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync()  calledfor %s\r\n", strRelPath);
		// Check to see if the ADSI Path is present.
		// Parse the object path
		// Parse the object path
		CObjectPathParser theParser;
		ParsedObjectPath *theParsedObjectPath = NULL;
		LPWSTR pszADSIPath = NULL;
		LPWSTR pszWBEMClass = NULL;
		LPWSTR pszADSIClass = NULL;

		try
		{
			switch(theParser.Parse((LPWSTR)strRelPath, &theParsedObjectPath))
			{
				case CObjectPathParser::NoError:
				{
					KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);
					// Check to see that there is 1 key specified and that its type is VT_BSTR
					if(pKeyRef && theParsedObjectPath->m_dwNumKeys == 1 && pKeyRef->m_vValue.vt == VT_BSTR)
					{
						try
						{
							// If the name of the key is specified, check the name
							if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_STR) != 0)
								break;

							pszADSIPath = new WCHAR[wcslen((*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal) + 1];
							wcscpy(pszADSIPath, (*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal);
							pszWBEMClass = new WCHAR[wcslen(theParsedObjectPath->m_pClass) + 1];
							wcscpy(pszWBEMClass, theParsedObjectPath->m_pClass);
						}
						catch ( ... )
						{
							theParser.Free(theParsedObjectPath);
							throw;
						}
					}
					break;
				}
				default:
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() Parsing of RELPATH FAILED\r\n");
					SysFreeString(strRelPath);
					return WBEM_E_FAILED;
					break;
			}

			try
			{
				if(pszWBEMClass)
				{
					// CHeck to see if the class is the containment/RootDSE class, if so disallow the operation
					if(_wcsicmp(theParsedObjectPath->m_pClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0 ||
						_wcsicmp(theParsedObjectPath->m_pClass, ROOTDSE_CLASS) == 0 )
					{
						result =  WBEM_E_PROVIDER_NOT_CAPABLE;
					}
					else
						pszADSIClass = CLDAPHelper::UnmangleWBEMNameToLDAP(pszWBEMClass);
				}
			}
			catch ( ... )
			{
				theParser.Free(theParsedObjectPath);
				throw;
			}

			// Free the parser object path
			theParser.Free(theParsedObjectPath);

			if ( strRelPath )
			{
				SysFreeString(strRelPath);
				strRelPath = NULL;
			}

			if ( pszWBEMClass )
			{
				delete [] pszWBEMClass;
				pszWBEMClass = NULL;
			}

			if(pszADSIPath && pszADSIClass && SUCCEEDED(result))
			{
				// Try to retreive the existing object
				// Get the ADSI object
				CADSIInstance *pADSIObject = NULL;
				result = CLDAPHelper::GetADSIInstance(pszADSIPath, &pADSIObject, g_pLogObject);

				try
				{
					// Check if the WBEM_FLAG_UPDATE_ONLY flag is specified
					if(lFlags & WBEM_FLAG_UPDATE_ONLY)
					{
						if(!pADSIObject)
							result = WBEM_E_FAILED;
					}
					// Check if the WBEM_FLAG_CREATE_ONLY flag is specified
					if(SUCCEEDED(result) && lFlags & WBEM_FLAG_CREATE_ONLY)
					{
						if(pADSIObject)
							result = WBEM_E_ALREADY_EXISTS;
					}
					else
						result = WBEM_S_NO_ERROR;

					if(SUCCEEDED(result))
					{
						if(pADSIObject)
						{
							if(SUCCEEDED(result = ModifyExistingADSIInstance(pInst, pszADSIPath, pADSIObject, pszADSIClass, pCtx)))
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync()  ModifyExistingInstance succeeded for %s\r\n", pszADSIPath);
							else
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() ModifyExistingInstance FAILED for %s with %x\r\n", pszADSIPath, result);
						}
						else
						{
							if(SUCCEEDED(result = CreateNewADSIInstance(pInst, pszADSIPath, pszADSIClass)))
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() CreateNewInstance succeeded for %s\r\n", pszADSIPath);
							else
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() CreateNewInstance FAILED for %s with %x\r\n", pszADSIPath, result);
						}
					}
				}
				catch ( ... )
				{
					// Release any existing object
					if(pADSIObject)
					{
						pADSIObject->Release();
						pADSIObject = NULL;
					}

					throw;
				}

				// Release any existing object
				if(pADSIObject)
					pADSIObject->Release();
			}
			else
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() one of ADSIPath or ADSIClass is NULL\r\n");
		}
		catch ( ... )
		{
			if ( strRelPath )
			{
				SysFreeString(strRelPath);
				strRelPath = NULL;
			}

			if ( pszWBEMClass )
			{
				delete [] pszWBEMClass;
				pszWBEMClass = NULL;
			}

			if ( pszADSIClass )
			{
				delete [] pszADSIClass;
				pszADSIClass = NULL;
			}

			if ( pszADSIPath )
			{
				delete [] pszADSIPath;
				pszADSIPath = NULL;
			}

			throw;
		}

		delete [] pszADSIClass;
		delete [] pszADSIPath;
	}
	else
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync()  FAILED to get RELPATH \r\n");

	// Set the status of the request
	result = (SUCCEEDED(result)? WBEM_S_NO_ERROR : WBEM_E_FAILED);
	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, result, NULL, NULL);
	return result;
}

HRESULT CLDAPInstanceProvider :: DeleteInstance(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: DeleteInstanceAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() called for %s\r\n", strObjectPath);

	HRESULT result = S_OK;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
		return WBEM_E_FAILED;
	}

	// Validate the arguments
	if(strObjectPath == NULL)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() argument validation FAILED\r\n");
		return WBEM_E_INVALID_PARAMETER;
	}

	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
			break;
		default:
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() object path parsing FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
	}

	// CHeck to see if the class is the containment/RootDSE class, if so disallow the operation
	if(_wcsicmp(theParsedObjectPath->m_pClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0 ||
		_wcsicmp(theParsedObjectPath->m_pClass, ROOTDSE_CLASS) == 0 )
	{
		result =  WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	// Check whether there is exactly 1 key specified
	if(theParsedObjectPath->m_dwNumKeys != 1 )
		result = WBEM_E_INVALID_PARAMETER;

	// Get the key
	KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);

	// Check to see that the key name is correct, if it is present
	if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_STR) != 0)
		result = WBEM_E_INVALID_PARAMETER;

	// Unfortunately, ADSI uses different interfaces to delete containers and non-containers
	//=======================================================================================
	if(SUCCEEDED(result))
	{
		IDirectoryObject *pDirectoryObject = NULL;
		if(SUCCEEDED(result = ADsOpenObject(pKeyRef->m_vValue.bstrVal, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pDirectoryObject)))
		{
			PADS_OBJECT_INFO pObjectInfo = NULL;
			if(SUCCEEDED(result = pDirectoryObject->GetObjectInformation(&pObjectInfo)))
			{
				// CHeck whether it is the same class as the class being deleted.
				LPWSTR pszWbemClass = CLDAPHelper::MangleLDAPNameToWBEM(pObjectInfo->pszClassName);
				if(_wcsicmp(theParsedObjectPath->m_pClass, pszWbemClass) == 0)
				{
					// Get its parent. THis should be the container from which the child is deleted
					IADsContainer *pParent = NULL;
					if(SUCCEEDED(result = ADsOpenObject(pObjectInfo->pszParentDN, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsContainer, (LPVOID *)&pParent)))
					{
						if(SUCCEEDED(result = pParent->Delete(pObjectInfo->pszClassName, pObjectInfo->pszRDN)))
						{
							g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() Deleted %s successfully\r\n", pKeyRef->m_vValue.bstrVal);
							result = WBEM_S_NO_ERROR;
						}
						else
						{
							if (HRESULT_CODE(result) == ERROR_DS_CANT_ON_NON_LEAF)
							{
								// this is non-empty container we wanted to delete here
								IADsDeleteOps *pADsDeleteOps = NULL;
								if(SUCCEEDED(result = ADsOpenObject(pKeyRef->m_vValue.bstrVal, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsDeleteOps, (LPVOID *)&pADsDeleteOps)))
								{
									if(FAILED(result = pADsDeleteOps->DeleteObject(0)))
									{
										g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() DeleteObject FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);

										if ( result == ERROR_DS_AUTH_METHOD_NOT_SUPPORTED )
										{
											result = WBEM_E_ACCESS_DENIED;
										}
										else
										{
											result = WBEM_E_FAILED;
										}
									}

									pADsDeleteOps->Release();
								}
							}
							else
							{
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() DeleteDSObject FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
								result = WBEM_E_FAILED;
							}
						}
						pParent->Release();
					}
					else
					{
						g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() ADsOpenObject on parent FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
						result = WBEM_E_FAILED;
					}
				}
				else
				{
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() wrong class returning success\r\n");
					result = WBEM_S_NO_ERROR;
				}

				delete [] pszWbemClass;
				FreeADsMem((LPVOID *) pObjectInfo);
			}
			else
			{
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() GetObjectInformation FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
				result = WBEM_E_NOT_FOUND;
			}
			pDirectoryObject->Release();
		}
		else
		{
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() ADsOpenObject FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
			result = WBEM_E_NOT_FOUND;
		}
	}
	// Free the parser object path
	theParser.Free(theParsedObjectPath);

	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , result, NULL, NULL);

	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: CreateInstanceEnum(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CreateInstanceEnumAsync(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}
	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync() called for %s Class \r\n", strClass  );

	HRESULT result;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync() CoImpersonate FAILED for %s with %x\r\n", strClass, result);
		return WBEM_E_FAILED;
	}

	// CHeck to see if the class is the containment class, if so disallow an enumeration
	if(_wcsicmp(strClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CLDAPInstanceProvider() Enumeration called on the containment class. Returning FAILED : WBEM_E_PROVIDER_NOT_CAPABLE\r\n");
		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}
	// Check if this is for the RootDSE class
	else if(_wcsicmp(strClass, ROOTDSE_CLASS) == 0)
	{
		result = ProcessRootDSEGetObject(strClass, pResponseHandler, pCtx);
	}
	else // The rest of the classes
	{

		// Fetch the class from CIMOM
		IWbemClassObject *pWbemClass = NULL;
		if(SUCCEEDED(result = m_IWbemServices->GetObject(strClass, 0, pCtx, &pWbemClass, NULL)))
		{
			// We need the object category information
			LPWSTR pszLDAPQuery = new WCHAR[10*(wcslen(strClass) + 25) + 50];
			if(SUCCEEDED(CWBEMHelper::FormulateInstanceQuery(m_IWbemServices, pCtx, strClass, pWbemClass, pszLDAPQuery, LDAP_DISPLAY_NAME_STR, DEFAULT_OBJECT_CATEGORY_STR)))
			{
		
				// Check to see if the client has specified any hints as to the DN of the object from
				// which the search should start
				BOOLEAN bRootDNSpecified = FALSE;
				LPWSTR *ppszRootDN = NULL;
				DWORD dwRootDNCount = 0;
				if(SUCCEEDED(GetRootDN(strClass, &ppszRootDN, &dwRootDNCount, pCtx)) && dwRootDNCount)
					bRootDNSpecified = TRUE;

				// Enumerate the ADSI Instances
				// If any RootDNs were specified, use them. Otherwise use the default naming context

				if(bRootDNSpecified)
				{
					for( DWORD i=0; i<dwRootDNCount; i++)
					{
						DoSingleQuery(strClass, pWbemClass, ppszRootDN[i], pszLDAPQuery,  pResponseHandler);
					}
				}
				else
				{
					DoSingleQuery(strClass, pWbemClass, m_lpszTopLevelContainerPath, pszLDAPQuery,  pResponseHandler);
				}

				if(bRootDNSpecified)
				{
					for(DWORD i=0; i<dwRootDNCount; i++)
					{
						delete [] ppszRootDN[i];
					}
					delete [] ppszRootDN;
				}

			}
			else
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync : FormulateInstanceQuery() FAILED for %s with %x \r\n", strClass, result);
			delete [] pszLDAPQuery;
			pWbemClass->Release();
		}
		else
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync : GetObject() FAILED for %s with %x \r\n", strClass, result);
	}

	if(SUCCEEDED(result))
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
		g_pLogObject->WriteW( L"XXXXXXXXXXXXX CLDAPInstanceProvider :: CreateInstanceEnumAsync() Enumeration succeeded for %s\r\n", strClass);
		return WBEM_S_NO_ERROR;
	}
	else
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
		g_pLogObject->WriteW( L"XXXXXXXXXXXXX CLDAPInstanceProvider :: CreateInstanceEnumAsync() Enumeration FAILED for %s\r\n", strClass);
		return WBEM_S_NO_ERROR;
	}
}

HRESULT CLDAPInstanceProvider :: ExecQuery(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecQueryAsync(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ExecQueryAsync() called with %s\r\n", strQuery);

	HRESULT result;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ExecQueryAsync() CoImpersonate FAILED for %s with %x\r\n", strQuery, result);
		return WBEM_E_FAILED;
	}

	// Create Parser for the Query.
    CTextLexSource src(strQuery);
    SQL1_Parser parser(&src);

    // Get the class name
    wchar_t classbuf[128];
    *classbuf = 0;
    parser.GetQueryClass(classbuf, 127);

	// Compare to see if it is the association class, Otherwise do an enuemration
	if(_wcsicmp(classbuf, INSTANCE_ASSOCIATION_CLASS_STR) != 0)
	{
		BSTR strClass = SysAllocString((LPWSTR)classbuf);

		// Ask CIMOM to postprocess the result
		pResponseHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, WBEM_S_NO_ERROR, NULL, NULL);

		// Try to process the query myself. If not successful, enumerate
		if(SUCCEEDED(result = ProcessInstanceQuery(strClass, strQuery, pCtx, pResponseHandler, &parser)))
		{
			pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
		}
		else
		{
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ExecQueryAsync() FAILED to process query %s. Resorting to enumeration\r\n", strQuery);
			CreateInstanceEnumAsync(strClass, 0, pCtx, pResponseHandler);
		}

		SysFreeString(strClass);
	}
	else
	{
		// Process query for associations
		result = ProcessAssociationQuery(pCtx, pResponseHandler, &parser);
	}

	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: ExecNotificationQuery(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecNotificationQueryAsync(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecMethod(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecMethodAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}


// Maps an ADSI Instance to WBEM
HRESULT CLDAPInstanceProvider :: MapADSIInstance(CADSIInstance *pADSIObject, IWbemClassObject *pWbemObject, IWbemClassObject *pWbemClass)
{
	DWORD dwNumAttributes = 0;
	PADS_ATTR_INFO pAttributeEntries = pADSIObject->GetAttributes(&dwNumAttributes);
	HRESULT result;
	for(DWORD i=0; i<dwNumAttributes; i++)
	{
		PADS_ATTR_INFO pNextAttribute = pAttributeEntries+i;

		// Get the WBEM Property Name
		LPWSTR pszWbemName = CLDAPHelper::MangleLDAPNameToWBEM(pNextAttribute->pszAttrName);
		BSTR strWbemName = SysAllocString(pszWbemName);
		delete[] pszWbemName;

		// No point in checking the return code, except for logging
		if(SUCCEEDED(result = MapPropertyValueToWBEM(strWbemName, pWbemClass, pWbemObject, pNextAttribute)))
		{
		}
		else if( result != WBEM_E_NOT_FOUND )
		{
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapADSIInstance() MapPropertyValueToWBEM FAILED with %x for attribute %s\r\n", result, strWbemName);
		}
		SysFreeString(strWbemName);
	}

	// Map the key property and other properties of the base-most class
	PADS_OBJECT_INFO pObjectInfo = pADSIObject->GetObjectInfo();
	if(!SUCCEEDED(result = CWBEMHelper::PutBSTRPropertyT(pWbemObject, ADSI_PATH_STR, pObjectInfo->pszObjectDN, FALSE)))
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapADSIInstance() Put FAILED for Key Property  with %x\r\n", result);

	return S_OK;
}

// Gets the IDIrectoryObject interface on an ADSI instance
HRESULT CLDAPInstanceProvider :: MapPropertyValueToWBEM(BSTR strWbemName, IWbemClassObject *pWbemClass, IWbemClassObject *pWbemObject, PADS_ATTR_INFO pAttribute)
{
	// This happens in WMI Stress sometimes.
	if(pAttribute->dwADsType == ADSTYPE_INVALID || pAttribute->dwADsType == ADSTYPE_PROV_SPECIFIC)
		return E_FAIL;

	VARIANT variant;
	VariantInit(&variant);
	CIMTYPE cimType;

	// Get the CIM TYPE of the property
	VARIANT dummyUnused;
	VariantInit(&dummyUnused);

	HRESULT result = pWbemClass->Get(strWbemName, 0, &dummyUnused, &cimType, NULL);

	VariantClear(&dummyUnused);

	// Whether the value was mapped successfully;
	BOOLEAN bMappedValue = FALSE;

	if(SUCCEEDED(result))
	{
		if(cimType & CIM_FLAG_ARRAY)
		{
			switch(cimType & ~CIM_FLAG_ARRAY)
			{
				case CIM_BOOLEAN:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BOOL, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						if(FAILED(result = SafeArrayPutElement ( safeArray , &index , &(pNextValue->Boolean))))
							break;
						pNextValue ++;
					}
					if(SUCCEEDED(result))
					{
						variant.vt = VT_ARRAY | VT_BOOL;
						variant.parray = safeArray;
						bMappedValue = TRUE;
					}
					else
						SafeArrayDestroy(safeArray);
					break;
				}
				case CIM_SINT32:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_I4, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						if(FAILED(result = SafeArrayPutElement ( safeArray , &index , &(pNextValue->Integer))))
							break;
						pNextValue ++;
					}
					if(SUCCEEDED(result))
					{
						variant.vt = VT_ARRAY | VT_I4;
						variant.parray = safeArray;
						bMappedValue = TRUE;
					}
					else
						SafeArrayDestroy(safeArray);

					break;
				}
				case CIM_SINT64:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BSTR, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					WCHAR temp[22]; // number of characters for biggest i64 plus sign and terminator
					BSTR strTemp = NULL;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						swprintf(temp, L"%I64d", (pNextValue->LargeInteger).QuadPart);
						strTemp = SysAllocString(temp);
						OnDelete<BSTR,VOID(*)(BSTR),SysFreeString> dm(strTemp);
						if(FAILED(result = SafeArrayPutElement ( safeArray , &index , strTemp)))
						{
							break;
						}
						pNextValue ++;
					}

					if(SUCCEEDED(result))
					{
						variant.vt = VT_ARRAY | VT_BSTR;
						variant.parray = safeArray;
						bMappedValue = TRUE;
					}
					else
						SafeArrayDestroy(safeArray);
					break;
				}
				case CIM_STRING:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BSTR, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					BSTR strTemp = NULL;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
    					strTemp = SysAllocString(pNextValue->DNString);
    					OnDelete<BSTR,VOID(*)(BSTR),SysFreeString> dm(strTemp);
						if(FAILED(result = SafeArrayPutElement ( safeArray , &index , strTemp)))
						{
							break;
						}
						pNextValue ++;
					}
					if(SUCCEEDED(result))
					{
						variant.vt = VT_ARRAY | VT_BSTR;
						variant.parray = safeArray;
						bMappedValue = TRUE;
					}
					else
						SafeArrayDestroy(safeArray);
					break;
				}

				case CIM_DATETIME:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BSTR, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					BSTR strTemp = NULL;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						WBEMTime wbemValue(pNextValue->UTCTime);
						strTemp = wbemValue.GetDMTF(TRUE);
						OnDelete<BSTR,VOID(*)(BSTR),SysFreeString> dm(strTemp);
						if(FAILED(result = SafeArrayPutElement ( safeArray , &index , strTemp)))
						{
							break;
						}
						pNextValue ++;
					}
					if(SUCCEEDED(result))
					{
						variant.vt = VT_ARRAY | VT_BSTR;
						variant.parray = safeArray;
						bMappedValue = TRUE;
					}
					else
						SafeArrayDestroy(safeArray);

					break;
				}

				case CIM_OBJECT:
				{
					// Get its cimType Qualifier to determine the "type" of the embedded object
					IWbemQualifierSet *pQualifierSet = NULL;
					if(SUCCEEDED(pWbemClass->GetPropertyQualifierSet(strWbemName, &pQualifierSet)))
					{
						LPWSTR pszQualifierValue = NULL;
						if(SUCCEEDED(CWBEMHelper::GetBSTRQualifierT(pQualifierSet, CIMTYPE_STR, &pszQualifierValue, NULL)))
						{

							// Create the safe array elements
							SAFEARRAY *safeArray;
							DWORD dwLength = pAttribute->dwNumValues;
							SAFEARRAYBOUND safeArrayBounds [ 1 ];
							safeArrayBounds[0].lLbound = 0;
							safeArrayBounds[0].cElements = dwLength;
							safeArray = SafeArrayCreate(VT_UNKNOWN, 1, safeArrayBounds);
							PADSVALUE pNextValue = pAttribute->pADsValues;
							IUnknown *pNextObject = NULL;
							for ( long index = 0; index<(long)dwLength; index ++ )
							{
								// Put the Embedded object in the array
								if(SUCCEEDED(MapEmbeddedObjectToWBEM(pNextValue, pszQualifierValue, &pNextObject)))
								{
								    OnDelete<IUnknown *,VOID(*)(IUnknown *),RM> dm(pNextObject);
									if(FAILED(result = SafeArrayPutElement ( safeArray , &index , pNextObject)))
									{
										break;
									}
									pNextObject = NULL;
								}
								else
									break;

								pNextValue ++;
							}
							if(SUCCEEDED(result))
							{
								variant.vt = VT_ARRAY | VT_UNKNOWN;
								variant.parray = safeArray;
								if(index == (long)dwLength)
									bMappedValue = TRUE;
							}
							else
								SafeArrayDestroy(safeArray);

							delete[] pszQualifierValue;
						}
						pQualifierSet->Release();
					}
					break;
				}
				default:
					break;
			}
		}
		else
		{
			switch(cimType)
			{
			case CIM_BOOLEAN:
				variant.vt = VT_BOOL;
				variant.boolVal = (pAttribute->pADsValues->Boolean)? VARIANT_TRUE : VARIANT_FALSE;
				bMappedValue = TRUE;
				break;

			case CIM_SINT32:
				variant.vt = VT_I4;
				variant.lVal = pAttribute->pADsValues->Integer;
				bMappedValue = TRUE;
				break;

			case CIM_SINT64:
				variant.vt = VT_BSTR;
				WCHAR temp[22]; // number of characters for biggest i64 plus sign an terminator
				swprintf(temp, L"%I64d", (pAttribute->pADsValues->LargeInteger).QuadPart);
				variant.bstrVal = SysAllocString(temp);
				bMappedValue = TRUE;
				break;

			case CIM_STRING:
				variant.vt = VT_BSTR;
				if(pAttribute->pADsValues->DNString)
				{
					variant.bstrVal = SysAllocString(pAttribute->pADsValues->DNString);
					bMappedValue = TRUE;
				}
				break;

			case CIM_OBJECT:
			{
				// Get its cimType Qualifier to determine the "type" of the embedded object
				IWbemQualifierSet *pQualifierSet = NULL;
				if(SUCCEEDED(pWbemClass->GetPropertyQualifierSet(strWbemName, &pQualifierSet)))
				{
					LPWSTR pszQualifierValue = NULL;
					if(SUCCEEDED(CWBEMHelper::GetBSTRQualifierT(pQualifierSet, CIMTYPE_STR, &pszQualifierValue, NULL)))
					{
						IUnknown *pEmbeddedObject = NULL;
						if(SUCCEEDED(MapEmbeddedObjectToWBEM(pAttribute->pADsValues, pszQualifierValue, &pEmbeddedObject)))
						{
							variant.vt = VT_UNKNOWN;
							variant.punkVal = pEmbeddedObject;
							bMappedValue = TRUE;
						}

						delete[] pszQualifierValue;
					}
					pQualifierSet->Release();
				}

			}
			break;

			case CIM_DATETIME:
			{
				variant.vt = VT_BSTR;
				WBEMTime wbemValue(pAttribute->pADsValues->UTCTime);
				if(variant.bstrVal = wbemValue.GetDMTF(TRUE))
					bMappedValue = TRUE;
			}
			break;

			default:
				break;
			}
		}
	}


	if(bMappedValue && FAILED(result = pWbemObject->Put(strWbemName, 0, &variant, NULL)))
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapADSIInstance() Put FAILED for %s with %x\r\n", strWbemName, result);

	VariantClear(&variant);
	return result;
}

HRESULT CLDAPInstanceProvider :: MapEmbeddedObjectToWBEM(PADSVALUE pAttribute, LPCWSTR pszQualifierName, IUnknown **ppEmbeddedObject)
{
	HRESULT result = WBEM_E_FAILED;

	// Skip the "object:" prefix while comparing
	//===========================================
	if (_wcsicmp(pszQualifierName+7, UINT8ARRAY_STR) == 0)
		result = MapUint8ArrayToWBEM(pAttribute, ppEmbeddedObject);
	else if(_wcsicmp(pszQualifierName+7, DN_WITH_BINARY_CLASS_STR) == 0)
		result = MapDNWithBinaryToWBEM(pAttribute, ppEmbeddedObject);
	else if (_wcsicmp(pszQualifierName+7, DN_WITH_STRING_CLASS_STR) == 0)
		result = MapDNWithStringToWBEM(pAttribute, ppEmbeddedObject);
	else
		result = E_FAIL;
	return result;
}

HRESULT CLDAPInstanceProvider :: MapUint8ArrayToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject)
{
	HRESULT result = E_FAIL;

	*ppEmbeddedObject = NULL;
	IWbemClassObject *pEmbeddedObject;
	if(SUCCEEDED(result = m_pWbemUin8ArrayClass->SpawnInstance(0, &pEmbeddedObject)))
	{
		if(SUCCEEDED(result = MapByteArray((pAttribute->OctetString).lpValue ,(pAttribute->OctetString).dwLength, VALUE_PROPERTY_STR, pEmbeddedObject)))
		{
			// Get the IUnknown interface of the embedded object
			if(SUCCEEDED(result = pEmbeddedObject->QueryInterface(IID_IUnknown, (LPVOID *)ppEmbeddedObject)))
			{
			}
		}
		pEmbeddedObject->Release();
	}
	return result;
}

HRESULT CLDAPInstanceProvider :: MapByteArray(LPBYTE lpBinaryValue, DWORD dwLength, const BSTR strPropertyName, IWbemClassObject *pInstance)
{
	HRESULT result = S_OK;
	// Create the safe array of uint8 elements
	SAFEARRAY *safeArray = NULL;
	SAFEARRAYBOUND safeArrayBounds [ 1 ];
	safeArrayBounds[0].lLbound = 0;
	safeArrayBounds[0].cElements = dwLength;
	safeArray = SafeArrayCreate(VT_UI1, 1, safeArrayBounds);
	for ( long index = 0; index<(long)dwLength; index ++ )
	{
		if(FAILED(result = SafeArrayPutElement ( safeArray , &index ,  lpBinaryValue+index)))
			break;
	}

	if(SUCCEEDED(result))
	{
		VARIANT embeddedVariant;
		VariantInit(&embeddedVariant);
		embeddedVariant.vt = VT_ARRAY | VT_UI1;
		embeddedVariant.parray = safeArray;

		result = pInstance->Put(strPropertyName, 0, &embeddedVariant, 0);
		VariantClear(&embeddedVariant);
	}
	else
		SafeArrayDestroy(safeArray);

	return result;
}

HRESULT CLDAPInstanceProvider :: MapDNWithBinaryToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject)
{
	
	HRESULT result = E_FAIL;
	IWbemClassObject *pEmbeddedObject;
	if(SUCCEEDED(result = m_pWbemDNWithBinaryClass->SpawnInstance(0, &pEmbeddedObject)))
	{
		if(pAttribute->pDNWithBinary->pszDNString && SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(pEmbeddedObject, DN_STRING_PROPERTY_STR, SysAllocString(pAttribute->pDNWithBinary->pszDNString), TRUE)))
		{
			if(SUCCEEDED(result = MapByteArray(pAttribute->pDNWithBinary->lpBinaryValue, pAttribute->pDNWithBinary->dwLength, VALUE_PROPERTY_STR, pEmbeddedObject)))
			{
				// Get the IUnknown interface of the embedded object
				if(SUCCEEDED(result = pEmbeddedObject->QueryInterface(IID_IUnknown, (LPVOID *)ppEmbeddedObject)))
				{
				}
			}
		}
		pEmbeddedObject->Release();
	}
	return result;
}

HRESULT CLDAPInstanceProvider :: MapDNWithStringToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject)
{
	HRESULT result = E_FAIL;

	IWbemClassObject *pEmbeddedObject;
	if(SUCCEEDED(result = m_pWbemDNWithStringClass->SpawnInstance(0, &pEmbeddedObject)))
	{

		if(pAttribute->pDNWithString->pszDNString && SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(pEmbeddedObject, DN_STRING_PROPERTY_STR, SysAllocString(pAttribute->pDNWithString->pszDNString), TRUE)))
		{
			if(pAttribute->pDNWithString->pszStringValue && SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(pEmbeddedObject, VALUE_PROPERTY_STR, SysAllocString(pAttribute->pDNWithString->pszStringValue), TRUE)))
			{
				// Get the IUnknown interface of the embedded object
				if(SUCCEEDED(result = pEmbeddedObject->QueryInterface(IID_IUnknown, (LPVOID *)ppEmbeddedObject)))
				{
				}
			}
		}
		pEmbeddedObject->Release();
	}
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::IsContainedIn
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: IsContainedIn(LPCWSTR pszChildInstance, LPCWSTR pszParentInstance)
{
	IDirectoryObject *pDirectoryObject = NULL;
	HRESULT result = S_FALSE;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszChildInstance, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *) &pDirectoryObject)))
	{
		PADS_OBJECT_INFO pObjectInfo = NULL;
		if(SUCCEEDED(result = pDirectoryObject->GetObjectInformation(&pObjectInfo)))
		{
			if(_wcsicmp(pszParentInstance, pObjectInfo->pszParentDN) == 0)
				result = S_OK;
			else
				result = S_FALSE;
			FreeADsMem((LPVOID *)pObjectInfo);
		}
		pDirectoryObject->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::CreateWBEMInstance
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: CreateWBEMInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance)
{
	HRESULT result;
	if(SUCCEEDED(result = m_pAssociationsClass->SpawnInstance(0, ppInstance)))
	{
		// Put the property values
		if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, CHILD_INSTANCE_PROPERTY_STR, strChildName, FALSE)))
		{
			if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, PARENT_INSTANCE_PROPERTY_STR, strParentName, FALSE)))
			{
			}
			else
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateWBEMInstance() PutBSTRProperty on parent property FAILED %x \r\n", result);
		}
		else
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateWBEMInstance() PutBSTRProperty on child property FAILED %x \r\n", result);
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::DoChildContainmentQuery
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: DoChildContainmentQuery(LPCWSTR pszChildPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar)
{
	IDirectoryObject *pChildObject = NULL;
	HRESULT result = S_FALSE;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszChildPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *) &pChildObject)))
	{
		PADS_OBJECT_INFO pChildInfo = NULL;
		if(SUCCEEDED(result = pChildObject->GetObjectInformation(&pChildInfo)))
		{
			IDirectoryObject *pParentObject = NULL;
			if(SUCCEEDED(result = ADsOpenObject(pChildInfo->pszParentDN, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *) &pParentObject)))
			{
				PADS_OBJECT_INFO pParentInfo = NULL;
				if(SUCCEEDED(result = pParentObject->GetObjectInformation(&pParentInfo)))
				{
					IWbemClassObject *pAssociationInstance = NULL;
					// Get the WBEM names of the LDAP classes
					LPWSTR pszChildClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(pChildInfo->pszClassName);
					LPWSTR pszParentClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(pParentInfo->pszClassName);
					BSTR strChildPath = CWBEMHelper::GetObjectRefFromADSIPath(pszChildPath, pszChildClassWbemName);
					BSTR strParentPath = CWBEMHelper::GetObjectRefFromADSIPath(pParentInfo->pszObjectDN, pszParentClassWbemName);
					delete [] pszChildClassWbemName;
					delete [] pszParentClassWbemName;

					// Check to see if it has already been indicated
					LPWSTR pszCombinedName = NULL;
					if(pszCombinedName = new WCHAR[wcslen(pszChildPath) + wcslen(pParentInfo->pszObjectDN) + 1])
					{
						wcscpy(pszCombinedName,pszChildPath);
						wcscat(pszCombinedName,pParentInfo->pszObjectDN);
						if(!pListIndicatedSoFar->IsNamePresent(pszCombinedName))
						{
							if(SUCCEEDED(result = CreateWBEMInstance(strChildPath, strParentPath, &pAssociationInstance)))
							{
								result = pResponseHandler->Indicate(1, &pAssociationInstance);
								pAssociationInstance->Release();

								// Add it to the list of objects indicated so far
								pListIndicatedSoFar->AddName(pszCombinedName);
							}
						}
						delete [] pszCombinedName;
					}
					else
						result = E_OUTOFMEMORY;
					SysFreeString(strChildPath);
					SysFreeString(strParentPath);
					FreeADsMem((LPVOID *)pParentInfo);
				}

				pParentObject->Release();
			}
			FreeADsMem((LPVOID *)pChildInfo);
		}
		pChildObject->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::DoParentContainmentQuery
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: DoParentContainmentQuery(LPCWSTR pszParentPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar)
{
	// We *have* to use the IADs interfaces since there are no container in
	IADsContainer *pContainer = NULL;
	IADs *pChild = NULL;
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszParentPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsContainer, (LPVOID *) &pContainer)))
	{
		IADs *pParent = NULL;
		if(SUCCEEDED(result = pContainer->QueryInterface(IID_IADs, (LPVOID *)&pParent)))
		{
			BSTR strParentClass = NULL;
			if(SUCCEEDED(result = pParent->get_Class(&strParentClass)))
			{
				// Get the WBEM names of the LDAP class
				LPWSTR pszParentClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(strParentClass);
				BSTR strParentWBEMPath = CWBEMHelper::GetObjectRefFromADSIPath(pszParentPath, pszParentClassWbemName);
				delete [] pszParentClassWbemName;
				SysFreeString(strParentClass);
				IEnumVARIANT *pEnum = NULL;
				if(SUCCEEDED(result = ADsBuildEnumerator(pContainer, &pEnum)))
				{
					bool bDone = false;
					while(!bDone && SUCCEEDED(result = ADsEnumerateNext(pEnum, 1, &variant, NULL)) && result != S_FALSE)
					{
						if(SUCCEEDED(result = (variant.pdispVal)->QueryInterface(IID_IADs, (LPVOID *)&pChild)))
						{
							BSTR strChildADSIPath = NULL;
							if(SUCCEEDED(result = pChild->get_ADsPath(&strChildADSIPath)))
							{
								BSTR strChildClass = NULL;
								if(SUCCEEDED(result = pChild->get_Class(&strChildClass)))
								{
									// Create an instance of the association class
									IWbemClassObject *pAssociationInstance = NULL;
									// Get the WBEM Name oo the child class
									LPWSTR pszChildClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(strChildClass);
									BSTR strChildWBEMPath = CWBEMHelper::GetObjectRefFromADSIPath(strChildADSIPath, pszChildClassWbemName);
									delete [] pszChildClassWbemName;

									// Check to see if it has already been indicated
									LPWSTR pszCombinedName = NULL;
									if(pszCombinedName = new WCHAR[wcslen(strChildADSIPath) + wcslen(pszParentPath) + 1])
									{
										wcscpy(pszCombinedName,strChildADSIPath);
										wcscat(pszCombinedName,pszParentPath);

										if(!pListIndicatedSoFar->IsNamePresent(pszCombinedName))
										{
											if(SUCCEEDED(result = CreateWBEMInstance(strChildWBEMPath, strParentWBEMPath, &pAssociationInstance)))
											{
												if(FAILED(result = pResponseHandler->Indicate(1, &pAssociationInstance)))
													bDone = true;
												pAssociationInstance->Release();

												// Add it to the list of objects indicated so far
												pListIndicatedSoFar->AddName(pszCombinedName);
											}
										}
										delete [] pszCombinedName;
									}
									else
										result = E_OUTOFMEMORY;
									SysFreeString(strChildClass);
									SysFreeString(strChildWBEMPath);
								}
								SysFreeString(strChildADSIPath);
							}
							pChild->Release();
						}

						VariantClear(&variant);
						VariantInit(&variant);
					}
					ADsFreeEnumerator(pEnum);
				}
				SysFreeString(strParentWBEMPath);
			}
			pParent->Release();
		}
		pContainer->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::ModifyExistingADSIInstance
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: ModifyExistingADSIInstance(IWbemClassObject *pWbemInstance,
															LPCWSTR pszADSIPath,
															CADSIInstance *pExistingObject,
															LPCWSTR pszADSIClass,
															IWbemContext *pCtx)
{
	HRESULT result = S_OK;
	BOOLEAN bPartialUpdate = FALSE;
	DWORD dwPartialUpdateCount = 0;
	BSTR *pstrProperyNames = NULL;
	SAFEARRAY *pArray = NULL;
	// See if the partial property list is indicated in the context
	VARIANT v1, v2;
	VariantInit(&v1);
	VariantInit(&v2);

	if(SUCCEEDED(result = pCtx->GetValue(PUT_EXTENSIONS_STR, 0, &v1)))
	{
		if(SUCCEEDED(result = pCtx->GetValue(PUT_EXT_PROPERTIES_STR, 0, &v2)))
		{

			switch(v2.vt)
			{
				case VT_BSTR | VT_ARRAY:
				{
					pArray = v2.parray;
					LONG lUbound = 0, lLbound = 0;
					if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pstrProperyNames) ) &&
						SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
						SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
					{
						dwPartialUpdateCount = lUbound - lLbound + 1;
						bPartialUpdate = TRUE;
					}
				}
				break;
				default:
					result = WBEM_E_FAILED;
					break;
			}
		}
		VariantClear(&v1);
	}
	else
		result = S_OK; // Reset it, there was no request for partial update

	if (FAILED(result))
		return WBEM_E_FAILED;

	// Find the number of properties first by doing an enumeration
	if(SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
	{
		DWORD dwNumProperties = 0;
		while(SUCCEEDED(result = pWbemInstance->Next(0, NULL, NULL, NULL, NULL)) && result != WBEM_S_NO_MORE_DATA )
			dwNumProperties ++;
		pWbemInstance->EndEnumeration();

		// Allocate ADSI structures for these properties
		PADS_ATTR_INFO pAttributeEntries = NULL;
		if(pAttributeEntries = new ADS_ATTR_INFO [dwNumProperties])
		{
			// Now go thru each wbem property and map it
			if(SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
			{
				DWORD dwNumPropertiesMapped = 0;
				BSTR strPropertyName = NULL;
				VARIANT vPropertyValue;
				CIMTYPE cType;
				LONG lFlavour;

				while(SUCCEEDED(result = pWbemInstance->Next(0,  &strPropertyName, &vPropertyValue, &cType, &lFlavour)) && result != WBEM_S_NO_MORE_DATA )
				{
					// Skip those properties that should not go to ADSI
					if(_wcsicmp(strPropertyName, ADSI_PATH_STR) == 0 )
					{
					}
					else // Map the property to ADSI
					{
						BOOLEAN bMapProperty = FALSE;
						if(bPartialUpdate)
						{
							if(CWBEMHelper::IsPresentInBstrList(pstrProperyNames, dwPartialUpdateCount, strPropertyName))
								bMapProperty = TRUE;
						}
						else
							bMapProperty = TRUE;

						if(bMapProperty)
						{

							if(vPropertyValue.vt == VT_NULL)
							{
								(pAttributeEntries + dwNumPropertiesMapped)->dwControlCode = ADS_ATTR_CLEAR;
								(pAttributeEntries + dwNumPropertiesMapped)->pszAttrName = CLDAPHelper::UnmangleWBEMNameToLDAP(strPropertyName);
								dwNumPropertiesMapped ++;
							}
							else if(SUCCEEDED(MapPropertyValueToADSI(pWbemInstance, strPropertyName, vPropertyValue, cType, lFlavour,  pAttributeEntries + dwNumPropertiesMapped)))
							{
								// Set the "attribute has been modified" flag
								(pAttributeEntries + dwNumPropertiesMapped)->dwControlCode = ADS_ATTR_UPDATE;
								dwNumPropertiesMapped ++;
							}
							else
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ModifyExistingADSIInstance() MapPropertyValueToADSI FAILED %x for %s\r\n", result, strPropertyName);
						}
						else
							g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ModifyExistingADSIInstance() Skipping %s since it is not in Context list\r\n", strPropertyName);
					}

					SysFreeString(strPropertyName);
					VariantClear(&vPropertyValue);
				}
				pWbemInstance->EndEnumeration();

				// Logging
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: The %d attributes being put are:\r\n", dwNumPropertiesMapped);
				for(DWORD i=0; i<dwNumPropertiesMapped; i++)
					g_pLogObject->WriteW( L"%s\r\n", (pAttributeEntries + i)->pszAttrName);

				// Get the actual object from ADSI to find out which attributes have changed.
				DWORD dwNumModified = 0;
				IDirectoryObject *pDirectoryObject = pExistingObject->GetDirectoryObject();
				if(SUCCEEDED(result = pDirectoryObject->SetObjectAttributes(pAttributeEntries, dwNumPropertiesMapped, &dwNumModified)))
				{
				}
				else
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: SetObjectAttributes FAILED with %x\r\n", result);
				pDirectoryObject->Release();

				// Delete the contents of each of the attributes
				for(i=0; i<dwNumPropertiesMapped; i++)
				{
					if((pAttributeEntries + i)->dwControlCode != ADS_ATTR_CLEAR)
						CLDAPHelper::DeleteAttributeContents(pAttributeEntries + i);
				}
			}
			delete [] pAttributeEntries;
		}
		else
			result = E_OUTOFMEMORY;
	}

	if(bPartialUpdate)
	{
		SafeArrayUnaccessData(pArray);
		VariantClear(&v2);
	}


	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::CreateNewADSIInstance
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: CreateNewADSIInstance(IWbemClassObject *pWbemInstance, LPCWSTR pszADSIPath, LPCWSTR pszADSIClass)
{
	// Find the ADSI path of the parent and the RDN of the child
	BSTR strRDNName = NULL;
	BSTR strParentADSIPath = NULL;
	BSTR strParentADSIPathWithoutLDAP = NULL;
	BSTR strParentPlusRDNADSIPath = NULL;
	HRESULT result = WBEM_E_FAILED;

	// Get the parentADSI path and RDN from the ADSI Path
	IADsPathname *pADsPathName = NULL;
	BSTR strADSIPath = SysAllocString(pszADSIPath);
	if(SUCCEEDED(result = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_ALL, IID_IADsPathname, (LPVOID *)&pADsPathName)))
	{
		if(SUCCEEDED(result = pADsPathName->Set(strADSIPath, ADS_SETTYPE_FULL)))
		{
			// This gives "<Parent>" without the "LDAP://" prefix
			if(SUCCEEDED(result = pADsPathName->Retrieve(ADS_FORMAT_X500_PARENT, &strParentADSIPathWithoutLDAP)))
			{
				// This gives "CN=Administrator,<Parent>"
				if(SUCCEEDED(result = pADsPathName->Retrieve(ADS_FORMAT_X500_DN, &strParentPlusRDNADSIPath)))
				{
					// Form the RDN - Dont ignore the comma.
					DWORD dwRDNLength = wcslen(strParentPlusRDNADSIPath) - wcslen(strParentADSIPathWithoutLDAP);
					LPWSTR pszRDN = NULL;
					if(pszRDN = new WCHAR [dwRDNLength])
					{
						wcsncpy(pszRDN, strParentPlusRDNADSIPath, dwRDNLength-1);
						pszRDN[dwRDNLength-1] = NULL;
						strRDNName = SysAllocString(pszRDN);
						delete [] pszRDN;
					}
					else
						result = E_OUTOFMEMORY;

					if(SUCCEEDED(result))
					{
						LPWSTR pszParentADSIPath  = NULL;
						if(pszParentADSIPath  = new WCHAR[wcslen(strParentADSIPathWithoutLDAP) + wcslen(LDAP_PREFIX) + 1])
						{
							wcscpy(pszParentADSIPath, LDAP_PREFIX);
							wcscat(pszParentADSIPath, strParentADSIPathWithoutLDAP);
							strParentADSIPath = SysAllocString(pszParentADSIPath);
							delete [] pszParentADSIPath;
						}
						else
							result = E_OUTOFMEMORY;
					}

					// Find the number of properties first by doing an enumeration
					if(SUCCEEDED(result) && SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
					{
						DWORD dwNumProperties = 0;
						while(SUCCEEDED(result = pWbemInstance->Next(0, NULL, NULL, NULL, NULL)) && result != WBEM_S_NO_MORE_DATA )
							dwNumProperties ++;
						pWbemInstance->EndEnumeration();

						// Allocate ADSI structures for these properties. An additional one for the "objectclass" property
						PADS_ATTR_INFO pAttributeEntries = NULL;
						if(pAttributeEntries = new ADS_ATTR_INFO [dwNumProperties + 1])
						{
							// Now go thru each wbem property and map it
							if(SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
							{
								DWORD dwNumPropertiesMapped = 0;
								BSTR strPropertyName = NULL;
								VARIANT vPropertyValue;
								CIMTYPE cType;
								LONG lFlavour;

								while(SUCCEEDED(result = pWbemInstance->Next(0,  &strPropertyName, &vPropertyValue, &cType, &lFlavour)) && result != WBEM_S_NO_MORE_DATA )
								{
									if(vPropertyValue.vt != VT_NULL)
									{
										// Skip those properties that should not go to ADSI
										if(_wcsicmp(strPropertyName, ADSI_PATH_STR) == 0 ||
											_wcsicmp(strPropertyName, OBJECT_CLASS_PROPERTY) == 0)
										{
										}
										else // Map the property to ADSI
										{
											if(SUCCEEDED(MapPropertyValueToADSI(pWbemInstance, strPropertyName, vPropertyValue, cType, lFlavour,  pAttributeEntries + dwNumPropertiesMapped)))
												dwNumPropertiesMapped ++;
											else
												g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateNewADSIInstance() MapPropertyValueToADSI FAILED %x for %s\r\n", result, strPropertyName);
										}
									}

									SysFreeString(strPropertyName);
									VariantClear(&vPropertyValue);
								}
								pWbemInstance->EndEnumeration();


								// Set the objectClass attribute too
								SetObjectClassAttribute(pAttributeEntries + dwNumPropertiesMapped, pszADSIClass);
								dwNumPropertiesMapped++;


								// Now get the parent ADSI object
								IDirectoryObject *pParentObject = NULL;
								if(SUCCEEDED(result = ADsOpenObject(strParentADSIPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pParentObject)))
								{
									if(SUCCEEDED(result = pParentObject->CreateDSObject(strRDNName, pAttributeEntries, dwNumPropertiesMapped, NULL)))
									{
									}
									else
										g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateDSObject on parent FAILED with %x\r\n", result);
									pParentObject->Release();
								}
								else
									g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ADsOpenObject on parent %s FAILED with %x\r\n", strParentADSIPath, result);

								// Delete the contents of each of the attributes
								for(DWORD i=0; i<dwNumPropertiesMapped; i++)
									CLDAPHelper::DeleteAttributeContents(pAttributeEntries + i);

							}

							delete [] pAttributeEntries;
						}
						else
							result = E_OUTOFMEMORY;
					}
					SysFreeString(strParentPlusRDNADSIPath);
					SysFreeString(strParentADSIPath);
				}
				SysFreeString(strParentADSIPathWithoutLDAP);
			}
		}

		pADsPathName->Release();
	}
	else
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CoCreateInstance() on IADsPathName FAILED %x\r\n", result);

	SysFreeString(strADSIPath);
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::MapPropertyValueToADSI
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: MapPropertyValueToADSI(IWbemClassObject *pWbemInstance, BSTR strPropertyName, VARIANT vPropertyValue, CIMTYPE cType, LONG lFlavour,  PADS_ATTR_INFO pAttributeEntry)
{
	// Set its fields to 0;
	memset((LPVOID)pAttributeEntry, 0, sizeof(ADS_ATTR_INFO));

	HRESULT result = E_FAIL;

	// Set the name
	pAttributeEntry->pszAttrName = CLDAPHelper::UnmangleWBEMNameToLDAP(strPropertyName);
	IWbemQualifierSet *pQualifierSet = NULL;

	if(SUCCEEDED(result = pWbemInstance->GetPropertyQualifierSet(strPropertyName, &pQualifierSet)))
	{
		// Get its attributeSyntax qualifer
		LPWSTR pszAttributeSyntax = NULL;
		if(SUCCEEDED(CWBEMHelper::GetBSTRQualifierT(pQualifierSet, ATTRIBUTE_SYNTAX_STR, &pszAttributeSyntax, NULL)))
		{
			if(_wcsicmp(pszAttributeSyntax, DISTINGUISHED_NAME_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_DN_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_DN_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, OBJECT_IDENTIFIER_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_DN_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, CASE_SENSITIVE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_EXACT_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_CASE_EXACT_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, CASE_INSENSITIVE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_CASE_IGNORE_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, PRINT_CASE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_PRINTABLE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_PRINTABLE_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, NUMERIC_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_NUMERIC_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_NUMERIC_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, DN_WITH_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_DN_WITH_STRING;
				result = SetDNWithStringValues(pAttributeEntry, ADSTYPE_DN_WITH_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, DN_WITH_BINARY_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_DN_WITH_BINARY;
				result = SetDNWithBinaryValues(pAttributeEntry, ADSTYPE_DN_WITH_BINARY, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, BOOLEAN_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_BOOLEAN;
				result = SetBooleanValues(pAttributeEntry, ADSTYPE_BOOLEAN, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, INTEGER_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_INTEGER;
				result = SetIntegerValues(pAttributeEntry, ADSTYPE_INTEGER, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, OCTET_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_OCTET_STRING;
				result = SetOctetStringValues(pAttributeEntry, ADSTYPE_OCTET_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, TIME_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetTimeValues(pAttributeEntry, ADSTYPE_CASE_IGNORE_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, UNICODE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_DN_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, NT_SECURITY_DESCRIPTOR_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
				result = SetOctetStringValues(pAttributeEntry, ADSTYPE_NT_SECURITY_DESCRIPTOR, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, LARGE_INTEGER_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_LARGE_INTEGER;
				result = SetLargeIntegerValues(pAttributeEntry, ADSTYPE_LARGE_INTEGER, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, SID_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_OCTET_STRING;
				result = SetOctetStringValues(pAttributeEntry, ADSTYPE_OCTET_STRING, &vPropertyValue);
			}
			else
			{
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapPropertyValueToADSI() Unknown attributeSyntax %s\r\n", pszAttributeSyntax);
				result = E_FAIL;
			}

			delete[] pszAttributeSyntax;
		}
		else
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapPropertyValueToADSI() Get on attributeSyntax FAILED %x\r\n", result);
		pQualifierSet->Release();
	}

	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetStringValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BSTR:
		{
			if(pvPropertyValue->bstrVal)
			{
				pAttributeEntry->dwNumValues = 1;
				pAttributeEntry->pADsValues = NULL;
				if(pAttributeEntry->pADsValues = new ADSVALUE)
				{
					pAttributeEntry->pADsValues->dwType = adType;
					pAttributeEntry->pADsValues->DNString = NULL;
					if(pAttributeEntry->pADsValues->DNString = new WCHAR[wcslen(pvPropertyValue->bstrVal) + 1])
						wcscpy(pAttributeEntry->pADsValues->DNString, pvPropertyValue->bstrVal);
					else
						result = E_OUTOFMEMORY;
				}
				else
					result = E_OUTOFMEMORY;
			}
		}
		break;
		case VT_BSTR | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			BSTR HUGEP *pbstr;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pbstr) ))
			{
				if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
				{
					if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
					{
						pAttributeEntry->pADsValues = NULL;
						if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
						{
							PADSVALUE pValues = pAttributeEntry->pADsValues;
							for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
							{
								pValues->dwType = adType;
								pValues->DNString = NULL;
								if(pValues->DNString = new WCHAR[wcslen(pbstr[i]) + 1])
									wcscpy(pValues->DNString, pbstr[i]);
								pValues ++;
							}
						}
						else
							result = E_OUTOFMEMORY;
					}
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetIntegerValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_I4:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				pAttributeEntry->pADsValues->Integer = pvPropertyValue->lVal;
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_I4 | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG HUGEP *pl;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pl) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							pValues->Integer = pl[i];
							pValues ++;
						}
					}
					else
						result = E_OUTOFMEMORY;
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetBooleanValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetBooleanValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BOOL:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				pAttributeEntry->pADsValues->Boolean = pvPropertyValue->boolVal;
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_BOOL | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			VARIANT_BOOL HUGEP *pb;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pb) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							pValues->Boolean = (pb[i] == VARIANT_TRUE)? TRUE : FALSE;
							pValues ++;
						}
					}
					else
						result = E_OUTOFMEMORY;
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetOctetStringValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetOctetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = E_FAIL;
	switch(pvPropertyValue->vt)
	{
		case VT_UNKNOWN:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				// Get the array
				IWbemClassObject *pEmbeddedObject = NULL;
				if(SUCCEEDED(result = (pvPropertyValue->punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
				{
					if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->OctetString.lpValue), &(pAttributeEntry->pADsValues->OctetString.dwLength) )))
					{
					}
					pEmbeddedObject->Release();
				}
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_UNKNOWN | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						IUnknown *pNextElement = NULL;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							if(SUCCEEDED(result = SafeArrayGetElement(pArray, (LONG *)&i, (LPVOID )&pNextElement )))
							{
								IWbemClassObject *pEmbeddedObject = NULL;
								if(SUCCEEDED(result = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
								{
									if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pValues->OctetString.lpValue), &(pValues->OctetString.dwLength))))
									{
									}
									pEmbeddedObject->Release();
								}
								pNextElement->Release();

							}
							pValues ++;

						}
					}
					else
						result = E_OUTOFMEMORY;
				}
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetDNWithStringValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetDNWithStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = E_FAIL;
	switch(pvPropertyValue->vt)
	{
		case VT_UNKNOWN:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				pAttributeEntry->pADsValues->pDNWithString = NULL;
				if(pAttributeEntry->pADsValues->pDNWithString = new ADS_DN_WITH_STRING)
				{
					IWbemClassObject *pEmbeddedObject = NULL;
					if(SUCCEEDED(result = (pvPropertyValue->punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
					{
						if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithString->pszStringValue) )))
						{
							if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithString->pszDNString) )))
							{
							}
						}
						pEmbeddedObject->Release();
					}
				}
				else
					result = E_OUTOFMEMORY;
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_UNKNOWN | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						IUnknown *pNextElement = NULL;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							if(SUCCEEDED(result = SafeArrayGetElement(pArray, (LONG *)&i, (LPVOID )&pNextElement )))
							{

								IWbemClassObject *pEmbeddedObject = NULL;
								if(SUCCEEDED(result = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
								{
									if(pValues->pDNWithString = new ADS_DN_WITH_STRING)
									{
										if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, VALUE_PROPERTY_STR, &(pValues->pDNWithString->pszStringValue) )))
										{
											if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pValues->pDNWithString->pszDNString) )))
											{
											}
										}
									}
									pEmbeddedObject->Release();
								}
								pNextElement->Release();
							}
							pValues ++;
						}
					}
					else
						result = E_OUTOFMEMORY;
				}
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetDNWithBinaryValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetDNWithBinaryValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = E_FAIL;
	switch(pvPropertyValue->vt)
	{
		case VT_UNKNOWN:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				pAttributeEntry->pADsValues->pDNWithBinary = NULL;
				if(pAttributeEntry->pADsValues->pDNWithBinary = new ADS_DN_WITH_BINARY)
				{
					IWbemClassObject *pEmbeddedObject = NULL;
					if(SUCCEEDED(result = (pvPropertyValue->punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
					{
						if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->lpBinaryValue), &(pAttributeEntry->pADsValues->pDNWithBinary->dwLength) )))
						{
							if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->pszDNString) )))
							{
							}
						}
						pEmbeddedObject->Release();
					}
				}
				else
					result = E_OUTOFMEMORY;
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_UNKNOWN | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						IUnknown *pNextElement = NULL;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							if(SUCCEEDED(result = SafeArrayGetElement(pArray, (LONG *)&i, (LPVOID )&pNextElement )))
							{

								IWbemClassObject *pEmbeddedObject = NULL;
								if(SUCCEEDED(result = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
								{
									if(pValues->pDNWithBinary = new ADS_DN_WITH_BINARY)
									{
										if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->lpBinaryValue), &(pAttributeEntry->pADsValues->pDNWithBinary->dwLength) )))
										{
											if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->pszDNString) )))
											{
											}
										}
									}
									pEmbeddedObject->Release();
								}
								pNextElement->Release();
							}
							pValues ++;

						}
					}
					else
						result = E_OUTOFMEMORY;
				}
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::SetTimeValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetTimeValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BSTR:
		{
			//199880819014734.000000+000 to 19980819014734.0Z to
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				pAttributeEntry->pADsValues->DNString = NULL;
				if(pAttributeEntry->pADsValues->DNString = new WCHAR[27])
				{
					wcscpy(pAttributeEntry->pADsValues->DNString, pvPropertyValue->bstrVal);
					(pAttributeEntry->pADsValues->DNString)[16] = L'Z';
					(pAttributeEntry->pADsValues->DNString)[17] = NULL;
				}
				else
					result = E_OUTOFMEMORY;
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_BSTR | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			BSTR HUGEP *pbstr;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pbstr) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						bool bError = false;
						for(DWORD i=0; !bError && (i<pAttributeEntry->dwNumValues); i++)
						{
							pValues->dwType = adType;
							pValues->DNString = NULL;
							if(pValues->DNString = new WCHAR[27])
							{
								wcscpy(pValues->DNString, pbstr[i]);
								(pValues->DNString)[16] = L'Z';
								(pValues->DNString)[17] = NULL;
								pValues ++;
							}
							else
							{
								bError = true;
								result = E_OUTOFMEMORY;
							}
						}
					}
					else
						result = E_OUTOFMEMORY;
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetLargeIntegerValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetLargeIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BSTR:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				swscanf(pvPropertyValue->bstrVal, L"%I64d", &((pAttributeEntry->pADsValues->LargeInteger).QuadPart));
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_BSTR | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			BSTR HUGEP *pbstr;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pbstr) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							swscanf(pbstr[i], L"%I64d", &((pValues->LargeInteger).QuadPart));
							pValues ++;
						}
					}
					else
						result = E_OUTOFMEMORY;
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::SetObjectClassAttribute
//
// Purpose: See Header File
//
//***************************************************************************
void CLDAPInstanceProvider :: SetObjectClassAttribute(PADS_ATTR_INFO pAttributeEntry, LPCWSTR pszADSIClassName)
{
	// Set its fields to 0;
	memset((LPVOID)pAttributeEntry, 0, sizeof(ADS_ATTR_INFO));


	// Set the name
	pAttributeEntry->pszAttrName = CLDAPHelper::UnmangleWBEMNameToLDAP(OBJECT_CLASS_PROPERTY);

	// Set the value
	pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
	pAttributeEntry->dwNumValues = 1;
	pAttributeEntry->pADsValues = NULL;
	if(pAttributeEntry->pADsValues = new ADSVALUE)
	{
		pAttributeEntry->pADsValues->dwType = ADSTYPE_DN_STRING;
		pAttributeEntry->pADsValues->DNString = NULL;
		if(pAttributeEntry->pADsValues->DNString = new WCHAR[wcslen(pszADSIClassName) + 1])
			wcscpy(pAttributeEntry->pADsValues->DNString, pszADSIClassName);
	}
}



// Process query for associations
HRESULT CLDAPInstanceProvider :: ProcessAssociationQuery(
	IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
	SQL1_Parser *pParser)
{
	HRESULT result = WBEM_S_NO_ERROR;
	// Parse the query
    SQL_LEVEL_1_RPN_EXPRESSION *pExp = 0;
    if(!pParser->Parse(&pExp))
    {
		// Check to see that it has exactly 1 or 2 clauses, and
		// if 2 clauses are present, these should be different ones, and the operator should be an AND
		// This is because we support only the following kinds of queries
		// Select * From DS_LDAP_CONTAINMENT_CLASS Where parentInstance = <something>
		// Select * From DS_LDAP_CONTAINMENT_CLASS Where childInstance = <something>
		// For all other queries, if there is a NOT operator, we do not support it.
		// Otherwise we just take the individual clauses and return theri union, asking CIMOM to postprocess
		int iNumTokens = pExp->nNumTokens;

		// Go thru the tokens to see that NOT is not present
		SQL_LEVEL_1_TOKEN *pNextToken = pExp->pArrayOfTokens;
		for(int i=0; i<iNumTokens; i++)
		{
			if(pNextToken->nTokenType == SQL_LEVEL_1_TOKEN::TOKEN_NOT ||
				(pNextToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION && pNextToken->nOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL))
			{
				result = WBEM_E_PROVIDER_NOT_CAPABLE;
				break;
			}
			pNextToken ++;
		}

		// No NOT was found
		if(result != WBEM_E_PROVIDER_NOT_CAPABLE)
		{
			// Ask CIMOM to postprocess the result
			pResponseHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, WBEM_S_NO_ERROR, NULL, NULL);

			// Duplicates need to be avoided. So keep a list of objects indicated so far.
			// The key in the list is formed by concatenating the child and parent ADSI paths
			//===========================================================================

			CNamesList listIndicatedSoFar;

			pNextToken = pExp->pArrayOfTokens;
			i=0;
			while(i<iNumTokens && result != WBEM_E_PROVIDER_NOT_CAPABLE)
			{
				if(pNextToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION)
				{
					LPWSTR pszADSIPath = CWBEMHelper::GetADSIPathFromObjectPath(pNextToken->vConstValue.bstrVal);
					if(_wcsicmp(pNextToken->pPropertyName, CHILD_INSTANCE_PROPERTY_STR) == 0)
					{
						DoChildContainmentQuery(pszADSIPath, pResponseHandler, &listIndicatedSoFar);
						result = WBEM_S_NO_ERROR;
					}
					else if (_wcsicmp(pNextToken->pPropertyName, PARENT_INSTANCE_PROPERTY_STR) == 0)
					{
						DoParentContainmentQuery(pszADSIPath, pResponseHandler, &listIndicatedSoFar);
						result = WBEM_S_NO_ERROR;
					}
					else
						result = WBEM_E_PROVIDER_NOT_CAPABLE;

					delete [] pszADSIPath;

				}
				i++;
				pNextToken ++;
			}

		}
    }
	else
		result = WBEM_E_FAILED;

    delete pExp;
	if(SUCCEEDED(result))
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
		result = WBEM_S_NO_ERROR;
	}
	else
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
		result = WBEM_S_NO_ERROR;
	}

	return result;
}


// Process Query for DS instances
HRESULT CLDAPInstanceProvider :: ProcessInstanceQuery(
    BSTR strClass,
	BSTR strQuery,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
	SQL1_Parser *pParser)
{
	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ProcessInstanceQuery() called for %s Class and query %s\r\n", strClass, strQuery);

	HRESULT result = WBEM_E_FAILED;

	// Parse the query
    SQL_LEVEL_1_RPN_EXPRESSION *pExp = NULL;
    if(!pParser->Parse(&pExp))
    {
		// Fetch the class from CIMOM
		IWbemClassObject *pWbemClass = NULL;
		if(SUCCEEDED(result = m_IWbemServices->GetObject(strClass, 0, pCtx, &pWbemClass, NULL)))
		{
			// We need the object category information
			LPWSTR pszLDAPQuery = NULL;
            int nLength = 6*(2*wcslen(strClass) + 75) + wcslen(strQuery) + 500;
			if(pszLDAPQuery = new WCHAR[nLength])
			{
				pszLDAPQuery[0] = LEFT_BRACKET_STR[0];
				pszLDAPQuery[1] = AMPERSAND_STR[0];
				pszLDAPQuery[2] = NULL;
				if(SUCCEEDED(CWBEMHelper::FormulateInstanceQuery(m_IWbemServices, pCtx, strClass, pWbemClass, pszLDAPQuery + 2, LDAP_DISPLAY_NAME_STR, DEFAULT_OBJECT_CATEGORY_STR)))
				{
					// Check to see if it can be converted to an LDAP query
					if(SUCCEEDED(result = ConvertWQLToLDAPQuery(pExp, pszLDAPQuery, nLength)))
					{
						// Complete the query string
						DWORD dwLen = wcslen(pszLDAPQuery);
						pszLDAPQuery[dwLen] = RIGHT_BRACKET_STR[0];
						pszLDAPQuery[dwLen + 1] = NULL;

						// Check to see if the client has specified any hints as to the DN of the object from
						// which the search should start
						BOOLEAN bRootDNSpecified = FALSE;
						LPWSTR *ppszRootDN = NULL;
						DWORD dwRootDNCount = 0;
						if(SUCCEEDED(GetRootDN(strClass, &ppszRootDN, &dwRootDNCount, pCtx)) && dwRootDNCount)
							bRootDNSpecified = TRUE;

						// Enumerate the ADSI Instances
						if(bRootDNSpecified)
						{
							for( DWORD i=0; i<dwRootDNCount; i++)
							{
								DoSingleQuery(strClass, pWbemClass, ppszRootDN[i], pszLDAPQuery,  pResponseHandler);
							}
						}
						else
						{
							DoSingleQuery(strClass, pWbemClass, m_lpszTopLevelContainerPath, pszLDAPQuery,  pResponseHandler);
						}

						if(bRootDNSpecified)
						{
							for(DWORD i=0; i<dwRootDNCount; i++)
							{
								delete [] ppszRootDN[i];
							}
							delete [] ppszRootDN;
						}

					}
				}
				else
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: FormulateInstanceQuery() on WBEM class %s FAILED with %x on query %s \r\n", strClass, result, strQuery);
			}
			else
				result = E_OUTOFMEMORY;
			pWbemClass->Release();
			delete [] pszLDAPQuery;
		}
		else
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ProcessInstanceQuery() Getting WBEM class %s FAILED with %x on query %s \r\n", strClass, result, strQuery);
	}
	else
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ProcessInstanceQuery() Parse() FAILED on query %s \r\n", strQuery);
    delete pExp;
	return result;
}

HRESULT CLDAPInstanceProvider :: ConvertWQLToLDAPQuery(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery, int nLength)
{
	HRESULT result = E_FAIL;
	DWORD dwLength = wcslen(pszLDAPQuery);

	// Append to the existing string
	if(QueryConvertor::ConvertQueryToLDAP(pExp, pszLDAPQuery + dwLength, nLength-dwLength-1))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ConvertWQLToLDAPQuery() Query converted to %s \r\n", pszLDAPQuery);
		result = S_OK;
	}
	else
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ConvertWQLToLDAPQuery() FAILED \r\n");

	return result;
}

HRESULT CLDAPInstanceProvider :: GetRootDN( LPCWSTR pszClass, LPWSTR **pppszRootDN, DWORD *pdwCount, IWbemContext *pCtx)
{
	*pppszRootDN = NULL;
	*pdwCount = 0;
	HRESULT result = WBEM_E_FAILED;

	// For the correct query
	LPWSTR pszQuery = new WCHAR[wcslen(pszClass) + wcslen(QUERY_FORMAT) + 10];
	swprintf(pszQuery, QUERY_FORMAT, pszClass);
	BSTR strQuery = SysAllocString(pszQuery);
	delete [] pszQuery;

	IEnumWbemClassObject *pEnum = NULL;
	if(SUCCEEDED(result = m_IWbemServices->ExecQuery(QUERY_LANGUAGE, strQuery, WBEM_FLAG_BIDIRECTIONAL, pCtx, &pEnum)))
	{
		// We ignore more than one instance in this implementation
		// Walk thru the enumeration and examine each class
		IWbemClassObject *pInstance = NULL;
		ULONG dwNextReturned = 0;
		while(SUCCEEDED(result = pEnum->Next( WBEM_INFINITE, 1, &pInstance, &dwNextReturned)) && dwNextReturned == 1)
		{
			(*pdwCount)++;
			pInstance->Release();
		}

		if(*pdwCount)
		{
			if(SUCCEEDED(result = pEnum->Reset()))
			{
				*pppszRootDN  = new LPWSTR[*pdwCount];

				DWORD i =0;
				while(SUCCEEDED(result = pEnum->Next( WBEM_INFINITE, 1, &pInstance, &dwNextReturned)) && dwNextReturned == 1)
				{
					// Get the ROOT_DN_PROPERTY, which has the instance
					BSTR strInstancePath = NULL;
					if(SUCCEEDED(result = CWBEMHelper::GetBSTRProperty(pInstance, ROOT_DN_PROPERTY, &strInstancePath)))
					{
						// Now get the object
						IWbemClassObject *pDNInstance = NULL;
						if(SUCCEEDED(result = m_IWbemServices->GetObject(strInstancePath, 0, pCtx, &pDNInstance, NULL)))
						{
							// Now get the DN_PROPERTY from the instance
							BSTR strRootDN = NULL;
							if(SUCCEEDED(result = CWBEMHelper::GetBSTRProperty(pDNInstance, DN_PROPERTY, &strRootDN)))
							{
								(*pppszRootDN)[i] = new WCHAR[wcslen(strRootDN) + 1];
								wcscpy((*pppszRootDN)[i], strRootDN);
								SysFreeString(strRootDN);

								i++;
							}
							pDNInstance->Release();
						}
						SysFreeString(strInstancePath);
					}
					pInstance->Release();
				}
				*pdwCount = i;
			}
		}
		else
			result = WBEM_E_FAILED; // To satisfy the return semantics of the function

		pEnum->Release();
	}
	SysFreeString(strQuery);
	return result;
}

// Process query for associations
HRESULT CLDAPInstanceProvider :: ProcessRootDSEGetObject(BSTR strClassName, IWbemObjectSink *pResponseHandler, IWbemContext *pCtx)
{
	HRESULT result = E_FAIL;

	// First get the object rom ADSI
	//==============================

	IADs *pADSIRootDSE = NULL;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pADSIRootDSE)))
	{
		// Get the class to spawn an instance
		IWbemClassObject *pWbemClass = NULL;
		if(SUCCEEDED(result = m_IWbemServices->GetObject(strClassName, 0, pCtx, &pWbemClass, NULL)))
		{
			IWbemClassObject *pWBEMRootDSE = NULL;
			// Spawn a instance of the WBEM Class
			if(SUCCEEDED(result = pWbemClass->SpawnInstance(0, &pWBEMRootDSE)))
			{
				// Map it to WBEM
				if(SUCCEEDED(result = MapRootDSE(pADSIRootDSE, pWBEMRootDSE)))
				{
					// Indicate the result
					result = pResponseHandler->Indicate(1, &pWBEMRootDSE);
				}
				pWBEMRootDSE->Release();
			}
			pWbemClass->Release();
		}
		pADSIRootDSE->Release();
	}

	return result;
}


HRESULT CLDAPInstanceProvider :: MapRootDSE(IADs *pADSIRootDSE, IWbemClassObject *pWBEMRootDSE)
{
	// Map the properties one-by-one
	//=================================
	VARIANT variant;

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUBSCHEMASUBENTRY_STR, &variant)))
		pWBEMRootDSE->Put(SUBSCHEMASUBENTRY_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SERVERNAME_STR, &variant)))
		pWBEMRootDSE->Put(SERVERNAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(DEFAULTNAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(DEFAULTNAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SCHEMANAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(SCHEMANAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(CONFIGURATIONNAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(CONFIGURATIONNAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(ROOTDOMAINNAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(ROOTDOMAINNAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(CURRENTTIME_STR, &variant)))
		pWBEMRootDSE->Put(CURRENTTIME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDVERSION_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDVERSION_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(NAMINGCONTEXTS_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, NAMINGCONTEXTS_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDCONTROLS_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDCONTROLS_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(DNSHOSTNAME_STR, &variant)))
		pWBEMRootDSE->Put(DNSHOSTNAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(DSSERVICENAME_STR, &variant)))
		pWBEMRootDSE->Put(DSSERVICENAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(HIGHESTCOMMITEDUSN_STR, &variant)))
		pWBEMRootDSE->Put(HIGHESTCOMMITEDUSN_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(LDAPSERVICENAME_STR, &variant)))
		pWBEMRootDSE->Put(LDAPSERVICENAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDCAPABILITIES_STR, &variant)))
		pWBEMRootDSE->Put(SUPPORTEDCAPABILITIES_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDLDAPPOLICIES_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDLDAPPOLICIES_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDSASLMECHANISMS_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDSASLMECHANISMS_STR, &variant);
	VariantClear(&variant);

	return S_OK;
}

HRESULT CLDAPInstanceProvider :: DoSingleQuery(BSTR strClass, IWbemClassObject *pWbemClass, LPCWSTR pszRootDN, LPCWSTR pszLDAPQuery, IWbemObjectSink *pResponseHandler)
{
	// Initialize the return values
	HRESULT result = E_FAIL;

	// Bind to the node from which the search should start
	IDirectorySearch *pDirectorySearchContainer = NULL;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszRootDN, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *)&pDirectorySearchContainer)))
	{
	    OnDelete<IUnknown *,void(*)(IUnknown *),RM> dm1(pDirectorySearchContainer);

		// Now perform a search for the attribute DISTINGUISHED_NAME_ATTR name
		if(SUCCEEDED(result = pDirectorySearchContainer->SetSearchPreference(m_pSearchInfo, 2)))
		{
			ADS_SEARCH_HANDLE hADSSearchOuter;

			if(SUCCEEDED(result = pDirectorySearchContainer->ExecuteSearch((LPWSTR) pszLDAPQuery, (LPWSTR *)&ADS_PATH_ATTR, 1, &hADSSearchOuter)))
			{
			    OnDeleteObj<ADS_SEARCH_HANDLE,
			    	        IDirectorySearch,
			    	        HRESULT(_stdcall IDirectorySearch::*)(ADS_SEARCH_HANDLE),
			    	        &IDirectorySearch::CloseSearchHandle> CloseSHandle(pDirectorySearchContainer,hADSSearchOuter);
			
				bool bDone = false;
				// Calculate the number of rows first. 
				while(!bDone && SUCCEEDED(result = pDirectorySearchContainer->GetNextRow(hADSSearchOuter)) &&
					result != S_ADS_NOMORE_ROWS)
				{
					CADSIInstance *pADSIInstance = NULL;

					// Get the columns for the attributes
					ADS_SEARCH_COLUMN adsColumn;

					// Store each of the LDAP class attributes 
					if(SUCCEEDED(pDirectorySearchContainer->GetColumn(hADSSearchOuter, (LPWSTR)ADS_PATH_ATTR, &adsColumn)))
					{
					    OnDeleteObj<ADS_SEARCH_COLUMN *,
					    	        IDirectorySearch,
					    	        HRESULT(_stdcall IDirectorySearch::*)(ADS_SEARCH_COLUMN *),
					    	        &IDirectorySearch::FreeColumn> FreeCol(pDirectorySearchContainer,&adsColumn);

						if(adsColumn.pADsValues->dwType != ADSTYPE_PROV_SPECIFIC)
						{
							// Create the CADSIInstance
							if(SUCCEEDED(result = CLDAPHelper:: GetADSIInstance(adsColumn.pADsValues->DNString, &pADSIInstance, g_pLogObject)))
							{
								OnDeleteObj0<CADSIInstance,void(CADSIInstance::*)(),&CADSIInstance::Release> dm(pADSIInstance);
								// Spawn a instance of the WBEM Class
								IWbemClassObject *pWbemInstance = NULL;
								if(SUCCEEDED(result = pWbemClass->SpawnInstance(0, &pWbemInstance)))
								{
								    OnDelete<IUnknown *,void(*)(IUnknown *),RM> dm(pWbemInstance);

									// Map it to WBEM
									if(SUCCEEDED(result = MapADSIInstance(pADSIInstance, pWbemInstance, pWbemClass)))
									{
										// Indicate the result
										if(FAILED(result = pResponseHandler->Indicate(1, &pWbemInstance)))
										{
											bDone = true;
											g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync Indicate() FAILED with %x \r\n", result);
										}
									}
									else
										g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync MapADSIInstance() FAILED with %x \r\n", result);
								}
							}
						}
					}
				}
			} // ExecuteSearch() 
			else
				g_pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ExecuteSearch() %s FAILED with %x\r\n", pszLDAPQuery, result);
		} // SetSearchPreference()
		else
			g_pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery SetSearchPreference() on %s FAILED with %x \r\n", pszLDAPQuery, result);
			
	} // ADsOpenObject
	else
		g_pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ADsOpenObject() on %s FAILED with %x \r\n", pszRootDN, result);

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\ldapcach.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapcach.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Cache for LDAP Schema objects (Properties and Classes)
//
//***************************************************************************


#ifndef LDAP_CACHE_H
#define LDAP_CACHE_H


class CLDAPCache
{
public:
	static DWORD dwLDAPCacheCount;

	//***************************************************************************
	//
	// CLDAPCache::CLDAPCache
	//
	// Purpose : Constructor. Fills in the cache with all the properties in LDAP.
	//
	// Parameters: 
	//	plogObject : Pointer to the ProvDebugLog object  onto which logging will be done.
	//***************************************************************************
	CLDAPCache();

	//***************************************************************************
	//
	// CLDAPCache::~CLDAPCache
	//
	// Purpose : Destructor 
	//
	//***************************************************************************
	~CLDAPCache();

	//***************************************************************************
	//
	// CLDAPCache::IsInitialized
	//
	// Purpose : Indicates whether the cache was created and initialized succeddfully
	//
	// Parameters: 
	//	None
	//
	//	Return value:
	//		A boolean value indicating the status
	//		
	//***************************************************************************
	BOOLEAN IsInitialized();

	//***************************************************************************
	//
	// CLDAPCache::GetProperty
	//
	// Purpose : Retreives the IDirectory interface of an LDAP property. 
	//
	// Parameters: 
	//	lpszPropertyName : The name of the LDAP Property to be retreived
	//	ppADSIProperty : The address of the pointer where the CADSIProperty object will be placed
	//	bWBEMName : True if the lpszPropertyName is the WBEM name. False, if it is the LDAP name
	//
	//	Return value:
	//		The COM value representing the return status. The user should delete the returned object when done.
	//		
	//***************************************************************************
	HRESULT GetProperty(LPCWSTR lpszPropertyName, CADSIProperty **ppADSIProperty, BOOLEAN bWBEMName);

	//***************************************************************************
	//
	// CLDAPCache::GetClass
	//
	// Purpose : Retreives the IDirectory interface of an LDAP Class
	//
	// Parameters: 
	//	lpszClassName : The name of the Class to be retreived. 
	//	ppADSIClass : The address of the pointer where the CADSIClass object will be placed
	//
	//	Return value:
	//		The COM value representing the return status. The user should delete the returned object when done.
	//		
	//***************************************************************************
	HRESULT GetClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszClassName, CADSIClass **ppADSIClass);

	//***************************************************************************
	//
	// CLDAPCache::EnumerateClasses
	//
	// Purpose : Retreives the IDirectory interface of an LDAP Class
	//
	// Parameters: 
	//		lppszWBEMSuperClass : The WBEM name of the immediate superclass of the classes to be retreived. This is optional
	//			and is ignored if NULL
	//		bDeep : Indicates whether a deep enumeration is required. Otherwise a shallow enumeration is done
	//		pppszClassNames : The address of the array of LPWSTR pointers where the resulting objects will be
	//			placed. The user should deallocate this array as well as its contents when done with them.
	//		pdwNumRows : The number of elements in the above array returned
	//
	//	Return value:
	//		The COM value representing the return status. The user should delete the returned object when done.
	//		
	//***************************************************************************
	HRESULT EnumerateClasses(LPCWSTR lpszSuperclass,
		BOOLEAN bDeep,
		LPWSTR **pppADSIClasses,
		DWORD *pdwNumRows,
		BOOLEAN bArtificialClass
		);

	//***************************************************************************
	//
	// CLDAPCache::GetSchemaContainerSearch
	//
	// Purpose : To return the IDirectorySearch interface on the schema container
	//
	// Parameters:
	//	ppDirectorySearch : The address where the pointer to the required interface will
	//		be stored.
	//
	// 
	//	Return Value: The COM result representing the status. The user should release
	//	the interface pointer when done with it.
	//***************************************************************************
	HRESULT GetSchemaContainerSearch(IDirectorySearch ** ppDirectorySearch);

	//***************************************************************************
	//
	// CLDAPCache::GetSchemaContainerObject
	//
	// Purpose : To return the IDirectoryObject interface on the schema container
	//
	// Parameters:
	//	ppDirectoryObject : The address where the pointer to the required interface will
	//		be stored.
	//
	// 
	//	Return Value: The COM result representing the status. The user should release
	//	the interface pointer when done with it.
	//***************************************************************************
	HRESULT GetSchemaContainerObject(IDirectoryObject ** ppDirectorySearch);
	
	//***************************************************************************
	//
	// CLDAPCache :: CreateEmptyADSIClass
	//
	// Purpose: Creates a new ADSI class from a WBEM class
	//
	// Parameters:
	//	lpszWBEMName : The WBEM Name of the class
	//
	//
	// Return Value: 
	//
	//***************************************************************************
	HRESULT CreateEmptyADSIClass( 
		LPCWSTR lpszWBEMName,
		CADSIClass **ppADSIClass);


	HRESULT FillInAProperty(CADSIProperty *pNextProperty, ADS_SEARCH_HANDLE hADSSearchOuter);


private:

	// The storage for cached properties
	CObjectTree m_objectTree;

	// Whether the cache was created successfully
	BOOLEAN m_isInitialized;

	// These are the search preferences often used
	ADS_SEARCHPREF_INFO m_pSearchInfo[3];

	// The path to the schema container
	LPWSTR m_lpszSchemaContainerSuffix;
	LPWSTR m_lpszSchemaContainerPath;
	// The IDirectorySearch interface of the schema container
	IDirectorySearch *m_pDirectorySearchSchemaContainer;

	// Some other literals
	static LPCWSTR ROOT_DSE_PATH;
	static LPCWSTR SCHEMA_NAMING_CONTEXT;
	static LPCWSTR LDAP_PREFIX;
	static LPCWSTR LDAP_TOP_PREFIX;
	static LPCWSTR RIGHT_BRACKET;
	static LPCWSTR OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA;

	// A function to fill in the object tree
	// This can be called only after the m_pDirectorySearchSchemaContainer member
	// is initialized
	HRESULT InitializeObjectTree();


};

#endif /* LDAP_CACHE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\ldapcach.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapcach.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Cache for LDAP Schema objects. 
//
//***************************************************************************

#include "precomp.h"

// Initialize the statics
LPCWSTR CLDAPCache :: ROOT_DSE_PATH			= L"LDAP://RootDSE";
LPCWSTR CLDAPCache :: SCHEMA_NAMING_CONTEXT = L"schemaNamingContext";
LPCWSTR CLDAPCache :: LDAP_PREFIX			= L"LDAP://";	
LPCWSTR CLDAPCache :: LDAP_TOP_PREFIX		= L"LDAP://CN=top,";
LPCWSTR CLDAPCache :: RIGHT_BRACKET			= L")";
LPCWSTR CLDAPCache :: OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA	= L"(objectCategory=attributeSchema)";

DWORD CLDAPCache::dwLDAPCacheCount = 0;

//***************************************************************************
//
// CLDAPCache::CLDAPCache
//
// Purpose : Constructor. Fills in the cache with all the properties in LDAP.
//
// Parameters: 
//	dsLog : The CDSLog object  onto which logging will be done.
//***************************************************************************

CLDAPCache :: CLDAPCache()
{
	dwLDAPCacheCount++;
	m_isInitialized = FALSE;
	m_pDirectorySearchSchemaContainer = NULL;

	// Initialize the search preferences often used
	m_pSearchInfo[0].dwSearchPref		= ADS_SEARCHPREF_SEARCH_SCOPE;
	m_pSearchInfo[0].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[0].vValue.Integer		= ADS_SCOPE_ONELEVEL;

	m_pSearchInfo[1].dwSearchPref		= ADS_SEARCHPREF_PAGESIZE;
	m_pSearchInfo[1].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[1].vValue.Integer		= 64;

	/*
	m_pSearchInfo[2].dwSearchPref		= ADS_SEARCHPREF_CACHE_RESULTS;
	m_pSearchInfo[2].vValue.dwType		= ADSTYPE_BOOLEAN;
	m_pSearchInfo[2].vValue.Boolean		= 0;
	*/

	m_lpszSchemaContainerSuffix = NULL;
	m_lpszSchemaContainerPath = NULL;
	// Get the ADSI path of the schema container and store it for future use
	//========================================================================
	IADs *pRootDSE = NULL;
	HRESULT result;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pRootDSE)))
	{
		// Get the location of the schema container
		BSTR strSchemaPropertyName = SysAllocString((LPWSTR) SCHEMA_NAMING_CONTEXT);


		// Get the schemaNamingContext property. This property contains the ADSI path
		// of the schema container
		VARIANT variant;
		VariantInit(&variant);
		if(SUCCEEDED(result = pRootDSE->Get(strSchemaPropertyName, &variant)))
		{
			// Store the ADSI path to the schema container
			m_lpszSchemaContainerSuffix = NULL;
			if(m_lpszSchemaContainerSuffix = new WCHAR[wcslen(variant.bstrVal) + 1])
			{
				wcscpy(m_lpszSchemaContainerSuffix, variant.bstrVal );
				g_pLogObject->WriteW( L"CLDAPCache :: Got Schema Container as : %s\r\n", m_lpszSchemaContainerSuffix);
			}

			// Form the schema container path
			//==================================
			m_lpszSchemaContainerPath = NULL;
			if(m_lpszSchemaContainerPath = new WCHAR[wcslen(LDAP_PREFIX) + wcslen(m_lpszSchemaContainerSuffix) + 1])
			{
				wcscpy(m_lpszSchemaContainerPath, LDAP_PREFIX);
				wcscat(m_lpszSchemaContainerPath, m_lpszSchemaContainerSuffix);
				
				m_isInitialized = TRUE;
				/*
				if(SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
				{

					g_pLogObject->WriteW( L"CLDAPCache :: Got IDirectorySearch on Schema Container \r\n");

					if(SUCCEEDED(result = InitializeObjectTree()))
					{
							m_isInitialized = TRUE;
					}
					else
						g_pLogObject->WriteW( L"CLDAPCache :: InitializeObjectTree() FAILED : %x \r\n", result);
				}
				else
					g_pLogObject->WriteW( L"CLDAPCache :: FAILED to get IDirectorySearch on Schema Container : %x\r\n", result);
				*/
			}
		}
		else
			g_pLogObject->WriteW( L"CLDAPCache :: Get on RootDSE FAILED : %x\r\n", result);

		SysFreeString(strSchemaPropertyName);
		VariantClear(&variant);
		pRootDSE->Release();

	}
	else
		g_pLogObject->WriteW( L"CLDAPClassProvider :: InitializeLDAPProvider ADsOpenObject on RootDSE FAILED : %x\r\n", result);

}

//***************************************************************************
//
// CLDAPCache::~CLDAPCache
//
// Purpose : Destructor 
//
//***************************************************************************

CLDAPCache :: ~CLDAPCache()
{
	dwLDAPCacheCount--;
	if(m_pDirectorySearchSchemaContainer)
		m_pDirectorySearchSchemaContainer->Release();

	if (m_lpszSchemaContainerSuffix)
	{
		delete [] m_lpszSchemaContainerSuffix;
	}

	if (m_lpszSchemaContainerPath)
	{
		delete [] m_lpszSchemaContainerPath;
	}
}

//***************************************************************************
//
// CLDAPCache::GetProperty
//
// Purpose : Retreives the IDirectory interface of an LDAP property
//
// Parameters: 
//	lpszPropertyName : The name of the LDAP Property to be retreived
//	ppADSIProperty : The address of the pointer where the CADSIProperty object will be placed
//	bWBEMName : True if the lpszPropertyName is the WBEM name. False, if it is the LDAP name
//
//	Return value:
//		The COM value representing the return status. The user should release the object when done.
//		
//***************************************************************************
HRESULT CLDAPCache :: GetProperty(LPCWSTR lpszPropertyName, CADSIProperty **ppADSIProperty, BOOLEAN bWBEMName)
{
	HRESULT result = E_FAIL;

	// Get the LDAP property name from the WBEM class name
	LPWSTR lpszLDAPPropertyName = NULL;
	if(bWBEMName)
		lpszLDAPPropertyName = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszPropertyName);
	else
		lpszLDAPPropertyName = (LPWSTR)lpszPropertyName; // Save a copy by casting, be careful when deleting

	try
	{
		// This is a cached implementation
		// Check the object tree first
		//===================================

		if((*ppADSIProperty) = (CADSIProperty *) m_objectTree.GetElement(lpszLDAPPropertyName))
		{
			// Found it in the tree. Nothing more to be done. It has already been 'addreff'ed
			result = S_OK;
		}
		else // Get it from ADSI 
		{
			if(!m_pDirectorySearchSchemaContainer)
			{
				if(!SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
					result = E_FAIL;
			}
			else
				result = S_OK;

			if(SUCCEEDED(result))
			{
				// Search for the property
				LPWSTR lpszQuery = NULL;
				if(lpszQuery = new WCHAR[ wcslen(OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA) + wcslen(LDAP_DISPLAY_NAME_ATTR) + wcslen(lpszLDAPPropertyName) + 20])
				{
					try
					{
						wcscpy(lpszQuery, LEFT_BRACKET_STR);
						wcscat(lpszQuery, AMPERSAND_STR);
						wcscat(lpszQuery, OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA);
						wcscat(lpszQuery, LEFT_BRACKET_STR);
						wcscat(lpszQuery, LDAP_DISPLAY_NAME_ATTR);
						wcscat(lpszQuery, EQUALS_STR);
						wcscat(lpszQuery, lpszLDAPPropertyName);
						wcscat(lpszQuery, RIGHT_BRACKET_STR);
						wcscat(lpszQuery, RIGHT_BRACKET_STR);

						ADS_SEARCH_HANDLE hADSSearchOuter;
						if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->ExecuteSearch(lpszQuery, NULL, -1, &hADSSearchOuter)))
						{
							try
							{
								if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter)) &&
									result != S_ADS_NOMORE_ROWS)
								{
									*ppADSIProperty = NULL;
									if(*ppADSIProperty = new CADSIProperty())
									{
										try
										{
											// Fill in the details of the property
											if(SUCCEEDED(result = FillInAProperty(*ppADSIProperty, hADSSearchOuter)))
											{
												// Add the property to the tree
												m_objectTree.AddElement((*ppADSIProperty)->GetADSIPropertyName(), *ppADSIProperty);
												// No need to release it since we're returning it
											}
											else
											{
												delete *ppADSIProperty;
												*ppADSIProperty = NULL;
											}
										}
										catch ( ... )
										{
											delete *ppADSIProperty;
											*ppADSIProperty = NULL;

											throw;
										}
									}
									else
										result = E_OUTOFMEMORY;
								}
							}
							catch ( ... )
							{
								m_pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);
								throw;
							}

							m_pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);
						}
					}
					catch ( ... )
					{
						delete [] lpszQuery;
						throw;
					}

					delete [] lpszQuery;
				}
				else
					result = E_OUTOFMEMORY;
			}
		}
	}
	catch ( ... )
	{
		if(bWBEMName)
		{
			delete[] lpszLDAPPropertyName;
			lpszLDAPPropertyName = NULL;
		}
		throw;
	}

	// Delete only what was allocated in this function
	//================================================
	if(bWBEMName)
	{
		delete[] lpszLDAPPropertyName;
		lpszLDAPPropertyName = NULL;
	}

	return result;
}

//***************************************************************************
//
// CLDAPCache::GetClass
//
// Purpose : See Header File
//		
//***************************************************************************
HRESULT CLDAPCache :: GetClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszLDAPClassName, CADSIClass **ppADSIClass)
{
	/************************************************************
	*************************************************************
	***** NO Cache implementation for now. Always fetch everytime
	*************************************************************
	*************************************************************/

	*ppADSIClass = NULL;
	if(!(*ppADSIClass = new CADSIClass(lpszWBEMClassName, lpszLDAPClassName)) )
		return E_OUTOFMEMORY;
	

	HRESULT result = E_FAIL;

	try
	{
		if(!m_pDirectorySearchSchemaContainer)
		{
			if(!SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
				result = E_FAIL;
		}
		else
			result = S_OK;

		if(SUCCEEDED(result))
		{
			result = CLDAPHelper::GetLDAPClassFromLDAPName(m_pDirectorySearchSchemaContainer,
				m_lpszSchemaContainerSuffix,
				m_pSearchInfo,
				2,
				*ppADSIClass
				);
		}
	}
	catch ( ... )
	{
		// at least GetLDAPClassFromLDAPName throws
		delete *ppADSIClass;
		*ppADSIClass = NULL;

		throw;
	}

	if(!SUCCEEDED(result))
	{
		delete *ppADSIClass;
		*ppADSIClass = NULL;
	}

	return result;
}

//***************************************************************************
//
// CLDAPCache::GetSchemaContainerSearch
//
// Purpose : To return the IDirectorySearch interface on the schema container
//
// Parameters:
//	ppDirectorySearch : The address where the pointer to the required interface will
//		be stored.
//
// 
//	Return Value: The COM result representing the status. The user should release
//	the interface pointer when done with it.
//***************************************************************************
HRESULT CLDAPCache :: GetSchemaContainerSearch(IDirectorySearch ** ppDirectorySearch)
{
	if(m_pDirectorySearchSchemaContainer)
	{
		*ppDirectorySearch = m_pDirectorySearchSchemaContainer;
		(*ppDirectorySearch)->AddRef();
		return S_OK;
	}
	else
		return E_FAIL;

}

//***************************************************************************
//
// CLDAPCache::EnumerateClasses
//
// Purpose : See Header
//		
//***************************************************************************
HRESULT CLDAPCache::EnumerateClasses(LPCWSTR lpszWBEMSuperclass,
	BOOLEAN bDeep,
	LPWSTR **pppADSIClasses,
	DWORD *pdwNumRows,
	BOOLEAN bArtificialClass)
{
	// Get the LDAP name of the super class
	// Do not mangle if it one of the classes that we know
	//=====================================================
	LPWSTR lpszLDAPSuperClassName = NULL;
	if(_wcsicmp(lpszWBEMSuperclass, LDAP_BASE_CLASS) != 0)
	{
		lpszLDAPSuperClassName = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszWBEMSuperclass);
		if(!lpszLDAPSuperClassName) // We were returned a NULL by the Unmangler, so not a DS class
		{
			*pppADSIClasses = NULL;
			*pdwNumRows = 0;
			return S_OK;
		}
	}

	HRESULT result = E_FAIL;
	if(!m_pDirectorySearchSchemaContainer)
	{
		if(!SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
			result = E_FAIL;
	}
	else
		result = S_OK;

	if(SUCCEEDED(result))
	{
		result = CLDAPHelper::EnumerateClasses(m_pDirectorySearchSchemaContainer, 
							m_lpszSchemaContainerSuffix, 
							m_pSearchInfo,
							2,
							lpszLDAPSuperClassName, 
							bDeep, 
							pppADSIClasses, 
							pdwNumRows,
							bArtificialClass);
	}

	// If the superclass is an artificial class like "ADS_User", then a concrete sub-class "DS_User" exists.
	// This is added manually here, to both the EnumInfoList as well as the structure being returned
	// The above call to EnumerateClasses would have helpfully left an extra element unfilled at the beginning
	// of the array
	if(SUCCEEDED(result) && bArtificialClass)
	{
		(*pppADSIClasses)[0] = NULL;
		if((*pppADSIClasses)[0] = new WCHAR[wcslen(lpszWBEMSuperclass+1) + 1])
			wcscpy((*pppADSIClasses)[0], lpszWBEMSuperclass+1); 
		else
			result = E_OUTOFMEMORY;
	}

	delete[] lpszLDAPSuperClassName;
	return result;
}

//***************************************************************************
//
// CLDAPCache::IsInitialized
//
// Purpose : Indicates whether the cache was created and initialized succeddfully
//
// Parameters: 
//	None
//
//	Return value:
//		A boolean value indicating the status
//		
//***************************************************************************

BOOLEAN CLDAPCache :: IsInitialized()
{
	return m_isInitialized;
}




//***************************************************************************
//
// CLDAPCache :: InitializeObjectTree
//
// Purpose : Initialize the lexically ordered binary tree with all the properties 
//	LDAP
//
// Parameters:
//	None
// 
//	Return Value: The COM status representing the return value
//***************************************************************************

HRESULT CLDAPCache :: InitializeObjectTree()
{
	// Get the attributes of all the instances of the
	// class "AttributeSchema"
	//=================================================
	HRESULT result = E_FAIL;

/*
	// Now perform a search for all the attributes
	//============================================
	if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->SetSearchPreference(m_pSearchInfo, 2)))
	{
		ADS_SEARCH_HANDLE hADSSearchOuter;
		
		// Count of attributes
		DWORD dwCount = 0;

		if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->ExecuteSearch((LPWSTR)OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA, NULL, -1, &hADSSearchOuter)))
		{
			CADSIProperty *pNextProperty;
			while(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter)) &&
				result != S_ADS_NOMORE_ROWS)
			{
				pNextProperty = new CADSIProperty();
				dwCount ++;

				// Fill in the details of the property
				FillInAProperty(pNextProperty, hADSSearchOuter);

				// Add the property to the tree
				m_objectTree.AddElement(pNextProperty->GetADSIPropertyName(), pNextProperty);
				pNextProperty->Release();
			}
			m_pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);
		}

		g_pLogObject->WriteW( L"CLDAPCache :: InitializeObjectTree() Initialized with %d attributes\r\n", dwCount);
	}
	else
		g_pLogObject->WriteW( L"CLDAPCache :: InitializeObjectTree() SetSearchPreference() FAILED with %x\r\n", result);

*/
	return result;
}

HRESULT CLDAPCache :: FillInAProperty(CADSIProperty *pNextProperty, ADS_SEARCH_HANDLE hADSSearchOuter)
{
	ADS_SEARCH_COLUMN adsNextColumn;
	HRESULT result = E_FAIL;
	LPWSTR lpszWBEMName = NULL;
	BOOLEAN bNeedToCheckForORName = FALSE;
	if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)ATTRIBUTE_SYNTAX_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
		{
			pNextProperty->SetSyntaxOID(adsNextColumn.pADsValues->CaseIgnoreString);
			if(_wcsicmp(adsNextColumn.pADsValues->CaseIgnoreString, DN_WITH_BINARY_OID) == 0)
				bNeedToCheckForORName = TRUE;
		}
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)IS_SINGLE_VALUED_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetMultiValued( (adsNextColumn.pADsValues->Boolean)? FALSE : TRUE);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)ATTRIBUTE_ID_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetAttributeID(adsNextColumn.pADsValues->CaseIgnoreString);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)COMMON_NAME_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetCommonName(adsNextColumn.pADsValues->CaseIgnoreString);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
		{
			pNextProperty->SetADSIPropertyName(adsNextColumn.pADsValues->CaseIgnoreString);
			lpszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM(adsNextColumn.pADsValues->CaseIgnoreString);
			pNextProperty->SetWBEMPropertyName(lpszWBEMName);
			delete []lpszWBEMName;
		}
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)MAPI_ID_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetMAPI_ID(adsNextColumn.pADsValues->Integer);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)OM_SYNTAX_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetOMSyntax(adsNextColumn.pADsValues->Integer);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(bNeedToCheckForORName && SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)OM_OBJECT_CLASS_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
		{
			// Just the first octet in the LPBYTE array is enough for differntiating between ORName and DNWithBinary
			if((adsNextColumn.pADsValues->OctetString).lpValue[0] == 0x56)
				pNextProperty->SetORName(TRUE);
		}
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)SEARCH_FLAGS_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetSearchFlags(adsNextColumn.pADsValues->Integer);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)SYSTEM_ONLY_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetSystemOnly(TRUE);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\ldaphelp.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldaphelp.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation the CLDAPHelper class. This is
//	a class that has many static helper functions pertaining to ADSI LDAP Provider
//***************************************************************************
/////////////////////////////////////////////////////////////////////////


#include "precomp.h"

LPCWSTR CLDAPHelper :: LDAP_CN_EQUALS						= L"LDAP://CN=";	
LPCWSTR CLDAPHelper :: LDAP_DISP_NAME_EQUALS				= L"(lDAPDisplayName=";
LPCWSTR CLDAPHelper :: OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA		= L"(objectCategory=classSchema)";
LPCWSTR CLDAPHelper	:: SUB_CLASS_OF_EQUALS				= L"(subclassOf=";
LPCWSTR CLDAPHelper :: NOT_LDAP_NAME_EQUALS				= L"(!ldapDisplayName=";
LPCWSTR CLDAPHelper :: LEFT_BRACKET_AND					= L"(&";
LPCWSTR CLDAPHelper :: GOVERNS_ID_EQUALS				= L"(governsId=";
LPCWSTR CLDAPHelper :: CLASS_SCHEMA						= L"classSchema";
LPCWSTR CLDAPHelper :: CN_EQUALS						= L"cn=";

//***************************************************************************
//
// CLDAPHelper :: GetLDAPClassFromLDAPName
//
// Purpose : See Header
//***************************************************************************
HRESULT CLDAPHelper :: GetLDAPClassFromLDAPName(
	IDirectorySearch *pDirectorySearchSchemaContainer,
	LPCWSTR lpszSchemaContainerSuffix,
	PADS_SEARCHPREF_INFO pSearchInfo,
	DWORD dwSearchInfoCount,
	CADSIClass *pADSIClass
)
{
	// We map the object from the LDAP Display name
	// Hence we cannot directly do an ADsOpenObject().
	// We have to send an LDAP query for the instance of ClassSchema/AttributeSchema where the
	// ldapdisplayname attribute is the lpszObjectName parameter.
	HRESULT result = E_FAIL;

	// For the search filter;
	LPCWSTR lpszLDAPObjectName = pADSIClass->GetADSIClassName();
	LPWSTR lpszSearchFilter = NULL;
	if(lpszSearchFilter = new WCHAR[ wcslen(LDAP_DISP_NAME_EQUALS) + wcslen(lpszLDAPObjectName) + wcslen(RIGHT_BRACKET_STR) + 1])
	{
		try
		{
			wcscpy(lpszSearchFilter, LDAP_DISP_NAME_EQUALS);
			wcscat(lpszSearchFilter, lpszLDAPObjectName);
			wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
			ADS_SEARCH_HANDLE hADSSearch;
			if(SUCCEEDED(result = pDirectorySearchSchemaContainer->ExecuteSearch(lpszSearchFilter, NULL, -1, &hADSSearch)))
			{
				try
				{
					if(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearch)) && result != S_ADS_NOMORE_ROWS)
					{
						// Get the column for the CN attribute
						ADS_SEARCH_COLUMN adsColumn;

						// Store each of the LDAP class attributes
						// Reset the LDAP and WBEM names to take care of change in case
						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
								{
									pADSIClass->SetADSIClassName(adsColumn.pADsValues->CaseIgnoreString);
									LPWSTR lpszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM(adsColumn.pADsValues->CaseIgnoreString);

									try
									{
										pADSIClass->SetWBEMClassName(lpszWBEMName);
									}
									catch ( ... )
									{
										delete [] lpszWBEMName;
										throw;
									}

									delete [] lpszWBEMName;
								}
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						// Store each of the LDAP class attributes 
						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)COMMON_NAME_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetCommonName(adsColumn.pADsValues->CaseIgnoreString);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						// Special case for top since ADSI returns "top" as the parent class of "top" and we
						// will go into an infinite loop later if we dont check this
						if(pADSIClass->GetCommonName() && _wcsicmp(pADSIClass->GetCommonName(), TOP_CLASS) != 0)
						{
							if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
								result = E_FAIL;
							else
							{
								if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SUB_CLASS_OF_ATTR, &adsColumn)))
								{
									try
									{
										if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
											result = E_FAIL;
										else
											pADSIClass->SetSuperClassLDAPName(adsColumn.pADsValues->CaseIgnoreString);
									}
									catch ( ... )
									{
										pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
										throw;
									}

									pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								}
							}
						}

						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)GOVERNS_ID_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetGovernsID(adsColumn.pADsValues->CaseIgnoreString);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SCHEMA_ID_GUID_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSchemaIDGUID((adsColumn.pADsValues->OctetString).lpValue, (adsColumn.pADsValues->OctetString).dwLength);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)RDN_ATT_ID_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetRDNAttribute(adsColumn.pADsValues->CaseIgnoreString);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)DEFAULT_SECURITY_DESCRP_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetDefaultSecurityDescriptor(adsColumn.pADsValues->CaseIgnoreString);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)OBJECT_CLASS_CATEGORY_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetObjectClassCategory(adsColumn.pADsValues->Integer);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						/*
						if(SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)NT_SECURITY_DESCRIPTOR_ATTR, &adsColumn)))
						{
							pADSIClass->SetNTSecurityDescriptor((adsColumn.pADsValues->SecurityDescriptor).lpValue, (adsColumn.pADsValues->SecurityDescriptor).dwLength);
							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						*/
						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)DEFAULT_OBJECTCATEGORY_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
								{
									// Get the LDAPDIpslayName of the class
									LPWSTR lpszLDAPName = NULL;
									if(SUCCEEDED(result) && SUCCEEDED(result = GetLDAPClassNameFromCN(adsColumn.pADsValues->DNString, &lpszLDAPName)))
									{
										try
										{
											pADSIClass->SetDefaultObjectCategory(lpszLDAPName);
										}
										catch ( ... )
										{
											delete [] lpszLDAPName;
											throw;
										}

										delete [] lpszLDAPName;
									}
								}
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_ONLY_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSystemOnly((BOOLEAN)adsColumn.pADsValues->Boolean);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)AUXILIARY_CLASS_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetAuxiliaryClasses(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_AUXILIARY_CLASS_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSystemAuxiliaryClasses(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_MAY_CONTAIN_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSystemMayContains(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)MAY_CONTAIN_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetMayContains(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_MUST_CONTAIN_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSystemMustContains(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)MUST_CONTAIN_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetMustContains(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_POSS_SUPERIORS_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSystemPossibleSuperiors(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)POSS_SUPERIORS_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetPossibleSuperiors(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
					}
					else
						result = E_FAIL;
				}
				catch ( ... )
				{
					// Close the search
					pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearch);

					throw;
				}

				// Close the search
				pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearch);
			}
		}
		catch ( ... )
		{
			if ( lpszSearchFilter )
			{
				// Delete the filter
				delete [] lpszSearchFilter;
				lpszSearchFilter = NULL;
			}

			throw;
		}

		if ( lpszSearchFilter )
		{
			// Delete the filter
			delete [] lpszSearchFilter;
			lpszSearchFilter = NULL;
		}
	}
	else
		result = E_OUTOFMEMORY;

	return result;
}


//***************************************************************************
//
// CLDAPHelper :: GetLDAPSchemaObjectFromCommonName
//
// Purpose : To fetch the IDirectoryObject interface on a class/property provided by the LDAP Provider
// Parameters:
//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
//			LDAP://CN=<lpszCommonName>,<lpszSchemaContainerSuffix>
//		lpszCommonName : The 'cn' attribute of the LDAP class or property to be fetched. 
//		ppLDAPObject : The address where the pointer to IDirectoryObject will be stored
//			It is the caller's responsibility to delete the object when done with it
// 
//	Return Value: The COM status value indicating the status of the request.
//***************************************************************************
HRESULT CLDAPHelper :: GetLDAPSchemaObjectFromCommonName(
	LPCWSTR lpszSchemaContainerSuffix,
	LPCWSTR lpszCommonName, 
	IDirectoryObject **ppLDAPObject)
{
	HRESULT result = S_OK;

	// Form the ADSI path to the LDAP object
	LPWSTR lpszLDAPObjectPath = NULL;
	if(lpszLDAPObjectPath = new WCHAR[wcslen(LDAP_CN_EQUALS) + wcslen(lpszCommonName) + wcslen(COMMA_STR) + wcslen(lpszSchemaContainerSuffix) + 1])
	{
		wcscpy(lpszLDAPObjectPath, LDAP_CN_EQUALS);
		wcscat(lpszLDAPObjectPath, lpszCommonName);
		wcscat(lpszLDAPObjectPath, COMMA_STR);
		wcscat(lpszLDAPObjectPath, lpszSchemaContainerSuffix);

		result = ADsOpenObject(lpszLDAPObjectPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)ppLDAPObject);

		delete[] lpszLDAPObjectPath;
	}
	else
		result = E_OUTOFMEMORY;
	return result;
}

//***************************************************************************
//
// CLDAPHelper :: GetLDAPClassNameFromCN
//
// Purpose : To fetch the LDAPDisplayNAme of a class from its path
// Parameters:
// 
//	lpszLDAPClassPath : The path to the class object without the LDAP prefix. Ex CN=user,CN=Schema, CN=COnfiguration ...
//	Return Value: The COM status value indicating the status of the request. The user should delete the
// name returned, when done
//***************************************************************************
HRESULT CLDAPHelper :: GetLDAPClassNameFromCN(LPCWSTR lpszLDAPClassPath, 
	LPWSTR *lppszLDAPName)
{
	IDirectoryObject *pLDAPClass = NULL;

	// Prepend the LDAP:// perfix
	LPWSTR lpszRealPath = NULL;
	HRESULT result = S_OK;
	if(lpszRealPath = new WCHAR[ wcslen(LDAP_PREFIX) + wcslen(lpszLDAPClassPath) + 1])
	{
		wcscpy(lpszRealPath, LDAP_PREFIX);
		wcscat(lpszRealPath, lpszLDAPClassPath);

		result = ADsOpenObject(lpszRealPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pLDAPClass);
		delete [] lpszRealPath;
	}
	else
		result = E_OUTOFMEMORY;

	// Get the attribute LDAPDisplayName
	if(SUCCEEDED(result))
	{
		PADS_ATTR_INFO pAttributes = NULL;
		DWORD dwReturnCount = 0;
		if(SUCCEEDED(result = pLDAPClass->GetObjectAttributes((LPWSTR *)&LDAP_DISPLAY_NAME_ATTR, 1, &pAttributes, &dwReturnCount)) && dwReturnCount == 1)
		{
			if(pAttributes->pADsValues->dwType == ADSTYPE_PROV_SPECIFIC)
				result = E_FAIL;
			else
			{
				*lppszLDAPName = NULL;
				if(*lppszLDAPName = new WCHAR[wcslen(pAttributes->pADsValues->DNString) + 1])
					wcscpy(*lppszLDAPName, pAttributes->pADsValues->DNString);
				else
					result = E_OUTOFMEMORY;
			}
			FreeADsMem((LPVOID *)pAttributes);
		}

		pLDAPClass->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPHelper :: EnumerateClasses
//
// Purpose : See Header
//***************************************************************************
HRESULT CLDAPHelper :: EnumerateClasses(
	IDirectorySearch *pDirectorySearchSchemaContainer,
	LPCWSTR lpszSchemaContainerSuffix,
	PADS_SEARCHPREF_INFO pSearchInfo,
	DWORD dwSearchInfoCount,
	LPCWSTR lpszLDAPSuperClass,
	BOOLEAN bDeep,
	LPWSTR **pppszClassNames,
	DWORD *pdwNumRows,
	BOOLEAN bArtificialClass)
{
	// Initialize the return values
	HRESULT result = E_FAIL;
	*pdwNumRows = 0;

	// The search filter;
	LPWSTR lpszSearchFilter = NULL;

	// There's various cases to be considered here.
	// if(lpszLDAPSuperClass is NULL)
	// then
	//		if bDeep is false, then no objects is returned (since we do not provide the LDAP base class
	//		else all the classes are returned using the filter (objectCategory=classSchema)
	//	else
	//		if bDeep is false, then the filter (&(objectCategory=classSchema)(subClassOf=lpszLDAPSuperClass)) is used
	//		else a lot of work has to be done!
	if(lpszLDAPSuperClass == NULL)
	{
		if(!bDeep)
		{
			*pppszClassNames = NULL;
			*pdwNumRows = 0;
			return S_OK;
		}
		else
		{
			if(!(lpszSearchFilter = new WCHAR[ wcslen(OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA) + 1]))
				return E_OUTOFMEMORY;
			wcscpy(lpszSearchFilter, OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA);
		}
	}
	else
	{
		if(!bDeep)
		{
			// One would imagine that a filter of the kind
			 //(&(objectClass=classSchema)(subClassOf=<lpszLDAPSuperClass>))
			// would be enough. Unfortunately it also gives the Top class
			//in the results when the value of lpszLDAPSuperClass is Top
			// we dont need that. Hnce we form the filter
			 //(&(objectClass=classSchema)(subClassOf=<lpszLDAPSuperClass>)(!ldapDisplayName=<lpszLDAPSuperClass>))
			if(lpszSearchFilter = new WCHAR[ wcslen(LEFT_BRACKET_AND)					// (&
									+ wcslen(OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA)		// (objectCategory=classSchema)
									+ wcslen(SUB_CLASS_OF_EQUALS)					// (subClassOf=
									+ wcslen(lpszLDAPSuperClass)					// superClass
									+ wcslen(RIGHT_BRACKET_STR)							// )
									+ wcslen(NOT_LDAP_NAME_EQUALS)					// (!ldapDisplayName=
									+ wcslen(lpszLDAPSuperClass)					// superClass
									+ 2*wcslen(RIGHT_BRACKET_STR)						// ))
									+1])
			{
				wcscpy(lpszSearchFilter, LEFT_BRACKET_AND);
				wcscat(lpszSearchFilter, OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA);
				wcscat(lpszSearchFilter, SUB_CLASS_OF_EQUALS);
				wcscat(lpszSearchFilter, lpszLDAPSuperClass);
				wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
				wcscat(lpszSearchFilter, NOT_LDAP_NAME_EQUALS);					// (!ldapDisplayName=
				wcscat(lpszSearchFilter, lpszLDAPSuperClass);
				wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
				wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
			}
			else
				result = E_OUTOFMEMORY;
		}
		else
			lpszSearchFilter = NULL; // THIS SPECIAL CASE IS TACKLED LATER
	}

	if(lpszSearchFilter)
	{
		ADS_SEARCH_HANDLE hADSSearchOuter;
		if(SUCCEEDED(result = pDirectorySearchSchemaContainer->ExecuteSearch(lpszSearchFilter, (LPWSTR *)&LDAP_DISPLAY_NAME_ATTR, 1, &hADSSearchOuter)))
		{
			*pdwNumRows = 0;
			DWORD dwFirstCount = 0; // Number of rows retreived on the first count

			// Calculate the number of rows first. 
			while(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter)) &&
				result != S_ADS_NOMORE_ROWS)
				dwFirstCount ++;

			// Allocate enough memory for the classes and names
			*pppszClassNames = NULL;
			if(bArtificialClass)
			{
				dwFirstCount ++;
				if(*pppszClassNames = new LPWSTR [dwFirstCount])
					(*pppszClassNames)[0] = NULL;
				else
					result = E_OUTOFMEMORY;
			}
			else
			{
				if(!(*pppszClassNames = new LPWSTR [dwFirstCount]))
					result = E_OUTOFMEMORY;
			}

			// The index of the attribute being processed
			DWORD dwSecondCount = 0;
			if(bArtificialClass)
				dwSecondCount ++;

			// Get the columns for the attributes
			ADS_SEARCH_COLUMN adsColumn;

			// Move to the beginning of the search
			if(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetFirstRow(hADSSearchOuter)) 
				&& result != S_ADS_NOMORE_ROWS)
			{
				// Store each of the LDAP class attributes 
				if(SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearchOuter, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsColumn)))
				{
					if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					{
						result = E_FAIL;
						pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
					}
					else
					{
						// Create the CADSIClass
						(*pppszClassNames)[dwSecondCount] = NULL;
						if((*pppszClassNames)[dwSecondCount] = new WCHAR[wcslen(adsColumn.pADsValues->CaseIgnoreString) + 1])
							wcscpy((*pppszClassNames)[dwSecondCount], adsColumn.pADsValues->CaseIgnoreString);
						pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
	
						dwSecondCount++;

						// Get the rest of the rows
						while(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter))&&
								result != S_ADS_NOMORE_ROWS)
						{
							// Store each of the LDAP class attributes 
							if(SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearchOuter, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsColumn)))
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
								{
									result = E_FAIL;
									pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								}
								else
								{
									// Create the CADSIClass
									(*pppszClassNames)[dwSecondCount] = NULL;
									if((*pppszClassNames)[dwSecondCount] = new WCHAR[wcslen(adsColumn.pADsValues->CaseIgnoreString) + 1])
										wcscpy((*pppszClassNames)[dwSecondCount], adsColumn.pADsValues->CaseIgnoreString);
									pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );

									dwSecondCount++;
								}
							}
						}
					}
				}
			}

			// Something went wrong? Release allocated resources
			if(dwSecondCount != dwFirstCount)
			{
				// Delete the contents of the array
				for(DWORD j=0; j<dwSecondCount; j++)
				{
					delete [] (*pppszClassNames)[j];
				}

				// Delete the array itself
				delete [] (*pppszClassNames);

				// Set return values to empty
				*pppszClassNames = NULL;
				*pdwNumRows = 0;

				result = E_FAIL;
			}
			else
				*pdwNumRows = dwFirstCount;

			// Close the search
			pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);

		} // ExecuteSearch() - Outer
		delete [] lpszSearchFilter;
	}
	else // THIS IS THE SPECIAL CASE WHERE ALL SUBCLASSES (RECURSIVELY) OF A GIVEN CLASS ARE REQUIRED
	{
		// A lot of work has to be done. THis is handled by CLDAPClassProvider. Hence control shold never reach here
		result = E_FAIL;
	}
	return result;
}


// Gets the IDIrectoryObject interface on an ADSI instance
HRESULT CLDAPHelper :: GetADSIInstance(LPCWSTR szADSIPath, CADSIInstance **ppADSIObject, ProvDebugLog *pLogObject)
{
	HRESULT result;
	IDirectoryObject *pDirectoryObject;
	*ppADSIObject = NULL;

	try
	{
		if(SUCCEEDED(result = ADsOpenObject((LPWSTR)szADSIPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pDirectoryObject)))
		{

			if(*ppADSIObject = new CADSIInstance(szADSIPath, pDirectoryObject))
			{
				PADS_ATTR_INFO pAttributeEntries;
				DWORD dwNumAttributes;
				if(SUCCEEDED(result = pDirectoryObject->GetObjectAttributes(NULL, -1, &pAttributeEntries, &dwNumAttributes)))
				{
					(*ppADSIObject)->SetAttributes(pAttributeEntries, dwNumAttributes);
					PADS_OBJECT_INFO pObjectInfo = NULL;
					if(SUCCEEDED(result = pDirectoryObject->GetObjectInformation(&pObjectInfo)))
					{
						(*ppADSIObject)->SetObjectInfo(pObjectInfo);
					}
					else
						pLogObject->WriteW( L"CLDAPHelper :: GetADSIInstance GetObjectInformation() FAILED on %s with %x\r\n", szADSIPath, result);
				}
				else
					pLogObject->WriteW( L"CLDAPHelper :: GetADSIInstance GetObjectAttributes() FAILED on %s with %x\r\n", szADSIPath, result);
			}
			else
				result = E_OUTOFMEMORY;
			pDirectoryObject->Release();
		}
		else
			pLogObject->WriteW( L"CLDAPHelper :: GetADSIInstance ADsOpenObject() FAILED on %s with %x\r\n", szADSIPath, result);
	}
	catch ( ... )
	{
		if ( *ppADSIObject )
		{
			delete *ppADSIObject;
			*ppADSIObject = NULL;
		}

		throw;
	}

	if(!SUCCEEDED(result))
	{
		delete *ppADSIObject;
		*ppADSIObject = NULL;
	}

	return result;
}

//***************************************************************************
//
// CLDAPHelper :: CreateADSIPath
//
// Purpose : Forms the ADSI path from a class or property name
//
// Parameters:
//	lpszLDAPSchemaObjectName : The LDAP class or property name
//	lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
//			LDAP://CN=<lpszLDAPSchemaObjectName>,<lpszSchemaContainerSuffix>
// 
//	Return Value: The ADSI path to the class or property object. This has to
//	be deallocated by the user
//***************************************************************************
LPWSTR CLDAPHelper :: CreateADSIPath(LPCWSTR lpszLDAPSchemaObjectName,	
									 LPCWSTR lpszSchemaContainerSuffix)
{
	LPWSTR lpszADSIObjectPath = NULL;
	if(lpszADSIObjectPath = new WCHAR[wcslen(LDAP_CN_EQUALS) + wcslen(lpszLDAPSchemaObjectName) + wcslen(COMMA_STR) + wcslen(lpszSchemaContainerSuffix) + 1])
	{
		wcscpy(lpszADSIObjectPath, LDAP_CN_EQUALS);
		wcscat(lpszADSIObjectPath, lpszLDAPSchemaObjectName);
		wcscat(lpszADSIObjectPath, COMMA_STR);
		wcscat(lpszADSIObjectPath, lpszSchemaContainerSuffix);
	}
	return lpszADSIObjectPath;
}

//***************************************************************************
//
// CLDAPHelper :: UnmangleWBEMNameToLDAP
//
// Purpose : Converts a mangled WBEM name to LDAP
//	An underscore in LDAP maps to two underscores in WBEM
//	An hyphen in LDAP maps to one underscore in WBEM
//
// Parameters:
//	lpszWBEMName : The WBEM class or property name
// 
//	Return Value: The LDAP name to the class or property object. This has to
//	be deallocated by the user
//***************************************************************************
LPWSTR CLDAPHelper :: UnmangleWBEMNameToLDAP(LPCWSTR lpszWBEMName)
{
	DWORD iPrefixLength = 0;
	if(_wcsnicmp(lpszWBEMName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
	{
		iPrefixLength = LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH;
	}
	else if (_wcsnicmp(lpszWBEMName, LDAP_CLASS_NAME_PREFIX, LDAP_CLASS_NAME_PREFIX_LENGTH) == 0)
	{
		iPrefixLength = LDAP_CLASS_NAME_PREFIX_LENGTH;
	}
	else
		return NULL;

	// The length of the resulting string (LDAP Name) is bound to be less than of equal to the length of WBEM name
	// So let's allocate the same as the wbem name length
	DWORD dwWbemNameLength = wcslen(lpszWBEMName) - iPrefixLength;
	LPWSTR lpszLDAPName = NULL;
	if(lpszLDAPName = new WCHAR[dwWbemNameLength + 1])
	{
		LPCWSTR lpszWBEMNameWithoutPrefix = lpszWBEMName + iPrefixLength;

		DWORD j=0;
		for(DWORD i=0; i<dwWbemNameLength; )
		{
			switch(lpszWBEMNameWithoutPrefix[i])
			{
				case (L'_'):
					if(lpszWBEMNameWithoutPrefix[i+1] == L'_')
					{
						i += 2;
						lpszLDAPName[j++] = L'_';
					}
					else
					{
						i++;
						lpszLDAPName[j++] = L'-';
					}
					break;

				default:
					lpszLDAPName[j++] = lpszWBEMNameWithoutPrefix[i++];

			}
		}
		lpszLDAPName[j] = NULL;
	}
	return lpszLDAPName;
}

//***************************************************************************
//
// CLDAPHelper :: MangleLDAPNameToWBEM
//
// Purpose : Converts a LDAP name to WBEM by mangling it
//	An underscore in LDAP maps to two underscores in WBEM
//	An hyphen in LDAP maps to one underscore in WBEM
//
// Parameters:
//	lpszLDAPName : The LDAP class or property name
// 
//	Return Value: The LDAP name to the class or property object. This has to
//	be deallocated by the user
//***************************************************************************
LPWSTR CLDAPHelper :: MangleLDAPNameToWBEM(LPCWSTR lpszLDAPName, BOOLEAN bArtificalName)
{
	if(!lpszLDAPName)
		return NULL;

	// The length of the resulting string (WBEM Name) is bound to be less than of equal to twice the length of LDAP name
	// So let's allocate double the LDAP name length
	DWORD dwLDAPNameLength = wcslen(lpszLDAPName);
	DWORD dwPrefixLength = (bArtificalName)? LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH : LDAP_CLASS_NAME_PREFIX_LENGTH;
	LPWSTR lpszWBEMName = NULL;
	
	if(lpszWBEMName = new WCHAR[2*dwLDAPNameLength + dwPrefixLength + 1])
	{
		// Prefix "DS_" or "ADS_"
		if(bArtificalName)
			wcscpy(lpszWBEMName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX);
		else
			wcscpy(lpszWBEMName, LDAP_CLASS_NAME_PREFIX);

		DWORD j=dwPrefixLength;

		for(DWORD i=0; i<dwLDAPNameLength; i++)
		{
			switch(lpszLDAPName[i])
			{
				case (__TEXT('-')):
					lpszWBEMName[j++] = L'_';
					break;

				case (__TEXT('_')):
					lpszWBEMName[j++] = L'_';
					lpszWBEMName[j++] = L'_';
					break;

				default:
					lpszWBEMName[j++] = lpszLDAPName[i];

			}
		}
		lpszWBEMName[j] = NULL;
	}
	return lpszWBEMName;
}

void CLDAPHelper :: DeleteAttributeContents(PADS_ATTR_INFO pAttribute)
{
	// delete the name
	delete [] pAttribute->pszAttrName;

	// Delete each value
	for(DWORD i=0; i<pAttribute->dwNumValues; i++)
		DeleteADsValueContents(pAttribute->pADsValues + i);

	// Delete the array of values
	delete [] pAttribute->pADsValues;
}

void CLDAPHelper :: DeleteADsValueContents(PADSVALUE pValue)
{
	switch(pValue->dwType)
	{
		// Nothing to delete
		case ADSTYPE_BOOLEAN:
		case ADSTYPE_INTEGER:
		case ADSTYPE_LARGE_INTEGER:
			break;
		
		case ADSTYPE_UTC_TIME:
		case ADSTYPE_DN_STRING:
		case ADSTYPE_CASE_EXACT_STRING:
		case ADSTYPE_CASE_IGNORE_STRING:
		case ADSTYPE_PRINTABLE_STRING:
		case ADSTYPE_NUMERIC_STRING:
			delete [] pValue->DNString;
			break;
		
		case ADSTYPE_OCTET_STRING:
		case ADSTYPE_NT_SECURITY_DESCRIPTOR:
			delete [] (pValue->OctetString.lpValue);
			break;
		case ADSTYPE_DN_WITH_BINARY:
			delete [] (pValue->pDNWithBinary->lpBinaryValue);
			delete [] (pValue->pDNWithBinary->pszDNString);
			delete pValue->pDNWithBinary;
			break;

		case ADSTYPE_DN_WITH_STRING:
			delete [] (pValue->pDNWithString->pszStringValue);
			delete [] (pValue->pDNWithString->pszDNString);
			delete pValue->pDNWithString;
			break;

		default:
		// Cause a Null Pointer violation intentionally
		// Otherwise we leak memory
		{
			assert(0);
		}
		break;
	}
}

//***************************************************************************
//
// CLDAPHelper :: ExecuteQuery
//
// Purpose : See Header
//***************************************************************************
HRESULT CLDAPHelper :: ExecuteQuery(
	LPCWSTR pszPathToRoot,
	PADS_SEARCHPREF_INFO pSearchInfo,
	DWORD dwSearchInfoCount,
	LPCWSTR pszLDAPQuery,
	CADSIInstance ***pppADSIInstances,
	DWORD *pdwNumRows,
	ProvDebugLog *pLogObject)
{
	// Initialize the return values
	HRESULT result = E_FAIL;
	*pdwNumRows = 0;
	*pppADSIInstances = NULL;

	// Bind to the node from which the search should start
	IDirectorySearch *pDirectorySearchContainer = NULL;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszPathToRoot, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *)&pDirectorySearchContainer)))
	{
		try
		{
			// Now perform a search for the attribute DISTINGUISHED_NAME_ATTR name
			if(SUCCEEDED(result = pDirectorySearchContainer->SetSearchPreference(pSearchInfo, dwSearchInfoCount)))
			{
				ADS_SEARCH_HANDLE hADSSearchOuter;

				if(SUCCEEDED(result = pDirectorySearchContainer->ExecuteSearch((LPWSTR) pszLDAPQuery, (LPWSTR *)&ADS_PATH_ATTR, 1, &hADSSearchOuter)))
				{
					*pdwNumRows = 0;
					// Calculate the number of rows first. 
					while(SUCCEEDED(result = pDirectorySearchContainer->GetNextRow(hADSSearchOuter)) &&
						result != S_ADS_NOMORE_ROWS)
						(*pdwNumRows) ++;

					try
					{
						// Do only if there were any rows
						if(*pdwNumRows)
						{
							// The index of the attribute being processed
							DWORD i = 0;

							// Allocate enough memory for the classes and names
							*pppADSIInstances = NULL;
							if(*pppADSIInstances = new CADSIInstance * [*pdwNumRows])
							{
								try
								{
									// Get the columns for the attributes
									ADS_SEARCH_COLUMN adsColumn;
									CADSIInstance *pADSIInstance = NULL;

									// Move to the first row
									if (SUCCEEDED(result = pDirectorySearchContainer->GetFirstRow(hADSSearchOuter))&&
											result != S_ADS_NOMORE_ROWS)
									{
										// Store each of the LDAP class attributes 
										if(SUCCEEDED(pDirectorySearchContainer->GetColumn(hADSSearchOuter, (LPWSTR)ADS_PATH_ATTR, &adsColumn)))
										{
											try
											{
												if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
													result = E_FAIL;
												else
												{
													// Create the CADSIInstance
													// Now get the attributes on this object

													if(SUCCEEDED(result = GetADSIInstance(adsColumn.pADsValues->DNString, &pADSIInstance, pLogObject)))
													{
														(*pppADSIInstances)[i] = pADSIInstance;
														i++;
													}
													else
														pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetADSIInstance() FAILED on %s with %x\r\n", adsColumn.pADsValues->DNString, result);
												}
											}
											catch ( ... )
											{
												pDirectorySearchContainer->FreeColumn( &adsColumn );
												throw;
											}

											// Free resouces
											pDirectorySearchContainer->FreeColumn( &adsColumn );
										}
										else
											pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetColumn() FAILED on %s with %x\r\n", pszLDAPQuery, result);

										// Get the other rows now
										if(SUCCEEDED(result))
										{
											while(SUCCEEDED(result = pDirectorySearchContainer->GetNextRow(hADSSearchOuter))&&
													result != S_ADS_NOMORE_ROWS)
											{

												// Store each of the LDAP class attributes 
												if(SUCCEEDED(pDirectorySearchContainer->GetColumn(hADSSearchOuter, (LPWSTR)ADS_PATH_ATTR, &adsColumn)))
												{
													try
													{
														if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
															result = E_FAIL;
														else
														{
															// Create the CADSIInstance
															// Now get the attributes on this object
															if(SUCCEEDED(result = GetADSIInstance(adsColumn.pADsValues->DNString, &pADSIInstance, pLogObject)))
															{
																(*pppADSIInstances)[i] = pADSIInstance;
																i++;
															}
															else
																pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetADSIInstance() FAILED on %s with %x\r\n", adsColumn.pADsValues->DNString, result);
														}
													}
													catch ( ... )
													{
														pDirectorySearchContainer->FreeColumn( &adsColumn );
														throw;
													}

													// Free resouces
													pDirectorySearchContainer->FreeColumn( &adsColumn );
												}
												else
													pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetColumn() FAILED on %s with %x\r\n", pszLDAPQuery, result);
											}
										}
									}
									else
										pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetFirstRow() FAILED on %s with %x\r\n", pszLDAPQuery, result);
								}
								catch ( ... )
								{
									// Delete the contents of the array
									for(DWORD j=0; j<i; j++)
										delete (*pppADSIInstances)[j];

									// Delete the array itself
									delete [] (*pppADSIInstances);

									// Set return values to empty
									*pppADSIInstances = NULL;
									*pdwNumRows = 0;

									throw;
								}
							}

							// Something went wrong? Release allocated resources
							if(i != *pdwNumRows)
							{
								pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery() Difference between Number of rows in 2 searches %d %d on %s Am invalidating the search as FAILED\r\n", i, *pdwNumRows, pszLDAPQuery);
								
								// Delete the contents of the array
								for(DWORD j=0; j<i; j++)
									delete (*pppADSIInstances)[j];

								// Delete the array itself
								delete [] (*pppADSIInstances);

								// Set return values to empty
								*pppADSIInstances = NULL;
								*pdwNumRows = 0;

								result = E_FAIL;
							}
						}
					}
					catch ( ... )
					{
						pDirectorySearchContainer->CloseSearchHandle(hADSSearchOuter);
						throw;
					}

					// Close the search. 
					pDirectorySearchContainer->CloseSearchHandle(hADSSearchOuter);
				} // ExecuteSearch() 
				else
					pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ExecuteSearch() %s FAILED with %x\r\n", pszLDAPQuery, result);
			} // SetSearchPreference()
			else
				pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery SetSearchPreference() on %s FAILED with %x \r\n", pszPathToRoot, result);
		}
		catch ( ... )
		{
			pDirectorySearchContainer->Release();
			throw;
		}

		pDirectorySearchContainer->Release();
	} // ADsOpenObject
	else
		pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ADsOpenObject() on %s FAILED with %x \r\n", pszPathToRoot, result);

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\ldaphelp.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldaphelp.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CLDAPHelper class. This is
//	a class that has many static helper functions pertaining to ADSI LDAP Provider
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef LDAP_HELPER_H
#define LDAP_HELPER_H

class CLDAPHelper
{

public:

	//***************************************************************************
	//
	// CLDAPHelper :: GetLDAPClassFromLDAPName
	//
	// Purpose : To fill in a CADSIClass object on a class/property provided by the LDAP Provider
	// Parameters:
	//		pDirectorySearchSchemaContainer : The IDirectorySearch interface where the schema object should be looked for
	//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetched will be:
	//			LDAP://CN=<lpszCommonName>,<lpszSchemaContainerSuffix>, where lpszCommonName is the
	//			'cn' attribute of the object having the ldapdisplayname attribute as lpszLDAPObjectName
	//		pSearchInfo: An array of ADS_SEARCHPREF_INFO to be used in the search
	//		dwSearchInfoCount : The number of elements in the above array
	//		lpszLDAPObjectName : The LDAPDisplayName of the LDAP class or property to be fetched. 
	//		ppLDAPObject : The address where the pointer to IDirectoryObject will be stored
	//			It is the caller's responsibility to delete the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT GetLDAPClassFromLDAPName(
		IDirectorySearch *pDirectorySearchSchemaContainer,
		LPCWSTR lpszSchemaContainerSuffix,
		PADS_SEARCHPREF_INFO pSearchInfo,
		DWORD dwSearchInfoCount,
		CADSIClass *pADSIClass);


	//***************************************************************************
	//
	// CLDAPHelper :: GetLDAPSchemaObjectFromCommonName
	//
	// Purpose : To fetch the IDirectoryObject interface on a class/property provided by the LDAP Provider
	// Parameters:
	//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
	//			LDAP://CN=<lpszCommonName>,<lpszSchemaContainerSuffix>
	//		lpszCommonName : The 'cn' attribute of the LDAP class or property to be fetched. 
	//		ppLDAPObject : The address where the pointer to IDirectoryObject will be stored
	//			It is the caller's responsibility to delete the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT GetLDAPSchemaObjectFromCommonName(
		LPCWSTR lpszSchemaContainerSuffix,
		LPCWSTR lpszCommonName, 
		IDirectoryObject **ppLDAPObject);

	//***************************************************************************
	//
	// CLDAPHelper :: GetLDAPClassNameFromCN
	//
	// Purpose : To fetch the LDAPDisplayNAme of a class from its path
	// Parameters:
	// 
	//	Return Value: The COM status value indicating the status of the request. The user should delete the
	// name returned, when done
	//***************************************************************************
	static HRESULT GetLDAPClassNameFromCN(LPCWSTR lpszLDAPClassPath, 
		LPWSTR *lppszLDAPName);

	//***************************************************************************
	//
	// CLDAPHelper :: EnumerateClasses
	//
	// Purpose : To fetch the list of names of subclasses (immediate) of an LDAP class
	// Parameters:
	//		pDirectorySearchSchemaContainer : The IDirectorySearch interface where the schema object should be looked for
	//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
	//			LDAP://CN=<lpszObjectName>,<lpszSchemaContainerSuffix>
	//		pSearchInfo: An array of ADS_SEARCHPREF_INFO to be used in the search
	//		dwSearchInfoCount : The number of elements in the above array
	//		lppszLDAPSuperClass : The immediate superclass of the classes to be retreived. This is optional
	//			and is ignored if NULL
	//		bDeep : Indicates whether a deep enumeration is required. Otherwise a shallow enumeration is done
	//		pppszClassNames : The address of the array of LPWSTR pointers where the resulting objects will be
	//			placed. The user should deallocate this array as well as its contents when done with them.
	//		pdwNumRows : The number of elements in the above array returned
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT EnumerateClasses(
		IDirectorySearch *pDirectorySearchSchemaContainer,
		LPCWSTR lpszSchemaContainerSuffix,
		PADS_SEARCHPREF_INFO pSearchInfo,
		DWORD dwSearchInfoCount,
		LPCWSTR lpszSuperClass,
		BOOLEAN bDeep,
		LPWSTR **pppszClassNames,
		DWORD *pdwNumRows,
		BOOLEAN bArtificialClass);

	// Gets the IDIrectoryObject interface on an ADSI instance
	static HRESULT GetADSIInstance(LPCWSTR szADSIPath, CADSIInstance **ppADSIInstance, ProvDebugLog *pLogObject);

	//***************************************************************************
	//
	// CLDAPHelper :: ExecuteQuery
	//
	// Purpose : To fetch the IDirectoryObject interface on a class/property provided by the LDAP Provider
	// Parameters:
	//		pszPathToRoot : The ADSI path to the node from which the search should start
	//		pSearchInfo: A pointer to a ADS_SEARCHPREF_INFO to be used in the search
	//		dwSearchInfoCount: The number of elements in pSearchInfo array
	//		pszLDAPQuery : The LDAP query to be executed
	//		pppADSIInstances : The address of the array of CADSIInstance pointers where the resulting objects will be
	//			placed. The user should deallocate this array as well as its contents when done with them.
	//		pdwNumRows : The number of elements in the above array returned
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT ExecuteQuery(
		LPCWSTR pszPathToRoot,
		PADS_SEARCHPREF_INFO pSearchInfo,
		DWORD dwSearchInfoCount,
		LPCWSTR pszLDAPQuery,
		CADSIInstance ***pppADSIInstances,
		DWORD *pdwNumRows,
		ProvDebugLog *pLogObject);

	// Helper functions to delete a ADS_ATTR_INFO structure
	static void DeleteAttributeContents(PADS_ATTR_INFO pAttribute);
	static void DeleteADsValueContents(PADSVALUE pValue);


	//***************************************************************************
	//
	// CLDAPHelper :: UnmangleWBEMNameToLDAP
	//
	// Purpose : Converts a mangled WBEM name to LDAP
	//	An underscore in LDAP maps to two underscores in WBEM
	//	An hyphen in LDAP maps to one underscore in WBEM
	//
	// Parameters:
	//	lpszWBEMName : The WBEM class or property name
	// 
	//	Return Value: The LDAP name to the class or property object. This has to
	//	be deallocated by the user
	//***************************************************************************
	static LPWSTR UnmangleWBEMNameToLDAP(LPCWSTR lpszWBEMName);

	//***************************************************************************
	//
	// CLDAPHelper :: MangleLDAPNameToWBEM
	//
	// Purpose : Converts a LDAP name to WBEM by mangling it
	//	An underscore in LDAP maps to two underscores in WBEM
	//	An hyphen in LDAP maps to one underscore in WBEM
	//
	// Parameters:
	//	lpszLDAPName : The LDAP class or property name
	// 
	//	Return Value: The LDAP name to the class or property object. This has to
	//	be deallocated by the user
	//***************************************************************************
	static LPWSTR MangleLDAPNameToWBEM(LPCWSTR lpszLDAPName, BOOLEAN bArtificalName = FALSE);

private:

	// Forms the ADSI path from a class or property name
	static LPWSTR CreateADSIPath(LPCWSTR lpszLDAPSchemaObjectName,	LPCWSTR lpszSchemaContainerSuffix);

	// Some literals
	static LPCWSTR LDAP_CN_EQUALS;
	static LPCWSTR LDAP_DISP_NAME_EQUALS;
	static LPCWSTR OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA;
	static LPCWSTR SUB_CLASS_OF_EQUALS;
	static LPCWSTR NOT_LDAP_NAME_EQUALS;
	static LPCWSTR LEFT_BRACKET_AND;
	static LPCWSTR GOVERNS_ID_EQUALS;
	static LPCWSTR CLASS_SCHEMA;
	static LPCWSTR CN_EQUALS;
};

#endif /* LDAP_HELPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\ldapproi.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CLDAPClassProviderInitializer class. This class
// is used to initialize the static members of the CLDAPCLassProvider class
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_LDAP_CLASS_PROVIDER_INIT_H
#define DS_LDAP_CLASS_PROVIDER_INIT_H

class CLDAPClassProviderInitializer
{

public:
	CLDAPClassProviderInitializer();
	~CLDAPClassProviderInitializer();
};

#endif /* DS_LDAP_CLASS_PROVIDER_INIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\ldapproi.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the class that is used to initialize the
//	CLDAPClassProvider class
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
// CLDAPClassProviderInitializer::CLDAPClassProviderInitializer
//
// Constructor Parameters:
//		None
//
//  
//***************************************************************************

CLDAPClassProviderInitializer :: CLDAPClassProviderInitializer ()
{
	CLDAPClassProvider :: LDAP_BASE_CLASS_STR			= SysAllocString(LDAP_BASE_CLASS);
	CLDAPClassProvider :: LDAP_CLASS_PROVIDER_NAME		= SysAllocString(L"Microsoft|DSLDAPClassProvider|V1.0");
	CLDAPClassProvider :: LDAP_INSTANCE_PROVIDER_NAME	= SysAllocString(L"Microsoft|DSLDAPInstanceProvider|V1.0");

	// WBEM Class Qualfiers
	CLDAPClassProvider :: DYNAMIC_BSTR						= SysAllocString(L"dynamic");
	CLDAPClassProvider :: PROVIDER_BSTR						= SysAllocString(L"provider");
	CLDAPClassProvider :: ABSTRACT_BSTR						= SysAllocString(L"abstract");
	CLDAPClassProvider :: COMMON_NAME_ATTR_BSTR				= SysAllocString(COMMON_NAME_ATTR);
	CLDAPClassProvider :: LDAP_DISPLAY_NAME_ATTR_BSTR		= SysAllocString(LDAP_DISPLAY_NAME_ATTR);
	CLDAPClassProvider :: GOVERNS_ID_ATTR_BSTR				= SysAllocString(GOVERNS_ID_ATTR);
	CLDAPClassProvider :: SCHEMA_ID_GUID_ATTR_BSTR			= SysAllocString(SCHEMA_ID_GUID_ATTR);
	CLDAPClassProvider :: MAPI_DISPLAY_TYPE_ATTR_BSTR		= SysAllocString(MAPI_DISPLAY_TYPE_ATTR);
	CLDAPClassProvider :: RDN_ATT_ID_ATTR_BSTR				= SysAllocString(RDN_ATT_ID_ATTR);
	CLDAPClassProvider :: SYSTEM_MUST_CONTAIN_ATTR_BSTR		= SysAllocString(SYSTEM_MUST_CONTAIN_ATTR);
	CLDAPClassProvider :: MUST_CONTAIN_ATTR_BSTR			= SysAllocString(MUST_CONTAIN_ATTR);
	CLDAPClassProvider :: SYSTEM_MAY_CONTAIN_ATTR_BSTR		= SysAllocString(SYSTEM_MAY_CONTAIN_ATTR);
	CLDAPClassProvider :: MAY_CONTAIN_ATTR_BSTR				= SysAllocString(MAY_CONTAIN_ATTR);
	CLDAPClassProvider :: SYSTEM_POSS_SUPERIORS_ATTR_BSTR	= SysAllocString(SYSTEM_POSS_SUPERIORS_ATTR);
	CLDAPClassProvider :: POSS_SUPERIORS_ATTR_BSTR			= SysAllocString(POSS_SUPERIORS_ATTR);
	CLDAPClassProvider :: SYSTEM_AUXILIARY_CLASS_ATTR_BSTR	= SysAllocString(SYSTEM_AUXILIARY_CLASS_ATTR);
	CLDAPClassProvider :: AUXILIARY_CLASS_ATTR_BSTR			= SysAllocString(AUXILIARY_CLASS_ATTR);
	CLDAPClassProvider :: DEFAULT_SECURITY_DESCRP_ATTR_BSTR	= SysAllocString(DEFAULT_SECURITY_DESCRP_ATTR);
	CLDAPClassProvider :: OBJECT_CLASS_CATEGORY_ATTR_BSTR	= SysAllocString(OBJECT_CLASS_CATEGORY_ATTR);
	CLDAPClassProvider :: SYSTEM_ONLY_ATTR_BSTR				= SysAllocString(SYSTEM_ONLY_ATTR);
	CLDAPClassProvider :: NT_SECURITY_DESCRIPTOR_ATTR_BSTR	= SysAllocString(NT_SECURITY_DESCRIPTOR_ATTR);
	CLDAPClassProvider :: DEFAULT_OBJECTCATEGORY_ATTR_BSTR	= SysAllocString(DEFAULT_OBJECTCATEGORY_ATTR);

	// WBEM Property Qualifiers
	CLDAPClassProvider :: SYSTEM_BSTR						= SysAllocString(L"system");
	CLDAPClassProvider :: NOT_NULL_BSTR						= SysAllocString(L"not_null");
	CLDAPClassProvider :: INDEXED_BSTR						= SysAllocString(L"indexed");
	CLDAPClassProvider :: ATTRIBUTE_SYNTAX_ATTR_BSTR		= SysAllocString(L"attributeSyntax");
	CLDAPClassProvider :: ATTRIBUTE_ID_ATTR_BSTR			= SysAllocString(L"attributeID");
	CLDAPClassProvider :: MAPI_ID_ATTR_BSTR					= SysAllocString(L"MAPI_ID");
	CLDAPClassProvider :: OM_SYNTAX_ATTR_BSTR				= SysAllocString(L"OM_Syntax");
	CLDAPClassProvider :: RANGE_LOWER_ATTR_BSTR				= SysAllocString(L"Range_Lower");
	CLDAPClassProvider :: RANGE_UPPER_ATTR_BSTR				= SysAllocString(L"Range_Upper");
	CLDAPClassProvider :: CIMTYPE_STR						= SysAllocString(L"Cimtype");
	CLDAPClassProvider :: EMBED_UINT8ARRAY					= SysAllocString(L"object:Uint8Array");
	CLDAPClassProvider :: EMBED_DN_WITH_STRING				= SysAllocString(L"object:DN_With_String");
	CLDAPClassProvider :: EMBED_DN_WITH_BINARY				= SysAllocString(L"object:DN_WIth_Binary");

	// WBEM Property names
	CLDAPClassProvider :: DYNASTY_BSTR						= SysAllocString(L"__DYNASTY");

	// The property cache
	CLDAPClassProvider :: s_pLDAPCache = new CLDAPCache();
}

//***************************************************************************
//
// CLDAPClassProviderInitializer::CLDAPClassProviderInitializer
//
// Destructor
//
//***************************************************************************
CLDAPClassProviderInitializer :: ~CLDAPClassProviderInitializer ()
{
	SysFreeString(CLDAPClassProvider::LDAP_BASE_CLASS_STR);
	SysFreeString(CLDAPClassProvider::LDAP_CLASS_PROVIDER_NAME);
	SysFreeString(CLDAPClassProvider::LDAP_INSTANCE_PROVIDER_NAME);

	// Class Qualifiers
	SysFreeString(CLDAPClassProvider::DYNAMIC_BSTR);
	SysFreeString(CLDAPClassProvider::PROVIDER_BSTR);
	SysFreeString(CLDAPClassProvider::ABSTRACT_BSTR);
	SysFreeString(CLDAPClassProvider::COMMON_NAME_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::LDAP_DISPLAY_NAME_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::GOVERNS_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SCHEMA_ID_GUID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MAPI_DISPLAY_TYPE_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::RDN_ATT_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_MUST_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MUST_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_MAY_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MAY_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_POSS_SUPERIORS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::POSS_SUPERIORS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_AUXILIARY_CLASS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::AUXILIARY_CLASS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::DEFAULT_SECURITY_DESCRP_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::OBJECT_CLASS_CATEGORY_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_ONLY_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::NT_SECURITY_DESCRIPTOR_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::DEFAULT_OBJECTCATEGORY_ATTR_BSTR);

	// Property Qualifiers
	SysFreeString(CLDAPClassProvider::SYSTEM_BSTR);
	SysFreeString(CLDAPClassProvider::NOT_NULL_BSTR);
	SysFreeString(CLDAPClassProvider::INDEXED_BSTR);
	SysFreeString(CLDAPClassProvider::ATTRIBUTE_SYNTAX_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::ATTRIBUTE_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MAPI_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::OM_SYNTAX_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::RANGE_LOWER_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::RANGE_UPPER_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::CIMTYPE_STR);
	SysFreeString(CLDAPClassProvider::EMBED_UINT8ARRAY);
	SysFreeString(CLDAPClassProvider::EMBED_DN_WITH_STRING);
	SysFreeString(CLDAPClassProvider::EMBED_DN_WITH_BINARY);

	// WBEM Property names
	SysFreeString(CLDAPClassProvider::DYNASTY_BSTR);

	// The property cache
	delete CLDAPClassProvider :: s_pLDAPCache;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\ldapprov.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapprov.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS LDAP Class Provider class. This
// class provides the classes in the DS LDAP namespace to WBEM. Note that an instance of the CDSClassProviderInitializer
//	class has to be created to initialize the static members of the CDSClassProvider class. Hence exactly
//	one instance of the CLDAPClassProviderInitializer class should be created for this
//	class to function properly.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef LDAP_CLASS_PROVIDER_H
#define LDAP_CLASS_PROVIDER_H

// Forward declaration for the initializer class
class CLDAPClassProviderInitializer;

class CLDAPClassProvider : public CDSClassProvider
{
	// The initializer class is a friend of this class
	friend CLDAPClassProviderInitializer;

public:

	//***************************************************************************
	//
	// CLDAPClassProvider::CLDAPClassProvider
	// CLDAPClassProvider::~CLDAPClassProvider
	//
	// Constructor Parameters:
	//  None
	//***************************************************************************
    CLDAPClassProvider () ;
    ~CLDAPClassProvider () ;

	//***************************************************************************
	//
	// CLDAPClassProvider::Initialize
	//
	// Purpose:
	//		As defined by the IWbemProviderInit interface
	//
	// Parameters:
	//		As defined by IWbemProviderInit interface
	// 
	//	Return Value: The COM status value indicating the status of the request
	//***************************************************************************
	HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

	//***************************************************************************
	//
	// CLDAPClassProvider :: CreateClassEnumAsync
	//
	// Purpose: Enumerates the classes 
	//
	// Parameters:
	//	Standard parmaters as described by the IWbemServices interface
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
		const BSTR strSuperclass,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler);


protected:

	//***************************************************************************
	//
	// CLDAPClassProvider::InitializeLDAPProvider
	//
	// Purpose: A helper function to do the ADSI LDAP provider specific initialization.
	//
	// Parameters:
	//		pCtx	The context object used in this call initialization
	// 
	// Return Value: TRUE if the function successfully finishes the initializaion. FALSE
	//	otherwise
	//***************************************************************************
	BOOLEAN InitializeLDAPProvider(IWbemContext *pCtx);

	////////////////////////////////////////////////////////
	// Functions for interacting with the LDAP ADSI provider
	////////////////////////////////////////////////////////
	//***************************************************************************
	//
	// CLDAPClassProvider::GetADSIClass
	//
	// Purpose : To Create a CADSIClass from an ADSI classSchema object
	// Parameters:
	//		lpszWBEMClassName : The WBEM Name of the class to be fetched. 
	//		ppADSIClass : The address where the pointer to the CADSIClass will be stored.
	//			It is the caller's responsibility to Release() the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	HRESULT GetADSIClass(
		LPCWSTR lpszClassName, 
		CADSIClass ** ppADSIClass);

	//***************************************************************************
	//
	// CLDAPClassProvider::GetADSIProperty
	//
	// Purpose : To create an CADSIProperty object from an LDAP AttributeSchema object
	// Parameters:
	//		lpszPropertyName : The LDAPDisplayName of the LDAP property to be fetched. 
	//		ppADSIProperty : The address where the pointer to the IDirectoryObject interface will be stored
	//			It is the caller's responsibility to Release() the interface when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request
	//***************************************************************************
	HRESULT GetADSIProperty(
		LPCWSTR lpszPropertyName, 
		CADSIProperty **ppADSIProperty);

	//***************************************************************************
	//
	// CLDAPClassProvider::GetWBEMBaseClassName
	//
	// Purpose : Returns the name of the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the base class. NULL if such a class doesnt exist.
	//***************************************************************************
	const BSTR GetWBEMBaseClassName();

	//***************************************************************************
	//
	// CLDAPClassProvider::GetWBEMBaseClass
	//
	// Purpose : Returns a pointer to the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The IWbemClassObject pointer to the base class. It is the duty of 
	//	user to release the class when done with using it.
	//***************************************************************************
	IWbemClassObject * GetWBEMBaseClass();

	//***************************************************************************
	//
	// CLDAPClassProvider::GetWBEMProviderName
	//
	// Purpose : Returns the name of the provider. This should be the same as the
	// value of the field Name in the __Win32Provider instance used for registration
	// of the provider
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the provider
	//***************************************************************************
	const BSTR GetWBEMProviderName();

	//***************************************************************************
	//
	// CLDAPClassProvider::IsUnProvidedClass
	//
	// Purpose : To check whether a class is one that the provider does not provide
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be checked
	//
	// 
	//	Return Value: TRUE is this is one of the classes not provided by the provider
	//***************************************************************************
	BOOLEAN IsUnProvidedClass(LPCWSTR lpszClassName);

	////////////////////////////////////////////////////////
	// Functions for handling a Get()
	////////////////////////////////////////////////////////
	//***************************************************************************
	//
	// CLDAPClassProvider::GetClassFromADSI
	//
	// Purpose : To create a WBEM class from an ADSI Class
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be retreived
	//	pCtx : A pointer to the context object that was used in this call. This
	//		may be used by this function to make calls to CIMOM
	//	ppWbemClass : The resulting WBEM Class. This has to be released once the
	//		user is done with it.
	//
	// 
	//	Return Value: The COM result representing the status. 
	//***************************************************************************
	HRESULT GetClassFromADSI( 
		LPCWSTR lpszClassName,
		IWbemContext *pCtx,
		IWbemClassObject ** ppWbemClass
		);	
	
	//***************************************************************************
	//
	// CDSClassProvider::CreateWBEMClass
	//
	// Purpose: Creates WBEM Class corresponding an ADSI Class
	//
	// Parameters:
	//	pADSIClass : A pointer to a CADSI class object that is to be mapped to WBEM.
	//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
	//		The caller should release it when done
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT CreateWBEMClass (CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider::MapClassSystemProperties
	//
	// Purpose: Creates an appropriately derived WBEM class and names it (__CLASS)
	//
	// Parameters:
	//	pADSIClass : The ADSI class that is being mapped
	//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
	//		The caller should release it when done
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT MapClassSystemProperties(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider :: MapClassQualifiersToWBEM
	//
	// Purpose: Creates the class qualifiers for a WBEM class from the ADSI class
	//
	// Parameters:
	//	pADSIClass : The LDAP class that is being mapped
	//	pWbemClass : The WBEM class object being created. T
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT MapClassQualifiersToWBEM(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject *pWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider :: MapClassPropertiesToWBEM
	//
	// Purpose: Creates the class properties for a WBEM class from the ADSI class
	//
	// Parameters:
	//	pADSIClass : The LDAP class that is being mapped
	//	pWbemClass : The WBEM class object being created. 
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT MapClassPropertiesToWBEM(CADSIClass *pADSIClass, IWbemClassObject *pWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CLDAPClassProvider :: MapPropertyListToWBEM
	//
	// Purpose: Maps a list of class properties for a WBEM class from the ADSI class
	//
	// Parameters:
	//	pWbemClass : The WBEM class object being created. 
	//	lppszPropertyList : A list of propery names
	//	dwCOunt : The number of items in the above list
	//	bMapSystemQualifier : Whether the "system" qualifier should be mapped
	//	bMapNotNullQualifier: Whether the "notNull" qualifier should be mapped
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	HRESULT MapPropertyListToWBEM(IWbemClassObject *pWbemClass, 
									LPCWSTR *lppszPropertyList, 
									DWORD dwCount, 
									BOOLEAN bMapSystemQualifier, 
									BOOLEAN bMapNotNullQualifier);

	//***************************************************************************
	//
	// CLDAPClassProvider :: CreateWBEMProperty
	//
	// Purpose: Creates a WBEM property from an LDAP property
	//
	// Parameters:
	//	pWbemClass : The WBEM class in which the property is created
	//	ppQualiferSet : The address of the pointer to IWbemQualiferSet where the qualifier set
	//		of this property will be placed
	//	pADSIProperty : The ADSI Property object that is being mapped to the property being created
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************	
	HRESULT CreateWBEMProperty(IWbemClassObject *pWbemClass, IWbemQualifierSet **ppQualifierSet, CADSIProperty *pNextProperty);

	//***************************************************************************
	//
	// CLDAPClassProvider :: MapLDAPSyntaxToWBEM
	//
	// Purpose: Maps the LDAP Syntax to WBEM
	//
	// Parameters:
	//	pADSIProperty = Pointer to the CADSIProperty object representing this attribute
	//
	// Return Value: The CIMTYPE value representing the WBEM Syntax for the LDAP Syntax. If
	// the syntax is unmappable, then CIM_STRING or CIM_STRING | CIM_FLAG_ARRAY is returned
	//
	//***************************************************************************
	CIMTYPE MapLDAPSyntaxToWBEM(CADSIProperty *pADSIProperty, BSTR *pstrCimTypeQualifier);

	/////////////////////////////////////
	/// Functions for Enumeration
	//////////////////////////////////////
	//***************************************************************************
	//
	// CLDAPClassProvider :: GetOneLevelDeep
	//
	// Purpose: Enumerates the sub classes of a superclass non-recursively
	//
	// Parameters:
	//
	//	lpszSuperClass : The super class name
	//	pResponseHandler : The interface where the resulting classes are put
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT GetOneLevelDeep( 
		LPCWSTR lpszWBEMSuperclass,
		BOOLEAN bArtificialClass,
		LPWSTR ** pppADSIClasses,
		DWORD *pdwNumClasses,
		IWbemContext *pCtx);

	//***************************************************************************
	//
	// CLDAPClassProvider :: HandleRecursiveEnumeration
	//
	// Purpose: Enumerates the sub classes of a superclass recursively
	//
	// Parameters:
	//
	//	lpszSuperClass : The super class name
	//	pResponseHandler : The interface where the resulting classes are put
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT HandleRecursiveEnumeration( 
		LPCWSTR lpszSuperclass,
		IWbemContext *pCtx,
		IWbemObjectSink *pResponseHandler);

	//***************************************************************************
	//
	// CLDAPClassProvider :: WrapUpEnumeration
	//
	// Purpose: Creates WBEM classes from ADSI classes 
	//
	// Parameters:
	//
	//	lpszSuperClass : The super class name
	//	pResponseHandler : The interface where the resulting classes are put
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT WrapUpEnumeration( 
		LPWSTR *ppADSIClasses,
		DWORD dwNumClasses,
		IWbemContext *pCtx,
		IWbemObjectSink *pResponseHandler);

	//***************************************************************************
	//
	// CLDAPClassProvider :: IsConcreteClass
	//
	// Purpose: Find out whether a WBEM class is concrete. First checks in the WBEM Cache and then calls GetClassFromCacheorADSI()
	//
	// Parameters:
	//
	//	pszWBEMName : The class name
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT IsConcreteClass( 
		LPCWSTR pszWBEMName,
		IWbemContext *pCtx);

	// Convert all characters to lower case
	void SanitizedClassName(LPWSTR lpszClassName);

private:

	// LDAP Class attribute names 
	static BSTR COMMON_NAME_ATTR_BSTR;
	static BSTR LDAP_DISPLAY_NAME_ATTR_BSTR;
	static BSTR GOVERNS_ID_ATTR_BSTR;
	static BSTR SCHEMA_ID_GUID_ATTR_BSTR;
	static BSTR MAPI_DISPLAY_TYPE_ATTR_BSTR;
	static BSTR RDN_ATT_ID_ATTR_BSTR;
	static BSTR SYSTEM_MUST_CONTAIN_ATTR_BSTR;
	static BSTR MUST_CONTAIN_ATTR_BSTR;
	static BSTR SYSTEM_MAY_CONTAIN_ATTR_BSTR;
	static BSTR MAY_CONTAIN_ATTR_BSTR;
	static BSTR SYSTEM_POSS_SUPERIORS_ATTR_BSTR;
	static BSTR POSS_SUPERIORS_ATTR_BSTR;
	static BSTR SYSTEM_AUXILIARY_CLASS_ATTR_BSTR;
	static BSTR AUXILIARY_CLASS_ATTR_BSTR;
	static BSTR DEFAULT_SECURITY_DESCRP_ATTR_BSTR;
	static BSTR OBJECT_CLASS_CATEGORY_ATTR_BSTR;
	static BSTR SYSTEM_ONLY_ATTR_BSTR;
	static BSTR NT_SECURITY_DESCRIPTOR_ATTR_BSTR;
	static BSTR DEFAULT_OBJECTCATEGORY_ATTR_BSTR;

	// Provider specific literals
	static BSTR	LDAP_BASE_CLASS_STR;
	static BSTR	LDAP_CLASS_PROVIDER_NAME;
	static BSTR	LDAP_INSTANCE_PROVIDER_NAME;

	// WBEM Class Qualifier names
	static BSTR	DYNAMIC_BSTR;
	static BSTR	PROVIDER_BSTR;
	static BSTR	ABSTRACT_BSTR;

	// WBEM Property Qualifier names
	static BSTR SYSTEM_BSTR;
	static BSTR NOT_NULL_BSTR;
	static BSTR INDEXED_BSTR;
	static BSTR ATTRIBUTE_SYNTAX_ATTR_BSTR;
	static BSTR ATTRIBUTE_ID_ATTR_BSTR;
	static BSTR MAPI_ID_ATTR_BSTR;
	static BSTR OM_SYNTAX_ATTR_BSTR;
	static BSTR RANGE_LOWER_ATTR_BSTR;
	static BSTR RANGE_UPPER_ATTR_BSTR;

	// Qualifiers for embedded objects
	static BSTR CIMTYPE_STR;
	static BSTR EMBED_UINT8ARRAY;
	static BSTR EMBED_DN_WITH_STRING;
	static BSTR EMBED_DN_WITH_BINARY;

	// WBEM Property names
	static BSTR DYNASTY_BSTR;

	// The default flavor for qualifiers
	static LONG DEFAULT_QUALIFIER_FLAVOUR;

	// These are the search preferences often used
	ADS_SEARCHPREF_INFO m_searchInfo1;

	// The LDAP property cache
	static CLDAPCache *s_pLDAPCache;

	// The base class of all the LDAP Provider Classes.
	IWbemClassObject *m_pLDAPBaseClass;

};


#endif // LDAP_CLASS_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\ldapprov.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapprov.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the DS LDAP Class Provider class. 
//
//***************************************************************************

#include "precomp.h"

/////////////////////////////////////////
// Initialize the static members
/////////////////////////////////////////
CLDAPCache *CLDAPClassProvider :: s_pLDAPCache		= NULL;	
DWORD CLDAPClassProvider::dwClassProviderCount = 0;

BSTR CLDAPClassProvider:: LDAP_BASE_CLASS_STR			= NULL;
BSTR CLDAPClassProvider:: LDAP_CLASS_PROVIDER_NAME		= NULL;
BSTR CLDAPClassProvider:: LDAP_INSTANCE_PROVIDER_NAME	= NULL;

// Names of the LDAP class attributes
BSTR CLDAPClassProvider :: COMMON_NAME_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: LDAP_DISPLAY_NAME_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: GOVERNS_ID_ATTR_BSTR				= NULL;
BSTR CLDAPClassProvider :: SCHEMA_ID_GUID_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: MAPI_DISPLAY_TYPE_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: RDN_ATT_ID_ATTR_BSTR				= NULL;
BSTR CLDAPClassProvider :: SYSTEM_MUST_CONTAIN_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: MUST_CONTAIN_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: SYSTEM_MAY_CONTAIN_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: MAY_CONTAIN_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: SYSTEM_POSS_SUPERIORS_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: POSS_SUPERIORS_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: SYSTEM_AUXILIARY_CLASS_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: AUXILIARY_CLASS_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: DEFAULT_SECURITY_DESCRP_ATTR_BSTR= NULL;
BSTR CLDAPClassProvider :: OBJECT_CLASS_CATEGORY_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: SYSTEM_ONLY_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: NT_SECURITY_DESCRIPTOR_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: DEFAULT_OBJECTCATEGORY_ATTR_BSTR	= NULL;


// Names of the LDAP property attributes
BSTR CLDAPClassProvider :: ATTRIBUTE_SYNTAX_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: ATTRIBUTE_ID_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: MAPI_ID_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: OM_SYNTAX_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: RANGE_LOWER_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: RANGE_UPPER_ATTR_BSTR		= NULL;

// Qualifiers for embedded objects
BSTR CLDAPClassProvider :: CIMTYPE_STR			= NULL;
BSTR CLDAPClassProvider :: EMBED_UINT8ARRAY		= NULL;
BSTR CLDAPClassProvider :: EMBED_DN_WITH_STRING = NULL;
BSTR CLDAPClassProvider :: EMBED_DN_WITH_BINARY = NULL;


// Default Qualifier Flavour
LONG CLDAPClassProvider :: DEFAULT_QUALIFIER_FLAVOUR = WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | WBEM_FLAVOR_OVERRIDABLE ;

// Names of WBEM Class Qualifiers
BSTR CLDAPClassProvider:: DYNAMIC_BSTR			= NULL;
BSTR CLDAPClassProvider:: PROVIDER_BSTR			= NULL;
BSTR CLDAPClassProvider:: ABSTRACT_BSTR			= NULL;

// Names of WBEM Property Qualifiers
BSTR CLDAPClassProvider :: SYSTEM_BSTR			= NULL;
BSTR CLDAPClassProvider :: NOT_NULL_BSTR		= NULL;
BSTR CLDAPClassProvider :: INDEXED_BSTR			= NULL;

// Names of WBEM properties
BSTR CLDAPClassProvider :: DYNASTY_BSTR			= NULL;

//***************************************************************************
//
// CLDAPClassProvider::CLDAPClassProvider
// CLDAPClassProvider::~CLDAPClassProvider
//
// Constructor Parameters:
//  None
//***************************************************************************

CLDAPClassProvider :: CLDAPClassProvider ()
: CDSClassProvider()
{
	// Initialize the search preferences often used
	m_searchInfo1.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
	m_searchInfo1.vValue.Integer = ADS_SCOPE_ONELEVEL;
	m_searchInfo1.dwStatus = ADS_STATUS_S_OK;

	m_pLDAPBaseClass = NULL;
	dwClassProviderCount++;
}

CLDAPClassProvider::~CLDAPClassProvider ()
{
	g_pLogObject->WriteW( L"CLDAPClassProvider :: ~CLDAPClassProvider() Called\r\n");
	dwClassProviderCount --;
	if(m_pLDAPBaseClass)
		m_pLDAPBaseClass->Release();
}

//***************************************************************************
//
// CLDAPClassProvider::Initialize
//
// Purpose:
//		As defined by the IWbemProviderInit interface
//
// Parameters:
//		As defined by IWbemProviderInit interface
// 
//	Return Value: The COM status value indicating the status of the request
//***************************************************************************

HRESULT CLDAPClassProvider :: Initialize( 
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{

	// Validate the arguments
	if( pNamespace == NULL || lFlags != 0 )
	{
		g_pLogObject->WriteW( L"CLDAPClassProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	g_pLogObject->WriteW( L"CLDAPClassProvider :: Initialize() Called\r\n");

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();


	// Do LDAP Provider initialization
	if(!InitializeLDAPProvider(pCtx))
	{
		g_pLogObject->WriteW( L"CLDAPClassProvider :: InitializeLDAPProvider FAILED\r\n");
		m_IWbemServices->Release();
		m_IWbemServices = NULL;

		// Do not set the status to failed for purposes of installation (MOFCOMP fails!)
		// Instead return a success but set an internal status value to FALSE
		// All operations should return FAILED if this internal status value is set to FALSE
		m_bInitializedSuccessfully = FALSE;
	}
	else
		m_bInitializedSuccessfully = TRUE;

	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
// CLDAPClassProvider::InitializeLDAPProvider
//
// Purpose: A helper function to do the ADSI LDAP provider specific initialization.
//
// Parameters:
//		pCtx	The context object used in this call initialization
// 
// Return Value: TRUE if the function successfully finishes the initializaion. FALSE
//	otherwise
//***************************************************************************
BOOLEAN CLDAPClassProvider :: InitializeLDAPProvider(IWbemContext *pCtx)
{
	// Get the static classes used by the LDAP provider
	HRESULT result = WBEM_E_FAILED;
	if(SUCCEEDED(result = m_IWbemServices->GetObject(LDAP_BASE_CLASS_STR, 0, pCtx, &m_pLDAPBaseClass, NULL)))
	{
		result = (s_pLDAPCache->IsInitialized())? S_OK : E_FAIL;
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassProvider :: InitializeLDAPProvider GetObject on base LDAP class FAILED : %x\r\n", result);

	return SUCCEEDED(result);
}		

//***************************************************************************
//
// CLDAPClassProvider::GetADSIClass
//
// Purpose : To Create a CADSIClass from an ADSI classSchema object
// Parameters:
//		lpszWBEMClassName : The WBEM Name of the class to be fetched. 
//		ppADSIClass : The address where the pointer to the CADSIClass will be stored.
//			It is the caller's responsibility to Release() the object when done with it
// 
//	Return Value: The COM status value indicating the status of the request.
//***************************************************************************
HRESULT CLDAPClassProvider :: GetADSIClass(LPCWSTR lpszADSIClassName, CADSIClass **ppADSIClass)
{
	// Convert the WBEM Class Name to LDAP
	LPWSTR lpszWBEMClassName = CLDAPHelper::MangleLDAPNameToWBEM(lpszADSIClassName);
	HRESULT result = s_pLDAPCache->GetClass(lpszWBEMClassName, lpszADSIClassName, ppADSIClass);

	delete[] lpszWBEMClassName;
	return result;
}

//***************************************************************************
//
// CLDAPClassProvider::GetADSIProperty
//
// Purpose : To create an CADSIProperty object from an LDAP AttributeSchema object
// Parameters:
//		lpszPropertyName : The LDAPDisplayName of the LDAP property to be fetched. 
//		ppADSIProperty : The address where the pointer to the IDirectoryObject interface will be stored
//			It is the caller's responsibility to Release() the interface when done with it
// 
//	Return Value: The COM status value indicating the status of the request
//***************************************************************************
HRESULT CLDAPClassProvider :: GetADSIProperty(LPCWSTR lpszPropertyName, CADSIProperty **ppADSIProperty)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	if ( ppADSIProperty )
	{
		if ( SUCCEEDED ( hRes = s_pLDAPCache->GetProperty(lpszPropertyName, ppADSIProperty, FALSE) ) )
		{
			if ( NULL == *ppADSIProperty )
			{
				hRes = WBEM_S_FALSE;
			}
		}
	}
	else
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	return hRes;
}


//***************************************************************************
//
// CLDAPClassProvider::GetWBEMBaseClassName
//
// Purpose : Returns the name of the class that is the base class of all classes
//	provided by this provider.
//
// Parameters:
//	None
// 
//	Return Value: The name of the base class. NULL if such a class doesnt exist.
//***************************************************************************
const BSTR CLDAPClassProvider :: GetWBEMBaseClassName()
{
	return LDAP_BASE_CLASS_STR; 
}

//***************************************************************************
//
// CLDAPClassProvider::GetWBEMBaseClass
//
// Purpose : Returns a pointer to the class that is the base class of all classes
//	provided by this provider.
//
// Parameters:
//	None
// 
//	Return Value: The IWbemClassObject pointer to the base class. It is the duty of 
//	user to release the class when done with using it.
//***************************************************************************
IWbemClassObject * CLDAPClassProvider :: GetWBEMBaseClass()
{
	m_pLDAPBaseClass->AddRef();
	return m_pLDAPBaseClass;
}


//***************************************************************************
//
// CLDAPClassProvider::GetWBEMProviderName
//
// Purpose : Returns the name of the provider. This should be the same as the
// value of the field Name in the __Win32Provider instance used for registration
// of the provider
//
// Parameters:
//	None
// 
//	Return Value: The name of the provider
//***************************************************************************
const BSTR CLDAPClassProvider :: GetWBEMProviderName()
{
	return LDAP_CLASS_PROVIDER_NAME; 
}

//***************************************************************************
//
// CLDAPClassProvider::IsUnProvidedClass
//
// Purpose : See header
//***************************************************************************
BOOLEAN CLDAPClassProvider :: IsUnProvidedClass(LPCWSTR lpszClassName)
{
	// CHeck if it is one of the static classes
	if(_wcsicmp(lpszClassName, LDAP_BASE_CLASS_STR) == 0 ||
		_wcsicmp(lpszClassName, UINT8ARRAY_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_WITH_STRING_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_WITH_BINARY_CLASS) == 0 ||
		_wcsicmp(lpszClassName, ROOTDSE_CLASS) == 0 ||
		_wcsicmp(lpszClassName, CLASS_ASSOCIATION_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_ASSOCIATION_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_CLASS) == 0 ||
		_wcsicmp(lpszClassName, INSTANCE_ASSOCIATION_CLASS) == 0)
		return TRUE;

	// Next check if it has appropriate profixes
	if(_wcsnicmp(lpszClassName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0 ||
		_wcsnicmp(lpszClassName, LDAP_CLASS_NAME_PREFIX, LDAP_CLASS_NAME_PREFIX_LENGTH) == 0 )
	{
		return FALSE;
	}

	return TRUE;
}

//***************************************************************************
//
// CLDAPClassProvider::GetClassFromADSI
//
// Purpose : To return the IDirectoryObject interface on the schema container
//
// Parameters:
//	lpszClassName : The WBEM Name of the class to be retreived
//	pCtx : A pointer to the context object that was used in this call. This
//		may be used by this function to make calls to CIMOM
//	ppWbemClass : The resulting WBEM Class. This has to be released once the
//		user is done with it.
//
// 
//	Return Value: The COM result representing the status. 
//***************************************************************************
HRESULT CLDAPClassProvider :: GetClassFromADSI( 
    LPCWSTR lpszWbemClassName,
    IWbemContext *pCtx,
	IWbemClassObject ** ppWbemClass
	)
{
	HRESULT result = E_FAIL;
	BOOLEAN bArtificialClass = FALSE;
	BOOLEAN bAbstractDSClass = FALSE;
	LPWSTR lpszADSIClassName = NULL;

	// First check if this is one our "artificial" classes. All "aritificial" classes start with "ads_".
	// All non artificial classes start with "ds_"
	if(!(lpszADSIClassName = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszWbemClassName)))
	{
		*ppWbemClass = NULL;
		return result;
	}

	if(_wcsnicmp(lpszWbemClassName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
		bArtificialClass = TRUE;

	CADSIClass *pADSIClass = NULL;
	CADSIClass *pADSIParentClass = NULL;

	try
	{
		if(SUCCEEDED(result = GetADSIClass(lpszADSIClassName, &pADSIClass)))
		{
			pADSIClass->SetWBEMClassName(lpszWbemClassName);

			// It is an abstract class is the ADSI class type is Abstract or Auxiliary
			if(pADSIClass->GetObjectClassCategory() == 2 || pADSIClass->GetObjectClassCategory() == 3) 
				bAbstractDSClass = TRUE;

			int iCaseNumber = 0;

			// if the WBEM class name starts with "ADS_" and the DS class is abstract, then this is an error
			if(bArtificialClass && bAbstractDSClass)
				result = WBEM_E_NOT_FOUND;
			else
			{
				// Special case for "top" since the DS returns top as the superclass of top
				if(_wcsicmp(lpszWbemClassName, TOP_CLASS) == 0)
					iCaseNumber = 1;
				else
				{
					if(pADSIClass->GetSuperClassLDAPName())
					{
						// If this is an artificial class
						// Then
						//		Get the ParentDS Class
						//		If the ParentDSClass is abstract 
						//		Then
						//			WMI Parent class is the non-artificial class. Case 2
						//		Else
						//			WMI Parent class is artificial. Case 3
						// Else
						//		If the Current DS Class is abstract
						//		Then
						//			WMI Parent is non-artificial. Case 4
						//		Else
						//			WMI Parent is artificial. Case 5
						//
						if(bArtificialClass)
						{
							// Get the parent DS Class
							if(SUCCEEDED(result = GetADSIClass(pADSIClass->GetSuperClassLDAPName(), &pADSIParentClass)))
							{
								if(pADSIParentClass->GetObjectClassCategory() == 2 || pADSIParentClass->GetObjectClassCategory() == 3) 
								{
									iCaseNumber = 2;
								}
								else
								{
									iCaseNumber = 3;
								}
							}
						}
						else
						{
							if(bAbstractDSClass)
							{
								iCaseNumber = 4;
							}
							else
							{
								iCaseNumber = 5;
							}
						}
					}
					else
						iCaseNumber = 1;
				}	
				
				// Map the ADSI class to a WBEM Class
				if(iCaseNumber != 0 && SUCCEEDED(result = CreateWBEMClass(pADSIClass, iCaseNumber, ppWbemClass,  pCtx)))
				{
				}
				else
				{
					result = WBEM_E_FAILED;
					g_pLogObject->WriteW(L"CLDAPClassProvider :: GetClassFromADSI() : CreateWBEMClass FAILED: %x for %s\r\n", result, lpszWbemClassName);
				}
			}

			// Free the parent ADSI class
			if(pADSIParentClass)
			{
				pADSIParentClass->Release();
				pADSIParentClass = NULL;
			}

			// Free the ADSI Class
			if ( pADSIClass )
			{
				pADSIClass->Release();
				pADSIClass = NULL;
			}
		}
		else
			g_pLogObject->WriteW( L"CLDAPClassProvider :: GetClassFromADSI() GetADSIClass FAILED : %x for %s\r\n", result, lpszWbemClassName);
	}
	catch ( ... )
	{
		// Free the parent ADSI class
		if ( pADSIParentClass )
		{
			pADSIParentClass->Release();
			pADSIParentClass = NULL;
		}

		// Free the ADSI Class
		if ( pADSIClass )
		{
			pADSIClass->Release();
			pADSIClass = NULL;
		}

		delete [] lpszADSIClassName;
		throw;
	}

	delete [] lpszADSIClassName;
	return result;
}


//***************************************************************************
//
// CLDAPClassProvider::CreateWBEMClass
//
// Purpose: Creates WBEM Class corresponding an ADSI Class
//
// Parameters:
//	pADSIClass : A pointer to a CADSI class object that is to be mapped to WBEM.
//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
//		The caller should release it when done
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: CreateWBEMClass (CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx)
{
	HRESULT result;

	*ppWbemClass = NULL;

	// Create the WBEM class and Map the class qualifiers
	if( SUCCEEDED(result = MapClassSystemProperties(pADSIClass, iCaseNumber, ppWbemClass, pCtx) ) )
	{
		// Now that ppWbemClass has been allocated, we need to deallocate it if the return value of this function
		// is not a success
		//=======================================================================================================


		if(iCaseNumber == 5)
		{
			// Nothing more to do except add the "provider" qualifier
			IWbemQualifierSet *pQualifierSet = NULL;
			if(SUCCEEDED(result = (*ppWbemClass)->GetQualifierSet(&pQualifierSet)))
			{
				result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, PROVIDER_BSTR, LDAP_INSTANCE_PROVIDER_NAME, DEFAULT_QUALIFIER_FLAVOUR, FALSE);
				pQualifierSet->Release();
			}
	
		}
		else
		{
			if( SUCCEEDED(result = MapClassQualifiersToWBEM(pADSIClass, iCaseNumber, *ppWbemClass, pCtx) ) )
			{
				// Map the  class properties 
				if( SUCCEEDED(result = MapClassPropertiesToWBEM(pADSIClass, *ppWbemClass, pCtx) ) )
				{
				}
				else
					g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMClass() MapClassPropertiesToWBEM FAILED : %x for %s\r\n", result, pADSIClass->GetWBEMClassName());
			}
			else
				g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMClass() MapClassQualifiersToWBEM FAILED : %x for %s\r\n", result, pADSIClass->GetWBEMClassName());
		}
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMClass() MapClassSystemProperties FAILED : %x for %s\r\n", result, pADSIClass->GetWBEMClassName());

	if(!SUCCEEDED(result))
	{
		if(*ppWbemClass)
		{
			(*ppWbemClass)->Release();
			*ppWbemClass = NULL;
		}
	}

	return result;
}

//***************************************************************************
//
// CLDAPClassProvider::MapClassSystemProperties
//
// Purpose: Creates an appropriately derived WBEM class and names it (__CLASS)
//
// Parameters:
//	pADSIClass : The ADSI class that is being mapped
//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
//		The caller should release it when done
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapClassSystemProperties(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx)
{
	HRESULT result = WBEM_S_NO_ERROR;
	LPCWSTR lpszClassName = pADSIClass->GetWBEMClassName();

	// Create the WBEM class first.
	// This process depends on whether the ADSI class is derived from
	// another ADSI class or not. 
	// If so, that base class has to be retrieved and the derived class
	// to be spawned from that.
	// If not, then the function GetWBEMBaseClass() is called and the class 
	// being mapped is derived from that class

	IWbemClassObject *pBaseClass = NULL;
	if(iCaseNumber == 1)
	{
		pBaseClass = GetWBEMBaseClass();
	}
	else
	{
		LPWSTR lpszWBEMParentClassName = NULL;
		switch(iCaseNumber)
		{
			case 1:
				{
					pBaseClass = GetWBEMBaseClass();
					break;
				}
			case 2:
			case 4:
				{
					lpszWBEMParentClassName = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetSuperClassLDAPName(), FALSE);
					break;
				}
			case 3:
				{
					lpszWBEMParentClassName = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetSuperClassLDAPName(), TRUE);
					break;
				}
			case 5:
				{
					lpszWBEMParentClassName = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetADSIClassName(), TRUE);
					break;
				}
			default:
				{
					result = WBEM_E_FAILED;
					break;
				}
		}

		if(SUCCEEDED(result))
		{
			BSTR strWBEMParentClass = SysAllocString(lpszWBEMParentClassName);		
			delete [] lpszWBEMParentClassName;
			// Get the parent WBEM Class
			if(FAILED(result = m_IWbemServices->GetObject(strWBEMParentClass, 0, pCtx, &pBaseClass, NULL)))
				g_pLogObject->WriteW( L"CLDAPClassProvider :: MapClassSystemProperties() GetObject on ADSI base class FAILED : %x for %s\r\n", result, strWBEMParentClass);
			SysFreeString(strWBEMParentClass);
		}
	}
	
	if(FAILED(result) || pBaseClass == NULL)
		return result;

	// Spawn the derived class
	result = pBaseClass->SpawnDerivedClass(0, ppWbemClass);
	pBaseClass->Release();
	if(SUCCEEDED(result))
	{
		// Create the __CLASS property
		// Make sure the case of the letters is not mixed up
		SanitizedClassName((LPWSTR)lpszClassName);
		if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppWbemClass, CLASS_STR, SysAllocString(lpszClassName), TRUE)))
		{
		}
		else
			g_pLogObject->WriteW( L"CLDAPClassProvider :: MapClassSystemProperties() on __CLASS FAILED : %x for %s\r\n", result, lpszClassName);
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassProvider :: MapClassSystemProperties() SpawnDerived on WBEM base class FAILED : %x for %s\r\n", result, lpszClassName);
	
	return result;
}




//***************************************************************************
//
// CLDAPClassProvider :: MapClassQualifiersToWBEM
//
// Purpose: Creates the class qualifiers for a WBEM class from the ADSI class
//
// Parameters:
//	pADSIClass : The LDAP class that is being mapped
//	pWbemClass : The WBEM class object being created. T
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapClassQualifiersToWBEM(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject *pWbemClass, IWbemContext *pCtx)
{
	IWbemQualifierSet *pQualifierSet = NULL;
	HRESULT result = pWbemClass->GetQualifierSet(&pQualifierSet);

	LPCWSTR lpszTemp;
	BOOLEAN bIsAbstract = FALSE;

	// Map each of the LDAP class attributes to WBEM class qualifiers/properties
	if(SUCCEEDED(result))
	{
		result = CWBEMHelper::PutI4Qualifier(pQualifierSet, OBJECT_CLASS_CATEGORY_ATTR_BSTR, pADSIClass->GetObjectClassCategory(), DEFAULT_QUALIFIER_FLAVOUR);
		// It is an abstract class is the ADSI class type is Abstract or Auxiliary
		if(SUCCEEDED(result) && (pADSIClass->GetObjectClassCategory() == 2 || pADSIClass->GetObjectClassCategory() == 3) )
		{
			bIsAbstract = TRUE;
			result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, ABSTRACT_BSTR, VARIANT_TRUE, WBEM_FLAVOR_OVERRIDABLE);
		} 
		else if (iCaseNumber == 2 || iCaseNumber == 3)
		{
			bIsAbstract = TRUE;
			result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, ABSTRACT_BSTR, VARIANT_TRUE, WBEM_FLAVOR_OVERRIDABLE);
		}
	}

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, DYNAMIC_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR);

	// provider qualifier is put only for non-abstract classes
	if(!bIsAbstract && SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, PROVIDER_BSTR, LDAP_INSTANCE_PROVIDER_NAME, DEFAULT_QUALIFIER_FLAVOUR, FALSE);

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, COMMON_NAME_ATTR_BSTR, SysAllocString(pADSIClass->GetCommonName()), DEFAULT_QUALIFIER_FLAVOUR);

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, LDAP_DISPLAY_NAME_ATTR_BSTR, SysAllocString(pADSIClass->GetName()), DEFAULT_QUALIFIER_FLAVOUR);
	
	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, GOVERNS_ID_ATTR_BSTR, SysAllocString(pADSIClass->GetGovernsID()), DEFAULT_QUALIFIER_FLAVOUR);
	
	// Do not map this, since this is not exposed thru the schema-management snapin
	/*
	if(SUCCEEDED(result))
	{
		const LPBYTE pValues = pADSIClass->GetSchemaIDGUID(&dwTemp);
		result = CWBEMHelper::PutUint8ArrayQualifier(pQualifierSet, SCHEMA_ID_GUID_ATTR_BSTR, pValues, dwTemp, DEFAULT_QUALIFIER_FLAVOUR);
	}
	*/
	
	if(SUCCEEDED(result) && (lpszTemp = pADSIClass->GetDefaultSecurityDescriptor()))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, DEFAULT_SECURITY_DESCRP_ATTR_BSTR, SysAllocString(lpszTemp), DEFAULT_QUALIFIER_FLAVOUR);
	
	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, SYSTEM_ONLY_ATTR_BSTR, pADSIClass->GetSystemOnly(), DEFAULT_QUALIFIER_FLAVOUR);

	/*
	if(SUCCEEDED(result))
	{
		const LPBYTE pValues = pADSIClass->GetNTSecurityDescriptor(&dwTemp);
		result = CWBEMHelper::PutUint8ArrayQualifier(pQualifierSet, NT_SECURITY_DESCRIPTOR_ATTR_BSTR, pValues, dwTemp, DEFAULT_QUALIFIER_FLAVOUR);
	}
	*/

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, DEFAULT_OBJECTCATEGORY_ATTR_BSTR, SysAllocString(pADSIClass->GetDefaultObjectCategory()), DEFAULT_QUALIFIER_FLAVOUR);

	pQualifierSet->Release();
	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: MapClassPropertiesToWBEM
//
// Purpose: Creates the class properties for a WBEM class from the ADSI class
//
// Parameters:
//	pADSIClass : The LDAP class that is being mapped
//	pWbemClass : The WBEM class object being created. 
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapClassPropertiesToWBEM(CADSIClass *pADSIClass, IWbemClassObject *pWbemClass, IWbemContext *pCtx)
{
	HRESULT result = S_OK;

	//////////////////////////////////////////////////
	// Go thru the set of Auxiliary Classes 
	//////////////////////////////////////////////////
	DWORD dwCount = 0;
	LPCWSTR *lppszPropertyList = pADSIClass->GetAuxiliaryClasses(&dwCount);
	CADSIClass *pNextClass = NULL;
	if(dwCount)
	{
		for(DWORD dwNextClass=0; dwNextClass<dwCount; dwNextClass++)
		{
			LPWSTR lpszWBEMClassName = CLDAPHelper::MangleLDAPNameToWBEM(lppszPropertyList[dwNextClass]);

			try
			{
				if(SUCCEEDED(result = s_pLDAPCache->GetClass(lpszWBEMClassName, lppszPropertyList[dwNextClass], &pNextClass)))
				{
					if(SUCCEEDED(result = MapClassPropertiesToWBEM(pNextClass, pWbemClass, pCtx)))
					{
					}
					pNextClass->Release();
					pNextClass = NULL;
				}
			}
			catch ( ... )
			{
				if ( pNextClass )
				{
					pNextClass->Release ();
					pNextClass = NULL;
				}

				delete [] lpszWBEMClassName;
				throw;
			}

			delete [] lpszWBEMClassName;
		}
	}
	if(FAILED(result))
		return result;

	//////////////////////////////////////////////////
	// Go thru the set of System Auxiliary Classes 
	//////////////////////////////////////////////////
	dwCount = 0;
	lppszPropertyList = pADSIClass->GetSystemAuxiliaryClasses(&dwCount);
	pNextClass = NULL;
	if(dwCount)
	{
		for(DWORD dwNextClass=0; dwNextClass<dwCount; dwNextClass++)
		{
			LPWSTR lpszWBEMClassName = CLDAPHelper::MangleLDAPNameToWBEM(lppszPropertyList[dwNextClass]);

			try
			{
				if(SUCCEEDED(result = s_pLDAPCache->GetClass(lpszWBEMClassName, lppszPropertyList[dwNextClass], &pNextClass)))
				{
					if(SUCCEEDED(result = MapClassPropertiesToWBEM(pNextClass, pWbemClass, pCtx)))
					{
					}
					pNextClass->Release();
					pNextClass = NULL;
				}
			}
			catch ( ... )
			{
				if ( pNextClass )
				{
					pNextClass->Release ();
					pNextClass = NULL;
				}

				delete [] lpszWBEMClassName;
				throw;
			}

			delete [] lpszWBEMClassName;
		}
	}
	if(FAILED(result))
		return result;

	//////////////////////////////////////////////////
	// Go thru the set of System May Contains
	//////////////////////////////////////////////////
	dwCount = 0;
	lppszPropertyList = pADSIClass->GetSystemMayContains(&dwCount);
	if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, TRUE, FALSE)))
	{
		//////////////////////////////////////////////////
		// Go thru the set of May Contains
		//////////////////////////////////////////////////
		dwCount = 0;
		lppszPropertyList = pADSIClass->GetMayContains(&dwCount);
		if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, FALSE, FALSE)))
		{
			//////////////////////////////////////////////////
			// Go thru the set of System Must Contains
			//////////////////////////////////////////////////
			dwCount = 0;
			lppszPropertyList = pADSIClass->GetSystemMustContains(&dwCount);
			if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, TRUE, TRUE)))
			{
				//////////////////////////////////////////////////
				// Go thru the set of Must Contains
				//////////////////////////////////////////////////
				dwCount = 0;
				lppszPropertyList = pADSIClass->GetMustContains(&dwCount);
				if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, FALSE, TRUE)))
				{

				} // MapPropertyListToWBEM
			} // MapPropertyListToWBEM
		} // MapPropertyListToWBEM
	} // MapPropertyListToWBEM
		
	// Do not map any other properties, if failed
	if(FAILED(result))
		return result;

	// Map the RDN property as indexed
	LPWSTR lpszRDNAttribute = NULL;
	lpszRDNAttribute = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetRDNAttribute());
	if(lpszRDNAttribute)
	{
		BSTR strRDNAttribute = SysAllocString(lpszRDNAttribute);
		IWbemQualifierSet *pQualifierSet = NULL;
		if(SUCCEEDED(result = pWbemClass->GetPropertyQualifierSet(strRDNAttribute, &pQualifierSet)))
		{
			IWbemQualifierSet *pClassQualifiers = NULL;
			if(SUCCEEDED(result = pWbemClass->GetQualifierSet(&pClassQualifiers)))
			{
				// ALso put a qualifier on the class that indicates that this is the RDNAttId
				if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(pClassQualifiers, RDN_ATT_ID_ATTR_BSTR, SysAllocString(pADSIClass->GetRDNAttribute()), DEFAULT_QUALIFIER_FLAVOUR, TRUE)))
				{
					if(SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, INDEXED_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR)))
					{

					}
					// It is fine if this property has already been designated as indexed in the base class
					else if (result == WBEM_E_OVERRIDE_NOT_ALLOWED)
						result = S_OK;
				}
				pClassQualifiers->Release();
			}
			// Release the Qualifer Set
			pQualifierSet->Release();
		}
		SysFreeString(strRDNAttribute);
	}
	delete [] lpszRDNAttribute;

	return result;
}


//***************************************************************************
//
// CLDAPClassProvider :: MapPropertyListToWBEM
//
// Purpose: Maps a list of class properties for a WBEM class from the ADSI class
//
// Parameters:
//	pWbemClass : The WBEM class object being created. 
//	lppszPropertyList : A list of propery names
//	dwCOunt : The number of items in the above list
//	bMapSystemQualifier : Whether the "system" qualifier should be mapped
//	bMapNotNullQualifier: Whether the "notNull" qualifier should be mapped
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapPropertyListToWBEM(IWbemClassObject *pWbemClass, 
													LPCWSTR *lppszPropertyList, 
													DWORD dwCount, 
													BOOLEAN bMapSystemQualifier, 
													BOOLEAN bMapNotNullQualifier)
{
	HRESULT result = S_OK;
	CADSIProperty *pNextProperty;
	IWbemQualifierSet *pQualifierSet;
	if(dwCount)
	{
		for(DWORD dwNextProperty=0; dwNextProperty<dwCount; dwNextProperty++)
		{
			// Get the property from the cache. The name of the property will be the LDAP name
			if(SUCCEEDED(result = s_pLDAPCache->GetProperty(lppszPropertyList[dwNextProperty], &pNextProperty, FALSE)))
			{
				if ( pNextProperty )
				{
					// Map the basic property
					if(SUCCEEDED(result = CreateWBEMProperty(pWbemClass, &pQualifierSet, pNextProperty)))
					{
						// Map the "system" qualifier
						if(bMapSystemQualifier && SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, SYSTEM_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR)))
						{
						}

						// Map the "not_null" qualifier
						if(bMapNotNullQualifier && SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, NOT_NULL_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR)))
						{
						}

						// Release the qualifier set
						pQualifierSet->Release();
					}
					// Release the property
					pNextProperty->Release();
				}
			}
			// Do not map any other properties
			if(FAILED(result))
				break;
		}
	}

	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: CreateWBEMProperty
//
// Purpose: Creates a WBEM property from an LDAP property
//
// Parameters:
//	pWbemClass : The WBEM class in which the property is created
//	ppQualiferSet : The address of the pointer to IWbemQualiferSet where the qualifier set
//		of this property will be placed
//	pADSIProperty : The ADSI Property object that is being mapped to the property being created
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: CreateWBEMProperty(IWbemClassObject *pWbemClass, IWbemQualifierSet **ppQualifierSet, CADSIProperty *pADSIProperty)
{
	HRESULT result = E_FAIL;

	// Get all the attributes of the ADSI class
	LPCWSTR lpszSyntaxOid = pADSIProperty->GetSyntaxOID();
	BSTR strCimTypeQualifier = NULL;

	// Note that strCimTypeQualifier is not allocated in this call, so it is not freed.
	CIMTYPE theCimType = MapLDAPSyntaxToWBEM(pADSIProperty, &strCimTypeQualifier);

	if(lpszSyntaxOid)
	{
		// Create the property
		BSTR strPropertyName = SysAllocString(pADSIProperty->GetWBEMPropertyName());
		if(SUCCEEDED(result = pWbemClass->Put(strPropertyName, 0, NULL, theCimType)))
		{
			// Get the Qualifier Set in ppQualifierSet
			if(SUCCEEDED(result = pWbemClass->GetPropertyQualifierSet(strPropertyName, ppQualifierSet)))
			{
				// Map the property attributes to WBEM qualifiers
				if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
							ATTRIBUTE_SYNTAX_ATTR_BSTR, 
							SysAllocString(lpszSyntaxOid),
							DEFAULT_QUALIFIER_FLAVOUR)))
				{
					/* Commented to reduce size of classes
					if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
								ATTRIBUTE_ID_ATTR_BSTR, 
								SysAllocString(pADSIProperty->GetAttributeID()),
								DEFAULT_QUALIFIER_FLAVOUR)))
					{
					*/
						if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
								COMMON_NAME_ATTR_BSTR, 
								SysAllocString(pADSIProperty->GetCommonName()),
								DEFAULT_QUALIFIER_FLAVOUR)))
						{
							/* Commented to reduce size of classes
							if(SUCCEEDED(result = CWBEMHelper::PutI4Qualifier(*ppQualifierSet, 
									MAPI_ID_ATTR_BSTR,
									pADSIProperty->GetMAPI_ID(),
									DEFAULT_QUALIFIER_FLAVOUR)))
							{
								if(SUCCEEDED(result = CWBEMHelper::PutI4Qualifier(*ppQualifierSet, 
										OM_SYNTAX_ATTR_BSTR,
										pADSIProperty->GetOMSyntax(),
										DEFAULT_QUALIFIER_FLAVOUR)))
								{
									if(pADSIProperty->IsSystemOnly())
									{
										if(SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(*ppQualifierSet, 
												SYSTEM_ONLY_ATTR_BSTR,
												VARIANT_TRUE,
												DEFAULT_QUALIFIER_FLAVOUR)))
										{
										}
									}
								*/

									// If this is an embedded property, then use the cimType qualifier on the property
									if(strCimTypeQualifier)
									{
										result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
													CIMTYPE_STR, 
													strCimTypeQualifier,
													DEFAULT_QUALIFIER_FLAVOUR, FALSE); 
									}

									if(SUCCEEDED(result) && pADSIProperty->GetSearchFlags() == 1)
									{
										if(SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(*ppQualifierSet, 
											INDEXED_BSTR,
											VARIANT_TRUE,
											DEFAULT_QUALIFIER_FLAVOUR)))
										{
										}
										else if (result == WBEM_E_OVERRIDE_NOT_ALLOWED)
											result = S_OK;
									}
								}
							/*
							}
						}
					}
					*/
				}
			}
			else
				g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMProperty FAILED to get qualifier set for %s", pADSIProperty->GetADSIPropertyName());
		}
		else
			g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMProperty FAILED to put property : %s", pADSIProperty->GetADSIPropertyName());

		SysFreeString(strPropertyName);
	}
	else
	{
		g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMProperty FAILED to get Syntax OID property for %s", pADSIProperty->GetADSIPropertyName());
		result = E_FAIL;
	}

	return result;
}


//***************************************************************************
//
// CLDAPClassProvider :: MapLDAPSyntaxToWBEM
//
// Purpose: See Header
//
//***************************************************************************
CIMTYPE CLDAPClassProvider :: MapLDAPSyntaxToWBEM(CADSIProperty *pADSIProperty, BSTR *pstrCimTypeQualifier)
{
	*pstrCimTypeQualifier = NULL;
	LPCWSTR lpszSyntaxOid = pADSIProperty->GetSyntaxOID();
	CIMTYPE retValue = (pADSIProperty->IsMultiValued())? CIM_FLAG_ARRAY : 0;

	if(wcscmp(lpszSyntaxOid, UNICODE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, INTEGER_OID) == 0)
		return retValue | CIM_SINT32;
	else if(wcscmp(lpszSyntaxOid, LARGE_INTEGER_OID) == 0)
		return retValue | CIM_SINT64;
	else if(wcscmp(lpszSyntaxOid, BOOLEAN_OID) == 0)
		return retValue | CIM_BOOLEAN;
	else if(wcscmp(lpszSyntaxOid, OBJECT_IDENTIFIER_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, DISTINGUISHED_NAME_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, CASE_SENSITIVE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, CASE_INSENSITIVE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, PRINT_CASE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, OCTET_STRING_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, NUMERIC_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, PRINT_CASE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, DN_WITH_BINARY_OID) == 0)
	{
		// DN_With_Binary and OR_Name have the same syntax oid.
		// They are differentiated base on the value of the OMObjectClass value
		if(pADSIProperty->IsORName())
			return retValue | CIM_STRING;
		else // It is DN_With_Binary
		{
			*pstrCimTypeQualifier = EMBED_DN_WITH_BINARY;
			return retValue | CIM_OBJECT;
		}
	}
	else if(wcscmp(lpszSyntaxOid, NT_SECURITY_DESCRIPTOR_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, PRESENTATION_ADDRESS_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, DN_WITH_STRING_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_DN_WITH_BINARY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, SID_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, TIME_OID) == 0)
		return retValue | CIM_DATETIME;
	else 
	{
		g_pLogObject->WriteW( L"CLDAPClassProvider :: MapLDAPSyntaxToWBEM FAILED to map syntax for OID: %s\r\n", lpszSyntaxOid);
		return retValue | CIM_STRING;
	}
}

//***************************************************************************
//
// CLDAPClassProvider :: CreateClassEnumAsync
//
// Purpose: Enumerates the classes 
//
// Parameters:
//	Standard parmaters as described by the IWbemServices interface
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: CreateClassEnumAsync( 
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPClassProvider :: Initialization status is FAILED, hence returning failure\r\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() called for %s SuperClass and %s \r\n",
		((strSuperclass)? strSuperclass : L" "), ((lFlags & WBEM_FLAG_SHALLOW)? L"SHALLOW" : L"DEEP"));

	// Impersonate the client
	//=======================
	HRESULT result = WBEM_E_FAILED;
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CDSClassProvider :: CreateClassEnumAsync() CoImpersonate FAILED for %s with %x\r\n", strSuperclass, result);
		return WBEM_E_FAILED;
	}

	try
	{

		BSTR strTheSuperClass = strSuperclass;
		
		// CIMOM seems to give the strSuperClass as NULL sometimes and as "" sometimes. Make it unambiguous
		if(!strTheSuperClass || wcscmp(strTheSuperClass, L"") == 0)
		{
			if( lFlags & WBEM_FLAG_SHALLOW) 
			{
				// Nothing to be done since we do not provide cany classes that fit this
				strTheSuperClass = NULL;
				result = S_OK;
			}
			else
			{
				strTheSuperClass = LDAP_BASE_CLASS_STR; // Recursive enumeration handled below
			}
		}

		// Take the special cases first
		//	1. Where the strSuperClass is LDAP_BASE_CLASS_STR and lFlags is Shallow
		//	Nothing to be returned here, since we are not supplying the LDAP_BASE_CLASS_STR
		//	which is statically supplied.
		//=======================================================================
		if(strTheSuperClass && _wcsicmp(strTheSuperClass, LDAP_BASE_CLASS_STR) == 0 )
		{
			// First the TOP class needs to be returned
			IWbemClassObject *pReturnObject = NULL;
			if(SUCCEEDED(result = GetClassFromCacheOrADSI(TOP_CLASS, &pReturnObject, pCtx)))
			{
				result = pResponseHandler->Indicate(1, &pReturnObject);
				pReturnObject->Release();

				if(SUCCEEDED(result))
				{
					if( lFlags & WBEM_FLAG_SHALLOW) // Notheing more to be done
					{
					}
					else // We've to return all the sub classes of top too, recursively
					{
						if(SUCCEEDED(result = HandleRecursiveEnumeration(TOP_CLASS, pCtx, pResponseHandler)))
						{
							g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s succeeded\r\n", strTheSuperClass);
						}
						else
						{
							g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s FAILED\r\n", strTheSuperClass);
						}
					}
				}
				else
					g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s was CANCELLED\r\n", strTheSuperClass);
			}
		}
		// 2. Where the superClass is specified
		//=======================================================================
		else if(strTheSuperClass)
		{
			// Optimize the operation by seeing if it is one of the static classes and
			// its name does not start with "ADS_" or "DS_". Then we dont know anything about it
			//============================================================================
			if(IsUnProvidedClass(strTheSuperClass))
			{
				result = S_OK;
			}
			else
			{
				BOOLEAN bArtificialClass = FALSE;

				// First check if this is one our "artificial" classes. All "aritificial" classes start with "ads_".
				// All non artificial classes start with "ds_"
				if(_wcsnicmp(strTheSuperClass, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
					bArtificialClass = TRUE;

				// When the search is shallow
				if( lFlags & WBEM_FLAG_SHALLOW)
				{
					// The ADSI classes
					LPWSTR *ppADSIClasses = NULL;
					// The number of ADSI classes
					DWORD dwNumClasses = 0;

					try
					{
						if(SUCCEEDED(result = GetOneLevelDeep(strTheSuperClass, bArtificialClass, &ppADSIClasses, &dwNumClasses, pCtx)))
						{
							// Interact with CIMOM
							//=====================
							if(SUCCEEDED(result = WrapUpEnumeration(ppADSIClasses, dwNumClasses, pCtx, pResponseHandler)))
							{
							}

							// Release the list of ADSI classes and its contents
							//==================================================
							for(DWORD j=0; j<dwNumClasses; j++)
							{
								delete [] ppADSIClasses[j];
								ppADSIClasses[j] = NULL;
							}

							delete[] ppADSIClasses;
							ppADSIClasses = NULL;
						}
					}
					catch ( ... )
					{
						if ( ppADSIClasses )
						{
							for ( DWORD j=0; j<dwNumClasses; j++ )
							{
								delete [] ppADSIClasses[j];
								ppADSIClasses[j] = NULL;
							}

							delete[] ppADSIClasses;
							ppADSIClasses = NULL;
						}

						throw;
					}
				}
				else // the search is deep
				{
					if(SUCCEEDED(result = HandleRecursiveEnumeration(strTheSuperClass, pCtx, pResponseHandler)))
					{
						g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s succeeded\r\n", strTheSuperClass);
					}
					else
					{
						g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s FAILED\r\n", strTheSuperClass);
					}
				}

			}
		}

				
		if(SUCCEEDED(result))
		{
			pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
			g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Non-Recursive enumeration succeeded\r\n");
		}
		else
		{
			pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
			g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Non-Recursive enumeration FAILED for superclass %s \r\n", strTheSuperClass);
		}
	}
	catch(Heap_Exception e_HE)
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_OUT_OF_MEMORY, NULL, NULL);
	}

	return WBEM_S_NO_ERROR;
}
    

//***************************************************************************
//
// CLDAPClassProvider :: GetOneLevelDeep
//
// Purpose: Enumerates the sub classes of a superclass non-recursively
//
// Parameters:
//
//	lpszSuperClass : The super class name
//	pResponseHandler : The interface where the resulting classes are put
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: GetOneLevelDeep( 
    LPCWSTR lpszWBEMSuperclass,
	BOOLEAN bArtificialClass,
	LPWSTR ** pppADSIClasses,
	DWORD *pdwNumClasses,
	IWbemContext *pCtx)
{
	// The ADSI classes
	*pppADSIClasses = NULL;
	// The number of ADSI classes
	*pdwNumClasses = 0;
	HRESULT result = WBEM_E_FAILED;

	// See if the super class
	IWbemClassObject *pSuperClass = NULL;
	if(!SUCCEEDED(result = GetClassFromCacheOrADSI(lpszWBEMSuperclass, &pSuperClass, pCtx)))
	{
		return WBEM_E_NOT_FOUND;
	}
	pSuperClass->Release();

	// If the WBEM class is concrete, we dont need to do anything
	if (SUCCEEDED(result = IsConcreteClass(lpszWBEMSuperclass, pCtx)))
	{
		if(result == S_OK)
			return S_OK;
	}
	else
		return result;

	// See the cache first
	//====================
	CEnumInfo *pEnumInfo = NULL;
	try
	{
		if(SUCCEEDED(result = s_pWbemCache->GetEnumInfo(lpszWBEMSuperclass, &pEnumInfo)))
		{
			CNamesList *pNamesList = pEnumInfo->GetSubClassNames();
			*pdwNumClasses = pNamesList->GetAllNames(pppADSIClasses);

			pEnumInfo->Release();
			pEnumInfo = NULL;
		}
		else // Go to ADSI 
			//============
		{
			// The following are the possibilities now"
			// 1. The Class starts with "ADS_". It is abstract by definition. All its sub-classes except one are abstract,artificial.
			// 2. The Class starts with "DS_" and it is abstract. It being concrete is ruled out since it was handled at the
			// top of this function

			// Get all the ADSI classes 
			if(SUCCEEDED(result = s_pLDAPCache->EnumerateClasses(
				lpszWBEMSuperclass,
				FALSE,
				pppADSIClasses,
				pdwNumClasses,
				bArtificialClass)))
			{

				// Create a list of names for holding the subclasses
				CNamesList *pNewList = new CNamesList;
				LPWSTR pszWBEMName = NULL;

				try
				{
					// The First case in the 2 cases above
					if(bArtificialClass)
					{
						// The first element is just the super class without the A
						// Example if the super class is "ADS_User", the first element is DS_user
						pNewList->AddName((*pppADSIClasses)[0]);


						// Start from the secodn element
						for(DWORD i=1; i<*pdwNumClasses; i++)
						{
							// Convert names to WBEM And add them to the new list
							pszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM((*pppADSIClasses)[i], TRUE);
							pNewList->AddName(pszWBEMName);

							delete [] (*pppADSIClasses)[i];
							(*pppADSIClasses)[i] = pszWBEMName;
						}
					}
					else // The Second case
					{
						for(DWORD i=0; i<*pdwNumClasses; i++)
						{
							// Convert names to WBEM And add them to the new list
							pszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM((*pppADSIClasses)[i], FALSE);

							LPWSTR pszRealClassName = NULL;

							if(SUCCEEDED(result = IsConcreteClass(pszWBEMName, pCtx)))
							{
								if(result == S_OK)
								{
									pszRealClassName = CLDAPHelper::MangleLDAPNameToWBEM((*pppADSIClasses)[i], TRUE);
									delete[] pszWBEMName;
									pNewList->AddName(pszRealClassName);
									delete [] (*pppADSIClasses)[i];
									(*pppADSIClasses)[i] = pszRealClassName;
								}
								else
								{
									pNewList->AddName(pszWBEMName);
									delete [] (*pppADSIClasses)[i];
									(*pppADSIClasses)[i] = pszWBEMName;
								}
							}
							else
								g_pLogObject->WriteW( L"CLDAPClassProvider :: GetOneLevelDeep() UNKNOWN FAILED for %s \r\n", lpszWBEMSuperclass);
						}
					}
				}
				catch ( ... )
				{
					if ( pNewList )
					{
						delete pNewList;
						pNewList = NULL;
					}

					throw;
				}

				// Add the new EnumInfo to the Enum cache
				pEnumInfo = new CEnumInfo(lpszWBEMSuperclass, pNewList);
				s_pWbemCache->AddEnumInfo(pEnumInfo);

				pEnumInfo->Release();
				pEnumInfo = NULL;
				
			}
			else
				g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() GetOneLevelDeep() FAILED for %s \r\n", lpszWBEMSuperclass);
		}
	}
	catch ( ... )
	{
		if ( pEnumInfo )
		{
			pEnumInfo->Release();
			pEnumInfo = NULL;
		}

		throw;
	}

	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: HandleRecursiveEnumeration
//
// Purpose: Enumerates the sub classes of a superclass recursively
//
// Parameters:
//
//	lpszSuperClass : The super class name
//	pResponseHandler : The interface where the resulting classes are put
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: HandleRecursiveEnumeration( 
    LPCWSTR lpszWBEMSuperclass,
    IWbemContext *pCtx,
    IWbemObjectSink *pResponseHandler)
{
	g_pLogObject->WriteW( L"CLDAPClassProvider :: HandleRecursiveEnumeration() called for %s SuperClass \r\n",
			((lpszWBEMSuperclass)? lpszWBEMSuperclass : L" "));
	HRESULT result = E_FAIL;

	// The ADSI classes
	LPWSTR *ppADSIClasses = NULL;
	// The number of ADSI classes
	DWORD dwNumClasses = 0;

	// First check if this is one our "artificial" classes. All "aritificial" classes start with "ads_".
	// All non artificial classes start with "ds_"
	BOOLEAN bArtificialClass = FALSE;
	if(_wcsnicmp(lpszWBEMSuperclass, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
		bArtificialClass = TRUE;

	if(SUCCEEDED(result = GetOneLevelDeep(lpszWBEMSuperclass, bArtificialClass, &ppADSIClasses, &dwNumClasses, pCtx)))
	{
		// Interact with CIMOM
		//=====================
		if(FAILED(result = WrapUpEnumeration(ppADSIClasses, dwNumClasses, pCtx, pResponseHandler)))
			g_pLogObject->WriteW( L"CLDAPClassProvider :: HandleRecursiveEnumeration() WrapUpEnumeration() for Superclass %s FAILED with %x \r\n",
				((lpszWBEMSuperclass)? lpszWBEMSuperclass : L" "), result);
		else
		{
			// Go thru the list of ADSI classes and its contents and Enumerate into them too
			for(DWORD j=0; j<dwNumClasses; j++)
			{
				if(FAILED(result = HandleRecursiveEnumeration(ppADSIClasses[j], pCtx, pResponseHandler)))
					break;
			}
		}

		// Go thru the list of ADSI classes and release them
		for(DWORD j=0; j<dwNumClasses; j++)
			delete [] ppADSIClasses[j];

		delete[] ppADSIClasses;
	}
	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: WrapUpEnumeration
//
// Purpose: Creates WBEM classes from ADSI classes and Indicates them to CIMOM
//
// Parameters:
//
//	lpszSuperClass : The super class name
//	pResponseHandler : The interface where the resulting classes are put
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: WrapUpEnumeration( 
	LPWSTR *ppADSIClasses,
	DWORD dwNumClasses,
    IWbemContext *pCtx,
    IWbemObjectSink *pResponseHandler)
{
	// The WBEM Class objects created
	IWbemClassObject **ppReturnWbemClassObjects = NULL;
	// The number of WBEM class objects that were successfully created
	DWORD i=0;
	DWORD j=0;
	HRESULT result = S_OK;
	if(dwNumClasses != 0)
	{
		// Allocate an array of IWbemClassObject pointers
		ppReturnWbemClassObjects = NULL;
		if(ppReturnWbemClassObjects = new IWbemClassObject *[dwNumClasses])
		{
			for(i=0; i<dwNumClasses; i++)
			{
				// Get the class
				if(!SUCCEEDED(result = GetClassFromCacheOrADSI(ppADSIClasses[i], ppReturnWbemClassObjects + i, pCtx)))
				{
					g_pLogObject->WriteW( L"CLDAPClassProvider :: WrapUpEnumeration() GetClassFromCacheOrADSI() FAILED with %x \r\n", result);
					break;
				}
			}
		}
		else
			result = E_OUTOFMEMORY;
	}

	// Indicate(), but do not SetStatus()
	if(SUCCEEDED(result))
	{
		// result = pResponseHandler->Indicate(i, ppReturnWbemClassObjects);
		////////////////////////////////////

		//
		// Break it up into 4 objects at a time - JUST FOR TESTING AGAINST BUG 39838
		// 

		DWORD dwMaxObjectsAtATime  = 4;
		j = 0;
		while ( j<i )
		{
			DWORD dwThisIndicationsCount = ((i-j) > dwMaxObjectsAtATime)? dwMaxObjectsAtATime : (i-j);
			if(FAILED(result = pResponseHandler->Indicate(dwThisIndicationsCount, ppReturnWbemClassObjects + j)))
			{
				g_pLogObject->WriteW( L"CLDAPClassProvider :: WrapUpEnumeration() Indicate() FAILED with %x \r\n", result);
				break;
			}

			j+= dwThisIndicationsCount;
		}
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassProvider :: HandleRecursiveEnumeration() WrapUpEnumeration() FAILED with %x \r\n", result);

	// Delete the list of WBEM Classes and its contents. 
	for(j=0; j<i; j++)
		(ppReturnWbemClassObjects[j])->Release();
	delete[] ppReturnWbemClassObjects;

	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: IsConcreteClass
//
// Purpose: Find out whether a WBEM class is concrete. 
//
// Parameters:
//
//	pszWBEMName : The class name
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: IsConcreteClass( 
	LPCWSTR pszWBEMName,
    IWbemContext *pCtx)
{
	// The call to IsConcreteClass is optimized if the class is artificial,
	// since all artificial classes are non-concrete
	if(_wcsnicmp(pszWBEMName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
		return S_FALSE;

	IWbemClassObject *pWbemClass = NULL;
	HRESULT result = E_FAIL;

	if(SUCCEEDED(GetClassFromCacheOrADSI(pszWBEMName,  &pWbemClass, pCtx)))
	{
		IWbemQualifierSet *pQualifierSet = NULL;
		if(SUCCEEDED(result = pWbemClass->GetQualifierSet(&pQualifierSet)))
		{
			VARIANT_BOOL bAbstract = VARIANT_FALSE;
			if(SUCCEEDED(CWBEMHelper::GetBOOLQualifier(pQualifierSet, ABSTRACT_BSTR, &bAbstract, NULL)))
			{
				if(bAbstract == VARIANT_TRUE)
					result = S_FALSE;
				else
					result = S_OK;
			}
			pQualifierSet->Release();
		}
		pWbemClass->Release();
	}
	return result;
}

void CLDAPClassProvider :: SanitizedClassName(LPWSTR lpszClassName)
{
	while(*lpszClassName)
	{
		*lpszClassName = towlower(*lpszClassName);
		lpszClassName++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\maindll.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Count of locks
extern long g_lComponents;

// Count of active locks
extern long g_lServerLocks;

// Critical section to access the static initializers of all classes in the DLL
extern CRITICAL_SECTION g_StaticsCreationDeletion;

// The log object for all providers
extern ProvDebugLog *g_pLogObject;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\maindll.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile: maindll.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains DLL entry points.  Also has code that controls
//  when the DLL can be unloaded by tracking the number of objects and locks.
//
//***************************************************************************

#include "precomp.h"
#include <initguid.h>
#include "dscpguid.h"
#include "dsipguid.h"

// HANDLE of the DLL
HINSTANCE   g_hInst = NULL;

// Count of locks
long g_lComponents = 0;
// Count of active locks
long g_lServerLocks = 0;

// A critical section to create/delete statics 
CRITICAL_SECTION g_StaticsCreationDeletion;

ProvDebugLog *g_pLogObject = NULL;

//***************************************************************************
//
// DllMain
//
// Description: Entry point for DLL.  Good place for initialization.
// Parameters: The standard DllMain() parameters
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (
	HINSTANCE hInstance,
	ULONG ulReason ,
	LPVOID pvReserved
)
{
	g_hInst = hInstance;
	BOOL status = TRUE ;

    if ( DLL_PROCESS_ATTACH == ulReason )
	{
		// Initialize the critical section to access the static initializer objects
		InitializeCriticalSection(&g_StaticsCreationDeletion);

		// Initialize the static Initializer objects. These are destroyed in DllCanUnloadNow
		CDSClassProviderClassFactory :: s_pDSClassProviderInitializer = NULL;
		CDSClassProviderClassFactory ::s_pLDAPClassProviderInitializer = NULL;
		CDSInstanceProviderClassFactory :: s_pDSInstanceProviderInitializer = NULL;
		DisableThreadLibraryCalls(g_hInst);			// 158024 

        g_pLogObject = ProvDebugLog::GetProvDebugLog(LOG_DSPROV);
		status = TRUE ;
    }
    else if ( DLL_PROCESS_DETACH == ulReason )
	{
		DeleteCriticalSection(&g_StaticsCreationDeletion);
		status = TRUE ;
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		status = TRUE ;
    }

    return status ;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Description: Called by COM when some client wants a a class factory.
//
//	Parameters: Ths standard DllGetClassObject() parameters
//
//	Return Value: S_OK only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (
	REFCLSID rclsid ,
	REFIID riid,
	void **ppv
)
{
	HRESULT status = S_OK ;

	try
	{
		if ( rclsid == CLSID_DSProvider )
		{
			CDSClassProviderClassFactory *lpunk = NULL;
			lpunk = new CDSClassProviderClassFactory ;

			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		else if ( rclsid == CLSID_DSClassAssocProvider )
		{
			CDSClassAssociationsProviderClassFactory *lpunk = new CDSClassAssociationsProviderClassFactory ;
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		else if ( rclsid == CLSID_DSInstanceProvider )
		{
			CDSInstanceProviderClassFactory *lpunk = new CDSInstanceProviderClassFactory ;
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		else
		{
			status = CLASS_E_CLASSNOTAVAILABLE ;
		}
	}
	catch(Heap_Exception e_HE)
	{
		status = E_OUTOFMEMORY ;
	}

	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Description: Called periodically by COM in order to determine if the
// DLL can be unloaded.
//
// Return Value: S_OK if there are no objects in use and the class factory
// isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	HRESULT hResult = S_FALSE;

	EnterCriticalSection(&g_StaticsCreationDeletion);
	try
	{

		if(g_lServerLocks == 0 && g_lComponents == 0)
		{
			// Delete the Initializer objects
			if ( g_pLogObject )
			{
				g_pLogObject->WriteW(L"DllCanUnloadNow called\r\n");
			}

			if ( CDSClassProviderClassFactory::s_pDSClassProviderInitializer )
			{
				delete CDSClassProviderClassFactory::s_pDSClassProviderInitializer;
				CDSClassProviderClassFactory::s_pDSClassProviderInitializer = NULL;
			}

			if ( CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer )
			{
				delete CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer;
				CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer = NULL;
			}

			if ( CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer )
			{
				delete CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer;
				CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer = NULL;
			}

			hResult = S_OK;
		}


	}
	catch ( ... )
	{
	}
	LeaveCriticalSection(&g_StaticsCreationDeletion);
	return hResult;
}

/***************************************************************************
 *
 * SetKeyAndValue
 *
 * Description: Helper function for DllRegisterServer that creates
 * a key, sets a value, and closes that key. If pszSubkey is NULL, then
 * the value is created for the pszKey key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR to the name of a subkey
 *  pszValueName    LPTSTR to the value name to use
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCTSTR pszKey, LPCTSTR pszSubkey, LPCTSTR pszValueName, LPCTSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

	// If a sub key is mentioned, use it.
    if (NULL != pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue,
			(_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 *
 * DeleteKey
 *
 * Description: Helper function for DllUnRegisterServer that deletes the subkey
 * of a key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL DeleteKey(LPCTSTR pszKey, LPCTSTR pszSubkey)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteKey(hKey, pszSubkey))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}


////////////////////////////////////////////////////////////////////
// Strings used during self registration
////////////////////////////////////////////////////////////////////
LPCTSTR INPROC32_STR			= __TEXT("InprocServer32");
LPCTSTR INPROC_STR				= __TEXT("InprocServer");
LPCTSTR THREADING_MODEL_STR		= __TEXT("ThreadingModel");
LPCTSTR APARTMENT_STR			= __TEXT("Both");

LPCTSTR CLSID_STR				= __TEXT("SOFTWARE\\CLASSES\\CLSID\\");

// DS Class Provider
LPCTSTR DSPROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Class Provider for WBEM");

// DS Class Associations provider
LPCTSTR DS_ASSOC_PROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Class Associations Provider for WBEM");

// DS Instance provider
LPCTSTR DS_INSTANCE_PROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Instance Provider for WBEM");

STDAPI DllRegisterServer()
{
	TCHAR szModule[512];
	GetModuleFileName(g_hInst, szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szDSProviderClassID[128];
	TCHAR szDSProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSProvider, szDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSProviderClassID[128];
	if(StringFromGUID2(CLSID_DSProvider, wszDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSProviderClassID, -1, szDSProviderClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSProviderCLSIDClassID, szDSProviderClassID);

	//
	// Create entries under CLSID for DS Class Provider
	//
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, NULL, NULL, DSPROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;


	TCHAR szDSClassAssocProviderClassID[128];
	TCHAR szDSClassAssocProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSClassAssocProvider, szDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSClassAssocProviderClassID[128];
	if(StringFromGUID2(CLSID_DSClassAssocProvider, wszDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSClassAssocProviderClassID, -1, szDSClassAssocProviderClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSClassAssocProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSClassAssocProviderCLSIDClassID, szDSClassAssocProviderClassID);

	//
	// Create entries under CLSID for DS Class Associations Provider
	//
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, NULL, NULL, DS_ASSOC_PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;




	TCHAR szDSInstanceProviderClassID[128];
	TCHAR szDSInstanceProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSInstanceProvider, szDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSInstanceProviderClassID[128];
	if(StringFromGUID2(CLSID_DSInstanceProvider, wszDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSInstanceProviderClassID, -1, szDSInstanceProviderClassID, 128, NULL, NULL);

#endif


	_tcscpy(szDSInstanceProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSInstanceProviderCLSIDClassID, szDSInstanceProviderClassID);

	//
	// Create entries under CLSID for DS Instance Provider
	//
	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, NULL, NULL, DS_INSTANCE_PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;

	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;



	return S_OK;
}


STDAPI DllUnregisterServer(void)
{
	TCHAR szModule[512];
	GetModuleFileName(g_hInst,szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szDSProviderClassID[128];
	TCHAR szDSProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSProvider, szDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSProviderClassID[128];
	if(StringFromGUID2(CLSID_DSProvider, wszDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSProviderClassID, -1, szDSProviderClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSProviderCLSIDClassID, szDSProviderClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSProviderCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSProviderClassID))
		return SELFREG_E_CLASS;

	TCHAR szDSClassAssocProviderClassID[128];
	TCHAR szDSClassAssocProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSClassAssocProvider, szDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSClassAssocProviderClassID[128];
	if(StringFromGUID2(CLSID_DSClassAssocProvider, wszDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSClassAssocProviderClassID, -1, szDSClassAssocProviderClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSClassAssocProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSClassAssocProviderCLSIDClassID, szDSClassAssocProviderClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSClassAssocProviderCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSClassAssocProviderClassID))
		return SELFREG_E_CLASS;

	TCHAR szDSInstanceProviderClassID[128];
	TCHAR szDSInstanceProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSInstanceProvider, szDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSInstanceProviderClassID[128];
	if(StringFromGUID2(CLSID_DSInstanceProvider, wszDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSInstanceProviderClassID, -1, szDSInstanceProviderClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSInstanceProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSInstanceProviderCLSIDClassID, szDSInstanceProviderClassID);

	//
	// Delete the keys in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSInstanceProviderCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSInstanceProviderClassID))
		return SELFREG_E_CLASS;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#include <tchar.h>
#include <stdio.h>

#include <assert.h>
#include <objbase.h>
#include <olectl.h>
#include <comdef.h>


/* WBEM includes */
#include <wbemcli.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <sqllex.h>
#include <sql_1.h>
#include <cominit.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include <provexpt.h>
#include <provlog.h>
#include "maindll.h"
#include "attributes.h"
#include "clsname.h"
#include "refcount.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "adsiinst.h"
#include "tree.h"
#include "ldapcach.h"
#include "ldaphelp.h"
#include "wbemhelp.h"
#include "wbemcach.h"
#include "classpro.h"
#include "ldapprov.h"
#include "clsproi.h"
#include "ldapproi.h"
#include "classfac.h"
#include "instprov.h"
#include "instproi.h"
#include "instfac.h"
#include "assocprov.h"
#include <wbemtime.h>
#include "queryconv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\queryconv.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef QUERY_H
#define QUERY_H


struct StackElement
{
	int m_iOperator;
	int m_iNumOperandsLeft;
};

class Stack
{
	StackElement m_stack[100];
	int m_iTop;
	static int s_iMax;

	public:
		Stack()
		{
			m_iTop = 0;
		}

		BOOLEAN Push(int iOperator, int iNumOperandsLeft)
		{
			if(m_iTop == s_iMax)
				return FALSE;
			m_stack[m_iTop].m_iOperator = iOperator;
			m_stack[m_iTop].m_iNumOperandsLeft = iNumOperandsLeft;
			m_iTop ++;
			return TRUE;
		}

		BOOLEAN Pop(int *piOperator, int *piNumOperandsLeft)
		{
			if(m_iTop == 0)
				return FALSE;
			m_iTop --;
			*piOperator = 	m_stack[m_iTop].m_iOperator;
			*piNumOperandsLeft = m_stack[m_iTop].m_iNumOperandsLeft;
			return TRUE;
		}

};

class QueryConvertor
{
private:
	static const WCHAR wchAND;
	static const WCHAR wchOR;
	static const WCHAR wchNOT;
	static const WCHAR wchEQUAL;
	static const WCHAR wchSTAR;
	static const WCHAR wchLEFT_BRACKET;
	static const WCHAR wchRIGHT_BRACKET;
	static LPCWSTR pszGE;
	static LPCWSTR pszLE;

	// Special characters excluding ( and ) and *
	static const WCHAR wchBACK_SLASH;

	static BOOLEAN TranslateExpression(LPWSTR pszLDAPQuery, int *piOutputIndex, 
											int iOperator, LPCWSTR pszPropertyName, VARIANT *pValue, int nLength);
	static BOOLEAN TranslateValueToLDAP(LPWSTR pszLDAPQuery, int *piOutputIndex, VARIANT *pValue);

	static LPWSTR EscapeStringValue(LPCWSTR pszValue);

public:
	// This assumes that enough memory has been allocated to the resulting query
	static BOOLEAN ConvertQueryToLDAP(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery, int nLength);


};	

#endif /* QUERY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\refcount.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:refcount.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the imlementation for a basic reference counted object
//
//***************************************************************************

#include "precomp.h"

CRefCountedObject::CRefCountedObject() :
	m_dwRefCount ( 1 ),
	m_lpszName ( NULL ),
	m_CreationTime ( 0 ),
	m_LastAccessTime ( 0 )
{
	// Initialize the critical section 
	InitializeCriticalSection(&m_ReferenceCountSection);

	FILETIME fileTime;
	GetSystemTimeAsFileTime(&fileTime);
	LARGE_INTEGER creationTime;
	memcpy((LPVOID)&creationTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);
	m_CreationTime = creationTime.QuadPart;
	m_LastAccessTime = creationTime.QuadPart;
}

CRefCountedObject::CRefCountedObject(LPCWSTR lpszName) :
	m_dwRefCount ( 1 ),
	m_lpszName ( NULL ),
	m_CreationTime ( 0 ),
	m_LastAccessTime ( 0 )
{
	// Initialize the critical section 
	InitializeCriticalSection(&m_ReferenceCountSection);

	if(lpszName)
	{
		try
		{
			m_lpszName = new WCHAR[wcslen(lpszName) + 1];
			wcscpy(m_lpszName, lpszName);
		}
		catch ( ... )
		{
			if ( m_lpszName )
			{
				delete [] m_lpszName;
				m_lpszName = NULL;
			}

			DeleteCriticalSection(&m_ReferenceCountSection);

			throw;
		}
	}

	FILETIME fileTime;
	GetSystemTimeAsFileTime(&fileTime);
	LARGE_INTEGER creationTime;
	memcpy((LPVOID)&creationTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);
	m_CreationTime = creationTime.QuadPart;
}

CRefCountedObject::~CRefCountedObject()
{
	if (m_lpszName)
	{
		delete[] m_lpszName;
	}

	// Destroy the critical section
	DeleteCriticalSection(&m_ReferenceCountSection);
}


void CRefCountedObject::AddRef()
{
	EnterCriticalSection(&m_ReferenceCountSection);
	m_dwRefCount ++;
	LeaveCriticalSection(&m_ReferenceCountSection);
}

void CRefCountedObject::Release()
{
	EnterCriticalSection(&m_ReferenceCountSection);
	DWORD dwCount = --m_dwRefCount;
	LeaveCriticalSection(&m_ReferenceCountSection);

	if( dwCount == 0)
		delete this;
}

LPCWSTR CRefCountedObject::GetName()
{
	return m_lpszName;
}

void CRefCountedObject::SetName(LPCWSTR lpszName)
{
	if (m_lpszName)
	{
		delete[] m_lpszName;
		m_lpszName=NULL;
	}

	if(lpszName)
	{
		m_lpszName = new WCHAR[wcslen(lpszName) + 1];
		wcscpy(m_lpszName, lpszName);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\queryconv.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"


const WCHAR QueryConvertor::wchAND		= L'&';
const WCHAR QueryConvertor::wchOR			= L'|';
const WCHAR QueryConvertor::wchNOT		= L'!';
const WCHAR QueryConvertor::wchSTAR		= L'*';
const WCHAR QueryConvertor::wchEQUAL		= L'=';
const WCHAR QueryConvertor::wchLEFT_BRACKET	= L'(';
const WCHAR QueryConvertor::wchRIGHT_BRACKET	= L')';
const WCHAR QueryConvertor::wchBACK_SLASH		= L'\\';
LPCWSTR QueryConvertor::pszGE	= L">=";
LPCWSTR QueryConvertor::pszLE	= L"<=";

int Stack::s_iMax = 100;

// This assumes that enough memory has been allocated to the resulting query
BOOLEAN QueryConvertor::ConvertQueryToLDAP(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery, int nLength)
{
	Stack t_stack;

	int iCurrentOperator = 0, idwNumOperandsLeft = 0;
	int iOutputIndex = 0;

	if(pExp->nNumTokens == 0)
		return TRUE;

	int iCurrentToken = pExp->nNumTokens -1;

	SQL_LEVEL_1_TOKEN *pNextToken = pExp->pArrayOfTokens + iCurrentToken;

	BOOLEAN retVal = FALSE, done = FALSE;

	// Write a '(' at the head of the LDAP Query
	pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;

	while (!done && iCurrentToken >= 0)
	{
		switch(pNextToken->nTokenType)
		{
			case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
			{
				// Try to tranlsate expression to LDAP
				if(TranslateExpression(pszLDAPQuery, &iOutputIndex, pNextToken->nOperator, pNextToken->pPropertyName, &pNextToken->vConstValue, nLength))
				{
					// If we've finished all the operands for the current operator, get the next one
					idwNumOperandsLeft --;
					while(idwNumOperandsLeft == 0)
					{
						pszLDAPQuery[iOutputIndex ++] = wchRIGHT_BRACKET;
						if(!t_stack.Pop(&iCurrentOperator, &idwNumOperandsLeft))
							done = TRUE;
						idwNumOperandsLeft --;
					}
					iCurrentToken --;
				}
				else
					done = TRUE;
				pNextToken --;
				break;
			}

			case SQL_LEVEL_1_TOKEN::TOKEN_AND:
			{
				if(iCurrentOperator)
				{
					if(!t_stack.Push(iCurrentOperator, idwNumOperandsLeft))
						done = TRUE;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_AND;
					idwNumOperandsLeft = 2;
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchAND;
				}
				else
				{
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchAND;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_AND;
					idwNumOperandsLeft = 2;
				}
				iCurrentToken --;
				pNextToken --;

				break;
			}

			case SQL_LEVEL_1_TOKEN::TOKEN_OR:
			{
				if(iCurrentOperator)
				{
					if(!t_stack.Push(iCurrentOperator, idwNumOperandsLeft))
						done = TRUE;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_OR;
					idwNumOperandsLeft = 2;
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchOR;
				}
				else
				{
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchOR;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_OR;
					idwNumOperandsLeft = 2;
				}
				iCurrentToken --;
				pNextToken --;
				break;
			}

			case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
			{
				if(iCurrentOperator)
				{
					if(!t_stack.Push(iCurrentOperator, idwNumOperandsLeft))
						done = TRUE;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
					idwNumOperandsLeft = 1;
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchNOT;
				}
				else
				{
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchNOT;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
					idwNumOperandsLeft = 1;
				}
				iCurrentToken --;
				pNextToken --;
				break;
			}

			default:
				done = TRUE;
				break;
		}

	}

	// Check if we used up all the tokens
	if(iCurrentToken == -1)
		retVal = TRUE;

	// Write a ')' at the end of the LDAP Query
	pszLDAPQuery[iOutputIndex ++] = wchRIGHT_BRACKET;
	pszLDAPQuery[iOutputIndex ++] = NULL;
	return retVal;
}



BOOLEAN QueryConvertor::TranslateExpression(LPWSTR pszLDAPQuery, int *piOutputIndex, 
											int iOperator, LPCWSTR pszPropertyName, VARIANT *pValue, int nLength)
{
	// If it is a CIMOM System property, then dont attempt to map it to LDAP
	if(pszPropertyName[0] == L'_' &&
		pszPropertyName[1] == L'_' )
		return TRUE;

	// If it is ADSIPath, convert it to distinguishedName attribute
	if(_wcsicmp(pszPropertyName, ADSI_PATH_ATTR) == 0 )
	{
		if(pValue== NULL || pValue->vt == VT_NULL)
		{
			if(iOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
			{
				// Put the property name as DistiguishedName

                if((*piOutputIndex) + (int)wcslen(DISTINGUISHED_NAME_ATTR) < nLength ) {
				    wcscpy(pszLDAPQuery + *piOutputIndex, DISTINGUISHED_NAME_ATTR);
				    *piOutputIndex += wcslen(DISTINGUISHED_NAME_ATTR);
                }else return FALSE;


                if(*piOutputIndex + 2 < nLength){
				    *(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
				    (*piOutputIndex) ++;
				    *(pszLDAPQuery + *piOutputIndex) = wchSTAR;
				    (*piOutputIndex) ++;
                }else return FALSE;
				return TRUE;
			}
			else
			{
				// The '!'
                if(*piOutputIndex + 1 < nLength){
				    *(pszLDAPQuery + *piOutputIndex) = wchNOT;
				    (*piOutputIndex) ++;
                }else return FALSE;

				// The '('
                if(*piOutputIndex + 1 < nLength){
				    *(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
				    (*piOutputIndex) ++;
                }else return FALSE;
				if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL, pszPropertyName, NULL, nLength))
				{
					// The ')'
                    if(*piOutputIndex + 1 < nLength){
					    *(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
					    (*piOutputIndex) ++;
                    }else return FALSE;
					return TRUE;
				}
				else 
					return FALSE;
			}
		}

		// TODO - WinMgmt should not allow this. It should check that the property type matches the property value
		// As soon as Winmgmt has fixed this bug, the next 2 lines may be deleted
		if(pValue->vt != VT_BSTR)
			return FALSE;

		// Get the parentADSI path and RDN from the ADSI Path
		IADsPathname *pADsPathName = NULL;
		BSTR strADSIPath = SysAllocString(pValue->bstrVal);
		BSTR strDN = NULL;
		BOOLEAN bRetVal = FALSE;
		HRESULT result = E_FAIL;
		if(SUCCEEDED(result = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_ALL, IID_IADsPathname, (LPVOID *)&pADsPathName)))
		{
			if(SUCCEEDED(result = pADsPathName->Set(strADSIPath, ADS_SETTYPE_FULL)))
			{
				// This gives the DN
				if(SUCCEEDED(result = pADsPathName->Retrieve(ADS_FORMAT_X500_DN, &strDN)))
				{
					// Put the property name as DistiguishedName

                    if(*piOutputIndex + (int)wcslen(DISTINGUISHED_NAME_ATTR) < nLength){
					    wcscpy(pszLDAPQuery + *piOutputIndex, DISTINGUISHED_NAME_ATTR);
					    *piOutputIndex += wcslen(DISTINGUISHED_NAME_ATTR);
                    }else return FALSE;

					// Put the LDAP Operator
					if(iOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
					{
                        if(*piOutputIndex + 1 < nLength){
						    *(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
						    (*piOutputIndex) ++;
                        }else return FALSE;
					}
					else
					{
						// The '!'
                        if(*piOutputIndex + 2 < nLength){
						    *(pszLDAPQuery + *piOutputIndex) = wchNOT;
						    (*piOutputIndex) ++;
						    *(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
						    (*piOutputIndex) ++;
                        }else return FALSE;
					}

					// Look for the special characters ( ) * and \ and escape them with a \ 
					LPWSTR pszEscapedValue = EscapeStringValue(strDN);

                    if(*piOutputIndex + (int)wcslen(pszEscapedValue) < nLength){
					    wcscpy(pszLDAPQuery + *piOutputIndex, pszEscapedValue);
					    (*piOutputIndex) += wcslen(pszEscapedValue);
                    }else return FALSE;
					delete [] pszEscapedValue;

					SysFreeString(strDN);
					bRetVal = TRUE;
				}
			}
			pADsPathName->Release();
		}
		SysFreeString(strADSIPath);

		return bRetVal;
	}

	// Write a '('
    if(*piOutputIndex + 1 < nLength){
	    pszLDAPQuery[(*piOutputIndex) ++] = wchLEFT_BRACKET;
    }

	switch(iOperator)
	{
		case SQL_LEVEL_1_TOKEN::OP_EQUAL:
		{
			// Special case where we use '*' LDAP operator
			// is NULL translates to !( x=*)
			if(pValue->vt == VT_NULL)
			{
                if(*piOutputIndex + 2 < nLength){
				    // The '!'
				    *(pszLDAPQuery + *piOutputIndex) = wchNOT;
				    (*piOutputIndex) ++;

				    // The '('
				    *(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
				    (*piOutputIndex) ++;
                }else return FALSE;

				if(!TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL, pszPropertyName, NULL, nLength))
					return FALSE;

                if(*piOutputIndex + 1 < nLength){
				    // The ')'
				    *(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
				    (*piOutputIndex) ++;
                }else return FALSE;

				break;
			}
			else
			{
				// Followthru
			}
		}
		case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
		case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
		{
			// Get the LDAP name of the property
			LPWSTR pszLDAPName = CLDAPHelper::UnmangleWBEMNameToLDAP(pszPropertyName);
            if(*piOutputIndex + (int)wcslen(pszLDAPName) < nLength){
			    wcscpy(pszLDAPQuery + *piOutputIndex, pszLDAPName);
			    *piOutputIndex += wcslen(pszLDAPName);
            }else return FALSE;
			delete [] pszLDAPName;

			// Put the LDAP Operator
			if(iOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
			{
                if(*piOutputIndex + 1 < nLength){
				    *(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
				    (*piOutputIndex) ++;
                }else return FALSE;
			}
			else if(iOperator == SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN)
			{
                if(*piOutputIndex + 2 < nLength){
				    wcscpy(pszLDAPQuery + *piOutputIndex, pszGE);
				    *piOutputIndex += 2;
                }else return FALSE;
			}
			else
			{
                if(*piOutputIndex + 2 < nLength){
				    wcscpy(pszLDAPQuery + *piOutputIndex, pszLE);
				    *piOutputIndex += 2;
                }else return FALSE;
			}

			// Put the value of the property
			if(!TranslateValueToLDAP(pszLDAPQuery, piOutputIndex, pValue))
				return FALSE;

		}
		break;

		case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
		{
			// Special case for use of '*'
			if(pValue == NULL || pValue->vt == VT_NULL)
			{

				// Get the LDAP name of the property
				LPWSTR pszLDAPName = CLDAPHelper::UnmangleWBEMNameToLDAP(pszPropertyName);
                if(*piOutputIndex + (int)wcslen(pszLDAPName) < nLength){
				    wcscpy(pszLDAPQuery + *piOutputIndex, pszLDAPName);
				    *piOutputIndex += wcslen(pszLDAPName);
                }else return FALSE;
				delete [] pszLDAPName;

                if(*piOutputIndex + 2 < nLength){
				    *(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
				    (*piOutputIndex) ++;
                

				    *(pszLDAPQuery + *piOutputIndex) = wchSTAR;
				    (*piOutputIndex) ++;
                }else return FALSE;

			}
			else 			
			{
                if(*piOutputIndex + 2 < nLength){
				    // The '!'
				    *(pszLDAPQuery + *piOutputIndex) = wchNOT;
				    (*piOutputIndex) ++;

				    // The '('
				    *(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
				    (*piOutputIndex) ++;
                }else return FALSE;

				if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_EQUAL, pszPropertyName, pValue, nLength))
				{
                    if(*piOutputIndex + 1 < nLength){
					    // The ')'
					    *(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
					    (*piOutputIndex) ++;
                    }else return FALSE;
				}
				else
					return FALSE;
			}
		}
		break;

		case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
		{
            if(*piOutputIndex + 2 < nLength){
			    // The '!'
			    *(pszLDAPQuery + *piOutputIndex) = wchNOT;
			    (*piOutputIndex) ++;

			    // The '('
			    *(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
			    (*piOutputIndex) ++;
            }else return FALSE;

			if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN, pszPropertyName, pValue,nLength))
			{
                if(*piOutputIndex + 1 < nLength){
				    // The ')'
				    *(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
				    (*piOutputIndex) ++;
                }else return FALSE;
			}
			else
				return FALSE;
		}
		break;

		case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
		{
            if(*piOutputIndex + 2 < nLength){
			    // The '!'
			    *(pszLDAPQuery + *piOutputIndex) = wchNOT;
			    (*piOutputIndex) ++;

			    // The '('
			    *(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
			    (*piOutputIndex) ++;
            }else return FALSE;

			if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN, pszPropertyName, pValue, nLength))
			{
                if(*piOutputIndex + 1 < nLength){
				    // The ')'
				    *(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
				    (*piOutputIndex) ++;
                }else return FALSE;
			}
			else
				return FALSE;
		}
		break;
		default:
			return FALSE;
	}

    if(*piOutputIndex + 1 < nLength){
	    // Write a ')'
	    pszLDAPQuery[(*piOutputIndex) ++] = wchRIGHT_BRACKET;
    } else return FALSE;
	return TRUE;
}

BOOLEAN QueryConvertor::TranslateValueToLDAP(LPWSTR pszLDAPQuery, int *piOutputIndex, VARIANT *pValue)
{
	switch(pValue->vt)
	{
		case VT_BSTR:
			{ 
				// Look for the special characters ( ) * and \ and escape them with a \ 
				LPWSTR pszEscapedValue = EscapeStringValue(pValue->bstrVal);
				wcscpy(pszLDAPQuery + *piOutputIndex, pszEscapedValue);
				(*piOutputIndex) += wcslen(pszEscapedValue);
				delete [] pszEscapedValue;
		}
		break;
			
		case VT_I4:
		{
			WCHAR temp[18];
			swprintf(temp, L"%d", pValue->lVal);
			wcscpy(pszLDAPQuery + *piOutputIndex, temp);
			(*piOutputIndex) += wcslen(temp);
		}
		break;

		case VT_BOOL:
		{
			if(pValue->boolVal == VARIANT_TRUE)
			{
				wcscpy(pszLDAPQuery + *piOutputIndex, L"TRUE");
				(*piOutputIndex) += wcslen(L"TRUE");
			}
			else
			{
				wcscpy(pszLDAPQuery + *piOutputIndex, L"FALSE");
				(*piOutputIndex) += wcslen(L"FALSE");
			}
		}
		break;
		default:
			return FALSE;
	}
	return TRUE;
}

LPWSTR QueryConvertor::EscapeStringValue(LPCWSTR pszValue)
{
	// Escape the special characters in a string value in a query
	LPWSTR pszRetValue = new WCHAR [wcslen(pszValue)*2 + 1];
	DWORD j=0;
	for(DWORD i=0; i<wcslen(pszValue); i++)
	{
		switch(pszValue[i])
		{
			case wchLEFT_BRACKET:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '2';
				pszRetValue[j++] = '8';
				break;
			case wchRIGHT_BRACKET:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '2';
				pszRetValue[j++] = '9';
				break;
			case wchSTAR:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '2';
				pszRetValue[j++] = 'a';
				break;
			case wchBACK_SLASH:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '5';
				pszRetValue[j++] = 'c';
				break;

			default:
				pszRetValue[j++] = pszValue[i];
				break;
		}
	}
	pszRetValue[j] = NULL;
	return 	pszRetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\refcount.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:refcount.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for a basic reference counted object, that
//	also stores a timestamp (in 100-nanosecond intervals since January 1, 1601. This
//	is copatible with the definition of the Win32 FILETIME struture)
//
//***************************************************************************

#ifndef REFCOUNTED_OBJECT_H
#define REFCOUNTED_OBJECT_H


class CRefCountedObject
{

public:

	CRefCountedObject();
	CRefCountedObject(LPCWSTR lpszName);
	virtual ~CRefCountedObject();

	LPCWSTR GetName();
	void SetName(LPCWSTR lpszName);
	void AddRef();
	void Release();
	// Returns the time of creation 
	__int64 GetCreationTime()
	{
		return m_CreationTime;
	}

	// Returns the last time of access 
	__int64 GetLastAccessTime()
	{
		return m_LastAccessTime;
	}
	// Sets the last time of access 
	void SetLastAccessTime(__int64 lastAccessTime)
	{
		m_LastAccessTime = lastAccessTime;
	}


private:
	// A critical section object for synchronizing modifications to refcount
	CRITICAL_SECTION m_ReferenceCountSection;

	unsigned m_dwRefCount;
	LPWSTR m_lpszName;
	__int64 m_CreationTime; 
	__int64 m_LastAccessTime; 

	
};

#endif /* REFCOUNTED_OBJECT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################


WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=dsprov

TARGETPATH=obj
TARGETTYPE=DYNLINK

# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
TARGETLIBS= \
    $(FRAMEWORK_EXPT_LIB) \
	$(FRAMEWORK_THRD_LIB) \
	$(UTILLIB_LIB) \
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\activeds.lib \
	$(SDK_LIB_PATH)\adsiid.lib   \
    $(SDK_LIB_PATH)\vccomsup.lib \
	$(SDK_LIB_PATH)\advapi32.lib

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(WMIIDL_INC); \
	$(STDLIBRARY_INC); \
	$(UTILLIB_INC); \
	$(FRAMEWORK_THRD_INC); \
	$(FRAMEWORK_EXPT_INC); \
	$(WBEMCOMN_INC);

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.
SOURCES=\
	..\maindll.cpp	\
	..\adsiclas.cpp	\
	..\adsiprop.cpp	\
	..\adsiinst.cpp	\
	..\wbemhelp.cpp	\
	..\ldaphelp.cpp	\
	..\refcount.cpp	\
	..\queryconv.cpp	\
	..\tree.cpp		\
	..\clsname.cpp	\
	..\classfac.cpp	\
	..\assocprov.cpp	\
	..\classpro.cpp	\
	..\clsproi.cpp	\
	..\ldapprov.cpp	\
	..\ldapproi.cpp	\
	..\wbemcach.cpp	\
	..\ldapcach.cpp	\
	..\instfac.cpp	\
	..\instprov.cpp	\
	..\instproi.cpp	\
	..\dsprov.rc	


# Next, specify options for the compiler using C_DEFINES. 
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
USE_STL=1

DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\dsprov.def
#NO_RTTI=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\tree.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef OBJECT_TREE_H
#define OBJECT_TREE_H


class CTreeElement
{
public:
	CTreeElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject);
	~CTreeElement();

	LPCWSTR GetHashedName() const;
	CRefCountedObject *GetObject() const;
	CTreeElement *GetLeft() const;
	CTreeElement *GetRight() const;

	void SetLeft(CTreeElement *pNext);
	void SetRight(CTreeElement *pNext);
private:
	LPWSTR m_lpszHashedName;
	CRefCountedObject *m_pObject;
	CTreeElement *m_pLeft;
	CTreeElement *m_pRight;
};

class CObjectTree
{

public:
	CObjectTree();
	~CObjectTree();

	BOOLEAN AddElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject);
	BOOLEAN DeleteElement(LPCWSTR lpszHashedName);
	BOOLEAN DeleteLeastRecentlyAccessedElement();
	CRefCountedObject *GetElement(LPCWSTR lpszHashedName);
	void DeleteTree();
	DWORD GetNumberOfElements() const
	{
		return m_dwNumElements;
	}

private:

	CTreeElement *m_pHead;

	// The number of elements in the tree currently
	DWORD m_dwNumElements;

	// A critical section object for synchronizing modifications
	CRITICAL_SECTION m_ModificationSection;

	// Private fucntions for recursive calls
	void DeleteSubTree(CTreeElement *pRoot);
	
	CRefCountedObject * GetLeastRecentlyAccessedElementRecursive(CTreeElement *pElement);

};	

#endif /* OBJECT_TREE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\tree.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <precomp.h>


CTreeElement :: CTreeElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject)
{
	m_lpszHashedName = new WCHAR[wcslen(lpszHashedName) + 1];
	wcscpy(m_lpszHashedName, lpszHashedName);

	m_pObject = pObject;
	m_pObject->AddRef();
	m_pLeft = NULL;
	m_pRight = NULL;
}

CTreeElement :: ~CTreeElement()
{
	if (m_lpszHashedName)
	{
		delete [] m_lpszHashedName;
	}
	m_pObject->Release();
}

LPCWSTR CTreeElement :: GetHashedName() const
{
	return m_lpszHashedName;
}

CRefCountedObject *CTreeElement :: GetObject() const
{
	m_pObject->AddRef();
	return m_pObject;
}

CTreeElement *CTreeElement :: GetRight() const
{
	return m_pRight;
}

CTreeElement *CTreeElement :: GetLeft() const
{
	return m_pLeft;
}

void CTreeElement :: SetRight(CTreeElement *pNext)
{
	m_pRight = pNext;
}

void CTreeElement :: SetLeft(CTreeElement *pNext)
{
	m_pLeft = pNext;
}

CObjectTree :: CObjectTree()
{
	// Initialize the critical section 
	InitializeCriticalSection(&m_ModificationSection);

	m_dwNumElements = 0;
	m_pHead = NULL;

}

CObjectTree :: ~CObjectTree()
{
	// Destroy the data
	DeleteTree();

	// Destroy the critical section
	DeleteCriticalSection(&m_ModificationSection);

}

void CObjectTree :: DeleteTree()
{
	EnterCriticalSection(&m_ModificationSection);
	if(m_pHead)
		DeleteSubTree(m_pHead);
	m_dwNumElements = 0;
	LeaveCriticalSection(&m_ModificationSection);
}


void CObjectTree :: DeleteSubTree(CTreeElement *pRoot)
{
	if(pRoot->GetLeft())
		DeleteSubTree(pRoot->GetLeft());
	if(pRoot->GetRight())
		DeleteSubTree(pRoot->GetRight());
	delete pRoot;
}

BOOLEAN CObjectTree :: AddElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject)
{
	BOOLEAN retVal = TRUE;

	EnterCriticalSection(&m_ModificationSection);
	CTreeElement *pCurrent = m_pHead;
	CTreeElement *pParent = NULL;
	int iCompare;
	// Locate the position where the new element is to be inserted
	while(pCurrent)
	{
		iCompare = _wcsicmp(lpszHashedName, pCurrent->GetHashedName());
		if(iCompare == 0)
		{
			retVal = FALSE; // The element already exists
			break;
		}
		else if(iCompare > 0)
		{
			pParent = pCurrent;
			pCurrent = pCurrent->GetRight();
		}
		else
		{
			pParent = pCurrent;
			pCurrent = pCurrent->GetLeft();
		}
	}

	// Create the new element at the appropriate position
	if(retVal == TRUE && pParent)
	{
		iCompare = _wcsicmp(lpszHashedName, pParent->GetHashedName());
		if(iCompare == 0)
			retVal = FALSE;
		else if(iCompare > 0)
		{
			retVal = TRUE;
			pParent->SetRight(new CTreeElement(lpszHashedName, pObject));
		}
		else
		{
			retVal = TRUE;
			pParent->SetLeft(new CTreeElement(lpszHashedName, pObject));
		}
	}
	else if (retVal == TRUE)
	{
		m_pHead = new CTreeElement(lpszHashedName, pObject);
		retVal =  TRUE;
	}
	// Increment the object count if the insertion was successful
	if(retVal)
		m_dwNumElements ++;

	LeaveCriticalSection(&m_ModificationSection);
	return retVal;
}

BOOLEAN CObjectTree :: DeleteElement(LPCWSTR lpszHashedName)
{
	BOOLEAN retVal = FALSE;
	int iDirection = 0; // 0 indicates Unknown, 1 indicates LEFT and 2 indicates RIGHT
	EnterCriticalSection(&m_ModificationSection);
	if(m_pHead == NULL)
		retVal = FALSE;
	else
	{
		// Find the node to be deleted and its parent
		CTreeElement *pParent = NULL;
		CTreeElement *pCurrent = m_pHead;
		int iCompare;
		while(pCurrent)
		{
			iCompare = _wcsicmp(lpszHashedName, pCurrent->GetHashedName());
			if(iCompare == 0)
				break;
			else if(iCompare < 0)
			{
				iDirection = 1;
				pParent = pCurrent;
				pCurrent = pCurrent->GetLeft();
			}
			else
			{
				iDirection = 2;
				pParent = pCurrent;
				pCurrent = pCurrent->GetRight();
			}
		}

		if(!pCurrent) 
			// The element was not found
			retVal = FALSE;
		else
		{
			CTreeElement *pCutPart = NULL;

			// If its left child is null, attach the right subtree to parent
			if(pCurrent->GetLeft() == NULL)
				pCutPart = pCurrent->GetRight();
			// If its right child is null, attach the left subtree to parent
			else if(pCurrent->GetRight() == NULL)
				pCutPart = pCurrent->GetLeft();
			else // We need to find the inorder successor
			{
				CTreeElement *pInorderSuccessor = pCurrent->GetRight();
				if(pInorderSuccessor->GetLeft() == NULL)
				{
					pInorderSuccessor->SetLeft(pCurrent->GetLeft());
					pCutPart = pInorderSuccessor;
				}
				else
				{
					CTreeElement *pPredecessor = pCurrent->GetRight();
					pInorderSuccessor = pPredecessor->GetLeft();
					while(pInorderSuccessor->GetLeft())
					{
						pPredecessor = pInorderSuccessor;
						pInorderSuccessor = pPredecessor->GetLeft();
					}
					pPredecessor->SetLeft(pInorderSuccessor->GetRight());
					pInorderSuccessor->SetLeft(pCurrent->GetLeft());
					pInorderSuccessor->SetRight(pCurrent->GetRight());
					pCutPart = pInorderSuccessor;
				}
			}

			if(iDirection == 0)
				m_pHead = pCutPart;
			else if (iDirection == 1)
				pParent->SetLeft(pCutPart);
			else
				pParent->SetRight(pCutPart);

			delete pCurrent;
			retVal = TRUE;

		}
	}
	// Decrement the count of items in the tree
	if(retVal)
		m_dwNumElements --;

	LeaveCriticalSection(&m_ModificationSection);

	return retVal;
}


CRefCountedObject * CObjectTree :: GetElement(LPCWSTR lpszHashedName)
{
	EnterCriticalSection(&m_ModificationSection);
	CTreeElement *pCurrent = m_pHead;
	CRefCountedObject *pRetVal = NULL;

	int iCompare;
	while(pCurrent)
	{
		iCompare = _wcsicmp(lpszHashedName, pCurrent->GetHashedName());
		if(iCompare == 0)
		{
			pRetVal = pCurrent->GetObject();
			break;
		}
		else if (iCompare > 0) 
			pCurrent = pCurrent->GetRight();
		else 
			pCurrent = pCurrent->GetLeft();
	}
	LeaveCriticalSection(&m_ModificationSection);
	return pRetVal;
}

BOOLEAN CObjectTree :: DeleteLeastRecentlyAccessedElement()
{
	BOOLEAN retVal = FALSE;
	EnterCriticalSection(&m_ModificationSection);
	if(m_pHead)
	{
		CRefCountedObject *pOldestElement = m_pHead->GetObject();
		CRefCountedObject *pLeftOldestElement = GetLeastRecentlyAccessedElementRecursive(m_pHead->GetLeft());
		CRefCountedObject *pRightOldestElement = GetLeastRecentlyAccessedElementRecursive(m_pHead->GetRight());

		if (pLeftOldestElement)
		{
			if(pLeftOldestElement->GetLastAccessTime() < pOldestElement->GetLastAccessTime())
			{
				pOldestElement->Release();
				pOldestElement = pLeftOldestElement;
			}
			else
				pLeftOldestElement->Release();
		}

		if (pRightOldestElement)
		{
			if(pRightOldestElement->GetLastAccessTime() < pOldestElement->GetLastAccessTime())
			{
				pOldestElement->Release();
				pOldestElement = pRightOldestElement;
			}
			else
				pRightOldestElement->Release();
		}

		retVal = DeleteElement(pOldestElement->GetName());
		pOldestElement->Release();
	}
	LeaveCriticalSection(&m_ModificationSection);
	return retVal;
}

CRefCountedObject * CObjectTree :: GetLeastRecentlyAccessedElementRecursive(CTreeElement *pElement)
{
	CRefCountedObject *pObject = NULL;
	if(pElement)
	{
		pObject = pElement->GetObject();
		CRefCountedObject *pLeftObject = GetLeastRecentlyAccessedElementRecursive(pElement->GetLeft());
		if(pLeftObject)
		{
			if(pLeftObject->GetCreationTime() < pObject->GetCreationTime())
			{
				pObject->Release();
				pObject = pLeftObject;
			}
			else
				pLeftObject->Release();
		}

		CRefCountedObject *pRightObject = GetLeastRecentlyAccessedElementRecursive(pElement->GetRight());
		if(pRightObject)
		{
			if (pRightObject->GetCreationTime() < pObject->GetCreationTime())
			{
				pObject->Release();
				pObject = pRightObject;
			}
			else
				pRightObject->Release();
		}

	}

	return pObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\wbemcach.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <precomp.h>


// Initialize the statics
const __int64 CWbemCache :: MAX_CACHE_AGE = 60*60*20; // In seconds, 4 Hours
const DWORD CWbemCache :: MAX_CACHE_SIZE = 500;

DWORD CWbemCache:: dwWBEMCacheCount = 0;
DWORD CEnumInfo:: dwCEnumInfoCount = 0;
DWORD CWbemClass:: dwCWbemClassCount = 0;

//***************************************************************************
//
// CWbemCache::CWbemCache
//
// Purpose : Constructor. Creates an empty cache
//
// Parameters: 
//***************************************************************************

CWbemCache :: CWbemCache()
{
	dwWBEMCacheCount ++;
}

//***************************************************************************
//
// CWbemCache::GetClass
//
// Purpose : Retreives the CWbemClass object, if present in the cache. Otherwise returns NULL
//
// Parameters: 
//	lpszClassName : The WBEM name of the Class to be retreived. 
//	ppWbemClass : The address of the pointer where the CWbemClass object will be placed
//
//	Return value:
//		The COM value representing the return status. The user should release the WBEM cclass
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: GetClass(LPCWSTR lpszWbemClassName, CWbemClass **ppWbemClass )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	if(*ppWbemClass = (CWbemClass *)m_objectTree.GetElement(lpszWbemClassName))
	{
		// Get the current time
		FILETIME fileTime;
		GetSystemTimeAsFileTime(&fileTime);
		LARGE_INTEGER currentTime;
		memcpy((LPVOID)&currentTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);

		// The QuadPart is in number of 100s of NanoSeconds.
		// Delete the object if is too old, and return failure
		// timeElapsed is the amount of time in seconds
		__int64 timeElapsed = ( currentTime.QuadPart - (*ppWbemClass)->GetCreationTime());
		timeElapsed = timeElapsed/(__int64)10000000;
		if( timeElapsed	> MAX_CACHE_AGE ) // in Seconds
		{
			(*ppWbemClass)->Release();
			*ppWbemClass = NULL;
			m_objectTree.DeleteElement(lpszWbemClassName);
			g_pLogObject->WriteW( L"CWbemCache :: GetClass() Deleted senile class : %s\r\n", lpszWbemClassName);
			return E_FAIL;
		}

		// Set its last accessed time
		(*ppWbemClass)->SetLastAccessTime(currentTime.QuadPart);

		return S_OK;
	}

	return E_FAIL;
#endif
}

//***************************************************************************
//
// CWbemCache::AddClass
//
// Purpose : Adds the CWbemClass object to the cache
//
// Parameters: 
//	ppWbemClass : The CWbemClass pointer of the object to be added
//
//	Return value:
//		The COM value representing the return status. 
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: AddClass(CWbemClass *pWbemClass )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	// Delete an element from the tree if its size has reached a limit of 100 nodes
	if(m_objectTree.GetNumberOfElements() >= MAX_CACHE_SIZE)
	{
		if(!m_objectTree.DeleteLeastRecentlyAccessedElement())
			return E_FAIL;
		g_pLogObject->WriteW( L"CWbemCache :: AddClass() Deleted LRU class from cache\r\n");
	}

	// Add the new element
	if(m_objectTree.AddElement(pWbemClass->GetName(), pWbemClass))
	{
		g_pLogObject->WriteW( L"CWbemCache :: AddClass() Added a class %s to cache\r\n", pWbemClass->GetName());
		return S_OK;
	}
	return E_FAIL;
#endif
}

//***************************************************************************
//
// CWbemCache::GetEnumInfo
//
// Purpose : Retreives the CEnumInfo object, if present in the cache. Otherwise returns NULL
//
// Parameters: 
//	lpszClassName : The WBEM name of the Class to be retreived. 
//	ppEnumInfo : The address of the pointer where the CEnumInfo object will be placed
//
//	Return value:
//		The COM value representing the return status. The user should release the EnumInfo object
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: GetEnumInfo(LPCWSTR lpszWbemClassName, CEnumInfo **ppEnumInfo )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	if(*ppEnumInfo = (CEnumInfo *)m_EnumTree.GetElement(lpszWbemClassName))
	{
		// Get the current time
		FILETIME fileTime;
		GetSystemTimeAsFileTime(&fileTime);
		LARGE_INTEGER currentTime;
		memcpy((LPVOID)&currentTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);

		// The QuadPart is in number of 100s of NanoSeconds.
		// Delete the object if is too old, and return failure
		// timeElapsed is the amount of time in seconds
		__int64 timeElapsed = ( currentTime.QuadPart - (*ppEnumInfo)->GetCreationTime());
		timeElapsed = timeElapsed/(__int64)10000000;
		if( timeElapsed	> MAX_CACHE_AGE ) // in Seconds
		{
			(*ppEnumInfo)->Release();
			*ppEnumInfo = NULL;
			m_EnumTree.DeleteElement(lpszWbemClassName);
			g_pLogObject->WriteW( L"CEnumCache :: GetClass() Deleted senile EnumInfo : %s\r\n", lpszWbemClassName);
			return E_FAIL;
		}

		// Set its last accessed time
		(*ppEnumInfo)->SetLastAccessTime(currentTime.QuadPart);

		return S_OK;
	}

	return E_FAIL;
#endif
}

//***************************************************************************
//
// CWbemCache::AddEnumInfo
//
// Purpose : Adds the CEnumInfo object to the cache
//
// Parameters: 
//	ppEnumInfo : The CEnumInfo pointer of the object to be added
//
//	Return value:
//		The COM value representing the return status. 
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: AddEnumInfo(CEnumInfo *pEnumInfo )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	// Delete an element from the tree if its size has reached a limit of 100 nodes
	if(m_EnumTree.GetNumberOfElements() >= MAX_CACHE_SIZE)
	{
		if(!m_EnumTree.DeleteLeastRecentlyAccessedElement())
			return E_FAIL;
		g_pLogObject->WriteW( L"CEnumCache :: AddClass() Deleted LRU class from cache\r\n");
	}

	// Add the new element
	if(m_EnumTree.AddElement(pEnumInfo->GetName(), pEnumInfo))
	{
		g_pLogObject->WriteW( L"CEnumCache :: AddClass() Added a EnumInfo %s to cache\r\n", pEnumInfo->GetName());
		return S_OK;
	}
	return E_FAIL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\wbemcach.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:wbemcach.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Cache for WBEM Class objects 
//
//***************************************************************************

#ifndef WBEM_CACHE_H
#define WBEM_CACHE_H

// This encapsulates a WBEM Class object
class CWbemClass : public CRefCountedObject
{
private:
	IWbemClassObject *m_pWbemClass;

public:
	static DWORD dwCWbemClassCount;

	CWbemClass(LPCWSTR pszWbemClassName, IWbemClassObject *pWbemClass)
		: CRefCountedObject(pszWbemClassName)
	{
		dwCWbemClassCount++;
		m_pWbemClass = pWbemClass;
		m_pWbemClass->AddRef();
	}
	~CWbemClass()
	{
		dwCWbemClassCount--;
		m_pWbemClass->Release();
	}

	IWbemClassObject *GetWbemClass()
	{
		m_pWbemClass->AddRef();
		return m_pWbemClass;
	}

};

// This encapsulates subclass enumeration (deep) of a WBEM class
class CEnumInfo : public CRefCountedObject
{
private:
	CNamesList *m_pClassNameList;

public:
	static DWORD dwCEnumInfoCount;
	CEnumInfo(LPCWSTR pszWbemSuperClassName, CNamesList *pClassNameList)
		: CRefCountedObject(pszWbemSuperClassName)
	{
		dwCEnumInfoCount++;
		m_pClassNameList = pClassNameList;
	}
	~CEnumInfo()
	{
		dwCEnumInfoCount--;
		delete m_pClassNameList;
	}

	CNamesList *GetSubClassNames() 
	{
		return m_pClassNameList;
	}
};

class CWbemCache
{
private:
	// The storage for cached classes
	CObjectTree m_objectTree;
	// The storage for enumeration information
	CObjectTree m_EnumTree;

	// Cache configuration parameters
	static const __int64 MAX_CACHE_AGE; // In seconds
	static const DWORD MAX_CACHE_SIZE;
	static DWORD dwWBEMCacheCount;

public:
	//***************************************************************************
	//
	// CWbemCache::CLDAPCache
	//
	// Purpose : Constructor. Creates an empty cache
	//
	// Parameters: 
	//***************************************************************************
	CWbemCache();

	//***************************************************************************
	//
	// CWbemCache::GetClass
	//
	// Purpose : Retreives the IDirectory interface of an LDAP Class
	//
	// Parameters: 
	//	lpszClassName : The WBEM name of the Class to be retreived. 
	//	ppWbemClass : The address of the pointer where the CWbemClass object will be placed
	//
	//	Return value:
	//		The COM value representing the return status. The user should release the WBEM cclass
	// when done.
	//		
	//***************************************************************************
	HRESULT GetClass(LPCWSTR lpszWbemClassName, CWbemClass **ppWbemClass );

	//***************************************************************************
	//
	// CWbemCache::AddClass
	//
	// Purpose : Adds the CWbemClass object to the cache
	//
	// Parameters: 
	//	ppWbemClass : The CWbemClass pointer of the object to be added
	//
	//	Return value:
	//		The COM value representing the return status. 
	// when done.
	//		
	//***************************************************************************
	HRESULT AddClass(CWbemClass *pWbemClass );

	//***************************************************************************
	//
	// CEnumCache::GetEnumInfo
	//
	// Purpose : Retreives the CEnumInfo object of a WBEM class
	//
	// Parameters: 
	//	lpszWbemClassName : The WBEM name of the Class to be retreived. 
	//	ppEnumInfo : The address of the pointer where the CEnumInfo object will be placed
	//
	//	Return value:
	//		The COM value representing the return status. The user should release the WBEM cclass
	// when done.
	//		
	//***************************************************************************
	HRESULT GetEnumInfo(LPCWSTR lpszWbemClassName, CEnumInfo **ppEnumInfo );

	//***************************************************************************
	//
	// CEnumCache::AddEnumInfo
	//
	// Purpose : Adds the CEnumInfo object to the cache
	//
	// Parameters: 
	//	ppWbemClass : The CEnumInfo pointer of the object to be added
	//
	//	Return value:
	//		The COM value representing the return status. 
	// when done.
	//		
	//***************************************************************************
	HRESULT AddEnumInfo(CEnumInfo *pEnumInfo);


};

#endif /* WBEM_CACHE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\wbemhelp.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:wbemhelp.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation the CWBEMHelper class. This is
//	a class that has many static helper functions pertaining to WBEM
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#include "precomp.h"

LPCWSTR CWBEMHelper :: EQUALS_QUOTE					= L"=\"";
LPCWSTR CWBEMHelper :: QUOTE						= L"\"";
LPCWSTR CWBEMHelper :: OBJECT_CATEGORY_EQUALS		= L"objectCategory=";
LPCWSTR CWBEMHelper :: OBJECT_CLASS_EQUALS			= L"objectClass=";

//***************************************************************************
//
// CWBEMHelper::PutBSTRProperty
//
// Purpose: Puts a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	strPropertyValue : The value of the property to be put
//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
//		the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRProperty(IWbemClassObject *pWbemClass, 
									   const BSTR strPropertyName, 
									   BSTR strPropertyValue, 
									   BOOLEAN deallocatePropertyValue)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR;
	variant.bstrVal = strPropertyValue;

	HRESULT result = pWbemClass->Put(strPropertyName, 0, &variant, 0);
	if (!deallocatePropertyValue)
		variant.bstrVal = NULL;

	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::GetBSTRProperty
//
// Purpose: Gets a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be gotten
//	strPropertyName : The name of the property to be gotten
//	pStrPropertyValue : The address where the value of the property to should be put
//
// Return Value: The COM value representing the return status. The user should delete the
// string allocated when done
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBSTRProperty(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	BSTR *pStrPropertyValue)
{
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result = pWbemClass->Get(strPropertyName, 0, &variant, NULL, NULL);
	if(variant.vt == VT_BSTR && variant.bstrVal)
		*pStrPropertyValue = SysAllocString(variant.bstrVal);
	else
		*pStrPropertyValue = NULL;
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::PutBSTRPropertyT
//
// Purpose: Puts a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	lpszPropertyValue : The value of the property to be put
//	deallocatePropertyValue : whether to deallocate the parameter lpszPropertyValue before
//		the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRPropertyT(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	LPWSTR lpszPropertyValue, 
	BOOLEAN deallocatePropertyValue)
{
	BSTR strPropertyValue = SysAllocString(lpszPropertyValue);
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR;
	variant.bstrVal = strPropertyValue;

	HRESULT result = pWbemClass->Put(strPropertyName, 0, &variant, 0);
	if (deallocatePropertyValue)
		delete[] lpszPropertyValue;

	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::GetBSTRPropertyT
//
// Purpose: Gets a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	lppszPropertyValue : The pointer to LPWSTR where the value of the property will be placed. The user should
//		delete this once he is done with it.
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBSTRPropertyT(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	LPWSTR *lppszPropertyValue)
{
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result = pWbemClass->Get(strPropertyName, 0, &variant, NULL, NULL);
	if(SUCCEEDED(result))
	{
		*lppszPropertyValue = new WCHAR[wcslen(variant.bstrVal) + 1];
		wcscpy(*lppszPropertyValue, variant.bstrVal);
	}
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::PutBSTRArrayProperty
//
// Purpose: Puts a BSTR Array property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	pStrPropertyValue : The array of BSTRS  that have the values of the property to be put
//	lCount : The number of elements in the above array
//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
//		the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRArrayProperty(IWbemClassObject *pWbemClass, 
											const BSTR strPropertyName, 
											VARIANT *pInputVariant)
{
	// THe input is a safe array of variants of type VT_BSTR
	// The output is a safe array for VT_BSTRs

    LONG lstart, lend;
    SAFEARRAY *inputSafeArray = pInputVariant->parray;
 
    // Get the lower and upper bound of the inpute safe array
    SafeArrayGetLBound( inputSafeArray, 1, &lstart );
    SafeArrayGetUBound( inputSafeArray, 1, &lend );
 

	// Create the output SAFEARRAY
	SAFEARRAY *outputSafeArray = NULL;
	SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
	safeArrayBounds[0].lLbound = lstart ;
	safeArrayBounds[0].cElements = lend - lstart + 1 ;
	outputSafeArray = SafeArrayCreate (VT_BSTR, 1, safeArrayBounds);

	// Fill it
    VARIANT inputItem;
	VariantInit(&inputItem);
	HRESULT result = S_OK;
	bool bError = false;
    for ( long idx=lstart; !bError && (idx <=lend); idx++ )
    {
	    VariantInit(&inputItem);
        SafeArrayGetElement( inputSafeArray, &idx, &inputItem );
		if(FAILED(result = SafeArrayPutElement(outputSafeArray, &idx, inputItem.bstrVal)))
			bError = true;
        VariantClear(&inputItem);
    }
 

	// Create the variant
	if(SUCCEEDED(result))
	{
		VARIANT outputVariant;
		VariantInit(&outputVariant);
		outputVariant.vt = VT_ARRAY | VT_BSTR ;
		outputVariant.parray = outputSafeArray ; 		
		result = pWbemClass->Put (strPropertyName, 0, &outputVariant, 0);
		VariantClear(&outputVariant);
	}
	else
		SafeArrayDestroy(outputSafeArray);
	return result;
}


//***************************************************************************
//
// CWBEMHelper :: PutBOOLQualifier
//
// Purpose: Puts a BOOLEAN Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	bQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	VARIANT_BOOL bQualifierValue,
	LONG lFlavour)
{

	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BOOL;
	variant.boolVal = bQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: GetBOOLQualifier
//
// Purpose: Gets a BOOLEAN Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to get
//	bQualifierValue : The value of the qualifier to get
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	VARIANT_BOOL *pbQualifierValue,
	LONG *plFlavour)
{
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result = pQualifierSet->Get(strQualifierName, 0, &variant, plFlavour);
	if(SUCCEEDED(result))
		*pbQualifierValue = variant.boolVal;
	VariantClear(&variant);
	return result;
}


//***************************************************************************
//
// CWBEMHelper :: PutI4Qualifier
//
// Purpose: Puts a VT_I4 Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutI4Qualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	long lQualifierValue,
	LONG lFlavour)
{

	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_I4;
	variant.lVal = lQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	VariantClear(&variant);
	return result;
}


//***************************************************************************
//
// CWBEMHelper :: PutLONGQualifier
//
// Purpose: Puts a LONG Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutLONGQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	LONG lQualifierValue,
	LONG lFlavour)
{

	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_I4;
	variant.lVal = lQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: PutBSTRQualifier
//
// Purpose: Puts a BSTR Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	strQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//	deallocateQualifierValue : whether to deallocate the parameter strQualifierValue 
//	before the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	BSTR strQualifierValue,
	LONG lFlavour,
	BOOLEAN deallocateQualifierValue)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR;
	variant.bstrVal = strQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	if(!deallocateQualifierValue)
		variant.bstrVal = NULL;
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: GetBSTRQualifierT
//
// Purpose: Gets a BSTR Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lppszQualifierValue : The address of the LPWSTR where the qualifier value will be put/
//		It is the duty of the caller to free this memory when done
//	plFlavour : The address where the qualifier flavor will be put. This is optional
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBSTRQualifierT(
	IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	LPWSTR *lppszQualifierValue,
	LONG *plFlavour)
{
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result = pQualifierSet->Get(strQualifierName, 0, &variant, plFlavour);
	if(SUCCEEDED(result))
	{
		if(variant.vt == VT_BSTR && variant.bstrVal)
		{
			*lppszQualifierValue = NULL;
			if(*lppszQualifierValue = new WCHAR [ wcslen(variant.bstrVal) + 1])
				wcscpy(*lppszQualifierValue, variant.bstrVal);
			else
				result = E_OUTOFMEMORY;
		}
		else
			result = E_FAIL;
	}
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: PutUint8ArrayQualifier
//
// Purpose: Puts a Uint8 array  Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lpQualifierValue : The value of the qualifier to be put. An array of BYTEs
//	dwLenght : The number of elements in the above array
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutUint8ArrayQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	LPBYTE lpQualifierValue,
	DWORD dwLength,
	LONG lFlavour)
{

	// Create the variant
	VARIANT variant;
	VariantInit(&variant);

	// Create the SAFEARRAY
	SAFEARRAY *safeArray ;
	SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
	safeArrayBounds[0].lLbound = 0 ;
	safeArrayBounds[0].cElements = dwLength ;
	safeArray = SafeArrayCreate (VT_I4, 1, safeArrayBounds);

	// Fill it
	UINT temp;
	HRESULT result = S_OK;
	bool bError = false;
	for (LONG index = 0; !bError && (index<(LONG)dwLength); index++)
	{
		temp = (UINT)lpQualifierValue[index];
		if(FAILED(result = SafeArrayPutElement(safeArray , &index,  (LPVOID)&temp)))
			bError = true;
	}

	if(SUCCEEDED(result))
	{
		variant.vt = VT_ARRAY | VT_I4 ;
		variant.parray = safeArray ; 		
		result = pQualifierSet->Put (strQualifierName, &variant, lFlavour);
		VariantClear(&variant);
	}
	else
		SafeArrayDestroy(safeArray);

	return result;

}

//***************************************************************************
//
// CWBEMHelper::GetADSIPathFromObjectPath
//
// Purpose: See Header File
//
//***************************************************************************
LPWSTR CWBEMHelper :: GetADSIPathFromObjectPath(LPCWSTR pszObjectRef)
{
	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	LPWSTR pszADSIPath = NULL;
	switch(theParser.Parse((LPWSTR)pszObjectRef, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
		{
			KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);
			// Check to see that there is 1 key specified and that its type is VT_BSTR
			if(theParsedObjectPath->m_dwNumKeys == 1 && pKeyRef->m_vValue.vt == VT_BSTR)
			{
				// If the name of the key is specified, check the name
				if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_ATTR) != 0)
					break;

				pszADSIPath = new WCHAR[wcslen((*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal) + 1];
				wcscpy(pszADSIPath, (*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal);
			}
			break;
		}	
		default:
			break;
	}

	// Free the parser object path
	theParser.Free(theParsedObjectPath);
	return pszADSIPath;
}

//***************************************************************************
//
// CWBEMHelper::GetObjectRefFromADSIPath
//
// Purpose: See Header File
//
//***************************************************************************
BSTR CWBEMHelper :: GetObjectRefFromADSIPath(LPCWSTR pszADSIPath, LPCWSTR pszWBEMClassName)
{
	// We need the object path parser to add WMI escape characters
	// from the key value which is an ADSI Path
	ParsedObjectPath t_ObjectPath;

	// Add a key value binding for the ADSIPath
	//===========================================
	VARIANT vKeyValue;
	VariantInit(&vKeyValue);
	vKeyValue.vt = VT_BSTR;
	vKeyValue.bstrVal = SysAllocString(pszADSIPath);
	t_ObjectPath.SetClassName(pszWBEMClassName);
	t_ObjectPath.AddKeyRef(ADSI_PATH_ATTR, &vKeyValue);
	VariantClear(&vKeyValue);


	// Get the Object Path value now
	//================================
	CObjectPathParser t_Parser;
	LPWSTR t_pszObjectPath = NULL;
	BSTR retVal = NULL;
	if(CObjectPathParser::NoError == t_Parser.Unparse(&t_ObjectPath, &t_pszObjectPath))
	{
		retVal = SysAllocString(t_pszObjectPath);
		delete [] t_pszObjectPath;
	}
	return retVal;
}

//***************************************************************************
//
// CWBEMHelper::GetUint8ArrayProperty
//
// Purpose: See Header file
//
//***************************************************************************	
HRESULT CWBEMHelper :: GetUint8ArrayProperty(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	LPBYTE *ppPropertyValues, 
	ULONG *plCount)
{
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result = pWbemClass->Get(strPropertyName, 0, &variant, NULL, NULL);
	if(SUCCEEDED(result))
	{
		if(variant.vt == (VT_ARRAY|VT_UI1))
		{
			SAFEARRAY *pArray = variant.parray;
			BYTE HUGEP *pb;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pb)))
			{
				if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)))
				{
					if (SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)))
					{
						if(*plCount = lUbound - lLbound + 1)
						{
							*ppPropertyValues = new BYTE[*plCount];
							for(DWORD i=0; i<*plCount; i++)
								(*ppPropertyValues)[i] = pb[i];
						}
					}
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		else
		{
			*ppPropertyValues = NULL;
			*plCount = 0;
		}
	}
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::FormulateInstanceQuery
//
// Purpose: See Header file
//
//***************************************************************************	
HRESULT CWBEMHelper :: FormulateInstanceQuery(IWbemServices *pServices, IWbemContext *pCtx, BSTR strClass, IWbemClassObject *pWbemClass, LPWSTR pszObjectCategory, BSTR strClassQualifier, BSTR strCategoryQualifier)
{
	DWORD dwOutput = 0;
	pszObjectCategory[dwOutput++] = LEFT_BRACKET_STR[0];
	DWORD dwOrPosition = dwOutput;
	pszObjectCategory[dwOutput++] = PIPE_STR[0];

	HRESULT result = E_FAIL;
	if(SUCCEEDED(result = AddSingleCategory(pszObjectCategory, &dwOutput, pWbemClass, strClassQualifier, strCategoryQualifier)))
	{
	}
/*
	IEnumWbemClassObject *pEnum = NULL;
	DWORD dwNumObjects = 0;
	HRESULT result = pServices->CreateClassEnum(strClass, WBEM_FLAG_DEEP, pCtx, &pEnum);
	if(SUCCEEDED(result))
	{
		IWbemClassObject *pNextObject = NULL;
		ULONG lNum = 0;
		while(SUCCEEDED(pEnum->Next(WBEM_INFINITE, 1, &pNextObject, &lNum)) && lNum )
		{
			if(!SUCCEEDED(AddSingleCategory(pszObjectCategory, &dwOutput, pNextObject, strClassQualifier, strCategoryQualifier)))
			{
				pNextObject->Release();
				break;
			}
			dwNumObjects ++;
			pNextObject->Release();
		}
		pEnum->Release();
	}

	// Remove the '|' if there is only one element
	if(!dwNumObjects)
	*/
		pszObjectCategory[dwOrPosition] = SPACE_STR[0];

	// Terminate the query
	pszObjectCategory[dwOutput++] = RIGHT_BRACKET_STR[0];
	pszObjectCategory[dwOutput] = NULL;
	return result;
}

//***************************************************************************
//
// CWBEMHelper::AddSingleCategory
//
// Purpose: See Header file
//
//***************************************************************************	
HRESULT CWBEMHelper :: AddSingleCategory(LPWSTR pszObjectCategory, DWORD *pdwOutput, IWbemClassObject *pNextObject, BSTR strLDAPNameQualifier, BSTR strCategoryQualifier)
{
	pszObjectCategory[(*pdwOutput)++] = SPACE_STR[0];
	pszObjectCategory[(*pdwOutput)++] = LEFT_BRACKET_STR[0];
	IWbemQualifierSet *pQualifierSet = NULL;
	HRESULT result;
	if(SUCCEEDED(result = pNextObject->GetQualifierSet(&pQualifierSet)))
	{
		VARIANT classNameVariant;
		if(SUCCEEDED(result = pQualifierSet->Get(strLDAPNameQualifier, 0, &classNameVariant, NULL)))
		{
			VARIANT categoryVariant;

			if(SUCCEEDED(result = pQualifierSet->Get(strCategoryQualifier, 0, &categoryVariant, NULL)))
			{
				pszObjectCategory[(*pdwOutput)++] = AMPERSAND_STR[0];

				pszObjectCategory[(*pdwOutput)++] = LEFT_BRACKET_STR[0];
				wcscpy(pszObjectCategory + *pdwOutput, OBJECT_CATEGORY_EQUALS);
				*pdwOutput += wcslen(OBJECT_CATEGORY_EQUALS);
				wcscpy(pszObjectCategory + *pdwOutput, categoryVariant.bstrVal);
				*pdwOutput += wcslen(categoryVariant.bstrVal);
				pszObjectCategory[(*pdwOutput)++] = RIGHT_BRACKET_STR[0];

				pszObjectCategory[(*pdwOutput)++] = LEFT_BRACKET_STR[0];
				wcscpy(pszObjectCategory + *pdwOutput, OBJECT_CLASS_EQUALS);
				*pdwOutput += wcslen(OBJECT_CLASS_EQUALS);
				wcscpy(pszObjectCategory + *pdwOutput, classNameVariant.bstrVal);
				*pdwOutput += wcslen(classNameVariant.bstrVal);
				pszObjectCategory[(*pdwOutput)++] = RIGHT_BRACKET_STR[0];

				VariantClear(&categoryVariant);
			}
			VariantClear(&classNameVariant);
		}
		pQualifierSet->Release();
	}
	pszObjectCategory[(*pdwOutput)++] = RIGHT_BRACKET_STR[0];
	pszObjectCategory[(*pdwOutput)++] = SPACE_STR[0];
	return result;
}


//***************************************************************************
//
// CWBEMHelper::IsPresentInBstrList
//
// Purpose: See Header file
//
//***************************************************************************	
BOOLEAN CWBEMHelper :: IsPresentInBstrList(BSTR *pstrProperyNames, DWORD dwNumPropertyNames, BSTR strPropertyName)
{
	for(DWORD i=0; i<dwNumPropertyNames; i++)
	{
		if(_wcsicmp(pstrProperyNames[i], strPropertyName) == 0)
			return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\wbemhelp.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:wbemhelp.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CWBEMHelper class. This is
//	a class that has many static helper functions pertaining to WBEM
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef WBEM_HELPER_H
#define WBEM_HELPER_H

class CWBEMHelper
{
protected:
	static LPCWSTR EQUALS_QUOTE;
	static LPCWSTR QUOTE;
	static LPCWSTR OBJECT_CATEGORY_EQUALS;
	static LPCWSTR OBJECT_CLASS_EQUALS;
public:

	//***************************************************************************
	//
	// CWBEMHelper::PutBSTRProperty
	//
	// Purpose: Puts a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	strPropertyValue : The value of the property to be put
	//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
	//		the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBSTRProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		BSTR strPropertyValue, 
		BOOLEAN deallocatePropertyValue = TRUE);

	//***************************************************************************
	//
	// CWBEMHelper::GetBSTRProperty
	//
	// Purpose: Gets a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be gotten
	//	strPropertyName : The name of the property to be gotten
	//	pStrPropertyValue : The address where the value of the property to should be put
	//
	// Return Value: The COM value representing the return status. The user should delete the
	// string allocated when done
	//
	//***************************************************************************
	static HRESULT GetBSTRProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		BSTR *pStrPropertyValue);

	//***************************************************************************
	//
	// CWBEMHelper::PutBSTRPropertyT
	//
	// Purpose: Puts a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	lpszPropertyValue : The value of the property to be put
	//	deallocatePropertyValue : whether to deallocate the parameter lpszPropertyValue before
	//		the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBSTRPropertyT(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		LPWSTR lpszPropertyValue, 
		BOOLEAN deallocatePropertyValue = TRUE);

	//***************************************************************************
	//
	// CWBEMHelper::GetBSTRPropertyT
	//
	// Purpose: Gets a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	lppszPropertyValue : The pointer to LPWSTR where the value of the property will be placed. The user should
	//		delete this once he is done with it.
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT GetBSTRPropertyT(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		LPWSTR *lppszPropertyValue);

	//***************************************************************************
	//
	// CWBEMHelper::PutBSTRArrayProperty
	//
	// Purpose: Puts a BSTR Array property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	pStrPropertyValue : The array of BSTRS  that have the values of the property to be put
	//	lCount : The number of elements in the above array
	//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
	//		the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************	
	static HRESULT PutBSTRArrayProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		VARIANT *pVariant);

	//***************************************************************************
	//
	// CWBEMHelper::GetUint8ArrayProperty
	//
	// Purpose: Gets a VT_UI1 Array property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be gotten
	//	strPropertyName : The name of the property 
	//	ppPropertyValuea : The address of a pointer to BYTE  where an array of values will be places
	//	plCount : The address where the count of elements will be placed
	//
	// Return Value: The COM value representing the return status. The user should deallocate the array
	//	returned when done.
	//
	//***************************************************************************	
	static HRESULT GetUint8ArrayProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		LPBYTE *ppPropertyValues, 
		ULONG *plCount);


	//***************************************************************************
	//
	// CWBEMHelper :: PutBOOLQualifier
	//
	// Purpose: Puts a BOOLEAN Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	bQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		VARIANT_BOOL bQualifierValue,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: GetBOOLQualifier
	//
	// Purpose: Gets a BOOLEAN Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to get
	//	bQualifierValue : The value of the qualifier to get
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT GetBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		VARIANT_BOOL *pbQualifierValue,
		LONG *plFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutI4Qualifier
	//
	// Purpose: Puts a VT_I4 Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************	
	static HRESULT PutI4Qualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		long lQualifierValue,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutBSTRQualifier
	//
	// Purpose: Puts a BSTR Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	strQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//	deallocateQualifierValue : whether to deallocate the parameter strQualifierValue 
	//	before the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBSTRQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		BSTR strQualifierValue,
		LONG lFlavour,
		BOOLEAN deallocateQualifierValue = TRUE);

	//***************************************************************************
	//
	// CWBEMHelper :: GetBSTRQualifierT
	//
	// Purpose: Gets a BSTR Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lppszQualifierValue : The address of the LPWSTR where the qualifier value will be put/
	//		It is the duty of the caller to free this memory when done
	//	plFlavour : The address where the qualifier flavor will be put. This is optional
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT GetBSTRQualifierT(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		LPWSTR *lppszQualifierValue,
		LONG *plFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutLONGQualifier
	//
	// Purpose: Puts a LONG Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutLONGQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		LONG lQualifierValue,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutUint8ArrayQualifier
	//
	// Purpose: Puts a Uint8 array  Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lpQualifierValue : The value of the qualifier to be put. An array of BYTEs
	//	dwLenght : The number of elements in the above array
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutUint8ArrayQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		LPBYTE lpQualifierValue,
		DWORD dwLength,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper::GetADSIPathFromObjectPath
	//
	// Purpose: Gets the ADSI Path from an object ref of a WBEM object
	//
	// Parameters :
	//	pszObjectRef : The object ref to a WBEM instance
	//
	// Return Value : The ADSI Path in the key of the object ref. The user should delete this
	//	when done
	//
	//***************************************************************************
	static LPWSTR GetADSIPathFromObjectPath(LPCWSTR pszObjectRef);

	//***************************************************************************
	//
	// CWBEMHelper::GetObjectRefFromADSIPath
	//
	// Purpose: Gets the object ref of a WBEM object from its ADSI path
	//
	// Parameters :
	//	pszADSIPath : The ADSI path to an ADSI instance
	//	pszWbemClassName : The WBEM class name of the instance
	//
	// Return Value : The WBEM object ref of the ADSI instance. The user should delete this
	//	when done
	//
	//***************************************************************************
	static BSTR GetObjectRefFromADSIPath(LPCWSTR pszADSIPath, LPCWSTR pszWBEMClassName);

	static HRESULT FormulateInstanceQuery(IWbemServices *pServices, IWbemContext *pContext, BSTR strClass, IWbemClassObject *pWbemClass, LPWSTR pszObjectCategory, BSTR strClassQualifier, BSTR strCategoryQualifier);
	static HRESULT AddSingleCategory(LPWSTR pszObjectCategory, DWORD *pdwOutput, IWbemClassObject *pNextObject, BSTR strClassQualifier, BSTR strCategoryQualifier);

	static BOOLEAN IsPresentInBstrList(BSTR *pstrProperyNames, DWORD dwNumPropertyNames, BSTR strPropertyName);

};

#endif /* WBEM_HELPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\mofs\makefile.inc ===
$(O)\dsprov.mof $(O)\dsprov.mfl: dsprov.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\dsprovTmp.mof -MFL:$(O)\dsprovTmp.mfl dsprov.mof
    copy copyright.mof+$(O)\dsprovTmp.mof+$(O)\dsprovTmp.mfl $(O)\dsprov.mof
    copy copyright.mof+$(O)\dsprovTmp.mfl $(O)\dsprov.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\pathprsr\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\dsprovider\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\pathprsr\sources.inc ===
#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=pathprsr
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES); \
	$(FRAMEWORK_PARSER_INC); \
	$(FRAMEWORK_EXPT_INC); \
	$(FRAMEWORK_MFC_INC)

SOURCES= \
	..\analyser.cpp \
    ..\namepath.cpp

C_DEFINES=$(C_DEFINES) 
USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\pathprsr\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#include <provexpt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\pathprsr\ansi\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\pathprsr\analyser.cpp ===
//***************************************************************************

//

//  ANALYSER.CPP

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <instpath.h>
#include <provexpt.h>
#include <strsafe.h>

WbemLexicon :: WbemLexicon () : position ( 0 ) , tokenStream ( NULL ) 
{
    value.string = NULL ;
    value.token = NULL ;
}

WbemLexicon :: ~WbemLexicon ()
{
    switch ( token ) 
    {
        case TOKEN_ID:
        {
            delete [] value.token ;
        }
        break ;
    
        case STRING_ID:
        {
            delete [] value.string ;
        }
        break ;

        default:
        {
        } ;
    }
}

WbemLexicon :: LexiconToken WbemLexicon :: GetToken ()
{
    return token ;
}

WbemLexiconValue *WbemLexicon :: GetValue ()
{
    return &value ;
}

WbemAnalyser :: WbemAnalyser ( WCHAR *tokenStream ) : status ( TRUE ) , position ( 0 ) , stream ( NULL ) 
{
    if ( tokenStream )
    {
		DWORD t_TextLength = wcslen ( tokenStream ) + 1 ;
        stream = new WCHAR [ t_TextLength ] ;
        StringCchCopyW ( stream , t_TextLength , tokenStream ) ;
    }
}

WbemAnalyser :: ~WbemAnalyser () 
{
    delete [] stream ;
}

void WbemAnalyser :: Set ( WCHAR *tokenStream ) 
{
    status = 0 ;
    position = NULL ;

    delete [] stream ;
	DWORD t_TextLength = wcslen ( tokenStream ) + 1 ;
    stream = new WCHAR [ t_TextLength ] ;
    StringCchCopyW ( stream , t_TextLength , tokenStream ) ;
}

void WbemAnalyser :: PutBack ( WbemLexicon *token ) 
{
    position = token->position ;
}

BOOL WbemAnalyser :: IsLeadingDecimal ( WCHAR token )
{
    return iswdigit ( token ) && ( token != L'0' ) ;
}

BOOL WbemAnalyser :: IsDecimal ( WCHAR token )
{
    return iswdigit ( token ) ;
}

BOOL WbemAnalyser :: IsHex ( WCHAR token )
{
    return iswxdigit ( token ) ;
}
    
BOOL WbemAnalyser :: IsWhitespace ( WCHAR token )
{
    return iswspace ( token ) ;
}

BOOL WbemAnalyser :: IsOctal ( WCHAR token )
{
    return ( token >= L'0' && token <= L'7' ) ;
}

BOOL WbemAnalyser :: IsAlpha ( WCHAR token )
{
    return iswalpha ( token ) ;
}

BOOL WbemAnalyser :: IsAlphaNumeric ( WCHAR token )
{
    return iswalnum ( token ) || ( token == L'_' ) || ( token == L'-' ) ;
}

BOOL WbemAnalyser :: IsEof ( WCHAR token )
{
    return token == 0 ;
}

LONG WbemAnalyser :: OctToDec ( WCHAR token ) 
{
    return token - L'0' ;
}

LONG WbemAnalyser :: HexToDec ( WCHAR token ) 
{
    if ( token >= L'0' && token <= L'9' )
    {
        return token - L'0' ;
    }
    else if ( token >= L'a' && token <= L'f' )
    {
        return token - L'a' + 10 ;
    }
    else if ( token >= L'A' && token <= L'F' )
    {
        return token - L'A' + 10 ;
    }
    else
    {
        return 0 ;
    }
}

WbemAnalyser :: operator void * () 
{
    return status ? this : NULL ;
}

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define STRING_START 4000
#define TOKEN_START 5000
#define OID_START 6000

#define OID_STATE 9000
#define TOKEN_STATE 9001
#define STRING_STATE 9002
#define EOF_STATE 9003
#define DEC_INTEGER_STATE 9004
#define HEX_INTEGER_STATE 9005
#define OCT_INTEGER_STATE 9006

#define ACCEPT_STATE 10000
#define REJECT_STATE 10001

WbemLexicon *WbemAnalyser :: Get () 
{
    WbemLexicon *lexicon = NULL ;

    if ( stream )
    {
        lexicon = GetToken () ;
    }
    else
    {
        lexicon = new WbemLexicon ;
        lexicon->position = position ;
        lexicon->token = WbemLexicon :: EOF_ID ;
    }

    return lexicon ;
}

WbemLexicon *WbemAnalyser :: GetToken () 
{
    WbemLexicon *lexicon = new WbemLexicon ;
    lexicon->position = position ;
    ULONG state = 0 ;

/* 
 * Integer Definitions
 */

    BOOL negative = FALSE ;
    LONG magicMult = ( LONG ) ( ( ( ULONG ) ( 1L << 31L ) ) / 10L ) ; 
    LONG magicNegDigit = 8 ;
    LONG magicPosDigit = 7 ;
    LONG datum = 0 ;    

/*
 * String Definitions
 */
    ULONG string_start = 0 ;
    ULONG string_length = 0 ;
    WCHAR *string = NULL ;


/*
 * Token Definitions
 */

    ULONG token_start = 0 ;

/*
 * OID Definitions
 */
    ULONG hex_datum = 0 ;
    ULONG brace_position = 0 ;
    ULONG hex_repetitions = 0 ;
    ULONG nybbleRepetitions = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        WCHAR token = stream [ position ] ;
        switch ( state )
        {
            case 0:
            {
                if ( IsLeadingDecimal ( token ) )
                {
                    state = DEC_INTEGER_START + 1  ;
                    datum = ( token - 48 ) ;
                }
                else if ( token == L'@' )
                {
                    lexicon->token = WbemLexicon :: AT_ID ;
                    state = ACCEPT_STATE ;
                } 
                else if ( token == L'\\' )
                {
                    lexicon->token = WbemLexicon :: BACKSLASH_ID ;
                    state = ACCEPT_STATE ;
                } 
                else if ( token == L'\"' )
                {
                    state = STRING_START ;
                    string_start = position + 1 ;
                }
                else if ( token == L'{' )
                {
                    state = OID_START ;
                    hex_datum = 0 ;
                    brace_position = position ;
                    hex_repetitions = 0 ;
                    nybbleRepetitions = 0 ;
                }
                else if ( token == L'}' )
                {
                    lexicon->token = WbemLexicon :: CLOSE_BRACE_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( token == L'=' )
                {
                    lexicon->token = WbemLexicon :: EQUALS_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( token == L'.' )
                {
                    lexicon->token = WbemLexicon :: DOT_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( token == L',' )
                {
                    lexicon->token = WbemLexicon :: COMMA_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( token == L':' )
                {
                    lexicon->token = WbemLexicon :: COLON_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( token == L'+' )
                {
                    state = DEC_INTEGER_START ;
                }
                else if ( token == L'-' ) 
                {
                    negative = TRUE ;
                    state = DEC_INTEGER_START ;
                }
                else if ( token == L'0' )
                {
                    state = 1 ;
                }
                else if ( IsWhitespace ( token ) ) 
                {
                    state = 0 ;
                }
                else if ( IsEof ( token ) )
                {
                    lexicon->token = WbemLexicon :: EOF_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( IsAlpha ( token ) )
                {
                    state = TOKEN_START ;
                    token_start = position ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( token == L'x' || token == L'X' )
                {
                    state = HEX_INTEGER_START ;             
                }
                else if ( IsOctal ( token ) )
                {
                    state = OCT_INTEGER_START ;
                    datum = ( token - 48 ) ;
                }
                else
                {
                    lexicon->token = WbemLexicon :: INTEGER_ID ;
                    lexicon->value.integer = 0 ;
                    position -- ;
                    state = ACCEPT_STATE ;
                }
            }
            break ;

            case STRING_START:
            {
                if ( token == L'\"' )
                {
                    lexicon->token = WbemLexicon :: STRING_ID ;
                    state = ACCEPT_STATE ;
        
                    if ( position == string_start )
                    {
                        lexicon->value.string = new WCHAR [ 1 ] ;
                        lexicon->value.string [ 0 ] = 0 ;
                    }
                    else
                    {
                        lexicon->value.string = new WCHAR [ string_length + 1 ] ;
                        wcsncpy ( 

                            lexicon->value.string , 
                            string ,
                            string_length
                        ) ;

                        lexicon->value.string [ string_length ] = 0 ;
                        free (string);
                    }
                }
                else if ( token == IsEof ( token ) ) 
                {
                    state = REJECT_STATE ;
                    free (string);                    
                }
                else 
                {
                    realloc_throw ( &string , sizeof ( WCHAR ) * ( string_length + 1 ) ) ;

                    string [ string_length ] = token ;
                    string_length ++ ;
                    state = STRING_START ;
                }
            }
            break ;

            case STRING_START+1:
            {
                if ( token == L'\"' )
                {
                    realloc_throw ( &string , sizeof ( WCHAR ) * ( string_length + 1 ) ) ;

		      string [ string_length ] = L'\"' ;
                    string_length ++ ;
                    state = STRING_START ;
                }
                else if ( token == IsEof ( token ) ) 
                {
                    state = REJECT_STATE ;
                }
                else 
                {
                    realloc_throw ( &string , sizeof ( WCHAR ) * ( string_length + 1 ) ) ;

                    string [ string_length ] = token ;
                    string_length ++ ;
                    state = STRING_START ;
                }
            }
            break ;

            case TOKEN_START:
            {
                if ( IsAlphaNumeric ( token ) ) 
                {
                    state = TOKEN_START ;
                }
                else 
                {
                    state = ACCEPT_STATE ;
                    lexicon->token = WbemLexicon :: TOKEN_ID ;
                    lexicon->value.token = new WCHAR [ position - token_start + 1 ] ;
                    wcsncpy ( 

                        lexicon->value.token , 
                        & stream [ token_start ] , 
                        position - token_start 
                    ) ;

                    lexicon->value.token [ position - token_start ] = 0 ;

                    position -- ;
                }
            }
            break ;

            case HEX_INTEGER_START:
            {
                if ( IsHex ( token ) )
                {
                    datum = HexToDec ( token ) ;
                    state = HEX_INTEGER_START + 1 ;
                }
                else
                {
                    state = REJECT_STATE ;
                }
            }
            break ;

            case HEX_INTEGER_START+1:
            {
                if ( IsHex ( token ) )
                {
                    state = HEX_INTEGER_START + 1 ;

                    if ( datum > magicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( datum == magicMult ) 
                    {
                        if ( HexToDec ( token ) > magicPosDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    datum = ( datum << 4 ) + HexToDec ( token ) ;
                }
                else
                {
                    lexicon->token = WbemLexicon :: INTEGER_ID ;
                    lexicon->value.integer = datum ;
                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }
            break ;

            case OCT_INTEGER_START:
            {
                if ( IsOctal ( token ) )
                {
                    state = OCT_INTEGER_START ;

                    if ( datum > magicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( datum == magicMult ) 
                    {
                        if ( OctToDec ( token ) > magicPosDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    datum = ( datum << 3 ) + OctToDec ( token ) ;

                }
                else
                {
                    lexicon->token = WbemLexicon :: INTEGER_ID ;
                    lexicon->value.integer = datum ;
                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }
            break ;

            case DEC_INTEGER_START:
            {
                if ( IsDecimal ( token ) )
                {
                    state = DEC_INTEGER_START + 1 ;
                    datum = ( token - 48 ) ;
                }
                else 
                if ( IsWhitespace ( token ) ) 
                {
                    state = DEC_INTEGER_START ;
                }
                else state = REJECT_STATE ;
            }   
            break ;

            case DEC_INTEGER_START+1:
            {
                if ( IsDecimal ( token ) )
                {   
                    state = DEC_INTEGER_START + 1 ;

                    if ( datum > magicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( datum == magicMult ) 
                    {
                        if ( negative ) 
                        {
                            if ( ( token - 48 ) > magicNegDigit ) 
                            {
                                state = REJECT_STATE ;
                            }
                        }
                        else
                        {
                            if ( ( token - 48 ) > magicPosDigit ) 
                            {
                                state = REJECT_STATE ;
                            }
                        }
                    }

                    datum = datum * 10 + ( token - 48 ) ;
                }
                else
                {
                    lexicon->token = WbemLexicon :: INTEGER_ID ;
                    if ( negative )
                    {
                        lexicon->value.integer = datum * -1 ;
                    }
                    else
                    {
                        lexicon->value.integer = datum ;
                    }

                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }   
            break ;

            case OID_START:     // {xxxxxxxx
            {
                if ( IsHex ( token ) )
                {
                    hex_datum = hex_datum + ( HexToDec ( token ) << ( ( 7 - hex_repetitions ) << 2 ) ) ;
                    hex_repetitions ++ ;
                    if ( hex_repetitions == 8 ) 
                    {
                        state = OID_START + 1 ;
                        lexicon->value.guid.Data1 = hex_datum ;
                        hex_repetitions = 0 ;
                        hex_datum = 0 ;
                    }
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+1:   // {xxxxxxxx-
            {
                if ( token == L'-' )
                {
                    state = OID_START + 2 ;
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+2:   // {xxxxxxxx-xxxx
            {
                if ( IsHex ( token ) )
                {
                    hex_datum = hex_datum + ( HexToDec ( token ) << ( ( 3 - hex_repetitions ) << 2 ) ) ;
                    hex_repetitions ++ ;
                    if ( hex_repetitions == 4 ) 
                    {
                        lexicon->value.guid.Data2 = ( USHORT ) hex_datum ;
                        hex_repetitions = 0 ;
                        hex_datum = 0 ;
                        state = OID_START + 3 ;
                    }
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+3:   // {xxxxxxxx-xxxx-
            {
                if ( token == L'-' )
                {
                    state = OID_START + 4 ;
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+4:   // {xxxxxxxx-xxxx-xxxx
            {
                if ( IsHex ( token ) )
                {
                    hex_datum = hex_datum + ( HexToDec ( token ) << ( ( 3 - hex_repetitions ) <<2 ) ) ;
                    hex_repetitions ++ ;
                    if ( hex_repetitions == 4 ) 
                    {
                        lexicon->value.guid.Data3 = ( USHORT ) hex_datum ;
                        hex_repetitions = 0 ;
                        hex_datum = 0 ;
                        state = OID_START + 5 ;
                    }
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+5:   // {xxxxxxxx-xxxx-xxxx-
            {
                if ( token == L'-' )
                {
                    state = OID_START + 6 ;
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+6:   // {xxxxxxxx-xxxx-xxxx-xxxx
            {
                if ( IsHex ( token ) )
                {
                    hex_datum = hex_datum + ( HexToDec ( token ) << ( ( 1 - nybbleRepetitions ) << 2 ) ) ;
                    hex_repetitions ++ ;
                    nybbleRepetitions ++ ;

                    if ( hex_repetitions == 2 ) 
                    {
                        lexicon->value.guid.Data4 [ 0 ] = ( char ) hex_datum ;
                        hex_datum = 0 ;
                        nybbleRepetitions = 0 ;
                    }                       
                    else if ( hex_repetitions == 4 ) 
                    {
                        lexicon->value.guid.Data4 [ 1 ] = ( char ) hex_datum ;
                        hex_repetitions = 0 ;
                        hex_datum = 0 ;
                        nybbleRepetitions = 0 ;
                        state = OID_START + 7 ;
                    }
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+7:   // {xxxxxxxx-xxxx-xxxx-xxxx-
            {
                if ( token == L'-' )
                {
                    state = OID_START + 8 ;
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+8:   // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
            {
                if ( IsHex ( token ) )
                {
                    hex_datum = hex_datum + ( HexToDec ( token ) << ( ( 1 - nybbleRepetitions ) << 2 ) ) ;
                    hex_repetitions ++ ;
                    nybbleRepetitions ++ ;

                    if ( hex_repetitions == 12 ) 
                    {
                        lexicon->value.guid.Data4 [ 7 ] = ( char ) hex_datum ;
                        hex_repetitions = 0 ;
                        nybbleRepetitions = 0 ;
                        hex_datum = 0 ;
                        state = OID_START + 9 ;
                    }
                    else if ( hex_repetitions % 2 == 0 ) 
                    {
                        lexicon->value.guid.Data4 [ 1 + ( hex_repetitions >> 1 ) ] = ( char ) hex_datum ;
                        hex_datum = 0 ;
                        nybbleRepetitions = 0 ;
                    }                       
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+9:   // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
            {
                if ( token == L'}' )
                {
                    lexicon->token = WbemLexicon :: OID_ID ;                
                    state = ACCEPT_STATE ;
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case ACCEPT_STATE:
            case REJECT_STATE:
            default:
            {
                state = REJECT_STATE ;
            } ;
            break ;
        }

        position ++ ;
    }

    status = ( state != REJECT_STATE ) ;

    return lexicon ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provexpt\ansi\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provexpt\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\pathprsr\namepath.cpp ===
//***************************************************************************

//

//  NAMEPATH.CPP

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provtempl.h>
#include <provmt.h>
#include <instpath.h>
#include <strsafe.h>

static wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix )
{
    int prefixTextLength = 0 ;
    if ( prefix )
    {
        prefixTextLength = wcslen ( prefix ) ;
    }

    int suffixTextLength = 0 ;
    if ( suffix )
    {
        suffixTextLength = wcslen ( suffix ) ;
    }

    if ( prefix || suffix )
    {
        int textLength = prefixTextLength + suffixTextLength ;
        wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;

        if ( prefix )
        {
            StringCchCopyW ( textBuffer , textLength + 1 , prefix ) ;
        }

        if ( suffix )
        {
            StringCchCopyW ( & textBuffer [ prefixTextLength ] , suffixTextLength + 1 , suffix ) ;
        }

        return textBuffer ;
    }   
    else
        return NULL ;
}

static wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) 
{
    if ( string )
    {
        int textLength = wcslen ( string ) ;

        wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;
        StringCchCopyW ( textBuffer , textLength + 1 , string ) ;

        return textBuffer ;
    }
    else
    {
        return NULL ;
    }
}

WbemNamespacePath :: WbemNamespacePath () : status ( FALSE ) ,
                                            pushedBack ( FALSE ) ,
                                            pushBack ( NULL ) ,
                                            server ( NULL ) ,
                                            relative ( FALSE ) ,
                                            nameSpaceListPosition ( NULL ) 
{
    nameSpaceList = new CList <wchar_t * , wchar_t * >  ;
}

void WbemNamespacePath :: SetUp () 
{
    status = FALSE ;
    pushedBack = FALSE ;
    pushBack = NULL ;
    server = NULL ;
    relative = FALSE ;
    nameSpaceListPosition = NULL ;
    nameSpaceList = new CList <wchar_t * , wchar_t * >  ;
}

WbemNamespacePath :: WbemNamespacePath (

    const WbemNamespacePath &nameSpacePathArg 

) : status ( FALSE ) ,
    pushedBack ( FALSE ) ,
    pushBack ( NULL ) ,
    server ( NULL ) ,
    relative ( FALSE ) ,
    nameSpaceListPosition ( NULL ) 
{
    nameSpaceList = new CList <wchar_t * , wchar_t * >  ;
    CList <wchar_t * , wchar_t *> *nameList = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
    CList <wchar_t * , wchar_t *> *copyNameList = ( CList <wchar_t * , wchar_t *> * ) nameSpacePathArg.nameSpaceList ;

    POSITION position = copyNameList->GetHeadPosition () ;
    while ( position )
    {
        wchar_t *name = copyNameList->GetNext ( position ) ;
        nameList->AddTail ( UnicodeStringDuplicate ( name ) ) ;
    }

    server = UnicodeStringDuplicate ( nameSpacePathArg.server ) ;
}

WbemNamespacePath :: ~WbemNamespacePath () 
{
    CleanUp () ;
}

void WbemNamespacePath :: CleanUp () 
{
	if ( nameSpaceList )
	{
		CList <wchar_t * , wchar_t *> *nameList = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
		POSITION position = nameList->GetHeadPosition () ;
		while ( position )
		{
			wchar_t *value = nameList->GetNext ( position ) ;   
			delete [] value ;
		}

		nameList->RemoveAll () ;

		delete ( CList <wchar_t * , wchar_t * > * ) nameSpaceList ;
		nameSpaceList = NULL ;
	}

	if ( pushBack )
	{
		delete pushBack ;
		pushBack = NULL ;
	}

	if ( server )
	{
		delete [] server ;
		server = NULL ;
	}

    relative = FALSE ;
}

BOOL WbemNamespacePath :: IsEmpty () const
{
    CList <wchar_t * , wchar_t *> *list = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
    return list->IsEmpty () ;
} 

ULONG WbemNamespacePath :: GetCount () const
{
    CList <wchar_t * , wchar_t *> *list = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
    return list->GetCount () ;
} 

void WbemNamespacePath :: Reset ()
{
    CList <wchar_t * , wchar_t *> *list = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
    nameSpaceListPosition = list->GetHeadPosition () ;
}

wchar_t *WbemNamespacePath :: Next () 
{
    wchar_t *value = NULL ;
    POSITION position = ( POSITION ) nameSpaceListPosition ;
    if ( position ) 
    {
        CList <wchar_t * , wchar_t *> *list = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
        value = list->GetNext ( position ) ;
        nameSpaceListPosition = position ;
    }
    return value ;
}

void WbemNamespacePath :: SetServer ( wchar_t *serverArg ) 
{
    delete [] server ;
	DWORD t_TextLength = wcslen ( serverArg) + 1 ;
    server = new wchar_t [ t_TextLength ] ;
    StringCchCopyW ( server , t_TextLength , serverArg ) ;
}

void WbemNamespacePath :: Add ( wchar_t *nameSpace ) 
{
    CList <wchar_t * , wchar_t * > *list = ( CList <wchar_t * , wchar_t * > * ) nameSpaceList ;
    list->AddTail ( nameSpace ) ;
}

WbemNamespacePath :: operator void *() 
{
    return status ? this : NULL ;
}

wchar_t *WbemNamespacePath :: GetNamespacePath ()
{
    if ( status ) 
    {
        wchar_t *path = NULL ;

        if ( GetServer () )
        {
            path = UnicodeStringDuplicate ( L"\\\\" ) ;
            wchar_t *concatPath = UnicodeStringAppend ( path , GetServer () ) ;
            delete [] path ;
            path = concatPath ;
        }

        if ( ! Relative () )
        {
            wchar_t *concatPath = UnicodeStringAppend ( path , L"\\" ) ;
            delete [] path ;
            path = concatPath ;
        }
        
        wchar_t *pathComponent ;

        ULONG t_ComponentCount = 0 ;
        Reset () ;
        while ( pathComponent = Next () )
        {
            wchar_t *concatPath = NULL ;

            t_ComponentCount ++ ;
            if ( t_ComponentCount != GetCount () )
            {
                
                wchar_t *t_Temp = UnicodeStringAppend ( path , pathComponent ) ;
                concatPath = UnicodeStringAppend ( t_Temp , L"\\" ) ;
                delete [] t_Temp ;
            }
            else
            {
                concatPath = UnicodeStringAppend ( path , pathComponent ) ;
            }

            delete [] path ;
            path = concatPath ;
        }

        return path ;
    }
    else
        return NULL ;
}

BOOL WbemNamespacePath :: ConcatenatePath ( WbemNamespacePath &relative )
{
    BOOL status = FALSE ;
    
    if ( relative.Relative () )
    {
        status = TRUE ;

        relative.Reset () ;
        wchar_t *namespaceComponent ;
        while ( namespaceComponent = Next () )
        {
            Add ( UnicodeStringDuplicate ( namespaceComponent ) ) ;
        }
    }

    return status ;
}

void WbemNamespacePath :: PushBack ()
{
    pushedBack = TRUE ;
}

WbemLexicon *WbemNamespacePath :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = analyser.Get () ;
    }

    return pushBack ;
}
    
WbemLexicon *WbemNamespacePath :: Match ( WbemLexicon :: LexiconToken tokenType )
{
    WbemLexicon *lexicon = Get () ;
    status = ( lexicon->GetToken () == tokenType ) ;
    return status ? lexicon : NULL ;
}

BOOL WbemNamespacePath :: SetNamespacePath ( wchar_t *tokenStream )
{
    CleanUp () ;
    SetUp () ;

    analyser.Set ( tokenStream ) ;

    status = TRUE ;

    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: DOT_ID:
        {
            PushBack () ;
            NameSpaceRel () ;
        }
        break ;

        case WbemLexicon :: TOKEN_ID:
        {
            PushBack () ;
            NameSpaceRel () ;
        }
        break ;

        case WbemLexicon :: BACKSLASH_ID:
        {
            PushBack () ;
            BackSlashFactoredServerNamespace () ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    Match ( WbemLexicon :: EOF_ID ) ;

    return status ;
} 

BOOL WbemNamespacePath :: BackSlashFactoredServerNamespace ()
{
    if ( Match ( WbemLexicon :: BACKSLASH_ID ) )
    {
        WbemLexicon *lookAhead = Get () ;
        switch ( lookAhead->GetToken () ) 
        {
            case WbemLexicon :: BACKSLASH_ID:
            {
                PushBack () ;
                BackSlashFactoredServerSpec () ;
            }
            break ;

            case WbemLexicon :: DOT_ID:
            {
                PushBack () ;
                NameSpaceRel () ;
            }
            break ;

            case WbemLexicon :: TOKEN_ID:
            {
                PushBack () ;
                NameSpaceRel () ;
            }
            break ;

            default:
            {
                status = FALSE ;
            }
        }
    }

    return status ;
}

BOOL WbemNamespacePath :: BackSlashFactoredServerSpec ()
{
    if ( Match ( WbemLexicon :: BACKSLASH_ID ) )
    {
        WbemLexicon *lookAhead = Get () ;
        switch ( lookAhead->GetToken () ) 
        {
            case WbemLexicon :: DOT_ID:
            {
                PushBack () ;
                WbemLexicon *token ;
                if ( token = Match ( WbemLexicon :: DOT_ID ) )
                {
                    SetServer ( L"." ) ;

                    WbemLexicon *lookAhead = Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case WbemLexicon :: BACKSLASH_ID:
                        {
                            PushBack () ;
                            NameSpaceAbs () ;
                        }
                        break ;

                        case WbemLexicon :: EOF_ID:
                        {
                            PushBack () ;
                        }
                        break ;

                        default:
                        {
                            status = FALSE ;
                        }
                    }
                }
            }
            break ;

            case WbemLexicon :: TOKEN_ID:
            {
                PushBack () ;
                WbemLexicon *token ;
                if ( token = Match ( WbemLexicon :: TOKEN_ID ) )
                {
                    SetServer ( token->GetValue ()->token ) ;

                    WbemLexicon *lookAhead = Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case WbemLexicon :: BACKSLASH_ID:
                        {
                            PushBack () ;
                            NameSpaceAbs () ;
                        }
                        break ;

                        case WbemLexicon :: EOF_ID:
                        {
                            PushBack () ;
                        }
                        break ;

                        default:
                        {
                            status = FALSE ;
                        }
                    }
                }
            }
            break ;

            default:
            {
                status = FALSE ;
            }
            break ;
        }
    }

    return status ;
}

BOOL WbemNamespacePath :: NameSpaceName ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: TOKEN_ID:
        {
            PushBack () ;
            WbemLexicon *token ;
            if ( token = Match ( WbemLexicon :: TOKEN_ID ) )
            {
                wchar_t *namespaceValue = token->GetValue ()->token ;

				if ( namespaceValue )
				{
					DWORD t_TextLength = wcslen ( namespaceValue ) + 1 ;
					wchar_t *copy = new wchar_t [ t_TextLength ] ;
					StringCchCopyW ( copy , t_TextLength , namespaceValue ) ;

					Add ( copy ) ;
				}
				else
				{
					status = FALSE ;
				}
            }
        }
        break ;

        case WbemLexicon :: DOT_ID:
        {
            PushBack () ;
            WbemLexicon *token ;
            if ( token = Match ( WbemLexicon :: DOT_ID ) )
            {
				DWORD t_TextLength = wcslen ( L"." ) + 1 ;
                wchar_t *copy = new wchar_t [ t_TextLength ] ;
                StringCchCopyW ( copy , t_TextLength , L"." ) ;

                Add ( copy ) ;
            }
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL WbemNamespacePath :: NameSpaceRel ()
{
    relative = TRUE ;

    NameSpaceName () &&
    RecursiveNameSpaceRel () ;
    
    return status ;
}

BOOL WbemNamespacePath :: RecursiveNameSpaceRel ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: BACKSLASH_ID:
        {
            PushBack () ;
            Match ( WbemLexicon :: BACKSLASH_ID ) &&            
            NameSpaceRel () ;
        }
        break ;

        case WbemLexicon :: EOF_ID:
        {
            PushBack () ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
    }

    return status ;

}

BOOL WbemNamespacePath :: NameSpaceAbs ()
{
    Match ( WbemLexicon :: BACKSLASH_ID ) &&
    NameSpaceName () &&
    RecursiveNameSpaceAbs () ;

    return status ;
}

BOOL WbemNamespacePath :: RecursiveNameSpaceAbs ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: BACKSLASH_ID:
        {
            PushBack () ;

            Match ( WbemLexicon :: BACKSLASH_ID ) &&
            NameSpaceName () &&
            RecursiveNameSpaceAbs () ;
        }
        break ;

        case WbemLexicon :: EOF_ID:
        {
            PushBack () ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
    }

    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\pathprsr\include\instpath.h ===
//***************************************************************************

//

//  INSTPATH.H

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#define OLEMS_PATH_SERVER_SEPARATOR L"\\\\"
#define OLEMS_PATH_NAMESPACE_SEPARATOR L"\\"
#define OLEMS_PATH_PROPERTY_SEPARATOR L","
#define OLEMS_PATH_CLASSOBJECT_SEPARATOR L":"
#define OLEMS_PATH_CLASSPROPERTYSPEC_SEPARATOR L"."
#define OLEMS_PATH_PROPERTYEQUIVALENCE L"="
#define OLEMS_PATH_ARRAY_START_SEPARATOR L"{"
#define OLEMS_PATH_ARRAY_END_SEPARATOR L"}"
#define OLEMS_PATH_SERVER_DEFAULT L"."
#define OLEMS_PATH_NAMESPACE_DEFAULT L"."
#define OLEMS_PATH_SINGLETON L"*"

//---------------------------------------------------------------------------
//
//	Class:		WbemLexiconValue
//
//  Purpose:	WbemLexiconValue provides a lexical token semantic value.
//
//  Description:	WbemAnalyser provides an implementation of a lexical 
//					analyser token semantic value
//
//---------------------------------------------------------------------------

union WbemLexiconValue
{
	LONG integer ;
	WCHAR *string ;
	GUID guid ;
	WCHAR *token ;
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemLexicon
//
//  Purpose:	WbemLexicon provides a lexical token creating during
//				lexical analysis.
//
//  Description:	WbemAnalyser provides an implementation of a lexical 
//					analyser token object
//
//---------------------------------------------------------------------------

class WbemAnalyser;
class WbemLexicon
{
friend WbemAnalyser ;

public:

enum LexiconToken {

	TOKEN_ID ,
	STRING_ID ,
	OID_ID ,
	INTEGER_ID ,
	COMMA_ID ,
	OPEN_BRACE_ID ,
	CLOSE_BRACE_ID ,
	COLON_ID ,
	DOT_ID ,
	AT_ID ,
	EQUALS_ID ,
	BACKSLASH_ID ,
	EOF_ID
} ;

private:

	WCHAR *tokenStream ;
	ULONG position ;
	LexiconToken token ;
	WbemLexiconValue value ;

protected:
public:

	WbemLexicon () ;
	~WbemLexicon () ;

	WbemLexicon :: LexiconToken GetToken () ;
	WbemLexiconValue *GetValue () ;
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemAnalyser
//
//  Purpose:	WbemAnalyser provides a lexical analyser for parsing.
//
//  Description:	WbemAnalyser provides an implementation of a lexical 
//					analyser used by WbemNamespacePath and WbemObjectPath
//					classes during path parsing.
//
//---------------------------------------------------------------------------

class WbemAnalyser
{
private:

	WCHAR *stream ;
	ULONG position ;
	BOOL status ;

	BOOL IsEof ( WCHAR token ) ;
	BOOL IsLeadingDecimal ( WCHAR token ) ;
	BOOL IsDecimal ( WCHAR token ) ;
	BOOL IsOctal ( WCHAR token ) ;
	BOOL IsHex ( WCHAR token ) ;	
	BOOL IsAlpha ( WCHAR token ) ;
	BOOL IsAlphaNumeric ( WCHAR token ) ;
	BOOL IsWhitespace ( WCHAR token ) ;

	LONG OctToDec ( WCHAR token ) ;
	LONG HexToDec ( WCHAR token ) ;

	WbemLexicon *GetToken () ;

protected:
public:

	WbemAnalyser ( WCHAR *tokenStream = NULL ) ;
	virtual ~WbemAnalyser () ;

	void Set ( WCHAR *tokenStream ) ;

	WbemLexicon *Get () ;

	void PutBack ( WbemLexicon *token ) ;

	virtual operator void * () ;

} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemNamespacePath
//
//  Purpose:	Defines interface for OLE MS namespace path definitions.
//
//  Description:	WbemNamespacePath allows the creation of an OLE MS namespace
//					path definition using either a textual string convention or 
//					via a programmatic interface.
//
//---------------------------------------------------------------------------

class WbemNamespacePath
{
private:

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	WbemAnalyser analyser ;
	WbemLexicon *pushBack ;

//
//	Status of the object path based on parsing process. Initially set to TRUE on 
//	object construction, set to FALSE prior to parsing process.
//

	BOOL status ;

//
//	component objects associated with namespace path
//

	BOOL relative ;
	WCHAR *server ;
	void *nameSpaceList ;
	void *nameSpaceListPosition ;

//
//	Utility Routines
//

	void CleanUp () ;
	void SetUp () ;

//
//	Recursive descent procedures
//

	BOOL NameSpaceName () ;
	BOOL NameSpaceAbs () ;
	BOOL RecursiveNameSpaceAbs () ;
	BOOL RecursiveNameSpaceRel () ;
	BOOL NameSpaceRel () ;
	BOOL BackSlashFactoredServerSpec () ;
	BOOL BackSlashFactoredServerNamespace () ;

//
//	Lexical analysis helper functions
//

	void PushBack () ;
	WbemLexicon *Get () ;
	WbemLexicon *Match ( WbemLexicon :: LexiconToken tokenType ) ;

protected:
public:

//
//	Constructor/Destructor.
//	Constructor initialises status of object to TRUE, 
//	i.e. operator void* returns this.
//

	WbemNamespacePath () ;
	WbemNamespacePath ( const WbemNamespacePath &nameSpacePathArg ) ;
	virtual ~WbemNamespacePath () ;

	BOOL Relative () const { return relative ; }

//
//	Get server component
//

	WCHAR *GetServer () const { return server ; } ;

//
//	Set server component, object must be on heap,
//	deletion of object is under control of WbemNamespacePath.
//

	void SetServer ( WCHAR *serverNameArg ) ;

//
//	Move to position prior to first element of namespace component hierarchy
//

	void Reset () ;

//
//	Move to next position in namespace component hierarchy and return namespace
//	component. Value returned is a reference to the actual component within the 
//	namespace component hierarchy container. Applications must not change contents
//	of value returned by reference. Next returns NULL when all namespace components
//	have been visited.
//

	WCHAR *Next () ;

	BOOL IsEmpty () const ;

	ULONG GetCount () const ;	

//
//	Append namespace component, object must be on heap,
//	deletion of object is under control of WbemNamespacePath.
//

	void Add ( WCHAR *namespacePath ) ;

//
//	Parse token stream to form component objects
//

	BOOL SetNamespacePath ( WCHAR *namespacePath ) ;

	void SetRelative ( BOOL relativeArg ) { relative = relativeArg ; }

//
//	Serialise component objects to form token stream
//

	WCHAR *GetNamespacePath () ;

// 
// Concatenate Absolute/Relative path with Relative path
//

	BOOL ConcatenatePath ( WbemNamespacePath &relative ) ;

//
//	Return status of WbemNamespacePath.
//	Status can only change during a call to SetNamespacePath.
//

	virtual operator void *() ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provexpt\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#include <ole2.h>
#include <windows.h>
#include <eh.h>
#include <provexpt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provexpt\provexpt.cpp ===
//***************************************************************************

//

//  PROVEXPT.CPP

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <malloc.h>

#ifdef COMMONALLOC

#include <corepol.h>
#include <arena.h>

#endif

#ifdef THROW_AFTER_N_NEW

UINT g_test = 0;

void *operator new( size_t n)
{
    void *ptr = (void*) LocalAlloc(LMEM_FIXED, n);

    if (ptr && (g_test < 250))
    {
        g_test++;
    }
    else
    {
        g_test = 0;
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}
#else //THROW_AFTER_N_NEW

#ifdef COMMONALLOC

void *operator new( size_t n)
{
    void *ptr = (void*) CWin32DefaultArena::WbemMemAlloc(n);

    if (!ptr)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}

#else

void* __cdecl operator new( size_t n)
{
    void *ptr = malloc( n );

    if (!ptr)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}

void* __cdecl operator new[]( size_t n)
{
    void *ptr = malloc( n );

    if (!ptr)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}

#endif // COMMONALLOC

#endif //THROW_AFTER_N_NEW

#ifdef COMMONALLOC

void operator delete( void *ptr )
{
    if (ptr)
    {
        CWin32DefaultArena::WbemMemFree(ptr);
    }
}

#else

void __cdecl operator delete( void *ptr )
{
    if (ptr)
    {
        free( ptr );
    }
}

void __cdecl operator delete[]( void *ptr )
{
    if (ptr)
    {
        free( ptr );
    }
}

#endif //COMMONALLOC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provexpt\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################


!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=provexpt
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES); \
	$(FRAMEWORK_EXPT_INC)

SOURCES= \
	..\provexpt.cpp

C_DEFINES=$(C_DEFINES) 
USE_RTTI=1
USE_NATIVE_EH=ASYNC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provexpt\include\provexpt.h ===
//***************************************************************************

//

//	PROVEXPT.H

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _PROVIDER_NEW_DELETE_EXCEPT_H
#define _PROVIDER_NEW_DELETE_EXCEPT_H

#include <eh.h>

void * __cdecl operator new( size_t n);
void* __cdecl operator new[]( size_t n);
void __cdecl operator delete( void *ptr );
void __cdecl operator delete[]( void *ptr );

//taken from new.h
#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
	{return; }
#endif
#endif

class CurveBall
{
private:
    UINT nSE;
	EXCEPTION_POINTERS* m_pExp;

public:
    CurveBall() {}
    CurveBall( UINT n, EXCEPTION_POINTERS* pExp ) : nSE( n ), m_pExp( pExp ) {}
    ~CurveBall() {}
    UINT GetSENumber() { return nSE; }
	EXCEPTION_POINTERS* GetExtendedInfo() { return m_pExp; }
};

class Structured_Exception
{
private:
    UINT nSE;
	EXCEPTION_POINTERS* m_pExp;

public:
    Structured_Exception() {}
    Structured_Exception( UINT n, EXCEPTION_POINTERS* pExp ) : nSE( n ), m_pExp( pExp ) {}
    ~Structured_Exception() {}
    UINT GetSENumber() { return nSE; }
	EXCEPTION_POINTERS* GetExtendedInfo() { return m_pExp; }
};

class SetStructuredExceptionHandler
{
private:

	_se_translator_function m_PrevFunc;

public:
	static void __cdecl trans_func( UINT u, EXCEPTION_POINTERS* pExp )
	{
#ifdef CRASH_ON_EXCEPTION
		throw CurveBall(u, pExp);
#else
		throw Structured_Exception(u, pExp);
#endif
	}

	SetStructuredExceptionHandler() : m_PrevFunc(NULL)
	{
		m_PrevFunc = _set_se_translator( trans_func );
	}

	~SetStructuredExceptionHandler()
	{
		_set_se_translator( m_PrevFunc );
	}
};

class Heap_Exception
{
public:
	enum HEAP_ERROR
	{
		E_ALLOCATION_ERROR = 0,
		E_FREE_ERROR
	};

private:
	HEAP_ERROR m_Error;

public:
	Heap_Exception(HEAP_ERROR e) : m_Error(e) {}
	~Heap_Exception() {}
	HEAP_ERROR GetError() { return m_Error; }
};

template<typename T>
void realloc_throw(T ** ptr, size_t size)
{
	T * tmp = (T*)realloc (*ptr, size);
	if (tmp == 0)
	{
		free (*ptr);
		*ptr = 0;
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	};
	*ptr = tmp;
};



#endif //_PROVIDER_NEW_DELETE_EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\array_o.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <provcoll.h>
#include "provmt.h"
#include "plex.h"

CObArray::CObArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CObArray::~CObArray()
{
    delete[] (BYTE*)m_pData;
}

void CObArray::SetSize(int nNewSize, int nGrowBy)
{
    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        delete[] (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
        m_pData = (CObject**) new BYTE[nNewSize * sizeof(CObject*)];

        memset(m_pData, 0, nNewSize * sizeof(CObject*));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(CObject*));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        CObject** pNewData = (CObject**) new BYTE[nNewMax * sizeof(CObject*)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(CObject*));

        // construct remaining elements
        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(CObject*));


        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

int CObArray::Append(const CObArray& src)
{
    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);

    memcpy(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(CObject*));

    return nOldSize;
}

void CObArray::Copy(const CObArray& src)
{
    SetSize(src.m_nSize);

    memcpy(m_pData, src.m_pData, src.m_nSize * sizeof(CObject*));
}

void CObArray::FreeExtra()
{
    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
        CObject** pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (CObject**) new BYTE[m_nSize * sizeof(CObject*)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(CObject*));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CObArray::SetAtGrow(int nIndex, CObject* newElement)
{
    if (nIndex >= m_nSize)
        SetSize(nIndex+1);
    m_pData[nIndex] = newElement;
}

void CObArray::InsertAt(int nIndex, CObject* newElement, int nCount)
{
    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(CObject*));

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(CObject*));

    }

    // insert new value in the gap
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CObArray::RemoveAt(int nIndex, int nCount)
{
    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(CObject*));
    m_nSize -= nCount;
}

void CObArray::InsertAt(int nStartIndex, CObArray* pNewArray)
{
    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

int CObArray::GetSize() const
    { return m_nSize; }
int CObArray::GetUpperBound() const
    { return m_nSize-1; }
void CObArray::RemoveAll()
    { SetSize(0); }
CObject* CObArray::GetAt(int nIndex) const
    { return m_pData[nIndex]; }
void CObArray::SetAt(int nIndex, CObject* newElement)
    { m_pData[nIndex] = newElement; }
CObject*& CObArray::ElementAt(int nIndex)
    { return m_pData[nIndex]; }
const CObject** CObArray::GetData() const
    { return (const CObject**)m_pData; }
CObject** CObArray::GetData()
    { return (CObject**)m_pData; }
int CObArray::Add(CObject* newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
CObject* CObArray::operator[](int nIndex) const
    { return GetAt(nIndex); }
CObject*& CObArray::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\mtex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <provcoll.h>
#include "provmt.h"
#include "plex.h"

bool CStaticCriticalSection::failureSet = false ;

/////////////////////////////////////////////////////////////////////////////
// CSemaphore

CSemaphore::CSemaphore(LONG lInitialCount, LONG lMaxCount,
    LPCTSTR pstrName, LPSECURITY_ATTRIBUTES lpsaAttributes)
    :  CSyncObject(pstrName)
{
    m_hObject = ::CreateSemaphore(lpsaAttributes, lInitialCount, lMaxCount,
        pstrName);
}

CSemaphore::~CSemaphore()
{
}

BOOL CSemaphore::Unlock(LONG lCount, LPLONG lpPrevCount /* =NULL */)
{
    return ::ReleaseSemaphore(m_hObject, lCount, lpPrevCount);
}

/////////////////////////////////////////////////////////////////////////////
// CMutex

CMutex::CMutex(BOOL bInitiallyOwn, LPCTSTR pstrName,
    LPSECURITY_ATTRIBUTES lpsaAttribute /* = NULL */)
    : CSyncObject(pstrName)
{
    m_hObject = ::CreateMutex(lpsaAttribute, bInitiallyOwn, pstrName);
}

CMutex::~CMutex()
{
}

BOOL CMutex::Unlock()
{
    return ::ReleaseMutex(m_hObject);
}

/////////////////////////////////////////////////////////////////////////////
// CEvent

CEvent::CEvent(BOOL bInitiallyOwn, BOOL bManualReset, LPCTSTR pstrName,
    LPSECURITY_ATTRIBUTES lpsaAttribute)
    : CSyncObject(pstrName)
{
    m_hObject = ::CreateEvent(lpsaAttribute, bManualReset,
        bInitiallyOwn, pstrName);
}

CEvent::~CEvent()
{
}

BOOL CEvent::Unlock()
{
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSingleLock

CSingleLock::CSingleLock(CSyncObject* pObject, BOOL bInitialLock)
{
    m_pObject = pObject;
    m_hObject = pObject->m_hObject;
    m_bAcquired = FALSE;

    if (bInitialLock)
        Lock();
}

BOOL CSingleLock::Lock(DWORD dwTimeOut /* = INFINITE */)
{
    m_bAcquired = m_pObject->Lock(dwTimeOut);
    return m_bAcquired;
}

BOOL CSingleLock::Unlock()
{
    if (m_bAcquired)
        m_bAcquired = !m_pObject->Unlock();

    // successfully unlocking means it isn't acquired
    return !m_bAcquired;
}

BOOL CSingleLock::Unlock(LONG lCount, LPLONG lpPrevCount /* = NULL */)
{
    if (m_bAcquired)
        m_bAcquired = !m_pObject->Unlock(lCount, lpPrevCount);

    // successfully unlocking means it isn't acquired
    return !m_bAcquired;
}

/////////////////////////////////////////////////////////////////////////////
// CMultiLock

#define _countof(array) (sizeof(array)/sizeof(array[0]))

CMultiLock::CMultiLock(CSyncObject* pObjects[], DWORD dwCount,
                       BOOL bInitialLock) : m_pHandleArray ( NULL ) , m_bLockedArray ( NULL )
{
    m_ppObjectArray = pObjects;
    m_dwCount = dwCount;

    // as an optimization, skip alloacating array if
    // we can use a small, predeallocated bunch of handles

    if (m_dwCount > _countof(m_hPreallocated))
    {
        m_pHandleArray = new HANDLE[m_dwCount];
        m_bLockedArray = new BOOL[m_dwCount];
    }
    else
    {
        m_pHandleArray = m_hPreallocated;
        m_bLockedArray = m_bPreallocated;
    }

    // get list of handles from array of objects passed
    for (DWORD i = 0; i <m_dwCount; i++)
    {
        m_pHandleArray[i] = pObjects[i]->m_hObject;
        m_bLockedArray[i] = FALSE;
    }

    if (bInitialLock)
        Lock();
}

CMultiLock::~CMultiLock()
{
    Unlock();
    if (m_pHandleArray != m_hPreallocated)
    {
        delete[] m_bLockedArray;
        delete[] m_pHandleArray;
    }
}

DWORD CMultiLock::Lock(DWORD dwTimeOut /* = INFINITE */,
        BOOL bWaitForAll /* = TRUE */, DWORD dwWakeMask /* = 0 */)
{
    DWORD dwResult;
    if (dwWakeMask == 0)
        dwResult = ::WaitForMultipleObjects(m_dwCount,
            m_pHandleArray, bWaitForAll, dwTimeOut);
    else
        dwResult = ::MsgWaitForMultipleObjects(m_dwCount,
            m_pHandleArray, bWaitForAll, dwTimeOut, dwWakeMask);

    if (dwResult < (WAIT_OBJECT_0 + m_dwCount))
    {
        if (bWaitForAll)
        {
            for (DWORD i = 0; i < m_dwCount; i++)
                m_bLockedArray[i] = TRUE;
        }
        else
        {
            m_bLockedArray[dwResult - WAIT_OBJECT_0] = TRUE;
        }
    }
    return dwResult;
}

BOOL CMultiLock::Unlock()
{
    for (DWORD i=0; i < m_dwCount; i++)
    {
        if (m_bLockedArray[i])
            m_bLockedArray[i] = !m_ppObjectArray[i]->Unlock();
    }
    return TRUE;
}

BOOL CMultiLock::Unlock(LONG lCount, LPLONG lpPrevCount /* =NULL */)
{
    BOOL bGotOne = FALSE;
    for (DWORD i=0; i < m_dwCount; i++)
    {
        if (m_bLockedArray[i])
        {
            CSemaphore* pSemaphore = ( CSemaphore *) m_ppObjectArray[i];
            if (pSemaphore != NULL)
            {
                bGotOne = TRUE;
                m_bLockedArray[i] = !m_ppObjectArray[i]->Unlock(lCount, lpPrevCount);
            }
        }
    }

    return bGotOne;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\mtcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <provcoll.h>
#include "provmt.h"
#include "plex.h"

/////////////////////////////////////////////////////////////////////////////
// Basic synchronization object

CSyncObject::CSyncObject(LPCTSTR pstrName)
{
    m_hObject = NULL;
}

CSyncObject::~CSyncObject()
{
    if (m_hObject != NULL)
    {
        ::CloseHandle(m_hObject);
        m_hObject = NULL;
    }
}

BOOL CSyncObject::Lock(DWORD dwTimeout)
{
    if (::WaitForSingleObject(m_hObject, dwTimeout) == WAIT_OBJECT_0)
        return TRUE;
    else
        return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\list_o.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized List
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <provcoll.h>
#include "provmt.h"
#include "plex.h"

/////////////////////////////////////////////////////////////////////////////

CObList::CObList(int nBlockSize)
{
    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

void CObList::RemoveAll()
{
    // destroy elements

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

CObList::~CObList()
{
    RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
/*
 * Implementation note: CNode's are stored in CPlex blocks and
 *  chained together. Free blocks are maintained in a singly linked list
 *  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
 *  Used blocks are maintained in a doubly linked list using both 'pNext'
 *  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
 *   as the head/tail.
 *
 * We never free a CPlex block unless the List is destroyed or RemoveAll()
 *  is used - so the total number of CPlex blocks may grow large depending
 *  on the maximum past size of the list.
 */

CObList::CNode*
CObList::NewNode(CObList::CNode* pPrev, CObList::CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }

    CObList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;

    pNode->data = 0; // start with zero

    return pNode;
}

void CObList::FreeNode(CObList::CNode* pNode)
{
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////

POSITION CObList::AddHead(CObject* newElement)
{
    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (POSITION) pNewNode;
}

POSITION CObList::AddTail(CObject* newElement)
{
    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (POSITION) pNewNode;
}

void CObList::AddHead(CObList* pNewList)
{
    // add a list of same elements to head (maintain order)
    POSITION pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

void CObList::AddTail(CObList* pNewList)
{
    // add a list of same elements
    POSITION pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

CObject* CObList::RemoveHead()
{
    CNode* pOldNode = m_pNodeHead;
    CObject* returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

CObject* CObList::RemoveTail()
{
    CNode* pOldNode = m_pNodeTail;
    CObject* returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

POSITION CObList::InsertBefore(POSITION position, CObject* newElement)
{
    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (POSITION) pNewNode;
}

POSITION CObList::InsertAfter(POSITION position, CObject* newElement)
{
    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (POSITION) pNewNode;
}

void CObList::RemoveAt(POSITION position)
{
    CNode* pOldNode = (CNode*) position;

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}


/////////////////////////////////////////////////////////////////////////////
// slow operations

POSITION CObList::FindIndex(int nIndex) const
{
    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        pNode = pNode->pNext;
    }
    return (POSITION) pNode;
}

POSITION CObList::Find(CObject* searchValue, POSITION startAfter) const
{
    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (pNode->data == searchValue)
            return (POSITION) pNode;
    return NULL;
}


int CObList::GetCount() const
    { return m_nCount; }
BOOL CObList::IsEmpty() const
    { return m_nCount == 0; }
CObject*& CObList::GetHead()
    { return m_pNodeHead->data; }
CObject* CObList::GetHead() const
    { return m_pNodeHead->data; }
CObject*& CObList::GetTail()
    { return m_pNodeTail->data; }
CObject* CObList::GetTail() const
    { return m_pNodeTail->data; }
POSITION CObList::GetHeadPosition() const
    { return (POSITION) m_pNodeHead; }
POSITION CObList::GetTailPosition() const
    { return (POSITION) m_pNodeTail; }
CObject*& CObList::GetNext(POSITION& rPosition) // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
CObject* CObList::GetNext(POSITION& rPosition) const // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
CObject*& CObList::GetPrev(POSITION& rPosition) // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
CObject* CObList::GetPrev(POSITION& rPosition) const // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
CObject*& CObList::GetAt(POSITION position)
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
CObject* CObList::GetAt(POSITION position) const
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
void CObList::SetAt(POSITION pos, CObject* newElement)
    { CNode* pNode = (CNode*) pos;
        pNode->data = newElement; }


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\plex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <provcoll.h>
#include "provmt.h"
#include "plex.h"

CPlex* CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
    CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
            // may throw exception
    p->nMax = nMax;
    p->nCur = 0;
    p->pNext = pHead;
    pHead = p;  // change head (adds in reverse order for simplicity)
    return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
    CPlex* p = this;
    while (p != NULL)
    {
        BYTE* bytes = (BYTE*) p;
        CPlex* pNext = p->pNext;
        delete bytes;
        p = pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################


WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=provmfc
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES); \
	$(FRAMEWORK_EXPT_INC); \
	$(FRAMEWORK_MFC_INC)

SOURCES= \
	..\PLEX.cpp \
	..\MTCORE.cpp \
	..\MTEX.cpp \
	..\Array_o.cpp \
	..\List_o.cpp \
	..\strex.cpp \
	..\strexa.cpp \
	..\strexw.cpp \
	..\strcore.cpp \
	..\strcorea.cpp \
	..\strcorew.cpp

C_DEFINES=$(C_DEFINES) 
USE_MSVCRT=1
USE_NATIVE_EH=ASYNC
USE_RTTI=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\include\plex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVPLEX_H__
#define __PROVPLEX_H__

struct CPlex    // warning variable length structure
{
	CPlex* pNext;
	UINT nMax;
	UINT nCur;
	/* BYTE data[maxNum*elementSize]; */

	void* data() { return this+1; }

	static CPlex* Create(CPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};


#endif //__PROVPLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\strcorea.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNilA is left for backward compatibility
char afxChNilA = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static CStringDataA* afxDataNilA = (CStringDataA*)&rgInitData;
static LPCSTR afxPchNilA = (LPCSTR)(((BYTE*)&rgInitData)+sizeof(CStringDataA));
// special function to make afxEmptyStringA work even during initialization
const CStringA& AFXAPI AfxGetEmptyStringA()
    { return *(CStringA*)&afxPchNilA; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CStringA::CStringA()
{
    Init();
}

CStringA::CStringA(const CStringA& stringSrc)
{
    if (stringSrc.GetData()->nRefs >= 0)
    {
        m_pchData = stringSrc.m_pchData;
        InterlockedIncrement(&GetData()->nRefs);
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

void CStringA::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
    if (nLen == 0)
        Init();
    else
    {
        CStringDataA* pData =
            (CStringDataA*)new BYTE[sizeof(CStringDataA) + (nLen+1)*sizeof(char)];
        pData->nRefs = 1;
        pData->data()[nLen] = '\0';
        pData->nDataLength = nLen;
        pData->nAllocLength = nLen;
        m_pchData = pData->data();
    }
}

void CStringA::Release()
{
    if (GetData() != afxDataNilA)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
        Init();
    }
}

void PASCAL CStringA::Release(CStringDataA* pData)
{
    if (pData != afxDataNilA)
    {
        if (InterlockedDecrement(&pData->nRefs) <= 0)
            delete[] (BYTE*)pData;
    }
}

void CStringA::Empty()
{
    if (GetData()->nDataLength == 0)
        return;
    if (GetData()->nRefs >= 0)
        Release();
    else
        *this = &afxChNilA;
}

void CStringA::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CStringDataA* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(char));
    }
}

void CStringA::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }
}

CStringA::~CStringA()
//  free any attached data
{
    if (GetData() != afxDataNilA)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CStringA::AllocCopy(CStringA& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(char));
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStringA::CStringA(LPCSTR lpsz)
{
    Init();
    int nLen = SafeStrlen(lpsz);
    if (nLen != 0)
    {
        AllocBuffer(nLen);
        memcpy(m_pchData, lpsz, nLen*sizeof(char));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

CStringA::CStringA(LPCWSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen*2);
        _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStringA&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStringA::AssignCopy(int nSrcLen, LPCSTR lpszSrcData)
{
    AllocBeforeWrite(nSrcLen);
    memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(char));
    GetData()->nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CStringA& CStringA::operator=(const CStringA& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != afxDataNilA) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            m_pchData = stringSrc.m_pchData;
            InterlockedIncrement(&GetData()->nRefs);
        }
    }
    return *this;
}

const CStringA& CStringA::operator=(LPCSTR lpsz)
{
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

const CStringA& CStringA::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    AllocBeforeWrite(nSrcLen*2);
    _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
    ReleaseBuffer();
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CStringA + CStringA
// and for ? = char, LPCSTR
//          CStringA + ?
//          ? + CStringA

void CStringA::ConcatCopy(int nSrc1Len, LPCSTR lpszSrc1Data,
    int nSrc2Len, LPCSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CStringA object

    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(char));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(char));
    }
}

CStringA AFXAPI operator+(const CStringA& string1, const CStringA& string2)
{
    CStringA s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);
    return s;
}

CStringA AFXAPI operator+(const CStringA& string, LPCSTR lpsz)
{
    CStringA s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CStringA::SafeStrlen(lpsz), lpsz);
    return s;
}

CStringA AFXAPI operator+(LPCSTR lpsz, const CStringA& string)
{
    CStringA s;
    s.ConcatCopy(CStringA::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStringA::ConcatInPlace(int nSrcLen, LPCSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
        return;

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CStringDataA* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        CStringA::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(char));
        GetData()->nDataLength += nSrcLen;
        m_pchData[GetData()->nDataLength] = '\0';
    }
}

const CStringA& CStringA::operator+=(LPCSTR lpsz)
{
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CStringA& CStringA::operator+=(char ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CStringA& CStringA::operator+=(const CStringA& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPSTR CStringA::GetBuffer(int nMinBufLength)
{
    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
        // we have to grow the buffer
        CStringDataA* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
            nMinBufLength = nOldLen;
        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(char));
        GetData()->nDataLength = nOldLen;
        CStringA::Release(pOldData);
    }

    // return a pointer to the character storage for this string
    return m_pchData;
}

void CStringA::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
        nNewLength = strlen(m_pchData); // zero terminated

    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
}

LPSTR CStringA::GetBufferSetLength(int nNewLength)
{
    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
    return m_pchData;
}

void CStringA::FreeExtra()
{
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CStringDataA* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(char));
        CStringA::Release(pOldData);
    }
}

LPSTR CStringA::LockBuffer()
{
    LPSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;
    return lpsz;
}

void CStringA::UnlockBuffer()
{
    if (GetData() != afxDataNilA)
        GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStringA::Find(char ch) const
{
    // find first single character
    LPSTR lpsz = strchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStringA::FindOneOf(LPCSTR lpszCharSet) const
{
    LPSTR lpsz = strpbrk(m_pchData, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CStringA::MakeUpper()
{
    CopyBeforeWrite();
    _strupr(m_pchData);
}

void CStringA::MakeLower()
{
    CopyBeforeWrite();
    _strlwr(m_pchData);
}

void CStringA::MakeReverse()
{
    CopyBeforeWrite();
    _strrev(m_pchData);
}

void CStringA::SetAt(int nIndex, char ch)
{
    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}

void CStringA::AnsiToOem()
{
    CopyBeforeWrite();
    ::AnsiToOem(m_pchData, m_pchData);
}
void CStringA::OemToAnsi()
{
    CopyBeforeWrite();
    ::OemToCharBuffA(m_pchData, m_pchData,SafeStrlen(m_pchData));    
}



///////////////////////////////////////////////////////////////////////////////
// OLE BSTR support

BSTR CStringA::AllocSysString() const
{
#if defined(OLE2ANSI)
    BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    BSTR bstr = ::SysAllocStringLen(NULL, nLen);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        bstr, nLen);
#endif

    return bstr;
}

BSTR CStringA::SetSysString(BSTR* pbstr) const
{
#if defined(OLE2ANSI)
    if (!::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    if (!::SysReAllocStringLen(pbstr, NULL, nLen))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        *pbstr, nLen);
#endif

    return *pbstr;
}

// CStringA
CStringDataA* CStringA::GetData() const
    { return ((CStringDataA*)m_pchData)-1; }
void CStringA::Init()
    { m_pchData = afxEmptyStringA.m_pchData; }
CStringA::CStringA(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
const CStringA& CStringA::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }

int CStringA::GetLength() const
    { return GetData()->nDataLength; }
int CStringA::GetAllocLength() const
    { return GetData()->nAllocLength; }
BOOL CStringA::IsEmpty() const
    { return GetData()->nDataLength == 0; }
CStringA::operator LPCSTR() const
    { return m_pchData; }
int PASCAL CStringA::SafeStrlen(LPCSTR lpsz)
    { return (lpsz == NULL) ? 0 : strlen(lpsz); }

// CStringA support (windows specific)
int CStringA::Compare(LPCSTR lpsz) const
    { return strcmp(m_pchData, lpsz); }    // MBCS/Unicode aware
int CStringA::CompareNoCase(LPCSTR lpsz) const
    { return _stricmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CStringA::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
int CStringA::Collate(LPCSTR lpsz) const
    { return strcoll(m_pchData, lpsz); }   // locale sensitive

char CStringA::GetAt(int nIndex) const
{
    return m_pchData[nIndex];
}
char CStringA::operator[](int nIndex) const
{
    // same as GetAt
    return m_pchData[nIndex];
}
bool AFXAPI operator==(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) == 0; }
bool AFXAPI operator!=(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) != 0; }
bool AFXAPI operator<(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) > 0; }
bool AFXAPI operator>(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) < 0; }
bool AFXAPI operator<=(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) >= 0; }
bool AFXAPI operator>=(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) <= 0; }


///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\strex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>
#include <strsafe.h>

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(TCHAR ch, int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
#ifdef _UNICODE
        for (int i = 0; i < nLength; i++)
            m_pchData[i] = ch;
#else
        memset(m_pchData, ch, nLength);
#endif
    }
}

CString::CString(LPCTSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CString& CString::operator=(TCHAR ch)
{
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CString AFXAPI operator+(const CString& string1, TCHAR ch)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CString AFXAPI operator+(TCHAR ch, const CString& string)
{
    CString s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
        nFirst = 0;
    if (nCount < 0)
        nCount = 0;

    if (nFirst + nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength - nFirst;
    if (nFirst > GetData()->nDataLength)
        nCount = 0;

    CString dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CString CString::Right(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CString dest;
    AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
    return dest;
}

CString CString::Left(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CString dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
    return Left(_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
    return Left(_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(TCHAR ch) const
{
    // find last single character
    LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(LPCTSTR lpszSub) const
{
    // find first matching substring
    LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CString formatting

#ifdef _MAC
    #define TCHAR_ARG   int
    #define WCHAR_ARG   unsigned
    #define CHAR_ARG    int
#else
    #define TCHAR_ARG   TCHAR
    #define WCHAR_ARG   WCHAR
    #define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
    #define DOUBLE_ARG  _AFX_DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
    {
        // handle '%' character, but watch out for '%%'
        if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
        {
            nMaxLen += _tclen(lpsz);
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
        {
            // check for valid flags
            if (*lpsz == '#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == '*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                *lpsz == ' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0)
        {
            // width indicated by
            nWidth = _ttoi(lpsz);
            for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                ;
        }

        int nPrecision = 0;
        if (*lpsz == '.')
        {
            // skip past '.' separator (width.precision)
            lpsz = _tcsinc(lpsz);

            // get precision and skip it
            if (*lpsz == '*')
            {
                nPrecision = va_arg(argList, int);
                lpsz = _tcsinc(lpsz);
            }
            else
            {
                nPrecision = _ttoi(lpsz);
                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                    ;
            }
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz)
        {
        // modifiers that affect size
        case 'h':
            nModifier = FORCE_ANSI;
            lpsz = _tcsinc(lpsz);
            break;
        case 'l':
            nModifier = FORCE_UNICODE;
            lpsz = _tcsinc(lpsz);
            break;

        // modifiers that do not affect size
        case 'F':
        case 'N':
        case 'L':
            lpsz = _tcsinc(lpsz);
            break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier)
        {
        // single characters
        case 'c':
        case 'C':
            nItemLen = 2;
            va_arg(argList, TCHAR_ARG);
            break;
        case 'c'|FORCE_ANSI:
        case 'C'|FORCE_ANSI:
            nItemLen = 2;
            va_arg(argList, CHAR_ARG);
            break;
        case 'c'|FORCE_UNICODE:
        case 'C'|FORCE_UNICODE:
            nItemLen = 2;
            va_arg(argList, WCHAR_ARG);
            break;

        // strings
        case 's':
        {
            LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = lstrlen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case 'S':
        {
#ifndef _UNICODE
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
#else
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
#endif
            break;
        }

        case 's'|FORCE_ANSI:
        case 'S'|FORCE_ANSI:
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

#ifndef _MAC
        case 's'|FORCE_UNICODE:
        case 'S'|FORCE_UNICODE:
        {
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }
#endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0)
        {
            nItemLen = max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = min(nItemLen, nPrecision);
        }
        else
        {
            switch (*lpsz)
            {
            // integers
            case 'd':
            case 'i':
            case 'u':
            case 'x':
            case 'X':
            case 'o':
                va_arg(argList, int);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'e':
            case 'f':
            case 'g':
            case 'G':
                va_arg(argList, DOUBLE_ARG);
                nItemLen = 128;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'p':
                va_arg(argList, void*);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            // no output
            case 'n':
                va_arg(argList, int*);
                break;

            default:
                break ;
            }
        }

        // adjust nMaxLen for output nItemLen
        nMaxLen += nItemLen;
    }

    GetBuffer(nMaxLen);
    StringCchVPrintf(m_pchData, nMaxLen,lpszFormat, argListSave);
    ReleaseBuffer();

    va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CString::Format(LPCTSTR lpszFormat, ...)
{
    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}

#ifndef _MAC
// formatting (using FormatMessage style formatting)
void AFX_CDECL CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPTSTR lpszTemp;

    if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    }

    // assign lpszTemp into the resulting string and free the temporary
    *this = lpszTemp;
    LocalFree(lpszTemp);
    va_end(argList);
}

#endif //!_MAC

void CString::TrimRight()
{
    CopyBeforeWrite();

    // find beginning of trailing spaces by starting at beginning (DBCS aware)
    LPTSTR lpsz = m_pchData;
    LPTSTR lpszLast = NULL;
    while (*lpsz != '\0')
    {
        if (_istspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = _tcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CString::TrimLeft()
{
    CopyBeforeWrite();

    // find first non-space character
    LPCTSTR lpsz = m_pchData;
    while (_istspace(*lpsz))
        lpsz = _tcsinc(lpsz);

    // fix up data and length
    int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
    GetData()->nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// CString support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CString> (CString* pElements, int nCount)
#else
void AFXAPI ConstructElements(CString* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        memcpy(pElements, &afxEmptyString, sizeof(*pElements));
}

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CString> (CString* pElements, int nCount)
#else
void AFXAPI DestructElements(CString* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        pElements->~CString();
}

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CString> (CString* pDest, const CString* pSrc, int nCount)
#else
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount)
#endif
{
    for (; nCount--; ++pDest, ++pSrc)
        *pDest = *pSrc;
}
/*
#ifndef OLE2ANSI
#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key)
#else
UINT AFXAPI HashKey(LPCWSTR key)
#endif
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}
#endif

#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCSTR> (LPCSTR key)
#else
UINT AFXAPI HashKey(LPCSTR key)
#endif
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}
*/
UINT AFXAPI HashKeyLPCWSTR(LPCWSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}

UINT AFXAPI HashKeyLPCSTR(LPCSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\strexa.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>
#include <mbstring.h>
#include <strsafe.h>

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStringA::CStringA(char ch, int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
        memset(m_pchData, ch, nLength);
    }
}

CStringA::CStringA(LPCSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(char));
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStringA& CStringA::operator=(char ch)
{
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStringA AFXAPI operator+(const CStringA& string1, char ch)
{
    CStringA s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CStringA AFXAPI operator+(char ch, const CStringA& string)
{
    CStringA s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStringA CStringA::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CStringA CStringA::Mid(int nFirst, int nCount) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
        nFirst = 0;
    if (nCount < 0)
        nCount = 0;

    if (nFirst + nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength - nFirst;
    if (nFirst > GetData()->nDataLength)
        nCount = 0;

    CStringA dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CStringA CStringA::Right(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CStringA dest;
    AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
    return dest;
}

CStringA CStringA::Left(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CStringA dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CStringA CStringA::SpanIncluding(LPCSTR lpszCharSet) const
{
    return Left(strspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CStringA CStringA::SpanExcluding(LPCSTR lpszCharSet) const
{
    return Left(strcspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStringA::ReverseFind(char ch) const
{
    // find last single character
    LPSTR lpsz = strrchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStringA::Find(LPCSTR lpszSub) const
{
    // find first matching substring
    LPSTR lpsz = strstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CStringA formatting

#ifdef _MAC
    #define TCHAR_ARG   int
    #define WCHAR_ARG   unsigned
    #define CHAR_ARG    int
#else
    #define TCHAR_ARG   char
    #define WCHAR_ARG   WCHAR
    #define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
    #define DOUBLE_ARG  _AFX_DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CStringA::FormatV(LPCSTR lpszFormat, va_list argList)
{
    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz))
    {
        // handle '%' character, but watch out for '%%'
        if (*lpsz != '%' || *(lpsz = (LPCSTR)(LPCSTR)_mbsinc((const unsigned char*)lpsz)) == '%')
        {
            nMaxLen += _mbclen((const unsigned char*)lpsz);
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != '\0'; lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz))
        {
            // check for valid flags
            if (*lpsz == '#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == '*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                *lpsz == ' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0)
        {
            // width indicated by
            nWidth = atoi(lpsz);
            for (; *lpsz != '\0' && isdigit(*lpsz); lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz))
                ;
        }

        int nPrecision = 0;
        if (*lpsz == '.')
        {
            // skip past '.' separator (width.precision)
            lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);

            // get precision and skip it
            if (*lpsz == '*')
            {
                nPrecision = va_arg(argList, int);
                lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);
            }
            else
            {
                nPrecision = atoi(lpsz);
                for (; *lpsz != '\0' && isdigit(*lpsz); lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz))
                    ;
            }
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz)
        {
        // modifiers that affect size
        case 'h':
            nModifier = FORCE_ANSI;
            lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);
            break;
        case 'l':
            nModifier = FORCE_UNICODE;
            lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);
            break;

        // modifiers that do not affect size
        case 'F':
        case 'N':
        case 'L':
            lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);
            break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier)
        {
        // single characters
        case 'c':
        case 'C':
            nItemLen = 2;
            va_arg(argList, TCHAR_ARG);
            break;
        case 'c'|FORCE_ANSI:
        case 'C'|FORCE_ANSI:
            nItemLen = 2;
            va_arg(argList, CHAR_ARG);
            break;
        case 'c'|FORCE_UNICODE:
        case 'C'|FORCE_UNICODE:
            nItemLen = 2;
            va_arg(argList, WCHAR_ARG);
            break;

        // strings
        case 's':
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = strlen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case 'S':
        {
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case 's'|FORCE_ANSI:
        case 'S'|FORCE_ANSI:
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

#ifndef _MAC
        case 's'|FORCE_UNICODE:
        case 'S'|FORCE_UNICODE:
        {
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }
#endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0)
        {
            nItemLen = max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = min(nItemLen, nPrecision);
        }
        else
        {
            switch (*lpsz)
            {
            // integers
            case 'd':
            case 'i':
            case 'u':
            case 'x':
            case 'X':
            case 'o':
                va_arg(argList, int);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'e':
            case 'f':
            case 'g':
            case 'G':
                va_arg(argList, DOUBLE_ARG);
                nItemLen = 128;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'p':
                va_arg(argList, void*);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            // no output
            case 'n':
                va_arg(argList, int*);
                break;

            default:
                break ;
            }
        }

        // adjust nMaxLen for output nItemLen
        nMaxLen += nItemLen;
    }

    GetBuffer(nMaxLen);
	StringCchVPrintfA(m_pchData, nMaxLen,lpszFormat, argListSave);
    ReleaseBuffer();

    va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CStringA::Format(LPCSTR lpszFormat, ...)
{
    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}

#ifndef _MAC
// formatting (using FormatMessage style formatting)
void AFX_CDECL CStringA::FormatMessage(LPCSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPSTR lpszTemp;

    if (::FormatMessageA(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    }

    // assign lpszTemp into the resulting string and free the temporary
    *this = lpszTemp;
    LocalFree(lpszTemp);
    va_end(argList);
}

#endif //!_MAC

void CStringA::TrimRight()
{
    CopyBeforeWrite();

    // find beginning of trailing spaces by starting at beginning (DBCS aware)
    LPSTR lpsz = m_pchData;
    LPSTR lpszLast = NULL;
    while (*lpsz != '\0')
    {
        if (isspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = (LPSTR)_mbsinc((const unsigned char*)lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CStringA::TrimLeft()
{
    CopyBeforeWrite();

    // find first non-space character
    LPCSTR lpsz = m_pchData;
    while (isspace(*lpsz))
        lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);

    // fix up data and length
    int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(char));
    GetData()->nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// CStringA support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CStringA> (CStringA* pElements, int nCount)
#else
void AFXAPI ConstructElements(CStringA* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        memcpy(pElements, &afxEmptyStringA, sizeof(*pElements));
}

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CStringA> (CStringA* pElements, int nCount)
#else
void AFXAPI DestructElements(CStringA* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        pElements->~CStringA();
}

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CStringA> (CStringA* pDest, const CStringA* pSrc, int nCount)
#else
void AFXAPI CopyElements(CStringA* pDest, const CStringA* pSrc, int nCount)
#endif
{
    for (; nCount--; ++pDest, ++pSrc)
        *pDest = *pSrc;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\strcorew.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
WCHAR afxChNilW = L'\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static CStringDataW* afxDataNilW = (CStringDataW*)&rgInitData;
static LPCWSTR afxPchNilW = (LPCWSTR)(((BYTE*)&rgInitData)+sizeof(CStringDataW));
// special function to make afxEmptyStringW work even during initialization
const CStringW& AFXAPI AfxGetEmptyStringW()
    { return *(CStringW*)&afxPchNilW; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CStringW::CStringW()
{
    Init();
}

CStringW::CStringW(const CStringW& stringSrc)
{
    if (stringSrc.GetData()->nRefs >= 0)
    {
        m_pchData = stringSrc.m_pchData;
        InterlockedIncrement(&GetData()->nRefs);
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

void CStringW::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
    if (nLen == 0)
        Init();
    else
    {
        CStringDataW* pData =
            (CStringDataW*)new BYTE[sizeof(CStringDataW) + (nLen+1)*sizeof(WCHAR)];
        pData->nRefs = 1;
        pData->data()[nLen] = L'\0';
        pData->nDataLength = nLen;
        pData->nAllocLength = nLen;
        m_pchData = pData->data();
    }
}

void CStringW::Release()
{
    if (GetData() != afxDataNilW)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
        Init();
    }
}

void PASCAL CStringW::Release(CStringDataW* pData)
{
    if (pData != afxDataNilW)
    {
        if (InterlockedDecrement(&pData->nRefs) <= 0)
            delete[] (BYTE*)pData;
    }
}

void CStringW::Empty()
{
    if (GetData()->nDataLength == 0)
        return;
    if (GetData()->nRefs >= 0)
        Release();
    else
        *this = &afxChNil;
}

void CStringW::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CStringDataW* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(WCHAR));
    }
}

void CStringW::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }
}

CStringW::~CStringW()
//  free any attached data
{
    if (GetData() != afxDataNilW)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CStringW::AllocCopy(CStringW& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(WCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStringW::CStringW(LPCWSTR lpsz)
{
    Init();
    int nLen = SafeStrlen(lpsz);
    if (nLen != 0)
    {
        AllocBuffer(nLen);
        memcpy(m_pchData, lpsz, nLen*sizeof(WCHAR));
    }
}

/////////////////////////////////////////////////////////////////////////////

CStringW::CStringW(LPCSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStringW&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStringW::AssignCopy(int nSrcLen, LPCWSTR lpszSrcData)
{
    AllocBeforeWrite(nSrcLen);
    memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(WCHAR));
    GetData()->nDataLength = nSrcLen;
    m_pchData[nSrcLen] = L'\0';
}

const CStringW& CStringW::operator=(const CStringW& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != afxDataNilW) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            m_pchData = stringSrc.m_pchData;
            InterlockedIncrement(&GetData()->nRefs);
        }
    }
    return *this;
}

const CStringW& CStringW::operator=(LPCWSTR lpsz)
{
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CStringW& CStringW::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    AllocBeforeWrite(nSrcLen);
    _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    ReleaseBuffer();
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CStringW + CStringW
// and for ? = WCHAR, LPCWSTR
//          CStringW + ?
//          ? + CStringW

void CStringW::ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data,
    int nSrc2Len, LPCWSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CStringW object

    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(WCHAR));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(WCHAR));
    }
}

CStringW AFXAPI operator+(const CStringW& string1, const CStringW& string2)
{
    CStringW s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);
    return s;
}

CStringW AFXAPI operator+(const CStringW& string, LPCWSTR lpsz)
{
    CStringW s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CStringW::SafeStrlen(lpsz), lpsz);
    return s;
}

CStringW AFXAPI operator+(LPCWSTR lpsz, const CStringW& string)
{
    CStringW s;
    s.ConcatCopy(CStringW::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStringW::ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
        return;

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CStringDataW* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        CStringW::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(WCHAR));
        GetData()->nDataLength += nSrcLen;
        m_pchData[GetData()->nDataLength] = L'\0';
    }
}

const CStringW& CStringW::operator+=(LPCWSTR lpsz)
{
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CStringW& CStringW::operator+=(WCHAR ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CStringW& CStringW::operator+=(const CStringW& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPWSTR CStringW::GetBuffer(int nMinBufLength)
{
    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
        // we have to grow the buffer
        CStringDataW* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
            nMinBufLength = nOldLen;
        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(WCHAR));
        GetData()->nDataLength = nOldLen;
        CStringW::Release(pOldData);
    }

    // return a pointer to the character storage for this string
    return m_pchData;
}

void CStringW::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
        nNewLength = wcslen(m_pchData); // zero terminated

    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = L'\0';
}

LPWSTR CStringW::GetBufferSetLength(int nNewLength)
{
    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = L'\0';
    return m_pchData;
}

void CStringW::FreeExtra()
{
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CStringDataW* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(WCHAR));
        CStringW::Release(pOldData);
    }
}

LPWSTR CStringW::LockBuffer()
{
    LPWSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;
    return lpsz;
}

void CStringW::UnlockBuffer()
{
    if (GetData() != afxDataNilW)
        GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStringW::Find(WCHAR ch) const
{
    // find first single character
    LPWSTR lpsz = wcschr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStringW::FindOneOf(LPCWSTR lpszCharSet) const
{
    LPWSTR lpsz = wcspbrk(m_pchData, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CStringW::MakeUpper()
{
    CopyBeforeWrite();
    _wcsupr(m_pchData);
}

void CStringW::MakeLower()
{
    CopyBeforeWrite();
    _wcslwr(m_pchData);
}

void CStringW::MakeReverse()
{
    CopyBeforeWrite();
    _wcsrev(m_pchData);
}

void CStringW::SetAt(int nIndex, WCHAR ch)
{
    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}




///////////////////////////////////////////////////////////////////////////////
// OLE BSTR support

BSTR CStringW::AllocSysString() const
{
    BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;

    return bstr;
}

BSTR CStringW::SetSysString(BSTR* pbstr) const
{
    if (!::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;

    return *pbstr;
}

// CStringW
CStringDataW* CStringW::GetData() const
    { return ((CStringDataW*)m_pchData)-1; }
void CStringW::Init()
    { m_pchData = afxEmptyStringW.m_pchData; }
CStringW::CStringW(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
const CStringW& CStringW::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }
const CStringW& CStringW::operator+=(char ch)
    { *this += (WCHAR)ch; return *this; }
const CStringW& CStringW::operator=(char ch)
    { *this = (WCHAR)ch; return *this; }
CStringW AFXAPI operator+(const CStringW& string, char ch)
    { return string + (WCHAR)ch; }
CStringW AFXAPI operator+(char ch, const CStringW& string)
    { return (WCHAR)ch + string; }

int CStringW::GetLength() const
    { return GetData()->nDataLength; }
int CStringW::GetAllocLength() const
    { return GetData()->nAllocLength; }
BOOL CStringW::IsEmpty() const
    { return GetData()->nDataLength == 0; }
CStringW::operator LPCWSTR() const
    { return m_pchData; }
int PASCAL CStringW::SafeStrlen(LPCWSTR lpsz)
    { return (lpsz == NULL) ? 0 : wcslen(lpsz); }

// CStringW support (windows specific)
int CStringW::Compare(LPCWSTR lpsz) const
    { return wcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
int CStringW::CompareNoCase(LPCWSTR lpsz) const
    { return _wcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CStringW::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
int CStringW::Collate(LPCWSTR lpsz) const
    { return wcscoll(m_pchData, lpsz); }   // locale sensitive

WCHAR CStringW::GetAt(int nIndex) const
{
    return m_pchData[nIndex];
}
WCHAR CStringW::operator[](int nIndex) const
{
    // same as GetAt
    return m_pchData[nIndex];
}
bool AFXAPI operator==(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) == 0; }
bool AFXAPI operator!=(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) != 0; }
bool AFXAPI operator<(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) > 0; }
bool AFXAPI operator>(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) < 0; }
bool AFXAPI operator<=(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) >= 0; }
bool AFXAPI operator>=(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) <= 0; }


///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\strexw.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>
#include <strsafe.h>

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStringW::CStringW(WCHAR ch, int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
        for (int i = 0; i < nLength; i++)
            m_pchData[i] = ch;
    }
}

CStringW::CStringW(LPCWSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(WCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStringW& CStringW::operator=(WCHAR ch)
{
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStringW AFXAPI operator+(const CStringW& string1, WCHAR ch)
{
    CStringW s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CStringW AFXAPI operator+(WCHAR ch, const CStringW& string)
{
    CStringW s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStringW CStringW::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CStringW CStringW::Mid(int nFirst, int nCount) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
        nFirst = 0;
    if (nCount < 0)
        nCount = 0;

    if (nFirst + nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength - nFirst;
    if (nFirst > GetData()->nDataLength)
        nCount = 0;

    CStringW dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CStringW CStringW::Right(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CStringW dest;
    AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
    return dest;
}

CStringW CStringW::Left(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CStringW dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CStringW CStringW::SpanIncluding(LPCWSTR lpszCharSet) const
{
    return Left(wcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CStringW CStringW::SpanExcluding(LPCWSTR lpszCharSet) const
{
    return Left(wcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStringW::ReverseFind(WCHAR ch) const
{
    // find last single character
    LPWSTR lpsz = wcsrchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStringW::Find(LPCWSTR lpszSub) const
{
    // find first matching substring
    LPWSTR lpsz = wcsstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CStringW formatting

#ifdef _MAC
    #define WCHAR_ARG   int
    #define WCHAR_ARG   unsigned
    #define CHAR_ARG    int
#else
    #define WCHAR_ARG   WCHAR
    #define WCHAR_ARG   WCHAR
    #define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
    #define DOUBLE_ARG  _AFX_DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CStringW::FormatV(LPCWSTR lpszFormat, va_list argList)
{
    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCWSTR lpsz = lpszFormat; *lpsz != L'\0'; lpsz++)
    {
        // handle '%' character, but watch out for '%%'
        if (*lpsz != L'%' || *(lpsz++) == L'%')
        {
            //nMaxLen += _tclen(lpsz);
            nMaxLen++;
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != L'\0'; lpsz++)
        {
            // check for valid flags
            if (*lpsz == L'#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == L'*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == L'-' || *lpsz == L'+' || *lpsz == L'0' ||
                *lpsz == L' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0)
        {
            // width indicated by
            nWidth = _wtoi(lpsz);
            for (; *lpsz != L'\0' && iswdigit(*lpsz); lpsz++)
                ;
        }

        int nPrecision = 0;
        if (*lpsz == L'.')
        {
            // skip past '.' separator (width.precision)
            lpsz++;

            // get precision and skip it
            if (*lpsz == L'*')
            {
                nPrecision = va_arg(argList, int);
                lpsz++;
            }
            else
            {
                nPrecision = _wtoi(lpsz);
                for (; *lpsz != L'\0' && iswdigit(*lpsz); lpsz++)
                    ;
            }
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz)
        {
        // modifiers that affect size
        case L'h':
            nModifier = FORCE_ANSI;
            lpsz++;
            break;
        case L'l':
            nModifier = FORCE_UNICODE;
            lpsz++;
            break;

        // modifiers that do not affect size
        case L'F':
        case L'N':
        case L'L':
            lpsz++;
            break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier)
        {
        // single characters
        case L'c':
        case L'C':
            nItemLen = 2;
            va_arg(argList, WCHAR_ARG);
            break;
        case L'c'|FORCE_ANSI:
        case L'C'|FORCE_ANSI:
            nItemLen = 2;
            va_arg(argList, CHAR_ARG);
            break;
        case L'c'|FORCE_UNICODE:
        case L'C'|FORCE_UNICODE:
            nItemLen = 2;
            va_arg(argList, WCHAR_ARG);
            break;

        // strings
        case L's':
        {
            LPCWSTR pstrNextArg = va_arg(argList, LPCWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case L'S':
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case L's'|FORCE_ANSI:
        case L'S'|FORCE_ANSI:
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

#ifndef _MAC
        case L's'|FORCE_UNICODE:
        case L'S'|FORCE_UNICODE:
        {
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }
#endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0)
        {
            nItemLen = max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = min(nItemLen, nPrecision);
        }
        else
        {
            switch (*lpsz)
            {
            // integers
            case L'd':
            case L'i':
            case L'u':
            case L'x':
            case L'X':
            case L'o':
                va_arg(argList, int);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case L'e':
            case L'f':
            case L'g':
            case L'G':
                va_arg(argList, DOUBLE_ARG);
                nItemLen = 128;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case L'p':
                va_arg(argList, void*);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            // no output
            case L'n':
                va_arg(argList, int*);
                break;

            default:
                break ;
            }
        }

        // adjust nMaxLen for output nItemLen
        nMaxLen += nItemLen;
    }

    GetBuffer(nMaxLen);
    StringCchVPrintfW(m_pchData, nMaxLen,lpszFormat, argListSave);
    ReleaseBuffer();

    va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CStringW::Format(LPCWSTR lpszFormat, ...)
{
    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}

#ifndef _MAC
// formatting (using FormatMessage style formatting)
void AFX_CDECL CStringW::FormatMessage(LPCWSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPWSTR lpszTemp;

    if (::FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPWSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    }

    // assign lpszTemp into the resulting string and free the temporary
    *this = lpszTemp;
    LocalFree(lpszTemp);
    va_end(argList);
}

#endif //!_MAC

void CStringW::TrimRight()
{
    CopyBeforeWrite();

    // find beginning of trailing spaces by starting at beginning (DBCS aware)
    LPWSTR lpsz = m_pchData;
    LPWSTR lpszLast = NULL;
    while (*lpsz != L'\0')
    {
        if (_istspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz++;
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = L'\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CStringW::TrimLeft()
{
    CopyBeforeWrite();

    // find first non-space character
    LPCWSTR lpsz = m_pchData;
    while (iswspace(*lpsz))
        lpsz++;

    // fix up data and length
    int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
    GetData()->nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// CStringW support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CStringW> (CStringW* pElements, int nCount)
#else
void AFXAPI ConstructElements(CStringW* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        memcpy(pElements, &afxEmptyStringW, sizeof(*pElements));
}

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CStringW> (CStringW* pElements, int nCount)
#else
void AFXAPI DestructElements(CStringW* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        pElements->~CStringW();
}

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CStringW> (CStringW* pDest, const CStringW* pSrc, int nCount)
#else
void AFXAPI CopyElements(CStringW* pDest, const CStringW* pSrc, int nCount)
#endif
{
    for (; nCount--; ++pDest, ++pSrc)
        *pDest = *pSrc;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\include\provcoll.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVCOLL_H__
#define __PROVCOLL_H__

#include "provstd.h"

class CObArray : public CObject
{
public:

// Construction
	CObArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	CObject* GetAt(int nIndex) const;
	void SetAt(int nIndex, CObject* newElement);
	CObject*& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const CObject** GetData() const;
	CObject** GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, CObject* newElement);
	int Add(CObject* newElement);
	int Append(const CObArray& src);
	void Copy(const CObArray& src);

	// overloaded operator helpers
	CObject* operator[](int nIndex) const;
	CObject*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, CObject* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CObArray* pNewArray);

// Implementation
protected:
	CObject** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CObArray();

protected:
	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};

/////////////////////////////////////////////////////////////////////////////

class CObList : public CObject
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CObject* data;
	};
public:

// Construction
	CObList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CObject*& GetHead();
	CObject* GetHead() const;
	CObject*& GetTail();
	CObject* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	CObject* RemoveHead();
	CObject* RemoveTail();

	// add before head or after tail
	POSITION AddHead(CObject* newElement);
	POSITION AddTail(CObject* newElement);

	// add another list of elements before head or after tail
	void AddHead(CObList* pNewList);
	void AddTail(CObList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CObject*& GetNext(POSITION& rPosition); // return *Position++
	CObject* GetNext(POSITION& rPosition) const; // return *Position++
	CObject*& GetPrev(POSITION& rPosition); // return *Position--
	CObject* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CObject*& GetAt(POSITION position);
	CObject* GetAt(POSITION position) const;
	void SetAt(POSITION pos, CObject* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, CObject* newElement);
	POSITION InsertAfter(POSITION position, CObject* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(CObject* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CObList();

	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};

#endif //!__PROVCOLL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\strcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static CStringData* afxDataNil = (CStringData*)&rgInitData;
static LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));
// special function to make afxEmptyString work even during initialization
const CString& AFXAPI AfxGetEmptyString()
    { return *(CString*)&afxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
    Init();
}

CString::CString(const CString& stringSrc)
{
    if (stringSrc.GetData()->nRefs >= 0)
    {
        m_pchData = stringSrc.m_pchData;
        InterlockedIncrement(&GetData()->nRefs);
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
    if (nLen == 0)
        Init();
    else
    {
        CStringData* pData =
            (CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
        pData->nRefs = 1;
        pData->data()[nLen] = '\0';
        pData->nDataLength = nLen;
        pData->nAllocLength = nLen;
        m_pchData = pData->data();
    }
}

void CString::Release()
{
    if (GetData() != afxDataNil)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
        Init();
    }
}

void PASCAL CString::Release(CStringData* pData)
{
    if (pData != afxDataNil)
    {
        if (InterlockedDecrement(&pData->nRefs) <= 0)
            delete[] (BYTE*)pData;
    }
}

void CString::Empty()
{
    if (GetData()->nDataLength == 0)
        return;
    if (GetData()->nRefs >= 0)
        Release();
    else
        *this = &afxChNil;
}

void CString::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CStringData* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
    }
}

void CString::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }
}

CString::~CString()
//  free any attached data
{
    if (GetData() != afxDataNil)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCTSTR lpsz)
{
    Init();
    int nLen = SafeStrlen(lpsz);
    if (nLen != 0)
    {
        AllocBuffer(nLen);
        memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CString::CString(LPCSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
}
#else //_UNICODE
CString::CString(LPCWSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen*2);
        _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
    }
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
    AllocBeforeWrite(nSrcLen);
    memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
    GetData()->nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            m_pchData = stringSrc.m_pchData;
            InterlockedIncrement(&GetData()->nRefs);
        }
    }
    return *this;
}

const CString& CString::operator=(LPCTSTR lpsz)
{
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CString& CString::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    AllocBeforeWrite(nSrcLen);
    _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    ReleaseBuffer();
    return *this;
}
#else //!_UNICODE
const CString& CString::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    AllocBeforeWrite(nSrcLen*2);
    _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
    ReleaseBuffer();
    return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
    int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
    }
}

CString AFXAPI operator+(const CString& string1, const CString& string2)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);
    return s;
}

CString AFXAPI operator+(const CString& string, LPCTSTR lpsz)
{
    CString s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CString::SafeStrlen(lpsz), lpsz);
    return s;
}

CString AFXAPI operator+(LPCTSTR lpsz, const CString& string)
{
    CString s;
    s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
        return;

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CStringData* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        CString::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
        GetData()->nDataLength += nSrcLen;
        m_pchData[GetData()->nDataLength] = '\0';
    }
}

const CString& CString::operator+=(LPCTSTR lpsz)
{
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CString& CString::operator+=(TCHAR ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CString& CString::operator+=(const CString& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CString::GetBuffer(int nMinBufLength)
{
    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
        // we have to grow the buffer
        CStringData* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
            nMinBufLength = nOldLen;
        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
        GetData()->nDataLength = nOldLen;
        CString::Release(pOldData);
    }

    // return a pointer to the character storage for this string
    return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
        nNewLength = lstrlen(m_pchData); // zero terminated

    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
}

LPTSTR CString::GetBufferSetLength(int nNewLength)
{
    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
    return m_pchData;
}

void CString::FreeExtra()
{
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CStringData* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
        CString::Release(pOldData);
    }
}

LPTSTR CString::LockBuffer()
{
    LPTSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;
    return lpsz;
}

void CString::UnlockBuffer()
{
    if (GetData() != afxDataNil)
        GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CString::Find(TCHAR ch) const
{
    // find first single character
    LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
    LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CString::MakeUpper()
{
    CopyBeforeWrite();
    _tcsupr(m_pchData);
}

void CString::MakeLower()
{
    CopyBeforeWrite();
    _tcslwr(m_pchData);
}

void CString::MakeReverse()
{
    CopyBeforeWrite();
    _tcsrev(m_pchData);
}

void CString::SetAt(int nIndex, TCHAR ch)
{
    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CString::AnsiToOem()
{
    CopyBeforeWrite();
    ::AnsiToOem(m_pchData, m_pchData);
}
void CString::OemToAnsi()
{
    CopyBeforeWrite();
    ::OemToCharBuff(m_pchData, m_pchData,SafeStrlen(m_pchData));
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CString conversion helpers (these use the current system locale)

int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
    if (count == 0 && mbstr != NULL)
        return 0;

    int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
        mbstr, count, NULL, NULL);

    if (result > 0)
        mbstr[result-1] = 0;
    return result;
}

int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
    if (count == 0 && wcstr != NULL)
        return 0;

    int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
        wcstr, count);

    if (result > 0)
        wcstr[result-1] = 0;
    return result;
}

LPWSTR AFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    if (lpa == NULL)
        return NULL;

    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

LPSTR AFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    if (lpw == NULL)
        return NULL;

    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}

///////////////////////////////////////////////////////////////////////////////
// OLE BSTR support

BSTR CString::AllocSysString() const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
    BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    BSTR bstr = ::SysAllocStringLen(NULL, nLen);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        bstr, nLen);
#endif

    return bstr;
}

BSTR CString::SetSysString(BSTR* pbstr) const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
    if (!::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    if (!::SysReAllocStringLen(pbstr, NULL, nLen))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        *pbstr, nLen);
#endif

    return *pbstr;
}

// CString
CStringData* CString::GetData() const
    { return ((CStringData*)m_pchData)-1; }
void CString::Init()
    { m_pchData = afxEmptyString.m_pchData; }
CString::CString(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
const CString& CString::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
const CString& CString::operator+=(char ch)
    { *this += (TCHAR)ch; return *this; }
const CString& CString::operator=(char ch)
    { *this = (TCHAR)ch; return *this; }
CString AFXAPI operator+(const CString& string, char ch)
    { return string + (TCHAR)ch; }
CString AFXAPI operator+(char ch, const CString& string)
    { return (TCHAR)ch + string; }
#endif

int CString::GetLength() const
    { return GetData()->nDataLength; }
int CString::GetAllocLength() const
    { return GetData()->nAllocLength; }
BOOL CString::IsEmpty() const
    { return GetData()->nDataLength == 0; }
CString::operator LPCTSTR() const
    { return m_pchData; }
int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
    { return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
int CString::Compare(LPCTSTR lpsz) const
    { return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
int CString::CompareNoCase(LPCTSTR lpsz) const
    { return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
int CString::Collate(LPCTSTR lpsz) const
    { return _tcscoll(m_pchData, lpsz); }   // locale sensitive

TCHAR CString::GetAt(int nIndex) const
{
    return m_pchData[nIndex];
}
TCHAR CString::operator[](int nIndex) const
{
    // same as GetAt
    return m_pchData[nIndex];
}
bool AFXAPI operator==(const CString& s1, const CString& s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) == 0; }
bool AFXAPI operator!=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) != 0; }
bool AFXAPI operator<(const CString& s1, const CString& s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) > 0; }
bool AFXAPI operator>(const CString& s1, const CString& s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) < 0; }
bool AFXAPI operator<=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) >= 0; }
bool AFXAPI operator>=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) <= 0; }


///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\include\provcont.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVCONT_H
#define __PROVCONT_H

#include <provexpt.h>

template<class TYPE, class ARG_TYPE>
class ProvList 
{
private:

	CCriticalSection * criticalSection ;
	CList <TYPE, ARG_TYPE> clist ;

protected:
public:

	ProvList ( BOOL threadSafeArg = FALSE ) ;
	virtual ~ProvList () ;

	int GetCount() const;
	BOOL IsEmpty() const;

	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

	TYPE RemoveHead();
	TYPE RemoveTail();

	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	void AddHead(ProvList<TYPE,ARG_TYPE>* pNewList);
	void AddTail(ProvList<TYPE,ARG_TYPE>* pNewList);

	void RemoveAll();

	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); 
	TYPE GetNext(POSITION& rPosition) const; 
	TYPE& GetPrev(POSITION& rPosition); 
	TYPE GetPrev(POSITION& rPosition) const; 

	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
	POSITION FindIndex(int nIndex) const;
} ;

template<class TYPE, class ARG_TYPE>
ProvList <TYPE,ARG_TYPE>:: ProvList ( BOOL threadSafeArg ) : criticalSection ( NULL )
{
	if ( threadSafeArg )	
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
ProvList <TYPE,ARG_TYPE> :: ~ProvList () 
{
	if ( criticalSection ) 
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
int ProvList <TYPE,ARG_TYPE> :: GetCount() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		int count = clist.GetCount () ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return clist.GetCount () ;
	}
}

template<class TYPE, class ARG_TYPE>
BOOL ProvList <TYPE,ARG_TYPE> :: IsEmpty() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL isEmpty = clist.IsEmpty () ;
		criticalSection->Unlock () ;
		return isEmpty ;
	}
	else
	{
		return clist.IsEmpty () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE &ProvList <TYPE,ARG_TYPE> :: GetHead () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &head = clist.GetHead () ;
		criticalSection->Unlock () ;
		return head;
	}
	else
	{
		return clist.GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: GetHead () const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE head = clist.GetHead () ;
		criticalSection->Unlock () ;
		return head ;
	}
	else
	{
		return clist.GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE &ProvList <TYPE,ARG_TYPE> :: GetTail()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &tail = clist.GetTail () ;
		criticalSection->Unlock () ;
		return tail ;
	}
	else
	{
		return clist.GetTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: GetTail() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE tail = clist.GetTail () ;
		criticalSection->Unlock () ;
		return tail ;
	}
	else
	{
		return clist.GetTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: RemoveHead()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE head = clist.RemoveHead () ;
		criticalSection->Unlock () ;
		return head ;
	}
	else
	{
		return clist.RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: RemoveTail()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE tail = clist.RemoveTail () ;
		criticalSection->Unlock () ;
		return tail ;
	}
	else
	{
		return clist.RemoveTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: AddHead(ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.AddHead ( newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.AddHead ( newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: AddTail(ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.AddTail ( newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.AddTail ( newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvList <TYPE,ARG_TYPE> :: AddHead(ProvList<TYPE,ARG_TYPE> *pNewList)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.AddHead ( pNewList->clist ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.AddHead ( pNewList->clist ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvList <TYPE,ARG_TYPE> :: AddTail(ProvList<TYPE,ARG_TYPE> *pNewList)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.AddTail ( pNewList->clist ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.AddTail ( pNewList->clist ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvList <TYPE,ARG_TYPE> :: RemoveAll ()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.RemoveAll () ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.RemoveAll () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: GetHeadPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.GetHeadPosition () ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.GetHeadPosition () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: GetTailPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.GetTailPosition () ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.GetTailPosition () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& ProvList <TYPE,ARG_TYPE> :: GetNext(POSITION& rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &type = clist.GetNext ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetNext ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: GetNext(POSITION& rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = clist.GetNext ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetNext ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& ProvList <TYPE,ARG_TYPE> :: GetPrev(POSITION& rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &type = clist.GetPrev ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetPrev ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: GetPrev(POSITION& rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = clist.GetPrev ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetPrev ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& ProvList <TYPE,ARG_TYPE> :: GetAt(POSITION rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &type = clist.GetAt ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetAt ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: GetAt(POSITION rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = clist.GetAt ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetAt ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvList <TYPE,ARG_TYPE> :: SetAt(POSITION pos, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.SetAt ( pos , newElement ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.SetAt ( pos , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvList <TYPE,ARG_TYPE> :: RemoveAt(POSITION position)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.RemoveAt ( position ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.RemoveAt ( position ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: InsertBefore(POSITION position, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.InsertBefore ( position , newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.InsertBefore ( position , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: InsertAfter(POSITION position, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.InsertAfter ( position , newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.InsertAfter ( position , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: Find(ARG_TYPE searchValue, POSITION startAfter ) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.Find ( searchValue , startAfter ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.Find ( searchValue , startAfter ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: FindIndex(int nIndex) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.Find ( nIndex ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.Find ( nIndex ) ;
	}
}

template<class TYPE, class ARG_TYPE>
class ProvStack : public ProvList<TYPE,ARG_TYPE>
{
private:

	CCriticalSection * criticalSection ;

protected:
public:

	ProvStack ( BOOL threadSafeArg = FALSE ) ;
	virtual ~ProvStack () ;

	void Add ( ARG_TYPE type ) ;
	TYPE Get () ;
	TYPE Delete () ;
} ;

template<class TYPE, class ARG_TYPE>
ProvStack <TYPE, ARG_TYPE> :: ProvStack ( BOOL threadSafeArg ) : ProvList<TYPE,ARG_TYPE> ( FALSE ) , criticalSection ( NULL )
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
ProvStack <TYPE, ARG_TYPE> :: ~ProvStack () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
void ProvStack <TYPE, ARG_TYPE> :: Add ( ARG_TYPE type ) 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		AddHead ( type ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		AddHead ( type ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvStack <TYPE, ARG_TYPE> :: Get () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = GetHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvStack <TYPE,ARG_TYPE> :: Delete () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = RemoveHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
class ProvQueue : public ProvList<TYPE,ARG_TYPE>
{
private:

	CCriticalSection * criticalSection ;

protected:
public:

	ProvQueue ( BOOL threadSafeArg = FALSE ) ;
	virtual ~ProvQueue () ;

	void Add ( ARG_TYPE type ) ;
	TYPE Get () ;
	TYPE Delete () ;
	void Rotate () ;

} ;

template<class TYPE, class ARG_TYPE>
ProvQueue <TYPE, ARG_TYPE> :: ProvQueue ( BOOL threadSafeArg ) : ProvList<TYPE,ARG_TYPE> ( FALSE ) ,  criticalSection ( NULL )
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
ProvQueue <TYPE, ARG_TYPE> :: ~ProvQueue () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
void ProvQueue <TYPE, ARG_TYPE> :: Add ( ARG_TYPE type ) 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		AddTail ( type ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		AddTail ( type ) ;
	}
}


template<class TYPE, class ARG_TYPE>
TYPE ProvQueue <TYPE, ARG_TYPE> :: Get () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = GetHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvQueue <TYPE, ARG_TYPE> :: Delete () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = RemoveHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvQueue <TYPE, ARG_TYPE> :: Rotate ()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = Delete () ;
		Add ( type ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		TYPE type = Delete () ;
		Add ( type ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class ProvMap 
{
private:

	CCriticalSection * criticalSection ;
	CMap <KEY, ARG_KEY, VALUE, ARG_VALUE> cmap ;

protected:
public:

	ProvMap ( BOOL threadSafe = FALSE ) ;
	virtual ~ProvMap () ;

	int GetCount () const  ;
	BOOL IsEmpty () const ;
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const ;
	VALUE& operator[](ARG_KEY key) ;
	void SetAt(ARG_KEY key, ARG_VALUE newValue) ;
	BOOL RemoveKey(ARG_KEY key) ;
	void RemoveAll () ;
	POSITION GetStartPosition() const ;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const ;
} ;


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ProvMap ( BOOL threadSafeArg ) : criticalSection ( NULL ) 
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = FALSE ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ~ProvMap () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
int ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetCount() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		int count = cmap.GetCount () ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return cmap.GetCount () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: IsEmpty() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL isEmpty = cmap.IsEmpty () ;
		criticalSection->Unlock () ;
		return isEmpty ;
	}
	else
	{
		return cmap.IsEmpty () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: Lookup(ARG_KEY key, VALUE& rValue) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL lookup = cmap.Lookup ( key , rValue ) ;
		criticalSection->Unlock () ;
		return lookup ;
	}
	else
	{
		return cmap.Lookup ( key , rValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: operator[](ARG_KEY key)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		VALUE &value = cmap.operator [] ( key ) ;
		criticalSection->Unlock () ;
		return value ;
	}
	else
	{
		return cmap.operator [] ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SetAt(ARG_KEY key, ARG_VALUE newValue)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		cmap.SetAt ( key , newValue ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		cmap.SetAt ( key , newValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveKey(ARG_KEY key)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL removeKey = cmap.RemoveKey ( key ) ;
		criticalSection->Unlock () ;
		return removeKey ;
	}
	else
	{
		return cmap.RemoveKey ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveAll()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		cmap.RemoveAll () ;
		criticalSection->Unlock () ;
	}
	else
	{
		cmap.RemoveAll () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
POSITION ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetStartPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = cmap.GetStartPosition () ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return cmap.GetStartPosition () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
	}
}

#endif // __PROVCONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\include\provmt.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVMT_H__
#define __PROVMT_H__

#ifdef UNICODE
#define LPCTSTR wchar_t *
#else
#define LPCTSTR char *
#endif

class CSyncObject;
class CSemaphore;
class CMutex;
class CEvent;
class CCriticalSection;
class CSingleLock;
class CMultiLock;

/////////////////////////////////////////////////////////////////////////////
// Basic synchronization object

class CSyncObject
{
public:

	CSyncObject(LPCTSTR pstrName);

// Attributes
public:
	operator HANDLE() const;
	HANDLE  m_hObject;

// Operations
	virtual BOOL Lock(DWORD dwTimeout = INFINITE);
	virtual BOOL Unlock() = 0;
	virtual BOOL Unlock(LONG /* lCount */, LPLONG /* lpPrevCount=NULL */)
		{ return TRUE; }

// Implementation
public:
	virtual ~CSyncObject();
	friend class CSingleLock;
	friend class CMultiLock;
};

/////////////////////////////////////////////////////////////////////////////
// CSemaphore

class CSemaphore : public CSyncObject
{
// Constructor
public:
	CSemaphore(LONG lInitialCount = 1, LONG lMaxCount = 1,
		LPCTSTR pstrName=NULL, LPSECURITY_ATTRIBUTES lpsaAttributes = NULL);

// Implementation
public:
	virtual ~CSemaphore();
	virtual BOOL Unlock();
	virtual BOOL Unlock(LONG lCount, LPLONG lprevCount = NULL);
};

/////////////////////////////////////////////////////////////////////////////
// CMutex

class CMutex : public CSyncObject
{
// Constructor
public:
	CMutex(BOOL bInitiallyOwn = FALSE, LPCTSTR lpszName = NULL,
		LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Implementation
public:
	virtual ~CMutex();
	BOOL Unlock();
};

/////////////////////////////////////////////////////////////////////////////
// CEvent

class CEvent : public CSyncObject
{
// Constructor
public:
	CEvent(BOOL bInitiallyOwn = FALSE, BOOL bManualReset = FALSE,
		LPCTSTR lpszNAme = NULL, LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Operations
public:
	BOOL SetEvent();
	BOOL PulseEvent();
	BOOL ResetEvent();
	BOOL Unlock();

// Implementation
public:
	virtual ~CEvent();
};

/////////////////////////////////////////////////////////////////////////////
// CCriticalSection

class CCriticalSection : public CSyncObject
{
// Constructor
public:
CCriticalSection();

// Attributes
public:
	operator CRITICAL_SECTION*();
	CRITICAL_SECTION m_sect;

// Operations
public:
	BOOL Unlock();
	BOOL Lock();
	BOOL Lock(DWORD dwTimeout);

// Implementation
public:
	virtual ~CCriticalSection();
};

/////////////////////////////////////////////////////////////////////////////
// CCriticalSection

class CStaticCriticalSection : public CSyncObject
{
	static bool failureSet;
	static void RecordFailure(){ failureSet = true;}
	bool validCS;

// Constructor
public:
	
CStaticCriticalSection();

// Attributes
public:
	operator CRITICAL_SECTION*();
	CRITICAL_SECTION m_sect;

// Operations
public:
	static bool AnyFailure() { return failureSet;}
	BOOL Unlock();
	BOOL Lock();
	BOOL Lock(DWORD dwTimeout);

// Implementation
public:
	virtual ~CStaticCriticalSection();
};

/////////////////////////////////////////////////////////////////////////////
// CSingleLock

class CSingleLock
{
// Constructors
public:
	CSingleLock(CSyncObject* pObject, BOOL bInitialLock = FALSE);

// Operations
public:
	BOOL Lock(DWORD dwTimeOut = INFINITE);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked();

// Implementation
public:
	~CSingleLock();

protected:
	CSyncObject* m_pObject;
	HANDLE  m_hObject;
	BOOL    m_bAcquired;
};

/////////////////////////////////////////////////////////////////////////////
// CMultiLock

class CMultiLock
{
// Constructor
public:
	CMultiLock(CSyncObject* ppObjects[], DWORD dwCount, BOOL bInitialLock = FALSE);

// Operations
public:
	DWORD Lock(DWORD dwTimeOut = INFINITE, BOOL bWaitForAll = TRUE,
		DWORD dwWakeMask = 0);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked(DWORD dwItem);

// Implementation
public:
	~CMultiLock();

protected:
	HANDLE  m_hPreallocated[8];
	BOOL    m_bPreallocated[8];

	CSyncObject* const * m_ppObjectArray;
	HANDLE* m_pHandleArray;
	BOOL*   m_bLockedArray;
	DWORD   m_dwCount;
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline CSyncObject::operator HANDLE() const
	{ return m_hObject;}

inline BOOL CSemaphore::Unlock()
	{ return Unlock(1, NULL); }

inline BOOL CEvent::SetEvent()
	{ return ::SetEvent(m_hObject); }
inline BOOL CEvent::PulseEvent()
	{ return ::PulseEvent(m_hObject); }
inline BOOL CEvent::ResetEvent()
	{ return ::ResetEvent(m_hObject); }

inline CSingleLock::~CSingleLock()
	{ Unlock(); }
inline BOOL CSingleLock::IsLocked()
	{ return m_bAcquired; }

inline BOOL CMultiLock::IsLocked(DWORD dwObject)
	{ return m_bLockedArray[dwObject]; }

inline CCriticalSection::CCriticalSection() : CSyncObject(NULL)
	{ 
		if (!::InitializeCriticalSectionAndSpinCount(&m_sect,0))
		{
        	throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
		}
	}

inline CCriticalSection::operator CRITICAL_SECTION*()
	{ return (CRITICAL_SECTION*) &m_sect; }
inline CCriticalSection::~CCriticalSection()
	{ ::DeleteCriticalSection(&m_sect); }
inline BOOL CCriticalSection::Lock()
	{ ::EnterCriticalSection(&m_sect); return TRUE; }
inline BOOL CCriticalSection::Lock(DWORD /* dwTimeout */)
	{ return Lock(); }
inline BOOL CCriticalSection::Unlock()
	{ ::LeaveCriticalSection(&m_sect); return TRUE; }

inline CStaticCriticalSection::CStaticCriticalSection() : CSyncObject(NULL)
	{ 
		if (::InitializeCriticalSectionAndSpinCount(&m_sect,0))
		{
			validCS = true;
		}
		else
		{
			validCS = false;
			RecordFailure();
		}
	}
inline CStaticCriticalSection::~CStaticCriticalSection()
	{ if (validCS) ::DeleteCriticalSection(&m_sect); }

inline CStaticCriticalSection::operator CRITICAL_SECTION*()
	{ return (CRITICAL_SECTION*) &m_sect; }

inline BOOL CStaticCriticalSection::Lock()
	{ 
	if (validCS)
		{
		::EnterCriticalSection(&m_sect); return TRUE; 
		}
	else
		return FALSE;
	}
inline BOOL CStaticCriticalSection::Lock(DWORD /* dwTimeout */)
	{ return Lock(); }
inline BOOL CStaticCriticalSection::Unlock()
	{
	if (validCS)
		{
		::LeaveCriticalSection(&m_sect); return TRUE; 
		}
	else
		return FALSE;
	}

#endif  // __AFXMT_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\include\provstd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVSTD_H_
#define __PROVSTD_H_

#include <windows.h>
#include <winnls.h>
#include <stdio.h>
#include <provexpt.h>

struct __POSITION { };
typedef __POSITION* POSITION;
#define BEFORE_START_POSITION ((POSITION)-1L)

struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _AFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

class CObject 
{
public:

	CObject () {} ;
	virtual ~CObject () {} ;
} ;

#define AFXAPI __stdcall 
#define AFX_CDECL __cdecl

#pragma warning(disable: 4275)  // deriving exported class from non-exported
#pragma warning(disable: 4251)  // using non-exported as public in exported
#pragma warning(disable: 4114)

#include "provstr.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\include\provtempl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVTEMPL_H__
#define __PROVTEMPL_H__

#ifndef __PROVPLEX_H__
#include "plex.h"
#endif

//#include <new.h>
#include "provstd.h"
#include "provstr.h"

template<class TYPE>
inline void AFXAPI ConstructElements(TYPE* pElements, int nCount)
{
	// first do bit-wise zero initialization
	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	// then call the constructor(s)
	for (; nCount--; pElements++)
		::new((void*)pElements) TYPE;
}

template<class TYPE>
inline void AFXAPI DestructElements(TYPE* pElements, int nCount)
{
	// call the destructor(s)
	for (; nCount--; pElements++)
		pElements->~TYPE();
}

template<class TYPE>
inline void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
	// default is element-copy using assignment
	while (nCount--)
		*pDest++ = *pSrc++;
}

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT AFXAPI HashKey(ARG_KEY key)
{
	// default identity hash - works for most primitive values
	return (UINT)((UINT_PTR)key) >> 4;
}

///////////////////////////////////////////////////////////////////////////////
// CString support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CString> (CString* pElements, int nCount);
#else
void AFXAPI ConstructElements(CString* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CString> (CString* pElements, int nCount);
#else
void AFXAPI DestructElements(CString* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CString> (CString* pDest, const CString* pSrc, int nCount);
#else
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CStringA> (CStringA* pElements, int nCount);
#else
void AFXAPI ConstructElements(CStringA* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CStringA> (CStringA* pElements, int nCount);
#else
void AFXAPI DestructElements(CStringA* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CStringA> (CStringA* pDest, const CStringA* pSrc, int nCount);
#else
void AFXAPI CopyElements(CStringA* pDest, const CStringA* pSrc, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CStringW> (CStringW* pElements, int nCount);
#else
void AFXAPI ConstructElements(CStringW* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CStringW> (CStringW* pElements, int nCount);
#else
void AFXAPI DestructElements(CStringW* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CStringW> (CStringW* pDest, const CStringW* pSrc, int nCount);
#else
void AFXAPI CopyElements(CStringW* pDest, const CStringW* pSrc, int nCount);
#endif

/*
#ifndef OLE2ANSI
#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key);
#else
UINT AFXAPI HashKey(LPCWSTR key);
#endif
#endif

#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCSTR> (LPCSTR key);
#else
UINT AFXAPI HashKey(LPCSTR key);
#endif
*/

UINT AFXAPI HashKeyLPCWSTR(LPCWSTR key);
UINT AFXAPI HashKeyLPCSTR(LPCSTR key);

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray 
{
public:
// Construction
	CArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	TYPE GetAt(int nIndex) const;
	void SetAt(int nIndex, ARG_TYPE newElement);
	TYPE& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const TYPE* GetData() const;
	TYPE* GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, ARG_TYPE newElement);
	int Add(ARG_TYPE newElement);
	int Append(const CArray& src);
	void Copy(const CArray& src);

	// overloaded operator helpers
	TYPE operator[](int nIndex) const;
	TYPE& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
	TYPE* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CArray();
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
	{ return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
	{ SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
	{ return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
	{ m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
	{ return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
	{ return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
	{ return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
	if (m_pData != NULL)
	{
		DestructElements<TYPE>(m_pData, m_nSize);
		delete[] (BYTE*)m_pData;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		if (m_pData != NULL)
		{
			DestructElements<TYPE>(m_pData, m_nSize);
			delete[] (BYTE*)m_pData;
			m_pData = NULL;
		}
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
		ConstructElements<TYPE>(m_pData, nNewSize);
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);
		}
		else if (m_nSize > nNewSize)
		{
			// destroy the old elements
			DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = m_nSize / 8;
			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

		// construct remaining elements

		ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);
	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
	return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
	SetSize(src.m_nSize);
	CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
		TYPE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
			// copy new data from old
			memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
	if (nIndex >= m_nSize)
		SetSize(nIndex+1, -1);
	m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount, -1);  // grow it to new size
		// destroy intial data before copying over it
		DestructElements<TYPE>(&m_pData[nOldSize], nCount);
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(TYPE));

		// re-init slots we copied from
		ConstructElements<TYPE>(&m_pData[nIndex], nCount);
	}

	// insert new value in the gap

	while (nCount--)
		m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	DestructElements<TYPE>(&m_pData[nIndex], nCount);
	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(TYPE));
	m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList 
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	CList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CList* pNewList);
	void AddTail(CList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); // return *Position++
	TYPE GetNext(POSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(POSITION& rPosition); // return *Position--
	TYPE GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	POSITION FindIndex(int nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CList();
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
	{ return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
	{ return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
	{ return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
	{ return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		DestructElements<TYPE>(&pNode->data, 1);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
	RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}

	CList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;

	ConstructElements<TYPE>(&pNode->data, 1);
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
	DestructElements<TYPE>(&pNode->data, 1);
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;

	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
	CNode* pOldNode = (CNode*) position;

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements<TYPE>(&pNode->data, &searchValue))
			return (POSITION)pNode;
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap 
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		KEY key;
		VALUE value;
	};
public:
// Construction
	CMap(int nBlockSize = 10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
	~CMap();
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				DestructElements<VALUE>(&pAssoc->value, 1);
				DestructElements<KEY>(&pAssoc->key, 1);
			}
		}
	}

	// free hash table
	delete[] m_pHashTable;
	m_pHashTable = NULL;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
	RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
		// chain them into free list
		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}

	CMap::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;

	ConstructElements<KEY>(&pAssoc->key, 1);
	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
	DestructElements<VALUE>(&pAssoc->value, 1);
	DestructElements<KEY>(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	UINT nHash;
	CAssoc* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	UINT nHash;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	CAssoc* pAssocRet = (CAssoc*)rNextPosition;

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
	}

	// find next association

	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(int nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(int nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
	void SetAt(int nIndex, TYPE ptr)
		{ BASE_CLASS::SetAt(nIndex, ptr); }

	// Potentially growing the array
	void SetAtGrow(int nIndex, TYPE newElement)
	   { BASE_CLASS::SetAtGrow(nIndex, newElement); }
	int Add(TYPE newElement)
	   { return BASE_CLASS::Add(newElement); }
	int Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
	   { return BASE_CLASS::Append(src); }
	void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
		{ BASE_CLASS::Copy(src); }

	// Operations that move elements around
	void InsertAt(int nIndex, TYPE newElement, int nCount = 1)
		{ BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
	void InsertAt(int nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
	   { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

	// overloaded operator helpers
	TYPE operator[](int nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](int nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
// Construction
	CTypedPtrList(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// peek at head or tail
	TYPE& GetHead()
		{ return (TYPE&)BASE_CLASS::GetHead(); }
	TYPE GetHead() const
		{ return (TYPE)BASE_CLASS::GetHead(); }
	TYPE& GetTail()
		{ return (TYPE&)BASE_CLASS::GetTail(); }
	TYPE GetTail() const
		{ return (TYPE)BASE_CLASS::GetTail(); }

	// get head or tail (and remove it) - don't call on empty list!
	TYPE RemoveHead()
		{ return (TYPE)BASE_CLASS::RemoveHead(); }
	TYPE RemoveTail()
		{ return (TYPE)BASE_CLASS::RemoveTail(); }

	// add before head or after tail
	POSITION AddHead(TYPE newElement)
		{ return BASE_CLASS::AddHead(newElement); }
	POSITION AddTail(TYPE newElement)
		{ return BASE_CLASS::AddTail(newElement); }

	// add another list of elements before head or after tail
	void AddHead(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddHead(pNewList); }
	void AddTail(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddTail(pNewList); }

	// iteration
	TYPE& GetNext(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetNext(rPosition); }
	TYPE GetNext(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetNext(rPosition); }
	TYPE& GetPrev(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
	TYPE GetPrev(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetPrev(rPosition); }

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position)
		{ return (TYPE&)BASE_CLASS::GetAt(position); }
	TYPE GetAt(POSITION position) const
		{ return (TYPE)BASE_CLASS::GetAt(position); }
	void SetAt(POSITION pos, TYPE newElement)
		{ BASE_CLASS::SetAt(pos, newElement); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:

// Construction
	CTypedPtrMap(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// Lookup
	BOOL Lookup(typename BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

	// Lookup and add if not there
	VALUE& operator[](typename BASE_CLASS::BASE_ARG_KEY key)
		{ return (VALUE&)BASE_CLASS::operator[](key); }

	// add a new key (key, value) pair
	void SetAt(KEY key, VALUE newValue)
		{ BASE_CLASS::SetAt(key, newValue); }

	// removing existing (key, ?) pair
	BOOL RemoveKey(KEY key)
		{ return BASE_CLASS::RemoveKey(key); }

	// iteration
	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
			(BASE_CLASS::BASE_VALUE&)rValue); }
};

/////////////////////////////////////////////////////////////////////////////

#endif //__AFXTEMPL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\precomp.h ===
#include <objbase.h>
#include <initguid.h>

extern "C"
{
#include <windows.h>
#include <winnls.h>
#include <stdio.h>
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\provmfc\include\provstr.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _PROVSTR_H_
#define _PROVSTR_H_

#include "provstd.h"
#include <tchar.h>

//use TCHAR and depend on UNICODE definition
struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString AFXAPI operator+(const CString& string1,
			const CString& string2);
	friend CString AFXAPI operator+(const CString& string, TCHAR ch);
	friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString AFXAPI operator+(const CString& string, char ch);
	friend CString AFXAPI operator+(char ch, const CString& string);
#endif
	friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
	friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void AFX_CDECL Format(LPCTSTR lpszFormat, ...);

#ifndef _MAC
	// formatting for localization (uses FormatMessage API)
	void AFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
#endif

#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool AFXAPI operator==(const CString& s1, const CString& s2);
bool AFXAPI operator==(const CString& s1, LPCTSTR s2);
bool AFXAPI operator==(LPCTSTR s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2);


//regardless of UNICODE definition always use char
struct CStringDataA
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// char data[nAllocLength]

	char* data()
		{ return (char*)(this+1); }
};

class CStringA
{
public:
// Constructors
	CStringA();
	CStringA(const CStringA& stringSrc);
	CStringA(char ch, int nRepeat = 1);
	CStringA(LPCSTR lpsz);
	CStringA(LPCWSTR lpsz);
	CStringA(LPCSTR lpch, int nLength);
	CStringA(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	char GetAt(int nIndex) const;      // 0 based
	char operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, char ch);
	operator LPCSTR() const;           // as a C string

	// overloaded assignment
	const CStringA& operator=(const CStringA& stringSrc);
	const CStringA& operator=(char ch);
	const CStringA& operator=(LPCSTR lpsz);
	const CStringA& operator=(LPCWSTR lpsz);
	const CStringA& operator=(const unsigned char* psz);

	// string concatenation
	const CStringA& operator+=(const CStringA& string);
	const CStringA& operator+=(char ch);
	const CStringA& operator+=(LPCSTR lpsz);

	friend CStringA AFXAPI operator+(const CStringA& string1,
			const CStringA& string2);
	friend CStringA AFXAPI operator+(const CStringA& string, char ch);
	friend CStringA AFXAPI operator+(char ch, const CStringA& string);
	friend CStringA AFXAPI operator+(const CStringA& string, LPCSTR lpsz);
	friend CStringA AFXAPI operator+(LPCSTR lpsz, const CStringA& string);

	// string comparison
	int Compare(LPCSTR lpsz) const;         // straight character
	int CompareNoCase(LPCSTR lpsz) const;   // ignore case
	int Collate(LPCSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CStringA Mid(int nFirst, int nCount) const;
	CStringA Mid(int nFirst) const;
	CStringA Left(int nCount) const;
	CStringA Right(int nCount) const;

	CStringA SpanIncluding(LPCSTR lpszCharSet) const;
	CStringA SpanExcluding(LPCSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(char ch) const;               // like "C" strchr
	int ReverseFind(char ch) const;
	int FindOneOf(LPCSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void AFX_CDECL Format(LPCSTR lpszFormat, ...);

#ifndef _MAC
	// formatting for localization (uses FormatMessage API)
	void AFX_CDECL FormatMessage(LPCSTR lpszFormat, ...);
#endif

	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();

	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

	// Access to string implementation buffer as "C" character array
	LPSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CStringA();
	int GetAllocLength() const;

protected:
	LPSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringDataA* GetData() const;
	void Init();
	void AllocCopy(CStringA& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCSTR lpszSrc1Data, int nSrc2Len, LPCSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCSTR lpszSrcData);
	void FormatV(LPCSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringDataA* pData);
	static int PASCAL SafeStrlen(LPCSTR lpsz);
};

// Compare helpers
bool AFXAPI operator==(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator==(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator==(LPCSTR s1, const CStringA& s2);
bool AFXAPI operator!=(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator!=(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator!=(LPCSTR s1, const CStringA& s2);
bool AFXAPI operator<(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator<(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator<(LPCSTR s1, const CStringA& s2);
bool AFXAPI operator>(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator>(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator>(LPCSTR s1, const CStringA& s2);
bool AFXAPI operator<=(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator<=(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator<=(LPCSTR s1, const CStringA& s2);
bool AFXAPI operator>=(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator>=(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator>=(LPCSTR s1, const CStringA& s2);


//regardless of UNICODE definition always use wchar

struct CStringDataW
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// WCHAR data[nAllocLength]

	WCHAR* data()
		{ return (WCHAR*)(this+1); }
};

class CStringW
{
public:
// Constructors
	CStringW();
	CStringW(const CStringW& stringSrc);
	CStringW(WCHAR ch, int nRepeat = 1);
	CStringW(LPCSTR lpsz);
	CStringW(LPCWSTR lpsz);
	CStringW(LPCWSTR lpch, int nLength);
	CStringW(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	WCHAR GetAt(int nIndex) const;      // 0 based
	WCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, WCHAR ch);
	operator LPCWSTR() const;           // as a C string

	// overloaded assignment
	const CStringW& operator=(const CStringW& stringSrc);
	const CStringW& operator=(WCHAR ch);
	const CStringW& operator=(char ch);
	const CStringW& operator=(LPCSTR lpsz);
	const CStringW& operator=(LPCWSTR lpsz);
	const CStringW& operator=(const unsigned char* psz);

	// string concatenation
	const CStringW& operator+=(const CStringW& string);
	const CStringW& operator+=(WCHAR ch);
	const CStringW& operator+=(char ch);
	const CStringW& operator+=(LPCWSTR lpsz);

	friend CStringW AFXAPI operator+(const CStringW& string1,
			const CStringW& string2);
	friend CStringW AFXAPI operator+(const CStringW& string, WCHAR ch);
	friend CStringW AFXAPI operator+(WCHAR ch, const CStringW& string);
	friend CStringW AFXAPI operator+(const CStringW& string, char ch);
	friend CStringW AFXAPI operator+(char ch, const CStringW& string);
	friend CStringW AFXAPI operator+(const CStringW& string, LPCWSTR lpsz);
	friend CStringW AFXAPI operator+(LPCWSTR lpsz, const CStringW& string);

	// string comparison
	int Compare(LPCWSTR lpsz) const;         // straight character
	int CompareNoCase(LPCWSTR lpsz) const;   // ignore case
	int Collate(LPCWSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CStringW Mid(int nFirst, int nCount) const;
	CStringW Mid(int nFirst) const;
	CStringW Left(int nCount) const;
	CStringW Right(int nCount) const;

	CStringW SpanIncluding(LPCWSTR lpszCharSet) const;
	CStringW SpanExcluding(LPCWSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(WCHAR ch) const;               // like "C" strchr
	int ReverseFind(WCHAR ch) const;
	int FindOneOf(LPCWSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCWSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void AFX_CDECL Format(LPCWSTR lpszFormat, ...);

#ifndef _MAC
	// formatting for localization (uses FormatMessage API)
	void AFX_CDECL FormatMessage(LPCWSTR lpszFormat, ...);
#endif

	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

	// Access to string implementation buffer as "C" character array
	LPWSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPWSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPWSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CStringW();
	int GetAllocLength() const;

protected:
	LPWSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringDataW* GetData() const;
	void Init();
	void AllocCopy(CStringW& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCWSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data, int nSrc2Len, LPCWSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData);
	void FormatV(LPCWSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringDataW* pData);
	static int PASCAL SafeStrlen(LPCWSTR lpsz);
};

// Compare helpers
bool AFXAPI operator==(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator==(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator==(LPCWSTR s1, const CStringW& s2);
bool AFXAPI operator!=(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator!=(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator!=(LPCWSTR s1, const CStringW& s2);
bool AFXAPI operator<(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator<(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator<(LPCWSTR s1, const CStringW& s2);
bool AFXAPI operator>(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator>(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator>(LPCWSTR s1, const CStringW& s2);
bool AFXAPI operator<=(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator<=(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator<=(LPCWSTR s1, const CStringW& s2);
bool AFXAPI operator>=(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator>=(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator>=(LPCWSTR s1, const CStringW& s2);

// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern TCHAR afxChNil;
const CString& AFXAPI AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()

extern char afxChNilA;
const CStringA& AFXAPI AfxGetEmptyStringA();
#define afxEmptyStringA AfxGetEmptyStringA()

extern WCHAR afxChNilW;
const CStringW& AFXAPI AfxGetEmptyStringW();
#define afxEmptyStringW AfxGetEmptyStringW()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks.  

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <process.h>
#include <objbase.h>
#include <provcont.h>
#include "provevt.h"
#include "provlog.h"

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	BOOL status = TRUE ;
	if ( DLL_PROCESS_DETACH == ulReason )
	{


	}
	else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		DisableThreadLibraryCalls(hInstance);			// 158024 
		status = !CStaticCriticalSection::AnyFailure();
	}
	else if ( DLL_THREAD_DETACH == ulReason )
	{
	}
	else if ( DLL_THREAD_ATTACH == ulReason )
	{
	}
    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\provdnf.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <wbemint.h>
#include <typeinfo.h>
#include <process.h>
#include <stdio.h>
#include <strsafe.h>
#include <provcont.h>
#include <provevt.h>
#include <provlog.h>
#include <genlex.h>
#include <sql_1.h>
#include <provtree.h>
#include <provdnf.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOrNode :: ~WmiOrNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAndNode :: ~WmiAndNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiNotNode :: ~WmiNotNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualNode :: ~WmiOperatorEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotEqualNode :: ~WmiOperatorNotEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrGreaterNode :: ~WmiOperatorEqualOrGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrLessNode :: ~WmiOperatorEqualOrLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorGreaterNode :: ~WmiOperatorGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLessNode :: ~WmiOperatorLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLikeNode :: ~WmiOperatorLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotLikeNode :: ~WmiOperatorNotLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorIsANode :: ~WmiOperatorIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotIsANode :: ~WmiOperatorNotIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOrNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;

			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOrNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiAndNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;

			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiAndNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNotNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNotNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{	
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiSignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiUnsignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiStringNode ( m_PropertyName , m_String , m_PropertyFunction , m_ConstantFunction , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNullNode ( m_PropertyName , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiSignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiUnsignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiStringRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStringNode :: WmiStringNode ( 

	BSTR a_PropertyName ,
	BSTR a_String ,
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	ULONG a_Index ,
	WmiTreeNode *a_Parent 

) : WmiValueNode ( 

		TypeId_WmiStringNode ,
		a_PropertyName , 
		a_PropertyFunction , 
		Function_None ,
		a_Index ,
		a_Parent 
	) 
{
	if ( a_String ) 
	{
		if ( a_ConstantFunction == Function_Upper )
		{
			ULONG t_StringLength = wcslen ( a_String ) ;
			wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
			for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
			{
				t_String [ t_Index ] = towlower ( a_String [ t_Index ] ) ;
			}

			m_String = SysAllocString ( t_String ) ;
			delete [] t_String ;
		}
		else if ( a_ConstantFunction == Function_Upper )
		{
			ULONG t_StringLength = wcslen ( a_String ) ;
			wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
			for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
			{
				t_String [ t_Index ] = towupper ( a_String [ t_Index ] ) ;
			}

			m_String = SysAllocString ( t_String ) ;
			delete [] t_String ;
		}
		else
		{
			m_String = SysAllocString ( a_String ) ;
		}

		if ( m_String == NULL )
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}
	}
	else
	{
		m_String = NULL ;
	}
}

WmiStringNode :: ~WmiStringNode ()
{
	if ( m_String )
	{
		SysFreeString ( m_String ) ;
	}
} ;

BOOL WmiStringNode :: LexicographicallyBefore ( BSTR &a_String )
{
	if ( wcscmp ( L"" , m_String ) == 0 )
	{
		return FALSE ;
	}
	else
	{
		ULONG t_StringLen = wcslen ( m_String ) ;
		wchar_t *t_String = NULL ;

		if ( m_String [ t_StringLen - 1 ] == 0x01 )
		{
			t_String = new wchar_t [ t_StringLen ] ;
			StringCchCopyNW ( t_String , t_StringLen , m_String , t_StringLen - 1 ) ;
			t_String [ t_StringLen ] = 0 ;
		}
		else
		{
			t_String = new wchar_t [ t_StringLen + 1 ] ;
			StringCchCopyW ( t_String , t_StringLen + 1 , m_String ) ;
			t_String [ t_StringLen - 1 ] = t_String [ t_StringLen - 1 ] - 1 ;
		}			
		
		a_String = SysAllocString ( t_String ) ;
		delete [] t_String ;

		return TRUE ;
	}
}

BOOL WmiStringNode :: LexicographicallyAfter ( BSTR &a_String )
{
	ULONG t_StringLen = wcslen ( m_String ) ;
	wchar_t *t_String = new wchar_t [ t_StringLen + 2 ] ;
	StringCchCopyW ( t_String , t_StringLen + 2 , m_String ) ;
	t_String [ t_StringLen ] = 0x01 ;
	t_String [ t_StringLen + 1 ] = 0x00 ;

	a_String = SysAllocString ( t_String ) ;

	delete [] t_String ;

	return TRUE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiNullRangeNode ( m_PropertyName , m_Index , NULL , NULL ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOrNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ) "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" Or "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ) "
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiAndNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ) "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" And "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNotNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Not"
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" = "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotEqualNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" != "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrGreaterNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" >= "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrLessNode :: Print () 
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" <= "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLessNode :: Print () 
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" < "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorGreaterNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" > "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLikeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" Like "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotLikeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" NotLike "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorIsANode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotIsANode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" Not IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %s ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %ld ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %d ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %s , %s , %s , %s , %s , %s ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? L"" : m_LowerBound ,
		m_InfiniteUpperBound ? L"" : m_UpperBound 
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %s , %s , %s , %s , %lu , %lu ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %s , %s , %s , %s , %ld , %ld ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLess (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLessOrEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerGreater (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLess (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLessOrEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerGreater (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLess (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) < 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
  		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLessOrEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) <= 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringGreater (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) > 0 ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return wcscmp ( X , Y ) == 0 ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareLessRangeNode ( 

	WmiRangeNode *a_LeftRange ,
	WmiRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( ( a_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
	{
		WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) a_LeftRange ;
		WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLess ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ? -1 : 0 ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
	{
		WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) a_LeftRange ;
		WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
	{
		WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) a_LeftRange ;
		WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiNullRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiNullRangeNode ) )
	{
		t_State = TRUE ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareLessOrEqualRangeNode ( 

	WmiRangeNode *a_LeftRange ,
	WmiRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( ( a_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
	{
		WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) a_LeftRange ;
		WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLessOrEqual ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ? -1 : 0 ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
	{
		WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) a_LeftRange ;
		WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
	{
		WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) a_LeftRange ;
		WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiNullRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiNullRangeNode ) )
	{
		t_State = TRUE ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetIntersectingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )


				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
                }
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
                }
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
#if DBG
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
#endif
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
				}
			}
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
#if DBG
// Can never happen
DebugBreak () ;
#endif
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
				}
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == -1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

   				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
                }
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
                }
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
#if DBG
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
#endif
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
				}
			}
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
#if DBG
// Can never happen
DebugBreak () ;
#endif
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == -1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetOverlappingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
                }
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
#if DBG
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
#endif
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE ,
					    X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					    Y_E_CLOSED ,
					    Y_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
#if DBG
// Can never happen
DebugBreak () ;
#endif
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
				}
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( :: State_True ) : ( :: State_Error ) ;
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					FALSE ,
					TRUE ,
					TRUE ,
					t_String->GetValue () ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualOrGreaterNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					TRUE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualOrLessNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					TRUE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorLessNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue ()  ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					FALSE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorGreaterNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE , 
				t_Integer->GetValue (),
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					FALSE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorLikeNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorNotLikeNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorIsANode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorNotIsANode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
#if DBG
// Can never happen
DebugBreak () ;
#endif
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: RecursiveEvaluate ( 

	void *a_Context ,
	SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
	WmiTreeNode *a_Parent , 
	WmiTreeNode **a_Node , 
	int &a_Index 
)
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"RecursiveEvaluate ( int &a_Index )"
	) ;
)

	BOOL t_Status = FALSE ;

	SQL_LEVEL_1_TOKEN *propertyValue = & ( a_Expression.pArrayOfTokens [ a_Index ] ) ;
	a_Index -- ;

	switch ( propertyValue->nTokenType )
	{
		case SQL_LEVEL_1_TOKEN :: OP_EXPRESSION:
		{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Operation = OP_EXPESSION"
	) ;
)

			WmiTreeNode *t_ParentNode = a_Parent ;
			WmiTreeNode **t_Node = a_Node ;
			WmiTreeNode *t_OperatorNode = NULL ;

			switch ( propertyValue->nOperator )
			{
				case SQL_LEVEL_1_TOKEN :: OP_EQUAL:
				{
					t_OperatorNode = new WmiOperatorEqualNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_NOT_EQUAL:
				{
					t_OperatorNode = new WmiOperatorNotEqualNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_EQUALorGREATERTHAN:
				{
					t_OperatorNode = new WmiOperatorEqualOrGreaterNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_EQUALorLESSTHAN: 
				{
					t_OperatorNode = new WmiOperatorEqualOrLessNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_LESSTHAN:
				{
					t_OperatorNode = new WmiOperatorLessNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_GREATERTHAN:
				{
					t_OperatorNode = new WmiOperatorGreaterNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_LIKE:
				{
					t_OperatorNode = new WmiOperatorLikeNode ( NULL , t_ParentNode ) ;
				}
				break ;

				default:
				{
				}
				break ;
			}

			if ( t_OperatorNode )
			{
				*t_Node = t_OperatorNode ;
				t_ParentNode = t_OperatorNode ;
				(*t_Node)->GetLeft ( t_Node ) ;

				t_Status = TRUE ;
			}

			WmiValueNode :: WmiValueFunction t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_None ;

			switch ( propertyValue->dwPropertyFunction )
			{
				case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
				{
					t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
				{
					t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
				default:
				{
				}
				break ;

			}
			
			WmiValueNode :: WmiValueFunction t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_None ;
			switch ( propertyValue->dwConstFunction )
			{
				case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
				{
					t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
				{
					t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
				default:
				{
				}
				break ;
			}

			WmiTreeNode *t_ValueNode = AllocTypeNode ( 

				a_Context ,
				propertyValue->pPropertyName , 
				propertyValue->vConstValue , 
				t_PropertyFunction ,
				t_ConstantFunction ,
				t_ParentNode 
			) ;

			if ( t_ValueNode )
			{
				*t_Node = t_ValueNode ;

				t_Status = TRUE ;
			}
			else
			{				
				t_Status = FALSE ;
			}
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_AND:
		{
			*a_Node = new WmiAndNode ( NULL , NULL , a_Parent ) ;
			WmiTreeNode **t_Left = NULL ;
			WmiTreeNode **t_Right = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;
			(*a_Node)->GetRight ( t_Right ) ;

			t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
						RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Operation = TOKEN_AND"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_OR:
		{
			*a_Node = new WmiOrNode ( NULL , NULL , a_Parent ) ;
			WmiTreeNode **t_Left = NULL ;
			WmiTreeNode **t_Right = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;
			(*a_Node)->GetRight ( t_Right ) ;

			t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
						RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  


		L"Operation = TOKEN_OR"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_NOT:
		{
			*a_Node = new WmiNotNode ( NULL , a_Parent ) ;
			WmiTreeNode **t_Left = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;

			t_Status = RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Operation = TOKEN_NOT"
	) ;
)

		}
		break ;
	}
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"RecursiveEvaluation t_Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: Evaluate ( 

	void *a_Context ,
	SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
	WmiTreeNode **a_Root 
)
{
	BOOL t_Status = TRUE ;
	if ( a_Expression.nNumTokens )
	{
		int t_Count = a_Expression.nNumTokens - 1 ;
		t_Status = RecursiveEvaluate ( a_Context , a_Expression , NULL , a_Root , t_Count ) ;
	}
	else
	{
	}

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"PostEvaluation Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: PrintTree ( WmiTreeNode *a_Root )
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Expression = "
	) ;

	if ( a_Root ) 
		a_Root->Print () ;

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"\n"
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_AndChild , 
	WmiTreeNode *a_OrChild 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_OrChild->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_OrChild->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_NewOrNodeLeft = new WmiAndNode ( a_AndChild , t_OrLeftChild , t_NewOrNode ) ;
		if ( t_NewOrNodeLeft )
		{
			t_NewOrNode->SetLeft ( t_NewOrNodeLeft ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_AndChildCopy = a_AndChild->Copy () ;
		if ( t_AndChildCopy )
		{
			WmiTreeNode *t_NewOrNodeRight = new WmiAndNode ( t_AndChildCopy , t_OrRightChild , t_NewOrNode ) ;
			if ( t_NewOrNodeRight )
			{
				t_NewOrNode->SetRight ( t_NewOrNodeRight ) ;
			}
			else
			{
				t_Status = :: State_Error ;
			}
		}
		else
		{
			t_Status = :: State_Error ;
		}

		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_NewOrNode ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_NewOrNode ) ;
			}	
		}

		a_Node->SetLeft ( NULL ) ;
		a_Node->SetRight ( NULL ) ;
		a_Node->SetData ( NULL ) ;

		a_OrChild->SetLeft ( NULL ) ;
		a_OrChild->SetRight ( NULL ) ;
		a_OrChild->SetData ( NULL ) ;

		delete a_Node ; 
		a_Node = NULL ;

		delete a_OrChild ; 
		a_OrChild = NULL ;
	}

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
		a_Node = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotNotExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	t_Leaf->SetParent ( t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_Leaf ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_Leaf ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	a_Node = t_Leaf ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotAndExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_AndLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_AndRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_AndLeftChild , t_NewOrNode ) ;
		if ( t_LeftNot )
		{
			t_NewOrNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_AndRightChild , t_NewOrNode ) ;
		if ( t_RightNot )
		{
			t_NewOrNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewAndNode = new WmiAndNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewAndNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_OrLeftChild , t_NewAndNode ) ;
		if ( t_LeftNot )
		{
			t_NewAndNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_OrRightChild , t_NewAndNode ) ;
		if ( t_RightNot )
		{
			t_NewAndNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewAndNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewAndNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewAndNode ;
	}
	else
	{
		delete t_NewAndNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LessNode = new WmiOperatorLessNode  ( a_Child , t_NewOrNode ) ;
		if ( t_LessNode )
		{
			t_NewOrNode->SetLeft ( t_LessNode ) ;
		}
		else
		{
			t_Status = :: State_Error ;
		}

		WmiTreeNode *t_CopyGreaterChild = a_Child->Copy () ;
		if ( t_CopyGreaterChild )
		{
			WmiTreeNode *t_GreatorNode = new WmiOperatorGreaterNode  ( t_CopyGreaterChild , t_NewOrNode ) ;
			if ( t_GreatorNode )
			{
				t_NewOrNode->SetRight ( t_GreatorNode ) ;
			}
			else
			{
				t_Status = :: State_Error ;
			}
		}
		else
		{
			t_Status = :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndTrueEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	
	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;
	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOrFalseEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	

	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;

	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOperatorToRange ( 

	WmiTreeNode *&a_Node 
)
{
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiOperatorNode *t_OperatorNode = ( WmiOperatorNode * ) a_Node ;
	WmiTreeNode *t_Range = t_OperatorNode->GetRange () ;
	if ( t_Range )
	{
		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_Range ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_Range ) ;
			}	
		}

		t_Range->SetParent ( t_Parent ) ;
	}

	delete a_Node ;

	a_Node = t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotExpression ( WmiTreeNode *&a_Node )
{
	if ( a_Node->GetLeft () )
	{
		WmiTreeNode *t_Left = a_Node->GetLeft () ;
		if ( t_Left->GetType () == TypeId_WmiAndNode ) 
		{
			TransformNotAndExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformNotOrExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiNotNode ) 
		{
			TransformNotNotExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformNotOperatorEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			TransformNotOperatorNotEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformNotOperatorEqualOrGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformNotOperatorEqualOrLessExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformNotOperatorLessExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformNotOperatorGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformNotOperatorLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformNotOperatorNotLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformNotOperatorIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformNotOperatorNotIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
		else
		{
			return :: State_False ; 
		}
	}

	return :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotEqualExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;

	TransformNotEqualExpression ( a_Node , t_Left ) ;
	return a_Node ? :: State_True : :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateAndExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;
	WmiTreeNode *t_Right = a_Node->GetRight () ;
	
	if ( t_Left )
	{
		if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Right , t_Left ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
	}

	if ( t_Right )
	{
		if ( t_Right->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Left , t_Right ) ;
			return a_Node ? :: State_True : :: State_Error ;
		}
	}

	return :: State_False ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateOrExpression ( WmiTreeNode *&a_Node )
{
	return :: State_False  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node )
{
	QueryPreprocessor :: QuadState t_Status = State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			if ( EvaluateAndExpression ( a_Node ) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			if ( EvaluateOrExpression ( a_Node ) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
			if ( EvaluateNotExpression ( a_Node ) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			if ( EvaluateNotEqualExpression ( a_Node ) == :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) 
{
	QueryPreprocessor :: QuadState t_Status = RecursiveDisjunctiveNormalForm ( a_Root ) ;
	if ( t_Status == QuadState :: State_ReEvaluate )
	{
		t_Status = DisjunctiveNormalForm ( a_Root ) ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveInvariants ( 

	void *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context, a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;
				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
			}
		}
		else
		{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveInvariants (

	void *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QuadState t_Status = RecursiveRemoveInvariants ( a_Context , a_Root ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveInvariants ( a_Context , a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveInsertNode ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;

			if ( t_Left )
			{
				t_Status = RecursiveInsertNode ( t_Left , a_Insertion ) ;
				if ( t_Status != :: State_False )
				{
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Right  )
			{
				t_Status = RecursiveInsertNode ( t_Right , a_Insertion ) ;
				if ( t_Status != :: State_False )
				{
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
		}
		else
		{
// Operator

			WmiValueNode *t_CompareValue = ( WmiValueNode * ) a_Node->GetLeft () ;
			WmiValueNode *t_InsertionValue = ( WmiValueNode * ) a_Insertion->GetLeft () ;
			LONG t_Compare = t_InsertionValue ->ComparePropertyName ( *t_CompareValue ) ;
			if ( t_Compare < 0 )
			{
// Insert to left

				WmiTreeNode *t_Parent = a_Node->GetParent () ;
				WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_Insertion , a_Node , t_Parent ) ;
				if ( t_NewAndNode )
				{
					a_Node->SetParent ( t_NewAndNode ) ;
					a_Insertion->SetParent ( t_NewAndNode ) ;

					if ( t_Parent )
					{
						if ( t_Parent->GetLeft () == a_Node )
						{
							t_Parent->SetLeft ( t_NewAndNode ) ;
						}
						else
						{
							t_Parent->SetRight ( t_NewAndNode ) ;
						}
					}

					a_Node = t_NewAndNode ;

					t_Status = :: State_True ;
				}
				else
				{
					t_Status = :: State_Error ; 
				}
			}
			else
			{
				t_Status = :: State_False  ;
			}
		}
	}
	else
	{
		a_Node = a_Insertion ;

		t_Status = :: State_True ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState  QueryPreprocessor :: InsertNode ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = RecursiveInsertNode ( a_NewRoot , a_Insertion ) ;
	if ( t_Status == :: State_False  )
	{
// Insert to right

		WmiTreeNode *t_Parent = a_NewRoot->GetParent () ;
		WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_NewRoot , a_Insertion , t_Parent ) ;
		if ( t_NewAndNode )
		{
			a_NewRoot->SetParent ( t_NewAndNode ) ;
			a_Insertion->SetParent ( t_NewAndNode ) ;

			if ( t_Parent )
			{
				if ( t_Parent->GetLeft () == a_NewRoot )
				{
					t_Parent->SetLeft ( t_NewAndNode ) ;
				}
				else
				{
					t_Parent->SetRight ( t_NewAndNode ) ;
				}
			}

			a_NewRoot = t_NewAndNode ;
		}
		else
		{
			return :: State_Error ;
		}
	}

	return :: State_True ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSortConditionals ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Left  ) ;
				a_Node->SetLeft ( NULL ) ;
				delete t_Left ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Right ) ;
				a_Node->SetRight ( NULL ) ;
				delete t_Right ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
		}
		else
		{
// Operator

			WmiTreeNode *t_Parent = a_Node->GetParent () ;
			if ( t_Parent ) 
			{
				if ( t_Parent->GetLeft () == a_Node )
				{
					t_Parent->SetLeft ( NULL ) ;
				}
				else
				{
					t_Parent->SetRight ( NULL ) ;
				}
			}

			a_Node->SetParent ( NULL ) ;

			t_Status = InsertNode ( a_NewRoot , a_Node ) ;

			a_Node = NULL ;
		}		
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: SortConditionals ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_NewRoot = NULL ;
	WmiTriState t_Status = RecursiveSortConditionals ( t_NewRoot , a_Root ) ;

    if ( a_Root )
    {
	    WmiTreeNode *t_Parent = a_Root->GetParent () ;
	    if ( t_Parent ) 
	    {
		    if ( t_Parent->GetLeft () == a_Root )
		    {
			    t_Parent->SetLeft ( t_NewRoot ) ;
		    }
		    else
		    {
			    t_Parent->SetRight ( t_NewRoot ) ;
		    }
	    }

	    t_NewRoot->SetParent ( t_Parent ) ;

	    delete a_Root ;
    }

	a_Root = t_NewRoot ;

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSort ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSort ( t_Left ) ;
			}

			if ( t_Status == :: State_True )
			{
				if ( t_Right  )
				{
					t_Status = RecursiveSort ( t_Right ) ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			t_Status = SortConditionals ( a_Node ) ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
		}
		else
		{
// Single operand
			t_Status = :: State_True ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: Sort ( WmiTreeNode *&a_Root )
{
	WmiTriState t_Status = RecursiveSort ( a_Root ) ;
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveConvertToRanges ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = :: State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? :: State_True : :: State_Error ;
		}
		else
		{
#if DBG
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
#endif
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: ConvertToRanges ( WmiTreeNode *&a_Root )
{
	return RecursiveConvertToRanges ( a_Root ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare ,
	WmiTreeNode *a_Intersection
)
{
	WmiTreeNode *t_CompareParent = a_Compare->GetParent () ;
	if ( t_CompareParent )
	{
		if ( t_CompareParent->GetLeft () == a_Compare )
		{
			t_CompareParent->SetLeft ( a_Intersection ) ;
		}
		else
		{
			t_CompareParent->SetRight ( a_Intersection ) ;
		}

		a_Intersection->SetParent ( t_CompareParent ) ;

		delete a_Compare ; 
		a_Compare = NULL ;
	}
	else
	{
#if DBG
// Should never happen
DebugBreak () ;
#endif
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNonIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare
) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Compare )
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					a_Compare = NULL ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;

				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

                    a_Compare = NULL;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNullRangeNode ) 
		{
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiNullRangeNode ) 
					{
						WmiTreeNode *t_Intersection = a_Node->Copy () ;

						TransformIntersectingRange (

							a_Node ,
							a_Compare ,
							t_Intersection
						) ;

						a_Compare = t_Intersection ;

						t_Status = QueryPreprocessor :: QuadState :: State_True ;
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiStringRangeNode ) 
		{
			WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiStringRangeNode ) 
					{
						WmiStringRangeNode *t_StringRange = ( WmiStringRangeNode * ) t_Range ;

						WmiStringRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_StringRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
		{
			WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
					{
						WmiUnsignedIntegerRangeNode *t_IntegerRange = ( WmiUnsignedIntegerRangeNode * ) t_Range ;

						WmiUnsignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break; 

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
		{
			WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
					{
						WmiSignedIntegerRangeNode *t_IntegerRange = ( WmiSignedIntegerRangeNode * ) t_Range ;

						WmiSignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else
		{
#if DBG
// Should never happen, failure in DNF evaluation otherwise
DebugBreak () ;
#endif
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveNonOverlappingRanges  ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_Compare = NULL ;

	QueryPreprocessor :: QuadState t_Status = RecursiveRemoveNonOverlappingRanges ( a_Root , t_Compare ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveNonOverlappingRanges ( a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: CountDisjunctions ( WmiTreeNode *a_Node , ULONG &a_Count ) 
{
	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			a_Count ++ ;

			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CountDisjunctions ( t_Left , a_Count ) ;
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				CountDisjunctions ( t_Right , a_Count ) ;
			}
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreateDisjunctions ( 

	void *a_Context , 
	WmiTreeNode *a_Node , 
	Disjunctions *a_Disjunctions , 
	ULONG a_PropertiesToPartitionCount ,
	BSTR *a_PropertiesToPartition ,
	ULONG &a_DisjunctionIndex
) 
{
	WmiTriState t_Status = :: State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = CreateDisjunctions ( 

					a_Context , 
					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex 
				) ;
			}

			if ( t_Status == :: State_True )
			{
				Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

				for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
				{
					if ( t_Disjunction->GetRange ( t_Index ) == NULL )
					{
						WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

							a_Context ,
							a_PropertiesToPartition [ t_Index ] 
						) ;

						if ( t_RangeNode )
						{
							t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
						}
						else
						{
							t_Status = :: State_Error ;
							break ;
						}
					}
				}
			}

			a_DisjunctionIndex ++ ;

			if ( t_Status == :: State_True )
			{
				WmiTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = CreateDisjunctions ( 

						a_Context ,
						t_Right , 
						a_Disjunctions ,
						a_PropertiesToPartitionCount ,
						a_PropertiesToPartition ,
						a_DisjunctionIndex
					) ;
				}

				if ( t_Status == :: State_True )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

					for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
					{
						if ( t_Disjunction->GetRange ( t_Index ) == NULL )
						{
							WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

								a_Context ,
								a_PropertiesToPartition [ t_Index ] 
							) ;

							if ( t_RangeNode )
							{
								t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
							}
							else
							{
								t_Status = :: State_Error ; 
								break;
							}
						}
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = CreateDisjunctions ( 

					a_Context ,
					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex
				) ;
			}

			if ( t_Status == :: State_True )
			{
				WmiTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = CreateDisjunctions ( 

						a_Context , 
						t_Right , 
						a_Disjunctions ,
						a_PropertiesToPartitionCount ,
						a_PropertiesToPartition ,
						a_DisjunctionIndex
					) ;
				}
			}
		}
		else
		{
			Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;
			BSTR t_PropertyName = t_Node->GetPropertyName () ;
			for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
			{
				if ( _wcsicmp ( t_PropertyName , a_PropertiesToPartition [ t_Index ] ) == 0 )
				{
					WmiRangeNode *t_NodeCopy = ( WmiRangeNode * ) t_Node->Copy () ;
					if ( t_NodeCopy )
					{
						t_Disjunction->SetRange ( t_Index , t_NodeCopy ) ;
					}
					else
					{
						t_Status = :: State_Error ;
					}

					break ;
				}
			}			
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreateDisjunctionContainer ( 

	void *a_Context , 
	WmiTreeNode *a_Root , 
	ULONG a_Count , 
	BSTR *a_Container , 
	Disjunctions *&a_Disjunctions
)
{
	WmiTriState t_Status = :: State_True ;

	if ( a_Count && a_Container )
	{
		ULONG t_PropertiesToPartitionCount = a_Count ;
		BSTR *t_PropertiesToPartition = a_Container ;

		ULONG t_Count = 1 ;
		CountDisjunctions ( a_Root , t_Count ) ;
		a_Disjunctions = new Disjunctions ( t_Count , t_PropertiesToPartitionCount ) ;
		if ( a_Disjunctions )
		{
			t_Status = a_Disjunctions->Initialize () ;
			if ( t_Status == :: State_True )
			{
				t_Count = 0 ; 
				t_Status = CreateDisjunctions ( 

					a_Context , 
					a_Root , 
					a_Disjunctions ,
					t_PropertiesToPartitionCount ,
					t_PropertiesToPartition ,
					t_Count
				) ;

				if ( t_Status == :: State_True )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( 0 ) ;

					for ( ULONG t_Index = 0 ; t_Index < t_PropertiesToPartitionCount ; t_Index ++ )
					{
						if ( t_Disjunction->GetRange ( t_Index ) == NULL )
						{
							WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

								a_Context ,
								t_PropertiesToPartition [ t_Index ] 
							) ;

							if ( t_RangeNode )
							{
								t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
							}
							else
							{
								t_Status = :: State_Error ;
								break ;
							}
						}
					}
				}
			}

			if ( t_Status != :: State_True )
			{
				delete a_Disjunctions ;
				a_Disjunctions = NULL;
			}
		}
		else
		{
			t_Status = :: State_Error ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintInit (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
   	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
        DebugMacro3( 

            ProvDebugLog :: s_ProvDebugLog->WriteW (  

	            L"    "
            ) ;
        )
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
        DebugMacro3( 

            ProvDebugLog :: s_ProvDebugLog->WriteW (  

	            L"%lu", a_DisjunctionSetToTest [ t_Index ] ? 1 : 0
            ) ;
        )
    }

    DebugMacro3( 

        ProvDebugLog :: s_ProvDebugLog->WriteW (  

	        L"\n"
        ) ;
    )

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
    	for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
        {
            DebugMacro3( 

                ProvDebugLog :: s_ProvDebugLog->WriteW (  

	                L"    "
                ) ;
            )
        }

		Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( t_Index ) ;
		if ( t_Disjunction )
		{
			t_Disjunction->GetRange ( a_KeyIndex )->Print () ;

			DebugMacro3( 

				ProvDebugLog :: s_ProvDebugLog->WriteW (  

					L"\n"
				) ;
			)
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintSortedRange (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
    ULONG *a_OriginToSorted ,
	ULONG a_KeyIndex ,
    WmiRangeNode **a_RangeTable
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
   		if ( a_RangeTable [ t_Index ] )
        {
    	    for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
            {
                DebugMacro3( 

                    ProvDebugLog :: s_ProvDebugLog->WriteW (  

	                    L"%lu    ", t_Index
                    ) ;
                )
            }

            if ( a_DisjunctionSetToTest [ a_OriginToSorted [ t_Index ] ] )
            {
                DebugMacro3( 

                    ProvDebugLog :: s_ProvDebugLog->WriteW (  

	                    L"In "
                    ) ;
				)
            }
            else
            {
                DebugMacro3( 

                    ProvDebugLog :: s_ProvDebugLog->WriteW (  

	                    L"Out "
                    ) ;
				)
            }

		    a_RangeTable [ t_Index ]->Print () ;

            DebugMacro3( 

                ProvDebugLog :: s_ProvDebugLog->WriteW (  

	                L"\n"
                ) ;
            )
        }
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintOverlap (

	ULONG a_DisjunctionSetToTestCount ,
   	ULONG *a_DisjunctionSetToTest ,
	ULONG *a_SortedDisjunctionSetToTest ,
    ULONG *a_OverlappingIndex ,
  	ULONG a_KeyIndex 
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
DebugMacro3( 

    ProvDebugLog :: s_ProvDebugLog->WriteW (  

	    L"    "
    ) ;
)
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
DebugMacro3( 

    if ( a_DisjunctionSetToTest [ t_Index ] )
    {
        ProvDebugLog :: s_ProvDebugLog->WriteW (  

	        L"%lu ",  a_OverlappingIndex [ t_Index ]
        ) ;
    }
    else
    {
        ProvDebugLog :: s_ProvDebugLog->WriteW (  

	        L"X "
        ) ;
    }
)
    }

DebugMacro3( 

    ProvDebugLog :: s_ProvDebugLog->WriteW (  

	    L"\n"
    ) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: RecursiveQuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Lower , 
	ULONG a_Upper
)
{
	if ( a_Lower <= a_Upper )
	{
		ULONG t_LeftIndex = a_Lower ; 
		ULONG t_RightIndex = a_Upper ;

		while ( true )
		{
			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ]  , a_Array [ a_Lower - 1 ] ) )
			{
				t_LeftIndex ++ ;
			}

			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ a_Lower - 1 ]  , a_Array [ t_RightIndex ] ) )
			{
				t_RightIndex -- ;
			}

			if ( t_LeftIndex < t_RightIndex ) 
			{
				WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
				a_Array [ t_LeftIndex ] = a_Array [ t_RightIndex ] ;
				a_Array [ t_RightIndex ] = t_Temp ;

				ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
				a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ t_RightIndex ];
				a_UnsortedOrder [ t_RightIndex ] = t_Val ;
			}
			else
			{
				break ;
			}
		}

		LONG t_Compare = CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ] , a_Array [ a_Lower - 1 ] ) ;
		if ( t_Compare )
		{
			WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
			a_Array [ t_LeftIndex ] = a_Array [ a_Lower - 1 ] ;
			a_Array [ a_Lower - 1 ] = t_Temp ;

			ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
			a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ a_Lower - 1 ];
			a_UnsortedOrder [ a_Lower - 1 ] = t_Val ;
		}

		RecursiveQuickSort ( 

			a_Array , 
			a_UnsortedOrder ,
			a_Lower , 
			t_LeftIndex - 1 
		) ;

 		RecursiveQuickSort ( 

			a_Array  , 
			a_UnsortedOrder ,
			t_LeftIndex + 1 , 
			a_Upper
		) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: QuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Size
)
{
	RecursiveQuickSort ( a_Array , a_UnsortedOrder , 1 , a_Size - 1 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: SortRanges (

	ULONG t_DisjunctionCount ,
    ULONG *t_OriginToSorted ,
	WmiRangeNode **t_RangeTable 
)
{
	QuickSort (	t_RangeTable , t_OriginToSorted , t_DisjunctionCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RemoveOverlaps (

	ULONG *a_DisjunctionSetToTest ,
	ULONG a_DisjunctionCount ,
	ULONG *a_OverlappingIndex ,
    ULONG *a_OriginToSorted ,
	WmiRangeNode **a_RangeTable 
)
{
	WmiTriState t_Status = :: State_True ;

/*
 *  Remove Overlaps
 */

	ULONG t_InnerIndex = 0 ;
	ULONG t_OuterIndex = 1 ;

	while ( ( t_Status != :: State_Error ) && ( t_OuterIndex < a_DisjunctionCount ) )
	{
		WmiRangeNode *t_LeftRange = a_RangeTable [ t_OuterIndex ] ;
		WmiRangeNode *t_RightRange = a_RangeTable [ t_InnerIndex ] ;

		if ( a_OverlappingIndex [ t_OuterIndex ] != a_OverlappingIndex [ t_InnerIndex ] )
		{
			if ( t_LeftRange && t_RightRange )
			{
				if ( ( t_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
				{
					WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) t_LeftRange ;
					WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) t_RightRange ;
    				WmiStringRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftString->GetOverlappingRange ( *t_RightString , t_OverLap ) ;
					if ( t_Status == :: State_True )
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Overlap\n"
	) ;
)

						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;

						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
					}
					else
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
				{
					WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) t_LeftRange ;
					WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) t_RightRange ;
    				WmiUnsignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == :: State_True )
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
				{
					WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) t_LeftRange ;
					WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) t_RightRange ;
    				WmiSignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == :: State_True )
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else
				{
// Failure
					t_Status = :: State_Error ;  
				}
			}
		}

		t_InnerIndex ++ ;
		t_OuterIndex ++ ;
	}

	for ( LONG t_Index = a_DisjunctionCount - 1 ; t_Index >= 0 ; t_Index -- )
	{
		if ( t_Index < a_OverlappingIndex [ t_Index ] )
		{
			a_OverlappingIndex [ t_Index ] = a_OverlappingIndex [ a_OverlappingIndex [ t_Index ] ] ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursivePartitionSet ( 

	Disjunctions *a_Disjunctions , 
	PartitionSet *&a_Partition , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
	WmiTriState t_Status = :: State_True ;

	if ( a_KeyIndex < a_Disjunctions->GetConjunctionCount () )
	{
		ULONG *t_OverlappingIndex = NULL ;
        ULONG *t_OriginToSorted = NULL ;
		WmiRangeNode **t_RangeTable = NULL ;

		try
		{
			t_OverlappingIndex = new ULONG [ a_DisjunctionSetToTestCount ] ;
			t_OriginToSorted = new ULONG [ a_DisjunctionSetToTestCount ] ;

			t_RangeTable = new WmiRangeNode * [ a_DisjunctionSetToTestCount ] ;
			memset ( t_RangeTable, 0, sizeof ( WmiRangeNode* ) * a_DisjunctionSetToTestCount );

			if ( t_OverlappingIndex && t_OriginToSorted && t_RangeTable )
			{
				for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionSetToTest [ t_Index ] ) ;
					t_RangeTable [ t_Index ] = ( WmiRangeNode * ) t_Disjunction->GetRange ( a_KeyIndex )->Copy () ;
					t_OverlappingIndex [ t_Index ] = t_Index ;
					t_OriginToSorted [ t_Index ] = t_Index ;
				}

				// Sort Partitions
				SortRanges (

					a_DisjunctionSetToTestCount ,
					t_OriginToSorted ,
					t_RangeTable 
				) ;

				t_Status = RemoveOverlaps (

					a_DisjunctionSetToTest ,
					a_DisjunctionSetToTestCount ,
					t_OverlappingIndex ,
					t_OriginToSorted ,
					t_RangeTable 
				) ;

				if ( t_Status != :: State_Error )
				{
					ULONG t_PartitionCount = 0 ;
					for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
					{
						if ( t_RangeTable [ t_Index ] )
						{
							t_PartitionCount ++ ;
						}
					}

					t_Status = a_Partition->Initialize ( t_PartitionCount ) ;
					if ( t_Status == :: State_True )
					{
						ULONG t_PartitionIndex = 0 ;
						for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount; t_Index ++ )
						{
							WmiRangeNode *t_Range = t_RangeTable [ t_Index ] ;
							if ( t_Range )
							{
								PartitionSet *t_Partition = new PartitionSet ;
								if ( t_Partition )
								{
									a_Partition->SetPartition ( t_PartitionIndex , t_Partition ) ;

									WmiRangeNode *t_Copy = ( WmiRangeNode * ) t_Range->Copy () ;
									if ( t_Copy )
									{
										t_Partition->SetRange ( t_Copy ) ;
										t_Partition->SetKeyIndex ( a_KeyIndex ) ;
										t_PartitionIndex ++ ;
									}
									else
									{
										t_Status = :: State_Error ; 
										break ;
									}
								}
								else
								{
									t_Status = :: State_Error ; 
									break ;
								}
							}
						}
					}

					if ( t_Status == :: State_True )
					{
/*
 *  Outer Index is the range order
 */
						ULONG t_PartitionIndex = 0 ;

/*
 *	Array allocation has max defined by function arg.
 */

						ULONG *t_DisjunctionSetToTest = NULL ;

						try
						{
							t_DisjunctionSetToTest = new ULONG [ a_DisjunctionSetToTestCount ] ;
							if ( t_DisjunctionSetToTest )
							{
								ULONG t_OuterIndex = 0 ;
								while ( t_Status && ( t_OuterIndex < a_DisjunctionSetToTestCount ) )
								{
									BOOL t_Found = FALSE ;

									ULONG t_DisjunctionSetToTestCount = 0 ;

									if ( t_RangeTable [ t_OuterIndex ] )
									{
	/*
	 * Inner index matches the overlaps
	 */

										LONG t_InnerIndex = t_OuterIndex ;
										while ( t_InnerIndex >= 0 )
										{
											if ( t_OverlappingIndex [ t_OuterIndex ] == t_OverlappingIndex [ t_InnerIndex ] )
											{
												t_DisjunctionSetToTest [ t_DisjunctionSetToTestCount ] = a_DisjunctionSetToTest [ t_OriginToSorted [ t_InnerIndex ] ] ;
												t_DisjunctionSetToTestCount ++ ;
												t_Found = TRUE ;
											}
											else
											{
												break ;
											}

											t_InnerIndex -- ;
										}
									}

    								if ( t_Found )
									{
										PartitionSet *t_Partition = a_Partition->GetPartition ( t_PartitionIndex ) ;
										if ( t_Partition )
										{
											t_Status = RecursivePartitionSet (

												a_Disjunctions ,
												t_Partition ,
												t_DisjunctionSetToTestCount ,
												t_DisjunctionSetToTest ,
												a_KeyIndex + 1
											) ;

											t_PartitionIndex ++ ;
										}
									}

									t_OuterIndex ++ ;
								}

								delete [] t_DisjunctionSetToTest ;
								t_DisjunctionSetToTest = NULL ;
							}
							else
							{
								t_Status = :: State_Error ; 
							}
						}
						catch ( ... )
						{
							if ( t_DisjunctionSetToTest )
							{
								delete [] t_DisjunctionSetToTest ;
								t_DisjunctionSetToTest = NULL ;
							}

							throw ;
						}
					}
				}
				else
				{
					t_Status = :: State_Error ; 
				}

				for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
				{
					if ( t_RangeTable [ t_Index ] )
					{
						delete t_RangeTable [ t_Index ] ;
						t_RangeTable [ t_Index ] = NULL ;
					}
				}
			}
			else
			{
				t_Status = :: State_Error ; 
			}
		}
		catch ( ... )
		{
			if ( t_RangeTable )
			{
				for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
				{
					if ( t_RangeTable [ t_Index ] )
					{
						delete t_RangeTable [ t_Index ] ;
						t_RangeTable [ t_Index ] = NULL ;
					}
				}

				delete [] t_RangeTable ;
				t_RangeTable = NULL;
			}

			if ( t_OverlappingIndex )
			{
				delete [] t_OverlappingIndex ;
			}

			if ( t_OriginToSorted )
			{
				delete [] t_OriginToSorted ;
			}

			throw;
		}

		delete [] t_RangeTable ;
		delete [] t_OverlappingIndex ;
		delete [] t_OriginToSorted ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreatePartitionSet ( Disjunctions *a_Disjunctions , PartitionSet *&a_Partition )
{
	WmiTriState t_Status = :: State_False ;

	a_Partition = NULL ;

	ULONG t_DisjunctionCount = a_Disjunctions->GetDisjunctionCount () ;
	ULONG *t_DisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;
	if ( t_DisjunctionSetToTest )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			t_DisjunctionSetToTest [ t_Index ] = t_Index ;
		}

		try
		{
			a_Partition = new PartitionSet ;
			if ( a_Partition )
			{
				t_Status = RecursivePartitionSet (

					a_Disjunctions ,
					a_Partition ,
					t_DisjunctionCount ,
					t_DisjunctionSetToTest ,
					0
				) ;
			}
			else
			{
				t_Status = :: State_Error ;
			}

			delete [] t_DisjunctionSetToTest ;
			t_DisjunctionSetToTest = NULL ;
		}
		catch ( ... )
		{
			if ( t_DisjunctionSetToTest )
			{ 
				delete [] t_DisjunctionSetToTest ;
				t_DisjunctionSetToTest = NULL ;
			}

			if ( a_Partition )
			{
				delete a_Partition;
				a_Partition = NULL;
			}

			throw;
		}
	}
	else
	{
		t_Status = :: State_Error ;
	}

	return t_Status;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: PreProcess ( 

	void *a_Context , 
	SQL_LEVEL_1_RPN_EXPRESSION *a_RpnExpression , 
	WmiTreeNode *a_Root ,
	ULONG a_Count , 
	BSTR *a_Container , 
	PartitionSet *&a_Partition
)
{
	QuadState t_State = State_True ;

    if ( a_Root != NULL )
    {
        WmiTreeNode *t_Root = a_Root->Copy () ;
		if ( t_Root )
		{
			t_State = RemoveInvariants ( a_Context , t_Root ) ;

			switch ( t_State )
			{
				case QueryPreprocessor :: QuadState :: State_True:
				{		
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Expression = TRUE "
	) ;
)
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_False:
				{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Expression = FALSE "
	) ;
)
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_Undefined:
				{
					PrintTree ( t_Root ) ;
						
					WmiTriState t_Status = Sort ( t_Root ) ;
					if ( t_Status == :: State_True )
					{
						PrintTree ( t_Root ) ;

						t_Status = ConvertToRanges ( t_Root ) ;
					}

					if ( t_Status == :: State_True )
					{
						PrintTree ( t_Root ) ;

						switch ( t_State = RemoveNonOverlappingRanges ( t_Root ) )
						{
							case QueryPreprocessor :: QuadState :: State_True :
							{		
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Expression = TRUE"
	) ;
)
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_False:
							{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Expression = FALSE"
	) ;
)
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_Undefined:
							{
								PrintTree ( t_Root ) ;

								t_State =  State_Error ;

								Disjunctions *t_Disjunctions = NULL ;

								try
								{
									t_Status = CreateDisjunctionContainer ( a_Context , t_Root , a_Count , a_Container , t_Disjunctions ) ;
									if ( t_Status == :: State_True )
									{
										PartitionSet *t_Partition = NULL ;

										try
										{
											t_Status = CreatePartitionSet ( t_Disjunctions , t_Partition ) ;
											if ( t_Status == :: State_True )
											{
												t_State =  State_Undefined ; 
												a_Partition = t_Partition ;
											}
											else
											{
												delete t_Partition ;
												t_Partition = NULL ;
											}

											delete t_Disjunctions ;
											t_Disjunctions = NULL;
										}
										catch ( ... )
										{
											if ( t_Partition )
											{
												delete t_Partition;
												t_Partition = NULL;

												a_Partition = NULL;
											}

											throw;
										}
									}
									else
									{
										t_State = QueryPreprocessor :: QuadState :: State_Error ;
									}
								}
								catch ( ... )
								{
									if ( t_Disjunctions )
									{
										delete t_Disjunctions ;
										t_Disjunctions = NULL ;
									}

									if ( t_Root )
									{
										delete t_Root;
									}

									throw;
								}
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_ReEvaluate:
							default:
							{
							}
							break ;
						}
					}
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_ReEvaluate:
				default:
				{
				}
				break ;
			}

			delete t_Root ;
		}
		else
		{
			t_State = State_Error ;
		}
    }

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: PreProcess (

	void *a_Context ,																
	SQL_LEVEL_1_RPN_EXPRESSION *a_RpnExpression , 
	WmiTreeNode *&a_Root 
)
{
	QuadState t_State = State_Error ;

	BOOL t_Status = Evaluate ( a_Context , *a_RpnExpression , &a_Root ) ;
	if ( t_Status )
	{
		t_State = State_True ;

		PrintTree ( a_Root ) ;
        
		t_State = DisjunctiveNormalForm ( a_Root ) ;

		PrintTree ( a_Root ) ;
	}
	else
	{
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: Query ( 

	BSTR a_Query ,
	SQL_LEVEL_1_RPN_EXPRESSION *&a_RpnExpression
)
{
	QuadState t_State = State_Error ;

	CTextLexSource t_Source ( a_Query ) ;
	SQL1_Parser t_Parser ( & t_Source ) ;

	int t_Status = t_Parser.Parse ( & a_RpnExpression ) ;
	if ( t_Status == 0 )
	{
		t_State = State_True ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: ~QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_THIS				L"__THIS"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *QueryPreprocessor :: AllocTypeNode ( 

	void *a_Context ,
	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_THIS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
	}

	return t_Node ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\provevt.cpp ===
//***************************************************************************

//

//  PROVEVT.CPP

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <provcont.h>
#include "provevt.h"


ProvEventObject :: ProvEventObject ( const TCHAR *globalEventName ) : m_event ( NULL )
{
	m_event = CreateEvent (

		NULL ,
		FALSE ,
		FALSE ,
		globalEventName 
	) ;

	if ( m_event == NULL )
	{
		if ( GetLastError () == ERROR_ALREADY_EXISTS )
		{
			m_event = OpenEvent (

				EVENT_ALL_ACCESS ,
				FALSE , 
				globalEventName
			) ;
		}
	}

    if( NULL == m_event ) throw Heap_Exception(Heap_Exception::E_ALLOCATION_ERROR);
}

ProvEventObject :: ~ProvEventObject () 
{
	if ( m_event )
		CloseHandle ( m_event ) ;
}

HANDLE ProvEventObject :: GetHandle () 
{
	return m_event ;
}

void ProvEventObject :: Set () 
{
	SetEvent ( m_event ) ;
}

void ProvEventObject :: Clear () 
{
	ResetEvent ( m_event ) ;
}

void ProvEventObject :: Process () 
{
}

BOOL ProvEventObject :: Wait ()
{
	return WaitForSingleObject ( GetHandle () , INFINITE ) == WAIT_OBJECT_0 ;
}

void ProvEventObject :: Complete ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\provtree.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <typeinfo.h>

#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <stdio.h>
#include <provcont.h>
#include <provevt.h>
#include <provlog.h>
#include <provtree.h>

WmiTreeNode *WmiTreeNode :: Copy () 
{
	TypeId_TreeNode t_Type = m_Type ;
	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_RightCopy = m_Right ? m_Right->Copy () : NULL ;
	WmiTreeNode *t_Node = new WmiTreeNode ( t_Type , t_DataCopy , t_LeftCopy , t_RightCopy , t_Parent ) ;
	return t_Node ;
} ;

WmiTreeNode *WmiTreeNode :: CopyNode () 
{
	WmiTreeNode *t_Node = new WmiTreeNode ( this ) ;
	return t_Node ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\provlog.cpp ===
//***************************************************************************

//

//  PROVLOG.CPP

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>

#include <wbemutil.h>

#include <provimex.h>
#include <provexpt.h>
#include <provstd.h>
#include <provmt.h>
#include <string.h>
#include <tchar.h>
#include <strsafe.h>
#include <provlog.h>
#include <provevt.h>
#include <Allocator.h>
#include <Algorithms.h>

#include <Allocator.cpp>

WmiAllocator g_Allocator ;

#define MAX_MESSAGE_SIZE		1024
#define HALF_MAX_MESSAGE_SIZE	512

#define TRUNCATE_T				_T(" * string was truncated ! *\n")
#define TRUNCATE_W				L" * string was truncated ! *\n"
#define TRUNCATE_A				" * string was truncated ! *\n"


long ProvDebugLog::s_ReferenceCount = 0 ;

ProvDebugLog ProvDebugLog::s_aLogs[LOG_MAX_PROV] =
{
    ProvDebugLog(LOG_WBEMCORE),
    ProvDebugLog(LOG_WINMGMT),
    ProvDebugLog(LOG_ESS),
    ProvDebugLog(LOG_WBEMPROX),
    ProvDebugLog(LOG_WBEMSTUB),  
    ProvDebugLog(LOG_QUERY), 
    ProvDebugLog(LOG_MOFCOMP),
    ProvDebugLog(LOG_EVENTLOG),
    ProvDebugLog(LOG_WBEMDISP), 
    ProvDebugLog(LOG_STDPROV), 
    ProvDebugLog(LOG_WIMPROV),
    ProvDebugLog(LOG_WMIOLEDB), 
    ProvDebugLog(LOG_WMIADAP),  
    ProvDebugLog(LOG_REPDRV),
    ProvDebugLog(LOG_PROVSS),
    ProvDebugLog(LOG_EVTPROV),
    ProvDebugLog(LOG_VIEWPROV),
    ProvDebugLog(LOG_DSPROV),
    ProvDebugLog(LOG_SNMPPROV),
    ProvDebugLog(LOG_PROVTHRD)
};	


ProvDebugLog * ProvDebugLog::s_ProvDebugLog = ProvDebugLog::GetProvDebugLog(LOG_PROVTHRD);


void ProvDebugLog :: Write ( const TCHAR *a_DebugFormatString , ... )
{
	TCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;
	va_list t_VarArgList ;

	va_start(t_VarArgList,a_DebugFormatString);

	HRESULT t_Result = StringCchVPrintf(t_OutputDebugString , MAX_MESSAGE_SIZE , a_DebugFormatString , t_VarArgList );
	if ( FAILED ( t_Result ) )
	{
		if ( t_Result == STRSAFE_E_INSUFFICIENT_BUFFER )
		{
			StringCchCopy ( &t_OutputDebugString [ MAX_MESSAGE_SIZE - (lstrlen (TRUNCATE_T)+1) ], lstrlen(TRUNCATE_T)+1, TRUNCATE_T );
			t_OutputDebugString [ MAX_MESSAGE_SIZE - 1 ] = ( TCHAR ) 0 ;
		}
	}

	va_end(t_VarArgList);

    DebugTrace(m_Caller,"%S",t_OutputDebugString);
}

void ProvDebugLog :: WriteW ( const WCHAR *a_DebugFormatString , ... )
{

	WCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;
	va_list t_VarArgList ;

	va_start(t_VarArgList,a_DebugFormatString);

	HRESULT t_Result = StringCchVPrintfW(t_OutputDebugString , MAX_MESSAGE_SIZE , a_DebugFormatString , t_VarArgList );
	if ( FAILED ( t_Result ) )
	{
		if ( t_Result == STRSAFE_E_INSUFFICIENT_BUFFER )
		{
			StringCchCopyW ( &t_OutputDebugString [ MAX_MESSAGE_SIZE - (wcslen (TRUNCATE_W)+1) ], wcslen(TRUNCATE_W)+1, TRUNCATE_W );
			t_OutputDebugString [ MAX_MESSAGE_SIZE - 1 ] = ( TCHAR ) 0 ;
		}
	}

	va_end(t_VarArgList);

    DebugTrace(m_Caller,"%S",t_OutputDebugString);
}

void ProvDebugLog :: WriteA ( const char *a_DebugFormatString , ... )
{
	char t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;
	va_list t_VarArgList ;

	va_start(t_VarArgList,a_DebugFormatString);

	HRESULT t_Result = StringCchVPrintfA(t_OutputDebugString , MAX_MESSAGE_SIZE , a_DebugFormatString , t_VarArgList );
	if ( FAILED ( t_Result ) )
	{
		if ( t_Result == STRSAFE_E_INSUFFICIENT_BUFFER )
		{
			StringCchCopyA ( &t_OutputDebugString [ MAX_MESSAGE_SIZE - (strlen (TRUNCATE_A)+1) ], strlen(TRUNCATE_A)+1, TRUNCATE_A );
			t_OutputDebugString [ MAX_MESSAGE_SIZE - 1 ] = ( char ) 0 ;
		}
	}

	va_end(t_VarArgList);

    DebugTrace(m_Caller,"%s",t_OutputDebugString);
}

void ProvDebugLog :: WriteFileAndLine ( const wchar_t *a_File , const ULONG a_Line , const wchar_t *a_DebugFormatString , ... )
{

	wchar_t t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

	StringCchPrintf ( t_OutputDebugString , HALF_MAX_MESSAGE_SIZE , _TEXT("%s:%d\r\n"),a_File,a_Line ) ;
    DebugTrace(m_Caller,"%S",t_OutputDebugString);	

	va_list t_VarArgList ;
	va_start(t_VarArgList,a_DebugFormatString);

	HRESULT t_Result = StringCchVPrintf(t_OutputDebugString , MAX_MESSAGE_SIZE , a_DebugFormatString , t_VarArgList );
	if ( FAILED ( t_Result ) )
	{
		if ( t_Result == STRSAFE_E_INSUFFICIENT_BUFFER )
		{
			StringCchCopy ( &t_OutputDebugString [ MAX_MESSAGE_SIZE - (lstrlen (TRUNCATE_T)+1) ], lstrlen(TRUNCATE_T)+1, TRUNCATE_T );
			t_OutputDebugString [ MAX_MESSAGE_SIZE - 1 ] = ( TCHAR ) 0 ;
		}
	}

	va_end(t_VarArgList);

    DebugTrace(m_Caller,"%S",t_OutputDebugString);
}

void ProvDebugLog :: WriteFileAndLine ( const char *a_File , const ULONG a_Line , const wchar_t *a_DebugFormatString , ... )
{

	wchar_t t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

	StringCchPrintf ( t_OutputDebugString , HALF_MAX_MESSAGE_SIZE , _TEXT("%S:%d\r\n"),a_File,a_Line ) ;
    DebugTrace(m_Caller,"%S",t_OutputDebugString);	

	va_list t_VarArgList ;
	va_start(t_VarArgList,a_DebugFormatString);

	HRESULT t_Result = StringCchVPrintf(t_OutputDebugString , MAX_MESSAGE_SIZE , a_DebugFormatString , t_VarArgList );
	if ( FAILED ( t_Result ) )
	{
		if ( t_Result == STRSAFE_E_INSUFFICIENT_BUFFER )
		{
			StringCchCopy ( &t_OutputDebugString [ MAX_MESSAGE_SIZE - (lstrlen (TRUNCATE_T)+1) ], lstrlen(TRUNCATE_T)+1, TRUNCATE_T );
			t_OutputDebugString [ MAX_MESSAGE_SIZE - 1 ] = ( TCHAR ) 0 ;
		}
	}

	va_end(t_VarArgList);

    DebugTrace(m_Caller,"%S",t_OutputDebugString);
}

void ProvDebugLog :: WriteFileAndLineW ( const WCHAR *a_File , const ULONG a_Line , const WCHAR *a_DebugFormatString , ... )
{
	WCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

	StringCchPrintf ( t_OutputDebugString , HALF_MAX_MESSAGE_SIZE , _TEXT("%S:%d\r\n"),a_File,a_Line ) ;
    DebugTrace(m_Caller,"%S",t_OutputDebugString);

	va_list t_VarArgList ;
	va_start(t_VarArgList,a_DebugFormatString);

	HRESULT t_Result = StringCchVPrintfW(t_OutputDebugString , MAX_MESSAGE_SIZE , a_DebugFormatString , t_VarArgList );
	if ( FAILED ( t_Result ) )
	{
		if ( t_Result == STRSAFE_E_INSUFFICIENT_BUFFER )
		{
			StringCchCopyW ( &t_OutputDebugString [ MAX_MESSAGE_SIZE - (wcslen (TRUNCATE_W)+1) ], wcslen(TRUNCATE_W)+1, TRUNCATE_W );
			t_OutputDebugString [ MAX_MESSAGE_SIZE - 1 ] = ( wchar_t ) 0 ;
		}
	}

	va_end(t_VarArgList);

   DebugTrace(m_Caller,"%S",t_OutputDebugString);

}

void ProvDebugLog :: WriteFileAndLineA ( const char *a_File , const ULONG a_Line , const char *a_DebugFormatString , ... )
{

    char t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

	StringCchPrintfA( t_OutputDebugString , HALF_MAX_MESSAGE_SIZE , "%s:%d\r\n",a_File,a_Line ) ;
    DebugTrace(m_Caller,"%s",t_OutputDebugString);

	va_list t_VarArgList ;
	va_start(t_VarArgList,a_DebugFormatString);

	HRESULT t_Result = StringCchVPrintfA(t_OutputDebugString , MAX_MESSAGE_SIZE , a_DebugFormatString , t_VarArgList );
	if ( FAILED ( t_Result ) )
	{
		if ( t_Result == STRSAFE_E_INSUFFICIENT_BUFFER )
		{
			StringCchCopyA ( &t_OutputDebugString [ MAX_MESSAGE_SIZE - (strlen (TRUNCATE_A)+1) ], strlen(TRUNCATE_A)+1, TRUNCATE_A );
			t_OutputDebugString [ MAX_MESSAGE_SIZE - 1 ] = ( char ) 0 ;
		}
	}

	va_end(t_VarArgList);
		
    DebugTrace(m_Caller,"%s",t_OutputDebugString);
}


BOOL ProvDebugLog :: Startup ()
{
    InterlockedIncrement(&s_ReferenceCount);
	return TRUE ;
}

void ProvDebugLog :: Closedown ()
{
    InterlockedDecrement(&s_ReferenceCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=provthrd
TARGETPATH=obj
TARGETTYPE=DYNLINK

LINKLIBS= \
	$(FRAMEWORK_MFC_LIB)
TARGETLIBS= \
	$(FRAMEWORK_EXPT_LIB) \
	$(STDLIBRARY_LIB) \
	$(WBEMCOMN_DLL_LIB) \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\version.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\wsock32.lib 

INCLUDES=$(INCLUDES); \
	$(FRAMEWORK_THRD_INC); \
	$(FRAMEWORK_EXPT_INC); \
	$(FRAMEWORK_MFC_INC); \
	$(FRAMEWORK_PARSER_INC); \
	$(WMIIDL_INC); \
	$(STDLIBRARY_INC); \
	$(WBEMCOMN_INC); \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC)

SOURCES= \
	..\provlog.cpp \
	..\provevt.cpp \
	..\maindll.cpp \
	..\provtype.cpp \
	..\provval.cpp \
	..\provdnf.cpp \
	..\provtree.cpp \
	..\provthrd.rc 

# Add the following to add DB verbose logging: '/DREP_VERBOSE_LOGGING'
C_DEFINES=$(C_DEFINES) /DPROVDEBUG_INIT /DPROVTHRD_INIT /DPROVIMEX_INIT
USE_MSVCRT=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\provthrd.def
USE_IOSTREAM=1
USE_NATIVE_EH=ASYNC
USE_RTTI=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provdnf.h ===
// (C) 1999-2001 Microsoft Corporation 

#ifndef __DNF_TREE_H
#define __DNF_TREE_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include <stdio.h>
#include <wmiutils.h>
#include "ProvTree.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum WmiTriState
{
	State_False		= 0 ,
	State_True		= 1 ,
	State_Error		= 0xFFFFFFFF
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define TypeId_WmiOrNode						1
#define TypeId_WmiAndNode						2
#define TypeId_WmiNotNode						3
#define TypeId_WmiOperatorNode					4
#define TypeId_WmiOperatorEqualNode				5
#define TypeId_WmiOperatorNotEqualNode			6
#define TypeId_WmiOperatorEqualOrGreaterNode	7
#define TypeId_WmiOperatorEqualOrLessNode		8
#define TypeId_WmiOperatorGreaterNode			9
#define TypeId_WmiOperatorLessNode				10
#define TypeId_WmiOperatorLikeNode				11
#define TypeId_WmiOperatorNotLikeNode			12
#define TypeId_WmiOperatorIsANode				13
#define TypeId_WmiOperatorNotIsANode			14
#define TypeId_WmiValueNode						15
#define TypeId_WmiSignedIntegerNode				16	
#define TypeId_WmiUnsignedIntegerNode			17
#define TypeId_WmiStringNode					18
#define TypeId_WmiNullNode						19
#define TypeId_WmiRangeNode						20
#define TypeId_WmiUnsignedIntegerRangeNode		21
#define TypeId_WmiSignedIntegerRangeNode		22
#define TypeId_WmiStringRangeNode				23
#define TypeId_WmiNullRangeNode					24

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOrNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOrNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiOrNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiOrNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiAndNode : public WmiTreeNode
{
private:
protected:
public:

	WmiAndNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiAndNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiAndNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiNotNode : public WmiTreeNode
{
private:
protected:
public:

	WmiNotNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiNotNode , NULL , a_Node , NULL , a_Parent ) {}

	~WmiNotNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiRangeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOperatorNode ( 

		TypeId_TreeNode a_Type , 
		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , a_Node , NULL , a_Parent ) {}

	~WmiOperatorNode () {} ;

	virtual WmiRangeNode *GetRange () = 0 ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorNotEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorNotEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () { return NULL ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorEqualOrGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorEqualOrLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrLessNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrLessNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLessNode , a_Node , a_Parent ) {}

	~WmiOperatorLessNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class DllImportExport WmiOperatorNotLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorNotLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorIsANode , a_Node , a_Parent ) {}

	~WmiOperatorIsANode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorNotIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotIsANode , a_Node , a_Parent ) {}

	~WmiOperatorNotIsANode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiValueNode : public WmiTreeNode
{
public:

	enum WmiValueFunction
	{
		Function_None = 0 ,
		Function_Upper = 1 ,
		Function_Lower = 2
	} ;

private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;
	WmiValueFunction m_PropertyFunction ;
	WmiValueFunction m_ConstantFunction ;

public:

	WmiValueNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		WmiValueFunction a_PropertyFunction ,
		WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , NULL , NULL , a_Parent ) ,
		m_PropertyFunction ( a_PropertyFunction ) ,
		m_ConstantFunction ( a_ConstantFunction ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;

			if ( m_PropertyName == NULL )
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
		}
		else
		{
			m_PropertyName = NULL ;
		}
	}

	~WmiValueNode ()
	{
		if ( m_PropertyName )
			SysFreeString ( m_PropertyName ) ;
	}

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	WmiValueNode :: WmiValueFunction GetPropertyFunction ()
	{
		return m_PropertyFunction ;
	}

	WmiValueNode :: WmiValueFunction GetConstantFunction ()
	{
		return m_ConstantFunction ;
	}

	LONG ComparePropertyName ( WmiValueNode &a_ValueNode ) 
	{
		if ( m_Index < a_ValueNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_ValueNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_ValueNode.m_PropertyName ) ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiSignedIntegerNode : public WmiValueNode
{
private:
protected:

	LONG m_Integer ;

public:

	WmiSignedIntegerNode ( 

		BSTR a_PropertyName ,
		LONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiSignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( LONG &a_Integer )
	{
		if ( m_Integer == 0x80000000 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( LONG &a_Integer )
	{
		if ( m_Integer == 0x7FFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	LONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiUnsignedIntegerNode : public WmiValueNode
{
private:
protected:

	ULONG m_Integer ;

public:

	WmiUnsignedIntegerNode ( 

		BSTR a_PropertyName ,
		ULONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiUnsignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 

		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( ULONG &a_Integer )
	{
		if ( m_Integer == 0 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( ULONG &a_Integer )
	{
		if ( m_Integer == 0xFFFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	ULONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiStringNode : public WmiValueNode
{
private:
protected:

	BSTR m_String ;

public:

	WmiStringNode ( 

		BSTR a_PropertyName ,
		BSTR a_String ,
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 
	) ;

	~WmiStringNode () ;

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( BSTR &a_String ) ;

	BOOL LexicographicallyAfter ( BSTR &a_String ) ;

	BSTR GetValue ()
	{
		return m_String ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiNullNode : public WmiValueNode
{
private:
protected:
public:

	WmiNullNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiNullNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
	}

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiRangeNode : public WmiTreeNode
{
private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;

	BOOL m_InfiniteLowerBound ;
	BOOL m_InfiniteUpperBound ;

	BOOL m_LowerBoundClosed;
	BOOL m_UpperBoundClosed;

public:

	LONG ComparePropertyName ( WmiRangeNode &a_RangeNode ) 
	{
		if ( m_Index < a_RangeNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_RangeNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_RangeNode.m_PropertyName ) ;
		}
	}

public:

	WmiRangeNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 
		
	) : WmiTreeNode ( a_Type , NULL , NULL , a_NextNode , a_Parent ),
		m_InfiniteLowerBound ( a_InfiniteLowerBound ) , 
		m_InfiniteUpperBound ( a_InfiniteUpperBound ) ,
		m_LowerBoundClosed ( a_LowerBoundClosed ) ,
		m_UpperBoundClosed ( a_UpperBoundClosed ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;

			if ( NULL == m_PropertyName )
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
		}
		else
		{
			m_PropertyName = NULL ;
		}
	} ;

	~WmiRangeNode () 
	{
		if ( m_PropertyName )
		{
			SysFreeString ( m_PropertyName ) ;
		}
	} ;

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	BOOL InfiniteLowerBound () { return m_InfiniteLowerBound ; }
	BOOL InfiniteUpperBound () { return m_InfiniteUpperBound ; }

	BOOL ClosedLowerBound () { return m_LowerBoundClosed ; }
	BOOL ClosedUpperBound () { return m_UpperBoundClosed ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiUnsignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	ULONG m_LowerBound ;
	ULONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;
	
	WmiTriState GetIntersectingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

public:

	WmiUnsignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		ULONG a_LowerBound ,
		ULONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiUnsignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	ULONG LowerBound () { return m_LowerBound ; }
	ULONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiSignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	LONG m_LowerBound ;
	LONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

public:

	WmiSignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		LONG a_LowerBound ,
		LONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiSignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	LONG LowerBound () { return m_LowerBound ; }
	LONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class DllImportExport WmiStringRangeNode : public WmiRangeNode
{
private:
protected:

	BSTR m_LowerBound ;
	BSTR m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

public:

	WmiStringRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		BSTR a_LowerBound ,
		BSTR a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiStringRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) 
	{
		if ( a_LowerBound )
		{
			m_LowerBound = SysAllocString ( a_LowerBound ) ;

			if ( NULL == m_LowerBound )
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
		}
		else
		{
			m_LowerBound = NULL ;
		}

		if ( a_UpperBound )
		{
			m_UpperBound = SysAllocString ( a_UpperBound ) ;

			if ( NULL == m_UpperBound )
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
		}
		else
		{
			m_UpperBound = NULL ;
		}
	}

	~WmiStringRangeNode ()
	{
		if ( m_LowerBound )
		{
			SysFreeString ( m_LowerBound ) ;
		}

		if ( m_UpperBound )
		{
			SysFreeString ( m_UpperBound ) ;
		}
	} ;

	BSTR LowerBound () { return m_LowerBound ; }
	BSTR UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiNullRangeNode : public WmiRangeNode
{
private:
protected:
public:

	WmiNullRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiNullRangeNode ,
			a_PropertyName , 
			a_Index , 
			TRUE ,
			TRUE ,
			FALSE ,
			FALSE ,
			a_NextNode ,
			a_Parent 
		) 
	{
	}

	~WmiNullRangeNode ()
	{
	} ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport Conjunctions
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_RangeContainerCount ;
	WmiRangeNode **m_RangeContainer ;
	
public:

	Conjunctions (

		ULONG a_RangeContainerCount 

	) :	m_RangeContainerCount ( a_RangeContainerCount ) ,
		m_RangeContainer ( NULL )
	{
	}

	~Conjunctions () 
	{
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				delete m_RangeContainer [ t_Index ] ;
			}

			delete [] m_RangeContainer ;
		}
	} ;	

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_RangeContainer = new WmiRangeNode * [ m_RangeContainerCount ] ;
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				m_RangeContainer [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ; 
		}

		return t_Status ;
	}

	ULONG GetRangeCount () 
	{
		return m_RangeContainerCount ;
	}

	WmiRangeNode *GetRange ( ULONG a_Index ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			return m_RangeContainer [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}

	void SetRange ( ULONG a_Index , WmiRangeNode *a_Range ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			if ( m_RangeContainer [ a_Index ] )
			{
				delete m_RangeContainer [ a_Index ] ;
			}

			m_RangeContainer [ a_Index ] = a_Range ;
		}		
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport Disjunctions 
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_ConjunctionCount ;
	ULONG m_DisjunctionCount ;
	Conjunctions **m_Disjunction ;
	
public:

	Disjunctions (

		ULONG a_DisjunctionCount ,
		ULONG a_ConjunctionCount 

	) :	m_DisjunctionCount ( a_DisjunctionCount ) ,
		m_ConjunctionCount ( a_ConjunctionCount ) ,
		m_Disjunction ( NULL )
	{
	}

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_Disjunction = new Conjunctions * [ m_DisjunctionCount ] ;
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				m_Disjunction [ t_Index ] = NULL ;
			}

			for ( t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = new Conjunctions ( m_ConjunctionCount ) ;
				if ( t_Disjunction )
				{
					t_Status = t_Disjunction->Initialize () ;
					if ( t_Status != State_True )
					{
						break ;
					}
				}
				else
				{
					t_Status = State_Error ;
					break ;
				}

				m_Disjunction [ t_Index ] = t_Disjunction ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}

	~Disjunctions () 
	{
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = m_Disjunction [ t_Index ] ;
				delete t_Disjunction ;
			}
			
			delete [] m_Disjunction ;
		}
	} ;	

	ULONG GetDisjunctionCount () 
	{
		return m_DisjunctionCount ;
	}

	ULONG GetConjunctionCount () 
	{
		return m_ConjunctionCount ;
	}

	Conjunctions *GetDisjunction ( ULONG a_Index ) 
	{
		if ( m_DisjunctionCount > a_Index ) 
		{
			return m_Disjunction [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport PartitionSet
{
private:
protected:

/*
 *	Null for top level
 */
	ULONG m_KeyIndex ;
	WmiRangeNode *m_Range ;

/*
 *	Number of non overlapping partitions, zero when all keys have been partitioned
 */

	ULONG m_NumberOfNonOverlappingPartitions ;
	PartitionSet **m_NonOverlappingPartitions ;

public:

	PartitionSet ()	:	m_Range ( NULL ) ,
						m_KeyIndex ( 0 ) ,
						m_NumberOfNonOverlappingPartitions ( 0 ) ,
						m_NonOverlappingPartitions ( NULL )
	{
	}

	virtual ~PartitionSet () 
	{
		delete m_Range ;

		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_NumberOfNonOverlappingPartitions ; t_Index ++ )
			{
				delete m_NonOverlappingPartitions [ t_Index ] ;
			}

			delete [] m_NonOverlappingPartitions ;
		}
	}

public:

	WmiTriState Initialize ( ULONG a_Count ) 
	{
		WmiTriState t_Status = State_True ;

		m_NumberOfNonOverlappingPartitions = a_Count ;
		m_NonOverlappingPartitions = new PartitionSet * [ a_Count ] ;
		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < a_Count ; t_Index ++ )
			{
				m_NonOverlappingPartitions [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}
	
	void SetPartition ( ULONG a_Index , PartitionSet *a_Partition )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			m_NonOverlappingPartitions [ a_Index ] = a_Partition ;
		}
	}

public:

	ULONG GetKeyIndex () { return m_KeyIndex ; }
	void SetKeyIndex ( ULONG a_KeyIndex ) { m_KeyIndex = a_KeyIndex ; }

	BOOL Root () { return m_Range == NULL ; }
	BOOL Leaf () { return m_NonOverlappingPartitions == NULL ; }

	void SetRange ( WmiRangeNode *a_Range ) { m_Range = a_Range ; }
	WmiRangeNode *GetRange () { return m_Range ; }

	ULONG GetPartitionCount () { return m_NumberOfNonOverlappingPartitions ; }

	PartitionSet *GetPartition ( ULONG a_Index )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			return m_NonOverlappingPartitions [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport QueryPreprocessor 
{
public:

	enum QuadState {

		State_True ,
		State_False ,
		State_ReEvaluate ,
		State_Undefined ,
		State_Error 
	} ;

private:
protected:

	BOOL RecursiveEvaluate ( 

		void *a_Context ,
		SQL_LEVEL_1_RPN_EXPRESSION & a_Expression , 
		WmiTreeNode *a_Parent , 
		WmiTreeNode **a_Node ,
		int &a_Index 
	) ;

	void TransformAndOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_AndChild , 
		WmiTreeNode *a_OrChild 
	) ;

	void TransformNotNotExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotAndExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformAndTrueEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOrFalseEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOperatorToRange ( 

		WmiTreeNode *&a_Node
	) ;

	void TransformIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare ,
		WmiTreeNode *a_Intersection
	) ;

	void TransformNonIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare
	) ;

	WmiTriState EvaluateNotEqualExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateNotExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateAndExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateOrExpression ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveRemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveInsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;
	WmiTriState InsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;

	WmiTriState RecursiveSortConditionals ( WmiTreeNode *&a_Root , WmiTreeNode *&a_NewRoot ) ;
	WmiTriState SortConditionals ( WmiTreeNode *&a_Root ) ;
	WmiTriState RecursiveSort ( WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveConvertToRanges ( WmiTreeNode *&a_Root ) ;
	
	QuadState RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Compare ) ;

	void CountDisjunctions ( WmiTreeNode *a_Root , ULONG &a_Count ) ;

	WmiTriState CreateDisjunctions ( 

		void *a_Context ,
		WmiTreeNode *a_Node , 
		Disjunctions *a_Disjunctions , 
		ULONG a_PropertiesToPartitionCount ,
		BSTR *a_PropertiesToPartition ,
		ULONG &a_DisjunctionIndex 
	) ;

	WmiTriState RecursivePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition , 
		ULONG a_DisjunctionSetToTestCount ,
		ULONG *a_DisjunctionSetToTest ,
		ULONG a_KeyIndex 
	) ;

protected:

/*
 *	Given a property name and it's value convert to it's correct type.
 *	e.g. if the CIMType of a_PropertyName is uint32 then create an WmiUnsignedIntegerNode
 *	return NULL if error.
 */

	virtual WmiTreeNode *AllocTypeNode ( 

		void *a_Context ,
		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		WmiTreeNode *a_Parent 

	) ;

	virtual QuadState InvariantEvaluate ( 

		void *a_Context ,
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 

	) { return State_Undefined ; }

	virtual WmiRangeNode *AllocInfiniteRangeNode (

		void *a_Context ,
		BSTR a_PropertyName 

	) { return NULL ; }

protected:

	BOOL Evaluate (

		void *a_Context ,
		SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
		WmiTreeNode **a_Root
	) ;

	QuadState DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) ;

	void RecursiveQuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Lower , 
		ULONG a_Upper
	) ;

	void QuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Size
	) ;

	void SortRanges (

		ULONG a_DisjunctionCount ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	WmiTriState RemoveOverlaps (

		ULONG *a_DisjunctionSetToTest ,
		ULONG a_DisjunctionCount ,
		ULONG *a_OverlappingIndex ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	QuadState RemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState Sort ( WmiTreeNode *&a_Root ) ;

	WmiTriState ConvertToRanges ( WmiTreeNode *&a_Root ) ;

	QuadState RemoveNonOverlappingRanges ( WmiTreeNode *&a_Root ) ;

	WmiTriState CreateDisjunctionContainer (

		void *a_Context , 
		WmiTreeNode *a_Root , 
		ULONG a_Count , 
		BSTR *a_Container , 
		Disjunctions *&a_Disjunctions
	) ;

	WmiTriState CreatePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition
	) ;

	void PrintTree ( WmiTreeNode *a_Root ) ;

public:

	QueryPreprocessor () ;
	virtual ~QueryPreprocessor () ;

	QuadState PreProcess (

		void *a_Context , 
		SQL_LEVEL_1_RPN_EXPRESSION *a_RpnExpression , 
		WmiTreeNode *&a_Root
	) ;

	QuadState PreProcess ( 

		void *a_Context ,
		SQL_LEVEL_1_RPN_EXPRESSION *a_RpnExpression , 
		WmiTreeNode *a_Root ,
		ULONG a_Count , 
		BSTR *a_Container , 
		PartitionSet *&a_Partition
	) ;

	QuadState Query ( 

		BSTR a_Query ,
		SQL_LEVEL_1_RPN_EXPRESSION *&a_RpnExpression
	) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provevt.h ===
//***************************************************************************

//

//  PROVEVT.H

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROVEVT_H__
#define __PROVEVT_H__

#ifdef PROVIMEX_INIT
class __declspec ( dllexport ) ProvEventObject
#else
class __declspec ( dllimport ) ProvEventObject
#endif
{
private:

	HANDLE m_event ;

protected:
public:

	ProvEventObject ( const TCHAR *globalEventName = NULL ) ;
	virtual ~ProvEventObject () ;

	HANDLE GetHandle () ;
	void Set () ;
	void Clear () ;

	virtual void Process () ;
	virtual BOOL Wait () ;
	virtual void Complete () ;
} ;

#endif //__PROVEVT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\provval.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: value.cpp
Written By:	B.Rajeev
----------------------------------------------------------*/

#include <precomp.h>
#include <typeinfo.h>
#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>

#include <provimex.h>
#include <provexpt.h>
#include <provval.h>

BOOL ProvNull :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = TRUE;
	}

	return bResult;
}


// Copy constructor
ProvInteger::ProvInteger ( IN const ProvInteger &value )
{
	val = value.GetValue();
}

BOOL ProvInteger :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvInteger &)value);
	}

	return bResult;
}

LONG ProvInteger::GetValue () const
{ 
	return val; 
}

void ProvInteger::SetValue ( IN const LONG value ) 
{ 
	val = value; 
}

ProvValue *ProvInteger::Copy () const 
{ 
	return new ProvInteger(val);
}

// Copy constructor
ProvGauge::ProvGauge ( IN const ProvGauge &value )
{
	val = value.GetValue();
}

BOOL ProvGauge :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvGauge &)value);
	}

	return bResult;
}

ULONG ProvGauge::GetValue () const
{ 
	return val; 
}

void ProvGauge::SetValue ( IN const ULONG value ) 
{ 
	val = value; 
}

ProvValue *ProvGauge::Copy () const 
{ 
	return new ProvGauge(val);
}

// Copy constructor
ProvCounter::ProvCounter ( IN const ProvCounter &value )
{
	val = value.GetValue();
}

BOOL ProvCounter :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvCounter &)value);
	}

	return bResult;
}

ULONG ProvCounter::GetValue () const
{ 
	return val; 
}

void ProvCounter::SetValue ( IN const ULONG value ) 
{ 
	val = value; 
}

ProvValue *ProvCounter::Copy () const 
{ 
	return new ProvCounter(val);
}

// Copy constructor
ProvTimeTicks::ProvTimeTicks ( IN const ProvTimeTicks &value )
{
	val = value.GetValue();
}

BOOL ProvTimeTicks :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvTimeTicks &)value);
	}

	return bResult;
}

ULONG ProvTimeTicks::GetValue () const
{ 
	return val; 
}

void ProvTimeTicks::SetValue ( IN const ULONG value ) 
{ 
	val = value; 
}

ProvValue *ProvTimeTicks::Copy () const 
{ 
	return new ProvTimeTicks(val);
}

void ProvOctetString::OverWrite(IN const UCHAR *value)
{
	if ( value && length )
	{
		memcpy(val, value, sizeof(UCHAR)*length);
	}
}

void ProvOctetString::Initialize(IN const UCHAR *value, IN const ULONG valueLength)
{
	is_valid = FALSE;

	if ( (value == NULL) && (valueLength != 0) )
		return;

	length = valueLength;
	val = Replicate(value, valueLength);
	is_valid = TRUE;
}


void ProvOctetString::UnReplicate(UCHAR *value)
{
	if ( is_valid == TRUE )
		delete[] val;
}

ProvOctetString::ProvOctetString ( IN const UCHAR *value , IN const ULONG valueLength ) : is_valid ( FALSE )
{		
	Initialize(value, valueLength);
}

ProvOctetString::ProvOctetString ( IN const ProvOctetString &value ) : is_valid ( FALSE )
{
	Initialize(value.GetValue(), value.GetValueLength());
}

ProvOctetString::~ProvOctetString ()
{
	UnReplicate(val);
}


ULONG ProvOctetString::GetValueLength () const 
{ 
	return length; 
}

UCHAR *ProvOctetString::GetValue () const 
{ 
	return val; 
}

ProvValue *ProvOctetString::Copy () const 
{
	return new ProvOctetString(val, length);
}
	
UCHAR *ProvOctetString::Replicate(IN const UCHAR *value, IN const ULONG valueLength)
{
	if ( value )
	{
		UCHAR *temp = new UCHAR[valueLength];

		memcpy(temp, value, sizeof(UCHAR)*valueLength);

		return temp;
	}
	else
	{
		return NULL ;
	}
}

void ProvOctetString::SetValue ( IN const UCHAR *value , IN const ULONG valueLength )
{
	if (length != valueLength)
	{
		UnReplicate(val);
		Initialize(value, valueLength);
	}
	else
		OverWrite(value);
}

BOOL ProvOctetString :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvOctetString &)value);
	}

	return bResult;
}

BOOL ProvOctetString::Equivalent(IN const ProvOctetString &Prov_octet_string) const
{
	if ( is_valid && Prov_octet_string() )
	{
		if ( length != Prov_octet_string.GetValueLength() )
			return FALSE;

		UCHAR *octet_values = Prov_octet_string.GetValue();

		for( UINT i=0; i < length; i++)
		{
			if ( val[i] != octet_values[i] )
				return FALSE;
		}

		return TRUE;
	}
	else
		return FALSE;
}

void ProvObjectIdentifier::OverWrite(IN const ULONG *value)
{
	if ( value )
	{
		memcpy(val, value, sizeof(ULONG)*length);
	}
}

void ProvObjectIdentifier::Initialize(IN const ULONG *value, IN const ULONG valueLength)
{	
	if ( ( (value == NULL) && (valueLength != 0) ) || ( valueLength == 0 ) )
	{
		length = 0 ;
		val = NULL ;
		return;
	}

	length = valueLength;

	if ( length <= DEFAULT_OBJECTIDENTIFIER_LENGTH )
	{
		val = m_value ;
		memcpy(val , value, sizeof(ULONG)*length);
		is_valid = TRUE;

	}
	else
	{
		val = new ULONG[length];
		memcpy(val , value, sizeof(ULONG)*length);
		is_valid = TRUE;
	}
}

void ProvObjectIdentifier::UnReplicate(ULONG *value)
{
	if ( ( is_valid == TRUE ) & ( length > DEFAULT_OBJECTIDENTIFIER_LENGTH ) )
	{
		delete[] val;
	}
}

ProvObjectIdentifier::ProvObjectIdentifier ( IN const ULONG *value , IN const ULONG valueLength ) : val ( NULL ) , length ( 0 ) , is_valid ( TRUE ) 
{	
	Initialize(value, valueLength);
}

ProvObjectIdentifier::ProvObjectIdentifier ( IN const ProvObjectIdentifier &value ) : val ( NULL ) , length ( 0 ) , is_valid ( TRUE ) 
{
	Initialize(value.GetValue(), value.GetValueLength());
}

ProvObjectIdentifier::~ProvObjectIdentifier ()
{
	UnReplicate(val);
}

ULONG ProvObjectIdentifier::GetValueLength () const 
{ 
	return length; 
}

ULONG *ProvObjectIdentifier::GetValue () const 
{ 
	return val; 
}

ProvValue *ProvObjectIdentifier::Copy () const 
{
	return new ProvObjectIdentifier(val, length);
}

		
ULONG *ProvObjectIdentifier::Replicate(IN const ULONG *value, IN const ULONG valueLength) const
{
	if ( value )
	{
		ULONG *temp = new ULONG[valueLength];
		memcpy(temp, value, sizeof(ULONG)*valueLength);
		return temp;
	}
	else
	{
		return NULL ;
	}
}

		
ULONG *ProvObjectIdentifier::Replicate(IN const ULONG *first_value, 
									   IN const ULONG first_length,
									   IN const ULONG *second_value,
									   IN const ULONG second_length) const
{
	if ( first_value && second_value )
	{
		ULONG new_length = first_length + second_length;
		ULONG *temp = new ULONG[new_length];
			
		int first_value_size = sizeof(ULONG)*first_length;

		memcpy(temp, first_value, first_value_size);
		memcpy(temp + first_length, second_value, 
					sizeof(ULONG)*second_length);
		return temp;
	}
	else if ( first_value )
	{
		ULONG *temp = new ULONG [ first_length];
		memcpy(temp, first_value, sizeof(ULONG)*first_length);
		return temp;
	}
	else if ( second_value )
	{
		ULONG *temp = new ULONG [ second_length];
		memcpy(temp, second_value, sizeof(ULONG)*second_length);
		return temp;

	}
	else
	{
		return NULL ;
	}
}


ProvObjectIdentifier::Comparison ProvObjectIdentifier::Compare(IN const ProvObjectIdentifier &first, 
															   IN const ProvObjectIdentifier &second) const
{
	ULONG *first_string = first.GetValue();
	ULONG *second_string = second.GetValue();
	int first_length = first.GetValueLength();
	int second_length = second.GetValueLength();
	int min_length = MIN(first_length,second_length);

	for(int i=0; i < min_length; i++)
	{
		if ( first_string[i] < second_string[i] )
			return LESS_THAN;
		else if ( first_string[i] > second_string[i] )
			return GREATER_THAN;
		else
			continue;
	}

	if ( first_length < second_length )
		return LESS_THAN;
	else if ( first_length > second_length )
			return GREATER_THAN;
	else
		return EQUAL_TO;
}

void ProvObjectIdentifier::SetValue ( IN const ULONG *value , IN const ULONG valueLength )
{
	if (valueLength)
	{
		if ( length != valueLength)
		{
			UnReplicate(val);
			Initialize(value, valueLength);
		}
		else
		{
			OverWrite(value);
		}
	}
	else
	{
		UnReplicate(val);
		val = NULL ;
		length = 0 ;
	}
}

// A null terminated dot-separated string representing the 
// object identifer value is passed and the private fields
// and length are set from it
ProvObjectIdentifier::ProvObjectIdentifier(IN const char *value)
{
	is_valid = FALSE;

	UINT str_len = strlen(value);
	if ( str_len <= 0 )
		return;

	ULONG temp_field[MAX_FIELDS];

	// create an input stream from the string
	istrstream input_stream((char *)value);

	// consecutive fields must be separated by a
	// FIELD_SEPARATOR
	char separator;

	input_stream >> temp_field[0];

  	if ( input_stream.bad() || input_stream.fail() )
		return;

	// while the stream still has something,
	// read (FIELD_SEPARATOR, ULONG) pairs from the input stream
	// and set the temp_fields
	// check if the read was bad or failed after the event
	for( int i = 1 ; (i < MAX_FIELDS) && (!input_stream.eof()); i++)
	{
		input_stream >> separator;

  		if ( input_stream.bad() || input_stream.fail() )
			return;

		if ( separator != FIELD_SEPARATOR )
			return;

		input_stream >> temp_field[i];
 
		if ( input_stream.bad() || input_stream.fail() )
			return;
	}

	is_valid = TRUE;

	// set the length
	length = i;
	val = NULL ;

	// create memory for the fields and copy temp_fields into it
	Initialize(temp_field, length);
}


BOOL ProvObjectIdentifier::Equivalent(IN const ProvObjectIdentifier &value,
									   IN ULONG max_length) const
{
	if ( (!is_valid) || (!value()) )
		return FALSE;

	if ( (length < max_length) || (value.GetValueLength() < max_length) )
		return FALSE;

	ULONG *value_string = value.GetValue();

	for( UINT i=0; i < max_length; i++ )
		if ( val[i] != value_string[i] )
			return FALSE;

	return TRUE;
}

BOOL ProvObjectIdentifier::Equivalent(IN const ProvObjectIdentifier &value) const
{
	if ( (!is_valid) || (!value()) )
		return FALSE;

	ULONG *value_string = value.GetValue();

	for( UINT i=length; i ; i-- )
	{
		if ( val[i-1] != value_string[i-1] )
			return FALSE;
	}

	return TRUE;
}

BOOL ProvObjectIdentifier :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvObjectIdentifier &)value);
	}

	return bResult;
}

ProvObjectIdentifier ProvObjectIdentifier::operator+ ( IN const ProvObjectIdentifier &value ) const
{	
	ULONG *temp_plus_array = Replicate(val, length, value.GetValue(), value.GetValueLength());

	ProvObjectIdentifier local_identifier(temp_plus_array, length+value.GetValueLength());
	delete[] temp_plus_array;

	return ProvObjectIdentifier(local_identifier);
}

// Determines the fields (starting from left), common to the
// two object identifiers and returns a new object identifier
// with only these fields. If nothing is shared, NULL is returned
ProvObjectIdentifier *ProvObjectIdentifier::Cut( ProvObjectIdentifier &value ) const
{
	// determine the smaller of the two lengths
	int min_length = MIN(length, value.GetValueLength());
	ULONG *other_field = value.GetValue();

	// compare the fields
	for(int index=0; index < min_length; index++)
		if ( val[index] != other_field[index] )
			break;

	// if nothing in common - return NULL
	if ( index == 0 )
		return NULL;

	// they must have the fields in the range [0..(index-1)] common
	// therefore, a common length of "index"
	return new ProvObjectIdentifier(other_field, index);
}


ULONG &ProvObjectIdentifier::operator [] ( IN const ULONG index ) const
{
	if ( index < length )
		return val[index];

	// should never reach here if the user checks the
	// index value before
	return val[0];
}

//returns an allocated char* representation of the OID.
//The return value  must be freed by the caller i.e. delete []
char *ProvObjectIdentifier::GetAllocatedString() const
{
	char * retVal = NULL ;

	if (length)
	{
		retVal = new char [ length * 18 ] ;
		ostrstream s ( retVal , length * 18 ) ;
		s << val[0];
		UINT i = 1;
		char dot = '.';

		while (i < length)
		{
			s << dot << val[i++] ;
		}
		
		s << ends ;
	}

	return retVal;
}
		

ProvIpAddress::ProvIpAddress ( IN const char *value )
{
	// create a stream to read the fields from
	istrstream address_stream((char *)value);

	// store the values [0..255] separated by FIELD_SEPARATORs
	// in the value string
	UCHAR field[PROV_IP_ADDR_LEN];

	// contains the maximum value for a UCHAR. used
	// for comparison with the field values read
	const UCHAR max_uchar = -1;

	// consecutive fields must be separated by a
	// FIELD_SEPARATOR
	char separator;

	// a field is first read into this for comparison
	// with max_uchar
	ULONG temp_field;

	is_valid = FALSE;

	// read the first three (UCHAR,FIELD_SEPARATOR) pairs
	// check if the stream is good before each read
	for(int i=0; i < (PROV_IP_ADDR_LEN-1); i++)
	{
		if ( !address_stream.good() )
			return;

		address_stream >> temp_field;
		if ( temp_field	> max_uchar )
			return;

		field[i] = (UCHAR)temp_field;

		if ( !address_stream.good() )
			return;

		address_stream >> separator;
		if ( separator != FIELD_SEPARATOR )
			return;
	}

	if ( !address_stream.good() )
		return;

	address_stream >> temp_field;
	if (temp_field > max_uchar)
		return;

	field[PROV_IP_ADDR_LEN-1] = (UCHAR)temp_field;

	// make sure that there are is nothing more left in the
	// stream
	if ( !address_stream.eof() )
		return;

	ULONG byteA = field [ 0 ] ;
	ULONG byteB = field [ 1 ] ;
	ULONG byteC = field [ 2 ] ;
	ULONG byteD = field [ 3 ] ;

	val = ( byteA << 24 ) + ( byteB << 16 ) + ( byteC << 8 ) + byteD ;

	is_valid = TRUE;
}


// Copy constructor
ProvIpAddress::ProvIpAddress ( IN const ProvIpAddress &value )
{
	if ( value() )
	{
		val = value.GetValue();
		is_valid = TRUE;
	}
	else
		is_valid = FALSE;
}

BOOL ProvIpAddress :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvIpAddress &)value);
	}

	return bResult;
}


ULONG ProvIpAddress::GetValue () const
{ 
	return val; 
}

void ProvIpAddress::SetValue ( IN const ULONG value ) 
{ 
	val = value;
	is_valid = TRUE;
}

ProvValue *ProvIpAddress::Copy () const 
{ 
	return new ProvIpAddress(val);
}

// Copy constructor
ProvUInteger32::ProvUInteger32 ( IN const ProvUInteger32 &value )
{
	val = value.GetValue();
}

ULONG ProvUInteger32::GetValue () const
{ 
	return val; 
}

void ProvUInteger32::SetValue ( IN const ULONG value ) 
{ 
	val = value; 
}

ProvValue *ProvUInteger32::Copy () const 
{ 
	return new ProvUInteger32(val);
}

BOOL ProvUInteger32 :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvUInteger32 &)value);
	}

	return bResult;
}

// Copy constructor
ProvCounter64::ProvCounter64( IN const ProvCounter64 &value )
{
	lval = value.GetLowValue();
	hval = value.GetHighValue();
}

ULONG ProvCounter64::GetLowValue () const
{ 
	return lval; 
}

ULONG ProvCounter64::GetHighValue () const
{ 
	return hval; 
}

void ProvCounter64::SetValue ( IN const ULONG lvalue , IN const ULONG hvalue ) 
{ 
	lval = lvalue; 
	hval = hvalue ;
}

ProvValue *ProvCounter64::Copy () const 
{ 
	return new ProvCounter64(lval,hval);
}

BOOL ProvCounter64 :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvCounter64 &)value);
	}

	return bResult;
}

BOOL ProvOpaque :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvOpaque &)value);
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\provtype.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS Prov Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include <provimex.h>
#include <provexpt.h>
#include <typeinfo.h>
#include <provtempl.h>
#include <strsafe.h>
#include <tchar.h>
#include <provmt.h>
#include <winsock.h>
#include <strstrea.h>
#include <provcont.h>
#include <provval.h>
#include <provtype.h>


#if _MSC_VER >= 1100
template <> UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key )
#else
UINT HashKey ( wchar_t *key )
#endif
{
	UCHAR *value = ( UCHAR * ) key ;
	ULONG length = wcslen ( key ) * sizeof ( wchar_t ) ;

    UINT hash;
    if (length > 1)
    {
        USHORT even = 0;
        USHORT odd = 0;

        for (ULONG i = length >> 1; i--;)
        {
            even += towlower (*value++) ;
            odd += towlower (*value++) ;
        }
        if (length & 1)
        {
            even += towlower (*value);
        }
        hash = odd>>8;
        hash |= (odd & 0xff) << 8;
        hash ^= even;
    }
    else
    {
        hash = *value;
    }

	return hash ;
}

#if _MSC_VER >= 1100
typedef wchar_t * WbemHack_wchar_t ;
template<> BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const WbemHack_wchar_t *pElement1, const WbemHack_wchar_t *pElement2 )
#else
BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 )
#endif
{
	return _wcsicmp ( *pElement1 , *pElement2 ) == 0 ;
}

CBString::CBString(int nSize) : m_pString ( NULL )
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString) : m_pString ( NULL )
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) 
	{
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}

DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString )
{
	size_t textLength = mbstowcs ( NULL , dbcsString , 0  ) ;
	wchar_t *unicodeString = new wchar_t [ textLength + 1 ] ;
	textLength = mbstowcs ( unicodeString , dbcsString , textLength + 1 ) ;
	if ( textLength == -1 )
	{
		delete [] unicodeString ;
		unicodeString = NULL ;
	}

	return unicodeString ;
}

DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString )
{
	size_t textLength = wcstombs ( NULL , unicodeString , 0 ) ;
	char *dbcsString = new char [ textLength + 1 ] ;
	textLength = wcstombs ( dbcsString , unicodeString , textLength + 1 ) ;
	if ( textLength == -1 )
	{
		delete [] dbcsString ;
		dbcsString = NULL ;
	}

	return dbcsString ;
}

DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) 
{
	if ( string )
	{
		int textLength = wcslen ( string ) ;

		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;
		StringCchCopyW ( textBuffer , textLength + 1 , string ) ;

		return textBuffer ;
	}
	else
	{
		return NULL ;
	}
}

DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix )
{
	int prefixTextLength = 0 ;
	if ( prefix )
	{
		prefixTextLength = wcslen ( prefix ) ;
	}

	int suffixTextLength = 0 ;
	if ( suffix )
	{
		suffixTextLength = wcslen ( suffix ) ;
	}

	if ( prefix || suffix )
	{
		int textLength = prefixTextLength + suffixTextLength ;
		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;

		if ( prefix )
		{
			StringCchCopyW ( textBuffer , prefixTextLength + 1 , prefix ) ;
		}

		if ( suffix )
		{
			StringCchCopyW ( & textBuffer [ prefixTextLength ] , suffixTextLength + 1 , suffix ) ;
		}

		return textBuffer ;
	}	
	else
		return NULL ;
}

ProvLexicon :: ProvLexicon () : position ( 0 ) , tokenStream ( NULL ) , token ( INVALID_ID )
{
	value.token = NULL ;
}

ProvLexicon :: ~ProvLexicon ()
{
	switch ( token ) 
	{
		case TOKEN_ID:
		{
			delete [] value.token ;
		}
		break ;
	
		default:
		{
		} ;
	}
}

void ProvLexicon :: SetToken ( ProvLexicon :: LexiconToken a_Token )
{
	token = a_Token ;
}

ProvLexicon :: LexiconToken ProvLexicon :: GetToken ()
{
	return token ;
}

ProvLexiconValue *ProvLexicon :: GetValue ()
{
	return &value ;
}

ProvAnalyser :: ProvAnalyser ( const wchar_t *tokenStream ) : status ( TRUE ) , position ( 0 ) , stream ( NULL ) 
{
	if ( tokenStream )
	{
		DWORD t_TextLength = wcslen ( tokenStream ) + 1 ;
		stream = new wchar_t [ t_TextLength ] ;
		StringCchCopyW ( stream , t_TextLength , tokenStream ) ;
	}
}

ProvAnalyser :: ~ProvAnalyser () 
{
	delete [] stream ;
}

void ProvAnalyser :: Set ( const wchar_t *tokenStream ) 
{
	status = 0 ;
	position = NULL ;

	delete [] stream ;
	stream = NULL ;

	DWORD t_TextLength = wcslen ( tokenStream ) + 1 ;
	stream = new wchar_t [ t_TextLength ] ;
	StringCchCopyW ( stream , t_TextLength , tokenStream ) ;
}

void ProvAnalyser :: PutBack ( const ProvLexicon *token ) 
{
	position = token->position ;
}

ProvAnalyser :: operator void * () 
{
	return status ? this : NULL ;
}

ProvLexicon *ProvAnalyser :: Get ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace ) 
{
	ProvLexicon *lexicon = NULL ;

	if ( stream )
	{
		lexicon = GetToken ( unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) ;
	}
	else
	{
		lexicon = CreateLexicon () ;
		lexicon->position = position ;
		lexicon->token = ProvLexicon :: EOF_ID ;
	}

	return lexicon ;
}

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define TOKEN_START 5000
#define WHITESPACE_START 6000
#define ACCEPT_STATE ANALYSER_ACCEPT_STATE
#define REJECT_STATE ANALYSER_REJECT_STATE 

ProvLexicon *ProvAnalyser :: GetToken ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace )  
{
	ProvLexicon *lexicon = CreateLexicon () ;
	lexicon->position = position ;

	Initialise () ;

	ULONG state = 0 ;

/* 
 * Integer Definitions
 */

	BOOL negative = FALSE ;
	BOOL positive = FALSE ;

	ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
	ULONG positiveMagicPosDigit = 5 ;
	ULONG positiveDatum = 0 ;	

	LONG negativeMagicMult = ( LONG ) ( ( ( ULONG ) ( 1L << 31L ) ) / 10L ) ; 
	ULONG negativeMagicNegDigit = 8 ;
	ULONG negativeMagicPosDigit = 7 ;
	LONG negativeDatum = 0 ;	

/*
 * Token Definitions
 */

	ULONG token_start = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = stream [ position ] ;
		if ( Analyse ( lexicon , state , token , stream , position , unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) )
		{
		}
		else
		{
			switch ( state )
			{
				case 0:
				{
					if ( IsAlpha ( token ) )
					{
						state = TOKEN_START ;
						token_start = position ;
					}
					else if ( ProvAnalyser :: IsLeadingDecimal ( token ) )
					{
						state = DEC_INTEGER_START + 1  ;
						negativeDatum = ( token - 48 ) ;
					}
					else if ( token == L'+' )
					{
						if ( unSignedIntegersOnly ) 
						{
							state = ACCEPT_STATE ;
							lexicon->token = ProvLexicon :: PLUS_ID ;
						}
						else
						{
							state = DEC_INTEGER_START ;
						}
					}
					else if ( token == L'-' ) 
					{
						if ( unSignedIntegersOnly )
						{
							state = ACCEPT_STATE ;
							lexicon->token = ProvLexicon :: MINUS_ID ;
						}
						else
						{
							negative = TRUE ;
							state = DEC_INTEGER_START ;
						}
					}
					else if ( token == L'0' )
					{
						if ( ! leadingIntegerZeros ) 
						{
							state = 1 ;
						}
						else
						{
							negativeDatum = 0 ;
							state = DEC_INTEGER_START + 1 ;
						}
					}
					else if ( ProvAnalyser :: IsWhitespace ( token ) ) 
					{
						if ( eatSpace )
						{
							state = 0 ;
						}
						else
						{
							lexicon->token = ProvLexicon :: WHITESPACE_ID ;
							state = WHITESPACE_START ;
						}
					}
					else if ( token == L'(' )
					{
						lexicon->token = ProvLexicon :: OPEN_PAREN_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L')' )
					{
						lexicon->token = ProvLexicon :: CLOSE_PAREN_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L',' )
					{
						lexicon->token = ProvLexicon :: COMMA_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L':' )
					{
						lexicon->token = ProvLexicon :: COLON_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L'.' )
					{
						state = 2;
					}
					else if ( IsEof ( token ) )
					{
						lexicon->token = ProvLexicon :: EOF_ID ;
						state = ACCEPT_STATE ;
					}
					else state = REJECT_STATE ;
				}
				break ;

				case 1:
				{
					if ( token == L'x' || token == L'X' )
					{
						state = HEX_INTEGER_START ;				
					}
					else if ( ProvAnalyser :: IsOctal ( token ) )
					{
						state = OCT_INTEGER_START ;
						positiveDatum = ( token - 48 ) ;
					}
					else
					{
						if ( unSignedIntegersOnly )
						{
							lexicon->token = ProvLexicon :: UNSIGNED_INTEGER_ID ;
							lexicon->value.unsignedInteger = 0 ;
						}
						else
						{
							lexicon->token = ProvLexicon :: SIGNED_INTEGER_ID ;
							lexicon->value.signedInteger = 0 ;
						}

						state = ACCEPT_STATE ;
						position -- ;
					}
				}
				break ;

				case 2:
				{
					if ( token == L'.' )
					{
						lexicon->token = ProvLexicon :: DOTDOT_ID ;
						state = ACCEPT_STATE ;
					}
					else
					{
						lexicon->token = ProvLexicon :: DOT_ID ;
						position -- ;
						state = ACCEPT_STATE  ;
					}
				}
				break ;

				case TOKEN_START:
				{
					if ( IsAlphaNumeric ( token ) ) 
					{
						state = TOKEN_START ;
					}
					else 
					{
						state = ACCEPT_STATE ;
						lexicon->token = ProvLexicon :: TOKEN_ID ;
						lexicon->value.token = new wchar_t [ position - token_start + 1 ] ;
						wcsncpy ( 

							lexicon->value.token , 
							& stream [ token_start ] , 
							position - token_start 
						) ;

						lexicon->value.token [ position - token_start ] = 0 ;

						position -- ;
					}
				}
				break ;

				case WHITESPACE_START:
				{
					if ( ProvAnalyser :: IsWhitespace ( token ) ) 
					{
						state = WHITESPACE_START ;
					}
					else
					{
						state = ACCEPT_STATE ;
						position -- ;
					}
				}
				break;

				case HEX_INTEGER_START:
				{
					if ( ProvAnalyser :: IsHex ( token ) )
					{
						positiveDatum = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
						state = HEX_INTEGER_START + 1 ;
					}
					else
					{
						state = REJECT_STATE ;
					}
				}
				break ;

				case HEX_INTEGER_START+1:
				{
					if ( ProvAnalyser :: IsHex ( token ) )
					{
						state = HEX_INTEGER_START + 1 ;

						if ( positiveDatum > positiveMagicMult )
						{
							state = REJECT_STATE ;
						}
						else if ( positiveDatum == positiveMagicMult ) 
						{
							if ( ProvAnalyser :: HexWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
							{
								state = REJECT_STATE ;
							}
						}

						positiveDatum = ( positiveDatum << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					}
					else
					{
						lexicon->token = ProvLexicon :: UNSIGNED_INTEGER_ID ;
						lexicon->value.unsignedInteger = positiveDatum ;
						state = ACCEPT_STATE ;

						position -- ;
					}
				}
				break ;

				case OCT_INTEGER_START:
				{
					if ( ProvAnalyser :: IsOctal ( token ) )
					{
						state = OCT_INTEGER_START ;

						if ( positiveDatum > positiveMagicMult )
						{
							state = REJECT_STATE ;
						}
						else if ( positiveDatum == positiveMagicMult ) 
						{
							if ( ProvAnalyser :: OctWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
							{
								state = REJECT_STATE ;
							}
						}

						positiveDatum = ( positiveDatum << 3 ) + ProvAnalyser :: OctWCharToDecInteger ( token ) ;
					}
					else
					{
						lexicon->token = ProvLexicon :: UNSIGNED_INTEGER_ID ;
						lexicon->value.unsignedInteger = positiveDatum ;
						state = ACCEPT_STATE ;

						position -- ;
					}
				}
				break ;

				case DEC_INTEGER_START:
				{
					if ( ProvAnalyser :: IsDecimal ( token ) )
					{
						negativeDatum = ( token - 48 ) ;
						state = DEC_INTEGER_START + 1 ;
					}
					else 
					if ( ProvAnalyser :: IsWhitespace ( token ) ) 
					{
						state = DEC_INTEGER_START ;
					}
					else state = REJECT_STATE ;
				}	
				break ;

				case DEC_INTEGER_START+1:
				{
					if ( ProvAnalyser :: IsDecimal ( token ) )
					{	
						state = DEC_INTEGER_START + 1 ;

						if ( positive )
						{
							if ( positiveDatum > positiveMagicMult )
							{
								state = REJECT_STATE ;
							}
							else if ( positiveDatum == positiveMagicMult ) 
							{
								if ( ( ULONG ) ( token - 48 ) > positiveMagicPosDigit ) 
								{
									state = REJECT_STATE ;
								}
							}
						}
						else
						{
							if ( negativeDatum > negativeMagicMult )
							{
								state = REJECT_STATE ;
							}
							else if ( negativeDatum == negativeMagicMult ) 
							{
								if ( negative ) 
								{
									if ( ( ULONG ) ( token - 48 ) > negativeMagicNegDigit ) 
									{
										state = REJECT_STATE ;
									}
								}
								else
								{
									if ( ( ULONG ) ( token - 48 ) > negativeMagicPosDigit ) 
									{
										positiveDatum = negativeDatum ;
										positive = TRUE ;
									}
								}
							}
						}

						if ( positive )
						{
							positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
						}
						else
						{
							negativeDatum = negativeDatum * 10 + ( token - 48 ) ;
						}
					}
					else
					{
						if ( negative )
						{
							if ( ! unSignedIntegersOnly )
							{
								lexicon->token = ProvLexicon :: SIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum * -1 ;
							}
							else
							{
								state = REJECT_STATE ;
							}
						}
						else if ( positive )
						{
							lexicon->token = ProvLexicon :: UNSIGNED_INTEGER_ID ;
							lexicon->value.unsignedInteger = positiveDatum ;
						}
						else
						{
							if ( unSignedIntegersOnly )
							{
								lexicon->token = ProvLexicon :: UNSIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum ;
							}
							else
							{
								lexicon->token = ProvLexicon :: SIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum ;
							}
						}

						state = ACCEPT_STATE ;

						position -- ;
					}
				}	
				break ;

				case ACCEPT_STATE:
				case REJECT_STATE:
				default:
				{
					state = REJECT_STATE ;
				} ;
				break ;
			}
		}

		position ++ ;
	}

	status = ( state != REJECT_STATE ) ;

	return lexicon ;
}

BOOL ProvAnalyser :: IsLeadingDecimal ( wchar_t token )
{
	return iswdigit ( token ) && ( token != L'0' ) ;
}

BOOL ProvAnalyser :: IsDecimal ( wchar_t token )
{
	return iswdigit ( token ) ;
}

BOOL ProvAnalyser :: IsHex ( wchar_t token )
{
	return iswxdigit ( token ) ;
}
	
BOOL ProvAnalyser :: IsWhitespace ( wchar_t token )
{
	return iswspace ( token ) ;
}

BOOL ProvAnalyser :: IsOctal ( wchar_t token )
{
	return ( token >= L'0' && token <= L'7' ) ;
}

BOOL ProvAnalyser :: IsAlpha ( wchar_t token )
{
	return iswalpha ( token ) ;
}

BOOL ProvAnalyser :: IsAlphaNumeric ( wchar_t token )
{
	return iswalnum ( token ) || ( token == L'_' ) || ( token == L'-' ) ;
}

BOOL ProvAnalyser :: IsEof ( wchar_t token )
{
	return token == 0 ;
}

ULONG ProvAnalyser :: OctWCharToDecInteger ( wchar_t token ) 
{
	return token - L'0' ;
}

ULONG ProvAnalyser :: HexWCharToDecInteger ( wchar_t token ) 
{
	if ( token >= L'0' && token <= L'9' )
	{
		return token - L'0' ;
	}
	else if ( token >= L'a' && token <= L'f' )
	{
		return token - L'a' + 10 ;
	}
	else if ( token >= L'A' && token <= L'F' )
	{
		return token - L'A' + 10 ;
	}
	else
	{
		return 0 ;
	}
}

ULONG ProvAnalyser :: DecWCharToDecInteger ( wchar_t token ) 
{
	if ( token >= L'0' && token <= L'9' )
	{
		return token - L'0' ;
	}
	else
	{
		return 0 ;
	}
}

wchar_t ProvAnalyser :: DecIntegerToOctWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 7 )
	{
		return L'0' + integer ;
	}
	else
	{
		return L'0' ;
	}
}

wchar_t ProvAnalyser :: DecIntegerToDecWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return L'0' + integer ;
	}
	else
	{
		return L'0' ;
	}
}

wchar_t ProvAnalyser :: DecIntegerToHexWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return L'0' + integer ;
	}
	else if ( integer >= 10 && integer <= 15 )
	{
		return L'a' + ( integer - 10 ) ;
	}
	else
	{
		return L'0' ;
	}
}

ULONG ProvAnalyser :: OctCharToDecInteger ( char token ) 
{
	return token - '0' ;
}

ULONG ProvAnalyser :: HexCharToDecInteger ( char token ) 
{
	if ( token >= '0' && token <= '9' )
	{
		return token - '0' ;
	}
	else if ( token >= 'a' && token <= 'f' )
	{
		return token - 'a' + 10 ;
	}
	else if ( token >= 'A' && token <= 'F' )
	{
		return token - 'A' + 10 ;
	}
	else
	{
		return 0 ;
	}
}

ULONG ProvAnalyser :: DecCharToDecInteger ( char token ) 
{
	if ( token >= '0' && token <= '9' )
	{
		return token - '0' ;
	}
	else
	{
		return 0 ;
	}
}

char ProvAnalyser :: DecIntegerToOctChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 7 )
	{
		return '0' + integer ;
	}
	else
	{
		return '0' ;
	}
}

char ProvAnalyser :: DecIntegerToDecChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return '0' + integer ;
	}
	else
	{
		return '0' ;
	}
}

char ProvAnalyser :: DecIntegerToHexChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return '0' + integer ;
	}
	else if ( integer >= 10 && integer <= 15 )
	{
		return 'a' + ( integer - 10 ) ;
	}
	else
	{
		return '0' ;
	}
}

ProvNegativeRangedType :: ProvNegativeRangedType ( const wchar_t *rangeValues ) : status ( TRUE ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	if ( rangeValues ) 
	{
		status = Parse ( rangeValues ) ;
	}
}

ProvNegativeRangedType :: ProvNegativeRangedType ( const ProvNegativeRangedType &copy ) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	POSITION position = copy.rangedValues.GetHeadPosition () ;
	while ( position )
	{
		ProvNegativeRangeType rangeType = copy.rangedValues.GetNext ( position ) ; 
		rangedValues.AddTail ( rangeType ) ;
	}
}

ProvNegativeRangedType :: ~ProvNegativeRangedType ()
{
	delete pushBack ;
	rangedValues.RemoveAll () ;
}


void ProvNegativeRangedType  :: PushBack ()
{
	pushedBack = TRUE ;
}

ProvLexicon *ProvNegativeRangedType  :: Get ()
{
	if ( pushedBack )
	{
		pushedBack = FALSE ;
	}
	else
	{
		delete pushBack ;
		pushBack = NULL ;
		pushBack = analyser.Get () ;
	}

	return pushBack ;
}
	
ProvLexicon *ProvNegativeRangedType  :: Match ( ProvLexicon :: LexiconToken tokenType )
{
	ProvLexicon *lexicon = Get () ;
	status = ( lexicon->GetToken () == tokenType ) ;
	return status ? lexicon : NULL ;
}

BOOL ProvNegativeRangedType :: Check ( const LONG &value )
{
	POSITION position = rangedValues.GetHeadPosition () ;
	if ( position )
	{
		while ( position )
		{
			ProvNegativeRangeType rangeType = rangedValues.GetNext ( position ) ;
			if ( value >= rangeType.GetLowerBound () && value <= rangeType.GetUpperBound () )
			{
				return TRUE ;
			}
		}

		return FALSE ;
	}

	return TRUE ; 

}

BOOL ProvNegativeRangedType :: Parse ( const wchar_t *rangeValues )
{
	BOOL status = TRUE ;

	analyser.Set ( rangeValues ) ;

	return RangeDef () && RecursiveDef () ;
}

BOOL ProvNegativeRangedType :: RangeDef ()
{
	BOOL status = TRUE ;

	LONG lowerRange = 0 ;
	LONG upperRange = 0 ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: SIGNED_INTEGER_ID:
		{
			lowerRange = lookAhead->GetValue()->signedInteger ;

			ProvLexicon *lookAhead = Get () ;
			switch ( lookAhead->GetToken () ) 
			{
				case ProvLexicon :: DOTDOT_ID:
				{
					ProvLexicon *lookAhead = Get () ;
					switch ( lookAhead->GetToken () ) 
					{
						case ProvLexicon :: SIGNED_INTEGER_ID:
						{
							upperRange = lookAhead->GetValue()->signedInteger ;
							ProvNegativeRangeType rangeType ( lowerRange , upperRange ) ;
							rangedValues.AddTail ( rangeType ) ;
						}
						break ;

						default:
						{
							status = FALSE ;
						}
						break ;
					}
				}
				break ;

				case ProvLexicon :: EOF_ID:
				case ProvLexicon :: COMMA_ID:
				{
					lowerRange = lookAhead->GetValue()->signedInteger ;
					ProvNegativeRangeType rangeType ( lowerRange , lowerRange ) ;
					rangedValues.AddTail ( rangeType ) ;

					PushBack () ;
				} 
				break ;

				default:
				{
					status = FALSE ;
				}
				break ;
			}
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

BOOL ProvNegativeRangedType :: RecursiveDef ()
{
	BOOL status = TRUE ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: COMMA_ID:
		{
			PushBack () ;
			Match ( ProvLexicon :: COMMA_ID ) &&
			RangeDef () &&
			RecursiveDef () ;
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

ProvPositiveRangedType :: ProvPositiveRangedType ( const wchar_t *rangeValues ) : status ( TRUE ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	if ( rangeValues ) 
	{
		status = Parse ( rangeValues ) ;
	}
}

ProvPositiveRangedType :: ProvPositiveRangedType ( const ProvPositiveRangedType &copy ) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	POSITION position = copy.rangedValues.GetHeadPosition () ;
	while ( position )
	{
		ProvPositiveRangeType rangeType = copy.rangedValues.GetNext ( position ) ;
		rangedValues.AddTail ( rangeType ) ;
	}
}

ProvPositiveRangedType :: ~ProvPositiveRangedType ()
{
	delete pushBack ;
	rangedValues.RemoveAll () ;
}

void ProvPositiveRangedType  :: PushBack ()
{
	pushedBack = TRUE ;
}

ProvLexicon *ProvPositiveRangedType  :: Get ()
{
	if ( pushedBack )
	{
		pushedBack = FALSE ;
	}
	else
	{
		delete pushBack ;
		pushBack = NULL ;
		pushBack = analyser.Get ( TRUE ) ;
	}

	return pushBack ;
}
	
ProvLexicon *ProvPositiveRangedType  :: Match ( ProvLexicon :: LexiconToken tokenType )
{
	ProvLexicon *lexicon = Get () ;
	status = ( lexicon->GetToken () == tokenType ) ;
	return status ? lexicon : NULL ;
}

BOOL ProvPositiveRangedType :: Check ( const ULONG &value )
{
	POSITION position = rangedValues.GetHeadPosition () ;
	if ( position )
	{
		while ( position )
		{
			ProvPositiveRangeType rangeType = rangedValues.GetNext ( position ) ;
			if ( value >= rangeType.GetLowerBound () && value <= rangeType.GetUpperBound () )
			{
				return TRUE ;
			}
		}

		return FALSE ;
	}	

	return TRUE ;
}

BOOL ProvPositiveRangedType :: Parse ( const wchar_t *rangeValues )
{
	BOOL status = TRUE ;

	analyser.Set ( rangeValues ) ;

	return RangeDef () && RecursiveDef () ;
}

BOOL ProvPositiveRangedType :: RangeDef ()
{
	BOOL status = TRUE ;

	ULONG lowerRange = 0 ;
	ULONG upperRange = 0 ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: UNSIGNED_INTEGER_ID:
		{
			lowerRange = lookAhead->GetValue()->unsignedInteger ;

			ProvLexicon *lookAhead = Get () ;
			switch ( lookAhead->GetToken () ) 
			{
				case ProvLexicon :: DOTDOT_ID:
				{
					ProvLexicon *lookAhead = Get () ;
					switch ( lookAhead->GetToken () ) 
					{
						case ProvLexicon :: UNSIGNED_INTEGER_ID:
						{
							upperRange = lookAhead->GetValue()->unsignedInteger ;
							ProvPositiveRangeType rangeType ( lowerRange , upperRange ) ;
							rangedValues.AddTail ( rangeType ) ;
						}
						break ;

						case ProvLexicon :: SIGNED_INTEGER_ID:
						{
							if ( lookAhead->GetValue()->signedInteger >= 0 )
							{
								upperRange = lookAhead->GetValue()->unsignedInteger ;
								ProvPositiveRangeType rangeType ( lowerRange , upperRange ) ;
								rangedValues.AddTail ( rangeType ) ;
							}
							else
							{
								status = FALSE ;
							}
						}
						break ;

						default:
						{
							status = FALSE ;
						}
						break ;
					}
				}
				break ;

				case ProvLexicon :: EOF_ID:
				case ProvLexicon :: COMMA_ID:
				{
					ProvPositiveRangeType rangeType ( lowerRange , lowerRange ) ;
					rangedValues.AddTail ( rangeType ) ;

					PushBack () ;
				} 
				break ;

				default:
				{
					status = FALSE ;
				}
				break ;
			}
		}
		break ;

		case ProvLexicon :: SIGNED_INTEGER_ID:
		{
			lowerRange = lookAhead->GetValue()->signedInteger ;
			if ( lowerRange > 0 )
			{
				ProvLexicon *lookAhead = Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case ProvLexicon :: DOTDOT_ID:
					{
						ProvLexicon *lookAhead = Get () ;
						switch ( lookAhead->GetToken () ) 
						{
							case ProvLexicon :: UNSIGNED_INTEGER_ID:
							{
								upperRange = lookAhead->GetValue()->unsignedInteger ;
								ProvPositiveRangeType rangeType ( lowerRange , upperRange ) ;
								rangedValues.AddTail ( rangeType ) ;
							}
							break ;

							case ProvLexicon :: SIGNED_INTEGER_ID:
							{
								if ( lookAhead->GetValue()->signedInteger >= 0 )
								{
									upperRange = lookAhead->GetValue()->signedInteger ;
									ProvPositiveRangeType rangeType ( lowerRange , upperRange ) ;
									rangedValues.AddTail ( rangeType ) ;
								}
								else
								{
									status = 0 ;
								}
							}
							break ;

							default:
							{
								status = FALSE ;
							}
							break ;
						}
					}
					break ;

					case ProvLexicon :: EOF_ID:
					case ProvLexicon :: COMMA_ID:
					{
						ProvPositiveRangeType rangeType ( lowerRange , lowerRange ) ;
						rangedValues.AddTail ( rangeType ) ;

						PushBack () ;
					} 
					break ;

					default:
					{
						status = FALSE ;
					}
					break ;
				}
			}
			else
			{
				status = FALSE ;
			}
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

BOOL ProvPositiveRangedType :: RecursiveDef ()
{
	BOOL status = TRUE ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: COMMA_ID:
		{
			PushBack () ;
			Match ( ProvLexicon :: COMMA_ID ) &&
			RangeDef () &&
			RecursiveDef () ;
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

BOOL ProvInstanceType :: IsValid () const
{
	return status ;
}

BOOL ProvInstanceType :: IsNull () const
{
	return m_IsNull ;
}

ProvInstanceType :: operator void *() 
{ 
	return status ? this : NULL ; 
} 

ProvNullType :: ProvNullType ( const ProvNull &nullArg )
{
}

ProvNullType :: ProvNullType ( const ProvNullType &nullArg )
{
}

ProvNullType :: ProvNullType ()
{
}

ProvNullType :: ~ProvNullType ()
{
}

BOOL ProvNullType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = TRUE;
	}

	return bResult;
}


ProvInstanceType *ProvNullType :: Copy () const 
{
	return new ProvNullType ( *this ) ;
}

wchar_t *ProvNullType :: GetStringValue () const 
{
	wchar_t *returnValue = new wchar_t [ 1 ] ;
	returnValue [ 0 ] = 0L ;
	return returnValue ;
}

ProvIntegerType :: ProvIntegerType ( 

	const ProvIntegerType &integerArg 

) : ProvInstanceType ( integerArg ) , ProvNegativeRangedType ( integerArg ) , integer ( integerArg.integer ) 
{
}

ProvIntegerType :: ProvIntegerType ( 

	const ProvInteger &integerArg ,
	const wchar_t *rangeValues

) : ProvNegativeRangedType ( rangeValues ) , integer ( integerArg ) 
{
	ProvInstanceType :: SetStatus ( ProvNegativeRangedType :: IsValid () ) ;
}

ProvIntegerType :: ProvIntegerType ( 

	const wchar_t *integerArg ,
	const wchar_t *rangeValues

) :	ProvInstanceType ( FALSE ) , ProvNegativeRangedType ( rangeValues ) , integer ( 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( integerArg ) && ProvNegativeRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvNegativeRangedType :: Check ( integer.GetValue () ) ) ;
	}
}

ProvIntegerType :: ProvIntegerType ( 

	const LONG integerArg ,
	const wchar_t *rangeValues 

) :  ProvNegativeRangedType ( rangeValues ) , integer ( integerArg ) 
{
	ProvInstanceType :: SetStatus ( ProvNegativeRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvNegativeRangedType :: Check ( integer.GetValue () ) ) ;
	}
}

ProvIntegerType :: ProvIntegerType ( const wchar_t *rangeValues ) : ProvNegativeRangedType ( rangeValues ) , 
																	ProvInstanceType ( TRUE , TRUE ) , 
																	integer ( 0 ) 
{
	ProvInstanceType :: SetStatus ( ProvNegativeRangedType :: IsValid () ) ;
}

ProvIntegerType :: ~ProvIntegerType () 
{
}

BOOL ProvIntegerType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = integer.GetValue() == ((const ProvIntegerType&)value).integer.GetValue();
	}

	return bResult;
}


ProvInstanceType *ProvIntegerType :: Copy () const 
{
	return new ProvIntegerType ( *this ) ;
}

BOOL ProvIntegerType :: Parse ( const wchar_t *integerArg ) 
{
	BOOL status = TRUE ;

	ProvAnalyser analyser ;

	analyser.Set ( integerArg ) ;

	ProvLexicon *lookAhead = analyser.Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: SIGNED_INTEGER_ID:
		{
			integer.SetValue ( lookAhead->GetValue ()->signedInteger ) ;
		}
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	delete lookAhead ;

	return status ;
}

wchar_t *ProvIntegerType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		wchar_t stringValue [ 40 ] ;
		_ltow ( integer.GetValue () , stringValue , 10 );

		DWORD t_TextLength = wcslen ( stringValue ) + 1 ;
		returnValue = new wchar_t [ t_TextLength ] ;
		StringCchCopyW ( returnValue , t_TextLength , stringValue ) ;
	}
	else 
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		StringCchCopyW ( returnValue , returnValueLength , L"" ) ;
	}

	return returnValue ;
}

LONG ProvIntegerType :: GetValue () const
{
	return integer.GetValue () ;
}

ProvGaugeType :: ProvGaugeType ( 

	const ProvGauge &gaugeArg ,
	const wchar_t *rangeValues
	
) : ProvPositiveRangedType ( rangeValues ) , gauge ( gaugeArg ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
	}
}

ProvGaugeType :: ProvGaugeType ( 

	const ProvGaugeType &gaugeArg 

) :  ProvInstanceType ( gaugeArg ) , ProvPositiveRangedType ( gaugeArg ) , gauge ( gaugeArg.gauge ) 
{
}

ProvGaugeType :: ProvGaugeType ( 

	const wchar_t *gaugeArg ,
	const wchar_t *rangeValues

) :	ProvInstanceType ( FALSE ) , ProvPositiveRangedType ( rangeValues ) , gauge ( 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( gaugeArg ) && ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
	}
}

ProvGaugeType :: ProvGaugeType ( 

	const ULONG gaugeArg ,
	const wchar_t *rangeValues

) : ProvPositiveRangedType ( rangeValues ) , gauge ( gaugeArg ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
	}
}

ProvGaugeType :: ProvGaugeType ( const wchar_t *rangeValues ) : ProvPositiveRangedType ( rangeValues ) , 
																ProvInstanceType ( TRUE , TRUE ) , 
																gauge ( 0 ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
}

ProvGaugeType :: ~ProvGaugeType () 
{
}

BOOL ProvGaugeType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = gauge.GetValue() == ((const ProvGaugeType&)value).gauge.GetValue();
	}

	return bResult;
}

ProvInstanceType *ProvGaugeType :: Copy () const 
{
	return new ProvGaugeType ( *this ) ;
}

BOOL ProvGaugeType :: Parse ( const wchar_t *gaugeArg ) 
{
	BOOL status = TRUE ;

	ProvAnalyser analyser ;

	analyser.Set ( gaugeArg ) ;

	ProvLexicon *lookAhead = analyser.Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: UNSIGNED_INTEGER_ID:
		{
			gauge.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
		}
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	delete lookAhead ;

	return status ;
}

wchar_t *ProvGaugeType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull ()  )
	{
		wchar_t stringValue [ 40 ] ;
		_ultow ( gauge.GetValue () , stringValue , 10 );
		DWORD t_TextLength = wcslen ( stringValue ) + 1 ;
		returnValue = new wchar_t [ t_TextLength ] ;
		StringCchCopyW ( returnValue , t_TextLength , stringValue ) ;
	}
	else 
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		StringCchCopyW ( returnValue , returnValueLength , L"" ) ;
	}

	return returnValue ;
}

ULONG ProvGaugeType :: GetValue () const
{
	return gauge.GetValue () ;
}

ProvTimeTicksType :: ProvTimeTicksType ( 

	const ProvTimeTicks &timeTicksArg 

) : timeTicks ( timeTicksArg ) 
{
}

ProvTimeTicksType :: ProvTimeTicksType ( 

	const ProvTimeTicksType &timeTicksArg 

) : ProvInstanceType ( timeTicksArg ) , timeTicks ( timeTicksArg.timeTicks ) 
{
}

ProvTimeTicksType :: ProvTimeTicksType ( 

	const wchar_t *timeTicksArg

) :	ProvInstanceType ( FALSE ) , timeTicks ( 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( timeTicksArg ) ) ;
}

ProvTimeTicksType :: ProvTimeTicksType ( 

	const ULONG timeTicksArg

) : timeTicks ( timeTicksArg ) 
{
}

ProvTimeTicksType :: ProvTimeTicksType () : ProvInstanceType ( TRUE , TRUE ) , 
											timeTicks ( 0 ) 
{
}

ProvTimeTicksType :: ~ProvTimeTicksType () 
{
}

BOOL ProvTimeTicksType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = timeTicks.GetValue() == ((const ProvTimeTicksType&)value).timeTicks.GetValue();
	}

	return bResult;
}

ProvInstanceType *ProvTimeTicksType :: Copy () const 
{
	return new ProvTimeTicksType ( *this ) ;
}

BOOL ProvTimeTicksType :: Parse ( const wchar_t *timeTicksArg ) 
{
	BOOL status = TRUE ;

	ProvAnalyser analyser ;

	analyser.Set ( timeTicksArg ) ;

	ProvLexicon *lookAhead = analyser.Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: UNSIGNED_INTEGER_ID:
		{
			timeTicks.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
		}
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	delete lookAhead ;

	return status ;
}

wchar_t *ProvTimeTicksType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull ()  )
	{
		wchar_t stringValue [ 40 ] ;
		_ultow ( timeTicks.GetValue () , stringValue , 10 );
		DWORD t_TextLength = wcslen ( stringValue ) + 1 ;
		returnValue = new wchar_t [ t_TextLength ] ;
		StringCchCopyW ( returnValue , t_TextLength , stringValue ) ;
	}
	else 
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		StringCchCopyW ( returnValue , returnValueLength , L"" ) ;
	}

	return returnValue ;
}

ULONG ProvTimeTicksType :: GetValue () const
{
	return timeTicks.GetValue () ;
}

ProvCounterType :: ProvCounterType ( const ProvCounter &counterArg ) : counter ( counterArg ) 
{
}

ProvCounterType :: ProvCounterType ( const ProvCounterType &counterArg ) : ProvInstanceType ( counterArg ) , counter ( counterArg.counter ) 
{
}

ProvInstanceType *ProvCounterType :: Copy () const 
{
	return new ProvCounterType ( *this ) ;
}

ProvCounterType :: ProvCounterType ( const wchar_t *counterArg ) :	ProvInstanceType ( FALSE ) , 
																counter ( 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( counterArg ) ) ;
}

BOOL ProvCounterType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = counter.GetValue() == ((const ProvCounterType&)value).counter.GetValue();
	}

	return bResult;
}

BOOL ProvCounterType :: Parse ( const wchar_t *counterArg ) 
{
	BOOL status = TRUE ;

	ProvAnalyser analyser ;

	analyser.Set ( counterArg ) ;

	ProvLexicon *lookAhead = analyser.Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: UNSIGNED_INTEGER_ID:
		{
			counter.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
		}
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	delete lookAhead ;

	return status ;
}

ProvCounterType :: ProvCounterType ( const ULONG counterArg ) : counter ( counterArg ) 
{
}

ProvCounterType :: ProvCounterType () : ProvInstanceType ( TRUE , TRUE ) , 
										counter ( 0 ) 
{
}

ProvCounterType :: ~ProvCounterType () 
{
}

wchar_t *ProvCounterType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		wchar_t stringValue [ 40 ] ;
		_ultow ( counter.GetValue () , stringValue , 10 );
		DWORD t_TextLength = wcslen ( stringValue ) + 1 ;
		returnValue = new wchar_t [ t_TextLength ] ;
		StringCchCopyW ( returnValue , t_TextLength , stringValue ) ;
	}
	else 
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		StringCchCopyW ( returnValue , returnValueLength , L"" ) ;
	}

	return returnValue ;
}

ULONG ProvCounterType :: GetValue () const
{
	return counter.GetValue () ;
}

ProvCounter64Type :: ProvCounter64Type ( const ProvCounter64Type &counterArg ) : ProvInstanceType ( counterArg ) , high ( counterArg.high ) , low ( counterArg.low )
{
}

ProvInstanceType *ProvCounter64Type :: Copy () const 
{
	return new ProvCounter64Type ( *this ) ;
}

ProvCounter64Type :: ProvCounter64Type ( const wchar_t *counterArg ) :	ProvInstanceType ( FALSE ) , high ( 0 ) , low ( 0 )
{
	ProvInstanceType :: SetStatus ( Parse ( counterArg ) ) ;
}

BOOL ProvCounter64Type :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = (low == ((const ProvCounter64Type&)value).low) &&
					(high == ((const ProvCounter64Type&)value).high);
	}

	return bResult;
}

BOOL ProvCounter64Type :: Parse ( const wchar_t *counterArg ) 
{
	BOOL status = TRUE ;

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define TOKEN_START 5000

	ULONG state = 0 ;

	ULONG position = 0 ;
/* 
 * Integer Definitions
 */

	BOOL negative = FALSE ;
	BOOL positive = FALSE ;

	DWORDLONG positiveMagicMult = ( DWORDLONG ) ( ( ( DWORDLONG ) -1 ) / 10L ) ; 
	DWORDLONG positiveMagicPosDigit = 5 ;
	DWORDLONG positiveDatum = 0 ;	
	DWORDLONG unsignedInteger = 0 ;
/*
 * Token Definitions
 */

	ULONG token_start = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = counterArg [ position ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsLeadingDecimal ( token ) )
				{
					state = DEC_INTEGER_START + 1  ;
					positiveDatum = ( token - 48 ) ;
				}
				else if ( token == L'+' )
				{
					state = DEC_INTEGER_START ;
				}
				else if ( token == L'-' ) 
				{
					state = DEC_INTEGER_START ;
				}
				else if ( token == L'0' )
				{
					state = 1 ;
				}
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) 
				{
					state = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( token == L'x' || token == L'X' )
				{
					state = HEX_INTEGER_START ;				
				}
				else if ( ProvAnalyser :: IsOctal ( token ) )
				{
					state = OCT_INTEGER_START ;
					positiveDatum = ( token - 48 ) ;
				}
				else
				{
					unsignedInteger = 0 ;

					state = ACCEPT_STATE ;
					position -- ;
				}
			}
			break ;

			case HEX_INTEGER_START:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					positiveDatum = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = HEX_INTEGER_START + 1 ;
				}
				else
				{
					state = REJECT_STATE ;
				}
			}
			break ;

			case HEX_INTEGER_START+1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					state = HEX_INTEGER_START + 1 ;

					if ( positiveDatum > positiveMagicMult )
					{
						state = REJECT_STATE ;
					}
					else if ( positiveDatum == positiveMagicMult ) 
					{
						if ( ProvAnalyser :: HexWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
						{
							state = REJECT_STATE ;
						}
					}

					positiveDatum = ( positiveDatum << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
				}
				else
				{
					unsignedInteger = positiveDatum ;
					state = ACCEPT_STATE ;

					position -- ;
				}
			}
			break ;

			case OCT_INTEGER_START:
			{
				if ( ProvAnalyser :: IsOctal ( token ) )
				{
					state = OCT_INTEGER_START ;

					if ( positiveDatum > positiveMagicMult )
					{
						state = REJECT_STATE ;
					}
					else if ( positiveDatum == positiveMagicMult ) 
					{
						if ( ProvAnalyser :: OctWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
						{
							state = REJECT_STATE ;
						}
					}

					positiveDatum = ( positiveDatum << 3 ) + ProvAnalyser :: OctWCharToDecInteger ( token ) ;
				}
				else
				{
					unsignedInteger = positiveDatum ;
					state = ACCEPT_STATE ;

					position -- ;
				}
			}
			break ;

			case DEC_INTEGER_START:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{
					positiveDatum = ( token - 48 ) ;
					state = DEC_INTEGER_START + 1 ;
				}
				else 
				if ( ProvAnalyser :: IsWhitespace ( token ) ) 
				{
					state = DEC_INTEGER_START ;
				}
				else state = REJECT_STATE ;
			}	
			break ;

			case DEC_INTEGER_START+1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{	
					state = DEC_INTEGER_START + 1 ;

					if ( positiveDatum > positiveMagicMult )
					{
						state = REJECT_STATE ;
					}
					else if ( positiveDatum == positiveMagicMult ) 
					{
						if ( ( ULONG ) ( token - 48 ) > positiveMagicPosDigit ) 
						{
							state = REJECT_STATE ;
						}
					}

					positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
				}
				else
				{
					unsignedInteger = positiveDatum ;

					state = ACCEPT_STATE ;

					position -- ;
				}
			}	
			break ;

			case ACCEPT_STATE:
			case REJECT_STATE:
			default:
			{
				state = REJECT_STATE ;
			} ;
			break ;
		}

		position ++ ;
	}

	status = ( state != REJECT_STATE ) ;
	if ( status )
	{
		high = ( ULONG ) ( unsignedInteger & 0xFFFFFFFF ) ;
		low =( ULONG ) ( unsignedInteger >> 32 ) ;
	}

	return status ;
}

ProvCounter64Type :: ProvCounter64Type ( const ULONG counterHighArg , const ULONG counterLowArg ) : high ( counterHighArg ) , low ( counterLowArg ) 
{
}

ProvCounter64Type :: ProvCounter64Type ( const ProvCounter64 &counterArg ) : high ( counterArg.GetHighValue () ) , low ( counterArg.GetLowValue () ) 
{
}

ProvCounter64Type :: ProvCounter64Type () : ProvInstanceType ( TRUE , TRUE ) , high ( 0 ) , low ( 0 )
{
}

ProvCounter64Type :: ~ProvCounter64Type () 
{
}

wchar_t *ProvCounter64Type :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		wchar_t stringValue [ 40 ] ;
		DWORDLONG t_Integer = ( high >> 32 ) + low ;
		_ui64tow ( t_Integer , stringValue , 40 );
		DWORD t_TextLength = wcslen ( stringValue ) + 1 ;
		returnValue = new wchar_t [ t_TextLength ] ;
		StringCchCopyW ( returnValue , t_TextLength , stringValue ) ;
	}
	else 
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		StringCchCopyW ( returnValue , returnValueLength , L"" ) ;
	}

	return returnValue ;
}

void ProvCounter64Type :: GetValue ( ULONG &counterHighArg , ULONG &counterLowArg ) const
{
	counterHighArg = high ;
	counterLowArg = low ;
}

ProvIpAddressType :: ProvIpAddressType ( const ProvIpAddress &ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

ProvIpAddressType :: ProvIpAddressType ( const ProvIpAddressType &ipAddressArg ) : ProvInstanceType ( ipAddressArg ) , ipAddress ( ipAddressArg.ipAddress ) 
{
}

ProvInstanceType *ProvIpAddressType :: Copy () const 
{
	return new ProvIpAddressType ( *this ) ;
}

ProvIpAddressType :: ProvIpAddressType ( const wchar_t *ipAddressArg ) : ProvInstanceType ( FALSE ) , 
																			ipAddress ( ( ULONG ) 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( ipAddressArg ) ) ;
}

BOOL ProvIpAddressType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = ipAddress.GetValue() == ((const ProvIpAddressType&)value).ipAddress.GetValue();
	}

	return bResult;
}


BOOL ProvIpAddressType :: Parse ( const wchar_t *ipAddressArg ) 
{
	BOOL status = TRUE ;
/*
 *	Datum fields.
 */

	ULONG datumA = 0 ;
	ULONG datumB = 0 ;
	ULONG datumC = 0 ;
	ULONG datumD = 0 ;

/*
 *	Parse input for dotted decimal IP Address.
 */

	ULONG position = 0 ;
	ULONG state = 0 ;
	while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
	{
/*
 *	Get token from input stream.
 */
		wchar_t token = ipAddressArg [ position ++ ] ;

		switch ( state ) 
		{
/*
 *	Parse first field 'A'.
 */

			case 0:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = ( token - 48 ) ;
					state = 1 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 2 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 3 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

/*
 *	Parse first field 'B'.
 */
            case 4:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                { 
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *	Parse first field 'C'.
 */
           	case 8:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *	Parse first field 'D'.
 */
            case 12:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
                if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;
            }
            break ;
 
			default:
			{
				state = REJECT_STATE ;
			}
			break ;
		}
	}


/*
 *	Check boundaries for IP fields.
 */

	status = ( state != REJECT_STATE ) ;

	if ( state == ACCEPT_STATE )
	{
		status = status && (  ( datumA < 256 ) ? TRUE : FALSE ) ;
		status = status && (  ( datumB < 256 ) ? TRUE : FALSE ) ;
		status = status && (  ( datumC < 256 ) ? TRUE : FALSE ) ;
		status = status && (  ( datumD < 256 ) ? TRUE : FALSE ) ;
	}

	ULONG data = ( datumA << 24 ) + ( datumB << 16 ) + ( datumC << 8 ) + datumD ;
	ipAddress.SetValue ( data ) ;

	return status ;	

}

ProvIpAddressType :: ProvIpAddressType ( const ULONG ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

ProvIpAddressType :: ProvIpAddressType () : ProvInstanceType ( TRUE , TRUE ) , 
											ipAddress ( ( ULONG ) 0 ) 
{
}

ProvIpAddressType :: ~ProvIpAddressType () 
{
}

wchar_t *ProvIpAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG ipAddressValue = ipAddress.GetValue () ;

		wchar_t stringAValue [ 40 ] ;
		_itow ( ipAddressValue >> 24 , stringAValue , 10 );

		wchar_t stringBValue [ 40 ] ;
		_itow ( ( ipAddressValue & 0x00FF0000 ) >> 16 , stringBValue , 10 );

		wchar_t stringCValue [ 40 ] ;
		_itow ( ( ipAddressValue & 0x0000FF00 ) >> 8 , stringCValue , 10 );

		wchar_t stringDValue [ 40 ] ;
		_itow ( ipAddressValue & 0x000000FF , stringDValue , 10 );

		ULONG totalLength = wcslen ( stringAValue ) +
							wcslen ( stringBValue ) +
							wcslen ( stringCValue ) +
							wcslen ( stringDValue ) ;

		ULONG t_TextLength = totalLength + 4 + 1 ;
		returnValue = new wchar_t [ t_TextLength ] ;
		StringCchCopyW ( returnValue , t_TextLength , stringAValue ) ;
		StringCchCatW ( returnValue , t_TextLength , L"." ) ;
		StringCchCatW ( returnValue , t_TextLength , stringBValue ) ;
		StringCchCatW ( returnValue , t_TextLength , L"." ) ;
		StringCchCatW ( returnValue , t_TextLength , stringCValue ) ;
		StringCchCatW ( returnValue , t_TextLength , L"." ) ;
		StringCchCatW ( returnValue , t_TextLength , stringDValue ) ;
	}
	else
	{
		ULONG returnValueLength = wcslen ( L"0.0.0.0" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		StringCchCopyW ( returnValue , returnValueLength , L"0.0.0.0" ) ;
	}

	return returnValue ;
}

ULONG ProvIpAddressType :: GetValue () const
{
	return ipAddress.GetValue () ;
}

ProvNetworkAddressType :: ProvNetworkAddressType ( const ProvIpAddress &ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

ProvNetworkAddressType :: ProvNetworkAddressType ( const ProvNetworkAddressType &networkAddressArg ) : ProvInstanceType ( networkAddressArg ) , ipAddress ( networkAddressArg.ipAddress ) 
{
}

ProvInstanceType *ProvNetworkAddressType :: Copy () const 
{
	return new ProvNetworkAddressType ( *this ) ;
}

ProvNetworkAddressType :: ProvNetworkAddressType ( const wchar_t *networkAddressArg ) :	ProvInstanceType ( FALSE ) , 
																						ipAddress ( ( ULONG ) 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( networkAddressArg ) ) ;
}

BOOL ProvNetworkAddressType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = ipAddress.GetValue() == ((const ProvNetworkAddressType&)value).ipAddress.GetValue();
	}

	return bResult;
}

BOOL ProvNetworkAddressType :: Parse ( const wchar_t *networkAddressArg ) 
{
	BOOL status = TRUE ;

/*
 *	Datum fields.
 */

	ULONG datumA = 0 ;
	ULONG datumB = 0 ;
	ULONG datumC = 0 ;
	ULONG datumD = 0 ;

/*
 *	Parse input for dotted decimal IP Address.
 */

	ULONG position = 0 ;
	ULONG state = 0 ;
	while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
	{
/*
 *	Get token from input stream.
 */
		wchar_t token = networkAddressArg [ position ++ ] ;

		switch ( state ) 
		{
/*
 *	Parse first field 'A'.
 */

			case 0:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = ( token - 48 ) ;
					state = 1 ;
				}
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) state = 0 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 2 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 3 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

/*
 *	Parse first field 'B'.
 */
            case 4:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                { 
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *	Parse first field 'C'.
 */
           	case 8:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *	Parse first field 'D'.
 */
            case 12:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
				if ( ProvAnalyser :: IsWhitespace ( token ) ) state = 15 ; 
                else if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;
            }
            break ;
 
			default:
			{
				state = REJECT_STATE ;
			}
			break ;
		}
	}


/*
 *	Check boundaries for IP fields.
 */

	status = ( state != REJECT_STATE ) ;

	if ( state == ACCEPT_STATE )
	{
		status = status && ( ( datumA < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumB < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumC < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumD < 256 ) ? TRUE : FALSE ) ;
	}

	ULONG data = ( datumA << 24 ) + ( datumB << 16 ) + ( datumC << 8 ) + datumD ;
	ipAddress.SetValue ( data ) ;

	return status ;	
}


ProvNetworkAddressType :: ProvNetworkAddressType ( const ULONG ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

ProvNetworkAddressType :: ProvNetworkAddressType () : ProvInstanceType ( TRUE , TRUE ) , 
														ipAddress ( ( ULONG ) 0 ) 
{
}

ProvNetworkAddressType :: ~ProvNetworkAddressType () 
{
}

wchar_t *ProvNetworkAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG ipAddressValue = ipAddress.GetValue () ;

		wchar_t stringAValue [ 40 ] ;
		_itow ( ipAddressValue >> 24 , stringAValue , 10 );

		wchar_t stringBValue [ 40 ] ;
		_itow ( ( ipAddressValue & 0x00FF0000 ) >> 16 , stringBValue , 10 );

		wchar_t stringCValue [ 40 ] ;
		_itow ( ( ipAddressValue & 0x0000FF00 ) >> 8 , stringCValue , 10 );

		wchar_t stringDValue [ 40 ] ;
		_itow ( ipAddressValue & 0x000000FF , stringDValue , 10 );

		ULONG totalLength = wcslen ( stringAValue ) +
							wcslen ( stringBValue ) +
							wcslen ( stringCValue ) +
							wcslen ( stringDValue ) ;

		DWORD t_TextLength = totalLength + 4 + 1 ;
		returnValue = new wchar_t [ t_TextLength ] ;
		StringCchCopyW ( returnValue , t_TextLength , stringAValue ) ;
		StringCchCatW ( returnValue , t_TextLength , L"." ) ;
		StringCchCatW ( returnValue , t_TextLength , stringBValue ) ;
		StringCchCatW ( returnValue , t_TextLength , L"." ) ;
		StringCchCatW ( returnValue , t_TextLength , stringCValue ) ;
		StringCchCatW ( returnValue , t_TextLength , L"." ) ;
		StringCchCatW ( returnValue , t_TextLength , stringDValue ) ;
	}
	else
	{
		ULONG returnValueLength = wcslen ( L"0.0.0.0" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		StringCchCopyW ( returnValue , returnValueLength , L"0.0.0.0" ) ;
	}

	return returnValue ;
}

ULONG ProvNetworkAddressType :: GetValue () const
{
	return ipAddress.GetValue () ;
}

ProvObjectIdentifierType :: ProvObjectIdentifierType ( const ProvObjectIdentifier &objectIdentifierArg ) : objectIdentifier ( objectIdentifierArg ) 
{
}

ProvObjectIdentifierType :: ProvObjectIdentifierType ( const ProvObjectIdentifierType &objectIdentifierArg ) : ProvInstanceType ( objectIdentifierArg ) , objectIdentifier ( objectIdentifierArg.objectIdentifier ) 
{
}

ProvInstanceType *ProvObjectIdentifierType :: Copy () const 
{
	return new ProvObjectIdentifierType ( *this ) ;
}

ProvObjectIdentifierType &ProvObjectIdentifierType :: operator=(const ProvObjectIdentifierType &to_copy )
{
	m_IsNull = to_copy.m_IsNull ;
	status = to_copy.status ;
	objectIdentifier = to_copy.objectIdentifier;

	return *this;
}

ProvObjectIdentifierType :: ProvObjectIdentifierType ( const wchar_t *objectIdentifierArg ) :	ProvInstanceType ( FALSE ) , 
																objectIdentifier ( NULL , 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( objectIdentifierArg ) ) ;
}

BOOL ProvObjectIdentifierType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = objectIdentifier == ((const ProvObjectIdentifierType&)value).objectIdentifier;
	}

	return bResult;
}

BOOL ProvObjectIdentifierType :: Parse ( const wchar_t *objectIdentifierArg ) 
{
#define AVERAGE_OID_LENGTH 20

	BOOL status = TRUE ;

	ULONG reallocLength = AVERAGE_OID_LENGTH ;
	ULONG *reallocArray = ( ULONG * ) malloc ( sizeof ( ULONG ) * reallocLength ) ;

	if (reallocArray == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}
	
	ULONG magicMult = ( ( ULONG ) - 1 ) / 10 ; 
	ULONG magicDigit = 5 ;
	ULONG datum = 0 ;	
	ULONG length = 0 ;

	ULONG position = 0 ;
	ULONG state = 0 ;
	while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
	{
/*
 *	Get token from input stream.
 */
		wchar_t token = objectIdentifierArg [ position ++ ] ;

		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{
					state = 1 ;
					datum = ( token - 48 ) ;
				}
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) 
				{
					state = 0 ;
				}
				else if ( token == 0 ) 
				{
					state = ACCEPT_STATE ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{	
					state = 1 ;

					if ( datum > magicMult )
					{
						state = REJECT_STATE ;
					}
					else if ( datum == magicMult ) 
					{
						if ( ( ULONG ) ( token - 48 ) > magicDigit ) 
						{
							state = REJECT_STATE ;
						}
					}

					datum = datum * 10 + ( token - 48 ) ;
				}
				else
				if ( token == L'.' ) 
				{
					reallocArray [ length ] = datum ;
					length ++ ;
					if ( length >= reallocLength )
					{
						reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
						realloc_throw ( &reallocArray , reallocLength ) ;
					}

					state = 2 ;
				}
				else if ( token == 0 ) 
				{
					reallocArray [ length ] = datum ;

					length ++ ;
					state = ACCEPT_STATE ;
				}
				else state = REJECT_STATE ;
			}	
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{
					state = 1 ;
					datum = ( token - 48 ) ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	objectIdentifier.SetValue ( reallocArray , length ) ;

	free ( reallocArray ) ;

	if ( length < 2 ) 
	{
		status = FALSE ;
	}

	return status ;
}

ProvObjectIdentifierType :: ProvObjectIdentifierType ( const ULONG *value , const ULONG valueLength ) : objectIdentifier ( value , valueLength ) 
{
}

ProvObjectIdentifierType :: ProvObjectIdentifierType () : ProvInstanceType ( TRUE , TRUE ) , 
										objectIdentifier ( NULL , 0 ) 
{
}

ProvObjectIdentifierType :: ~ProvObjectIdentifierType () 
{
}

wchar_t *ProvObjectIdentifierType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG totalLength = 0 ;
		ULONG reallocLength = AVERAGE_OID_LENGTH ;
		wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

		if (reallocArray == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		ULONG objectIdentifierLength = objectIdentifier.GetValueLength () ;		
		ULONG index = 0 ;
		while ( index < objectIdentifierLength ) 
		{
			wchar_t stringValue [ 40 ] ;
			_ultow ( objectIdentifier [ index ] , stringValue , 10 );
			ULONG stringLength = wcslen ( stringValue ) ;

			if ( ( totalLength + stringLength + 1 ) >= reallocLength )
			{
				ULONG t_Max = max( stringLength + 1 , AVERAGE_OID_LENGTH ) ;
				reallocLength = reallocLength + t_Max ;
				realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
			}

			StringCchCopyW ( & reallocArray [ totalLength ] , stringLength + 1 , stringValue ) ;
			totalLength = totalLength + stringLength ;

			index ++ ;
			if ( index < objectIdentifierLength )
			{
				if ( ( totalLength + 1 + 1 ) >= reallocLength )
				{
					reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
					realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
				}

				StringCchCopyW ( & reallocArray [ totalLength ] , 1 + 1 , L"." ) ;
				totalLength ++ ;
			}
		}

		returnValue = new wchar_t [ totalLength + 1 ] ;
		if ( objectIdentifierLength )
		{
			StringCchCopyW ( returnValue , totalLength + 1 , reallocArray ) ;
		}
		else
		{
			returnValue [ 0 ] = 0 ;
		}

		free ( reallocArray ) ;
	}
	else
	{
		ULONG returnValueLength = wcslen ( L"0.0" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		StringCchCopyW ( returnValue , returnValueLength , L"0.0" ) ;
	}

	return returnValue ;
}

ULONG *ProvObjectIdentifierType :: GetValue () const
{
	return objectIdentifier.GetValue () ;
}

ULONG ProvObjectIdentifierType :: GetValueLength () const
{
	return objectIdentifier.GetValueLength () ;
}

#define AVERAGE_OCTET_LENGTH 256 

ProvOpaqueType :: ProvOpaqueType ( 

	const ProvOpaque &opaqueArg ,
	const wchar_t *rangeValues

) : ProvPositiveRangedType ( rangeValues ) , opaque ( opaqueArg ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
	}
}

ProvOpaqueType :: ProvOpaqueType ( 

	const ProvOpaqueType &opaqueArg 

) : ProvInstanceType ( opaqueArg ) , ProvPositiveRangedType ( opaqueArg ) , opaque ( opaqueArg.opaque ) 
{
}

ProvOpaqueType :: ProvOpaqueType ( 

	const wchar_t *opaqueArg ,
	const wchar_t *rangeValues

) :	ProvInstanceType ( FALSE ) , ProvPositiveRangedType ( rangeValues ) , opaque ( NULL , 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( opaqueArg ) && ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
	}
}

ProvOpaqueType :: ProvOpaqueType ( 

	const UCHAR *value , 
	const ULONG valueLength ,
	const wchar_t *rangeValues

) : ProvPositiveRangedType ( rangeValues ) , opaque ( value , valueLength ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
	}
}

ProvOpaqueType :: ProvOpaqueType ( const wchar_t *rangeValues ) :	ProvInstanceType ( TRUE , TRUE ) , 
																	ProvPositiveRangedType ( rangeValues ) ,
																	opaque ( NULL , 0 ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
}

ProvOpaqueType :: ~ProvOpaqueType () 
{
}

BOOL ProvOpaqueType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = opaque.Equivalent( ((const ProvOpaqueType&)value).opaque );
	}

	return bResult;
}

ProvInstanceType *ProvOpaqueType :: Copy () const 
{
	return new ProvOpaqueType ( *this ) ;
}

BOOL ProvOpaqueType :: Parse ( const wchar_t *opaqueArg ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
	UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

	if (reallocArray == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

/* 
 * Oqaque Definitions
 */

	BOOL even = FALSE ;
	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = opaqueArg [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;

				even = FALSE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;

				even = FALSE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					if ( reallocLength <= length ) 
					{
						reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
						realloc_throw ( &reallocArray , reallocLength * sizeof ( UCHAR ) ) ;
					}

					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					reallocArray [ length ] = ( UCHAR ) byte ;
					state = 1 ;
					length ++ ;
					byte = 0 ;
					even = TRUE ;
				}
				else if ( token == 0 )
				{
					state = REJECT_STATE ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( length )
	{
		opaque.SetValue ( reallocArray , length ) ;
	}
	else
	{
		opaque.SetValue ( NULL , 0 ) ;
	}

	free ( reallocArray ) ;

	return status ;
}

wchar_t *ProvOpaqueType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		ULONG totalLength = 0 ;
		ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
		wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

		if (reallocArray == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		ULONG opaqueLength = opaque.GetValueLength () ;		
		UCHAR *opaqueArray = opaque.GetValue () ;

		ULONG index = 0 ;
		while ( index < opaqueLength ) 
		{
			wchar_t hexValue [ 40 ] ;
			_ultow ( opaqueArray [ index ] , hexValue , 16 );
			ULONG hexLength = wcslen ( hexValue ) ;

			wchar_t stringValue [ 3 ] ;
			ULONG stringLength = 2 ;

			if ( hexLength == 1 )
			{
				stringValue [ 0 ] = L'0' ;
				stringValue [ 1 ] = hexValue [ 0 ] ;
				stringValue [ 2 ] = 0 ;
			}
			else
			{
				stringValue [ 0 ] = hexValue [ 0 ] ;
				stringValue [ 1 ] = hexValue [ 1 ] ;
				stringValue [ 2 ] = 0 ;
			}

			if ( ( totalLength + stringLength + 1 ) >= reallocLength )
			{
				ULONG t_Max = max( stringLength + 1 , AVERAGE_OID_LENGTH ) ;
				reallocLength = reallocLength + t_Max ;
				realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
			}

			StringCchCopyW ( & reallocArray [ totalLength ] , stringLength + 1 , stringValue ) ;
			totalLength = totalLength + stringLength ;

			index ++ ;
		}

		DWORD t_TextLength = totalLength + 1 ;
		returnValue = new wchar_t [ t_TextLength ] ;
		if ( opaqueLength )
		{
			StringCchCopyW ( returnValue , t_TextLength , reallocArray ) ;
		}
		else
		{
			returnValue [ 0 ] = 0 ;
		}

		free ( reallocArray ) ;
	}
	else
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		StringCchCopyW ( returnValue , returnValueLength , L"" ) ;
	}

	return returnValue ;
}

UCHAR *ProvOpaqueType :: GetValue () const
{
	return opaque.GetValue () ;
}

ULONG ProvOpaqueType :: GetValueLength () const
{
	return opaque.GetValueLength () ;
}

ProvFixedLengthOpaqueType :: ProvFixedLengthOpaqueType ( 

	const ULONG &fixedLengthArg , 
	const ProvOpaque &opaqueArg 

) : ProvOpaqueType ( opaqueArg , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	if ( opaque.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOpaqueType :: ProvFixedLengthOpaqueType ( 

	const ProvFixedLengthOpaqueType &opaqueArg 

) : ProvOpaqueType ( opaqueArg ) ,
	ProvFixedType ( opaqueArg )
{
	if ( opaque.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvInstanceType *ProvFixedLengthOpaqueType :: Copy () const 
{
	return new ProvFixedLengthOpaqueType ( *this ) ;
}

ProvFixedLengthOpaqueType :: ProvFixedLengthOpaqueType ( 

	const ULONG &fixedLengthArg ,
	const wchar_t *opaqueArg 

) : ProvOpaqueType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	ProvInstanceType :: SetStatus ( Parse ( opaqueArg ) ) ;
	if ( opaque.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOpaqueType :: ProvFixedLengthOpaqueType ( 

	const ULONG &fixedLengthArg ,
	const UCHAR *value , 
	const ULONG valueLength 

) : ProvOpaqueType ( value , valueLength , NULL ) ,
	ProvFixedType ( fixedLengthArg ) 
{
	if ( opaque.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOpaqueType :: ProvFixedLengthOpaqueType (

	const ULONG &fixedLengthArg

) : ProvOpaqueType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	ProvInstanceType :: SetNull ( TRUE ) ;
}

ProvFixedLengthOpaqueType :: ~ProvFixedLengthOpaqueType () 
{
}

ProvOctetStringType :: ProvOctetStringType ( 

	const ProvOctetString &octetStringArg ,
	const wchar_t *rangeValues

) : ProvPositiveRangedType ( rangeValues ) , octetString ( octetStringArg ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
	}
}

ProvOctetStringType :: ProvOctetStringType ( 

	const ProvOctetStringType &octetStringArg 

) : ProvInstanceType ( octetStringArg ) , ProvPositiveRangedType ( octetStringArg ) , octetString ( octetStringArg.octetString ) 
{
}

ProvOctetStringType :: ProvOctetStringType ( 

	const wchar_t *octetStringArg ,
	const wchar_t *rangeValues

) :	ProvInstanceType ( FALSE ) , ProvPositiveRangedType ( rangeValues ) , octetString ( NULL , 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( octetStringArg ) && ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
	}
}

ProvOctetStringType :: ProvOctetStringType ( 

	const UCHAR *value , 
	const ULONG valueLength ,
	const wchar_t *rangeValues

) : ProvPositiveRangedType ( rangeValues ) , octetString ( value , valueLength ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
	}
}

ProvOctetStringType :: ProvOctetStringType ( const wchar_t *rangeValues ) : ProvPositiveRangedType ( rangeValues ) ,
																			ProvInstanceType ( TRUE , TRUE ) , 
																			octetString ( NULL , 0 ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
}

ProvOctetStringType :: ~ProvOctetStringType () 
{
}

BOOL ProvOctetStringType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = octetString.Equivalent( ((const ProvOctetStringType&)value).octetString );
	}

	return bResult;
}

ProvInstanceType *ProvOctetStringType :: Copy () const 
{
	return new ProvOctetStringType ( *this ) ;
}

BOOL ProvOctetStringType :: Parse ( const wchar_t *octetStringArg ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
	UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

	if (reallocArray == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

/* 
 * OctetString Definitions
 */

	BOOL even = FALSE ;
	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = octetStringArg [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;

				even = FALSE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;

				even = FALSE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					if ( reallocLength <= length ) 
					{
						reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
						realloc_throw ( &reallocArray , reallocLength * sizeof ( UCHAR ) ) ;
					}

					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					reallocArray [ length ] = ( UCHAR ) byte ;
					state = 1 ;
					length ++ ;
					byte = 0 ;
					even = TRUE ;
				}
				else if ( token == 0 )
				{
					state = REJECT_STATE ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( length )
	{
		octetString.SetValue ( reallocArray , length ) ;
	}
	else
	{
		octetString.SetValue ( NULL , 0 ) ;
	}

	free ( reallocArray ) ;

	return status ;
}

wchar_t *ProvOctetStringType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		ULONG totalLength = 0 ;
		ULONG octetStringLength = octetString.GetValueLength () ;		
		UCHAR *octetStringArray = octetString.GetValue () ;

		returnValue = new wchar_t [ octetStringLength * 2 + 1 ] ;

		ULONG index = 0 ;
		while ( index < octetStringLength ) 
		{
			wchar_t stringValue [ 3 ] ;

			stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
			stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
			stringValue [ 2 ] = 0 ;

			StringCchCopyW ( & returnValue [ totalLength ] , 3 , stringValue ) ;
			totalLength = totalLength + 2 ;

			index ++ ;
		}

		returnValue [ octetStringLength * 2 ] = 0 ;
	}
	else
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		StringCchCopyW ( returnValue , returnValueLength , L"" ) ;
	}

	return returnValue ;
}

UCHAR *ProvOctetStringType :: GetValue () const
{
	return octetString.GetValue () ;
}

ULONG ProvOctetStringType :: GetValueLength () const
{
	return octetString.GetValueLength () ;
}

ProvFixedLengthOctetStringType :: ProvFixedLengthOctetStringType ( 

	const ULONG &fixedLengthArg , 
	const ProvOctetString &octetStringArg 

) : ProvOctetStringType ( octetStringArg , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	if ( octetString.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOctetStringType :: ProvFixedLengthOctetStringType ( 

	const ProvFixedLengthOctetStringType &octetStringArg 

) : ProvOctetStringType ( octetStringArg ) ,
	ProvFixedType ( octetStringArg )
{
	if ( octetString.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvInstanceType *ProvFixedLengthOctetStringType :: Copy () const 
{
	return new ProvFixedLengthOctetStringType ( *this ) ;
}

ProvFixedLengthOctetStringType :: ProvFixedLengthOctetStringType ( 

	const ULONG &fixedLengthArg ,
	const wchar_t *octetStringArg 

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	ProvInstanceType :: SetStatus ( Parse ( octetStringArg ) ) ;
	if ( octetString.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOctetStringType :: ProvFixedLengthOctetStringType ( 

	const ULONG &fixedLengthArg ,
	const UCHAR *value 

) : ProvOctetStringType ( value , fixedLengthArg , NULL ) ,
	ProvFixedType ( fixedLengthArg ) 
{
	if ( octetString.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOctetStringType :: ProvFixedLengthOctetStringType (

	const ULONG &fixedLengthArg

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	ProvInstanceType :: SetNull ( TRUE ) ;
}

ProvFixedLengthOctetStringType :: ~ProvFixedLengthOctetStringType () 
{
}

ProvMacAddressType :: ProvMacAddressType ( const ProvOctetString &macAddressArg ) : ProvFixedLengthOctetStringType ( 6 , macAddressArg ) 
{
}

ProvMacAddressType :: ProvMacAddressType ( const ProvMacAddressType &macAddressArg ) : ProvFixedLengthOctetStringType ( macAddressArg ) 
{
}

ProvInstanceType *ProvMacAddressType :: Copy () const 
{
	return new ProvMacAddressType ( *this ) ;
}

ProvMacAddressType :: ProvMacAddressType ( const wchar_t *macAddressArg ) : ProvFixedLengthOctetStringType ( 6 )  
{
	ProvInstanceType :: SetStatus ( Parse ( macAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

BOOL ProvMacAddressType :: Parse ( const wchar_t *macAddressArg ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	UCHAR macAddress [ 6 ] ;

/* 
 * MacAddress Definitions
 */

	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = macAddressArg [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 1 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( length >= 6 ) state = REJECT_STATE ;
				else if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					macAddress [ length ] = ( UCHAR ) byte ;
					state = 2 ;
					length ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( token == L':' ) state = 0 ;
				else if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( status )
	{
		octetString.SetValue ( macAddress , 6 ) ;
	}

	return status ;
}

ProvMacAddressType :: ProvMacAddressType ( const UCHAR *value ) : ProvFixedLengthOctetStringType ( 6 , value ) 
{
}

ProvMacAddressType :: ProvMacAddressType () : ProvFixedLengthOctetStringType ( 6 ) 
{
}

ProvMacAddressType :: ~ProvMacAddressType () 
{
}

wchar_t *ProvMacAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		UCHAR *value = octetString.GetValue () ;
		ULONG valueLength = octetString.GetValueLength () ;
		if ( valueLength != 6 )
			throw ;

		returnValue = new wchar_t [ 18 ] ;

		returnValue [ 2 ] = L':' ;
		returnValue [ 5 ] = L':' ;
		returnValue [ 8 ] = L':' ;
		returnValue [ 11 ] = L':' ;
		returnValue [ 14 ] = L':' ;
		returnValue [ 17 ] = 0 ;

		returnValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 0 ] >> 4 ) ;
		returnValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 0 ] & 0xf ) ;

		returnValue [ 3 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 1 ] >> 4 ) ;
		returnValue [ 4 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 1 ] & 0xf ) ;

		returnValue [ 6 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 2 ] >> 4 ) ;
		returnValue [ 7 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 2 ] & 0xf ) ;

		returnValue [ 9 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 3 ] >> 4 ) ;
		returnValue [ 10 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 3 ] & 0xf ) ;

		returnValue [ 12 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 4 ] >> 4 ) ;
		returnValue [ 13 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 4 ] & 0xf ) ;

		returnValue [ 15 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 5 ] >> 4 ) ;
		returnValue [ 16 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 5 ] & 0xf ) ;
	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}

ProvPhysAddressType :: ProvPhysAddressType ( 

	const ProvOctetString &physAddressArg , 
	const wchar_t *rangedValues 

) : ProvOctetStringType ( physAddressArg , rangedValues ) 
{
}

ProvPhysAddressType :: ProvPhysAddressType ( 

	const ProvPhysAddressType &physAddressArg 

) : ProvOctetStringType ( physAddressArg ) 
{
}

ProvInstanceType *ProvPhysAddressType :: Copy () const 
{
	return new ProvPhysAddressType ( *this ) ;
}

ProvPhysAddressType :: ProvPhysAddressType ( 

	const wchar_t *physAddressArg ,
	const wchar_t *rangedValues

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues )  
{
	ProvInstanceType :: SetStatus ( Parse ( physAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

BOOL ProvPhysAddressType :: Parse ( const wchar_t *physAddress ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
	UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

	if (reallocArray == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

/* 
 * PhyAddress Definitions
 */

	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = physAddress [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					if ( reallocLength <= length ) 
					{
						reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
						realloc_throw ( &reallocArray , reallocLength * sizeof ( UCHAR ) ) ;
					}

					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					reallocArray [ length ] = ( UCHAR ) byte ;
					state = 3 ;
					length ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L':' )
				{
					state = 1 ;
				}
				else if ( token == 0 )
				{
					state = ACCEPT_STATE ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( length )
	{
		octetString.SetValue ( reallocArray , length ) ;
	}
	else
	{
		octetString.SetValue ( NULL , 0 ) ;
	}

	free ( reallocArray ) ;

	return status ;
}

ProvPhysAddressType :: ProvPhysAddressType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) : ProvOctetStringType ( value , valueLength , rangedValues ) 
{
}

ProvPhysAddressType :: ProvPhysAddressType (

	const wchar_t *rangedValues 

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues ) 
{
	ProvInstanceType :: SetNull ( TRUE ) ;
}

ProvPhysAddressType :: ~ProvPhysAddressType () 
{
}

wchar_t *ProvPhysAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		ULONG totalLength = 0 ;
		ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
		wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

		if (reallocArray == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		ULONG physAddressLength = octetString.GetValueLength () ;		
		UCHAR *physAddressArray = octetString.GetValue () ;

		ULONG index = 0 ;
		while ( index < physAddressLength ) 
		{
			wchar_t stringValue [ 3 ] ;

			stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] >> 4 ) ;
			stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] & 0xf ) ;
			stringValue [ 2 ] = 0 ;

			if ( ( totalLength + 2 + 1 ) >= reallocLength )
			{
				reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
				realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
			}

			StringCchCopyW ( & reallocArray [ totalLength ] , 2 + 1 , stringValue ) ;
			totalLength = totalLength + 2 ;

			index ++ ;
			if ( index < physAddressLength )
			{
				if ( ( totalLength + 1 + 1 ) >= reallocLength )
				{
					reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
					realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
				}

				StringCchCopyW ( & reallocArray [ totalLength ] , 1 + 1 , L":" ) ;
				totalLength ++ ;
			}
		}

		returnValue = new wchar_t [ totalLength + 1 ] ;
		if ( physAddressLength )
		{
			StringCchCopyW ( returnValue , totalLength + 1 , reallocArray ) ;
		}
		else
		{
			returnValue [ 0 ] = 0 ;
		}

		free ( reallocArray ) ;
	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}

ProvFixedLengthPhysAddressType :: ProvFixedLengthPhysAddressType ( 

	const ULONG &fixedLengthArg ,
	const ProvOctetString &physAddressArg 

) : ProvFixedLengthOctetStringType ( fixedLengthArg , physAddressArg ) 
{
}

ProvFixedLengthPhysAddressType :: ProvFixedLengthPhysAddressType ( 

	const ProvFixedLengthPhysAddressType &physAddressArg 

) : ProvFixedLengthOctetStringType ( physAddressArg ) 
{
}

ProvInstanceType *ProvFixedLengthPhysAddressType :: Copy () const 
{
	return new ProvFixedLengthPhysAddressType ( *this ) ;
}

ProvFixedLengthPhysAddressType :: ProvFixedLengthPhysAddressType ( 

	const ULONG &fixedLengthArg ,
	const wchar_t *physAddressArg 

) : ProvFixedLengthOctetStringType ( fixedLengthArg )
{
	ProvInstanceType :: SetStatus ( Parse ( physAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvFixedLengthPhysAddressType :: ProvFixedLengthPhysAddressType (

	const ULONG &fixedLengthArg

) : ProvFixedLengthOctetStringType ( fixedLengthArg )
{
	ProvInstanceType :: SetNull ( TRUE ) ;
}

ProvFixedLengthPhysAddressType :: ~ProvFixedLengthPhysAddressType () 
{
}

BOOL ProvFixedLengthPhysAddressType :: Parse ( const wchar_t *physAddress ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
	UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

	if (reallocArray == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	
/* 
 * PhyAddress Definitions
 */

	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = physAddress [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					if ( reallocLength <= length ) 
					{
						reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
						realloc_throw ( &reallocArray , reallocLength * sizeof ( UCHAR ) ) ;
					}

					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					reallocArray [ length ] = ( UCHAR ) byte ;
					state = 3 ;
					length ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L':' )
				{
					state = 1 ;
				}
				else if ( token == 0 )
				{
					state = ACCEPT_STATE ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( length == fixedLength )
	{
		octetString.SetValue ( reallocArray , length ) ;
	}
	else
	{
		status = FALSE ;
		octetString.SetValue ( NULL , 0 ) ;
	}

	free ( reallocArray ) ;

	return status ;
}

wchar_t *ProvFixedLengthPhysAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG totalLength = 0 ;
		ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
		wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;
		
		if (reallocArray == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		
		ULONG physAddressLength = octetString.GetValueLength () ;		
		UCHAR *physAddressArray = octetString.GetValue () ;

		ULONG index = 0 ;
		while ( index < physAddressLength ) 
		{
			wchar_t stringValue [ 3 ] ;

			stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] >> 4 ) ;
			stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] & 0xf ) ;
			stringValue [ 2 ] = 0 ;

			if ( ( totalLength + 2 + 1 ) >= reallocLength )
			{
				reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
				realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
			}

			StringCchCopyW ( & reallocArray [ totalLength ] , 2 + 1 , stringValue ) ;
			totalLength = totalLength + 2 ;

			index ++ ;
			if ( index < physAddressLength )
			{
				if ( ( totalLength + 1 + 1 ) >= reallocLength )
				{
					reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
					realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

				}

				StringCchCopyW ( & reallocArray [ totalLength ] , 1 + 1 , L":" ) ;
				totalLength ++ ;
			}
		}

		returnValue = new wchar_t [ totalLength + 1 ] ;
		if ( physAddressLength )
		{
			StringCchCopyW ( returnValue , totalLength + 1 , reallocArray ) ;
		}
		else
		{
			returnValue [ 0 ] = 0 ;
		}

		free(reallocArray);

	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}

ProvDisplayStringType :: ProvDisplayStringType ( 

	const ProvOctetString &displayStringArg ,
	const wchar_t *rangeValues

) : ProvOctetStringType ( displayStringArg , rangeValues ) 
{
}

ProvDisplayStringType :: ProvDisplayStringType ( 

	const ProvDisplayStringType &displayStringArg 

) : ProvOctetStringType ( displayStringArg ) 
{
}

ProvInstanceType *ProvDisplayStringType :: Copy () const 
{
	return new ProvDisplayStringType ( *this ) ;
}

ProvDisplayStringType :: ProvDisplayStringType ( 

	const wchar_t *displayStringArg ,
	const wchar_t *rangeValues

) : ProvOctetStringType ( NULL , 0 , rangeValues )
{
	char *textBuffer = UnicodeToDbcsString ( displayStringArg ) ;
	if ( textBuffer )
	{
		ULONG textLength = strlen ( textBuffer ) ;

		octetString.SetValue ( ( UCHAR * ) textBuffer , textLength ) ;

		delete [] textBuffer ;

		ProvInstanceType :: SetStatus ( TRUE ) ;
		ProvInstanceType :: SetNull ( FALSE ) ;
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvDisplayStringType :: ProvDisplayStringType (

	const wchar_t *rangedValues 

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues )
{
	ProvInstanceType :: SetNull ( TRUE ) ;
}

ProvDisplayStringType :: ~ProvDisplayStringType () 
{
}

wchar_t *ProvDisplayStringType :: GetValue () const 
{
	if ( ProvInstanceType :: IsValid () )
	{
		if ( ! ProvInstanceType :: IsNull () )
		{
			char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
			memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
			textBuffer [ octetString.GetValueLength () ] = 0 ;

			wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

			delete [] textBuffer ;

			return unicodeString ;
		}
		else
		{
			return ProvOctetStringType :: GetStringValue () ;
		}
	}
	else
	{
		return ProvOctetStringType :: GetStringValue () ;
	}
}

wchar_t *ProvDisplayStringType :: GetStringValue () const 
{
	if ( ProvInstanceType :: IsValid () )
	{
		if ( ! ProvInstanceType :: IsNull () )
		{
			char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
			memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
			textBuffer [ octetString.GetValueLength () ] = 0 ;

			wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

			delete [] textBuffer ;

			return unicodeString ;
		}
		else
		{
			return ProvOctetStringType :: GetStringValue () ;
		}
	}
	else
	{
		return ProvOctetStringType :: GetStringValue () ;
	}

}

ProvFixedLengthDisplayStringType :: ProvFixedLengthDisplayStringType ( 

	const ULONG &fixedLengthArg ,
	const ProvOctetString &displayStringArg 

) : ProvFixedLengthOctetStringType ( fixedLengthArg , displayStringArg ) 
{
}

ProvFixedLengthDisplayStringType :: ProvFixedLengthDisplayStringType ( 

	const ProvFixedLengthDisplayStringType &displayStringArg 

) : ProvFixedLengthOctetStringType ( displayStringArg ) 
{
}

ProvInstanceType *ProvFixedLengthDisplayStringType :: Copy () const 
{
	return new ProvFixedLengthDisplayStringType ( *this ) ;
}

ProvFixedLengthDisplayStringType :: ProvFixedLengthDisplayStringType ( 

	const ULONG &fixedLengthArg ,
	const wchar_t *displayStringArg 

) : ProvFixedLengthOctetStringType ( fixedLengthArg )
{
	char *textBuffer = UnicodeToDbcsString ( displayStringArg ) ;
	if ( textBuffer )
	{
		ULONG textLength = strlen ( textBuffer ) ;

		octetString.SetValue ( ( UCHAR * ) textBuffer , textLength + 1 ) ;

		delete [] textBuffer ;
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthDisplayStringType :: ProvFixedLengthDisplayStringType (

	const ULONG &fixedLengthArg

) : ProvFixedLengthOctetStringType ( fixedLengthArg )
{
}

ProvFixedLengthDisplayStringType :: ~ProvFixedLengthDisplayStringType () 
{
}

wchar_t *ProvFixedLengthDisplayStringType :: GetValue () const 
{
	if ( ProvInstanceType :: IsValid () )
	{
		char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
		memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
		textBuffer [ octetString.GetValueLength () ] = 0 ;

		wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

		delete [] textBuffer ;

		return unicodeString ;
	}
	else
	{
		return ProvOctetStringType :: GetStringValue () ;
	}
}

wchar_t *ProvFixedLengthDisplayStringType :: GetStringValue () const 
{
	if ( ProvInstanceType :: IsValid () )
	{
		char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
		memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
		textBuffer [ octetString.GetValueLength () ] = 0 ;

		wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

		delete [] textBuffer ;

		return unicodeString ;
	}
	else
	{
		return ProvOctetStringType :: GetStringValue () ;
	}
}

ProvEnumeratedType :: ProvEnumeratedType ( 

	const wchar_t *enumeratedValues , 
	const LONG &enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;

	wchar_t *enumeratedStringValue ;
	if ( integerMap.Lookup ( ( LONG ) enumeratedValue , enumeratedStringValue ) )
	{
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}

	integer.SetValue ( enumeratedValue ) ;

	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvEnumeratedType :: ProvEnumeratedType ( 

	const wchar_t *enumeratedValues , 
	const ProvInteger &enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;

	wchar_t *enumeratedStringValue ;
	if ( integerMap.Lookup ( ( LONG ) enumeratedValue.GetValue () , enumeratedStringValue ) )
	{
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}

	integer.SetValue ( enumeratedValue.GetValue () ) ;

	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvEnumeratedType :: ProvEnumeratedType ( 

	const wchar_t *enumeratedValues , 
	const wchar_t *enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;
	LONG enumeratedIntegerValue ;
	if ( stringMap.Lookup ( ( wchar_t * ) enumeratedValue , enumeratedIntegerValue ) )
	{
		integer.SetValue ( enumeratedIntegerValue ) ;
	}
	else
	{
		ProvAnalyser analyser ;
		analyser.Set ( enumeratedValue ) ;
		ProvLexicon *lookAhead = analyser.Get () ;
		switch ( lookAhead->GetToken () ) 
		{
			case ProvLexicon :: UNSIGNED_INTEGER_ID:
			{
				LONG enumerationInteger = lookAhead->GetValue()->signedInteger ;
				integer.SetValue ( enumerationInteger ) ;
			}	
			break ;

			default:
			{
				ProvInstanceType :: SetStatus ( FALSE ) ;
			}
			break ;
		}

		delete lookAhead ;
	}

	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvEnumeratedType :: ProvEnumeratedType ( 

	const ProvEnumeratedType &copy

) : ProvIntegerType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	POSITION position = copy.integerMap.GetStartPosition () ;
	while ( position )
	{
		LONG enumeratedIntegerValue ;
		wchar_t *enumeratedStringValue ;
		copy.integerMap.GetNextAssoc ( position , enumeratedIntegerValue , enumeratedStringValue ) ;

		DWORD t_TextLength = wcslen ( enumeratedStringValue ) + 1 ;
		wchar_t *stringCopy = new wchar_t [ t_TextLength ] ;
		StringCchCopyW ( stringCopy , t_TextLength , enumeratedStringValue ) ;

		integerMap [ enumeratedIntegerValue ] = stringCopy ;
		stringMap [ stringCopy ] = enumeratedIntegerValue ;
	}
}

ProvEnumeratedType :: ProvEnumeratedType (

	const wchar_t *enumeratedValues

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;
}

ProvEnumeratedType :: ~ProvEnumeratedType ()
{
	POSITION position = integerMap.GetStartPosition () ;
	while ( position )
	{
		LONG enumeratedIntegerValue ;
		wchar_t *enumeratedStringValue ;
		integerMap.GetNextAssoc ( position , enumeratedIntegerValue , enumeratedStringValue ) ;

		delete [] enumeratedStringValue ;
	}

	integerMap.RemoveAll () ;
	stringMap.RemoveAll () ;

	delete pushBack ;
}

wchar_t *ProvEnumeratedType :: GetStringValue () const
{
	wchar_t *stringValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		if ( ! ProvInstanceType :: IsNull () )
		{
			wchar_t *enumeratedValue ;
			if ( integerMap.Lookup ( integer.GetValue () , enumeratedValue ) )
			{
				DWORD t_TextLength = wcslen ( enumeratedValue ) + 1 ;
				stringValue = new wchar_t [ t_TextLength ] ;
				StringCchCopyW ( stringValue , t_TextLength , enumeratedValue ) ;
			}
			else
			{
				stringValue = ProvIntegerType :: GetStringValue () ;
			}
		}
		else
		{
			stringValue = ProvIntegerType :: GetStringValue () ;
		}
	}
	else
	{
		stringValue = ProvIntegerType :: GetStringValue () ;
	}

	return stringValue ;
}

wchar_t *ProvEnumeratedType :: GetValue () const
{
	wchar_t *stringValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		if ( ! ProvInstanceType :: IsNull () )
		{
			wchar_t *enumeratedValue ;
			if ( integerMap.Lookup ( integer.GetValue () , enumeratedValue ) )
			{
				DWORD t_TextLength = wcslen ( enumeratedValue ) + 1 ;
				stringValue = new wchar_t [ t_TextLength ] ;
				StringCchCopyW ( stringValue , t_TextLength , enumeratedValue ) ;
			}
			else
			{
				stringValue = ProvIntegerType :: GetStringValue () ;
			}
		}
		else
		{
			stringValue = ProvIntegerType :: GetStringValue () ;
		}
	}
	else
	{
		stringValue = ProvIntegerType :: GetStringValue () ;
	}

	return stringValue ;
}

ProvInstanceType *ProvEnumeratedType :: Copy () const
{
	return new ProvEnumeratedType ( *this ) ;
}

BOOL ProvEnumeratedType :: Parse ( const wchar_t *enumeratedValues )
{
	BOOL status = TRUE ;

	analyser.Set ( enumeratedValues ) ;

	return EnumerationDef () && RecursiveDef () ;
}

BOOL ProvEnumeratedType :: EnumerationDef ()
{
	BOOL status = TRUE ;

	wchar_t *enumerationString = NULL ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: TOKEN_ID:
		{
			wchar_t *tokenString = lookAhead->GetValue()->token ;
			DWORD t_TextLength = wcslen ( tokenString ) + 1 ;
			enumerationString = new wchar_t [ t_TextLength ] ;

			try
			{

				StringCchCopyW ( enumerationString , t_TextLength , tokenString ) ;

				ProvLexicon *lookAhead = Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case ProvLexicon :: OPEN_PAREN_ID:
					{
						ProvLexicon *lookAhead = Get () ;
						switch ( lookAhead->GetToken () ) 
						{
							case ProvLexicon :: UNSIGNED_INTEGER_ID:
							{
								LONG enumerationInteger = lookAhead->GetValue()->signedInteger ;
								integerMap [ enumerationInteger ] = enumerationString ;
								stringMap [ enumerationString ] = enumerationInteger ;
								enumerationString = NULL ;

								Match ( ProvLexicon :: CLOSE_PAREN_ID ) ;
							}
							break ;

							default:
							{
								status = FALSE ;
							}
							break ;
						}
					}
					break ;

					default:
					{
						status = FALSE ;
					}
					break ;
				}
			}
			catch(...)
			{
				if (enumerationString)
				{
					delete [] enumerationString ;
				}

				throw;
			}

			if (enumerationString)
			{
				delete [] enumerationString ;
			}
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

BOOL ProvEnumeratedType :: RecursiveDef ()
{
	BOOL status = TRUE ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: COMMA_ID:
		{
			PushBack () ;
			Match ( ProvLexicon :: COMMA_ID ) &&
			EnumerationDef () &&
			RecursiveDef () ;
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

void ProvEnumeratedType  :: PushBack ()
{
	pushedBack = TRUE ;
}

ProvLexicon *ProvEnumeratedType  :: Get ()
{
	if ( pushedBack )
	{
		pushedBack = FALSE ;
	}
	else
	{
		delete pushBack ;
		pushBack = NULL ;
		pushBack = analyser.Get ( TRUE ) ;
	}

	return pushBack ;
}
	
ProvLexicon *ProvEnumeratedType  :: Match ( ProvLexicon :: LexiconToken tokenType )
{
	ProvLexicon *lexicon = Get () ;
	ProvInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
	return ProvInstanceType :: IsValid () ? lexicon : NULL ;
}

ProvRowStatusType :: ProvRowStatusType ( 

	const LONG &rowStatusValue 

) : ProvEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

ProvRowStatusType :: ProvRowStatusType ( 

	const wchar_t *rowStatusValue 

) : ProvEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

ProvRowStatusType :: ProvRowStatusType ( 

	const ProvInteger &rowStatusValue 

) : ProvEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

ProvRowStatusType :: ProvRowStatusType ( 

	const ProvRowStatusEnum &rowStatusValue 

) : ProvEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , ( LONG ) rowStatusValue ) 
{
}

ProvRowStatusType :: ProvRowStatusType ( const ProvRowStatusType &rowStatusValue ) : ProvEnumeratedType ( rowStatusValue ) 
{
}

ProvRowStatusType :: ProvRowStatusType () : ProvEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" )
{
}

ProvRowStatusType :: ~ProvRowStatusType () 
{
}

wchar_t *ProvRowStatusType :: GetStringValue () const 
{
	return ProvEnumeratedType :: GetStringValue () ;
}

wchar_t *ProvRowStatusType :: GetValue () const 
{
	return ProvEnumeratedType :: GetValue () ;
}

ProvRowStatusType :: ProvRowStatusEnum ProvRowStatusType :: GetRowStatus () const 
{
	return ( ProvRowStatusType :: ProvRowStatusEnum ) integer.GetValue () ;
} ;

ProvInstanceType *ProvRowStatusType :: Copy () const
{
	return new ProvRowStatusType ( *this ) ;
}

ProvBitStringType :: ProvBitStringType ( 

	const wchar_t *bitStringValues , 
	const ProvOctetString &bitStringValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;

	BOOL valueStatus = TRUE ;

	ULONG bitCounter = 0 ;
	UCHAR *value = bitStringValue.GetValue () ;
	ULONG valueLength = bitStringValue.GetValueLength () ;
	ULONG valueIndex = 0 ;

	while ( valueIndex < valueLength ) 
	{
		for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
		{
			ULONG bitValue = ( bit == 0 ) ? 1 : ( 1 << bit ) ;
			bitValue = value [ valueIndex ] & bitValue ;
			if ( bitValue )					
			{
				bitValue = bit + ( valueIndex * 8 ) ;
				wchar_t *bitStringStringValue ;
				if ( integerMap.Lookup ( bitValue , bitStringStringValue ) )
				{
				}
				else
				{
					valueStatus = FALSE ;
				}
			}
		}

		valueIndex ++ ;
	}

	octetString.SetValue ( bitStringValue.GetValue () , bitStringValue.GetValueLength () ) ;

	ProvInstanceType :: SetStatus ( valueStatus ) ;

	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvBitStringType :: ProvBitStringType ( 

	const wchar_t *bitStringValues , 
	const wchar_t **bitStringValueArray , 
	const ULONG &bitStringValueLength 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;

	BOOL valueStatus = TRUE ;

	if ( bitStringValueLength )
	{
		ULONG maximumValue = 0 ;
		for ( ULONG index = 0 ; index < bitStringValueLength ; index ++ )
		{
			ULONG bitStringIntegerValue ;
			const wchar_t *bitStringValue = bitStringValueArray [ index ] ;
			if ( stringMap.Lookup ( ( wchar_t * ) bitStringValue , bitStringIntegerValue ) )
			{
				maximumValue = maximumValue < bitStringIntegerValue ? bitStringIntegerValue : maximumValue ;
			}
			else
			{
				ProvAnalyser analyser ;
				analyser.Set ( bitStringValue ) ;
				ProvLexicon *lookAhead = analyser.Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case ProvLexicon :: UNSIGNED_INTEGER_ID:
					{
						ULONG bitStringIntegerValue = lookAhead->GetValue()->signedInteger ;
						maximumValue = maximumValue < bitStringIntegerValue ? bitStringIntegerValue : maximumValue ;
					}	
					break ;

					default:
					{
						valueStatus = FALSE ;
					}
					break ;
				}

				delete lookAhead ;
			}
		}

		if ( valueStatus )
		{
			ULONG valueLength = ( maximumValue >> 3 ) + 1 ;
			UCHAR *value = new UCHAR [ valueLength ] ;
			memset ( value , 0 , sizeof ( UCHAR ) ) ;
			
			for ( ULONG index = 0 ; ( index < bitStringValueLength ) && valueStatus ; index ++ )
			{
				ULONG bitStringIntegerValue ;
				const wchar_t *bitStringValue = bitStringValueArray [ index ] ;
				if ( stringMap.Lookup ( ( wchar_t * ) bitStringValue , bitStringIntegerValue ) )
				{
					ULONG byte = bitStringIntegerValue >> 3 ;
					UCHAR bit = ( UCHAR ) ( bitStringIntegerValue & 0x7 ) ;
					bit = ( bit == 0 ) ? 1 : ( 1 << bit ) ;
					value [ byte ] = value [ byte ] | bit ;
				}
				else
				{
					ProvAnalyser analyser ;
					analyser.Set ( bitStringValue ) ;
					ProvLexicon *lookAhead = analyser.Get () ;
					switch ( lookAhead->GetToken () ) 
					{
						case ProvLexicon :: UNSIGNED_INTEGER_ID:
						{
							LONG bitStringIntegerValue = lookAhead->GetValue()->signedInteger ;
							ULONG byte = bitStringIntegerValue >> 3 ;
							UCHAR bit = ( UCHAR ) ( bitStringIntegerValue & 0x7 ) ;
							bit = ( bit == 0 ) ? 1 : ( 1 << bit ) ;
							value [ byte ] = value [ byte ] | bit ;

							value [ byte ] = value [ byte ] | bit ;
						}	
						break ;

						default:
						{
						}
						break ;
					}

					delete lookAhead ;

					valueStatus = FALSE ;
				}
			}

			octetString.SetValue ( value , valueLength ) ;
			delete [] value ;
		}
	}
	else
	{
		octetString.SetValue ( NULL , 0 ) ;
	}

	ProvInstanceType :: SetStatus ( valueStatus ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvBitStringType :: ProvBitStringType ( 

	const ProvBitStringType &copy

) : ProvOctetStringType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	POSITION position = copy.integerMap.GetStartPosition () ;
	while ( position )
	{
		ULONG bitStringIntegerValue ;
		wchar_t *bitStringStringValue ;
		copy.integerMap.GetNextAssoc ( position , bitStringIntegerValue , bitStringStringValue ) ;

		DWORD t_TextLength = wcslen ( bitStringStringValue ) + 1 ;
		wchar_t *stringCopy = new wchar_t [ t_TextLength ] ;
		StringCchCopyW ( stringCopy , t_TextLength , bitStringStringValue ) ;

		integerMap [ bitStringIntegerValue ] = stringCopy ;
		stringMap [ stringCopy ] = bitStringIntegerValue ;
	}
}

ProvBitStringType :: ProvBitStringType (

	const wchar_t *bitStringValues

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;
}

ProvBitStringType :: ~ProvBitStringType ()
{
	POSITION position = integerMap.GetStartPosition () ;
	while ( position )
	{
		ULONG bitStringIntegerValue ;
		wchar_t *bitStringStringValue ;
		integerMap.GetNextAssoc ( position , bitStringIntegerValue , bitStringStringValue ) ;

		delete [] bitStringStringValue ;
	}

	integerMap.RemoveAll () ;
	stringMap.RemoveAll () ;

	delete pushBack ;
}

ULONG ProvBitStringType :: GetValue ( wchar_t **&stringValue ) const
{
	ULONG stringValueLength = 0 ;
	stringValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		UCHAR *value = octetString.GetValue () ;
		ULONG valueLength = octetString.GetValueLength () ;
		ULONG valueIndex = 0 ;

		BOOL valueStatus = TRUE ;

		while ( ( valueIndex < valueLength ) && valueStatus )
		{
			for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
			{
				ULONG bitValue = ( bit == 0 ) ? 1 : ( 1 << bit ) ;
				bitValue = value [ valueIndex ] & bitValue ;
				if ( bitValue )					
				{
					stringValueLength ++ ;
				}
			}

			valueIndex ++ ;
		}

		if ( stringValueLength )
		{
			stringValue = new wchar_t * [ stringValueLength ] ;

			ULONG stringValueIndex = 0 ;
			valueIndex = 0 ;
			while ( valueIndex < valueLength ) 
			{
				for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
				{
					ULONG bitValue = ( bit == 0 ) ? 1 : ( 1 << bit ) ;
					bitValue = value [ valueIndex ] & bitValue ;
					if ( bitValue )					
					{
						bitValue = bit + ( valueIndex << 3 ) ;
						wchar_t *bitStringStringValue ;
						if ( integerMap.Lookup ( ( LONG ) bitValue , bitStringStringValue ) )
						{
							stringValue [ stringValueIndex ++ ] = UnicodeStringDuplicate ( bitStringStringValue ) ;
						}
						else
						{
							wchar_t stringValueBuffer [ 40 ] ;
							_ultow ( bitValue , stringValueBuffer , 10 );
							DWORD t_TextLength = wcslen ( stringValueBuffer ) + 1 ;
							wchar_t *returnValue = new wchar_t [ t_TextLength ] ;
							StringCchCopyW ( returnValue , t_TextLength , stringValueBuffer ) ;
							stringValue [ stringValueIndex ++ ] = returnValue ;

							valueStatus = FALSE ;
						}
					}
				}

				valueIndex ++ ;
			}
			
			delete [] value ;
		}
	}

	return stringValueLength ;
}

wchar_t *ProvBitStringType :: GetStringValue () const
{
	return ProvOctetStringType :: GetStringValue () ;
}

ProvInstanceType *ProvBitStringType :: Copy () const
{
	return new ProvBitStringType ( *this ) ;
}

BOOL ProvBitStringType :: Parse ( const wchar_t *bitStringValues )
{
	BOOL status = TRUE ;

	analyser.Set ( bitStringValues ) ;

	return BitStringDef () && RecursiveDef () ;
}

BOOL ProvBitStringType :: BitStringDef ()
{
	BOOL status = TRUE ;

	wchar_t *bitStringString = NULL ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: TOKEN_ID:
		{
			wchar_t *tokenString = lookAhead->GetValue()->token ;
			DWORD t_TextLength = wcslen ( tokenString ) + 1 ;
			bitStringString = new wchar_t [ t_TextLength ] ;

			try
			{
				StringCchCopyW ( bitStringString , t_TextLength , tokenString ) ;

				ProvLexicon *lookAhead = Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case ProvLexicon :: OPEN_PAREN_ID:
					{
						ProvLexicon *lookAhead = Get () ;
						switch ( lookAhead->GetToken () ) 
						{
							case ProvLexicon :: UNSIGNED_INTEGER_ID:
							{
								LONG bitStringInteger = lookAhead->GetValue()->signedInteger ;
								integerMap [ bitStringInteger ] = bitStringString ;
								stringMap [ bitStringString ] = bitStringInteger ;
								bitStringString = NULL;

								Match ( ProvLexicon :: CLOSE_PAREN_ID ) ;
							}
							break ;

							default:
							{
								status = FALSE ;
							}
							break ;
						}
					}
					break ;

					default:
					{
						status = FALSE ;
					}
					break ;
				}
			}
			catch (...)
			{
				if (bitStringString)
				{
					delete [] bitStringString ;
				}

				throw;
			}

			if (bitStringString)
			{
				delete [] bitStringString ;
			}
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

BOOL ProvBitStringType :: RecursiveDef ()
{
	BOOL status = TRUE ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: COMMA_ID:
		{
			PushBack () ;
			Match ( ProvLexicon :: COMMA_ID ) &&
			BitStringDef () &&
			RecursiveDef () ;
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

void ProvBitStringType  :: PushBack ()
{
	pushedBack = TRUE ;
}

ProvLexicon *ProvBitStringType  :: Get ()
{
	if ( pushedBack )
	{
		pushedBack = FALSE ;
	}
	else
	{
		delete pushBack ;
		pushBack = NULL ;
		pushBack = analyser.Get ( TRUE ) ;
	}

	return pushBack ;
}
	
ProvLexicon *ProvBitStringType  :: Match ( ProvLexicon :: LexiconToken tokenType )
{
	ProvLexicon *lexicon = Get () ;
	ProvInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
	return ProvInstanceType :: IsValid () ? lexicon : NULL ;
}

ProvDateTimeType :: ProvDateTimeType ( 

	const ProvOctetString &dateTimeValue 

) : ProvOctetStringType ( dateTimeValue , NULL ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ULONG valueLength = dateTimeValue.GetValueLength () ;
	if ( valueLength != 8 && valueLength != 11 )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvDateTimeType :: ProvDateTimeType ( 

	const wchar_t *dateTimeValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( dateTimeValue ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvDateTimeType :: ProvDateTimeType ( 

	const ProvDateTimeType &copy

) : ProvOctetStringType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
}

ProvDateTimeType :: ProvDateTimeType () : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
}

ProvDateTimeType :: ~ProvDateTimeType ()
{
}

wchar_t *ProvDateTimeType :: GetValue () const
{
	wchar_t *stringValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG valueLength = octetString.GetValueLength () ;
		
		if (valueLength == 8 || valueLength == 11)
		{
			UCHAR *value = octetString.GetValue () ;

			USHORT *yearPtr = ( USHORT * ) & value [ 0 ] ;
			UCHAR *monthPtr = ( UCHAR * ) & value [ 2 ] ;
			UCHAR *dayPtr = ( UCHAR * ) & value [ 3 ] ;
			UCHAR *hourPtr = ( UCHAR * ) & value [ 4 ] ;
			UCHAR *minutesPtr = ( UCHAR * ) & value [ 5 ] ;
			UCHAR *secondsPtr = ( UCHAR * ) & value [ 6 ] ;
			UCHAR *deciSecondsPtr = ( UCHAR * ) & value [ 7 ] ;

			char dateTime [ 80 ] ;
			ostrstream oStrStream(dateTime, 80) ;

			oStrStream << ( ULONG ) ( ntohs ( *yearPtr ) ) ;
			oStrStream << "-" ;
			oStrStream << ( ULONG ) ( *monthPtr ) ;
			oStrStream << "-" ;
			oStrStream << ( ULONG ) ( *dayPtr ) ;
			oStrStream << "," ;
			oStrStream << ( ULONG ) ( *hourPtr ) ;
			oStrStream << ":" ;
			oStrStream << ( ULONG ) ( *minutesPtr ) ;
			oStrStream << ":" ;
			oStrStream << ( ULONG ) ( *secondsPtr ) ;
			oStrStream << "." ;
 			oStrStream << ( ULONG ) ( *deciSecondsPtr ) ;

			if ( valueLength == 11 )
			{
				UCHAR *UTC_directionPtr = ( UCHAR * ) & value [ 8 ] ;
				UCHAR *UTC_hoursPtr = ( UCHAR * ) & value [ 9 ] ;
				UCHAR *UTC_minutesPtr = ( UCHAR * ) & value [ 10 ] ;

				oStrStream << "," ;
		
				if ( *UTC_directionPtr == '+' )
				{
					oStrStream << "+" ;
				}
				else
				{
					oStrStream << "-" ;
				}

				oStrStream << ( ULONG ) ( *UTC_hoursPtr ) ;
				oStrStream << ":" ;
				oStrStream << ( ULONG ) ( *UTC_minutesPtr ) ;
			}

			oStrStream << ends ;

			stringValue = DbcsToUnicodeString ( dateTime ) ;
		}
	}

	if (!stringValue)
	{
		stringValue = ProvOctetStringType :: GetStringValue () ;
	}

	return stringValue ;
}

wchar_t *ProvDateTimeType :: GetStringValue () const
{
	wchar_t *stringValue = GetValue () ;
	return stringValue ;
}

ProvInstanceType *ProvDateTimeType :: Copy () const
{
	return new ProvDateTimeType ( *this ) ;
}

BOOL ProvDateTimeType :: Parse ( const wchar_t *dateTimeValues )
{
	BOOL status = TRUE ;

	analyser.Set ( dateTimeValues ) ;

	return DateTimeDef () ;
}

BOOL ProvDateTimeType :: DateTimeDef ()
{
	BOOL status = TRUE ;

	ULONG year = 0 ;
	ULONG month = 0 ;
	ULONG day = 0 ;
	ULONG hour = 0 ;
	ULONG minutes = 0 ;
	ULONG seconds = 0 ;
	ULONG deciSeconds = 0 ;
	ULONG UTC_present = FALSE ;
	ULONG UTC_direction = 0 ;
	ULONG UTC_hours = 0 ;
	ULONG UTC_minutes = 0 ;

	ProvLexicon *lookAhead = NULL ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	year = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: MINUS_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	month = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: MINUS_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	day = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: COMMA_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	hour = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: COLON_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	minutes = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: COLON_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	seconds = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: DOT_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	deciSeconds = lookAhead->GetValue()->unsignedInteger ;

	lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: COMMA_ID:
		{
			lookAhead = Get () ;
			switch ( lookAhead->GetToken () ) 
			{
				case ProvLexicon :: PLUS_ID:
				{
					UTC_present = TRUE ;
					UTC_direction = '+' ;

					if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

					UTC_hours = lookAhead->GetValue()->unsignedInteger ;

					if ( ! Match ( ProvLexicon :: COLON_ID ) ) return FALSE ;

					if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

					UTC_minutes = lookAhead->GetValue()->unsignedInteger ;

					if ( ( lookAhead = Match ( ProvLexicon :: EOF_ID ) ) == FALSE ) return FALSE ;
				}
				break ;

				case ProvLexicon :: MINUS_ID:
				{
					UTC_present = TRUE ;
					UTC_direction = '-' ;

					if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

					UTC_hours = lookAhead->GetValue()->unsignedInteger ;

					if ( ! Match ( ProvLexicon :: COLON_ID ) ) return FALSE ;

					if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

					UTC_minutes = lookAhead->GetValue()->unsignedInteger ;

					if ( ( lookAhead = Match ( ProvLexicon :: EOF_ID ) ) == FALSE ) return FALSE ;
				}
				break ;

				default:
				{
					status = FALSE ;
				}
				break ;
			}
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
		}
		break ;
	
		default:
		{
			status = FALSE ;
		}
		break ;	
	}

	if ( status ) 
	{
		status = FALSE ;

		if ( year <= 65535 )
		if ( month >= 1 && month <= 12 )
		if ( day >= 1 && day <= 31 )
		if ( hour <= 23 )
		if ( minutes <= 59 )
		if ( seconds <= 60 )
		if ( UTC_present )
		{
			if ( UTC_hours <= 11 )
			if ( UTC_minutes <= 59 )
			{
				status = TRUE ;
			}
		}
		else
		{
			status = TRUE ;
		}

		if ( status )
		{

// Encode here

			Encode ( 

				year ,
				month ,
				day ,
				hour ,
				minutes ,
				seconds ,
				deciSeconds ,
				UTC_present ,
				UTC_direction ,
				UTC_hours ,
				UTC_minutes
			) ;
		}
	}

	return status ;
}

void ProvDateTimeType :: Encode (

	const ULONG &year ,
	const ULONG &month ,
	const ULONG &day ,
	const ULONG &hour ,
	const ULONG &minutes ,
	const ULONG &seconds ,
	const ULONG &deciSeconds ,
	const ULONG &UTC_present ,
	const ULONG &UTC_direction ,
	const ULONG &UTC_hours ,
	const ULONG &UTC_minutes
) 
{
	UCHAR *value = NULL ;
	ULONG valueLength = 0 ;

	if ( UTC_present )
	{
		valueLength = 11 ;
	}
	else
	{	
		valueLength = 8 ;
	}

	value = new UCHAR [ valueLength ] ;

	USHORT *yearPtr = ( USHORT * ) & value [ 0 ] ;
	UCHAR *monthPtr = ( UCHAR * ) & value [ 2 ] ;
	UCHAR *dayPtr = ( UCHAR * ) & value [ 3 ] ;
	UCHAR *hourPtr = ( UCHAR * ) & value [ 4 ] ;
	UCHAR *minutesPtr = ( UCHAR * ) & value [ 5 ] ;
	UCHAR *secondsPtr = ( UCHAR * ) & value [ 6 ] ;
	UCHAR *deciSecondsPtr = ( UCHAR * ) & value [ 7 ] ;

	*yearPtr = htons ( ( USHORT ) year ) ;
	*monthPtr = ( UCHAR ) month ;
	*dayPtr = ( UCHAR ) day ;
	*hourPtr = ( UCHAR ) hour ;
	*minutesPtr = ( UCHAR ) minutes ;
	*secondsPtr = ( UCHAR ) seconds ;
	*deciSecondsPtr = ( UCHAR ) deciSeconds ;

	if ( UTC_present )
	{
		UCHAR *UTC_directionPtr = ( UCHAR * ) & value [ 8 ] ;
		UCHAR *UTC_hoursPtr = ( UCHAR * ) & value [ 9 ] ;
		UCHAR *UTC_minutesPtr = ( UCHAR * ) & value [ 10 ] ;

		*UTC_directionPtr = ( UCHAR ) UTC_direction ;
		*UTC_hoursPtr = ( UCHAR ) UTC_hours ;
		*UTC_minutesPtr = ( UCHAR ) UTC_minutes ;
	}

	octetString.SetValue ( value , valueLength ) ;

	delete [] value ;
}

void ProvDateTimeType  :: PushBack ()
{
	pushedBack = TRUE ;
}

ProvLexicon *ProvDateTimeType  :: Get ()
{
	if ( pushedBack )
	{
		pushedBack = FALSE ;
	}
	else
	{
		delete pushBack ;
		pushBack = NULL ;
		pushBack = analyser.Get ( TRUE , TRUE ) ;
	}

	return pushBack ;
}
	
ProvLexicon *ProvDateTimeType  :: Match ( ProvLexicon :: LexiconToken tokenType )
{
	ProvLexicon *lexicon = Get () ;
	ProvInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
	return ProvInstanceType :: IsValid () ? lexicon : NULL ;
}

ProvOSIAddressType :: ProvOSIAddressType ( 

	const ProvOctetString &osiAddressArg 

) : ProvOctetStringType ( osiAddressArg , NULL ) 
{
	if ( osiAddressArg.GetValueLength () > 1 )
	{
		UCHAR *value = osiAddressArg.GetValue () ;
		ULONG NSAPLength = value [ 0 ] ;

		if ( ! ( NSAPLength < osiAddressArg.GetValueLength () ) )
		{
			ProvInstanceType :: SetStatus ( FALSE ) ;
		}
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvOSIAddressType :: ProvOSIAddressType ( 

	const ProvOSIAddressType &osiAddressArg 

) : ProvOctetStringType ( osiAddressArg ) 
{
}

ProvInstanceType *ProvOSIAddressType :: Copy () const 
{
	return new ProvOSIAddressType ( *this ) ;
}

ProvOSIAddressType :: ProvOSIAddressType ( 

	const wchar_t *osiAddressArg 

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL )  
{
	ProvInstanceType :: SetStatus ( Parse ( osiAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

BOOL ProvOSIAddressType :: Parse ( const wchar_t *osiAddress ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;


/* 
 * OSIAddress Definitions
 */

/*
         -- for a ProvOSIAddress of length m:
          --
          -- octets   contents            encoding
          --    1     length of NSAP      "n" as an unsigned-integer
          --                                (either 0 or from 3 to 20)
          -- 2..(n+1) NSAP                concrete binary representation
          -- (n+2)..m TSEL                string of (up to 64) octets
          --
          ProvOSIAddress ::= TEXTUAL-CONVENTION
              DISPLAY-HINT "*1x:/1x:"
              STATUS       current
              DESCRIPTION
                      "Represents an OSI transport-address."
              SYNTAX       OCTET STRING (SIZE (1 | 4..85))
*/

	UCHAR *OSIValue = new UCHAR [ 1 + 20 + 64 ] ;

	UCHAR NSAPLength = 0 ;
	ULONG TSELLength = 0 ;

	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = osiAddress [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				{
					if ( token == L'/' ) 
						state = 4 ;
					else 
						state = REJECT_STATE ;	
				}
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					OSIValue [ 1 + NSAPLength ] = ( UCHAR ) byte ;
					state = 3 ;
					NSAPLength ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L':' )
				{
					if ( NSAPLength < 20 ) 
					{
						state = 1 ;
					}
					else 
						state = REJECT_STATE ;
				}
				else 
				{
					if ( token == L'/' )
					{
						if ( NSAPLength >= 2 ) 
						{
							OSIValue [ 0 ] = NSAPLength ;
							state = 4 ;
						}
						else state = REJECT_STATE ;
					}
					else state = REJECT_STATE ;
				}
			}
			break ;

			case 4:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 5 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 5:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					OSIValue [ 1 + NSAPLength + TSELLength ] = ( UCHAR ) byte ;
					state = 6 ;
					TSELLength ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 6:
			{
				if ( token == L':' )
				{
					if ( TSELLength < 64 ) 
					{
						state = 4 ;
					}
					else state = REJECT_STATE ;
				}
				else 
				{
					if ( token == 0 )
					{
						state = ACCEPT_STATE ;
					}
					else state = REJECT_STATE ;
				}
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( status )
	{
		octetString.SetValue ( OSIValue , 1 + NSAPLength + TSELLength ) ;
	}
	else
	{
		octetString.SetValue ( NULL , 0 ) ;
	}

	delete [] OSIValue ;

	return status ;
}

ProvOSIAddressType :: ProvOSIAddressType ( 

	const UCHAR *value , 
	const ULONG valueLength 

) : ProvOctetStringType ( value , valueLength , NULL ) 
{
	if ( valueLength > 1 )
	{
		ULONG NSAPLength = value [ 0 ] ;

		if ( ! ( NSAPLength < valueLength ) )
		{
			ProvInstanceType :: SetStatus ( FALSE ) ;
		}
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvOSIAddressType :: ProvOSIAddressType () : ProvOctetStringType ( NULL ) 
{
}

ProvOSIAddressType :: ~ProvOSIAddressType () 
{
}

wchar_t *ProvOSIAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG octetStringLength = octetString.GetValueLength () ;		
		UCHAR *octetStringArray = octetString.GetValue () ;

		if ( octetStringLength < 1 )
			throw ;

		ULONG NSAPLength = octetStringArray [ 0 ] ;

		if ( NSAPLength < octetStringLength )
		{
 			ULONG totalLength = 0 ;
			ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
			wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;
	
			if (reallocArray == NULL)
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}


			ULONG index = 1 ;
			while ( index <= NSAPLength ) 
			{
				wchar_t stringValue [ 4 ] ;

				if ( index != NSAPLength )
				{
					stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
					stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
					stringValue [ 2 ] = L':' ;
					stringValue [ 3 ] = 0 ;

					if ( ( totalLength + 3 + 1 ) >= reallocLength )
					{
						reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
						realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
					}

					StringCchCopyW ( & reallocArray [ totalLength ] , 3 + 1 , stringValue ) ;
					totalLength = totalLength + 3 ;
				}
				else
				{
					stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
					stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
					stringValue [ 2 ] = 0 ;

					if ( ( totalLength + 2 + 1 ) >= reallocLength )
					{
						reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
						realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
					}

					StringCchCopyW ( & reallocArray [ totalLength ] , 2 + 1 , stringValue ) ;
					totalLength = totalLength + 2 ;
				}


				index ++ ;
			}

			wchar_t stringValue [ 2 ] ;

			stringValue [ 0 ] = L'/' ;
			stringValue [ 1 ] = 0 ;

			if ( ( totalLength + 1 + 1 ) >= reallocLength )
			{
				reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
				realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
			}

			StringCchCopyW ( & reallocArray [ totalLength ] , 1 + 1 , stringValue ) ;
			totalLength = totalLength + 1 ;

			while ( index < octetStringLength )
			{
				wchar_t stringValue [ 4 ] ;

				if ( index != ( octetStringLength - 1 ) )
				{
					stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
					stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
					stringValue [ 2 ] = L':' ;
					stringValue [ 3 ] = 0 ;

					if ( ( totalLength + 3 + 1 ) >= reallocLength )
					{
						reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
						realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

					}

					StringCchCopyW ( & reallocArray [ totalLength ] , 3 + 1 , stringValue ) ;
					totalLength = totalLength + 3 ;
				}
				else
				{
					stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
					stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
					stringValue [ 2 ] = 0 ;

					if ( ( totalLength + 2 + 1 ) >= reallocLength )
					{
						reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
						realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

					}

					StringCchCopyW ( & reallocArray [ totalLength ] , 2 + 1 , stringValue ) ;
					totalLength = totalLength + 2 ;
				}


				index ++ ;
			}

			returnValue = new wchar_t [ totalLength + 1 ] ;
			StringCchCopyW ( returnValue , totalLength + 1 , reallocArray ) ;
			free (reallocArray);

		}
		else
			throw ;
	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}

ProvUDPAddressType :: ProvUDPAddressType ( 

	const ProvOctetString &udpAddressArg 

) : ProvFixedLengthOctetStringType ( 6 , udpAddressArg ) 
{
}

ProvUDPAddressType :: ProvUDPAddressType ( 

	const ProvUDPAddressType &udpAddressArg 

) : ProvFixedLengthOctetStringType ( udpAddressArg ) 
{
}

ProvInstanceType *ProvUDPAddressType :: Copy () const 
{
	return new ProvUDPAddressType ( *this ) ;
}

ProvUDPAddressType :: ProvUDPAddressType ( 

	const wchar_t *udpAddressArg 

) : ProvFixedLengthOctetStringType ( 6 )  
{
	ProvInstanceType :: SetStatus ( Parse ( udpAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

BOOL ProvUDPAddressType :: Parse ( const wchar_t *udpAddressArg ) 
{
	BOOL status = TRUE ;
/*
 *	Datum fields.
 */
	UCHAR udpAddress [ 6 ] ;

	ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
	ULONG positiveMagicPosDigit = 5 ;
	ULONG positiveDatum = 0 ;	

	ULONG datumA = 0 ;
	ULONG datumB = 0 ;
	ULONG datumC = 0 ;
	ULONG datumD = 0 ;

/*
 *	Parse input for dotted decimal IP Address.
 */

	ULONG position = 0 ;
	ULONG state = 0 ;
	while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
	{
/*
 *	Get token from input stream.
 */
		wchar_t token = udpAddressArg [ position ++ ] ;

		switch ( state ) 
		{
/*
 *	Parse first field 'A'.
 */

			case 0:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = ( token - 48 ) ;
					state = 1 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 2 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 3 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

/*
 *	Parse first field 'B'.
 */
            case 4:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                { 
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *	Parse first field 'C'.
 */
           	case 8:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *	Parse first field 'D'.
 */
            case 12:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
                if ( token == L'/' ) state = 16 ;
				else state = REJECT_STATE ;
            }
            break ;

			case 16:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{
					state = 17 ;
					positiveDatum = ( token - 48 ) ;
				}
				else state = REJECT_STATE ;
			}	
			break ;

			case 17:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{	
					state = 17 ;

					if ( positiveDatum > 65535 ) state = REJECT_STATE ;
	
					positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
				}
				else if ( token == 0 )
				{
					state = ACCEPT_STATE ;
				}
				else state = REJECT_STATE ;
			}	
			break ;
 
			default:
			{
				state = REJECT_STATE ;
			}
			break ;
		}
	}


/*
 *	Check boundaries for IP fields.
 */

	status = ( state != REJECT_STATE ) ;

	if ( state == ACCEPT_STATE )
	{
		status = status && ( ( datumA < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumB < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumC < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumD < 256 ) ? TRUE : FALSE ) ;
	}

	udpAddress [ 0 ] = ( UCHAR ) datumA ;
	udpAddress [ 1 ] = ( UCHAR ) datumB ;
	udpAddress [ 2 ] = ( UCHAR ) datumC ;
	udpAddress [ 3 ] = ( UCHAR ) datumD ;

	USHORT *portPtr = ( USHORT * ) & udpAddress [ 4 ] ;
	*portPtr = htons ( ( USHORT ) positiveDatum ) ;

	octetString.SetValue ( udpAddress , 6 ) ;

	return status ;	
}

ProvUDPAddressType :: ProvUDPAddressType ( const UCHAR *value ) : ProvFixedLengthOctetStringType ( 6 , value ) 
{
}

ProvUDPAddressType :: ProvUDPAddressType () : ProvFixedLengthOctetStringType ( 6 ) 
{
}

ProvUDPAddressType :: ~ProvUDPAddressType () 
{
}

wchar_t *ProvUDPAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		UCHAR *value = octetString.GetValue () ;
		ULONG valueLength = octetString.GetValueLength () ;
		if ( valueLength != 6 )
			throw ;

		char ipxAddress [ 40 ] ;
		ostrstream oStrStream ( ipxAddress , 40 ) ;

		oStrStream << ( ( ULONG ) value [ 0 ] ) ;
		oStrStream << "." ;
		oStrStream << ( ( ULONG ) value [ 1 ] ) ;
		oStrStream << "." ;
		oStrStream << ( ( ULONG ) value [ 2 ] ) ;
		oStrStream << "." ;
		oStrStream << ( ( ULONG ) value [ 3 ] ) ;

		oStrStream << "/" ;
	
		ULONG portNumber =  ntohs ( * ( ( USHORT * ) & value [ 4 ] ) ) ;

		oStrStream << portNumber ;

		oStrStream << ends ;

		returnValue = DbcsToUnicodeString ( ipxAddress ) ;

	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}

ProvIPXAddressType :: ProvIPXAddressType ( const ProvOctetString &ipxAddressArg ) : ProvFixedLengthOctetStringType ( 12 , ipxAddressArg ) 
{
}

ProvIPXAddressType :: ProvIPXAddressType ( const ProvIPXAddressType &ipxAddressArg ) : ProvFixedLengthOctetStringType ( ipxAddressArg ) 
{
}

ProvInstanceType *ProvIPXAddressType :: Copy () const 
{
	return new ProvIPXAddressType ( *this ) ;
}

ProvIPXAddressType :: ProvIPXAddressType ( const wchar_t *ipxAddressArg ) : ProvFixedLengthOctetStringType ( 12 )  
{
	ProvInstanceType :: SetStatus ( Parse ( ipxAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

BOOL ProvIPXAddressType :: Parse ( const wchar_t *ipxAddressArg ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	UCHAR ipxAddress [ 12 ] ;

/*
          ProvIPXAddress ::= TEXTUAL-CONVENTION
              DISPLAY-HINT "4x.1x:1x:1x:1x:1x:1x.2d"
              STATUS       current
              DESCRIPTION
                      "Represents an IPX address."
              SYNTAX       OCTET STRING (SIZE (12))
 */

/* 
 * IPXAddress Definitions
 */

	ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
	ULONG positiveMagicPosDigit = 5 ;
	ULONG positiveDatum = 0 ;	

	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

#define NETWORK_HEX_INTEGER_START 0
#define STATION_HEX_INTEGER_START 100
#define PORT_DEC_INTEGER_START 200

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = ipxAddressArg [ position ++ ] ;
		switch ( state )
		{
			case NETWORK_HEX_INTEGER_START:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = NETWORK_HEX_INTEGER_START + 1 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case NETWORK_HEX_INTEGER_START+1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					ipxAddress [ length ] = ( UCHAR ) byte ;
					state = NETWORK_HEX_INTEGER_START + 2 ;
					length ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case NETWORK_HEX_INTEGER_START+2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = NETWORK_HEX_INTEGER_START + 1 ;
				}
				else
				{
					if ( token == L'.' ) 
					{
						if ( length ==4 )
						{
							state = STATION_HEX_INTEGER_START ;
						}
						else
							state = REJECT_STATE ;
					}
					else state = REJECT_STATE ;
				}
			}
			break ;

			case STATION_HEX_INTEGER_START:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = STATION_HEX_INTEGER_START + 1 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case STATION_HEX_INTEGER_START + 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					ipxAddress [ length ] = ( UCHAR ) byte ;
					state = STATION_HEX_INTEGER_START + 2 ;
					length ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case STATION_HEX_INTEGER_START + 2 :
			{
				if ( token == L':' )
				{
					state = STATION_HEX_INTEGER_START ;
				}
				else 
				{
					if ( token == L'.' )
					{
						if ( length == 10 ) 
						{
							state = PORT_DEC_INTEGER_START ;
						}
						else state = REJECT_STATE ;
					}
					else state = REJECT_STATE ;
	 			}
			}
			break ;

			case PORT_DEC_INTEGER_START:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{
					state = PORT_DEC_INTEGER_START + 1 ;
					positiveDatum = ( token - 48 ) ;
				}
				else state = REJECT_STATE ;
			}	
			break ;

			case PORT_DEC_INTEGER_START+1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{	
					state = PORT_DEC_INTEGER_START + 1 ;

					if ( positiveDatum > 65535 ) state = REJECT_STATE ;
	
					positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
				}
				else 
				{
					if ( token == 0 )
					{
						USHORT *portPtr = ( USHORT * ) & ipxAddress [ 10 ] ;
						*portPtr = htons ( ( USHORT ) positiveDatum ) ;

						state = ACCEPT_STATE ;
					}
					else state = REJECT_STATE ;
				}
			}	
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( status )
	{
		octetString.SetValue ( ipxAddress , 12 ) ;
	}

	return status ;
}

ProvIPXAddressType :: ProvIPXAddressType ( const UCHAR *value ) : ProvFixedLengthOctetStringType ( 12 , value ) 
{
}

ProvIPXAddressType :: ProvIPXAddressType () : ProvFixedLengthOctetStringType ( 12 ) 
{
}

ProvIPXAddressType :: ~ProvIPXAddressType () 
{
}

wchar_t *ProvIPXAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		UCHAR *value = octetString.GetValue () ;
		ULONG valueLength = octetString.GetValueLength () ;
		if ( valueLength != 12 )
			throw ;

		char ipxAddress [ 80 ] ;
		ostrstream oStrStream ( ipxAddress , 80) ;

		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 0 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 0 ] & 0xf ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 1 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 1 ] & 0xf ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 2 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 2 ] & 0xf ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 3 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 3 ] & 0xf ) ;

		oStrStream << "." ;
	
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 4 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 4 ] & 0xf ) ;
		oStrStream << ":" ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 5 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 5 ] & 0xf ) ;
		oStrStream << ":" ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 6 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 6 ] & 0xf ) ;
		oStrStream << ":" ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 7 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 7 ] & 0xf ) ;
		oStrStream << ":" ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 8 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 8 ] & 0xf ) ;
		oStrStream << ":" ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 9 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 9 ] & 0xf ) ;

		oStrStream << "." ;

		ULONG portNumber =  ntohs ( * ( ( USHORT * ) & value [ 10 ] ) ) ;

		oStrStream << portNumber ;

		oStrStream << ends ;

		returnValue = DbcsToUnicodeString ( ipxAddress ) ;
	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provimex.h ===
//***************************************************************************

//

//  PROVIMEX.H

//

//  Module: 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef __PROVIMEX_H__
#define __PROVIMEX_H__

#define DllImport __declspec ( dllimport )
#define DllExport __declspec ( dllexport )

#ifdef PROVIMEX_INIT
#define DllImportExport __declspec ( dllexport )
#else
#define DllImportExport __declspec ( dllimport )
#endif

#endif //__PROVIMEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provthrd.h ===
//***************************************************************************

//

//  PROVTHRD.H

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROVTHREAD_PROVTHRD_H__
#define __PROVTHREAD_PROVTHRD_H__

#include <Allocator.h>
#include <Queue.h>
#include <BasicTree.h>

#endif //__PROVTHREAD_PROVTHRD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provlog.h ===
//***************************************************************************

//

//  PROVLOG.H

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROVLOG_H
#define __PROVLOG_H

#include <wbemutil.h>

#ifdef PROVDEBUG_INIT
class __declspec ( dllexport ) ProvDebugLog
#else
class __declspec ( dllimport ) ProvDebugLog
#endif
{
private:

	char m_Caller ;

protected:
public:

	/*************************************************************************
	* There are 3 functions to write to a log file, which may be used in accordance with the following rules:
	*
	*	1. The user always knows whether he is writing to an ANSI file or a Unicode file, and he
	*		has to make sure this holds good in the rules 2, 3 and 4 below. This will be changed later to
	*		make it more flowxible to the user.
	*	2. Write() takes TCHAR arguments and the function will write and ANSI or Unicode string
	*		to the log file depending on what TCHAR maps to, in the compilation.
	*	3. WriteW() takes WCHAR arguments only, and expects that the file being written to is a Unicode file.
	*	4. WriteA() takes char arguments only, and expects that the file being written to is an ANSI file.
	*
	****************************************************************/
	void Write ( const TCHAR *a_DebugFormatString , ... ) ;
	void WriteFileAndLine ( const TCHAR *a_File , const ULONG a_Line , const TCHAR *a_DebugFormatString , ... ) ;
	void WriteFileAndLine ( const char *a_File , const ULONG a_Line , const wchar_t *a_DebugFormatString , ... );	
	void WriteW ( const WCHAR *a_DebugFormatString , ... ) ;
	void WriteFileAndLineW ( const WCHAR *a_File , const ULONG a_Line , const WCHAR *a_DebugFormatString , ... ) ;
	void WriteA ( const char *a_DebugFormatString , ... ) ;
	void WriteFileAndLineA ( const char *a_File , const ULONG a_Line , const char *a_DebugFormatString , ... ) ;

	ProvDebugLog ( char Caller ):m_Caller(Caller)
	{
	};

	BOOL GetLogging()
	{ 
	    if (GetLoggingLevelEnabled() == 2) 
	    	return TRUE; 
	    else 
	    	return FALSE;
	};

	DWORD GetLevel(){ return 32768-1; };

	static BOOL Startup () ;
	static void Closedown () ;

	static long s_ReferenceCount ;	
	static ProvDebugLog s_aLogs[LOG_MAX_PROV];
	static ProvDebugLog * s_ProvDebugLog;

    static ProvDebugLog * GetProvDebugLog(char Caller)
    {
       if (Caller > LOG_MAX_PROV) return NULL;
       return &s_aLogs[Caller];
    };
} ;

#define DebugMacro(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro0(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 1 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro1(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 2 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro2(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 4 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro3(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 8 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro4(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 16 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro5(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 32 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro6(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 64 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro7(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 128 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro8(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 256 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro9(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 512 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro10(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 1024 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro11(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 2048 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro12(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 4096 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro13(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 8192 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro14(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 16384 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro15(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 32768 ) ) \
	{ \
		{a ; } \
	} \
} 

#endif __PROVLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provtree.h ===
// (C) 1999-2001 Microsoft Corporation 
#ifndef WMI_TREE
#define WMI_TREE

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef DWORD TypeId_TreeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiTreeNode 
{
protected:

	TypeId_TreeNode m_Type ;

	void *m_Data ;
	WmiTreeNode *m_Left ;
	WmiTreeNode *m_Right ;
	WmiTreeNode *m_Parent ;
	
public:

	WmiTreeNode ( 

		WmiTreeNode *a_Node 
	) 
	{
		m_Type = a_Node->m_Type ;
		m_Data = a_Node->m_Data ;
		m_Left = a_Node->m_Left ;
		m_Right = a_Node->m_Right ;
		m_Parent = a_Node->m_Parent ;
	}

	WmiTreeNode ( 

		TypeId_TreeNode a_Type = 0 ,
		void *a_Data = NULL ,
		WmiTreeNode *a_Left = NULL ,
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 
	) 
	{
		m_Type = a_Type ;
		m_Parent = a_Parent ;
		m_Data = a_Data ;
		m_Left = a_Left ;
		m_Right = a_Right ;

		if ( m_Left )
			m_Left->SetParent ( this ) ;

		if ( m_Right )
			m_Right->SetParent ( this ) ;
	}

	virtual ~WmiTreeNode () {}

	TypeId_TreeNode GetType ()
	{
		return m_Type ;
	}

	void *GetData () 
	{
		return m_Data ; 
	}

	WmiTreeNode *GetLeft () 
	{ 
		return m_Left ; 
	}

	WmiTreeNode *GetRight () 
	{
		return m_Right ; 
	}

	WmiTreeNode *GetParent () 
	{
		return m_Parent ; 
	}

	void GetData ( void **a_Data ) 
	{
		*a_Data = & m_Data ; 
	}

	void GetLeft ( WmiTreeNode **&a_Left ) 
	{ 
		a_Left = &m_Left ; 
	}

	void GetRight ( WmiTreeNode **&a_Right ) 
	{
		a_Right = &m_Right ; 
	}

	void GetParent ( WmiTreeNode **&a_Parent ) 
	{
		a_Parent = &m_Parent ; 
	}

	void SetType ( TypeId_TreeNode a_Type )
	{
		m_Type = a_Type ;
	}

	void *SetData ( void *a_Data )
	{
		void *t_Data = m_Data ;
		m_Data = a_Data ;
		return t_Data ;
	}

	WmiTreeNode *SetLeft ( WmiTreeNode *a_Left )
	{
		WmiTreeNode *t_Left = m_Left ;
		m_Left = a_Left ;
		return t_Left ;
	}

	WmiTreeNode *SetRight ( WmiTreeNode *a_Right ) 
	{
		WmiTreeNode *t_Right = m_Right ;
		m_Right = a_Right ;
		return t_Right ;
	}

	WmiTreeNode *SetParent ( WmiTreeNode *a_Parent ) 
	{
		WmiTreeNode *t_Parent = m_Parent ;
		m_Parent = a_Parent ;
		return t_Parent ;
	}

	virtual WmiTreeNode *Copy () ;	// Copy node, not allocating copies of data and allocating copies of sub tree

	virtual WmiTreeNode *CopyNode () ; // Copy node, not allocating copies of data and subtree

	virtual void Print () {} ;
} ;

class DllImportExport WmiTreeNodeIterator 
{
protected:

	WmiTreeNode *m_Iterator ;

public:

	WmiTreeNodeIterator ( WmiTreeNodeIterator *a_WmiTreeNodeIterator )
	{
		m_Iterator = a_WmiTreeNodeIterator->m_Iterator ; 
	}

	WmiTreeNodeIterator ( WmiTreeNode *a_Root ) 
	{
		m_Iterator = a_Root ; 
	}

	virtual ~WmiTreeNodeIterator () {}

	WmiTreeNode *GetIterator () 
	{
		return m_Iterator ; 
	}

	WmiTreeNode *SetIterator ( WmiTreeNode *a_Iterator ) 
	{ 
		WmiTreeNode *t_Iterator = m_Iterator ;
		m_Iterator = a_Iterator ;
		return t_Iterator ;
	}

	virtual WmiTreeNodeIterator *Copy ()	
	{
		WmiTreeNodeIterator *t_Iterator = new WmiTreeNodeIterator ( m_Iterator ) ;
		return t_Iterator ;
	}

	void InOrder () ;
	void PreOrder () ;
	void PostOrder () ;
} ;

#endif // WMI_TREE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\include\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provtype.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include <provexpt.h>

DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString ) ;
DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString ) ;
DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix ) ;
DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) ;

class DllImportExport CBString
{
private:

    BSTR    m_pString;

public:

    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) 
		{
            SysFreeString(m_pString);
        }
        
		m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#if _MSC_VER >= 1100
template <> DllImportExport UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key ) ;
#else
DllImportExport UINT HashKey ( wchar_t *key ) ;
#endif

#if _MSC_VER >= 1100
typedef wchar_t * HmmHack_wchar_t ;
template<> DllImportExport BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const HmmHack_wchar_t *pElement1, const HmmHack_wchar_t *pElement2 ) ;
#else
DllImportExport BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 ) ;
#endif

union ProvLexiconValue
{
	LONG signedInteger ;
	ULONG unsignedInteger ;
	wchar_t *token ;
} ;

class ProvAnalyser;
class DllImportExport ProvLexicon
{
friend ProvAnalyser ;
public:

enum LexiconToken {

	TOKEN_ID ,
	SIGNED_INTEGER_ID ,
	UNSIGNED_INTEGER_ID ,
	COLON_ID ,
	COMMA_ID ,
	OPEN_PAREN_ID ,
	CLOSE_PAREN_ID ,
	DOT_ID ,
	DOTDOT_ID ,
	PLUS_ID ,
	MINUS_ID ,
	EOF_ID,
	WHITESPACE_ID,
	INVALID_ID,
	USERDEFINED_ID
} ;

private:

	wchar_t *tokenStream ;
	ULONG position ;
	LexiconToken token ;
	ProvLexiconValue value ;

protected:
public:

	ProvLexicon () ;
	~ProvLexicon () ;

	void SetToken ( ProvLexicon :: LexiconToken a_Token ) ;
	ProvLexicon :: LexiconToken GetToken () ;
	ProvLexiconValue *GetValue () ;
} ;

#define ANALYSER_ACCEPT_STATE 10000
#define ANALYSER_REJECT_STATE 10001

/* 
	User defined states should be greater than 20000
 */

class DllImportExport ProvAnalyser
{
private:

	wchar_t *stream ;
	ULONG position ;
	BOOL status ;

	ProvLexicon *GetToken (  BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

protected:

	virtual void Initialise () {} ;

	virtual ProvLexicon *CreateLexicon () { return new ProvLexicon ; }

	virtual BOOL Analyse ( 

		ProvLexicon *lexicon , 
		ULONG &state , 
		const wchar_t token , 
		const wchar_t *tokenStream , 
		ULONG &position , 
		BOOL unSignedIntegersOnly , 
		BOOL leadingIntegerZeros , 
		BOOL eatSpace 
	) 
	{ return FALSE ; }

public:

	ProvAnalyser ( const wchar_t *tokenStream = NULL ) ;
	virtual ~ProvAnalyser () ;

	void Set ( const wchar_t *tokenStream ) ;

	ProvLexicon *Get ( BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

	void PutBack ( const ProvLexicon *token ) ;

	virtual operator void * () ;

	static BOOL IsEof ( wchar_t token ) ;
	static BOOL IsLeadingDecimal ( wchar_t token ) ;
	static BOOL IsDecimal ( wchar_t token ) ;
	static BOOL IsOctal ( wchar_t token ) ;
	static BOOL IsHex ( wchar_t token ) ;	
	static BOOL IsAlpha ( wchar_t token ) ;
	static BOOL IsAlphaNumeric ( wchar_t token ) ;
	static BOOL IsWhitespace ( wchar_t token ) ;

	static ULONG OctWCharToDecInteger ( wchar_t token ) ;
	static ULONG HexWCharToDecInteger ( wchar_t token ) ;
	static ULONG DecWCharToDecInteger ( wchar_t token ) ;
	static wchar_t DecIntegerToHexWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToDecWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToOctWChar ( UCHAR integer ) ;

	static ULONG OctCharToDecInteger ( char token ) ;
	static ULONG HexCharToDecInteger ( char token ) ;
	static ULONG DecCharToDecInteger ( char token ) ;
	static char DecIntegerToHexChar ( UCHAR integer ) ;
	static char DecIntegerToDecChar ( UCHAR integer ) ;
	static char DecIntegerToOctChar ( UCHAR integer ) ;

} ;

class DllImportExport ProvNegativeRangeType
{
private:
protected:

	LONG lowerBound ;
	LONG upperBound ;

public:

	ProvNegativeRangeType ( const ProvNegativeRangeType &rangeType ) : lowerBound ( rangeType.lowerBound ) , upperBound ( rangeType.upperBound ) {}
	ProvNegativeRangeType ( LONG lowerBoundArg , LONG upperBoundArg ) : lowerBound ( lowerBoundArg ) , upperBound ( upperBoundArg ) {}
	ProvNegativeRangeType () : lowerBound ( 0 ) , upperBound ( 0 ) { } ;
	virtual ~ProvNegativeRangeType () {}


	LONG GetLowerBound () { return lowerBound ; }
	LONG GetUpperBound () { return upperBound ; }
	void SetUpperBound ( const LONG &upperBoundArg ) { upperBound = upperBoundArg ; }
	void SetLowerBound ( const LONG &lowerBoundArg ) { lowerBound = lowerBoundArg ; }

	virtual ProvNegativeRangeType *Copy () { return new ProvNegativeRangeType ( *this ) ; }
} ;

class ProvNegativeRangedType
{
private:
protected:

	BOOL status ;

	ProvList <ProvNegativeRangeType,ProvNegativeRangeType> rangedValues ;

	BOOL Parse ( const wchar_t *rangedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	ProvAnalyser analyser ;
	ProvLexicon *pushBack ;

	void PushBack () ;
	ProvLexicon *Get () ;
	ProvLexicon *Match ( ProvLexicon :: LexiconToken tokenType ) ;

	BOOL RecursiveDef () ;
	BOOL RangeDef () ;

public:

	ProvNegativeRangedType ( const ProvNegativeRangedType &rangedValues ) ;
	ProvNegativeRangedType ( const wchar_t *rangedValues = NULL ) ;
	virtual ~ProvNegativeRangedType () ;

	BOOL IsValid () { return status ; }

	void SetStatus ( const BOOL &statusArg ) { status = statusArg ; }

	BOOL Check ( const LONG &value ) ;

	virtual operator void* () { return status ? this : NULL ; } 

} ;

class DllImportExport ProvPositiveRangeType
{
private:
protected:

	ULONG lowerBound ;
	ULONG upperBound ;

public:

	ProvPositiveRangeType ( const ProvPositiveRangeType &rangeType ) : lowerBound ( rangeType.lowerBound ) , upperBound ( rangeType.upperBound ) {}
	ProvPositiveRangeType ( ULONG lowerBoundArg , LONG upperBoundArg ) : lowerBound ( lowerBoundArg ) , upperBound ( upperBoundArg ) {}
	ProvPositiveRangeType () : lowerBound ( 0 ) , upperBound ( 0 ) { } ;
	virtual ~ProvPositiveRangeType () {}


	ULONG GetLowerBound () { return lowerBound ; }
	ULONG GetUpperBound () { return upperBound ; }
	void SetUpperBound ( const ULONG &upperBoundArg ) { upperBound = upperBoundArg ; }
	void SetLowerBound ( const ULONG &lowerBoundArg ) { lowerBound = lowerBoundArg ; }

	virtual ProvPositiveRangeType *Copy () { return new ProvPositiveRangeType ( *this ) ; }
} ;

class DllImportExport ProvPositiveRangedType
{
private:
protected:

	BOOL status ;

	ProvList <ProvPositiveRangeType,ProvPositiveRangeType> rangedValues ;

	BOOL Parse ( const wchar_t *rangedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	ProvAnalyser analyser ;
	ProvLexicon *pushBack ;

	void PushBack () ;
	ProvLexicon *Get () ;
	ProvLexicon *Match ( ProvLexicon :: LexiconToken tokenType ) ;

	BOOL RecursiveDef () ;
	BOOL RangeDef () ;

public:

	ProvPositiveRangedType ( const ProvPositiveRangedType &rangedValues ) ;
	ProvPositiveRangedType ( const wchar_t *rangedValues = NULL ) ;
	virtual ~ProvPositiveRangedType () ;

	void SetStatus ( const BOOL &statusArg ) { status = statusArg ; }

	BOOL IsValid () { return status ; }

	BOOL Check ( const ULONG &value ) ;

	virtual operator void* () { return status ? this : NULL ; }
} ;

class DllImportExport ProvFixedType
{
private:
protected:

	ULONG fixedLength ;

public:

	ProvFixedType ( const ProvFixedType &fixedLengthArg ) { fixedLength = fixedLengthArg.fixedLength ; }
	ProvFixedType ( const ULONG fixedLengthArg ) { fixedLength = fixedLengthArg ; }
	virtual ~ProvFixedType () {} ;
} ;

class DllImportExport ProvInstanceType 
{
private:
protected:

	BOOL m_IsNull ;
	BOOL status ;

	ProvInstanceType ( const ProvInstanceType &copy ) { status = copy.status ; m_IsNull = copy.m_IsNull ; }
	ProvInstanceType ( BOOL statusArg = TRUE , BOOL nullArg = FALSE ) { status = statusArg ; m_IsNull = nullArg ; } ;
	virtual BOOL Equivalent (IN const ProvInstanceType &value) const = 0;

public:

	virtual ~ProvInstanceType () {} ;

	virtual wchar_t *GetStringValue () const = 0 ;

	virtual ProvInstanceType *Copy () const = 0 ;

	virtual operator void *() ;

	void SetStatus ( BOOL statusArg ) { status = statusArg ; }
	void SetNull ( BOOL nullArg ) { m_IsNull = nullArg ; }

	virtual BOOL IsValid () const ;
	virtual BOOL IsNull () const ;
	virtual BOOL IsProvV1Type () const { return TRUE ; }
	virtual BOOL IsProvV2CType () const { return TRUE ; }

	BOOL operator==(IN const ProvInstanceType &value) const
	{
		return Equivalent(value) ;
	}

	BOOL operator!=(IN const ProvInstanceType &value) const
	{
		return !((*this) == value) ;
	}

} ;

class DllImportExport ProvNullType : public ProvInstanceType
{
private:

	ProvNull null ;

protected:

	BOOL Equivalent (IN const ProvInstanceType &value) const;

public:

	ProvNullType ( const ProvNullType &nullArg ) ;
	ProvNullType ( const ProvNull &nullArg ) ;
	ProvNullType () ;
	~ProvNullType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;

	BOOL IsProvV2CType () const { return FALSE ; }
} ;

class DllImportExport ProvIntegerType : public ProvInstanceType , protected ProvNegativeRangedType
{
private:
protected:

	ProvInteger integer ;
	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *integerArg ) ;

public:

	ProvIntegerType ( const ProvIntegerType &integerArg ) ;
	ProvIntegerType ( const ProvInteger &integerArg , const wchar_t *rangeValues ) ;
	ProvIntegerType ( const wchar_t *integerArg , const wchar_t *rangeValues ) ;
	ProvIntegerType ( const LONG integerArg , const wchar_t *rangeValues ) ;
	ProvIntegerType ( const wchar_t *rangeValues = NULL ) ;
	~ProvIntegerType () ;

	wchar_t *GetStringValue () const ;
	LONG GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvGaugeType : public ProvInstanceType , protected ProvPositiveRangedType
{
private:
protected:

	ProvGauge gauge ;

	BOOL Parse ( const wchar_t *gaugeArg )  ;
	BOOL Equivalent (IN const ProvInstanceType &value) const ;

public:

	ProvGaugeType ( const ProvGaugeType &gaugeArg ) ;
	ProvGaugeType ( const ProvGauge &gaugeArg , const wchar_t *rangeValues ) ;
	ProvGaugeType ( const wchar_t *gaugeArg , const wchar_t *rangeValues ) ;
	ProvGaugeType ( const ULONG gaugeArg , const wchar_t *rangeValues ) ;
	ProvGaugeType ( const wchar_t *rangeValues = NULL ) ;
	~ProvGaugeType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvTimeTicksType : public ProvInstanceType
{
private:
protected:

	ProvTimeTicks timeTicks ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *timeTicksArg )  ;

public:

	ProvTimeTicksType ( const ProvTimeTicks &timeTicksArg ) ;
	ProvTimeTicksType ( const ProvTimeTicksType &timeTicksArg ) ;
	ProvTimeTicksType ( const wchar_t *timeTicksArg ) ;
	ProvTimeTicksType ( const ULONG timeTicksArg ) ;
	ProvTimeTicksType () ;
	~ProvTimeTicksType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvCounterType : public ProvInstanceType 
{
private:
protected:

	ProvCounter counter ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *counterArg )  ;

public:

	ProvCounterType ( const ProvCounter &counterArg ) ;
	ProvCounterType ( const ProvCounterType &counterArg ) ;
	ProvCounterType ( const wchar_t *counterArg ) ;
	ProvCounterType ( const ULONG counterArg ) ;
	ProvCounterType () ;
	~ProvCounterType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;
	
	ProvInstanceType *Copy () const ;

} ;

class DllImportExport  ProvCounter64Type : public ProvInstanceType 
{
private:
protected:

	ULONG high ;
	ULONG low ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *counterArg )  ;

public:

	ProvCounter64Type ( const ProvCounter64Type &counterArg ) ;
	ProvCounter64Type ( const ProvCounter64 &counterArg ) ;
	ProvCounter64Type ( const wchar_t *counterArg ) ;
	ProvCounter64Type ( const ULONG counterHighArg , const ULONG counterLowArg ) ;
	ProvCounter64Type () ;
	~ProvCounter64Type () ;

	wchar_t *GetStringValue () const ;
	void GetValue ( ULONG &counterHighArg , ULONG &counterLowArg ) const ;

	BOOL IsProvV1Type () const { return FALSE ; } 
	
	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvIpAddressType : public ProvInstanceType
{
private:
protected:

	ProvIpAddress ipAddress ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *ipAddressArg )  ;

public:

	ProvIpAddressType ( const ProvIpAddress &ipAddressArg ) ;
	ProvIpAddressType ( const ProvIpAddressType &ipAddressArg ) ;
	ProvIpAddressType ( const wchar_t *ipAddressArg ) ;
	ProvIpAddressType ( const ULONG ipAddressArg ) ;
	ProvIpAddressType () ;
	~ProvIpAddressType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvNetworkAddressType : public ProvInstanceType
{
private:
protected:

	ProvIpAddress ipAddress ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *gaugeArg )  ;

public:

	ProvNetworkAddressType ( const ProvIpAddress &ipAddressArg ) ;
	ProvNetworkAddressType ( const ProvNetworkAddressType &ipAddressArg ) ;
	ProvNetworkAddressType ( const wchar_t *networkAddressArg ) ;
	ProvNetworkAddressType ( const ULONG ipAddressArg ) ;
	ProvNetworkAddressType () ;
	~ProvNetworkAddressType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvObjectIdentifierType : public ProvInstanceType
{
private:
protected:

	ProvObjectIdentifier objectIdentifier ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *objectIdentifierArg )  ;

public:

	ProvObjectIdentifierType ( const ProvObjectIdentifier &objectIdentifierArg ) ;
	ProvObjectIdentifierType ( const ProvObjectIdentifierType &objectIdentifierArg ) ;
	ProvObjectIdentifierType ( const wchar_t *objectIdentifierArg ) ;
	ProvObjectIdentifierType ( IN const ULONG *value , IN const ULONG valueLength ) ;
	ProvObjectIdentifierType () ;
	~ProvObjectIdentifierType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	ULONG *GetValue () const ;

	ProvInstanceType *Copy () const ;

	ProvObjectIdentifierType &operator=(const ProvObjectIdentifierType &to_copy ) ;
} ;

class DllImportExport  ProvOpaqueType : public ProvInstanceType , protected ProvPositiveRangedType
{
private:
protected:

	ProvOpaque opaque ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *opaqueArg )  ;

public:

	ProvOpaqueType ( const ProvOpaque &opaqueArg , const wchar_t *rangedValues ) ;
	ProvOpaqueType ( const ProvOpaqueType &opaqueArg ) ;
	ProvOpaqueType ( const wchar_t *opaqueArg , const wchar_t *rangedValues ) ;
	ProvOpaqueType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	ProvOpaqueType ( const wchar_t *rangedValues = NULL ) ;
	~ProvOpaqueType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	UCHAR *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvFixedLengthOpaqueType : public ProvOpaqueType , protected ProvFixedType
{
private:
protected:
public:

	ProvFixedLengthOpaqueType ( const ULONG &fixedLength , const ProvOpaque &opaqueArg ) ;
	ProvFixedLengthOpaqueType ( const ProvFixedLengthOpaqueType &opaqueArg ) ;
	ProvFixedLengthOpaqueType ( const ULONG &fixedLength , const wchar_t *opaqueArg ) ;
	ProvFixedLengthOpaqueType ( const ULONG &fixedLengthArg , const UCHAR *value , const ULONG valueLength ) ;
	ProvFixedLengthOpaqueType ( const ULONG &fixedLength ) ;
	~ProvFixedLengthOpaqueType () ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvOctetStringType : public ProvInstanceType , protected ProvPositiveRangedType
{
private:
protected:

	ProvOctetString octetString ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *octetStringArg )  ;

public:

	ProvOctetStringType ( const ProvOctetString &octetStringArg , const wchar_t *rangedValues ) ;
	ProvOctetStringType ( const ProvOctetStringType &octetStringArg ) ;
	ProvOctetStringType ( const wchar_t *octetStringArg , const wchar_t *rangedValues ) ;
	ProvOctetStringType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	ProvOctetStringType ( const wchar_t *rangedValues = NULL ) ;
	~ProvOctetStringType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	UCHAR *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvFixedLengthOctetStringType : public ProvOctetStringType , protected ProvFixedType
{
private:
protected:
public:

	ProvFixedLengthOctetStringType ( const ULONG &fixedLength , const ProvOctetString &octetStringArg ) ;
	ProvFixedLengthOctetStringType ( const ProvFixedLengthOctetStringType &octetStringArg ) ;
	ProvFixedLengthOctetStringType ( const ULONG &fixedLength , const wchar_t *octetStringArg ) ;
	ProvFixedLengthOctetStringType ( const ULONG &fixedLength , const UCHAR *value ) ;
	ProvFixedLengthOctetStringType ( const ULONG &fixedLength ) ;
	~ProvFixedLengthOctetStringType () ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvMacAddressType : public ProvFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *macAddressArg )  ;

public:

	ProvMacAddressType ( const ProvOctetString &macAddressArg ) ;
	ProvMacAddressType ( const ProvMacAddressType &macAddressArg ) ;
	ProvMacAddressType ( const wchar_t *macAddressArg ) ;
	ProvMacAddressType ( const UCHAR *macAddressArg ) ;
	ProvMacAddressType () ;
	~ProvMacAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvPhysAddressType : public ProvOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *physAddressArg )  ;

public:

	ProvPhysAddressType ( const ProvOctetString &physAddressArg , const wchar_t *rangedValues  ) ;
	ProvPhysAddressType ( const ProvPhysAddressType &physAddressArg ) ;
	ProvPhysAddressType ( const wchar_t *physAddressArg , const wchar_t *rangedValues ) ;
	ProvPhysAddressType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	ProvPhysAddressType ( const wchar_t *rangedValues = NULL ) ;
	~ProvPhysAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvFixedLengthPhysAddressType : public ProvFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *physAddressArg )  ;

public:

	ProvFixedLengthPhysAddressType ( const ULONG &fixedLength , const ProvOctetString &physAddressArg ) ;
	ProvFixedLengthPhysAddressType ( const ProvFixedLengthPhysAddressType &physAddressArg ) ;
	ProvFixedLengthPhysAddressType ( const ULONG &fixedLength , const wchar_t *physAddressArg ) ;
	ProvFixedLengthPhysAddressType ( const ULONG &fixedLength , const UCHAR *value , const ULONG valueLength ) ;
	ProvFixedLengthPhysAddressType ( const ULONG &fixedLength ) ;
	~ProvFixedLengthPhysAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvDisplayStringType : public ProvOctetStringType
{
private:
protected:
public:

	ProvDisplayStringType ( const ProvOctetString &displayStringArg , const wchar_t *rangedValues ) ;
	ProvDisplayStringType ( const ProvDisplayStringType &displayStringArg ) ;
	ProvDisplayStringType ( const wchar_t *displayStringArg , const wchar_t *rangedValues ) ;
	ProvDisplayStringType ( const wchar_t *rangedValues = NULL ) ;
	~ProvDisplayStringType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvFixedLengthDisplayStringType : public ProvFixedLengthOctetStringType 
{
private:
protected:
public:

	ProvFixedLengthDisplayStringType ( const ULONG &fixedLength , const ProvOctetString &displayStringArg ) ;
	ProvFixedLengthDisplayStringType ( const ProvFixedLengthDisplayStringType &displayStringArg ) ;
	ProvFixedLengthDisplayStringType ( const ULONG &fixedLength , const wchar_t *displayStringArg ) ;
	ProvFixedLengthDisplayStringType ( const ULONG &fixedLength ) ;
	~ProvFixedLengthDisplayStringType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvEnumeratedType : public ProvIntegerType
{
private:

	ProvMap <LONG, const LONG,wchar_t *,wchar_t *> integerMap ;
	ProvMap <wchar_t *,wchar_t *,LONG,LONG> stringMap ;

	BOOL Parse ( const wchar_t *enumeratedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	ProvAnalyser analyser ;
	ProvLexicon *pushBack ;

	void PushBack () ;
	ProvLexicon *Get () ;
	ProvLexicon *Match ( ProvLexicon :: LexiconToken tokenType ) ;

	BOOL EnumerationDef () ;
	BOOL RecursiveDef () ;

protected:
public:

	ProvEnumeratedType ( const wchar_t *enumeratedValues , const LONG &enumeratedValue ) ;
	ProvEnumeratedType ( const wchar_t *enumeratedValues , const wchar_t *enumeratedValue ) ;
	ProvEnumeratedType ( const wchar_t *enumeratedValues , const ProvInteger &enumeratedValue ) ;
	ProvEnumeratedType ( const ProvEnumeratedType &enumerateValues ) ;
	ProvEnumeratedType ( const wchar_t *enumeratedValues ) ;
	~ProvEnumeratedType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvRowStatusType : public ProvEnumeratedType
{
private:
protected:
public:

	enum ProvRowStatusEnum
	{
		active = 1 ,
		notInService = 2 ,
		notReady = 3 ,
		createAndGo = 4 ,
		createAndWait = 5,
		destroy = 6
	} ;

	ProvRowStatusType ( const LONG &rowStatusValue ) ;
	ProvRowStatusType ( const wchar_t *rowStatusValue ) ;
	ProvRowStatusType ( const ProvInteger &rowStatusValue ) ;
	ProvRowStatusType ( const ProvRowStatusType &rowStatusValue ) ;
	ProvRowStatusType ( const ProvRowStatusEnum &rowStatusValue ) ;
	ProvRowStatusType () ;
	~ProvRowStatusType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;
	ProvRowStatusEnum GetRowStatus () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvBitStringType : public ProvOctetStringType
{
private:

	ProvMap <ULONG, const ULONG,wchar_t *,wchar_t *> integerMap ;
	ProvMap <wchar_t *,wchar_t *,ULONG,ULONG> stringMap ;

	BOOL Parse ( const wchar_t *bitStringValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	ProvAnalyser analyser ;
	ProvLexicon *pushBack ;

	void PushBack () ;
	ProvLexicon *Get () ;
	ProvLexicon *Match ( ProvLexicon :: LexiconToken tokenType ) ;

	BOOL BitStringDef () ;
	BOOL RecursiveDef () ;

protected:
public:

	ProvBitStringType ( const wchar_t *bitStringValues , const ProvOctetString &bitStringValue ) ;
	ProvBitStringType ( const wchar_t *bitStringValues , const wchar_t **bitStringValue , const ULONG &bitStringValueLength ) ;
	ProvBitStringType ( const ProvBitStringType &bitStringValues ) ;
	ProvBitStringType ( const wchar_t *bitStringValues ) ;
	~ProvBitStringType () ;

	wchar_t *GetStringValue () const ;
	ULONG ProvBitStringType :: GetValue ( wchar_t **&stringValue ) const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport ProvDateTimeType : public ProvOctetStringType
{
private:

	BOOL Parse ( const wchar_t *dateTimeValue ) ;
	void Encode (

		const ULONG &year ,
		const ULONG &month ,
		const ULONG &day ,
		const ULONG &hour ,
		const ULONG &minutes ,
		const ULONG &seconds ,
		const ULONG &deciSeconds ,
		const ULONG &UTC_present ,
		const ULONG &UTC_direction ,
		const ULONG &UTC_hours ,
		const ULONG &UTC_minutes
	) ;

	BOOL DateTimeDef () ;
//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	ProvAnalyser analyser ;
	ProvLexicon *pushBack ;

	void PushBack () ;
	ProvLexicon *Get () ;
	ProvLexicon *Match ( ProvLexicon :: LexiconToken tokenType ) ;

protected:
public:

	ProvDateTimeType ( const wchar_t *dateTimeValue ) ;
	ProvDateTimeType ( const ProvDateTimeType &dateTimeValue ) ;
	ProvDateTimeType ( const ProvOctetString &dateTimeValue ) ;
	ProvDateTimeType () ;
	~ProvDateTimeType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport ProvOSIAddressType : public ProvOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *osiAddressArg )  ;

public:

	ProvOSIAddressType ( const ProvOctetString &osiAddressArg ) ;
	ProvOSIAddressType ( const ProvOSIAddressType &osiAddressArg ) ;
	ProvOSIAddressType ( const wchar_t *osiAddressArg ) ;
	ProvOSIAddressType ( const UCHAR *value , const ULONG valueLength ) ;
	ProvOSIAddressType () ;
	~ProvOSIAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvUDPAddressType : public ProvFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *udpAddressArg )  ;

public:

	ProvUDPAddressType ( const ProvOctetString &udpAddressArg ) ;
	ProvUDPAddressType ( const ProvUDPAddressType &udpAddressArg ) ;
	ProvUDPAddressType ( const wchar_t *udpAddressArg ) ;
	ProvUDPAddressType ( const UCHAR *udpAddressArg ) ;
	ProvUDPAddressType () ;
	~ProvUDPAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvIPXAddressType : public ProvFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *ipxAddressArg )  ;

public:

	ProvIPXAddressType ( const ProvOctetString &ipxAddressArg ) ;
	ProvIPXAddressType ( const ProvIPXAddressType &ipxAddressArg ) ;
	ProvIPXAddressType ( const wchar_t *ipxAddressArg ) ;
	ProvIPXAddressType ( const UCHAR *ipxAddressArg ) ;
	ProvIPXAddressType () ;
	~ProvIPXAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\iproute\dll\ciprouteevent.cpp ===
//=================================================================
//
// PowerManagement.cpp --
//
// Copyright 1999- 2002 Microsoft Corporation
//
//=================================================================

#include "precomp.h"
#include <ntddip.h>
#include <ntddtcp.h>
#include "CIpRouteEvent.h"

#include <provexpt.h>

LONG CIPRouteEventProviderClassFactory::s_ObjectsInProgress = 0 ;
LONG CIPRouteEventProviderClassFactory::s_LocksInProgress = 0 ;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Class:			CIPRouteEventProviderClassFactory

 Description:	Provides class factory support for power management events

 Derivations:	public IClassFactory
 Caveats:
 Raid:
 History:		a-peterc  31-Mar-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

//
CIPRouteEventProviderClassFactory :: CIPRouteEventProviderClassFactory () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( &s_ObjectsInProgress ) ;
}

//
CIPRouteEventProviderClassFactory::~CIPRouteEventProviderClassFactory ()
{
	InterlockedDecrement ( &s_ObjectsInProgress ) ;
}

//
STDMETHODIMP_( ULONG ) CIPRouteEventProviderClassFactory::AddRef()
{
	return InterlockedIncrement ( &m_ReferenceCount ) ;
}

//
STDMETHODIMP_(ULONG) CIPRouteEventProviderClassFactory::Release()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement( &m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//
BOOL CIPRouteEventProviderClassFactory::DllCanUnloadNow()
{
	return ( !(s_ObjectsInProgress || s_LocksInProgress) ) ;
}

//***************************************************************************
//
// CBaseClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CIPRouteEventProviderClassFactory::LockServer ( BOOL a_fLock )
{
	if ( a_fLock )
	{
		InterlockedIncrement ( &s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( &s_LocksInProgress ) ;
	}

	return S_OK	;
}

//
STDMETHODIMP CIPRouteEventProviderClassFactory::QueryInterface (

	REFIID a_riid,
	PPVOID a_ppv
)
{
    *a_ppv = NULL ;

    if ( IID_IUnknown == a_riid || IID_IClassFactory == a_riid )
	{
        *a_ppv = this ;
    }

    if ( NULL != *a_ppv )
    {
        AddRef() ;
        return NOERROR ;
    }

    return ResultFromScode( E_NOINTERFACE ) ;
}

//***************************************************************************
//
// CIPRouteEventProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Event Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CIPRouteEventProviderClassFactory :: CreateInstance (

	LPUNKNOWN a_pUnkOuter ,
	REFIID a_riid ,
	LPVOID FAR *a_ppvObject
)
{
	HRESULT t_status = S_OK ;

	if ( a_pUnkOuter )
	{
		t_status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		try
		{
			//
			// new throws Heap_Exception exception
			//

			IWbemProviderInit *t_lpunk = ( IWbemProviderInit * ) new CIPRouteEventProvider ;

			if ( t_lpunk == NULL )
			{
				t_status = E_OUTOFMEMORY;
			}
			else
			{
				t_status = t_lpunk->QueryInterface ( a_riid , a_ppvObject ) ;
				if ( FAILED ( t_status ) )
				{
					delete t_lpunk ;
				}
			}
		}
		catch ( Heap_Exception& e_HE )
		{
			t_status = E_OUTOFMEMORY ;
		}
	}
	return t_status ;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Class:			CIPRouteEventProvider

 Description:	Provider support for power management events

 Derivations:	public CIPRouteEventProvider,
				public IWbemEventProvider,
				public IWbemProviderInit
 Caveats:
 Raid:
 History:		a-peterc  31-Mar-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// Event provider object

CIPRouteEventProvider :: CIPRouteEventProvider () : m_ReferenceCount( 0 ) ,
													m_pHandler(NULL),
													m_pClass(NULL),
													m_dwThreadID(NULL)

{
	InterlockedIncrement ( &CIPRouteEventProviderClassFactory::s_ObjectsInProgress ) ;

	InitializeCriticalSection ( &m_csEvent ) ;

	// Create a thread that will spin off an event loop

	NTSTATUS t_NtStatus = NtCreateEvent (

		&m_TerminationEventHandle,
        EVENT_ALL_ACCESS,
        NULL,
        SynchronizationEvent,
        FALSE
	) ;

	if (NT_SUCCESS(t_NtStatus))
	{
		m_hThreadHandle = CreateThread (

			NULL,						// pointer to security attributes
			0L,							// initial thread stack size
			dwThreadProc,				// pointer to thread function
			this,						// argument for new thread
			0L,							// creation flags
			&m_dwThreadID
		) ;
	}
}

//
CIPRouteEventProvider :: ~CIPRouteEventProvider ()
{
	LONG t_PreviousState = 0 ;

	if ( (m_hThreadHandle != INVALID_HANDLE_VALUE) && (m_TerminationEventHandle != INVALID_HANDLE_VALUE) )
	{
		//the worker thread should exit...
		NTSTATUS t_NtStatus = NtSetEvent (

			m_TerminationEventHandle ,
			& t_PreviousState
		) ;

		if (!NT_SUCCESS(t_NtStatus))
		{
			//fallback - next wait will fail and the thread should exit.
			m_TerminationEventHandle = INVALID_HANDLE_VALUE;
		}

		t_NtStatus = NtWaitForSingleObject ( m_hThreadHandle , FALSE, NULL ) ;
	}

   	DeleteCriticalSection ( &m_csEvent ) ;

	if ( m_pHandler )
	{
        m_pHandler->Release () ;
        m_pHandler = NULL ;
    }

	if ( m_pClass )
	{
        m_pClass->Release () ;
        m_pClass = NULL ;
    }

	InterlockedDecrement ( & CIPRouteEventProviderClassFactory::s_ObjectsInProgress ) ;
}

//
STDMETHODIMP_( ULONG ) CIPRouteEventProvider :: AddRef ()
{
	return InterlockedIncrement ( &m_ReferenceCount ) ;
}

//
STDMETHODIMP_(ULONG) CIPRouteEventProvider :: Release ()
{
	LONG t_ref ;
	if ( ( t_ref = InterlockedDecrement ( &m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ref ;
	}
}

//
STDMETHODIMP CIPRouteEventProvider :: QueryInterface (

	REFIID a_riid,
	void **a_ppv
)
{
	if ( NULL == a_ppv )
	{
		return E_INVALIDARG ;
	}
	else
	{
		*a_ppv = NULL ;
	}

    if( a_riid == IID_IWbemEventProvider )
    {
        *a_ppv = (IWbemEventProvider *)this ;
    }
	else if ( a_riid == IID_IWbemProviderInit )
	{
        *a_ppv = (IWbemProviderInit *) this ;
    }
	else if ( a_riid == IID_IUnknown )
	{
        *a_ppv = (IWbemProviderInit *) this ;
    }

	if (*a_ppv != NULL)
	{
		AddRef() ;
        return S_OK ;
	}
    else
	{
		return E_NOINTERFACE ;
	}
}

//
STDMETHODIMP CIPRouteEventProvider::Initialize (

	LPWSTR a_wszUser,
	long a_lFlags,
	LPWSTR a_wszNamespace,
	LPWSTR a_wszLocale,
	IWbemServices *a_pNamespace,
	IWbemContext *a_pCtx,
	IWbemProviderInitSink *a_pSink
)
{
	HRESULT t_hRes = WBEM_E_OUT_OF_MEMORY;

	if ( (m_hThreadHandle != INVALID_HANDLE_VALUE) && (m_TerminationEventHandle != INVALID_HANDLE_VALUE) )
	{
		IWbemClassObject *t_pEventClass = NULL;
		BSTR t_bstrClass = SysAllocString (IPROUTE_EVENT_CLASS);

		if (t_bstrClass)
		{
			t_hRes = a_pNamespace->GetObject (

				t_bstrClass,
				0,
				a_pCtx,
				&t_pEventClass,
				NULL
			) ;

			// ptr initialization routines
			if (SUCCEEDED(t_hRes))
			{
				SetClass ( t_pEventClass ) ;
			}

			SysFreeString ( t_bstrClass ) ;
		}
	}
	else
	{
		t_hRes = WBEM_E_FAILED;
	}

	a_pSink->SetStatus( t_hRes, 0 ) ;

    return t_hRes ;
}

//
STDMETHODIMP CIPRouteEventProvider::ProvideEvents (

	IWbemObjectSink *a_pSink,
	long a_lFlags
)
{
  	SetHandler( a_pSink ) ;

	return S_OK ;
}


void CIPRouteEventProvider::SetHandler( IWbemObjectSink __RPC_FAR *a_pHandler )
{
    EnterCriticalSection( &m_csEvent ) ;

    if ( m_pHandler )
	{
        m_pHandler->Release() ;
    }

	m_pHandler = a_pHandler ;
	if ( m_pHandler )
	{
		m_pHandler->AddRef() ;
	}

    LeaveCriticalSection( &m_csEvent ) ;
}

//
void CIPRouteEventProvider::SetClass ( IWbemClassObject *a_pClass )
{
    EnterCriticalSection( &m_csEvent ) ;

    if ( m_pClass )
	{
        m_pClass->Release() ;
    }

	m_pClass = a_pClass ;
	if ( m_pClass )
	{
		m_pClass->AddRef() ;
	}

    LeaveCriticalSection( &m_csEvent ) ;
}

// worker thread pump
DWORD WINAPI CIPRouteEventProvider :: dwThreadProc ( LPVOID a_lpParameter )
{
	CIPRouteEventProvider *t_pThis = ( CIPRouteEventProvider * ) a_lpParameter ;

	if ( t_pThis )
	{
		SmartCloseNtHandle t_StackHandle ;
		SmartCloseNtHandle t_CompleteEventHandle ;

		NTSTATUS t_NtStatus = t_pThis->OpenQuerySource (

			t_StackHandle ,
			t_CompleteEventHandle
		) ;

		BOOL t_Continue = TRUE ;

		while ( t_Continue && NT_SUCCESS ( t_NtStatus ) )
		{
			IO_STATUS_BLOCK t_IoStatusBlock ;

			t_NtStatus = NtDeviceIoControlFile (

				t_StackHandle,
				(HANDLE) t_CompleteEventHandle ,
				(PIO_APC_ROUTINE) NULL,
				(PVOID) NULL,
				&t_IoStatusBlock,
				IOCTL_IP_RTCHANGE_NOTIFY_REQUEST,
				NULL, // input buffer
				0,
				NULL ,    // output buffer
				0
			) ;

			if ( t_NtStatus == STATUS_PENDING )
			{
				HANDLE t_WaitArray [ 2 ] ;
				t_WaitArray [ 0 ] = (HANDLE)t_CompleteEventHandle ;
				t_WaitArray [ 1 ] = (HANDLE)t_pThis->m_TerminationEventHandle ;

				t_NtStatus = NtWaitForMultipleObjects (

					2 ,
					t_WaitArray ,
					WaitAny,
					FALSE ,
					NULL
				);

				switch ( t_NtStatus )
				{
					case STATUS_WAIT_0:
					{
					}
					break ;

					case STATUS_WAIT_1:
					{
						t_Continue = FALSE ;
					}
					break ;

					default:
					{
						t_Continue = FALSE ;
					}
					break ;
				}
			}
			else if ( t_NtStatus != STATUS_SUCCESS )
			{
			}
			else if ( t_IoStatusBlock.Status != STATUS_SUCCESS )
			{
			}

			if ( NT_SUCCESS ( t_NtStatus ) )
			{
				t_pThis->SendEvent () ;
			}
		}
	}

	return 0 ;
}

void CIPRouteEventProvider::SendEvent ()
{
	if( m_pClass && m_pHandler)
	{
		IWbemClassObject *t_pInst = NULL ;

		if( SUCCEEDED( m_pClass->SpawnInstance( 0L, &t_pInst ) ) )
		{
			m_pHandler->Indicate ( 1, &t_pInst ) ;
		}

		t_pInst->Release() ;
	}
}

NTSTATUS CIPRouteEventProvider::OpenQuerySource (

	HANDLE &a_StackHandle ,
	HANDLE &a_CompleteEventHandle
)
{
	UNICODE_STRING t_Stack ;
	RtlInitUnicodeString ( & t_Stack , DD_IP_DEVICE_NAME ) ;

	OBJECT_ATTRIBUTES t_Attributes;
	InitializeObjectAttributes (

		&t_Attributes,
		&t_Stack ,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
	) ;

	IO_STATUS_BLOCK t_IoStatusBlock ;

	NTSTATUS t_NtStatus = NtOpenFile (

		&a_StackHandle,
		GENERIC_EXECUTE,
		&t_Attributes,
		&t_IoStatusBlock,
		FILE_SHARE_READ,
		0
	);

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
        t_NtStatus = NtCreateEvent (

			&a_CompleteEventHandle,
            EVENT_ALL_ACCESS,
            NULL,
            SynchronizationEvent,
            FALSE
		) ;

		if ( ! NT_SUCCESS ( t_NtStatus ) )
		{
			NtClose ( a_StackHandle ) ;
			a_StackHandle = INVALID_HANDLE_VALUE ;
		}
	}

	return t_NtStatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\iproute\dll\cippersistedrtble.cpp ===
/******************************************************************
   CIPPersistedRTble.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine

   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib &
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description:



******************************************************************/

#include "precomp.h"
#include <winsock2.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provval.h>
#include <provtype.h>
#include <cregcls.h>
#include "CIPPersistedRTble.h"

extern const WCHAR *RouteDestination ;
extern const WCHAR *RouteInformation ;
extern const WCHAR *RouteMask ;
extern const WCHAR *RouteMetric1 ;
extern const WCHAR *RouteNextHop ;
extern const WCHAR *RouteName ;
extern const WCHAR *RouteCaption ;
extern const WCHAR *RouteDescription ;



#define TCIP_PERSISTENT_REG         L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\PersistentRoutes"
#define MAX_METRIC1					9999
#define PERSITENT_ROUTE_SEP			L','

CIPPersistedRouteTable MyCIPPersistedRouteTableSet (

	PROVIDER_NAME_CIPPERSISTEDROUTETABLE ,
	L"root\\cimv2"
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CIPPersistedRouteTable::CIPPersistedRouteTable
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/

CIPPersistedRouteTable :: CIPPersistedRouteTable (

	LPCWSTR lpwszName,
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CIPPersistedRouteTable::~CIPPersistedRouteTable
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CIPPersistedRouteTable :: ~CIPPersistedRouteTable ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CIPPersistedRouteTable::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here and
*                       all properties that this class knows how to populate must
*                       be filled in.  If there are no instances, return
*                       WBEM_S_NO_ERROR.  It is not an error to have no instances.
*                       If you are implementing a 'method only' provider, you
*                       should remove this method.
*
*****************************************************************************/

HRESULT CIPPersistedRouteTable :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR ;
    CRegistry t_Reg;

	DWORD dwError = ERROR_SUCCESS;
	if ( ( dwError = t_Reg.Open( HKEY_LOCAL_MACHINE, TCIP_PERSISTENT_REG, KEY_READ) ) == ERROR_SUCCESS)
	{
		WCHAR *pValueName = NULL ;
		BYTE *pValueData = NULL ;

        try
		{
			for(DWORD i = 0 ; i < t_Reg.GetValueCount() && SUCCEEDED(hRes); i++)
			{
				DWORD dwRetCode = t_Reg.EnumerateAndGetValues(i, pValueName, pValueData) ;

				if(dwRetCode == ERROR_SUCCESS)
				{
					CHString t_Dest ;
					CHString t_Mask ;
					CHString t_NextHop ;
					long t_Metric ;

					if ( Parse (	pValueName , t_Dest , t_Mask , t_NextHop , t_Metric ) )
					{
						CInstance *pInstance = CreateNewInstance ( pMethodContext ) ;

						if (pInstance != NULL )
						{
						/*
						 *	Initialize the instance
						 */
							pInstance->SetCHString( RouteDestination, t_Dest ) ;
							pInstance->SetCHString( RouteMask, t_Mask ) ;
							pInstance->SetCHString( RouteNextHop, t_NextHop ) ;
							pInstance->SetDWORD ( RouteMetric1, t_Metric ) ;

							//set the inherited properties that are sensible
							SetInheritedProperties (
								t_Dest ,
								t_NextHop ,
								t_Mask ,
								t_Metric ,
								*pInstance
							) ;

						/*
						 *	Forward the instance onto the core wmi service
						 */

							hRes = Commit ( pInstance ) ;
						}
					}
				}

				if ( pValueName )
				{
					delete [] pValueName ;
					pValueName = NULL ;
				}

				if ( pValueData )
				{
					delete [] pValueData ;
					pValueData = NULL ;
				}
			}

			t_Reg.Close() ;
		}
		catch ( ... )
		{
			if ( pValueName )
			{
				delete [] pValueName ;
				pValueName = NULL ;
			}

			if ( pValueData )
			{
				delete [] pValueData ;
				pValueData = NULL ;
			}

			throw ;
		}
	}
	else
	{
		if ( ERROR_ACCESS_DENIED == dwError )
		{
			hRes = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			hRes = WBEM_E_FAILED ;	
		}
	}

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPPersistedRouteTable::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::GetObjectAsync.
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error
*                   occurred.
*
*  COMMENTS    :    If you are implementing a 'method only' provider, you should
*                   remove this method.
*
*****************************************************************************/

HRESULT CIPPersistedRouteTable :: GetObject (

	CInstance *pInstance,
	long lFlags
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString t_Dest ;
    CHString t_Mask ;
    CHString t_NextHop ;
    long t_Metric1 = 1;

    pInstance->GetCHString ( RouteDestination , t_Dest ) ;
    pInstance->GetCHString ( RouteMask , t_Mask ) ;
    pInstance->GetCHString ( RouteNextHop , t_NextHop ) ;
    pInstance->GetDWORD ( RouteMetric1 , (DWORD&)t_Metric1 ) ;

    CRegistry t_Reg;

	DWORD dwError = ERROR_SUCCESS;
	if ( ( dwError = t_Reg.Open( HKEY_LOCAL_MACHINE, TCIP_PERSISTENT_REG, KEY_READ) ) == ERROR_SUCCESS)
	{
		WCHAR buff [ 20 ];
		buff [ 0 ] = L'\0' ;
		_ultow( t_Metric1, buff , 10 ) ;
		CHString t_ValName = t_Dest + PERSITENT_ROUTE_SEP + t_Mask + PERSITENT_ROUTE_SEP + t_NextHop + PERSITENT_ROUTE_SEP + buff ;

		if ( RegQueryValueEx ( t_Reg.GethKey(), t_ValName , NULL , NULL , NULL , NULL ) == ERROR_SUCCESS )
		{
			hr = S_OK ;

			/*
			 *	Initialize the instance
			 */

			//set the inherited properties that are sensible
			SetInheritedProperties (
				t_Dest ,
				t_NextHop ,
				t_Mask ,
				t_Metric1,
				*pInstance
			) ;
		}

		t_Reg.Close();
	}
	else
	{
		if ( ERROR_ACCESS_DENIED == dwError )
		{
			hr = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			hr = WBEM_E_FAILED ;	
		}
	}

    return hr ;
}


/*****************************************************************************
*
*  FUNCTION    : CIPPersistedRouteTable::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can
*                   write instance information back to the hardware or
*                   software.  For example: Win32_Environment will allow a
*                   PutInstance to create or update an environment variable.
*                   However, a class like MotherboardDevice will not allow
*                   editing of the number of slots, since it is difficult for
*                   a provider to affect that number.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::PutInstanceAsync.
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider,
*                       or are creating a 'method only' provider, remove this
*                       method.
*
*****************************************************************************/

HRESULT CIPPersistedRouteTable :: PutInstance  (

	const CInstance &Instance,
	long lFlags
)
{
    HRESULT hr = WBEM_E_FAILED ;

    switch ( lFlags & (WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY) )
	{
        case WBEM_FLAG_CREATE_OR_UPDATE:
        case WBEM_FLAG_CREATE_ONLY:
		{
			CHString t_ValName ;
			hr = CheckParameters ( Instance , t_ValName ) ;

			if ( SUCCEEDED ( hr ) )
			{
				CRegistry t_Reg;

				DWORD dwError = ERROR_SUCCESS;
				if ( ( dwError = t_Reg.Open( HKEY_LOCAL_MACHINE, TCIP_PERSISTENT_REG, KEY_ALL_ACCESS) ) == ERROR_SUCCESS)
				{
					CHString t_temp;

					if ( ERROR_SUCCESS != t_Reg.SetCurrentKeyValue( t_ValName, t_temp ) )
					{
						hr = S_OK ;
					}

					t_Reg.Close () ;
				}
				else
				{
					if ( ERROR_ACCESS_DENIED == dwError )
					{
						hr = WBEM_E_ACCESS_DENIED ;
					}
					else
					{
						hr = WBEM_E_FAILED ;	
					}
				}
			}
			else
			{
				hr = WBEM_E_INVALID_PARAMETER ;
			}
		}
		break ;

		default:
		{
			hr = WBEM_E_PROVIDER_NOT_CAPABLE ;
		}
		break ;
	}

    return hr ;
}

HRESULT CIPPersistedRouteTable :: CheckParameters (

	const CInstance &a_Instance ,
	CHString &a_ValueName
)
{
	bool t_Exists ;
	VARTYPE t_Type ;
	long t_mask  = 0 ;
	long t_dest  = 0 ;
	long t_nexthop = 0 ;

	CHString t_RouteDestinationString ;

	if ( a_Instance.GetStatus ( RouteDestination , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteDestination , t_RouteDestinationString ) && ! t_RouteDestinationString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteDestinationString ) ;

				if ( t_Address.IsValid () )
				{
					t_dest = htonl ( t_Address.GetValue () ) ;

					if ( t_dest == -1 )
					{
						return WBEM_E_INVALID_PARAMETER ;
					}
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;	
	}

	CHString t_RouteDestinationMaskString ;

	if ( a_Instance.GetStatus ( RouteMask , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteMask , t_RouteDestinationMaskString ) && ! t_RouteDestinationMaskString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteDestinationMaskString ) ;

				if ( t_Address.IsValid () )
				{
					t_mask = htonl ( t_Address.GetValue () ) ;

					if ( ( t_dest & t_mask ) != t_dest )
					{
						return WBEM_E_INVALID_PARAMETER;
					}
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;	
	}

	CHString t_RouteNextHopString ;

	if ( a_Instance.GetStatus ( RouteNextHop, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteNextHop , t_RouteNextHopString ) && ! t_RouteNextHopString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteNextHopString ) ;

				if ( t_Address.IsValid () )
				{
					t_nexthop = htonl ( t_Address.GetValue () ) ;

					if ( t_nexthop == -1 )
					{
						return WBEM_E_INVALID_PARAMETER ;
					}
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;	
	}

	DWORD t_Metric = 0 ;

	if ( a_Instance.GetStatus ( RouteMetric1 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			if ( !a_Instance.GetDWORD ( RouteMetric1 , t_Metric ) || ( t_Metric < 1) || ( t_Metric > MAX_METRIC1) )
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;	
	}

	WCHAR buff [ 20 ] ;
	buff [ 0 ] = L'\0' ;
	_ultow ( t_Metric , buff , 10 ) ;
	a_ValueName = t_RouteDestinationString + PERSITENT_ROUTE_SEP
					+ t_RouteDestinationMaskString + PERSITENT_ROUTE_SEP
					+ t_RouteNextHopString  + PERSITENT_ROUTE_SEP
					+ buff;
	return S_OK ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPPersistedRouteTable::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices,
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::DeleteInstanceAsync.
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/

HRESULT CIPPersistedRouteTable :: DeleteInstance (

	const CInstance &Instance,
	long lFlags
)
{
	HRESULT hr = WBEM_E_FAILED ;

    CHString t_Dest ;
    CHString t_Mask ;
    CHString t_NextHop ;
    long t_Metric1 = 1;

    Instance.GetCHString ( RouteDestination , t_Dest ) ;
    Instance.GetCHString ( RouteMask , t_Mask ) ;
    Instance.GetCHString ( RouteNextHop , t_NextHop ) ;
    Instance.GetDWORD ( RouteMetric1 , (DWORD&)t_Metric1 ) ;

    CRegistry t_Reg;

	DWORD dwError = ERROR_SUCCESS;
	if ( ( dwError = t_Reg.Open( HKEY_LOCAL_MACHINE, TCIP_PERSISTENT_REG, KEY_ALL_ACCESS) ) == ERROR_SUCCESS)
	{
		WCHAR buff [ 20 ];
		buff[0] = L'\0' ;
		_ultow( t_Metric1 , buff , 10 ) ;
		CHString t_ValName = t_Dest + PERSITENT_ROUTE_SEP + t_Mask + PERSITENT_ROUTE_SEP + t_NextHop + PERSITENT_ROUTE_SEP + buff ;

		if ( t_Reg.DeleteCurrentKeyValue(t_ValName) == ERROR_SUCCESS )
		{
			hr = S_OK ;
		}

		t_Reg.Close();
	}
	else
	{
		if ( ERROR_ACCESS_DENIED == dwError )
		{
			hr = WBEM_E_ACCESS_DENIED ;
		}
	}

    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPPersistedRouteTable::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.
*                   A method is an entry point for the user of your provider
*                   to request your class perform some function above and
*                   beyond a change of state.  (A change of state should be
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/

HRESULT CIPPersistedRouteTable :: ExecMethod (

	const CInstance &Instance,
	const BSTR bstrMethodName,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags
)
{
    // For non-static methods, use the CInstance Get functions (for example,
    // call GetCHString(L"Name", sTemp)) against Instance to see the key
    // values the client requested.

    return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

BOOL CIPPersistedRouteTable :: Parse (

	LPWSTR a_InStr ,
	CHString &a_Dest ,
	CHString &a_Mask ,
	CHString &a_NextHop ,
	long &a_Metric
)
{
	BOOL t_RetVal = FALSE ;

	if ( a_InStr && ( wcslen ( a_InStr ) > 0 ) )
	{
		LPWSTR t_Str = a_InStr ;
		LPWSTR t_Addr = t_Str ;
		a_Metric = 1 ;

		DWORD t_count = 0;

		while ( *t_Str != L'\0' )
		{
			if ( *t_Str != PERSITENT_ROUTE_SEP )
			{
				t_Str++ ;
			}
			else
			{
				*t_Str = L'\0';
				ProvIpAddressType t_Address ( t_Addr ) ;
				
				if ( t_Address.IsValid () )
				{
					t_count++ ;
					t_RetVal = TRUE ;

					switch ( t_count )
					{
						case 1 :
						{
							a_Dest = t_Addr ;
						}
						break ;

						case 2 :
						{
							a_Mask = t_Addr ;
						}
						break ;

						case 3 :
						{
							a_NextHop = t_Addr ;
						}
						break ;

						default :
						{
							t_RetVal = FALSE ;
						}

					}
					
					if ( t_RetVal )
					{
						*t_Str = PERSITENT_ROUTE_SEP ;
						t_Str++ ;
						t_Addr = t_Str ;
					}
					else
					{
						break ;
					}
				}
				else
				{
					t_RetVal = FALSE ;
					break ;
				}
			}
		}

		if ( ( t_count == 3 ) && t_RetVal )
		{
			//get the metric
			if (t_Addr != t_Str)
			{
				a_Metric = _wtoi ( t_Addr ) ;

				if ( a_Metric < 1 )
				{
					t_RetVal = FALSE ;
				}
			}
		}
		else
		{
			t_RetVal = FALSE ;
		}
	}

	return t_RetVal;
}

void CIPPersistedRouteTable :: SetInheritedProperties (

	LPCWSTR a_dest ,
	LPCWSTR a_gateway ,
	LPCWSTR a_mask ,
	long a_metric ,
	CInstance &a_Instance
)
{
	CHString t_temp( a_dest ) ;
	a_Instance.SetCHString ( RouteName, t_temp ) ;
	a_Instance.SetCHString ( RouteCaption, t_temp ) ;
	WCHAR t_buff [ 20 ] ;
	t_buff[0] = L'\0' ;
	_ultow( a_metric , t_buff , 10 ) ;
	t_temp = t_temp + PERSITENT_ROUTE_SEP + a_mask + PERSITENT_ROUTE_SEP + a_gateway + PERSITENT_ROUTE_SEP + t_buff ;
	a_Instance.SetCHString ( RouteDescription, t_temp ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\iproute\dll\ciprouteevent.h ===
//=================================================================

//

// PowerManagement.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   03/31/99	a-peterc        Created
//
//=================================================================

#ifndef _WBEM_POWER_EVENT_PROVIDER_H
#define _WBEM_POWER_EVENT_PROVIDER_H

#define IPROUTE_EVENT_CLASS L"Win32_IP4RouteTableEvent"

class SmartCloseNtHandle
{

private:
	HANDLE m_h;

public:
	SmartCloseNtHandle():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseNtHandle(HANDLE h):m_h(h){}
   ~SmartCloseNtHandle(){if (m_h!=INVALID_HANDLE_VALUE) NtClose(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) NtClose(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	operator HANDLE&() {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) NtClose(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

//
class CIPRouteEventProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;

    CIPRouteEventProviderClassFactory () ;
    ~CIPRouteEventProviderClassFactory () ;
	
	static BOOL DllCanUnloadNow();

	//IUnknown members
	STDMETHODIMP QueryInterface( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef() ;
    STDMETHODIMP_( ULONG ) Release() ;
	
	//IClassFactory members
	STDMETHODIMP CreateInstance( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer( BOOL ) ;
};

//
class CIPRouteEventProvider : public IWbemEventProvider, public IWbemProviderInit
{
private:

	long m_ReferenceCount ;

	SmartCloseNtHandle m_TerminationEventHandle ;

	CRITICAL_SECTION m_csEvent ;		
			
	static DWORD WINAPI dwThreadProc ( LPVOID lpParameter );

	void SendEvent () ;
	NTSTATUS OpenQuerySource ( 

		HANDLE &a_StackHandle , 
		HANDLE &a_CompleteEventHandle
	) ;


protected:

	IWbemObjectSink *m_pHandler ;
	IWbemClassObject *m_pClass ;
	SmartCloseHandle m_hThreadHandle ;
	DWORD m_dwThreadID ;

public:

	CIPRouteEventProvider() ;
	~CIPRouteEventProvider() ;

	void SetHandler ( IWbemObjectSink __RPC_FAR *a_pHandler ) ;
	void SetClass ( IWbemClassObject __RPC_FAR *a_pClass ) ;

    STDMETHOD ( QueryInterface ) ( 

		REFIID a_riid, 
		void **a_ppv
	) ;

    STDMETHOD_( ULONG, AddRef ) () ;
    STDMETHOD_( ULONG, Release ) () ;

    STDMETHOD ( ProvideEvents ) (

		IWbemObjectSink *a_pSink,
		long a_lFlags
	) ;
	
	STDMETHOD ( Initialize ) (

		LPWSTR a_wszUser , 
		long a_lFlags , 
		LPWSTR a_wszNamespace ,
		LPWSTR a_wszLocale ,
		IWbemServices *a_pNamespace ,  
		IWbemContext *a_pCtx ,
		IWbemProviderInitSink *a_pSink
	) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provval.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*-----------------------------------------------------------------
Filename: value.hpp
Purpose	: To specify the classes of various Prov values and instance
		  identifiers. These classes represent the different types of 
		  values for variables that may populate a MIB. 
Written By:	B.Rajeev
-----------------------------------------------------------------*/


#ifndef __VALUE__
#define __VALUE__

/*-----------------------------------------------------------------
General Overview:
	A variable instance refers to a MIB object, e.g. 
	1.3.6.1.2.1.1.1.0 or 1.3.6.1.2.1.2.1.2.1. The instance is 
	encoded as an Prov object identifier and is represented by the 
	class ProvObjectIdentifier. 

  The classes derived from ProvValue represent the encoding of the 
  information stored within the MIB object. The value is encoded 
  as an implementation of the abstract class ProvValue. The Prov 
  class library implements the following derivations of ProvValue 
  which refer to Prov BER encoded types.

		ProvNull
		ProvInteger
		ProvCounter32
		ProvCounter64
		ProvGauge
		ProvTimeTicks
		ProvIPAddress
		ProvNetworkAddress
		ProvBitString
		ProvOctetString
		ProvOpaque
		ProvObjectIdentifier

  All the implemented classes provide (in addition to others) -
  1. Constructors to initialize using relevant values or another
	instance of the same class.

  2. GetValue, SetValue methods for obtaining and setting
	relevant values.

  3. "=" operator to over-ride the default assignment operator and
	 an Equivalent method to check for equivalence between two instances
	 of the same (derived) class

  4. Copy methods for obtaining a copy of a specified instance of
	the class.


  note of caution:
  ----------------
		Some of the GetValue functions return pointers
  to dynamically allocated data. Users of the class must make copies
  of the returned values and must not rely on the integrity of this
  pointer or values obtained through it in future (because of 
  SetValue methods, or destruction of corresponding ProvValue class) 
-----------------------------------------------------------------*/

#include <provimex.h>
#include <provexpt.h>

// Abstract class at the root of all Prov Values

// maximum length of decimal dot notation addresses
#define MAX_ADDRESS_LEN			100

// end of string character
#define EOS '\0'

#define MIN(a,b) ((a<=b)?a:b)

#define BETWEEN(i, min, max) ( ((i>=min)&&(i<max))?TRUE:FALSE )

#define MAX_FIELDS 100
#define FIELD_SEPARATOR '.'
#define PROV_IP_ADDR_LEN 4

class DllImportExport ProvValue 
{
	// the "=" operator and the copy constructor have been
	// made private to prevent copies of the ProvValue instance
	// from being made
	ProvValue &operator=(IN const ProvValue &) 
	{
		return *this;
	}

	ProvValue(IN const ProvValue &Prov_value) {}

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const = 0;
	ProvValue() {}

public:

	virtual ProvValue *Copy () const = 0 ;

	BOOL operator==(IN const ProvValue &value) const
	{
		return Equivalent(value) ;
	}

	BOOL operator!=(IN const ProvValue &value) const
	{
		return !((*this) == value) ;
	}

	virtual ~ProvValue() {}
} ;


// Enables null values for required variables. Its a concrete class
// with dummy constructor and destructors to enable specification of
// null values
class DllImportExport ProvNull : public ProvValue
{
protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	// dummy constructor and destructor
	ProvNull() {}

	~ProvNull() {}

	ProvValue &operator=(IN const ProvNull &to_copy) 
	{
		return *this;
	}

	ProvValue *Copy() const { return new ProvNull; }
};


// Allows integer values to be specified
class DllImportExport ProvInteger : public ProvValue 
{
private:

	LONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvInteger ( IN const LONG value ) : val(value) {}
	ProvInteger ( IN const ProvInteger &value );

	~ProvInteger () {}

	LONG GetValue () const;

	void SetValue ( IN const LONG value );

	ProvValue &operator=(IN const ProvInteger &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvInteger &Prov_integer)	const
	{
		if ( val == Prov_integer.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

	ProvValue *Copy () const;
} ;

// Encapsulates gauge value
class DllImportExport ProvGauge : public ProvValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvGauge ( IN const LONG value ) : val(value) {}
	ProvGauge ( IN const ProvGauge &value );
	~ProvGauge () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvGauge &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvGauge &Prov_gauge)	const
	{
		if ( val == Prov_gauge.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates Counter values
class DllImportExport ProvCounter : public ProvValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvCounter ( IN const ULONG value ) : val(value) {}
	ProvCounter ( IN const ProvCounter &value );

	~ProvCounter () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvCounter &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvCounter &Prov_counter)	const
	{
		if ( val == Prov_counter.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates Time Ticks (since an earlier event)
class DllImportExport ProvTimeTicks : public ProvValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvTimeTicks ( IN const ULONG value ) : val(value) {}
	ProvTimeTicks ( IN const ProvTimeTicks &value );

	~ProvTimeTicks () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvTimeTicks &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvTimeTicks &Prov_time_ticks) const
	{
		if ( val == Prov_time_ticks.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates octet strings that do not have any terminator.
// The octet string is specified by the pair (val,length) where
// 'val' is a pointer to heap data and 'length' provides the number
// of octets in the data string.
class DllImportExport ProvOctetString : public ProvValue
{
private:

	// in case a new 'value' string has the same length as the stored
	// string, the stored string may be overwritten. this avoids
	// having to allocate and deallocate heap memory for the purpose.
	void OverWrite(IN const UCHAR *value);

protected:

	BOOL is_valid;
	UCHAR *val;
	ULONG length;

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;
	virtual void Initialize(IN const UCHAR *value, IN const ULONG valueLength);

	
	// The Replicate and UnReplicate methods allocate and deallocate
	// heap data. Replicate also copies the contents of the parameter
	// 'value' onto the allocated memory. This function may be 
	// implemented different and, thus, the methods have been declared
	// virtual.
	virtual UCHAR *Replicate(IN const UCHAR *value, IN const ULONG valueLength);

	virtual void UnReplicate(UCHAR *value);

public:

	ProvOctetString ( IN const UCHAR *value , IN const ULONG valueLength );

	ProvOctetString ( IN const ProvOctetString &value );

	~ProvOctetString ();

	void SetValue ( IN const UCHAR *value , IN const ULONG valueLength );

	ULONG GetValueLength () const;
	UCHAR *GetValue () const;

	ProvValue *Copy () const;


	ProvValue &operator=(IN const ProvOctetString &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	BOOL Equivalent(IN const ProvOctetString &Prov_octet_string) const;
} ;

// OpaqueValue class encapsulates octet strings
class DllImportExport ProvOpaque : public ProvValue
{
private:
	ProvOctetString *octet_string;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvOpaque ( IN const UCHAR *value , IN const ULONG valueLength ) : octet_string ( NULL )
	{
		octet_string = new ProvOctetString(value, valueLength);
	}

	ProvOpaque ( IN const ProvOpaque &value ) : octet_string ( NULL )
	{
		octet_string = new ProvOctetString(value.GetValue(), value.GetValueLength());
	}
	
	~ProvOpaque()
	{
		delete octet_string;
	}

	void SetValue ( IN const UCHAR *value , IN const ULONG valueLength )
	{
		octet_string->SetValue(value, valueLength);
	}

	ULONG GetValueLength () const
	{
		return octet_string->GetValueLength();
	}

	UCHAR *GetValue () const
	{
		return octet_string->GetValue();
	}


	ProvValue &operator=(IN const ProvOpaque &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	ProvValue *Copy () const
	{
		return new ProvOpaque(octet_string->GetValue(),
							  octet_string->GetValueLength());
	}

	void * operator()(void) const
	{
		return (*octet_string)();
	}


	BOOL Equivalent(IN const ProvOpaque &Prov_opaque) const
	{
		return octet_string->Equivalent(*(Prov_opaque.octet_string));
	}
};

#define DEFAULT_OBJECTIDENTIFIER_LENGTH 32

// Encapsulates the object identifier. An object identifier 
// identifies a MIB object instance
class DllImportExport ProvObjectIdentifier : public ProvValue
{
	
	// describes the legal values for a comparison
	enum Comparison {LESS_THAN, EQUAL_TO, GREATER_THAN};

private:

	BOOL is_valid;
	ULONG m_value[DEFAULT_OBJECTIDENTIFIER_LENGTH];
	ULONG *val;
	ULONG length;

	// in case a new 'value' string has the same length as the stored
	// string, the stored string may be overwritten. this avoids
	// having to allocate and deallocate heap memory for the purpose.
	void OverWrite(IN const ULONG *value);

protected:
	
	virtual BOOL Equivalent(IN const ProvValue &value)	const ;
	virtual void Initialize(IN const ULONG *value, IN const ULONG valueLength);

	
	// The Replicate and UnReplicate methods allocate and deallocate
	// heap data. Replicate also copies the contents of the parameter
	// 'value' onto the allocated memory. This function may be 
	// implemented different and, thus, the methods have been declared
	// virtual.
	virtual ULONG *Replicate(IN const ULONG *value, IN const ULONG valueLength) const;

	// Allocates enough memory to copy the first value followed by
	// the second value to be copied, thus, appending the two values
	virtual ULONG *Replicate(IN const ULONG *first_value, IN const ULONG first_length,
							 IN const ULONG *second_value, IN const ULONG second_length) const;

	virtual void UnReplicate(ULONG *value);

	// This single function
	Comparison Compare(IN const ProvObjectIdentifier &first, 
					   IN const ProvObjectIdentifier &second) const;

	BOOL Equivalent(IN const ProvObjectIdentifier &value) const;

public:

	ProvObjectIdentifier ( IN const ULONG *value , IN const ULONG valueLength );

	ProvObjectIdentifier ( IN const char *value );

	ProvObjectIdentifier ( IN const ProvObjectIdentifier &value );

	~ProvObjectIdentifier ();

	void SetValue ( IN const ULONG *value , IN const ULONG valueLength );

	ULONG GetValueLength () const;
	ULONG *GetValue () const;

	ProvValue *Copy () const;

	BOOL Equivalent(IN const ProvObjectIdentifier &value,
					 IN ULONG max_length) const;
	
	BOOL operator<(IN const ProvObjectIdentifier &value)	const
	{
		return (Compare(*this,value) == LESS_THAN)?TRUE:FALSE;

	}

	BOOL operator>(IN const ProvObjectIdentifier &value)	const
	{
		return (Compare(*this,value) == GREATER_THAN)?TRUE:FALSE;
	}

	BOOL operator<=(IN const ProvObjectIdentifier &value) const
	{
		return !(*this > value);
	}

	BOOL operator>=(IN const ProvObjectIdentifier &value) const
	{
		return !(*this < value);
	}

	BOOL operator==(IN const ProvObjectIdentifier &value) const
	{
		if ( this->GetValueLength() == value.GetValueLength() )
			return Equivalent(value) ;
		else
			return FALSE;
	}

	BOOL operator!=(IN const ProvObjectIdentifier &value) const
	{
		return !(*this == value);
	}
	
	ProvObjectIdentifier operator+ ( IN const ProvObjectIdentifier &value ) const;

	BOOL Prefix( IN ULONG index, ProvObjectIdentifier &prefix ) const
	{
		if ( index >= length )
			return FALSE;
		
		prefix.UnReplicate (val) ;
		prefix.Initialize (val, index+1) ;
		return TRUE ;
	}

	BOOL Suffix ( IN ULONG index , ProvObjectIdentifier &suffix ) const
	{
		if ( index >= length )
			return FALSE;

		suffix.UnReplicate (val) ;
		suffix.Initialize ( val+index, length-index ) ;
		return TRUE ;
	}

	ProvObjectIdentifier *Cut (ProvObjectIdentifier &value) const;


	ULONG &operator [] ( IN const ULONG index ) const;


	ProvValue &operator=(IN const ProvObjectIdentifier &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	char *GetAllocatedString() const;
} ;


// encapsulates an ip address. represents the 32 bit value in a ULONG
class DllImportExport ProvIpAddress : public ProvValue 
{
private:

	// if the dotted decimal representation passed to the constructor
	// is ill-formed, the instance may be invalid
	BOOL is_valid;
	ULONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvIpAddress ( IN const ULONG value )
		:val(value), is_valid(TRUE)
	{}

	// a dotted decimal representation is parsed to obtain the 32 bit value
	ProvIpAddress ( IN const char *value ) ;

	ProvIpAddress ( IN const ProvIpAddress &value );

	~ProvIpAddress () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvIpAddress &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	BOOL Equivalent(IN const ProvIpAddress &Prov_ip_address) const
	{
		if ( is_valid && Prov_ip_address() )
			return ( val == Prov_ip_address.GetValue() );
		else
			return FALSE;
	}

} ;

// Encapsulates UInteger32 value
class DllImportExport ProvUInteger32 : public ProvValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvUInteger32 ( IN const LONG value ) : val(value) {}
	ProvUInteger32 ( IN const ProvUInteger32 &value );
	~ProvUInteger32 () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvUInteger32 &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvUInteger32 &Prov_integer)	const
	{
		if ( val == Prov_integer.GetValue() )
			return TRUE;
		else
			return FALSE;
	}
} ;


// Encapsulates Counter64 values
class DllImportExport ProvCounter64 : public ProvValue 
{
private:

	ULONG lval;
	ULONG hval;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvCounter64 ( IN const ULONG lvalue , IN const ULONG hvalue ) : lval(lvalue),hval(hvalue) {}
	ProvCounter64 ( IN const ProvCounter64 &value );

	~ProvCounter64 () {}

	ULONG GetLowValue () const;
	ULONG GetHighValue () const;

	void SetValue ( IN const ULONG lvalue , IN const ULONG hvalue );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvCounter64 &to_copy) 
	{
		SetValue(to_copy.GetLowValue(),to_copy.GetHighValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvCounter64 &Prov_counter )	const
	{
		if ( ( lval == Prov_counter.GetLowValue() ) && ( hval == Prov_counter.GetHighValue() ) )
			return TRUE;
		else
			return FALSE;
	}

} ;



#endif // __VALUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\iproute\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WMI Framework Instance provider

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <CIpRouteEvent.h>
#include <brodcast.h>

HMODULE ghModule ;

// {23b77e99-5c2d-482d-a795-62ca3ae5b673}
DEFINE_GUID(CLSID_CIPROUTETABLE,
0x23b77e99, 0x5c2d, 0x482d, 0xa7, 0x95, 0x62, 0xca, 0x3a, 0xe5, 0xb6, 0x73);


// {6D7A4B0E-66D5-4ac3-A7ED-0189E8CF5E77}
DEFINE_GUID(CLSID_CIPROUTETABLEEVENT,
0x6d7a4b0e, 0x66d5, 0x4ac3, 0xa7, 0xed, 0x1, 0x89, 0xe8, 0xcf, 0x5e, 0x77);

#define PROVIDER_NAME L"CIPROUTETABLE"

//Count number of objects and number of locks.
long g_cLock = 0 ;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;
    
    try
    {
        if ( CLSID_CIPROUTETABLE == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else if( CLSID_CIPROUTETABLEEVENT == rclsid )
        {
            CIPRouteEventProviderClassFactory *lpunk = new CIPRouteEventProviderClassFactory ;
            if ( lpunk == NULL )
            {
                hr = E_OUTOFMEMORY ;
            }
            else
            {
                hr = lpunk->QueryInterface ( riid , ppv ) ;
                if ( FAILED ( hr ) )
                {
                    delete lpunk ;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
    SCODE sc = S_FALSE;

    try
    {
        if (CIPRouteEventProviderClassFactory::DllCanUnloadNow())
        {
            sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
        }
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("WBEM IP Route Provider"), CLSID_CIPROUTETABLE ) ;
        if( NOERROR == t_status )
        {
            t_status = RegisterServer( _T("WBEM IP Route Event Provider"), CLSID_CIPROUTETABLEEVENT ) ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_CIPROUTETABLE ) ;
        if( NOERROR == t_status )
        {
            t_status = UnregisterServer( CLSID_CIPROUTETABLEEVENT ) ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;
    try
    {
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
				bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
					// Perform any necessary cleanup.
					LogMessage( L"DLL_PROCESS_DETACH" );
			}
			break;
		}
    }
    catch ( ... )
    {
		bRet = FALSE;
    }

    return bRet ;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\iproute\dll\ciproutetable.cpp ===
/******************************************************************
   CIPRouteTable.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine

   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib &
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description:



******************************************************************/

#include "precomp.h"
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include "CIPRouteTable.h"
#include "CIpRouteEvent.h"

// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.  For instance:  "root\\default or "root\\cimv2".
//===================================================================

CIPRouteTable MyCIPRouteTableSet (

	PROVIDER_NAME_CIPROUTETABLE ,
	L"root\\cimv2"
) ;

// Property names
//===============
const WCHAR *RouteAge				= L"Age" ;
const WCHAR *RouteDestination		= L"Destination" ;
const WCHAR *RouteInterfaceIndex	= L"InterfaceIndex" ;
const WCHAR *RouteInformation		= L"Information" ;
const WCHAR *RouteMask				= L"Mask" ;
const WCHAR *RouteMetric1			= L"Metric1" ;
const WCHAR *RouteMetric2			= L"Metric2" ;
const WCHAR *RouteMetric3			= L"Metric3" ;
const WCHAR *RouteMetric4			= L"Metric4" ;
const WCHAR *RouteMetric5			= L"Metric5" ;
const WCHAR *RouteNextHop			= L"NextHop" ;
const WCHAR *RouteProtocol			= L"Protocol" ;
const WCHAR *RouteType				= L"Type" ;

// Inherited properties populated
//===============================
const WCHAR *RouteName				= L"Name" ;
const WCHAR *RouteCaption			= L"Caption" ;
const WCHAR *RouteDescription		= L"Description" ;

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define ROUTE_DESCRIPTION_SEP				L" - "

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

class CDeleteString
{
private:

	wchar_t * m_ptr;
	CDeleteString ( const CDeleteString& p ) ;
	CDeleteString & operator= ( const CDeleteString & p ) ;

public:

	CDeleteString ( wchar_t *ptr = NULL ) : m_ptr( ptr )
	{
	}

	~CDeleteString ( )
	{
		if ( m_ptr )
		{
			delete [] m_ptr ;
			m_ptr = NULL ;
		}
	}

	operator LPCWSTR ( ) const { return ( (LPCWSTR) m_ptr ) ; }
};


/*****************************************************************************
 *
 *  FUNCTION    :   CIPRouteTable::CIPRouteTable
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/

CIPRouteTable :: CIPRouteTable (

	LPCWSTR lpwszName,
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace ), m_ClassCInst( NULL )
{
	InitializeCriticalSection( &m_CS ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CIPRouteTable::~CIPRouteTable
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CIPRouteTable :: ~CIPRouteTable ()
{
	DeleteCriticalSection( &m_CS ) ;

	if ( m_ClassCInst != NULL )
	{
		m_ClassCInst->Release();
	}
}

/*****************************************************************************
*
*  FUNCTION    :    CIPRouteTable::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here and
*                       all properties that this class knows how to populate must
*                       be filled in.  If there are no instances, return
*                       WBEM_S_NO_ERROR.  It is not an error to have no instances.
*                       If you are implementing a 'method only' provider, you
*                       should remove this method.
*
*****************************************************************************/

HRESULT CIPRouteTable :: RangeQuery (

	MethodContext *pMethodContext,
	PartitionSet &a_PartitionSet ,
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	SmartCloseNtHandle t_StackHandle ;
	SmartCloseNtHandle t_CompleteEventHandle ;

	NTSTATUS t_NtStatus = OpenQuerySource (

		t_StackHandle ,
		t_CompleteEventHandle
	) ;

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
		ulong t_RouteTableSize = 0 ;
		IPRouteEntry *t_InformationBlock = NULL ;

		t_NtStatus = QueryInformation_IpRouteInfo (

			t_StackHandle ,
			t_CompleteEventHandle ,
			t_RouteTableSize ,
			t_InformationBlock
		) ;

		if ( NT_SUCCESS ( t_NtStatus ) )
		{
			try
			{
				ULONG t_PartitionCount = a_PartitionSet.GetPartitionCount () ;

				for ( ulong t_RouteIndex = 0 ; t_RouteIndex < t_RouteTableSize ; t_RouteIndex ++ )
				{
					IPRouteEntry &t_Entry = t_InformationBlock [ t_RouteIndex ] ;

					ProvIpAddressType t_DestinationIpAddress ( ntohl ( t_Entry.ire_dest ) ) ;
					CDeleteString t_DestinationIpAddressString(t_DestinationIpAddress.GetStringValue ());

					BOOL t_Create = FALSE ;

					for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
					{
						PartitionSet *t_PropertyPartition = a_PartitionSet.GetPartition ( t_Partition ) ;

						WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_PropertyPartition->GetRange () ;

						if ( t_Node->InfiniteLowerBound () )
						{
							if ( t_Node->InfiniteUpperBound () )
							{
								t_Create = TRUE ;
							}
							else
							{
								int t_Compare = wcscmp ( t_DestinationIpAddressString , t_Node->UpperBound () ) ;
								if ( t_Node->ClosedUpperBound () )
								{
									if ( t_Compare <= 0 )
									{
										t_Create = TRUE ;
									}
								}
								else
								{
									if ( t_Compare < 0 )
									{
										t_Create = TRUE ;
									}
								}
							}
						}
						else
						{
							int t_Compare = wcscmp ( t_DestinationIpAddressString , t_Node->LowerBound () ) ;
							if ( t_Node->ClosedLowerBound () )
							{
								if ( t_Compare >= 0 )
								{
									if ( t_Node->InfiniteUpperBound () )
									{
										t_Create = TRUE ;
									}
									else
									{
										t_Compare = wcscmp ( t_DestinationIpAddressString , t_Node->UpperBound () ) ;
										if ( t_Node->ClosedUpperBound () )
										{
											if ( t_Compare <= 0 )
											{
												t_Create = TRUE ;
											}
										}
										else
										{
											if ( t_Compare < 0 )
											{
												t_Create = TRUE ;
											}
										}
									}
								}
							}
							else
							{
								if ( t_Compare > 0 )
								{
									if ( t_Node->InfiniteUpperBound () )
									{
										t_Create = TRUE ;
									}
									else
									{
										t_Compare = wcscmp ( t_DestinationIpAddressString , t_Node->UpperBound () ) ;
										if ( t_Node->ClosedUpperBound () )
										{
											if ( t_Compare <= 0 )
											{
												t_Create = TRUE ;
											}
										}
										else
										{
											if ( t_Compare < 0 )
											{
												t_Create = TRUE ;
											}
										}
									}
								}
							}
						}
					}

					if( t_Create )
					{

					/*
					 *	Create a new instance based on the passed-in MethodContext.
					 *	Note that CreateNewInstance may throw, but will never return NULL.
					 */

						CInstance *pInstance = CreateNewInstance ( pMethodContext ) ;

					/*
					 *	Set the keys for the instance
					 */

						pInstance->SetCHString ( RouteDestination, t_DestinationIpAddressString ) ;

						ProvIpAddressType t_NextHopIpAddress ( ntohl ( t_Entry.ire_nexthop ) ) ;
						CDeleteString t_NextHopIpAddressString (t_NextHopIpAddress.GetStringValue () ) ;
						pInstance->SetCHString( RouteNextHop, t_NextHopIpAddressString ) ;

					/*
					 *	Initialize the instance
					 */

						ProvIpAddressType t_DestinationMaskIpAddress ( ntohl ( t_Entry.ire_mask ) ) ;
						CDeleteString t_DestinationMaskIpAddressString (t_DestinationMaskIpAddress.GetStringValue () ) ;
						pInstance->SetCHString( RouteMask, t_DestinationMaskIpAddressString ) ;

						pInstance->SetDWORD ( RouteAge, t_Entry.ire_age ) ;
						pInstance->SetDWORD ( RouteInterfaceIndex, t_Entry.ire_index ) ;
						pInstance->SetCHString ( RouteInformation, "0.0" ) ;
						pInstance->SetDWORD ( RouteProtocol, t_Entry.ire_proto ) ;
						pInstance->SetDWORD ( RouteType, t_Entry.ire_type ) ;
						pInstance->SetDWORD ( RouteMetric1, t_Entry.ire_metric1 ) ;
						pInstance->SetDWORD ( RouteMetric2, t_Entry.ire_metric2 ) ;
						pInstance->SetDWORD ( RouteMetric3, t_Entry.ire_metric3 ) ;
						pInstance->SetDWORD ( RouteMetric4, t_Entry.ire_metric4 ) ;
						pInstance->SetDWORD ( RouteMetric5, t_Entry.ire_metric5 ) ;

						//set the inherited properties that are sensible
						SetInheritedProperties (
							t_DestinationIpAddressString ,
							t_NextHopIpAddressString ,
							t_DestinationMaskIpAddressString ,
							*pInstance
						) ;


					/*
					 *	Forward the instance onto the core wmi service
					 */

						hRes = Commit ( pInstance ) ;
					}
				}
			}
			catch(...)
			{
				HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;
				throw ;
			}

			HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;

		}
		else
		{
			if ( STATUS_ACCESS_DENIED == t_NtStatus )
			{
				hRes = WBEM_E_ACCESS_DENIED ;
			}
			else
			{
				hRes = WBEM_E_FAILED ;	
			}
		}
	}
	else
	{
		if ( STATUS_ACCESS_DENIED == t_NtStatus )
		{
			hRes = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			hRes = WBEM_E_FAILED ;	
		}
	}

    return hRes ;
}

HRESULT CIPRouteTable :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	SmartCloseNtHandle t_StackHandle ;
	SmartCloseNtHandle t_CompleteEventHandle ;

	NTSTATUS t_NtStatus = OpenQuerySource (

		t_StackHandle ,
		t_CompleteEventHandle
	) ;

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
		ulong t_RouteTableSize = 0 ;
		IPRouteEntry *t_InformationBlock = NULL ;

		t_NtStatus = QueryInformation_IpRouteInfo (

			t_StackHandle ,
			t_CompleteEventHandle ,
			t_RouteTableSize ,
			t_InformationBlock
		) ;

		if ( NT_SUCCESS ( t_NtStatus ) )
		{
			try
			{
				for ( ulong t_RouteIndex = 0 ; t_RouteIndex < t_RouteTableSize ; t_RouteIndex ++ )
				{
					IPRouteEntry &t_Entry = t_InformationBlock [ t_RouteIndex ] ;

				/*
				 *	Create a new instance based on the passed-in MethodContext.
				 *	Note that CreateNewInstance may throw, but will never return NULL.
				 */

					CInstance *pInstance = CreateNewInstance ( pMethodContext ) ;

				/*
				 *	Set the keys for the instance
				 */

					ProvIpAddressType t_DestinationIpAddress ( ntohl ( t_Entry.ire_dest ) ) ;
					CDeleteString t_DestinationIpAddressString(t_DestinationIpAddress.GetStringValue ());
					pInstance->SetCHString ( RouteDestination, t_DestinationIpAddressString ) ;

					ProvIpAddressType t_NextHopIpAddress ( ntohl ( t_Entry.ire_nexthop ) ) ;
					CDeleteString t_NextHopIpAddressString (t_NextHopIpAddress.GetStringValue () ) ;
					pInstance->SetCHString( RouteNextHop, t_NextHopIpAddressString ) ;

				/*
				 *	Initialize the instance
				 */

					ProvIpAddressType t_DestinationMaskIpAddress ( ntohl ( t_Entry.ire_mask ) ) ;
					CDeleteString t_DestinationMaskIpAddressString (t_DestinationMaskIpAddress.GetStringValue () ) ;
					pInstance->SetCHString( RouteMask, t_DestinationMaskIpAddressString ) ;

					pInstance->SetDWORD ( RouteAge, t_Entry.ire_age ) ;
					pInstance->SetDWORD ( RouteInterfaceIndex, t_Entry.ire_index ) ;
					pInstance->SetCHString ( RouteInformation, "0.0" ) ;
					pInstance->SetDWORD ( RouteProtocol, t_Entry.ire_proto ) ;
					pInstance->SetDWORD ( RouteType, t_Entry.ire_type ) ;
					pInstance->SetDWORD ( RouteMetric1, t_Entry.ire_metric1 ) ;
					pInstance->SetDWORD ( RouteMetric2, t_Entry.ire_metric2 ) ;
					pInstance->SetDWORD ( RouteMetric3, t_Entry.ire_metric3 ) ;
					pInstance->SetDWORD ( RouteMetric4, t_Entry.ire_metric4 ) ;
					pInstance->SetDWORD ( RouteMetric5, t_Entry.ire_metric5 ) ;

					//set the inherited properties that are sensible
					SetInheritedProperties (
						t_DestinationIpAddressString ,
						t_NextHopIpAddressString ,
						t_DestinationMaskIpAddressString ,
						*pInstance
					) ;

				/*
				 *	Forward the instance onto the core wmi service
				 */

					hRes = Commit ( pInstance ) ;
				}
			}
			catch ( ... )
			{
				HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;
				throw ;
			}

			HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;
		}
		else
		{
			if ( STATUS_ACCESS_DENIED == t_NtStatus )
			{
				hRes = WBEM_E_ACCESS_DENIED ;
			}
			else
			{
				hRes = WBEM_E_FAILED ;	
			}
		}
	}
	else
	{
		if ( STATUS_ACCESS_DENIED == t_NtStatus )
		{
			hRes = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			hRes = WBEM_E_FAILED ;	
		}
	}

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPRouteTable::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::GetObjectAsync.
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error
*                   occurred.
*
*  COMMENTS    :    If you are implementing a 'method only' provider, you should
*                   remove this method.
*
*****************************************************************************/

HRESULT CIPRouteTable :: GetObject (

	CInstance *pInstance,
	long lFlags
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString t_KeyDest ;
    pInstance->GetCHString ( RouteDestination , t_KeyDest ) ;
	ProvIpAddressType t_IpAddress ( t_KeyDest ) ;

    CHString t_KeyHop ;
    pInstance->GetCHString ( RouteNextHop , t_KeyHop ) ;
	ProvIpAddressType t_NextHop ( t_KeyHop ) ;

	if ( t_IpAddress.IsValid () && t_NextHop.IsValid () )
	{
		IPRouteEntry t_RouteEntry ;

		hr = QueryInformation_GetRouteEntry (

			t_IpAddress ,
			t_NextHop ,
			t_RouteEntry
		) ;

		if ( SUCCEEDED ( hr ) )
		{
			/*
			 *	Initialize the instance
			 */

			ProvIpAddressType t_DestinationMaskIpAddress ( ntohl ( t_RouteEntry.ire_mask ) ) ;
			CDeleteString t_DestinationMaskIpAddressString (t_DestinationMaskIpAddress.GetStringValue () ) ;
			pInstance->SetCHString( RouteMask, t_DestinationMaskIpAddressString ) ;

			pInstance->SetDWORD ( RouteAge, t_RouteEntry.ire_age ) ;
			pInstance->SetDWORD ( RouteInterfaceIndex, t_RouteEntry.ire_index ) ;
			pInstance->SetCHString ( RouteInformation, "0.0" ) ;
			pInstance->SetDWORD ( RouteProtocol, t_RouteEntry.ire_proto ) ;
			pInstance->SetDWORD ( RouteType, t_RouteEntry.ire_type ) ;
			pInstance->SetDWORD ( RouteMetric1, t_RouteEntry.ire_metric1 ) ;
			pInstance->SetDWORD ( RouteMetric2, t_RouteEntry.ire_metric2 ) ;
			pInstance->SetDWORD ( RouteMetric3, t_RouteEntry.ire_metric3 ) ;
			pInstance->SetDWORD ( RouteMetric4, t_RouteEntry.ire_metric4 ) ;
			pInstance->SetDWORD ( RouteMetric5, t_RouteEntry.ire_metric5 ) ;

			//set the inherited properties that are sensible
			SetInheritedProperties (
				t_KeyDest , 
				t_KeyHop ,
				t_DestinationMaskIpAddressString ,
				*pInstance
			) ;
		}
	}

    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPRouteTable::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of
*                   instances that satisfy the query, and a CFrameworkQuery
*                   which describes the query.  Create and populate all
*                   instances which satisfy the query.  You may return more
*                   instances or more properties than are requested and WinMgmt
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt
*                       will call your enumerate function to get all the instances and perform the
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/

HRESULT CIPRouteTable :: ExecQuery (

	MethodContext *pMethodContext,
	CFrameworkQuery &Query,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;


	CHString t_QueryString ;
	SQL_LEVEL_1_RPN_EXPRESSION *t_RpnExpression = NULL ;

	QueryPreprocessor :: QuadState t_State = QueryPreprocessor :: QuadState :: State_False;
	try
	{
		t_QueryString = Query.GetQuery () ;
		t_State = CIPRouteTable :: Query (

			t_QueryString.GetBuffer ( 0 ) ,
			t_RpnExpression
		) ;
	}
	catch ( ... )
	{
		if ( t_RpnExpression )
		{
			delete t_RpnExpression;
			t_RpnExpression = NULL;
		}

		throw;
	}

	if ( t_State == QueryPreprocessor :: QuadState :: State_True )
	{
		WmiTreeNode *t_Root = NULL ;

		try
		{
			t_State = PreProcess (

				pMethodContext ,
				t_RpnExpression ,
				t_Root
			) ;

			switch ( t_State )
			{
				case QueryPreprocessor :: QuadState :: State_True:
				{
					PartitionSet *t_Partition = NULL ;

					BSTR t_PropertyContainer [ 1 ] ;
					t_PropertyContainer [ 0 ] = SysAllocString ( RouteDestination ) ;

					if ( NULL == t_PropertyContainer [ 0 ] )
					{
						throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
					}

					try
					{
						t_State = PreProcess (

							pMethodContext ,
							t_RpnExpression ,
							t_Root ,
							1 ,
							t_PropertyContainer ,
							t_Partition
						) ;
					}
					catch(...)
					{
						if ( t_Partition )
						{
							delete t_Partition;
							t_Partition = NULL;
						}

						if ( t_PropertyContainer [ 0 ] )
						{
							SysFreeString ( t_PropertyContainer [ 0 ] ) ;
							t_PropertyContainer [ 0 ] = NULL;
						}

						throw;
					}

					SysFreeString ( t_PropertyContainer [ 0 ] ) ;

					switch ( t_State )
					{
						case QueryPreprocessor :: QuadState :: State_True :
						{
							t_Result = EnumerateInstances ( pMethodContext , lFlags ) ;
						}
						break ;

						case QueryPreprocessor :: QuadState :: State_False :
						{
	/*
	 * Empty set
	 */
						}
						break ;

						case QueryPreprocessor :: QuadState :: State_Undefined :
						{
							t_Result = RangeQuery ( pMethodContext , *t_Partition , lFlags ) ;

							delete t_Partition ;
							t_Partition = NULL ;
						}
						break ;

						default:
						{
							//couldn't understand this query
							t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
						}
						break ;
					}

					//this is allocated on PreProcess(pctx, rpn, root) success
					delete t_Root ;
					t_Root = NULL ;
				}
				break ;

				default:
				{
					//couldn't understand this query
					t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
				}
				break ;
			}

			delete t_RpnExpression ;
			t_RpnExpression = NULL ;
		}
		catch ( ... )
		{
			if ( t_Root )
			{
				delete t_Root;
				t_Root = NULL;
			}

			if ( t_RpnExpression )
			{
				delete t_RpnExpression;
				t_RpnExpression = NULL;
			}

			throw;
		}
	}
	else
	{
		//couldn't understand this query
		t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
	}

	return t_Result ;
}

/*****************************************************************************
*
*  FUNCTION    : CIPRouteTable::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can
*                   write instance information back to the hardware or
*                   software.  For example: Win32_Environment will allow a
*                   PutInstance to create or update an environment variable.
*                   However, a class like MotherboardDevice will not allow
*                   editing of the number of slots, since it is difficult for
*                   a provider to affect that number.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::PutInstanceAsync.
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider,
*                       or are creating a 'method only' provider, remove this
*                       method.
*
*****************************************************************************/

HRESULT CIPRouteTable :: PutInstance  (

	const CInstance &Instance,
	long lFlags
)
{
    HRESULT hr = WBEM_E_FAILED ;

    switch ( lFlags & (WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY) )
	{
        case WBEM_FLAG_CREATE_OR_UPDATE:
        case WBEM_FLAG_UPDATE_ONLY:
        case WBEM_FLAG_CREATE_ONLY:
		{
			CHString t_KeyDest ;
			Instance.GetCHString ( RouteDestination , t_KeyDest ) ;
			ProvIpAddressType t_IpAddress ( t_KeyDest ) ;

			CHString t_KeyHop ;
			Instance.GetCHString ( RouteNextHop , t_KeyHop ) ;
			ProvIpAddressType t_NextHop ( t_KeyHop ) ;

			if ( t_IpAddress.IsValid () && t_NextHop.IsValid () )
			{
				IPRouteEntry t_RouteEntry ;

				hr = QueryInformation_GetRouteEntry (

					t_IpAddress ,
					t_NextHop ,
					t_RouteEntry
				) ;

				switch ( lFlags & (WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY) )
				{
					case WBEM_FLAG_CREATE_OR_UPDATE:
					{
						hr = ( hr == WBEM_E_NOT_FOUND || hr == WBEM_S_NO_ERROR ) ? WBEM_S_NO_ERROR : hr ;
					}
					break;

					case WBEM_FLAG_UPDATE_ONLY:
					{
					}
					break;

					case WBEM_FLAG_CREATE_ONLY:
					{
						if ( hr == WBEM_S_NO_ERROR )
						{
							hr = WBEM_E_ALREADY_EXISTS ;
						}
						else if ( hr == WBEM_E_NOT_FOUND )
						{
							hr = WBEM_S_NO_ERROR ;
						}
					}
					break;
				}

				if ( SUCCEEDED ( hr ) )
				{
					hr = CheckParameters (

						Instance ,
						t_RouteEntry
					) ;
				}

				if ( SUCCEEDED ( hr ) )
				{
					//reset to an error which will be cleared on success...
					hr = WBEM_E_FAILED;

					SmartCloseNtHandle t_StackHandle;
					SmartCloseNtHandle t_CompleteEventHandle;

					NTSTATUS t_NtStatus = OpenSetSource (

						t_StackHandle ,
						t_CompleteEventHandle
					) ;

					if ( NT_SUCCESS ( t_NtStatus ) )
					{
						t_NtStatus = SetInformation_IpRouteInfo (

							t_StackHandle ,
							t_CompleteEventHandle ,
							t_RouteEntry
						) ;

						if ( NT_SUCCESS ( t_NtStatus ) )
						{
							hr = WBEM_S_NO_ERROR ;
						}
					}
				}
			}
			else
			{
				hr = WBEM_E_INVALID_PARAMETER ;
			}
		}
		break ;

		default:
		{
			hr = WBEM_E_PROVIDER_NOT_CAPABLE ;
		}
		break ;
	}

    return hr ;
}

HRESULT CIPRouteTable :: CheckParameters (

	const CInstance &a_Instance ,
	IPRouteEntry &a_RouteEntry
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;

	ZeroMemory ( & a_RouteEntry , sizeof ( a_RouteEntry ) ) ;

	a_RouteEntry.ire_metric2 = -1 ;
	a_RouteEntry.ire_metric3 = -1 ;
	a_RouteEntry.ire_metric4 = -1 ;
	a_RouteEntry.ire_metric5 = -1 ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_RouteDestinationString ;
	if ( a_Instance.GetStatus ( RouteDestination , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteDestination , t_RouteDestinationString ) && ! t_RouteDestinationString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteDestinationString ) ;
				if ( t_Address.IsValid () )
				{
					a_RouteEntry.ire_dest = htonl ( t_Address.GetValue () ) ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}

	CHString t_RouteDestinationMaskString ;
	if ( a_Instance.GetStatus ( RouteMask , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteMask , t_RouteDestinationMaskString ) && ! t_RouteDestinationMaskString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteDestinationMaskString ) ;
				if ( t_Address.IsValid () )
				{
					a_RouteEntry.ire_mask = htonl ( t_Address.GetValue () ) ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}

	CHString t_RouteNextHopString ;
	if ( a_Instance.GetStatus ( RouteNextHop, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteNextHop , t_RouteNextHopString ) && ! t_RouteNextHopString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteNextHopString ) ;
				if ( t_Address.IsValid () )
				{
					a_RouteEntry.ire_nexthop = htonl ( t_Address.GetValue () ) ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}

	if ( a_Instance.GetStatus ( RouteInterfaceIndex , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_InterfaceIndex = 0 ;
			if ( a_Instance.GetDWORD ( RouteInterfaceIndex , t_InterfaceIndex ) )
			{
				a_RouteEntry.ire_index = t_InterfaceIndex ;
			}
			else
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}

	if ( a_Instance.GetStatus ( RouteProtocol , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_Protocol = 0 ;
			if ( a_Instance.GetDWORD ( RouteProtocol , t_Protocol ) )
			{
				a_RouteEntry.ire_proto = t_Protocol ;
			}
			else
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}


	if ( a_Instance.GetStatus ( RouteType , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_Type = 0 ;
			if ( a_Instance.GetDWORD ( RouteType , t_Type ) )
			{
				a_RouteEntry.ire_type = t_Type ;
			}
			else
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}

#if 0
	if ( a_Instance.GetStatus ( RouteAge , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_Age = 0 ;
			if ( a_Instance.GetDWORD ( RouteAge , t_Age ) )
			{
				a_RouteEntry.ire_age = t_Age ;
			}
			else
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}

#endif

	if ( a_Instance.GetStatus ( RouteMetric1 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_Metric = 0 ;
			if ( a_Instance.GetDWORD ( RouteMetric1 , t_Metric ) )
			{
				a_RouteEntry.ire_metric1 = t_Metric ;
			}
			else
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}

	if ( a_Instance.GetStatus ( RouteMetric2 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				DWORD t_Metric = 0 ;
				if ( a_Instance.GetDWORD ( RouteMetric2 , t_Metric ) )
				{
					a_RouteEntry.ire_metric2 = t_Metric ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER  ;
				}
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}

	if ( a_Instance.GetStatus ( RouteMetric3 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				DWORD t_Metric = 0 ;
				if ( a_Instance.GetDWORD ( RouteMetric3 , t_Metric ) )
				{
					a_RouteEntry.ire_metric3 = t_Metric ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER  ;
				}
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}

	if ( a_Instance.GetStatus ( RouteMetric5 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				DWORD t_Metric = 0 ;
				if ( a_Instance.GetDWORD ( RouteMetric5 , t_Metric ) )
				{
					a_RouteEntry.ire_metric5 = t_Metric ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER  ;
				}
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}

	if ( a_Instance.GetStatus ( RouteMetric4 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				DWORD t_Metric = 0 ;
				if ( a_Instance.GetDWORD ( RouteMetric4 , t_Metric ) )
				{
					a_RouteEntry.ire_metric4 = t_Metric ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER  ;
				}
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_FAILED ;
	}

	return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPRouteTable::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices,
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::DeleteInstanceAsync.
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/

HRESULT CIPRouteTable :: DeleteInstance (

	const CInstance &Instance,
	long lFlags
)
{
	HRESULT hr = WBEM_E_FAILED ;

    CHString t_KeyDest ;
    Instance.GetCHString ( RouteDestination , t_KeyDest ) ;
	ProvIpAddressType t_IpAddress ( t_KeyDest ) ;

    CHString t_KeyHop ;
    Instance.GetCHString ( RouteNextHop , t_KeyHop ) ;
	ProvIpAddressType t_NextHop ( t_KeyHop ) ;

	if ( t_IpAddress.IsValid () && t_NextHop.IsValid () )
	{
		IPRouteEntry t_RouteEntry ;

		hr = QueryInformation_GetRouteEntry (

			t_IpAddress ,
			t_NextHop ,
			t_RouteEntry
		) ;

		if ( SUCCEEDED ( hr ) )
		{
			SmartCloseNtHandle t_StackHandle ;
			SmartCloseNtHandle t_CompleteEventHandle ;

			NTSTATUS t_NtStatus = OpenSetSource (

				t_StackHandle ,
				t_CompleteEventHandle
			) ;

			if ( NT_SUCCESS ( t_NtStatus ) )
			{
				t_NtStatus = DeleteInformation_IpRouteInfo (

					t_StackHandle ,
					t_CompleteEventHandle ,
					t_RouteEntry
				) ;

				if ( NT_SUCCESS ( t_NtStatus ) )
				{
					hr = WBEM_S_NO_ERROR ;
				}
			}
		}
	}

    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPRouteTable::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.
*                   A method is an entry point for the user of your provider
*                   to request your class perform some function above and
*                   beyond a change of state.  (A change of state should be
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/

HRESULT CIPRouteTable :: ExecMethod (

	const CInstance &Instance,
	const BSTR bstrMethodName,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags
)
{
    // For non-static methods, use the CInstance Get functions (for example,
    // call GetCHString(L"Name", sTemp)) against Instance to see the key
    // values the client requested.

    return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

NTSTATUS CIPRouteTable :: OpenQuerySource (

	HANDLE &a_StackHandle ,
	HANDLE &a_CompleteEventHandle
)
{
	UNICODE_STRING t_Stack ;
	RtlInitUnicodeString ( & t_Stack , DD_TCP_DEVICE_NAME ) ;

	OBJECT_ATTRIBUTES t_Attributes;
	InitializeObjectAttributes (

		&t_Attributes,
		&t_Stack ,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
	) ;

	IO_STATUS_BLOCK t_IoStatusBlock ;

	NTSTATUS t_NtStatus = NtOpenFile (

		&a_StackHandle,
		GENERIC_EXECUTE,
		&t_Attributes,
		&t_IoStatusBlock,
		FILE_SHARE_READ,
		0
	);

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
        t_NtStatus = NtCreateEvent (

			&a_CompleteEventHandle,
            EVENT_ALL_ACCESS,
            NULL,
            SynchronizationEvent,
            FALSE
		) ;

		if ( ! NT_SUCCESS ( t_NtStatus ) )
		{
			NtClose ( a_StackHandle ) ;
			a_StackHandle = INVALID_HANDLE_VALUE ;
		}
	}

	return t_NtStatus ;
}

HRESULT CIPRouteTable :: QueryInformation_GetRouteEntry (

	const ProvIpAddressType &a_DestinationIpAddress ,
	const ProvIpAddressType &a_NextHopIpAddress ,
	IPRouteEntry &a_RouteEntry
)
{
	HRESULT hRes = WBEM_E_NOT_FOUND ;

	SmartCloseNtHandle t_StackHandle ;
	SmartCloseNtHandle t_CompleteEventHandle ;

	NTSTATUS t_NtStatus = OpenQuerySource (

		t_StackHandle ,
		t_CompleteEventHandle
	) ;

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
		ulong t_RouteTableSize = 0 ;
		IPRouteEntry *t_InformationBlock = NULL ;

		t_NtStatus = QueryInformation_IpRouteInfo (

			t_StackHandle ,
			t_CompleteEventHandle ,
			t_RouteTableSize ,
			t_InformationBlock
		) ;

		if ( NT_SUCCESS ( t_NtStatus ) )
		{
			try
			{
				for ( ulong t_RouteIndex = 0 ; t_RouteIndex < t_RouteTableSize ; t_RouteIndex ++ )
				{
					IPRouteEntry &t_Entry = t_InformationBlock [ t_RouteIndex ] ;

					ProvIpAddressType t_DestinationIpAddress ( ntohl ( t_Entry.ire_dest ) ) ;
					ProvIpAddressType t_NextHopIpAddress ( ntohl ( t_Entry.ire_nexthop ) ) ;

					if ( ( t_DestinationIpAddress == a_DestinationIpAddress ) &&
						( t_NextHopIpAddress == a_NextHopIpAddress ) )
					{
						a_RouteEntry = t_InformationBlock [ t_RouteIndex ] ;

						hRes = WBEM_S_NO_ERROR ;
						break ;
					}
				}
			}
			catch ( ... )
			{
				HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;
				throw ;
			}

			HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;
		}
		else
		{
			if ( STATUS_ACCESS_DENIED == t_NtStatus )
			{
				hRes = WBEM_E_ACCESS_DENIED ;
			}
			else
			{
				hRes = WBEM_E_FAILED ;	
			}
		}
	}

	return hRes ;
}

NTSTATUS CIPRouteTable :: QueryInformation_IpRouteInfo (

	HANDLE a_StackHandle ,
	HANDLE a_CompleteEventHandle ,
	ulong &a_RouteTableSize ,
	IPRouteEntry *&a_InformationBlock
)
{
	IPSNMPInfo a_Information ;
	NTSTATUS t_NtStatus = QueryInformation_IpSnmpInfo (

		a_StackHandle ,
		a_CompleteEventHandle ,
		a_Information
	) ;

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
		TCP_REQUEST_QUERY_INFORMATION_EX InBuf;
		ulong InBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );

		ulong OutBufLen = ( a_Information.ipsi_numroutes + 16 ) * sizeof ( IPRouteEntry ) ;
		a_InformationBlock = ( IPRouteEntry * ) HeapAlloc ( GetProcessHeap (), 0, OutBufLen ) ;
		if ( a_InformationBlock )
		{
			TDIObjectID *ID = & ( InBuf.ID ) ;

			ID = &(InBuf.ID);
			ID->toi_entity.tei_entity = CL_NL_ENTITY;
			ID->toi_entity.tei_instance = 0;
			ID->toi_class = INFO_CLASS_PROTOCOL;
			ID->toi_type = INFO_TYPE_PROVIDER;
			ID->toi_id = IP_MIB_RTTABLE_ENTRY_ID;

			uchar *Context = ( uchar * ) & ( InBuf.Context [ 0 ] ) ;

			ZeroMemory ( Context, CONTEXT_SIZE ) ;

			IO_STATUS_BLOCK t_IoStatusBlock ;

			t_NtStatus = NtDeviceIoControlFile (

				a_StackHandle ,
				a_CompleteEventHandle ,
				NULL ,
				NULL ,
				&t_IoStatusBlock ,
				IOCTL_TCP_QUERY_INFORMATION_EX,
				( void * ) & InBuf,
				InBufLen,
				( void * ) ( a_InformationBlock ) ,
				OutBufLen
			);

			if ( t_NtStatus == STATUS_PENDING )
			{
				t_NtStatus = NtWaitForSingleObject ( a_CompleteEventHandle , FALSE, NULL ) ;
			}

			if ( SUCCEEDED ( t_NtStatus ) )
			{
			    a_RouteTableSize = ( t_IoStatusBlock.Information / sizeof ( IPRouteEntry ) ) ;
			}
		}
		else
		{
			return ERROR_NOT_ENOUGH_MEMORY ;
		}
	}

	return t_NtStatus ;
}

NTSTATUS CIPRouteTable :: QueryInformation_IpSnmpInfo (

	HANDLE a_StackHandle ,
	HANDLE a_CompleteEventHandle ,
	IPSNMPInfo &a_Information
)
{
    TCP_REQUEST_QUERY_INFORMATION_EX InBuf;
    ulong InBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    ulong OutBufLen = sizeof ( IPSNMPInfo ) ;

    TDIObjectID *ID = & ( InBuf.ID ) ;

    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = IP_MIB_STATS_ID;

    uchar *Context = ( uchar * ) & ( InBuf.Context [ 0 ] ) ;

    ZeroMemory ( Context, CONTEXT_SIZE ) ;

	IO_STATUS_BLOCK t_IoStatusBlock ;

	NTSTATUS t_NtStatus = NtDeviceIoControlFile (

		a_StackHandle ,
        a_CompleteEventHandle ,
        NULL ,
        NULL ,
        &t_IoStatusBlock ,
        IOCTL_TCP_QUERY_INFORMATION_EX,
        ( void * ) & InBuf,
        InBufLen,
        ( void * ) ( & a_Information ) ,
        OutBufLen
	);

	if ( t_NtStatus == STATUS_PENDING )
	{
		t_NtStatus = NtWaitForSingleObject ( a_CompleteEventHandle , FALSE, NULL ) ;
	}

	if ( SUCCEEDED ( t_NtStatus ) )
	{
	}

	return t_NtStatus ;
}

NTSTATUS CIPRouteTable :: OpenSetSource (

	HANDLE &a_StackHandle ,
	HANDLE &a_CompleteEventHandle
)
{
	UNICODE_STRING t_Stack ;
	RtlInitUnicodeString ( & t_Stack , DD_TCP_DEVICE_NAME ) ;

	OBJECT_ATTRIBUTES t_Attributes;
	InitializeObjectAttributes (

		&t_Attributes,
		&t_Stack ,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
	) ;

	IO_STATUS_BLOCK t_IoStatusBlock ;

	NTSTATUS t_NtStatus = NtOpenFile (

		&a_StackHandle,
		GENERIC_WRITE,
		&t_Attributes,
		&t_IoStatusBlock,
		FILE_SHARE_READ,
		0
	);

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
        t_NtStatus = NtCreateEvent (

			&a_CompleteEventHandle,
            EVENT_ALL_ACCESS,
            NULL,
            SynchronizationEvent,
            FALSE
		) ;

		if ( ! NT_SUCCESS ( t_NtStatus ) )
		{
			NtClose ( a_StackHandle ) ;
			a_StackHandle = INVALID_HANDLE_VALUE ;
		}
	}

	return t_NtStatus ;
}

NTSTATUS CIPRouteTable :: SetInformation_IpRouteInfo (

	HANDLE a_StackHandle ,
	HANDLE a_CompleteEventHandle ,
	IPRouteEntry &a_RouteEntry
)
{
	NTSTATUS t_NtStatus = STATUS_SUCCESS ;

    ulong InBufLen = sizeof ( TCP_REQUEST_SET_INFORMATION_EX ) + sizeof ( IPSNMPInfo ) - 1 ;
    TCP_REQUEST_SET_INFORMATION_EX  *InBuf = ( TCP_REQUEST_SET_INFORMATION_EX  * ) HeapAlloc ( GetProcessHeap(), 0, InBufLen ) ;
    if ( InBuf )
    {
		try
		{
			IPRouteEntry *t_Entry = ( IPRouteEntry * ) &(InBuf->Buffer[0]) ;
			*t_Entry = a_RouteEntry ;

			TDIObjectID *ID = &(InBuf->ID);
			ID->toi_entity.tei_entity = CL_NL_ENTITY;
			ID->toi_entity.tei_instance = 0;
			ID->toi_class = INFO_CLASS_PROTOCOL;
			ID->toi_type = INFO_TYPE_PROVIDER;
			ID->toi_id = IP_MIB_RTTABLE_ENTRY_ID;

			InBuf->BufferSize = sizeof ( IPRouteEntry );

			IO_STATUS_BLOCK t_IoStatusBlock ;

			t_NtStatus = NtDeviceIoControlFile (

				a_StackHandle ,
				a_CompleteEventHandle ,
				NULL ,
				NULL ,
				&t_IoStatusBlock ,
				IOCTL_TCP_SET_INFORMATION_EX ,
				( void * ) InBuf,
				InBufLen,
				NULL ,
				0
			);

			if ( t_NtStatus == STATUS_PENDING )
			{
				t_NtStatus = NtWaitForSingleObject ( a_CompleteEventHandle , FALSE, NULL ) ;
			}
		}
		catch ( ... )
		{
			HeapFree ( GetProcessHeap () , 0, InBuf ) ;
			throw ;
		}

		HeapFree ( GetProcessHeap () , 0, InBuf ) ;
	}
	else
	{
		t_NtStatus = ERROR_NOT_ENOUGH_MEMORY ;
	}

	return t_NtStatus ;
}

NTSTATUS CIPRouteTable :: DeleteInformation_IpRouteInfo (

	HANDLE a_StackHandle ,
	HANDLE a_CompleteEventHandle ,
	IPRouteEntry &a_RouteEntry
)
{
	NTSTATUS t_NtStatus = STATUS_SUCCESS ;

    ulong InBufLen = sizeof ( TCP_REQUEST_SET_INFORMATION_EX ) + sizeof ( IPSNMPInfo ) - 1 ;
    TCP_REQUEST_SET_INFORMATION_EX  *InBuf = ( TCP_REQUEST_SET_INFORMATION_EX  * ) HeapAlloc ( GetProcessHeap(), 0, InBufLen ) ;
    if ( InBuf )
    {
		try
		{
			IPRouteEntry *t_Entry = ( IPRouteEntry * ) &(InBuf->Buffer[0]) ;
			*t_Entry = a_RouteEntry ;

/*
 *	Invalidate the route
 */

			t_Entry->ire_type = 2 ;

			TDIObjectID *ID = &(InBuf->ID);
			ID->toi_entity.tei_entity = CL_NL_ENTITY;
			ID->toi_entity.tei_instance = 0;
			ID->toi_class = INFO_CLASS_PROTOCOL;
			ID->toi_type = INFO_TYPE_PROVIDER;
			ID->toi_id = IP_MIB_RTTABLE_ENTRY_ID;

			InBuf->BufferSize = sizeof ( IPRouteEntry );

			IO_STATUS_BLOCK t_IoStatusBlock ;

			t_NtStatus = NtDeviceIoControlFile (

				a_StackHandle ,
				a_CompleteEventHandle ,
				NULL ,
				NULL ,
				&t_IoStatusBlock ,
				IOCTL_TCP_SET_INFORMATION_EX ,
				( void * ) InBuf,
				InBufLen,
				NULL ,
				0
			);

			if ( t_NtStatus == STATUS_PENDING )
			{
				t_NtStatus = NtWaitForSingleObject ( a_CompleteEventHandle , FALSE, NULL ) ;
			}
		}
		catch ( ... )
		{
			HeapFree ( GetProcessHeap () , 0, InBuf ) ;
			throw ;
		}

		HeapFree ( GetProcessHeap () , 0, InBuf ) ;
	}
	else
	{
		t_NtStatus = ERROR_NOT_ENOUGH_MEMORY ;
	}

	return t_NtStatus ;
}

DWORD CIPRouteTable :: GetPriority ( BSTR a_PropertyName )
{
	return 0xFFFFFFFF ;
}

QueryPreprocessor :: QuadState CIPRouteTable :: Compare (

	LONG a_Operand1 ,
	LONG a_Operand2 ,
	DWORD a_Operand1Func ,
	DWORD a_Operand2Func ,
	WmiTreeNode &a_OperatorType
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	switch ( a_Operand1Func )
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func )
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		t_Status = a_Operand1 == a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		t_Status = a_Operand1 != a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		t_Status = a_Operand1 >= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		t_Status = a_Operand1 <= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		t_Status = a_Operand1 < a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		t_Status = a_Operand1 > a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;

	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	return t_Status ;
}

QueryPreprocessor :: QuadState CIPRouteTable :: Compare (

	wchar_t *a_Operand1 ,
	wchar_t *a_Operand2 ,
	DWORD a_Operand1Func ,
	DWORD a_Operand2Func ,
	WmiTreeNode &a_OperatorType
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	CHString a_Operand1AfterFunc ;
	CHString a_Operand2AfterFunc ;

	switch ( a_Operand1Func )
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			a_Operand1AfterFunc = a_Operand1 ;
			a_Operand1AfterFunc.MakeUpper () ;
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			a_Operand1AfterFunc = a_Operand1 ;
			a_Operand1AfterFunc.MakeLower () ;
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func )
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			a_Operand2AfterFunc = a_Operand2 ;
			a_Operand2AfterFunc.MakeUpper () ;
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			a_Operand2AfterFunc = a_Operand2 ;
			a_Operand2AfterFunc.MakeLower () ;
		}
		break ;

		default:
		{
		}
		break ;
	}

	const wchar_t *t_Arg1 = a_Operand1AfterFunc.IsEmpty () ? a_Operand1 : (LPCWSTR)a_Operand1AfterFunc ;
	const wchar_t *t_Arg2 = a_Operand2AfterFunc.IsEmpty () ? a_Operand2 : (LPCWSTR)a_Operand2AfterFunc ;

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) == 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) != 0 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) >= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_False ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) <= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) < 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) > 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	return t_Status ;
}

QueryPreprocessor :: QuadState CIPRouteTable :: CompareString (

	IWbemClassObject *a_ClassObject ,
	BSTR a_PropertyName ,
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	WmiStringNode *t_StringNode = ( WmiStringNode * ) a_Operand ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare (

			t_StringNode->GetValue () ,
			t_Variant.bstrVal ,
			t_StringNode->GetPropertyFunction () ,
			t_StringNode->GetConstantFunction () ,
			*a_Operator
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

QueryPreprocessor :: QuadState CIPRouteTable :: CompareInteger (

	IWbemClassObject *a_ClassObject ,
	BSTR a_PropertyName ,
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	WmiSignedIntegerNode *t_IntegerNode = ( WmiSignedIntegerNode * ) a_Operand ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare (

			t_IntegerNode->GetValue () ,
			t_Variant.lVal ,
			t_IntegerNode->GetPropertyFunction () ,
			t_IntegerNode->GetConstantFunction () ,
			*a_Operator
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

WmiTreeNode *CIPRouteTable :: AllocTypeNode (

	void *a_Context ,
	BSTR a_PropertyName ,
	VARIANT &a_Variant ,
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode (

				a_PropertyName ,
				a_Variant.lVal,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode (

				a_PropertyName ,
				a_Variant.lVal ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
		{
		}
	}
	else
	{
		CInstance *t_ClassObject = NULL ;
		HRESULT t_Result = GetClassObject ( t_ClassObject, (MethodContext *)a_Context ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObjectPtr t_pClas ( t_ClassObject->GetClassObjectInterface () , false ) ;

			if ( t_pClas != NULL )
			{
				CIMTYPE t_VarType ;
				long t_Flavour ;
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;


				HRESULT t_Result = t_pClas->Get (

					a_PropertyName ,
					0 ,
					& t_Variant ,
					& t_VarType ,
					& t_Flavour
				);

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_VarType & CIM_FLAG_ARRAY )
					{
					}
					else
					{
						switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
						{
							case CIM_BOOLEAN:
							{
								if(V_VT(&a_Variant) == VT_I4)
								{
									t_Node = new WmiSignedIntegerNode ( 

										a_PropertyName , 
										a_Variant.lVal , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									) ;
								}
								else if (V_VT(&a_Variant) == VT_BOOL)
								{
									t_Node = new WmiSignedIntegerNode ( 

										a_PropertyName , 
										(a_Variant.lVal == VARIANT_FALSE) ? 0 : 1, 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									) ;
								}
								else if (V_VT(&a_Variant) == VT_NULL)
								{
									t_Node = new WmiNullNode (

										a_PropertyName , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									);
								}
							}
							break ;

							case CIM_SINT8:
							case CIM_SINT16:
							case CIM_CHAR16:
							case CIM_SINT32:
							{
								if(V_VT(&a_Variant) == VT_I4)
								{
									t_Node = new WmiSignedIntegerNode (

										a_PropertyName ,
										a_Variant.lVal ,
										GetPriority ( a_PropertyName ) ,
										a_Parent
									) ;
								}
								else if (V_VT(&a_Variant) == VT_NULL)
								{
									t_Node = new WmiNullNode (

										a_PropertyName , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									);
								}
							}
							break ;

							case CIM_UINT8:
							case CIM_UINT16:
							case CIM_UINT32:
							{
								if(V_VT(&a_Variant) == VT_I4)
								{
									t_Node = new WmiUnsignedIntegerNode (

										a_PropertyName ,
										a_Variant.lVal ,
										GetPriority ( a_PropertyName ) ,
										a_Parent
									) ;
								}
								else if (V_VT(&a_Variant) == VT_NULL)
								{
									t_Node = new WmiNullNode (

										a_PropertyName , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									);
								}
							}
							break ;

							case CIM_SINT64:
							case CIM_UINT64:
							{
								if(V_VT(&a_Variant) == VT_BSTR)
								{
									t_Node = new WmiStringNode ( 

										a_PropertyName , 
										a_Variant.bstrVal , 
										a_PropertyFunction ,
										a_ConstantFunction ,
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									) ;
								}
								else if(V_VT(&a_Variant) == VT_I4)
								{
									_variant_t t_uintBuff (&a_Variant);

									t_Node = new WmiStringNode ( 

										a_PropertyName , 
										(BSTR)((_bstr_t) t_uintBuff), 
										a_PropertyFunction ,
										a_ConstantFunction ,
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									) ;
								}
								else if (V_VT(&a_Variant) == VT_NULL)
								{
									t_Node = new WmiNullNode (

										a_PropertyName , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									);
								}
							}
							break ;

							case CIM_STRING:
							case CIM_DATETIME:
							case CIM_REFERENCE:
							{
								if(V_VT(&a_Variant) == VT_BSTR)
								{
									t_Node = new WmiStringNode (

										a_PropertyName ,
										a_Variant.bstrVal ,
										a_PropertyFunction ,
										a_ConstantFunction ,
										GetPriority ( a_PropertyName ) ,
										a_Parent
									) ;
								}
								else if (V_VT(&a_Variant) == VT_NULL)
								{
									t_Node = new WmiNullNode (

										a_PropertyName , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									);
								}
							}
							break ;

							case CIM_REAL32:
							case CIM_REAL64:
							{
							}
							break ;

							case CIM_OBJECT:
							case CIM_EMPTY:
							{
							}
							break ;

							default:
							{
							}
							break ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;
			}

			t_ClassObject->Release () ;
		}
	}

	return t_Node ;
}

QueryPreprocessor :: QuadState CIPRouteTable :: InvariantEvaluate (

	void *a_Context ,
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand
)
{
/*
 *  If property and value are invariant i.e. will never change for all instances then return State_True.
 *	If property is not indexable or keyed then return State_True to define an unknown number of possible values which we cannot optimise against.
 *	If property and value can never occur then return State_False to imply empty set
 *	If property and value do not infer anything then return State_Undefined.
 *	If property and value are in error then return State_Error
 *	Never return State_ReEvaluate.
 */

	QueryPreprocessor :: QuadState t_State = QueryPreprocessor :: QuadState :: State_Error ;

	CInstance *t_ClassObject = NULL ;
	HRESULT t_Result = GetClassObject ( t_ClassObject, (MethodContext *)a_Context ) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObjectPtr t_pClas(t_ClassObject->GetClassObjectInterface (), false );

		if (t_pClas != NULL)
		{
			WmiValueNode *t_Node = ( WmiValueNode * ) a_Operand ;
			BSTR t_PropertyName = t_Node->GetPropertyName () ;

			if ( t_PropertyName != NULL )
			{
				if ( *t_PropertyName == L'_' )
				{
					// System property, must check values
					if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_CLASS ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_SUPERCLASS ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 )
					{
						t_State = CompareInteger (

							t_pClas ,
							SYSTEM_PROPERTY_GENUS ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_SERVER ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_NAMESPACE ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 )
					{
						t_State = CompareInteger (

							t_pClas ,
							SYSTEM_PROPERTY_PROPERTY_COUNT ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_DYNASTY ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_RELPATH ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_PATH ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
				}
				else
				{
					if ( typeid ( *a_Operand ) == typeid ( WmiNullNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_True ;
					}
					else
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
	#if 0
					else if ( typeid ( *a_Operand ) == typeid ( WmiStringNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operand ) == typeid ( WmiUnsignedIntegerNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operand ) == typeid ( WmiSignedIntegerNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}

					if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotEqualNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrLessNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLessNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorGreaterNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLikeNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotLikeNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
	#endif
				}
			}
			else
			{
				t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
			}
		}

		t_ClassObject->Release();
	}

	return t_State ;
}

WmiRangeNode *CIPRouteTable :: AllocInfiniteRangeNode (

	void *a_Context ,
	BSTR a_PropertyName
)
{
	WmiRangeNode *t_RangeNode = NULL ;
	CInstance *t_ClassObject = NULL ;
	HRESULT t_Result = GetClassObject ( t_ClassObject, (MethodContext *)a_Context ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObjectPtr t_pClas ( t_ClassObject->GetClassObjectInterface () , false ) ;

		if ( t_pClas != NULL )
		{
			CIMTYPE t_VarType ;
			long t_Flavour ;
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;

			HRESULT t_Result = t_pClas->Get (

				a_PropertyName ,
				0 ,
				& t_Variant ,
				& t_VarType ,
				& t_Flavour
			);

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_VarType & CIM_FLAG_ARRAY )
				{
				}
				else
				{
					switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
					{
						case CIM_BOOLEAN:
						case CIM_SINT8:
						case CIM_SINT16:
						case CIM_CHAR16:
						case CIM_SINT32:
						{
							t_RangeNode = new WmiSignedIntegerRangeNode (

								a_PropertyName ,
								0xFFFFFFFF ,
								TRUE ,
								TRUE ,
								FALSE ,
								FALSE ,
								0 ,
								0 ,
								NULL ,
								NULL
							) ;
						}
						break ;

						case CIM_UINT8:
						case CIM_UINT16:
						case CIM_UINT32:
						{
							t_RangeNode = new WmiUnsignedIntegerRangeNode (

								a_PropertyName ,
								0xFFFFFFFF ,
								TRUE ,
								TRUE ,
								FALSE ,
								FALSE ,
								0 ,
								0 ,
								NULL ,
								NULL
							) ;
						}
						break ;

						case CIM_SINT64:
						case CIM_UINT64:
						case CIM_STRING:
						case CIM_DATETIME:
						case CIM_REFERENCE:
						{
							t_RangeNode = new WmiStringRangeNode (

								a_PropertyName ,
								0x0 ,
								TRUE ,
								TRUE ,
								FALSE ,
								FALSE ,
								NULL ,
								NULL ,
								NULL ,
								NULL
							) ;
						}
						break ;

						case CIM_REAL32:
						case CIM_REAL64:
						{
						}
						break ;

						case CIM_OBJECT:
						case CIM_EMPTY:
						{
						}
						break ;

						default:
						{
						}
						break ;
					}
				}
			}

			VariantClear ( & t_Variant ) ;
		}

		t_ClassObject->Release () ;
	}

	return t_RangeNode ;
}

HRESULT CIPRouteTable :: GetClassObject ( CInstance *&a_ClassObject, MethodContext *a_Context )
{
	HRESULT t_Result = S_OK ;
	EnterCriticalSection( &m_CS ) ;

	try
	{
		if ( m_ClassCInst == NULL )
		{
			t_Result = WBEM_E_FAILED ;
		}
	}
	catch(...)
	{
		LeaveCriticalSection( &m_CS );
		throw;
	}

	LeaveCriticalSection( &m_CS );

	if (t_Result == WBEM_E_FAILED)
	{	
		CHString t_Namespace ( GetNamespace () ) ;
		CHString t_ComputerName ( GetLocalComputerName () ) ;
		CHString t_ClassName ( GetProviderName () ) ;
		CHString t_AbsPath = L"\\\\" + t_ComputerName + L"\\" + t_Namespace + L":" + t_ClassName ;

		t_Result = CWbemProviderGlue :: GetInstanceByPath ( ( LPCTSTR ) t_AbsPath.GetBuffer ( 0 ) , & a_ClassObject, a_Context ) ;

		if ( SUCCEEDED (t_Result) )
		{
			EnterCriticalSection( &m_CS ) ;

			try
			{
				if ( m_ClassCInst == NULL )
				{
					m_ClassCInst = a_ClassObject ;
					m_ClassCInst->AddRef();
				}
			}
			catch(...)
			{
				LeaveCriticalSection( &m_CS );
				throw;
			}

			LeaveCriticalSection( &m_CS );
		}
	}
	else
	{
		a_ClassObject = m_ClassCInst;
		a_ClassObject->AddRef();
	}

	return t_Result ;
}

void CIPRouteTable :: SetInheritedProperties (

	LPCWSTR a_dest ,
	LPCWSTR a_gateway ,
	LPCWSTR a_mask ,
	CInstance &a_Instance
)
{
	CHString t_temp( a_dest ) ;
	a_Instance.SetCHString ( RouteName, t_temp ) ;
	a_Instance.SetCHString ( RouteCaption, t_temp ) ;

	t_temp = t_temp + ROUTE_DESCRIPTION_SEP + a_mask + ROUTE_DESCRIPTION_SEP + a_gateway;
	a_Instance.SetCHString ( RouteDescription, t_temp ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\iproute\dll\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <Binding.h>

CBinding MyActiveRoute(
    L"Win32_ActiveRoute",
    L"root\\cimv2",
    L"Win32_IP4RouteTable",
    L"Win32_IP4PersistedRouteTable",
    L"SystemElement",
    L"SameElement",
	L"Destination",
	L"Destination"
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\iproute\dll\precomp.h ===
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntstatus.h>
}


#include <objbase.h>
#include <initguid.h>
#include <fwcommon.h>
#include <provider.h>
#include <instance.h>
#include <smartptr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjioactgprops.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjIOActgProps.h

#pragma once


//*****************************************************************************
// BEGIN: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************
#define IDS_Win32_JobObjectIOAccountingInfo L"Win32_NamedJobObjectActgInfo"

#define PROP_ALL_REQUIRED                           0xFFFFFFFF
#define PROP_NONE_REQUIRED                          0x00000000
#define PROP_JOIOActgID                             0x00000001
#define PROP_TotalUserTime                          0x00000002
#define PROP_TotalKernelTime                        0x00000004
#define PROP_ThisPeriodTotalUserTime                0x00000008
#define PROP_ThisPeriodTotalKernelTime              0x00000010
#define PROP_TotalPageFaultCount                    0x00000020
#define PROP_TotalProcesses                         0x00000040
#define PROP_ActiveProcesses                        0x00000080
#define PROP_TotalTerminatedProcesses               0x00000100
#define PROP_ReadOperationCount                     0x00000200
#define PROP_WriteOperationCount                    0x00000400
#define PROP_OtherOperationCount                    0x00000800
#define PROP_ReadTransferCount                      0x00001000
#define PROP_WriteTransferCount                     0x00002000
#define PROP_OtherTransferCount                     0x00004000
#define PROP_PeakProcessMemoryUsed                  0x00010000
#define PROP_PeakJobMemoryUsed                      0x00020000



// The following enum is used to reference
// into the array that follows it.  Hence,
// they must be kept in synch.
typedef enum tag_JOB_OBJ_IOACTG_PROPS
{
    JOIOACTGPROP_ID = 0,
    JOIOACTGPROP_TotalUserTime,
    JOIOACTGPROP_TotalKernelTime,
    JOIOACTGPROP_ThisPeriodTotalUserTime,    
    JOIOACTGPROP_ThisPeriodTotalKernelTime,  
    JOIOACTGPROP_TotalPageFaultCount,        
    JOIOACTGPROP_TotalProcesses,             
    JOIOACTGPROP_ActiveProcesses,            
    JOIOACTGPROP_TotalTerminatedProcesses,   
    JOIOACTGPROP_ReadOperationCount,         
    JOIOACTGPROP_WriteOperationCount,        
    JOIOACTGPROP_OtherOperationCount,        
    JOIOACTGPROP_ReadTransferCount,          
    JOIOACTGPROP_WriteTransferCount,         
    JOIOACTGPROP_OtherTransferCount,
    JOIOACTGPROP_PeakProcessMemoryUsed,          
    JOIOACTGPROP_PeakJobMemoryUsed,         
         

    // used to keep track of how many props we have:
    JOIOACTGPROP_JobObjIOActgPropertyCount  

} JOB_OBJ_IOACTG_PROPS;

// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE ENUMERATION DECLARED ABOVE!!!
extern LPCWSTR g_rgJobObjIOActgPropNames[];
//*****************************************************************************
// END: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************



class CJobObjIOActgProps : public CObjProps
{
public:
    CJobObjIOActgProps() { m_hJob = NULL; }
    CJobObjIOActgProps(CHString& chstrNamespace);
    CJobObjIOActgProps(
        HANDLE hJob,
        CHString& chstrNamespace);


    virtual ~CJobObjIOActgProps();

    HRESULT SetKeysFromPath(
        const BSTR ObjectPath, 
        IWbemContext __RPC_FAR *pCtx);

    HRESULT SetKeysDirect(
        std::vector<CVARIANT>& vecvKeys);

    
    HRESULT GetWhichPropsReq(
        CFrameworkQuery& cfwq);

    HRESULT SetNonKeyReqProps();

    HRESULT LoadPropertyValues(
        IWbemClassObject* pIWCO);

    void SetHandle(const HANDLE hJob);
    HANDLE& GetHandle();

private:
    HANDLE m_hJob;

    // Member meant to only be called
    // by base class.
    static DWORD CheckProps(
        CFrameworkQuery& Query);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjioactgprops.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjIOActgProps.cpp

//#define _WIN32_WINNT 0x0500 



#include "precomp.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include <vector>
#include "helpers.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjIOActgProps.h"
#include <crtdbg.h>


//*****************************************************************************
// BEGIN: Declaration of Win32_JobObjIOActgInfo class properties.
//*****************************************************************************
// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE JOB_OBJ_PROPS ENUMERATION DECLARED
// IN CJobObjProps.h !!!
LPCWSTR g_rgJobObjIOActgPropNames[] = 
{
    { L"Name" },
    { L"TotalUserTime" },             
    { L"TotalKernelTime" },           
    { L"ThisPeriodTotalUserTime" },   
    { L"ThisPeriodTotalKernelTime" }, 
    { L"TotalPageFaultCount" },       
    { L"TotalProcesses" },            
    { L"ActiveProcesses" },           
    { L"TotalTerminatedProcesses" },  
    { L"ReadOperationCount" },        
    { L"WriteOperationCount" },       
    { L"OtherOperationCount" },       
    { L"ReadTransferCount" },         
    { L"WriteTransferCount" },        
    { L"OtherTransferCount" },
    { L"PeakProcessMemoryUsed" },        
    { L"PeakJobMemoryUsed" }        
        
};
//*****************************************************************************
// END: Declaration of Win32_JobObjIOActgInfo class properties.
//*****************************************************************************



CJobObjIOActgProps::CJobObjIOActgProps(CHString& chstrNamespace)
  : CObjProps(chstrNamespace)
{
}


CJobObjIOActgProps::CJobObjIOActgProps(
        HANDLE hJob,
        CHString& chstrNamespace)
  : CObjProps(chstrNamespace),
    m_hJob(hJob)
{
}

CJobObjIOActgProps::~CJobObjIOActgProps()
{
}


// Clients call this to establish which properties
// were requested.  This function calls a base class
// helper, which calls our CheckProps function.  
// The base class helper finally stores the result
// in the base class member m_dwReqProps.
HRESULT CJobObjIOActgProps::GetWhichPropsReq(
    CFrameworkQuery& cfwq)
{
    HRESULT hr = S_OK;

    // Call base class version for help.
    // Base class version will call our
    // CheckProps function.
    hr = CObjProps::GetWhichPropsReq(
             cfwq,
             CheckProps);

    return hr;
}


DWORD CJobObjIOActgProps::CheckProps(
    CFrameworkQuery& Query)
{
    DWORD  dwReqProps = PROP_NONE_REQUIRED;
    // Get the requested properties for this
    // specific object...
    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ID])) 
        dwReqProps |= PROP_JOIOActgID;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_TotalUserTime])) 
        dwReqProps |= PROP_TotalUserTime;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_TotalKernelTime])) 
        dwReqProps |= PROP_TotalKernelTime;
    
    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ThisPeriodTotalUserTime])) 
        dwReqProps |= PROP_ThisPeriodTotalUserTime;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ThisPeriodTotalKernelTime])) 
        dwReqProps |= PROP_ThisPeriodTotalKernelTime;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_TotalPageFaultCount])) 
        dwReqProps |= PROP_TotalPageFaultCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_TotalProcesses])) 
        dwReqProps |= PROP_TotalProcesses;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ActiveProcesses])) 
        dwReqProps |= PROP_ActiveProcesses;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_TotalTerminatedProcesses])) 
        dwReqProps |= PROP_TotalTerminatedProcesses;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ReadOperationCount])) 
        dwReqProps |= PROP_ReadOperationCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_WriteOperationCount])) 
        dwReqProps |= PROP_WriteOperationCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_OtherOperationCount])) 
        dwReqProps |= PROP_OtherOperationCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ReadTransferCount])) 
        dwReqProps |= PROP_ReadTransferCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_WriteTransferCount])) 
        dwReqProps |= PROP_WriteTransferCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_OtherTransferCount])) 
        dwReqProps |= PROP_OtherTransferCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_PeakProcessMemoryUsed])) 
        dwReqProps |= PROP_PeakProcessMemoryUsed;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_PeakJobMemoryUsed])) 
        dwReqProps |= PROP_PeakJobMemoryUsed;


    return dwReqProps;
}


void CJobObjIOActgProps::SetHandle(
    const HANDLE hJob)
{
    m_hJob = hJob;
}

HANDLE& CJobObjIOActgProps::GetHandle()
{
    _ASSERT(m_hJob);
    return m_hJob;
}

// Sets the key properties from the ObjectPath.
HRESULT CJobObjIOActgProps::SetKeysFromPath(
    const BSTR ObjectPath, 
    IWbemContext __RPC_FAR *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This array contains the key field names
    CHStringArray rgchstrKeys;
    rgchstrKeys.Add(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ID]);
    
    // This array contains the index numbers 
    // in m_PropMap corresponding to the keys.
    short sKeyNum[1];
    sKeyNum[0] = JOIOACTGPROP_ID;

    hr = CObjProps::SetKeysFromPath(
             ObjectPath,                                       
             pCtx,
             IDS_Win32_JobObjectIOAccountingInfo,
             rgchstrKeys,
             sKeyNum);

    return hr;
}


// Sets the key property from in supplied
// parameter.
HRESULT CJobObjIOActgProps::SetKeysDirect(
    std::vector<CVARIANT>& vecvKeys)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(vecvKeys.size() == 1)
    {
        short sKeyNum[1];
        sKeyNum[0] = JOIOACTGPROP_ID;

        hr = CObjProps::SetKeysDirect(
                 vecvKeys,
                 sKeyNum);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}


// Sets the non-key properties.  Only those
// properties requested are set (as determined
// by base class member m_dwReqProps).
HRESULT CJobObjIOActgProps::SetNonKeyReqProps()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwReqProps = GetReqProps();
    _ASSERT(m_hJob);
    if(!m_hJob) return WBEM_E_INVALID_PARAMETER;

    // Because all the properties of this class
    // come from the same underlying win32 job
    // object structure, we only need to get that
    // structure one time.  We only need to get
    // it at all if at least one non-key property
    // was requested.
    if(dwReqProps != PROP_NONE_REQUIRED)
    {
        // Get the value from the underlying JO:
        JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION  jobaioai;
        JOBOBJECT_EXTENDED_LIMIT_INFORMATION joeli;

        BOOL fQIJO = ::QueryInformationJobObject(
                         m_hJob,
                         JobObjectBasicAndIoAccountingInformation,
                         &jobaioai,
                         sizeof(JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION),
                         NULL);

        if(fQIJO)
        {
            fQIJO = ::QueryInformationJobObject(
                         m_hJob,
                         JobObjectExtendedLimitInformation,
                         &joeli,
                         sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
                         NULL);
        }

        if(!fQIJO)
        {
            _ASSERT(0);
            hr = WBEM_E_FAILED;
        }
        else
        {                                                           
            try // CVARIANT can throw
            {
                // Get all the requested values...
                if(dwReqProps & PROP_TotalUserTime)
                {
                    ULONGLONG llTotalUserTime = (ULONGLONG)jobaioai.BasicInfo.TotalUserTime.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_TotalUserTime, 
                                     new CVARIANT(llTotalUserTime)));
                }                      

                if(dwReqProps & PROP_TotalKernelTime)
                {
                    ULONGLONG llTotalKernelTime = (ULONGLONG)jobaioai.BasicInfo.TotalKernelTime.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_TotalKernelTime, 
                                     new CVARIANT(llTotalKernelTime)));
                }

                if(dwReqProps & PROP_ThisPeriodTotalUserTime)
                {
                    ULONGLONG llThisPeriodTotalUserTime = (ULONGLONG)jobaioai.BasicInfo.ThisPeriodTotalUserTime.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_ThisPeriodTotalUserTime, 
                                     new CVARIANT(llThisPeriodTotalUserTime)));
                }

                if(dwReqProps & PROP_ThisPeriodTotalKernelTime)
                {
                    ULONGLONG llThisPeriodTotalKernelTime = (ULONGLONG)jobaioai.BasicInfo.ThisPeriodTotalKernelTime.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_ThisPeriodTotalKernelTime, 
                                     new CVARIANT(llThisPeriodTotalKernelTime)));
                }

                if(dwReqProps & PROP_TotalPageFaultCount)
                {
                    DWORD dwTotalPageFaultCount = jobaioai.BasicInfo.TotalPageFaultCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_TotalPageFaultCount, 
                                     new CVARIANT(dwTotalPageFaultCount)));
                }

                if(dwReqProps & PROP_TotalProcesses)
                {
                    DWORD dwTotalProcesses = jobaioai.BasicInfo.TotalProcesses;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_TotalProcesses, 
                                     new CVARIANT(dwTotalProcesses)));
                }

                if(dwReqProps & PROP_ActiveProcesses)
                {
                    DWORD dwActiveProcesses = jobaioai.BasicInfo.ActiveProcesses;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_ActiveProcesses, 
                                     new CVARIANT(dwActiveProcesses)));
                }

                if(dwReqProps & PROP_TotalTerminatedProcesses)
                {
                    DWORD dwTotalTerminatedProcesses = jobaioai.BasicInfo.TotalTerminatedProcesses;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_TotalTerminatedProcesses, 
                                     new CVARIANT(dwTotalTerminatedProcesses)));
                }

                if(dwReqProps & PROP_ReadOperationCount)
                {
                    ULONGLONG ullReadOperationCount = jobaioai.IoInfo.ReadOperationCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_ReadOperationCount, 
                                     new CVARIANT(ullReadOperationCount)));
                }

                if(dwReqProps & PROP_WriteOperationCount)
                {
                    ULONGLONG ullWriteOperationCount = jobaioai.IoInfo.WriteOperationCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_WriteOperationCount, 
                                     new CVARIANT(ullWriteOperationCount)));
                }

                if(dwReqProps & PROP_OtherOperationCount)
                {
                    ULONGLONG ullOtherOperationCount = jobaioai.IoInfo.OtherOperationCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_OtherOperationCount, 
                                     new CVARIANT(ullOtherOperationCount)));
                }

                if(dwReqProps & PROP_ReadTransferCount)
                {
                    ULONGLONG ullReadTransferCount = jobaioai.IoInfo.ReadTransferCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_ReadTransferCount, 
                                     new CVARIANT(ullReadTransferCount)));
                }

                if(dwReqProps & PROP_WriteTransferCount)
                {
                    ULONGLONG ullWriteTransferCount = jobaioai.IoInfo.WriteTransferCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_WriteTransferCount, 
                                     new CVARIANT(ullWriteTransferCount)));
                }

                if(dwReqProps & PROP_OtherTransferCount)
                {
                    ULONGLONG ullOtherTransferCount = jobaioai.IoInfo.OtherTransferCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_OtherTransferCount, 
                                     new CVARIANT(ullOtherTransferCount)));
                }

                if(dwReqProps & PROP_PeakProcessMemoryUsed)
                {
                    DWORD dwPeakProcessMemoryUsed = joeli.PeakProcessMemoryUsed;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_PeakProcessMemoryUsed, 
                                     new CVARIANT(dwPeakProcessMemoryUsed)));
                }

                if(dwReqProps & PROP_PeakJobMemoryUsed)
                {
                    DWORD dwPeakJobMemoryUsed = joeli.PeakJobMemoryUsed;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_PeakJobMemoryUsed, 
                                     new CVARIANT(dwPeakJobMemoryUsed)));
                }
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }                                            
    }
    
    return hr;
}



HRESULT CJobObjIOActgProps::LoadPropertyValues(
        IWbemClassObject* pIWCO)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(!pIWCO) return E_POINTER;

    hr = CObjProps::LoadPropertyValues(
             g_rgJobObjIOActgPropNames,
             pIWCO);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\iproute\inc\cippersistedrtble.h ===
/******************************************************************

   CIPPersistedRTble.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _CIPPersistedRTble_H_
#define _CIPPersistedRTble_H_

#define PROVIDER_NAME_CIPPERSISTEDROUTETABLE L"Win32_IP4PersistedRouteTable"

class CIPPersistedRouteTable : public Provider
{
private:

protected:

		HRESULT ExecMethod (

			const CInstance &Instance,
			const BSTR bstrMethodName,
			CInstance *pInParams,
			CInstance *pOutParams,
			long lFlags
		);

        // Writing Functions
        //============================

		HRESULT DeleteInstance (

			const CInstance &Instance,
			long lFlags
		);

		HRESULT CIPPersistedRouteTable :: PutInstance  (

			const CInstance &Instance,
			long lFlags
		);

        // Reading Functions
        //============================

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags = 0L
		) ;


        // Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================
		HRESULT CheckParameters (

			const CInstance &a_Instance ,
			CHString &a_ValueName
		);

		BOOL CIPPersistedRouteTable :: Parse (

			LPWSTR a_InStr ,
			CHString &a_Dest ,
			CHString &a_Mask ,
			CHString &a_NextHop ,
			long &a_Metric
		);

		void SetInheritedProperties (

			LPCWSTR a_dest ,
			LPCWSTR a_gateway ,
			LPCWSTR a_mask ,
			long a_metric ,
			CInstance &a_Instance
		) ;

public:

        // Constructor/destructor
        //=======================

        CIPPersistedRouteTable (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CIPPersistedRouteTable () ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\iproute\inc\ciproutetable.h ===
/******************************************************************

   CIPRouteTable.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _CIPRouteTable_H_
#define _CIPRouteTable_H_

#define PROVIDER_NAME_CIPROUTETABLE L"Win32_IP4RouteTable"


class CIPRouteTable : public Provider , public QueryPreprocessor 
{
private:
        // All data members for CIPRouteTable should be included here.
	CInstance *m_ClassCInst;
	CRITICAL_SECTION m_CS;

	NTSTATUS DeleteInformation_IpRouteInfo ( 

		HANDLE a_StackHandle , 
		HANDLE a_CompleteEventHandle ,
		IPRouteEntry &a_RouteEntry 
	) ;

	NTSTATUS SetInformation_IpRouteInfo ( 

		HANDLE a_StackHandle , 
		HANDLE a_CompleteEventHandle ,
		IPRouteEntry &a_RouteEntry 
	) ;

	HRESULT CheckParameters ( 

		const CInstance &a_Instance ,
		IPRouteEntry &a_RouteEntry 
	) ;

	HRESULT QueryInformation_GetRouteEntry ( 

		const ProvIpAddressType &a_DestinationIpAddress ,
		const ProvIpAddressType &a_NextHopIpAddress ,
		IPRouteEntry &a_RouteEntry 
	) ;

	NTSTATUS QueryInformation_IpRouteInfo ( 

		HANDLE a_StackHandle , 
		HANDLE a_CompleteEventHandle ,
		ulong &a_RouteTableSize ,
		IPRouteEntry *&a_InformationBlock 
	) ;
 
	HRESULT QueryInformation_IpSnmpInfo ( 

		HANDLE a_StackHandle , 
		HANDLE a_CompleteEventHandle ,
		IPSNMPInfo &a_Information 
	) ;

	NTSTATUS OpenQuerySource ( 

		HANDLE &a_StackHandle , 
		HANDLE &a_CompleteEventHandle
	) ;

	NTSTATUS OpenSetSource ( 

		HANDLE &a_StackHandle , 
		HANDLE &a_CompleteEventHandle
	) ;

	void SetInheritedProperties (

		LPCWSTR a_dest ,
		LPCWSTR a_gateway ,
		LPCWSTR a_mask ,
		CInstance &a_Instance
	) ;

private:


	QueryPreprocessor :: QuadState Compare ( 

		wchar_t *a_Operand1 , 
		wchar_t *a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState Compare ( 

		LONG a_Operand1 , 
		LONG a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState CompareString ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

	QueryPreprocessor :: QuadState CompareInteger ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

protected:

        // Reading Functions
        //============================

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags = 0L
		) ;

        HRESULT ExecQuery ( 

			MethodContext *pMethodContext, 
			CFrameworkQuery& Query, 
			long lFlags = 0L
		) ;

        HRESULT RangeQuery ( 

			MethodContext *pMethodContext, 
			PartitionSet &a_PartitionSet ,
			long lFlags = 0L
		) ;

        // Writing Functions
        //============================

        HRESULT PutInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;

        HRESULT DeleteInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;

        // Method Function

        HRESULT ExecMethod ( 

			const CInstance& Instance,
            const BSTR bstrMethodName,
            CInstance *pInParams,
            CInstance *pOutParams,
            long lFlags = 0L
		) ;

		WmiTreeNode *AllocTypeNode ( 

			void *a_Context ,
			BSTR a_PropertyName , 
			VARIANT &a_Variant , 
			WmiValueNode :: WmiValueFunction a_PropertyFunction ,
			WmiValueNode :: WmiValueFunction a_ConstantFunction ,
			WmiTreeNode *a_Parent 
		) ;

		QuadState InvariantEvaluate ( 

			void *a_Context ,
			WmiTreeNode *a_Operator ,
			WmiTreeNode *a_Operand 
		) ;

		WmiRangeNode *AllocInfiniteRangeNode (

			void *a_Context ,
			BSTR a_PropertyName 
		) ;

		HRESULT GetClassObject ( CInstance *&a_ClassObject, MethodContext *pContext ) ;

		virtual DWORD GetPriority ( BSTR a_PropertyName ) ;

        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

public:

        // Constructor/destructor
        //=======================

        CIPRouteTable (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CIPRouteTable () ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjlimitinfoprops.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjLimitInfoProps.cpp

//#define _WIN32_WINNT 0x0500 



#include "precomp.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include <vector>
#include "helpers.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjLimitInfoProps.h"
#include <crtdbg.h>


//*****************************************************************************
// BEGIN: Declaration of Win32_JobObjectLimitInfo class properties.
//*****************************************************************************
// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE JOB_OBJ_PROPS ENUMERATION DECLARED
// IN CJobObjProps.h !!!
LPCWSTR g_rgJobObjLimitInfoPropNames[] = 
{
    { L"SettingID" },
    { L"PerProcessUserTimeLimit" },             
    { L"PerJobUserTimeLimit" },           
    { L"LimitFlags" },   
    { L"MinimumWorkingSetSize" }, 
    { L"MaximumWorkingSetSize" },       
    { L"ActiveProcessLimit" },            
    { L"Affinity" },           
    { L"PriorityClass" },  
    { L"SchedulingClass" },        
    { L"ProcessMemoryLimit" },       
    { L"JobMemoryLimit" }       
};
//*****************************************************************************
// END: Declaration of Win32_JobObjectLimitInfo class properties.
//*****************************************************************************



CJobObjLimitInfoProps::CJobObjLimitInfoProps(CHString& chstrNamespace)
  : CObjProps(chstrNamespace)
{
}


CJobObjLimitInfoProps::CJobObjLimitInfoProps(
        HANDLE hJob,
        CHString& chstrNamespace)
  : CObjProps(chstrNamespace),
    m_hJob(hJob)
{
}

CJobObjLimitInfoProps::~CJobObjLimitInfoProps()
{
}


// Clients call this to establish which properties
// were requested.  This function calls a base class
// helper, which calls our CheckProps function.  
// The base class helper finally stores the result
// in the base class member m_dwReqProps.
HRESULT CJobObjLimitInfoProps::GetWhichPropsReq(
    CFrameworkQuery& cfwq)
{
    HRESULT hr = S_OK;

    // Call base class version for help.
    // Base class version will call our
    // CheckProps function.
    hr = CObjProps::GetWhichPropsReq(
             cfwq,
             CheckProps);

    return hr;
}


DWORD CJobObjLimitInfoProps::CheckProps(
    CFrameworkQuery& Query)
{
    DWORD  dwReqProps = PROP_NONE_REQUIRED;
    // Get the requested properties for this
    // specific object...
    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_ID])) 
        dwReqProps |= PROP_JOLimitInfoID;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_PerProcessUserTimeLimit])) 
        dwReqProps |= PROP_PerProcessUserTimeLimit;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_PerJobUserTimeLimit])) 
        dwReqProps |= PROP_PerJobUserTimeLimit;
    
    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_LimitFlags])) 
        dwReqProps |= PROP_LimitFlags;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_MinimumWorkingSetSize])) 
        dwReqProps |= PROP_MinimumWorkingSetSize;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_MaximumWorkingSetSize])) 
        dwReqProps |= PROP_MaximumWorkingSetSize;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_ActiveProcessLimit])) 
        dwReqProps |= PROP_ActiveProcessLimit;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_Affinity])) 
        dwReqProps |= PROP_Affinity;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_PriorityClass])) 
        dwReqProps |= PROP_PriorityClass;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_SchedulingClass])) 
        dwReqProps |= PROP_SchedulingClass;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_ProcessMemoryLimit])) 
        dwReqProps |= PROP_ProcessMemoryLimit;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_JobMemoryLimit])) 
        dwReqProps |= PROP_JobMemoryLimit;


    return dwReqProps;
}


void CJobObjLimitInfoProps::SetHandle(
    const HANDLE hJob)
{
    m_hJob = hJob;
}

HANDLE& CJobObjLimitInfoProps::GetHandle()
{
    _ASSERT(m_hJob);
    return m_hJob;
}

// Sets the key properties from the ObjectPath.
HRESULT CJobObjLimitInfoProps::SetKeysFromPath(
    const BSTR ObjectPath, 
    IWbemContext __RPC_FAR *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This array contains the key field names
    CHStringArray rgchstrKeys;
    rgchstrKeys.Add(g_rgJobObjLimitInfoPropNames[JOLMTPROP_ID]);
    
    // This array contains the index numbers 
    // in m_PropMap corresponding to the keys.
    short sKeyNum[1];
    sKeyNum[0] = JOLMTPROP_ID;

    hr = CObjProps::SetKeysFromPath(
             ObjectPath,                                       
             pCtx,
             IDS_Win32_NamedJobObjectLimitSetting,
             rgchstrKeys,
             sKeyNum);

    return hr;
}


// Sets the key property from in supplied
// parameter.
HRESULT CJobObjLimitInfoProps::SetKeysDirect(
    std::vector<CVARIANT>& vecvKeys)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(vecvKeys.size() == 1)
    {
        short sKeyNum[1];
        sKeyNum[0] = JOLMTPROP_ID;

        hr = CObjProps::SetKeysDirect(
                 vecvKeys,
                 sKeyNum);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}


// Sets the non-key properties.  Only those
// properties requested are set (as determined
// by base class member m_dwReqProps).
HRESULT CJobObjLimitInfoProps::SetNonKeyReqProps()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwReqProps = GetReqProps();
    _ASSERT(m_hJob);
    if(!m_hJob) return WBEM_E_INVALID_PARAMETER;

    // Because all the properties of this class
    // come from the same underlying win32 job
    // object structure, we only need to get that
    // structure one time.  We only need to get
    // it at all if at least one non-key property
    // was requested.
    if(dwReqProps != PROP_NONE_REQUIRED)
    {
        // Get the value from the underlying JO:
        JOBOBJECT_EXTENDED_LIMIT_INFORMATION joeli;

        BOOL fQIJO = ::QueryInformationJobObject(
                         m_hJob,
                         JobObjectExtendedLimitInformation,
                         &joeli,
                         sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
                         NULL);

        if(!fQIJO)
        {
            _ASSERT(0);
            hr = WBEM_E_FAILED;
        }
        else
        {                                                           
            try // CVARIANT can throw
            {
                // Get all the reequested values...
                if(dwReqProps & PROP_PerProcessUserTimeLimit)             
                {
                    ULONGLONG llPerProcessUserTimeLimit = (ULONGLONG)joeli.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_PerProcessUserTimeLimit, 
                                     new CVARIANT(llPerProcessUserTimeLimit)));
                }                      

                if(dwReqProps & PROP_PerJobUserTimeLimit)
                {
                    ULONGLONG llPerJobUserTimeLimit = (ULONGLONG)joeli.BasicLimitInformation.PerJobUserTimeLimit.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_PerJobUserTimeLimit, 
                                     new CVARIANT(llPerJobUserTimeLimit)));
                }

                if(dwReqProps & PROP_LimitFlags)
                {
                    DWORD dwLimitFlags = joeli.BasicLimitInformation.LimitFlags;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_LimitFlags, 
                                     new CVARIANT(dwLimitFlags)));
                }

                if(dwReqProps & PROP_MinimumWorkingSetSize)
                {
                    DWORD dwMinimumWorkingSetSize = joeli.BasicLimitInformation.MinimumWorkingSetSize;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_MinimumWorkingSetSize, 
                                     new CVARIANT(dwMinimumWorkingSetSize)));
                }

                if(dwReqProps & PROP_MaximumWorkingSetSize)
                {
                    DWORD dwMaximumWorkingSetSize = joeli.BasicLimitInformation.MaximumWorkingSetSize;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_MaximumWorkingSetSize, 
                                     new CVARIANT(dwMaximumWorkingSetSize)));
                }

                if(dwReqProps & PROP_ActiveProcessLimit)
                {
                    DWORD dwActiveProcessLimit = joeli.BasicLimitInformation.ActiveProcessLimit;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_ActiveProcessLimit, 
                                     new CVARIANT(dwActiveProcessLimit)));
                }

                if(dwReqProps & PROP_Affinity)
                {
                    DWORD dwAffinity = joeli.BasicLimitInformation.Affinity;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_Affinity, 
                                     new CVARIANT(dwAffinity)));
                }

                if(dwReqProps & PROP_PriorityClass)
                {
                    DWORD dwPriorityClass = joeli.BasicLimitInformation.PriorityClass;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_PriorityClass, 
                                     new CVARIANT(dwPriorityClass)));
                }

                if(dwReqProps & PROP_SchedulingClass)
                {
                    DWORD dwSchedulingClass = joeli.BasicLimitInformation.SchedulingClass;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_SchedulingClass, 
                                     new CVARIANT(dwSchedulingClass)));
                }

                if(dwReqProps & PROP_ProcessMemoryLimit)
                {
                    DWORD dwProcessMemoryLimit = joeli.ProcessMemoryLimit ;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_ProcessMemoryLimit, 
                                     new CVARIANT(dwProcessMemoryLimit)));
                }

                if(dwReqProps & PROP_JobMemoryLimit)
                {
                    DWORD dwJobMemoryLimit = joeli.JobMemoryLimit ;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_JobMemoryLimit, 
                                     new CVARIANT(dwJobMemoryLimit)));
                }
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }                                            
    }
    
    return hr;
}


// Used by PutInstance to write out properties.
HRESULT CJobObjLimitInfoProps::SetWin32JOLimitInfoProps(
        IWbemClassObject __RPC_FAR *pInst)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _ASSERT(pInst);
    if(!pInst) return WBEM_E_INVALID_PARAMETER;

    // Go through the instance and extract all
    // specified values into the win32 structure.
    // If a value was not specified, set it to zero.
    CVARIANT v;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION joeli;
    ::ZeroMemory(&joeli, sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION));

    hr = pInst->Get(
             g_rgJobObjLimitInfoPropNames[JOLMTPROP_PerProcessUserTimeLimit],
             0,
             &v,
             NULL, 
             NULL);

    if(SUCCEEDED(hr))
    {
        (V_VT(&v) == VT_BSTR) ? 
            joeli.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart = _wtoi64(V_BSTR(&v)) :
            joeli.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart = 0;
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_PerJobUserTimeLimit],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_BSTR) ? 
                joeli.BasicLimitInformation.PerJobUserTimeLimit.QuadPart = _wtoi64(V_BSTR(&v)) :
                joeli.BasicLimitInformation.PerJobUserTimeLimit.QuadPart = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_LimitFlags],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.LimitFlags = V_I4(&v) :
                joeli.BasicLimitInformation.LimitFlags = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_MinimumWorkingSetSize],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.MinimumWorkingSetSize = V_I4(&v) :
                joeli.BasicLimitInformation.MinimumWorkingSetSize = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_MaximumWorkingSetSize],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.MaximumWorkingSetSize = V_I4(&v) :
                joeli.BasicLimitInformation.MaximumWorkingSetSize = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_ActiveProcessLimit],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.ActiveProcessLimit = V_I4(&v) :
                joeli.BasicLimitInformation.ActiveProcessLimit = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_Affinity],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.Affinity = V_I4(&v) :
                joeli.BasicLimitInformation.Affinity = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_PriorityClass],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.PriorityClass = V_I4(&v) :
                joeli.BasicLimitInformation.PriorityClass = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_SchedulingClass],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.SchedulingClass = V_I4(&v) :
                joeli.BasicLimitInformation.SchedulingClass = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_ProcessMemoryLimit],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.ProcessMemoryLimit = V_I4(&v) :
                joeli.ProcessMemoryLimit = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_JobMemoryLimit],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.JobMemoryLimit = V_I4(&v) :
                joeli.JobMemoryLimit = 0;
        }
    }
    
    // Now write the info out...
    if(SUCCEEDED(hr))
    {
        if(!::SetInformationJobObject(
            m_hJob,
            JobObjectExtendedLimitInformation,
            &joeli,
            sizeof(joeli)))
        {
            hr = WinErrorToWBEMhResult(::GetLastError());
        }
    }

    return hr;
}




HRESULT CJobObjLimitInfoProps::LoadPropertyValues(
        IWbemClassObject* pIWCO)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(!pIWCO) return E_POINTER;

    hr = CObjProps::LoadPropertyValues(
             g_rgJobObjLimitInfoPropNames,
             pIWCO);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjprops.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProv.h

#pragma once


//*****************************************************************************
// BEGIN: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************
#define IDS_Win32_NamedJobObject L"Win32_NamedJobObject"
#define IDS_EventClass L"Win32_JobObjectEvent"
#define IDS_ExitCode L"ExitCode"
// Win32_NamedJobObjectEvent class properties:
#define IDS_Type L"Type"
#define IDS_JobObjectID L"JobObjectID"
#define IDS_PID L"PID"

#define PROP_ALL_REQUIRED                           0xFFFFFFFF
#define PROP_NONE_REQUIRED                          0x00000000
#define PROP_ID                                     0x00000001
#define PROP_JobObjectBasicUIRestrictions           0x00000002

// The following enum is used to reference
// into the array that follows it.  Hence,
// they must be kept in synch.
typedef enum tag_JOB_OBJ_PROPS
{
    JO_ID = 0,
    JO_JobObjectBasicUIRestrictions,
    // used to keep track of how many props we have:
    JO_JobObjectPropertyCount  

} JOB_OBJ_PROPS;

// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE ENUMERATION DECLARED ABOVE!!!
extern LPCWSTR g_rgJobObjPropNames[];
//*****************************************************************************
// END: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************



class CJobObjProps : public CObjProps
{
public:
    CJobObjProps() { m_hJob = NULL; }
    CJobObjProps(CHString& chstrNamespace);
    CJobObjProps(
        HANDLE hJob,
        CHString& chstrNamespace);


    virtual ~CJobObjProps();

    HRESULT SetKeysFromPath(
        const BSTR ObjectPath, 
        IWbemContext __RPC_FAR *pCtx);

    HRESULT SetKeysDirect(
        std::vector<CVARIANT>& vecvKeys);

    
    HRESULT GetWhichPropsReq(
        CFrameworkQuery& cfwq);

    HRESULT SetNonKeyReqProps();

    HRESULT LoadPropertyValues(
        IWbemClassObject* pIWCO);

    void SetHandle(const HANDLE hJob);
    HANDLE& GetHandle();

private:
    HANDLE m_hJob;

    // Member meant to only be called
    // by base class.
    static DWORD CheckProps(
        CFrameworkQuery& Query);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjlimitinfoprops.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjLimitInfoProps.h

#pragma once


//*****************************************************************************
// BEGIN: Declaration of Win32_JobObjectLimitInfo class properties.
//*****************************************************************************
#define IDS_Win32_NamedJobObjectLimitSetting L"Win32_NamedJobObjectLimitSetting"

#define PROP_ALL_REQUIRED                           0xFFFFFFFF
#define PROP_NONE_REQUIRED                          0x00000000
#define PROP_JOLimitInfoID                          0x00000001
#define PROP_PerProcessUserTimeLimit                0x00000002
#define PROP_PerJobUserTimeLimit                    0x00000004
#define PROP_LimitFlags                             0x00000008
#define PROP_MinimumWorkingSetSize                  0x00000010
#define PROP_MaximumWorkingSetSize                  0x00000020
#define PROP_ActiveProcessLimit                     0x00000040
#define PROP_Affinity                               0x00000080
#define PROP_PriorityClass                          0x00000100
#define PROP_SchedulingClass                        0x00000200
#define PROP_ProcessMemoryLimit                     0x00000400
#define PROP_JobMemoryLimit                         0x00000800


// The following enum is used to reference
// into the array that follows it.  Hence,
// they must be kept in synch.
typedef enum tag_JOB_OBJ_LIMIT_INFO_PROPS
{
    JOLMTPROP_ID = 0,
    JOLMTPROP_PerProcessUserTimeLimit,
    JOLMTPROP_PerJobUserTimeLimit,
    JOLMTPROP_LimitFlags,    
    JOLMTPROP_MinimumWorkingSetSize,  
    JOLMTPROP_MaximumWorkingSetSize,        
    JOLMTPROP_ActiveProcessLimit,             
    JOLMTPROP_Affinity,            
    JOLMTPROP_PriorityClass,   
    JOLMTPROP_SchedulingClass,         
    JOLMTPROP_ProcessMemoryLimit,        
    JOLMTPROP_JobMemoryLimit,        

    // used to keep track of how many props we have:
    JOIOACTGPROP_JobObjLimitInfoPropertyCount  

} JOB_OBJ_LIMIT_INFO_PROPS;

// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE ENUMERATION DECLARED ABOVE!!!
extern LPCWSTR g_rgJobObjLimitInfoPropNames[];
//*****************************************************************************
// END: Declaration of Win32_JobObjectLimitInfo class properties.
//*****************************************************************************



class CJobObjLimitInfoProps : public CObjProps
{
public:
    CJobObjLimitInfoProps() { m_hJob = NULL; }
    CJobObjLimitInfoProps(CHString& chstrNamespace);
    CJobObjLimitInfoProps(
        HANDLE hJob,
        CHString& chstrNamespace);


    virtual ~CJobObjLimitInfoProps();

    HRESULT SetKeysFromPath(
        const BSTR ObjectPath, 
        IWbemContext __RPC_FAR *pCtx);

    HRESULT SetKeysDirect(
        std::vector<CVARIANT>& vecvKeys);

    
    HRESULT GetWhichPropsReq(
        CFrameworkQuery& cfwq);

    HRESULT SetNonKeyReqProps();

    HRESULT LoadPropertyValues(
        IWbemClassObject* pIWCO);

    void SetHandle(const HANDLE hJob);
    HANDLE& GetHandle();

    HRESULT SetWin32JOLimitInfoProps(
        IWbemClassObject __RPC_FAR *pInst);


private:
    HANDLE m_hJob;

    // Member meant to only be called
    // by base class.
    static DWORD CheckProps(
        CFrameworkQuery& Query);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjprops.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProps.cpp

//#define _WIN32_WINNT 0x0500 



#include "precomp.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include <vector>
#include "helpers.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjProps.h"
#include <crtdbg.h>


//*****************************************************************************
// BEGIN: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************
// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE JOB_OBJ_PROPS ENUMERATION DECLARED
// IN CJobObjProps.h !!!
LPCWSTR g_rgJobObjPropNames[] = 
{
    { L"CollectionID" },
    { L"BasicUIRestrictions" }
};
//*****************************************************************************
// END: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************



CJobObjProps::CJobObjProps(CHString& chstrNamespace)
  : CObjProps(chstrNamespace)
{
}


CJobObjProps::CJobObjProps(
        HANDLE hJob,
        CHString& chstrNamespace)
  : CObjProps(chstrNamespace),
    m_hJob(hJob)
{
}

CJobObjProps::~CJobObjProps()
{
}


// Clients call this to establish which properties
// were requested.  This function calls a base class
// helper, which calls our CheckProps function.  
// The base class helper finally stores the result
// in the base class member m_dwReqProps.
HRESULT CJobObjProps::GetWhichPropsReq(
    CFrameworkQuery& cfwq)
{
    HRESULT hr = S_OK;

    // Call base class version for help.
    // Base class version will call our
    // CheckProps function.
    hr = CObjProps::GetWhichPropsReq(
             cfwq,
             CheckProps);

    return hr;
}


DWORD CJobObjProps::CheckProps(
    CFrameworkQuery& Query)
{
    DWORD  dwReqProps = PROP_NONE_REQUIRED;
    // Get the requested properties for this
    // specific object...
    if (Query.IsPropertyRequired(g_rgJobObjPropNames[JO_ID])) 
        dwReqProps |= PROP_ID;
    if (Query.IsPropertyRequired(g_rgJobObjPropNames[JO_JobObjectBasicUIRestrictions])) 
        dwReqProps |= PROP_JobObjectBasicUIRestrictions;

    return dwReqProps;
}


void CJobObjProps::SetHandle(
    const HANDLE hJob)
{
    m_hJob = hJob;
}

HANDLE& CJobObjProps::GetHandle()
{
    _ASSERT(m_hJob);
    return m_hJob;
}

// Sets the key properties from the ObjectPath.
HRESULT CJobObjProps::SetKeysFromPath(
    const BSTR ObjectPath, 
    IWbemContext __RPC_FAR *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This array contains the key field names
    CHStringArray rgchstrKeys;
    rgchstrKeys.Add(g_rgJobObjPropNames[JO_ID]);
    
    // This array contains the index numbers 
    // in m_PropMap corresponding to the keys.
    short sKeyNum[1];
    sKeyNum[0] = JO_ID;

    hr = CObjProps::SetKeysFromPath(
             ObjectPath,                                       
             pCtx,
             IDS_Win32_NamedJobObject,
             rgchstrKeys,
             sKeyNum);

    return hr;
}


// Sets the key property from in supplied
// parameter.
HRESULT CJobObjProps::SetKeysDirect(
    std::vector<CVARIANT>& vecvKeys)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(vecvKeys.size() == 1)
    {
        short sKeyNum[1];
        sKeyNum[0] = JO_ID;

        hr = CObjProps::SetKeysDirect(
                 vecvKeys,
                 sKeyNum);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}


// Sets the non-key properties.  Only those
// properties requested are set (as determined
// by base class member m_dwReqProps).
HRESULT CJobObjProps::SetNonKeyReqProps()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwReqProps = GetReqProps();

    if(dwReqProps & PROP_JobObjectBasicUIRestrictions)
    {
        // Get the value from the underlying JO:
        JOBOBJECT_BASIC_UI_RESTRICTIONS jouir;
        BOOL fQIJO = ::QueryInformationJobObject(
                         m_hJob,
                         JobObjectBasicUIRestrictions,
                         &jouir,
                         sizeof(JOBOBJECT_BASIC_UI_RESTRICTIONS),
                         NULL);

        if(!fQIJO)
        {
            hr = WBEM_E_FAILED;
        }
        else
        {
            try // CVARIANT can throw...
            {
                // Store the value...
                m_PropMap.insert(SHORT2PVARIANT::value_type(
                                    JO_JobObjectBasicUIRestrictions, 
                                    new CVARIANT(jouir.UIRestrictionsClass)));
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }                                            
    }
    
    return hr;
}



HRESULT CJobObjProps::LoadPropertyValues(
        IWbemClassObject* pIWCO)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(!pIWCO) return E_POINTER;

    hr = CObjProps::LoadPropertyValues(
             g_rgJobObjPropNames,
             pIWCO);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cobjprops.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProv.h


#include "precomp.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "helpers.h"
#include "globals.h"
#include <map>
#include <vector>
#include "CVARIANT.h"
#include "CObjProps.h"
#include <crtdbg.h>

#ifndef PROP_NONE_REQUIRED
#define PROP_NONE_REQUIRED  0x00000000
#endif

CObjProps::CObjProps(CHString& chstrNamespace)
{
    m_chstrNamespace = chstrNamespace;
}



CObjProps::~CObjProps()
{
    // Clean the property map.
    ClearProps();
}


void CObjProps::ClearProps()
{
    // Clean the property map.
    SHORT2PVARIANT::iterator theIterator;

    for(theIterator = m_PropMap.begin();
        theIterator != m_PropMap.end();
        theIterator++)
    {
        if(theIterator->second != NULL)
        {
            delete theIterator->second;
        }
    }
    m_PropMap.clear();
}



// Accessors to the requested properties member.
void CObjProps::SetReqProps(DWORD dwProps)
{
    m_dwReqProps = dwProps;
}

DWORD CObjProps::GetReqProps()
{
    return m_dwReqProps;
}



//***************************************************************************
//
//  Function:   SetKeysFromPath
//
//  called by the DeleteInstance and GetObject in order to load a
//  IWbemClassObject* with the key values in an object path.
//
//  Inputs:     IWbemClassObject*       pInstance - Instance to store
//                                      key values in.
//              ParsedObjectPath*       pParsedObjectPath - All the news
//                                      thats fit to print. 
//              rgKeyNameArray          An array of CHStrings containing
//                                      the names of the key properties.
//              sKeyNum                 An array of the key property 
//                                      reference numbers.
//
//  Outputs:    
//
//  Return:     HRESULT                 Success/Failure
//
//  Comments:  The number of elements in rgKeyNameArray and sKeyNum must be
//             the same.
//
//***************************************************************************
HRESULT CObjProps::SetKeysFromPath(
    const BSTR ObjectPath, 
    IWbemContext __RPC_FAR *pCtx,
    LPCWSTR wstrClassName,
    CHStringArray& rgKeyNameArray,
    short sKeyNum[])
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _ASSERT(sKeyNum);

    CObjectPathParser objpathParser;
    ParsedObjectPath* pParsedPath = NULL;

    try
    {
        int iParseResult = objpathParser.Parse(
                 ObjectPath,  
                 &pParsedPath);

        if(CObjectPathParser::NoError == iParseResult)
        {
            CFrameworkQueryEx cfwqe;
            cfwqe.Init(
                    (ParsedObjectPath*) pParsedPath, 
                    (IWbemContext*) pCtx, 
                    wstrClassName, 
                    (CHString&) m_chstrNamespace);

            if(rgKeyNameArray.GetSize() == pParsedPath->m_dwNumKeys)
            {
                // populate key props...
                for (DWORD i = 0; 
                     SUCCEEDED(hr) && i < (pParsedPath->m_dwNumKeys); 
                     i++)
                {
                    if (pParsedPath->m_paKeys[i])
                    {
                        // If a name was specified in the form class.keyname=value
                        if (pParsedPath->m_paKeys[i]->m_pName != NULL) 
                        {
                            if(_wcsicmp(pParsedPath->m_paKeys[i]->m_pName, 
                                      rgKeyNameArray[i]) == 0)
                            {
                                // Store the value...
                                m_PropMap.insert(SHORT2PVARIANT::value_type(
                                    sKeyNum[i], 
                                    new CVARIANT(pParsedPath->m_paKeys[i]->m_vValue)));
                            }
                        } 
                        else 
                        {
                            // There is a special case that you can say class=value
                            // only one key allowed in the format.  Check the names 
                            // on the path
                            if (pParsedPath->m_dwNumKeys == 1) 
                            {
                                // Store the value...
                                m_PropMap.insert(SHORT2PVARIANT::value_type(
                                    sKeyNum[i], 
                                    new CVARIANT(pParsedPath->m_paKeys[i]->m_vValue)));
                            }
                            else
                            {
                                hr = WBEM_E_INVALID_OBJECT_PATH;
                                _ASSERT(0);  // somebody lied about the number 
                                                  // of keys or the datatype was wrong
                            }    
                        }
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OBJECT_PATH;
                        _ASSERT(0); // somebody lied about the number of keys!
                    }
                }
            }
            else
            {
                hr = WBEM_E_INVALID_OBJECT_PATH;
                _ASSERT(0); // somebody lied about the number of keys!
            }
        }
        else
        {
            hr = WBEM_E_INVALID_OBJECT_PATH;
            _ASSERT(0); 
        }

        if (pParsedPath)
        {
            objpathParser.Free( pParsedPath );
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
        if (pParsedPath)
        {
            objpathParser.Free( pParsedPath );
        }
    }
    catch(...)
    {
        if (pParsedPath)
        {
            objpathParser.Free( pParsedPath );
        }
        throw;
    }    

    return hr;
}


// Allows direct setting of key properties.
// Key property values are stored in vecvKeys.
// sKeyNum is an array of the key property
// positions in m_PropMap.  The elements of
// these two arrays map to each other (e.g., 
// the first element in vecvKeys should be
// associated with the first element in sKeyNum, 
// and so on).
HRESULT CObjProps::SetKeysDirect(
    std::vector<CVARIANT>& vecvKeys,
    short sKeyNum[])
{
    HRESULT hr = S_OK;
    UINT uiCount = vecvKeys.size();

    try // CVARIANT can throw and I want the error...
    {
        for (UINT u = 0; u < uiCount; u++)
        {
            // Store the value...
            m_PropMap.insert(SHORT2PVARIANT::value_type(
                                sKeyNum[u], 
                                new CVARIANT(vecvKeys[u])));
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}




HRESULT CObjProps::GetWhichPropsReq(
    CFrameworkQuery& cfwq,
    PFN_CHECK_PROPS pfnChk)
{
    // Get the requested properties for this
    // specific object via derived class fn...
    m_dwReqProps = pfnChk(cfwq);
    return WBEM_S_NO_ERROR;
}



// Loads all properties stored in this
// object into a new IWbemClassObject instance.
HRESULT CObjProps::LoadPropertyValues(
        LPCWSTR rgwstrPropNames[],
        IWbemClassObject* pIWCO)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(!pIWCO) return E_POINTER;

    SHORT2PVARIANT::iterator theIterator;

    // Our map will only contain entries for properties
    // that were set via SetNonKeyReqProps, which only 
    // set properties that were requested.
    try // CVARIANT can throw and I want the error...
    {
        for(theIterator = m_PropMap.begin();
            theIterator != m_PropMap.end() && SUCCEEDED(hr);
            theIterator++)
        {
            // Because DWORDS and ULONGLONGs are not
            // automation compatible types (although
            // they are valid CIM types!), we need
            // to handle those two differently.  Same
            // with the other types special cased below.
            LPCWSTR wstrFoo = rgwstrPropNames[theIterator->first];
            CVARIANT* pvFoo = theIterator->second;

            if(theIterator->second->GetType() == VT_UI4)
            {
                WCHAR wstrTmp[256] = { '\0' };
                _ultow(theIterator->second->GetDWORD(), wstrTmp, 10);
                CVARIANT vTmp(wstrTmp);
                hr = pIWCO->Put(
                         rgwstrPropNames[theIterator->first], 
                         0, 
                         &vTmp,
                         NULL);
            }
            else if(theIterator->second->GetType() == VT_UI8)
            {
                WCHAR wstrTmp[256] = { '\0' };
                _ui64tow(theIterator->second->GetULONGLONG(), wstrTmp, 10);
                CVARIANT vTmp(wstrTmp);
                hr = pIWCO->Put(
                         rgwstrPropNames[theIterator->first], 
                         0, 
                         &vTmp,
                         NULL);
            }
            else if(theIterator->second->GetType() == VT_I8)
            {
                WCHAR wstrTmp[256] = { '\0' };
                _i64tow(theIterator->second->GetLONGLONG(), wstrTmp, 10);
                CVARIANT vTmp(wstrTmp);
                hr = pIWCO->Put(
                         rgwstrPropNames[theIterator->first], 
                         0, 
                         &vTmp,
                         NULL);
            }
            else
            {  
                hr = pIWCO->Put(
                         rgwstrPropNames[theIterator->first], 
                         0, 
                         *(theIterator->second),
                         NULL);
            }   
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cobjprops.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProv.h

#pragma once


typedef std::map<short, CVARIANT* > SHORT2PVARIANT;

typedef DWORD (*PFN_CHECK_PROPS)(CFrameworkQuery&);




class CObjProps
{
public:
    CObjProps() {}
    CObjProps(CHString& chstrNamespace);
    virtual ~CObjProps();
    
    
    HRESULT SetKeysFromPath(
        const BSTR ObjectPath, 
        IWbemContext __RPC_FAR *pCtx,
        LPCWSTR wstrClassName,
        CHStringArray& rgKeyNameArray,
        short sKeyNum[]);

    HRESULT SetKeysDirect(
        std::vector<CVARIANT>& vecvKeys,
        short sKeyNum[]);

    void SetReqProps(DWORD dwProps);
    DWORD GetReqProps();

    void ClearProps();

protected:
    SHORT2PVARIANT m_PropMap;

    HRESULT GetWhichPropsReq(
        CFrameworkQuery& cfwq,
        PFN_CHECK_PROPS pfnChk);

    HRESULT LoadPropertyValues(
        LPCWSTR rgwstrPropNames[],
        IWbemClassObject* pIWCO);


private:
    DWORD m_dwReqProps;
    CHString m_chstrNamespace;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjseclimitinfoprops.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjSecLimitInfoProps.h

#pragma once


//*****************************************************************************
// BEGIN: Declaration of Win32_JobObjectSecLimitInfo class properties.
//*****************************************************************************
#define IDS_Win32_NamedJobObjectSecLimitSetting L"Win32_NamedJobObjectSecLimitSetting"
#define IDS_GroupCount                     L"GroupCount"
#define IDS_Groups                         L"Groups"
#define IDS_Privileges                     L"Privileges"
#define IDS_PrivilegeCount                 L"PrivilegeCount"
#define IDS_SID                            L"SID"
#define IDS_AccountName                    L"AccountName"
#define IDS_ReferencedDomainName           L"ReferencedDomainName"
#define IDS_Attributes                     L"Attributes"
#define IDS_LUID                           L"LUID"
#define IDS_Win32_TokenGroups              L"Win32_TokenGroups"
#define IDS_Win32_TokenPrivileges          L"Win32_TokenPrivileges"
#define IDS_Win32_SidAndAttributes         L"Win32_SidAndAttributes"
#define IDS_Win32_LUIDAndAttributes        L"Win32_LUIDAndAttributes"
#define IDS_Win32_Sid                      L"Win32_Sid"
#define IDS_Win32_LUID                     L"Win32_LUID"
#define IDS_HighPart                       L"HighPart"
#define IDS_LowPart                        L"LowPart"

#define PROP_ALL_REQUIRED                           0xFFFFFFFF
#define PROP_NONE_REQUIRED                          0x00000000
#define PROP_JOSecLimitInfoID                       0x00000001
#define PROP_SecurityLimitFlags                     0x00000002
#define PROP_SidsToDisable                          0x00000004
#define PROP_PrivilagesToDelete                     0x00000008
#define PROP_RestrictedSids                         0x00000010


// The following enum is used to reference
// into the array that follows it.  Hence,
// they must be kept in synch.
typedef enum tag_JOB_OBJ_SEC_LIMIT_INFO_PROPS
{
    JOSECLMTPROP_ID = 0,
    JOSECLMTPROP_SecurityLimitFlags,
    JOSECLMTPROP_SidsToDisable,    
    JOSECLMTPROP_PrivilegesToDelete,  
    JOSECLMTPROP_RestrictedSids,        

    // used to keep track of how many props we have:
    JOIOACTGPROP_JobObjSecLimitInfoPropertyCount  

} JOB_OBJ_SEC_LIMIT_INFO_PROPS;

// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE ENUMERATION DECLARED ABOVE!!!
extern LPCWSTR g_rgJobObjSecLimitInfoPropNames[];
//*****************************************************************************
// END: Declaration of Win32_JobObjectSecLimitInfo class properties.
//*****************************************************************************






class CJobObjSecLimitInfoProps : public CObjProps
{
public:
    CJobObjSecLimitInfoProps();

    CJobObjSecLimitInfoProps(CHString& chstrNamespace);
    CJobObjSecLimitInfoProps(
        HANDLE hJob,
        CHString& chstrNamespace);


    virtual ~CJobObjSecLimitInfoProps();

    HRESULT SetKeysFromPath(
        const BSTR ObjectPath, 
        IWbemContext __RPC_FAR *pCtx);

    HRESULT SetKeysDirect(
        std::vector<CVARIANT>& vecvKeys);

    
    HRESULT GetWhichPropsReq(
        CFrameworkQuery& cfwq);

    HRESULT SetNonKeyReqProps();

    HRESULT LoadPropertyValues(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);

    void SetHandle(const HANDLE hJob);
    HANDLE& GetHandle();

    HRESULT SetWin32JOSecLimitInfoProps(
        IWbemClassObject __RPC_FAR *pInst);


private:

    HANDLE m_hJob;
    
    // Because many of the security limit info
    // properties can't be directly represented
    // as a variant type, we don't use our
    // m_PropMap and other mechanisms for this
    // class.  Instead, we store the properties
    // in this member variable.
    PJOBOBJECT_SECURITY_LIMIT_INFORMATION  m_pjosli;


    // Helpers to set an outgoing instance...
    HRESULT SetInstanceFromJOSLI(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);    

    HRESULT SetInstanceSidsToDisable(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);

    HRESULT SetInstancePrivilegesToDelete(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);

    HRESULT SetInstanceRestrictedSids(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);

    HRESULT SetInstanceTokenGroups(
        IWbemClassObject* pWin32TokenGroups,
        PTOKEN_GROUPS ptg,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);

    HRESULT SetInstanceTokenPrivileges(
        IWbemClassObject* pWin32TokenPrivileges,
        PTOKEN_PRIVILEGES ptp,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);



    // Member meant to only be called
    // by base class.
    static DWORD CheckProps(
        CFrameworkQuery& Query);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cunknown.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CUnknown.cpp
#include "precomp.h"
#include <objidl.h>
#include <cominit.h>

#include <objbase.h>
#include <comdef.h>

#include "CUnknown.h"

#include "factory.h"


extern const char g_szTypeLibName[];

long CUnknown::s_cActiveComponents = 0L;

/*****************************************************************************/
// Constructor
/*****************************************************************************/
CUnknown::CUnknown() 
  : m_cRef(1),
    m_hEventThread(NULL),
    m_eStatus(Pending)
{ 
	InterlockedIncrement(&s_cActiveComponents); 
}

/*****************************************************************************/
// Destructor
/*****************************************************************************/
CUnknown::~CUnknown() 
{ 
	InterlockedDecrement(&s_cActiveComponents); 
    if(m_hEventThread)
    {
        ::CloseHandle(m_hEventThread);
    }
}

/*****************************************************************************/
// FinalRelease - called by Release before it deletes the component
/*****************************************************************************/
void CUnknown::FinalRelease()
{
	// If we have an event thread...
    if(m_eStatus != Pending)
    {
        // Let the event thread know that it can stop...
        m_eStatus = PendingStop;
        // Hold here until the event thread has stopped...
        DWORD dwWait = ::WaitForSingleObject(
            m_hEventThread,
            1000 * 60 * 20);  

        if(dwWait == WAIT_TIMEOUT)
        {
            // Something is most likely wrong....
            // If it takes 20 minutes, we will terminate
            // the thread, even though it is understood
            // that TerminateThread will leak some 
            // resources, as that is better than
            // leaving the thread running infinitely.
            ::TerminateThread(
                m_hEventThread,
                -1L);
        }
    }    
}

/*****************************************************************************/
// CUnknown default initialization
/*****************************************************************************/
STDMETHODIMP CUnknown::Init()
{    
	HRESULT hr = S_OK;


	return S_OK ;
}

/*****************************************************************************/
// IUnknown implementation
/*****************************************************************************/
STDMETHODIMP CUnknown::QueryInterface(const IID& iid, void** ppv)
{    
	HRESULT hr = S_OK;

    if(iid == IID_IUnknown)
	{
		*ppv = static_cast<IUnknown*>(this); 
	}
	else
	{
		*ppv = NULL;
		hr = E_NOINTERFACE;
	}
	if(SUCCEEDED(hr))
    {
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

	return hr;
}

STDMETHODIMP_(ULONG) CUnknown::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CUnknown::Release() 
{
    ULONG ulRet = 0L;
    InterlockedDecrement(&m_cRef);
    if (m_cRef == 0)
	{
		FinalRelease();
        delete this;
	}
    else
    {
        ulRet = m_cRef;
    }
	return ulRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjseclimitinfoprops.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjSecLimitInfoProps.cpp

//#define _WIN32_WINNT 0x0500 



#include "precomp.h"

#pragma warning( disable: 4154 )

#include <wbemprov.h>
#include "FRQueryEx.h"
#include <vector>
#include "helpers.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjSecLimitInfoProps.h"
#include <crtdbg.h>


//*****************************************************************************
// BEGIN: Declaration of Win32_JobObjectSecLimitInfo class properties.
//*****************************************************************************
// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE JOB_OBJ_PROPS ENUMERATION DECLARED
// IN CJobObjProps.h !!!
LPCWSTR g_rgJobObjSecLimitInfoPropNames[] = 
{
    { L"SettingID" },
    { L"SecurityLimitFlags" },             
    { L"SidsToDisable" },   
    { L"PrivilegesToDelete" }, 
    { L"RestrictedSids" }       
};
//*****************************************************************************
// END: Declaration of Win32_JobObjectSecLimitInfo class properties.
//*****************************************************************************

CJobObjSecLimitInfoProps::CJobObjSecLimitInfoProps() 
  : m_hJob(NULL),
    m_pjosli(NULL)
{
}

CJobObjSecLimitInfoProps::CJobObjSecLimitInfoProps(CHString& chstrNamespace)
  : CObjProps(chstrNamespace),
    m_hJob(NULL),
    m_pjosli(NULL)
{
}


CJobObjSecLimitInfoProps::CJobObjSecLimitInfoProps(
        HANDLE hJob,
        CHString& chstrNamespace)
  : CObjProps(chstrNamespace),
    m_hJob(hJob),
    m_pjosli(NULL)
{
}

CJobObjSecLimitInfoProps::~CJobObjSecLimitInfoProps()
{
    if(m_pjosli)
    {
        delete m_pjosli;
        m_pjosli = NULL;
    }
}


// Clients call this to establish which properties
// were requested.  This function calls a base class
// helper, which calls our CheckProps function.  
// The base class helper finally stores the result
// in the base class member m_dwReqProps.
HRESULT CJobObjSecLimitInfoProps::GetWhichPropsReq(
    CFrameworkQuery& cfwq)
{
    HRESULT hr = S_OK;

    // Call base class version for help.
    // Base class version will call our
    // CheckProps function.
    hr = CObjProps::GetWhichPropsReq(
             cfwq,
             CheckProps);

    return hr;
}


DWORD CJobObjSecLimitInfoProps::CheckProps(
    CFrameworkQuery& Query)
{
    DWORD  dwReqProps = PROP_NONE_REQUIRED;
    // Get the requested properties for this
    // specific object...
    if (Query.IsPropertyRequired(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_ID])) 
        dwReqProps |= PROP_JOSecLimitInfoID;

    if (Query.IsPropertyRequired(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_SecurityLimitFlags])) 
        dwReqProps |= PROP_SecurityLimitFlags;

    if (Query.IsPropertyRequired(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_SidsToDisable])) 
        dwReqProps |= PROP_SidsToDisable;

    if (Query.IsPropertyRequired(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_PrivilegesToDelete])) 
        dwReqProps |= PROP_PrivilagesToDelete;

    if (Query.IsPropertyRequired(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_RestrictedSids])) 
        dwReqProps |= PROP_RestrictedSids;

    return dwReqProps;
}


void CJobObjSecLimitInfoProps::SetHandle(
    const HANDLE hJob)
{
    m_hJob = hJob;
}

HANDLE& CJobObjSecLimitInfoProps::GetHandle()
{
    _ASSERT(m_hJob);
    return m_hJob;
}

// Sets the key properties from the ObjectPath.
HRESULT CJobObjSecLimitInfoProps::SetKeysFromPath(
    const BSTR ObjectPath, 
    IWbemContext __RPC_FAR *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This array contains the key field names
    CHStringArray rgchstrKeys;
    rgchstrKeys.Add(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_ID]);
    
    // This array contains the index numbers 
    // in m_PropMap corresponding to the keys.
    short sKeyNum[1];
    sKeyNum[0] = JOSECLMTPROP_ID;

    hr = CObjProps::SetKeysFromPath(
             ObjectPath,                                       
             pCtx,
             IDS_Win32_NamedJobObjectSecLimitSetting,
             rgchstrKeys,
             sKeyNum);

    return hr;
}


// Sets the key property from in supplied
// parameter.
HRESULT CJobObjSecLimitInfoProps::SetKeysDirect(
    std::vector<CVARIANT>& vecvKeys)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(vecvKeys.size() == 1)
    {
        short sKeyNum[1];
        sKeyNum[0] = JOSECLMTPROP_ID;

        hr = CObjProps::SetKeysDirect(
                 vecvKeys,
                 sKeyNum);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}


// Sets the non-key properties.  Only those
// properties requested are set (as determined
// by base class member m_dwReqProps).
HRESULT CJobObjSecLimitInfoProps::SetNonKeyReqProps()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwReqProps = GetReqProps();
    _ASSERT(m_hJob);
    if(!m_hJob) return WBEM_E_INVALID_PARAMETER;

    // Because all the properties of this class
    // come from the same underlying win32 job
    // object structure, we only need to get that
    // structure one time.  We only need to get
    // it at all if at least one non-key property
    // was requested.
    if(dwReqProps != PROP_NONE_REQUIRED)
    {
        // Get the value from the underlying JO:
        // This is a really flakey API when used
        // with a JobObjectSecurityLimitInformation,
        // as there is no way to get the size of
        // the buffer beforehand.  So we have to
        // allocate, see if it was enough, and if
        // not, reallocate!  We'll do this 10 times
        // at most, and if still not enough then bail.
        // Remember: new's throw on allocation
        // failure, hence not checking their allocation
        // below.
        PBYTE pbBuff = NULL;
        DWORD dwSize = 128L;
        BOOL fQIJO = FALSE;

        try
        {
            for(short s = 0;
                s < 10 && !fQIJO;
                s++)
            {
                pbBuff = new BYTE[dwSize];
                ZeroMemory(pbBuff, dwSize);

                fQIJO = ::QueryInformationJobObject(
                            m_hJob,
                            JobObjectSecurityLimitInformation,
                            pbBuff,
                            dwSize,
                            NULL);

                // Want to assign newly allocated
                // buffer to a place from which it
                // will be guarenteed to be cleaned 
                // up while we are inside this try
                // block.
                if(fQIJO)
                {
                    m_pjosli = (PJOBOBJECT_SECURITY_LIMIT_INFORMATION) pbBuff;
                }
                else
                {
                    delete pbBuff;
                    pbBuff = NULL;
                }

                dwSize = dwSize << 1;
            }
        }
        catch(...)
        {
            if(pbBuff)
            {
                delete pbBuff;
                pbBuff = NULL;
            }
            throw;
        }

        if(!fQIJO)
        {
            _ASSERT(0);
            hr = WBEM_E_FAILED;
        }
    }
    
    return hr;
}





HRESULT CJobObjSecLimitInfoProps::LoadPropertyValues(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(!pIWCO) return E_POINTER;

    // Load properties from the map...
    hr = CObjProps::LoadPropertyValues(
             g_rgJobObjSecLimitInfoPropNames,
             pIWCO);

    // Uses member josli and dwReqProps to
    // load properties to the instance.
    hr = SetInstanceFromJOSLI(
             pIWCO,
             pCtx,
             pNamespace);

    return hr;
}



//*****************************************************************************
//
// The following are a family of functions used to set information in a
// Win32_NamedJobObjectSecLimitSetting instance from a 
// JOBOBJECT_SECURITY_LIMIT_INFORMATION structure. Called by LoadPropertyValues.
//
//*****************************************************************************

HRESULT CJobObjSecLimitInfoProps::SetInstanceFromJOSLI(
    IWbemClassObject* pIWCO,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    // We expect, when this function is called,
    // that at least the member m_pjosli has been
    // set (via a call to SetNonKeyReqProps).
    // That function will have set the other
    // member variables (such as m_ptgSidsToDisable)
    // based on which properties were requested.
    //
    // Our job in this function is to populate
    // only those properties of the IWbemClassObject
    // (which will be handed back to CIMOM) that
    // the user requested.  We encapsulate this
    // work into helper fuctions for those properties
    // that are embedded objects.
    DWORD dwReqProps = GetReqProps();
    CVARIANT v;

    try // CVARIANT can throw and I want the error...
    {
        if(dwReqProps & PROP_SecurityLimitFlags)             
        {
            v.SetLONG((LONG)m_pjosli->SecurityLimitFlags);
            hr = pIWCO->Put(
                     g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_SecurityLimitFlags], 
                     0, 
                     &v,
                     NULL);
        }                      
    
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & PROP_SidsToDisable)
            {
                hr = SetInstanceSidsToDisable(
                         pIWCO,
                         pCtx,
                         pNamespace);
            }
        }

        if(SUCCEEDED(hr))
        {
            if(dwReqProps & PROP_PrivilagesToDelete)
            {
                hr = SetInstancePrivilegesToDelete(
                         pIWCO,
                         pCtx,
                         pNamespace);
            }
        }

        if(SUCCEEDED(hr))
        {
            if(dwReqProps & PROP_RestrictedSids)
            {
                hr = SetInstanceRestrictedSids(
                         pIWCO,
                         pCtx,
                         pNamespace);
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}



HRESULT CJobObjSecLimitInfoProps::SetInstanceSidsToDisable(
    IWbemClassObject* pIWCO,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If m_ptgSidsToDisable is not null,
    // Create a Win32_TokenGroups instance
    // and call a function to populate it.
    if(m_pjosli->SidsToDisable)
    {
        IWbemClassObjectPtr pWin32TokenGroups;
        hr = CreateInst(
                 pNamespace,
                 &pWin32TokenGroups,
                 _bstr_t(IDS_Win32_TokenGroups),
                 pCtx);
        
        if(SUCCEEDED(hr))
        {
            hr = SetInstanceTokenGroups(
                     pWin32TokenGroups,
                     m_pjosli->SidsToDisable,
                     pCtx,
                     pNamespace);
        }

        if(SUCCEEDED(hr))
        {
            try
            {
                CVARIANT v;
                v.SetUnknown(pWin32TokenGroups);
                hr = pIWCO->Put(
                         g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_SidsToDisable], 
                         0, 
                         &v,
                         NULL);
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }
    }     

    return hr;
}



HRESULT CJobObjSecLimitInfoProps::SetInstancePrivilegesToDelete(
    IWbemClassObject* pIWCO,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If m_ptpPrivilegesToDelete is not null,
    // Create a Win32_TokenPrivileges instance
    // and call a function to populate it.
    if(m_pjosli->PrivilegesToDelete)
    {
        IWbemClassObjectPtr pWin32TokenPrivileges;
        hr = CreateInst(
                 pNamespace,
                 &pWin32TokenPrivileges,
                 _bstr_t(IDS_Win32_TokenPrivileges),
                 pCtx);
        
        if(SUCCEEDED(hr))
        {
            hr = SetInstanceTokenPrivileges(
                     pWin32TokenPrivileges,
                     m_pjosli->PrivilegesToDelete,
                     pCtx,
                     pNamespace);
        }

        if(SUCCEEDED(hr))
        {
            try
            {
                CVARIANT v;
                v.SetUnknown(pWin32TokenPrivileges);
                hr = pIWCO->Put(
                         g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_PrivilegesToDelete], 
                         0, 
                         &v,
                         NULL);
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }
    }     

    return hr;
}



HRESULT CJobObjSecLimitInfoProps::SetInstanceRestrictedSids(
    IWbemClassObject* pIWCO,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If m_ptgRestrictedSids is not null,
    // Create a Win32_TokenGroups instance
    // and call a function to populate it.
    if(m_pjosli->RestrictedSids)
    {
        IWbemClassObjectPtr pWin32TokenGroups;
        hr = CreateInst(
                 pNamespace,
                 &pWin32TokenGroups,
                 _bstr_t(IDS_Win32_TokenGroups),
                 pCtx);
        
        if(SUCCEEDED(hr))
        {
            hr = SetInstanceTokenGroups(
                     pWin32TokenGroups,
                     m_pjosli->RestrictedSids,
                     pCtx,
                     pNamespace);
        }

        if(SUCCEEDED(hr))
        {
            try
            {
                CVARIANT v;
                v.SetUnknown(pWin32TokenGroups);
                hr = pIWCO->Put(
                         g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_RestrictedSids], 
                         0, 
                         &v,
                         NULL);
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }
    }     

    return hr;
}



HRESULT CJobObjSecLimitInfoProps::SetInstanceTokenGroups(
    IWbemClassObject* pWin32TokenGroups,
    PTOKEN_GROUPS ptg,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _ASSERT(ptg);
    if(!ptg) return hr = WBEM_E_INVALID_PARAMETER;

    // We need to populate the two properties of
    // Win32_TokenGroups (passed in as pWin32TokenGroups:
    // GroupCount, and Groups.  If GroupCount is
    // zero, on the other hand, don't bother with
    // the Groups property.
    try // CVARIANT  can throw and I want the error...
    {
        CVARIANT vGroupCount;
        LONG lSize = (LONG)ptg->GroupCount;

        vGroupCount.SetLONG(lSize);
        hr = pWin32TokenGroups->Put(
                 IDS_GroupCount, 
                 0, 
                 &vGroupCount,
                 NULL);

        if(SUCCEEDED(hr) && 
           lSize > 0)
        {
            // Need to create an array for the
            // Win32_SidAndAttributes instances...
            SAFEARRAY* saSidAndAttr;
	        SAFEARRAYBOUND rgsabound[1];
		    long ix[1];

            rgsabound[0].cElements = lSize;
		    rgsabound[0].lLbound = 0;
		    saSidAndAttr = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
		    ix[0] = 0;

            for(long m = 0; m < lSize && SUCCEEDED(hr); m++)
            {
                IWbemClassObjectPtr pWin32SidAndAttributes;
                IWbemClassObjectPtr pWin32Sid;

                hr = CreateInst(
                         pNamespace,
                         &pWin32SidAndAttributes,
                         _bstr_t(IDS_Win32_SidAndAttributes),
                         pCtx);
            
                if(SUCCEEDED(hr))
                {
                    // Set the attrubutes...
                    CVARIANT vAttributes;
                    vAttributes.SetLONG((LONG)ptg->Groups[m].Attributes);
                    hr = pWin32SidAndAttributes->Put(
                             IDS_Attributes, 
                             0, 
                             &vAttributes,
                             NULL);
                }

                if(SUCCEEDED(hr))
                {
                    // Set the sid...
                    hr = CreateInst(
                             pNamespace,
                             &pWin32Sid,
                             _bstr_t(IDS_Win32_Sid),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        _bstr_t bstrtSid;

                        StringFromSid(
                            ptg->Groups[m].Sid,
                            bstrtSid);
                    
                        // Set the SID property of the Win32_SID...
                        CVARIANT vSID;
                        vSID.SetStr(bstrtSid);
                        hr = pWin32Sid->Put(
                                 IDS_SID, 
                                 0, 
                                 &vSID,
                                 NULL);

                        // As a courtesy, set the domain and
                        // account name props of win32_sid;
                        // don't care about failures.
                        {
                            CHString chstrName;
                            CHString chstrDom;

                            GetNameAndDomainFromPSID(
                                ptg->Groups[m].Sid,
                                chstrName,
                                chstrDom);
                            
                            vSID.SetStr(chstrName);
                            pWin32Sid->Put(
                                     IDS_AccountName, 
                                     0, 
                                     &vSID,
                                     NULL);

                            vSID.SetStr(chstrDom);
                            pWin32Sid->Put(
                                     IDS_ReferencedDomainName, 
                                     0, 
                                     &vSID,
                                     NULL);
                        }
                    }

                    // Set the SID property of the 
                    // Win32_SidAndAttributes...
                    if(SUCCEEDED(hr))
                    {
                        CVARIANT vSAndASid;
                        vSAndASid.SetUnknown(pWin32Sid);
                        hr = pWin32SidAndAttributes->Put(
                                 IDS_SID,
                                 0,
                                 &vSAndASid,
                                 NULL);
                    }    
                }
            
                // Now we need to add the Win32_SidAndAttributes
                // instance to the safearray.  We need to make
                // sure that the instances we add to the safearray
                // don't go away as soon as pWin32SidAndAttributes
                // and pWin32Sid go out of scope (being smart
                // pointers, they will Release when they do), so
                // we must addref both interfaces...
                if(SUCCEEDED(hr))
                {
                    pWin32Sid.AddRef();
                    pWin32SidAndAttributes.AddRef();

                    SafeArrayPutElement(
                        saSidAndAttr, 
                        ix, 
                        pWin32SidAndAttributes);
                }

                ix[0]++;
            }

            // We now have a populated safe array.
            // Now we must set the Groups property
            // of the pWin32TokenGroups that was 
            // passed into this function...
            if(SUCCEEDED(hr))
            {
                CVARIANT vGroups;
                vGroups.SetArray(
                    saSidAndAttr,
                    VT_UNKNOWN | VT_ARRAY);

                hr = pWin32TokenGroups->Put(
                         IDS_Groups, 
                         0, 
                         &vGroups,
                         NULL);
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}


HRESULT CJobObjSecLimitInfoProps::SetInstanceTokenPrivileges(
    IWbemClassObject* pWin32TokenPrivileges,
    PTOKEN_PRIVILEGES ptp,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _ASSERT(ptp);
    if(!ptp) return hr = WBEM_E_INVALID_PARAMETER;

    // We need to populate the two properties of
    // Win32_TokenGroups (passed in as pWin32TokenGroups:
    // GroupCount, and Groups.  If GroupCount is
    // zero, on the other hand, don't bother with
    // the Groups property.
    
    try // CVARIANT can throw and I want the error...
    {
        CVARIANT vPrivilegeCount;
        LONG lSize = (LONG)ptp->PrivilegeCount;
        vPrivilegeCount.SetLONG(lSize);
        hr = pWin32TokenPrivileges->Put(
                 IDS_PrivilegeCount, 
                 0, 
                 &vPrivilegeCount,
                 NULL);

        if(SUCCEEDED(hr) && 
           lSize > 0)
        {
            // Need to create an array for the
            // Win32_LUIDAndAttributes instances...
            SAFEARRAY* saLUIDAndAttr;
	        SAFEARRAYBOUND rgsabound[1];
		    long ix[1];

            rgsabound[0].cElements = lSize;
		    rgsabound[0].lLbound = 0;
		    saLUIDAndAttr = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
		    ix[0] = 0;

            for(long m = 0; m < lSize && SUCCEEDED(hr); m++)
            {
                IWbemClassObjectPtr pWin32LUIDAndAttributes;
                IWbemClassObjectPtr pWin32LUID;
                hr = CreateInst(
                         pNamespace,
                         &pWin32LUIDAndAttributes,
                         _bstr_t(IDS_Win32_LUIDAndAttributes),
                         pCtx);
            
                if(SUCCEEDED(hr))
                {
                    // Set the attrubutes...
                    CVARIANT vAttributes;
                    vAttributes.SetLONG((LONG)ptp->Privileges[m].Attributes);
                    hr = pWin32LUIDAndAttributes->Put(
                             IDS_Attributes, 
                             0, 
                             &vAttributes,
                             NULL);
                }

                if(SUCCEEDED(hr))
                {
                    // Set the luid...
                    hr = CreateInst(
                             pNamespace,
                             &pWin32LUID,
                             _bstr_t(IDS_Win32_LUID),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        // Set the HighPart and LowPart properties
                        // of the Win32_LUID...
                        CVARIANT vHighPart;
                        vHighPart.SetLONG(ptp->Privileges[m].Luid.HighPart);
                        hr = pWin32LUID->Put(
                                 IDS_HighPart, 
                                 0, 
                                 &vHighPart,
                                 NULL);

                        if(SUCCEEDED(hr))
                        {
                            CVARIANT vLowPart;
                            vLowPart.SetLONG((LONG)ptp->Privileges[m].Luid.LowPart);
                            hr = pWin32LUID->Put(
                                     IDS_LowPart, 
                                     0, 
                                     &vLowPart,
                                     NULL);
                        }    
                    }

                    // Set the LUID property of the 
                    // Win32_LUIDAndAttributes...
                    if(SUCCEEDED(hr))
                    {
                        CVARIANT vLAndALUID;
                        vLAndALUID.SetUnknown(pWin32LUID);
                        hr = pWin32LUIDAndAttributes->Put(
                                 IDS_LUID,
                                 0,
                                 &vLAndALUID,
                                 NULL);
                    }    
                }
            
                // Now we need to add the Win32_LUIDAndAttributes
                // instance to the safearray.  We need to make
                // sure that the instances we add to the safearray
                // don't go away as soon as pWin32SidAndAttributes
                // goes out of scope (being a smart
                // pointer, it will Release when it does), so
                // we must addref the interface...
                if(SUCCEEDED(hr))
                {
                    pWin32LUIDAndAttributes.AddRef();
                    pWin32LUID.AddRef();

                    SafeArrayPutElement(
                        saLUIDAndAttr, 
                        ix, 
                        pWin32LUIDAndAttributes);
                }

                ix[0]++;
            }

            // We now have a populated safe array.
            // Now we must set the Privileges property
            // of the pWin32TokenPrivileges that was 
            // passed into this function...
            if(SUCCEEDED(hr))
            {
                CVARIANT vPrivileges;
                vPrivileges.SetArray(
                    saLUIDAndAttr,
                    VT_UNKNOWN | VT_ARRAY);

                hr = pWin32TokenPrivileges->Put(
                         IDS_Privileges, 
                         0, 
                         &vPrivileges,
                         NULL);
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cunknown.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CUnknown.h

#pragma once


/*****************************************************************************/
// Component 
/*****************************************************************************/

class CUnknown : public IUnknown
{
public:
    // Constructor
	CUnknown();

	// Destructor
	virtual ~CUnknown();

	// IDispatch declarartion
    STDMETHOD(QueryInterface)(const IID& iid, void** ppv);                     
	STDMETHOD_(ULONG,AddRef)();                                                
	STDMETHOD_(ULONG,Release)();                                               
                                                                                   
    // Initialization
 	STDMETHOD(Init)();

    // Count of currently active components
	static long ActiveComponents() 
		{ return s_cActiveComponents ;}

    // Notification to derived classes that we are releasing
	STDMETHOD_(void,FinalRelease)() ;


protected:
    // Event thread status
    enum { Pending, Running, PendingStop, Stopped };
    int m_eStatus;
    HANDLE m_hEventThread;



private:
	// Reference count
	LONG m_cRef;

    // Count of all active instances
	static long s_cActiveComponents ;
};


/*****************************************************************************/
// Macro for easy declaration of IUnknown.  Derived classes using this must
// still implement QueryInterface (specifying their own interfaces).  
/*****************************************************************************/
#define DECLARE_IUNKNOWN									                   \
    STDMETHOD(QueryInterface)(const IID& iid, void** ppv);                     \
	STDMETHOD_(ULONG,AddRef)()                                                 \
    {                                                                          \
        return CUnknown::AddRef();                                             \
    }                                                                          \
	STDMETHOD_(ULONG,Release)()                                                \
    {                                                                          \
        return CUnknown::Release();                                            \
    }                                                                          \
                                                                               \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\cvariant.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CVARIANT.h

#pragma once


class CVARIANT;
class CVARIANTError;


class CVARIANTError
{
public:
    inline CVARIANTError()
      : m_hr(E_FAIL)
    {}

    inline CVARIANTError(HRESULT hr)
      : m_hr(hr)
    {}

    inline virtual ~CVARIANTError() {}

    inline HRESULT GetError()
    {
        return m_hr;
    }

    inline HRESULT GetWBEMError()
    {
        HRESULT hrOut = WBEM_S_NO_ERROR;
        switch(m_hr)
        {
            case DISP_E_ARRAYISLOCKED:
            {
                hrOut = WBEM_E_FAILED;
                break;
            }
            case DISP_E_BADVARTYPE:
            {
                hrOut = WBEM_E_INVALID_PARAMETER;
                break;
            }
            case E_OUTOFMEMORY:
            {
                hrOut = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            case E_INVALIDARG:
            {
                hrOut = WBEM_E_INVALID_PARAMETER;
                break;
            }
        }

        return hrOut;    
    }

private:
    HRESULT m_hr;
};

class CVARIANT
{
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }

    CVARIANT(const CVARIANT& vIn) throw(CVARIANTError)
    {
        HRESULT hr = S_OK;
        VariantInit(&v);
        hr = ::VariantCopy(&v, const_cast<VARIANT*>(&(vIn.v)));
        if(FAILED(hr))
        {
            throw CVARIANTError(hr);
        }  
    }

    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }
    CVARIANT& operator=(const CVARIANT& rv) 
    { 
        HRESULT hr = S_OK;
        hr = ::VariantCopy(&v, const_cast<VARIANT*>(&(rv.v)));
        if(FAILED(hr))
        {
            throw CVARIANTError(hr);
        }
         
        return *this; 
    }

    CVARIANT(LPCWSTR pSrc)      { ::VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)         { ::VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(DWORD dwSrc)       { ::VariantInit(&v); SetDWORD(dwSrc); }
    CVARIANT(LONGLONG llSrc)    { ::VariantInit(&v); SetLONGLONG(llSrc); }
    CVARIANT(ULONGLONG ullSrc)  { ::VariantInit(&v); SetULONGLONG(ullSrc); }
    CVARIANT(BOOL b)            { ::VariantInit(&v); SetBool(b); }
    CVARIANT(short i)           { ::VariantInit(&v); SetShort(i); }
    CVARIANT(double d)          { ::VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)            { ::VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { ::VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }
    CVARIANT(VARIANT& vIn)       
    { 
        HRESULT hr = S_OK;
        ::VariantInit(&v); 
        hr = ::VariantCopy(&v, &vIn); 
        if(FAILED(hr))
        {
            throw CVARIANTError(hr);
        }
    }
    
    // Can't have a DATE override, since DATA and double are defined
    // the same. Hence, to set a date, construct a CVARIANT using the
    // default constructor, then call SetDate.
    //CVARIANT(DATE dtDate)       { ::VariantInit(&v); SetDATE(dtDate); }

    void   SetStr(LPCWSTR pSrc)
    { Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDWORD(DWORD dwSrc) { Clear(); V_VT(&v) = VT_UI4; V_UI4(&v) = dwSrc; }
    LONG GetDWORD() { return V_UI4(&v); }
    operator DWORD() { return V_UI4(&v);  }

    void SetLONGLONG(LONGLONG llSrc) { Clear(); V_VT(&v) = VT_I8; V_I8(&v) = llSrc; }
    LONGLONG GetLONGLONG() { return V_I8(&v); }
    operator LONGLONG() { return V_I8(&v);  }

    void SetULONGLONG(ULONGLONG ullSrc) { Clear(); V_VT(&v) = VT_UI8; V_UI8(&v) = ullSrc; }
    ULONGLONG GetULONGLONG() { return V_UI8(&v); }
    operator ULONGLONG() { return V_UI8(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetDate(DATE dtDate) { Clear(); V_VT(&v) = VT_DATE; V_DATE(&v) = dtDate; }
    double GetDate() { return V_DATE(&v); }
    // operator DATE won't work since we have operator double.  You must call
    // GetDate() instead.
    //operator DATE() { return V_DATE(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = b ? VARIANT_TRUE : VARIANT_FALSE; }
    BOOL GetBool() { return V_BOOL(&v) == VARIANT_TRUE; }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; if(pDisp) pDisp->AddRef(); }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk;  if(pUnk) pUnk->AddRef(); }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    // Should only be used for artificially
    // setting the type to something other 
    // than what it really is!
    void SetType(VARTYPE vt) { V_VT(&v) = vt; }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { ::VariantInit(&v); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\factory.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// Factory.cpp
#include "precomp.h"
#include <iostream.h>
#include <objbase.h>
#include "CUnknown.h"
#include "factory.h"
#include "Registry.h"


// Set static members
LONG CFactory::s_cServerLocks = 0L ;   // Count of locks
HMODULE CFactory::s_hModule = NULL ;   // DLL module handle

extern CFactoryData g_FactoryDataArray[];


/*****************************************************************************/
// Class factory constructor
/*****************************************************************************/
CFactory::CFactory(const CFactoryData* pFactoryData)
: m_cRef(1)
{
	m_pFactoryData = pFactoryData ;
    LockServer(TRUE);
}

/*****************************************************************************/
// Class factory IUnknown implementation
/*****************************************************************************/

STDMETHODIMP CFactory::QueryInterface(const IID& iid, void** ppv)
{    
	if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
	{
		*ppv = static_cast<IClassFactory*>(this) ; 
	}
	else
	{
		*ppv = NULL ;
		return E_NOINTERFACE ;
	}
	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
	return S_OK ;
}

STDMETHODIMP_(ULONG) CFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG) CFactory::Release() 
{
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	return m_cRef ;
}

/*****************************************************************************/
// IClassFactory implementation
/*****************************************************************************/

STDMETHODIMP CFactory::CreateInstance(IUnknown* pUnknownOuter,
                                      const IID& iid,
                                      void** ppv) 
{
	HRESULT hr = S_OK;
    // Cannot aggregate.
	if (pUnknownOuter != NULL)
	{
		hr = CLASS_E_NOAGGREGATION;
	}

    if(SUCCEEDED(hr))
    {
	    // Create component using the specific component's version of CreateInstance.
        CUnknown* pNewComponent ;
	    hr = m_pFactoryData->CreateInstance(&pNewComponent) ;
    
        if(SUCCEEDED(hr))
        {
	        // Initialize the component
            hr = pNewComponent->Init();
            if(SUCCEEDED(hr))
            {
                // Get the requested interface.
	            hr = pNewComponent->QueryInterface(iid, ppv);
            }
            // Release the IUnknown pointer (the new AND the QI incremented the refcount on SUC.
	        // (If QueryInterface failed, component will delete itself.)
	        pNewComponent->Release();
        }
    }
	return hr ;
}

/*****************************************************************************/
// Lock server
/*****************************************************************************/
STDMETHODIMP CFactory::LockServer(BOOL bLock) 
{
	if (bLock)
	{
		InterlockedIncrement(&s_cServerLocks) ; 
	}
	else
	{
		InterlockedDecrement(&s_cServerLocks) ;
	}
	return S_OK ;
}

/*****************************************************************************/
// GetClassObject - Create a class factory based on a CLSID.
/*****************************************************************************/
HRESULT CFactory::GetClassObject(const CLSID& clsid,
                                 const IID& iid,
                                 void** ppv)
{
	HRESULT hr = S_OK;

    if ((iid != IID_IUnknown) && (iid != IID_IClassFactory))
	{
		hr = E_NOINTERFACE ;
	}

    if(SUCCEEDED(hr))
    {
	    // Traverse the array of data looking for this class ID.
	    for (int i = 0; i < g_cFactoryDataEntries; i++)
	    {
		    if(g_FactoryDataArray[i].IsClassID(clsid))
		    {
			    // Found the ClassID in the array of components we can
			    // create.  So create a class factory for this component.
			    // Pass the CFactoryData structure to the class factory
			    // so that it knows what kind of components to create.
                const CFactoryData* pData = &g_FactoryDataArray[i] ;
			    CFactory* pFactory = new CFactory(pData);
			    if (pFactory == NULL)
			    {
				    hr = E_OUTOFMEMORY ;
			    }
                else
                {
                    // Get requested interface.
	                HRESULT hr = pFactory->QueryInterface(iid, ppv);
	                pFactory->Release();
                }
			    break;
		    }
	    }
        if(i == g_cFactoryDataEntries)
        {
            hr = CLASS_E_CLASSNOTAVAILABLE;
        }
    }
	return hr;
}

/*****************************************************************************/
// Register all components.
/*****************************************************************************/
HRESULT CFactory::RegisterAll()
{
	for(int i = 0 ; i < g_cFactoryDataEntries ; i++)
	{
		RegisterServer(s_hModule,
		               *(g_FactoryDataArray[i].m_pCLSID),
		               g_FactoryDataArray[i].m_RegistryName,
		               g_FactoryDataArray[i].m_szVerIndProgID,
		               g_FactoryDataArray[i].m_szProgID) ;
	}
	return S_OK ;
}

/*****************************************************************************/
// Un-register all components
/*****************************************************************************/
HRESULT CFactory::UnregisterAll()
{
	for(int i = 0 ; i < g_cFactoryDataEntries ; i++)
	{
		UnregisterServer(*(g_FactoryDataArray[i].m_pCLSID),
		                 g_FactoryDataArray[i].m_szVerIndProgID,
		                 g_FactoryDataArray[i].m_szProgID) ;

	}
	return S_OK ;
}

/*****************************************************************************/
// Determine if the component can be unloaded.
/*****************************************************************************/
HRESULT CFactory::CanUnloadNow()
{
	if (CUnknown::ActiveComponents() || IsLocked())
	{
		return S_FALSE ;
	}
	else
	{
		return S_OK ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\globals.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// Globals.cpp


#include "precomp.h"
//#include <windows.h>
//#include <objbase.h>
//#include <comdef.h>
#include "CUnknown.h"
#include "factory.h"
#include "Registry.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjProps.h"
#include "JobObjectProv.h"
#include "CJobObjIOActgProps.h"
#include "JobObjIOActgInfoProv.h"
#include "CJobObjLimitInfoProps.h"
#include "JobObjLimitInfoProv.h"
#include "CJobObjSecLimitInfoProps.h"
#include "JobObjSecLimitInfoProv.h"
#include <initguid.h>
#include "Globals.h"



/*****************************************************************************/
// Globals
/*****************************************************************************/



//
// This file contains the component server code.
// The FactoryDataArray contains the components that 
// can be served.
//

// Each component derived from Unknown defines a static function
// for creating the component with the following prototype. 
// HRESULT CreateInstance(CUnknown** ppNewComponent) ;
// This function is used to create the component.
//
// The following array contains the data used by CFactory
// to create components. Each element in the array contains
// the CLSID, the pointer to the creation function, and the name
// of the component to place in the Registry.
//
CFactoryData g_FactoryDataArray[] =
{
	{   
        &CLSID_JobObjectProvComp,                           // Component class id
        CJobObjectProv::CreateInstance,                     // Name of the component's creation function
		L"Win32_JobObject Provider Component",              // Friendly name
		L"JobObjectProv.JobObjectProv.1",                   // ProgID
		L"JobObjectProv.JobObjectProv"                      // Version-independent ProgID
    },
    {
        &CLSID_JobObjIOActgInfoComp,                        // Component class id
        CJobObjIOActgInfoProv::CreateInstance,              // Name of the component's creation function
		L"Win32_JobObjectIOAccountingInfo Component",       // Friendly name
		L"JobObjIOActgInfoProv.JobObjIOActgInfoProv.1",     // ProgID
		L"JobObjIOActgInfoProv.JobObjIOActgInfoProv"        // Version-independent ProgID
    },
    {
        &CLSID_JobObjLimitInfoComp,                         // Component class id
        CJobObjLimitInfoProv::CreateInstance,               // Name of the component's creation function
		L"Win32_JobObjectLimitInfo Component",              // Friendly name
		L"JobObjLimitInfoProv.JobObjLimitInfoProv.1",       // ProgID
		L"JobObjLimitInfoProv.JobObjLimitInfoProv"          // Version-independent ProgID
    },
    {
        &CLSID_JobObjSecLimitInfoComp,                      // Component class id
        CJobObjSecLimitInfoProv::CreateInstance,            // Name of the component's creation function
		L"Win32_JobObjectSecLimitInfo Component",           // Friendly name
		L"JobObjSecLimitInfoProv.JobObjSecLimitInfoProv.1", // ProgID
		L"JobObjSecLimitInfoProv.JobObjSecLimitInfoProv"    // Version-independent ProgID
    }

} ;

int g_cFactoryDataEntries = 
    sizeof(g_FactoryDataArray)/sizeof(CFactoryData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\helpers.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// Helpers.h:  Prototypes for helper functions for JobObjectProv component.


#pragma once



_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));


#define JOB_OBJECT_STATUS_OBJECT L"Win32_JobObjectStatus"
#define JOB_OBJECT_NAMESPACE L"root\\cimv2"


class SmartCloseHANDLE
{

private:
	HANDLE m_h;

public:
	SmartCloseHANDLE():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseHANDLE(HANDLE h):m_h(h){}
   ~SmartCloseHANDLE(){if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};





HRESULT CreateInst(
    IWbemServices *pNamespace, 
    IWbemClassObject **pNewInst,
    BSTR bstrClassName,
    IWbemContext *pCtx);


HRESULT GetObjInstKeyVal(
    const BSTR ObjectPath,
    LPCWSTR wstrClassName,
    LPCWSTR wstrKeyPropName, 
    LPWSTR wstrObjInstKeyVal, 
    long lBufLen);



HRESULT GetJobObjectList(
    std::vector<_bstr_t>& rgbstrtJOList);



bool WINAPI WhackToken(
    LPWSTR str, 
    LPWSTR token);

bool WINAPI StrToIdentifierAuthority(
    LPCWSTR str, 
    SID_IDENTIFIER_AUTHORITY& identifierAuthority);

PSID WINAPI StrToSID(LPCWSTR wstrIncommingSid);

void StringFromSid(PSID psid, _bstr_t& strSID);

void RemoveQuotes(LPWSTR wstrObjInstKeyVal);

HRESULT CheckImpersonationLevel();

HRESULT SetStatusObject(
    IWbemContext* pContext,
    IWbemServices* pSvcs,
    DWORD dwError,
    LPCWSTR wstrErrorDescription,
    LPCWSTR wstrOperation,
    LPCWSTR wstrNamespace,
    IWbemClassObject** ppStatusObjOut);

IWbemClassObject* GetStatusObject(
    IWbemContext* pContext,
    IWbemServices* pSvcs);

void UndecorateJOName(
    LPCWSTR wstrDecoratedName,
    CHString& chstrUndecoratedJOName);

void DecorateJOName(
    LPCWSTR wstrUndecoratedName,
    CHString& chstrDecoratedJOName);

void UndecorateNamesInNamedJONameList(
    std::vector<_bstr_t>& rgNamedJOs);

HRESULT WinErrorToWBEMhResult(LONG error);

bool GetNameAndDomainFromPSID(
    PSID psid,
    CHString& chstrName,
    CHString& chstrDomain);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\jobase.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JOBase.cpp


#include "precomp.h"
//#include <windows.h>
//#include <cominit.h>
//#include <objbase.h>
//#include <comdef.h>

#include "CUnknown.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "globals.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "JOBase.h"
#include "Factory.h"
#include "helpers.h"
#include <map>
#include <vector>
#include "SmartHandle.h"
#include "AssertBreak.h"






HRESULT CJOBase::Initialize(
    LPWSTR pszUser, 
    LONG lFlags,
    LPWSTR pszNamespace, 
    LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    if(pNamespace) pNamespace->AddRef();
    m_pNamespace = pNamespace;
    m_chstrNamespace = pszNamespace;

    //Let CIMOM know you are initialized
    pInitSink->SetStatus(
        WBEM_S_INITIALIZED,
        0);

    return WBEM_S_NO_ERROR;
}



HRESULT CJOBase::GetObjectAsync( 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    CObjProps& objprops,
    PFN_CHECK_PROPS pfnChk,
    LPWSTR wstrClassName,
    LPCWSTR wstrKeyProp)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // We need the name of the instance they requested...
    WCHAR wstrObjInstKeyVal[MAX_PATH];
    hr = GetObjInstKeyVal(
           ObjectPath,
           wstrClassName,
           wstrKeyProp, 
           wstrObjInstKeyVal, 
           sizeof(wstrObjInstKeyVal) - sizeof(WCHAR));
    
    if(SUCCEEDED(hr))
    {
        // wstrObjInstKeyVal now contains the name of the object.  See if
        // it exists...
        SmartHandle hJob;
        hJob = ::OpenJobObject(
                   MAXIMUM_ALLOWED,
                   FALSE,
                   wstrObjInstKeyVal);

        if(hJob)
        {
            // We seem to have found one matching the specified name,
            // so create a return instance...
            objprops.SetJobHandle(hJob);
            IWbemClassObjectPtr pIWCO = NULL;

            hr = CreateInst(
                     m_pNamespace,
                     &pIWCO,
                     _bstr_t(wstrClassName),
                     pCtx);

            if(SUCCEEDED(hr))
            {
                // see what properties are requested...
                hr = objprops.GetWhichPropsReq(
                         ObjectPath,
                         pCtx,
                         wstrClassName,
                         pfnChk);
            }
                
            if(SUCCEEDED(hr))
            {
                // set the key properties...
                hr = objprops.SetKeysFromPath(
                       ObjectPath,
                       pCtx);
            }

            if(SUCCEEDED(hr))
            {
                // set the non-key requested properties...
                hr = objprops.SetNonKeyReqProps();
            }

            if(SUCCEEDED(hr))
            {
                // Load requested non-key properties 
                // to the instance...
                hr = objprops.LoadPropertyValues(
                         pIWCO);

                // Commit the instance...
                if(SUCCEEDED(hr))
                {
                    hr = pResponseHandler->Indicate(
                             1,
                             &pIWCO);
                }
            }
        }
    }

    // Set Status
    pResponseHandler->SetStatus(0, hr, NULL, NULL);

    return hr;
}




HRESULT CJOBase::ExecQueryAsync( 
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    CObjProps& objprops,
    LPCWSTR wstrClassName,
    LPCWSTR wstrKeyProp)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // We will optimize for those cases in which
    // a particular set of named job objects
    // (e.g., 1 or more).  Enumerate also
    // optimizes for the properties that were
    // requested.
    CFrameworkQuery cfwq;
    hr = cfwq.Init(
             QueryLanguage,
             Query,
             lFlags,
             m_chstrNamespace);

    std::vector<_bstr_t> rgNamedJOs;
    if(SUCCEEDED(hr))
    {
        hr = cfwq.GetValuesForProp(
                 _bstr_t(wstrKeyProp), 
                 rgNamedJOs);
    }

    if(SUCCEEDED(hr))
    {
        hr = Enumerate(
                 pCtx,
                 pResponseHandler,
                 rgNamedJOs,
                 objprops,
                 wstrClassName);
    }

    return hr;
}




HRESULT CJOBase::CreateInstanceEnumAsync( 
    const BSTR Class,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    CObjProps& objprops,
    LPCWSTR wstrClassName)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(wcsicmp(
           Class, 
           wstrClassName) != NULL)
    {
        hr = WBEM_E_INVALID_CLASS;
    }

    // For every job object, return all accounting
    // info properties...
    if(SUCCEEDED(hr))
    {
        // Get a list of named jobs...
        std::vector<_bstr_t> rgNamedJOs;
        hr = GetJobObjectList(rgNamedJOs);

        if(SUCCEEDED(hr))
        {
            hr = Enumerate(
                     pCtx,
                     pResponseHandler,
                     rgNamedJOs,
                     objprops,
                     wstrClassName);
        }
    }
    return hr;
}




HRESULT CJOBase::Enumerate(
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    std::vector<_bstr_t>& rgNamedJOs,
    CObjProps& objprops,
    LPCWSTR wstrClassName)
{
    HRESULT hr = S_OK;

    long lNumJobs = rgNamedJOs.size();

    try // CVARIANT can throw and I want the error...
    {
        if(lNumJobs > 0)
        {
            // Create an object path...
            _bstr_t bstrtObjPath;
            bstrtObjPath = wstrClassName;

            // Get which props requested...
            hr = objprops.GetWhichPropsReq(
                     bstrtObjPath,
                     pCtx);

            if(SUCCEEDED(hr))
            {
                SmartHandle hJob;

                for(long m = 0L; m < lNumJobs; m++)
                {
                    // We have the name of a JO; need to open it up
                    // and get its properties...
                    hJob = ::OpenJobObject(
                       MAXIMUM_ALLOWED,
                       FALSE,
                       (LPCWSTR)(rgNamedJOs[m]));
                    // (NOTE: hJob smarthandle class automatically
                    // closes its handle on destruction and on
                    // reassignment.)
                    if(hJob)
                    {
                        // Set the handle...
                        objprops.SetJobHandle(hJob);

                        // Set the key properties directly...
                        std::vector<CVARIANT> vecvKeys;
                        CVARIANT vID(rgNamedJOs[m]);
                        vecvKeys.push_back(vID);
                        hr = objprops.SetKeysDirect(vecvKeys);

                        if(SUCCEEDED(hr))
                        {
                            // set the non-key requested 
                            // properties...
                            hr = objprops.SetNonKeyReqProps();
                        }

                        // Create a new outgoing instance...
                        IWbemClassObjectPtr pIWCO = NULL;
                        if(SUCCEEDED(hr))
                        {
                            hr = CreateInst(
                                     m_pNamespace,
                                     &pIWCO,
                                     _bstr_t(wstrClassName),
                                     pCtx);
                        }

                        // Load the properties of the 
                        // new outgoing instance...
                        if(SUCCEEDED(hr))
                        {
                            hr = objprops.LoadPropertyValues(pIWCO);
                        }

                        // And send it out...
                        if(SUCCEEDED(hr))
                        {
                            hr = pResponseHandler->Indicate(
                                     1, 
                                     &pIWCO);
                        }
                    }
                    else
                    {
                        ASSERT_BREAK(0);
                    }
                }
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\globals.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// Globals.h


// {7FB1D98A-F895-4761-8DC2-774969C84D10}
DEFINE_GUID(CLSID_JobObjectProvComp, 
0x7fb1d98a, 0xf895, 0x4761, 0x8d, 0xc2, 0x77, 0x49, 0x69, 0xc8, 0x4d, 0x10);


// {C0AA9D93-2EF5-47fb-960C-F90FC644B48E}
DEFINE_GUID(CLSID_JobObjIOActgInfoComp, 
0xc0aa9d93, 0x2ef5, 0x47fb, 0x96, 0xc, 0xf9, 0xf, 0xc6, 0x44, 0xb4, 0x8e);


// {6515834D-6125-4878-A3A3-6B0A73B809A2}
DEFINE_GUID(CLSID_JobObjLimitInfoComp, 
0x6515834d, 0x6125, 0x4878, 0xa3, 0xa3, 0x6b, 0xa, 0x73, 0xb8, 0x9, 0xa2);

// {AB40A5C1-804B-40bd-9DFE-A640691C6956}
DEFINE_GUID(CLSID_JobObjSecLimitInfoComp, 
0xab40a5c1, 0x804b, 0x40bd, 0x9d, 0xfe, 0xa6, 0x40, 0x69, 0x1c, 0x69, 0x56);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\helpers.cpp ===
// Copyright (c) 2000-2002 Microsoft Corporation, All Rights Reserved
// Helpers.cpp:  Helper functions for the SecUtil component

//#include "FWCommon.h"
//#include <windows.h>

//#include <winnt.h>

/*
#ifndef USE_POLARITY
// For most users, this is the correct setting for POLARITY.
#define USE_POLARITY
#endif
*/


#include "precomp.h"

#include <cominit.h>
#include <vector>
#include "Helpers.h"
#include "AssertBreak.h"
#include "CVARIANT.H"
#include <crtdbg.h>





#define IDS_NTDLLDOTDLL                L"NTDLL.DLL"
#define IDS_NTOPENDIRECTORYOBJECT      "NtOpenDirectoryObject"
#define IDS_NTQUERYDIRECTORYOBJECT     "NtQueryDirectoryObject"
#define IDS_RTLINITUNICODESTRING       "RtlInitUnicodeString"
#define IDS_WHACKWHACKBASENAMEDOBJECTS L"\\BaseNamedObjects"
#define IDS_NTQUERYINFORMATIONPROCESS  "NtQueryInformationProcess"
#define IDS_NTOPENPROCESS              "NtOpenProcess"

#define IDS_WIN32_ERROR_CODE L"Win32ErrorCode"
#define IDS_ADDITIONAL_DESCRIPTION L"AdditionalDescription"
#define IDS_OPERATION L"Operation"


typedef NTSTATUS (NTAPI *PFN_NT_OPEN_DIRECTORY_OBJECT)
(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
);

typedef NTSTATUS (NTAPI *PFN_NT_QUERY_DIRECTORY_OBJECT)
(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
);

typedef VOID (WINAPI *PFN_NTDLL_RTL_INIT_UNICODE_STRING)
(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
);

typedef NTSTATUS (NTAPI *PFN_NTDLL_NT_QUERY_INFORMATION_PROCESS)
(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);

typedef NTSTATUS (NTAPI *PFN_NT_OPEN_PROCESS)
(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
);




//***************************************************************************
//
// CreateInst
//
// Purpose: Creates a new instance.
//
// Return:   S_OK if all is well, otherwise an error code is returned
//
//***************************************************************************
HRESULT CreateInst(
    IWbemServices *pNamespace, 
    IWbemClassObject **pNewInst,
    BSTR bstrClassName,
    IWbemContext *pCtx)
{   
    HRESULT hr = S_OK;
    IWbemClassObjectPtr pClass;
    hr = pNamespace->GetObject(
                         bstrClassName, 
                         0, 
                         pCtx, 
                         &pClass, 
                         NULL);
    
    if(SUCCEEDED(hr))
    {
        hr = pClass->SpawnInstance(
                         0, 
                         pNewInst);
    }
    
    return hr;
}


//***************************************************************************
//
// GetObjInstKeyVal
//
// Purpose: Obtains an object's instance key from an object path.
//
// Return:  true if the key was obtained.
//
//***************************************************************************
HRESULT GetObjInstKeyVal(
    const BSTR ObjectPath,
    LPCWSTR wstrClassName,
    LPCWSTR wstrKeyPropName, 
    LPWSTR wstrObjInstKeyVal, 
    long lBufLen)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR* pwcEqualSign = NULL;
    WCHAR* pwcTmp = NULL;

    if(!ObjectPath)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if((pwcEqualSign = wcschr(ObjectPath, L'=')) != NULL)
    {
        pwcEqualSign++;
        long lLen = wcslen(pwcEqualSign) * sizeof(WCHAR);
        if(*pwcEqualSign &&
           lLen > 0 &&
           lLen < (long)(lBufLen - sizeof(WCHAR)))
        {
            wcscpy(wstrObjInstKeyVal, pwcEqualSign);

            // Remove any quotation marks that might
            // be there...
            RemoveQuotes(wstrObjInstKeyVal);

            // Also need to check that the class name
            // matches the name specified...
            WCHAR wstrClass[_MAX_PATH];
            wcscpy(wstrClass, ObjectPath);
            pwcTmp = wcschr(wstrClass, L'=');
            if(pwcTmp)
            {
                *pwcTmp = '\0';
                // Either the key property was specified or
                // it wasn't...
                pwcTmp = NULL;
                pwcTmp = wcschr(wstrClass, L'.');
                if(pwcTmp)
                {
                    // Key property specified, so check that
                    // both it and the class name are correct...
                    *pwcTmp = '\0';
                    if(_wcsicmp(wstrClassName, wstrClass) == 0)
                    {
                        if(_wcsicmp(wstrKeyPropName, ++pwcTmp) != 0)
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                        }
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_CLASS;
                    }
                }
                else
                {
                    // No key prop specified, so only need
                    // to check that the class name is correct...
                    if(_wcsicmp(wstrClassName, wstrClass) != 0)
                    {            
                        hr = WBEM_E_INVALID_CLASS;
                    }
                }
            }
            else
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }
        else
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}


HRESULT GetJobObjectList(
    std::vector<_bstr_t>& rgbstrtJOs)
{
    HRESULT hr = S_OK;
    HINSTANCE hinst = NULL;
    SmartCloseHANDLE hDir;
    PBYTE pbBuff = NULL;

    try
    {
        if((hinst = ::LoadLibrary(IDS_NTDLLDOTDLL)) != NULL)
        {
            PFN_NT_OPEN_DIRECTORY_OBJECT pfnNtOpenDirectoryObject = NULL; 
            PFN_NT_QUERY_DIRECTORY_OBJECT pfnNtQueryDirectoryObject = NULL; 
            PFN_NTDLL_RTL_INIT_UNICODE_STRING pfnRtlInitUnicodeString = NULL;

            pfnNtOpenDirectoryObject = (PFN_NT_OPEN_DIRECTORY_OBJECT) 
                                            ::GetProcAddress(hinst, IDS_NTOPENDIRECTORYOBJECT);

            pfnNtQueryDirectoryObject = (PFN_NT_QUERY_DIRECTORY_OBJECT) 
                                            ::GetProcAddress(hinst, IDS_NTQUERYDIRECTORYOBJECT);

            pfnRtlInitUnicodeString = (PFN_NTDLL_RTL_INIT_UNICODE_STRING) 
                                            ::GetProcAddress(hinst, IDS_RTLINITUNICODESTRING);


            if(pfnNtOpenDirectoryObject != NULL &&
               pfnNtQueryDirectoryObject != NULL &&
               pfnRtlInitUnicodeString != NULL)
            {
                OBJECT_ATTRIBUTES oaAttributes;
                UNICODE_STRING ustrNtFileName;
                NTSTATUS ntstat = -1L;

                pfnRtlInitUnicodeString(&ustrNtFileName, 
                                        IDS_WHACKWHACKBASENAMEDOBJECTS);

                InitializeObjectAttributes(&oaAttributes,
					                       &ustrNtFileName,
					                       OBJ_CASE_INSENSITIVE,
					                       NULL,
					                       NULL);

    
	            ntstat = pfnNtOpenDirectoryObject(&hDir,
	           	                                  FILE_READ_DATA,
                                                  &oaAttributes);
                                      
                if(NT_SUCCESS(ntstat))
                {
                    ULONG ulContext = -1L;
                    ntstat = STATUS_SUCCESS;
                    ULONG ulBufLen = 0L;
                    ULONG ulNewBufLen = 0L;

                    // First query to get buffer size to allocate...
                    ntstat = pfnNtQueryDirectoryObject(hDir,          // IN HANDLE DirectoryHandle,
                                                       NULL,          // OUT PVOID Buffer,
                                                       0L,            // IN ULONG Length,
                                                       FALSE,         // IN BOOLEAN ReturnSingleEntry,
                                                       TRUE,          // IN BOOLEAN RestartScan,
                                                       &ulContext,    // IN OUT PULONG Context,
                                                       &ulBufLen);    // OUT PULONG ReturnLength OPTIONAL
                
                    pbBuff = new BYTE[ulBufLen];
                    if(pbBuff)
                    {
                        // then loop through all the entries...
                        for(; ntstat != STATUS_NO_MORE_ENTRIES && pbBuff != NULL;)
                        {
                            ntstat = pfnNtQueryDirectoryObject(hDir,          // IN HANDLE DirectoryHandle,
                                                               pbBuff,        // OUT PVOID Buffer,
                                                               ulBufLen,      // IN ULONG Length,
                                                               TRUE,          // IN BOOLEAN ReturnSingleEntry,
                                                               FALSE,         // IN BOOLEAN RestartScan,
                                                               &ulContext,    // IN OUT PULONG Context,
                                                               &ulNewBufLen); // OUT PULONG ReturnLength OPTIONAL

                            if(ntstat == STATUS_BUFFER_TOO_SMALL)
                            {
                                // Deallocate buffer and reallocate...
                                if(pbBuff != NULL)
                                {
                                    delete pbBuff;
                                    pbBuff = NULL;
                                }
                                pbBuff = new BYTE[ulNewBufLen];
                                ulBufLen = ulNewBufLen;
                            }
                            else if(NT_SUCCESS(ntstat))
                            {
                                // All went well, should have data...
                                if(pbBuff != NULL)
                                {
                                    POBJECT_DIRECTORY_INFORMATION podi = (POBJECT_DIRECTORY_INFORMATION) pbBuff;
                                    LPWSTR wstrName = (LPWSTR)podi->Name.Buffer;
                                    LPWSTR wstrType = (LPWSTR)podi->TypeName.Buffer;
                    
                                    // do something...
                                    // offset to string name is in four bytes...
                                    if(wstrName != NULL && 
                                       wstrType != NULL &&
                                       wcslen(wstrType) == 3)
                                    {
                                        WCHAR wstrTmp[4]; wstrTmp[3] = '\0';
                                        wcsncpy(wstrTmp, wstrType, 3);
                                        if(_wcsicmp(wstrTmp, L"job") == 0)
                                        {
                                            rgbstrtJOs.push_back(_bstr_t(wstrName));    
                                        }
                                    }
                                }
                            }
                            else if(ntstat == STATUS_NO_MORE_ENTRIES)
                            {
                                // we will break
                            }
                            else
                            {
                                // Something we weren't expecting happened, so bail out...
                                hr = E_FAIL;
                            }
                        }  // while we still have entries

                        delete pbBuff;
                        pbBuff = NULL;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                
                } // NtOpenDirectoryObject succeeded
                else
                {
                    hr = E_FAIL;
                }
            } // Got the fn ptrs
            else
            {
                hr = E_FAIL;
            }
            ::FreeLibrary(hinst);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    catch(...)
    {
        if(pbBuff != NULL)
        {
            delete pbBuff; pbBuff = NULL;
        }
        if(hinst != NULL)
        {
            ::FreeLibrary(hinst); hinst = NULL;
        }
        throw;
    }

    return hr;
}

void StringFromSid(PSID psid, _bstr_t& strSID)
{
	// Initialize m_strSid - human readable form of our SID
	SID_IDENTIFIER_AUTHORITY *psia = NULL;
    psia = ::GetSidIdentifierAuthority(psid);
	WCHAR wstrTmp[_MAX_PATH];

	// We assume that only last byte is used 
    // (authorities between 0 and 15).
	// Correct this if needed.
	ASSERT( psia->Value[0] == 
            psia->Value[1] == 
            psia->Value[2] == 
            psia->Value[3] == 
            psia->Value[4] == 0 );

	DWORD dwTopAuthority = psia->Value[5];

	wsprintf(wstrTmp, L"S-1-%u", dwTopAuthority);

	WCHAR wstrSubAuthority[_MAX_PATH];

	int iSubAuthorityCount = *(GetSidSubAuthorityCount(psid));

	for ( int i = 0; i < iSubAuthorityCount; i++ ) {

		DWORD dwSubAuthority = *(GetSidSubAuthority(psid, i));
		wsprintf(wstrSubAuthority, L"%u", dwSubAuthority);
		wcscat(wstrTmp, L"-");
        wcscat(wstrTmp, wstrSubAuthority);
	}

    strSID = wstrTmp;
}

void RemoveQuotes(LPWSTR wstrObjInstKeyVal)
{
    WCHAR wstrTmp[MAX_PATH] = { L'\0' };
    WCHAR* pwchr = NULL;

    // Get rid of the first quote...
    if((pwchr = wcschr(wstrObjInstKeyVal, L'"')) != NULL)
    {
        wcscpy(wstrTmp, pwchr+1);
    }

    // now the last...
    if((pwchr = wcsrchr(wstrTmp, L'"')) != NULL)
    {
        *pwchr = L'\0';
    }

    wcscpy(wstrObjInstKeyVal, wstrTmp);
}


HRESULT CheckImpersonationLevel()
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;
    OSVERSIONINFOW OsVersionInfoW;

    OsVersionInfoW.dwOSVersionInfoSize = sizeof (OSVERSIONINFOW);
    GetVersionExW(&OsVersionInfoW);

    if (OsVersionInfoW.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        HRESULT hRes = WbemCoImpersonateClient();
        if (SUCCEEDED(hRes)) // From cominit.cpp - needed for nt3.51
        {
            // Now, let's check the impersonation level.  First, get the thread token
            SmartCloseHANDLE hThreadTok;
            DWORD dwImp, dwBytesReturned;

            if (!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                &hThreadTok
                ))
            {
                DWORD dwLastError = GetLastError();

                if (dwLastError == ERROR_NO_TOKEN)
                {
                    // If the CoImpersonate works, but the OpenThreadToken fails due to ERROR_NO_TOKEN, we
                    // are running under the process token (either local system, or if we are running
                    // with /exe, the rights of the logged in user).  In either case, impersonation rights
                    // don't apply.  We have the full rights of that user.

                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    // If we failed to get the thread token for any other reason, an error.
                    hr = WBEM_E_ACCESS_DENIED;
                }
            }
            else
            {
                // We really do have a thread token, so let's retrieve its level

                if (GetTokenInformation(
                    hThreadTok,
                    TokenImpersonationLevel,
                    &dwImp,
                    sizeof(DWORD),
                    &dwBytesReturned
                    ))
                {
                    // Is the impersonation level Impersonate?
                    if ((dwImp == SecurityImpersonation) || (dwImp == SecurityDelegation))
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hr = WBEM_E_ACCESS_DENIED;
                    }
                }
                else
                {
                    hr = WBEM_E_FAILED;
                }
            }

			if (FAILED(hr))
			{
				WbemCoRevertToSelf();
			}
        }
        else if (hRes == E_NOTIMPL)
        {
            // On 3.51 or vanilla 95, this call is not implemented, we should work anyway
            hr = WBEM_S_NO_ERROR;
        }
    }
    else
    {
        // let win9X in...
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}


HRESULT SetStatusObject(
    IWbemContext* pCtx,
    IWbemServices* pSvcs,
    DWORD dwError,
    LPCWSTR wstrErrorDescription,
    LPCWSTR wstrOperation,
    LPCWSTR wstrNamespace,
    IWbemClassObject** ppStatusObjOut)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject* pStatusObj = NULL;

    ASSERT_BREAK(pCtx != NULL);
    ASSERT_BREAK(pSvcs != NULL);

    if(pSvcs && ppStatusObjOut && pCtx)
    {
        pStatusObj = GetStatusObject(
            pCtx,
            pSvcs);
    
        if(pStatusObj != NULL)
        {
            CVARIANT v;

            // Set the error code:
            v.SetLONG(dwError);
            pStatusObj->Put(
                IDS_WIN32_ERROR_CODE, 
                0, 
                &v, 
                NULL);
            v.Clear();

            // Set the error description
            if(wstrErrorDescription != NULL &&
               *wstrErrorDescription != L'\0')
            {
                v.SetStr(wstrErrorDescription);
                pStatusObj->Put(
                    IDS_ADDITIONAL_DESCRIPTION,
                    0,
                    &v,
                    NULL);
                v.Clear();
            }

            if(wstrOperation != NULL &&
               *wstrOperation != L'\0')
            {
                v.SetStr(wstrOperation);
                pStatusObj->Put(
                    IDS_OPERATION,
                    0,
                    &v,
                    NULL);
                v.Clear();
            }
        }

        if(pStatusObj)
        {
            if(*ppStatusObjOut != NULL)
            {
                (*ppStatusObjOut)->Release();
                *ppStatusObjOut = NULL;
            }
            *ppStatusObjOut = pStatusObj;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}


IWbemClassObject* GetStatusObject(
    IWbemContext* pContext,
    IWbemServices* pSrvc)
{
    ASSERT_BREAK(pContext != NULL);
    ASSERT_BREAK(pSrvc != NULL);
    IWbemClassObjectPtr pStatusObjClass;
    IWbemClassObject* pStatusObjectInstance = NULL;

    if(pContext && pSrvc)
    {
        if(pSrvc)
        {
            // not checking return code, error object should be NULL on error
            pSrvc->GetObject( 
                _bstr_t(JOB_OBJECT_STATUS_OBJECT), 
                0, 
                pContext, 
                &pStatusObjClass, 
                NULL);

            if(pStatusObjClass)
            {
                pStatusObjClass->SpawnInstance(
                    0,
                    &pStatusObjectInstance);
            }   
        }
    }

    ASSERT_BREAK(pStatusObjectInstance);
    return pStatusObjectInstance;
}



void UndecorateNamesInNamedJONameList(
    std::vector<_bstr_t>& rgNamedJOs)
{
    std::vector<_bstr_t> rgUndecoratedNames;
    CHString chstrTemp;

    for(long m = 0L;
        m < rgNamedJOs.size();
        m++)
    {
        UndecorateJOName(
            rgNamedJOs[m],
            chstrTemp);
  
        _bstr_t bstrtTemp((LPCWSTR)chstrTemp);    
        rgUndecoratedNames.push_back(
            bstrtTemp);       
    }

    // Wipe out the original vector...
    rgNamedJOs.clear();

    // Push in new vector's contents...
    for(m = 0L;
        m < rgUndecoratedNames.size();
        m++)
    {
        rgNamedJOs.push_back(
            rgUndecoratedNames[m]);
    }
}



// Takes a decorated job object name and
// undecorates it.  Decorated job object names
// have a backslash preceeding any character
// that should be uppercase once undecorated.
// 
// Due to the way CIMOM handles backslashes,
// we will get capital letters preceeded by
// two, not just one, backslashes.  Hence, we
// must strip them both.
//
// According to the decoration scheme, the
// following are both lower case: 'A' and 'a',
// while the following are both upper case:
// '\a' and '\A'.
//
void UndecorateJOName(
    LPCWSTR wstrDecoratedName,
    CHString& chstrUndecoratedJOName)
{
    if(wstrDecoratedName != NULL &&
        *wstrDecoratedName != L'\0')
    {
        LPWSTR wstrDecoratedNameLower = NULL;

        try
        {
            wstrDecoratedNameLower = new WCHAR[wcslen(wstrDecoratedName)+1];

            if(wstrDecoratedNameLower)
            {
                wcscpy(wstrDecoratedNameLower, wstrDecoratedName);
                _wcslwr(wstrDecoratedNameLower);

                WCHAR* p3 = chstrUndecoratedJOName.GetBuffer(
                    wcslen(wstrDecoratedNameLower) + 1);

                const WCHAR* p1 = wstrDecoratedNameLower;
                const WCHAR* p2 = p1 + 1;

                while(*p1 != L'\0')
                {
                    if(*p1 == L'\\')
                    {
                        if(*p2 != NULL)
                        {
                            // Might have any number of
                            // backslashes back to back,
                            // which we will treat as
                            // being the same as one
                            // backslash - i.e., we will
                            // skip over the backslash(s)
                            // and copy over the following
                            // letter.
                            while(*p2 == L'\\')
                            {
                                p2++;
                            };
                    
                            *p3 = towupper(*p2);
                            p3++;

                            p1 = p2 + 1;
                            if(*p1 != L'\0')
                            {
                                p2 = p1 + 1;
                            }
                        }
                        else
                        {
                            p1++;
                        }
                    }
                    else
                    {
                        *p3 = *p1;
                        p3++;

                        p1 = p2;
                        if(*p1 != L'\0')
                        {
                            p2 = p1 + 1;
                        }
                    }
                }
        
                *p3 = NULL;

                chstrUndecoratedJOName.ReleaseBuffer();

                delete wstrDecoratedNameLower;
                wstrDecoratedNameLower = NULL;
            }
        }
        catch(...)
        {
            if(wstrDecoratedNameLower)
            {
                delete wstrDecoratedNameLower;
                wstrDecoratedNameLower = NULL;
            }
            throw;
        }
    }
}


// Does the inverse of the above function.
// However, here, we only need to put in one
// backslash before each uppercase letter.
// CIMOM will add the second backslash.
void DecorateJOName(
    LPCWSTR wstrUndecoratedName,
    CHString& chstrDecoratedJOName)
{
    if(wstrUndecoratedName != NULL &&
        *wstrUndecoratedName != L'\0')
    {
        // Worst case is that we will have
        // a decorated string twice as long
        // as the undecorated string (happens
        // is every character in the undecorated
        // string is a capital letter).
        WCHAR* p3 = chstrDecoratedJOName.GetBuffer(
            2 * (wcslen(wstrUndecoratedName) + 1));

        const WCHAR* p1 = wstrUndecoratedName;

        while(*p1 != L'\0')
        {
            if(iswupper(*p1))
            {
                // Add in a backslash...
                *p3 = L'\\';
                p3++;

                // Add in the character...
                *p3 = *p1;
                
                p3++;
                p1++;
            }
            else
            {
                // Add in the character...
                *p3 = *p1;
                
                p3++;
                p1++;
            }
        }

        *p3 = NULL;
        
        chstrDecoratedJOName.ReleaseBuffer();

        // What if we had a job called Job,
        // and someone specified it in the
        // object path as "Job" instead of
        // "\Job"?  We DON'T want to find it
        // in such a case, because this would
        // appear to not be adhering to our
        // own convention.  Hence, we 
        // lowercase the incoming string.
        chstrDecoratedJOName.MakeLower();
    }
}


// map standard API return values (defined WinError.h)
// to WBEMish hresults (defined in WbemCli.h)
HRESULT WinErrorToWBEMhResult(LONG error)
{
	HRESULT hr = WBEM_E_FAILED;

	switch (error)
	{
		case ERROR_SUCCESS:
			hr = WBEM_S_NO_ERROR;
			break;
		case ERROR_ACCESS_DENIED:
			hr = WBEM_E_ACCESS_DENIED;
			break;
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_OUTOFMEMORY:
			hr = WBEM_E_OUT_OF_MEMORY;
			break;
		case ERROR_ALREADY_EXISTS:
			hr = WBEM_E_ALREADY_EXISTS;
			break;
		case ERROR_BAD_NETPATH:
        case ERROR_INVALID_DATA:
        case ERROR_BAD_PATHNAME:
        case REGDB_E_INVALIDVALUE:
		case ERROR_PATH_NOT_FOUND:
		case ERROR_FILE_NOT_FOUND:
                case ERROR_INVALID_PRINTER_NAME:
		case ERROR_BAD_USERNAME:
        case ERROR_NOT_READY:
        case ERROR_INVALID_NAME:
			hr = WBEM_E_NOT_FOUND;
			break;
		default:
			hr = WBEM_E_FAILED;
	}

	return hr;
}


// Copied from sid.h
bool GetNameAndDomainFromPSID(
    PSID pSid,
    CHString& chstrName,
    CHString& chstrDomain)
{
	bool fRet = false;
    // pSid should be valid...
	_ASSERT( (pSid != NULL) && ::IsValidSid( pSid ) );

	if ( (pSid != NULL) && ::IsValidSid( pSid ) )
	{
		// Initialize account name and domain name
		LPTSTR pszAccountName = NULL;
		LPTSTR pszDomainName = NULL;
		DWORD dwAccountNameSize = 0;
		DWORD dwDomainNameSize = 0;
        DWORD dwLastError = ERROR_SUCCESS;
        BOOL bResult = TRUE;

		try
        {
			// This call should fail
            SID_NAME_USE	snuAccountType;
			bResult = ::LookupAccountSid(   NULL,
											pSid,
											pszAccountName,
											&dwAccountNameSize,
											pszDomainName,
											&dwDomainNameSize,
											&snuAccountType );
			dwLastError = ::GetLastError();

		    if ( ERROR_INSUFFICIENT_BUFFER == dwLastError )
		    {

			    // Allocate buffers
			    if ( dwAccountNameSize != 0 )
                {
				    pszAccountName = (LPTSTR) new TCHAR[ dwAccountNameSize * sizeof(TCHAR) ];
                }

			    if ( dwDomainNameSize != 0 )
                {
				    pszDomainName = (LPTSTR) new TCHAR[ dwDomainNameSize * sizeof(TCHAR) ];
                }

				// Make second call
				bResult = ::LookupAccountSid(   NULL,
												pSid,
												pszAccountName,
												&dwAccountNameSize,
												pszDomainName,
												&dwDomainNameSize,
												&snuAccountType );


			    if ( bResult == TRUE )
			    {
				    chstrName = pszAccountName;
				    chstrDomain = pszDomainName;
			    }
			    else
			    {

				    // There are some accounts that do not have names, such as Logon Ids,
				    // for example S-1-5-X-Y. So this is still legal
				    chstrName = _T("Unknown Account");
				    chstrDomain = _T("Unknown Domain");
			    }

			    if ( NULL != pszAccountName )
			    {
				    delete pszAccountName;
                    pszAccountName = NULL;
			    }

			    if ( NULL != pszDomainName )
			    {
				    delete pszDomainName;
                    pszDomainName = NULL;
			    }

                fRet = true;

		    }	// If ERROR_INSUFFICIENT_BUFFER
        } // try
        catch(...)
        {
            if ( NULL != pszAccountName )
			{
				delete pszAccountName;
                pszAccountName = NULL;
			}

			if ( NULL != pszDomainName )
			{
				delete pszDomainName;
                pszDomainName = NULL;
			}
            throw;
        }
	}	// IF IsValidSid

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\factory.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// Factory.h
#pragma once

class CFactoryData;
class CFactory;

// Global data used by CFactory
extern CFactoryData g_FactoryDataArray[] ;
extern int g_cFactoryDataEntries ;

typedef HRESULT (*FPCREATEINSTANCE)(CUnknown**) ;



///////////////////////////////////////////////////////////
//
// CFactoryData
//   - Information CFactory needs to create a component
//     supported by the DLL
//
class CFactoryData
{
public:

    // The class ID for the component
	const CLSID* m_pCLSID ;

	// Pointer to the function that creates it
	FPCREATEINSTANCE CreateInstance ;

	// Name of the component to register in the registry
	LPCWSTR m_RegistryName ;

	// ProgID
	LPCWSTR m_szProgID ;

	// Version-independent ProgID
	LPCWSTR m_szVerIndProgID ;

	// Helper function for finding the class ID
	BOOL IsClassID(const CLSID& clsid) const
		{ return (*m_pCLSID == clsid) ;}
};




class CFactory : public IClassFactory
{
public:
	// IUnknown
	STDMETHOD(QueryInterface) (const IID& iid, void** ppv);
	STDMETHOD_(ULONG,AddRef) ();
	STDMETHOD_(ULONG,Release)();

	// IClassFactory
	STDMETHOD(CreateInstance) (IUnknown* pUnknownOuter,
	                           const IID& iid,
	                           void** ppv);

	STDMETHOD(LockServer) (BOOL bLock); 

    // Constructor - Pass pointer to data of component to create.
	CFactory(const CFactoryData* pFactoryData) ;

	// Destructor
	~CFactory() { LockServer(FALSE); }


    //
	// Static FactoryData support functions
	//

	// DllGetClassObject support
	static HRESULT GetClassObject(const CLSID& clsid,
	                              const IID& iid, 
	                              void** ppv) ;

	// Helper function for DllCanUnloadNow 
	static BOOL IsLocked()
		{ return (s_cServerLocks > 0) ;}

	// Functions to [un]register all components
	static HRESULT RegisterAll() ;
	static HRESULT UnregisterAll() ;

	// Function to determine if component can be unloaded
	static HRESULT CanUnloadNow() ;


public:
    // Reference count
    long m_cRef ;

	// Pointer to information about class this factory creates
	const CFactoryData* m_pFactoryData ;
      
	// Count of locks
	static LONG s_cServerLocks ;

	// Module handle
	static HMODULE s_hModule ;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\jobase.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JOBase.h

#pragma once


_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));



class CJOBase
{
public:

    CJOBase() {}
    virtual ~CJOBase() {}

    HRESULT Initialize(
         LPWSTR pszUser,
         LONG lFlags,
         LPWSTR pszNamespace,
         LPWSTR pszLocale,
         IWbemServices *pNamespace,
         IWbemContext *pCtx,
         IWbemProviderInitSink *pInitSink);

    HRESULT GetObjectAsync( 
        const BSTR ObjectPath,
        long lFlags,
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        CObjProps& objprops,
        PFN_CHECK_PROPS pfnChk,
        LPWSTR wstrClassName,
        LPCWSTR wstrKeyProp);

    HRESULT ExecQueryAsync( 
        const BSTR QueryLanguage,
        const BSTR Query,
        long lFlags,
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        CObjProps& objprops,
        LPCWSTR wstrClassName,
        LPCWSTR wstrKeyProp);

    HRESULT CreateInstanceEnumAsync( 
        const BSTR Class,
        long lFlags,
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        CObjProps& objprops,
        LPCWSTR wstrClassName);

    HRESULT Enumerate(
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        std::vector<_bstr_t>& rgNamedJOs,
        CObjProps& objprops,
        LPCWSTR wstrClassName);


protected:

    IWbemServicesPtr m_pNamespace;
    CHString m_chstrNamespace;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjectprov.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProv.cpp

//#define _WIN32_WINNT 0x0500 

#include "precomp.h"
//#include <windows.h>
#include "cominit.h"
//#include <objbase.h>
//#include <comdef.h>
#include <objidl.h>
#include "CUnknown.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "globals.h"

#include "Factory.h"
#include "helpers.h"
#include <map>
#include <vector>
#include "SmartHandle.h"
#include <crtdbg.h>
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjProps.h"
#include "JobObjectProv.h"
#include "Helpers.h"



CJobObjectProv::CJobObjectProv()
{
}


CJobObjectProv::~CJobObjectProv()
{
}

/*****************************************************************************/
// QueryInterface override to allow for this component's interface(s)
/*****************************************************************************/
STDMETHODIMP CJobObjectProv::QueryInterface(const IID& iid, void** ppv)
{    
	HRESULT hr = S_OK;

    if(iid == IID_IWbemServices)
    {
        *ppv = static_cast<IWbemServices*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else if(iid == IID_IWbemProviderInit)
    {
        *ppv = static_cast<IWbemProviderInit*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else
    {
        hr = CUnknown::QueryInterface(iid, ppv);
    }

	return hr;
}



/*****************************************************************************/
// Creation function used by CFactory
/*****************************************************************************/
HRESULT CJobObjectProv::CreateInstance(CUnknown** ppNewComponent)
{
	HRESULT hr = S_OK;
    CUnknown* pUnk = NULL;
    pUnk = new CJobObjectProv;
    if(pUnk != NULL)
    {
        *ppNewComponent = pUnk;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
	return hr ;
}

/*****************************************************************************/
// IWbemProviderInit implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjectProv::Initialize(
    LPWSTR pszUser, 
    LONG lFlags,
    LPWSTR pszNamespace, 
    LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(pNamespace) 
    {   // smartptr does the addref
        m_pNamespace = pNamespace;
    }
    m_chstrNamespace = pszNamespace;

    //Let CIMOM know I am initialized...
    return pInitSink->SetStatus(
        WBEM_S_INITIALIZED,
        0);
}


/*****************************************************************************/
// IWbemServices implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjectProv::GetObjectAsync( 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We need the name of the instance they requested...
            WCHAR wstrObjInstKeyVal[MAX_PATH];
            hr = GetObjInstKeyVal(
                   ObjectPath,
                   IDS_Win32_NamedJobObject,
                   g_rgJobObjPropNames[JO_ID], 
                   wstrObjInstKeyVal, 
                   sizeof(wstrObjInstKeyVal) - sizeof(WCHAR));
    
            if(SUCCEEDED(hr))
            {
                // wstrObjInstKeyVal now contains the name of the object.  See if
                // it exists...
                CHString chstrUndecoratedJOName;

                UndecorateJOName(
                    wstrObjInstKeyVal,
                    chstrUndecoratedJOName);

                SmartHandle hJob;
                hJob = ::OpenJobObjectW(
                           MAXIMUM_ALLOWED,
                           FALSE,
                           chstrUndecoratedJOName);

                if(hJob)
                {
                    // We seem to have found one matching the specified name,
                    // so create a return instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    CJobObjProps cjop(hJob, m_chstrNamespace);

                    hr = CreateInst(
                             m_pNamespace,
                             &pIWCO,
                             _bstr_t(IDS_Win32_NamedJobObject),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        cjop.SetReqProps(PROP_ALL_REQUIRED);
                    }
                
                    if(SUCCEEDED(hr))
                    {
                        // set the key properties...
                        hr = cjop.SetKeysFromPath(
                               ObjectPath,
                               pCtx);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested properties...
                        hr = cjop.SetNonKeyReqProps();
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load requested non-key properties 
                        // to the instance...
                        hr = cjop.LoadPropertyValues(
                                 pIWCO);

                        // Commit the instance...
                        if(SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                            hr = pResponseHandler->Indicate(
                                     1,
                                     &pTmp);
                        }
                    }
                }
                else
                {
                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjectProv::ExecQueryAsync( 
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();
        IWbemClassObjectPtr pStatusObject;

        if(SUCCEEDED(hrImp))
        {
            // We will optimize for those cases in which
            // a particular set of named job objects
            // (e.g., 1 or more).  Enumerate also
            // optimizes for the properties that were
            // requested.
            CFrameworkQuery cfwq;
            hr = cfwq.Init(
                     QueryLanguage,
                     Query,
                     lFlags,
                     m_chstrNamespace);

            std::vector<_bstr_t> rgNamedJOs;
            if(SUCCEEDED(hr))
            {
                hr = cfwq.GetValuesForProp(
                         _bstr_t(g_rgJobObjPropNames[JO_ID]), 
                         rgNamedJOs);
            }

            // If none were specifically requested, they
            // want them all...
            if(rgNamedJOs.size() == 0)
            {
                hr = GetJobObjectList(rgNamedJOs);
            }
            else
            {
                // Object paths were specified.  Before
                // passing them along, we need to un-
                // decorate them.
                UndecorateNamesInNamedJONameList(rgNamedJOs);
            }

            // Find out what propeties were requested...
            CJobObjProps cjop(m_chstrNamespace);
            cjop.GetWhichPropsReq(cfwq);

            if(SUCCEEDED(hr))
            {
                hr = Enumerate(
                         pCtx,
                         pResponseHandler,
                         rgNamedJOs,
                         cjop,
                         &pStatusObject);
            }
            else
            {
                SetStatusObject(
                    pCtx,
                    m_pNamespace,
                    -1L,
                    NULL,
                    L"Helpers.cpp::GetJobObjectList",
                    JOB_OBJECT_NAMESPACE,
                    &pStatusObject);
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    hr = pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
    return hr;
}


STDMETHODIMP CJobObjectProv::CreateInstanceEnumAsync( 
    const BSTR Class,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();
    
        if(SUCCEEDED(hrImp))
        {
            if(_wcsicmp(Class, IDS_Win32_NamedJobObject) != NULL)
            {
                hr = WBEM_E_INVALID_CLASS;
            }

            // For every job object, return all properties...
            if(SUCCEEDED(hr))
            {
                // Get a list of named jobs...
                std::vector<_bstr_t> rgNamedJOs;
                hr = GetJobObjectList(rgNamedJOs);

                if(SUCCEEDED(hr))
                {
                    CJobObjProps cjop(m_chstrNamespace);
                    cjop.SetReqProps(PROP_ALL_REQUIRED);
                    hr = Enumerate(
                             pCtx,
                             pResponseHandler,
                             rgNamedJOs,
                             cjop,
                             &pStatusObject);
                }
                else
                {
                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        -1L,
                        NULL,
                        L"Helpers.cpp::GetJobObjectList",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}





/*****************************************************************************/
// Private member function implementations
/*****************************************************************************/             
HRESULT CJobObjectProv::Enumerate(
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    std::vector<_bstr_t>& rgNamedJOs,
    CJobObjProps& cjop,
    IWbemClassObject** ppStatusObject)
{
    HRESULT hr = S_OK;

    try // CVARIANT can throw and I want the error...
    {
        long lNumJobs = rgNamedJOs.size();

        if(lNumJobs > 0)
        {
            SmartHandle hJob;

            for(long m = 0L; m < lNumJobs && SUCCEEDED(hr); m++)
            {
                cjop.ClearProps();

                // We have the name of a JO; need to open it up
                // and get its properties...
                hJob = ::OpenJobObjectW(
                   MAXIMUM_ALLOWED,
                   FALSE,
                   rgNamedJOs[m]);

                // (NOTE: hJob smarthandle class automatically
                // closes its handle on destruction and on
                // reassignment.)
                if(hJob)
                {
                    // Set the handle...
                    cjop.SetHandle(hJob);

                    // Set the key properties directly...
                    CHString chstrDecoratedJOName;
                    DecorateJOName(
                        rgNamedJOs[m],
                        chstrDecoratedJOName);

                    std::vector<CVARIANT> vecvKeys;
                    CVARIANT vID(chstrDecoratedJOName);
                    vecvKeys.push_back(vID);
                    hr = cjop.SetKeysDirect(vecvKeys);

                    if(FAILED(hr))
                    {
                        SetStatusObject(
                            pCtx,
                            m_pNamespace,
                            ::GetLastError(),
                            NULL,
                            L"CJobObjProps::SetKeysDirect",
                            JOB_OBJECT_NAMESPACE,
                            ppStatusObject);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested 
                        // properties...
                        hr = cjop.SetNonKeyReqProps();

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjProps::SetNonKeyReqProps",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Create a new outgoing instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    if(SUCCEEDED(hr))
                    {
                        hr = CreateInst(
                                 m_pNamespace,
                                 &pIWCO,
                                 _bstr_t(IDS_Win32_NamedJobObject),
                                 pCtx);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjectProv::CreateInst",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Load the properties of the 
                    // new outgoing instance...
                    if(SUCCEEDED(hr))
                    {
                        hr = cjop.LoadPropertyValues(pIWCO);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjProps::LoadPropertyValues",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // And send it out...
                    if(SUCCEEDED(hr))
                    {
                        IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                        hr = pResponseHandler->Indicate(
                                 1, 
                                 &pTmp);
                    }
                }
                else
                {
                    _ASSERT(0);

                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"CJobObjectProv::Enumerate",
                        JOB_OBJECT_NAMESPACE,
                        ppStatusObject);
                }
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjioactginfoprov.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjIOActgInfoProv.cpp

//#define _WIN32_WINNT 0x0500 

#include "precomp.h"
//#include <windows.h>
#include "cominit.h"
//#include <objbase.h>
//#include <comdef.h>

#include "CUnknown.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "globals.h"

#include "Factory.h"
#include "helpers.h"
#include <map>
#include <vector>
#include "SmartHandle.h"
#include <crtdbg.h>
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjIOActgProps.h"
#include "JobObjIOActgInfoProv.h"





/*****************************************************************************/
// QueryInterface override to allow for this component's interface(s)
/*****************************************************************************/
STDMETHODIMP CJobObjIOActgInfoProv::QueryInterface(const IID& iid, void** ppv)
{    
	HRESULT hr = S_OK;

    if(iid == IID_IWbemServices)
    {
        *ppv = static_cast<IWbemServices*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else if(iid == IID_IWbemProviderInit)
    {
        *ppv = static_cast<IWbemProviderInit*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else
    {
        hr = CUnknown::QueryInterface(iid, ppv);
    }

	return hr;
}



/*****************************************************************************/
// Creation function used by CFactory
/*****************************************************************************/
HRESULT CJobObjIOActgInfoProv::CreateInstance(CUnknown** ppNewComponent)
{
	HRESULT hr = S_OK;
    CUnknown* pUnk = NULL;
    pUnk = new CJobObjIOActgInfoProv;
    if(pUnk != NULL)
    {
        *ppNewComponent = pUnk;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
	return hr ;
}

/*****************************************************************************/
// IWbemProviderInit implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjIOActgInfoProv::Initialize(
    LPWSTR pszUser, 
    LONG lFlags,
    LPWSTR pszNamespace, 
    LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    m_pNamespace = pNamespace;
    m_chstrNamespace = pszNamespace;
    //Let CIMOM know you are initialized
    //==================================
    
    return pInitSink->SetStatus(
        WBEM_S_INITIALIZED,
        0);
}


/*****************************************************************************/
// IWbemServices implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjIOActgInfoProv::GetObjectAsync( 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We need the name of the instance they requested...
            WCHAR wstrObjInstKeyVal[MAX_PATH];
            hr = GetObjInstKeyVal(
                   ObjectPath,
                   IDS_Win32_JobObjectIOAccountingInfo,
                   g_rgJobObjIOActgPropNames[JOIOACTGPROP_ID], 
                   wstrObjInstKeyVal, 
                   sizeof(wstrObjInstKeyVal) - sizeof(WCHAR));
    
            if(SUCCEEDED(hr))
            {
                // wstrObjInstKeyVal now contains the name of the object.  See if
                // it exists...
                CHString chstrUndecoratedJOName;

                UndecorateJOName(
                    wstrObjInstKeyVal,
                    chstrUndecoratedJOName);

                SmartHandle hJob;
                hJob = ::OpenJobObjectW(
                           MAXIMUM_ALLOWED,
                           FALSE,
                           chstrUndecoratedJOName);

                if(hJob)
                {
                    // We seem to have found one matching the specified name,
                    // so create a return instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    CJobObjIOActgProps cjoioap(hJob, m_chstrNamespace);

                    hr = CreateInst(
                             m_pNamespace,
                             &pIWCO,
                             _bstr_t(IDS_Win32_JobObjectIOAccountingInfo),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        cjoioap.SetReqProps(PROP_ALL_REQUIRED);;
                    }
                
                    if(SUCCEEDED(hr))
                    {
                        // set the key properties...
                        hr = cjoioap.SetKeysFromPath(
                               ObjectPath,
                               pCtx);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested properties...
                        hr = cjoioap.SetNonKeyReqProps();
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load requested non-key properties 
                        // to the instance...
                        hr = cjoioap.LoadPropertyValues(
                                 pIWCO);

                        // Commit the instance...
                        if(SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                            hr = pResponseHandler->Indicate(
                                     1,
                                     &pTmp);
                        }
                    }
                }
                else
                {
                    _ASSERT(0);

                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjIOActgInfoProv::ExecQueryAsync( 
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We will optimize for those cases in which
            // a particular set of named job objects
            // (e.g., 1 or more).  Enumerate also
            // optimizes for the properties that were
            // requested.
            CFrameworkQuery cfwq;
            hr = cfwq.Init(
                     QueryLanguage,
                     Query,
                     lFlags,
                     m_chstrNamespace);

            std::vector<_bstr_t> rgNamedJOs;
            if(SUCCEEDED(hr))
            {
                hr = cfwq.GetValuesForProp(
                         _bstr_t(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ID]), 
                         rgNamedJOs);
            }

            // If none were specifically requested, they
            // want them all...
            if(rgNamedJOs.size() == 0)
            {
                hr = GetJobObjectList(rgNamedJOs);
            }
            else
            {
                // Object paths were specified.  Before
                // passing them along, we need to un-
                // decorate them.
                UndecorateNamesInNamedJONameList(rgNamedJOs);
            }

            // Find out what propeties were requested...
            CJobObjIOActgProps cjoioap(m_chstrNamespace);
            cjoioap.GetWhichPropsReq(cfwq);

            if(SUCCEEDED(hr))
            {
                hr = Enumerate(
                         pCtx,
                         pResponseHandler,
                         rgNamedJOs,
                         cjoioap,
                         &pStatusObject);
            }
            else
            {
                SetStatusObject(
                    pCtx,
                    m_pNamespace,
                    -1L,
                    NULL,
                    L"helpers.cpp::GetJobObjectList",
                    JOB_OBJECT_NAMESPACE,
                    &pStatusObject);
            }
        
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjIOActgInfoProv::CreateInstanceEnumAsync( 
    const BSTR Class,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            if(_wcsicmp(
                   Class, 
                   IDS_Win32_JobObjectIOAccountingInfo) != NULL)
            {
                hr = WBEM_E_INVALID_CLASS;
            }

            // For every job object, return all accounting
            // info properties...
            if(SUCCEEDED(hr))
            {
                // Get a list of named jobs...
                std::vector<_bstr_t> rgNamedJOs;
                hr = GetJobObjectList(rgNamedJOs);

                if(SUCCEEDED(hr))
                {
                    CJobObjIOActgProps cjoioap(m_chstrNamespace);
                    cjoioap.SetReqProps(PROP_ALL_REQUIRED);
                    hr = Enumerate(
                             pCtx,
                             pResponseHandler,
                             rgNamedJOs,
                             cjoioap,
                             &pStatusObject);
                }
                else
                {
                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        -1L,
                        NULL,
                        L"helpers.cpp::GetJobObjectList",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}







/*****************************************************************************/
// Private member function implementations
/*****************************************************************************/             
HRESULT CJobObjIOActgInfoProv::Enumerate(
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    std::vector<_bstr_t>& rgNamedJOs,
    CJobObjIOActgProps& cjoaip,
    IWbemClassObject** ppStatusObject)
{
    HRESULT hr = S_OK;

    long lNumJobs = rgNamedJOs.size();

    try // CVARIANT can throw and I want the error...
    {
        if(lNumJobs > 0)
        {
            SmartHandle hJob;

            for(long m = 0L; m < lNumJobs && SUCCEEDED(hr); m++)
            {
                cjoaip.ClearProps();

                // We have the name of a JO; need to open it up
                // and get its properties...
                hJob = ::OpenJobObjectW(
                   MAXIMUM_ALLOWED,
                   FALSE,
                   rgNamedJOs[m]);

                // (NOTE: hJob smarthandle class automatically
                // closes its handle on destruction and on
                // reassignment.)
                if(hJob)
                {
                    // Set the handle...
                    cjoaip.SetHandle(hJob);

                    // Set the key properties directly...
                    CHString chstrDecoratedJOName;
                    DecorateJOName(
                        rgNamedJOs[m],
                        chstrDecoratedJOName);

                    std::vector<CVARIANT> vecvKeys;
                    CVARIANT vID(chstrDecoratedJOName);
                    vecvKeys.push_back(vID);
                    hr = cjoaip.SetKeysDirect(vecvKeys);

                    if(FAILED(hr))
                    {
                        SetStatusObject(
                            pCtx,
                            m_pNamespace,
                            ::GetLastError(),
                            NULL,
                            L"CJobObjIOActgProps::SetKeysDirect",
                            JOB_OBJECT_NAMESPACE,
                            ppStatusObject);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested 
                        // properties...
                        hr = cjoaip.SetNonKeyReqProps();
                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjIOActgProps::SetNonKeyReqProps",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Create a new outgoing instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    if(SUCCEEDED(hr))
                    {
                        hr = CreateInst(
                                 m_pNamespace,
                                 &pIWCO,
                                 _bstr_t(IDS_Win32_JobObjectIOAccountingInfo),
                                 pCtx);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjIOActgInfoProv::CreateInst",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Load the properties of the 
                    // new outgoing instance...
                    if(SUCCEEDED(hr))
                    {
                        hr = cjoaip.LoadPropertyValues(pIWCO);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjIOActgInfoProv::LoadPropertyValues",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // And send it out...
                    if(SUCCEEDED(hr))
                    {
                        IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                        hr = pResponseHandler->Indicate(
                                 1, 
                                 &pTmp);
                    }
                }
                else
                {
                    _ASSERT(0);

                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        ppStatusObject);
                }
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjlimitinfoprov.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjLimitInfoProv.cpp

//#define _WIN32_WINNT 0x0500 

#include "precomp.h"
//#include <windows.h>
#include "cominit.h"
//#include <objbase.h>
//#include <comdef.h>

#include "CUnknown.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "globals.h"

#include "Factory.h"
#include "helpers.h"
#include <map>
#include <vector>
#include "SmartHandle.h"
#include <crtdbg.h>
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjLimitInfoProps.h"
#include "JobObjLimitInfoProv.h"





/*****************************************************************************/
// QueryInterface override to allow for this component's interface(s)
/*****************************************************************************/
STDMETHODIMP CJobObjLimitInfoProv::QueryInterface(const IID& iid, void** ppv)
{    
	HRESULT hr = S_OK;

    if(iid == IID_IWbemServices)
    {
        *ppv = static_cast<IWbemServices*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else if(iid == IID_IWbemProviderInit)
    {
        *ppv = static_cast<IWbemProviderInit*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else
    {
        hr = CUnknown::QueryInterface(iid, ppv);
    }

	return hr;
}



/*****************************************************************************/
// Creation function used by CFactory
/*****************************************************************************/
HRESULT CJobObjLimitInfoProv::CreateInstance(CUnknown** ppNewComponent)
{
	HRESULT hr = S_OK;
    CUnknown* pUnk = NULL;
    pUnk = new CJobObjLimitInfoProv;
    if(pUnk != NULL)
    {
        *ppNewComponent = pUnk;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
	return hr ;
}

/*****************************************************************************/
// IWbemProviderInit implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjLimitInfoProv::Initialize(
    LPWSTR pszUser, 
    LONG lFlags,
    LPWSTR pszNamespace, 
    LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    m_pNamespace = pNamespace;
    m_chstrNamespace = pszNamespace;
    //Let CIMOM know you are initialized
    //==================================
    
    return pInitSink->SetStatus(
        WBEM_S_INITIALIZED,
        0);
}


/*****************************************************************************/
// IWbemServices implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjLimitInfoProv::GetObjectAsync( 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We need the name of the instance they requested...
            WCHAR wstrObjInstKeyVal[MAX_PATH];
            hr = GetObjInstKeyVal(
                   ObjectPath,
                   IDS_Win32_NamedJobObjectLimitSetting,
                   g_rgJobObjLimitInfoPropNames[JOLMTPROP_ID], 
                   wstrObjInstKeyVal, 
                   sizeof(wstrObjInstKeyVal) - sizeof(WCHAR));
    
            if(SUCCEEDED(hr))
            {
                // wstrObjInstKeyVal now contains the name of the object.  See if
                // it exists...
                CHString chstrUndecoratedJOName;

                UndecorateJOName(
                    wstrObjInstKeyVal,
                    chstrUndecoratedJOName);

                SmartHandle hJob;
                hJob = ::OpenJobObjectW(
                           MAXIMUM_ALLOWED,
                           FALSE,
                           chstrUndecoratedJOName);

                if(hJob)
                {
                    // We seem to have found one matching the specified name,
                    // so create a return instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    CJobObjLimitInfoProps cjolip(hJob, m_chstrNamespace);

                    hr = CreateInst(
                             m_pNamespace,
                             &pIWCO,
                             _bstr_t(IDS_Win32_NamedJobObjectLimitSetting),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        cjolip.SetReqProps(PROP_ALL_REQUIRED);;
                    }
                
                    if(SUCCEEDED(hr))
                    {
                        // set the key properties...
                        hr = cjolip.SetKeysFromPath(
                               ObjectPath,
                               pCtx);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested properties...
                        hr = cjolip.SetNonKeyReqProps();
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load requested non-key properties 
                        // to the instance...
                        hr = cjolip.LoadPropertyValues(
                                 pIWCO);

                        // Commit the instance...
                        if(SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                            hr = pResponseHandler->Indicate(
                                     1,
                                     &pTmp);
                        }
                    }
                }
                else
                {
                    _ASSERT(0);

                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjLimitInfoProv::ExecQueryAsync( 
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;
    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We will optimize for those cases in which
            // a particular set of named job objects
            // (e.g., 1 or more).  Enumerate also
            // optimizes for the properties that were
            // requested.
            CFrameworkQuery cfwq;
            hr = cfwq.Init(
                     QueryLanguage,
                     Query,
                     lFlags,
                     m_chstrNamespace);

            std::vector<_bstr_t> rgNamedJOs;
            if(SUCCEEDED(hr))
            {
                hr = cfwq.GetValuesForProp(
                         _bstr_t(g_rgJobObjLimitInfoPropNames[JOLMTPROP_ID]), 
                         rgNamedJOs);
            }

            // If none were specifically requested, they
            // want them all...
            if(rgNamedJOs.size() == 0)
            {
                hr = GetJobObjectList(rgNamedJOs);
            }
            else
            {
                // Object paths were specified.  Before
                // passing them along, we need to un-
                // decorate them.
                UndecorateNamesInNamedJONameList(rgNamedJOs);
            }

            // Find out what propeties were requested...
            CJobObjLimitInfoProps cjolip(m_chstrNamespace);
            cjolip.GetWhichPropsReq(cfwq);

            if(SUCCEEDED(hr))
            {
                hr = Enumerate(
                         pCtx,
                         pResponseHandler,
                         rgNamedJOs,
                         cjolip,
                         &pStatusObject);
            }
            else
            {
                SetStatusObject(
                    pCtx,
                    m_pNamespace,
                    -1L,
                    NULL,
                    L"helpers.cpp::GetJobObjectList",
                    JOB_OBJECT_NAMESPACE,
                    &pStatusObject);
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjLimitInfoProv::CreateInstanceEnumAsync( 
    const BSTR Class,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            if(_wcsicmp(
                   Class, 
                   IDS_Win32_NamedJobObjectLimitSetting) != NULL)
            {
                hr = WBEM_E_INVALID_CLASS;
            }

            // For every job object, return all accounting
            // info properties...
            if(SUCCEEDED(hr))
            {
                // Get a list of named jobs...
                std::vector<_bstr_t> rgNamedJOs;
                hr = GetJobObjectList(rgNamedJOs);

                if(SUCCEEDED(hr))
                {
                    CJobObjLimitInfoProps cjolip(m_chstrNamespace);
                    cjolip.SetReqProps(PROP_ALL_REQUIRED);
                    hr = Enumerate(
                             pCtx,
                             pResponseHandler,
                             rgNamedJOs,
                             cjolip,
                             &pStatusObject);
                }
                else
                {
                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        -1L,
                        NULL,
                        L"helpers.cpp::GetJobObjectList",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}







/*****************************************************************************/
// Private member function implementations
/*****************************************************************************/             
HRESULT CJobObjLimitInfoProv::Enumerate(
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    std::vector<_bstr_t>& rgNamedJOs,
    CJobObjLimitInfoProps& cjolip,
    IWbemClassObject** ppStatusObject)
{
    HRESULT hr = S_OK;

    long lNumJobs = rgNamedJOs.size();

    try // CVARIANT can throw and I want the error...
    {
        if(lNumJobs > 0)
        {
            SmartHandle hJob;

            for(long m = 0L; m < lNumJobs && SUCCEEDED(hr); m++)
            {
                cjolip.ClearProps();

                // We have the name of a JO; need to open it up
                // and get its properties...
                hJob = ::OpenJobObjectW(
                   MAXIMUM_ALLOWED,
                   FALSE,
                   rgNamedJOs[m]);

                // (NOTE: hJob smarthandle class automatically
                // closes its handle on destruction and on
                // reassignment.)
                if(hJob)
                {
                    // Set the handle...
                    cjolip.SetHandle(hJob);

                    // Set the key properties directly...
                    CHString chstrDecoratedJOName;
                    DecorateJOName(
                        rgNamedJOs[m],
                        chstrDecoratedJOName);

                    std::vector<CVARIANT> vecvKeys;
                    CVARIANT vID(chstrDecoratedJOName);
                    vecvKeys.push_back(vID);
                    hr = cjolip.SetKeysDirect(vecvKeys);

                    if(FAILED(hr))
                    {
                        SetStatusObject(
                            pCtx,
                            m_pNamespace,
                            ::GetLastError(),
                            NULL,
                            L"CJobObjLimitInfoProps::SetKeysDirect",
                            JOB_OBJECT_NAMESPACE,
                            ppStatusObject);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested 
                        // properties...
                        hr = cjolip.SetNonKeyReqProps();

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjLimitInfoProps::SetNonKeyReqProps",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Create a new outgoing instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    if(SUCCEEDED(hr))
                    {
                        hr = CreateInst(
                                 m_pNamespace,
                                 &pIWCO,
                                 _bstr_t(IDS_Win32_NamedJobObjectLimitSetting),
                                 pCtx);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjLimitInfoProv::CreateInst",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Load the properties of the 
                    // new outgoing instance...
                    if(SUCCEEDED(hr))
                    {
                        hr = cjolip.LoadPropertyValues(pIWCO);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjLimitInfoProps::LoadPropertyValues",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // And send it out...
                    if(SUCCEEDED(hr))
                    {
                        IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                        hr = pResponseHandler->Indicate(
                                 1, 
                                 &pTmp);
                    }
                }
                else
                {
                    _ASSERT(0);

                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        ppStatusObject);
                }
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjectprov.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProv.h

#pragma once



#define JOB_OBJECT_PROVIDER L"NamedJobObjectProv"




_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

/*****************************************************************************/
// Component 
/*****************************************************************************/

class CJobObjectProv;

class CJobObjectProv : public CUnknown,
                       public IWbemServices,
                       public IWbemProviderInit   
{
public:	
	// IDispatch declaration and implementation
    DECLARE_IUNKNOWN

    // Constructor
	CJobObjectProv();

	// Destructor
	virtual ~CJobObjectProv();
    
    // Creation
	static HRESULT CreateInstance(CUnknown** ppNewComponent);

    // Interface IWbemProviderInit
    STDMETHOD(Initialize)(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink);

    SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

    // Interface IWbemServices  
	  STDMETHOD(OpenNamespace)( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CancelAsyncCall)( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;}
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObject)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObjectAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(PutClass)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutClassAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClass)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClassAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnum)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnumAsync)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstance)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstanceAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstance)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstanceAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnum)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnumAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecNotificationQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecNotificationQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecMethod)( const BSTR, const BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

    STDMETHOD(ExecMethodAsync)( const BSTR, const BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}



private:
    
    HRESULT Enumerate(
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        std::vector<_bstr_t>& rgNamedJOs,
        CJobObjProps& cjop,
        IWbemClassObject** ppStatusObject);

    IWbemServicesPtr m_pNamespace;

    CHString m_chstrNamespace;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjioactginfoprov.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjIOActgProv.h

#pragma once





_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));

/*****************************************************************************/
// Component 
/*****************************************************************************/


class CJobObjIOActgInfoProv : public CUnknown,
                              public IWbemServices, 
                              public IWbemProviderInit   
{
public:	
	// IDispatch declaration and implementation
    DECLARE_IUNKNOWN

    // Constructor
	CJobObjIOActgInfoProv(){}

	// Destructor
	virtual ~CJobObjIOActgInfoProv(){}
    
    // Creation
	static HRESULT CreateInstance(CUnknown** ppNewComponent);
	
    // Interface IWbemProviderInit
    STDMETHOD(Initialize)(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink);

    SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

    // Interface IWbemServices  
	  STDMETHOD(OpenNamespace)( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CancelAsyncCall)( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;}
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObject)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObjectAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(PutClass)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutClassAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClass)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClassAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnum)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnumAsync)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstance)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstanceAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstance)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstanceAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnum)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnumAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecNotificationQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecNotificationQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecMethod)( const BSTR, const BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

    STDMETHOD(ExecMethodAsync)( const BSTR, const BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

private:
    
    HRESULT Enumerate(
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        std::vector<_bstr_t>& rgNamedJOs,
        CJobObjIOActgProps& cjoioap,
        IWbemClassObject** ppStatusObject);

    IWbemServicesPtr m_pNamespace;

    CHString m_chstrNamespace;
        
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjseclimitinfoprov.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjSecLimitInfoProv.cpp

//#define _WIN32_WINNT 0x0500 

#include "precomp.h"
//#include <windows.h>
#include "cominit.h"
//#include <objbase.h>
//#include <comdef.h>

#include "CUnknown.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "globals.h"

#include "Factory.h"
#include "helpers.h"
#include <map>
#include <vector>
#include "SmartHandle.h"
#include <crtdbg.h>
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjSecLimitInfoProps.h"
#include "JobObjSecLimitInfoProv.h"





/*****************************************************************************/
// QueryInterface override to allow for this component's interface(s)
/*****************************************************************************/
STDMETHODIMP CJobObjSecLimitInfoProv::QueryInterface(const IID& iid, void** ppv)
{    
	HRESULT hr = S_OK;

    if(iid == IID_IWbemServices)
    {
        *ppv = static_cast<IWbemServices*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else if(iid == IID_IWbemProviderInit)
    {
        *ppv = static_cast<IWbemProviderInit*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else
    {
        hr = CUnknown::QueryInterface(iid, ppv);
    }

	return hr;
}



/*****************************************************************************/
// Creation function used by CFactory
/*****************************************************************************/
HRESULT CJobObjSecLimitInfoProv::CreateInstance(CUnknown** ppNewComponent)
{
	HRESULT hr = S_OK;
    CUnknown* pUnk = NULL;
    pUnk = new CJobObjSecLimitInfoProv;
    if(pUnk != NULL)
    {
        *ppNewComponent = pUnk;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
	return hr ;
}

/*****************************************************************************/
// IWbemProviderInit implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjSecLimitInfoProv::Initialize(
    LPWSTR pszUser, 
    LONG lFlags,
    LPWSTR pszNamespace, 
    LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    m_pNamespace = pNamespace;
    m_chstrNamespace = pszNamespace;
    //Let CIMOM know you are initialized
    //==================================
    
    return pInitSink->SetStatus(
        WBEM_S_INITIALIZED,
        0);
}


/*****************************************************************************/
// IWbemServices implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjSecLimitInfoProv::GetObjectAsync( 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We need the name of the instance they requested...
            WCHAR wstrObjInstKeyVal[MAX_PATH];
            hr = GetObjInstKeyVal(
                   ObjectPath,
                   IDS_Win32_NamedJobObjectSecLimitSetting,
                   g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_ID], 
                   wstrObjInstKeyVal, 
                   sizeof(wstrObjInstKeyVal) - sizeof(WCHAR));
    
            if(SUCCEEDED(hr))
            {
                // wstrObjInstKeyVal now contains the name of the object.  See if
                // it exists...
                CHString chstrUndecoratedJOName;

                UndecorateJOName(
                    wstrObjInstKeyVal,
                    chstrUndecoratedJOName);

                SmartHandle hJob;
                hJob = ::OpenJobObjectW(
                           MAXIMUM_ALLOWED,
                           FALSE,
                           chstrUndecoratedJOName);

                if(hJob)
                {
                    // We seem to have found one matching the specified name,
                    // so create a return instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    CJobObjSecLimitInfoProps cjoslip(hJob, m_chstrNamespace);

                    hr = CreateInst(
                             m_pNamespace,
                             &pIWCO,
                             _bstr_t(IDS_Win32_NamedJobObjectSecLimitSetting),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        cjoslip.SetReqProps(PROP_ALL_REQUIRED);
                    }
                
                    if(SUCCEEDED(hr))
                    {
                        // set the key properties...
                        hr = cjoslip.SetKeysFromPath(
                               ObjectPath,
                               pCtx);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested properties...
                        hr = cjoslip.SetNonKeyReqProps();
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load requested non-key properties 
                        // to the instance...
                        hr = cjoslip.LoadPropertyValues(
                                 pIWCO,
                                 pCtx,
                                 m_pNamespace);

                        // Commit the instance...
                        if(SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                            hr = pResponseHandler->Indicate(
                                     1,
                                     &pTmp);
                        }
                    }
                }
                else
                {
                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjSecLimitInfoProv::ExecQueryAsync( 
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We will optimize for those cases in which
            // a particular set of named job objects
            // (e.g., 1 or more).  Enumerate also
            // optimizes for the properties that were
            // requested.
            CFrameworkQuery cfwq;
            hr = cfwq.Init(
                     QueryLanguage,
                     Query,
                     lFlags,
                     m_chstrNamespace);

            std::vector<_bstr_t> rgNamedJOs;
            if(SUCCEEDED(hr))
            {
                hr = cfwq.GetValuesForProp(
                         _bstr_t(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_ID]), 
                         rgNamedJOs);
            }

            // If none were specifically requested, they
            // want them all...
            if(rgNamedJOs.size() == 0)
            {
                hr = GetJobObjectList(rgNamedJOs);
            }
            else
            {
                // Object paths were specified.  Before
                // passing them along, we need to un-
                // decorate them.
                UndecorateNamesInNamedJONameList(rgNamedJOs);
            }
    
            // Find out what propeties were requested...
            CJobObjSecLimitInfoProps cjoslip(m_chstrNamespace);
            cjoslip.GetWhichPropsReq(cfwq);

            if(SUCCEEDED(hr))
            {
                hr = Enumerate(
                         pCtx,
                         pResponseHandler,
                         rgNamedJOs,
                         cjoslip,
                         &pStatusObject);
            }
            else
            {
                SetStatusObject(
                    pCtx,
                    m_pNamespace,
                    -1L,
                    NULL,
                    L"Helpers.cpp::GetJobObjectList",
                    JOB_OBJECT_NAMESPACE,
                    &pStatusObject);
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjSecLimitInfoProv::CreateInstanceEnumAsync( 
    const BSTR Class,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            if(_wcsicmp(
                   Class, 
                   IDS_Win32_NamedJobObjectSecLimitSetting) != NULL)
            {
                hr = WBEM_E_INVALID_CLASS;
            }

            // For every job object, return all accounting
            // info properties...
            if(SUCCEEDED(hr))
            {
                // Get a list of named jobs...
                std::vector<_bstr_t> rgNamedJOs;
                hr = GetJobObjectList(rgNamedJOs);

                if(SUCCEEDED(hr))
                {
                    CJobObjSecLimitInfoProps cjoslip(m_chstrNamespace);
                    cjoslip.SetReqProps(PROP_ALL_REQUIRED);
                    hr = Enumerate(
                             pCtx,
                             pResponseHandler,
                             rgNamedJOs,
                             cjoslip,
                             &pStatusObject);
                }
                else
                {
                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        -1L,
                        NULL,
                        L"Helpers.cpp::GetJobObjectList",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}






/*****************************************************************************/
// Private member function implementations
/*****************************************************************************/             
HRESULT CJobObjSecLimitInfoProv::Enumerate(
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    std::vector<_bstr_t>& rgNamedJOs,
    CJobObjSecLimitInfoProps& cjoslip,
    IWbemClassObject** ppStatusObject)
{
    HRESULT hr = S_OK;

    hr = CheckImpersonationLevel();

    try // CVARIANT can throw and I want the error...
    {
        if(SUCCEEDED(hr))
        {
            long lNumJobs = rgNamedJOs.size();

            if(lNumJobs > 0)
            {
                SmartHandle hJob;

                for(long m = 0L; m < lNumJobs && SUCCEEDED(hr); m++)
                {
                    cjoslip.ClearProps();

                    // We have the name of a JO; need to open it up
                    // and get its properties...
                    hJob = ::OpenJobObjectW(
                       MAXIMUM_ALLOWED,
                       FALSE,
                       rgNamedJOs[m]);
                    // (NOTE: hJob smarthandle class automatically
                    // closes its handle on destruction and on
                    // reassignment.)
                    if(hJob)
                    {
                        // Set the handle...
                        cjoslip.SetHandle(hJob);

                        // Set the key properties directly...
                        CHString chstrDecoratedJOName;
                        DecorateJOName(
                            rgNamedJOs[m],
                            chstrDecoratedJOName);

                        std::vector<CVARIANT> vecvKeys;
                        CVARIANT vID(chstrDecoratedJOName);
                        vecvKeys.push_back(vID);
                        hr = cjoslip.SetKeysDirect(vecvKeys);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjSecLimitInfoProps::SetKeysDirect",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }

                        if(SUCCEEDED(hr))
                        {
                            // set the non-key requested 
                            // properties...
                            hr = cjoslip.SetNonKeyReqProps();

                            if(FAILED(hr))
                            {
                                SetStatusObject(
                                    pCtx,
                                    m_pNamespace,
                                    ::GetLastError(),
                                    NULL,
                                    L"CJobObjSecLimitInfoProps::SetNonKeyReqProps",
                                    JOB_OBJECT_NAMESPACE,
                                    ppStatusObject);
                            }
                        }

                        // Create a new outgoing instance...
                        IWbemClassObjectPtr pIWCO = NULL;
                        if(SUCCEEDED(hr))
                        {
                            hr = CreateInst(
                                     m_pNamespace,
                                     &pIWCO,
                                     _bstr_t(IDS_Win32_NamedJobObjectSecLimitSetting),
                                     pCtx);

                            if(FAILED(hr))
                            {
                                SetStatusObject(
                                    pCtx,
                                    m_pNamespace,
                                    ::GetLastError(),
                                    NULL,
                                    L"CJobObjSecLimitInfoProv::CreateInst",
                                    JOB_OBJECT_NAMESPACE,
                                    ppStatusObject);
                            }
                        }

                        // Load the properties of the 
                        // new outgoing instance...
                        if(SUCCEEDED(hr))
                        {
                            hr = cjoslip.LoadPropertyValues(
                                     pIWCO,
                                     pCtx,
                                     m_pNamespace);

                            if(FAILED(hr))
                            {
                                SetStatusObject(
                                    pCtx,
                                    m_pNamespace,
                                    ::GetLastError(),
                                    NULL,
                                    L"CJobObjSecLimitInfoProps::LoadPropertyValues",
                                    JOB_OBJECT_NAMESPACE,
                                    ppStatusObject);
                            }
                        }

                        // And send it out...
                        if(SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                            hr = pResponseHandler->Indicate(
                                     1, 
                                     &pTmp);
                        }
                    }
                    else
                    {
                        _ASSERT(0);

                        hr = WBEM_E_NOT_FOUND;

                        SetStatusObject(
                            pCtx,
                            m_pNamespace,
                            ::GetLastError(),
                            NULL,
                            L"::OpenJobObject",
                            JOB_OBJECT_NAMESPACE,
                            ppStatusObject);
                    }
                }
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjseclimitinfoprov.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjSecLimitInfoProv.h

#pragma once





_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));

/*****************************************************************************/
// Component 
/*****************************************************************************/


class CJobObjSecLimitInfoProv : public CUnknown,
                                public IWbemServices, 
                                public IWbemProviderInit   
{
public:	
	// IDispatch declaration and implementation
    DECLARE_IUNKNOWN

    // Constructor
	CJobObjSecLimitInfoProv(){}

	// Destructor
	virtual ~CJobObjSecLimitInfoProv(){}
    
    // Creation
	static HRESULT CreateInstance(CUnknown** ppNewComponent);
	
    // Interface IWbemProviderInit
    STDMETHOD(Initialize)(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink);

    SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

    // Interface IWbemServices  
	  STDMETHOD(OpenNamespace)( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CancelAsyncCall)( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;}
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObject)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObjectAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(PutClass)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutClassAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClass)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClassAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnum)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnumAsync)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstance)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstanceAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstance)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstanceAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnum)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnumAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecNotificationQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecNotificationQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecMethod)( const BSTR, const BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

    STDMETHOD(ExecMethodAsync)( const BSTR, const BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

private:
    
    HRESULT Enumerate(
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        std::vector<_bstr_t>& rgNamedJOs,
        CJobObjSecLimitInfoProps& cjoslip,
        IWbemClassObject** ppStatusObject);

    IWbemServicesPtr m_pNamespace;

    CHString m_chstrNamespace;
        
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjlimitinfoprov.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjLimitInfoProv.h

#pragma once





_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));

/*****************************************************************************/
// Component 
/*****************************************************************************/


class CJobObjLimitInfoProv : public CUnknown,
                             public IWbemServices, 
                             public IWbemProviderInit   
{
public:	
	// IDispatch declaration and implementation
    DECLARE_IUNKNOWN

    // Constructor
	CJobObjLimitInfoProv(){}

	// Destructor
	virtual ~CJobObjLimitInfoProv(){}
    
    // Creation
	static HRESULT CreateInstance(CUnknown** ppNewComponent);
	
    // Interface IWbemProviderInit
    STDMETHOD(Initialize)(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink);

    SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

    // Interface IWbemServices  
	  STDMETHOD(OpenNamespace)( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CancelAsyncCall)( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;}
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObject)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObjectAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(PutClass)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutClassAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClass)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClassAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnum)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnumAsync)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstance)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstanceAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstance)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstanceAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnum)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnumAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecNotificationQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecNotificationQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecMethod)( const BSTR, const BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

    STDMETHOD(ExecMethodAsync)( const BSTR, const BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

private:
    
    HRESULT Enumerate(
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        std::vector<_bstr_t>& rgNamedJOs,
        CJobObjLimitInfoProps& cjolip,
        IWbemClassObject** ppStatusObject);

    IWbemServicesPtr m_pNamespace;

    CHString m_chstrNamespace;
        
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\maindll.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// MainDll.cpp

#include "precomp.h"
#include <iostream.h>
#include <objbase.h>
#include "CUnknown.h"
#include "factory.h"




/*****************************************************************************/
// Exported functions
/*****************************************************************************/

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    return CFactory::CanUnloadNow() ;
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    return CFactory::GetClassObject(clsid, iid, ppv) ;
}

//
// Server registration
//
STDAPI DllRegisterServer()
{
    return CFactory::RegisterAll() ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return CFactory::UnregisterAll() ;
}

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
        CFactory::s_hModule = static_cast<HMODULE>(hModule) ;
		DisableThreadLibraryCalls(CFactory::s_hModule);			// 158024 
	}
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\precomp.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

#pragma message("Precompiling header...")

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <fwcommon.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\makefile.inc ===
$(O)\maindll.obj : maindll.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\maindll.cpp
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\mofs\makefile.inc ===
$(O)\cimwin32.mof $(O)\cimwin32.mfl: win32_cim.mof win32_wmi.mof win32_system.mof win32_application.mof win32_storage.mof win32_userdevice.mof win32_power.mof win32_devices.mof win32_printer.mof win32_network.mof win32_ports.mof win32_memory.mof win32_com.mof win32_user.mof
    copy /b win32_cim.mof+win32_wmi.mof+win32_system.mof+win32_application.mof+win32_storage.mof+win32_userdevice.mof+win32_power.mof+win32_devices.mof+win32_printer.mof+win32_network.mof+win32_ports.mof+win32_memory.mof+win32_com.mof+win32_user.mof $(O)\cimwin32_v2_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\cimwin32Tmp.mof -MFL:$(O)\cimwin32Tmp.mfl $(O)\cimwin32_v2_desc.mof
    copy copyright.mof+$(O)\cimwin32Tmp.mof+$(O)\cimwin32Tmp.mfl $(O)\cimwin32.mof
    copy copyright.mof+$(O)\cimwin32Tmp.mfl $(O)\cimwin32.mfl

$(O)\msi.mof $(O)\msi.mfl: msi.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\msiTmp.mof -MFL:$(O)\msiTmp.mfl msi.mof
    copy copyright.mof+$(O)\msiTmp.mof+$(O)\msiTmp.mfl $(O)\msi.mof
    copy copyright.mof+$(O)\msiTmp.mfl $(O)\msi.mfl

$(O)\ntevt.mof $(O)\ntevt.mfl: ntevt.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\ntevtTmp.mof -MFL:$(O)\ntevtTmp.mfl ntevt.mof
    copy copyright.mof+$(O)\ntevtTmp.mof+$(O)\ntevtTmp.mfl $(O)\ntevt.mof
    copy copyright.mof+$(O)\ntevtTmp.mfl $(O)\ntevt.mfl

$(O)\wmi.mof $(O)\wmi.mfl: wmi.mof $(BASE_INC_PATH)\mcaia64.mof
    copy wmi.mof+$(BASE_INC_PATH)\mcaia64.mof $(O)\wmiia64.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmiTmp.mof -MFL:$(O)\wmiTmp.mfl $(O)\wmiia64.mof
    copy copyright.mof+wminamespace.mof+$(O)\wmiTmp.mfl+$(O)\wmiTmp.mof $(O)\wmi.mof
    copy copyright.mof+$(O)\wmiTmp.mfl $(O)\wmi.mfl

$(O)\secrcw32.mof $(O)\secrcw32.mfl: secrcw32_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\secrcw32Tmp.mof -MFL:$(O)\secrcw32Tmp.mfl secrcw32_desc.mof
    copy copyright.mof+$(O)\secrcw32Tmp.mof+$(O)\secrcw32Tmp.mfl $(O)\secrcw32.mof
    copy copyright.mof+$(O)\secrcw32Tmp.mfl $(O)\secrcw32.mfl

$(O)\wmipdfs.mof $(O)\wmipdfs.mfl: dfs_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipdfsTmp.mof -MFL:$(O)\wmipdfsTmp.mfl dfs_desc.mof
    copy copyright.mof+$(O)\wmipdfsTmp.mof+$(O)\wmipdfsTmp.mfl $(O)\wmipdfs.mof
    copy copyright.mof+$(O)\wmipdfsTmp.mfl $(O)\wmipdfs.mfl

$(O)\wmipdskq.mof $(O)\wmipdskq.mfl: dskquota_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipdskqTmp.mof -MFL:$(O)\wmipdskqTmp.mfl dskquota_desc.mof
    copy copyright.mof+$(O)\wmipdskqTmp.mof+$(O)\wmipdskqTmp.mfl $(O)\wmipdskq.mof
    copy copyright.mof+$(O)\wmipdskqTmp.mfl $(O)\wmipdskq.mfl

$(O)\wmipjobj.mof $(O)\wmipjobj.mfl: jobobj_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipjobjTmp.mof -MFL:$(O)\wmipjobjTmp.mfl jobobj_desc.mof
    copy copyright.mof+$(O)\wmipjobjTmp.mof+$(O)\wmipjobjTmp.mfl $(O)\wmipjobj.mof
    copy copyright.mof+$(O)\wmipjobjTmp.mfl $(O)\wmipjobj.mfl

$(O)\wmipicmp.mof $(O)\wmipicmp.mfl: ping_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipicmpTmp.mof -MFL:$(O)\wmipicmpTmp.mfl ping_desc.mof
    copy copyright.mof+$(O)\wmipicmpTmp.mof+$(O)\wmipicmpTmp.mfl $(O)\wmipicmp.mof
    copy copyright.mof+$(O)\wmipicmpTmp.mfl $(O)\wmipicmp.mfl

$(O)\wmipiprt.mof $(O)\wmipiprt.mfl: route_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipiprtTmp.mof -MFL:$(O)\wmipiprtTmp.mfl route_desc.mof
    copy copyright.mof+$(O)\wmipiprtTmp.mof+$(O)\wmipiprtTmp.mfl $(O)\wmipiprt.mof
    copy copyright.mof+$(O)\wmipiprtTmp.mfl $(O)\wmipiprt.mfl

$(O)\wmipsess.mof $(O)\wmipsess.mfl: session_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipsessTmp.mof -MFL:$(O)\wmipsessTmp.mfl session_desc.mof
    copy copyright.mof+$(O)\wmipsessTmp.mof+$(O)\wmipsessTmp.mfl $(O)\wmipsess.mof
    copy copyright.mof+$(O)\wmipsessTmp.mfl $(O)\wmipsess.mfl

$(O)\krnlprov.mof $(O)\krnlprov.mfl: win32_systemtrace.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\krnlprovTmp.mof -MFL:$(O)\krnlprovTmp.mfl win32_systemtrace.mof
    copy copyright.mof+$(O)\krnlprovTmp.mof+$(O)\krnlprovTmp.mfl $(O)\krnlprov.mof
    copy copyright.mof+$(O)\krnlprovTmp.mfl $(O)\krnlprov.mfl

$(O)\wmipcima.mof $(O)\wmipcima.mfl: cimwin32a_v2_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipcimaTmp.mof -MFL:$(O)\wmipcimaTmp.mfl cimwin32a_V2_desc.mof
    copy copyright.mof+$(O)\wmipcimaTmp.mof+$(O)\wmipcimaTmp.mfl $(O)\wmipcima.mof
    copy copyright.mof+$(O)\wmipcimaTmp.mfl $(O)\wmipcima.mfl

$(O)\regevent.mof $(O)\regevent.mfl: regevent.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\regeventTmp.mof -MFL:$(O)\regeventTmp.mfl regevent.mof
    copy copyright.mof+$(O)\regeventTmp.mof+$(O)\regeventTmp.mfl $(O)\regevent.mof
    copy copyright.mof+$(O)\regeventTmp.mfl $(O)\regevent.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\registry.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __REGISTRY_H__
#define __REGISTRY_H__
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       LPCWSTR szFriendlyName,
                       LPCWSTR szVerIndProgID,
                       LPCWSTR szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         LPCWSTR szVerIndProgID,
                         LPCWSTR szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\smarthandle.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// SmartHandle.h


class SmartHandle
{
public:
    SmartHandle() : m_h(NULL) {}
    ~SmartHandle()
    { 
        if(m_h)
        {
            ::CloseHandle(m_h); 
        }
    }

    SmartHandle& operator=(const HANDLE h)
    {
        if(m_h)
        {
            ::CloseHandle(m_h); m_h = NULL;
        }
        m_h = h;
        return *this;
    }

    operator bool() const
    {
        if(m_h) return true;
        else return false;
    }

    operator HANDLE() const { return m_h; }

private:
    HANDLE m_h;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\jobobjectprov\registry.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Registry.cpp
//

#include "precomp.h"
#include <objbase.h>
#include <assert.h>

#include "Registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(LPCWSTR pszPath,
                    LPCWSTR szSubkey,
                    LPCWSTR szValue) ;

// Convert a CLSID into a char string.
void CLSIDtoWCHAR(const CLSID& clsid, 
                  LPWSTR szCLSID,
                  int length) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, LPCWSTR szKeyChild) ;

BOOL setEntryAndValue(LPCWSTR szKey,
                      LPCWSTR szSubkey,
                      LPCWSTR szValue);


////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,        // DLL module handle
                       const CLSID& clsid,     // Class ID
                       LPCWSTR szFriendlyName, // Friendly Name
                       LPCWSTR szVerIndProgID, // Programmatic
                       LPCWSTR szProgID)       // typelib id
{
	// Get server location.
	WCHAR szModule[512] ;
	szModule[511] = 0;
	DWORD dwResult =
		::GetModuleFileNameW(hModule, 
		                    szModule,
		                    sizeof(szModule)/sizeof(WCHAR) - 1) ;
	assert(dwResult != 0) ;

	// Convert the CLSID into a char.
	WCHAR szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtoWCHAR(clsid, szCLSID, sizeof(szCLSID)/sizeof(WCHAR)) ;

	// Build the key CLSID\\{...}
	WCHAR szKey[64] ;
	wcscpy(szKey, L"CLSID\\") ;
	wcscat(szKey, szCLSID) ;
  
	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName) ;

	// Add the server filename subkey under the CLSID key.
	setKeyAndValue(szKey, L"InprocServer32", szModule) ;

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, L"ProgID", szProgID) ;

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, L"VersionIndependentProgID",
	               szVerIndProgID) ;

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szVerIndProgID, L"CLSID", szCLSID) ;
	setKeyAndValue(szVerIndProgID, L"CurVer", szProgID) ;

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szProgID, L"CLSID", szCLSID) ;

    // Specify the threading model as Free...
    wcscat(szKey, L"\\");
    wcscat(szKey, L"InprocServer32");
    setEntryAndValue(szKey, L"ThreadingModel", L"Free");

	return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,     // Class ID
                      LPCWSTR szVerIndProgID, // Programmatic
                      LPCWSTR szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	WCHAR szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtoWCHAR(clsid, szCLSID, sizeof(szCLSID)/sizeof(WCHAR)) ;

	// Build the key CLSID\\{...}
	WCHAR szKey[64] ;
	wcscpy(szKey, L"CLSID\\") ;
	wcscat(szKey, szCLSID) ;

	// Delete the CLSID Key - CLSID\{...}
	LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the version-independent ProgID Key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the ProgID key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtoWCHAR(const CLSID& clsid,
                  LPWSTR szCLSID,
                  int length)
{
	assert(length >= CLSID_STRING_SIZE) ;
	// Get CLSID
	LPOLESTR wszCLSID = NULL ;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
	assert(SUCCEEDED(hr)) ;

    if(SUCCEEDED(hr) && wszCLSID)
    {
	    wcsncpy(szCLSID, wszCLSID, length) ;
    }

	// Free memory.
	CoTaskMemFree(wszCLSID) ;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,       // Parent of key to delete
                        LPCWSTR lpszKeyChild)  // Key to delete
{
	// Open the child.
	HKEY hKeyChild ;
	LONG lRes = RegOpenKeyExW(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild) ;
	if (lRes != ERROR_SUCCESS)
	{
		return lRes ;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time ;
	WCHAR szBuffer[256] ;
	DWORD dwSize = 256 ;
	while (RegEnumKeyExW(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild) ;
			return lRes;
		}
		dwSize = 256 ;
	}

	// Close the child.
	RegCloseKey(hKeyChild) ;

	// Delete this child.
	return RegDeleteKeyW(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(LPCWSTR szKey,
                    LPCWSTR szSubkey,
                    LPCWSTR szValue)
{
	HKEY hKey;
	WCHAR szKeyBuf[1024] ;

	// Copy keyname into buffer.
	wcscpy(szKeyBuf, szKey) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		wcscat(szKeyBuf, L"\\") ;
		wcscat(szKeyBuf, szSubkey ) ;
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyExW(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueExW(hKey, NULL, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              (wcslen(szValue)+1) * sizeof(WCHAR)) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;
}

//
// Create a value within an existing key and set its data.
//
BOOL setEntryAndValue(LPCWSTR szKey,
                      LPCWSTR szValue,
                      LPCWSTR szData)
{
	HKEY hKey;
	WCHAR szKeyBuf[1024] ;

	// Copy keyname into buffer.
	wcscpy(szKeyBuf, szKey) ;

	// Create and open key and subkey.
	long lResult = RegOpenKeyExW(HKEY_CLASSES_ROOT ,
	                            szKeyBuf, 
	                            0, 
	                            KEY_ALL_ACCESS,
                                &hKey) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueExW(hKey, szValue, 0, REG_SZ, 
		              (BYTE *)szData, 
		              (wcslen(szData)+1) * sizeof(WCHAR)) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\actioncheck.cpp ===
// ActionCheck.cpp: implementation of the CActionCheck class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ActionCheck.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActionCheck::CActionCheck(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CActionCheck::~CActionCheck()
{

}

HRESULT CActionCheck::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pActionRObj = NULL;
    CRequestObject *pCheckRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
            int i;

            for(i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"ACTION") == 0){

                    pActionRObj = new CRequestObject();
                    if(!pActionRObj) throw he;

                    pActionRObj->Initialize(m_pNamespace);

                    pActionRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
            }

            for(i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"CHECK") == 0){

                    pCheckRObj = new CRequestObject();
                    if(!pCheckRObj) throw he;

                    pCheckRObj->Initialize(m_pNamespace);

                    pCheckRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
            }
        }

        if(atAction == ACTIONTYPE_ENUM || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_CreateFolderAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0)))))
            if(FAILED(hr = CreateFolderDirectory(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if(atAction == ACTIONTYPE_ENUM || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_DuplicateFileAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_FileSpecification") == 0)))))
            if(FAILED(hr = FileDuplicateFile(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        
        if(atAction == ACTIONTYPE_ENUM || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_FontInfoAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_FileSpecification") == 0)))))
            if(FAILED(hr = FontInfoFile(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ClassInfoAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_ProgIDSpecification") == 0)))))
            if(FAILED(hr = ProgIDSpecificationClass(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_RemoveIniAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0)))))
            if(FAILED(hr = RemoveIniDirectory(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_SelfRegModuleAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_FileSpecification") == 0)))))
            if(FAILED(hr = SelfRegModuleFile(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ShortcutAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0)))))
            if(FAILED(hr = ShortcutDirectory(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_TypeLibraryInfoAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0)))))
            if(FAILED(hr = TypeLibraryDirectory(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }

        if(pCheckRObj){

            pCheckRObj->Cleanup();
            delete pCheckRObj;
            pCheckRObj = NULL;
        }

    }catch(...){
            
        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }

        if(pCheckRObj){

            pCheckRObj->Cleanup();
            delete pCheckRObj;
            pCheckRObj = NULL;
        }
    }

    return hr;
}

HRESULT CActionCheck::TypeLibraryDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcDir[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcTestCode[39];
    WCHAR wcLibID[BUFF_SIZE];

    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcCheck[BUFF_SIZE];
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcLibID);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
        
        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcCheck);

						//we have a componentized directory... do a little more work
						if ((wcCheck[wcslen(wcCheck) - 1] == L'}') &&
							(wcCheck[wcslen(wcCheck) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcCheck, wcCheck);
						}

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `LibID`, `Language`, `Directory_`, `Component_` from TypeLib" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `LibID`=\'", wcLibID, L"\'" );
		}

		if ( bGotCheck )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Directory_`=\'", wcCheck, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Directory_`=\'", wcCheck, L"\'" );
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

	LPWSTR Buffer1 = NULL;
	LPWSTR dynBuffer1 = NULL;

	DWORD dwDynBuffer1 = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

	        //Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"TypeLib", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        bDoneFirst = false;
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 3, dwBufSize, wcDir, dwDynBuffer1, dynBuffer1, Buffer1 );

						// make query on fly
						wcQuery1.Append ( 2, Buffer1, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                            //----------------------------------------------------

                                            dwBufSize = BUFF_SIZE;
											GetBufferToPut ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );
                                           
                                            if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
											{
												if ( dynBuffer && dynBuffer [ 0 ] != 0 )
												{
													dynBuffer [ 0 ] = 0;
												}

                                                dwBufSize = BUFF_SIZE;
                                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                                                if(wcscmp(wcBuf, L"") != 0)
												{
													// safe operation
                                                    wcProp.Copy(L"Win32_TypeLibraryInfoAction.ActionID=\"");
                                                    wcProp.Append(1, wcBuf);

                                                    dwBufSize = BUFF_SIZE;
													CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

													wcProp.Append (3, wcBuf, wcProductCode, L"\"");
													PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

                                                    if ( Buffer1 && Buffer1 [ 0 ] != 0 )
													{
														// safe operation
														wcProp.Copy(L"Win32_DirectorySpecification.CheckID=\"");

														if(uiStatus == ERROR_SUCCESS)
														{
															wcProp.Append (4, Buffer1, wcCompID, wcProductCode, L"\"");
														}
														else
														{
															wcProp.Append (3, Buffer1, wcProductCode, L"\"");
														}

														PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                                                    //=====================================================

                                                    //----------------------------------------------------

                                                        if(bDriver && bAttribute) bMatch = true;

                                                        if(!(atAction == ACTIONTYPE_GET)  || bMatch){

                                                            hr = pHandler->Indicate(1, &m_pObj);
                                                        }
                                                    }
                                                }
                                            }
											else
											{
												if ( dynBuffer && dynBuffer [ 0 ] != 0 )
												{
													dynBuffer [ 0 ] = 0;
												}
											}

                                            m_pObj->Release();
                                            m_pObj = NULL;

                                            if(!bDoneFirst) bDoneFirst = true;
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

										uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

						if ( dynBuffer1 && dynBuffer1 [ 0 ] != 0 )
						{
							dynBuffer1 [ 0 ] = 0;
						}
                    }
                }
            }
			catch(...)
			{
			    if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if ( dynBuffer1 )
				{
					delete [] dynBuffer1;
					dynBuffer1 = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

    if ( dynBuffer1 )
	{
		delete [] dynBuffer1;
		dynBuffer1 = NULL;
	}

	return hr;
}

HRESULT CActionCheck::ShortcutDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcDir[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcTestCode[39];

    WCHAR wcShortcut[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcCheck[BUFF_SIZE];
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcShortcut);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcCheck);

						//we have a componentized directory... do a little more work
						if ((wcCheck[wcslen(wcCheck) - 1] == L'}') &&
							(wcCheck[wcslen(wcCheck) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcCheck, wcCheck);
						}

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
			}
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Shortcut`, `Component_`, `Directory_` from Shortcut" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Shortcut`=\'", wcShortcut, L"\'" );
		}

		if ( bGotCheck )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Directory_`=\'", wcCheck, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Directory_`=\'", wcCheck, L"\'" );
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

	LPWSTR Buffer1 = NULL;
	LPWSTR dynBuffer1 = NULL;

	DWORD dwDynBuffer1 = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

	        //Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        bDoneFirst = false;
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 3, dwBufSize, wcDir, dwDynBuffer1, dynBuffer1, Buffer1 );

						// make query on fly
						wcQuery1.Append ( 2, Buffer1, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                            //----------------------------------------------------

                                            dwBufSize = BUFF_SIZE;
											GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                            if ( Buffer && Buffer [ 0 ] != 0 )
											{
												// safe operation
												wcProp.Copy(L"Win32_ShortcutAction.ActionID=\"");
												wcProp.Append ( 3, Buffer, wcProductCode, L"\"");
												PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

												if ( dynBuffer && dynBuffer [ 0 ] != 0 )
												{
													dynBuffer [ 0 ] = 0;
												}

                                                dwBufSize = BUFF_SIZE;
												GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                                if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
												{
													if ( dynBuffer && dynBuffer [ 0 ] != 0 )
													{
														dynBuffer [ 0 ] = 0;
													}

                                                    if ( Buffer1 && Buffer1 [ 0 ]  != 0 )
													{
														// safe operation
														wcProp.Copy(L"Win32_DirectorySpecification.CheckID=\"");

														if(uiStatus == ERROR_SUCCESS)
														{
															wcProp.Append (4, Buffer1, wcCompID, wcProductCode, L"\"");
														}
														else
														{
															wcProp.Append (3, Buffer1, wcProductCode, L"\"");
														}

														PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                                                    //=====================================================

                                                    //----------------------------------------------------

                                                        if(bDriver && bAttribute) bMatch = true;

                                                        if(!(atAction == ACTIONTYPE_GET)  || bMatch){

                                                            hr = pHandler->Indicate(1, &m_pObj);
                                                        }
                                                    }
                                                }
												else
												{
													if ( dynBuffer && dynBuffer [ 0 ] != 0 )
													{
														dynBuffer [ 0 ] = 0;
													}
												}
                                            }

                                            m_pObj->Release();
                                            m_pObj = NULL;

                                            if(!bDoneFirst) bDoneFirst = true;
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

                                        uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

						if ( dynBuffer1 && dynBuffer1 [ 0 ] != 0 )
						{
							dynBuffer1 [ 0 ] = 0;
						}
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if ( dynBuffer1 )
				{
					delete [] dynBuffer1;
					dynBuffer1 = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

    if ( dynBuffer1 )
	{
		delete [] dynBuffer1;
		dynBuffer1 = NULL;
	}

	return hr;
}

HRESULT CActionCheck::SelfRegModuleFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];

    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcFile);

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_` from SelfReg" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcFile, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"SelfReg", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( Buffer && Buffer [ 0 ] != 0 )
						{
							// safe operation
							wcProp.Copy(L"Win32_SelfRegModuleAction.ActionID=\"");
							wcProp.Append (3, Buffer, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

							// safe operation
							wcProp.Copy(L"Win32_FileSpecification.CheckID=\"");
							wcProp.Append ( 3, Buffer, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                        //=====================================================

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                        //----------------------------------------------------

                            if(bDriver && bAttribute) bMatch = true;

                            if(!(atAction == ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CActionCheck::RemoveIniDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcDir[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcTestCode[39];

    WCHAR wcIniFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcCheck[BUFF_SIZE];
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcIniFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcCheck);

						//we have a componentized directory... do a little more work
						if ((wcCheck[wcslen(wcCheck) - 1] == L'}') &&
							(wcCheck[wcslen(wcCheck) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcCheck, wcCheck);
						}

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
			}
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `RemoveIniFile`, `Component_`, `DirProperty` from RemoveIniFile" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `RemoveIniFile`=\'", wcIniFile, L"\'" );
		}

		if ( bGotCheck )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `DirProperty`=\'", wcCheck, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `DirProperty`=\'", wcCheck, L"\'" );
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

	LPWSTR Buffer1 = NULL;
	LPWSTR dynBuffer1 = NULL;

	DWORD dwDynBuffer1 = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"RemoveIniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        bDoneFirst = false;
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 3, dwBufSize, wcDir, dwDynBuffer1, dynBuffer1, Buffer1 );

						// make query on fly
						wcQuery1.Append ( 2, Buffer1, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase(), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                            //----------------------------------------------------

                                            dwBufSize = BUFF_SIZE;
											GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                            if ( Buffer && Buffer [ 0 ] != 0 )
											{
												// safe operation
												wcProp.Copy(L"Win32_RemoveIniAction.ActionID=\"");
												wcProp.Append ( 3, Buffer, wcProductCode, L"\"");
												PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

												if ( dynBuffer && dynBuffer [ 0 ] != 0 )
												{
													dynBuffer [ 0 ] = 0;
												}

                                                dwBufSize = BUFF_SIZE;
												GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                                if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
												{
													if ( dynBuffer && dynBuffer [ 0 ] != 0 )
													{
														dynBuffer [ 0 ] = 0;
													}

                                                    if ( Buffer1 && Buffer1 [ 0 ] != 0 )
													{
														// safe operation
														wcProp.Copy(L"Win32_DirectorySpecification.CheckID=\"");

														if(uiStatus == ERROR_SUCCESS)
														{
															wcProp.Append (4, Buffer1, wcCompID, wcProductCode, L"\"");
														}
														else
														{
															wcProp.Append (3, Buffer1, wcProductCode, L"\"");
														}

														PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                                                    //=====================================================

                                                    //----------------------------------------------------

                                                        if(bDriver && bAttribute) bMatch = true;

                                                        if(!(atAction == ACTIONTYPE_GET)  || bMatch){

                                                            hr = pHandler->Indicate(1, &m_pObj);
                                                        }
                                                    }
                                                }
												else
												{
													if ( dynBuffer && dynBuffer [ 0 ] != 0 )
													{
														dynBuffer [ 0 ] = 0;
													}
												}
                                            }

                                            m_pObj->Release();
                                            m_pObj = NULL;

                                            if(!bDoneFirst) bDoneFirst = true;
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

                                        uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

						if ( dynBuffer1 && dynBuffer1 [ 0 ] != 0 )
						{
							dynBuffer1 [ 0 ] = 0;
						}
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if ( dynBuffer1 )
				{
					delete [] dynBuffer1;
					dynBuffer1 = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

    if ( dynBuffer1 )
	{
		delete [] dynBuffer1;
		dynBuffer1 = NULL;
	}

	return hr;
}

HRESULT CActionCheck::ProgIDSpecificationClass(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hCView	= NULL;
	MSIHANDLE hCRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];

    WCHAR wcProgID[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcCheck[BUFF_SIZE];
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcProgID);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcCheck);

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ProgId`, `Class_` from ProgId" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Class_`=\'", wcProgID, L"\'" );
		}

		if ( bGotCheck )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `ProgId`=\'", wcCheck, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `ProgId`=\'", wcCheck, L"\'" );
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `Context`, `Component_` from Class where `CLSID`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

	while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try{

                if ( GetView ( &hView, wcProductCode, wcQuery, L"ProgId", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( Buffer && Buffer [ 0 ] != 0 )
						{
							// safe operation
							wcProp.Copy(L"Win32_ProgIDSpecification.CheckID=\"");
							wcProp.Append ( 3, Buffer, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pCheck, wcProp, &bDriver, m_pRequest);

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            wcProp.Copy(L"Win32_ClassInfoAction.ActionID=\"");

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( Buffer && Buffer [ 0 ]  != 0 )
							{
								wcProp.Append ( 1, Buffer );

								// make query on fly
								wcQuery1.Append ( 2, Buffer, L"\'" );

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                CheckMSI(g_fpMsiDatabaseOpenViewW(msidata.GetDatabase(), wcQuery1, &hCView));
                                CheckMSI(g_fpMsiViewExecute(hCView, 0));

                                try{

                                    uiStatus = g_fpMsiViewFetch(hCView, &hCRecord);

                                    if(uiStatus != ERROR_NO_MORE_ITEMS){

                                        dwBufSize = BUFF_SIZE;
										GetBufferToPut ( hCRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

										wcProp.Append (3, Buffer, wcProductCode, L"\"");

										if ( dynBuffer && dynBuffer [ 0 ] != 0 )
										{
											dynBuffer [ 0 ] = 0;
										}

                                        dwBufSize = BUFF_SIZE;
										GetBufferToPut ( hCRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
										{
											if ( dynBuffer && dynBuffer [ 0 ] != 0 )
											{
												dynBuffer [ 0 ] = 0;
											}

                                            PutKeyProperty(m_pObj, pAction, wcProp, &bAttribute, m_pRequest);

                                        //----------------------------------------------------

                                            if(bDriver && bAttribute) bMatch = true;

                                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                                hr = pHandler->Indicate(1, &m_pObj);
                                            }
                                        }
										else
										{
											if ( dynBuffer && dynBuffer [ 0 ] != 0 )
											{
												dynBuffer [ 0 ] = 0;
											}
										}
                                        
                                    }else throw WBEM_E_FAILED;

                                }catch(...){

                                    g_fpMsiCloseHandle(hCRecord);
                                    g_fpMsiViewClose(hCView);
                                    g_fpMsiCloseHandle(hCView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hCRecord);
                                g_fpMsiViewClose(hCView);
                                g_fpMsiCloseHandle(hCView);

                            }else bMatch = false;
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CActionCheck::FontInfoFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];

    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcFile);

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute;


    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_` from Font" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcFile, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Font", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( Buffer && Buffer [ 0 ] != 0 )
						{
							// safe operation
							wcProp.Copy(L"Win32_FontInfoAction.ActionID=\"");
							wcProp.Append ( 3, Buffer, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

							// safe operation
							wcProp.Copy(L"Win32_FileSpecification.CheckID=\"");
							wcProp.Append ( 3, Buffer, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                        //----------------------------------------------------

                            if(bDriver && bAttribute) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

						uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }
            
			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CActionCheck::FileDuplicateFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];

    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcCheck[BUFF_SIZE];
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcCheck);

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `FileKey`, `Component_`, `File_` from DuplicateFile" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `FileKey`=\'", wcFile, L"\'" );
		}

		if ( bGotCheck )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `File_`=\'", wcCheck, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `File_`=\'", wcCheck, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"DuplicateFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( Buffer && Buffer [ 0 ] != 0 )
						{
							// safe operation
							wcProp.Copy(L"Win32_DuplicateFileAction.ActionID=\"");
							wcProp.Append (3, Buffer, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                if ( Buffer && Buffer [ 0 ] != 0 ) 
								{
									// safe operation
									wcProp.Copy(L"Win32_FileSpecification.CheckID=\"");
									wcProp.Append (3, Buffer, wcProductCode, L"\"");
									PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                                //=====================================================

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

                                //----------------------------------------------------

                                    if(bDriver && bAttribute) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);

                                    }
                                }
                            }
							else
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}
							}
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}


HRESULT CActionCheck::CreateFolderDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcDir[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcTestCode[39];

    WCHAR wcFolder[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFolder);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcFolder);

						//we have a componentized directory... do a little more work
						if ((wcFolder[wcslen(wcFolder) - 1] == L'}') &&
							(wcFolder[wcslen(wcFolder) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcFolder, wcFolder);
						}

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Directory_`, `Component_` from CreateFolder" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		wcQuery.Append ( 3, L" where `Directory_`=\'", wcFolder, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

	LPWSTR Buffer1 = NULL;
	LPWSTR dynBuffer1 = NULL;

	DWORD dwDynBuffer1 = 0L;

	while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"CreateFolder", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);
                        bDoneFirst = false;

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcDir, dwDynBuffer1, dynBuffer1, Buffer1 );

						// make query on fly
						wcQuery1.Append ( 2, Buffer1, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase(), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                            //----------------------------------------------------
                                            
                                            if ( Buffer1 && Buffer1 [ 0 ] != 0 )
											{
												// safe operation
												wcProp.Copy(L"Win32_CreateFolderAction.ActionID=\"");
												wcProp.Append (3, Buffer1, wcProductCode, L"\"");
												PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

												// safe operation
                                                wcProp.Copy(L"Win32_DirectorySpecification.CheckID=\"");

												if(uiStatus == ERROR_SUCCESS)
												{
													wcProp.Append (4, Buffer1, wcCompID, wcProductCode, L"\"");
												}
												else
												{
													wcProp.Append (3, Buffer1, wcProductCode, L"\"");
												}

												PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                                                dwBufSize = BUFF_SIZE;
												GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                                if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
												{
													if ( dynBuffer && dynBuffer [ 0 ] != 0 )
													{
														dynBuffer [ 0 ] = 0;
													}

                                                    if(bDriver && bAttribute) bMatch = true;

                                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

														hr = pHandler->Indicate(1, &m_pObj);

	                                                   }
                                                }
												else
												{
													if ( dynBuffer && dynBuffer [ 0 ] != 0 )
													{
														dynBuffer [ 0 ] = 0;
													}
												}
                                            }

                                            m_pObj->Release();
                                            m_pObj = NULL;

                                            if(!bDoneFirst) bDoneFirst = true;
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

                                        uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

						if ( dynBuffer1 && dynBuffer1 [ 0 ] != 0 )
						{
							dynBuffer1 [ 0 ] = 0;
						}
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if ( dynBuffer1 )
				{
					delete [] dynBuffer1;
					dynBuffer1 = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

	if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	if ( dynBuffer1 )
	{
		delete [] dynBuffer1;
		dynBuffer1 = NULL;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\actioncheck.h ===
// ActionCheck.h: interface for the CActionCheck class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONCHECK_H__B0A7DBE0_D706_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_ACTIONCHECK_H__B0A7DBE0_D706_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CActionCheck : public CGenericClass  
{
public:
	CActionCheck(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CActionCheck();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT CreateFolderDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								  CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT FileDuplicateFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							  CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT FontInfoFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
						 CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT ProgIDSpecificationClass(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT RemoveIniDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							   CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT SelfRegModuleFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							  CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT ShortcutDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							  CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT TypeLibraryDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								 CRequestObject *pActionData, CRequestObject *pCheckData);

};

#endif // !defined(AFX_ACTIONCHECK_H__B0A7DBE0_D706_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\applicationcommandline.cpp ===
// ApplicationCommandLine.cpp: implementation of the CApplicationCommandLine class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ApplicationCommandLine.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CApplicationCommandLine::CApplicationCommandLine(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CApplicationCommandLine::~CApplicationCommandLine()
{

}

HRESULT CApplicationCommandLine::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSEView	= NULL;
	MSIHANDLE hSERecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcCommand[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    WCHAR wcElement[BUFF_SIZE];
    bool bElement = false;
    CRequestObject *pAntData = NULL;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        int j;
        //GetObject optimizations
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        for(j = 0; j < m_pRequest->m_iPropCount; j++){

            if(_wcsicmp(m_pRequest->m_Property[j], L"Antecedent") == 0){

                pAntData = new CRequestObject();
                if(!pAntData) throw he;

                pAntData->Initialize(m_pNamespace);

                pAntData->ParsePath(m_pRequest->m_Value[j]);
                break;
            }
        }

        if(pAntData){

            for(j = 0; j < pAntData->m_iPropCount; j++){

                if(_wcsicmp(pAntData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen ( pAntData->m_Value[j] ) < BUFF_SIZE )
					{
						wcscpy(wcElement, pAntData->m_Value[j]);

						bElement = true;
						break;
					}
                }
            }

            pAntData->Cleanup();
            delete pAntData;
            pAntData = NULL;
        }

    }

    //These will change from class to class
    bool bAntec, bDepend;
    INSTALLSTATE piInstalled;

    CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Shortcut`, `Component_` from Shortcut" );

    //optimize for GetObject
    if ( bElement )
	{
		wcQuery.Append ( 3, L" where `Shortcut`=\'", wcElement, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Component`=\'" );

	LPWSTR dynBuffer = NULL;
	LPWSTR Buffer = NULL;

	DWORD dwdynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]
        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try{

            if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwdynBuffer, dynBuffer, Buffer );

					if ( Buffer && Buffer[0] != 0 )
					{
						wcProp.Copy ( L"Win32_ApplicationService.Name=\"" );
						wcProp.Append ( 2, Buffer, L"\"");

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						PutKeyProperty(m_pObj, pAntecedent, wcProp, &bAntec, m_pRequest);

						dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwdynBuffer, dynBuffer, Buffer );

						// make query on fly
						wcQuery1.Append ( 2, Buffer, L"\'" );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						CheckMSI(g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hSEView));
						CheckMSI(g_fpMsiViewExecute(hSEView, 0));

						try{

							uiStatus = g_fpMsiViewFetch(hSEView, &hSERecord);

							if(uiStatus != ERROR_NO_MORE_ITEMS){

								dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hSERecord, 1, wcBuf, &dwBufSize));

								if(ValidateComponentID(wcBuf, wcProductCode)){

									dwBufSize = BUFF_SIZE;
									piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcBuf,
										wcCommand, &dwBufSize);

									if((wcscmp(wcCommand, L"") != 0) && (piInstalled != INSTALLSTATE_UNKNOWN)
										&& (piInstalled != INSTALLSTATE_ABSENT)){

										dwBufSize = BUFF_SIZE;
										GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwdynBuffer, dynBuffer, Buffer );

										if ( ValidateComponentName	(	msidata.GetDatabase (),
																		wcProductCode,
																		Buffer
																	)
										   )
										{
											wcProp.Copy ( L"Win32_CommandLineAccess.Name=\"" );
											wcProp.Append ( 2, EscapeStringW(wcCommand, Buffer), L"\"" );

											if ( dynBuffer && dynBuffer [ 0 ] != 0 )
											{
												dynBuffer [ 0 ] = 0;
											}

											PutKeyProperty(m_pObj, pDependent, wcProp, &bDepend, m_pRequest);

										//----------------------------------------------------

											if(bAntec && bDepend) bMatch = true;

											if((atAction != ACTIONTYPE_GET) || bMatch){

												hr = pHandler->Indicate(1, &m_pObj);
											}
										}
										else
										{
											if ( dynBuffer && dynBuffer [ 0 ] != 0 )
											{
												dynBuffer [ 0 ] = 0;
											}
										}
									}
								}
							}

						}catch(...){
        
							g_fpMsiViewClose(hSEView);
							g_fpMsiCloseHandle(hSEView);
							g_fpMsiCloseHandle(hSERecord);
							throw;
						}

						g_fpMsiViewClose(hSEView);
						g_fpMsiCloseHandle(hSEView);
						g_fpMsiCloseHandle(hSERecord);
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

	if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\applicationcommandline.h ===
// ApplicationCommandLine.h: interface for the CApplicationCommandLine class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APPLICATIONCOMMANDLINE_H__3586F540_D0EE_11D2_B22A_00A0C9954921__INCLUDED_)
#define AFX_APPLICATIONCOMMANDLINE_H__3586F540_D0EE_11D2_B22A_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CApplicationCommandLine : public CGenericClass  
{
public:
	CApplicationCommandLine(CRequestObject *pObj, IWbemServices *pNamespace,
		IWbemContext *pCtx = NULL);
	virtual ~CApplicationCommandLine();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler,
		IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_APPLICATIONCOMMANDLINE_H__3586F540_D0EE_11D2_B22A_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\applicationservice.cpp ===
// ApplicationService.cpp: implementation of the CApplicationService class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <tchar.h>
#include "ApplicationService.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CApplicationService::CApplicationService(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CApplicationService::~CApplicationService()
{

}

HRESULT CApplicationService::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bName;
    INSTALLSTATE piInstalled, piAction;

    if( m_pRequest->m_iPropCount >= MSI_KEY_LIST_SIZE) {
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }

    if(m_pRequest->m_iValCount > m_pRequest->m_iPropCount){

        m_pRequest->m_Property[m_pRequest->m_iPropCount] = SysAllocString(L"Name");

        if(!m_pRequest->m_Property[(m_pRequest->m_iPropCount)++])
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }

    bool bGotID = false;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Shortcut`, `Component_` from Shortcut" );

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"Name" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				bGotID = true;
				wcQuery.Append ( 3, L" where `Shortcut`=\'", m_pRequest->m_Value[iPos], L"\'" );
			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", FALSE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------

                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                    PutKeyProperty(m_pObj, pName, Buffer, &bName, m_pRequest);
                    PutProperty(m_pObj, pCaption, Buffer);
                    PutProperty(m_pObj, pDescription, Buffer);

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                    if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
					{
                        uiStatus = g_fpMsiGetComponentStateW( msidata.GetProduct (), Buffer, &piInstalled, &piAction );

                        if(uiStatus == ERROR_SUCCESS){

                            if((piInstalled == INSTALLSTATE_ADVERTISED) ||
                                (piInstalled == INSTALLSTATE_LOCAL) ||
                                (piInstalled == INSTALLSTATE_SOURCE) ||
                                (piInstalled == INSTALLSTATE_DEFAULT))
                                wcscpy(wcBuf, L"OK");
                            else if((piInstalled == INSTALLSTATE_BADCONFIG) ||
                                (piInstalled == INSTALLSTATE_MOREDATA) ||
                                (piInstalled == INSTALLSTATE_INVALIDARG))
                                wcscpy(wcBuf, L"Error");
                            else if((piInstalled == INSTALLSTATE_INCOMPLETE) ||
                                (piInstalled == INSTALLSTATE_SOURCEABSENT) ||
                                (piInstalled == INSTALLSTATE_BROKEN) ||
                                (piInstalled == INSTALLSTATE_NOTUSED) ||
                                (piInstalled == INSTALLSTATE_REMOVED) ||
                                (piInstalled == INSTALLSTATE_ABSENT))
                                wcscpy(wcBuf, L"Degraded");
                            else
                                wcscpy(wcBuf, L"Unknown");
                        }else
                            wcscpy(wcBuf, L"Unknown");

                        PutProperty(m_pObj, pStatus, wcBuf);

                        PutProperty(m_pObj, pCreationClassName, L"Win32_ApplicationService");

                        PutProperty(m_pObj, pSystemCreationClassName, L"Win32_ComputerSystem");

                        TCHAR cBuf[MAX_COMPUTERNAME_LENGTH + 1] = { _T('\0') };
                        dwBufSize = ( MAX_COMPUTERNAME_LENGTH+1 ) * sizeof ( TCHAR );

                        if(!GetComputerName(cBuf, &dwBufSize)) throw WBEM_E_FAILED;

						#ifndef	UNICODE
                        WCHAR wcComputer[MAX_COMPUTERNAME_LENGTH + 1];
                        mbstowcs(wcComputer, cBuf, MAX_COMPUTERNAME_LENGTH + 1);

                        PutProperty(m_pObj, pSystemName, wcComputer);
						#else	UNICODE
                        PutProperty(m_pObj, pSystemName, cBuf);
						#endif	UNICODE

                    //====================================================

                        PutProperty(m_pObj, pStartMode, L"Manual");

                    //----------------------------------------------------

                        if(bName) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }
                    }

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

					uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
			msidata.CloseProduct ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
		msidata.CloseProduct ();
    }

	if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\applicationservice.h ===
// ApplicationService.h: interface for the CApplicationService class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APPLICATIONSERVICE_H__DB614F23_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_APPLICATIONSERVICE_H__DB614F23_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CApplicationService : public CGenericClass  
{
public:
	CApplicationService(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CApplicationService();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_APPLICATIONSERVICE_H__DB614F23_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\binary.h ===
// Binary.h: interface for the CBinary class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BINARY_H__CB597B75_1CE5_11D2_BF8D_00A0C9954921__INCLUDED_)
#define AFX_BINARY_H__CB597B75_1CE5_11D2_BF8D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CBinary : public CGenericClass  
{
public:
	CBinary(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CBinary();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_BINARY_H__CB597B75_1CE5_11D2_BF8D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\bindimage.cpp ===
// BindImage.cpp: implementation of the CBindImage class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "BindImage.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBindImage::CBindImage(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CBindImage::~CBindImage()
{

}

HRESULT CBindImage::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;

    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_`, `Path` from BindImage" );

    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcAction, L"\'" );
    }

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"BindImage", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pFile, Buffer);
                        PutProperty(m_pObj, pName, Buffer);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

						CStringExt prop ( wcslen ( Buffer ) + wcslen ( wcProductCode ) + 1 );
						prop.Append ( 2, Buffer, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						PutKeyProperty(m_pObj, pActionID, prop, &bActionID, m_pRequest);

					//====================================================

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pPath );

                    //----------------------------------------------------

                        if(bActionID) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\binary.cpp ===
// Binary.cpp: implementation of the CBinary class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Binary.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBinary::CBinary(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CBinary::~CBinary()
{

}

HRESULT CBinary::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTestCode[39];
    bool bGotName = false;
    WCHAR wcName[BUFF_SIZE];

    //These will change from class to class
    bool bName, bCode;

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ProductCode" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
		            //Get the product code we're looking for
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}
			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrCompare = SysAllocString ( L"Name" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the name we're looking for
					wcscpy(wcName, m_pRequest->m_Value[iPos]);
					bGotName = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Name` from Binary" );

    if( bGotName )
	{
		wcQuery.Append ( 3, L" where `Name`=\'", wcName, L"\'" );
    }

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Binary", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutKeyProperty(m_pObj, pName, Buffer, &bName, m_pRequest);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bCode, m_pRequest);

                    //----------------------------------------------------

                        if(bName && bCode) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

	if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\bindimage.h ===
// BindImage.h: interface for the CBindImage class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BINDIMAGE_H__75F6BA2A_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_BINDIMAGE_H__75F6BA2A_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CBindImage : public CGenericClass  
{
public:
	CBindImage(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CBindImage();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_BINDIMAGE_H__75F6BA2A_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\checkcheck.cpp ===
// CheckCheck.cpp: implementation of the CCheckCheck class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "CheckCheck.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCheckCheck::CCheckCheck(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CCheckCheck::~CCheckCheck()
{

}

HRESULT CCheckCheck::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pCheckRObj = NULL;
    CRequestObject *pLocationRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
            int i;

            for(i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"Location") == 0){

                    pLocationRObj = new CRequestObject();
                    if(!pLocationRObj) throw he;

                    pLocationRObj->Initialize(m_pNamespace);

                    pLocationRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
            }

            for(i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"CHECK") == 0){

                    pCheckRObj = new CRequestObject();
                    if(!pCheckRObj) throw he;

                    pCheckRObj->Initialize(m_pNamespace);

                    pCheckRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
            }
        }

        if((atAction == ACTIONTYPE_ENUM) || ((pLocationRObj && pLocationRObj->m_bstrClass && (_wcsicmp(pLocationRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_IniFileSpecification") == 0)))))
            if(FAILED(hr = IniFileDirectory(pHandler, atAction, pCheckRObj, pLocationRObj))){

                    if(pLocationRObj){

                        pLocationRObj->Cleanup();
                        delete pLocationRObj;
                        pLocationRObj = NULL;
                    }

                    if(pCheckRObj){

                        pCheckRObj->Cleanup();
                        delete pCheckRObj;
                        pCheckRObj = NULL;
                    }
                    return hr;
                }

        if((atAction == ACTIONTYPE_ENUM) || ((pLocationRObj && pLocationRObj->m_bstrClass && (_wcsicmp(pLocationRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0)))))
            if(FAILED(hr = DirectoryParent(pHandler, atAction, pCheckRObj, pLocationRObj))){

                    if(pLocationRObj){

                        pLocationRObj->Cleanup();
                        delete pLocationRObj;
                        pLocationRObj = NULL;
                    }

                    if(pCheckRObj){

                        pCheckRObj->Cleanup();
                        delete pCheckRObj;
                        pCheckRObj = NULL;
                    }
                    return hr;
                }

            if(pLocationRObj){

                pLocationRObj->Cleanup();
                delete pLocationRObj;
                pLocationRObj = NULL;
            }

            if(pCheckRObj){

                pCheckRObj->Cleanup();
                delete pCheckRObj;
                pCheckRObj = NULL;
            }

    }catch(...){
            
        if(pLocationRObj){

            pLocationRObj->Cleanup();
            delete pLocationRObj;
            pLocationRObj = NULL;
        }

        if(pCheckRObj){

            pCheckRObj->Cleanup();
            delete pCheckRObj;
            pCheckRObj = NULL;
        }
    }

    return hr;
}

HRESULT CCheckCheck::DirectoryParent(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                             CRequestObject *pCheckRObj, CRequestObject *pLocationRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;
	MSIHANDLE hPView	= NULL;
	MSIHANDLE hPRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcParent[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcParentCompID[39];
    WCHAR wcTestCode[39];
    WCHAR wcFolder[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcLocation[BUFF_SIZE];
    bool bCheck = false;
    bool bLocation = false;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckRObj){

            for(int i = 0; i < pCheckRObj->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckRObj->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckRObj->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckRObj->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckRObj->m_Value[i], wcFolder);

						//we have a componentized directory... do a little more work
						if ((wcFolder[wcslen(wcFolder) - 1] == L'}') &&
							(wcFolder[wcslen(wcFolder) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcFolder, wcFolder);
						}

						bTestCode = true;
						bCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pLocationRObj){

            for(int i = 0; i < pLocationRObj->m_iPropCount; i++){
                
				if(_wcsicmp(pLocationRObj->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pLocationRObj->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pLocationRObj->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pLocationRObj->m_Value[i], wcLocation);

						//we have a componentized directory... do a little more work
						if ((wcLocation[wcslen(wcLocation) - 1] == L'}') &&
							(wcLocation[wcslen(wcLocation) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcLocation, wcLocation);
						}

						bTestCode = true;
						bLocation = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated, bParent, bDir;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Directory`, `Directory_Parent` from Directory" );

    //optimize for GetObject
    if ( bCheck || bLocation )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `Directory`=\'", wcFolder, L"\'" );
		}

		if ( bLocation )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Directory_Parent`=\'", wcLocation, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Directory_Parent`=\'", wcLocation, L"\'" );
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );
	QueryExt wcQuery2 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

	LPWSTR Buffer1 = NULL;
	LPWSTR dynBuffer1 = NULL;

	DWORD dwDynBuffer1 = 0L;

	while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Directory", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        bDoneFirst = false;
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer1, dynBuffer1, Buffer1 );

						// make query on fly
						wcQuery1.Append ( 2, Buffer1, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;
                                        bDir = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                            bDir = true;
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            dwBufSize = BUFF_SIZE;
											GetBufferToPut ( hRecord, 2, dwBufSize, wcParent, dwDynBuffer, dynBuffer, Buffer );

											// make query on fly
											wcQuery2.Append ( 2, Buffer, L"\'" );

                                            if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery2, &hPView)) == ERROR_SUCCESS)
                                                || !bDoneFirst){

                                                if((g_fpMsiViewExecute(hPView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                                    try{

                                                        uiStatus = g_fpMsiViewFetch(hPView, &hPRecord);

                                                        while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                                            
                                                            bValidated = false;
                                                            bParent = false;

                                                            if(uiStatus == ERROR_SUCCESS){

                                                                dwBufSize = 39;
                                                                CheckMSI(g_fpMsiRecordGetStringW(hPRecord, 1, wcParentCompID, &dwBufSize));
                                                                bValidated = ValidateComponentID(wcParentCompID, wcProductCode);
                                                                bParent = true;
                                                            }

                                                            if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                                                if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                                                //----------------------------------------------------
                                                                if ( Buffer1 && Buffer1 [ 0 ] != 0 )
																{
																	// safe operation
																	wcProp.Copy ( L"Win32_DirectorySpecification.CheckID=\"" );

																	if(bDir)
																	{
																		wcProp.Append ( 4, Buffer1, wcCompID, wcProductCode, L"\"" );
																	}
																	else
																	{
																		wcProp.Append ( 3, Buffer1, wcProductCode, L"\"" );
																	}

																	PutKeyProperty(m_pObj, pCheck, wcProp, &bDriver, m_pRequest);

                                                                    if ( Buffer && Buffer [ 0 ] != 0 ) 
																	{
																		// safe operation
																		wcProp.Copy ( L"Win32_DirectorySpecification.CheckID=\"" );

																		if(bParent)
																		{
																			wcProp.Append ( 4, Buffer, wcParentCompID, wcProductCode, L"\"" );
																		}
																		else
																		{
																			wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
																		}

																		PutKeyProperty(m_pObj, pLocation, wcProp, &bAttribute, m_pRequest);

                                                                    //----------------------------------------------------

                                                                        if(bDriver && bAttribute) bMatch = true;

                                                                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                                                                            hr = pHandler->Indicate(1, &m_pObj);
                                                                        }
                                                                    }
                                                                }

                                                                m_pObj->Release();
                                                                m_pObj = NULL;

                                                                if(!bDoneFirst) bDoneFirst = true;
                                                            }

                                                            g_fpMsiCloseHandle(hPRecord);

																uiStatus = g_fpMsiViewFetch(hPView, &hPRecord);
                                                        }

                                                    }catch(...){

                                                        g_fpMsiCloseHandle(hPRecord);
                                                        g_fpMsiViewClose(hPView);
                                                        g_fpMsiCloseHandle(hPView);
                                                        throw;
                                                    }

                                                    g_fpMsiCloseHandle(hPRecord);
                                                    g_fpMsiViewClose(hPView);
                                                    g_fpMsiCloseHandle(hPView);
                                                }
                                            }

											if ( dynBuffer && dynBuffer [ 0 ] != 0 )
											{
												dynBuffer [ 0 ] = 0;
											}
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

                                        uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

						if ( Buffer1 && Buffer1 [ 0 ] != 0 )
						{
							Buffer1 [ 0 ] = 0 ;
						}
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if ( dynBuffer1 )
				{
					delete [] dynBuffer1;
					dynBuffer1 = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

    if ( dynBuffer1 )
	{
		delete [] dynBuffer1;
		dynBuffer1 = NULL;
	}

	return hr;
}

HRESULT CCheckCheck::IniFileDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                             CRequestObject *pCheckRObj, CRequestObject *pLocationRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcDir[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcTestCode[39];
    WCHAR wcIniFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcLocation[BUFF_SIZE];
    bool bCheck = false;
    bool bLocation = false;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckRObj){

            for(int i = 0; i < pCheckRObj->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckRObj->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckRObj->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckRObj->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckRObj->m_Value[i], wcIniFile);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pLocationRObj){

            for(int i = 0; i < pLocationRObj->m_iPropCount; i++){
                
				if(_wcsicmp(pLocationRObj->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pLocationRObj->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pLocationRObj->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pLocationRObj->m_Value[i], wcLocation);

						//we have a componentized directory... do a little more work
						if ((wcLocation[wcslen(wcLocation) - 1] == L'}') &&
							(wcLocation[wcslen(wcLocation) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcLocation, wcLocation);
						}

						bTestCode = true;
						bLocation = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `IniFile`, `Component_`, `DirProperty` from IniFile" );

    if(atAction != ACTIONTYPE_ENUM){

		//optimize for GetObject
		if ( bCheck || bLocation )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" where `IniFile`=\'", wcIniFile, L"\'" );
			}

			if ( bLocation )
			{
				if ( bCheck )
				{
					wcQuery.Append ( 3, L" or `DirProperty`=\'", wcLocation, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `DirProperty`=\'", wcLocation, L"\'" );
				}
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

	LPWSTR Buffer1 = NULL;
	LPWSTR dynBuffer1 = NULL;

	DWORD dwDynBuffer1 = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"IniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        bDoneFirst = false;
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 3, dwBufSize, wcDir, dwDynBuffer1, dynBuffer1, Buffer1 );

						// make query on fly
						wcQuery1.Append ( 2, Buffer1, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                            //----------------------------------------------------
                                            dwBufSize = BUFF_SIZE;
											GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                            if ( Buffer && Buffer [ 0 ] != 0 )
											{
												// safe operation
												wcProp.Copy ( L"Win32_IniFileSpecification.CheckID=\"" );
												wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
												PutKeyProperty(m_pObj, pCheck, wcProp, &bDriver, m_pRequest);

												if ( dynBuffer && dynBuffer [ 0 ] != 0 )
												{
													dynBuffer [ 0 ] = 0;
												}

                                                dwBufSize = BUFF_SIZE;
												GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                                if ( ValidateComponentName	(	msidata.GetDatabase (),
																				wcProductCode,
																				Buffer
																			)
												   )
												{
													if ( dynBuffer && dynBuffer [ 0 ] != 0 )
													{
														dynBuffer [ 0 ] = 0;
													}

                                                    if ( Buffer1 && Buffer1 [ 0 ] != 0 )
													{
														// safe operation
														wcProp.Copy ( L"Win32_DirectorySpecification.CheckID=\"" );

														if(uiStatus == ERROR_SUCCESS)
														{
															wcProp.Append ( 4, Buffer1, wcCompID, wcProductCode, L"\"" );
														}
														else
														{
															wcProp.Append ( 3, Buffer1, wcProductCode, L"\"" );
														}

														PutKeyProperty(m_pObj, pLocation, wcProp, &bAttribute, m_pRequest);

                                                    //=====================================================

                                                    //----------------------------------------------------

                                                        if(bDriver && bAttribute) bMatch = true;

                                                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                                                            hr = pHandler->Indicate(1, &m_pObj);
                                                        }
                                                    
                                                    }
                                                }
												else
												{
													if ( dynBuffer && dynBuffer [ 0 ] != 0 )
													{
														dynBuffer [ 0 ] = 0;
													}
												}
                                            }

                                            if(!bDoneFirst) bDoneFirst = true;

                                            m_pObj->Release();
                                            m_pObj = NULL;
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

                                        uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

						if ( dynBuffer1 && dynBuffer1 [ 0 ] != 0 )
						{
							dynBuffer1 [ 0 ] = 0;
						}
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if ( dynBuffer1 )
				{
					delete [] dynBuffer1;
					dynBuffer1 = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

    if ( dynBuffer1 )
	{
		delete [] dynBuffer1;
		dynBuffer1 = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\checkcheck.h ===
// CheckCheck.h: interface for the CCheckCheck class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHECKCHECK_H__6F0256C0_D708_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_CHECKCHECK_H__6F0256C0_D708_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CCheckCheck : public CGenericClass  
{
public:
	CCheckCheck(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CCheckCheck();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT IniFileDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							 CRequestObject *pCheckRObj, CRequestObject *pLocationRObj);
	HRESULT DirectoryParent(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							CRequestObject *pCheckRObj, CRequestObject *pLocationRObj);
};

#endif // !defined(AFX_CHECKCHECK_H__6F0256C0_D708_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: WBEM Instance provider sample code

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <objbase.h>
#include "classfac.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    InterlockedIncrement(&g_cObj);

    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
	InterlockedDecrement(&g_cObj);

    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , LPVOID * ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid) *ppv=this;

    if (NULL!=*ppv){
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount) delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, LPVOID * ppvObj)
{
    CMSIProv *pObj;
    HRESULT hr = WBEM_S_NO_ERROR;

    *ppvObj=NULL;
    hr = E_OUTOFMEMORY;

    // This object doesnt support aggregation.

    if(NULL!=pUnkOuter) return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    pObj=new CMSIProv();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if(FAILED(hr)) delete pObj;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock) InterlockedIncrement(&g_cLock);
    else InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\classinfoaction.cpp ===
// ClassInfoAction.cpp: implementation of the CClassInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ClassInfoAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CClassInfoAction::CClassInfoAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CClassInfoAction::~CClassInfoAction()
{

}

HRESULT CClassInfoAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSView	= NULL;
	MSIHANDLE hSRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery1[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCLSID[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZ