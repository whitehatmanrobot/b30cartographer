;

		} // End While loop

		FindClose(FindFileHandle);

		// free memory
		if(AccountSids)
			LocalFree(AccountSids);
		if(SidFromLookupName)
			LocalFree(SidFromLookupName);
		if(SidEveryone)
			LocalFree(SidEveryone);

		return(TRUE);

	} /* end of main if */
	else
		usage(HELP, NULL);  

	return(TRUE);
} /* End of Main */

/* ********************************************************************* 
	Recure Subdirectories
************************************************************************ */
BOOL
RecurseSubs(IN LPTSTR FileName,
						IN LPTSTR FilePath,
						IN PSID UserSid,
						IN BOOL BackPriv,
						IN BOOL Recurse)
{
	char
		PathBuff[LSA_WIN_STANDARD_BUFFER_SIZE],  
		FileNameBuffer[LSA_WIN_STANDARD_BUFFER_SIZE],  
		GeneralUseBuffer[LSA_WIN_STANDARD_BUFFER_SIZE];

		DWORD cchRefDFromLookupName=0,
					SidsizeFromGetFileSecurity=0,
					lpcbsdRequired=0;

	SID_NAME_USE  UseFromLookupSid;                                
	LPSTR RPath,
				RFile;
	SECURITY_INFORMATION si;          /* requested information  */
	BOOL  BoolStatus=TRUE;
	ULONG AccountSidsLength;
	HANDLE FileHandle;
	WIN32_FIND_DATA FindFileData;

	
	
	// Need to create a wildcard file name for FindFirstFile    
	sprintf(FileNameBuffer, "%s%s%s", FilePath,  FileName, "\\*");
	RFile = (LPTSTR) &FileNameBuffer[0];
	// Update path to include the new directory
	sprintf(PathBuff, "%s%s%s", FilePath, FileName, "\\");
	RPath = (LPTSTR) &PathBuff[0];
	FileHandle = FindFirstFile(RFile, &FindFileData);
	if(FileHandle == INVALID_HANDLE_VALUE)
		return(FALSE);    
	
	si =(OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION
				 |DACL_SECURITY_INFORMATION);
		
		
	// Now have all of the user sid and the first file.
	// Loop through the files
	while(1)
	{
		
		// Need to check for "." and ".."
	 
		if(strcmp(FindFileData.cFileName, ".") != 0) 
			if(strcmp(FindFileData.cFileName, "..") != 0)
		{
			sprintf(RFile, "%s%s", RPath,  FindFileData.cFileName);
			/* The call to GetFileSecurity works similar to LookupAccountName 
				in that the first call get need buffer sizes */
		 

			// Use a fairly larger buffer size of returned size value.
			// This will keep the number of malloc type calls down.
			SidsizeFromGetFileSecurity = LARGEPSID;
			BoolStatus = GetFileSecurityBackup(RFile, 
					si, 
					SidFromGetFileSecurity, 
					SidsizeFromGetFileSecurity,  /* buffer size */
					&lpcbsdRequired,    /* required buffer size */
					BackPriv);
		 if(!BoolStatus)
		 {
		 // GetFileSecurity failed need to check if buffer was to small
			if(lpcbsdRequired != 0)
			{
				SidsizeFromGetFileSecurity = lpcbsdRequired;
				// Reallocate the memory to the new size
				SidFromGetFileSecurity =  GlobalReAlloc( SidFromGetFileSecurity, lpcbsdRequired, GMEM_ZEROINIT);  
				BoolStatus = GetFileSecurityBackup(RFile, 
					si, 
					SidFromGetFileSecurity, 
					SidsizeFromGetFileSecurity,    
					&lpcbsdRequired,     
					BackPriv);
				if(!BoolStatus)
				{
					 
					return(FALSE);
			 }

			}
			// Have general failure this is a access priv problem.
			DisplayPerms(RFile, FALSE);
		}
		if(BoolStatus)  // Valid file security discriptor
		{
			grant_mask = 0;
	
			if(!GetFilePermissions(SidFromGetFileSecurity, (PSID) UserSid))
				return(FALSE);
			// Need to chech for directory structure
			if(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				 // Display the directory perms
				 strcat(RFile, "\\");
				 DisplayPerms(RFile, TRUE);
				 // Recurse subdirectories
				 // Need the Filename, Path, user account sid, and Backup priv flag
				 RecurseSubs(FindFileData.cFileName, RPath, SidFromLookupName, BackPriv,
				 Recurse);
		 
			}
			else
				DisplayPerms(RFile, TRUE);
		} // End of valid security descriptor else
	} // end of ". or .." if
	 // Go for the next file 
	 if(!FindNextFile(FileHandle, &FindFileData))
		break;
	} // End While loop
	
	return(TRUE);
}


/* ***************************************************************
	Usage Error subroutine
******************************************************************* */


void usage(IN INT message_num, 
					 IN PCHAR string_val)
{
	if(string_val == NULL)
		fprintf(stderr, "\n%s\n", MESSAGES[message_num]);
	else
		fprintf(stderr,"\n%s %s\n", MESSAGES[message_num], string_val);
}

/*
	System Error subroutine
*/


void syserror(DWORD error_val)
{
	CHAR MessageBuf[512];
	DWORD eval,
				Lang_Val;

	Lang_Val = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
	FormatMessage(
	FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
								NULL,
								error_val,
								Lang_Val,
								(LPTSTR) MessageBuf,
								512,
								NULL);

 printf("\n%s", MessageBuf);               
}

/* ********************************************************************* */
BOOL IsDomainName(
						 IN LPSTR TestDomainName, 
						 IN LPSTR DomainNameBuff)
{
	NTSTATUS dNtStatus;
	ANSI_STRING  AnsiString;
	UNICODE_STRING UDomainName;
	NET_API_STATUS NetCallStatus;
	LPBYTE xbuff = NULL;
	LPWSTR NDomainName;
	UINT BuffSize;
	INT AnsiSize, slen;
	
	UDomainName.Buffer = NULL;
	// get a unicode string  
	RtlInitAnsiString( &AnsiString, TestDomainName );
	dNtStatus = RtlAnsiStringToUnicodeString( &UDomainName, &AnsiString, TRUE );
	// Free up the ansi string to use it later
//	RtlFreeAnsiString(&AnsiString);
	// Compute the needed amount of memory for a zero terminated string  
	// Allocate the memory and zero it 
	BuffSize = (UINT) (UDomainName.Length * 2) + 4;
	NDomainName = LocalAlloc( (UINT) LPTR, 
								 BuffSize);        

	if (NDomainName == NULL)
	{
			syserror(GetLastError());
			exit(FALSE);                                                          
	}                                                                           
	// Copy the wide string to the allocated memory 
	RtlMoveMemory( NDomainName, UDomainName.Buffer, BuffSize-4);
	// Should now have a zero terminated string
	
	// now check for the domain name 
	NetCallStatus = NetGetDCName(NULL, NDomainName,
																 &xbuff );
	if(NetCallStatus == ERROR_SUCCESS)
	{
		// Convert the wchar null string to ansi sting is passed back machine 
		// name of domain controler
		// Use the current unicode buffer
		slen = wcslen((USHORT *) xbuff) * 2;
		UDomainName.Length = (USHORT) slen;
		UDomainName.MaximumLength = (USHORT) slen + 2;
		UDomainName.Buffer = (PWSTR) xbuff;
		dNtStatus = RtlUnicodeStringToAnsiString( &AnsiString, &UDomainName, TRUE );
		// return the string pointer
		RtlMoveMemory( DomainNameBuff, AnsiString.Buffer, 
		(UINT) strlen(AnsiString.Buffer) +1);
		LocalFree(NDomainName);

		return(TRUE);
	}
	LocalFree(NDomainName);

	return(FALSE);
}

/* ********************************************************************* */

BOOL
LookupAllUserSidsWS( IN LPSTR lpSystemName  
		)

/*++

Routine Description:


Arguments:


Return Value:

		BOOL - TRUE is returned if successful, else FALSE.

--*/

{
	NTSTATUS xNtStatus;
	ANSI_STRING  AnsiString;
	UNICODE_STRING USystemName;
	ULONG Count;
	OBJECT_ATTRIBUTES ObjectAttributes;
	SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
	LSA_HANDLE PolicyHandle = NULL;
	UNICODE_STRING AccountDomainName;
	PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
	USystemName.Buffer = NULL;

		
		
		RtlInitAnsiString( &AnsiString, lpSystemName );
		xNtStatus = RtlAnsiStringToUnicodeString( &USystemName, &AnsiString, TRUE );

		if (!NT_SUCCESS(xNtStatus)) 
		{
			SetLastError(xNtStatus);
			return(FALSE);
		}
		//
		// Open a handle to the target Workstation's Policy Object so that we can
		// information from it and also so that we can use it for looking up.
		// Sids
		//

		InitObjectAttributes(
											&ObjectAttributes,
											&SecurityQualityOfService
														);


		xNtStatus = LsaOpenPolicy(
											&USystemName,   // WorkstationName,
											&ObjectAttributes,
											POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,
											&PolicyHandle
													);

		if (!NT_SUCCESS(xNtStatus)) 
		{
			// try local machine
			PolicyHandle = NULL;
			xNtStatus = LsaOpenPolicy(
											NULL,    // WorkstationName,
											&ObjectAttributes,
											POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,
											&PolicyHandle
													);


			if (!NT_SUCCESS(xNtStatus)) 
			{
				SetLastError(xNtStatus);
				return(FALSE);
			}
		}
		//  Lookup the Group Sids contained in the Workstation's                                                                             
		// SAM Account Domain
		//
		// First, obtain the Name and Sid of the SAM Account Domain from the
		// Workstation's LSA Policy Object.
		//
		 

		xNtStatus = LsaQueryInformationPolicy(
		PolicyHandle,
		PolicyAccountDomainInformation,
		(PVOID *) &PolicyAccountDomainInfo
		);
		
		if (!NT_SUCCESS(xNtStatus)) 
		{
			SetLastError(xNtStatus);
			return(FALSE);
		}

		AccountDomainName = PolicyAccountDomainInfo->DomainName;
		
		xNtStatus = LsaClose(PolicyHandle);
		if(!NT_SUCCESS(xNtStatus)) 
		{

			SetLastError(xNtStatus);
			return(FALSE);
		}

		if(!LookupSidsInSamDomain(
										&USystemName,   // WorkstationName,
										&USystemName,   // WorkstationName,
										&AccountDomainName
										)) 
		return(FALSE);
		
		if( USystemName.Buffer != NULL ) 
		{

				RtlFreeUnicodeString( &USystemName );
		}
		
	return(TRUE);
}


BOOL                                                                       
GeneralBuildSid(                                                         
		OUT PSID *Sid,                                                                
		IN PSID DomainSid,                                                           
		IN ULONG RelativeId                                                          
		)                                                                         

/*++                                                                          
		
Routine Description:                                                          
		
		This function builds a Sid from a Domain Sid and a RelativeId.            
		
Arguments:                                                                    
		
		Sid - Receives a pointer to the constructed Sid.                          
		
		DomainSid - Points to a Domain Sid                                        
		
		RelativeId - Contains a Relative Id

		
	
 
	
		
				
								
		BOOL - TRUE if successful, else FALSE.                                 
	
--*/                                                                          
	
{                                                                             
	PSID OutputSid = NULL;                                                      
	ULONG OutputSidLength;                                                      
	UCHAR SubAuthorityCount;
	
	SubAuthorityCount = *RtlSubAuthorityCountSid( DomainSid ) + (UCHAR) 1;      
		OutputSidLength = RtlLengthRequiredSid( SubAuthorityCount );

	OutputSid = LocalAlloc( (UINT) LMEM_FIXED, (UINT) OutputSidLength );        

	if (OutputSid == NULL) {                                                    

			return(FALSE);                                                          
	}                                                                           
 
	RtlMoveMemory( OutputSid, DomainSid, OutputSidLength - sizeof (ULONG));     
		(*RtlSubAuthorityCountSid( OutputSid ))++;                                  
		(*RtlSubAuthoritySid(OutputSid, SubAuthorityCount - (UCHAR) 1)) = RelativeId; 
 
	*Sid = OutputSid;  
	
	return(TRUE);                                                               
}                                                                             



VOID
InitObjectAttributes(
		IN POBJECT_ATTRIBUTES ObjectAttributes,
		IN PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
		)

/* ++

Routine Description:

		This function initializes the given Object Attributes structure, including
		Security Quality Of Service.  Memory must be allcated for both
		ObjectAttributes and Security QOS by the caller.

Arguments:

		ObjectAttributes - Pointer to Object Attributes to be initialized.

		SecurityQualityOfService - Pointer to Security QOS to be initialized.

Return Value:

		None.

-- */

{
		SecurityQualityOfService->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
		SecurityQualityOfService->ImpersonationLevel = SecurityImpersonation;
		SecurityQualityOfService->ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
		SecurityQualityOfService->EffectiveOnly = FALSE;

		//
		// Set up the object attributes prior to opening the LSA.
		//

		InitializeObjectAttributes(
				ObjectAttributes,
				NULL,
				0L,
				NULL,
				NULL
		);

		//
		// The InitializeObjectAttributes macro presently stores NULL for
		// the SecurityQualityOfService field, so we must manually copy that
		// structure for now.
		//

		ObjectAttributes->SecurityQualityOfService = SecurityQualityOfService;
}


BOOL
LookupSidsInSamDomain(
		IN OPTIONAL PUNICODE_STRING WorkstationName,
		IN PUNICODE_STRING DomainControllerName,
		IN PUNICODE_STRING SamDomainName
		)

/*++

Routine Description:

		This function enumerates all the SAM accounts of a specified type
		in a specified SAM domain on a specified target system.  The system
		must be one of the following:

		o The Workstation itself.
		o A Domain Controller for the Primary Domain of the Workstation.
		o A Domain Controller for one of the Trusted Domains of the
			Workstation.


		Having enumerated the accounts, the function then performs
		an LsaLookupSids call via the specified Workstation to lookup all of
		these account Sids, and then compares the returned information
		with that expected.

Arguments:

		WorkstationName - Specifies a Workstation Name.  The name may be
				the NULL string, which means the current system.

		DomainControllerName - Specifies the name of a target Domain Controller
				for (the Workstation's Primary Domain or one of its Trusted
				Domains.

		SamDomainName - Specifies the name of the SAM Domain. This is either
				the BUILTIN Domain or the name of the Accounts Domain.

		SamAccountType - Specifies the type of SAM account to be enumerated
				and looked up.

Return Values:

		BOOL - TRUE if successful, else FALSE.

--*/

{
		NTSTATUS CtStatus;
		BOOL BooleanStatus = TRUE;
		OBJECT_ATTRIBUTES SamObjectAttributes;
		OBJECT_ATTRIBUTES LsaObjectAttributes;
		PSID SamDomainSid = NULL;
		SID WorldTypeSid = SECURITY_WORLD_SID_AUTHORITY;
		PSAM_RID_ENUMERATION EnumerationBuffer = NULL;
		ULONG DomainIndex;
		ULONG UserAccountControl;
		ULONG GroupCount;
		ULONG SidCount=0;
		ULONG Relid=0;
		ULONG RidIndex=0;
		ULONG GenRid;
		ULONG CountReturned;
		PULONG AliasBuffer;
		UNICODE_STRING TmpDomainControllerName;
		PVOID EnumerationInformation;
		ULONG EnumerationContext;
		ULONG PreferedMaximumLength;
		
		//
		// Connect to the SAM server.
		//

				CtStatus = SamConnect(
								 DomainControllerName,
								 &SamServerHandle,
								 SAM_SERVER_ENUMERATE_DOMAINS | SAM_SERVER_LOOKUP_DOMAIN,
								 &SamObjectAttributes
								 );

			if (!NT_SUCCESS(CtStatus)) 
			{

				// try local machine
				CtStatus = SamConnect(
								 NULL,    // DomainControllerName,
								 &SamServerHandle,
								 SAM_SERVER_ENUMERATE_DOMAINS | SAM_SERVER_LOOKUP_DOMAIN,
								 &SamObjectAttributes
								 );
				if (!NT_SUCCESS(CtStatus)) 
				{
					SetLastError(CtStatus);
					return(FALSE);
				}
			}

		//
		// Lookup the Named Domain in the Sam Server to get its Sid.
		//
		CountReturned = 0;
		EnumerationContext = 0;
		EnumerationBuffer = NULL;
		PreferedMaximumLength = 512;
		CtStatus = SamEnumerateDomainsInSamServer(
														SamServerHandle,
														&EnumerationContext,
														(PVOID *) &EnumerationBuffer,
														PreferedMaximumLength,
														&CountReturned
														);
		if(!NT_SUCCESS(CtStatus)) 
		{
			SetLastError(CtStatus);
			return(FALSE);
		}

		if((INT) CountReturned == 0) 
		{
			SetLastError(CtStatus);
			return(FALSE);
		}


	 //
	 // Now look up the sid for the domains in the samserver
	 //
		
	for(DomainIndex = 0; DomainIndex < CountReturned; DomainIndex++) 
	{

//    if(SamDomainHandle != NULL)
//      CtStatus = SamCloseHandle(SamDomainHandle);
		SamDomainHandle = NULL;
		SamDomainSid = NULL;
		GroupCount = 0;
		SidCount = 0;

		CtStatus = SamLookupDomainInSamServer(
								SamServerHandle,
								(PUNICODE_STRING) &EnumerationBuffer[ DomainIndex ].Name,     // SamDomainName,
								&SamDomainSid
								);

		if(!NT_SUCCESS(CtStatus)) 
		{
			SetLastError(CtStatus);
			return(FALSE);
		}

		//
		// Open the Domain
		//
		
		CtStatus = SamOpenDomain(
								SamServerHandle,
								(GENERIC_READ | GENERIC_EXECUTE), //(DOMAIN_LIST_ACCOUNTS|DOMAIN_GET_ALIAS_MEMBERSHIP)
								SamDomainSid,
								&SamDomainHandle
								);

		if (!NT_SUCCESS(CtStatus)) 
		{
			SetLastError(CtStatus);
			return(FALSE);
		}
		CtStatus = SamGetAliasMembership(
										SamDomainHandle,
										1,
										ASidFromLookupName,
										&GroupCount,
										&AliasBuffer
										);
		 if(!NT_SUCCESS(CtStatus)) 
		 {
			SetLastError(CtStatus);
			return(FALSE);
		}

			if (GroupCount == 0)
			{
			 //  SamCloseHandle(SamDomainHandle);
				 SamFreeMemory(AliasBuffer);
				SamDomainSid = NULL;
				GroupCount = 0;
				SidCount = 0;
				continue;
			}
		//
		// Now construct the Account Sids from the Rids just enumerated.
		// We prepend the Sam Domain Sid to the Rids.
		//
			SidCount = RidIndex + GroupCount;
			for (RidIndex; RidIndex < SidCount; RidIndex++) 
			{
				Relid =  AliasBuffer[ RidIndex ];
				if (!GeneralBuildSid(
								&(AccountSids[Total_Sids++]),
								SamDomainSid,
								AliasBuffer[ RidIndex ]
								)) 
				{
					SetLastError(CtStatus);
					return(FALSE);
				}
			}  // end for loop

	// free up Sam memory to use again
	SamFreeMemory(AliasBuffer);

	}  // domain for loop 
				
	// add world sid        
	AccountSids[Total_Sids++] = SeWorldSid;


	// if interactive logon
	if(inter_logon)
	{
		// printf("\n adding Interactive sid ");
		AccountSids[Total_Sids++] = SeInteractiveSid;
	}
	else
		AccountSids[Total_Sids++] = SeNetworkSid;


	// Add in Account Sid 
	AccountSids[Total_Sids++] = SidFromLookupName;

	//
	// If necessary, close the SAM Domain Handle for the Workstation.
	//
	if(SamDomainHandle != NULL)
		CtStatus = SamCloseHandle( SamDomainHandle);
	//
	// If necessary, disconnect from the SAM Server.
	//

	if(SamServerHandle != NULL)
		CtStatus = SamCloseHandle( SamServerHandle );

	return(TRUE);
}


//
//
//

void DisplayPerms(IN LPTSTR filename, IN BOOL valid_access)
{
	if(g_noAccess)
	{
		printf("-");
		goto exit;
	}

	if(valid_access)
	{
		if(owner_flag == TRUE)
			printf("*");
		else if(owner_group == TRUE)
			printf("#");

		if( grant_mask == 0)
		{
			printf("?");
			goto exit;
		}

		if(grant_mask == FILE_GEN_ALL)
		{
			printf("A");
			goto exit;
		}
		if((FILE_GENERIC_READ & grant_mask) == FILE_GENERIC_READ)
			printf("R");

		if((FILE_GENERIC_WRITE & grant_mask) == FILE_GENERIC_WRITE)
			printf("W");
	
		if((FILE_GENERIC_EXECUTE & grant_mask) == FILE_GENERIC_EXECUTE)
			printf("X");
	
		if((DELETE & grant_mask) == DELETE)
			printf("D");
	
		if((WRITE_DAC & grant_mask) == WRITE_DAC)
			printf("P");
	
		if((WRITE_OWNER & grant_mask) == WRITE_OWNER)
			printf("O");
	} // End if !valid_access
	else
		printf("?");

exit:	
	printf("\t%s\n", filename);		
	return;
}



BOOL GetFilePermissions(
		 IN PSECURITY_DESCRIPTOR SecurityDescriptor,
		 OUT PSID UserAccountSids)

{

		PISECURITY_DESCRIPTOR ISecurityDescriptor;
		UCHAR Revision;
		SECURITY_DESCRIPTOR_CONTROL Control;
		PSID Owner;
		PSID Group;
		PACL Sacl;
		PACL Dacl;
		ULONG ui;


		ISecurityDescriptor = ( PISECURITY_DESCRIPTOR )SecurityDescriptor;

		Revision = ISecurityDescriptor->Revision;
		Control  = ISecurityDescriptor->Control;

		Owner    = SepOwnerAddrSecurityDescriptor( ISecurityDescriptor );
		Group    = SepGroupAddrSecurityDescriptor( ISecurityDescriptor );
		Sacl     = SepSaclAddrSecurityDescriptor( ISecurityDescriptor );
		Dacl     = SepDaclAddrSecurityDescriptor( ISecurityDescriptor );

		
		if(EqualSid(UserAccountSids, Owner))
			owner_flag = TRUE;
		// check all the group sids for owner
		for(ui=0; ui < Total_Sids; ui++)
		{
			if(EqualSid(AccountSids[ui], Owner))
			{
				SidOwnerGroup = AccountSids[ui];
				owner_group = TRUE;
			}
		}

		
		if(Dacl == NULL)
		{
			return(TRUE);
		}
		else
		{
			// Check the user sid ACLS
			if(!ProcessAcl( Dacl))
			{
				return(FALSE);
			}

		}
	return(TRUE);
}

/* ********************************************************************** */


// changed by a-zexu @ 5/10/98
BOOL ProcessAcl(PACL Acl)
{
	ULONG i;
	PACCESS_ALLOWED_ACE Ace;
	BOOL KnownType = FALSE;
	ULONG isid;
	ACCESS_MASK  mask = 0;
	PCHAR AceTypes[] = { "Access Allowed",
						 "Access Denied ",
						 "System Audit  ",
						 "System Alarm  " };

	
	// Check if the Acl is null.  
	if (Acl == NULL)
		return(FALSE);

	// Now for each Ace check the Sids of Owner
	if(owner_group)
	{
		mask = 0;

		for (i = 0, Ace = FirstAce(Acl);
				 i < Acl->AceCount;
				 i++, Ace = NextAce(Ace) ) 
		{
			if(EqualSid(SidOwnerGroup, &Ace->SidStart))
			{
				//  Special case on the standard ace types
				if(Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) 
				{
					mask = Ace->Mask;
				}
				else if(Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) 
					g_noAccess = TRUE;
			}
		} //end ace loop
		
		grant_mask |= mask;
	}

	// Now for each Ace check the Sids of Everyone
	if(!g_noAccess && SidEveryone)
	{	
		mask = 0;

		for (i = 0, Ace = FirstAce(Acl);
				 i < Acl->AceCount;
				 i++, Ace = NextAce(Ace) ) 
		{
			if(EqualSid(SidEveryone, &Ace->SidStart))
			{
				//  Special case on the standard ace types
				if(Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) 
				{
					mask = Ace->Mask;
				}
				else if(Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) 
					g_noAccess = TRUE;
			}
		} //end ace loop

		grant_mask |= mask;
	}

	// Now for each Ace check the Sids of the user
	if(!g_noAccess)
	{
		mask = 0;

		for (i = 0, Ace = FirstAce(Acl);
				 i < Acl->AceCount;
				 i++, Ace = NextAce(Ace) ) 
		{
			if(EqualSid(SidFromLookupName, &Ace->SidStart))
			{
				//  Special case on the standard ace types
				if(Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) 
				{
					mask = Ace->Mask;
				}
				else if(Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) 
					g_noAccess = TRUE;
			}
		} //end ace loop

		grant_mask |= mask;
	}
	
	return(TRUE);
}
/********************************************************************/


BOOL
VariableInitialization()
/*++

Routine Description:

		This function initializes the global variables used by and exposed
		by security.

Arguments:

		None.

Return Value:

		TRUE if variables successfully initialized.
		FALSE if not successfully initialized.

--*/
{

		PVOID HeapHandel;                                  
																															 
		ULONG SidWithZeroSubAuthorities;
		ULONG SidWithOneSubAuthority;
		ULONG SidWithTwoSubAuthorities;
		ULONG SidWithThreeSubAuthorities;
		
		SID_IDENTIFIER_AUTHORITY NullSidAuthority;
		SID_IDENTIFIER_AUTHORITY WorldSidAuthority;
		SID_IDENTIFIER_AUTHORITY LocalSidAuthority;
		SID_IDENTIFIER_AUTHORITY CreatorSidAuthority;
		SID_IDENTIFIER_AUTHORITY SeNtAuthority;

		
																													 
		//                                                 
		// Get the handle to the current process heap      
		//                                                 

		HeapHandel = RtlProcessHeap();                     
																													 

		
		
		NullSidAuthority         = SepNullSidAuthority;
		WorldSidAuthority        = SepWorldSidAuthority;
		LocalSidAuthority        = SepLocalSidAuthority;
		CreatorSidAuthority      = SepCreatorSidAuthority;
		SeNtAuthority            = SepNtAuthority;


		//
		//  The following SID sizes need to be allocated
		//

		SidWithZeroSubAuthorities  = RtlLengthRequiredSid( 0 );
		SidWithOneSubAuthority     = RtlLengthRequiredSid( 1 );
		SidWithTwoSubAuthorities   = RtlLengthRequiredSid( 2 );
		SidWithThreeSubAuthorities = RtlLengthRequiredSid( 3 );

		//
		//  Allocate and initialize the universal SIDs
		//

		SeNullSid         = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeWorldSid        = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeLocalSid        = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeCreatorOwnerSid = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeCreatorGroupSid = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);

		//
		// Fail initialization if we didn't get enough memory for the universal
		// SIDs.
		//

		if ( (SeNullSid         == NULL) ||
				 (SeWorldSid        == NULL) ||
				 (SeLocalSid        == NULL) ||
				 (SeCreatorOwnerSid == NULL) ||
				 (SeCreatorGroupSid == NULL)
			 ) 
		{
				return( FALSE );
		}

		RtlInitializeSid( SeNullSid,         &NullSidAuthority, 1 );
		RtlInitializeSid( SeWorldSid,        &WorldSidAuthority, 1 );
		RtlInitializeSid( SeLocalSid,        &LocalSidAuthority, 1 );
		RtlInitializeSid( SeCreatorOwnerSid, &CreatorSidAuthority, 1 );
		RtlInitializeSid( SeCreatorGroupSid, &CreatorSidAuthority, 1 );

		*(RtlSubAuthoritySid( SeNullSid, 0 ))         = SECURITY_NULL_RID;
		*(RtlSubAuthoritySid( SeWorldSid, 0 ))        = SECURITY_WORLD_RID;
		*(RtlSubAuthoritySid( SeLocalSid, 0 ))        = SECURITY_LOCAL_RID;
		*(RtlSubAuthoritySid( SeCreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;
		*(RtlSubAuthoritySid( SeCreatorGroupSid, 0 )) = SECURITY_CREATOR_GROUP_RID;

		//
		// Allocate and initialize the NT defined SIDs
		//

		SeNetworkSid      = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeInteractiveSid  = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeLocalSystemSid  = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);

		SeAliasAdminsSid   = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasUsersSid  = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasGuestsSid   = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasPowerUsersSid = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasAccountOpsSid = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasSystemOpsSid  = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasPrintOpsSid   = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasBackupOpsSid  = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);

		//
		// Fail initialization if we didn't get enough memory for the NT SIDs.
		//

		if((SeNetworkSid          == NULL) ||
				 (SeInteractiveSid      == NULL) ||
				 (SeLocalSystemSid      == NULL) ||
				 (SeAliasAdminsSid      == NULL) ||
				 (SeAliasUsersSid       == NULL) ||
				 (SeAliasGuestsSid      == NULL) ||
				 (SeAliasPowerUsersSid  == NULL) ||
				 (SeAliasAccountOpsSid  == NULL) ||
				 (SeAliasSystemOpsSid   == NULL) ||
				 (SeAliasPrintOpsSid    == NULL) ||
				 (SeAliasBackupOpsSid   == NULL)
			 ) {
				return(FALSE);
		}

		RtlInitializeSid( SeNetworkSid,         &SeNtAuthority, 1 );
		RtlInitializeSid( SeInteractiveSid,     &SeNtAuthority, 1 );
		RtlInitializeSid( SeLocalSystemSid,     &SeNtAuthority, 1 );


		*(RtlSubAuthoritySid( SeNetworkSid,         0 )) = SECURITY_NETWORK_RID;
		*(RtlSubAuthoritySid( SeInteractiveSid,     0 )) = SECURITY_INTERACTIVE_RID;
		*(RtlSubAuthoritySid( SeLocalSystemSid,     0 )) = SECURITY_LOCAL_SYSTEM_RID;


		return(TRUE);

}


/* ************************************************************************* */



BOOL
GetTokenHandle(
		IN OUT PHANDLE TokenHandle
		)
//
// This routine will open the current process and return
// a handle to its token.
//
// These handles will be closed for us when the process
// exits.
//
{

		HANDLE ProcessHandle;
		BOOL Result;

		ProcessHandle = OpenProcess(
												PROCESS_QUERY_INFORMATION,
												FALSE,
												GetCurrentProcessId()
												);

		if (ProcessHandle == NULL)
				return(FALSE);


		Result = OpenProcessToken (
								 ProcessHandle,
								 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
								 TokenHandle
								 );

		if (!Result)
				return(FALSE);

		return(TRUE);
}

/* *********************************************************************** */

BOOL
SetBackOperatorPriv(
			IN HANDLE TokenHandle
		)
//
// This routine turns on SeSetBackupPrivilege in the current
// token.  Once that has been accomplished, we can open the file
// for READ_OWNER even if we are denied that access by the ACL
// on the file.

{
		LUID SetBackupPrivilegeValue;
		TOKEN_PRIVILEGES TokenPrivileges;


		//
		// First, find out the value of Backup Privilege
		//


		if(!LookupPrivilegeValue(
								 NULL,
								 "SeBackupPrivilege",
								 &SetBackupPrivilegeValue
								 ))
				return(FALSE);

		//
		// Set up the privilege set we will need
		//

		TokenPrivileges.PrivilegeCount = 1;
		TokenPrivileges.Privileges[0].Luid = SetBackupPrivilegeValue;
		TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;




		(VOID) AdjustTokenPrivileges (
								TokenHandle,
								FALSE,
								&TokenPrivileges,
								sizeof( TOKEN_PRIVILEGES ),
								NULL,
								NULL
								);

		if(GetLastError() != NO_ERROR ) 
				return(FALSE);

		return(TRUE);
}




BOOL
GetFileSecurityBackupW(
		LPWSTR lpFileName,
		SECURITY_INFORMATION RequestedInformation,
		PSECURITY_DESCRIPTOR pSecurityDescriptor,
		DWORD nLength,
		LPDWORD lpnLengthNeeded,
		BOOL UseBackUp
		)

/*++

Routine Description:

		This API returns top the caller a copy of the security descriptor
		protecting a file or directory.  Based on the caller's access
		rights and privileges, this procedure will return a security
		descriptor containing the requested security descriptor fields.
		To read the handle's security descriptor the caller must be
		granted READ_CONTROL access or be the owner of the object.  In
		addition, the caller must have SeSecurityPrivilege privilege to
		read the system ACL.

Arguments:

		lpFileName - Represents the name of the file or directory whose
				security is being retrieved.

		RequestedInformation - A pointer to the security information being
				requested.

		pSecurityDescriptor - A pointer to the buffer to receive a copy of
				the secrity descriptor protecting the object that the caller
				has the rigth to view.  The security descriptor is returned in
				self-relative format.

		nLength - The size, in bytes, of the security descriptor buffer.

		lpnLengthNeeded - A pointer to the variable to receive the number
				of bytes needed to store the complete secruity descriptor.  If
				returned number of bytes is less than or equal to nLength then
				the entire security descriptor is returned in the output
				buffer, otherwise none of the descriptor is returned.

Return Value:

		TRUE is returned for success, FALSE if access is denied or if the
				buffer is too small to hold the security descriptor.


--*/
{
		NTSTATUS WStatus;
		HANDLE FileHandle;
		ACCESS_MASK DesiredAccess;
		OBJECT_ATTRIBUTES Obja;
		UNICODE_STRING FileName;
		RTL_RELATIVE_NAME_U RelativeName;
		IO_STATUS_BLOCK IoStatusBlock;
		PVOID FreeBuffer;

		QuerySecAccessMask(
				RequestedInformation,
				&DesiredAccess
				);

		if(!RtlDosPathNameToRelativeNtPathName_U(
														lpFileName,
														&FileName,
														NULL,
														&RelativeName
														))
                {
			return(FALSE);
                }

		FreeBuffer = FileName.Buffer;

		if(RelativeName.RelativeName.Length) 
		{
				FileName = RelativeName.RelativeName;
		}
		else 
		{
				RelativeName.ContainingDirectory = NULL;
		}

		InitializeObjectAttributes(
				&Obja,
				&FileName,
				OBJ_CASE_INSENSITIVE,
				RelativeName.ContainingDirectory,
				NULL
				);
		// Check for backup operator priv.
		if(UseBackUp)
		{
			WStatus = NtOpenFile(
								 &FileHandle,
								 DesiredAccess,
								 &Obja,
								 &IoStatusBlock,
								 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 
								 FILE_OPEN_FOR_BACKUP_INTENT  
								 );
		}
		else
		{
			WStatus = NtOpenFile(
								 &FileHandle,
								 DesiredAccess,
								 &Obja,
								 &IoStatusBlock,
								 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 
								 0
								 );
		}

                RtlReleaseRelativeName(&RelativeName);
		RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

		if(NT_SUCCESS(WStatus)) 
		{
				WStatus = NtQuerySecurityObject(
										 FileHandle,
										 RequestedInformation,
										 pSecurityDescriptor,
										 nLength,
										 lpnLengthNeeded
										 );
				NtClose(FileHandle);
		}


		if(!NT_SUCCESS(WStatus)) 
		{
		 //   LastNTError(WStatus);
				return(FALSE);
		}

		return(TRUE);
}

BOOL
GetFileSecurityBackup(
		LPSTR lpFileName,
		SECURITY_INFORMATION RequestedInformation,
		PSECURITY_DESCRIPTOR pSecurityDescriptor,
		DWORD nLength,
		LPDWORD lpnLengthNeeded,
		BOOL BackUpPrivFlag
		)

/*++

Routine Description:

		ANSI thunk to GetFileSecurityBackupW

--*/

{

		PUNICODE_STRING Unicode;
		ANSI_STRING AnsiString;
		NTSTATUS FStatus;

		Unicode = &NtCurrentTeb()->StaticUnicodeString;
		RtlInitAnsiString(&AnsiString,lpFileName);
		FStatus = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
		if(!NT_SUCCESS(FStatus)) 
		{
		 //   LastNTError(FStatus);
				return FALSE;
		}
		return ( GetFileSecurityBackupW( Unicode->Buffer,
															 RequestedInformation,
															 pSecurityDescriptor,
															 nLength,
															 lpnLengthNeeded,
															 BackUpPrivFlag
												)
					 );
}





VOID
QuerySecAccessMask(
		IN SECURITY_INFORMATION SecurityInformation,
		OUT LPDWORD DesiredAccess
		)

/*++

Routine Description:

		This routine builds an access mask representing the accesses necessary
		to query the object security information specified in the
		SecurityInformation parameter.  While it is not difficult to determine
		this information, the use of a single routine to generate it will ensure
		minimal impact when the security information associated with an object is
		extended in the future (to include mandatory access control information).

Arguments:

		SecurityInformation - Identifies the object's security information to be
				queried.

		DesiredAccess - Points to an access mask to be set to represent the
				accesses necessary to query the information specified in the
				SecurityInformation parameter.

Return Value:

		None.

--*/

{

		//
		// Figure out accesses needed to perform the indicated operation(s).
		//

		(*DesiredAccess) = 0;

		if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
				(SecurityInformation & GROUP_SECURITY_INFORMATION) ||
				(SecurityInformation & DACL_SECURITY_INFORMATION)) {
				(*DesiredAccess) |= READ_CONTROL;
		}

		if ((SecurityInformation & SACL_SECURITY_INFORMATION)) {
				(*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
		}

		return;

} // end function




/* ******************************************************************
	 This routines filter out odd user inputs . .. ../ / _: and
	 unc //xxx/xxx. The routine adds a backslash to root level
	 directories only. For the "FROM" String.
	 ****************************************************************** */
BOOL CleanUpSource(IN LPTSTR InString,
		 OUT LPTSTR OutString,
		 OUT BOOL *DirectoryFlag)
{
	LPTSTR searchchar,
				 schar,
				 OutstringAddr=NULL;

	char CurDir[STANDARD_BUFFER_SIZE],
			 SaveCurDir[STANDARD_BUFFER_SIZE],
			 TempBuff[STANDARD_BUFFER_SIZE];
	DWORD DirNameLen;
	BOOL Valid=TRUE;

	strcpy(OutString, InString);
	
	OutstringAddr=OutString;

	// Check for ":" file type
	searchchar = strchr(OutString, ':');
	if(searchchar != NULL)
	{
		// Have a device type root dir
		// Check the next char of NULL
		searchchar++;
		if(*searchchar == (CHAR) NULL)
		{
			// add a "\" after the ":"
			*searchchar = 0x5c;
			searchchar++;
			// Terminate the string
			*searchchar = (CHAR) NULL;
			*DirectoryFlag = TRUE;
			return(TRUE);
		}
		// Have a : Check for "\"
		// Note this takes care of _:\ paths Can't Do Checking on redirected
		// drives with findfirstfile program will blow out later
		
		if(*searchchar == 0x5c)
		{
			//check for NULL
			searchchar++;
			if(*searchchar == (CHAR) NULL)
			{
				*DirectoryFlag = TRUE;
				return(TRUE);
			}
		}
		// Need to check for relative path stuff ".\.\.." etc
		if(IsRelativeString(InString))
		{
			strcpy(TempBuff, InString);
			// Save Current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, 
									 (LPTSTR) SaveCurDir);
			if(DirNameLen == 0)
				return(FALSE);
			// Find the end directory
			searchchar = strrchr(InString, 0x5c);       
			schar = strrchr(TempBuff, 0x5c);
			if(schar == NULL)
				return(FALSE);
			// Chech for . or ..
			schar++;
			if(*schar == '.')
			{
				schar++;
				if(*schar == '.')
				{
					schar++;
					*schar == (CHAR) NULL;
					searchchar+3;
				}
			}
			else
			{
				schar--;
				*schar == (CHAR) NULL;
			}
			// Have the path now get the real path
			if(!SetCurrentDirectory(TempBuff))
				return(FALSE);
			// Now Save the current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
			if(DirNameLen == 0)
				return(FALSE);
			*OutstringAddr = (CHAR) NULL;
			// Build The String with real path
			strcpy(OutString, CurDir);
			// Remove end "\" from "C:\" GetCurrentDir.. returns with "\" on root 
			RemoveEndSlash(OutString);
			strcat(OutString, searchchar);
			// return to the user's diretory
			if(!SetCurrentDirectory(SaveCurDir))
				 return(FALSE);
		
			}
			// Check for wild card
			if(IsWildCard(OutString))
			{
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			// Check for Direcory or file
			if(!IsDirectory(OutString, &Valid))
				*DirectoryFlag = FALSE;
			else
				*DirectoryFlag = TRUE;
			
			if(Valid == FALSE)
				return(FALSE);
			return(TRUE);
	}
	// Have a nondevice name
	
	// Check for "\\" in first 2 chars in file path for UNC path
	if(strncmp(InString, "\\\\", 2) == 0)
	{
		// Bump pointer 
		InString +=3;
		// Serarch for the next "\"
		searchchar = strchr(InString, 0x5c); 
		if(searchchar == NULL)
			return(FALSE);
		// Have the 3rd one check for fourth on in typical UNC string
		searchchar++;
		searchchar = strchr(searchchar, 0x5c);
		if(searchchar == NULL)
		{ // Have UNC Pth Only
			// Need to add "\" to end of string
			strcat(OutString, "\\");
			*DirectoryFlag = TRUE;
			return(TRUE);
		}
		else
		{
			// Have the fouth "\" need to check for file or directory
			// Check for wild card
			if(IsWildCard(OutString))
			{
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			// Check for Direcory or file
			if(!IsDirectory(OutString, &Valid))
				*DirectoryFlag = FALSE;
			else
				*DirectoryFlag = TRUE;
			if(Valid == FALSE)
				return(FALSE);
			 return(TRUE);
		 }
	} // End of "\\"
										 

	 // Check for a "\"
	if(*OutString == 0x5c)
	{ 
		// Have a leading "\" check next char
		OutString++;
		if(*OutString != (CHAR) NULL)
		{
			// Check for wild card
			if(IsWildCard(InString))
			{
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			// Check for directory
			if(!IsDirectory(InString, &Valid))
				*DirectoryFlag = FALSE;
			else
				*DirectoryFlag = TRUE;
			if(Valid == FALSE)
				return(FALSE);
			 return(TRUE);
		}
		// Have a single need to get full "_:\"
		DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
		if(DirNameLen == 0)
			return(FALSE);
		// Now feed the result in to StripRootDir
		// Set OutString to a NULL char to recive the string
		OutString--;
		*OutString = (CHAR) NULL;
		if(!StripRootDir( (LPTSTR) CurDir, OutString))
			return(FALSE);
		*DirectoryFlag = TRUE;
		return(TRUE);
	}  // End of "\"
	
	// Now check for .. ../
	if(strncmp(InString, "..", 2) == 0)
	{
		// Save Current directory
		DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) SaveCurDir);
		if(DirNameLen == 0)
			return(FALSE);
		// Chech the Input string for the last Slash
		searchchar = strrchr(InString, 0x5c);       
		if(searchchar == NULL)
		{  // Just have .. 
			// set current dir to where the path (InString) is
			if(!SetCurrentDirectory(InString))
			return(FALSE);
			// Now Save the current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
		 if(DirNameLen == 0)
				return(FALSE);
			strcpy(OutString, CurDir);
			*DirectoryFlag = TRUE;
			// return to the user's diretory
			if(!SetCurrentDirectory(SaveCurDir))
				 return(FALSE);
			return(TRUE);
		}
		else // Have smething after the ..
		{
			// Need to check for a ending ".."
			schar = strstr(searchchar, "..");
			if(schar != NULL)
			{
				// set current dir to where the path (InString) is
				if(!SetCurrentDirectory(InString))
					return(FALSE);
		
				// Now Save the current directory
				DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
				if(DirNameLen == 0)
					return(FALSE);
				// Save the path 
				strcpy(OutString, CurDir);
				*DirectoryFlag = TRUE;
				// return to the user's diretory
				if(!SetCurrentDirectory(SaveCurDir))
					 return(FALSE);
				return(TRUE);
			}
			// Save the last "\" Position
			schar = strrchr(OutString, 0x5c);

			// Terminate the string after the last slash 
			*schar = (CHAR) NULL;
			// set current dir to where the path (OutString) is
			if(!SetCurrentDirectory(OutString))
				return(FALSE);
			// Now Save the current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
			if(DirNameLen == 0)
				return(FALSE);
			// Save the path 
			strcpy(OutString, CurDir);
			// Copy anything after and including the "\" for the input string
			strcat(OutString, searchchar);
			// Check for wildcard
			if(IsWildCard(InString))
			{
				// Restore dir path
				if(!SetCurrentDirectory(SaveCurDir))
					return(FALSE);
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			
			// Check for Direcory or file
			if(!IsDirectory(OutString, &Valid))
				*DirectoryFlag = FALSE;
			else
				*DirectoryFlag = TRUE;
			
			// Restore dir path
			if(!SetCurrentDirectory(SaveCurDir))
				return(FALSE);
			
			if(Valid == FALSE)
				return(FALSE);
			
			return(TRUE);
		}
	}  // End of "..\"


	// "." and ".\"
	if(*InString == '.')
	{
		// Save Current directory
		DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) SaveCurDir);
		if(DirNameLen == 0)
			return(FALSE);
		// Chech the Input string for the last Slash
		searchchar = strrchr(InString, 0x5c);       
		if(searchchar == NULL)
		{  // Just have . or something after it ._ 
			// set current dir to where the path (InString) is
			if(!SetCurrentDirectory(InString))
			{
				strcpy(OutString, SaveCurDir);
				// Add "\" directory
				strcat(OutString, "\\");
				strcat(OutString, InString);
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			// Now Save the current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
		 if(DirNameLen == 0)
				return(FALSE);
			strcpy(OutString, CurDir);
			*DirectoryFlag = TRUE;
			// return to the user's diretory
			if(!SetCurrentDirectory(SaveCurDir))
				 return(FALSE);
			return(TRUE);
		}
		else // Have smething after the .
		{
			// Need to check for a ending ".."
			schar = strstr(searchchar, "..");
			if(schar != NULL)
			{
				// set current dir to where the path (InString) is
				if(!SetCurrentDirectory(InString))
					return(FALSE);
		
				// Now Save the current directory
				DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
				if(DirNameLen == 0)
					return(FALSE);
				// Save the path 
				strcpy(OutString, CurDir);
				*DirectoryFlag = TRUE;
				// return to the user's diretory
				if(!SetCurrentDirectory(SaveCurDir))
					 return(FALSE);
				return(TRUE);
			}
			// Save the last "\" Position
			schar = strrchr(OutString, 0x5c);

			// Terminate the string after the last slash 
			*schar = (CHAR) NULL;
			// set current dir to where the path (OutString) is
			if(!SetCurrentDirectory(OutString))
				return(FALSE);
			// Now Save the current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
			if(DirNameLen == 0)
				return(FALSE);
			// Save the path 
			strcpy(OutString, CurDir);
			// Copy anything after and including the "\" for the input string
			strcat(OutString, searchchar);
			// Check for wildcard
			if(IsWildCard(InString))
			{
				// Restore dir path
				if(!SetCurrentDirectory(SaveCurDir))
					return(FALSE);
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			
			// Check for Direcory or file
			if(!IsDirectory(OutString, &Valid))
				*DirectoryFlag = FALSE;
			else
				*DirectoryFlag = TRUE;
			
			// Restore dir path
			if(!SetCurrentDirectory(SaveCurDir))
				return(FALSE);
			
			if(Valid == FALSE)
				return(FALSE);
			
			return(TRUE);
		}
	}  // End of "." ".\"



	// Now only have a file name or directory local
	DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
	if(DirNameLen == 0)
		return(FALSE);
	strcpy(OutString, CurDir);
	// Check if last last char slash
	if(!IsLastCharSlash(OutString))
		strcat(OutString, "\\");
	strcat(OutString, InString);
	// Check for wild Card
	if(IsWildCard(InString))
	{  
		*DirectoryFlag = FALSE;
		return(TRUE);
	}
	// Check for Directory
	if(!IsDirectory(OutString, &Valid))
		*DirectoryFlag = FALSE;
	else
		*DirectoryFlag = TRUE;
	if(Valid == FALSE)
		return(FALSE);
	return(TRUE);

}

/* ********************************************************************
*********************************************************************** */
BOOL IsDirectory(IN LPTSTR InTestFile,
								 IN BOOL *FileValid)
{
	WIN32_FIND_DATA FindFileData;
	HANDLE FindFileHandle;
	char IsBuff[STANDARD_BUFFER_SIZE];

	strcpy(IsBuff, InTestFile);
	if(RemoveEndSlash((LPTSTR) IsBuff))
		FindFileHandle = FindFirstFile(IsBuff, &FindFileData);
	else
		FindFileHandle = FindFirstFile(InTestFile, &FindFileData);


	if(FindFileHandle == INVALID_HANDLE_VALUE)
	{
//    printf("\n problem with findfirstfile in IsDirectory");
		*FileValid = FALSE;
		return(FALSE);
	}
	if(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{  
		FindClose(FindFileHandle);		// changed by a-zexu @ 10/19/97
		return(TRUE);
	}
	FindClose(FindFileHandle);	// changed by a-zexu @ 10/19/97
	return(FALSE);


}


BOOL IsWildCard(LPSTR psz)
{
		char ch;

		while (ch = *psz++)
				{
				if (ch == '*' || ch == '?')
						return(TRUE);
				}
		return(FALSE);
}


BOOL RemoveEndSlash(LPSTR TestString)
{
	LPTSTR slashptr;
	
	slashptr = strrchr(TestString, 0x5c);
	if(slashptr == NULL)
		return(FALSE);
	// Check Next char for NULL
	slashptr++;
	if(*slashptr == (CHAR) NULL)
	{
		slashptr--;
		*slashptr = (CHAR) NULL;
		return(TRUE);
	}
	return(FALSE);
}


BOOL SetSlash(IN LPTSTR InString,
							IN OUT LPTSTR TestString)
{
	LPTSTR slashptr;
	strcpy(TestString, InString);  
	slashptr = strrchr(TestString, 0x5c);
	if(slashptr == NULL)
		return(FALSE);
	slashptr++;
	*slashptr = (CHAR) NULL;
	return(TRUE);
}


BOOL AddDotSlash(LPSTR TestString)
{
	LPTSTR slashptr;
	
	// Find End of String
	slashptr = strrchr(TestString, (CHAR) NULL);
	if(slashptr == NULL)
		return(FALSE);
	// Check previous char for "\"
	slashptr--;
	if(*slashptr == 0x5c)
	{
		slashptr++;
		*slashptr = '.';
		slashptr++;
		*slashptr = (CHAR) NULL;
	}
	else
	{
		slashptr++;
		*slashptr = 0x5c;
		slashptr++;
		*slashptr = '.';
		slashptr++;
		*slashptr = (CHAR) NULL;
	}
	return(TRUE);

}

BOOL AddWildCards(LPSTR TestString)
{
	LPTSTR slashptr;
	
	// Find End of String
	slashptr = strrchr(TestString, (CHAR) NULL);
	if(slashptr == NULL)
		return(FALSE);
	// Check previous char for "\"
	slashptr--;
	if(*slashptr == 0x5c)
	{
		slashptr++;
		*slashptr = '*';
		slashptr++;
		*slashptr = '.';
		slashptr++;
		*slashptr = '*';
		slashptr++;
		*slashptr = (CHAR) NULL;
	}
	else
	{
		slashptr++;
		*slashptr = 0x5c;
		slashptr++;
		*slashptr = '*';
		slashptr++;
		*slashptr = '.';
		slashptr++;
		*slashptr = '*';
		slashptr++;
		*slashptr = (CHAR) NULL;
	}
	return(TRUE);

}

BOOL IsLastCharSlash(LPSTR TestString)
{
	LPTSTR slashptr;
	
	// Find End of String
	slashptr = strrchr(TestString, (CHAR) NULL);
	if(slashptr == NULL)
		return(FALSE);
	// Check previous char for "\"
	slashptr--;
	if(*slashptr == 0x5c)
		return(TRUE);
	return(FALSE);
}


BOOL IsRelativeString(LPSTR TestString)
{
	LPTSTR slashptr;
	// Start looking for Relative strings order is important
	slashptr = strstr(TestString, "..\\");
	if(slashptr != NULL)
		return(TRUE);
	slashptr = strstr(TestString, ".\\");
	if(slashptr != NULL)
		return(TRUE);
	slashptr = strstr(TestString, "\\..");
	if(slashptr != NULL)
		return(TRUE);
	slashptr = strstr(TestString, "\\.");
	if(slashptr != NULL)
	{
		// Check Next Char for NULL or "\"
		slashptr++;
		if(*slashptr == (CHAR) NULL);
			return(TRUE);
		if(*slashptr == 0x5c);
			return(TRUE);
	}
	return(FALSE);

}


BOOL RemoveEndDot(LPSTR TestString)
{
	LPTSTR slashptr;
	
	// Find End of String
	slashptr = strrchr(TestString, (CHAR) NULL);
	if(slashptr == NULL)
		return(FALSE);
	// Check previous char for "."
	slashptr--;
	if(*slashptr == '.')
	{
		*slashptr = (CHAR) NULL;
	}
	return(TRUE);
}



/* *********************************************************************
	 ********************************************************************* */
BOOL StripRootDir(IN LPTSTR InDir,
		 OUT LPTSTR OutRootDir)
{
	LPTSTR searchchar;
	
	strcpy(OutRootDir, InDir);

	// Check for ":" file type
	searchchar = strchr(OutRootDir, ':');
	if(searchchar != NULL)
	{
		// Have a device type root dir
		searchchar++;
		// add a "\" after the ":"
		*searchchar = 0x5c;
		searchchar++;
		// Terminate the string
		*searchchar = (CHAR) NULL;
		return(TRUE);
	}
	else  // Have a nondevice name
	{
		// Check for "\\" in first 2 chars in file path for UNC path
	 if( strncmp(OutRootDir, "\\\\", 2) == 0)
	 {
		 // Bump pointer 
		 OutRootDir +=3;
		 // Serarch for the next "\"
		 searchchar = strchr(OutRootDir, 0x5c); 
		 if(searchchar == NULL)
			return(FALSE);
		 // Have the 3rd one check for fourth on in typical UNC string
		 searchchar++;
		 searchchar = strchr(searchchar, 0x5c);
		 if(searchchar == NULL)
		 { // Have UNC Pth Only
			 // Need to add "\" to end of string
			 OutRootDir += strlen(OutRootDir);
			 *OutRootDir = 0x5c;
			 ++OutRootDir;
			 *OutRootDir = (CHAR) NULL;
			 return(TRUE);
		 }
		 else
		 {
			 // Have the fouth "\"
			 ++searchchar;
			 // Add NULL
			 *searchchar = (CHAR) NULL;
			 return(TRUE);
		 }
	 }
	 else // Have a "\" or whatever
	 {
		 *OutRootDir = (CHAR) NULL;
		 return(TRUE);
	 }
	}
	// Should not get here
	return(FALSE);
}

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\terrain\tools\metasnap\metasnap.cpp ===
//***********************************************************
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  metasnap.cpp
//  
//  Description: Metabase Snapshot utility tool main  
//
//  History: 15-July-98  Tamas Nemeth (t-tamasn)  Created.
//
//***********************************************************

//#define NDEBUG
//#define WIN32
#define INITGUID

//#define _WINDOWSWIN32
//#define WIN32_WINNT     0x400

//#define _WIN32WIN_
//#define UNICODE
//#define MD_CHECKED

#define DEFAULT_MD_TIMEOUT 20000 // 20 seconds
#define DEFAULT_GETALL_BUFFER_SIZE  65536  // 64k
#include <wchar.h>

#include <afx.h>
#include <objbase.h>
#include <coguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <mbstring.h>

#include "convert.h"
#include "iadmw.h"
#include "iiscnfg.h"

struct _CMD_PARAMS
{
	LPWSTR pwstrMachineName;
	LPWSTR pwstrStartKey;
	BOOL bShowSecure; 
};

typedef struct _CMD_PARAMS CMD_PARAMS;
typedef CString* pCString;

// Global variables:

PBYTE     g_pbGetAllBuffer;
DWORD	  g_dwGetAllBufferSize;
DWORD*    g_dwSortArray;
pCString* g_pstrPropName;

// Function prototypes:

HRESULT PrintKeyRecursively(IMSAdminBase *  pcAdmCom, 
							WCHAR *         lpwstrFullPath,
							METADATA_HANDLE hmdHandle, 
							WCHAR *         lpwstrRelPath,
							BOOL            bShowSecure);

HRESULT PrintAllPropertiesAtKey(IMSAdminBase*   pcAdmCom, 
								METADATA_HANDLE hmdHandle, 
								BOOL            bShowSecure);

VOID PrintProperty(METADATA_GETALL_RECORD&  mdr, 
				   pCString                 pstrPropName, 
				   BOOL                     bShowSecure);

VOID PrintDataTypeAndValue(METADATA_GETALL_RECORD *  pmdgr, 
						   BOOL                      bShowSecure);

HRESULT ParseCommands(int          argc, 
					  char *       argv[],
					  CMD_PARAMS * pcpCommands);

VOID DisplayHelp();

// Comparison functions required by qsort:

int __cdecl PropNameCompare(const void *index1,
					const void *index2);

int __cdecl PropIDCompare(const void *index1,
				  const void *index2);




HRESULT __cdecl main(int argc, char *argv[])
/*++

Routine Description:

    Metabase Snapshot Tool main.

Arguments:
    
	  argc, argv[]     Standard command line input.

Return Value:

    HRESULT - ERROR_SUCCESS
			  E_OUTOFMEMORY
			  E_INVALIDARG
              Errors returned by COM Interface
			  Errors returned by MultiByteToWideChar converted to HRESULT
--*/
{
	if (argc == 1)
	{
		DisplayHelp();
		return ERROR_SUCCESS;
	}

	// Parse command line arguments:
	CMD_PARAMS cpCommands;
	HRESULT hresError = ParseCommands(argc, argv, &cpCommands);

	if (hresError != ERROR_SUCCESS)
	{
		if (hresError == E_OUTOFMEMORY)
			fprintf (stderr, "ERROR: Out of memory.");
		else if (hresError == E_INVALIDARG)
			fprintf (stderr, "ERROR: Invalid arguments.");
		else 
			fprintf (stderr,"ERROR: Couldn't process arguments. Error: %d (%#x)\n", hresError, hresError);

		fprintf(stderr, " Enter \"metasnap\" without arguments for help.\n");
		return hresError;
	}
	
	// Allocate memory:
	g_dwGetAllBufferSize = DEFAULT_GETALL_BUFFER_SIZE;
	g_pbGetAllBuffer = (PBYTE) HeapAlloc (GetProcessHeap(),
										  HEAP_ZERO_MEMORY,
										  DEFAULT_GETALL_BUFFER_SIZE);

	if (g_pbGetAllBuffer == NULL)
	{	
		fprintf(stderr, "ERROR: Out of memory.\n");
		return E_OUTOFMEMORY;
	}

	// Here come some COM function calls:

	IMSAdminBase *pcAdmCom = NULL;   //interface pointer
	IClassFactory * pcsfFactory = NULL;
	COSERVERINFO csiMachineName;
	COSERVERINFO *pcsiParam = NULL;

	// Fill the structure for CoGetClassObject:
		csiMachineName.pAuthInfo = NULL;
		csiMachineName.dwReserved1 = 0;
		csiMachineName.dwReserved2 = 0;
		pcsiParam = &csiMachineName;
		csiMachineName.pwszName = cpCommands.pwstrMachineName;

	// Initialize COM:
    hresError = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hresError))
	{
		fprintf (stderr, "ERROR: COM Initialization failed. Error: %d (%#x)\n", hresError, hresError);
        return hresError;
	}

	hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
							IID_IClassFactory, (void**) &pcsfFactory);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(REGDB_E_CLASSNOTREG): 
			fprintf(stderr, "ERROR: IIS Metabase does not exist.\n");
			break;
		case HRESULT_FROM_WIN32(E_ACCESSDENIED): 
			fprintf(stderr, "ERROR: Access to Metabase denied.\n");
			break;
		case HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE):  
			fprintf(stderr, "ERROR: The specified host is unavailable.\n");
			break;
 		default:
			fprintf (stderr, "ERROR: Couldn't get Metabase Object. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
        return hresError;
	}

	hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &pcAdmCom);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(RPC_S_SEC_PKG_ERROR):
			fprintf (stderr, "ERROR: A security-related error occurred.\n");
			break;
		case E_OUTOFMEMORY:
			fprintf (stderr, "ERROR: There is not enough memory available.\n");
			break;
		default:
			fprintf (stderr, "ERROR: Couldn't create Metabase Instance. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
		pcsfFactory->Release();
		return hresError;
	}

	pcsfFactory->Release();
	
	// Print header line:
	printf(" ID         NAME                            ATTRIB  USERTYPE    SIZE    DATATYPE    VALUE\n");

	// Recursively print metabase from StartKey:
	hresError = PrintKeyRecursively(pcAdmCom, 
									cpCommands.pwstrStartKey,
									METADATA_MASTER_ROOT_HANDLE, 
									cpCommands.pwstrStartKey, 
									cpCommands.bShowSecure);

	if (hresError != ERROR_SUCCESS)
		fprintf (stderr, "ERROR: Failed dumping metabase. Error: %u (%#x)\n", hresError, hresError);
	else
		fprintf (stderr, "Successfully dumped metabase.\n");

	pcAdmCom->Release();
	return hresError;

} // end main




HRESULT ParseCommands (int			argc, 
					   char *		argv[], 
					   CMD_PARAMS*	pcpCommands)
/*++

Routine Description:

    Parses the argument vector into a command parameters structure.

Arguments:

	argc          Number of arguments.
	
	argv[]        Argument vector.
	
	pcpCommands   Pointer to a command parameters struct.

Return Value:

    HRESULT - ERROR_SUCCESS
              E_INVALIDARG
			  E_OUTOFMEMORY
			  Errors returned by MultiByteToWideChar converted to HRESULT		
--*/
{
	if ( (argc < 2) || (argc > 4) )
		return E_INVALIDARG;

	// Allocate buffers:
	DWORD dwStartKeyLen = _mbstrlen(argv[1]);
	pcpCommands->pwstrStartKey = (LPWSTR) HeapAlloc(GetProcessHeap(), 
													 HEAP_ZERO_MEMORY,
													 (dwStartKeyLen + 1) 
													 * sizeof (WCHAR));

	pcpCommands->pwstrMachineName = (LPWSTR) HeapAlloc(GetProcessHeap(), 
											        HEAP_ZERO_MEMORY, 
													(METADATA_MAX_NAME_LEN + 1) 
													* sizeof (WCHAR) );

	if (pcpCommands->pwstrStartKey == NULL || pcpCommands->pwstrStartKey == NULL)
		return E_OUTOFMEMORY;

	// Take care of StartKey:
	
	DWORD dwResult = MultiByteToWideChar(
		CP_ACP,
		0,
		argv[1],
		dwStartKeyLen + 1,
		pcpCommands->pwstrStartKey,
		dwStartKeyLen + 1);

	if (dwResult == 0)
		return HRESULT_FROM_WIN32(GetLastError());

	// Chop off trailing slashes: 
	LPWSTR lpwchTemp = &(pcpCommands->pwstrStartKey[dwStartKeyLen-1]);	
	if (!wcscmp(lpwchTemp, (const unsigned short *)TEXT("/") ) ||
		!wcscmp(lpwchTemp, (const unsigned short *)TEXT("\\")) )
			*lpwchTemp = (WCHAR)'\0';

	// Initialize bShowSecure:
	pcpCommands->bShowSecure = FALSE;
	

	// Look for MachineName:
	if ( argc > 2 && strcmp("-s",argv[2])) // machine name is specified
	{
		DWORD dwMachineNameLen = _mbstrlen(argv[2]);

		dwResult = MultiByteToWideChar(
			CP_ACP,
			0,
			argv[2],
			dwMachineNameLen + 1,
			pcpCommands->pwstrMachineName,
			dwMachineNameLen + 1);

		if (dwResult == 0)
			return HRESULT_FROM_WIN32(GetLastError());

		// Check for "-s" flag:
		if (argc == 4)
			if ( !strcmp("-s",argv[3]) )
				pcpCommands->bShowSecure = TRUE;
			else
				return E_INVALIDARG;
	}
	else if (argc == 3 && !strcmp("-s",argv[2])) // no MachineName, but have -s
	{
		wcscpy(pcpCommands->pwstrMachineName,L"localhost"); //set default
		pcpCommands->bShowSecure = TRUE;
	}
	else if (argc > 2)
		return E_INVALIDARG;

	return ERROR_SUCCESS;

} // end ParseCommands


HRESULT PrintAllPropertiesAtKey(IMSAdminBase* pcAdmCom, 
								METADATA_HANDLE hmdHandle, 
								BOOL bShowSecure)
/*++

Routine Description:

    Prints all metabase properties under a give metabase key in alphabetical order of 
	their ADSI name. Properties with no corresponding ADSI name are ordered by their 
	identifier.

Arguments:

    pcAdmCom     Pointer to a metabase object.

	hmdHandle	 Handle to a metabase key.

    bShowSecure  Boolean flag specifying whether to display confidential data.

Return Value:

    HRESULT - ERROR_SUCCESS
			  E_OUTOFMEMORY
              Errors returned by Metabase Interface function calls

--*/
{
   // Get all data into a buffer:
	DWORD dwNumDataEntries;
	DWORD dwDataSetNumber;
	DWORD dwRequiredDataLen;

	HRESULT hresError = pcAdmCom -> GetAllData (
				hmdHandle,
				(const unsigned short *)TEXT ("/"),
				0,
				0,
				0,
				&dwNumDataEntries,
				&dwDataSetNumber,
				g_dwGetAllBufferSize,
				g_pbGetAllBuffer,
				&dwRequiredDataLen);


	if (hresError == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
	{
		// retry the GetAllData with the new buffer size
		g_dwGetAllBufferSize = dwRequiredDataLen;
		g_pbGetAllBuffer = (PBYTE)HeapReAlloc 
									(GetProcessHeap(),
									0,
									g_pbGetAllBuffer,
									g_dwGetAllBufferSize);

		if (!g_pbGetAllBuffer)
			return E_OUTOFMEMORY;

		hresError = pcAdmCom -> GetAllData(
				hmdHandle,
				(const unsigned short *)TEXT ("/"),
				0,
				0,
				0,
				&dwNumDataEntries,
				&dwDataSetNumber,
				g_dwGetAllBufferSize,
				g_pbGetAllBuffer,
				&dwRequiredDataLen);
	}

	if (hresError != ERROR_SUCCESS)
		return hresError;

	METADATA_GETALL_RECORD *pmdgr = NULL;
	
	// Dynamically allocate arrays:
	g_dwSortArray = new DWORD[dwNumDataEntries];
	g_pstrPropName = new pCString[dwNumDataEntries];
	
	DWORD dwIndex = 0;
	
	if (g_dwSortArray == NULL || g_pstrPropName == NULL)
	{	
		hresError = E_OUTOFMEMORY;
		goto exitPoint;
	}

	for (dwIndex = 0; dwIndex < dwNumDataEntries; dwIndex ++)
	{   
		g_pstrPropName[dwIndex] = new CString;
		if (g_pstrPropName[dwIndex] == NULL)
		{
			hresError = E_OUTOFMEMORY;
			goto exitPoint;
		}
	}

	// Initialize arrays:
	for (dwIndex = 0; dwIndex < dwNumDataEntries; dwIndex ++)
	{
		pmdgr = &(((METADATA_GETALL_RECORD *) g_pbGetAllBuffer)[dwIndex]);
		(*g_pstrPropName[dwIndex]) = tPropertyNameTable::MapCodeToName(pmdgr->dwMDIdentifier);
		g_dwSortArray[dwIndex] = dwIndex;
	}

	 // Sort entries using Quicksort algorithm: 
	if (dwNumDataEntries > 1)
	{
		qsort( (void *)g_dwSortArray, 
			    dwNumDataEntries, 
				sizeof(DWORD), 
				PropNameCompare );

		// locate index of first non-empty entry:
		for (dwIndex = 0; dwIndex <dwNumDataEntries && 
				!g_pstrPropName[g_dwSortArray[dwIndex]]->Compare(_T("")); dwIndex ++)
		{}

		qsort( (void *)g_dwSortArray, dwIndex, sizeof(DWORD), PropIDCompare );
	}

	// print all properties in order:
	for (dwIndex = 0; dwIndex < dwNumDataEntries; dwIndex ++)
	{
		pmdgr = &(((METADATA_GETALL_RECORD *) g_pbGetAllBuffer)[g_dwSortArray[dwIndex]]);

		// Convert the data pointer from offset to absolute
		pmdgr->pbMDData = pmdgr->dwMDDataOffset + g_pbGetAllBuffer;
		PrintProperty(*pmdgr, g_pstrPropName[g_dwSortArray[dwIndex]], bShowSecure);
	}

exitPoint:
	for (DWORD dwCount = 0; dwCount < dwIndex; dwCount ++)
		delete g_pstrPropName[dwCount];

	delete g_dwSortArray;
	delete g_pstrPropName;

	return hresError;
} // end PrintAllPropertiesAtKey



HRESULT PrintKeyRecursively(IMSAdminBase *pcAdmCom, 
							WCHAR *lpwstrFullPath,
							METADATA_HANDLE hmdHandle, 
							WCHAR *lpwstrRelPath,
							BOOL bShowSecure)
/*++

Routine Description:

    Performs a depth-first traversal of the metabase. Nodes at the same level are visited 
	in alphabetical order. At each key prints the full key name and its contents in
	alphabetical order.

Arguments:

    pcAdmCom        Pointer to a metabase object.

	lpwstrFullPath  Pointer to full key name.	
	
	hmdHandle		Handle to metabase key from last level.

	lpwstrRelPath   Pointer to path to the key relative to hmdHandle.
	
    bShowSecure     Boolean flag specifying whether to display confidential data.

Return Value:

    HRESULT - ERROR_SUCCESS
			  E_OUTOFMEMORY
              Errors returned by Metabase Interface function calls
--*/
{
	// Print [full key name]:
	printf("[%S]\n",lpwstrFullPath);

	METADATA_HANDLE hmdNewHandle;

	HRESULT hresError = pcAdmCom->OpenKey(
								hmdHandle,
								lpwstrRelPath,
								METADATA_PERMISSION_READ,
								DEFAULT_MD_TIMEOUT,
								&hmdNewHandle);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(ERROR_PATH_BUSY):
			fprintf (stderr, "ERROR: The specified key is already in use.\n"); 
			break;
		case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
			fprintf (stderr, "ERROR: The specified key is not found.\n");
			break;
		default:
			fprintf (stderr, "ERROR: Couldn't open Metabase Key. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
		return hresError; 
	}

	hresError = PrintAllPropertiesAtKey(pcAdmCom, 
										hmdNewHandle, 
										bShowSecure);

	if (hresError != ERROR_SUCCESS)
	{
		fprintf (stderr, "ERROR: Could not print [%S]. Error: %#x\n", lpwstrFullPath, hresError);
		pcAdmCom->CloseKey(hmdNewHandle);
		return hresError;
	}

	WCHAR *lpwstrTempPath = (WCHAR*) HeapAlloc 
									(GetProcessHeap(),
									HEAP_ZERO_MEMORY,
									METADATA_MAX_NAME_LEN * sizeof (WCHAR));

	if (lpwstrTempPath == NULL)
	{
		pcAdmCom->CloseKey(hmdNewHandle);
		return E_OUTOFMEMORY;
	}

	// Find out number of the children:
	DWORD dwChildCount = 0;
	while (1)
	{
		hresError = pcAdmCom->EnumKeys (
								hmdNewHandle,
								(const unsigned short *)TEXT("/"),
								lpwstrTempPath,
								dwChildCount);

		if (hresError != ERROR_SUCCESS)
			break;
		dwChildCount++;
	}

	if (dwChildCount == 0) // we are done
	{
		pcAdmCom->CloseKey(hmdNewHandle);
		return ERROR_SUCCESS;
	}

	// Dynamically allocate arrays:
	LPWSTR * lpwstrChildPath = new LPWSTR[dwChildCount];
	DWORD * dwSortedIndex = new DWORD[dwChildCount];

	DWORD dwIndex = 0;
	
	if (lpwstrChildPath == NULL || dwSortedIndex == NULL)
	{	
		hresError = E_OUTOFMEMORY;
		goto exitPoint;
	}

	for (dwIndex = 0; dwIndex < dwChildCount; dwIndex ++)
	{   
		lpwstrChildPath[dwIndex] = (WCHAR*) HeapAlloc(GetProcessHeap(),
													  HEAP_ZERO_MEMORY,
													  (METADATA_MAX_NAME_LEN + 1) 
													  * sizeof (WCHAR));
		if (lpwstrChildPath[dwIndex] == NULL)
		{
			hresError = E_OUTOFMEMORY;
			goto exitPoint;
		}
	}

	// Initialization:
	for (dwIndex = 0; dwIndex < dwChildCount; dwIndex++)
	{
		dwSortedIndex[dwIndex] = dwIndex;

		hresError = pcAdmCom->EnumKeys (
								hmdNewHandle,
								(const unsigned short *)TEXT("/"),
								lpwstrChildPath[dwIndex],
								dwIndex);
	}

	if (hresError == ERROR_SUCCESS)
	{
		// Sort children lexicographically (here we assume that dwChildCount is small)
		if (dwChildCount > 1 )
		{
			 DWORD dwTemp;
			 for (DWORD i = 1; i < dwChildCount; i++)
				for (DWORD j=0; j < dwChildCount-i; j++)
				{
					if (wcscmp(lpwstrChildPath[dwSortedIndex[j]],lpwstrChildPath[dwSortedIndex[j+1]]) > 0)
					{
						dwTemp = dwSortedIndex[j+1];
						dwSortedIndex[j+1] = dwSortedIndex[j];
						dwSortedIndex[j] = dwTemp;
					}
				}
		}

		for (dwIndex = 0; dwIndex < dwChildCount; dwIndex++)
		{
			// create the full path name for the child:
			wsprintf((LPTSTR)lpwstrTempPath,TEXT("%s/%s"),
										lpwstrFullPath,
										lpwstrChildPath[dwSortedIndex[dwIndex]]);

			hresError = PrintKeyRecursively(
				pcAdmCom, 
				lpwstrTempPath, 
				hmdNewHandle, 
				lpwstrChildPath[dwSortedIndex[dwIndex]],
				bShowSecure);

			if (hresError != ERROR_SUCCESS)
				break;
		}
	}

exitPoint:

	// Close open keys, free memory and exit
	for (DWORD dwCount = 0; dwCount < dwIndex; dwCount ++)
		HeapFree (GetProcessHeap(), 0, lpwstrChildPath[dwCount]);

	pcAdmCom->CloseKey(hmdNewHandle);
	delete lpwstrChildPath;
	delete dwSortedIndex;
	HeapFree (GetProcessHeap(), 0, lpwstrTempPath);

	return hresError;
}



VOID PrintProperty(METADATA_GETALL_RECORD & mdr, 
				   pCString pstrPropName, 
				   BOOL bShowSecure)
/*++

Routine Description:

    Prints a metabase property in a human readable format. Secure 
	data is replaced by stars if bShowSecure is false.

Arguments:

    mdr          A metadata getall record struct (passed in by reference).
	
	pstrPropName Pointer to the ADSI name corresponding to the metadata 
				 identifier (comes from the table in convert.cpp)
    
	bShowSecure  Boolean flag specifying whether to display confidential data.

Return Value:
				None.
--*/
{
    // Print identifier and name of property:
	printf(" %-10ld %-35S", mdr.dwMDIdentifier, LPCTSTR(*pstrPropName));

    // Print attribute flags:

    CString strFlagsToPrint=(L"");

    if (mdr.dwMDAttributes & METADATA_INHERIT)
        strFlagsToPrint+=(L"I");
    if (mdr.dwMDAttributes & METADATA_INSERT_PATH)
        strFlagsToPrint+=(L"P");    
    if(mdr.dwMDAttributes & METADATA_ISINHERITED)
        strFlagsToPrint+=(L"i");     
    if(!mdr.dwMDAttributes )  //METADATA_NO_ATTRIBUTES
        strFlagsToPrint+=(L"N");
    if(mdr.dwMDAttributes & METADATA_PARTIAL_PATH)
        strFlagsToPrint+=(L"p");
    if (mdr.dwMDAttributes & METADATA_REFERENCE)
        strFlagsToPrint+=(L"R");
    if (mdr.dwMDAttributes & METADATA_SECURE)
        strFlagsToPrint+=(L"S");
    if (mdr.dwMDAttributes & METADATA_VOLATILE)
        strFlagsToPrint+=(L"V");
    
    printf( " %-6S",LPCTSTR(strFlagsToPrint));

    // Print user type:

    CString strUserType=(L"");
    
	switch (mdr.dwMDUserType)
	{
	case IIS_MD_UT_SERVER:
        strUserType=(L"SER");
		break;
    case IIS_MD_UT_FILE:
        strUserType=(L"FIL");
		break;
    case IIS_MD_UT_WAM:
        strUserType=(L"WAM");
		break;
    case ASP_MD_UT_APP:
        strUserType=(L"ASP");
		break;
	default:
		break;
	}

	if (strUserType == (L""))
		printf(" %-10ld",mdr.dwMDUserType);
	else
		printf( "%-10S",LPCTSTR(strUserType));

    // Print data size:
	printf(" %-10ld",mdr.dwMDDataLen);
	
    // Print data type and value:
	PrintDataTypeAndValue (&mdr, bShowSecure);
	
}


VOID PrintDataTypeAndValue (METADATA_GETALL_RECORD *pmdgr, 
							BOOL bShowSecure)
/*++

Routine Description:

    Prints the data type and data value fields of a metabase property in a human 
	readable format. Secure data is replaced by stars if bShowSecure is false.

Arguments:

    pmdgr        Pointer to a metadata getall record struct.

    bShowSecure  Boolean flag specifying whether to display confidential data.

Return Value:
				None.
--*/
{
    BOOL bSecure =(pmdgr->dwMDAttributes & METADATA_SECURE);

	DWORD i;
    switch (pmdgr->dwMDDataType) 
	{
		case DWORD_METADATA:
			printf("DWO  ");
			if (!bShowSecure && bSecure)
				printf( "********");
			else
			{
	            printf( "0x%x", *(DWORD *)(pmdgr->pbMDData));
	      
				// try to convert to readable info        
				CString strNiceContent;
	            strNiceContent=tValueTable::MapValueContentToString(
															*(DWORD *)(pmdgr->pbMDData), 
															pmdgr->dwMDIdentifier);           
				if(!strNiceContent.IsEmpty())
	               printf( "={%S}",LPCTSTR(strNiceContent));
	            else        //at least decimal value can be useful
	                printf( "={%ld}",*(DWORD *)(pmdgr->pbMDData));
	        }
	        break;

		case BINARY_METADATA:
			printf("BIN  0x");
			if (!bShowSecure && bSecure)
				printf("** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ");
			else
				for (i=0; i<pmdgr->dwMDDataLen; i++) 
					printf( "%02x ", ((PBYTE)(pmdgr->pbMDData))[i]);
			break;

	    case STRING_METADATA:
	    case EXPANDSZ_METADATA:
			if(pmdgr->dwMDDataType == STRING_METADATA)
					printf( "STR  ");
			else
					printf( "ESZ  ");
			
			if (!bShowSecure && bSecure)
				printf("\"********************\"" );  
			else
				printf("\"%S\"",pmdgr->pbMDData);
			break;

		case MULTISZ_METADATA:
	        printf( ("MSZ  ")); 
			if (!bShowSecure && bSecure)
	           printf(  ("\"********************\"" ));
			else
			{
				WCHAR * lpwstrPtr = (WCHAR*)pmdgr->pbMDData;
				while (*lpwstrPtr != 0)
				{
					printf("\"%S\" ",lpwstrPtr);
					lpwstrPtr += (wcslen(lpwstrPtr) + 1);
				}
			}
			break;
		
		default:
			printf( ("UNK  "));
			break;
	}	
	printf("\n");
}


VOID DisplayHelp()
/*++

Routine Description:

    Displays usage information and provides examples.

Arguments:
				None.

Return Value:
				None.

--*/
{
	fprintf (stderr, "\n DESCRIPTION: Takes a snapshot of the metabase.\n\n");
	fprintf (stderr, " FORMAT: metasnap <StartKey> <MachineName> [-s]\n\n");
	fprintf (stderr, "    <StartKey>   : metabase key to start at.\n");
	fprintf (stderr, "    <MachineName>: name of host (optional, default: localhost).\n");
	fprintf (stderr, "    [-s]         : show secure data (ACLs, passwords) flag.\n\n");
	fprintf (stderr, " EXAMPLES: metasnap  /lm/w3svc/1  t-tamasn2  -s\n");
	fprintf (stderr, "           metasnap  \"/LM/Logging/ODBC Logging\"\n");
	fprintf (stderr, "           metasnap  /  >  dump.txt  (dumps everything to text)\n");
}


// Comparison functions required by qsort:

int __cdecl PropIDCompare(const void *index1, const void *index2)
/*++

Routine Description:

    Compares the identifiers of two metabase properties. This function
	is used exclusively by qsort (from stdlib).

Arguments:

	index1, index2  Pointers to entries in g_dwSortArray. g_dwSortArray specifies the 
					ordering of the metabase records after sorting.

Return Value:

	1  if the identifier of the metabase property specified by index1 is greater 
	   than the identifier of the one corresponding to index2
	0  if they are equal
   -1  otherwise

--*/
{
	METADATA_GETALL_RECORD *pmdr1, *pmdr2;
	pmdr1 = &(((METADATA_GETALL_RECORD *) g_pbGetAllBuffer)[ *(DWORD*)index1]);
	pmdr2 = &(((METADATA_GETALL_RECORD *) g_pbGetAllBuffer)[ *(DWORD*)index2]);
	if (pmdr1->dwMDIdentifier > pmdr2->dwMDIdentifier)
		return 1;
	else if (pmdr1->dwMDIdentifier < pmdr2->dwMDIdentifier)
		return (-1);
	return 0;
}

int __cdecl PropNameCompare(const void *index1, const void *index2)
/*++

Routine Description:

    Compares two CStrings. This function is used exclusively by qsort (from stdlib).

Arguments:

	index1, index2  Pointers to entries in g_dwSortArray. g_dwSortArray specifies the 
					ordering of the metabase records after sorting.

Return Value:

	1  if the ADSI name of the metabase property specified by index1 precedes 
	   alphabetically the ADSI name of the one corresponding to index2
	0  if they are the same
   -1  otherwise

--*/
{
   return g_pstrPropName[ *(DWORD*)index1]->Compare(*g_pstrPropName[*(DWORD*)index2]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\cfactory.h ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CFactory
Purpose:    Define CFactory class
Remarks:
Owner:      i-shdong@microsoft.com
Platform:   Win32
Revise:     First created by: i-shdong    11/17/1999
============================================================================*/

#ifndef __CFactory_h__
#define __CFactory_h__

// Forward reference
class CFactoryData ;

// Global data used by CFactory
extern CFactoryData g_FactoryDataArray[] ;
extern int g_cFactoryDataEntries ;

//  Component creation function
class CUnknown ;

typedef HRESULT (*FPCREATEINSTANCE)(IUnknown*, CUnknown**) ;

// CFactoryData
//   - Information CFactory needs to create a component
//     supported by the DLL
class CFactoryData
{
public:
        // The class ID for the component
        const CLSID* m_pCLSID ;

        // Pointer to the function that creates it
        FPCREATEINSTANCE CreateInstance ;

        // Name of the component to register in the registry
        //const char* m_RegistryName ;
        LPCTSTR m_RegistryName ;

        // ProgID
        //const char* m_szProgID ;
        LPCTSTR m_szProgID ;

        // Version-independent ProgID
        //const char* m_szVerIndProgID ;
        LPCTSTR m_szVerIndProgID ;

        // Helper function for finding the class ID
        BOOL IsClassID(const CLSID& clsid) const
                { return (*m_pCLSID == clsid) ;}

} ;


// Class Factory
class CFactory : public IClassFactory
{
public:
        // IUnknown
        virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;
        virtual ULONG   __stdcall AddRef() ;
        virtual ULONG   __stdcall Release() ;

        // IClassFactory
        virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
                                                 const IID& iid,
                                                 void** ppv) ;
        virtual HRESULT __stdcall LockServer(BOOL bLock) ;

        // Constructor - Pass pointer to data of component to create.
        CFactory(const CFactoryData* pFactoryData) ;

        // Destructor
        ~CFactory() { } ;

        //
        // Static FactoryData support functions
        //

        // DllGetClassObject support
        static HRESULT GetClassObject(const CLSID& clsid,
                                      const IID& iid,
                                      void** ppv) ;

        // Helper function for DllCanUnloadNow
        static BOOL IsLocked()
                { return (s_cServerLocks > 0) ;}

        // Functions to [un]register all components
        static HRESULT RegisterAll() ;
        static HRESULT UnregisterAll() ;

        // Function to determine if component can be unloaded
        static HRESULT CanUnloadNow() ;

public:
        // Reference Count
        LONG m_cRef ;

        // Pointer to information about class this factory creates
        const CFactoryData* m_pFactoryData ;

        // Count of locks
        static LONG s_cServerLocks ;

        // Module handle
        static HINSTANCE s_hModule ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\terrain\tools\perms\perms.h ===
//
// System include files.
//

#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// #include <lmcons.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <string.h>
#include <stdio.h>

#include <windef.h> 
#include <winbase.h>
#include <winnetwk.h>
#include <crt\ctype.h>
// #include "seopaque.h"
#include <lmaccess.h>



#define USAGE_ARG     0
#define INVALID_ACC   1
#define INVALID_ARG   2
#define INVALID_PTH   3
#define INVALID_SWT   4
#define INVALID_FIL   5
#define HELP          6
#define MAXARGS       4
#define LSA_WIN_STANDARD_BUFFER_SIZE     0x000000200L 
#define STANDARD_BUFFER_SIZE             512 


char *MESSAGES[] = 
{
	"PERMS [domain\\|computer\\]user path [/i] [/s] [/?]\n",

	"User on domain or computer can't be located or accessed.",

	"Invalid argument: \n",

	"Path to file is not valid.",

	"Invalid switch.",

	"File name can't be located: ",

	"Displays a user's permissions to specified files and directories.\n\n"
	"PERMS   [domain\\|computer\\]username   path  [/i]  [/s]  [/?] \n\n"
	" [domain\\|computer\\]username\n"
	"               Name of user whose permissions are to be checked. If \n"
	"               no domain is given, defaults to local computer.\n\n"
	" path          A file or directory, wildcards (*,?) are accepted.\n\n" 
	" /i            Assumes the specified user is logged on interactively\n"
	"               to computer where the file/directory resides.\n"  
	"               With this switch, PERMS assumes the user is a member\n"
	"               of the INTERACTIVE group. Without this switch, PERMS\n"
	"               assumes the user is a member of the NETWORK group.\n\n"
	" /s            Check permissions on files in subdirectories.\n\n"
	"The following letters indicate granted access types:\n\n"
	"      R Read \n"
	"      W Write \n"
	"      X Execute \n"
	"      D Delete \n"
	"      P Change Permissions \n"
	"      O Take Ownership \n\n"
	"      A General All \n"
	"      - No Access \n\n"
	"* The specified user is the owner of the file or directory.\n"
	"# A group the user is a member of owns the file or directory.\n\n"
	"? The user's access permisssions can not be determined or the information\n"
	"  may not exist (if the file system is FAT).\n"
};




static SID_IDENTIFIER_AUTHORITY    SepNullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepLocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepCreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepNtAuthority = SECURITY_NT_AUTHORITY;


																									

//                                
// Universal well known SIDs      
//                                
																	
PSID  SeNullSid;                  
PSID  SeWorldSid;                 
PSID  SeLocalSid;                 
PSID  SeCreatorOwnerSid;          
PSID  SeCreatorGroupSid;          
																	
//                                
// Sids defined by NT             
//                                
																	
PSID SeNtAuthoritySid;            
																	
PSID SeDialupSid;                 
PSID SeNetworkSid;                
PSID SeBatchSid;                  
PSID SeInteractiveSid;            
PSID SeServiceSid;                
PSID SeLocalSystemSid;            
PSID SeAliasAdminsSid;            
PSID SeAliasUsersSid;             
PSID SeAliasGuestsSid;            
PSID SeAliasPowerUsersSid;        
PSID SeAliasAccountOpsSid;        
PSID SeAliasSystemOpsSid;         
PSID SeAliasPrintOpsSid;          
PSID SeAliasBackupOpsSid;         
																	

																									 
//                                                 
// System default DACL                             
//                                                 
																									 
PACL SeSystemDefaultDacl;                          
																									 

PACL SePublicDefaultDacl;   



#define TstAllocatePool(IgnoredPoolType,NumberOfBytes)    \
		RtlAllocateHeap(RtlProcessHeap(), 0, NumberOfBytes)

#define TstDeallocatePool(Pointer) \
		RtlFreeHeap(RtlProcessHeap(), 0, Pointer)


OBJECT_ATTRIBUTES ObjectAttributes;
SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

//
// Globally Visible Table of Sids.
//

PSID AccountDomainSid = NULL;
PSID PrimaryDomainSid = NULL;
PSID *TrustedDomainSids = NULL;

BOOL
VariableInitialization();

BOOL
LookupSidsInSamDomain(
		IN OPTIONAL PUNICODE_STRING WorkstationName,
		IN PUNICODE_STRING DomainControllerName,
		IN PUNICODE_STRING SamDomainName
		);

BOOL
GeneralBuildSid(
		PSID *Sid,
		PSID DomainSid,
		ULONG RelativeId
		);

VOID
InitObjectAttributes(
		IN POBJECT_ATTRIBUTES ObjectAttributes,
		IN PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
		);

VOID usage(INT message_num, PCHAR string_val);
BOOL LookupAllUserSidsWS(LPSTR lpSystemName);
VOID DisplayPerms(IN LPTSTR filename,
									IN BOOL valid_access);
BOOL GetFilePermissions(
			 PSECURITY_DESCRIPTOR SecurityDescriptor,
			 PSID UserAccountSids);
BOOL IsDomainName(
			 LPSTR TestDomainName,
			 LPSTR DomainNameBuff);
BOOL ProcessAcl(
			 PACL Acl
			 );

BOOL SetBackOperatorPriv(HANDLE TokenHandle);
BOOL GetTokenHandle(PHANDLE TokenHandle);
BOOL GetFileSecurityBackup(
			LPSTR lpFileName,
			SECURITY_INFORMATION RequestedInformation,
			PSECURITY_DESCRIPTOR pSecurityDescriptor,
			DWORD nLength,
			LPDWORD lpnLengthNeeded,
			BOOL BackUpPrivFlag
			);

BOOL GetFileSecurityBackupW(
			LPWSTR lpFileName,
			SECURITY_INFORMATION RequestedInformation,
			PSECURITY_DESCRIPTOR pSecurityDescriptor,
			DWORD nLength,
			LPDWORD lpnLengthNeeded,
			BOOL UseBackUp
			);
VOID QuerySecAccessMask(
			IN SECURITY_INFORMATION SecurityInformation,
			OUT LPDWORD DesiredAccess
			);



BOOL CleanUpSource(IN LPTSTR InSting,
		 OUT LPTSTR OutString,
		 OUT BOOL *DirectoryFlag);

BOOL IsDirectory(IN LPTSTR InTestFile,
								 IN BOOL *ValidFile);

BOOL IsWildCard(IN LPSTR psz);

BOOL SetSlash(IN LPTSTR InString,
							IN OUT LPTSTR TestString);

BOOL RemoveEndSlash(LPSTR psz);

BOOL AddDotSlash(LPSTR TestString);

BOOL AddWildCards(LPSTR TestString);

BOOL IsLastCharSlash(LPSTR TestString);

BOOL StripRootDir(IN LPTSTR InDir,
		 OUT LPTSTR OutRootDir);

BOOL RemoveEndDot(LPSTR TestString);

BOOL IsRelativeString(LPSTR TestString);

//
// Macros for calculating the address of the components of a security
// descriptor.  This will calculate the address of the field regardless
// of whether the security descriptor is absolute or self-relative form.
// A null value indicates the specified field is not present in the
// security descriptor.
//

#define SepOwnerAddrSecurityDescriptor( SD )                                   \
					 ( ((SD)->Owner == NULL) ? (PSID)NULL :                             \
							 (   ((SD)->Control & SE_SELF_RELATIVE) ?                        \
											 (PSID)RtlOffsetToPointer((SD), (SD)->Owner)  :          \
											 (PSID)((SD)->Owner)                                     \
							 )                                                               \
					 )

#define SepGroupAddrSecurityDescriptor( SD )                                   \
					 ( ((SD)->Group == NULL) ? (PSID)NULL :                              \
							 (   ((SD)->Control & SE_SELF_RELATIVE) ?                        \
											 (PSID)RtlOffsetToPointer((SD), (SD)->Group)  :          \
											 (PSID)((SD)->Group)                                     \
							 )                                                               \
					 )

#define SepSaclAddrSecurityDescriptor( SD )                                    \
					 ( (!((SD)->Control & SE_SACL_PRESENT) || ((SD)->Sacl == NULL) ) ?   \
						 (PACL)NULL :                                                      \
							 (   ((SD)->Control & SE_SELF_RELATIVE) ?                        \
											 (PACL)RtlOffsetToPointer((SD), (SD)->Sacl)  :           \
											 (PACL)((SD)->Sacl)                                      \
							 )                                                               \
					 )

#define SepDaclAddrSecurityDescriptor( SD )                                    \
					 ( (!((SD)->Control & SE_DACL_PRESENT) || ((SD)->Dacl == NULL) ) ?   \
						 (PACL)NULL :                                                      \
							 (   ((SD)->Control & SE_SELF_RELATIVE) ?                        \
											 (PACL)RtlOffsetToPointer((SD), (SD)->Dacl)  :           \
											 (PACL)((SD)->Dacl)                                      \
							 )                                                               \
					 )


BOOL RecurseSubs(IN LPTSTR FileName,
						IN LPTSTR FilePath,
						IN PSID UserSid,
						IN BOOL BackPriv,
						IN BOOL Recurse);

VOID syserror(IN DWORD error_val);

#define LARGEPSID 2048
#define FILE_GEN_ALL 0x001f01ff
#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\cfactory.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CFactory
Purpose:   Base class for reusing a single class factory for
           all components in a DLL
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include "Registry.h"
#include "CUnknown.h"
#include "CFactory.h"


// Static variables
LONG CFactory::s_cServerLocks = 0 ;    // Count of locks

HMODULE CFactory::s_hModule = NULL ;   // DLL module handle

// CFactory implementation

// Constructor
CFactory::CFactory(const CFactoryData* pFactoryData)
: m_cRef(1)
{
    m_pFactoryData = pFactoryData ;
}

// IUnknown implementation

HRESULT __stdcall CFactory::QueryInterface(REFIID iid, void** ppv)
{
    IUnknown* pI ;
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory)) {
        pI = this ;
    } else {
       *ppv = NULL;
        return E_NOINTERFACE;
    }
    pI->AddRef() ;
    *ppv = pI ;
    return S_OK;
}

ULONG __stdcall CFactory::AddRef()
{
    return ::InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall CFactory::Release()
{
    if (::InterlockedDecrement(&m_cRef) == 0) {
        delete this;
        return 0 ;
    }
    return m_cRef;
}


// IClassFactory implementation

HRESULT __stdcall CFactory::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{

    // No Aggregate
    if (pUnknownOuter != NULL) {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create the component.
    CUnknown* pNewComponent ;
    HRESULT hr = m_pFactoryData->CreateInstance(pUnknownOuter,
                                                &pNewComponent) ;
    if (FAILED(hr)) {
        return hr ;
    }

    // Initialize the component.
    hr = pNewComponent->Init();
    if (FAILED(hr)) {
        // Initialization failed.  Release the component.
        pNewComponent->NondelegatingRelease() ;
        return hr ;
    }

    // Get the requested interface.
    hr = pNewComponent->NondelegatingQueryInterface(iid, ppv) ;

    // Release the reference held by the class factory.
    pNewComponent->NondelegatingRelease() ;
    return hr ;
}

// LockServer
HRESULT __stdcall CFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        ::InterlockedIncrement(&s_cServerLocks) ;
    } else {
        ::InterlockedDecrement(&s_cServerLocks) ;
    }

    return S_OK ;
}


// GetClassObject
//   - Create a class factory based on a CLSID.
HRESULT CFactory::GetClassObject(const CLSID& clsid,
                                 const IID& iid,
                                 void** ppv)
{
    if ((iid != IID_IUnknown) && (iid != IID_IClassFactory)) {
        return E_NOINTERFACE ;
    }

    // Traverse the array of data looking for this class ID.
    for (int i = 0; i < g_cFactoryDataEntries; i++) {
        const CFactoryData* pData = &g_FactoryDataArray[i] ;
        if (pData->IsClassID(clsid)) {

            // Found the ClassID in the array of components we can
            // create. So create a class factory for this component.
            // Pass the CFactoryData structure to the class factory
            // so that it knows what kind of components to create.
            *ppv = (IUnknown*) new CFactory(pData) ;
            if (*ppv == NULL) {
                return E_OUTOFMEMORY ;
            }
            return S_OK ;
        }
    }
    return CLASS_E_CLASSNOTAVAILABLE ;
}


// Determine if the component can be unloaded.
HRESULT CFactory::CanUnloadNow()
{
    if (CUnknown::ActiveComponents() || IsLocked()) {
        return S_FALSE ;
    } else {
        return S_OK ;
    }
}


// Register all components.
HRESULT CFactory::RegisterAll()
{
    for (int i = 0 ; i < g_cFactoryDataEntries ; i++) {
        RegisterServer(s_hModule,
                       *(g_FactoryDataArray[i].m_pCLSID),
                       g_FactoryDataArray[i].m_RegistryName,
                       g_FactoryDataArray[i].m_szVerIndProgID,
                       g_FactoryDataArray[i].m_szProgID) ;
    }
    return S_OK ;
}

HRESULT CFactory::UnregisterAll()
{
    for (int i = 0 ; i < g_cFactoryDataEntries ; i++) {
        UnregisterServer(*(g_FactoryDataArray[i].m_pCLSID),
                         g_FactoryDataArray[i].m_szVerIndProgID,
                         g_FactoryDataArray[i].m_szProgID) ;
    }
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\errordef.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Error ID

Purpose:   Define critique error ID for proof engine
Notes:     This header is included by ProofEng.h and WordLink.h
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz	2/24/98
============================================================================*/
#ifndef _ERRORDEF_H_
#define _ERRORDEF_H_

#define ERRDef_NIL			0	// No error
#define ERRDef_CEW			1	// Common error word
#define ERRDef_FEI			2	// Single char which can not used as word
#define ERRDef_TAI			3	// Disused measure unit
#define ERRDef_LMCHECK		4	// Can not pass the SLM checking
#define ERRDef_DUPPUNCT		5	// Dup usage of punctuation
#define ERRDef_PUNCTMATCH	6	// Unmatched punctuation pair
#define ERRDef_WORDUSAGE	7	// Error usage of specific word
#define ERRDef_DUPWORD		8	// Unexpected duplicated of words
#define ERRDef_NUMERIAL		9	// Error numerial words
#define ERRDef_NOSTDNUM		10	// Non-standard numerial words usage
#define ERRDef_UNSMOOTH		11	// Not a perfectly smooth usage of a specific word
#define ERRDef_QUOTATION	12	// Quotation word which could not pass SLM Check
#define ERRDef_AMOUNT		13	// Amount category error
#define ERRDef_TIME			14	// Time category error


#endif	// _ERRORDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\charfreq.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  CharFreq
Purpose:    To manage the CharFreq resource(CharFreq is one of the linguistic resources)
            The CharFreq is stored as the struct CCharFreq followed the frequecy table  
Notes:      
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    4/23/97
============================================================================*/
#ifndef _CHARFREQ_H_
#define _CHARFREQ_H_


#pragma pack(1)
class CCharFreq
{
    public:
        USHORT  m_idxFirst;
        USHORT  m_idxLast;
        UCHAR*  m_rgFreq;

    public:
        // Constructor
        CCharFreq();
        // Destructor
        ~CCharFreq();

        // Init the Freq table from a file pointer to the table memory
        BOOL fOpen(BYTE* pbFreqMap);
        // Close: clear the freq table setting
        void Close(void);

        // Return the frequency of the given idx
        UCHAR CCharFreq::uchGetFreq(WCHAR wch)
        {   
            assert(m_rgFreq);

            if (wch >= m_idxFirst && wch <= m_idxLast) {
                return (UCHAR)(m_rgFreq[wch-m_idxFirst]);
            } else {
                return (UCHAR)0;
            }
        }
};
#pragma pack()


#endif  // _CHARFREQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\fixtable.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  FixTable
Purpose:    Declare the CFixTable class. It contain fixed length string in fixed 
            element number.
            Proof98 engine use this class to contain proper names: Person, Place,
            and Foreign Names
            The element number can not be changed once initialized, the elements
            will be used cycled
            I implement this class just using linear approach at first, and would
            implement it in more efficient data structure some day, if necessary.
Notes:      This is an independent fundamental class as some basic ADT
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    6/1/97
============================================================================*/
#include "myafx.h"

#include "FixTable.h"

//  Constructor
CFixTable::CFixTable()
{
    m_ciElement  = 0;
    m_cwchElement = 0;
    m_iNext      = 0;
    m_pwchBuf     = NULL;
}


//  Destructor
CFixTable::~CFixTable()
{
    FreeTable();
}


/*
*   Initialize the table using iElementCount and cchElementSize
*   The cchElementSize contain the terminating '\0'
*   Return FALSE if memory allocating error or other error occur
*/
BOOL CFixTable::fInit(USHORT ciElement, USHORT cwchElement)
{
    assert(ciElement > 1 && cwchElement > 3);

    FreeTable();
    if ((m_pwchBuf = new WCHAR[ciElement * cwchElement]) == NULL) {
        return FALSE;
    }
    memset((LPVOID)m_pwchBuf, 0, ciElement * cwchElement * sizeof(WCHAR));
    m_ciElement = ciElement;
    m_cwchElement = cwchElement;
    return TRUE;
}

/*
*   Free the element memory of the table
*/
void CFixTable::FreeTable(void)
{
    if (m_pwchBuf != NULL) {
        delete [] m_pwchBuf;
        m_pwchBuf = NULL;
    }
}

/*
*   Add an element into the table, and the terminating '\0' will be appended
*   Return count of bytes added, the string will be truncated at m_cchElement-1
*/
USHORT CFixTable::cwchAdd(LPCWSTR pwchText, USHORT cwchLen)
{
    LPWSTR pSrc;
    LPWSTR pDst;

    assert(pwchText && cwchLen );
    if (cwchLen > m_cwchElement - 1) {
        return 0;
    }
    if (fFind(pwchText, cwchLen)) {
        return 0; // duplicated element
    }
    for (pSrc = const_cast<LPWSTR>(pwchText),
         pDst = (m_pwchBuf + m_iNext * m_cwchElement);
         cwchLen && *pSrc; cwchLen--) {

        *pDst++ = *pSrc++;
    }
    *pDst = '\0';

    m_iNext++;
    if (m_iNext == m_ciElement) {
        m_iNext = 0;
    }
    
    return (USHORT)(pSrc - pwchText);
}

/*
*   Get the max matched item in the table. Must full matched for table item
*   Return length of the max matched item
*/
USHORT CFixTable::cwchMaxMatch(LPCWSTR pwchText, USHORT cwchLen)
{
    LPWSTR pwchItem;
    USHORT iwch;
    USHORT idx;
    USHORT cwchMax = 0;

    assert(pwchText && cwchLen);
    for (idx = 0; idx < m_ciElement; idx++) {
        pwchItem = m_pwchBuf + idx * m_cwchElement;
        if (pwchItem[0] == L'\0') {
            break; // empty element encountered
        }
        for (iwch = 0; pwchItem[iwch] && (iwch < cwchLen); iwch += 1 ) {
            if (pwchText[iwch] != pwchItem[iwch]) {
                        break;
            }
        }
        if (!pwchItem[iwch] && iwch > cwchMax) {
                cwchMax = iwch;
        }
    }
    return cwchMax;
}

/*
*   Search the first cchLen bytes of pchText in the table
*   If matched element found in the table return TRUE, or return FALSE
*/
BOOL CFixTable::fFind(LPCWSTR pwchText, USHORT cwchLen)
{
    LPWSTR pwch1;
    LPWSTR pwch2;
    USHORT idx;
    USHORT cwch;

    assert(pwchText);
    
    if (cwchLen > m_cwchElement - 1) {
        return FALSE;
    }
    for (idx = 0; idx < m_ciElement; idx++)  {
        pwch2 = m_pwchBuf + idx * m_cwchElement;
        if (*pwch2 == L'\0') {
            break; // empty element encountered
        }
        cwch = cwchLen;
        for (pwch1 = const_cast<LPWSTR>(pwchText); cwch && *pwch2; cwch--) {
            if (*pwch1++ != *pwch2++) {
                break;
            }
        }
        if (cwch == 0) {
            return TRUE;
        }
    }
    return FALSE;
}

/*
*   Clear all elements in the table into empty string
*/
void CFixTable::ClearAll(void)
{
    for (m_iNext = m_ciElement; m_iNext; m_iNext--) {
        m_pwchBuf[(m_iNext - 1) * m_cwchElement] = L'\0';
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\iwordbreaker.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: WordBreaker.h    
Purpose:   Implementation of the CIWordBreaker
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include <query.h>
#include <cierror.h>
#include <filterr.h>

#include "CUnknown.h"
#include "IWordBreaker.h"
#include "WordLink.h"
#include "WBEngine.h"
#include "Utility.h"
#include "Lock.h"

extern HINSTANCE   v_hInst;

// constructor
CIWordBreaker::CIWordBreaker(IUnknown* pUnknownOuter)
: CUnknown(pUnknownOuter)
{
    m_pEng = NULL;
    m_pLink = NULL;
    m_ulMaxTokenSize = 0;
    m_fQuery = FALSE;
    m_pbLex = NULL;
    m_fInit = FALSE;
    m_pwchBuf = NULL;
	m_hMutex = NULL ;
	m_pIUnknownFreeThreadedMarshaler = NULL ;
}

// destructor
CIWordBreaker::~CIWordBreaker()
{
    if (m_pwchBuf != NULL) {
        delete [] m_pwchBuf;
    }
    if (m_pEng != NULL) {
        delete m_pEng;
    }
    if (m_pLink != NULL) {
        delete m_pLink;
    }
    if (m_hMutex != NULL) {
        CloseHandle(m_hMutex);
    }
}

/*============================================================================
CIWordBreaker::Init
    Implement IWordBreaker::Init method. 

Returns:
    S_OK, Init ok.
    E_INVALIDARG, if pfLicense is NULL.

Remarks:
    For client, Init must be called before any other method of IWordBreaker.
============================================================================*/
STDMETHODIMP CIWordBreaker::Init( 
            /* [in] */ BOOL fQuery,
            /* [in] */ ULONG ulMaxTokenSize,
            /* [out] */ BOOL __RPC_FAR *pfLicense)
{
    if (pfLicense == NULL) {
        return  E_INVALIDARG;
    }

	CSimpleLock Lock(m_hMutex) ;

    m_fQuery = fQuery;

    if (! ulMaxTokenSize) {
        return E_INVALIDARG;
    }
    if (m_ulMaxTokenSize < ulMaxTokenSize) {
        if (m_pwchBuf != NULL) {
            delete [] m_pwchBuf;
            m_pwchBuf = NULL;
        }
        m_pwchBuf = new WCHAR[ulMaxTokenSize];
        if (m_pwchBuf == NULL) {
            m_fInit = FALSE;
            return WBREAK_E_INIT_FAILED;
        }
    }
    m_ulMaxTokenSize = ulMaxTokenSize;
    *pfLicense = TRUE;

    if (! (m_fInit = fOpenLexicon())) {
        return WBREAK_E_INIT_FAILED;
    } else {
        return S_OK;
    }
}

/*============================================================================
CIWordBreaker::BreakText

    Implement IWordBreaker::BreakText method. This call parses the text it 
receives from pTextSource to find both individual tokens and noun phrases,
then calls methods of pWordSink and pPhraseSink with the results.

Returns:
    S_OK, The raw text in pTextSource has be parsed and no more text is available to refill the buffer.
    E_INVALIDARG, if pTextSource is NULL or Both pWordSink and pPhraseSink is NULL

Remarks:
    MM1 limit: Only less than 64K text should be refill a time.

============================================================================*/
STDMETHODIMP CIWordBreaker::BreakText( 
            /* [in] */ TEXT_SOURCE __RPC_FAR *pTextSource,
            /* [in] */ IWordSink __RPC_FAR *pWordSink,
            /* [in] */ IPhraseSink __RPC_FAR *pPhraseSink)
{
    if (pTextSource == NULL) {
        return  E_INVALIDARG;
    }
    if (pWordSink == NULL && pPhraseSink == NULL) {
        return  E_INVALIDARG;
    } 

    SCODE   sFillTextBuffer = S_OK, sPut = S_OK;

    if (pTextSource->iCur >= pTextSource->iEnd) {
        sFillTextBuffer = (*(pTextSource->pfnFillTextBuffer))(pTextSource);
        if (sFillTextBuffer == WBREAK_E_END_OF_TEXT)
        {
            return S_OK;
        }            
    }

    CSimpleLock Lock(m_hMutex) ;

	SCODE	iret;
    ULONG   cwchText, cwchStart, cwchLine;
    LPCWSTR pwchText = NULL; 
    BOOL    fEndOfText = FALSE; 

    if ((m_pEng = new CWBEngine) == NULL) {
        return E_OUTOFMEMORY;
    }
    if ((m_pLink = new CWordLink) == NULL) {
        delete m_pEng;
        m_pEng = NULL;
        return E_OUTOFMEMORY;
    }
    if ((iret = m_pEng->InitEngine(m_pbLex)) != S_OK) {
        iret = E_FAIL;
        goto gotoExit;
    };

    do {
        // Alloc ANSI buffer and convert Unicode text into ANSI text
        cwchText = pTextSource->iEnd - pTextSource->iCur;
        pwchText = pTextSource->awcBuffer + pTextSource->iCur;

        // refill the raw text buffer
        if ( FAILED(sFillTextBuffer) ) {
            fEndOfText = TRUE;
            iret = sFillTextBuffer == WBREAK_E_END_OF_TEXT ? S_OK : sFillTextBuffer;
        }

        // Hack: query on alpha, client may call with a "\0" string;
		if (cwchText == 0 || 
            cwchText == 1 && *pwchText == NULL) {
		    goto gotoExit;
        }

        // Break the text buffer and fill in the Token List
        do {
            cwchText = pTextSource->iEnd - pTextSource->iCur;
            pwchText = pTextSource->awcBuffer + pTextSource->iCur;

            CWBEngine::FindSentence(pwchText, min(cwchText, 0x0FFFF), (INT*)&cwchLine);
            assert(cwchLine && cwchLine < 0x0FFFF);
            // Initialize the WordLink
            m_pLink->InitLink(pwchText, (USHORT)(cwchLine));
            // Break the next part of the text buffer
            if (!m_fQuery && ERROR_SUCCESS != m_pEng->BreakLink(m_pLink) ||
                m_fQuery && ERROR_SUCCESS != m_pEng->BreakLink(m_pLink, m_fQuery)) {
                iret = E_FAIL;
                goto gotoExit;
            }

            // Fill in the chunk list and callback Word if the chunk list full
            if (pPhraseSink == NULL) {
                sPut = PutWord(pWordSink, pTextSource->iCur,
                                     cwchText, fEndOfText);
            } else if (pWordSink == NULL) {
                sPut = PutPhrase(pPhraseSink, pTextSource->iCur,
                                     cwchText, fEndOfText);
            } else {
                sPut = PutBoth(pWordSink, pPhraseSink, pTextSource->iCur,
                                     cwchText, fEndOfText);
            }
            // After put word, pTextSource->iCur has been increased correctly
            // by PutWord / PutPhrase / PutBoth
        } while (SUCCEEDED(sPut) && m_pLink->cwchGetLength() < cwchText); 

        if (FAILED(sPut)) {
            fEndOfText = TRUE;
            iret = sPut;
        }
		assert(pTextSource->iCur <= pTextSource->iEnd);
        // need refill buffer
        if (! fEndOfText) {
            sFillTextBuffer=(*(pTextSource->pfnFillTextBuffer))(pTextSource);
        }
    } while  (! fEndOfText);

gotoExit:
    if (m_pLink != NULL) {
        delete m_pLink;
        m_pLink = NULL;
    }
    if (m_pEng != NULL) {
        delete m_pEng;
        m_pEng = NULL;
    }
    if (iret >= FILTER_E_END_OF_CHUNKS &&
        iret <= FILTER_E_PASSWORD ) {
        iret = S_OK;
    }
	return iret;
}
        
/*============================================================================
CIWordBreaker::ComposePhrase

    Implement IWordBreaker::ComposePhrase method. This methord convert a noun
and a modifier back into a linguistically correct source phrase.

Returns:
    S_OK, license information pointer in *ppwcsLicense.
    E_INVALIDARG, if one of pointers in param is NULL.
    WBREAK_E_QUERY_ONLY, if called at index time

Remarks:
    this method isn't implemented in MM1, would be implemented in MM2.

============================================================================*/
STDMETHODIMP CIWordBreaker::ComposePhrase( 
            /* [size_is][in] */ const WCHAR __RPC_FAR *pwcNoun,
            /* [in] */ ULONG cwcNoun,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pwcModifier,
            /* [in] */ ULONG cwcModifier,
            /* [in] */ ULONG ulAttachmentType,
            /* [size_is][out] */ WCHAR __RPC_FAR *pwcPhrase,
            /* [out][in] */ ULONG __RPC_FAR *pcwcPhrase)
{

    if (pwcNoun == NULL || pwcModifier == NULL 
        || pwcPhrase == NULL || pcwcPhrase == NULL ) {
        return  E_INVALIDARG;
    }
    if (! m_fQuery) {
        return WBREAK_E_QUERY_ONLY;
    }
    if ( *pcwcPhrase < cwcNoun + cwcModifier ) {
        *pcwcPhrase = cwcNoun + cwcModifier;
        return WBREAK_E_BUFFER_TOO_SMALL;
    }

//    CSimpleLock Lock(m_hMutex) ;

    wcsncpy( pwcPhrase, pwcModifier, cwcModifier );
    wcsncpy( pwcPhrase + cwcModifier, pwcNoun, cwcNoun );
    *pcwcPhrase = cwcNoun + cwcModifier;
    return S_OK;
}

LPWSTR  g_pwcsLicense = L"Copyright Microsoft Corporation, 1999";

/*============================================================================
CIWordBreaker::GetLicenseToUse

    Implement IWordBreaker::GetLicenseToUse method. return a pointer to the 
license information provided by WordBreaker.

Returns:
    S_OK, license information pointer in *ppwcsLicense.
    E_INVALIDARG, if ppwcsLicense is NULL.

============================================================================*/
STDMETHODIMP CIWordBreaker::GetLicenseToUse( 
            /* [string][out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcsLicense)
{

    if (ppwcsLicense == NULL) {
        return  E_INVALIDARG;
    }
    *ppwcsLicense = g_pwcsLicense;
    return S_OK;
}

// QueryInterface Implementation
HRESULT __stdcall CIWordBreaker::NondelegatingQueryInterface(const IID& iid,
                                                             void** ppv)
{ 	
	if (iid == IID_IWordBreaker) {
		return FinishQI(static_cast<IWordBreaker*>(this), ppv) ;

    } else if (iid == IID_IMarshal) {
		return m_pIUnknownFreeThreadedMarshaler->QueryInterface(iid,
		                                                        ppv) ;
	} else {
		return CUnknown::NondelegatingQueryInterface(iid, ppv) ;
	}
}

// Creation function used by CFactory
HRESULT CIWordBreaker::CreateInstance(IUnknown* pUnknownOuter,
	                                  CUnknown** ppNewComponent )
{
    if (pUnknownOuter != NULL)
    {
        // Don't allow aggregation (just for the heck of it).
        return CLASS_E_NOAGGREGATION ;
    }
	
    if (NULL == (*ppNewComponent = new CIWordBreaker(pUnknownOuter))) {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

// Initialize the component by creating the contained component
HRESULT CIWordBreaker::Init()
{
	HRESULT hr = CUnknown::Init() ;
	if (FAILED(hr))
	{
		return hr ;
	}

	// Create a mutex to protect member access
	m_hMutex = CreateMutex(NULL, FALSE, NULL) ;
	if (m_hMutex == NULL)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// Aggregate the free-threaded marshaler.
	hr = ::CoCreateFreeThreadedMarshaler(
	        GetOuterUnknown(),
	        &m_pIUnknownFreeThreadedMarshaler) ;
	return hr;
}

// FinalRelease - Called by Release before it deletes the component
void CIWordBreaker::FinalRelease()
{
	// Call base class to incremement m_cRef and prevent recursion.
	CUnknown::FinalRelease() ;

    if (m_pIUnknownFreeThreadedMarshaler != NULL)
	{
		m_pIUnknownFreeThreadedMarshaler->Release() ;
	}
}

// Put all word in m_pLink to IWordSink
SCODE CIWordBreaker::PutWord(IWordSink *pWordSink,
                              DWORD& cwchSrcPos,
                              DWORD cwchText,
                              BOOL fEnd)
{
	CWord	*pWord, *pChild;
	DWORD	cwchWord, cwchPutWord, cwch;
    LPCWSTR pwchTemp; 
    WORD    wFtr;
    SCODE   scode = S_OK;
    BOOL    fPunct;

    assert(m_pLink);
    assert(pWordSink);

    // Fill in the chunk list and callback Word if the chunk list full
    pWord = m_pLink->pGetHead();
    if (pWord == NULL) {
        assert(0);
        return scode;
    }
   
    for(; SUCCEEDED(scode) && pWord; pWord = pWord->pNextWord()) {
        cwchPutWord = cwchWord = pWord->cwchLen();
        if( pWord->fIsTail() && pWord != m_pLink->pGetHead()
            && m_pLink->cwchGetLength() >= cwchText
            && ! fEnd
            && cwchPutWord < cwchText ) {
            // the last word node breaked in this buffer maybe isn't a 
            // whole word, so keep this in buffer and refill the buffer
            // to get a whole word.
            return scode;
        }

        if (pWord->fGetAttri(LADef_punJu)) { // end of sentence
            scode = pWordSink->PutBreak( WORDREP_BREAK_EOS );
        } else if (pWord->fGetAttri(LADef_punPunct)) {
                // punctuation or space , don't PutWord
        } else {
            fPunct = iswctype(*(pWord->pwchGetText()), _SPACE | _PUNCT | _CONTROL);            
            for (cwch = 1; fPunct && cwch < cwchPutWord; cwch++) {
                fPunct = iswctype(*(pWord->pwchGetText()+cwch), _SPACE | _PUNCT | _CONTROL);
            }
            if (fPunct) {
                // punctuation or space , don't PutWord
                cwchSrcPos += cwchWord;
                continue;
            }

            if (m_fQuery && pWord->fGetAttri(LADef_iwbAltPhr)) {
                assert(pWord->fHasChild());

                // StartAltPhrase
                scode = pWordSink->StartAltPhrase();
                scode = SUCCEEDED(scode) ? PutAllChild(pWordSink, pWord, cwchSrcPos, cwchPutWord)
                                         : scode;
                
                // StartAltPhrase
                scode = SUCCEEDED(scode) ? pWordSink->StartAltPhrase()
                                         : scode;
                scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                        pWord->pwchGetText(),
                                                        cwchPutWord, 
                                                        cwchSrcPos )
                                         : scode;
                scode = SUCCEEDED(scode) ? pWordSink->EndAltPhrase()
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            }

            if (pWord->fGetAttri(LADef_iwbNPhr1)) {
                assert(cwchPutWord > 1);
                // putword modifier
                scode = pWordSink->PutWord(1, pWord->pwchGetText(), 1, cwchSrcPos);
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 1,pWord->pwchGetText() + 1,
                                                    cwchPutWord - 1,cwchSrcPos + 1)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            } 
            
            if (pWord->fGetAttri(LADef_iwbNPhr2)) {
                assert(cwchPutWord > 2);
                // putword modifier
                scode = pWordSink->PutWord(2, pWord->pwchGetText(), 2, cwchSrcPos);
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 2,pWord->pwchGetText() + 2,
                                                        cwchPutWord - 2,cwchSrcPos + 2)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            } 
            
            if (pWord->fGetAttri(LADef_iwbNPhr3)) {
                assert(cwchPutWord > 3);
                // putword modifier
                scode = pWordSink->PutWord(3, pWord->pwchGetText(), 3, cwchSrcPos);
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 3,pWord->pwchGetText() + 3,
                                                cwchPutWord - 3,cwchSrcPos + 3)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            } 
            
            if (wFtr = m_pEng->GetPhrFeature(pWord)) {
                WORD    wBit = 0x01;
                ULONG   cwTotal = 0, cwSubWord = 0;
                assert(cwchPutWord <= 16);

                if (m_fQuery) {
                    // StartAltPhrase
                    scode = pWordSink->StartAltPhrase();
                    // for ////// wFtr = 0x00AD
                    // = 0000 0000 1010 1101b
                    // is  1  0  1 1  0  1  0  1, 0000, 0000, ( bit0 --> bit15 )
                    //           
                    while (SUCCEEDED(scode) && cwTotal < cwchPutWord) {
                        cwSubWord = 0;
						/* Bug: compile bug
                        while (wBit == ((wFtr >> (cwTotal + cwSubWord)) & 0x01) ) {
                            cwSubWord++;
                        }
						*/
						// Bugfix
						if (wBit) {
							while (wFtr & (0x01 << (cwTotal + cwSubWord))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 0;
						} else {
							while ( ! (wFtr & (0x01 << (cwTotal + cwSubWord)))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 1;
						}
						// End Bugfix

//                        assert(cwTotal + cwSubWord <= cwchPutWord);
                        scode = pWordSink->PutWord( cwSubWord, 
                                            pWord->pwchGetText() + cwTotal,
                                            cwchPutWord, 
                                            cwchSrcPos );
                        cwTotal += cwSubWord;
//                        wBit = wBit == 0 ? 1 : 0;
                    }
                    scode = SUCCEEDED(scode) ? pWordSink->StartAltPhrase()
                                             : scode;
                    scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                    pWord->pwchGetText(),
                                                    cwchPutWord, 
                                                    cwchSrcPos )
                                             : scode;
                    scode = SUCCEEDED(scode) ? pWordSink->EndAltPhrase()
                                             : scode;
                } else {
                    while (SUCCEEDED(scode) && cwTotal < cwchPutWord) {
                        cwSubWord = 0;
						/* Bug: compile bug
                        while (wBit == ((wFtr >> (cwTotal + cwSubWord)) & 0x01) ) {
                            cwSubWord++;
                        }
						*/
						// Bugfix
						if (wBit) {
							while (wFtr & (0x01 << (cwTotal + cwSubWord))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 0;
						} else {
							while ( ! (wFtr & (0x01 << (cwTotal + cwSubWord)))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 1;
						}
						// End Bugfix

//                        assert(cwTotal + cwSubWord <= cwchPutWord);
                        scode = pWordSink->PutWord( cwSubWord, 
                                            pWord->pwchGetText() + cwTotal,
                                            cwSubWord, 
                                            cwchSrcPos + cwTotal);
                        cwTotal += cwSubWord;
//                        wBit = wBit == 0 ? 1 : 0;
                    }
                }
                cwchSrcPos += cwchWord;
                continue;
            }

            if (cwchPutWord > (DWORD)m_ulMaxTokenSize && pWord->fHasChild()) {
                // too large word node. break
                scode = PutAllChild(pWordSink, pWord, cwchSrcPos, cwchPutWord);
                cwchSrcPos += cwchWord;
                continue;
            }
           
            // PutAltWord if need
            if (pWord->fGetAttri(LADef_iwbAltWd1) &&
                pWord->fHasChild() ) {
                assert(pWord->pChildWord());
                pChild = pWord->pChildWord();
                scode = pWordSink->PutAltWord(pChild->cwchLen(),
                                      pChild->pwchGetText(),
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else if (pWord->fGetAttri(LADef_iwbAltWd2) &&
                       pWord->fHasChild() ) {
                assert(pWord->pChildWord());
                assert(pWord->pChildWord()->pNextWord());
                pChild = pWord->pChildWord()->pNextWord();
                scode = pWordSink->PutAltWord(pChild->cwchLen(),
                                      pChild->pwchGetText(),
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else if (pWord->fGetAttri(LADef_iwbAltWdc13) &&
                       pWord->fHasChild() ) {
                assert(pWord->pChildWord());
                pChild = pWord->pChildWord();
                assert(pChild->pNextWord());
                assert(pChild->pNextWord()->pNextWord());
                wcsncpy(m_pwchBuf, pChild->pwchGetText(),
                        pChild->cwchLen());
                wcsncpy(m_pwchBuf + pChild->cwchLen(),
                        pChild->pNextWord()->pNextWord()->pwchGetText(),
                        pChild->pNextWord()->pNextWord()->cwchLen());
                scode = pWordSink->PutAltWord(pChild->cwchLen() + pChild->pNextWord()->pNextWord()->cwchLen(),
                                      m_pwchBuf,
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else {
                // Hack: word node breaked by WBEngine include tail space characters 
                // so we should get rid of this space characters
                if ( cwchPutWord > 1 ) {
                    pwchTemp = pWord->pwchGetText() + cwchPutWord - 1;
                    while ( iswspace(*pwchTemp) && cwchPutWord ) {
                        cwchPutWord --;
                        pwchTemp --;
                    }
                    if (cwchPutWord == 0) {
                        cwchSrcPos += cwchWord;
                        continue;
                    }
                }
            }
            // PutWord()
            scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                    pWord->pwchGetText(),
                                                    cwchPutWord, 
                                                    cwchSrcPos )
                                     : scode;
        }
        cwchSrcPos += cwchWord;
    } // end of for(; pWord; pWord = pWord->pNextWord()) 
    return scode;
}

// Put all word in m_pLink to IPhraseSink
SCODE CIWordBreaker::PutPhrase(IPhraseSink *pPhraseSink,
                DWORD& cwchSrcPos,
                DWORD cwchText,
                BOOL fEnd)
{
	CWord	*pWord;
	DWORD	cwchPutWord;
    SCODE   scode = S_OK;

    assert(m_pLink);
    assert(pPhraseSink);

    // Fill in the chunk list and callback Word if the chunk list full
    pWord = m_pLink->pGetHead();
    if (pWord == NULL) {
        assert(0);
        return scode;
    }
   
    for(; SUCCEEDED(scode) && pWord; pWord = pWord->pNextWord()) {
        cwchPutWord = pWord->cwchLen();
        if( pWord->fIsTail() && pWord != m_pLink->pGetHead()
            && m_pLink->cwchGetLength() >= cwchText
            && ! fEnd
            && cwchPutWord < cwchText ) {
            // the last word node breaked in this buffer maybe isn't a 
            // whole word, so keep this in buffer and refill the buffer
            // to get a whole word.
            return scode;
        }
        if (pWord->fGetAttri(LADef_iwbNPhr1)) {
            assert(cwchPutWord > 1);
            if (m_fQuery) {
                scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
            } else {
                scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText()+1,
                    cwchPutWord-1,
                    pWord->pwchGetText(),
                    1, 
                    0 );
            }
        } else if (pWord->fGetAttri(LADef_iwbNPhr2)) {
            assert(cwchPutWord > 2);
            if (m_fQuery) {
                scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
            } else {
                scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText()+2,
                    cwchPutWord-2,
                    pWord->pwchGetText(),
                    2, 
                    0 );
            }
        } else if (pWord->fGetAttri(LADef_iwbNPhr3)) {
            assert(cwchPutWord > 3);
            if (m_fQuery) {
                scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
            } else {
                scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText()+3,
                    cwchPutWord-3,
                    pWord->pwchGetText(),
                    3, 
                    0 );
            }
        } else {
        }
		cwchSrcPos += cwchPutWord;
    }
    return scode;
}

// Put all word in m_pLink to both IWordBreaker and IPhraseSink
SCODE CIWordBreaker::PutBoth(IWordSink *pWordSink,
                             IPhraseSink *pPhraseSink,
                             DWORD& cwchSrcPos,
                             DWORD cwchText,
                             BOOL fEnd)
{
	CWord	*pWord, *pChild;
	DWORD	cwchWord, cwchPutWord, cwch;
    LPCWSTR pwchTemp; 
    SCODE   scode = S_OK;
    WORD    wFtr;
    BOOL    fPunct;

    assert(m_pLink);
    assert(pPhraseSink);
    assert(pWordSink);

    // Fill in the chunk list and callback Word if the chunk list full
    pWord = m_pLink->pGetHead();
    if (pWord == NULL) {
        assert(0);
        return scode;
    }
   
    for(; SUCCEEDED(scode) && pWord; pWord = pWord->pNextWord()) {
        cwchPutWord = cwchWord = pWord->cwchLen();
        if( pWord->fIsTail() && pWord != m_pLink->pGetHead()
            && m_pLink->cwchGetLength() >= cwchText
            && ! fEnd
            && cwchPutWord < cwchText ) {
            // the last word node breaked in this buffer maybe isn't a 
            // whole word, so keep this in buffer and refill the buffer
            // to get a whole word.
            return scode;
        }

        if (pWord->fGetAttri(LADef_punJu)) { // end of sentence
            scode = pWordSink->PutBreak( WORDREP_BREAK_EOS );
        } else if (pWord->fGetAttri(LADef_punPunct)) {
                // punctuation or space , don't PutWord
        } else {
            fPunct = iswctype(*(pWord->pwchGetText()), _SPACE | _PUNCT | _CONTROL);
            for (cwch = 1; fPunct && cwch < cwchPutWord; cwch++) {
                fPunct = iswctype(*(pWord->pwchGetText()+cwch), _SPACE | _PUNCT | _CONTROL);
            }
            if (fPunct) {
                // punctuation or space , don't PutWord
                cwchSrcPos += cwchWord;
                continue;
            }

            if (m_fQuery && pWord->fGetAttri(LADef_iwbAltPhr)) {
                assert(pWord->fHasChild());

                // StartAltPhrase
                scode = pWordSink->StartAltPhrase();
                scode = SUCCEEDED(scode) ? PutAllChild(pWordSink, pWord, cwchSrcPos, cwchPutWord)
                                         : scode;
                
                // StartAltPhrase
                scode = SUCCEEDED(scode) ? pWordSink->StartAltPhrase()
                                         : scode;
                scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                        pWord->pwchGetText(),
                                                        cwchPutWord, 
                                                        cwchSrcPos )
                                         : scode;
                scode = SUCCEEDED(scode) ? pWordSink->EndAltPhrase()
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            }

            if (pWord->fGetAttri(LADef_iwbNPhr1)) {
                assert(cwchPutWord > 1);
                if (m_fQuery) {
                    scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
                } else {
                    scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText() + 1,
                                                cwchPutWord - 1,
                                                pWord->pwchGetText(),
                                                1, 
                                                0 );
                }
                // putword modifier
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(1, pWord->pwchGetText(), 1, cwchSrcPos)
                                         : scode;
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 1,pWord->pwchGetText() + 1,
                                                        cwchPutWord - 1,cwchSrcPos + 1)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            } 
            
            if (pWord->fGetAttri(LADef_iwbNPhr2)) {
                assert(cwchPutWord > 2);
                if (m_fQuery) {
                    scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
                } else {
                    scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText() + 2,
                                                cwchPutWord - 2,
                                                pWord->pwchGetText(),
                                                2, 
                                                0 );
                }
                // putword modifier
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(2, pWord->pwchGetText(), 2, cwchSrcPos)
                                         : scode;
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 2,pWord->pwchGetText() + 2,
                                                              cwchPutWord - 2,cwchSrcPos + 2)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            } 
            
            if (pWord->fGetAttri(LADef_iwbNPhr3)) {
                assert(cwchPutWord > 3);
                if (m_fQuery) {
                    scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
                } else {
                    scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText() + 3,
                                                cwchPutWord - 3,
                                                pWord->pwchGetText(),
                                                3, 
                                                0 );
                }
                // putword modifier
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(3, pWord->pwchGetText(), 3, cwchSrcPos)
                                         : scode;
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 3,pWord->pwchGetText() + 3,
                                                                cwchPutWord - 3,cwchSrcPos + 3)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            }
            
            if (wFtr = m_pEng->GetPhrFeature(pWord)) {
                WORD    wBit = 0x01;
                ULONG   cwTotal = 0, cwSubWord = 0;
                assert(cwchPutWord <= 16);

                if (m_fQuery) {
                    // StartAltPhrase
                    scode = pWordSink->StartAltPhrase();
                    // for ////// wFtr = 0x00AD
                    // = 0000 0000 1010 1101b
                    // is  1  0  1 1  0  1  0  1, 0000, 0000, ( bit0 --> bit15 )
                    //           
                    while (SUCCEEDED(scode) && cwTotal < cwchPutWord) {
                        cwSubWord = 0;
						/* Bug: compile bug
                        while (wBit == ((wFtr >> (cwTotal + cwSubWord)) & 0x01) ) {
                            cwSubWord++;
                        }
						*/
						// Bugfix
						if (wBit) {
							while (wFtr & (0x01 << (cwTotal + cwSubWord))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 0;
						} else {
							while ( ! (wFtr & (0x01 << (cwTotal + cwSubWord)))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 1;
						}
						// End Bugfix

//                        assert(cwTotal + cwSubWord <= cwchPutWord);
                        scode = pWordSink->PutWord( cwSubWord, 
                                            pWord->pwchGetText() + cwTotal,
                                            cwchPutWord, 
                                            cwchSrcPos );
                        cwTotal += cwSubWord;
//                        wBit = wBit == 0 ? 1 : 0;
                    }
                    scode = SUCCEEDED(scode) ? pWordSink->StartAltPhrase()
                                             : scode;
                    scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                        pWord->pwchGetText(),
                                                        cwchPutWord, 
                                                        cwchSrcPos )
                                         : scode;
                    scode = SUCCEEDED(scode) ? pWordSink->EndAltPhrase()
                                         : scode;
                } else {
                    while (SUCCEEDED(scode) && cwTotal < cwchPutWord) {
                        cwSubWord = 0;
						/* Bug: compile bug
                        while (wBit == ((wFtr >> (cwTotal + cwSubWord)) & 0x01) ) {
                            cwSubWord++;
                        }
						*/
						// Bugfix
						if (wBit) {
							while (wFtr & (0x01 << (cwTotal + cwSubWord))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 0;
						} else {
							while ( ! (wFtr & (0x01 << (cwTotal + cwSubWord)))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 1;
						}
						// End Bugfix

//                        assert(cwTotal + cwSubWord <= cwchPutWord);
                        scode = pWordSink->PutWord( cwSubWord, 
                                                    pWord->pwchGetText() + cwTotal,
                                                    cwSubWord, 
                                                    cwchSrcPos + cwTotal);
                        cwTotal += cwSubWord;
//                        wBit = wBit == 0 ? 1 : 0;
                    }
                }
                cwchSrcPos += cwchWord;
                continue;
            }

            if (cwchPutWord > (DWORD)m_ulMaxTokenSize && pWord->fHasChild()) {
                // too large word node. break
                scode = PutAllChild(pWordSink, pWord, cwchSrcPos, cwchPutWord);
                cwchSrcPos += cwchWord;
                continue;
            }

            // PutAltWord if need
            if (pWord->fGetAttri(LADef_iwbAltWd1) &&
                pWord->fHasChild() ) {

                assert(pWord->pChildWord());
                pChild = pWord->pChildWord();
                scode = pWordSink->PutAltWord(pChild->cwchLen(),
                                      pChild->pwchGetText(),
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else if (pWord->fGetAttri(LADef_iwbAltWd2) &&
                       pWord->fHasChild() ) {
                assert(pWord->pChildWord());
                assert(pWord->pChildWord()->pNextWord());
                pChild = pWord->pChildWord()->pNextWord();
                scode = pWordSink->PutAltWord(pChild->cwchLen(),
                                      pChild->pwchGetText(),
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else if (pWord->fGetAttri(LADef_iwbAltWdc13) &&
                       pWord->fHasChild() ) {
                assert(pWord->pChildWord());
                pChild = pWord->pChildWord();
                assert(pChild->pNextWord());
                assert(pChild->pNextWord()->pNextWord());
                wcsncpy(m_pwchBuf, pChild->pwchGetText(),
                        pChild->cwchLen());
                wcsncpy(m_pwchBuf + pChild->cwchLen(),
                        pChild->pNextWord()->pNextWord()->pwchGetText(),
                        pChild->pNextWord()->pNextWord()->cwchLen());
                scode = pWordSink->PutAltWord(pChild->cwchLen() + pChild->pNextWord()->pNextWord()->cwchLen(),
                                      m_pwchBuf,
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else {
                // Hack: word node breaked by WBEngine include tail space characters 
                // so we should get rid of this space characters
                if ( cwchPutWord > 1 ) {
                    pwchTemp = pWord->pwchGetText() + cwchPutWord - 1;
                    while ( iswspace(*pwchTemp) && cwchPutWord ) {
                        cwchPutWord --;
                        pwchTemp --;
                    }
                    if (cwchPutWord == 0) {
                        cwchSrcPos += cwchWord;
                        continue;
                    }
                }
            }
            // PutWord()
            scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                    pWord->pwchGetText(),
                                                    cwchPutWord, 
                                                    cwchSrcPos )
                                     : scode;
        }
        cwchSrcPos += cwchWord;
    } // end of for(; pWord; pWord = pWord->pNextWord()) 
    return scode;
}

// PutWord() all of the pWord's child word 
SCODE CIWordBreaker::PutAllChild(IWordSink *pWordSink,
                                CWord* pWord,
                                ULONG cwchSrcPos,
                                ULONG cwchPutWord )
{
    assert(pWord);
    assert(pWord->fHasChild());

    SCODE scode = S_OK;

    CWord *pChild;

    pChild = pWord->pChildWord();
    while (SUCCEEDED(scode) && pChild) {
        if (pChild->fHasChild()) {
            scode = PutAllChild(pWordSink, pChild, cwchSrcPos, cwchPutWord);
        } else if (pChild->fGetAttri(LADef_iwbNPhr1)) {
            assert(cwchPutWord > 1);
            // putword modifier
            scode = pWordSink->PutWord(1, pChild->pwchGetText(), 1, cwchSrcPos);
            // putword noun
            scode = pWordSink->PutWord(pChild->cwchLen() - 1,
                pChild->pwchGetText() + 1,
                cwchPutWord,
                cwchSrcPos);
        } else if (pChild->fGetAttri(LADef_iwbNPhr2)) {
            assert(cwchPutWord > 2);
            // putword modifier
            scode = pWordSink->PutWord(2, pChild->pwchGetText(), 2, cwchSrcPos);
            // putword noun
            scode = pWordSink->PutWord(pChild->cwchLen() - 2,
                pChild->pwchGetText() + 2,
                cwchPutWord,
                cwchSrcPos);
        } else if (pChild->fGetAttri(LADef_iwbNPhr3)) {
            assert(cwchPutWord > 3);
            // putword modifier
            scode = pWordSink->PutWord(3, pChild->pwchGetText(), 3, cwchSrcPos);
            // putword noun
            scode = pWordSink->PutWord(pChild->cwchLen() - 3,
                pChild->pwchGetText() + 3,
                cwchPutWord,
                cwchSrcPos);
        } else {
            scode = pWordSink->PutWord(pChild->cwchLen(), pChild->pwchGetText(),
                cwchPutWord, cwchSrcPos );
        }
        pChild = pChild->pNextWord();
    }
    return scode;
}


//	Load the lexicon and charfreq resource into memory
BOOL CIWordBreaker::fOpenLexicon(void)
{
    HRSRC   hRSRC; 
    HGLOBAL hLexRes;


    if ( (hRSRC = FindResource(v_hInst, _T("MainDic"), _T("DIC"))) != NULL &&
         (hLexRes = LoadResource(v_hInst, hRSRC)) != NULL &&
         (m_pbLex = (BYTE*)LockResource(hLexRes)) != NULL) {

        return TRUE;
    }

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\cunknown.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CUnknown
Purpose:   Implementation of IUnknown Base class CUnknown
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include "CUnknown.h"

/*============================================================================
Count of active objects
   - Use to determine if we can unload the DLL.
============================================================================*/
long CUnknown::s_cActiveComponents = 0 ;

// Constructor
CUnknown::CUnknown(IUnknown* pUnknownOuter)
: m_cRef(1)
{
	// Set m_pUnknownOuter pointer.
	if (pUnknownOuter == NULL)
	{
		m_pUnknownOuter = reinterpret_cast<IUnknown*>
		                     (static_cast<INondelegatingUnknown*>
		                     (this)) ;  // notice cast
	}
	else
	{
		m_pUnknownOuter = pUnknownOuter ;
	}
	// Increment count of active components.
	::InterlockedIncrement(&s_cActiveComponents) ;
}

// Destructor
CUnknown::~CUnknown()
{
	::InterlockedDecrement(&s_cActiveComponents) ;
}

// FinalRelease - called by Release before it deletes the component
void CUnknown::FinalRelease()
{
	m_cRef = 1 ;
}

// IUnknown
//   - Override to handle custom interfaces.
HRESULT __stdcall 
	CUnknown::NondelegatingQueryInterface(const IID& iid, void** ppv)
{
	// CUnknown supports only IUnknown.
	if (iid == IID_IUnknown)
	{
		return FinishQI(reinterpret_cast<IUnknown*>
		                   (static_cast<INondelegatingUnknown*>(this)),
		                ppv) ;
	}	
	else
	{
		*ppv = NULL ;
		return E_NOINTERFACE ;
	}
}

// AddRef
ULONG __stdcall CUnknown::NondelegatingAddRef()
{
	return InterlockedIncrement(&m_cRef) ;
}


// Release
ULONG __stdcall CUnknown::NondelegatingRelease()
{
	InterlockedDecrement(&m_cRef) ;
	if (m_cRef == 0)
	{
		FinalRelease() ;
		delete this ;
		return 0 ;
	}
	return m_cRef ;
}


// FinishQI
//   - Helper function to simplify overriding
//     QueryInterface
HRESULT CUnknown::FinishQI(IUnknown* pI, void** ppv) 
{
	*ppv = pI ;
	pI->AddRef() ;
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\chsbrkr.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: DLL Main and exported functions
Purpose:   DLL Main and exported functions
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include "Registry.h"
#include "CFactory.h"

HINSTANCE   v_hInst = NULL;

// DLL module information
BOOL APIENTRY DllMain(HINSTANCE hModule, 
                      DWORD dwReason, 
                      void* lpReserved )
{
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        CFactory::s_hModule = hModule ;
        v_hInst = hModule;
        DisableThreadLibraryCalls(hModule);
        break;

    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE ;
}

// Exported functions

STDAPI DllCanUnloadNow()
{
    return CFactory::CanUnloadNow() ; 
}

// Get class factory
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv) 
{
    return CFactory::GetClassObject(clsid, iid, ppv) ;
}

// Server registration
STDAPI DllRegisterServer()
{
    HRESULT hr;
    hr = CFactory::RegisterAll() ;
    if (hr != S_OK) {
        return hr;
    }
    return hr;
}


STDAPI DllUnregisterServer()
{
    HRESULT hr;
    hr = CFactory::UnregisterAll() ;
    if (hr != S_OK) {
        return hr;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\cunknown.h ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CUnknown
Purpose:   Define CUnknown class
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/

#ifndef __CUnknown_h__
#define __CUnknown_h__

// Nondelegating IUnknown interface
//   - Nondelegating version of IUnknown
interface INondelegatingUnknown
{
	virtual HRESULT __stdcall 
		NondelegatingQueryInterface(const IID& iid, void** ppv) = 0 ;
	virtual ULONG   __stdcall NondelegatingAddRef() = 0 ;
	virtual ULONG   __stdcall NondelegatingRelease() = 0 ;
} ;

/*============================================================================
Declaration of CUnknown 
  - Base class for implementing IUnknown
============================================================================*/
class CUnknown : public INondelegatingUnknown
{
public:
	// IUnknown implementation
	// Nondelegating IUnknown implementation
	virtual HRESULT __stdcall NondelegatingQueryInterface(const IID&,
	                                                      void**) ;
	virtual ULONG   __stdcall NondelegatingAddRef() ;
	virtual ULONG   __stdcall NondelegatingRelease() ;

	// Constructor
	CUnknown(IUnknown* pUnknownOuter) ;

	// Destructor
	virtual ~CUnknown() ;

	// Initialization
	virtual HRESULT Init() { return S_OK ;}

	// Notification to derived classes that we are releasing
	virtual void FinalRelease() ;

	// Count of currently active components
	static long ActiveComponents() 
		{ return s_cActiveComponents ;}
	
	// Helper function
	HRESULT FinishQI(IUnknown* pI, void** ppv) ;

protected:
	// Support for delegation
	IUnknown* GetOuterUnknown() const
		{ return m_pUnknownOuter ;}

private:
	// Reference count for this object
	long m_cRef ;
	
	// Pointer to (external) outer IUnknown
	IUnknown* m_pUnknownOuter ;

	// Count of all active instances
	static long s_cActiveComponents ; 
} ;

// Delegating IUnknown
//   - Delegates to the nondelegating IUnknown, or to the
//     outer IUnknown if the component is aggregated.
//
#define DECLARE_IUNKNOWN		                             \
	virtual HRESULT __stdcall	                             \
		QueryInterface(const IID& iid, void** ppv)           \
	{	                                                     \
		return GetOuterUnknown()->QueryInterface(iid,ppv) ;  \
	} ;	                                                     \
	virtual ULONG __stdcall AddRef()	                     \
	{	                                                     \
		return GetOuterUnknown()->AddRef() ;                 \
	} ;	                                                     \
	virtual ULONG __stdcall Release()	                     \
	{	                                                     \
		return GetOuterUnknown()->Release() ;                \
	} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\fixtable.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  FixTable
Purpose:    Declare the CFixTable class. It contain fixed length string in fixed 
            element number.
            Proof98 engine use this class to contain proper names: Person, Place,
            and Foreign Names
            The element number can not be changed once initialized, the elements
            will be used cycled
            I implement this class just using linear approach at first, and would
            implement it in more efficient data structure some day, if necessary.
Notes:      This is an independent fundamental class as some basic ADT
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    6/1/97
============================================================================*/
#ifndef _FIXTABLE_H_
#define _FIXTABLE_H_

class CFixTable
{
    public:
        CFixTable();
        ~CFixTable();

        /*
        *   Initialize the table using iElementCount and cchElementSize
        *   The cchElementSize contain the terminating '\0'
        *   Return FALSE if memory allocating error or other error occur
        */
        BOOL fInit(USHORT ciElement, USHORT cwchElement);

        /*
        *   Free the element memory of the table
        */
        void FreeTable(void);

        /*
        *   Add an element into the table, and the terminating '\0' will be appended
        *   Return count of bytes added, the string will be truncated at m_cchElement-1
        */
        USHORT cwchAdd(LPCWSTR pwchText, USHORT cwchLen);

        /*
        *   Get the max matched item in the table. Must full matched for table item
        *   Return length of the max matched item
        */
        USHORT cwchMaxMatch(LPCWSTR pwchText, USHORT cwchLen);

        /*
        *   Clear all elements in the table into empty string
        */
        void ClearAll(void);

    private:
        USHORT  m_ciElement;
        USHORT  m_cwchElement;
        USHORT  m_iNext;

        LPWSTR  m_pwchBuf;

    private:
        /*
        *   Search the first cwchLen chars of pwchText in the table
        *   If matched element found in the table return TRUE, or return FALSE
        */
        BOOL fFind(LPCWSTR pwchText, USHORT cwchLen);
};

#endif  // _FIXTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\jargon.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CJargon
Purpose:    Declare the CJargon class for new words identification. There are a lot of
            tasks to do in Jargon moudle:
            1. Name of palce (Jargon1.cpp)
            2. Name of foreign person and places (Jargon1.cpp)
            3. Name of orgnizations (Jargon1.cpp)
            4. Name of HanZu person (Jargon1.cpp)
Notes:      The CJargon class will be implemented in several cpp files:
            Jargon.cpp, Jargon1.cpp, Jargon2.cpp
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#ifndef _JARGON_H_
#define _JARGON_H_

// Forward declaration of classes
class CLexicon;
class CWordLink;
class CFixTable;
struct CWord;


//  Define the CJargon class
class CJargon
{
    public:
        CJargon();
        ~CJargon();

        // Initialize the Jargon class
        int ecInit(CLexicon* pLexicon);

        // Process control function of Jargon class
        int ecDoJargon(CWordLink* pLink);

    private:
        CWordLink*  m_pLink;
        CLexicon*   m_pLex;

        CFixTable*  m_ptblName;
        CFixTable*  m_ptblPlace;
        CFixTable*  m_ptblForeign;

        int         m_iecError;     // Runtime error code
        CWord*      m_pWord;        // Current word pointer shared inside one pass of analysis
        CWord*      m_pTail;        // Right or left end of the likely proper name,
                                    // according to the specific sort of names.

    private:
        // Terminate the Jargon class
        void TermJargon(void);

        /*============================================================================
        Proper names identification stuffs
        ============================================================================*/
        //  Proper names identification scan pass controlling function
        //  Return TRUE if successful.
        //  Return FALSE if runtime error and set error code in m_iecError
        BOOL fIdentifyProperNames();

        //  Handle name of HanZu places
        //  Return TRUE if merged, or FALSE if un-merged. No error return.
        BOOL fHanPlaceHandler();
        
        //  Handle organization name identification
        //  Return TRUE if merged, or FALSE if un-merged. No error return.
        BOOL fOrgNameHandler(void);
        
        //  Foreign proper name identification
        //  Return TRUE if merged, or FALSE if un-merged. No error return.
        BOOL fForeignNameHandler(CWord* pTail);
        //  Get foreign string
        //  return TRUE if the is an multi-section foreign name found and merged
        //  return FALSE if only one section found, and the word follows the last word node 
        //  in the likely foreign name will be returned in ppTail
        //  Note: m_pWord is not moved!!!
        BOOL fGetForeignString(CWord** ppTail);

        //  HanZu person name identification
        //  Return TRUE if merged, or FALSE if un-merged. No error return.
        BOOL fHanPersonHandler(void);
        //  Merge  + 
        //  Return TRUE if merged, or FALSE if un-merged. No error return.
        BOOL fChengWeiHandler(void);

        
        //-----------------------
        //  Service functions:
        //-----------------------
        //  Add pWord to specific table
        void AddWordToTable(CWord* pWord, CFixTable* pTable);
        //  Check proper name table, and merge match words
        BOOL fInTable(CWord* pWord, CFixTable* pTable);

};

#endif // _JARGON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\jargon.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CJargon
Purpose:    Implement process control and public functions in CJargon class
            There are a lot of tasks to do in Jargon moudle:
            1. Name of palce (Jargon1.cpp)
            2. Name of foreign person and places (Jargon1.cpp)
            3. Name of orgnizations (Jargon1.cpp)
            4. Name of HanZu person (Jargon1.cpp)               
Notes:      The CJargon class will be implemented in several cpp files:
            Jargon.cpp, Jargon1.cpp, Jargon2.cpp
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "jargon.h"
#include "lexicon.h"
#include "wordlink.h"
#include "proofec.h"
#include "fixtable.h"


/*============================================================================
Implementation of PUBLIC member functions
============================================================================*/
// Constructor
CJargon::CJargon()
{
    m_pLink = NULL;
    m_pLex = NULL;
    m_iecError = 0;
    m_pWord = NULL;
    m_pTail = NULL;
    m_ptblName = NULL;
    m_ptblPlace = NULL;
    m_ptblForeign = NULL;
}


// Destructor
CJargon::~CJargon()
{
    TermJargon();
}


// Initialize the CJargon class
int CJargon::ecInit(CLexicon* pLexicon)
{
    assert(m_pLex == NULL && m_pLink == NULL);
    assert(pLexicon);

    m_pLex = pLexicon;
    
    // Init the 3 FixTable
    if ((m_ptblName = new CFixTable)== NULL || !m_ptblName->fInit(50, 10)) {
        goto gotoOOM;
    }
    if ((m_ptblPlace = new CFixTable)== NULL || !m_ptblPlace->fInit(40, 20)) {
        goto gotoOOM;
    }
    if ((m_ptblForeign =new CFixTable)==NULL || !m_ptblForeign->fInit(60, 15)){
        goto gotoOOM;
    }

    return PRFEC::gecNone;
gotoOOM:
    TermJargon();
    return PRFEC::gecOOM;
}


// Process control function of CJargon class
int CJargon::ecDoJargon(CWordLink* pLink)
{
    assert(pLink);

    m_pLink = pLink;
    m_iecError = PRFEC::gecNone;
    m_pWord = NULL;
    m_pTail = NULL;

    // Perform the proper name identification
    if (!fIdentifyProperNames()) {
        assert(m_iecError != PRFEC::gecNone);
        return m_iecError;
    }

    return PRFEC::gecNone;
}

        
/*============================================================================
Implementation of Private member functions
============================================================================*/
// Terminate the Jargon class
void CJargon::TermJargon(void)
{
    m_pLex = NULL;
    m_pLink = NULL;
    m_iecError = 0;
    m_pWord = NULL;
    m_pTail = NULL;
    if (m_ptblName != NULL) {
        delete m_ptblName;
        m_ptblName = NULL;
    }
    if (m_ptblPlace != NULL) {
        delete m_ptblPlace;
        m_ptblPlace = NULL;
    }
    if (m_ptblForeign != NULL) {
        delete m_ptblForeign;
        m_ptblForeign = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\lexprop.h ===
//--------------------------------------------------------------------------------------
 //	LexProp.h																			
 //	Project:	Chinese Grammar'9                  										
 //	Module:		LexProp																	
 //	Purpose:	Define symbols of lex attributes and features used by the Rules and Parser
 //	Notes:		This header file is generated by the lexicon builder of the lex manager	
 //	Owner:		donghz@microsoft.com													
 //	Platform:	Win32																	
 //	Revise:		First created by: donghz	12/5/97										
 //--------------------------------------------------------------------------------------
 #ifndef _LEXPROP_H_ 
 #define _LEXPROP_H_ 


// Define Lex version verify ID
#define LexDef_Version 173

// Define Max WordID
#define LexDef_MaxWordID 58325
// Define Max CharID
#define LexDef_MaxCharID 3483

// Define the ID of groups of Attributes
#define LGDef_WrdBrk_First 1
#define LADef_genBreakPunct 1 	// 
#define LADef_genCi 2 	// 
#define LADef_genCuo 3 	// 
#define LADef_posA 4 	// 
#define LADef_posB 5 	// 
#define LADef_posD 6 	// 
#define LADef_posM 7 	// 
#define LADef_posN 8 	// 
#define LADef_posO 9 	// 
#define LADef_posP 10 	// 
#define LADef_posQ 11 	// 
#define LADef_posT 12 	// 
#define LADef_posV 13 	// 
#define LADef_posZ 14 	// 
#define LADef_genDBForeign 15 	// DBCS
#define LADef_tmPoint 16 	// 
#define LADef_tmGapMinute 17 	// 
#define LADef_amtApprox 18 	// 
#define LADef_genAmbiMorph 19 	// Morph
#define LADef_amtWanQian 20 	// /// 
#define LGDef_WrdBrk_Last 20

#define LGDef_IWordBreaker_First 21
#define LADef_iwbAltPhr 21 	// StartAltPhrase( ) / EndAltPhrase() with child words.
#define LADef_iwbAltWd1 22 	// PutAltWord ( the first word in this word's childs )
#define LADef_iwbAltWd2 23 	// PutAltWord ( the second word in this word's childs )
#define LADef_iwbAltWdc13 24 	// PutAltWord ( combination of the first word and the third word in this word's childs )
#define LADef_iwbNPhr1 25 	// Modifier + Noun Phrase, Modifier
#define LADef_iwbNPhr2 26 	// Modifier + Noun Phrase, Modifier
#define LADef_iwbNPhr3 27 	// Modifier + Noun Phrase, Modifier
#define LGDef_IWordBreaker_Last 27

#define LGDef_NounSubClass_First 28
#define LADef_nounOrg 28 	// 
#define LADef_nounPerson 29 	// 
#define LADef_nounPlace 30 	// 
#define LADef_nounTM 31 	// 
#define LADef_nounTerm 32 	// 
#define LADef_nounShiDuan 33 	// 
#define LGDef_NounSubClass_Last 33

#define LGDef_Punct_First 34
#define LADef_punPunct 34 	// DBCS
#define LADef_punJu 35 	// 
#define LADef_punPair 36 	// 
#define LGDef_Punct_Last 36

#define LGDef_Number_First 37
#define LADef_numArabic 37 	// DBCS
#define LADef_numChinese 38 	// DBCS
#define LADef_numCode 39 	// 
#define LADef_numGan 40 	// 
#define LADef_numInteger 41 	// 
#define LADef_numPercent 42 	// 
#define LADef_numSBCS 43 	// SBCS
#define LADef_numZhi 44 	// 
#define LADef_numXi 45 	// 
#define LADef_numMixed 46 	// 8120
#define LADef_numOrdinal 47 	// 
#define LADef_numDecimal 48 	// 
#define LADef_numTipDecimal 49 	// 
#define LADef_numTipOrdinal 50 	// 
#define LADef_numNumber 51 	// 
#define LGDef_Number_Last 51

#define LGDef_Morpheme_First 52
#define LADef_afxPrefix 52 	// 
#define LADef_afxSuffix 53 	// 
#define LADef_pfxAa 54 	// <>
#define LADef_pfxChao 55 	// <>
#define LADef_pfxDai 56 	// <>
#define LADef_pfxFan 57 	// <>
#define LADef_pfxFei 58 	// <>
#define LADef_pfxFu 59 	// <>
#define LADef_pfxGuo 60 	// <>
#define LADef_pfxLao 61 	// <>
#define LADef_pfxWei1 62 	// <>
#define LADef_pfxWei3 63 	// <>
#define LADef_pfxXiao 64 	// <>
#define LADef_pfxZhun 65 	// <>
#define LADef_pfxZong 66 	// <>
#define LADef_sfxChang 67 	// <>
#define LADef_sfxDan 68 	// <>
#define LADef_sfxDui 69 	// <>
#define LADef_sfxEr 70 	// <>
#define LADef_sfxFa 71 	// <>
#define LADef_sfxFang 72 	// <>
#define LADef_sfxGan 73 	// <>
#define LADef_sfxGuan 74 	// <>
#define LADef_sfxHua 75 	// <>
#define LADef_sfxJi 76 	// <>
#define LADef_sfxJia 77 	// <>
#define LADef_sfxJie 78 	// <>
#define LADef_sfxLao 79 	// <>
#define LADef_sfxLun 80 	// <>
#define LADef_sfxLv 81 	// <>
#define LADef_sfxMen 82 	// <>
#define LADef_sfxPin 83 	// <>
#define LADef_sfxQi 84 	// <>
#define LADef_sfxSheng 85 	// <>
#define LADef_sfxSheng3 86 	// <>
#define LADef_sfxShi 87 	// <>
#define LADef_sfxShi1 88 	// <>
#define LADef_sfxShi4 89 	// <>
#define LADef_sfxTi 90 	// <>
#define LADef_sfxTing 91 	// <>
#define LADef_sfxTou 92 	// <>
#define LADef_sfxXing2 93 	// <>
#define LADef_sfxXing4 94 	// <>
#define LADef_sfxXue 95 	// <>
#define LADef_sfxYan 96 	// <>
#define LADef_sfxYe 97 	// <>
#define LADef_sfxYi 98 	// <>
#define LADef_sfxYuan 99 	// <>
#define LADef_sfxZhang 100 	// <>
#define LADef_sfxZhe 101 	// <>
#define LADef_sfxZheng 102 	// <>
#define LADef_sfxZi 103 	// <>
#define LADef_sfxZhi 104 	// <>
#define LGDef_Morpheme_Last 104

#define LGDef_Duplicate_First 105
#define LADef_dupAAABB 105 	// AABB
#define LADef_dupAABAB 106 	// ABAB
#define LADef_dupABB 107 	// ABB
#define LADef_dupMAABB 108 	// AABB
#define LADef_dupMABAB 109 	// ABAB
#define LADef_dupMM 110 	// 
#define LADef_dupNAABB 111 	// AABB
#define LADef_dupNN 112 	// 
#define LADef_dupQQ 113 	// 
#define LADef_dupVAABB 114 	// AABB
#define LADef_dupVABAB 115 	// ABAB
#define LADef_dupVV 116 	// 
#define LADef_dupVVO 117 	// VVO
#define LADef_dupZABAB 118 	// ABAB
#define LADef_dupAA 119 	// 
#define LADef_dupDD 120 	// 
#define LADef_dupDAABB 121 	// AABB
#define LADef_dupDABAB 122 	// ABAB
#define LADef_dupAAToD 123 	// 
#define LGDef_Duplicate_Last 123

#define LGDef_Pattern_First 124
#define LADef_patD1 124 	// DADB
#define LADef_patV1 125 	// VV
#define LADef_patV2 126 	// VV
#define LADef_patV3 127 	// VV
#define LADef_patV4 128 	// VV
#define LADef_patV5 129 	// VV
#define LGDef_Pattern_Last 129

#define LGDef_SeparateWord_First 130
#define LADef_sepBuDe 130 	// <///>
#define LADef_sepChaBu 131 	// 
#define LADef_sepChaDing 132 	// 
#define LADef_sepHou 133 	// 
#define LADef_sepQDong 134 	// 
#define LADef_sepQian 135 	// 
#define LADef_sepQShi 136 	// 
#define LADef_sepVG 137 	// 
#define LADef_sepVO 138 	// 
#define LADef_sepVR 139 	// 
#define LGDef_SeparateWord_Last 139

#define LGDef_FlagWord_First 140
#define LADef_flgNoABu 140 	// <>
#define LADef_flgNoVBu 141 	// <>
#define LADef_flgNoVMei 142 	// <>
#define LGDef_FlagWord_Last 142

#define LGDef_Misc_First 143
#define LADef_miscElement 143 	// 
#define LADef_miscYear 144 	// 
#define LGDef_Misc_Last 144

#define LGDef_ProperName_First 145
#define LADef_pnCheng 145 	// 
#define LADef_pnDi 146 	// 
#define LADef_pnDian 147 	// 
#define LADef_pnHou 148 	// 
#define LADef_pnMing 149 	// ()
#define LADef_pnMing2 150 	// 
#define LADef_pnQian 151 	// 
#define LADef_pnShang 152 	// 
#define LADef_pnWai 153 	// 
#define LADef_pnXing 154 	// 
#define LADef_pnYi 155 	// 
#define LADef_pnLianMing 156 	// 
#define LADef_pnAction 157 	// 
#define LADef_pnChengWei 158 	// 
#define LADef_pnNoTM 159 	// 
#define LADef_pnPaiHang 160 	// 
#define LADef_pnNoFHead 161 	// 
#define LADef_pnNoFTail 162 	// 
#define LADef_pnXingZhi 163 	// 
#define LGDef_ProperName_Last 163

// Define the MaxID of Lex Attributes
#define LADef_MaxID 163


// Define the ID of Features
#define LFDef_verbModifier 1 	// 
#define LFDef_verbObject 2 	// 
#define LFDef_iwbPhr 3 	// IWordBreaker Phrase

// Define the MaxID of Lex Features
#define LFDef_MaxID 3


#endif // _LEXPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\iwordbreaker.h ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: WordBreaker.h    
Purpose:   Declaration of the CIWordBreaker
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/

#ifndef __IWordBreaker_H_
#define __IWordBreaker_H_

extern "C" const IID IID_IWordBreaker;
class CUnknown;
class CWBEngine;
class CWordLink;
struct CWord;

// CIWordBreaker
class CIWordBreaker : public CUnknown,
                      public IWordBreaker
{

public:	
	// Creation
	static HRESULT CreateInstance(IUnknown* pUnknownOuter,
	                              CUnknown** ppNewComponent ) ;

private:
    DECLARE_IUNKNOWN

    // Nondelegating IUnknown
	virtual HRESULT __stdcall 
		NondelegatingQueryInterface( const IID& iid, void** ppv) ;

    // Initialization
	virtual HRESULT Init() ;

	// Cleanup
	virtual void FinalRelease() ;

    // IWordBreaker
	STDMETHOD(Init)( 
            /* [in] */ BOOL fQuery,
            /* [in] */ ULONG ulMaxTokenSize,
            /* [out] */ BOOL __RPC_FAR *pfLicense);

    STDMETHOD(BreakText)( 
            /* [in] */ TEXT_SOURCE __RPC_FAR *pTextSource,
            /* [in] */ IWordSink __RPC_FAR *pWordSink,
            /* [in] */ IPhraseSink __RPC_FAR *pPhraseSink);
        
    STDMETHOD(ComposePhrase)( 
            /* [size_is][in] */ const WCHAR __RPC_FAR *pwcNoun,
            /* [in] */ ULONG cwcNoun,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pwcModifier,
            /* [in] */ ULONG cwcModifier,
            /* [in] */ ULONG ulAttachmentType,
            /* [size_is][out] */ WCHAR __RPC_FAR *pwcPhrase,
            /* [out][in] */ ULONG __RPC_FAR *pcwcPhrase);
        
    STDMETHOD(GetLicenseToUse)( 
            /* [string][out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcsLicense);

private:    
	CIWordBreaker(IUnknown* pUnknownOuter);

    ~CIWordBreaker();

    // Put all word in m_pLink to IWordSink
    SCODE PutWord(IWordSink *pWordSink, DWORD& cwchSrcPos, DWORD cwchText, BOOL fEnd);
    // Put all word in m_pLink to IPhraseSink
    SCODE PutPhrase(IPhraseSink *pPhraseSink, DWORD& cwchSrcPos, DWORD cwchText, BOOL fEnd);
    // Put all word in m_pLink to both IWordBreaker and IPhraseSink
    SCODE PutBoth(IWordSink *pWordSink, IPhraseSink *pPhraseSink,
                  DWORD& cwchSrcPos, DWORD cwchText, BOOL fEnd);
    // PutWord() all of the pWord's child word 
    SCODE PutAllChild(IWordSink *pWordSink, CWord* pWord,
                     ULONG cwchSrcPos, ULONG cwchPutWord);
    
    //	Load the lexicon and charfreq resource into memory
    BOOL CIWordBreaker::fOpenLexicon(void);

protected:
    LPBYTE      m_pbLex;
	CWBEngine*	m_pEng;
	CWordLink*	m_pLink;
    ULONG       m_ulMaxTokenSize;
    BOOL        m_fQuery;
    BOOL        m_fInit;
    LPWSTR      m_pwchBuf;
	// Mutex to protect member access
	HANDLE m_hMutex ;
	// Handle to the free threaded marshaller
	IUnknown* m_pIUnknownFreeThreadedMarshaler ;
};

#endif //__WordBreaker_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\lexdef.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  LexDef
Purpose:    Declare the file structure of lexicon.
            This is only a header file w/o any CPP, this header will be included
            by both Lexicon and LexMan module.          
Notes:      We drop this file in Engine sub project only because we want to make 
            Engine code self-contained
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/5/97
============================================================================*/
#ifndef _LEXDEF_H_
#define _LEXDEF_H_

// define Unicode character blocks
#define LEX_LATIN_FIRST     0x0020
#define LEX_LATIN_LAST      0x00bf
#define LEX_GENPUNC_FIRST   0x2010
#define LEX_GENPUNC_LAST    0x2046
#define LEX_NUMFORMS_FIRST  0x2153
#define LEX_NUMFORMS_LAST   0x2182
#define LEX_ENCLOSED_FIRST  0x2460
#define LEX_ENCLOSED_LAST   0x24ea
#define LEX_CJKPUNC_FIRST   0x3000
#define LEX_CJKPUNC_LAST    0x33ff
#define LEX_CJK_FIRST       0x4e00
#define LEX_CJK_LAST        0x9fff
#define LEX_FORMS_FIRST     0xff01
#define LEX_FORMS_LAST      0xff64

// basic latin  [0x20,0x7e]
#define LEX_IDX_OFST_LATIN   0
#define LEX_LATIN_TOTAL      (LEX_LATIN_LAST - LEX_LATIN_FIRST + 1)
// General punctuation [0x2010,0x2046]
#define LEX_IDX_OFST_GENPUNC (LEX_IDX_OFST_LATIN + LEX_LATIN_TOTAL)
#define LEX_GENPUNC_TOTAL    (LEX_GENPUNC_LAST - LEX_GENPUNC_FIRST + 1)
// Number Forms :  ...
#define LEX_IDX_OFST_NUMFORMS   (LEX_IDX_OFST_GENPUNC + LEX_GENPUNC_TOTAL)
#define LEX_NUMFORMS_TOTAL      (LEX_NUMFORMS_LAST - LEX_NUMFORMS_FIRST + 1)
// Enclosed Alphanumerics; ... ... ...
#define LEX_IDX_OFST_ENCLOSED   (LEX_IDX_OFST_NUMFORMS + LEX_NUMFORMS_TOTAL)
#define LEX_ENCLOSED_TOTAL      (LEX_ENCLOSED_LAST - LEX_ENCLOSED_FIRST + 1)
// CJK symbols and punctuation [0x3000,0x301f]
#define LEX_IDX_OFST_CJKPUNC (LEX_IDX_OFST_ENCLOSED + LEX_ENCLOSED_TOTAL)
#define LEX_CJKPUNC_TOTAL    (LEX_CJKPUNC_LAST - LEX_CJKPUNC_FIRST + 1)
// CJK unified idographs [0x4e00,0x9fff]
#define LEX_IDX_OFST_CJK     (LEX_IDX_OFST_CJKPUNC + LEX_CJKPUNC_TOTAL)
#define LEX_CJK_TOTAL        (LEX_CJK_LAST - LEX_CJK_FIRST + 1)
// halfwidth and fullwidth forms [0xff01,0xff64]
#define LEX_IDX_OFST_FORMS   (LEX_IDX_OFST_CJK + LEX_CJK_TOTAL)
#define LEX_FORMS_TOTAL      ((LEX_FORMS_LAST - LEX_FORMS_FIRST + 1) + 1)

#define LEX_IDX_OFST_OTHER   (LEX_IDX_OFST_FORMS + LEX_FORMS_TOTAL)
#define LEX_INDEX_COUNT      (LEX_IDX_OFST_OTHER + 1)

// define encoding/decodeing magic number
#define LEX_CJK_MAGIC       0x5000
#define LEX_LATIN_MAGIC     0x8000
#define LEX_GENPUNC_MAGIC   (LEX_LATIN_MAGIC + LEX_LATIN_TOTAL)
#define LEX_NUMFORMS_MAGIC  (LEX_GENPUNC_MAGIC + LEX_GENPUNC_TOTAL)
#define LEX_ENCLOSED_MAGIC  (LEX_NUMFORMS_MAGIC + LEX_NUMFORMS_TOTAL)
#define LEX_CJKPUNC_MAGIC   (LEX_ENCLOSED_MAGIC + LEX_ENCLOSED_TOTAL)
#define LEX_FORMS_MAGIC     0xff00
// all encoded word in lex would has MostSignificant set to 1
#define LEX_MSBIT       0x8000
// no lex flag and offset mask for lex index item
#define LEX_INDEX_NOLEX 0x80000000
#define LEX_OFFSET_MASK 0x7fffffff

/*============================================================================
Struct  CRTLexHeader
Desc:   File header of lexicon. The offset of both Index and Lex data section will be 
        defined, and some version info are also defined in this structure
============================================================================*/
#pragma pack(1)

struct CRTLexHeader
{
    DWORD   m_dwVersion;
    DWORD   m_ofbIndex;         // Offset of Index section, it's the length of CLexHeader
    DWORD   m_ofbText;          // Offset of Lex section
    DWORD   m_ofbProp;          // property, attributes and index of feature set
    DWORD   m_ofbFeature;
    DWORD   m_cbLexSize;        // size of the whole lexicon
};

/*============================================================================
Struct  CRTLexIndex
Desc:   Index node data structure
        (m_dwIndex & 0x80000000), if no multi-char word in lexicon.
        Use (m_dwIndex & 0x7FFFFFFF) to keep tracking the position in lex section
        The offset is count in 2 bytes, bytes offset = (m_ofwLex * 2) (same as WIC)
        For words with no property, just set m_ofbProp = 0
============================================================================*/
struct CRTLexIndex
{
    DWORD   m_ofwLex;   // offset in the lex area count by WORD !
    DWORD   m_ofbProp;  // offset in the property area
};

/*============================================================================
Struct  CRTLexRec
Desc:   Structure of word mark of multi-char word in the lexicon
        For words with no property, just set m_ofbProp = 0
============================================================================*/
struct CRTLexRec
{
    DWORD   m_ofbProp;      // Both HiWord and LoWord's high bit == 0
    // follows by the lex text
    // WCHAR m_rgchLex[];
};

/*============================================================================
Struct  CRTLexProp
Desc:   Structure of lex property
============================================================================*/
struct CRTLexProp
{
    WORD    m_iWordID;
    // WORD m_wFlags;       // more property of lex can be add here
    USHORT  m_ciAttri;
    USHORT  m_ciFeature;
    // follows the attributes and feature index
    // USHORT m_rgAttri[];
    // CRTLexFeature m_rgFertureIndex[];
};

/*============================================================================
Struct  CRTLexFeature
Desc:   Structure of lex feature index
============================================================================*/
struct CRTLexFeature
{
    USHORT  m_wFID;
    USHORT  m_cwchLen;
    DWORD   m_ofbFSet;  // offset point to the feature area
};

/*============================================================================
The feature text of lex stored as "abcd\0efgh\0ijk\0...."
There is no separators between features, also no separators between lex feature sets
============================================================================*/

#pragma pack()


#endif // _LEXDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\jargon1.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CJargon
Purpose:    Implement process control and public functions in CJargon class
            There are a lot of tasks to do in Jargon moudle:
            1. Name of palce (Jargon1.cpp)
            2. Name of foreign person and places (Jargon1.cpp)
            3. Name of orgnizations (Jargon1.cpp)
            4. Name of HanZu person (Jargon1.cpp)               
Notes:      The CJargon class will be implemented in several cpp files:
            Jargon.cpp, Jargon1.cpp, Jargon2.cpp
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "jargon.h"
#include "lexicon.h"
#include "wordlink.h"
#include "fixtable.h"
#include "proofec.h"
#include "lexprop.h"
#include "scchardef.h"

#define PN_UNMERGE  0
#define PN_MERGED   1
#define PN_ERROR    2


/*============================================================================
CJargon::fIdentifyProperNames():
    Control function for proper names identification
Returns:
    TRUE if successful.
    FALSE if runtime error and set error code in m_iecError
============================================================================*/
BOOL CJargon::fIdentifyProperNames()
{
    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);
    assert(*(m_pLink->pwchGetText()) != 0);

    m_pWord = m_pLink->pGetHead();
    assert(m_pWord && m_pWord->pwchGetText() == m_pLink->pwchGetText());

    if (m_pWord->fIsTail()) {
        return TRUE; // Single word sentence
    }

    // Scan pass for name of place and organization
    for (; m_pWord; m_pWord = m_pWord->pNextWord()) {
       if (fHanPlaceHandler()) {
            continue;
        }
        fOrgNameHandler();
    }

    // Scan pass for foreign name
    m_pWord = m_pLink->pGetHead();
    for(; m_pWord && !m_pWord->fIsTail(); m_pWord = m_pWord->pNextWord()) {
        CWord* pTail;
        // Merge  + 
        if (fChengWeiHandler()) {
            continue;
        }

        // Handle foreign name
        if (m_pWord->fGetAttri(LADef_pnWai) && 
            !m_pWord->fGetAttri(LADef_pnNoFHead)) {
            if (fGetForeignString(&pTail)) {
                //_DUMPLINK(m_pLink, m_pWord);
                continue;
            } else if (pTail && m_pWord->pNextWord() != pTail &&
                       fForeignNameHandler(pTail)) {
                //_DUMPLINK(m_pLink, m_pWord);
                continue;
            } else {
            }
        }

        // Handle HanZu person name
        fHanPersonHandler();
    }
    return TRUE;
}


/*============================================================================
CJargon::fHanPlaceHandler():
    PLACE: Handle name of HanZu places
Returns:
    TRUE if success
    FALSE if runtime error, error code in m_iecError
============================================================================*/
inline BOOL CJargon::fHanPlaceHandler()
{
    CWord*  pTailWord;
    int     nMerge;

    assert(m_iecError == PRFEC::gecNone);
    if (m_pWord->fIsTail() || 
        !m_pWord->fGetAttri(LADef_pnYi) &&
        !m_pWord->fGetAttri(LADef_nounPlace)) {
        return FALSE; // fired by  or 
    }
        
    if (m_pWord->fGetAttri(LADef_nounPlace)) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pnDi)) {
            // *{} + <> => Merge(1,2);
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_nounPlace);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return TRUE;
        } else {
            return FALSE;
        }
    }
    
    if (fInTable(m_pWord, m_ptblPlace)) {
        // *# => Merge
        if (!m_pWord->fIsTail() && 
            ( m_pWord->pNextWord()->fGetAttri(LADef_pnDi) ||
              m_pWord->pNextWord()->fGetAttri(LADef_nounPlace) ) ) {
            // *# + [<>, {}] => Merge(1,2); 
            m_pLink->MergeWithNext(m_pWord, FALSE);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
        }
        m_pWord->SetAttri(LADef_nounPlace);
        m_pWord->SetAttri(LADef_posN);
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }

    assert(m_pWord->fGetAttri(LADef_pnYi) && !m_pWord->fIsTail());
    if (m_pWord->fIsHead()) {
        return FALSE;
    }

    // Find tail of a likely place name
    pTailWord = m_pWord->pNextWord();
    nMerge = 0;
    while (pTailWord &&
           pTailWord->fGetAttri(LADef_pnYi) &&
           !pTailWord->fGetAttri(LADef_pnDi)) {
        pTailWord = pTailWord->pNextWord();
        nMerge ++;
    }
    
    if (pTailWord == NULL) {
        return FALSE;
    }

    if (pTailWord->fGetAttri(LADef_pnDi)) {
        // The *# ended with 
        assert(m_pWord->pPrevWord());
        if (m_pWord->pPrevWord()->fGetAttri(LADef_nounPlace) ||
            m_pWord->pPrevWord()->fGetAttri(LADef_pnLianMing) &&
            !m_pWord->pPrevWord()->fIsHead() && 
            m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_nounPlace)) {
            // {} + *# + <> => Merge(2,3);
            // {} + [""] + *# + <> => Merge(3,4);
            // first merge all the *#, free the words been merged
            m_pWord = m_pLink->pRightMerge(m_pWord, nMerge, FALSE);
            // merge with the <>
            m_pLink->MergeWithNext(m_pWord, FALSE);

            // Add the *# into the table of place name
            assert(m_pWord->cwchLen() > 1);
            AddWordToTable(m_pWord, m_ptblPlace);

            if (!m_pWord->fIsTail() &&
                m_pWord->pNextWord()->fGetAttri(LADef_pnDi)) {
                // {} + [""] + *# + <> + <> => Merge(3,4,5); SetWordInfo(*, CIDDef::idEnumPlace, <>, {});
                // {} + *# + <> + <> => Merge(2,3,4); SetWordInfo(*, CIDDef::idEnumPlace, <>, {});
                m_pLink->MergeWithNext(m_pWord, FALSE);  // Merge the second <>
                //_DUMPLINK(m_pLink, m_pWord);
            } else {
                //_DUMPLINK(m_pLink, m_pWord);
            }
            m_pWord->SetAttri(LADef_posN);
            m_pWord->SetAttri(LADef_nounPlace);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            return TRUE;
        }
    }

    // The *# is not ended with <>
    if (nMerge &&
        !m_pWord->pPrevWord()->fIsHead() && !pTailWord->fIsTail() && 
        m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DUNHAO) &&   // ""
        m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_nounPlace) && 
        ( pTailWord->pNextWord()->fIsWordChar(SC_CHAR_DUNHAO) ||
          pTailWord->pNextWord()->fIsWordChar(SC_CHAR_DENG) ) ) {
        // {} + "" + *# + [""] => Merge(3); 
        // merge all the *#, free the words been merged
        m_pWord = m_pLink->pRightMerge(m_pWord, nMerge, FALSE);
        // Add the *# into the table of place name
        assert(m_pWord->cwchLen() > 1);
        AddWordToTable(m_pWord, m_ptblPlace);
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounPlace);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }

    return FALSE;
}


/*============================================================================
CJargon::fOrgNameHandler():
    handle Orgnization name identification
Returns:
    TRUE if success
    FALSE if runtime error, error code in m_iecError
============================================================================*/
#define MAX_UNKNOWN_TM  8
BOOL CJargon::fOrgNameHandler(void)
{
    BOOL    fOK = FALSE;    // Is any valid Org name found
    CWord*  pHead;          // Head of the Org name
    CWord*  pTry;           // Try to combind more words after a valid one found
    int     cwchTM;         // length of unknown trademark

    assert(m_iecError == PRFEC::gecNone && m_pWord);
    // Fired by <> or <>
    if (!m_pWord->fGetAttri(LADef_pnDian) &&
        !m_pWord->fGetAttri(LADef_nounOrg)) {
        return FALSE;
    }

    // Skip one or more <> words before current word
    pHead = m_pWord->pPrevWord(); 
    while (pHead && (pHead->fGetAttri(LADef_pnShang) || // []
           pHead->fGetAttri(LADef_numOrdinal) ||
           pHead->fGetAttri(LADef_numInteger)) ) {
        pHead = pHead->pPrevWord();
    }
    if (pHead == NULL) {
        goto gotoExit;
    }

    // continue to go backward
    if (pHead->fGetAttri(LADef_nounOrg) || pHead->fGetAttri(LADef_nounPlace)) {
        // [{},{}] + <>...<> + [<>, {}] => {}
        fOK = TRUE; // can be a valid Org name
        //_DUMPLINK(m_pLink, m_pWord);
    } else if (pHead->fGetAttri(LADef_nounTM)) {
        // {} + <>...<> + [<>, {}] => {}
        fOK = TRUE;
        //_DUMPLINK(m_pLink, m_pWord);
        pTry = pHead->pPrevWord();
        if (pTry && pTry->fGetAttri(LADef_nounPlace)) {
            // {} + {} + <>...<> + [<>, {}] => {}
            pHead = pTry; 
            //_DUMPLINK(m_pLink, m_pWord);
        } else {
            goto gotoExit;
        } // Terminate
    } else {
        // Try to locate a unknown trademark
        assert(pHead);  // protect from changes 
        pTry = pHead;   // keep this point for unknown trademark detection
        cwchTM = pHead->cwchLen();
        pHead = pHead->pPrevWord();
        while (1) {
            // search the {} or {} before unknown trademark, for better performance
            if (pHead == NULL || cwchTM > MAX_UNKNOWN_TM) {
                goto gotoExit;
            }
            if (pHead->fGetAttri(LADef_nounPlace) ||
                pHead->fGetAttri(LADef_nounOrg)) {
                break; // got it!
            }
            cwchTM += pHead->cwchLen();
            pHead = pHead->pPrevWord();
        }
        // Now we can check the unknown string between pHead(Excluded) to pTry(Incuded)
        while (pTry != pHead) {
            if (pTry->fGetFlag(CWord::WF_SBCS) || 
                pTry->fGetAttri(LADef_punPunct) ||
                pTry->fGetAttri(LADef_pnNoTM) ) {
                // Should not include some specific sort of word nodes
                goto gotoExit;
            }
            pTry = pTry->pPrevWord();
            assert(pTry != NULL); // impossible?
        }
        //_DUMPLINK(m_pLink, m_pWord);
        fOK = TRUE;
    }

    // Try to bind more words before the Org name just found
    assert(fOK && pHead); // A valid Org name has been found
    if ((pTry = pHead->pPrevWord()) == NULL) {
        goto gotoExit;
    }

    if (pTry->fGetAttri(LADef_nounOrg) || pTry->fGetAttri(LADef_nounPlace)) {
        // [{},{}] + (  ) => {}  One level is enough to bind all
        pHead = pTry;
        //_DUMPLINK(m_pLink, m_pWord);
    } else if (pTry->fGetAttri(LADef_pnShang) ||
               pTry->fGetAttri(LADef_numOrdinal) ||
               pTry->fGetAttri(LADef_numInteger)) {
        // [{},{}] + <>...<> + (  ) => {}
        pTry = pTry->pPrevWord(); 
        while (pTry && (pTry->fGetAttri(LADef_pnShang) ||
                        pTry->fGetAttri(LADef_numOrdinal) || 
                        pTry->fGetAttri(LADef_numInteger))) {
            pTry = pTry->pPrevWord(); // skip one or more <>
        }

        if (pTry == NULL) {
            goto gotoExit;
        }

        if (pTry->fGetAttri(LADef_nounOrg) ||
            pTry->fGetAttri(LADef_nounPlace)) {

            pHead = pTry; // Got it!
            //_DUMPLINK(m_pLink, m_pWord);
        }
    } else {
    }
    
gotoExit:
    if (fOK) { // A valid Org name found
        assert(pHead);
        // Merge words from pHead to m_pWord
        pTry = m_pWord->pNextWord();
        m_pWord = pHead;
        while (m_pWord->pNextWord() != pTry) {
            assert(pHead != NULL);
            m_pLink->MergeWithNext(m_pWord, FALSE);
        }
        assert(m_pWord->cwchLen() > 1); // Make sure the WMDef_wmChar mark was not lost
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounOrg);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }

    return FALSE;
}


/*============================================================================
CJargon::fGetForeignString()
    Get foreign string
Returns:
    TRUE if the is an multi-section foreign name found and merged
    FALSE if only one section found, and the word follows the last word node 
          in the likely foreign name will be returned in ppTail
Remarks:
    m_pWord is not moved!!!
============================================================================*/
inline BOOL CJargon::fGetForeignString(CWord** ppTail)
{
    CWord*  pWord;
    CWord*  pNext;
    CWord*  pHead;
    CWord*  pTail;
    BOOL    fOK, fAdd = FALSE;

    assert(m_iecError == PRFEC::gecNone);
    assert(!m_pWord->fIsTail() && m_pWord->fGetAttri(LADef_pnWai));
    
    // Test "A.St." previous to current word. 
    // Handle both DBCS point "" and SBCS point "."
    fOK = FALSE;
    pHead = m_pWord;
    if (!m_pWord->fIsHead() && !m_pWord->pPrevWord()->fIsHead() ) {
        pWord = m_pWord->pPrevWord();
        if ( (   (pWord->fIsWordChar(SC_CHAR_WAIDIAN) || 
                  pWord->fIsWordChar(SC_CHAR_SHUDIAN)  ) &&
                 pWord->pPrevWord()->fGetAttri(LADef_genDBForeign)
             ) ||
             (   pWord->fIsWordChar(SC_CHAR_ANSIDIAN) &&
                 pWord->pPrevWord()->fGetFlag(CWord::WF_SBCS) &&
                 pWord->pPrevWord()->fGetAttri(LADef_posN)
             ) ) {
            fOK = TRUE;
            pHead = pWord->pPrevWord();
            pWord = pHead->pPrevWord();
            if (pWord && !pWord->fIsHead()) {
                // to find the second backword foreign name section
                if( (   (pWord->fIsWordChar(SC_CHAR_WAIDIAN) || 
                         pWord->fIsWordChar(SC_CHAR_SHUDIAN)  ) &&
                        pWord->pPrevWord()->fGetAttri(LADef_genDBForeign)
                    ) ||
                    (   pWord->fIsWordChar(SC_CHAR_ANSIDIAN) &&
                        pWord->pPrevWord()->fGetFlag(CWord::WF_SBCS) &&
                        pWord->pPrevWord()->fGetAttri(LADef_posN)
                    ) ) {
                    pHead = pWord->pPrevWord();
                }
            } // End of if (pWord && !pWord->fIsHead())
        }
    }
    
    // Find the right boundary of the foreign name  
    pTail = m_pWord;
    pWord = m_pWord;
    pNext = m_pWord->pNextWord();
    while (1) {
        // Get a valid section
        while (pNext && pNext->fGetAttri(LADef_pnWai)) {
            if (!pNext->fGetAttri(LADef_pnNoFTail)) {
                pTail = pNext;
            }
            pNext = pNext->pNextWord();
        }
        if (pTail->pNextWord() != pNext) {
            break;
        }
        // Test more section
        if (pNext && !pNext->fIsTail() && 
            ( pNext->fIsWordChar(SC_CHAR_WAIDIAN) || 
              pNext->fIsWordChar(SC_CHAR_SHUDIAN) ||
              pWord->fIsWordChar(SC_CHAR_ANSIDIAN)
            ) && 
            ( pNext->pNextWord()->fGetAttri(LADef_pnWai) &&
              !pNext->pNextWord()->fGetAttri(LADef_pnNoFHead)
            ) ) {
            // A valid point foreign name separator
            fOK = TRUE;
            // Add this section to the foreign name list
            if (pWord->pNextWord() != pNext) { // don't add if only one word node
                assert((pNext->pwchGetText() - pWord->pwchGetText()) > 1);
                m_ptblForeign->cwchAdd(pWord->pwchGetText(),
                                       (UINT)(pNext->pwchGetText()-pWord->pwchGetText()));
            }
            pNext = pNext->pNextWord();
            pWord = pNext;
            pTail = pNext;          
        } else {
            //_DUMPLINK(m_pLink, pNext);
            break;
        }
        if (pNext->pNextWord()) {
            pNext = pNext->pNextWord();
        }
    } // end of while(1)

    // Add the last section to the foreign name list
    if (fOK && pWord != pTail) { // don't add if only one word node
        assert(pTail && (pTail->pwchGetText() - pWord->pwchGetText()) >= 1 && pTail->cwchLen());
        m_ptblForeign->cwchAdd(pWord->pwchGetText(),
                               (UINT)(pTail->pwchGetText() - pWord->pwchGetText() + pTail->cwchLen()));
    }

    pTail = pTail->pNextWord();

    if (fOK) { // More than one section in the foreign name, merge directly
        m_pWord = pHead;
        while (m_pWord->pNextWord() != pTail) {
            assert(m_pWord->pNextWord());
            m_pLink->MergeWithNext(m_pWord, FALSE);
        }
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
    }
    *ppTail = pTail;
    return fOK;
}


/*============================================================================
CJargon::fForeignNameHandler():
    Foreign proper name identification
Returns:
    TRUE if success
    FALSE if runtime error, error code in m_iecError
============================================================================*/
inline BOOL CJargon::fForeignNameHandler(CWord* pTail)
{
    BOOL    fOK;
    CWord*  pWord;
    int     nMerge = 0;

    assert(m_iecError == PRFEC::gecNone);
    assert(m_pWord->fGetAttri(LADef_pnWai) &&
            !m_pWord->fGetAttri(LADef_pnNoFHead) &&
            !m_pWord->fIsTail());

    if ((fOK = fInTable(m_pWord, m_ptblForeign))) { // In 
        pTail = m_pWord->pNextWord();
        if (pTail == NULL) {
            m_pWord->SetAttri(LADef_posN);
            m_pWord->SetAttri(LADef_nounTerm);
            //_DUMPLINK(m_pLink, m_pWord);
            return TRUE;
        }
        //_DUMPLINK(m_pLink, m_pWord);
    }

    // Try to decided what kind of name it is for a likely foreign name
    // Try name of person first:
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_pnQian)) {
        // <> + * => Merge()
        //_DUMPLINK(m_pLink, m_pWord);
        goto gotoMergePerson;
    }
    if (pTail->pNextWord() &&
        pTail->fGetAttri(LADef_pnHou)) {
        // * + <> => Merge()
        //_DUMPLINK(m_pLink, m_pWord);
        goto gotoMergePerson;
    }           
    if (!m_pWord->fIsHead() && !m_pWord->pPrevWord()->fIsHead() &&
        m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DE4) &&
        ( m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_pnDian) ||
          m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_nounPlace) ||
          m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_nounOrg) ) ) {
        // [<>,{}] + "" + * => Merge(), 
        // SetWordInfo(), AddForeignList()
        //_DUMPLINK(m_pLink, m_pWord);
        goto gotoMergePerson;
    }
    if (!pTail->fIsTail() &&
        (pTail->fGetAttri(LADef_punPunct)|| pTail->fIsWordChar(SC_CHAR_DENG))&&
        (m_pWord->fIsHead() || m_pWord->pPrevWord()->fGetAttri(LADef_punPunct))){
        // [{},<>] + * + [<>,""] => Merge(),
        // SetWordInfo(), AddForeignList()
        //_DUMPLINK(m_pLink, m_pWord);
        goto gotoMergePerson;
    }
    
    // Try name of place or organization
    if (!pTail->fIsTail()) {
        if (pTail->fGetAttri(LADef_pnShang) ||
            pTail->fGetAttri(LADef_nounOrg)) {
            // * + [<>,{}] => Merge()
            if (!fOK) { // Not in the foreign name list
                while (m_pWord->pNextWord() != pTail) {
                    m_pLink->MergeWithNext(m_pWord, FALSE);
                }
                AddWordToTable(m_pWord, m_ptblForeign);
            }
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_posN);
            m_pWord->SetAttri(LADef_nounTM);
            //_DUMPLINK(m_pLink, m_pWord);
            return TRUE;
        }
        if (pTail->fGetAttri(LADef_pnDian) && !m_pWord->fIsHead() && 
            ( m_pWord->pPrevWord()->fGetAttri(LADef_nounPlace) ||
              m_pWord->pPrevWord()->fGetAttri(LADef_nounOrg)) ) {
            // [{}{}] + * + <> => Merge(2,3)
            if (!fOK) {
                while (m_pWord->pNextWord() != pTail) {
                    m_pLink->MergeWithNext(m_pWord, FALSE);
                }
                AddWordToTable(m_pWord, m_ptblForeign);
            }
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
            m_pWord->SetAttri(LADef_nounOrg);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return TRUE;
        }
        if (pTail->fGetAttri(LADef_pnDi)) {
            // * + <> => Merge(1,2,3) mark as {}
            pTail = pTail->pNextWord();
            if (pTail && pTail->fGetAttri(LADef_pnDi)) {
                pTail = pTail->pNextWord();
            }
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMergePlace;
        }
    } // End of if(!pTail->fIsTail())

    if (!m_pWord->fIsHead()) {
        pWord = m_pWord->pPrevWord();
        if (pWord->fGetAttri(LADef_pnCheng)) {
            // <> + * => Mark(*) as <>
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMergePlace;
        }
        if (pWord->fGetAttri(LADef_nounPlace)) {
            // {} + * => Mark * as {}
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMergePlace;
        }
        if (pWord->fGetAttri(LADef_pnLianMing) && !pWord->fIsHead()) {
            if (pWord->pPrevWord()->fGetAttri(LADef_pnHou) ||
                pWord->pPrevWord()->fGetAttri(LADef_nounPerson) ) {
                // [,] + [""] + * => Merge(),
                // SetWordInfo(), AddForeignList()
                //_DUMPLINK(m_pLink, m_pWord);
                goto gotoMergePerson;
            } else if (pWord->pPrevWord()->fGetAttri(LADef_nounPlace)) {
                //_DUMPLINK(m_pLink, m_pWord);
                goto gotoMergePlace;
            } else {
            }
        }
    } // End of if(!m_pWord->fIsHead())
    
    if (fOK) { // Found in ForeignTable but could not identify which kind of name it is!
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounTerm);
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }

    if (pTail && (pTail->pwchGetText() - m_pWord->pwchGetText()) >= 4) {
        // very long 
        while (m_pWord->pNextWord() != pTail) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
        }
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounTerm);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }

    return FALSE;

gotoMergePlace:
    if (!fOK) {
        while (m_pWord->pNextWord() != pTail) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
        }
        AddWordToTable(m_pWord, m_ptblForeign);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
    }
    m_pWord->SetAttri(LADef_posN);
    m_pWord->SetAttri(LADef_nounPlace);
    //_DUMPLINK(m_pLink, m_pWord);
    return TRUE;

gotoMergePerson:
    if (!fOK) {
        while (m_pWord->pNextWord() != pTail) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
        }
        AddWordToTable(m_pWord, m_ptblForeign);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
    }
    m_pWord->SetAttri(LADef_posN);
    m_pWord->SetAttri(LADef_nounPerson);
    //_DUMPLINK(m_pLink, m_pWord);
    return TRUE;
}


/*============================================================================
CJargon::fHanPersonHandler():
    HanZu person name identification
Returns:
    TRUE if success
    FALSE if runtime error, error code in m_iecError
============================================================================*/
inline BOOL CJargon::fHanPersonHandler(void)
{
    CWord*  pTail = NULL;
    CWord*  pNext;
    CWord*  pPrev;
    USHORT  cwchLen;

    assert(m_iecError == PRFEC::gecNone);
    if ( m_pWord->fIsTail() || 
        ( !m_pWord->fGetAttri(LADef_pnXing) &&
          !m_pWord->fGetAttri(LADef_pnMing2)) ) {
        return FALSE;
    }

    cwchLen = m_pWord->fGetAttri(LADef_pnXing) ? m_pWord->cwchLen() : 0;
    if (fInTable(m_pWord, m_ptblName)) {
        // In 
        //_DUMPLINK(m_pLink, m_pWord);
        if ( (m_pWord->cwchLen() - cwchLen) == 1 &&
            !m_pWord->fIsTail() &&
            m_pWord->pNextWord()->fGetAttri(LADef_pnMing) &&
            !m_pWord->pNextWord()->fGetAttri(LADef_genCi) ) {
            // *# + <> => Merge(1,2);
            m_pLink->MergeWithNext(m_pWord, FALSE);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
        }
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounPerson);
        return TRUE;
    }

    if (m_pWord->fGetAttri(LADef_pnXing)) { // *<>
        assert(!m_pWord->fIsTail());
        pNext = m_pWord->pNextWord();
        if (!pNext->fIsTail() &&
            pNext->fGetAttri(LADef_pnMing) &&
            pNext->pNextWord()->fGetAttri(LADef_pnMing) ) {
            // *<> + <> + <>
            if ( (m_pWord->fGetFlag(CWord::WF_CHAR) &&
                !m_pWord->fGetAttri(LADef_genCi)) ||
                !pNext->fGetAttri(LADef_genCi) ||
                !pNext->pNextWord()->fGetAttri(LADef_genCi) ) {
                // *<> + <> + <> && [1,2,3] <> => Merge(1,2,3);
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pLink->MergeWithNext(m_pWord, FALSE);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_posN);
                m_pWord->SetAttri(LADef_nounPerson);
                // Add this name to the naming table
                AddWordToTable(m_pWord, m_ptblName);
                //_DUMPLINK(m_pLink, m_pWord);
                return TRUE;
            }
            // Need confirm
            pTail = pNext->pNextWord()->pNextWord();
            //_DUMPLINK(m_pLink, m_pWord);
        } else if (pNext->fGetAttri(LADef_pnMing) ||
                   pNext->fGetAttri(LADef_pnMing2)) { 
            // *<> + <: >
            if ((m_pWord->fGetFlag(CWord::WF_CHAR) &&
                !m_pWord->fGetAttri(LADef_genCi)) ||
                (pNext->fGetFlag(CWord::WF_CHAR) &&
                !pNext->fGetAttri(LADef_genCi)) ) {
                // *<> + <> && [1,2] <> => Merge(1,2);
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pWord->SetAttri(LADef_posN);
                m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                // Add this name to the naming table
                AddWordToTable(m_pWord, m_ptblName);
                //_DUMPLINK(m_pLink, m_pWord);
                return TRUE;
            }
            // Need confirm
            pTail = pNext->pNextWord();
            //_DUMPLINK(m_pLink, m_pWord);
        } else { 
            // Other cases for <>
            if (pNext->fGetAttri(LADef_pnHou) ||
                pNext->fGetAttri(LADef_pnXingZhi)) {
                // *<> + [<>, <>] => Merge(1,2);
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pWord->SetAttri(LADef_posN);
                m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                //_DUMPLINK(m_pLink, m_pWord);
                return TRUE;
            }
            if (!pNext->fIsTail() && pNext->fGetAttri(LADef_pnPaiHang) &&
                pNext->pNextWord()->fGetAttri(LADef_pnChengWei) ) {
                // *<> + # + # => Merge(1,2,3); 
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pWord->SetAttri(LADef_posN);
                m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                //_DUMPLINK(m_pLink, m_pWord);
                return TRUE;
            }
            if (!m_pWord->fIsHead() && 
                ( m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_XIAO) ||
                  m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_LAO)) ) {
                // [""] + *<> =>Merge(1,2);
                m_pWord = m_pWord->pPrevWord();
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pWord->SetAttri(LADef_posN);
                m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                //_DUMPLINK(m_pLink, m_pWord);
                return TRUE;
            }
        }
    } else {
        // *<>: 
        assert(m_pWord->fGetAttri(LADef_pnMing2));
        if (m_pWord->fGetAttri(LADef_nounPerson)) { // *{}
            if (m_pWord->pNextWord()->fGetAttri(LADef_pnMing)) { // *{} + <>
                // To be confirmed
                pTail = m_pWord->pNextWord()->pNextWord();
//                assert(pTail);
                //_DUMPLINK(m_pLink, m_pWord);
            } else {
                return TRUE;
            }
        }
    } // end of *<>

    // Could not fall in here w/ pTail == NULL!!!
    if (pTail == NULL) {
        return FALSE;
    }

    // Confirm the likely name of persons
    if (!m_pWord->fIsHead()) {
        pPrev = m_pWord->pPrevWord();
        if (pPrev->fGetAttri(LADef_pnQian) ||
            pPrev->fGetAttri(LADef_pnLianMing)) {
            // [<>, []] + *# => Merge(2...)
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMerge;
        }
        if (pPrev->fGetAttri(LADef_nounPerson) && pPrev->cwchLen() == 3) {
            // {} + *# (1 [""]) =>
            //_DUMPLINK(m_pLink, m_pWord);
            //goto gotoMerge;
        }
        if (pTail->pNextWord() &&
            pPrev->fGetAttri(LADef_punPunct) &&
            ( pTail->fGetAttri(LADef_punPunct) ||
              pTail->fGetAttri(LADef_pnLianMing)) ) {
            // <> + *# + [<>, ""] =>
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMerge;
        }
    }

    if (pTail->pNextWord()) {
        if (pTail->fGetAttri(LADef_pnHou)) { // *# + <> =>
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMerge;
        }
        if (pTail->fGetAttri(LADef_pnAction)) { // *# + <> =>
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMerge;
        }
    }

    return FALSE;  // No name found!

gotoMerge:
    while (m_pWord->pNextWord() != pTail) {
        m_pLink->MergeWithNext(m_pWord, FALSE);
    }
    m_pWord->SetAttri(LADef_posN);
    // Add this name to the naming table
    AddWordToTable(m_pWord, m_ptblName);
    if (!m_pWord->fIsTail() && 
        ( m_pWord->pNextWord()->fGetAttri(LADef_pnDian) ||
          m_pWord->pNextWord()->fGetAttri(LADef_nounOrg)) ) {
        // *#{} + [<>, {}] => Merge(1,2); SetWordInfo(*, 0, 0, {});
        m_pLink->MergeWithNext(m_pWord, FALSE);
        m_pWord->SetAttri(LADef_nounOrg);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }
    m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
    m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
    //_DUMPLINK(m_pLink, m_pWord);
    return TRUE;
}


/*============================================================================
Merge  + 
============================================================================*/
inline BOOL CJargon::fChengWeiHandler(void)
{
    assert(m_iecError == PRFEC::gecNone);

    if (m_pWord->fGetAttri(LADef_pnChengWei) && !m_pWord->fIsHead()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_pnPaiHang)) {
            // * +  => Merge(1,2); SetWordInfo(<>);
            // occurs 742 times in 20M corpus
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_pnQian);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return TRUE;
        }
    }
    return FALSE;
}


/*============================================================================
Service functions
============================================================================*/
// Add pWord to specific table
void CJargon::AddWordToTable(CWord* pWord, CFixTable* pTable)
{
    pTable->cwchAdd( pWord->pwchGetText(), pWord->cwchLen() );
}


// Check proper name table, and merge match words
BOOL CJargon::fInTable(CWord* pWord, CFixTable* pTable)
{
    CWord*  pNext = pWord->pNextWord();
    LPWSTR  pwchWord = pWord->pwchGetText();
    USHORT  cwchMatch, cwchLen = pWord->cwchLen();
    USHORT  ciWord = 0;

    cwchMatch = pTable->cwchMaxMatch(pwchWord, (UINT)(m_pLink->cwchGetLength() -
                                               ( pWord->pwchGetText() -
                                                 m_pLink->pwchGetText())));
    if (!cwchMatch) {
        return FALSE;
    }
    while (pNext && (cwchLen < cwchMatch)) {
        cwchLen += pNext->cwchLen();
        pNext = pNext->pNextWord();
        ciWord++;
    }
    if (cwchLen == cwchMatch) {
        // Match at word bounary, merge words
        for (cwchMatch = 0; cwchMatch < ciWord; cwchMatch++) {
            m_pLink->MergeWithNext(pWord, FALSE);
#ifdef LADef_iwbAltPhr
            pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        }
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\lexicon.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Module:     LEXICON
Prefix:     Lex
Purpose:    Declare the CLexicon object. CLexicon is used to manage the SC Lexicon
            for word breaker and proofreading process.
Notes:
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    5/28/97
============================================================================*/
#ifndef _LEXICON_H_
#define _LEXICON_H_

// Foreward declaration of structures and classes
struct CRTLexIndex;
struct CRTLexRec;
struct CRTLexProp;

/*============================================================================
Struct WORDINFO:
Desc:   Word information data structure, transfer word info from lexicon to it's user
Prefix: winfo
============================================================================*/
struct CWordInfo
{
    friend class CLexicon;

    public:        
        inline DWORD GetWordID() const { return m_dwWordID; };
        inline DWORD GetLexHandle( ) const { return m_hLex; };
        inline USHORT AttriNum() const { return m_ciAttri; };
        inline USHORT GetAttri( USHORT iAttri ) const { 
            assert (m_ciAttri == 0 || m_rgAttri != NULL);
            assert (iAttri < m_ciAttri);
            if (iAttri < m_ciAttri) {
                return m_rgAttri[iAttri]; 
            } else {
                return 0;
            }
        }

        // Query a specific attribute
        BOOL fGetAttri(USHORT iAttriID) const {
            assert (m_ciAttri == 0 || m_rgAttri != NULL);
            for (int i = 0; i < m_ciAttri && m_rgAttri[i] <= iAttriID; i++) {
                if (m_rgAttri[i] == iAttriID) {
                    return TRUE;
                }
            }
            return FALSE;
        }

    private:
        DWORD   m_dwWordID;     //  32 bit word id
        USHORT  m_ciAttri;
        USHORT* m_rgAttri;
        DWORD   m_hLex;

};

/*============================================================================
Class CLexicon:
Desc:   Declare the lexicon class
Prefix: lex
============================================================================*/
class CLexicon
{
    public:
        //  Constructor
        CLexicon();
        //  Destructor
        ~CLexicon();

        //  fInit: load the LexHeader and calculate the offset of index and lex section
        //  Return FALSE if invalid LexHeader 
        BOOL fOpen(BYTE* pbLexHead);
        //  Close: clear current lexicon setting, file closed by LangRes
        void Close(void);
        //  Get LexVersion
        DWORD dwGetLexVersion(void) const {
            return m_dwLexVersion; 
        }

        //  fGetCharInfo: get the word info of the given single char word
        BOOL fGetCharInfo(const WCHAR wChar, CWordInfo* pwinfo);
        
        //  cchMaxMatch: lexicon based max match algorithm
        //  Return length of the matched string
        USHORT cwchMaxMatch(LPCWSTR pwchStart, 
                            const USHORT cwchLen, 
                            CWordInfo* pwinfo);
        /*============================================================================
        CLexicon::pwchGetFeature(): 
            retrieve the specific feature for given lex handle
        Returns:
            the feature buffer and length of the feature if found
            NULL if the feature was not found or invalid lex handle
        Notes:
            Because lexicon object does not know how to explain the feature buffer,
            to parse the feature buffer is the client's work.
        ============================================================================*/
        LPWSTR pwchGetFeature(const DWORD hLex, const USHORT iFtrID, USHORT* pcwchFtr) const;
        //  The following two functions involve the Lexicon in the Feature test format!!!
        //  Test whether the given SC character is included in a given feature
        BOOL fIsCharFeature(const DWORD hLex, const USHORT iFtrID, const WCHAR wChar) const;
        //  Test whether the given buffer is included in a given feature
        BOOL fIsWordFeature(const DWORD hLex, const USHORT iFtrID, 
                            LPCWSTR pwchWord, const USHORT cwchWord) const;

    private:
        DWORD           m_dwLexVersion; // Lex Version
        
        USHORT          m_ciIndex;      // Count of index entry
        CRTLexIndex*    m_rgIndex;      // index section
        WORD*           m_pwLex;        // lexicon section
        BYTE*           m_pbProp;       // property section
        BYTE*           m_pbFtr;        // feature text section
        //  Store the lenght of property and feature section for runtime address validation
        //  These two fields are only necessary to access feature by lex handle
        DWORD           m_cbProp;       // length of the property section
        DWORD           m_cbFtr;        // length of the feature text section

    private:

        //  Set WordInfo from lex index or lex record
        void SetWordInfo(DWORD ofbProp, CWordInfo* pwinfo) const;

        //  Calculate the index value from a Chinese char
        inline WORD wCharToIndex( WCHAR wChar );
        
        //  Decoding the Encoded WordID from the lexicon record
        DWORD dwWordIDDecoding(DWORD dwEncoded);

        // encoding the Unicode char wChar
        inline WCHAR wchEncoding(WCHAR wChar);

        // decoding the Unicode char from wEncoded
        WCHAR wchDecodeing(WCHAR wEncoded);

#ifdef DEBUG
        // Debugging functions that make the lexicon access safe 
    private:
        DWORD*  m_rgofbProp;
        DWORD   m_ciProp;
        DWORD   m_ciMaxProp;
        //  Verify the lexicon format for each word.
        BOOL fVerifyLexicon(DWORD cbSize);
        //  Expand prop offset array
        BOOL fExpandProp(void);
#endif // DEBUG

};

#endif  // #ifndef _LEXICON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\lexicon.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Module:     LEXICON
Prefix:     Lex
Purpose:    Implementation of the CLexicon object. CLexicon is used to manage 
            the SC Lexicon for word breaker and proofreading process.
Notes:
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    5/28/97
============================================================================*/
#include "myafx.h"
#include <limits.h>

#include "lexicon.h"
#include "lexdef.h"
#include "lexprop.h"    // for Dynamic version checking!

/*============================================================================
Implementation of Public member functions
============================================================================*/

// Constructor
CLexicon::CLexicon()
{
    m_ciIndex   = 0;
    m_rgIndex   = NULL;
    m_pwLex     = NULL;
    m_pbProp    = NULL;
    m_pbFtr     = NULL;
    m_cbProp    = 0;
    m_cbFtr     = 0;
}
    
//  Destructor
CLexicon::~CLexicon()
{
}


/*============================================================================
CLexicon::fInit()
    load the LexHeader and calculate the offset of index and lex section
Returns:
    FALSE if invalid LexHeader 
============================================================================*/
BOOL CLexicon::fOpen(BYTE* pbLexHead)
{
    assert(m_ciIndex == 0); // Catch duplicated initialization
    assert(pbLexHead);      // Catch invalid mapping address

    CRTLexHeader* pheader = (CRTLexHeader*)pbLexHead;
    // Validate the lexicon version
    if (pheader->m_dwVersion != LexDef_Version) {
        assert(0);
        return FALSE;
    }
    m_dwLexVersion = pheader->m_dwVersion;

    
    // Validate the lex header setting.
    // Only run in debug build because version checking in release build is enough
    assert(pheader->m_ofbIndex == sizeof(CRTLexHeader));
    assert(pheader->m_ofbText > pheader->m_ofbIndex);
    assert(((pheader->m_ofbText - pheader->m_ofbIndex) % sizeof(CRTLexIndex)) == 0);
    assert(pheader->m_ofbProp > pheader->m_ofbText);
    assert(pheader->m_ofbFeature > pheader->m_ofbProp);
    assert(pheader->m_cbLexSize >= pheader->m_ofbFeature);
    assert(((pheader->m_ofbText - pheader->m_ofbIndex) / sizeof(CRTLexIndex)) == LEX_INDEX_COUNT);

    m_ciIndex   = (USHORT)((pheader->m_ofbText - pheader->m_ofbIndex) / sizeof(CRTLexIndex));
    m_rgIndex   = (CRTLexIndex*)(pbLexHead + pheader->m_ofbIndex);
    m_pwLex     = (WORD*)(pbLexHead + pheader->m_ofbText);
    m_pbProp    = (BYTE*)(pbLexHead + pheader->m_ofbProp);
    m_pbFtr     = (BYTE*)(pbLexHead + pheader->m_ofbFeature);
    // Because I expose the offset of the lex property as a handle to the client,
    // I have to perform runtime address checking to protect from invalid handle
    // To store the size of feature text section is for this checking
    m_cbProp    = pheader->m_ofbFeature - pheader->m_ofbProp;
    m_cbFtr     = pheader->m_cbLexSize - pheader->m_ofbFeature;

#ifdef DEBUG
    // Verify the lexicon in debug build. It will take a long init time!!!
    if (!fVerifyLexicon(pheader->m_cbLexSize)) {
        assert(0);
        return FALSE;
    }
#endif // DEBUG
    
    return TRUE;
}


/*============================================================================
CLexicon::Close()
    clear current lexicon setting, file closed by LangRes
============================================================================*/
void CLexicon::Close(void)
{
    m_ciIndex   = 0;
    m_rgIndex   = NULL;
    m_pwLex     = NULL;
    m_pbProp    = NULL;
    m_pbFtr     = NULL;
    m_cbProp    = 0;
    m_cbFtr     = 0;
}
    
#pragma optimize("t", on)
/*============================================================================
CLexicon::fGetCharInfo(): 
    get the word info of the given single char word
============================================================================*/
BOOL CLexicon::fGetCharInfo(const WCHAR wChar, CWordInfo* pwinfo)
{
    assert(m_ciIndex != 0);
    assert(pwinfo);

    USHORT idx = wCharToIndex(wChar);
    if (idx >= m_ciIndex) {
        return FALSE;
    }

    SetWordInfo(m_rgIndex[idx].m_ofbProp, pwinfo);
    return TRUE;
}

// Hack:  define a static const attribute of LADef_genDBForeign
static const USHORT LA_DBForeign = LADef_genDBForeign;
        
/*============================================================================
CLexicon::cwchMaxMatch(): 
    lexicon based max match algorithm
Returns:
    length of the matched string
Notes:
    chars in pwchStart must be Unicode.
    English words 
============================================================================*/
USHORT CLexicon::cwchMaxMatch(
                     LPCWSTR pwchStart, 
                     USHORT cwchLen,
                     CWordInfo* pwinfo )
{
    WORD    wC1Seat;        // Position of the first char in the index array
    WORD    wcChar;         // WORD encoded of char
    
    assert(m_ciIndex != 0); // Catch uninitialized call
    
    assert(pwchStart && cwchLen); // Catch invalid input buffer
    assert(pwinfo); // catch NULL pointer
    
    if (cwchLen == 0) {
        assert(0);
        return (USHORT)0;
    }
    
    // Locate the first character in the index
    wC1Seat = wCharToIndex(*pwchStart);
    
    // Hack: for foreign character, fill pwinfo manually,
    //       and point to a LADef_genDBForeign attribute
    if (wC1Seat == LEX_IDX_OFST_OTHER) {
        pwinfo->m_dwWordID = 0;
        pwinfo->m_ciAttri = 1;
        pwinfo->m_rgAttri = const_cast<USHORT*>(&LA_DBForeign);
        pwinfo->m_hLex = m_rgIndex[wC1Seat].m_ofbProp;
        return (USHORT)1;
    }

    if (cwchLen == 1 || 
        (m_rgIndex[wC1Seat].m_ofwLex & LEX_INDEX_NOLEX) ||
        ((wcChar = wchEncoding( *(pwchStart+1) )) == 0) ) {
        SetWordInfo(m_rgIndex[wC1Seat].m_ofbProp, pwinfo);
        return (USHORT)1;
    }
    
    LPCWSTR pwchEnd;
    LPCWSTR pwchSrc;
    DWORD   dwLexStart;     // Start of the lex range
    DWORD   dwLexEnd;       // end of the lex range
    DWORD   dwLexPos;       // position of the entry head in the lexicon

    DWORD   dwlow;
    DWORD   dwmid;
    DWORD   dwhigh;
    DWORD   cwLexRec = sizeof(CRTLexRec) / sizeof(WORD);

    USHORT  cwcMatchLen;
    USHORT  cwcMaxMatch;
        
    assert(wcChar);
    // prepare to match more characters
    pwchSrc = pwchStart + 1;
    pwchEnd = pwchStart + cwchLen;
    // Get the lex range
    dwLexStart = m_rgIndex[wC1Seat].m_ofwLex;
    dwLexEnd = m_rgIndex[wC1Seat+1].m_ofwLex & (~LEX_INDEX_NOLEX);
    assert((dwLexStart + cwLexRec) < dwLexEnd );   // at least one char
    
    /***************************************************
    *   Binary search for any C2 match in the lexicon
    ****************************************************/
    dwlow = dwLexStart;
    dwhigh = dwLexEnd;
    dwLexPos = UINT_MAX;    // as a flag to identify whether C2 matched
    while (dwlow < dwhigh) {
        dwmid = (dwlow + dwhigh) / 2;
        while (m_pwLex[dwmid] & LEX_MSBIT) {
            dwmid--;    // search head of the word
        }
        while ( !(m_pwLex[dwmid] & LEX_MSBIT) ) {
            dwmid++;    // dwmid fall in word mark fields
        }
        
        if (wcChar > m_pwLex[dwmid]) {
            while ( (dwmid < dwLexEnd) && (m_pwLex[dwmid] & LEX_MSBIT) ) {
                dwmid++;    // search head of next word
            }
            dwlow = dwmid;
            continue;   
        }

        if (wcChar < m_pwLex[dwmid]) {   
            dwhigh = dwmid - cwLexRec; // no overflow here !
            continue;   
        }

        if (wcChar == m_pwLex[dwmid]) {  
            dwLexPos = dwmid - cwLexRec;
            break;      
        }
    }

    if (dwLexPos == UINT_MAX) {
        // No C2 match
        SetWordInfo(m_rgIndex[wC1Seat].m_ofbProp, pwinfo);
        return (USHORT)1;
    }
    
    /***************************************
    *   Try to match the max word from C2
    ****************************************/
    dwlow = dwLexPos;
    dwhigh = dwLexPos;  // store the C2 match position for backward search
    dwLexPos = UINT_MAX;    // use the special value as the flag of match
    cwcMaxMatch = 0;
    
    // search forward first
    while (TRUE) {
        // Current direction test
        dwmid = dwlow + cwLexRec;
        pwchSrc = pwchStart + 1;

        while (TRUE) {
            wcChar = wchEncoding( *pwchSrc );
            if (wcChar == m_pwLex[dwmid]) {  
                dwmid ++;   
                if( !(m_pwLex[dwmid] & LEX_MSBIT)  || dwmid == dwLexEnd) { // Full match
                    cwcMatchLen = (BYTE)(dwmid - dwlow - cwLexRec + 1);
                    dwLexPos = dwlow;
                    break;  
                }
                pwchSrc ++;
                if (pwchSrc < pwchEnd) {
                    continue;
                }
            }
            break;  
        }

        if ( wcChar > m_pwLex[dwmid] &&          // Optimization!!! current lex too small 
            cwcMaxMatch <= (dwmid - dwlow) &&   // match parts in NOT shorter and shorter
            pwchSrc < pwchEnd ) {      // of course there are chars left in the string to be matched

            cwcMaxMatch = (BYTE)(dwmid - dwlow);
            // step forward to next lex entry
            while ((dwmid < dwLexEnd) && (m_pwLex[dwmid] & LEX_MSBIT)) {
                dwmid++;
            }
            dwlow = dwmid;
        } else {
            break;
        }
    }

    // search backward if necessary
    while (dwLexPos == UINT_MAX && dwhigh > dwLexStart) { // control no overflow here
        while (m_pwLex[dwhigh-1] & LEX_MSBIT) {
            dwhigh--; // back to previous word head
        }
        dwmid = dwhigh;
        pwchSrc = pwchStart + 1;
        wcChar = wchEncoding( *pwchSrc );
        
        while (wcChar == m_pwLex[dwmid] && pwchSrc < pwchEnd) {
            dwmid++;
            if ( !(m_pwLex[dwmid] & LEX_MSBIT) ) {
                cwcMatchLen = (BYTE)(dwmid - dwhigh + 1);
                dwLexPos = dwhigh - cwLexRec;
                break;
            }
            pwchSrc ++;
            wcChar = wchEncoding( *pwchSrc );
        }
        if (dwmid == dwhigh)  {// C2 can not match any more
            break;
        }
        dwhigh -= cwLexRec;
    }
    
    // if no multi-char word is matched
    if ( dwLexPos == UINT_MAX ) {
        SetWordInfo(m_rgIndex[wC1Seat].m_ofbProp, pwinfo);
        return (USHORT)1;
    } else {
        // fill multi-char wrd info structure
        SetWordInfo(dwWordIDDecoding(((CRTLexRec*)(&m_pwLex[dwLexPos]))->m_ofbProp), pwinfo);
        return (cwcMatchLen);
    }
}


/*============================================================================
CLexicon::pwchGetFeature(): 
    retrieve the specific feature for given lex handle
Returns:
    the feature buffer and length of the feature if found
    NULL if the feature was not found or invalid lex handle
Notes:
    Because lexicon object does not know how to explain the feature buffer,
    to parse the feature buffer is the client's work.
============================================================================*/
LPWSTR CLexicon::pwchGetFeature(
                    const DWORD hLex, 
                    const USHORT iFtrID, 
                    USHORT* pcwchFtr) const
{
    *pcwchFtr = 0;
    if ((hLex + sizeof(CRTLexProp)) >= m_cbProp) {
        assert(0);
        return NULL;
    }
    CRTLexProp* pProp = (CRTLexProp*)(m_pbProp + hLex);
    if ( pProp->m_ciFeature == 0 || 
         (hLex + sizeof(CRTLexProp) + pProp->m_ciAttri * sizeof(USHORT) + 
         pProp->m_ciFeature * sizeof(CRTLexFeature)) >= m_cbProp) {
        assert(pProp->m_ciFeature == 0);
        return NULL;
    }
    CRTLexFeature* pFtr=(CRTLexFeature*)((USHORT*)(pProp +1)+ pProp->m_ciAttri);
    int lo = 0, mi, hi = pProp->m_ciFeature - 1;
    LPWSTR pwchFtr = NULL;
    if (pProp->m_ciFeature <= 10) { // Using linear search for small feature array
        while (lo <= hi && pFtr[lo].m_wFID < iFtrID) {
            lo++;
        }
        if (pFtr[lo].m_wFID == iFtrID && 
            (pFtr[lo].m_ofbFSet + pFtr[lo].m_cwchLen * sizeof(WCHAR)) <= m_cbFtr){
            pwchFtr = (LPWSTR)(m_pbFtr + pFtr[lo].m_ofbFSet);
            *pcwchFtr = pFtr[lo].m_cwchLen;
//            assert(pwchFtr[*pcwchFtr - 1] == L'\0');
        } else {
            assert(pFtr[lo].m_wFID > iFtrID);
        }
    } else { // Using binary search for large feature array
        while (lo <= hi) {
            mi = (lo + hi) / 2;
            if (iFtrID < pFtr[mi].m_wFID) {
                hi = mi - 1;
            } else if(iFtrID > pFtr[mi].m_wFID) {
                lo = mi + 1;
            } else { // match!!!
                if ((pFtr[mi].m_ofbFSet + pFtr[mi].m_cwchLen * sizeof(WCHAR)) 
                    <= m_cbFtr) {
                    pwchFtr = (LPWSTR)(m_pbFtr + pFtr[mi].m_ofbFSet);
                    *pcwchFtr = pFtr[mi].m_cwchLen;
                    assert(pwchFtr[*pcwchFtr - 1] == L'\0');
                    break;
                } else {
                    assert(0);
                }
            }
        } // end of while (lo <= hi)
    }
    return pwchFtr;
}


/*============================================================================
CLexicon::fIsCharFeature():
    Test whether the given SC character is included in a given feature
============================================================================*/
BOOL CLexicon::fIsCharFeature(
                  const DWORD  hLex, 
                  const USHORT iFtrID, 
                  const WCHAR  wChar) const
{
    LPWSTR  pwchFtr;
    USHORT  cwchFtr;
    if (NULL == (pwchFtr = pwchGetFeature(hLex, iFtrID, &cwchFtr))) {
        return FALSE;
    }
    for (USHORT ilen = 0; ilen < cwchFtr; ) {
        for (USHORT iwch = ilen; iwch < cwchFtr && pwchFtr[iwch]; iwch++) {
            ;
        }
        if ((iwch - ilen) == 1 && pwchFtr[ilen] == wChar){
            return TRUE;
        }
        ilen = iwch + 1;
    }
    return FALSE;
}


/*============================================================================
CLexicon::fIsWordFeature():
    Test whether the given buffer is included in a given feature
============================================================================*/
BOOL CLexicon::fIsWordFeature(
                  const DWORD hLex, 
                  const USHORT iFtrID, 
                  LPCWSTR pwchWord, 
                  const USHORT cwchWord) const
{
    assert(pwchWord);
    assert(cwchWord);

    LPWSTR  pwchFtr;
    USHORT  cwchFtr;

    if(NULL == (pwchFtr = pwchGetFeature(hLex, iFtrID, &cwchFtr))) {
        return FALSE;
    }
    // Only linear search here, assume no very large feature here
    assert(cwchFtr < 256); // less than 100 feature words
    for (USHORT ilen = 0; ilen < cwchFtr; ) {
        for (USHORT iwch = ilen; iwch < cwchFtr && pwchFtr[iwch]; iwch++) {
            ;
        }
        if (iwch - ilen == cwchWord) {
            for (iwch = 0; ; iwch++) {
                if (iwch == cwchWord) {
                    return TRUE;
                }
                if (pwchFtr[ilen + iwch] - pwchWord[iwch]) {
                    break;
                }
            }
            iwch = cwchWord;
        }
        ilen = iwch + 1;
    }
    return FALSE;
}

/*============================================================================
Implementation of Private member functions
============================================================================*/

/*============================================================================
CLexicon::SetWordInfo():
    Fill the CWordInfo structure by the lex properties
============================================================================*/
inline void CLexicon::SetWordInfo(DWORD ofbProp, CWordInfo* pwinfo) const
{
    assert((ofbProp + sizeof(CRTLexProp)) < m_cbProp);

    CRTLexProp* pProp = (CRTLexProp*)(m_pbProp + ofbProp);
    pwinfo->m_dwWordID = pProp->m_iWordID;
    pwinfo->m_ciAttri = pProp->m_ciAttri;
    pwinfo->m_rgAttri = NULL;
    if (pProp->m_ciAttri > 0) {
        assert((BYTE*)((USHORT*)(pProp + 1) + pProp->m_ciAttri) <= (m_pbProp + m_cbProp)); 
        pwinfo->m_rgAttri = (USHORT*)(pProp + 1);
    }
    pwinfo->m_hLex = ofbProp;
}


/*============================================================================
CLexicon::wCharToIndex():
    Calculate the index value from a Chinese char
============================================================================*/
inline WORD CLexicon::wCharToIndex(WCHAR wChar)
{ 
    if (wChar >= LEX_CJK_FIRST && wChar <= LEX_CJK_LAST) {
        // return LEX_IDX_OFST_CJK + (wChar - LEX_CJK_FIRST);
        // tuning speed
        return  wChar - (LEX_CJK_FIRST - LEX_IDX_OFST_CJK);

    } else if (wChar >= LEX_LATIN_FIRST && wChar <= LEX_LATIN_LAST) {
        // return LEX_IDX_OFST_LATIN + (wChar - LEX_LATIN_FIRST);
        return  wChar - (LEX_LATIN_FIRST - LEX_IDX_OFST_LATIN);

    } else if (wChar >= LEX_GENPUNC_FIRST && wChar <= LEX_GENPUNC_LAST) {
        // return LEX_IDX_OFST_GENPUNC + (wChar - LEX_GENPUNC_FIRST);
        return  wChar - (LEX_GENPUNC_FIRST - LEX_IDX_OFST_GENPUNC);

    } else if (wChar >= LEX_NUMFORMS_FIRST && wChar <= LEX_NUMFORMS_LAST) {
        // return LEX_IDX_OFST_NUMFORMS + (wChar - LEX_NUMFORMS_FIRST);
        return  wChar - (LEX_NUMFORMS_FIRST - LEX_IDX_OFST_NUMFORMS);

    } else if (wChar >= LEX_ENCLOSED_FIRST && wChar <= LEX_ENCLOSED_LAST) {
        // return LEX_IDX_OFST_ENCLOSED + (wChar - LEX_ENCLOSED_FIRST);
        return wChar - (LEX_ENCLOSED_FIRST - LEX_IDX_OFST_ENCLOSED);

    } else if (wChar >= LEX_CJKPUNC_FIRST && wChar <= LEX_CJKPUNC_LAST) {
        // return LEX_IDX_OFST_CJKPUNC + (wChar - LEX_CJKPUNC_FIRST);
        return  wChar - (LEX_CJKPUNC_FIRST - LEX_IDX_OFST_CJKPUNC);

    } else if (wChar >= LEX_FORMS_FIRST && wChar <= LEX_FORMS_LAST) {
        // return LEX_IDX_OFST_FORMS + (wChar - LEX_FORMS_FIRST);
        return  wChar - (LEX_FORMS_FIRST - LEX_IDX_OFST_FORMS);

    } else {
        return LEX_IDX_OFST_OTHER;
    }
}

    
/*============================================================================
CLexicon::dwWordIDDecoding():
    Decoding the Encoded WordID from the lexicon record
============================================================================*/
inline DWORD CLexicon::dwWordIDDecoding(DWORD dwStore)
{ 
    return ((dwStore & 0x7FFF0000) >> 1) + (dwStore & 0x7FFF); 
}

// encoding the Unicode char wChar
inline WCHAR CLexicon::wchEncoding(WCHAR wChar)
{
    if (wChar >= LEX_CJK_FIRST && wChar <= LEX_CJK_LAST) {
        return wChar + (LEX_CJK_MAGIC | ((WCHAR)LexDef_Version & 0x00ff));

    } else if (wChar >= LEX_LATIN_FIRST && wChar <= LEX_LATIN_LAST) {
        // return LEX_LATIN_MAGIC + (wChar - LEX_LATIN_FIRST);
        return wChar + (LEX_LATIN_MAGIC - LEX_LATIN_FIRST);

    } else if (wChar >= LEX_GENPUNC_FIRST && wChar <= LEX_GENPUNC_LAST) {
        // return LEX_GENPUNC_MAGIC + (wChar - LEX_GENPUNC_FIRST);
        return wChar + (LEX_GENPUNC_MAGIC - LEX_GENPUNC_FIRST);

    } else if (wChar >= LEX_NUMFORMS_FIRST && wChar <= LEX_NUMFORMS_LAST) {
        // return LEX_NUMFORMS_MAGIC + (wChar - LEX_NUMFORMS_FIRST);
        return wChar + (LEX_NUMFORMS_MAGIC - LEX_NUMFORMS_FIRST);

    } else if (wChar >= LEX_ENCLOSED_FIRST && wChar <= LEX_ENCLOSED_LAST) {
        // return LEX_ENCLOSED_MAGIC + (wChar - LEX_ENCLOSED_FIRST);
        return wChar + (LEX_ENCLOSED_MAGIC - LEX_ENCLOSED_FIRST);

    } else if (wChar >= LEX_CJKPUNC_FIRST && wChar <= LEX_CJKPUNC_LAST) {
        // return LEX_CJKPUNC_MAGIC + (wChar - LEX_CJKPUNC_FIRST);
        return wChar + (LEX_CJKPUNC_MAGIC - LEX_CJKPUNC_FIRST);

    } else if (wChar >= LEX_FORMS_FIRST && wChar <= LEX_FORMS_LAST) {
        // return LEX_FORMS_MAGIC + (wChar - LEX_FORMS_FIRST);
        return wChar - (LEX_FORMS_FIRST - LEX_FORMS_MAGIC);

    } else {
//        assert(0);
        return 0;
    }
}

// decoding the Unicode char from wEncoded
WCHAR CLexicon::wchDecodeing(WCHAR wEncoded)
{
    assert(wEncoded > LEX_LATIN_MAGIC);
    if (wEncoded >= (LEX_CJK_FIRST + (LEX_CJK_MAGIC | (LexDef_Version & 0x00ff))) &&
        wEncoded <= (LEX_CJK_FIRST + (LEX_CJK_MAGIC | (LexDef_Version & 0x00ff))+LEX_CJK_TOTAL)) {
        return wEncoded - (LEX_CJK_MAGIC | ((WCHAR)LexDef_Version & 0x00ff));

    } else if (wEncoded >= LEX_FORMS_MAGIC && wEncoded < LEX_FORMS_MAGIC + LEX_FORMS_TOTAL) {
        // return wEncoded - LEX_FORMS_MAGIC + LEX_FORMS_FIRST;
        return wEncoded + (LEX_FORMS_FIRST - LEX_FORMS_MAGIC);

    } else if (wEncoded < LEX_LATIN_MAGIC) {
        assert(0);
        return 0;

    } else if (wEncoded < LEX_GENPUNC_MAGIC) {
        // return wEncoded - LEX_LATIN_MAGIC + LEX_LATIN_FIRST;
        return wEncoded - (LEX_LATIN_MAGIC - LEX_LATIN_FIRST);

    } else if (wEncoded < LEX_NUMFORMS_MAGIC) {
        // return wEncoded - LEX_GENPUNC_MAGIC + LEX_GENPUNC_FIRST;
        return wEncoded - (LEX_GENPUNC_MAGIC - LEX_GENPUNC_FIRST);

    } else if (wEncoded < LEX_ENCLOSED_MAGIC) {
        // return wEncoded - LEX_NUMFORMS_MAGIC + LEX_NUMFORMS_FIRST;
        return wEncoded - (LEX_NUMFORMS_MAGIC - LEX_NUMFORMS_FIRST);

    } else if (wEncoded < LEX_CJKPUNC_MAGIC) {
        // return wEncoded - LEX_ENCLOSED_MAGIC + LEX_ENCLOSED_FIRST;
        return wEncoded - (LEX_ENCLOSED_MAGIC - LEX_ENCLOSED_FIRST);

    } else if (wEncoded < (LEX_CJKPUNC_MAGIC + LEX_CJKPUNC_TOTAL)) {
        // return wEncoded - LEX_CJKPUNC_MAGIC + LEX_CJKPUNC_FIRST;
        return wEncoded - (LEX_CJKPUNC_MAGIC - LEX_CJKPUNC_FIRST);

    } else {
        assert(0);
        return 0;
    }
}

#pragma optimize( "", on )

/*******************************************************************************************
*   Implementation of Private debugging member functions
*******************************************************************************************/
#ifdef DEBUG
/*============================================================================
CLexicon::fVerifyLexicon():
    Verify the lexicon format for each word.
============================================================================*/
BOOL CLexicon::fVerifyLexicon(DWORD cbSize)
{
    int     iret = FALSE;
    DWORD   idx;
    WCHAR*   pwTail;
    WCHAR*   pw1;
    WCHAR*   pw2;
    USHORT  cw1, cw2;
    CRTLexRec*  pLex;
    CRTLexProp* pProp;
    CRTLexFeature* pFtr;
    USHORT  ci;
    DWORD   ofbFtr;
    BOOL    fOK;

    // Initialize the prop offset array
    m_rgofbProp = NULL;
    m_ciProp = m_ciMaxProp = 0;
    // Verify index and lex section
    assert((m_rgIndex[0].m_ofwLex & LEX_OFFSET_MASK) == 0);

    for (idx = 0; idx < LEX_INDEX_COUNT-1; idx++) {
        if (m_rgIndex[idx].m_ofbProp != 0) {
            if (m_ciProp == m_ciMaxProp && !fExpandProp()) { 
                assert(0); 
                goto gotoExit; 
            }
            m_rgofbProp[m_ciProp++] = m_rgIndex[idx].m_ofbProp;
        }
        if (m_rgIndex[idx].m_ofwLex & LEX_INDEX_NOLEX) { // no multi-char lex!
            assert( (m_rgIndex[idx].m_ofwLex & LEX_OFFSET_MASK) == 
                     (m_rgIndex[idx + 1].m_ofwLex & LEX_OFFSET_MASK) ); // error lex offset!
            continue;
        }
        // Has multi-char lex!
        assert( (m_rgIndex[idx].m_ofwLex+ sizeof(CRTLexRec)/sizeof(WORD)+1)<=
                 (m_rgIndex[idx + 1].m_ofwLex & LEX_OFFSET_MASK) ); // error lex offset!
        pwTail = m_pwLex + (m_rgIndex[idx + 1].m_ofwLex & LEX_OFFSET_MASK);
        pLex = (CRTLexRec*)(m_pwLex + m_rgIndex[idx].m_ofwLex);
        if (pLex->m_ofbProp != 0) {
            if (m_ciProp == m_ciMaxProp && !fExpandProp()) {
                assert(0);
                goto gotoExit;
            }
            m_rgofbProp[m_ciProp++] = dwWordIDDecoding(pLex->m_ofbProp);
        }
        pw1 = (WORD*)(pLex + 1);
        for (cw1 = 0; (pw1 + cw1) < pwTail && (pw1[cw1] & LEX_MSBIT); cw1++) {
            ;   // to the next word
        }
        while ((pw1 + cw1) < pwTail) {
            assert((pw1 + cw1 + sizeof(CRTLexRec)/sizeof(WORD) +1)<=pwTail); // 0 size lex
            pLex = (CRTLexRec*)(pw1 + cw1);
            if (pLex->m_ofbProp != 0) {
                if (m_ciProp == m_ciMaxProp && !fExpandProp()) {
                    assert(0);
                    goto gotoExit;
                }
                m_rgofbProp[m_ciProp++] = dwWordIDDecoding(pLex->m_ofbProp);
            }
            pw2 = (WORD*)(pLex + 1); fOK = FALSE;
            for (cw2 = 0; (pw2 + cw2) < pwTail && (pw2[cw2] & LEX_MSBIT); cw2++) {
                if (fOK == FALSE && (cw2 >= cw1 || pw1[cw2] < pw2[cw2])) {
                    fOK = TRUE;
                }
            }
            assert(fOK); // error lex order
            pw1 = pw2; cw1 = cw2;
        }
        assert(pw1 + cw1 == pwTail); // error offset in index
    } // end of index loop
            
    // Finish checking index and lex section, m_rgofbProp filled with all prop offsets
    if (m_ciProp == m_ciMaxProp && !fExpandProp()) {
        assert(0);
        goto gotoExit;
    }
    m_rgofbProp[m_ciProp] = m_cbProp; // fill the end of array
    ofbFtr = 0;
    for (idx = 0; idx < m_ciProp; idx++) {
        assert(m_rgofbProp[idx] + sizeof(CRTLexProp) <= m_cbProp &&
                m_rgofbProp[idx + 1] <= m_cbProp); // offset over boundary!!!
        pProp = (CRTLexProp*)(m_pbProp + m_rgofbProp[idx]);
        assert((m_rgofbProp[idx] + sizeof(CRTLexProp) + 
                pProp->m_ciAttri * sizeof(USHORT) +
                pProp->m_ciFeature * sizeof(CRTLexFeature)) 
                == m_rgofbProp[idx + 1]); // error prop offset
        // verify the attributes order
        pw1 = (USHORT*)(pProp + 1); 
        for (cw1 = 1; cw1 < pProp->m_ciAttri; cw1++) { // Validate the attributes order
            assert(pw1[cw1] > pw1[cw1 - 1]); 
        }
        if (pProp->m_ciAttri > 0) { // Validate the range of attribute ID value 
            assert(pw1[pProp->m_ciAttri - 1] <= LADef_MaxID);
        }
        // verify the feature order
        if (pProp->m_ciFeature > 0) {
            pFtr = (CRTLexFeature*)((USHORT*)(pProp + 1) + pProp->m_ciAttri);
            assert(pFtr->m_ofbFSet == ofbFtr); // no leak bytes in the feature section
            assert(pFtr->m_cwchLen > 0); // zero feature set
            ofbFtr += pFtr->m_cwchLen * sizeof(WCHAR);
            assert(ofbFtr <= m_cbFtr); // feature offset over boundary
            cw1 = pFtr->m_wFID;
            for (ci = 1, pFtr++; ci < pProp->m_ciFeature; ci++, pFtr++) {
                assert(pFtr->m_ofbFSet == ofbFtr); // no leak bytes in the feature section
                assert(pFtr->m_cwchLen > 0); // zero feature set
                ofbFtr += pFtr->m_cwchLen * sizeof(WCHAR);
                assert(ofbFtr <= m_cbFtr); // feature offset over boundary
                cw2 = pFtr->m_wFID;
                assert(cw2 > cw1); // error feature set order
                cw1 = cw2;
            }
            assert(cw1 <= LFDef_MaxID); // Validate the range of feature ID value
        }
    } // end of property loop
    assert(ofbFtr == m_cbFtr);

    iret = TRUE;
gotoExit:
    if (m_rgofbProp != NULL) {
        delete [] m_rgofbProp;
    }
    return iret;
}


//  Expand prop offset array
BOOL CLexicon::fExpandProp(void)
{
    DWORD* pNew = new DWORD[m_ciMaxProp + 20000];
    if (pNew == NULL) {
        return FALSE;
    }
    if (m_rgofbProp != NULL) {
        memcpy(pNew, m_rgofbProp, m_ciProp * sizeof(DWORD));
        delete [] m_rgofbProp;
    }
    m_rgofbProp = pNew;
    m_ciMaxProp += 20000;
    return TRUE;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\lock.h ===
#ifndef __CSimpleLock_h__
#define __CSimpleLock_h__

///////////////////////////////////////////////////////////
//
// Lock.h
//   - This class provides a simple locking mechanism.
//

class CSimpleLock
{
public:
	// Lock 
	CSimpleLock(HANDLE hMutex) 
	{
		m_hMutex = hMutex ;
		WaitForSingleObject(hMutex, INFINITE) ;
	}

	// Unlock
	~CSimpleLock()
	{
		ReleaseMutex(m_hMutex) ;
	}

private:
	HANDLE m_hMutex  ;
};

#endif ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\morph.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Define the morphological analysis on the sentence:
                1. Merge DBCS foreign character string (morph.cpp)
                2. Hnadle punctuation pair check and combind short quotation (morph.cpp)
                3. Resegment on some specific ambiguous words (morph1.cpp)
                4. Binding numerial words (morph2.cpp)
                5. Handle special M+Q usage (morph2.cpp)
                6. Handle affix attachment and usage of some specific words (morph3.cpp)
                7. Identify morphological patterns(Repeat, Pattern and 
                   Separacte words) (morph4.cpp)
                8. Merge 2-char compond verb and noun that are OOV (morph5.cpp)
            Morph-analysis is the first step in the Chinese parsing
Notes:      In order to make the Morphological module easy to manage, this class
            will be implemented in severial cpp files:
                morph.cpp, morph1.cpp, morph2.cpp, morph3.cpp, morph4.cpp, morph5.cpp
            All these cpp files share this header file
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#ifndef _MORPH_H_
#define _MORPH_H_

// Forward declaration of classes
class CLexicon;
class CWordLink;
struct CWord;
struct CWordInfo;

//   Define the CMorph class
class CMorph
{
    public:
        CMorph();
        ~CMorph();

        // Initialize the morph class
        int ecInit(CLexicon* pLexicon);

        // process affix attachment
        int ecDoMorph(CWordLink* pLink, BOOL fAfxAttach = TRUE);

    private:
        int         m_iecError; // runtime error code

        CWordLink*  m_pLink;
        CLexicon*   m_pLex;

        CWord*      m_pWord;

    private:
        // Terminate the Morph class
        void TermMorph(void);

        /*============================================================================
        Private functions for pre-combind process
        ============================================================================*/

        //  Pre-combind process control function.
        //  One pass scan the WordLink and call process functions
        BOOL fPreCombind();

        //  DBForeignHandler combind the conjunctive DB foreign characters
        int DBForeignHandler(void);
        //  Short quotation merge proc
        int QuoteHandler(void);

        /*============================================================================
        In order to handle different operation for different quote marks pair, 
        I use a separate process function for each kind of quote pair
        ============================================================================*/
        int preQuote1_Proc(void);   //  
        int preQuote2_Proc(void);   //  
        int preQuote3_Proc(void);   //  
        int preQuote4_Proc(void);   //  
        int preQuote5_Proc(void);   //  
        int preQuote6_Proc(void);   //  
        int preQuote7_Proc(void);   //  
        int preQuote8_Proc(void);   //  
        int preQuote9_Proc(void);   //  
        int preQuote10_Proc(void);  //  
        
        /*
        *   Common routine to handle       
        *   Merge into one node means will not proofread on the quote text any more!!!
        */
        int preQuoteMerge(WCHAR wchLeft, WCHAR wchRight);


        /*============================================================================
        //  Private functions for adjusting specific kind of ambiguities
        ============================================================================*/
        //  Scan the word link and handle the specific class of words (LADef_genAmbiMorph)
        //  We use table driven again to handle the specific words
        BOOL fAmbiAdjust();

        //  Dispatch the control to specific word processor
        int ResegWordsHandler();

        /*
        *   Following ambi words processors:
        *       Return AMBI_RESEGED if ambi reseg successfully or any error found
        *       Return AMBI_UNRESEG if could not reseg
        *       Return AMBI_ERROR if any error occurred, the error code in m_iecError
        */
        int ambiShiFen_Proc();  // 
        int ambiZhiYi_Proc();   // 
        int ambiYiDian_Proc();  // 
        int ambiYiShi_Proc();   // 
        int ambiBaDu_Proc();    // 
        int ambiBaiNian_Proc(); // 
        int ambiWanFen_Proc();  // 

        //  Break a multi-char words into single-char words and reset their property by
        //  lookup the lexicon char by char. 
        //  Return TRUE if successful, and keep m_pWord point to the first single-char word
        //  Return FALSE if any error occurred
        BOOL fBreakIntoChars();

        //  Lookup the lexicon for the given word node, and reset the lex prop of it.
        //  Return TRUE if the word can be found in the lexicon
        //  Reture FALSE if the word can not be found in the lexicon
        BOOL fRecheckLexInfo(CWord* pWord);


        /*============================================================================
        //  Private functions for Numerical words analysis
        ============================================================================*/
        /*--------- Level 1 ---------*/
        //  Numerical Analysis control function. return TRUE if done
        //  Return FALSE if error occurred, and the error code in m_iecError
        BOOL fNumerialAnalysis();


        /*--------- Level 2 ---------*/
        //  Analysis number word string, check error and mark the class of the merged
        //  number words.
        //  Note: number testing from current word!
        int GetNumber();

        //  
        int BindOrdinal();
        //  
        int BindDecimal();
        //  : //
        int BindRange();
        
        /*--------- Level 3 ---------*/
        //  Parser for SBCS number called by GetNumber()
        void numSBCSParser(); 
        //  Parser for DBCS Arabic number called by GetNumber()
        void numArabicParser(); 
        //  Parser for DBCS Chinese number called by GetNumber()
        void numChineseParser(); 
        //  Bind  called by GetNumber()
        void numGanZhiHandler();
        
        /*
        *   Following case processors:
        *       Return NUM_PROCESSED if merged successfully or any error found
        *       Return NUM_UNPROCESS if could not merged
        *       Return NUM_ERROR if any error occurred, the error code in m_iecError
        */
        //  Ordinal number processors: called by BindOrdinal()
        int ordDi_Proc();           // 
        int ordChu_Proc();          // 

        //  Decimal number processors: called by BindDecimal()
        int decBaiFen_Proc();       // , , 
        int decBei_Proc();          // 
        int decCheng_Proc();        // 
        int decDian_Proc();         // 
        int decFenZhi_Proc();       // 

        /*--------- Level 4 ---------*/
        //  Service routines
        //  Test 2-char Chinese string, and return whether it is a valid approx number
        BOOL fValidApproxNum(WCHAR* pwchWord);
        // Test duplicated conjunction char in the word
        BOOL fCheckDupChar(CWord* pWord);


        //--------------------------------------------------------------------------------
        //  Private functions for affix attachment
        //--------------------------------------------------------------------------------
        //  Affix attachment control function. Return TRUE if done.
        //  Return FALSE if error occurred, and set error code in m_iecError
        BOOL fAffixAttachment();

        /* 
        *   Prefix and suffix handler functions:
        *       Return AFFIX_ATTACHED if attached successfully
        *       Return AFFIX_UNATTACH if could not attached
        *       Return AFFIX_ERROR if runtime error occurred
        */
        int PrefixHandler(void);
        int SuffixHandler(void);
        
        //  Get Prefix ID, return -1 if pWord is not a prefix
        int GetPrefixID(void);
        //  Get Suffix ID, return -1 if pWord is not a suffix
        int GetSuffixID(void);

        /* 
        *   Prefix process functions:
        *       Return AFFIX_ATTACHED if attached successfully
        *       Return AFFIX_UNATTACH if could not attached
        *       Return AFFIX_ERROR if runtime error occurred
        */
        int pfxAa_Proc(void);       // 
        int pfxChao_Proc(void);     // 
        int pfxDai_Proc(void);      // 
        int pfxFan_Proc(void);      // 
        int pfxFei_Proc(void);      // 
        int pfxFu_Proc(void);       // 
        int pfxGuo_Proc(void);      // 
        int pfxLao_Proc(void);      // 
        int pfxWei1_Proc(void);     // 
        int pfxWei3_Proc(void);     // 
        int pfxXiao_Proc(void);     // 
        int pfxZhun_Proc(void);     // 
        int pfxZong_Proc(void);     // 

        /* 
        *   Suffix process functions:
        *       Return AFFIX_ATTACHED if attached successfully
        *       Return AFFIX_UNATTACH if could not attached
        *       Return AFFIX_ERROR if runtime error occurred
        */
        int sfxZhang_Proc(void);    // 
        int sfxChang_Proc(void);    // 
        int sfxDan_Proc(void);      // 
        int sfxDui_Proc(void);      // 
        int sfxEr_Proc(void);       // 
        int sfxFa_Proc(void);       // 
        int sfxFang_Proc(void);     // 
        int sfxGan_Proc(void);      // 
        int sfxGuan_Proc(void);     // 
        int sfxHua_Proc(void);      // 
        int sfxJi_Proc(void);       // 
        int sfxJia_Proc(void);      // 
        int sfxJie_Proc(void);      // 
        int sfxLao_Proc(void);      // 
        int sfxLv_Proc(void);       // 
        int sfxLun_Proc(void);      // 
        int sfxMen_Proc(void);      // 
        int sfxPin_Proc(void);      // 
        int sfxQi_Proc(void);       // 
        int sfxSheng_Proc(void);    // 
        int sfxSheng3_Proc(void);   // 
        int sfxShi1_Proc(void);     // 
        int sfxShi4_Proc(void);     // 
        int sfxShi_Proc(void);      // 
        int sfxTi_Proc(void);       // 
        int sfxTing_Proc(void);     // 
        int sfxTou_Proc(void);      // 
        int sfxXing2_Proc(void);    // 
        int sfxXing4_Proc(void);    // 
        int sfxXue_Proc(void);      // 
        int sfxYan_Proc(void);      // 
        int sfxYe_Proc(void);       // 
        int sfxYi_Proc(void);       // 
        int sfxYuan_Proc(void);     // 
        int sfxZhe_Proc(void);      // 
        int sfxZheng_Proc(void);    // 
        int sfxZhi_Proc(void);      // 
        int sfxZi_Proc(void);       // 
        
        //  sfxXing2_Proc() service function
        BOOL fCheckXingQian(CWord* pWord);
        //  sfxShi_Proc() service function
        BOOL fCheckShiQian(CWord* pWord);


        /*============================================================================
        //  Private functions for pattern identification
        ============================================================================*/
        /*
        *   Pattern match control function. 
        *   WordLink scan, procedure control and error handling. Return TRUE if finished, 
        *   or FALSE if runtime error, and set error code to m_iecError.
        */
        BOOL fPatternMatch(void);

        // DupHandler: find duplicate cases and call coordinate proc functions
        int DupHandler(void);
        // PatHandler: find pattern and call coordinate proc functions
        int PatHandler(void);
        // SepHandler: find separate word and call coordinate proc functions
        int SepHandler(void);

        // Duplicate word processing functions
        int dupNN_Proc(void);       // *N N
        int dupNAABB_Proc(void);    // A *AB B
        int dupMM_Proc(void);       // *M M
        int dupMABAB_Proc(void);    // *AB AB
        int dupMAABB_Proc(void);    // A *AB B
        int dupQQ_Proc(void);       // *Q Q
        int dupVV_Proc(void);       // *V V
        int dupVABAB_Proc(void);    // *AB AB
        int dupVAABB_Proc(void);    // A *AB B
        int dupVVO_Proc(void);      // V *VO
        int dupAA_Proc(void);       // *A A
        int dupAAABB_Proc(void);    // A *AB B
        int dupAABAB_Proc(void);    // *AB AB
        int dupABB_Proc(void);      // *AB B
        int dupZABAB_Proc(void);    // *AB AB
        int dupDD_Proc(void);       // *D D
        int dupDAABB_Proc(void);    // A *AB B
        int dupDABAB_Proc(void);    // *AB AB

        // Pattern processing functions
        int patV1_Proc(void);       // *V  V
        int patV2_Proc(void);       // *V  V
        int patV3_Proc(void);       // *V  V
        int patV4_Proc(void);       // *V  V 
        int patV5_Proc(void);       // *V  V 
        int patA1_Proc(void);       // A  *AB
        int patD1_Proc(void);       // *D A D B
        int patABuA_Proc(void);     // *V  V
        int patVMeiV_Proc(void);    // *V  V

        // Separate word processing functions
        int sepVO_Proc(CWord* pBin, CWordInfo* pwinfo); // 
        int sepVR_Proc(CWord* pJie, CWordInfo* pwinfo); // 
        int sepVG_Proc(CWord* pQu, CWordInfo* pwinfo);  // 

};

#endif // _MORPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\morph5.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:	Combind 2-char compond verb and noun that OOV
Notes:		There are many 2-char verb and noun which can not be collected in the 
			lexicon but they are quite stable and few boundary ambiguities if combind.
			Most of them have one of the following structures:
				A + N
				V + N
				V + A
				N + N
			This step can be viewed as implementation of secondary Lexicon. 
			But we implement this using lex feature and attributes
Owner:		donghz@microsoft.com
Platform:	Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "wordlink.h"
#include "scchardef.h"
//#include "engindbg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\morph4.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Identify the Morphological pattern
Notes:      Include 3 parts: Duplicate, Pattern, and Separacte words
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "wordlink.h"
//#include "engindbg.h"
#include "lexicon.h"
#include "scchardef.h"
#include "slmdef.h"

//  Define local constants
#define PTN_UNMATCH     0
#define PTN_MATCHED     1
#define PTN_ERROR       2

//  Implement functions for pattern identification

/*============================================================================
CMorph::fPatternMatch(void):
    Pattern match control function. 
    WordLink scan, procedure control and error handling. 
Returns:
    TRUE if finished, 
    FALSE if runtime error, and set error code to m_iecError.
============================================================================*/
BOOL CMorph::fPatternMatch(void)
{
    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);

    int iret;
    m_pWord = m_pLink->pGetHead();
    assert(m_pWord != NULL); // error: missing the terminate word node!

    // Scan from left to right for pattern match
    for ( ; m_pWord && m_pWord->pNextWord() != NULL;
            m_pWord = m_pWord->pNextWord()) {
        if (m_pWord->fGetFlag(CWord::WF_SBCS) ||
            m_pWord->fGetFlag(CWord::WF_REDUCED)) {
            continue;
        }
        if ((iret = DupHandler()) != PTN_UNMATCH) {
            if (iret == PTN_ERROR) {
                return FALSE;
            }
            assert(m_pWord->fGetFlag(CWord::WF_REDUCED));
            m_pWord->SetWordID(SLMDef_semDup);
            continue;
        }
        if ((iret = PatHandler()) != PTN_UNMATCH) {
            if (iret == PTN_ERROR) {
                return FALSE;
            }
            assert(m_pWord->fGetFlag(CWord::WF_REDUCED));
            m_pWord->SetWordID(SLMDef_semPattern);
            continue;
        }
        if ((iret = SepHandler()) != PTN_UNMATCH) {
            if (iret == PTN_ERROR) {
                return FALSE;
            }
            continue;
        }
    }
    return TRUE;
}

// DupHandler: find duplicate cases and call coordinate proc functions
inline int CMorph::DupHandler(void)
{
    int     iret; 
    int     cwCurr, cwNext;
    CWord*  pNext;
    WCHAR*  pwch;
    BOOL    fRight;

    assert(m_pWord->pNextWord());
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));

    if ((cwCurr = m_pWord->cwchLen()) > 2) {
        return PTN_UNMATCH;
    }

    fRight = FALSE;
    iret = PTN_UNMATCH;
    pwch = m_pWord->pwchGetText();
    pNext = m_pWord->pNextWord();
    if (pNext->pNextWord() &&
        !pNext->fGetFlag(CWord::WF_SBCS) &&
        (cwNext = pNext->cwchLen()) <= 2) {
        // possible AA/ABAB/ABB
        if (cwCurr == 1) {
            if (cwNext == 1 && *pwch == *(pwch+1)) {
                // Match (*A A)
                if (m_pWord->fGetAttri(LADef_dupQQ)) {
                    iret = dupQQ_Proc();
                } else if (m_pWord->fGetAttri(LADef_dupAA)) {
                    iret = dupAA_Proc();
                } else if (m_pWord->fGetAttri(LADef_dupVV)) {
                    iret = dupVV_Proc(); // , 
                } else if (m_pWord->fGetAttri(LADef_dupDD)) {
                    iret = dupDD_Proc();
                } else if (m_pWord->fGetAttri(LADef_dupMM)) {
                    iret = dupMM_Proc();
                } else if (m_pWord->fGetAttri(LADef_dupNN)) {
                    iret = dupNN_Proc();
                } else {
                    // invalid AA case fall in here!!!
                    if (!m_pWord->fGetAttri(LADef_posM) && 
                        !m_pWord->fGetAttri(LADef_numArabic) && 
                        !m_pWord->fGetAttri(LADef_posO) ) {

                        m_pWord->pNextWord()->SetErrID(ERRDef_DUPWORD);
                        //_DUMPLINK(m_pLink, m_pWord);
                    }
                }
            }
            return iret;
        } else if (cwNext == 2 &&
                   *pwch == *(pwch + 2) &&
                   *(pwch + 1) == *(pwch + 3)) { 
            // Match (*AB AB)
            assert (cwCurr = 2);
            if (m_pWord->fGetAttri(LADef_dupMABAB)) {
                iret = dupMABAB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupVABAB)) {
                iret = dupVABAB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupZABAB)) {
                iret = dupZABAB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupAABAB)) {
                iret = dupAABAB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupDABAB)) {
                iret = dupDABAB_Proc();
            } else {
                // Invalid ABAB cases fall in here!!!
                m_pWord->pNextWord()->SetErrID(ERRDef_DUPWORD);
                //_DUMPLINK(m_pLink, m_pWord);
            }
            return iret;
        } else if (cwNext == 1 && *(pwch + 1) == *(pwch + 2)) {
            // Match (*AB B)
            assert(cwCurr == 2);
            fRight = TRUE;
        } else {
            return iret;
        }
    } // end of if possible AA/ABAB/ABB

    // match left char
    if (m_pWord->cwchLen() == 2 && m_pWord->pPrevWord() && 
            m_pWord->pPrevWord()->cwchLen() == 1 && *pwch == *(pwch-1)) {
        // Match (A *AB )
        if (fRight) { // Match (A AB B)!
            if (m_pWord->fGetAttri(LADef_dupVAABB)) {
                iret = dupVAABB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupAAABB)) {
                iret = dupAAABB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupMAABB)) {
                iret = dupMAABB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupDAABB)) {
                iret = dupDAABB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupNAABB)) {
                iret = dupNAABB_Proc();
            } else {
                // Invalid AABB cases fall in here!
                // Mark error on *AB
                m_pWord->SetErrID(ERRDef_DUPWORD);
                //_DUMPLINK(m_pLink, m_pWord);
            }
        } else {
            if (m_pWord->fGetAttri(LADef_dupVVO)) {
                iret = dupVVO_Proc();
            } else {
                // Invalid AAB cases fall in here!
                // Mark error on A
                m_pWord->pPrevWord()->SetErrID(ERRDef_DUPWORD);
                //_DUMPLINK(m_pLink, m_pWord);
            }
        }
        return iret;
    }

    if (fRight) { // Match (*AB B) but could not match (A *AB B)!
        if (m_pWord->fGetAttri(LADef_dupABB)) {
            return dupABB_Proc();
        } else {
            // Invalid ABB cases fall in here!
            pNext = m_pWord->pNextWord();
            if (!pNext->fIsWordChar(SC_CHAR_DE4) &&    // ": /..."
                !pNext->fIsWordChar(SC_CHAR_YI3) &&    // ": /..."
                !pNext->fIsWordChar(SC_CHAR_WEI) ) {      // ": /..."
              
                pNext->SetErrID(ERRDef_DUPWORD);
                //_DUMPLINK(m_pLink, m_pWord);
            }           
        }
    }

    return PTN_UNMATCH;
}

// PatHandler: find pattern and call coordinate proc functions
inline int CMorph::PatHandler(void)
{
    CWord*  pNextNext;
    assert(m_pWord->pNextWord());
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));

    if (m_pWord->pNextWord()->pNextWord() == NULL ||
        m_pWord->pNextWord()->pNextWord()->pNextWord() == NULL) {
        return PTN_UNMATCH;
    }
    pNextNext = m_pWord->pNextWord()->pNextWord();
    
    // try "VV" first
    if (m_pWord->fGetAttri(LADef_patV3) &&
        pNextNext->pNextWord()->pNextWord() &&
        m_pWord->pNextWord()->fIsWordChar(SC_CHAR_LE) &&
        pNextNext->fIsWordChar(SC_CHAR_YI) &&
        m_pWord->fIsTextIdentical(pNextNext->pNextWord()) ) {
        // Match!
        return patV3_Proc();
    }

    // try other A x A patterns
    int iret = PTN_UNMATCH;
    if (!m_pWord->fGetAttri(LADef_punPunct) &&
        m_pWord->fIsTextIdentical(pNextNext)) {
        // Match m_pWord and pNextNext!
        if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_YI)) {
            iret = patV1_Proc();
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_LE)) {
            iret = patV2_Proc();
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_LAI) && 
                  pNextNext->pNextWord()->pNextWord() &&
                  pNextNext->pNextWord()->fIsWordChar(SC_CHAR_QU)) {
            iret = patV4_Proc();
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_SHANG) && 
                   pNextNext->pNextWord()->pNextWord() &&
                   pNextNext->pNextWord()->fIsWordChar(SC_CHAR_XIA)) {
            iret = patV5_Proc();
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_BU)) {
            iret = patABuA_Proc();
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_MEI)) {
            iret = patVMeiV_Proc();
        } else if (m_pWord->fGetAttri(LADef_patD1)) {
            iret = patD1_Proc();
        } else {
            // No handler for the (*A x A ) pattern, error?
            //_DUMPLINK(m_pLink, m_pWord);
        }
        return iret;
    }
    return PTN_UNMATCH;
}

// SepHandler: find separate word and call coordinate proc functions
#define SEPARATE_LENGTH     3   // count of words between the two parts of the separate words
inline int CMorph::SepHandler(void)
{
    assert(m_pWord->pNextWord());
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));

    CWord*  pHou; // the second part of the separat words
    WCHAR   rgwchLex[6];
    CWordInfo   winfo;

    if (!m_pWord->fGetAttri(LADef_sepQian)) {
        return PTN_UNMATCH;
    }
    // found the first part of the separate word
    pHou = m_pWord->pNextWord();
    USHORT ilen = SEPARATE_LENGTH;
    while (1) {
        if (pHou->pNextWord() == NULL ||
            pHou->fGetAttri(LADef_punPunct) || ilen-- <= 0) {
            return PTN_UNMATCH;
        }
        if (pHou->fGetAttri(LADef_sepHou)) {
            break;
        }
        pHou = pHou->pNextWord();
    }
    // both of the two parts matched
    assert(pHou && pHou->pNextWord());

    if (m_pWord->cwchLen() + pHou->cwchLen() > sizeof(rgwchLex)/sizeof(rgwchLex[0])) {
        assert(0);
        return PTN_UNMATCH;
    }
    ilen = m_pWord->cwchLen();
    memcpy(rgwchLex, m_pWord->pwchGetText(), ilen * sizeof (WCHAR));
    memcpy(&rgwchLex[ilen], pHou->pwchGetText(), pHou->cwchLen() * sizeof (WCHAR));
    ilen += pHou->cwchLen();
    if (ilen != m_pLex->cwchMaxMatch(rgwchLex, ilen, &winfo)) {
        return PTN_UNMATCH;
    }
    
    // the separate word found
    if (winfo.fGetAttri(LADef_sepVR)) {
        return sepVR_Proc(pHou, &winfo);
    } else if (winfo.fGetAttri(LADef_sepVG)) {
        return sepVG_Proc(pHou, &winfo);
    } else if (winfo.fGetAttri(LADef_sepVO)) {
        return sepVO_Proc(pHou, &winfo);
    }
    
    //_DUMPLINK(m_pLink, m_pWord);

    return PTN_UNMATCH;

}

// Duplicate word processing functions
int CMorph::dupNN_Proc(void)        // *N N
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupNAABB_Proc(void) // A *AB B
{
    assert(m_pWord->pPrevWord());

    m_pWord = m_pWord->pPrevWord();
    m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
    m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupMM_Proc(void)        // *M M
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posM);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupMABAB_Proc(void) // *AB AB
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posM);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupMAABB_Proc(void) // A *AB B
{
    assert(m_pWord->pPrevWord());
//    m_pLink->MergeWithNext(m_pWord);
//    m_pLink->MergeWithNext(m_pWord);
    m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
    m_pWord->SetAttri(LADef_posM);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupQQ_Proc(void)        // *Q Q
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posQ);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_YI)) {

        m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
        //_DUMPLINK(m_pLink, m_pWord);
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupVV_Proc(void)        // *V V
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupVABAB_Proc(void) // *AB AB
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupVAABB_Proc(void) // A *AB B
{
    assert(m_pWord->pPrevWord());
    m_pWord = m_pWord->pPrevWord();
//    m_pLink->MergeWithNext(m_pWord);
//    m_pLink->MergeWithNext(m_pWord);
    m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupVVO_Proc(void)       // V *VO
{
    assert(m_pWord->pPrevWord());
    m_pWord = m_pWord->pPrevWord();
    m_pLink->MergeWithNext(m_pWord, FALSE);
    // Set attributes for VVO words
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupAA_Proc(void)        // *A A
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    // Set attributes for AA words
    if (m_pWord->fGetAttri(LADef_dupAAToD)) {
        // 
        m_pWord->SetAttri(LADef_posD);
        //_DUMPLINK(m_pLink, m_pWord);
    } else {
        m_pWord->SetAttri(LADef_posV);
        //_DUMPLINK(m_pLink, m_pWord);
    }
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    return PTN_MATCHED;
}

int CMorph::dupAAABB_Proc(void) // A *AB B
{
    assert(m_pWord->pPrevWord());

    m_pWord = m_pWord->pPrevWord();
//    m_pLink->MergeWithNext(m_pWord);
//    m_pLink->MergeWithNext(m_pWord);
    m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
    m_pWord->SetAttri(LADef_posZ);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupAABAB_Proc(void) // *AB AB
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupABB_Proc(void)       // *AB B
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posZ);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupZABAB_Proc(void) // *AB AB
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posZ);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupDD_Proc(void)        // *D D
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posD);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupDAABB_Proc(void) // A *AB B
{
    assert(m_pWord->pPrevWord());
    m_pWord = m_pWord->pPrevWord();
//    m_pLink->MergeWithNext(m_pWord);
//    m_pLink->MergeWithNext(m_pWord);
    m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
    m_pWord->SetAttri(LADef_posD);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupDABAB_Proc(void) // *AB AB
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posD);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}


// Pattern processing functions
int CMorph::patV1_Proc(void)        // *V  V
{
    if (m_pWord->fGetAttri(LADef_patV1)) {
//        m_pLink->MergeWithNext(m_pWord);
//        m_pLink->MergeWithNext(m_pWord);
        m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
        m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        // Invalid words in (*V  V) pattern
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}

int CMorph::patV2_Proc(void)        // *V  V
{
    if (m_pWord->fGetAttri(LADef_patV1)) {
//        m_pLink->MergeWithNext(m_pWord);
//        m_pLink->MergeWithNext(m_pWord);
        m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
        m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        // Invalid words in (*V  V) pattern
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}

int CMorph::patV3_Proc(void)        // *V  V
{
    assert(m_pWord->fGetAttri(LADef_patV3));

    m_pWord = m_pLink->pRightMerge(m_pWord, 3, FALSE);
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::patV4_Proc(void)        // *V  V 
{
    if (m_pWord->fGetAttri(LADef_patV4)) {
        m_pWord = m_pLink->pRightMerge(m_pWord, 3, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
        m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        m_pWord->pNextWord()->pNextWord()->SetErrID(ERRDef_DUPWORD);
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}

int CMorph::patV5_Proc(void)        // *V  V 
{
    if (m_pWord->fGetAttri(LADef_patV5)) {
        m_pWord = m_pLink->pRightMerge(m_pWord, 3, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
        m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        m_pWord->pNextWord()->pNextWord()->SetErrID(ERRDef_DUPWORD);
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}

int CMorph::patD1_Proc(void)        // *D A D B
{    
#ifndef _CHSWBRKR_DLL_IWORDBREAKER // for IWordBreaker inrerface, don't merge
    CWord* pLast = m_pWord->pNextWord()->pNextWord()->pNextWord();
    assert(pLast);
    if (m_pWord->pNextWord()->fGetAttri(LADef_posV) &&
        pLast->fGetAttri(LADef_posV) &&
        m_pWord->pNextWord()->cwchLen() == pLast->cwchLen()) {

        m_pWord = m_pLink->pRightMerge(m_pWord,3);
        m_pWord->SetAttri(LADef_posV);
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else if (m_pWord->pNextWord()->fGetAttri(LADef_posA) &&
               pLast->fGetAttri(LADef_posA) &&
               m_pWord->pNextWord()->cwchLen() == pLast->cwchLen()) {
        m_pWord = m_pLink->pRightMerge(m_pWord,3);
        m_pWord->SetAttri(LADef_posA);
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        //_DUMPLINK(m_pLink, m_pWord);
    }
#endif // _CHSWBRKR_DLL_IWORDBREAKER
    return PTN_UNMATCH;
}

int CMorph::patABuA_Proc(void)      // (*V  V) or (*A  A)
{
    if (m_pWord->fGetAttri(LADef_posV)) {
        if (!m_pWord->fGetAttri(LADef_flgNoVBu)) {
            m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
            m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
            m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
            //_DUMPLINK(m_pLink, m_pWord);
            return PTN_MATCHED;
        }
    } else if (m_pWord->fGetAttri(LADef_posA)) {
        if (!m_pWord->fGetAttri(LADef_flgNoABu)) {
            m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
            m_pWord->SetAttri(LADef_posA);
#ifdef LADef_iwbAltWd1
            m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
            //_DUMPLINK(m_pLink, m_pWord);
            return PTN_MATCHED;
        }
    } else {
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}

int CMorph::patVMeiV_Proc(void)     // *V  V
{
    if (m_pWord->fGetAttri(LADef_posV) &&
        !m_pWord->fGetAttri(LADef_flgNoVMei)) {

        m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
        m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}


// Separate word processing functions
int CMorph::sepVO_Proc(CWord* pBin, CWordInfo* pwinfo)  // 
{
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_UNMATCH;
}

int CMorph::sepVR_Proc(CWord* pJie, CWordInfo* pwinfo)  // 
{
    assert(m_pWord->pNextWord() && m_pWord->pNextWord()->pNextWord());

    if (( m_pWord->pNextWord()->fIsWordChar(SC_CHAR_BU) || 
          m_pWord->pNextWord()->fIsWordChar(SC_CHAR_DE)   ) &&
        m_pWord->pNextWord()->pNextWord() == pJie ) {

        m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWdc13
        m_pWord->SetAttri(LADef_iwbAltWdc13);
#endif // LADef_iwbAltWdc13
        // For SLM!
        m_pWord->SetWordID(pwinfo->GetWordID());
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_UNMATCH;
}

int CMorph::sepVG_Proc(CWord* pQu, CWordInfo* pwinfo)   // 
{
    assert(m_pWord->pNextWord() && m_pWord->pNextWord()->pNextWord());

    if (( m_pWord->pNextWord()->fIsWordChar(SC_CHAR_BU) || 
          m_pWord->pNextWord()->fIsWordChar(SC_CHAR_DE)   ) &&
        m_pWord->pNextWord()->pNextWord() == pQu ) {

        m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWdc13
        m_pWord->SetAttri(LADef_iwbAltWdc13);
#endif // LADef_iwbAltWdc13
        // For SLM!
        m_pWord->SetWordID(pwinfo->GetWordID());
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_UNMATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\morph1.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Implement resegmentation of some secific ambiguous words
Notes:      
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "wordlink.h"
#include "lexicon.h"
#include "scchardef.h"
//#include "engindbg.h"
#include "proofec.h"

#define AMBI_UNRESEG    0
#define AMBI_RESEGED    1
#define AMBI_ERROR      2

/*============================================================================
Private functions for adjusting specific kind of ambiguities
============================================================================*/

/*============================================================================
CMorph::fAmbiAdjust():
    Scan the word link and handle the specific class of words (LADef_genAmbiMorph)
    We use table driven again to handle the specific words
============================================================================*/
BOOL CMorph::fAmbiAdjust()
{
    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);

    m_pWord = m_pLink->pGetHead();
    assert(m_pWord);

    if (m_pWord->fIsTail()) {
        return TRUE;
    }

    // Scan from left to right for pattern match
    for (; m_pWord && m_pWord->pNextWord() != NULL;
           m_pWord = m_pWord->pNextWord()) {
        if (m_pWord->fGetAttri(LADef_genAmbiMorph)) {
            if (ResegWordsHandler() == AMBI_ERROR) {
                return FALSE;
            }
        }
    }
    return TRUE;
}


#define ID_ambiShiFen   1       // 
#define ID_ambiZhiYi    2       // 
#define ID_ambiYiDian   3       // 
#define ID_ambiYiShi    4       // 
#define ID_ambiBaDu     5       // 
#define ID_ambiBaiNian  6       // 
#define ID_ambiWanFen   7       // 

//  Dispatch the control to specific word processor
int CMorph::ResegWordsHandler()
{
    static struct { 
        WCHAR*  m_lpszKey;
        int     m_idEntry;
        } rgResegEntry[] = {
            { SC_WORD_YISHI, ID_ambiYiShi },    // L"\x4e00\x65f6"  // ""
            { SC_WORD_YIDIAN, ID_ambiYiDian },  // L"\x4e00\x70b9"  // ""
            { SC_WORD_WANFEN, ID_ambiWanFen },  // L"\x4e07\x5206"  // ""
            { SC_WORD_ZHIYI, ID_ambiZhiYi },    // L"\x4e4b\x4e00"  // ""
            { SC_WORD_BADU, ID_ambiBaDu },      // L"\x516b\x5ea6"  // ""
            { SC_WORD_SHIFEN, ID_ambiShiFen },  // L"\x5341\x5206"  // ""
            { SC_WORD_BAINIAN, ID_ambiBaiNian } // L"\x767e\x5e74"  // ""
        };

    assert(m_pWord->fGetAttri(LADef_genAmbiMorph));

    WCHAR*  pwchWord = m_pWord->pwchGetText();
    int     lo = 0, hi = sizeof(rgResegEntry) / sizeof(rgResegEntry[0]) - 1;
    int     mi, icmp = 0;
    int     idEntry = -1;

    while (lo <= hi) {
        mi = (lo + hi) / 2;
        // compare the text
        WCHAR*  pwchKey = rgResegEntry[mi].m_lpszKey;
        int     i = 0;
        while (1) {
            if (pwchKey[i] == L'\0') { 
                if (i < m_pWord->cwchLen()) {
                    icmp = 1; 
                }
                break; 
            }
            if (i >= m_pWord->cwchLen()) {
                icmp = -1;
                break;
            }
            if ((icmp = (pwchWord[i] - pwchKey[i])) != 0) {
                break;
            }
            i++;
        }
        // locate next mid point
        if (icmp < 0) {
            hi = mi - 1;
        } else if (icmp > 0) {
            lo = mi + 1;
        } else { // match!
            idEntry = rgResegEntry[mi].m_idEntry;
            break;
        }
    }
    if (idEntry == -1) {
        assert(0); // Uncovered cases
        return AMBI_UNRESEG;
    }
    // Handle case by case
    switch (idEntry) {
        case ID_ambiShiFen:
            return ambiShiFen_Proc();

        case ID_ambiZhiYi:
            return ambiZhiYi_Proc();

        case ID_ambiYiDian:
            return ambiYiDian_Proc();

        case ID_ambiYiShi:
            return ambiYiShi_Proc();

        case ID_ambiBaDu:       // 
            return ambiBaDu_Proc();

        case ID_ambiBaiNian:    // 
            return ambiBaiNian_Proc();

        case ID_ambiWanFen:     // 
            return ambiWanFen_Proc();

        default:
            assert(0);
            break;
    }
    return AMBI_UNRESEG;
}


/*============================================================================
*   Following ambi words processors:
*       Return AMBI_RESEGED if ambi reseg successfully or any error found
*       Return AMBI_UNRESEG if could not reseg
*       Return AMBI_ERROR if any error occurred, the error code in m_iecError
============================================================================*/

inline int CMorph::ambiShiFen_Proc()    // 
{
    if (!m_pWord->fIsHead() &&
        ( m_pWord->pPrevWord()->fGetAttri(LADef_numChinese) ||
          m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_SHI) ||  // 
          m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DIAN3)) ) { // 
        // 
        //_DUMPLINK(m_pLink, m_pWord);
    } else if (!m_pWord->fIsTail() && 
               ( m_pWord->pNextWord()->fIsWordText(SC_WORD_ZHIYI) ||   // 
                 m_pWord->pNextWord()->fIsWordChar(SC_CHAR_ZHI)) ) {   // 
        // 
        //_DUMPLINK(m_pLink, m_pWord);
    } else {
        // Used as adv. 
        // Occur 3983 times in 40M Corpus
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_UNRESEG;
    }

    // Occur 209 times in 40M Corpus. Re-break it into two single-char words
    if (!fBreakIntoChars()) {
        return AMBI_ERROR;
    }
    return AMBI_RESEGED;
}


inline int CMorph::ambiZhiYi_Proc() // 
{
    if (!m_pWord->fIsHead() && m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_FEN)){
        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        // Merge  with previous 
        m_pWord = m_pWord->pPrevWord();
        m_pLink->MergeWithNext(m_pWord);
        if (!fRecheckLexInfo(m_pWord)) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


inline int CMorph::ambiYiDian_Proc()    // 
{
    if( !m_pWord->fIsTail() &&
        m_pWord->pNextWord()->fGetAttri(LADef_numChinese) ||
        !m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_numChinese) ) {

        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


inline int CMorph::ambiYiShi_Proc() // 
{
    if (!m_pWord->fIsHead() && 
        ( m_pWord->pPrevWord()->fGetAttri(LADef_numChinese) ||
          m_pWord->pPrevWord()->fGetAttri(LADef_posT) ||
          m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_CHU) ||
          m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_GAO)) ) {
        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


inline int CMorph::ambiBaDu_Proc()      // 
{
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_numChinese)) {
        //   => break 
        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


inline int CMorph::ambiBaiNian_Proc()   // 
{
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_numChinese)) {
        //   => break 
        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


inline int CMorph::ambiWanFen_Proc()    // 
{
    if (!m_pWord->fIsTail() && 
        ( m_pWord->pNextWord()->fIsWordText(SC_WORD_ZHIYI) ||   // 
          m_pWord->pNextWord()->fIsWordChar(SC_CHAR_ZHI)) ) {   // 
        // 
        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


/*============================================================================
Service functions for adjusting specific kind of ambiguities
============================================================================*/

/*============================================================================
CMorph::fBreakIntoChars():
    Break a multi-char words into single-char words and reset their property by
    lookup the lexicon char by char. 
Return:
    TRUE if successful, and keep m_pWord point to the first single-char word
    FALSE if any error occurred
============================================================================*/
BOOL CMorph::fBreakIntoChars()
{
    if (m_pWord->fGetFlag(CWord::WF_SBCS) ||
        m_pWord->fGetFlag(CWord::WF_REDUCED)) {
        // Could not rebreak the reduced node or SBCS word node
        assert(0); 
        m_iecError = PRFEC::gecUnknown;
        return FALSE;
    }
    CWord* pWord = m_pWord;
#ifdef DEBUG
    CWord* dbg_pWord = m_pWord->pPrevWord();
#endif // DEBUG
    CWordInfo winfo;
    assert(!pWord->fGetFlag(CWord::WF_CHAR));
    while (!pWord->fGetFlag(CWord::WF_CHAR)) {
        if ((pWord = m_pLink->pSplitWord(pWord, 1)) == NULL) { // OOM in pSplitWord()
            m_iecError = PRFEC::gecOOM;
            return FALSE;
        }
        if (!m_pLex->fGetCharInfo(*(pWord->pwchGetText()), &winfo)) {
            m_iecError = PRFEC::gecUnknown;
            return FALSE;
        }
        // Set the word property
        pWord->SetWordID(winfo.GetWordID());
        pWord->SetLexHandle(winfo.GetLexHandle());
        for (USHORT i = 0; i < winfo.AttriNum(); i++) {
            pWord->SetAttri(winfo.GetAttri(i));
        }
        pWord = pWord->pNextWord();
    }
    // Lookup the last char in the lexicon
    if (!m_pLex->fGetCharInfo(*(pWord->pwchGetText()), &winfo)) {
        m_iecError = PRFEC::gecUnknown;
        return FALSE;
    }
    // Set the word property
    pWord->SetWordID(winfo.GetWordID());
    pWord->SetLexHandle(winfo.GetLexHandle());
    for (USHORT i = 0; i < winfo.AttriNum(); i++) {
        pWord->SetAttri(winfo.GetAttri(i));
    }

#ifdef DEBUG
    assert(dbg_pWord == m_pWord->pPrevWord());
#endif // DEBUG
    
    return TRUE;
}

/*============================================================================
CMorph::fRecheckLexInfo(CWord* pWord):
    Lookup the lexicon for the given word node, and reset the lex prop of it.
Return:
    TRUE if the word can be found in the lexicon
    FALSE if the word can not be found in the lexicon
============================================================================*/
BOOL CMorph::fRecheckLexInfo(CWord* pWord)
{
    assert(pWord->pNextWord());
    assert(pWord->cwchLen());
    assert(!pWord->fGetFlag(CWord::WF_SBCS));

    CWordInfo   winfo;
    USHORT      cwchLen = pWord->cwchLen();
    // Lookup the lexicon for the word
    if (cwchLen == 0 ||
        cwchLen != m_pLex->cwchMaxMatch(pWord->pwchGetText(),cwchLen, &winfo)){
        m_iecError = PRFEC::gecUnknown;
        return FALSE;
    }
    // Set the word property
    pWord->SetWordID(winfo.GetWordID());
    pWord->SetLexHandle(winfo.GetLexHandle());
    for (USHORT i = 0; i < winfo.AttriNum(); i++) {
        pWord->SetAttri(winfo.GetAttri(i));
    }
    if (cwchLen == 1) {
        pWord->SetFlag(CWord::WF_CHAR);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\morph2.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Implement the numerical words binding and special M+Q usage processing
Notes:      There are some analysis exceed the scope of morphological in the M+Q 
            analysis, they are some phrase structure analyzing stuff, but I think 
            implement them here is more reasonable and effecient
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "wordlink.h"
#include "scchardef.h"
//#include "engindbg.h"

//  Define the return value of rules handler functions
#define NUM_UNPROCESS   0
#define NUM_PROCESSED   1
#define NUM_ERROR       2

/*============================================================================
Implement Private functions for Numerical words analysis
============================================================================*/
//  Level 1:

/*============================================================================
CMorph::fNumerialAnalysis():
    Numerical Analysis control function. 
Returns:
    TRUE if done
    FALSE if error occurred, and the error code in m_iecError
============================================================================*/
BOOL CMorph::fNumerialAnalysis()
{
    int     iret;

    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);

    m_pWord = m_pLink->pGetHead();
    assert(m_pWord);

    if (m_pWord->fIsTail()) {
        return TRUE;
    }

    // Scan from left to right for numerial words processing
    for (; m_pWord; m_pWord = m_pWord->pNextWord()) {
        // Test the number word, combind and parse the number word
        if ((iret = GetNumber()) == NUM_UNPROCESS) {
            continue;
        }
        if (iret == NUM_ERROR) { 
            assert(m_iecError != 0);
            return FALSE;
        }
        
        // Bind ordinal number
        if (!m_pWord->fIsHead() &&
            m_pWord->pPrevWord()->fGetAttri(LADef_numTipOrdinal)) {

            if ((iret = BindOrdinal()) == NUM_PROCESSED) {
                continue;
            }
            if (iret == NUM_ERROR) {
                assert(m_iecError != 0);
                return FALSE;
            }
        }

        // Bind decimal number
        if (!m_pWord->fIsHead() &&
            m_pWord->pPrevWord()->fGetAttri(LADef_numTipDecimal) ||
            !m_pWord->fIsTail() &&
            m_pWord->pNextWord()->fGetAttri(LADef_numTipDecimal) ) {

            if ((iret = BindDecimal()) == NUM_PROCESSED) {
                continue;
            }
            if (iret == NUM_ERROR) {
                assert(m_iecError != 0);
                return FALSE;
            }
        }

        // Bind Range of Integers , ,  
        if (m_pWord->fGetAttri(LADef_numInteger)) {
            if (BindRange() == NUM_ERROR) {
                assert(m_iecError != 0);
                return FALSE;
            }
        }
    }

#ifdef DEBUG
    // Validate numNumber node
    m_pWord = m_pLink->pGetHead();
    for (; m_pWord; m_pWord = m_pWord->pNextWord()) {
        int dbg_ciTag = 0;
        if (m_pWord->fGetAttri(LADef_numNumber)) {
            if (m_pWord->fGetAttri(LADef_numInteger)) {
                dbg_ciTag++;
            }
            if (m_pWord->fGetAttri(LADef_numPercent)) {
                dbg_ciTag++;
            }
            if (m_pWord->fGetAttri(LADef_numDecimal)) {
                dbg_ciTag++;
            }
            if (m_pWord->fGetAttri(LADef_numOrdinal)) {
                dbg_ciTag++;
            }
            assert(dbg_ciTag <= 1); // Only one of these 3 can be set
            if (dbg_ciTag == 0) {
                assert(m_pWord->fGetAttri(LADef_numCode)); // Must have some attribute
                //_DUMPLINK(m_pLink, m_pWord);
            } else if (m_pWord->fGetAttri(LADef_numCode)) {
                // Only numInteger could co-exist with numCode
                assert(m_pWord->fGetAttri(LADef_numInteger)); 
                //_DUMPLINK(m_pLink, m_pWord);
            } else {
            }
        }
    }
#endif // DEBUG

    return TRUE;
}


//  Level 2: 

/*============================================================================
CMorph::GetNumber():
    Analysis number word string, check error and mark the class of the merged
    number words.
Remarks:
    number testing from current word!
============================================================================*/
inline int CMorph::GetNumber()
{
    int iret = NUM_UNPROCESS;
    if (m_pWord->fGetAttri(LADef_numSBCS)) {
        numSBCSParser();
        if (m_pWord->pPrevWord() &&
            ( m_pWord->pPrevWord()->fGetAttri(LADef_numArabic) ||
              m_pWord->pPrevWord()->fGetAttri(LADef_numChinese))) {
            // 
            m_pWord->SetErrID(ERRDef_NOSTDNUM);
            //_DUMPLINK(m_pLink, m_pWord);
        }
        iret = NUM_PROCESSED;
    } else if (m_pWord->fGetAttri(LADef_numArabic)) {
        if (!m_pWord->fGetFlag(CWord::WF_REDUCED)) { // Has not been processed
            numArabicParser();
        }
        if (m_pWord->pPrevWord() &&
            ( m_pWord->pPrevWord()->fGetAttri(LADef_numSBCS) ||
              m_pWord->pPrevWord()->fGetAttri(LADef_numChinese))) {
            // 
            m_pWord->SetErrID(ERRDef_NOSTDNUM);
            //_DUMPLINK(m_pLink, m_pWord);
        }
        iret = NUM_PROCESSED;
    } else if (m_pWord->fGetAttri(LADef_numChinese)) {
        if (!m_pWord->fGetFlag(CWord::WF_REDUCED)) { // Has not been processed
            numChineseParser();
            // Return at once when error found
            if (m_pWord->GetErrID() != ERRDef_NIL) {
                return NUM_PROCESSED;
            }
        }
        if (m_pWord->fGetFlag(CWord::WF_CHAR) &&
            !m_pWord->fGetAttri(LADef_numXi) &&
            ( m_pWord->fIsWordChar(SC_CHAR_WAN) ||
              m_pWord->fIsWordChar(SC_CHAR_QIAN) ||
              m_pWord->fIsWordChar(SC_CHAR_YI4) ) &&
            !m_pWord->fIsHead() ) {

            CWord* pPrev = m_pWord->pPrevWord();
            if (pPrev->fGetAttri(LADef_numDecimal)) {
                if (pPrev->fGetAttri(LADef_numChinese)) {
                    m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                    m_pWord->SetAttri(LADef_numChinese);
                } else {
                    m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                    m_pWord->SetAttri(LADef_numMixed);
                }
                //_DUMPCASE(m_pLink, m_pWord, 1000);
                m_pWord->SetAttri(LADef_numInteger);
            } else if (pPrev->fGetAttri(LADef_numSBCS) ||
                       pPrev->fGetAttri(LADef_numArabic) ) { // 8, 5, 
                m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                if (!m_pWord->fIsHead() &&
                    m_pWord->pPrevWord()->fGetAttri(LADef_numMixed)) {
                    // 85
                    m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                }
                if (!m_pWord->fIsTail() &&
                    ( m_pWord->pNextWord()->fIsWordChar(SC_CHAR_DUO) ||
                      m_pWord->pNextWord()->fIsWordChar(SC_CHAR_YU) ) ) {
                    // 85 /
                    m_pLink->MergeWithNext(m_pWord);
                    m_pWord->SetAttri(LADef_amtApprox);
                }
                m_pWord->SetAttri(LADef_numMixed);
                m_pWord->SetAttri(LADef_numInteger);
                //_DUMPCASE(m_pLink, m_pWord, 1001);
            } else if (( pPrev->fIsWordChar(SC_CHAR_DUO) ||
                         pPrev->fIsWordChar(SC_CHAR_YU)) &&
                       !pPrev->fIsHead() &&
                       pPrev->pPrevWord()->fGetAttri(LADef_numInteger) ) {
                //  +  + /
                if (pPrev->pPrevWord()->fGetAttri(LADef_numChinese)) {
                    //  / 
                    m_pWord = m_pLink->pLeftMerge(m_pWord, 2);
                    m_pWord->SetAttri(LADef_numInteger);
                    m_pWord->SetAttri(LADef_numChinese);
                    m_pWord->SetAttri(LADef_amtApprox);
                    //_DUMPCASE(m_pLink, m_pWord, 1002);
                } else if (pPrev->pPrevWord()->fGetAttri(LADef_numArabic) ||
                           pPrev->pPrevWord()->fGetAttri(LADef_numSBCS) ) {
                    // Merge mixed number
                    m_pWord = m_pLink->pLeftMerge(m_pWord, 2);
                    if (!m_pWord->fIsHead() &&
                        m_pWord->pPrevWord()->fGetAttri(LADef_numMixed)) {
                        // 1200
                        m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                    }
                    //_DUMPCASE(m_pLink, m_pWord, 1003);
                    m_pWord->SetAttri(LADef_numInteger);
                    m_pWord->SetAttri(LADef_numMixed);
                    m_pWord->SetAttri(LADef_amtApprox);
                } else {
                }
            } else {
            }
        } else if (!m_pWord->fIsHead() &&
                   ( m_pWord->pPrevWord()->fGetAttri(LADef_numSBCS) || 
                     m_pWord->pPrevWord()->fGetAttri(LADef_numArabic) ) ) {
            // 
            m_pWord->SetErrID(ERRDef_NOSTDNUM);
            //_DUMPCASE(m_pLink, m_pWord, 1004);
        } else {
        }

        m_pWord->SetAttri(LADef_numNumber);
        iret = NUM_PROCESSED;
    } else if (m_pWord->fGetAttri(LADef_numGan) && !m_pWord->fIsTail() &&
               m_pWord->pNextWord()->fGetAttri(LADef_numZhi) ) {
        // Merge 
        numGanZhiHandler();
        m_pWord->SetAttri(LADef_posT);
        iret = NUM_PROCESSED;
    } else {
    }

    return iret;
}


//  
int CMorph::BindOrdinal()
{
    int iret;
    assert(!m_pWord->fIsHead() &&
           m_pWord->pPrevWord()->fGetAttri(LADef_numTipOrdinal));

    if (m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DI)) {
        iret = ordDi_Proc();    // 
    } else if (m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_CHU)) {
        iret = ordChu_Proc();   // 
    } else {
        //_DUMPLINK(m_pLink, m_pWord);
        return NUM_UNPROCESS;
    }
    m_pWord->SetAttri(LADef_numNumber);
    return NUM_PROCESSED;
}


//  
int CMorph::BindDecimal()
{
    assert(!m_pWord->fIsHead() &&
           m_pWord->pPrevWord()->fGetAttri(LADef_numTipDecimal) ||
           !m_pWord->fIsTail() &&
           m_pWord->pNextWord()->fGetAttri(LADef_numTipDecimal) );

    CWord*  pWord;
    int     iret;
    BOOL    fHit = FALSE;
    // Handle 
    if (!m_pWord->fIsTail() &&
        m_pWord->pNextWord()->fGetAttri(LADef_numTipDecimal)) {

        pWord = m_pWord->pNextWord();
        if (pWord->fIsWordChar(SC_CHAR_DIAN3)) {        // 
            iret = decDian_Proc();      
        } else if (pWord->fIsWordChar(SC_CHAR_BEI)) {   // 
            iret = decBei_Proc();
        } else if (pWord->fIsWordChar(SC_CHAR_CHENG)) { // 
            iret = decCheng_Proc();
        } else {
            //_DUMPLINK(m_pLink, m_pWord);
            iret = NUM_UNPROCESS;
        }

        if (iret == NUM_PROCESSED) {
            fHit = TRUE;
        } else if (iret == NUM_ERROR) {
            return NUM_ERROR;
        } else {
        }
    }

    // Handle 
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_numTipDecimal)) {

        pWord = m_pWord->pPrevWord();
        if (pWord->fIsWordText(SC_WORD_BAIFENZHI)) {    // 
            iret = decBaiFen_Proc();
        } else if (pWord->fIsWordText(SC_WORD_FENZHI)) {// 
            iret = decFenZhi_Proc();
        } else if (pWord->fIsWordText(SC_WORD_QIANFENZHI) ||  // 
                   pWord->fIsWordText(SC_WORD_WANFENZHI))  {  // 
            iret = decBaiFen_Proc();
        } else {
            //_DUMPLINK(m_pLink, m_pWord);
            iret = NUM_UNPROCESS;
        }

        if (iret == NUM_PROCESSED) {
            fHit = TRUE;
        } else if (iret == NUM_ERROR) {
            return NUM_ERROR;
        } else {
        }
    }
    if (fHit) {
        return NUM_PROCESSED;
    }
    return NUM_UNPROCESS;
}


//  : //
inline int CMorph::BindRange()
{
    assert(m_pWord->fGetAttri(LADef_numInteger));

    if (m_pWord->fIsHead()) {
        return NUM_UNPROCESS;
    }

    USHORT iStyle;
    CWord* pWord = m_pWord->pPrevWord();
    if( pWord->fGetFlag(CWord::WF_CHAR) &&
        ( pWord->fIsWordChar(SC_CHAR_ZHI4) ||
          pWord->fIsWordChar(SC_CHAR_DUNHAO) ||
          pWord->fIsWordChar(SC_CHAR_LIANHAO) ) &&
        !pWord->fIsHead() &&
        pWord->pPrevWord()->fGetAttri(LADef_numInteger) ) { // Match!
        // Get number style of m_pWord
        if (m_pWord->fGetAttri(LADef_numSBCS)) {
            iStyle = LADef_numSBCS;
        } else if (m_pWord->fGetAttri(LADef_numArabic)) {
            iStyle = LADef_numArabic;
        } else if (m_pWord->fGetAttri(LADef_numChinese)) {
            iStyle = LADef_numChinese;
        } else if (m_pWord->fGetAttri(LADef_numMixed)) {
            iStyle = LADef_numMixed;
        } else {
            //_DUMPLINK(m_pLink, m_pWord);
            iStyle = 0;
        }
        // Check style with previous integer
        if (!pWord->pPrevWord()->fGetAttri(iStyle)) { // Unmatched style!
            if ((iStyle == LADef_numSBCS || iStyle == LADef_numArabic) &&
                ( pWord->pPrevWord()->fGetAttri(LADef_numSBCS) ||
                  pWord->pPrevWord()->fGetAttri(LADef_numArabic) ) ) {
                // Mixed usage of SBCS and Arabic numbers
                m_pWord->SetErrID(ERRDef_NOSTDNUM);
                //_DUMPLINK(m_pLink, pWord);
            }
            return NUM_UNPROCESS;
        }
        // Merge the integer range
        m_pWord = pWord->pPrevWord();
        m_pLink->MergeWithNext(m_pWord);
        m_pLink->MergeWithNext(m_pWord);
        m_pWord->SetAttri(iStyle);
        m_pWord->SetAttri(LADef_numInteger);
        m_pWord->SetAttri(LADef_amtApprox);
        m_pWord->SetAttri(LADef_numNumber);
        //_DUMPLINK(m_pLink, m_pWord);
    } else {
        //_DUMPLINK(m_pLink, m_pWord);
    }

    return NUM_UNPROCESS;
}

    
//  Level 3:
//  Parse the 3 kinds of number: numSBCS, numArabic, numChinese

//  Parser for SBCS number called by GetNumber()
void CMorph::numSBCSParser()
{
    assert(m_pWord->fGetFlag(CWord::WF_SBCS) &&
           m_pWord->fGetAttri(LADef_numSBCS));

    BOOL fFloat = FALSE;
    BOOL fPercent = FALSE;
    WCHAR* pwch = m_pWord->pwchGetText();
    WCHAR* pwchTail = m_pWord->pwchGetText()+m_pWord->cwchLen();

    // only one character
    if (m_pWord->cwchLen() == 1) {
        // Clear the numSBCS attribute if only '.' or '%' alone
        if (*pwch == SC_CHAR_ANSIPERCENT || *pwch == SC_CHAR_ANSIDIAN) {
            m_pWord->ClearAttri(LADef_numSBCS);
            return;
        }
    }

    // Multi-char SBCS number
    while (pwch < pwchTail) {
        if (*pwch == SC_CHAR_ANSIDIAN) {
            fFloat = TRUE;
        } else if (*pwch == SC_CHAR_ANSIPERCENT) {
            fPercent = TRUE;
        }
        pwch++;
    }
    if (fPercent) {
        m_pWord->SetAttri(LADef_numPercent);
    } else if (fFloat) {
        m_pWord->SetAttri(LADef_numDecimal);
    } else {
        if (!m_pWord->fIsHead() && !m_pWord->pPrevWord()->fIsHead() &&
            m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_numSBCS) &&
            m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_numInteger) &&
            *(m_pWord->pPrevWord()->pwchGetText()) == SC_CHAR_ANSISLASH ) {
            // fraction like 2/3
            m_pWord = m_pWord->pPrevWord()->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
            m_pLink->MergeWithNext(m_pWord);
            m_pWord->SetAttri(LADef_numSBCS);
            m_pWord->SetAttri(LADef_numPercent);
            //_DUMPLINK(m_pLink, m_pWord);
        } else {
            m_pWord->SetAttri(LADef_numCode);
            m_pWord->SetAttri(LADef_numInteger);
        }
    }
    // Mark numNumber
    m_pWord->SetAttri(LADef_numNumber);

    return;
}


//  Parser for DBCS Arabic number called by GetNumber()
void CMorph::numArabicParser() 
{
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));
    assert(m_pWord->fGetAttri(LADef_numArabic));
    
    // Merge continuous Arabic numbers
    BOOL fFloat = FALSE;
    BOOL fPercent = FALSE;
    while (m_pWord->pNextWord() &&
           m_pWord->pNextWord()->fGetAttri(LADef_numArabic)) {
        if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_SHUDIAN)) {
            if (!fFloat && m_pWord->pNextWord()->pNextWord() &&
                m_pWord->pNextWord()->pNextWord()->fGetAttri(LADef_numArabic)) {

                fFloat = TRUE;
            } else {
                break;
            }
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_PERCENT)) {
            fPercent = TRUE;
        } else if (fPercent) {
            m_pWord->SetErrID(ERRDef_NUMERIAL);
        }
        m_pLink->MergeWithNext(m_pWord);
    }

    if (m_pWord->fGetFlag(CWord::WF_CHAR)) {
        if (m_pWord->fIsWordChar(SC_CHAR_PERCENT) ||
            m_pWord->fIsWordChar(SC_CHAR_SHUDIAN)) { 
            if (!m_pWord->fIsHead() && m_pWord->fGetAttri(LADef_numSBCS)) {
                // DBCS "" or "" follow the SBCS number
                m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                m_pWord->SetErrID(ERRDef_NOSTDNUM);
                //_DUMPLINK(m_pLink, m_pWord);
            } else {
                // Only DBCS "" or "", return w/o mark numArabic
            }
            return;
        }
    }

    // Set the attribute for multi-char Arabic number
    if (fPercent) {
        m_pWord->SetAttri(LADef_numPercent);
        //_DUMPLINK(m_pLink, m_pWord);
    } else if (fFloat) {
        m_pWord->SetAttri(LADef_numDecimal);
        //_DUMPLINK(m_pLink, m_pWord);
    } else {
        if ( !m_pWord->fIsHead() && !m_pWord->pPrevWord()->fIsHead() &&
             m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_numArabic) &&
             m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_numInteger) &&
             m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_SLASH) ) {
            // fraction like 2/3
            m_pWord = m_pWord->pPrevWord()->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
            m_pLink->MergeWithNext(m_pWord);
            m_pWord->SetAttri(LADef_numPercent);
            //_DUMPLINK(m_pLink, m_pWord);
        } else {
            m_pWord->SetAttri(LADef_numCode);
            m_pWord->SetAttri(LADef_numInteger);
            //_DUMPLINK(m_pLink, m_pWord);
        }
    }
    m_pWord->SetAttri(LADef_numArabic);
    m_pWord->SetAttri(LADef_numNumber);
    return;
}


//  Parser for DBCS Chinese number called by GetNumber()
//  Define the events constant
#define EVENT_LING  0
#define EVENT_XI    1
#define EVENT_LIANG 2
#define EVENT_SHI   3
#define EVENT_BAI   4
#define EVENT_QIAN  5
#define EVENT_WAN   6
#define EVENT_YI    7
#define EVENT_JI    8
#define EVENT_END   9

//  Define the events array
static struct { 
    WCHAR   m_wchEvent;
    char    m_iEvent;
    } v_rgEvent[] = {
                     { SC_DIGIT_YI,    EVENT_XI   },// 0x4e00 ""
                     { SC_DIGIT_QI,    EVENT_XI   },// 0x4e03 ""
                     { SC_DIGIT_WAN,   EVENT_WAN  },// 0x4e07 ""
                     { SC_DIGIT_SAN,   EVENT_XI   },// 0x4e09 ""
                     { SC_DIGIT_LIANG, EVENT_LIANG},// 0x4e24 ""
                     { SC_DIGIT_JIU,   EVENT_XI   },// 0x4e5d ""
                     { SC_DIGIT_ER,    EVENT_XI   },// 0x4e8c ""
                     { SC_DIGIT_WU,    EVENT_XI   },// 0x4e94 ""
                     { SC_DIGIT_YI4,   EVENT_YI   },// 0x4ebf ""
                     { SC_DIGIT_BA,    EVENT_XI   },// 0x516b ""
                     { SC_DIGIT_LIU,   EVENT_XI   },// 0x516d ""
                     { SC_CHAR_JI,     EVENT_JI   },// 0x51e0 ""
                     { SC_DIGIT_SHI,   EVENT_SHI  },// 0x5341 ""
                     { SC_DIGIT_QIAN,  EVENT_QIAN },// 0x5343 ""
                     { SC_DIGIT_SI,    EVENT_XI   },// 0x56db ""
                     { SC_DIGIT_BAI,   EVENT_BAI  },// 0x767e ""
                     { SC_DIGIT_LING,  EVENT_LING },// 0x96f6 ""
                     { SC_ARABIC_LING, EVENT_LING },// 0xff10 ""
                     { SC_DBCS_LING,   EVENT_LING } // 0X3007 ""
    };

static const char v_ciEvents = 10;

//  Define the state transfer array
//  Ambiguities! can not find errors like  or  (Unexpected "")
static char v_rgStateTrans[][v_ciEvents] = { 
    //                                    End
    /*  0       */  -1,  1,  1,  3,  6,  9, 12, 24,  1, -1,
    /*  1       */   2,  1,  1,  3,  6,  9, 12, 24, -1,  0,
    /*  2     */  -1, -1, -1, -1,  6,  9, 12, 24, -1, -1,
    /*  3       */  -1,  4, -1, -1, -1, -1, -1, -1,  4,  0,
    /*  4       */   5,  4, -1, -1,  6, -1, -1, -1, -1,  0,
    /*  5     */  -1, -1, -1, -1, -1,  9, 12, 24, -1, -1,
    /*  6       */  -1,  7,  7, -1, -1, -1, -1, -1,  7, -1,
    /*  7       */   8,  7,  7, -1, -1,  9, -1, -1, -1,  0,
    /*  8     */  -1, -1, -1, -1, -1, -1, 12, 24, -1, -1,
    /*  9       */  -1, 10, 10, -1, -1, -1, -1, -1, 10, -1,
    /* 10       */  11, 10, 10, -1, -1, -1, 12, -1, -1,  0,
    /* 11     */  -1, -1, -1, -1, -1, -1, 12, 24, -1, -1,
    /* 12       */  -1, 13, 13, 15, 18, 21, -1, -1, 13, -1,
    /* 13       */  14, 13, 13, 15, -1, -1, -1, -1, -1,  0,
    /* 14     */  -1, -1, -1, -1, 18, 21, -1, 24, -1, -1,
    /* 15     */  -1, 16, 16, -1, -1, -1, -1, -1, 16,  0,
    /* 16     */  17, 16, 16, -1, 18, -1, -1, -1, -1,  0,
    /* 17   */  -1, -1, -1, -1, 18, 21, -1, 24, -1, -1,
    /* 18     */  -1, 19, 19, -1, -1, -1, -1, -1, 19, -1,
    /* 19     */  20, 19, 19, -1, -1, 21, -1, -1, -1,  0,
    /* 20   */  -1, -1, -1, -1, -1, 21, -1, 24, -1, -1,
    /* 21     */  -1, 22, 22, -1, -1, -1, -1, -1, 22, -1,
    /* 22     */  23, 22, 22, -1, -1, -1, -1, 24, -1,  0,
    /* 23   */  -1, -1, -1, -1, -1, -1, -1, 24, -1, -1,
    /* 24       */  -1, 25, 25, 27, 30, 32, -1, -1, 25, -1,
    /* 25       */  26, 25, 25, 27, -1, -1, -1, -1, -1,  0,
    /* 26     */  -1, -1, -1, -1, 30, 32, -1, -1, -1, -1,
    /* 27     */  -1, 28, 28, -1, -1, -1, -1, -1, 28,  0,
    /* 28     */  29, 28, 28, -1, 30, -1, -1, -1, -1,  0,
    /* 29   */  -1, -1, -1, -1, -1, 32, -1, -1, -1, -1,
    /* 30     */  -1, 31, 31, -1, -1, -1, -1, -1, 31, -1,
    /* 31     */  -1, 31, 31, -1, -1, 32, -1, -1, -1,  0,
    /* 32     */  -1, 33, 33, -1, -1, -1, -1, -1, 33, -1,
    /* 33     */  -1, 33, 33, -1, -1, -1, -1, -1, -1,  0
};

void CMorph::numChineseParser() 
{
    assert(!m_pWord->fGetFlag(CWord::WF_REDUCED));
    assert(m_pWord->fGetAttri(LADef_numChinese));

    char iEvent, iState;
    BOOL fXi = m_pWord->fGetAttri(LADef_numXi);
    BOOL fWei = !fXi;
    BOOL fJi = m_pWord->fIsWordChar(SC_CHAR_JI);
    // Merge the continuous Chinese number words
    while (m_pWord->pNextWord() &&
           m_pWord->pNextWord()->fGetAttri(LADef_numChinese)) {
        fJi = (fJi || m_pWord->fIsWordChar(SC_CHAR_JI));
        if (m_pWord->pNextWord()->fGetAttri(LADef_numXi)) {
            fXi = TRUE;
        } else {
            fWei = TRUE;
        }
        m_pLink->MergeWithNext(m_pWord);
    }
    m_pWord->SetAttri(LADef_numChinese);

    // Only one character numerial word
    if (m_pWord->cwchLen() == 1) {
        if ( m_pWord->fGetAttri(LADef_numXi) ||    // ..., , , 
             m_pWord->fIsWordChar(SC_DIGIT_SHI) ) {// 
            //_DUMPLINK(m_pLink, m_pWord);
        } else {  //  or , , , 
            m_pWord->SetAttri(LADef_amtApprox);
            //_DUMPLINK(m_pLink, m_pWord);
        }
        // Bind  ////
        if (m_pWord->pPrevWord() &&
            m_pWord->pPrevWord()->fGetAttri(LADef_amtWanQian) &&
            ( m_pWord->fGetAttri(LADef_amtApprox) &&
              !m_pWord->fIsWordChar(SC_CHAR_JI) ||
              m_pWord->fIsWordChar(SC_DIGIT_SHI)) ) {

            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
            m_pWord->SetAttri(LADef_amtApprox);
        }
        m_pWord->SetAttri(LADef_numInteger);
        return;
    }
    // Only  words like: 
    if (!fXi && fWei) {
        // Sould not contain dup chars
        if (fCheckDupChar(m_pWord)) {
            m_pWord->SetErrID(ERRDef_NUMERIAL);
            return;
        }
        // Bind //// //
        if (m_pWord->pPrevWord() &&
            m_pWord->pPrevWord()->fGetAttri(LADef_amtWanQian)) {

            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
        }
        m_pWord->SetAttri(LADef_amtApprox);
        m_pWord->SetAttri(LADef_numInteger);
        //_DUMPLINK(m_pLink, m_pWord);
        return;
    }
    // Only  words
    if (fXi && !fWei) {
        if (m_pWord->cwchLen() == 2) {
            if (fValidApproxNum(m_pWord->pwchGetText())) {
                // Valid 
                m_pWord->SetAttri(LADef_amtApprox);
                m_pWord->SetAttri(LADef_numInteger);
                //_DUMPLINK(m_pLink, m_pWord);
            } else if (!m_pWord->fIsTail() &&
                        m_pWord->pNextWord()->fGetAttri(LADef_posQ)) {
                // Other [ + ]
                if (!m_pWord->fIsHead() &&
                    m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DIAN3)) {
                    //_DUMPCASE(m_pLink, m_pWord, 1031);
                } else if (!m_pWord->fIsTail() &&
                    m_pWord->pNextWord()->fIsWordChar(SC_CHAR_NIAN)) {
                    //_DUMPCASE(m_pLink, m_pWord, 1021);
                } else if (m_pWord->fIsWordLastChar(SC_CHAR_LIANG)) {
                    //_DUMPCASE(m_pLink, m_pWord, 1011);
                } else if (!m_pWord->fGetFlag(CWord::WF_REDUCED)) {
                    // Don't mark error on words like 
                } else {
                    //  
                    m_pWord->SetErrID(ERRDef_NUMERIAL);
                    //_DUMPCASE(m_pLink, m_pWord, 1001);
                }
            } else {
            }
        } // end of if (m_pWord->cwchLen() == 2) 
        if (m_pWord->cwchLen() > 2 && fJi) {
            m_pWord->SetErrID(ERRDef_NUMERIAL);
            //_DUMPCASE(m_pLink, m_pWord, 1002);
        }
        m_pWord->SetAttri(LADef_numCode);
        return;
    }

    // XiWei mixed as integer
    m_pWord->SetAttri(LADef_numInteger);

    // Analyz the  string from right to left
    fXi = FALSE; iState = 0;
    WCHAR* pwchChar = m_pWord->pwchGetText() + m_pWord->cwchLen();
    while (pwchChar > m_pWord->pwchGetText()) {
        pwchChar -= 1; // Move to the last char in the Chinese number string
        // Search in the events array and get current event
        iEvent = EVENT_END;
        int lo = 0, hi = sizeof(v_rgEvent) / sizeof(v_rgEvent[0]) - 1, mi, icmp;
        while (lo <= hi) {
            mi = (lo + hi) / 2;
            if ((icmp = *pwchChar - v_rgEvent[mi].m_wchEvent) == 0) {
                // Match!
                iEvent = v_rgEvent[mi].m_iEvent;
                break;
            } else if (icmp < 0) {
                hi = mi - 1;
            } else {
                lo = mi + 1;
            }
        }

        assert(iEvent != EVENT_END);

        // Handle some special cases for the state machine
        if ((iEvent == EVENT_XI || iEvent == EVENT_LIANG) && fXi) {
            //  +  (: ..., . : , , )
            if (m_pWord->fGetAttri(LADef_amtApprox)) {
                // more than one [+] structure in the same 
                iState = -1;
                break;
            } else {
                assert((pwchChar + 2) <= m_pWord->pNextWord()->pwchGetText());

                if (!fValidApproxNum(pwchChar)) { // [+]
                    iState = -1;
                    break;
                }
                // Not handle error: , 
            }
            m_pWord->SetAttri(LADef_amtApprox); //  if there is a [+]
        }
        fXi = (iEvent == EVENT_XI || iEvent == EVENT_LIANG) ? TRUE : FALSE;

        // Transfer to next state
        iState = v_rgStateTrans[iState][iEvent];
        if(iState == -1) {
            //_DUMPLINK(m_pLink, m_pWord);
            break;
        }
    }
    // Check the end event
    if (iState != -1 && v_rgStateTrans[iState][EVENT_END] == 0) {
        // Valid Chinese number!
    } else { // error found!
        if (!m_pWord->fIsHead() && 
            m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DIAN3) &&
            ( m_pWord->fIsWordLastChar(SC_CHAR_WAN) ||
              m_pWord->fIsWordLastChar(SC_CHAR_YI4) ) ) {
            //    
            m_pWord = m_pLink->pSplitWord(m_pWord, m_pWord->cwchLen() - 1);
            m_pWord->SetAttri(LADef_numCode);
            m_pWord->SetAttri(LADef_numChinese);
            m_pWord->pNextWord()->SetAttri(LADef_numInteger);
            m_pWord->pNextWord()->SetAttri(LADef_amtApprox);
            m_pWord->pNextWord()->SetAttri(LADef_numChinese);
            //_DUMPCASE(m_pLink, m_pWord, 1004);
        } else if ( m_pWord->cwchLen() == 2 &&
                    ( m_pWord->fIsWordText(SC_WORD_WANLIANG) ||
                      m_pWord->fIsWordText(SC_WORD_YI4LIANG) ) ) {
            //  or 
            m_pWord = m_pLink->pSplitWord(m_pWord, 1);
            m_pWord->SetAttri(LADef_numInteger);
            m_pWord->SetAttri(LADef_numChinese);
            m_pWord->SetAttri(LADef_amtApprox);
            if (!fRecheckLexInfo(m_pWord->pNextWord())) {
                assert(0);
            }
            //_DUMPCASE(m_pLink, m_pWord, 1006);
        } else {
            m_pWord->SetErrID(ERRDef_NUMERIAL);
            //_DUMPCASE(m_pLink, m_pWord, 1003);
        }
    }
    return;
}


void CMorph::numGanZhiHandler()     // 
{
    // Occurs 29 times in 20M IME Corpus
    assert(!m_pWord->fIsTail());

    m_pLink->MergeWithNext(m_pWord);
    if (!m_pWord->fIsTail() && m_pWord->pNextWord()->fIsWordChar(SC_CHAR_NIAN)){
        m_pLink->MergeWithNext(m_pWord);
    }
    m_pWord->SetAttri(LADef_posT);
    //_DUMPLINK(m_pLink, m_pWord);
    return;
}


/*============================================================================
//  Following case processors:
//      Return NUM_PROCESSED if merged successfully or any error found
//      Return NUM_UNPROCESS if could not merged
//      Return NUM_ERROR if any error occurred, the error code in m_iecError
============================================================================*/

//  Ordinal number processors: called by BindOrdinal()
inline int CMorph::ordDi_Proc()         // 
{
    if (m_pWord->fGetAttri(LADef_numInteger) &&
        !m_pWord->fGetAttri(LADef_amtApprox) ||
        m_pWord->fIsWordChar(SC_CHAR_JI)) {
        //  + () or  + 
        USHORT    iStyle;
        if (m_pWord->fGetAttri(LADef_numChinese)) {
            iStyle = LADef_numChinese;
        } else if (m_pWord->fGetAttri(LADef_numArabic)) {
            iStyle = LADef_numArabic;
        } else if (m_pWord->fGetAttri(LADef_numSBCS)) {
            iStyle = LADef_numSBCS;
        } else if (m_pWord->fGetAttri(LADef_numMixed)){
            iStyle = LADef_numMixed;
        } else {
            assert(0);
            iStyle = 0;
        }
        m_pWord = m_pWord->pPrevWord();
        m_pLink->MergeWithNext(m_pWord);
        m_pWord->SetAttri(iStyle);
        m_pWord->SetAttri(LADef_numOrdinal);
        // Properties of LADef_numNumber are set in upper level
        //_DUMPLINK(m_pLink, m_pWord);
        return NUM_PROCESSED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return NUM_UNPROCESS;
}

inline int CMorph::ordChu_Proc()            // 
{
    if (m_pWord->fGetFlag(CWord::WF_CHAR) &&
        m_pWord->fGetAttri(LADef_numChinese) &&
        m_pWord->fGetAttri(LADef_numInteger) ) {
        //  + 
        m_pWord = m_pWord->pPrevWord();
        m_pLink->MergeWithNext(m_pWord);
        m_pWord->SetAttri(LADef_numOrdinal);
        // Properties of LADef_numNumber are set in upper level
        //_DUMPLINK(m_pLink, m_pWord);
        return NUM_PROCESSED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return NUM_UNPROCESS;
}


//  Decimal number processors: called by BindDecimal()
inline int CMorph::decBaiFen_Proc()     // 
{
    if (m_pWord->fGetAttri(LADef_numInteger) ||
        m_pWord->fGetAttri(LADef_numDecimal) ||
        m_pWord->fIsWordChar(SC_CHAR_JI) ) {

        if (m_pWord->fGetAttri(LADef_numChinese)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
            if (!m_pWord->fIsHead() &&
                m_pWord->pPrevWord()->fGetAttri(LADef_numInteger)) {

                if (m_pWord->pPrevWord()->fGetAttri(LADef_numChinese)) {
                    m_pWord = m_pWord->pPrevWord();
                    m_pLink->MergeWithNext(m_pWord);
                    //_DUMPLINK(m_pLink, m_pWord);
                } else {
                    // Error: 3
                    m_pWord->pPrevWord()->SetErrID(ERRDef_NUMERIAL);
                    //_DUMPLINK(m_pLink, m_pWord);
                }
            }
            m_pWord->SetAttri(LADef_numPercent);
            m_pWord->SetAttri(LADef_numNumber);
            //_DUMPLINK(m_pLink, m_pWord);
            return NUM_PROCESSED;
        } else {
            // Error: 50
            m_pWord->SetErrID(ERRDef_NUMERIAL);
            //_DUMPLINK(m_pLink, m_pWord);
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return NUM_UNPROCESS;
}


inline int CMorph::decCheng_Proc()          // 
{
    CWord* pWord;

    assert(m_pWord->pNextWord()->fIsWordChar(SC_CHAR_CHENG));

    if (!(m_pWord->fGetFlag(CWord::WF_CHAR) && m_pWord->fGetAttri(LADef_numInteger)) &&
        !(m_pWord->cwchLen() == 2 && fValidApproxNum(m_pWord->pwchGetText())) ) {
        // 
        m_pLink->MergeWithNext(m_pWord);
        m_pWord->SetErrID(ERRDef_NUMERIAL);
        //_DUMPLINK(m_pLink, m_pWord);
        return NUM_PROCESSED;
    }
    // Merge with 
    m_pLink->MergeWithNext(m_pWord);

    // Test number after 
    if (!m_pWord->fIsTail()) {
        pWord = m_pWord;
        m_pWord = m_pWord->pNextWord();
        if (GetNumber() == NUM_PROCESSED &&
            m_pWord->fGetFlag(CWord::WF_CHAR) &&
            m_pWord->fGetAttri(LADef_numInteger)) {
            // 
            m_pLink->MergeWithNext(pWord);
            //_DUMPLINK(m_pLink, m_pWord);
        } else if (m_pWord->fIsWordChar(SC_CHAR_BAN)) { // 
            m_pLink->MergeWithNext(pWord);
            //_DUMPLINK(m_pLink, m_pWord);
        }
        m_pWord = pWord;
    }

    // Test  or 
    if (!m_pWord->fIsHead() && !m_pWord->pPrevWord()->fIsHead()) {
        pWord = m_pWord->pPrevWord();
        if (pWord->fGetFlag(CWord::WF_CHAR) &&
            pWord->pPrevWord()->fGetFlag(CWord::WF_CHAR) &&
            pWord->pPrevWord()->fGetAttri(LADef_numInteger) && 
            ( pWord->fIsWordChar(SC_CHAR_DUNHAO) || 
              pWord->fIsWordChar(SC_CHAR_ZHI4)) ) {

            m_pWord = pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
            m_pLink->MergeWithNext(m_pWord);
            m_pWord->SetAttri(LADef_amtApprox);
            //_DUMPLINK(m_pLink, m_pWord);
        }
    }

    m_pWord->SetAttri(LADef_numPercent); // 
    m_pWord->SetAttri(LADef_numNumber);
    //_DUMPLINK(m_pLink, m_pWord);
    return NUM_PROCESSED;
}


inline int CMorph::decDian_Proc()           // 
{
    CWord*  pWord;
    int     iret = NUM_PROCESSED;

    assert(m_pWord->pNextWord()->fIsWordChar(SC_CHAR_DIAN3));

    if (!m_pWord->pNextWord()->fIsTail()) {
        pWord = m_pWord;
        m_pWord = m_pWord->pNextWord()->pNextWord();
        if (GetNumber() == NUM_PROCESSED &&
            m_pWord->fGetAttri(LADef_numChinese)) {
            //   
            BOOL fTime = m_pWord->fGetAttri(LADef_numInteger);
            m_pLink->MergeWithNext(pWord);
            m_pLink->MergeWithNext(pWord);
            if (fTime && !pWord->fIsTail() && pWord->pNextWord()->fIsWordChar(SC_CHAR_FEN)){
                // Merge with : 
                m_pLink->MergeWithNext(pWord);
                if (!pWord->fIsTail() &&
                    pWord->pNextWord()->fGetAttri(LADef_numChinese)) {

                    m_pWord = pWord->pNextWord();
                    if (NUM_PROCESSED == GetNumber() &&
                        !m_pWord->fIsTail() &&
                        m_pWord->pNextWord()->fIsWordChar(SC_CHAR_MIAO)) {
                        // Merge with  + 
                        m_pLink->MergeWithNext(pWord);
                        m_pLink->MergeWithNext(pWord);
                    }
                }
                pWord->SetAttri(LADef_tmGapMinute);
                pWord->SetAttri(LADef_tmPoint);
                pWord->SetAttri(LADef_posT);
                //_DUMPCASE(m_pLink, pWord, 1001);
            } else {
                if (pWord->fIsWordLastChar(SC_CHAR_SHI2)) { // 
                    pWord->SetErrID(ERRDef_NUMERIAL);
                } else { // Valid 
                    pWord->SetAttri(LADef_numDecimal);
                    pWord->SetAttri(LADef_numNumber);
                    pWord->SetAttri(LADef_numChinese);
                    //_DUMPCASE(m_pLink, pWord, 1002);
                }
            }
        } else {
            iret = NUM_UNPROCESS;
            //_DUMPLINK(m_pLink, pWord);
        }
        m_pWord = pWord;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return iret;
}


inline int CMorph::decFenZhi_Proc()     // 
{
    BOOL fError = FALSE;

    if (!m_pWord->fGetAttri(LADef_numChinese)) {
        fError = TRUE;
        //_DUMPLINK(m_pLink, m_pWord);
    }
    m_pWord = m_pWord->pPrevWord();
    m_pLink->MergeWithNext(m_pWord);
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_numChinese)) {

        m_pWord = m_pWord->pPrevWord();
        m_pLink->MergeWithNext(m_pWord);
    } else {
        fError = TRUE;
        //_DUMPLINK(m_pLink, m_pWord);
    }
    if (fError) {
        m_pWord->SetErrID(ERRDef_NUMERIAL);
    }
    m_pWord->SetAttri(LADef_numPercent);
    m_pWord->SetAttri(LADef_numNumber);
    return NUM_PROCESSED;
}


inline int CMorph::decBei_Proc()            // 
{
    m_pLink->MergeWithNext(m_pWord);
    if (!m_pWord->fIsTail() &&
        m_pWord->pNextWord()->fIsWordChar(SC_CHAR_BAN)) { 
        // 
        m_pLink->MergeWithNext(m_pWord);
        //_DUMPLINK(m_pLink, m_pWord);
    }
    m_pWord->SetAttri(LADef_numPercent);
    m_pWord->SetAttri(LADef_numNumber);
    //_DUMPLINK(m_pLink, m_pWord);
    return NUM_PROCESSED;
}



//  Level 4:
//  Service routines

//  Test 2-char Chinese string, and return whether it is a valid approx number
BOOL CMorph::fValidApproxNum(WCHAR* pwchWord)
{
    static WCHAR* rgszApproxNum[] = { 
                    SC_APXNUM_YILIANG ,    // L"\x4e00\x4e24"   // ""
                    SC_APXNUM_YIER    ,    // L"\x4e00\x4e8c"   // ""
                    SC_APXNUM_QIBA    ,    // L"\x4e03\x516b"   // ""
                    SC_APXNUM_SANLIANG,    // L"\x4e09\x4e24"   // ""
                    SC_APXNUM_SANWU   ,    // L"\x4e09\x4e94"   // ""
                    SC_APXNUM_SANSI   ,    // L"\x4e09\x56db"   // ""
                    SC_APXNUM_LIANGSAN,    // L"\x4e24\x4e09"   // ""
                    SC_APXNUM_ERSAN   ,    // L"\x4e8c\x4e09"   // ""
                    SC_APXNUM_WULIU   ,    // L"\x4e94\x516d"   // ""
                    SC_APXNUM_SIWU    ,    // L"\x56db\x4e94"   // ""
                    SC_APXNUM_LIUQI   ,    // L"\x516d\x4e03"   // ""
                    SC_APXNUM_BAJIU        // L"\x516b\x4e5d"   // ""
    };
    for (int i = 0; i < sizeof(rgszApproxNum) / sizeof(rgszApproxNum[0]); i++) {
        if (*((DWORD UNALIGNED *)pwchWord) == *((DWORD*)(rgszApproxNum[i]))) {
            return TRUE;
        }
    }
    return FALSE;
}


// Test duplicated conjunction char in the word
BOOL CMorph::fCheckDupChar(CWord* pWord)
{
    if (pWord->pNextWord() == NULL) {
        return FALSE;
    }
    int cw = pWord->cwchLen() - 1;
    for (int i = 0; i < cw; i++) {
        LPWSTR pwChar = pWord->pwchGetText();
        if (pwChar[i] == pwChar[i+1]) {
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\morph3.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Implement the affix attachment process in the Morph-analysis class.
Notes:      This implementation use table driven, handle prefix and suffix one by one

    How to add a new prefix or suffix handler:
            1. Mark afxPrefix or afxSuffix on the specific lex
            2. Collect all words that the affix can attached in the lexicon,
               and list these words in a separated text file with attribute def header
               name the attri with "pfx..." or "sfx...", and set group as "Morpheme"
            3. Add this attribute into the lex database, and rebuild the lexicon
               and LexProp.h file
            4. Insert the CAfxMap element into the specific mapping array, carefully
               choose the correct insert position in GBK sorting order
            5. Define the interface of affix processing function for the new affix in 
               Morph.h
            6. Implement the affix processing function to handle the attachment and 
               error detection at the correct position in this file.
            7. Insert a new case of the specific attribute ID into the switch block
               in PrefixHandler or SuffixHandler function

Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "lexicon.h"
#include "wordlink.h"
//#include "engindbg.h"
#include "scchardef.h"
#include "slmdef.h"

//  Define local constants
#define AFFIX_UNATTACH  0
#define AFFIX_ATTACHED  1
#define AFFIX_ERROR     2


//  Declare local datatypes of structure and global variables

// Define the affix id mapping structure
struct CAfxMap {
    WCHAR   m_wchAffix;
    int     m_iAttriID;
};

// Define the Prefix ID map
static CAfxMap v_rgpfxMap[] = {
        { SC_PFXCHAR_DAI,  LADef_pfxDai  }, // 0x4ee3  // ""
        { SC_PFXCHAR_WEI3, LADef_pfxWei3 }, // 0x4f2a  // ""
        { SC_PFXCHAR_ZHUN, LADef_pfxZhun }, // 0x51c6  // ""
        { SC_PFXCHAR_FU,   LADef_pfxFu   }, // 0x526f  // ""
        { SC_PFXCHAR_FAN,  LADef_pfxFan  }, // 0x53cd  // ""
        { SC_PFXCHAR_XIAO, LADef_pfxXiao }, // 0x5c0f  // ""
        { SC_PFXCHAR_WEI1, LADef_pfxWei1 }, // 0x5fae  // ""
        { SC_PFXCHAR_ZONG, LADef_pfxZong }, // 0x603b  // ""
        { SC_PFXCHAR_LAO,  LADef_pfxLao  }, // 0x8001  // ""
        { SC_PFXCHAR_CHAO, LADef_pfxChao }, // 0x8d85  // ""
        { SC_PFXCHAR_GUO,  LADef_pfxGuo  }, // 0x8fc7  // ""
        { SC_PFXCHAR_AA,   LADef_pfxAa   }, // 0x963f  // ""
        { SC_PFXCHAR_FEI,  LADef_pfxFei  }  // 0x975e  // ""
    };

// Define the suffix ID map
static CAfxMap v_rgsfxMap[] = {
        { SC_SFXCHAR_YE,    LADef_sfxYe     },// 0x4e1a  // ""
        { SC_SFXCHAR_YI,    LADef_sfxYi     },// 0x4eea  // ""
        { SC_SFXCHAR_MEN,   LADef_sfxMen    },// 0x4eec  // ""
        { SC_SFXCHAR_TI,    LADef_sfxTi     },// 0x4f53  // ""
        { SC_SFXCHAR_ER,    LADef_sfxEr     },// 0x513f  // ""
        { SC_SFXCHAR_ZHI,   LADef_sfxZhi    },// 0x5236  // ""
        { SC_SFXCHAR_HUA,   LADef_sfxHua    },// 0x5316  // ""
        { SC_SFXCHAR_DAN,   LADef_sfxDan    },// 0x5355  // ""
        { SC_SFXCHAR_YUAN,  LADef_sfxYuan   },// 0x5458  // ""
        { SC_SFXCHAR_PIN,   LADef_sfxPin    },// 0x54c1  // ""
        { SC_SFXCHAR_QI,    LADef_sfxQi     },// 0x5668  // ""
        { SC_SFXCHAR_CHANG, LADef_sfxChang  },// 0x573a  // ""
        { SC_SFXCHAR_XING2, LADef_sfxXing2  },// 0x578b  // ""
        { SC_SFXCHAR_DUI,   LADef_sfxDui    },// 0x5806  // ""
        { SC_SFXCHAR_TOU,   LADef_sfxTou    },// 0x5934  // ""
        { SC_SFXCHAR_ZI,    LADef_sfxZi     },// 0x5b50  // ""
        { SC_SFXCHAR_XUE,   LADef_sfxXue    },// 0x5b66  // ""
        { SC_SFXCHAR_JIA,   LADef_sfxJia    },// 0x5bb6  // ""  
        { SC_SFXCHAR_SHI4,  LADef_sfxShi4   },// 0x5e02  // ""
        { SC_SFXCHAR_SHI1,  LADef_sfxShi1   },// 0x5e08  // ""
        { SC_SFXCHAR_SHI,   LADef_sfxShi    },// 0x5f0f  // ""
        { SC_SFXCHAR_XING4, LADef_sfxXing4  },// 0x6027  // ""
        { SC_SFXCHAR_GAN,   LADef_sfxGan    },// 0x611f  // ""
        { SC_SFXCHAR_FANG,  LADef_sfxFang   },// 0x65b9  // ""
        { SC_SFXCHAR_JI,    LADef_sfxJi     },// 0x673a  // ""
        { SC_SFXCHAR_FA,    LADef_sfxFa     },// 0x6cd5  // ""
        { SC_SFXCHAR_YAN,   LADef_sfxYan    },// 0x708e  // ""
        { SC_SFXCHAR_LV,    LADef_sfxLv     },// 0x7387  // ""  
        { SC_SFXCHAR_SHENG, LADef_sfxSheng  },// 0x751f  // ""
        { SC_SFXCHAR_JIE,   LADef_sfxJie    },// 0x754c  // ""
        { SC_SFXCHAR_ZHENG, LADef_sfxZheng  },// 0x75c7  // ""
        { SC_SFXCHAR_SHENG3,LADef_sfxSheng3 },// 0x7701  // ""
        { SC_SFXCHAR_LAO,   LADef_sfxLao    },// 0x8001  // ""
        { SC_SFXCHAR_ZHE,   LADef_sfxZhe    },// 0x8005  // ""
        { SC_SFXCHAR_TING,  LADef_sfxTing   },// 0x8247  // ""
        { SC_SFXCHAR_GUAN,  LADef_sfxGuan   },// 0x89c2  // ""
        { SC_SFXCHAR_LUN,   LADef_sfxLun    },// 0x8bba  // ""
        { SC_SFXCHAR_ZHANG, LADef_sfxZhang  } // 0x957f  // ""
    };

#ifdef DEBUG
// Verify the sorting order of the id map of prefix and suffix
static BOOL fVerifyMaps(void)
{
    for (int i = 1; i < sizeof(v_rgpfxMap) / sizeof(CAfxMap); i++) {
        if (v_rgpfxMap[i].m_wchAffix < v_rgpfxMap[i-1].m_wchAffix) {
            return FALSE;
        }
    }
    for (i = 1; i < sizeof(v_rgsfxMap) / sizeof(CAfxMap); i++) {
        if(v_rgsfxMap[i].m_wchAffix < v_rgsfxMap[i-1].m_wchAffix) {
            return FALSE;
        }
    }
    return TRUE;
}
#endif // DEBUG

                   
/*============================================================================
Implement functions of affix attachment
============================================================================*/

// Affix attachment control function
BOOL CMorph::fAffixAttachment()
{
    assert(fVerifyMaps()); // Verify the id map of prefix and suffix in debugging code
    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);

    int iret;

    m_pWord = m_pLink->pGetHead();
    assert (m_pWord != NULL); // error: missing the terminate word node!

    // First pass scan fron left to right, suffix precede to prefix
    for ( ; m_pWord; m_pWord = m_pWord->pNextWord()) {

        if (!m_pWord->fGetAttri(LADef_afxSuffix)) {
            continue;
        }
        if ((iret = SuffixHandler()) == AFFIX_ERROR) {
            assert(0); // runtime error in suffix attachment
            return FALSE;
        } else if (iret == AFFIX_ATTACHED) {
            // suffix attached successfully
            assert(m_pWord->fGetFlag(CWord::WF_REDUCED));
            if (m_pWord->pPrevWord() &&
                m_pWord->pPrevWord()->fGetAttri(LADef_afxPrefix)) {
                // previous word is a prefix, try to attach
                m_pWord = m_pWord->pPrevWord(); // move current word pointer to prev word
                if ((iret = PrefixHandler()) == AFFIX_ERROR) {
                    assert(0); // runtime error in prefix attachment
                    return FALSE;
                } else if (iret == AFFIX_UNATTACH) {
                    assert(m_pWord->pNextWord() != NULL);
                    m_pWord = m_pWord->pNextWord();
                } else {
                }
            } // end of if (prev word is a prefix)
        } else {// end of if AFFIX_ATTACHED
        }
    }

    m_pWord = m_pLink->pGetTail();
    assert (m_pWord != NULL); // error: missing the terminate word node!
    // Second pass scan from right to left, prefix precede to suffix
    for ( m_pWord = m_pWord->pPrevWord(); m_pWord;
          m_pWord = m_pWord->pPrevWord() ) {
        if (!m_pWord->fGetAttri(LADef_afxPrefix)) {
            continue;
        }
        if ((iret = PrefixHandler()) == AFFIX_ERROR) {
            assert(0); // runtime error in prefix attachment
            return FALSE;
        } else if (iret == AFFIX_ATTACHED) { // prefix attached successfully
            assert(m_pWord->fGetFlag(CWord::WF_REDUCED));
            if (m_pWord->pNextWord() &&
                m_pWord->pNextWord()->fGetAttri(LADef_afxSuffix)) {
                // next word is a suffix, try to attach
                m_pWord = m_pWord->pNextWord(); // move current word pointer to next word
                if ((iret = SuffixHandler()) == AFFIX_ERROR) {
                    assert(0); // runtime error in suffix attachment
                    return FALSE;
                } else if (iret == AFFIX_UNATTACH) {
                    assert(m_pWord->pPrevWord() != NULL);
                    m_pWord = m_pWord->pPrevWord();
                } else {
                }
            } // end of if (next word is a suffix)
        } else {
        }
    } 

    return TRUE;
}


/*============================================================================
CMorph::PrefixHandler(void):
    Prefix handler functions:
Returns:
    AFFIX_ATTACHED if attached successfully
    AFFIX_UNATTACH if could not attached
    AFFIX_ERROR if runtime error occurred
============================================================================*/

int CMorph::PrefixHandler(void)
{
    assert(m_pWord->fGetAttri(LADef_afxPrefix));

    int iret = AFFIX_UNATTACH;
    
    switch(GetPrefixID()) {
        case LADef_pfxAa:       // 
            iret = pfxAa_Proc();
            break;

        case LADef_pfxChao:     // 
            iret = pfxChao_Proc();
            break;

        case LADef_pfxDai:      // 
            iret = pfxDai_Proc();
            break;

        case LADef_pfxFan:      // 
            iret = pfxFan_Proc();
            break;

        case LADef_pfxFei:      // 
            iret = pfxFei_Proc();
            break;

        case LADef_pfxFu:       // 
            iret = pfxFu_Proc();
            break;

        case LADef_pfxGuo:      // 
            iret = pfxGuo_Proc();
            break;

        case LADef_pfxLao:      // 
            iret = pfxLao_Proc();
            break;

        case LADef_pfxWei1:     // 
            iret = pfxWei1_Proc();
            break;

        case LADef_pfxWei3:     // 
            iret = pfxWei3_Proc();
            break;

        case LADef_pfxXiao:     // 
            iret = pfxXiao_Proc();
            break;

        case LADef_pfxZhun:     // 
            iret = pfxZhun_Proc();
            break;

        case LADef_pfxZong:     // 
            iret = pfxZong_Proc();
            break;

        default:
            // error attri id value in lexicon
            assert(0);
            break;
    }
/*  if(iret == AFFIX_ATTACHED) {
        //_DUMPLINK(m_pLink, m_pWord);
        }
*/  return iret;
}


/*============================================================================
CMorph::SuffixHandler(void):
    Suffix handler functions:
Returns:
    AFFIX_ATTACHED if attached successfully
    AFFIX_UNATTACH if could not attached
    AFFIX_ERROR if runtime error occurred
============================================================================*/
int CMorph::SuffixHandler(void)
{
    assert(m_pWord->fGetAttri(LADef_afxSuffix));

    int iret = AFFIX_UNATTACH;
    
    switch(GetSuffixID()) {
        case LADef_sfxZhang:    // 
            iret = sfxZhang_Proc();
            break;

        case LADef_sfxChang:    // 
            iret = sfxChang_Proc();
            break;

        case LADef_sfxDan:      // 
            iret = sfxDan_Proc();
            break;

        case LADef_sfxDui:      // 
            iret = sfxDui_Proc();
            break;

        case LADef_sfxEr:       // 
            iret = sfxEr_Proc();
            break;

        case LADef_sfxFa:       // 
            iret = sfxFa_Proc();
            break;

        case LADef_sfxFang:     // 
            iret = sfxFang_Proc();
            break;

        case LADef_sfxGan:      // 
            iret = sfxGan_Proc();
            break;

        case LADef_sfxGuan:     // 
            iret = sfxGuan_Proc();
            break;

        case LADef_sfxHua:      // 
            iret = sfxHua_Proc();
            break;

        case LADef_sfxJi:       // 
            iret = sfxJi_Proc();
            break;

        case LADef_sfxJia:      // 
            iret = sfxJia_Proc();
            break;

        case LADef_sfxJie:      // 
            iret = sfxJie_Proc();
            break;

        case LADef_sfxLao:      // 
            iret = sfxLao_Proc();
            break;

        case LADef_sfxLv:       // 
            iret = sfxLv_Proc();
            break;

        case LADef_sfxLun:      // 
            iret = sfxLun_Proc();
            break;

        case LADef_sfxMen:      // 
            iret = sfxMen_Proc();
            break;

        case LADef_sfxPin:      // 
            iret = sfxPin_Proc();
            break;

        case LADef_sfxQi:       // 
            iret = sfxQi_Proc();
            break;

        case LADef_sfxSheng:    // 
            iret = sfxSheng_Proc();
            break;

        case LADef_sfxSheng3:   // 
            iret = sfxSheng3_Proc();
            break;

        case LADef_sfxShi1:     // 
            iret = sfxShi1_Proc();
            break;

        case LADef_sfxShi4:     // 
            iret = sfxShi4_Proc();
            break;

        case LADef_sfxShi:      // 
            iret = sfxShi_Proc();
            break;

        case LADef_sfxTi:       // 
            iret = sfxTi_Proc();
            break;

        case LADef_sfxTing:     // 
            iret = sfxTing_Proc();
            break;

        case LADef_sfxTou:      // 
            iret = sfxTou_Proc();
            break;

        case LADef_sfxXing2:    // 
            iret = sfxXing2_Proc();
            break;

        case LADef_sfxXing4:    //    
            iret = sfxXing4_Proc();
            break;

        case LADef_sfxXue:      // 
            iret = sfxXue_Proc();
            break;

        case LADef_sfxYan:      // 
            iret = sfxYan_Proc();
            break;

        case LADef_sfxYe:       // 
            iret = sfxYe_Proc();
            break;

        case LADef_sfxYi:       // 
            iret = sfxYi_Proc();
            break;

        case LADef_sfxYuan:     // 
            iret = sfxYuan_Proc();
            break;

        case LADef_sfxZhe:      // 
            iret = sfxZhe_Proc();
            break;

        case LADef_sfxZheng:    // 
            iret = sfxZheng_Proc();
            break;

        case LADef_sfxZhi:      // 
            iret = sfxZhi_Proc();
            break;

        case LADef_sfxZi:       // 
            iret = sfxZi_Proc();
            break;

        default:
            // error attri id setting in lexicon
            assert(0);
            break;
        }
/*  if(iret == AFFIX_ATTACHED) {
        //_DUMPLINK(m_pLink, m_pWord);
        }
*/  return iret;
}


/*============================================================================
CMorph::GetPrefixID(void):
    Get Prefix ID
Returns:
    LADef_pfx...
    -1 if m_pWord is not a prefix
============================================================================*/
inline int CMorph::GetPrefixID(void)
{
    // only single char words mark as prefix
    if (!m_pWord->fGetFlag(CWord::WF_CHAR)) {
        assert(0); // all prefix should be single char words
        return -1;
    }

    assert(m_pWord->cwchLen() == 1);

    WCHAR*   pwchWord = m_pWord->pwchGetText();
#ifdef DEBUG
    // Serialize search to verify the result
    int dbg_iret = -1;
    for (int dbg_i =0; dbg_i < sizeof(v_rgpfxMap) / sizeof(CAfxMap); dbg_i++) {
        if (v_rgpfxMap[dbg_i].m_wchAffix == *pwchWord ) {
            dbg_iret = v_rgpfxMap[dbg_i].m_iAttriID;
            break;
        }
    }
    // the attri ID of matched prefix stored in the dbg_iret.
#endif // DEBUG

    // Binary search for the specific prefix
    int lo = 0, hi = (sizeof(v_rgpfxMap) / sizeof(CAfxMap)) - 1, mi, icmp;
    while (lo <= hi) {
        mi = (lo + hi) / 2;
        if ((icmp = *pwchWord - v_rgpfxMap[mi].m_wchAffix) == 0) {
            assert(v_rgpfxMap[mi].m_iAttriID == dbg_iret);
            return v_rgpfxMap[mi].m_iAttriID;
        } else if (icmp < 0) {
            hi = mi - 1;
        } else {
            lo = mi + 1;
        }
    }
    assert(dbg_iret == -1);
    return -1; // can not found the prefix!
}


/*============================================================================
CMorph::GetPrefixID(void):
    Get Suffix ID
Returns:
    LADef_sfx...
    -1 if m_pWord is not a suffix
Remarks: because it's likely to extend the prefix or suffix to more than single char
         words, so I dup the binary search code in two isolated functions.
         I do not like to make the assumption that prefix and suffix MUST share a same
         search mechanism, although they are same till now!
============================================================================*/
inline int CMorph::GetSuffixID(void)
{
    // only single char words mark as suffix
    if (!m_pWord->fGetFlag(CWord::WF_CHAR)) {
        assert(0); // all suffix should be single char words
        return -1;
    }

    assert(m_pWord->cwchLen() == 1);

    WCHAR*   pwchWord = m_pWord->pwchGetText();
#ifdef DEBUG
    // Serialize search to verify the result
    int dbg_iret = -1;
    for (int dbg_i =0; dbg_i < sizeof(v_rgsfxMap) / sizeof(CAfxMap); dbg_i++) {
        if (v_rgsfxMap[dbg_i].m_wchAffix == *pwchWord ) {
            dbg_iret = v_rgsfxMap[dbg_i].m_iAttriID;
            break;
        }
    }
    // the attri ID of matched prefix stored in the dbg_iret.
#endif // DEBUG

    // Binary search for the specific prefix
    int lo = 0, hi = (sizeof(v_rgsfxMap) / sizeof(CAfxMap)) - 1, mi, icmp;
    while (lo <= hi) {
        mi = (lo + hi) / 2;
        if ((icmp = *pwchWord - v_rgsfxMap[mi].m_wchAffix) == 0) {
            assert(v_rgsfxMap[mi].m_iAttriID == dbg_iret);
            return v_rgsfxMap[mi].m_iAttriID;
        } else if (icmp < 0) {
            hi = mi - 1;
        } else {
            lo = mi + 1;
        }
    }
    assert(dbg_iret == -1);
    return -1; // can not found the prefix!
}


/*============================================================================
//  Implement prefix process functions for each prefix
//  For prefix process functions:
//      Return AFFIX_ATTACHED if attached successfully
//      Return AFFIX_UNATTACH if could not attached
//      Return AFFIX_ERROR if runtime error occurred
============================================================================*/
inline int CMorph::pfxAa_Proc(void)     // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxAa)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxChao_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxChao)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posB);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxDai_Proc(void)    // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxDai)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxFan_Proc(void)    // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxFan)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxFei_Proc(void)    // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxFei)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posB);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxFu_Proc(void)     // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxFu)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxGuo_Proc(void)    // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxGuo)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posB);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxLao_Proc(void)    // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxLao)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxWei1_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxWei1)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxWei3_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxWei3)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxXiao_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxXiao)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxZhun_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxZhun)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxZong_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxZong)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}


/*============================================================================
//  Implement suffix process functions for each suffix
//  For suffix process functions:
//      Return AFFIX_ATTACHED if attached successfully
//      Return AFFIX_UNATTACH if could not attached
//      Return AFFIX_ERROR if runtime error occurred
============================================================================*/

inline int CMorph::sfxZhang_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxZhang)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semZhang);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxChang_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxChang)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semChang);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxDan_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxDan)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semDan);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxDui_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxDui)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semDui);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxEr_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxEr)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semEr);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxFa_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxFa)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semFa);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxFang_Proc(void)       // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxFang)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semFang);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxGan_Proc(void)        // 
{
    if (m_pWord->pPrevWord() == NULL) {
        m_pWord->SetErrID(ERRDef_WORDUSAGE);
        return AFFIX_UNATTACH;
    }
    CWord* pPrev = m_pWord->pPrevWord();
    if (pPrev->fGetAttri(LADef_sfxGan)) {
        m_pWord = pPrev;
        m_pLink->MergeWithNext(m_pWord, FALSE);
        m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        m_pWord->SetWordID(SLMDef_semGan);
        //_DUMPLINK(m_pLink, m_pWord);
        return AFFIX_ATTACHED;
    }
    if (pPrev->fIsWordChar(SC_CHAR_ZHI)) { // " "
        if (pPrev->pPrevWord() && pPrev->pPrevWord()->cwchLen() >= 2) { // "AB..  "
            m_pWord = pPrev->pPrevWord();
            m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semGan);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        } else { // " or A"
            pPrev->SetErrID(ERRDef_WORDUSAGE); // Mark error on ""
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_UNATTACH;
        }
    }
    if (pPrev->cwchLen() == 1) {
        if (m_pLex->fIsCharFeature(m_pWord->GetLexHandle(),
                                   LFDef_verbModifier, 
                                   *(pPrev->pwchGetText()) ) ) {
            m_pWord = pPrev;
            m_pLink->MergeWithNext(m_pWord);
            m_pWord->SetAttri(LADef_posV);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AFFIX_UNATTACH;
    }
    // ""
    // pPrev->m_idErr = ERRDef_WORDUSAGE;
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxGuan_Proc(void)       // 
{
    if (m_pWord->pPrevWord() != NULL) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxGuan)) {
            m_pWord = m_pWord->pPrevWord();
            if (m_pWord->pPrevWord() &&
                m_pWord->pPrevWord()->fGetAttri(LADef_sfxGuan)) {
                // <  > <  >
                m_pWord = m_pWord->pPrevWord();
                m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
            } else {
                m_pLink->MergeWithNext(m_pWord, FALSE);
            }
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semGuan);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    // Mark "" as posV, will not confuse the proper name identification rules
    m_pWord->SetAttri(LADef_posV);
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxHua_Proc(void)        // 
{
    if (m_pWord->pPrevWord() != NULL) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxHua)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posV);
            m_pWord->SetAttri(LADef_posA);
            m_pWord->SetAttri(LADef_pfxFei); // < ... >
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semHua);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        } else if (m_pWord->pPrevWord()->fGetAttri(LADef_miscElement)) {
            // :  
            BOOL fFound = FALSE;
            if (m_pWord->pNextWord() &&
                m_pWord->pNextWord()->fGetAttri(LADef_miscElement)) { // 

                m_pLink->MergeWithNext(m_pWord);
                fFound = TRUE;
            } else if (m_pWord->pNextWord() &&
                       m_pWord->pNextWord()->fGetAttri(LADef_posM) && 
                       m_pWord->pNextWord()->pNextWord()->pNextWord() &&
                       m_pWord->pNextWord()->pNextWord()->fGetAttri(LADef_miscElement)){
                // 
                m_pLink->MergeWithNext(m_pWord);
                m_pLink->MergeWithNext(m_pWord);
                fFound = TRUE;
            }
            if (fFound) {
                m_pWord = m_pWord->pPrevWord();
                if (m_pWord->pPrevWord() &&
                    m_pWord->pPrevWord()->fGetAttri(LADef_posM)){

                    m_pWord = m_pWord->pPrevWord();
                    m_pLink->MergeWithNext(m_pWord);
                }
                m_pLink->MergeWithNext(m_pWord);
                m_pWord->SetAttri(LADef_nounTerm);
                m_pWord->SetAttri(LADef_posN);
                //_DUMPLINK(m_pLink, m_pWord);
                return AFFIX_ATTACHED;
            }
        } else {
        }
    }
    if (m_pWord->pNextWord() &&
        m_pWord->pNextWord()->pNextWord() &&
        m_pWord->pNextWord()->pNextWord()->pNextWord() &&
        m_pWord->pNextWord()->pNextWord()->fIsWordChar(SC_CHAR_WEI)) {
        // Test  A  B pattern
        m_pWord = m_pLink->pRightMerge(m_pWord, 3, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return AFFIX_ATTACHED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxJi_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxJi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semJi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxJia_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxJia)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semJia);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxJie_Proc(void)        // 
{
    CWord* pPrev = m_pWord->pPrevWord();
    if (pPrev) {
        if (pPrev->fGetAttri(LADef_sfxJie)) {
            m_pWord = pPrev;
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semJie);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
#ifndef _CHSWBRKR_DLL_IWORDBREAKER
        if (pPrev->fIsWordChar(SC_CHAR_WEI)) {
            // Try "..." pattern
            int ilen = 0;
            pPrev = pPrev->pPrevWord();
            for (; ilen < 3 && pPrev; ilen++, pPrev = pPrev->pPrevWord()) {
                if (pPrev->fGetAttri(LADef_punPunct)) {
                    break;
                }
                if (pPrev->fIsWordChar(SC_CHAR_YI3)) { // Matach!!
                    while (pPrev->pNextWord() != m_pWord) {
                        m_pLink->MergeWithNext(pPrev);
                    }
                    m_pWord = pPrev;
                    m_pLink->MergeWithNext(m_pWord);
                    m_pWord->SetAttri(LADef_posP);
                    //_DUMPLINK(m_pLink, m_pWord);
                    return AFFIX_ATTACHED;
                }
            }
        }
#endif // _CHSWBRKR_DLL_IWORDBREAKER
        m_pWord->SetAttri(LADef_posN); // As noun execpt in the proper name.
    } else {
        // Should not be the first word in a sentence
        m_pWord->SetErrID(ERRDef_WORDUSAGE);
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxLao_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxLao)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semLao);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxLv_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxLv)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semLv);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
        // { V()+V()+ } or { V()+N()+ } 
        // , 
    }
    if (m_pWord->pNextWord() &&
        m_pWord->pNextWord()->fGetFlag(CWord::WF_CHAR) &&
        m_pLex->fIsCharFeature(m_pWord->GetLexHandle(),
                               LFDef_verbObject, 
                               *(m_pWord->pNextWord()->pwchGetText()) ) ) {
        //  + (~/~/~/~/~/~) (40M Corpus)
        m_pLink->MergeWithNext(m_pWord, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return AFFIX_ATTACHED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxLun_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxLun)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semLun);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxMen_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxMen)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semMen);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxPin_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxPin)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semPin);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxQi_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxQi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semQi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxSheng_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxSheng)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semSheng);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxSheng3_Proc(void)     // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxSheng3)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semSheng3);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxShi1_Proc(void)       // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxShi1)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semShi1);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxShi4_Proc(void)       // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxShi4)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semShi4);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxShi_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxShi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posB);
            m_pWord->SetAttri(LADef_pfxFei);
            m_pWord->SetAttri(LADef_pfxChao);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semShi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        } else if (m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_YI)) { // "  "
            if (m_pWord->pNextWord() &&
                m_pWord->pNextWord()->pNextWord() &&
                m_pWord->pNextWord()->fGetFlag(CWord::WF_CHAR) &&
                m_pWord->pNextWord()->fGetAttri(LADef_posM) &&
                // m_pWord->pNextWord()->pNextWord()->pNextWord() &&
                m_pWord->pNextWord()->pNextWord()->fGetFlag(CWord::WF_CHAR) &&
                m_pWord->pNextWord()->pNextWord()->fGetAttri(LADef_posQ) )
            {
                //    pattern 
                m_pWord = m_pWord->pPrevWord();
                m_pWord = m_pLink->pRightMerge(m_pWord, 3, FALSE);
                m_pWord->SetAttri(LADef_posD); // 
                //_DUMPLINK(m_pLink, m_pWord);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            } else {
                // " " 
                m_pWord = m_pWord->pPrevWord();
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pWord->SetAttri(LADef_posZ);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                //_DUMPLINK(m_pLink, m_pWord);
            }
            return AFFIX_ATTACHED;
        } else if (fCheckShiQian(m_pWord->pPrevWord())) {
#ifndef _CHSWBRKR_DLL_IWORDBREAKER
        // "": 
            do  {
                m_pWord = m_pWord->pPrevWord();
                m_pLink->MergeWithNext(m_pWord);
            } while (m_pWord->pPrevWord() && fCheckShiQian(m_pWord->pPrevWord()));
            m_pWord->SetAttri(LADef_posB);
            m_pWord->SetWordID(SLMDef_semShi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
#endif // _CHSWBRKR_DLL_IWORDBREAKER
        } else {
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

//  sfxShi_Proc() service function
inline BOOL CMorph::fCheckShiQian(CWord* pWord)
{
    assert(pWord->pNextWord());
    if (pWord->fGetAttri(LADef_posM) ||
        pWord->fGetAttri(LADef_numArabic) ||
        pWord->fGetAttri(LADef_nounPlace) ||
        pWord->fGetAttri(LADef_nounTM) ||
        pWord->fGetAttri(LADef_nounTerm) && pWord->fGetFlag(CWord::WF_QUOTE) ||
        pWord->fGetAttri(LADef_genDBForeign) ||
        pWord->fGetAttri(LADef_nounPerson) ) {

        return TRUE;
    }
    return FALSE;
}

inline int CMorph::sfxTi_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxTi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semTi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxTing_Proc(void)       // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxTing)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semTing);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    m_pWord->SetAttri(LADef_posN); // Mark as Noun if could no combind
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxTou_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxTou)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semTou);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxXing2_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxXing2)) {
            m_pWord = m_pWord->pPrevWord();
            if (m_pWord->pPrevWord() &&
                m_pWord->pPrevWord()->fGetAttri(LADef_sfxXing2)) {
                //  N-X-  A-X-NA
                // "  ", "  " 
                // ""!
                m_pWord = m_pWord->pPrevWord();
                m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
                //_DUMPLINK(m_pLink, m_pWord);
            } else {
                m_pLink->MergeWithNext(m_pWord, FALSE);
            }
            m_pWord->SetAttri(LADef_posB);
            m_pWord->SetAttri(LADef_pfxFei);
            m_pWord->SetAttri(LADef_pfxChao);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semXing2);
            // m_pWord->SetAttri(LADef_pfxQuan); ""
            // m_pWord->SetAttri(LADef_...); 
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        } else if (fCheckXingQian(m_pWord->pPrevWord())) {
        // "":
#ifndef _CHSWBRKR_DLL_IWORDBREAKER
            do  {
                m_pWord = m_pWord->pPrevWord();
                m_pLink->MergeWithNext(m_pWord);
            } while(m_pWord->pPrevWord() && fCheckXingQian(m_pWord->pPrevWord()));
            m_pWord->SetAttri(LADef_posB);
            m_pWord->SetWordID(SLMDef_semXing2);
            // 40M IME !
            // m_pWord->SetAttri(LADef_...); , 
            // !!!, 
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
#endif // _CHSWBRKR_DLL_IWORDBREAKER
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

//  sfxXing2_Proc() service function
inline BOOL CMorph::fCheckXingQian(CWord* pWord)
{
    assert(pWord->pNextWord());

    if (pWord->fGetAttri(LADef_posM) ||
        pWord->fGetAttri(LADef_numArabic) ||
        pWord->fGetAttri(LADef_nounPlace) ||
        pWord->fGetAttri(LADef_nounTM) ||
        pWord->fGetAttri(LADef_nounTerm) && pWord->fGetFlag(CWord::WF_QUOTE) ||
        pWord->fGetAttri(LADef_genDBForeign) ||
        pWord->fGetAttri(LADef_nounPerson) ) {

        return TRUE;
    }
    return FALSE;
}

inline int CMorph::sfxXing4_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxXing4)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semXing4);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxXue_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxXue)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semXue);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxYan_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxYan)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semYan);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxYe_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxYe)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semYe);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxYi_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxYi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semYi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxYuan_Proc(void)       // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxYuan)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semYuan);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxZhe_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxZhe)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semZhe);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxZheng_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxZheng)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semZheng);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxZhi_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxZhi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semZhi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxZi_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxZi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semZi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\myafx.cpp ===
// MyAFX.cpp
// Pre-compile header

#include "myafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\myafx.h ===
// MyAFX.h
// Pre-compile header
#ifndef _MY_AFX_H
#define _MY_AFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#define WINVER 0x0400

#ifdef _DEBUG
#undef DEBUG
#define DEBUG
#endif

#define _CHSWBRKR_DLL_IWORDBREAKER

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>

#include <assert.h>
#include <crtdbg.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\morphw.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Implement the public member functions and control process of the Morph-
            analysis class. The pre-combind process
Notes:      In order to make all the 3 parts of Morph-analysis isolated, this class
            will be implemented into 4 cpp files:
                Morph.cpp   implement the public member function and control process
                Morph1.cpp  implement the numerical words binding
                Morph2.cpp  implement the affix attachment
                Morph3.cpp  implement the morphological pattern identification
            All these 4 cpp files will share morph.h header file
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "scchardef.h"
#include "lexicon.h"
#include "wordlink.h"
//#include "engindbg.h"
#include "proofec.h"

// Define return value for pre-combind processing functions
#define PRE_UNMERGE 1
#define PRE_MERGED  2
#define PRE_ERROR   3
// Define the max length of short quote(exclude the quote mark nodes), short quote
// will be merge to a single node, and treated as term of proper noun
#define MORPH_SHORT_QUOTE   4

/*============================================================================
Implementation of PUBLIC member functions
============================================================================*/

// Constructor
CMorph::CMorph()
{
    m_pLink = NULL;
    m_pLex = NULL;
}


// Destructor
CMorph::~CMorph()
{
    TermMorph();
}


// Initialize the morph class
int CMorph::ecInit(CLexicon* pLexicon)
{
    assert(pLexicon);

    m_pLex = pLexicon;
    return PRFEC::gecNone;
}


// process affix attachment
int CMorph::ecDoMorph(CWordLink* pLink, BOOL fAfxAttach)
{
    assert(pLink);

    m_pLink = pLink;
    m_iecError = PRFEC::gecNone;

    m_pWord = m_pLink->pGetHead();
    assert(m_pWord != NULL);    // error: missing the terminate word node!

    if (m_pWord == NULL) {
        assert(0); // should not run to here for a empty link!
        return PRFEC::gecNone;
    }
    if (m_pWord->pNextWord() == NULL) {
        return PRFEC::gecNone;
    }
    if (!fPreCombind()) {
        return m_iecError;
    }
    if (!fAmbiAdjust()) {
        return m_iecError;
    }
    if (!fNumerialAnalysis()) {
        return m_iecError;
    }
    if (!fPatternMatch()) {
        return m_iecError;
    }
    if (fAfxAttach && !fAffixAttachment()) {
        return m_iecError;
    }

    return PRFEC::gecNone;
}

/*============================================================================
Implementation of Private member functions
============================================================================*/
// Terminate the Morph class
void CMorph::TermMorph(void)
{
    m_pLex = NULL;
    m_pLink = NULL;
}


/*============================================================================
Private functiona for pre-combind process
============================================================================*/
//  Pre-combind process control function.
//  One pass scan the WordLink and call process functions
BOOL CMorph::fPreCombind()
{
    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);

    int iret;

    // Scan from left to right for DBForeign Combined
    m_pWord = m_pLink->pGetHead();
    assert(m_pWord != NULL && m_pWord->pNextWord() != NULL); // error: missing the terminate word node!

    for ( ; m_pWord->pNextWord() != NULL; m_pWord = m_pWord->pNextWord()) {
        if (m_pWord->fGetFlag(CWord::WF_SBCS) ||
            m_pWord->fGetFlag(CWord::WF_REDUCED)) {
            continue;
        }
        if ((iret = DBForeignHandler()) != PRE_UNMERGE) {
            if (iret == PRE_ERROR) {
                return FALSE;
            }
            continue;
        }
    }

    // Scan from left to right for quotation process
    m_pWord = m_pLink->pGetHead();
    for ( ; m_pWord->pNextWord() != NULL; m_pWord = m_pWord->pNextWord()) {
        if (m_pWord->fGetFlag(CWord::WF_SBCS) ||
            m_pWord->fGetFlag(CWord::WF_REDUCED)) {
            continue;
        }
        if ((iret = QuoteHandler()) != PRE_UNMERGE) {
            if (iret == PRE_ERROR) {
                return FALSE;
            }
            continue;
        }
    }
    return TRUE;
}


//  DBForeignHandler combind the conjunctive DB foreign characters
inline int CMorph::DBForeignHandler(void)
{
    assert(m_pWord->pNextWord());
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));

    if (m_pWord->fGetAttri(LADef_genDBForeign)) {
        while (m_pWord->pNextWord()->pNextWord() && 
                m_pWord->pNextWord()->fGetAttri(LADef_genDBForeign)) {
            m_pLink->MergeWithNext(m_pWord);
        }
        if (m_pWord->fGetFlag(CWord::WF_REDUCED)) {
            m_pWord->SetAttri(LADef_genDBForeign);
            //_DUMPLINK(m_pLink, m_pWord);
            return PRE_MERGED;
        }
    }
    return PRE_UNMERGE;
}


//  Short quotation merge proc
inline int CMorph::QuoteHandler(void)
{
    assert(m_pWord->pNextWord());
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));

    int iret;
    if (m_pWord->fGetAttri(LADef_punPair)) {
        if (m_pWord->GetErrID() == ERRDef_PUNCTMATCH) {
            return PRE_MERGED; // Don't check on the error quote marks!
        }
        assert(m_pWord->cwchLen() == 1);
        if (m_pWord->fIsWordChar(SC_CHAR_PUNL1)) {
            iret = preQuote1_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL2)) {
            iret = preQuote2_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL3)) {
            iret = preQuote3_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL4)) {
            iret = preQuote4_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL5)) {
            iret = preQuote5_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL6)) {
            iret = preQuote6_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL7)) {
            iret = preQuote7_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL8)) {
            iret = preQuote8_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL9)) {
            iret = preQuote9_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL10)) {
            iret = preQuote10_Proc();
        } else { 
            if (m_pWord->pPrevWord() != NULL &&
                !m_pWord->pPrevWord()->fGetFlag(CWord::WF_QUOTE)) {
                // Found unmatched right quote!!!
                m_pWord->SetErrID(ERRDef_PUNCTMATCH);
            }
            iret = PRE_MERGED;
        }
        return iret;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return PRE_UNMERGE;
}


/*============================================================================
In order to handle different operation for different quote marks pair, 
I use a separate process function for each kind of quote pair
============================================================================*/
inline int CMorph::preQuote1_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL1, SC_CHAR_PUNR1);
}


inline int CMorph::preQuote2_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL2, SC_CHAR_PUNR2);
}


inline int CMorph::preQuote3_Proc(void)    //  
{
    return PRE_UNMERGE;
}


inline int CMorph::preQuote4_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL4, SC_CHAR_PUNR4);
}

inline int CMorph::preQuote5_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL5, SC_CHAR_PUNR5);
}

inline int CMorph::preQuote6_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL6, SC_CHAR_PUNR6);
}

inline int CMorph::preQuote7_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL7, SC_CHAR_PUNR7);
}

inline int CMorph::preQuote8_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL8, SC_CHAR_PUNR8);
}

inline int CMorph::preQuote9_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL9, SC_CHAR_PUNR9);
}

inline int CMorph::preQuote10_Proc(void)   //  
{
    return preQuoteMerge(SC_CHAR_PUNL10, SC_CHAR_PUNR10);
}


/*============================================================================
Common routine to handle       
Merge into one node means will not proofread on the quote text any more!!!
============================================================================*/
int CMorph::preQuoteMerge(WCHAR wchLeft, WCHAR wchRight)
{
    assert(m_pWord->pNextWord());

    int     ciWord = 0;
    CWord*  pNext = m_pWord->pNextWord();

    do {
        if (pNext->fGetAttri(LADef_punPair)) {
            if (pNext->fIsWordChar(wchRight)) { // found  after 
                if(ciWord && ciWord < MORPH_SHORT_QUOTE) {
                    m_pLink->pRightMerge(m_pWord->pNextWord(), ciWord - 1);
                    m_pWord->SetFlag(CWord::WF_QUOTE);
                    m_pWord->SetAttri(LADef_nounTerm);
                    //_DUMPLINK(m_pLink, m_pWord);
                }
                return PRE_MERGED;
            } 
        }
        pNext->SetFlag(CWord::WF_QUOTE);
        ciWord++;
        pNext = pNext->pNextWord();
    } while (pNext != NULL);

    return PRE_UNMERGE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\myplex.cpp ===
// MyPlex.cpp

#include "myafx.h"

#include "MyPlex.h"
// *****************************************************************************************
//  Implementation of CMyPlex
// *****************************************************************************************
CMyPlex* CMyPlex::Create(
            CMyPlex*& pHead,    // Head block this block will insert before
            UINT nMax,          // Number of elements in this block
            UINT cbElement)     // Size of each element
{
    assert(nMax > 0 && cbElement > 0);
    CMyPlex* p = (CMyPlex*)new BYTE[sizeof(CMyPlex) + nMax * cbElement];
    if (!p) {
        return NULL;
    }
    p->m_pNext = pHead;
    pHead = p;      // Note: pHead passed by reference!
    return p;
}

void CMyPlex::FreeChain()
{
    CMyPlex* p = this;
    while(p != NULL) {
        BYTE* pBytes = (BYTE*)p;
        CMyPlex* pNext = p->m_pNext;
        delete[] pBytes;
        p = pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\myplex.h ===
// MyPlex.h
// a fixed size memory allocator stolen from MFC's source code
#ifndef _MYPLEX_H_
#define _MYPLEX_H_

// *****************************************************************************************
//  Declare Plex structure for LexNode memory management
// *****************************************************************************************
#pragma pack(1)
struct CMyPlex
{
    CMyPlex* m_pNext;

    void* Data() { return this+1; }
    static CMyPlex* Create(CMyPlex*& pHead, UINT nMax, UINT cbElement);
    void FreeChain();   // Free this block and all linked
};
#pragma pack()

#endif  // _MYPLEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ChsBrkr.rc
//
#define IDS_PROJNAME                    100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\proofec.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  Grammar Error Codes

Purpose:	Define error code for Proof Engine. 
			All algorithm modules: WrdBreak, Rules and HeuRead return these error codes
			MainDic also return these error code to PrfEngine module
			These error code are get from CGAPI directly
Owner:		donghz@microsoft.com
Platform:	Win32
Revise:		First created by: donghz	5/29/97
============================================================================*/

/*============================================================================
Grammar Error Codes
This error code set is very stable, because it defined in the common CGAPI spec.
Only level 2 modules (algorithm and MainDic) employ this error code set, and these
error codes can passed to the CGAPI caller through PrfEngine layer directly
============================================================================*/
#ifndef _PROOFEC_H
#define _PROOFEC_H

struct PRFEC
{
	enum EC
	{
		gecNone					=	0,  /* no errors */
		gecErrors				=	1,  /* one or more errors; see GRB */
		gecUnknown				=	2,  /* unknown error */
		gecPartialSentence		=	3,  /* refill GIB; save text >= ichStart */
		gecSkipSentence			=	4,  /* internal error; skip this sentence */
		gecEndOfDoc				=   5,  /* hit end of doc; last portion blank */
		gecOOM                  =   6,  /* out of memory; skip sentence */
		gecBadMainDict			=	7,  /* bad main dictionary */
		gecBadUserDict			=	8,  /* bad user dictionary */
		gecModuleInUse			=	9,  /* another app is using this dll */
		gecBadProfile			=  10,  /* can't open profile; using defaults */
		gecNoMainDict			=  11,  /* main dict not loaded yet */
		gecHaveMainDict			=  12,  /* have main dict (during GramOpenMdt) */
		gecNoSuchError			=  13,  /* no such error in grb */
		//gecCantPutupDlg		=  14,     now use gecOOM instead 
		gecCancelDlg 			=  15,  /* options dialog was canceled */
		gecRuleIsOn 			=  16,  /* rule is not ignored */
		gecIOErrorMdt           =  17,  /* Read,write,or share error with Mdt. */
		gecIOErrorUdr           =  18,  /* Read,write,or share error with Udr. */
		gecIOErrorPrf           =  19,  /* Read,write,or share error with Profile file */
		gecNoStats              =  20,  /* Stats not currently available */
		gecUdrFull              =  21,  /* User dictionary full*/
		gecInvalidUdrEntry      =  22,  /* Invalid user dictionary entry*/
		//Tnetative.
		gecForeignLanguage      =  22,  /* passed sentence is not a sentence in lid*/
		gecInterrupted          =  23,  /* checking interrupted by caller */
        // new Udr error
		gecNoUserDict			=  24   /* No user dictionary */
	};
};

#endif //PROOFEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\registry.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Registry
Purpose:   Helper functions registering and unregistering a component
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include "registry.h"
// Constants
// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

// Convert a CLSID to a char string.
BOOL CLSIDtoString(const CLSID& clsid,
                   LPTSTR szCLSID,
                   int length)
{
    assert(szCLSID);
    assert(length >= CLSID_STRING_SIZE) ;
    // Get CLSID
#ifdef _UNICODE
    HRESULT hr = StringFromGUID2(clsid, szCLSID, length) ;
    if (!SUCCEEDED(hr)) {
        assert(0);
        return FALSE;
    }
#else
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    if (!SUCCEEDED(hr)) {
        assert(0);
        // Free memory.
        CoTaskMemFree(wszCLSID) ;
        return FALSE;
    }
    // Covert from wide characters to non-wide.
    wcstombs(szCLSID, wszCLSID, length) ;
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
#endif
    return TRUE;
}

// Delete a key and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        LPCTSTR lpszKeyChild)  // Key to delete
{
    assert(lpszKeyChild);
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
                             KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS) {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
                        NULL, NULL, &time) == S_OK) {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS) {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

// Determine if a particular subkey exists.
BOOL SubkeyExists(LPCTSTR pszPath,    // Path of key to check
                  LPCTSTR szSubkey)   // Key to check
{
    HKEY hKey ;
    TCHAR szKeyBuf[MAX_PATH] ;

    assert(pszPath != NULL && _tcslen(pszPath) < MAX_PATH - 1);
    assert(szSubkey != NULL && _tcslen(pszPath) + _tcslen(szSubkey) < MAX_PATH - 1);
    
    // Copy keyname into buffer.
    _tcsncpy(szKeyBuf, pszPath, MAX_PATH - 1) ;
    szKeyBuf[MAX_PATH - 1] = 0;

    // Add subkey name to buffer.
    if (szSubkey != NULL && _tcslen(szKeyBuf) + _tcslen(szSubkey) < MAX_PATH - 1)
    {
        _tcscat(szKeyBuf, _TEXT("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Determine if key exists by trying to open it.
    LONG lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                  szKeyBuf,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hKey) ;
    if (lResult == ERROR_SUCCESS)
    {
        RegCloseKey(hKey) ;
        return TRUE ;
    }
    return FALSE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(LPCTSTR szKey,
                    LPCTSTR szSubkey,
                    LPCTSTR szValue,
                    LPCTSTR szName)
{
    HKEY hKey;
    
#define KEYBUF_LEN_1024 1024
    TCHAR szKeyBuf[KEYBUF_LEN_1024] ;

    assert(szKey != NULL && _tcslen(szKey) < KEYBUF_LEN_1024 - 1);
    assert(szSubkey != NULL && _tcslen(szKey) + _tcslen(szSubkey) < KEYBUF_LEN_1024 - 1);
    
    // Copy keyname into buffer.
    _tcsncpy(szKeyBuf, szKey, KEYBUF_LEN_1024 - 1) ;
    szKeyBuf[KEYBUF_LEN_1024 - 1] = 0;

    // Add subkey name to buffer.
    if (szSubkey != NULL && _tcslen(szKeyBuf) + _tcslen(szSubkey) < KEYBUF_LEN_1024 - 1)
    {
        _tcscat(szKeyBuf, _TEXT("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
                                  szKeyBuf,
                                  0, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS, NULL,
                                  &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
                      (BYTE *)szValue,
                      sizeof(TCHAR) * (_tcslen(szValue)+1)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

// Register the component in the registry.
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       LPCTSTR szFriendlyName, // Friendly Name
                       LPCTSTR szVerIndProgID, // Programmatic
                       LPCTSTR szProgID)       //   IDs
{
    // Get server location.
    TCHAR szModule[512] ;
    DWORD dwResult = ::GetModuleFileName(hModule,
                                         szModule,
                                         sizeof(szModule)/sizeof(TCHAR)) ;
    assert(dwResult != 0) ;

    szModule[ ( sizeof( szModule ) / sizeof( TCHAR ) ) - 1 ] = 0;

    // Convert the CLSID into a char.
    TCHAR szCLSID[CLSID_STRING_SIZE] ;
    szCLSID[0] = NULL;
    if (FALSE == CLSIDtoString(clsid, szCLSID, sizeof(szCLSID) / sizeof(TCHAR)))
    {
        return E_OUTOFMEMORY;
    }

    // Build the key CLSID\\{...}
    TCHAR szKey[64] ;
    _tcscpy(szKey, _TEXT("CLSID\\")) ;
    _tcscat(szKey, szCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _TEXT("InprocServer32"), szModule) ;

    // Add Threading Model
    setKeyAndValue(szKey,
                   _TEXT("InprocServer32"),
                   _TEXT("Both"),
                   _TEXT("ThreadingModel")) ;

    // Add the ProgID subkey under the CLSID key.
    setKeyAndValue(szKey, _TEXT("ProgID"), szProgID) ;

    // Add the version-independent ProgID subkey under CLSID key.
    setKeyAndValue(szKey, _TEXT("VersionIndependentProgID"),
                   szVerIndProgID) ;

    // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
    setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ;
    setKeyAndValue(szVerIndProgID, _TEXT("CLSID"), szCLSID) ;
    setKeyAndValue(szVerIndProgID, _TEXT("CurVer"), szProgID) ;

    // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
    setKeyAndValue(szProgID, NULL, szFriendlyName) ;
    setKeyAndValue(szProgID, _TEXT("CLSID"), szCLSID) ;

    return S_OK ;
}

// Remove the component from the registry.
HRESULT UnregisterServer(const CLSID& clsid,         // Class ID
                      LPCTSTR szVerIndProgID, // Programmatic
                      LPCTSTR szProgID)       //   IDs
{
    // Convert the CLSID into a char.
    TCHAR szCLSID[CLSID_STRING_SIZE] ;

    szCLSID[0] = NULL;
    if (FALSE == CLSIDtoString(clsid, szCLSID, sizeof(szCLSID) / sizeof(TCHAR)))
    {
        return E_OUTOFMEMORY;
    }

    // Build the key CLSID\\{...}
    TCHAR szKey[80] ;
    _tcscpy(szKey, _TEXT("CLSID\\")) ;
    _tcscat(szKey, szCLSID) ;

    // Check for a another server for this component.
    if (SubkeyExists(szKey, _TEXT("LocalServer32"))) {
        // Delete only the path for this server.    
        if (sizeof(szKey) / sizeof(szKey[0]) > _tcslen(_TEXT("\\InprocServer32")) + _tcslen(szKey))
        {
            _tcscat(szKey, _TEXT("\\InprocServer32")) ;
            LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
            assert(lResult == ERROR_SUCCESS) ;
        }
    } else {
        // Delete all related keys.
        // Delete the CLSID Key - CLSID\{...}
        LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

        // Delete the version-independent ProgID Key.
        lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

        // Delete the ProgID key.
        lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    }
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\scchardef.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  SCCharDef.h
Purpose:    Define constents of special SC Characters
            These special characters are used in the specific grammar rules
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    1/15/98
============================================================================*/
#ifndef _SCCHARDEF_H_
#define _SCCHARDEF_H_

#define SC_CHAR_DI4     0x5730  // ""
#define SC_CHAR_GUO     0x8fc7  // ""
#define SC_CHAR_HE      0x548c  // ""
#define SC_CHAR_YOU     0x6709  // ""
#define SC_CHAR_ZHE     0x7740  // ""
#define SC_CHAR_YI      0x4e00  // ""
#define SC_CHAR_LE      0x4e86  // ""
#define SC_CHAR_LAI     0x6765  // ""
#define SC_CHAR_QU      0x53bb  // ""
#define SC_CHAR_SHANG   0x4e0a  // ""
#define SC_CHAR_XIA     0x4e0b  // ""
#define SC_CHAR_BU      0x4e0d  // ""
#define SC_CHAR_MEI     0x6ca1  // ""
#define SC_CHAR_DE      0x5f97  // ""
#define SC_CHAR_ZHI     0x4e4b  // ""
#define SC_CHAR_WEI     0x4e3a  // ""
#define SC_CHAR_XIN     0x65b0  // ""
#define SC_CHAR_YI3     0x4ee5  // ""
#define SC_CHAR_SHUDIAN 0xff0e  // ""
#define SC_CHAR_PERCENT 0xff05  // ""
#define SC_CHAR_ANSIPERCENT 0x0025  // "%"
#define SC_CHAR_SLASH   0xff0f  // ""
#define SC_CHAR_ANSISLASH 0x002f  // "/"
#define SC_CHAR_SHI2    0x5341  // ""
#define SC_CHAR_BAI     0x767e  // ""
#define SC_CHAR_QIAN    0x5343  // ""
#define SC_CHAR_WAN     0x4e07  // ""
#define SC_CHAR_YI4     0x4ebf  // ""
#define SC_CHAR_LIANG   0x4e24  // ""
#define SC_CHAR_DUNHAO  0x3001  // ""
#define SC_CHAR_DOUHAO  0xff0c  // ""
#define SC_CHAR_LIANHAO 0xff5e  // ""
#define SC_CHAR_ZHI4    0x81f3  // ""
#define SC_CHAR_BAN     0x534a  // ""
#define SC_CHAR_GAO     0x9ad8  // ""
#define SC_CHAR_ZHONG   0x4e2d  // ""
// Ordinal Tips
#define SC_CHAR_DI      0x7b2c  // ""
#define SC_CHAR_CHU     0x521d  // ""
// Decimal Tips
#define SC_CHAR_DIAN3   0x70b9  // ""
#define SC_CHAR_CHENG   0x6210  // ""
#define SC_CHAR_YOU4    0x53c8  // ""
#define SC_CHAR_BEI     0x500d  // ""
// Approx Tips
#define SC_CHAR_DUO     0x591a  // ""
#define SC_CHAR_YU      0x4f59  // ""
#define SC_CHAR_LAI     0x6765  // ""
#define SC_CHAR_JI      0x51e0  // ""
#define SC_CHAR_YUE1    0x7ea6  // ""
#define SC_CHAR_JIN     0x8fd1  // ""
#define SC_CHAR_SHU     0x6570  // ""
//#define SC_CHAR_SHANG 0x4e0a  // ""
// Quantity Tips
#define SC_CHAR_GE      0x4e2a  // ""
#define SC_CHAR_NIAN    0x5e74  // ""
#define SC_CHAR_YUE     0x6708  // ""
#define SC_CHAR_RI      0x65e5  // ""
#define SC_CHAR_SHI     0x65f6  // ""
#define SC_CHAR_FEN     0x5206  // ""
#define SC_CHAR_MIAO    0x79d2  // ""
#define SC_CHAR_ZHONG1  0x949f  // ""
#define SC_CHAR_ZHENG   0x6574  // ""

// Jargon
#define SC_CHAR_DENG    0x7b49  // ""
#define SC_CHAR_WAIDIAN 0x00b7  // ""
#define SC_CHAR_ANSIDIAN 0x002e  // "."
#define SC_CHAR_DE4     0x7684  // ""
#define SC_CHAR_XIAO    0x5c0f  // ""
#define SC_CHAR_LAO     0x8001  // ""

// Punctuation pairs
#define SC_CHAR_PUNL1   0x201c  // ""
#define SC_CHAR_PUNR1   0x201d  // ""
#define SC_CHAR_PUNL2   0x300a  // ""
#define SC_CHAR_PUNR2   0x300b  // ""
#define SC_CHAR_PUNL3   0xff08  // ""
#define SC_CHAR_PUNR3   0xff09  // ""
#define SC_CHAR_PUNL4   0x2018  // ""
#define SC_CHAR_PUNR4   0x2019  // ""
#define SC_CHAR_PUNL5   0x3014  // ""
#define SC_CHAR_PUNR5   0x3015  // ""
#define SC_CHAR_PUNL6   0x3016  // ""
#define SC_CHAR_PUNR6   0x3017  // ""
#define SC_CHAR_PUNL7   0x3010  // ""
#define SC_CHAR_PUNR7   0x3011  // ""
#define SC_CHAR_PUNL8   0x3008  // ""
#define SC_CHAR_PUNR8   0x3009  // ""
#define SC_CHAR_PUNL9   0xff3b  // ""
#define SC_CHAR_PUNR9   0xff3d  // ""
#define SC_CHAR_PUNL10  0xff5b  // ""
#define SC_CHAR_PUNR10  0xff5d  // ""

// Time category char def
#define SC_CHAR_MO      0x672b  // ""
#define SC_CHAR_QIAN2   0x524d  // ""
#define SC_CHAR_DI3     0x5e95  // ""
#define SC_CHAR_NEI     0x5185  // ""
#define SC_CHAR_ZHONG3  0x7ec8  // ""
#define SC_CHAR_MEI3    0x6bcf  // ""
#define SC_CHAR_MOU     0x67d0  // ""
#define SC_CHAR_JIN1    0x4eca  // ""
#define SC_CHAR_YUAN    0x5143  // ""
#define SC_CHAR_TIAN    0x5929  // ""
#define SC_CHAR_LING    0x96f6  // ""
#define SC_CHAR_DA      0x5927  // ""
#define SC_CHAR_SHI4    0x662f  // ""
#define SC_CHAR_BI      0x6bd4  // ""
// Chinese digits
#define SC_DIGIT_LING   SC_CHAR_LING    // 0x96f6 ""
#define SC_DIGIT_YI     SC_CHAR_YI      // 0x4e00 ""
#define SC_DIGIT_LIANG  SC_CHAR_LIANG   // 0x4e24 ""
#define SC_DIGIT_ER     0x4e8c          // 0x4e8c ""
#define SC_DIGIT_SAN    0x4e09          // 0x4e09 ""
#define SC_DIGIT_SI     0x56db          // 0x56db ""
#define SC_DIGIT_WU     0x4e94          // 0x4e94 ""
#define SC_DIGIT_LIU    0x516d          // 0x516d ""
#define SC_DIGIT_QI     0x4e03          // 0x4e03 ""
#define SC_DIGIT_BA     0x516b          // 0x516b ""
#define SC_DIGIT_JIU    0x4e5d          // 0x4e5d ""
#define SC_DIGIT_SHI    SC_CHAR_SHI2    // 0x5341 ""
#define SC_DIGIT_BAI    SC_CHAR_BAI     // 0x767e ""
#define SC_DIGIT_QIAN   SC_CHAR_QIAN    // 0x5343 ""
#define SC_DIGIT_WAN    SC_CHAR_WAN     // 0x4e07 ""
#define SC_DIGIT_YI4    SC_CHAR_YI4     // 0x4ebf ""
#define SC_ARABIC_LING  0xff10          // 0xff10 ""
#define SC_SBCS_LING    0X0030          // 0X0030 "0"
#define SC_DBCS_LING    0X3007          // 0X3007 ""
// prefix char
#define SC_PFXCHAR_AA   0x963f  // ""
#define SC_PFXCHAR_CHAO 0x8d85  // ""
#define SC_PFXCHAR_DAI  0x4ee3  // ""
#define SC_PFXCHAR_FAN  0x53cd  // ""
#define SC_PFXCHAR_FEI  0x975e  // ""
#define SC_PFXCHAR_FU   0x526f  // ""
#define SC_PFXCHAR_GUO  SC_CHAR_GUO  // 0x8fc7  // ""
#define SC_PFXCHAR_LAO  SC_CHAR_LAO  // 0x8001  // ""
#define SC_PFXCHAR_WEI1 0x5fae  // ""
#define SC_PFXCHAR_WEI3 0x4f2a  // ""
#define SC_PFXCHAR_XIAO SC_CHAR_XIAO // 0x5c0f  // ""
#define SC_PFXCHAR_ZHUN 0x51c6  // ""
#define SC_PFXCHAR_ZONG 0x603b  // ""
// suffix char
#define SC_SFXCHAR_CHANG    0x573a  // ""
#define SC_SFXCHAR_ZHANG    0x957f  // ""
#define SC_SFXCHAR_DAN      0x5355  // ""
#define SC_SFXCHAR_DUI      0x5806  // ""
#define SC_SFXCHAR_ER       0x513f  // ""
#define SC_SFXCHAR_FA       0x6cd5  // ""
#define SC_SFXCHAR_FANG     0x65b9  // ""
#define SC_SFXCHAR_GAN      0x611f  // ""
#define SC_SFXCHAR_GUAN     0x89c2  // ""
#define SC_SFXCHAR_HUA      0x5316  // ""
#define SC_SFXCHAR_JI       0x673a  // ""
#define SC_SFXCHAR_JIA      0x5bb6  // ""
#define SC_SFXCHAR_JIE      0x754c  // ""
#define SC_SFXCHAR_LAO      0x8001  // ""
#define SC_SFXCHAR_LV       0x7387  // ""
#define SC_SFXCHAR_LUN      0x8bba  // ""
#define SC_SFXCHAR_MEN      0x4eec  // ""
#define SC_SFXCHAR_PIN      0x54c1  // ""
#define SC_SFXCHAR_QI       0x5668  // ""
#define SC_SFXCHAR_SHENG    0x751f  // ""
#define SC_SFXCHAR_SHENG3   0x7701  // ""
#define SC_SFXCHAR_SHI1     0x5e08  // ""
#define SC_SFXCHAR_SHI      0x5f0f  // ""
#define SC_SFXCHAR_SHI4     0x5e02  // ""
#define SC_SFXCHAR_TI       0x4f53  // ""
#define SC_SFXCHAR_TING     0x8247  // ""
#define SC_SFXCHAR_TOU      0x5934  // ""
#define SC_SFXCHAR_XING2    0x578b  // ""
#define SC_SFXCHAR_XING4    0x6027  // ""
#define SC_SFXCHAR_XUE      0x5b66  // ""
#define SC_SFXCHAR_YAN      0x708e  // ""
#define SC_SFXCHAR_YE       0x4e1a  // ""
#define SC_SFXCHAR_YI       0x4eea  // ""
#define SC_SFXCHAR_YUAN     0x5458  // ""
#define SC_SFXCHAR_ZHE      0x8005  // ""
#define SC_SFXCHAR_ZHENG    0x75c7  // ""
#define SC_SFXCHAR_ZHI      0x5236  // ""
#define SC_SFXCHAR_ZI       0x5b50  // ""

#define SC_DTWORD_YI     L"\x4e00"    // ""
#define SC_DTWORD_LIANG  L"\x4e24"    // ""
#define SC_DTWORD_ER     L"\x4e8c"    // ""
#define SC_DTWORD_SAN    L"\x4e09"    // ""
#define SC_DTWORD_SI     L"\x56db"    // ""
#define SC_DTWORD_WU     L"\x4e94"    // ""
#define SC_DTWORD_LIU    L"\x516d"    // ""
#define SC_DTWORD_QI     L"\x4e03"    // ""
#define SC_DTWORD_BA     L"\x516b"    // ""
#define SC_DTWORD_JIU    L"\x4e5d"    // ""
#define SC_DTWORD_SHI    L"\x5341"    // ""
#define SC_DTWORD_BAI    L"\x767e"    // ""
#define SC_DTWORD_QIAN   L"\x5343"    // ""
#define SC_DTWORD_WAN    L"\x4e07"    // ""
#define SC_DTWORD_YI4    L"\x4ebf"    // ""

#define SC_WORD_BENYUE      L"\x672c\x6708"  // ""
#define SC_WORD_SHANGYUE    L"\x4e0a\x6708"  // ""
#define SC_WORD_XIAYUE      L"\x4e0b\x6708"  // ""
#define SC_WORD_JINNIAN     L"\x4eca\x5e74"  // ""
#define SC_WORD_QUNIAN      L"\x53bb\x5e74"  // ""
#define SC_WORD_MINGNIAN    L"\x660e\x5e74"  // ""
#define SC_WORD_ZHIYI       L"\x4e4b\x4e00"  // ""
#define SC_WORD_WANLIANG    L"\x4e07\x4e24"  // ""
#define SC_WORD_YI4LIANG    L"\x4ebf\x4e24"  // ""
#define SC_WORD_BADU        L"\x516b\x5ea6"  // ""
#define SC_WORD_BAINIAN     L"\x767e\x5e74"  // ""
#define SC_WORD_SHIFEN      L"\x5341\x5206"  // ""
#define SC_WORD_WANFEN      L"\x4e07\x5206"  // ""
#define SC_WORD_YIDIAN      L"\x4e00\x70b9"  // ""
#define SC_WORD_YISHI       L"\x4e00\x65f6"  // ""
// Decimal Tips
#define SC_WORD_FENZHI      L"\x5206\x4e4b"  // ""
#define SC_WORD_BAIFENZHI   L"\x767e\x5206\x4e4b"  // ""
#define SC_WORD_QIANFENZHI  L"\x5343\x5206\x4e4b"  // ""
#define SC_WORD_WANFENZHI   L"\x4e07\x5206\x4e4b"  // ""
// Approx Tips
#define SC_WORD_GUALING     L"\x6302\x96f6" // ""
#define SC_WORD_ZUOYOU      L"\x5de6\x53f3" // ""
#define SC_WORD_HAOJI       L"\x597d\x51e0" // ""
#define SC_WORD_BAINIAN     L"\x767e\x5e74" // ""
// Time category word def
#define SC_WORD_GONGYUAN        L"\x516c\x5143" // ""
#define SC_WORD_GONGYUANQIAN    L"\x516c\x5143\x524d"   // ""
#define SC_WORD_BANGE           L"\x534a\x4e2a" // ""
#define SC_WORD_MOUGE           L"\x67d0\x4e2a" // ""
#define SC_WORD_MEIGE           L"\x6bcf\x4e2a" // ""
// Time Category analysis
#define SC_TMWORD_SHIJI         L"\x4e16\x7eaa" // ""
#define SC_TMWORD_NIANDAI       L"\x5e74\x4ee3" // ""
#define SC_TMWORD_NIAN          L"\x5e74" // ""
#define SC_TMWORD_NIANDU        L"\x5e74\x5ea6" // ""
#define SC_TMWORD_NIANTOU       L"\x5e74\x5934" // ""
#define SC_TMWORD_CAINIAN       L"\x8d22\x5e74" // ""
#define SC_TMWORD_JIDU          L"\x5b63\x5ea6" // ""
#define SC_TMWORD_YUE           L"\x6708" // ""
#define SC_TMWORD_YUEFEN        L"\x6708\x4efd" // ""
#define SC_TMWORD_ZHOU          L"\x5468" // ""
#define SC_TMWORD_XINGQI        L"\x661f\x671f" // ""
#define SC_TMWORD_LIBAI         L"\x793c\x62dc" // ""
#define SC_TMWORD_TIAN          L"\x5929" // ""
#define SC_TMWORD_RI            L"\x65e5" // ""
#define SC_TMWORD_XIAOSHI       L"\x5c0f\x65f6" // ""
#define SC_TMWORD_ZHONGTOU      L"\x949f\x5934" // ""
#define SC_TMWORD_SHI           L"\x65f6" // ""
#define SC_TMWORD_DIAN          L"\x70b9" // ""
#define SC_TMWORD_FEN           L"\x5206" // ""
#define SC_TMWORD_FENZHONG      L"\x5206\x949f" // ""
#define SC_TMWORD_MIAO          L"\x79d2" // ""
// ambi
#define SC_WORD_NIANTOU         L"\x5e74\x5934" // ""
#define SC_WORD_RIQIAN          L"\x65e5\x524d" // ""

#define SC_QTWORD_BEI           L"\x500d"   // ""
#define SC_QTWORD_GE            L"\x4e2a"   // ""
#define SC_QTWORD_ZHONG         L"\x79cd"   // ""

#define SC_DMWORD_ZHE           L"\x8fd9"   // ""
#define SC_DMWORD_GE            L"\x5404"   // ""
#define SC_DMWORD_NA            L"\x90a3"   // ""

#define SC_APXWORD_DUO          L"\x591a"   // ""
#define SC_APXWORD_JIN          L"\x8fd1"   // ""
#define SC_APXWORD_LAI          L"\x6765"   // ""
#define SC_APXWORD_SHU          L"\x6570"   // ""
#define SC_APXWORD_YU           L"\x4f59"   // ""
#define SC_APXWORD_YUE          L"\x7ea6"   // ""

#define SC_APXNUM_YIER          L"\x4e00\x4e8c"   // ""
#define SC_APXNUM_YILIANG       L"\x4e00\x4e24"   // ""
#define SC_APXNUM_LIANGSAN      L"\x4e24\x4e09"   // ""
#define SC_APXNUM_SANLIANG      L"\x4e09\x4e24"   // ""
#define SC_APXNUM_ERSAN         L"\x4e8c\x4e09"   // ""
#define SC_APXNUM_SANSI         L"\x4e09\x56db"   // ""
#define SC_APXNUM_SANWU         L"\x4e09\x4e94"   // ""
#define SC_APXNUM_SIWU          L"\x56db\x4e94"   // ""
#define SC_APXNUM_WULIU         L"\x4e94\x516d"   // ""
#define SC_APXNUM_LIUQI         L"\x516d\x4e03"   // ""
#define SC_APXNUM_QIBA          L"\x4e03\x516b"   // ""
#define SC_APXNUM_BAJIU         L"\x516b\x4e5d"   // ""

#endif // _SCCHARDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\server.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Server.cpp
Purpose:   This file contains the component server code.
           The FactoryDataArray contains the components that 
           can be served.
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include "query.h"
#include "CUnknown.h"
#include "CFactory.h"
#include "IWordBreaker.h"

#include "classid.hxx"

// Each component derived from CUnknown defines a static function
// for creating the component with the following prototype. 
// HRESULT CreateInstance(IUnknown* pUnknownOuter, 
//                        CUnknown** ppNewComponent) ;
// This function is used to create the component.
//

//
// The following array contains the data used by CFactory
// to create components. Each element in the array contains
// the CLSID, the pointer to the creation function, and the name
// of the component to place in the Registry.
//
CFactoryData g_FactoryDataArray[] =
{
    {&CLSID_Chinese_Simplified_WBreaker, CIWordBreaker::CreateInstance, 
        _TEXT("Chinese_Simplified Word Breaker"),  // Friendly Name
        _TEXT("Chinese_Simplified Word Breaker.2"),// ProgID
        _TEXT("Chinese_Simplified Word Breaker")}  // Version-independent ProgID
} ;
int g_cFactoryDataEntries
    = sizeof(g_FactoryDataArray) / sizeof(CFactoryData) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\registry.h ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Registry
Purpose:   Helper functions registering and unregistering a component
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#ifndef __Registry_H__
#define __Registry_H__

// Set the given key and its value.
BOOL setKeyAndValue(LPCTSTR pszPath,
                    LPCTSTR szSubkey,
                    LPCTSTR szValue,
                    LPCTSTR szName = NULL) ;

// Convert a CLSID into a char string.
void CLSIDtoString(const CLSID& clsid,
                   LPCTSTR szCLSID,
                   int length) ;

// Determine if a particular subkey exists.
BOOL SubkeyExists(LPCTSTR pszPath,
                  LPCTSTR szSubkey) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, LPCTSTR szKeyChild) ;

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule,
                       const CLSID& clsid,
                       LPCTSTR szFriendlyName,
                       LPCTSTR szVerIndProgID,
                       LPCTSTR szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         LPCTSTR szVerIndProgID,
                         LPCTSTR szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\slmdef.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  SLMDef
Purpose:    Declare constants and the file structure of Statistical Language Model.
                1. Define the syntactic categories used in SLM.
                2. Define the special WordID, semantic categories in some point of view.
                3. Define the file structure of the runtime WordMatrix.
            This is only a header file w/o any CPP, this header will be included
            by all SLM modules. 
            
Notes:      We drop this file in Engine sub project only because we want to make 
            Engine code self-contained
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    2/6/98
============================================================================*/
#ifndef _SLMDEF_H_
#define _SLMDEF_H_

//  Define the type of WordID
typedef WORD WORDID;

/*============================================================================
Define the syntactic categories used in the SLM.
============================================================================*/

//  Count of syntactic category
#define SLMDef_CountOfSynCat    19

//  All syntactic categories defined in SLMDef_syn prefix
#define SLMDef_synChar      0
#define SLMDef_synVN        1   // ()
#define SLMDef_synVA        2   // 
#define SLMDef_synV         3   // 
#define SLMDef_synAN        4   // ()
#define SLMDef_synA         5   // 
#define SLMDef_synN         6   // 
#define SLMDef_synT         7   // 
#define SLMDef_synS         8   // 
#define SLMDef_synF         9   // 
#define SLMDef_synM         10  // 
#define SLMDef_synQ         11  // 
#define SLMDef_synB         12  // 
#define SLMDef_synR         13  // 
#define SLMDef_synZ         14  // 
#define SLMDef_synD         15  // 
#define SLMDef_synP         16  // 
#define SLMDef_synC         17  // 
#define SLMDef_synMisc      18  // ()


/*============================================================================
Define the special WordID, it stands for the semantic categories in some point of view.
============================================================================*/

//  Count of semantic category (special WordID)
#define SLMDef_CountOfSemCat    55

//  All semantic categories defines in SLMDef_sem prefix
#define SLMDef_semNone      0   // Words non't involved in SLM check
//  
#define SLMDef_semPerson    1   // 
#define SLMDef_semPlace     2   // 
#define SLMDef_semOrg       3   // 
#define SLMDef_semTM        4   // 
#define SLMDef_semTerm      5   // 
//  
#define SLMDef_semInteger   6   // 
#define SLMDef_semCode      7   // 
#define SLMDef_semDecimal   8   // 
#define SLMDef_semPercent   9   // 
#define SLMDef_semOrdinal   10  // 
//  
#define SLMDef_semRRen      11  // 
//  
#define SLMDef_semChang     12  // <>
#define SLMDef_semDan       13  // <>
#define SLMDef_semDui       14  // <>
#define SLMDef_semEr        15  // <>
#define SLMDef_semFa        16  // <>
#define SLMDef_semFang      17  // <>
#define SLMDef_semGan       18  // <>
#define SLMDef_semGuan      19  // <>
#define SLMDef_semHua       20  // <>
#define SLMDef_semJi        21  // <>
#define SLMDef_semJia       22  // <>
#define SLMDef_semJie       23  // <>
#define SLMDef_semLao       24  // <>
#define SLMDef_semLun       25  // <>
#define SLMDef_semLv        26  // <>
#define SLMDef_semMen       27  // <>
#define SLMDef_semPin       28  // <>
#define SLMDef_semQi        29  // <>
#define SLMDef_semSheng     30  // <>
#define SLMDef_semSheng3    31  // <>
#define SLMDef_semShi       32  // <>
#define SLMDef_semShi1      33  // <>
#define SLMDef_semShi4      34  // <>
#define SLMDef_semTi        35  // <>
#define SLMDef_semTing      36  // <>
#define SLMDef_semTou       37  // <>
#define SLMDef_semXing2     38  // <>
#define SLMDef_semXing4     39  // <>
#define SLMDef_semXue       40  // <>
#define SLMDef_semYan       41  // <>
#define SLMDef_semYe        42  // <>
#define SLMDef_semYi        43  // <>
#define SLMDef_semYuan      44  // <>
#define SLMDef_semZhang     45  // <>
#define SLMDef_semZhe       46  // <>
#define SLMDef_semZheng     47  // <>
#define SLMDef_semZi        48  // <>
#define SLMDef_semZhi       49  // <>
//  Pattern
#define SLMDef_semDup       50  // 
#define SLMDef_semPattern   51  // Pattern
//  
#define SLMDef_semIdiom     52  // 
#define SLMDef_semPunct     53  // ()
#define SLMDef_semMisc      54  // 


//------------------------------------------------------------------------------------------
//  Define the file structure of the runtime WordMatrix.
//------------------------------------------------------------------------------------------
#pragma pack(1)
// Define the WordMatrix header
struct CWordMatrixHeader {
    DWORD   m_dwLexVersion;
    DWORD   m_ciWordID;
    DWORD   m_ofbMatrix;        // Start position of the matrix
    DWORD   m_cbMatrix;         // Length of the matrix, only for verification
};

// Define the WordMatrix index item
struct CWordMatrixIndex {
    DWORD   m_ofbMatrix;
    UINT    m_ciLeftNode    : (32 - SLMDef_CountOfSynCat);
    UINT    m_bitLeft       : SLMDef_CountOfSynCat;
    UINT    m_ciRightNode   : (32 - SLMDef_CountOfSynCat);
    UINT    m_bitRight      : SLMDef_CountOfSynCat;
};

// All WordMatrix node listed one by one continuously, no separators between sections

#pragma pack()


#endif  // _SLMDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\utility.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Utility.h

Purpose:   Utility stuffs
Notes:     
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz 4/21/97
============================================================================*/
#ifndef _UTILITY_H_
#define _UTILITY_H_

#include <assert.h>

#ifdef  __cplusplus
extern  "C"
{
#endif  // __cplusplus

/*============================================================================
IsSurrogateChar
    Test if the 2 WCHAR at given pointer is a Surrogate char.
Entry:  pwch - pointer to 2 WCHAR
Return: TRUE
        FALSE    
Caution:
    Caller side must make sure the 4 bytes are valid memory!
============================================================================*/
inline BOOL IsSurrogateChar(LPCWSTR pwch)
{
    assert(! IsBadReadPtr((CONST VOID*)pwch, sizeof(WCHAR) * 2));
    if (((*pwch & 0xFC00) == 0xD800) && ((*(pwch+1) & 0xFC00) == 0xDC00)) {
        return TRUE;
    }

    assert(((*pwch & 0xFC00) != 0xD800) && ((*(pwch+1) & 0xFC00) != 0xDC00));
    return FALSE;
};

#ifdef  __cplusplus
}
#endif  // __cplusplus

#endif  // _UTILITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\wbdicdef.h ===
/*
*	WBDicDef.h
*	Define the dic header for CHammer word breaker 
*/
#ifndef _WBDICDEF_H_
#define _WBDICDEF_H_

// define the dic header
struct CWBDicHeader
	{
	DWORD	m_ofbCharFreq;
	DWORD	m_ofbLexicon;
	};


#endif	// _WBDICDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\utility.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Utility.cpp

Purpose:   Utility stuffs
Notes:     
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz 4/22/97
============================================================================*/
#include <windows.h>
#include <assert.h>

#include "Utility.h"

/*============================================================================
BOOL GetBaseDirectory()
    Get base directory of the given path
Return: 
    TRUE if base dir parse success, szBaseDir = "c:\...\...\"
    FALSE, szBaseDir = ""
============================================================================*/
BOOL GetBaseDirectory(
        LPCTSTR szFullPath, 
        LPTSTR  szBaseDir, 
        int cBaseBuf)//Specifies the number bytes (ANSI version) 
                     //or characters (Unicode version) of szBaseDir
{
    assert(! IsBadStringPtr(szFullPath, MAX_PATH));
    assert(cBaseBuf && ! IsBadStringPtr(szBaseDir, cBaseBuf));
    int ilen;

    szBaseDir[0] = NULL;
    
    for (ilen = lstrlen(szFullPath); 
         ilen && *(szFullPath + ilen) != TEXT('\\'); ilen--) {
         ;
    }
    if (!ilen || ilen >= cBaseBuf) {
        return FALSE;
    }
    // szBaseDir = "c:\...\...\"
    lstrcpyn(szBaseDir, szFullPath, ilen+2);
    return TRUE;
}
        
/*============================================================================
LPTSTR GetFileNameFromPath()
    Get the file name from the given path
Returns:
    the pointer to the start position in the path
============================================================================*/
LPTSTR GetFileNameFromPath(LPCTSTR lpszPath)
{
    LPTSTR pc = const_cast<LPTSTR>(lpszPath);
    LPTSTR pbs = const_cast<LPTSTR>(lpszPath);
    while (*pc) {
        if(*pc == TEXT('\\')) {
            pbs = pc+1;
        }
        pc++;
    }
    return pbs;
}

/*============================================================================
fIsGBKEUDCChar
    Check whether the given char is an EUDC char
Returns:
    TRUE if hit EUDC area
============================================================================*/
BOOL fIsGBKEUDCChar(WORD wChar)
{
    if(wChar >= 0xA1B0 && wChar <= 0xFEF7) { // GB 2312 Area 0xB0A1-0xF7FE
        return FALSE;
    }
    if( (wChar >= 0x40A1 && wChar <= 0xA0A7) || // 0xA140 - 0xA7A0
        (wChar >= 0xA1AA && wChar <= 0xFEAF) || // 0xAAA1 - 0xAFFE
        (wChar >= 0xFAF8 && wChar <= 0xFEFE)    // 0xF8FA - 0xFEFE
      ) {
        return TRUE;
    }
    return FALSE;
}

/*============================================================================
fIsEUDCChar
    Check whether the given Unicode char is an EUDC char
Returns:
    TRUE if hit EUDC area
============================================================================*/
BOOL fIsEUDCChar(WORD wChar) // wChar is an Unicode char
{
    if (wChar >= 0xE000 && wChar <= 0xF8FF) {
        return TRUE;
    }
    return FALSE;
}

/*============================================================================
fIsIdeograph
    Check whether the given Unicode char is an CJK Unified Ideograph char
Returns:
    TRUE
============================================================================*/
BOOL fIsIdeograph(WORD wChar) // wChar is an Unicode char
{
    if (wChar >= 0x4E00 && wChar <= 0x9FFF) {
        return TRUE;
    }
    return FALSE;
}

/*============================================================================
ustrcmp
Entry:	const char * src - string for left-hand side of comparison
		const char * dst - string for right-hand side of comparison
Return:	returns -1 if src <  dst
		returns  0 if src == dst
		returns +1 if src >  dst
============================================================================*/
int ustrcmp (const unsigned char * src, const unsigned char * dst)
{
	int ret = 0;

	while( !( ret = (int)((unsigned char)*src - (unsigned char)*dst) ) && *dst )
		++src, ++dst;

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}


/*============================================================================
WideCharStrLenToSurrogateStrLen
    Calculate length with Surrogate support of given 2byte Unicode string
Return: 
============================================================================*/
UINT WideCharStrLenToSurrogateStrLen(LPCWSTR pwch, UINT cwch)
{
    assert(! IsBadReadPtr((CONST VOID*)pwch, sizeof(WCHAR) * cwch));

    UINT cchSurrogate = cwch;
    for (UINT i=0; i<cwch - 1; i++) {
        if (IsSurrogateChar(pwch+i)) {
            i++;
            cchSurrogate --;
        }
    }
    assert(i==cwch || i==cwch - 1);

    return cchSurrogate;
}

/*============================================================================
SurrogateStrLenToWideCharStrLen
    Calculate length in WCHAR of given Surrogate string
Return: 
    wchar length of pwSurrogate
============================================================================*/
UINT SurrogateStrLenToWideCharStrLen(const WORD *pwSurrogate, UINT cchSurrogate)
{
    assert(! IsBadReadPtr((CONST VOID*)pwSurrogate, sizeof(WCHAR) * cchSurrogate));

    UINT  cwch = cchSurrogate;

    for (UINT i=0; i<cchSurrogate; i++, cwch++) {
        if ((*(pwSurrogate+cwch) & 0xFC00) == 0xD800) {
            cwch++;
            assert((*(pwSurrogate+cwch) & 0xFC00) == 0xDC00);
        }
    }
    assert(i==cchSurrogate && cwch>=cchSurrogate);
    assert(! IsBadReadPtr((CONST VOID*)pwSurrogate, sizeof(WCHAR) * cwch));

    return cwch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\wbengine.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: WBEngine    
Purpose:   CWBEngine class is the control and interface class of WordBreaking Engine
           It depend on all other class in WordBreaking Engine
Remarks:
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz                6/6/97
           Isolated as a WordBreaker by donghz     8/5/97
============================================================================*/
#include "myafx.h"

#include "WBEngine.h"
#include "wbdicdef.h"
#include "WrdBreak.h"
#include "Lexicon.h"
#include "CharFreq.h"
#include "WordLink.h"
#include "ProofEC.h"
#include "utility.h"
#include "morph.h"
#include "jargon.h"
#include "WCStack.h"
#include "SCCharDef.h"

//  Constructor
CWBEngine::CWBEngine()
{
    m_fInit         = FALSE;
    // initialize the object handles
    m_pWordBreak    = NULL;
    m_pMorph        = NULL;
    m_pJargon       = NULL;
    m_pLexicon      = NULL;
    m_pCharFreq     = NULL;
    // Initialize the file mapping handles
    m_pbLex = NULL;
}


//  Destructor
CWBEngine::~CWBEngine()
{
    if (m_fInit) {
        TermEngine();
    }
}


//  Break given WordLink
HRESULT CWBEngine::BreakLink(CWordLink* pLink,
                           BOOL fQuery) // Index time break or Query time break
{
    int     iret;

    if (!m_fInit) {
        assert(0);
        iret = E_FAIL;
        goto gotoExit;
    }

    iret = m_pWordBreak->ecBreakSentence(pLink);
    if (iret != PRFEC::gecNone && iret != PRFEC::gecPartialSentence) {
        iret = E_FAIL;
        goto gotoExit;
    }
    iret = m_pMorph->ecDoMorph(pLink, fQuery);
    if (iret != PRFEC::gecNone) {
        iret = E_FAIL;
        goto gotoExit;
    }

    if (fQuery) {
        iret = m_pJargon->ecDoJargon(pLink);
        if (iret != PRFEC::gecNone) {
            iret = E_FAIL;
            goto gotoExit;
        }
    }

    iret = S_OK;
gotoExit:
    return iret;
}

// get the iwbPhr feature data of the pWord, and convert to WORD
// if no iwbPhr feature , return 0;
WORD CWBEngine::GetPhrFeature(CWord* pWord)
{
    WORD wFtr = 0;
    USHORT  cwFtr = 0;
    LPBYTE  pbFtr;
    pbFtr = (LPBYTE)m_pLexicon->pwchGetFeature(pWord->GetLexHandle(),
                                               LFDef_iwbPhr, &cwFtr);
    assert(cwFtr <= 1);
    if (pbFtr && cwFtr == 1) {
        wFtr = ((WORD)pbFtr[0] << 8) | (WORD)pbFtr[1];
    }
    return wFtr;
}


//  Initialize the WordBreak object, Lexicon and CharFreq object
//  Return ERROR_SUCCESS if success
HRESULT CWBEngine::InitEngine(LPBYTE pbLex)
{
    assert(pbLex);
    int      iret = E_OUTOFMEMORY;
    
    if (m_fInit) {
        assert(0);
        return S_OK;;
    }

    m_pbLex = pbLex;
    // alloc the lexicon and charfreq objects
    if ((m_pLexicon = new CLexicon) == NULL) {
        goto gotoError;
    }
    if ((m_pCharFreq = new CCharFreq) == NULL) {
        goto gotoError;
    }
    // open the lexicon and mapping the lexicon and charfreq resource into memory
    if (!fOpenLexicon()) {
        iret = E_FAIL;
        goto gotoError;
    }

    // Alloc and initialize the word breaker object
    if ((m_pWordBreak = new CWordBreak) == NULL) {
        goto gotoError;
    }
    if (PRFEC::gecNone != m_pWordBreak->ecInit(m_pLexicon, m_pCharFreq)) {
        goto gotoError;
    }
    if ((m_pMorph = new CMorph) == NULL) {
        goto gotoError;
    }
    if (PRFEC::gecNone != m_pMorph->ecInit(m_pLexicon)) {
        goto gotoError;
    }

    if ((m_pJargon = new CJargon) == NULL) {
        goto gotoError;
    }
    if (PRFEC::gecNone != m_pJargon->ecInit(m_pLexicon)) {
        goto gotoError;
    }

    m_fInit = TRUE;
    return S_OK;
gotoError:
    TermEngine();
    return iret;
}


//  Terminate the Proof Engine
void CWBEngine::TermEngine(void)
{
    if (m_pWordBreak) { 
        delete m_pWordBreak; 
        m_pWordBreak = NULL;
    }

    if (m_pMorph) {
        delete m_pMorph;
        m_pMorph = NULL;
    }

    if (m_pJargon) {
        delete m_pJargon;
        m_pJargon = NULL;
    }

    CloseLexicon();

    if (m_pLexicon) {
        delete m_pLexicon;
        m_pLexicon = NULL;
    }
    if (m_pCharFreq) {
        delete m_pCharFreq;
        m_pCharFreq = NULL;
    }

    m_pbLex = NULL;
    m_fInit = FALSE;
    return;
}


//  Open the lexicon and charfreq resource into memory
//  The lexicon file format is encapsulated in this function
BOOL CWBEngine::fOpenLexicon(void)
{
    CWBDicHeader*   phdr;

    assert(m_pbLex);
    // Validate the header of the lex file
    phdr = (CWBDicHeader*)m_pbLex;
    if (phdr->m_ofbCharFreq != sizeof(CWBDicHeader) ||
        phdr->m_ofbLexicon <= phdr->m_ofbCharFreq ) {
        goto gotoError; // error lex format!
    }

    // Open the char freq table
    if (!m_pCharFreq->fOpen(m_pbLex + phdr->m_ofbCharFreq)) {
        goto gotoError;
    }
    // Open the lexicon
    if (!m_pLexicon->fOpen(m_pbLex + phdr->m_ofbLexicon)) {
        goto gotoError;
    }

    return TRUE;
gotoError:
    CloseLexicon();
    return FALSE;
}


// Close the lexicon file and unmap the lexicon and charfreq file mapping
inline void CWBEngine::CloseLexicon(void)
{
    if (m_pCharFreq) {
        m_pCharFreq->Close();
    }
    if (m_pLexicon) {
        m_pLexicon->Close();
    }
    return;
}


// define ANSI char type for driving the LSM
#define TEXT_NULL		0
#define TEXT_NUMBER		1
#define TEXT_JU	        2	// Sentence terminating punctuations
#define TEXT_PUNCT		4	// Punctuation except sentence terminators
#define TEXT_TEXT		5

/*============================================================================
FindSentence():
    Find a sentence in text buffer.

Arguments:   [in] pszBuffStart
                  This is the beginning of the buffer.
             [in] wchLen
                  This is the length of the buffer. if no sentence end is 
                  found after this , then PRFEC::gecPartialSentence is 
                  returned to signify no complete sentence found.
             [out] pcchSent
                  The number of characters found in the sentence, 
                  not including the trailing spaces, and
                  not including the NULL terminator.
                  
Returns:     PRFEC::gecNone
                  The Sentence Seperator found a complete sentence
             PRFEC::gecPartialSentence
                  If no sentence end point could be established,
                  or the sentence was too long.
============================================================================*/
INT CWBEngine::FindSentence(LPCWSTR pwszStart,
                               const INT wchLen,
                               INT *pwchSent)
{
    assert(! IsBadReadPtr(pwszStart, wchLen * sizeof(WCHAR)));

	INT		ich;
	INT 	iChar;
    INT     iret = PRFEC::gecUnknown;
    CWCStack    PunctStack;
	LPCWSTR  pMid;
	BYTE	hich, loch;
    WCHAR   wch, wchUnmatchedPunct = 0;

	pMid = pwszStart;

    if (! PunctStack.Init())
    {   // can not allocate the punctuation stack
        *pwchSent = wchLen;
        return PRFEC::gecOOM;
    }

gotoRescan:

    for (ich = 0; ich < wchLen; ich++) {
		iChar = TEXT_TEXT;
		hich = HIBYTE(pMid[ich]);
        if (hich == 0  || hich == 0xff) {// ansi or Full Size ansi
            if (pMid[ich] > 0xFF5f) {
				iChar = TEXT_TEXT;
            } else {
				loch = LOBYTE(pMid[ich]);
                if (hich == 0xFF) {
                    loch += 0x20;
                }
				switch(loch)
				{
					case '\x0d':
                        iChar = TEXT_JU;
                        break;

					case '.':
                        iChar = TEXT_JU;
                        if (ich < wchLen-1 &&
                            ich > 0 &&
                            ( pMid[ich-1] >= '0' && pMid[ich-1] <= '9' ||         // ansi 0 ~ 9
                              pMid[ich-1] >= 0xFF10 && pMid[ich-1] <= 0xFF19 ) && // wide  ~ 
                            ( pMid[ich+1] >= '0' && pMid[ich+1] <= '9' ||         // ansi 0 ~ 9
                              pMid[ich+1] >= 0xFF10 && pMid[ich+1] <= 0xFF19 ) ) {// wide  ~ 

    						iChar = TEXT_PUNCT;
                        }
						break;

                    case ':': case ';':
                        iChar = TEXT_JU;
						break;

					case '!': case '?':
                        iChar = TEXT_JU;
                        if (ich < wchLen-1 &&                            
                            ( pMid[ich+1] == '!' || pMid[ich+1] == '?' ||
                              pMid[ich+1] == 0xFF01 || pMid[ich+1] == 0xFF1F) ) {  // wide '' || ''

                            ich ++;
                        }
                        break;

					case '(':
					case '[':
                    case '{' :
                        iChar = TEXT_PUNCT;
                        if (! PunctStack.EPush(pMid[ich]))
                        {
                            iret = PRFEC::gecOOM;
                        }
                        break;

                    case ')':
                        if (PunctStack.Pop(wch)) {
                            if (HIBYTE(wch) != hich ||
                                LOBYTE(wch) + (hich ? 0x20 : 0) != '(' ) {
                                // push the poped wchar back to the stack
                                PunctStack.Push(wch);
                            }
                        }
                        if (! PunctStack.IsEmpty()) {
                            iChar = TEXT_PUNCT;
                        } 
                        break;

                    case ']' :
                        if (PunctStack.Pop(wch)) {
                            if (HIBYTE(wch) != hich ||
                                LOBYTE(wch) + (hich ? 0x20 : 0) != '[' ) {
                                // push the poped wchar back to the stack
                                PunctStack.Push(wch);
                            }
                        }
                        if (! PunctStack.IsEmpty()) {
                            iChar = TEXT_PUNCT;
                        } 
                        break;

                    case '}':
                        if (PunctStack.Pop(wch)) {
                            if (HIBYTE(wch) != hich ||
                                LOBYTE(wch) + (hich ? 0x20 : 0) != '{' ) {
                                // push the poped wchar back to the stack
                                PunctStack.Push(wch);
                            } 
                        }
                        if (! PunctStack.IsEmpty()) {
                            iChar = TEXT_PUNCT;
                        } 
                        break;

					default:
						iChar = TEXT_TEXT;
						break;
				} // end of switch()
			} // end of if else
		} // end of if ansi
		else {
			// check for Hanzi punc chars
			switch (pMid[ich])
			{
			case 0x3002: //
//            case 0xff0c: //
//            case 0x3001: //
                iChar = TEXT_JU;
                break;

            case SC_CHAR_PUNL1:
            case SC_CHAR_PUNL2:
            case SC_CHAR_PUNL3:
            case SC_CHAR_PUNL4:
            case SC_CHAR_PUNL5:
            case SC_CHAR_PUNL6:
            case SC_CHAR_PUNL7:
            case SC_CHAR_PUNL8:
            case SC_CHAR_PUNL9:
            case SC_CHAR_PUNL10:
                iChar = TEXT_PUNCT;
                if (! PunctStack.EPush(pMid[ich]))
                {
                    iret = PRFEC::gecOOM;
                }
                break;

            case SC_CHAR_PUNR1:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL1) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR2:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL2) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR3:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL3) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR4:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL4) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR5:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL5) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR6:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL6) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR7:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL7) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR8:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL8) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR9:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL9) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR10:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL10) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            default:
				iChar = TEXT_TEXT;
				break;
			}
		}

        if (iret == PRFEC::gecOOM)
        { // memory full
            *pwchSent = wchLen;
            return iret;
        }
        
        if (iChar == TEXT_JU) {
            if (PunctStack.IsEmpty()) {
                ich++;
                iret = PRFEC::gecNone;
                break;
            } else {
                PunctStack.Pop(wch);
                if (wch == wchUnmatchedPunct && PunctStack.IsEmpty()) {
                    ich++;
                    iret = PRFEC::gecPartialSentence;
                    break;
                }
                PunctStack.Push(wch);
            }
		}
	} // end for

    if (iret == PRFEC::gecUnknown) {
        iret = PRFEC::gecPartialSentence;
        if (! PunctStack.IsEmpty()) {
            // some pair punctuation error.
            PunctStack.Pop(wchUnmatchedPunct);
            PunctStack.Empty();
            goto gotoRescan;
        }
    }

    assert(iret == PRFEC::gecNone || iret == PRFEC::gecPartialSentence);

    BOOL fCR = FALSE;
    // trail space, CR/LF
    while (ich < wchLen) {
        if (pMid[ich] == L'\r' || 
            pMid[ich] == L'\n' ) {
            
            fCR = TRUE;
            ich ++;
        } else if (! fCR && pMid[ich] == L' ') {
            
            ich ++;
        } else {
            break;
        }
    }

    *pwchSent = ich;

	return iret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\wbengine.h ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: WBEngine    
Purpose:   CWBEngine class is the control and interface class of WordBreaking Engine
           It depend on all other class in WordBreaking Engine
Remarks:
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz                6/6/97
           Isolated as a WordBreaker by donghz     8/5/97
============================================================================*/
#ifndef _WBENGINE_H_
#define _WBENGINE_H_

//   Foreward declaration of some class
class CWordBreak;
class CLexicon;
class CCharFreq;
class CWordLink;
class CMorph;
struct CWord;
class CJargon;

//   Declare the CWBEngine class
class CWBEngine
{
    public:
        CWBEngine();
        ~CWBEngine();

        /*
        *   Initialize the WordBreak object, Lexicon and CharFreq object
        *   Return ERROR_SUCCESS if success
        */
        HRESULT InitEngine(LPBYTE pbLex);
        //   Break the given WordLink
        HRESULT BreakLink(CWordLink* pLink, BOOL fQuery = FALSE);

        // get the iwbPhr feature data of the pWord, and convert to WORD
        // if no iwbPhr feature , return 0;
        WORD    GetPhrFeature(CWord* pWord);

        // Find a sentence in text buffer.
        static INT FindSentence(LPCWSTR pwszStart,
                                const INT wchLen,
                                INT *pwchSent);


    private:
        BOOL        m_fInit;        // Whether the ProofEngine has been initialized

        CWordBreak* m_pWordBreak;
        CMorph*     m_pMorph;
        CJargon*    m_pJargon;

        CLexicon*   m_pLexicon;
        CCharFreq*  m_pCharFreq;

        BYTE*       m_pbLex;

    private:
        /*
        *   Terminate the Word Breaking Engine
        */
        void TermEngine(void);
        /*
        *   Open the lexicon file and mapping the lexicon and charfreq resource into memory
        *   The lexicon file format is encapsulated in this function
        */
        BOOL fOpenLexicon(void);
        /*
        *   Close the lexicon file and unmap the lexicon and charfreq file mapping
        */
        inline void CloseLexicon(void);
};

#endif  // _PROOFENG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\wcstack.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CWCStack
Purpose:    Define CWCStack class.
            CWCStack class is a simple stack for wide char.
Notes:      No cpp.
Platform:   Win32
Revise:     First created by: i-shdong    03/01/2000
============================================================================*/
#ifndef _WCSTACK_H_
#define _WCSTACK_H_

class CWCStack
{
    public:
        CWCStack() {
            m_lpwcStack = NULL;
            m_nTop = 0;
            m_nSize = 0;
        };

        ~CWCStack() {
            if (m_lpwcStack) {
                delete [] m_lpwcStack;
            }
        };

    public:
        // Init the stack, 
        // nSize: stack size
        // Return FALSE if can't allocate stack from memory.
        // Stack can be reinited, if so, the prev stack is destroyed and released
        BOOL Init(const UINT nSize = 16) {
            if (m_lpwcStack) {
                delete [] m_lpwcStack;
            }
            m_lpwcStack = new WCHAR[nSize];
            if (m_lpwcStack == NULL) {
                return FALSE;
            }
            m_nTop = 0;
            m_nSize = nSize;
            return TRUE;
        };

        // Destroy the stack
        void Destroy(void) {
            if (m_lpwcStack) {
                delete [] m_lpwcStack;
            }
            m_nTop = 0;
            m_nSize = 0;
        };


        // Pop the stack top to wch.
        // Return FALSE if stack empty.
        BOOL Pop(WCHAR & wch) {
            assert(m_lpwcStack);
            assert(m_nTop >= 0);
            if (m_nTop > 0) {
                -- m_nTop;
                wch = m_lpwcStack[m_nTop];
                return TRUE;
            } else {
                return FALSE;
            }
        }

        // Push wch to stack 
        // Return FALSE is stack is full.
        BOOL  Push(const WCHAR wch) {
            assert(m_lpwcStack);
            assert(m_nTop >= 0);
            if (m_nTop < m_nSize) {
                m_lpwcStack[m_nTop] = wch;
                m_nTop ++;
                return TRUE;
            } else {
                return FALSE;
            }
        };

        // Push wch to stack , increase stack if full.
        BOOL EPush(const WCHAR wch) {
            assert(m_lpwcStack);
            assert(m_nTop >= 0);
            if (m_nTop == m_nSize) {
                if (! Extend()) {
                    return FALSE;
                }
            }
            assert(m_nTop < m_nSize);
            m_lpwcStack[m_nTop] = wch;
            m_nTop ++;
            return TRUE;
        };

        // Empty the stack
        inline void Empty(void) {
            assert(m_lpwcStack);
            assert(m_nTop >= 0);
            m_nTop = 0;
        };

        // Return TRUE is stack is full
        inline BOOL IsFull(void) const {
            return (BOOL)(m_nTop == m_nSize);
        };

        // Return TRUE if stack is empty
        inline BOOL IsEmpty(void) const {
            return (BOOL)(m_nTop == 0);
        };

        // Extend stack more space
        // Return FALSE if no enough memory and the stack is unchanged.
        // Return TRUE if ok. 
        BOOL Extend(const UINT nExtend = 16) {
            assert(m_lpwcStack);
            assert(m_nTop >= 0);

            LPWSTR lpwcNew = new WCHAR[m_nSize + nExtend];

            if (lpwcNew == NULL) {
                return  FALSE;
            } else {
                wcsncpy(lpwcNew, m_lpwcStack, m_nTop);
                delete [] m_lpwcStack;
                m_lpwcStack = lpwcNew;
                m_nSize += nExtend;
                return  TRUE;
            }
        };

    private:
        LPWSTR  m_lpwcStack;
        UINT    m_nTop;
        UINT    m_nSize;

    private:
        //   Disabled operations.
        CWCStack(const CWCStack & Copy);
        void operator = (const CWCStack & Copy);

};

#endif // _WCSTACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\wordlink.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Word and WordLink

Purpose:   Define the CWord and CWordLink classes
           Using CMyPlex to alloc and manage memory for word object in the link
Notes:     This module is a fundamental stuff for SCProof'98, 
           it does NOT depend on any other class.
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz    5/26/97
============================================================================*/

#ifndef _WORDLINK_H_
#define _WORDLINK_H_

#include "LexProp.h"
#include "ErrorDef.h"
#include "assert.h"
// Forward declaration of classes and structures
struct CMyPlex;
struct CWordInfo;
// Define the type of error ID
typedef USHORT ERRID;
// define macro DWORDINDEX, which is used to count the DWORD's( the iAttriID's 
// bit representation is fall into this DWORD ) index in attributes array
#define DWORDINDEX( iAttriID )    ((iAttriID) >> 5)
// define macro BITMASK, which is uesd to Get/Set/Clear the iAttriID's 
// bit representation in the DWORD
#define BITMASK( iAttriID )      (1 << ((iAttriID) & 0x1F))
// Define the element count in the attribute array (count of DWORD)
#define WORD_ATTRI_SIZE     (DWORDINDEX(LADef_MaxID) + 1)

/*============================================================================
Class:   CWord
Perpose: Word node in the word link, 
         Declare CWordLink as a friend class, so that word link can access
         those link  pointers directly.
============================================================================*/
#pragma pack(1)     // align at WORD boundary
struct CWord
{
    friend class CWordLink;

    public:
        // constructor
        CWord();

    public:
        inline BOOL fGetFlag(DWORD dwFlag) const { return (BOOL)(m_dwFlag & dwFlag);}
        inline void SetFlag(DWORD dwFlag) { m_dwFlag |= dwFlag; }
        inline void ClearFlag(DWORD dwFlag) { m_dwFlag &= (~dwFlag); }
        inline void ClearAllFlag(void) { m_dwFlag = 0; }

        inline BOOL fGetAttri(USHORT iAttriID) const
        {
            assert (iAttriID <= LADef_MaxID);
            assert (DWORDINDEX(iAttriID) < WORD_ATTRI_SIZE);

            return iAttriID <= LADef_MaxID ? 
                (BOOL)(m_aAttri[DWORDINDEX(iAttriID)] & BITMASK( iAttriID ))
                : FALSE;
        }

        inline void SetAttri(USHORT iAttriID) 
        {
            assert (iAttriID <= LADef_MaxID);
            assert (DWORDINDEX(iAttriID) < WORD_ATTRI_SIZE);

            if (iAttriID <= LADef_MaxID) {
                m_aAttri[DWORDINDEX(iAttriID)] |= BITMASK( iAttriID );
            }
        }

        inline void ClearAttri(USHORT iAttriID) 
        {
            assert (iAttriID <= LADef_MaxID);
            assert (DWORDINDEX(iAttriID) < WORD_ATTRI_SIZE);

            if (iAttriID <= LADef_MaxID) {
                m_aAttri[DWORDINDEX(iAttriID)] &= ~BITMASK( iAttriID );
            }
        }

        inline void ClearAllAttri(void) 
        {
            ZeroMemory( (LPVOID)m_aAttri, sizeof(DWORD)*WORD_ATTRI_SIZE);
        }

        inline BOOL fProperName(void) const
        {
            return (BOOL)(  fGetAttri(LADef_nounPerson) || 
                            fGetAttri(LADef_nounPlace)  ||
                            fGetAttri(LADef_nounOrg)    || 
                            fGetAttri(LADef_nounTM)     || 
                            fGetAttri(LADef_nounTerm)
                         );
        }

        inline CWord* pPrevWord() const
        { 
            assert (m_pPrev == NULL || m_pPrev->m_pNext == this);
            return m_pPrev; 
        }

        inline CWord* pNextWord() const
        { 
            assert (m_pNext == NULL || m_pNext->m_pPrev == this);
            return m_pNext; 
        }

        /*============================================================================
        CWord::pChildWord()
        Get the Word's child word head.
        ============================================================================*/
        inline CWord* CWord::pChildWord() const
        {
#ifdef DEBUG
            if (fHasChild()) {
                CWord* pWord = m_pMergedFrom;
                USHORT cwchText=0;
                assert(pWord != NULL);
                assert(pWord->m_pPrev == NULL);
                while (pWord) {
                    assert(pWord->cwchLen() > 0);
                    assert(pWord->fGetFlag(CWord::WF_SBCS) ||
                        (pWord->cwchLen() == 1 && 
                        pWord->fGetFlag(CWord::WF_CHAR)) ||
                        (pWord->cwchLen() > 1 && 
                        !pWord->fGetFlag(CWord::WF_CHAR)) );
                    assert(pWord->m_pMergedTo == this );
                    assert(m_pwchText + cwchText == pWord->m_pwchText);
                    cwchText += pWord->m_cwchText;
                    pWord->pChildWord(); // do a recursion to child's child
                    pWord = pWord->pNextWord();
                }                
                assert(m_cwchText==cwchText);
            }
#endif // DEBUG
            return m_pMergedFrom;
        }

        inline BOOL fIsHead() const { return (BOOL)(m_pPrev == NULL); }
        inline BOOL fIsTail() const { return (BOOL)(m_pNext == NULL); }
        inline BOOL fHasChild() const { return (BOOL)(m_pMergedFrom != NULL); }
        inline LPWSTR pwchGetText(void) { return m_pwchText; }
        inline USHORT cwchLen() const { return (USHORT)(m_cwchText); }
        inline DWORD dwGetWordID(void) { return m_dwWordID; }
        inline void  SetWordID(DWORD dwID) { m_dwWordID = dwID; }
        inline DWORD GetLexHandle(void) { return m_hLex; }
        inline void  SetLexHandle(DWORD hLex) { m_hLex = hLex; }
        inline ERRID GetErrID(void)  { return m_idErr; }
        inline void  SetErrID( ERRID dwErr ) { m_idErr = dwErr; }

        // Clear data members of the given word node
        inline void ClearWord(void) 
        {
            m_dwWordID = 0;
            m_hLex = 0;
            m_dwFlag = 0;
            ZeroMemory( (LPVOID)m_aAttri, sizeof(DWORD)*WORD_ATTRI_SIZE);
            m_idErr = 0;
        }
        // Copy the pWord to this word
        inline void CopyWord(CWord* pWord)
        {
            assert (pWord);
            memcpy((void*)this, (void*)pWord, sizeof(CWord));
        }
        void FillWord( LPCWSTR pwchText, USHORT cwchText,
                              CWordInfo* pwinfo = NULL );

        // Check whether current word is a Chinese Hanzi word
        // Exclude: 1. SBCS word node.
        //          2. Punctuation node.
        //          3. DBCS Foreign char (include symbols) node
        inline BOOL fIsHanzi(void) const
        {
            if(fGetAttri(LADef_punPunct) || fGetFlag(WF_SBCS) 
#ifdef LADef_genDBForeign
                || fGetAttri(LADef_genDBForeign)
#endif
                )  {
                return FALSE;
            }
            return TRUE;
        }

        //  Compare word with a Chinese character, if match return TRUE, or return FALSE
        inline BOOL fIsWordChar(const WCHAR wChar) const {
            assert (m_pwchText);
            assert (m_cwchText);

            if (m_cwchText == 1 && m_pwchText != NULL && *m_pwchText ==wChar) {
                return TRUE;
            }
            return FALSE;
        }
        
        //  Compare the first char of the word with a Chinese character, 
        //  if match return TRUE, or return FALSE
        inline BOOL fIsWordFirstChar(const WCHAR wChar) const {
            assert (m_pwchText);
            assert (m_cwchText);

            if (m_cwchText >= 1 && m_pwchText != NULL && *m_pwchText ==wChar) {
                return TRUE;
            }
            return FALSE;
        }

        //  Compare the last char of the word with a Chinese character, 
        //  if match return TRUE, or return FALSE
        inline BOOL fIsWordLastChar(const WCHAR wChar) const {
            assert (m_pwchText);
            assert (m_cwchText);

            if (m_cwchText >= 1 && m_pwchText != NULL 
                && *(m_pwchText+m_cwchText - 1) == wChar) {
                return TRUE;
            }
            return FALSE;
        }


        //  Compare this word's text with given text, return TRUE if match, or return FALSE
        BOOL fIsWordText(LPCWSTR lpwcText) const;
        //  Compare this word with other word, if the text of them identical return TRUE, or return FALSE
        BOOL fIsTextIdentical(const CWord* pWord) const;

    private:
        DWORD   m_dwWordID;
        DWORD   m_hLex;     // lexicon handle to get feature
        DWORD   m_dwFlag;
        DWORD   m_aAttri[WORD_ATTRI_SIZE]; // attributes
        ERRID   m_idErr;
        USHORT  m_cwchText;  // word's text length
        WCHAR*  m_pwchText;  // pointer to the text in source buffer

        CWord*  m_pPrev;
        CWord*  m_pNext;
        CWord*  m_pMergedFrom;// pointer to the words which this word merged from
#ifdef  DEBUG
        CWord*  m_pMergedTo;  // pointer to the word which this word was merged to
#endif  // DEBUG

    public:
        enum WFLAG  // flag bit setting of m_dwFlag
        {
            WF_SBCS     = 0x1,      // SBCS WordNode
            WF_CHAR     = 0x2,      // DBCS single character word
            WF_WORDAMBI = 0x4,      // Mark the ambiguious word
            WF_POSAMBI  = 0x8,      // The word is binded by rules, not in the lexicon
            WF_LMFAULT  = 0x10,     // Can not pass LM checking
            WF_REDUCED  = 0x20,     // Word node merged by rules
            WF_QUOTE    = 0x40,     // Word node between any pair quote marks, 
                                    // exclude the quote marks!!
            WF_DEBUG    = 0x80000000    // Reserve this bit for debug usage
        };

#ifdef DEBUG
        inline CWord* pParentWord() const { return m_pMergedTo; }
        inline BOOL   fIsChild() const { return (BOOL)(m_pMergedTo!=NULL); }

        inline BOOL fIsNew(void) const
        {
            if(m_idErr == 0 && m_dwWordID == 0 && m_hLex == 0 && m_dwFlag == 0) {
                for(int i = 0; i < WORD_ATTRI_SIZE; i++) {
                    if(m_aAttri[i] != 0)
                        return FALSE;
                    }
                return TRUE;
            }
            return FALSE;
        }
#endif // DEBUG
};
#pragma pack()


/*============================================================================
Class:   CWordLink
Purpose: To manage the word link as a container, employ CMyPlex in the inplementation   
Usage:   The instance need be created only one time, memory will not be freed 
         until destuction. Call FreeLink after use, and call InitLink to set the 
         buffer pointer before use.
Note:    In order to get high performance, I left some runtime error checking in 
         the debugging code, so more testing on debug version is required
         This class run in best performance for both running time and space, 
         all links contain similar word number, like sentence or sub-sentence
============================================================================*/
class CWordLink
{
    public:
        enum { // Define the WordLink flags
            WLF_PARTIAL = 0x1,
        };

    public:
        CWordLink(UINT ciBlockWordCount = 40);
        ~CWordLink();

        //  Init word link set the text buffer pointer
        void InitLink(const WCHAR* pwchText, USHORT cwchLen, DWORD dwFormat = 0);

        //  Get text pointer
        inline LPCWSTR pwchGetText(void) { return m_pwchText; }
        //  Get length of the WordLink
        inline USHORT cwchGetLength(void) { return m_cwchLen; }
        //  Set the length of WordLink, when a sentence terminater found
        inline void SetLength(USHORT cwchLen) { m_cwchLen = cwchLen; }
        //  Get format identifier of current text of WordLink
        inline DWORD dwGetFormat(void) { return m_dwFormat; }

        //  Get the first CWord node in the WordLink
        CWord* pGetHead(void);
        CWord* pGetTail(void) {
            return m_pTail;
        }

        //  Get specific WordLink flag
        inline BOOL fGetFlag(DWORD dwFlag) { return (BOOL)(m_dwFlag | dwFlag); }
        //  Set WordLink flag
        inline void SetFlag(DWORD dwFlag) { m_dwFlag |= dwFlag; }
        //  Clear a specific WordLink flag
        inline void ClearFlag(DWORD dwFlag) { m_dwFlag &= (~dwFlag); }
        //  Clear all flags
        inline void ClearAllFlag(void) { m_dwFlag = 0; }
        
        //  Alloc a new word, but do not chain the word into the link. 
        //  All data members will be clear, and return NULL if OOM.
        CWord* pAllocWord(void);
        //  Append a word object into the link.
        void AppendWord(CWord* pWord);
        //  Free word to the free chain, pWord must out of current WordLink
        void FreeWord(CWord* pWord);
        //  Free the word link begin with CWord* (link words to the free chain)
        void FreeLink( CWord* pWord );
        
        //  Split the given word into two words, return pointer to the right word if success
        //  return NULL if failed. cchSplitAt must fall in DBCS boundary.
        //  Note: Don't try to split SBCS nodes!!!
        CWord* pSplitWord(CWord* pWord, USHORT cwchSplitAt);
        //  Merge pWord with its next word to a single word, and free its next word
        //  pWord should not be the last word in the sentence
        //  fFree: if TRUE, free the Words been merged. FALSE, chain the Word been
        //  merged as the new word's child
        void MergeWithNext(CWord* pWord, BOOL fFree = TRUE);

        //  Merge pWord and it's left ciWords words, and return pointer to the merged word
        //  ciWords: 0 - don't merge, 1 - merge one time, 2 - merge two time (contain 3 words)
        //  fFree: if TRUE, free the Words been merged. FALSE, chain the Word been
        //  merged as the new word's child
        CWord* pLeftMerge(CWord* pWord, UINT ciWords, BOOL fFree = TRUE);
        //  Merge pWord and it's right ciWords words, and return pointer to the merged word
        //  ciWords: 0 - don't merge, 1 - merge one time, 2 - merge two time (contain 3 words)
        //  fFree: if TRUE, free the Words been merged. FALSE, chain the Word been
        //  merged as the new word's child
        CWord* pRightMerge(CWord* pWord, UINT ciWords, BOOL fFree = TRUE);

    private:
        DWORD       m_dwFlag;
        DWORD       m_dwFormat;

        CWord*      m_pHead;
        CWord*      m_pTail;

        UINT        m_ciBlockSize;  // number of words in each block
        CMyPlex*    m_pWordPool;
        CWord*      m_pFree;

        LPCWSTR     m_pwchText;      // buffer length validation need be taken by caller
        USHORT      m_cwchLen;

    private:
        // Merge word nodes from pLeft to pRight
        // only called by pLeftMerge() and pRightMerge() and MergeWithNext()
        // to do the merge work
        CWord* pMerge(CWord* pLeft, CWord* pRight, BOOL fFree);

        //  Alloc a new word fro the free chain, expand the blocks if free chain empty
        CWord* pNewWord(void);
        
        //  Free word in the link and reset the link (only link words to the free chain)
        void FreeLink(void);

#ifdef  DEBUG
    private:
        //  Debugging function to check whether a word pointer is in the link
        BOOL fInLink(CWord* pWord);
        // Debugging function to check whether a word pointer is in one of the 
        // child chains.
        inline BOOL CWordLink::fInChild(CWord* pWord);
        // Debugging function to check whether a word pointer is in the child chain 
        // of the pParent.
        BOOL fInChildOf(CWord* pWord, CWord* pParent);
        //  Debugging function to check whether the pWord is in CMyPlex blocks
        BOOL fInBlocks(CWord* pWord);
        //   Debugging function to check whether the pWord is in free links
        BOOL fInFree(CWord* pWord);
        //  Debugging function to check whether there are some word node leak to
        //  out of the link and the free chain
        //  Return TRUE if any leak is detected, or FALSE if no leak detected   
        //  Note: I hire thr most significant bit in CWord::m_dwFlag as the debugging use
        BOOL fDetectLeak(void);
        void SetDetectFlag(CWord* pWord);
#endif  // DEBUG

};

#endif  // _WORDLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\wrdbreak.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Module:     WordBreak
Purpose:    Implement the CWordBreak class. This class is in Algorithm Layer.
            Perform the max-match word segmentation, and ambiguous resolution
Notes:      This module depend on CLexicon, CWordLink and CWord class.
            Code in this module interact with linguistic resource layer through
            CWord object, and only use the WordInfo data type in Lexicon
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    2/12/97
============================================================================*/
#include "myafx.h"

#include "wrdbreak.h"
#include "wordlink.h"
#include "lexprop.h"
#include "lexicon.h"
#include "charfreq.h"
#include "proofec.h"
#include "utility.h"

#define _ANSI_LOW		0x0020
#define _ANSI_HIGH      0x007E
#define _WANSI_LOW		0xFF21
#define _WANSI_HIGH		0xFF5A
#define _EUROPEAN_LOW   0x0100
#define _EUROPEAN_HIGH  0x1FFF

/*============================================================================
Implementation of PUBLIC member functions
============================================================================*/
//  Constructor
CWordBreak::CWordBreak()
{
    m_pLexicon  = NULL;
    m_pFreq     = NULL;
    m_pwinfo    = NULL;
    m_pLink     = NULL;
    
    for (int i=0; i < MAX_AMBI_WORDS; i++) {
        m_rgAmbi[i] = NULL;
    }
}


//  Destructor
CWordBreak::~CWordBreak()
{
    if (m_pwinfo) {
        delete m_pwinfo;
    }
}

/*============================================================================
CWordBreak::ecInit():
    initialize the WordBreaker and set the object handles
Returns:
    Return PRFEC
Remarks:
    It's valid to initialize the WordBreaker more than once!
============================================================================*/
int CWordBreak::ecInit(CLexicon* pLexicon, CCharFreq* pFreq)
{
    assert(pLexicon && pFreq);

    if (!m_pwinfo) {
        if ((m_pwinfo = new CWordInfo) == NULL) {
            m_pLexicon = NULL;
            m_pFreq = NULL;
            return PRFEC::gecOOM;
        }
    }
    m_pLink     = NULL;
    m_pLexicon  = pLexicon;
    m_pFreq     = pFreq;
    return PRFEC::gecNone;
}
      
/*============================================================================
Implementation of PRIVATE member functions
============================================================================*/
#pragma optimize("t", on)

// define ANSI char type for driving the LSM
#define WB_ANSI_NULL		0
#define WB_ANSI_NUMBER		1
#define WB_ANSI_SENTENCE	2	// Sentence terminating punctuations
#define WB_ANSI_PUNCT		3	// Punctuation except sentence terminators
#define WB_ANSI_CONTROL     4
#define WB_ANSI_TEXT		5
#define WB_ANSI_SPACE		6
#define WB_NOT_ANSI         7

/*============================================================================
ecBreakANSI()
    Break ANSI into words, and add words to the WordLink
Returns:
    PRFEC error code
============================================================================*/
int	CWordBreak::ecBreakANSI(LPCWSTR pwchAnsi, USHORT cwchLen, USHORT& cwchBreaked)
{
    assert(pwchAnsi);
    assert(cwchLen);
    assert(pwchAnsi[0] >= _ANSI_LOW && pwchAnsi[0] <= _ANSI_HIGH ||
		   pwchAnsi[0] >= _WANSI_LOW && pwchAnsi[0] <= _WANSI_HIGH );

	USHORT	wch, wchPrev = 0;
	USHORT	wState;
	USHORT	wChar;
    BOOL    fFullWidth;
	BYTE	hich, loch;
	CWord   *pword;
    
	wState = wChar = WB_ANSI_NULL;
    fFullWidth = (BOOL)(HIBYTE(pwchAnsi[0]));

	for (wch = 0; wch < cwchLen && wState != WB_NOT_ANSI; wch++) {
        wState = wChar;
        if (wch == cwchLen ) {
            // end of the line
            wChar = WB_NOT_ANSI;            
        } 
        hich = HIBYTE(pwchAnsi[wch]);
        loch = LOBYTE(pwchAnsi[wch]);

        if (fFullWidth &&
			(pwchAnsi[wch] < _WANSI_LOW || pwchAnsi[wch] > _WANSI_HIGH) ||
            ! fFullWidth &&
			(pwchAnsi[wch] < _ANSI_LOW || pwchAnsi[wch] > _ANSI_HIGH)) { 
            //  Not ansi any more
            wChar = WB_NOT_ANSI;
        } else {
            if (hich == 0xFF) {
                loch += 0x20;
            }

            switch (loch) {

            case '0': case '1': case '2': case '3': case '4': 
            case '5': case '6': case '7': case '8': case '9':
            case '%':
                wChar = WB_ANSI_NUMBER;
                break;

            case '.':
                if (wState == WB_ANSI_NUMBER && wch < cwchLen-1 && 
                    (! fFullWidth &&
                     LOBYTE(pwchAnsi[wch+1]) >= '0' &&
                     LOBYTE(pwchAnsi[wch+1]) <= '9'    ) ||
                    (fFullWidth &&
                     LOBYTE(pwchAnsi[wch+1]) + 0x20 >= '0' &&
                     LOBYTE(pwchAnsi[wch+1]) + 0x20 <= '9'    )) {

                    wChar = WB_ANSI_NUMBER;
                } else {
                    wChar = WB_ANSI_SENTENCE;
                }
                break;
                
            case '!': case '?': case ';': case ':':
                wChar = WB_ANSI_SENTENCE;
                break;

            case '#': case '$' : case '&' : case '*': case '=':
            case '+': case '-' : case '/' : case '<': case '>':
            case ',': case '\"': case '\'': case '(': case ')':
            case '[': case ']' : case '{' : case '}': case '_':
            case '`': case '^' : case '@': case '|':
                wChar = WB_ANSI_PUNCT;
                break;

            case ' ':  // space 
                wChar = WB_ANSI_SPACE;
                break;

            default:
                wChar = WB_ANSI_TEXT;
                break;
                
            } // end of switch()
        }

		if (wChar != wState && wState != WB_ANSI_NULL) {
            if ((pword = m_pLink->pAllocWord()) == NULL) {
				return PRFEC::gecOOM;
            }
            pword->FillWord(pwchAnsi + wchPrev, wch - wchPrev);
            if (! fFullWidth) {
                pword->SetFlag(CWord::WF_SBCS);
            }
			switch (wState) {
            
            case WB_ANSI_NUMBER:
                if (fFullWidth) {
                    pword->SetAttri(LADef_numArabic);
                } else {
                    pword->SetAttri(LADef_numSBCS);
                }
                break;
            
            case WB_ANSI_SENTENCE:
                pword->SetAttri(LADef_punPunct);
                pword->SetAttri(LADef_punJu);
                break;
            
            case WB_ANSI_PUNCT:
                pword->SetAttri(LADef_punPunct);
                if (LOBYTE(pwchAnsi[wch]) == ',') {
                    pword->SetAttri(LADef_punJu);
                }
                break;

            case WB_ANSI_TEXT:
                if (fFullWidth) {
                    pword->SetAttri(LADef_genDBForeign);
                }
                break;

            case WB_ANSI_CONTROL:
            case WB_ANSI_SPACE:
                break;

            default:
                pword->SetAttri(LADef_posN);
                break;
            }

			m_pLink->AppendWord(pword);
            wchPrev = wch;
			wState = wChar;
        }
    } // end of for(wch...)

    assert(wch <= cwchLen);
    // Link the last word
    if (wch == cwchLen) {
        if ((pword = m_pLink->pAllocWord()) == NULL) {
            return PRFEC::gecOOM;
        }
        pword->FillWord(pwchAnsi + wchPrev, wch - wchPrev);
        if (! fFullWidth) {
            pword->SetFlag(CWord::WF_SBCS);
        }
        switch (wState) {
            
        case WB_ANSI_NUMBER:
            if (fFullWidth) {
                pword->SetAttri(LADef_numArabic);
            } else {
                pword->SetAttri(LADef_numSBCS);
            }
            break;
            
        case WB_ANSI_SENTENCE:
            pword->SetAttri(LADef_punPunct);
            pword->SetAttri(LADef_punJu);
            break;
            
        case WB_ANSI_PUNCT:
            pword->SetAttri(LADef_punPunct);
            if (LOBYTE(pwchAnsi[wch]) == ',') {
                pword->SetAttri(LADef_punJu);
            }
            break;
            
        case WB_ANSI_TEXT:
            if (fFullWidth) {
                pword->SetAttri(LADef_genDBForeign);
            }
            break;
            
        case WB_ANSI_CONTROL:
        case WB_ANSI_SPACE:
            break;
            
        default:
            pword->SetAttri(LADef_posN);
            break;
        }
        
        m_pLink->AppendWord(pword);
        cwchBreaked = wch;
    } else {
        cwchBreaked = wch - 1;
    }
	return PRFEC::gecNone;
}

/*============================================================================
ecBreakEuro()
    Break european chars into words, and add words to the WordLink
Returns:
    PRFEC error code
============================================================================*/
int	CWordBreak::ecBreakEuro(LPCWSTR pwchEuro, USHORT cwchLen, USHORT& cwchBreaked)
{
    assert(pwchEuro);
    assert(cwchLen);
    assert(pwchEuro[0] >= _EUROPEAN_LOW && pwchEuro[0] <= _EUROPEAN_HIGH);

	CWord*	pWord;
    USHORT  wch;

    for (wch = 0; wch < cwchLen; wch++) {
        if (pwchEuro[wch] < _EUROPEAN_LOW || pwchEuro[wch] > _EUROPEAN_HIGH) {
            break;
        }
    }
    
    if ((pWord = m_pLink->pAllocWord()) == NULL) {
        return PRFEC::gecOOM;
    }
    pWord->FillWord(pwchEuro, wch);
    pWord->SetAttri(LADef_genDBForeign);
    m_pLink->AppendWord(pWord);
    cwchBreaked = wch;
	return PRFEC::gecNone;
}


#define AMBI_WDNUM_THRESHOLD    3
#define AMBI_FREQ_THRESHOLD1    50
/*============================================================================
CWordBreak::ecDoBreak():
    Break Chinese section into words, and add words to the WordLink
    Call ambiguity function to resolve ambiguities
Returns:
    PRFEC error code
============================================================================*/
int CWordBreak::ecDoBreak(void)
{
    int     iret;
    LPCWSTR pwchText;
    USHORT  cwchText;
    USHORT  iwchWord = 0;   // offset of current word from the head position of current section
    USHORT  ciAmbi;     // count of Ambi words
    USHORT  cwMatch;
	CWord*  pword;

    cwchText = m_pLink->cwchGetLength();
    pwchText = m_pLink->pwchGetText();
    while (iwchWord < cwchText)  {
        // Handle surrogates
        if (iwchWord + 1 < cwchText && IsSurrogateChar(pwchText+iwchWord)) {

            cwMatch = 2;
            while (iwchWord + cwMatch + 1 < cwchText &&
                   IsSurrogateChar(pwchText+iwchWord + cwMatch)) {
                cwMatch += 2;
            }
            if ((pword = m_pLink->pAllocWord()) == NULL) {
                return PRFEC::gecOOM;
            }
            pword->FillWord(pwchText + iwchWord, cwMatch);
            //  pword->SetAttri(LADef_genDBForeign);
            m_pLink->AppendWord(pword);
            iwchWord += cwMatch;
            continue;
        } else if (pwchText[iwchWord] >= _ANSI_LOW && pwchText[iwchWord] <= _ANSI_HIGH ||
			       pwchText[iwchWord] >= _WANSI_LOW && pwchText[iwchWord] <= _WANSI_HIGH ) {
            // ANSI or Full size ANSI break
            iret = ecBreakANSI(pwchText+iwchWord, cwchText - iwchWord, cwMatch);
            if ( iret != PRFEC::gecNone ) {
                return iret;
            }
            iwchWord += cwMatch;
            continue;
        } else if (pwchText[iwchWord] <= _EUROPEAN_HIGH &&
                   pwchText[iwchWord] >= _EUROPEAN_LOW) {
            // European text break
            iret = ecBreakEuro(pwchText+iwchWord, cwchText - iwchWord, cwMatch);
            if ( iret != PRFEC::gecNone ) {
                return iret;
            }
            iwchWord += cwMatch;
            continue;
        } else {
        }
        ciAmbi = 1;
        cwMatch = m_pLexicon->cwchMaxMatch( pwchText + iwchWord, 
                                            cwchText - iwchWord, m_pwinfo);
        if ((m_rgAmbi[0] = m_pLink->pAllocWord()) == NULL) {
            return PRFEC::gecOOM;
        }
        m_rgAmbi[0]->FillWord(pwchText + iwchWord, cwMatch, m_pwinfo);
        iwchWord += cwMatch;
        if (cwMatch == 1) {
            m_pLink->AppendWord(m_rgAmbi[0]);
            m_rgAmbi[0] = NULL;
            continue;
        }

        // Detect ambiguity
        if ( !fNoAmbiWord(m_rgAmbi[0]) ) {
            while ((cwMatch > 1) && 
                   cwMatch <= AMBI_WDNUM_THRESHOLD &&
                   ciAmbi < MAX_AMBI_WORDS && iwchWord < cwchText ) {

                cwMatch = m_pLexicon->cwchMaxMatch(pwchText + iwchWord - 1,
                                         cwchText - iwchWord + 1, m_pwinfo);
                if (cwMatch > 1) { 
                    // Ambiguous found!
                    if (! (m_rgAmbi[ciAmbi] = m_pLink->pAllocWord()) ) {
                        break;  // we can not return with some unlinked word nodes in m_rgAmbi
                    }
                    m_rgAmbi[ciAmbi]->FillWord( pwchText + iwchWord - 1, 
                                                cwMatch, m_pwinfo);
                    iwchWord += cwMatch - 1;
                    ciAmbi++;
                }
            } // while(iwchWord < cwchText && ciAmbi < MAX_AMBI_WORDS)
        
        } 

        if (ciAmbi > 1) { // Resolve ambiguities
                iret = ecResolveAmbi(ciAmbi);
                for (int i = 0; i < ciAmbi; i++) { 
                    if(m_rgAmbi[i] != NULL) { 
                        m_pLink->FreeWord(m_rgAmbi[i]);
                        m_rgAmbi[i] = NULL;
                    }
                }
                 // assert don't over boundary
                assert(ciAmbi == MAX_AMBI_WORDS || m_rgAmbi[ciAmbi] == NULL);
                if (iret != PRFEC::gecNone) {
                    return iret;
                }
        } else {
            // No ambiguities
            m_pLink->AppendWord(m_rgAmbi[0]);
            m_rgAmbi[0] = NULL;
        }
    } // end of sentence word link loop for(iwchWord = 0; iwchWord < cwchText; )

    assert(iwchWord <= cwchText);

    return PRFEC::gecNone;
}
        
/*============================================================================
CWordBreak::ecResolveAmbi():
    Single char cross ambiguity resolution function
    Ambiguious word pointers stored in m_rgAmbi, m_pLink is the owner of these words
Returns:
    PRFEC error code
Remarks:
    Elements of m_rgAmbi contain word pointer which have been add the the WordLink
    will be set to NULL, the other word nodes should be freed by the caller
    The whole ambiguious string must be processed by this function
    Two words ambiguous, unigram threshold to become single char word, unigram of 0xB3A4()
============================================================================*/
int CWordBreak::ecResolveAmbi(USHORT ciAmbi)
{
    CWordInfo   winfo;
    UCHAR       freq1, freq2, freq3;
    UCHAR       nResolved;
    USHORT      cwMatch, iwch, cwch;
    LPWSTR      pwch;

    assert(MAX_AMBI_WORDS < 255); // make sure nResolved will not overflow

    switch (ciAmbi) {
        case 2:
            if ((m_rgAmbi[0]->cwchLen()== 2) && (m_rgAmbi[1]->cwchLen()== 2)){
                // AB BC
                if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[1]->pwchGetText()+1),
                                              m_pwinfo)) {
                    return PRFEC::gecUnknown;
                }
                if ( !m_rgAmbi[0]->fGetAttri(LADef_pnQian) || // ""
                     !m_pwinfo->fGetAttri(LADef_pnXing) &&    // ""
                     !m_pwinfo->fGetAttri(LADef_pnWai) ) {    // ""
                    if (m_pFreq->uchGetFreq(*(m_rgAmbi[0]->pwchGetText())) >
                        m_pFreq->uchGetFreq(*(m_rgAmbi[1]->pwchGetText()+1)) ) {
                        // if Freq(A) > Freq(C) then A/BC
                        // BUG: don't use m_pwinfo here, it keep the wordinfo of C!
                        // if(!m_pLexicon->fGetCharInfo(m_pLink->pchGetText() + m_rgAmbi[0].m_pWord->m_ichStart, m_pwinfo)) {
                        if (!m_pLexicon->fGetCharInfo(
                                            *(m_rgAmbi[0]->pwchGetText()),
                                            &winfo)) {
                            assert(0);
                            return PRFEC::gecUnknown;
                        }
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),
                                              1, &winfo)){
                            return PRFEC::gecOOM;
                        }
                        LinkAmbiWord(1);
                        return PRFEC::gecNone;
                    }
                }
                // if Freq(A) <= Freq(B) .or. ("" + "") .or. ("" + "") then AB/C
                LinkAmbiWord(0);
                if (!fLinkNewAmbiWord(m_rgAmbi[1]->pwchGetText()+1,
                                      1, m_pwinfo)) {
                    return PRFEC::gecOOM;
                }
                return PRFEC::gecNone;
            }
            
            // case 2:
            if ((m_rgAmbi[0]->cwchLen()== 2) && (m_rgAmbi[1]->cwchLen() > 2)) {
                // AB BCD
                if (m_pFreq->uchGetFreq(*(m_rgAmbi[0]->pwchGetText()))
                             <= AMBI_FREQ_THRESHOLD1) {
                    if (m_pLexicon->cwchMaxMatch(m_rgAmbi[1]->pwchGetText()+1,
                                                 m_rgAmbi[1]->cwchLen()-1, 
                                                 m_pwinfo) 
                                    == (m_rgAmbi[1]->cwchLen() - 1)) {
                        // if Freq(A) <= Threshold1 .and. IsWord(CD) then AB/CD
                        LinkAmbiWord(0);
                        if (!fLinkNewAmbiWord(m_rgAmbi[1]->pwchGetText() + 1,
                                              m_rgAmbi[1]->cwchLen() - 1,
                                              m_pwinfo) ) {
                            return PRFEC::gecOOM;
                        }
                        return PRFEC::gecNone;
                    }
                }
                // if Freq(A) > Threshold1 .or. !IsWord(CD) then A/BCD
                if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[0]->pwchGetText()),
                                              m_pwinfo)) {
                        return PRFEC::gecUnknown;
                }
                if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),1, m_pwinfo)){
                    return PRFEC::gecOOM;
                }
                LinkAmbiWord(1);
                return PRFEC::gecNone;
            }

            // case: 2
            if ((m_rgAmbi[0]->cwchLen() > 2) && (m_rgAmbi[1]->cwchLen() == 2)) {
                // ABC CD
                if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[1]->pwchGetText() + 1),
                                              m_pwinfo)) {
                    return PRFEC::gecUnknown;
                }
                if ((m_pFreq->uchGetFreq(*(m_rgAmbi[1]->pwchGetText() + 1))
                              <= AMBI_FREQ_THRESHOLD1) &&
                    (!m_rgAmbi[0]->fGetAttri(LADef_pnQian) ||  // ""
                     !m_pwinfo->fGetAttri(LADef_pnXing) &&         // ""
                     !m_pwinfo->fGetAttri(LADef_pnWai)) ) {        // ""
                    // if Freq(D) <= Threshold1 .and. ( !("" + "") .and. !("" + "") ) then...
                    // BUG: don't use m_pwinfo here, it keep the wordinfo of C!
                    if (m_pLexicon->cwchMaxMatch(m_rgAmbi[0]->pwchGetText(),
                                                 m_rgAmbi[0]->cwchLen() - 1,
                                                 &winfo)
                                    == (m_rgAmbi[0]->cwchLen()-1)) {
                        // if IsWord(AB) then AB/CD
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),
                                              m_rgAmbi[0]->cwchLen() - 1,
                                              &winfo)) {
                            return PRFEC::gecOOM;
                        }
                        LinkAmbiWord(1);
                        return PRFEC::gecNone;
                    }
                }
                // if Freq(D) > Threshold1 or ( ("" + "") .or. ("" + "") ) or !IsWord(AB) 
                // then ABC/D
                LinkAmbiWord(0);
                if (!fLinkNewAmbiWord(m_rgAmbi[1]->pwchGetText() + 1, 
                                      1, m_pwinfo)) {
                    return PRFEC::gecOOM;
                }
                return PRFEC::gecNone;
            }
                
            // case 2:
            if ((m_rgAmbi[0]->cwchLen() > 2) && (m_rgAmbi[1]->cwchLen() > 2)) {
                // ABC CDE
                if (m_pLexicon->cwchMaxMatch(m_rgAmbi[0]->pwchGetText(),
                                             m_rgAmbi[0]->cwchLen() - 1,
                                             m_pwinfo) 
                                == (m_rgAmbi[0]->cwchLen() - 1)) {
                    // if IsWord(AB) then AB/CDE
                    if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),
                                          m_rgAmbi[0]->cwchLen() - 1,
                                          m_pwinfo)) {
                        return PRFEC::gecOOM;
                    }
                    LinkAmbiWord(1);
                    return PRFEC::gecNone;
                }
                // if !IsWord(AB) then ABC/D...E    (re-break D...E string)
                LinkAmbiWord(0);
                pwch = m_rgAmbi[1]->pwchGetText() + 1;
                cwch = m_rgAmbi[1]->cwchLen() - 1;
                iwch = 0;
                while (iwch < cwch) {
                    cwMatch = m_pLexicon->cwchMaxMatch(pwch + iwch,
                                                       cwch - iwch, m_pwinfo);
                    assert(cwMatch);
                    if (!fLinkNewAmbiWord(pwch + iwch, cwMatch, m_pwinfo)) {
                        return PRFEC::gecOOM;
                    }
                    iwch += cwMatch;
                }
                return PRFEC::gecNone;
            }

            // case 2:
            assert(0);  // Never run to here!
            break;

        case 3:
            if (m_rgAmbi[1]->cwchLen() == 2) {
                // A.C CD D.E
                if ((m_rgAmbi[0]->cwchLen()==3) && (m_rgAmbi[2]->cwchLen()==2)){
                    // ABC CD DE
                    cwMatch =m_pLexicon->cwchMaxMatch(m_rgAmbi[0]->pwchGetText(),
                                                      m_rgAmbi[0]->cwchLen()-1,
                                                      m_pwinfo);
                    if( (cwMatch == m_rgAmbi[0]->cwchLen()-1) &&
                        (m_pFreq->uchGetFreq(*(m_rgAmbi[1]->pwchGetText()))+2<
                         m_pFreq->uchGetFreq(*(m_rgAmbi[2]->pwchGetText()+1)))){
                        // if IsWord(AB) .and. (Freq(E)-Freq(C) > 2) then AB/CD/E
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(), 
                                              cwMatch, m_pwinfo)) {
                            return PRFEC::gecOOM;
                        }
                        LinkAmbiWord(1);
                        if (!m_pLexicon->fGetCharInfo(
                                            *(m_rgAmbi[2]->pwchGetText()+1),
                                            m_pwinfo)) {
                            return PRFEC::gecUnknown;
                        }
                        if (!fLinkNewAmbiWord(m_rgAmbi[2]->pwchGetText()+1, 
                                              1, m_pwinfo)) {
                            return PRFEC::gecOOM;
                        }
                        return PRFEC::gecNone;
                    }
                } // end if(ABC CD DE) and only some special cases have been handled
                else if ((m_rgAmbi[0]->cwchLen() == 2) && 
                         (m_rgAmbi[2]->cwchLen() == 3)) {
                    // AB BC CDE
                    cwMatch = m_pLexicon->cwchMaxMatch(
                                              m_rgAmbi[2]->pwchGetText()+1,
                                              m_rgAmbi[2]->cwchLen()-1,
                                              m_pwinfo);
                    if( (cwMatch == m_rgAmbi[2]->cwchLen()-1) &&
                        ( m_pFreq->uchGetFreq(*(m_rgAmbi[0]->pwchGetText()))-2 >
                          m_pFreq->uchGetFreq(*(m_rgAmbi[2]->pwchGetText()))) ){
                        // if IsWord(DE) .and. (Freq(A)-Freq(C) > 2) then A/BC/DE
                        if (!m_pLexicon->fGetCharInfo(
                                            *(m_rgAmbi[0]->pwchGetText()),
                                            &winfo)) {
                            return PRFEC::gecUnknown;
                        }
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(), 
                                              1, &winfo)) {
                            return PRFEC::gecOOM;
                        }
                        LinkAmbiWord(1);
                        if (!fLinkNewAmbiWord(m_rgAmbi[2]->pwchGetText()+1,
                                              cwMatch, m_pwinfo)) {
                            return PRFEC::gecOOM;
                        }
                        return PRFEC::gecNone;
                    }
                } // end of if(AB BC CDE) and only some special cases have been handled
                else {
                }
                // else
                // if (AB BC CD) or (A.B BC C.D) then A.B/C.D
                LinkAmbiWord(0);
                LinkAmbiWord(2);
                return PRFEC::gecNone;
            } // if(m_rgAmbi[1]->cwchLen() == 2)
            else {  // the middle word contain more then 2 characters
                    /*
                    *   I have no idea to handle these cases and get better 
                    *   accuracy than the recursive approach
                    */
                goto gotoRecursive;
            }
            break;

        case 4:
            if( (m_rgAmbi[0]->cwchLen()== 2) && (m_rgAmbi[1]->cwchLen()== 2) &&
                (m_rgAmbi[2]->cwchLen()== 2) && (m_rgAmbi[3]->cwchLen()== 2)) {
                // AB BC CD DE
                // This is the most common case in terms of statistical result
                // if we get the MAX[Freq(A), Freq(C), Freq(E)], then everything are easy
                freq1 = m_pFreq->uchGetFreq(*(m_rgAmbi[0]->pwchGetText()));
                freq2 = m_pFreq->uchGetFreq(*(m_rgAmbi[2]->pwchGetText()));
                freq3 = m_pFreq->uchGetFreq(*(m_rgAmbi[3]->pwchGetText() + 1));

                if ( (freq1 > freq2) && (freq1 >= freq3) ) {
                    //    A/BC/DE
                    if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[0]->pwchGetText()),
                                                  m_pwinfo)) {
                        return PRFEC::gecUnknown;
                    }
                    if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(), 
                                          1, m_pwinfo)) {
                        return PRFEC::gecOOM;
                    }
                    LinkAmbiWord(1);
                    LinkAmbiWord(3);
                    return PRFEC::gecNone;
                } else if( (freq2 >= freq1) && (freq2 > freq3) ) {
                    //    AB/C/DE
                    LinkAmbiWord(0);
                    if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[2]->pwchGetText()),
                                                  m_pwinfo)) {
                        return PRFEC::gecUnknown;
                    }
                    if (!fLinkNewAmbiWord(m_rgAmbi[2]->pwchGetText(), 
                                          1, m_pwinfo)) {
                        return PRFEC::gecOOM;
                    }
                    LinkAmbiWord(3);
                    return PRFEC::gecNone;
                } else {
                    // if(freq3 >= freq2 && freq3 >= freq1)
                    //    AB/CD/E
                    LinkAmbiWord(0);
                    LinkAmbiWord(2);
                    if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[3]->pwchGetText()+1),
                                                  m_pwinfo)) {
                        return PRFEC::gecUnknown;
                    }
                    if (!fLinkNewAmbiWord(m_rgAmbi[3]->pwchGetText() + 1, 
                                          1, m_pwinfo)) {
                        return PRFEC::gecOOM;
                    }
                    return PRFEC::gecNone;
                }
            } // end of if(AB BC CD DE)
            else {
                /*
                *   There are too many cases in 4 words nested ambiguities
                *   I have to left all other cases to be resolved in recursive approach
                */
                goto gotoRecursive;
            }

        case 5:
            // I just handle the easy but most common case directly here
            if ((m_rgAmbi[1]->cwchLen()== 2) && (m_rgAmbi[3]->cwchLen()== 2)){
                LinkAmbiWord(0);
                LinkAmbiWord(2);
                LinkAmbiWord(4);
                return PRFEC::gecNone;
            } else {
                /*
                *   I have to left all other cases for recursive approach
                */
                goto gotoRecursive;
            }
            break;

        default:
gotoRecursive:
            /*
            *   I left all other cases to fall in here, and handle them using the 
            *   recursive approach. The depth of the recursive stack are controlled
            *   by the MAX_AMBI_WORDS. Thanks god, it take only 12 bytes stack overhead
            *   in each recursive call.
            *   In terms of recursive ambiguity resolving, I just handle the first word
            *   in the ambi string, and reset the array of m_rgAmbi[] to call this function
            *   recursively, till all words in the string have been processed
            *   It's quit dangous to free the word node and move the elements in m_rgAmbi[],
            *   please be careful if you touch m_rgAmbi[] or make any assumption on it, 
            *   when you do some change on this piece of code some day.
            *   I have no better idea to avoid spreading these tricky things more than 
            *   one place until now <donhz 5/31>
            */
            assert(ciAmbi > 2); // I have process all cases when ciAmbi == 2
            if (m_rgAmbi[1]->cwchLen()== 2 ) {
                // just split the 2nd word and then free it
                assert(ciAmbi > 3); // A.B BC C.D has been processed in ciAmbi == 3
                LinkAmbiWord(0);
                // I employ nResolved to keep the number of words have been resolved,
                // and it will used to reset the m_rgAmbi[] and ciAmbi for next
                // recursive call. 
                nResolved = 2; 
            } else {
                // if(m_rgAmbi[1]->cwchLen() > 2)
                // there are more complicated cases here
                if (m_rgAmbi[0]->cwchLen()== 2 ) {
                    // AB BC.D ...
                    cwMatch = m_pLexicon->cwchMaxMatch(
                                            m_rgAmbi[1]->pwchGetText() + 1,
                                            m_rgAmbi[1]->cwchLen() - 1,
                                            m_pwinfo);
                    if (cwMatch == m_rgAmbi[1]->cwchLen() - 1) {
                        // if IsWord(C.D) then AB/C.D...
                        LinkAmbiWord(0);
                        m_rgAmbi[1]->ClearWord();
                        m_rgAmbi[1]->FillWord(m_rgAmbi[1]->pwchGetText() + 1, 
                                              cwMatch, m_pwinfo);
                        nResolved = 1;
                    } else { 
                        // if !IsWord(C.D) then let A alone
                        if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[0]->pwchGetText()),
                                                      m_pwinfo)){
                            // I have not do any thing until now, so return and don't worry
                            return PRFEC::gecUnknown;   
                        }
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),
                                              1, m_pwinfo)) {
                            return PRFEC::gecOOM;
                        }
                        nResolved = 1;
                    }
                } else {
                    // if (m_rgAmbi[0]->cwchLen() > 2 )
                    // A.BC CD.E ...
                    if ( (m_rgAmbi[0]->cwchLen() == 3)  &&
                         ( m_pLexicon->cwchMaxMatch(m_rgAmbi[0]->pwchGetText(),
                                                    m_rgAmbi[0]->cwchLen() - 1,
                                                    m_pwinfo)
                                       == (m_rgAmbi[0]->cwchLen() - 1) ) ) {
                        // if (ABC CD.E ...) .and. IsWord(AB) then A.B/CD.E...
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),
                                              m_rgAmbi[0]->cwchLen() - 1,
                                              m_pwinfo)){
                            return PRFEC::gecOOM;
                        }
                        nResolved = 1;
                    }
                    else if( (cwMatch = m_pLexicon->cwchMaxMatch(
                                                m_rgAmbi[1]->pwchGetText()+1,
                                                m_rgAmbi[1]->cwchLen() - 1,
                                                m_pwinfo)) 
                             == (m_rgAmbi[1]->cwchLen() - 1) ) {
                        // if IsWord(D.E) then A.BC/D.E...
                        // Not too bad!
                        LinkAmbiWord(0);
                        m_rgAmbi[1]->ClearWord();
                        m_rgAmbi[1]->FillWord(m_rgAmbi[1]->pwchGetText() + 1, 
                                              cwMatch, m_pwinfo);
                        nResolved = 1;
                    }
                    else {// if ( (ABC CD.E ...) .and. !IsWord(AB) .and. !IsWord(D.E) ) .or.
                          //    ( (AB.C CD.E ...) .and. !IsWord(D.E) ) 
                          // then AB.C/D/././EF...       (Re-break string before E)
                        LinkAmbiWord(0);
                        // Re-break section "D."
                        if (m_rgAmbi[1]->cwchLen() == 3) {
                            // the only case indeed, if we stop ambiguity detection at >=4 char words
                            if (!m_pLexicon->fGetCharInfo(
                                                *(m_rgAmbi[1]->pwchGetText()+1),
                                                m_pwinfo)) {
                                return PRFEC::gecUnknown;
                            }
                            if (!fLinkNewAmbiWord(m_rgAmbi[1]->pwchGetText()+1,
                                                  1, m_pwinfo)) {
                                return PRFEC::gecOOM;
                            }
                        } else {
                            // if(m_rgAmbi[1]->cwchLen() > 3)
                            // re-break "D." in a word breaking loop
                            assert(m_rgAmbi[1]->cwchLen() > 6);
                            pwch = m_rgAmbi[1]->pwchGetText() + 1;
                            cwch = m_rgAmbi[1]->cwchLen() - 2;
                            iwch = 0;
                            while (iwch < cwch) {
                                cwMatch = m_pLexicon->cwchMaxMatch(pwch + iwch,
                                                                   cwch - iwch,
                                                                   m_pwinfo);
                                assert(cwMatch);
                                if (!fLinkNewAmbiWord(pwch + iwch, 
                                                      cwMatch, m_pwinfo)) {
                                    return PRFEC::gecOOM;
                                }
                                iwch += cwMatch;
                            }
                        }
                        nResolved = 2;
                        if (ciAmbi == 3) {
                            // Don't leave a single word in m_rgAmbi[], 
                            // there are no abmiguities any more
                            LinkAmbiWord(2);
                            return PRFEC::gecNone; // Another way to exit!!!
                        }
                    }
                } // end of if (m_rgAmbi[0]->cwchLen() > 2 )
            } // end of if(m_rgAmbi[1]->cwchLen() > 2)

            /*
            *   All cases of 1st word have been handled.
            *   Now, it's time to reset m_rgAmbi[] and ciAmbi.
            */
            for (iwch = 0; iwch < nResolved; iwch++) {
                if (m_rgAmbi[iwch] != NULL) {
                    m_pLink->FreeWord(m_rgAmbi[iwch]); // free unlinked word node
                }
            }
            for (iwch = nResolved; iwch < ciAmbi; iwch++) {
                m_rgAmbi[iwch - nResolved] = m_rgAmbi[iwch];
            }
            for (iwch = ciAmbi - nResolved; iwch < ciAmbi; iwch++) {
                m_rgAmbi[iwch] = NULL;
            }
            ciAmbi -= nResolved;
            assert(ciAmbi >= 2);

            /*
            *   The last thing to do is calling myself recursively
            */
            return ecResolveAmbi(ciAmbi);

        } // end of main switch()

    assert(0); // It's impossible to get here
    return PRFEC::gecUnknown; 
}

#pragma optimize( "", on ) 
    
/*============================================================================
BOOL CWordBreak::fNoAmbiWord():
    Check whether the word can participate ambiguity detection
Returns:
    TRUE if it can not.
    FALSE for normal word
============================================================================*/
inline BOOL CWordBreak::fNoAmbiWord(CWord* pWord)
{
    assert(!pWord->fGetFlag(CWord::WF_SBCS));
    assert(pWord->cwchLen() > 1);
    return (BOOL)( // pWord->cwchLen() == 1 ||
                    pWord->fGetAttri(LADef_punPunct) || 
                    pWord->fGetAttri(LADef_genCuo) || 
                    pWord->fProperName()
                 );
}
    

/*============================================================================
CWordBreak::LinkAmbiWord():
    Link specific Ambi word in m_rgAmbi[], and mark it as WF_AMBI
============================================================================*/
inline void CWordBreak::LinkAmbiWord(
                            USHORT iAmbi)// index of Ambi word in m_rgAmbi[]
{
    assert(m_rgAmbi[iAmbi]);
    m_rgAmbi[iAmbi]->SetFlag(CWord::WF_WORDAMBI);
    m_pLink->AppendWord(m_rgAmbi[iAmbi]); 
    m_rgAmbi[iAmbi] = NULL;
}


/*============================================================================
CWordBreak::fLinkNewAmbiWord():
    Link a new work to the WordLink, and mark it as WF_AMBI
============================================================================*/
inline BOOL CWordBreak::fLinkNewAmbiWord(
                         LPCWSTR pwchWord, 
                         USHORT cwchLen, 
                         CWordInfo* pwinfo)
{
    CWord* pWord = m_pLink->pAllocWord();
    if (pWord != NULL) {
        pWord->FillWord( pwchWord, cwchLen, pwinfo );
        pWord->SetFlag(CWord::WF_WORDAMBI);
        m_pLink->AppendWord(pWord);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\wordlink.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Word and WordLink

Purpose:   Define the CWord and CWordLink classes
           Using CMyPlex to alloc and manage memory for word object in the link
Notes:     This module is a fundamental stuff for SCProof'98, 
           it does NOT depend on any other class.
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz    5/26/97
============================================================================*/
#include "myafx.h"

#include "wordlink.h"
#include "myplex.h"
#include "lexicon.h"

/*============================================================================
Implementation of functions in CWord
============================================================================*/

/*============================================================================
CWord constructor
============================================================================*/
CWord::CWord( ) 
{
    m_dwWordID = 0;
    m_hLex = 0;
    m_dwFlag = 0;
    for (int i = 0; i < WORD_ATTRI_SIZE; i++)
        m_aAttri[i] = 0;
    m_idErr = 0;
    m_cwchText = 0;
    m_pwchText = NULL;
    m_pPrev = NULL;
    m_pNext = NULL;
    m_pMergedFrom = NULL;
#ifdef DEBUG
    m_pMergedTo = NULL;
#endif
}

/*============================================================================
CWord::FillWord():
    Fill the word.
============================================================================*/
void CWord::FillWord( LPCWSTR pwchText, USHORT cwchText, CWordInfo* pwinfo )
{
    assert(pwchText);
    assert(cwchText);

    m_pwchText = const_cast<LPWSTR>(pwchText);
    m_cwchText = cwchText;
    m_dwFlag = 0;
    ZeroMemory( (LPVOID)m_aAttri, sizeof(DWORD)*WORD_ATTRI_SIZE);
    m_idErr = 0;
    if (m_cwchText == 1) {
        SetFlag(CWord::WF_CHAR);
    }
    if (pwinfo != NULL) {
        m_dwWordID = pwinfo->GetWordID();
        m_hLex = pwinfo->GetLexHandle();
        for (USHORT i = 0; i < pwinfo->AttriNum(); i++) {
            SetAttri( pwinfo->GetAttri(i) );
        }
    } else {
        m_dwWordID = 0;
        m_hLex = 0;
    }
}

/*============================================================================
CWord::fIsWordText()
    Compare this word's text with given text.
Returns:
    TRUE if match
    FALSE if not
============================================================================*/
BOOL CWord::fIsWordText(LPCWSTR lpwcText) const
{
    assert(m_pwchText && m_cwchText);
    assert(lpwcText);
    if(m_cwchText != wcslen(lpwcText))
        return FALSE;
    for(USHORT i = 0; i < m_cwchText; i++) {
        if(lpwcText[i] != m_pwchText[i])
            return FALSE;
    }
    return TRUE;
}

/*============================================================================
CWord::fIsTextIdentical(const CWord*)
    Compare this word's text with other word's text
Returns:
    TRUE if the text of them identical
    FALSE if not
============================================================================*/
BOOL CWord::fIsTextIdentical(const CWord* pWord) const
{
    assert(m_pwchText);
    assert(m_cwchText);
    assert(pWord);
    assert(pWord->m_pwchText);
    if (m_pwchText == NULL || pWord->m_pwchText == NULL 
        || m_cwchText != pWord->m_cwchText) {
        return FALSE;
    }
    return (BOOL)(wcsncmp(m_pwchText, pWord->m_pwchText, m_cwchText) == 0);
}

/*============================================================================
Implementation of functions in CWordLink
============================================================================*/

/*============================================================================
CWordLink constructor
============================================================================*/
CWordLink::CWordLink(UINT ciBlockWordCount)
{
    // Assert: all blocks are in same size!
    m_dwFlag = 0;
    m_dwFormat = 0;
    m_ciBlockSize = ciBlockWordCount;

    m_pwchText  = NULL;
    m_pWordPool = NULL;
    m_pHead     = NULL;
    m_pTail     = NULL;
    m_pFree     = NULL;
}


/*============================================================================
CWordLink destructor
============================================================================*/
CWordLink::~CWordLink()
{
#ifdef DEBUG
    assert(!fDetectLeak()); // Assert: no memory leak detected
#endif
    if(m_pWordPool)
        m_pWordPool->FreeChain();
}

    
/*============================================================================
CWordLink::InitLink()
    Init word link, set the text buffer pointer and length.
Remarks:
    If there are words in the link, free the link at first
    dwFormat is a format hint info generate by WinWord, 
    it's a very important property of the sentence
============================================================================*/
void CWordLink::InitLink(const WCHAR* pwchText, USHORT cwchLen, DWORD dwFormat)
{
    FreeLink();
    m_dwFlag = 0;
    m_pwchText = pwchText;
    m_cwchLen = cwchLen;
    m_dwFormat = dwFormat;
}

    
/*============================================================================
CWord::pGetHead()
    Get the head Word node of the WordLink.
Remarks:
    In debug mode, do a all nodes verify one by one.
============================================================================*/
#ifdef DEBUG
CWord* CWordLink::pGetHead(void)
{ 
    // Verify each node before iterate the WordLink
    CWord* pWord = m_pHead;
    WCHAR* pwchText;
    USHORT cwchText=0;

    if (pWord != NULL) {
        pwchText = pWord->m_pwchText;
        // head node's m_pwchText must match this WordLink's m_pwchText !
        assert(pwchText == m_pwchText); 
    }
    while (pWord) {
        assert(pWord->cwchLen() > 0);
        assert(pWord->fGetFlag(CWord::WF_SBCS) ||
                (pWord->cwchLen() == 1 && pWord->fGetFlag(CWord::WF_CHAR)) ||
                (pWord->cwchLen() > 1 && !pWord->fGetFlag(CWord::WF_CHAR)) );
        assert(pwchText + cwchText == pWord->m_pwchText);
        cwchText += pWord->m_cwchText;
        pWord->pChildWord(); // do a recursion to childs
        pWord = pWord->pNextWord();
    }
    return (CWord*)m_pHead; 
}
#else
CWord* CWordLink::pGetHead(void) { return m_pHead; };
#endif // DEBUG


/*============================================================================
CWordLink::pAllocWord()
    Alloc a new word, but do not chain the word into the link.
    All public fields in the word object set to 0.
Returns:
    a CWord point to the new word.
    NULL if alloc failure.
============================================================================*/
CWord* CWordLink::pAllocWord(void)
{
    assert(m_pwchText); // Catch uninitialized call
    CWord*  pWord = pNewWord();
    if (pWord != NULL) {
        ZeroMemory( pWord, sizeof(CWord) );
/************
        pWord->ClearWord();
        pWord->m_pwchText = NULL;
        pWord->m_cwchText = 0;
        pWord->m_pNext = NULL;
        pWord->m_pPrev = NULL;
        pWord->m_pMergedFrom = NULL;
#ifdef DEBUG
        pWord->m_pMergedTo = NULL;
#endif // DEBUG
************/
    }
    return pWord;
}

/*============================================================================
CWordLink::AppendWord()
    Append a word object into the link.
============================================================================*/
void CWordLink::AppendWord(CWord* pWord)
{
#ifdef DEBUG
    assert(m_pwchText && m_cwchLen); // Catch uninitialized call
    // Word's text pointer must fall in WordLink's text buffer
    assert(pWord->m_pwchText >= m_pwchText && pWord->m_cwchText); 
    assert(pWord->m_pwchText + pWord->m_cwchText <= m_pwchText + m_cwchLen);
    assert(!fInLink(pWord));   // pWord must outof current link
    assert(!fInChild(pWord));  
    assert(fInBlocks(pWord));  // pWord must owned by current WordLink
    if (m_pTail) {
        // No zero-length word allowed
        assert(pWord->m_pwchText == m_pTail->m_pwchText + m_pTail->m_cwchText); 
    } else {
        assert(pWord->m_pwchText == m_pwchText);
    }
#endif // DEBUG

    pWord->m_pNext = NULL;
    if (!m_pHead) {
        assert(pWord->m_pwchText == m_pwchText);
        m_pHead = pWord;
    }   else {
        assert(pWord->m_pwchText > m_pwchText);
        m_pTail->m_pNext = pWord;
    }
    pWord->m_pPrev = m_pTail;
    m_pTail = pWord;
}


/*============================================================================
CWordLink::FreeWord()
    Free word to the free chain, pWord must out of current WordLink
============================================================================*/
void CWordLink::FreeWord(CWord* pWord)
{
    assert(pWord);
    assert(m_pwchText);          // Catch uninitialized call
#ifdef DEBUG
    assert(!fInLink(pWord));    // pWord should not in current link
    assert(!fInChild(pWord));   // must not in any of the child links
    assert(!fInFree(pWord));    // must not in free link
    assert(fInBlocks(pWord));   // pWord must owned by this WordLink instance
#endif // DEBUG
    // link the word to the free link
    pWord->m_pNext = m_pFree;
    m_pFree = pWord;
}

/*============================================================================
CWordLink::FreeLink(CWord*)
    Free the word link begin with CWord* (link words to the free chain)
============================================================================*/
void CWordLink::FreeLink( CWord* pWord )
{
    assert(pWord);
#ifdef DEBUG
    assert(fInBlocks(pWord));   // pWord must owned by this WordLink instance
    if (pWord != m_pHead) {
        if (m_pwchText) {
            assert(!fInLink(pWord));    // pWord should not in current link
            assert(!fInChild(pWord));  
        }
    }
#endif // DEBUG

    CWord* pNode = pWord;
    while (pNode->m_pNext) {
        if (pNode->m_pMergedFrom) {
            FreeLink(pNode->m_pMergedFrom);
        }
        pNode = pNode->m_pNext;
#ifdef DEBUG
        assert(!fInFree(pWord));
#endif // DEBUG
    }
    if (pNode->m_pMergedFrom) {
        FreeLink(pNode->m_pMergedFrom);
    }
    pNode->m_pNext = m_pFree;
    m_pFree = pWord;
}

/*============================================================================
CWordLink::pSplitWord()
    Split a proper word into two words and insert the new word into the link
Returns:
    Return the new word pointer if success, return NULL if failed to alloc new word
    or invalid cchSplitAt
Remarks:
    only Chinese word can be splitted
============================================================================*/
CWord* CWordLink::pSplitWord(CWord* pWord, USHORT cwchSplitAt)
{
    assert(m_pwchText); // Catch uninitialized call
    assert(pWord);
#ifdef DEBUG
    assert(fInLink(pWord)); // pWord must in current link
#endif // DEBUG
    assert(cwchSplitAt < pWord->m_cwchText);
    assert(!pWord->fGetFlag(CWord::WF_SBCS) && cwchSplitAt > 0);

    if (cwchSplitAt == 0 || cwchSplitAt >= pWord->m_cwchText) {
        return NULL;
    }

    if (pWord->m_pMergedFrom != NULL) {
        // free the child chains!
        CWord* pTemp = pWord->m_pMergedFrom;
        pWord->m_pMergedFrom = NULL;
        FreeLink(pTemp);
    }
    CWord*  pNew = pNewWord();
    if (pNew != NULL) {
        // link the new word into the WordLink
        pNew->m_pPrev = pWord;
        if (pWord->m_pNext == NULL) {
            m_pTail = pNew;
            pNew->m_pNext = NULL;
        } else {
            pWord->m_pNext->m_pPrev = pNew;
            pNew->m_pNext = pWord->m_pNext;
        }
        pWord->m_pNext = pNew;
        pNew->m_pMergedFrom = NULL;
#ifdef DEBUG
        pNew->m_pMergedTo = NULL;
#endif // DEBUG
        // Initialize the new word node
        pNew->ClearWord();
        pNew->m_pwchText = pWord->m_pwchText + cwchSplitAt;
        pNew->m_cwchText = pWord->m_cwchText - cwchSplitAt;
        if(pNew->m_cwchText == 1) {
            pNew->SetFlag(CWord::WF_CHAR);
        }
        // reset the original word node
        pWord->ClearWord();
        pWord->m_cwchText = cwchSplitAt;
        if(cwchSplitAt == 1) {
            pWord->SetFlag(CWord::WF_CHAR);
        }
    }
    return pWord;   
}

/*============================================================================
CWordLink::MergeWithNext()
    Merge pWord with its next word to a new single word, and chain the old two
    word as the new word's child word
Remarks:
    pWord should not be the last word in the sentence
============================================================================*/
void CWordLink::MergeWithNext(
                     CWord* pWord,
                     BOOL fFree) // TRUE: free the words been merged
                     // FALSE: chain the words been merged as new word's child
{
    assert(m_pwchText);
    assert(pWord);
#ifdef DEBUG
    assert(fInLink(pWord));
#endif // DEBUG 
    assert(pWord->m_pNext);  // catch the last word in the link

    pMerge(pWord, pWord->m_pNext, fFree);
}


/*============================================================================
CWordLink::pLeftMerge()
    Merge pWord and it's left ciWords words, the ciWords+1 words chained to 
    be the new merged word's childs.
Returns:
    pointer to the merged word.
    if there is not enough left word nodes, words are NOT merged
============================================================================*/
CWord* CWordLink::pLeftMerge(
          CWord* pWord, //  merge begin from pWord with left ciWords words
          UINT ciWords, //  0 - don't merge, 1 - merge one time(merge with prev)
                        //  2 - merge two time (contain 3 words)
          BOOL fFree) // TRUE: free the words been merged
                      // FALSE: chain the words been merged as new word's child
{
    assert(pWord);
#ifdef DEBUG
    assert(fInLink(pWord));
#endif 
    if (ciWords == 0) {
        return pWord;
    }
    assert(ciWords > 0);

    CWord* pLeft = pWord;
    CWord* pRight = pWord;
    for(UINT i = 0; i < ciWords; i++) {        
        if((pLeft = pLeft->m_pPrev) == NULL) { // Defensive way!
            assert(0);
            return pWord;
        }
    }
    return pMerge(pLeft, pRight, fFree);
}


/*============================================================================
CWordLink::pRightMerge()
    Merge pWord and it's right ciWords words, the ciWords+1 words chained to 
    be the new merged word's childs.
Returns:
    pointer to the merged word.
    NULL if there is not enough right word nodes, and words are NOT merged
============================================================================*/
CWord* CWordLink::pRightMerge(
          CWord* pWord, //  merge begin from pWord with right ciWords words
          UINT ciWords, //  0 - don't merge, 1 - merge one time(merge with next)
                        //  2 - merge two time (contain 3 words)
          BOOL fFree) // TRUE: free the words been merged
                      // FALSE: chain the words been merged as new word's child
{
    assert(pWord);
#ifdef DEBUG
    assert(fInLink(pWord));
#endif // DEBUG

    if (ciWords == 0) {
        return pWord;
    }
    assert(ciWords > 0);
    CWord* pLeft = pWord;
    CWord* pRight = pWord;
    for(UINT i = 0; i < ciWords; i++) {
        if ((pRight = pRight->m_pNext) == NULL) { // Defensive way!
            assert(0);
            return pWord;
        }
    }
    return pMerge(pLeft, pRight, fFree);
}

/*============================================================================
Implementation of private functions in CWordLink
============================================================================*/

// Merge word nodes from pLeft to pRight
// only called by pLeftMerge() and pRightMerge() and MergeWithNext()
// to do the merge work
CWord* CWordLink::pMerge(CWord* pLeft, CWord* pRight, BOOL fFree)
{
    assert(pLeft);
    assert(pRight);

    CWord* pNew;
    BOOL   fSBCS = (BOOL)(pLeft->fGetFlag(CWord::WF_SBCS));
    USHORT cwchText = pLeft->m_cwchText;

    pNew = pLeft;
    do {
        pNew = pNew->m_pNext;
        assert(pNew != NULL);
        fSBCS = fSBCS && pNew->fGetFlag(CWord::WF_SBCS);
        cwchText += pNew->m_cwchText;
    } while (pNew != pRight);
    // alloc a new word node to save the pLeft and serve as the old pLeft in child
    // the pLeft serve as the merged word.
    pNew = fFree ? NULL : pAllocWord();
    // pNew != NULL
    if (pNew != NULL) {
        assert(fFree == FALSE);
        pNew->CopyWord(pLeft);
#ifdef DEBUG
        if (pLeft->fHasChild()) {
            CWord* pTemp;
            pTemp = pLeft->pChildWord();
            while (pTemp) {
                pTemp->m_pMergedTo = pNew;
                pTemp = pTemp->m_pNext;
            }        
        }
#endif // DEBUG
    } else {
        // pNew == NULL, low-resource of system, force the words been merged be freed.
        fFree = TRUE;
        pNew = pLeft->pNextWord();
    }

    if ( pRight->m_pNext == NULL ) { // tail node
        m_pTail = pLeft;
        pLeft->m_pNext = NULL;
    } else {
        pRight->m_pNext->m_pPrev = pLeft;
        pLeft->m_pNext = pRight->m_pNext;
    }
    pLeft->m_cwchText = cwchText;

    if (fFree) {
        // pNew comes from pLeft->pNextWord() 
        pNew->m_pPrev = NULL;
        pRight->m_pNext = NULL;
        FreeLink(pNew);

        if (pLeft->fHasChild()) {
            pNew = pLeft->pChildWord();
            assert(pNew);
            pLeft->m_pMergedFrom = NULL;
#ifdef DEBUG
            pNew->m_pMergedTo = NULL;
#endif // DEBUG
            FreeLink(pNew);
        }
    } else {
        // link the pNew to pWord chain as the pLeft's child
        pNew->m_pPrev = NULL;
        pNew->m_pNext->m_pPrev = pNew;
        pRight->m_pNext = NULL;
        pLeft->m_pMergedFrom = pNew;
#ifdef DEBUG
        while ( pNew != NULL ) {
            pNew->m_pMergedTo = pLeft;
            pNew = pNew->m_pNext;
        }
        assert(pLeft->pChildWord());
#endif //DEBUG
    }
    // reset the merged node
    pLeft->ClearWord();
    if(fSBCS) {
        pLeft->SetFlag(CWord::WF_SBCS);
    }
    assert(pLeft->fGetFlag(CWord::WF_SBCS) || pLeft->m_cwchText > 1);
    pLeft->SetFlag(CWord::WF_REDUCED); // All merged word node should be reduced
    return pLeft;
}

/*============================================================================
CWordLink::pNewWord()
    Alloc a new word from the free chain, expand the blocks if free chain empty
============================================================================*/
inline CWord* CWordLink::pNewWord()
{
    CWord* pWord;

    if (!m_pFree) {
        CMyPlex* pNewBlock = CMyPlex::Create(m_pWordPool, m_ciBlockSize, 
                                                          sizeof(CWord));
        if (!pNewBlock)
            return NULL;    // can not allocate more memory block

        // chain them into free list
        pWord = (CWord*)pNewBlock->Data();
        // free in reverse order to make it easier to debug 
        pWord += m_ciBlockSize - 1;
        for(int i = (m_ciBlockSize - 1); i >= 0; i--, pWord--) {
            pWord->m_pNext = m_pFree;
            m_pFree = pWord;
        }
    }
    assert(m_pFree != NULL);    // we must have nodes in the free list now!

    pWord = m_pFree;
    m_pFree = m_pFree->m_pNext;

    return pWord;
}

/*============================================================================
CWordLink::FreeLink(void)
    Free word in the link and reset the link (only link words to the free chain)
Remarks:
    This method call FreeLink( CWord *pWord ) recursion to free link and child link
============================================================================*/
void CWordLink::FreeLink(void)
{
#ifdef DEBUG
    assert(!fDetectLeak()); // Assert: no memory leak detected
#endif // DEBUG
    if (m_pwchText) {
        if (m_pHead) { 
            CWord* pTemp = m_pHead;
            m_pwchText = NULL;
            m_pHead = NULL;
            m_pTail = NULL;
            FreeLink(pTemp);
        } else {
            assert(m_pwchText == NULL);
            assert(m_pHead == NULL);
            assert(m_pTail == NULL);
        }
    }
    assert(!m_pHead);
}

/*============================================================================
Implementation of private debugging functions
============================================================================*/
#ifdef  DEBUG

/*============================================================================
CWordLink::fInLink()
    Debugging function to check whether a word pointer is in the link.
    Not check whether the pointer is in child chain.
============================================================================*/
BOOL CWordLink::fInLink(CWord* pWord)
{
    CWord* pcw = m_pHead;
    while (pcw) {
        if (pcw == pWord)
            return TRUE;
        pcw = pcw->m_pNext;
    }
    return FALSE;
}

/*============================================================================
CWordLink::fInChild()
    Debugging function to check whether a word pointer is in one of the 
    child chains.
============================================================================*/
inline BOOL CWordLink::fInChild(CWord* pWord)
{
    CWord* pcw = m_pHead;
    while (pcw) {
        if (pcw->m_pMergedFrom != NULL && fInChildOf(pWord, pcw)) {
            return TRUE;
        }
        pcw = pcw->pNextWord();
    }
    return FALSE;
}

/*============================================================================
CWordLink::fInChildOf()
    Debugging function to check whether a word pointer is in the child chain 
    of the pParent.
============================================================================*/
BOOL CWordLink::fInChildOf(CWord* pWord, CWord* pParent)
{
    CWord* pcw = pParent->pChildWord();
    while (pcw) {
        if (pcw == pWord) {
            return TRUE;
        } else if (pcw->m_pMergedFrom != NULL && fInChildOf(pWord, pcw)) {
            return TRUE;
        } else {
        }
        pcw = pcw->m_pNext;
    }
    return FALSE;
}

/*============================================================================
CWordLink::fInBlocks()
    Debugging function to check whether the pWord is in CMyPlex blocks
============================================================================*/
BOOL CWordLink::fInBlocks(CWord* pWord)
{
    CWord* pFirstWord;
    CMyPlex* pBlock = m_pWordPool;
    while(pBlock) {
        pFirstWord = (CWord*)(pBlock->Data());
        if(pWord >= pFirstWord && pWord < (pFirstWord + m_ciBlockSize)) {
            return TRUE;
        }
        pBlock = pBlock->m_pNext;
    }
    return FALSE;
}

/*============================================================================
CWordLink::fInFree()
    Debugging function to check whether the pWord is in free links
============================================================================*/
BOOL CWordLink::fInFree(CWord* pWord)
{
    CWord* pcw = m_pFree;
    while (pcw) {
        if (pcw == pWord) {
            return TRUE;
        }
        pcw = pcw->m_pNext;
    }
    return FALSE;
}

/*============================================================================
CWordLink::SetDetectFlag
    Debugging function to set the word node leak flg used by fDetectLeak()
============================================================================*/
void CWordLink::SetDetectFlag(CWord* pWord)
{
    CWord* pcw = pWord;
    while (pcw) {
        if (pcw->m_pMergedFrom != NULL) {
            SetDetectFlag( pcw->m_pMergedFrom );
        }
        pcw->SetFlag(CWord::WF_DEBUG);
        pcw = pcw->m_pNext;
    }
    return;
}

/*============================================================================
CWordLink::fDetectLeak()
    Debugging function to check whether there are some word node leak to
    out of the link and the free chain
Returns:
    TRUE if any leak is detected, 
    FALSE if no leak detected
Remarks: 
    I hire the most significant bit in CWord::m_bFlag as the debugging use
============================================================================*/
BOOL CWordLink::fDetectLeak(void)
{
    CWord* pWord;
    CMyPlex* pBlock;
    UINT i;

    // clear flag bit for all words in all blocks
    for(pBlock = m_pWordPool; pBlock; pBlock = pBlock->m_pNext) {
        for(i = 0, pWord = (CWord*)(pBlock->Data()); 
                                  i < m_ciBlockSize; i++, pWord++) {
            pWord->ClearFlag(CWord::WF_DEBUG);
        }
    }

    // mark the flag bit for words in current link and in the free chain
    SetDetectFlag( m_pHead );
    for(pWord = m_pFree; pWord; pWord = pWord->m_pNext) {
        pWord->SetFlag(CWord::WF_DEBUG);
    }

    // Check whether there are any leak words
    for(pBlock = m_pWordPool; pBlock; pBlock = pBlock->m_pNext) {
        for(i = 0, pWord = (CWord*)(pBlock->Data()); i < m_ciBlockSize; i++, pWord++) {
            if(!pWord->fGetFlag(CWord::WF_DEBUG)) {
                return TRUE;
            }
        }
    }

    return FALSE;
}


#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\baselex.h ===
#ifdef _BASE_LEX_
#else
#define _BASE_LEX_

#define ATTR_DM             0x01
#define ATTR_COMPOUND       0x02
#define ATTR_RULE_WORD      0x04
#define ATTR_EUDP_WORD      0x08
#define ATTR_ERROR_WORD     0x10

#define MAX_CHAR_PER_WORD   10

#define CHT_UNICODE_BEGIN   0x4E00
#define CHT_UNICODE_END     0x9FA5

#define MAX_CHAR_PER_WORD    10

#define APLEXICON_COUNT       1000

typedef struct tagSLexHeader {
    DWORD dwMaxCharPerWord;
    DWORD dwWordNumber[MAX_CHAR_PER_WORD];
} SLexHeader, *PSLexHeader;

class CBaseLex {
public:
    virtual BOOL GetWordInfo(LPCWSTR lpcwString, DWORD dwLength,
        PWORD pwAttrib) = 0;
};
typedef CBaseLex* PCBaseLex; 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\wrdbreak.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Module:     WordBreak
Purpose:    Declare the CWordBreak class. This class is in Algorithm Layer.
            Perform the max-match word segmentation, and ambiguous resolution
            Both Chinese string and ANSI string will be broken into words
            WordBreaker also take sentence breaking function, and return the length
            processed through reference
Notes:      Both WordLink, Lexicon and CharFreq will be used
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    5/29/97
============================================================================*/
#ifndef _WRDBREAK_H_
#define _WRDBREAK_H_

#include "wordlink.h"
// Max count of nested ambiguous can be processed
#define MAX_AMBI_WORDS      20

// Foreward declarations
class   CLexicon;
class   CCharFreq;
class   CWordLink;
struct  CWord;
struct  CWordInfo;

/*============================================================================
Class:  CWordBreak:
Desc:   Declare the CWordBreak class
Prefix: 
============================================================================*/
class CWordBreak
{
    public:
        // Constructor
        CWordBreak();
        // Destructor
        ~CWordBreak();

        /*============================================================================
        *   fInit: initialize the WordBreaker and set the object handles
        *   It's valid to initialize the WordBreaker more than once!
        *   Return PRFEC
        ============================================================================*/
        int ecInit(CLexicon* pLexicon, CCharFreq* pFreq);

        /*============================================================================
        ecBreakSentence: break sentence into word and add the words to WordLink
        ============================================================================*/
        inline int CWordBreak::ecBreakSentence(CWordLink* pLink)   // WordLink to be broken
        {                       
            assert(pLink && m_pLexicon && m_pFreq);
            assert(pLink->pwchGetText() != NULL);
            assert(pLink->cwchGetLength() > 0);
            
            m_pLink = pLink;
            m_fSentence = FALSE;    // whether the input buffer contain a intact sentence
            return ecDoBreak();
        }
        
    private:
        CLexicon*   m_pLexicon;
        CCharFreq*  m_pFreq;

        CWordInfo*  m_pwinfo;
        CWordLink*  m_pLink;        // Contain pointer and length of the text buffer
        BOOL        m_fSentence;    // set TRUE if ant sentence terminator found
        CWord*      m_rgAmbi[MAX_AMBI_WORDS]; // store ambiguious words
                
    private:
        CWordBreak(CWordBreak&) { };

    private:


        //  Break ANSI into words, and add words to the WordLink
        int ecBreakANSI(LPCWSTR pwchAnsi, USHORT cwchLen, USHORT& cwchBreaked);

        //  Break European chars into words, and add words to the WordLink
        int ecBreakEuro(LPCWSTR pwchEuro, USHORT cwchLen, USHORT& cwchBreaked);

        //  Break Chinese section into words, and add words to the WordLink
        //  Call ambiguity function to resolve ambiguities
        int ecDoBreak();

        /*============================================================================
        *   Single char cross ambiguity resolution function
        *   Ambiguious word pointers stored in m_rgpWord, m_pLink is the owner of these words
        *   Elements of m_rgpWord contain word pointer which have been add the the WordLink
        *   will be set to NULL, the other word nodes should be freed by the caller
        *   This function return PRFEC error code, because it probably be interrupt by
        *   the user when running in background mode
        *   Note: the whole ambiguious string must be processed by this function
        ============================================================================*/
        int ecResolveAmbi(USHORT ciAmbi);

        /*============================================================================
        *   Check whether the word can participate ambiguity detection
        *   Return TRUE if it can not. and return FALSE for normal word
        ============================================================================*/
        BOOL fNoAmbiWord(CWord* pWord);

        /*============================================================================
        *   Link specific Ambi word in m_rgAmbi[]
        ============================================================================*/
        void LinkAmbiWord(USHORT iAmbi);    // index of Ambi word in m_rgAmbi[]

        /*============================================================================
        *   Link a new word to the WordLink, and mark it as WF_AMBI
        ============================================================================*/
        BOOL fLinkNewAmbiWord(LPCWSTR pwchWord, USHORT cwchLen, CWordInfo* pwinfo);
};

#endif  // _WBREAK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\defbrkr.h ===
#ifndef __DEFAULT_WORD_BREAKER_H_
#define __DEFAULT_WORD_BREAKER_H_

class CDefWordBreaker {
public:
    CDefWordBreaker();
    ~CDefWordBreaker() {};
    SCODE BreakText(TEXT_SOURCE *pTextSource, IWordSink *pWordSink, IPhraseSink *pPhraseSink, DWORD dwBase); 
private:    
    BOOL IsWordChar(int nIndex, PWORD _aCharInfo1, PWORD _aCharInfo3, const WCHAR* pwcChunk) const;
    BOOL ScanChunk(PWORD _aCharInfo1, PWORD _aCharInfo3, const WORD* pwcChunk, ULONG ucwc);
    void Tokenize(TEXT_SOURCE *pTextSource, ULONG cwc, IWordSink *pWordSink, ULONG& cwcProcd, PWORD _aCharInfo1, PWORD _aCharInfo3, DWORD dwBase);
private:
    WORD ccCompare; 
};

#else 

#endif // __DEFAULT_WORD_BREAKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\chtbrkr.h ===
#ifndef _CHT_WORD_BREAKER_H__
#define _CHT_WORD_BREAKER_H__

#define BUFFER_GROW_UINT      30
#define LATTICE_LENGHT        50 
#define LOCAL_LENGTH           3

class CBaseLex;

typedef struct tagSLatticeNode {
    WORD   wCount;
    WORD   wAttr;
    BYTE   bTerminalCode;
    UINT   uLen;
    double fVariance;
    DWORD  dwUniCount; 
} SLatticeNode, *PSLatticeNode, **PPSLatticeNode;

typedef struct tagSLocalPath {
    DWORD  dwLength[LOCAL_LENGTH];
    WORD   wUnicount[LOCAL_LENGTH];
    WORD   wAttribute[LOCAL_LENGTH];
    BYTE   bTerminalCode[LOCAL_LENGTH];
    // for rule 1 - 5
    UINT   uPathLength;
    double fVariance;
    UINT   uCompoundNum;
    UINT   uDMNum;
    WORD   wUniCountSum;
    UINT   uStep;
}SLocalPath, *PSLocalPath;

typedef struct tagBreakResult{
    DWORD dwWordNumber;
    PUINT puWordLen;
    PUINT puWordAttrib;
    PBYTE pbTerminalCode;
} SBreakResult, *PSBreakResult;

class CCHTWordBreaker {
public:
    CCHTWordBreaker();
    ~CCHTWordBreaker();

public:
    BOOL  InitData(HINSTANCE hInstance);
    DWORD BreakText(LPCWSTR lpcwszText, INT nTextLen, CBaseLex* pcBaseLex = NULL, DWORD dwMaxWordLen = MAX_CHAR_PER_WORD,
        BOOL fBreakWithParser = TRUE);
    DWORD GetBreakResult(PUINT* ppuResult) {
        *ppuResult = m_psBreakResult->puWordLen;
        return m_psBreakResult->dwWordNumber;
    }
    DWORD GetBreakResultWithAttribute(PUINT* ppuResult, PUINT* ppuAttrib) {
        *ppuAttrib = m_psBreakResult->puWordAttrib;
        return GetBreakResult(ppuResult);
    }
    BOOL  AddSpecialWord(LPCWSTR lpcwEUDPStr, WORD wAttrib) {
        return m_pcLexicon->AddInLexiconInsert(lpcwEUDPStr, wAttrib);    
    }
    DWORD GetAltWord(LPCWSTR lpcwString, DWORD dwLength, LPWSTR* lppwAltWordBuf) {
        return m_pcLexicon->GetAltWord(lpcwString, dwLength, lppwAltWordBuf);
    }
private:
    BOOL AllocLattice(DWORD dwLength);
    void DestroyLattice(void);
    BOOL LatticeGrow(DWORD dwNewLength);

private:
    BOOL  BuildLattice(LPCWSTR lpcwszText, DWORD dwTextLen, CBaseLex *pcBaseLex, DWORD dwWordLen);
    DWORD GetResult();
    void  GetScore(PSLocalPath psLocalPath);
    INT   CompareScore(PSLocalPath psLocalPath1, PSLocalPath psLocalPath);
//  DWORD LongestRuleWord(DWORD dwIndex); 
private:
    PCCHTLexicon   m_pcLexicon;
    PPSLatticeNode m_ppWordLattice;
    PDWORD         m_pdwCandidateNumber;
    DWORD          m_dwSentenceLength;
    DWORD          m_dwLatticeLength;
    PDWORD         m_pdwMaxWordLength;
    PSBreakResult  m_psBreakResult;
    PCRuleLexicon  m_pcRuleLex;
};
typedef CCHTWordBreaker *PCCHTWordBreaker;

#endif //_CHT_WORD_BREAKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\defbrkr.cpp ===
#include <windows.h>
#include "IWBrKr.h"
#include "DefBrKr.h"

#define ZERO_WIDTH_SPACE   0x200B
#define MAX_Def_WordBrKr_Prcess_Len   1000

BOOL IsWinNT(void)
{
    OSVERSIONINFOA  osVersionInfo;
    BOOL fRet = FALSE;
    
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    GetVersionExA(&osVersionInfo);
    if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        fRet = TRUE; 
    }
    return fRet;
}

BOOL MyGetStringTypeEx(
    LCID   LocalID,
    DWORD  dwInfoType,
    const WCHAR *lpSrcStr,   // unicode base
    INT    cchSrc,
    LPWORD lpCharType)
{
    BOOL fRet = FALSE;

    if (IsWinNT()) {
        fRet = GetStringTypeW(dwInfoType, lpSrcStr, cchSrc,lpCharType);
    } else {
        DWORD dwANSISize = 0;
        dwANSISize = WideCharToMultiByte(GetACP(), WC_COMPOSITECHECK, lpSrcStr, cchSrc,
            NULL, 0, NULL, NULL);
        if (dwANSISize) {
            LPSTR lpAnsiStr = NULL;
            lpAnsiStr = new CHAR[dwANSISize];
            if (lpAnsiStr) {
                dwANSISize = WideCharToMultiByte(GetACP(), WC_COMPOSITECHECK, lpSrcStr, cchSrc,
                    lpAnsiStr, dwANSISize, NULL, NULL);
                fRet = GetStringTypeExA(LocalID, dwInfoType, lpAnsiStr, dwANSISize, lpCharType);
                if (ERROR_INVALID_PARAMETER == GetLastError() && (CT_CTYPE1 == dwInfoType || CT_CTYPE3 == dwInfoType)) {
                    for (INT i = 0; i < cchSrc; ++i) {
                        switch (dwInfoType) {
                        case CT_CTYPE1:
                            lpCharType[i] = C1_ALPHA;
                            break;
                        case CT_CTYPE3:
                            lpCharType[i] = (C3_NONSPACING | C3_ALPHA);
                            break;
                        }
                    }
                    fRet = TRUE;
                }
                delete [] lpAnsiStr;
                lpAnsiStr = NULL;
            }
        }
    }
    return fRet;
}


CDefWordBreaker::CDefWordBreaker()
{
    ccCompare = MAX_Def_WordBrKr_Prcess_Len;
}
//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreaker::IsWordChar
//
//  Synopsis:   Find whether the i'th character in the buffer _awString
//              is a word character (rather than word break)
//
//  Arguments:  [i] -- index into _awString
//
//  History:    22-Jul-1994  BartoszM       Created
//
//--------------------------------------------------------------------------

inline BOOL CDefWordBreaker::IsWordChar(
    int i,
    PWORD _aCharInfo1,
    PWORD _aCharInfo3,
    const WCHAR* pwcChunk) const
{
    if ( (_aCharInfo1[i] & (C1_ALPHA | C1_DIGIT))
        || (_aCharInfo3[i] & C3_NONSPACING)  )
    {
        return TRUE;
    }

    WCHAR c = pwcChunk[i];

    if (c == L'_')
        return TRUE;

    if (c == 0xa0) // non breaking space
    {
        // followed by a non-spacing character
        // (looking ahead is okay)
        if (_aCharInfo3[i+1] & C3_NONSPACING)
            return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefWordBreaker::ScanChunk
//
//  Synopsis:   For each character find its type
//
//
//  History:    16-Aug-94  BartoszM     Created
//
//----------------------------------------------------------------------------
BOOL CDefWordBreaker::ScanChunk(
    PWORD _aCharInfo1, 
    PWORD _aCharInfo3,
    const WCHAR *pwcChunk,
    ULONG ucwc)
{
    BOOL fRet = FALSE;

    // POSIX character typing, Source, Size of source, Character info
    if (!MyGetStringTypeEx(GetSystemDefaultLCID(), CT_CTYPE1, pwcChunk, ucwc, _aCharInfo1)) { 
     // Additional POSIX, Source, Size of source, Character info 3
    } else if (!MyGetStringTypeEx(GetSystemDefaultLCID(), CT_CTYPE3, pwcChunk, ucwc, _aCharInfo3)) {         // 
    } else {
        fRet = TRUE;
    }
    return fRet;
}

/*
BOOL CDefWordBreaker::ScanChunk(
    PWORD _aCharInfo1, 
    PWORD _aCharInfo3,
    const WCHAR *pwcChunk,
    ULONG ucwc)
{

    //
    // GetStringTypeW is returning error 87 (ERROR_INVALID_PARAMETER) if
    // we pass in a null string.
    //
//  Win4Assert( (0 != _cMapped) && (0 != _pwcChunk) );

    if (IsWinNT())
    {
        if (!MyGetStringTypeEx(0,                     // Dummy
                              CT_CTYPE1,              // POSIX character typing
                              pwcChunk,               // Source
                              ucwc,                   // Size of source
                              _aCharInfo1 ) )         // Character info
        {
            return FALSE;
        }

        if ( !MyGetStringTypeEx(0,                    // Dummy
                              CT_CTYPE3,              // Additional POSIX
                              pwcChunk,               // Source
                              ucwc,                   // Size of source
                              _aCharInfo3 ) )         // Character info 3
        {
            return FALSE;
        }
    }
    else
    {
        //
        // BUGBUG: This is all wrong -- we don't know if this is the right
        //         locale to use and there isn't a way to know at this point.
        //

        if (!MyGetStringTypeEx( GetSystemDefaultLCID(),
                                CT_CTYPE1,              // POSIX character typing
                                pwcChunk,               // Source
                                ucwc,                   // Size of source
                                _aCharInfo1 ) )         // Character info
        {
//           ciDebugOut(( DEB_ERROR, "GetStringTypeW returned %d\n",
//                         GetLastError() ));

            // Win9x just stinks.  No 2 ways about it.

            if ( ERROR_INVALID_PARAMETER == GetLastError() )
            {
                for ( unsigned i = 0; i < ucwc; i++ )
                    _aCharInfo1[i] = C1_ALPHA;

                return TRUE;
            }

            return FALSE;
        }

        if ( !MyGetStringTypeEx(GetSystemDefaultLCID(),
                                CT_CTYPE3,              // Additional POSIX
                                pwcChunk,               // Source
                                ucwc,                   // Size of source
                                _aCharInfo3 ) )         // Character info 3
        {
//            ciDebugOut(( DEB_ERROR, "GetStringTypeW CTYPE3 returned %d\n",
 //                        GetLastError() ));

            // Win9x just stinks.  No 2 ways about it.

            if ( ERROR_INVALID_PARAMETER == GetLastError() )
            {
                for ( unsigned i = 0; i < ucwc; i++ )
                    _aCharInfo3[i] = ( C3_NONSPACING | C3_ALPHA );

                return TRUE;
            }

            return FALSE;
        }
    }

    return TRUE;
} //ScanChunk
*/
//+---------------------------------------------------------------------------
//
//  Member:     CDefWordBreaker::BreakText
//
//  Synopsis:   Break input stream into words.
//
//  Arguments:  [pTextSource] - source of input buffers
//              [pWordSink] - sink for words
//              [pPhraseSink] - sink for noun phrases
//
//  History:    07-June-91  t-WadeR     Created
//              12-Oct-92   AmyA        Added Unicode support
//              18-Nov-92   AmyA        Overloaded
//              11-Apr-94   KyleP       Sync with spec
//              26-Aug-94   BartoszM    Fixed Unicode parsing
//
//----------------------------------------------------------------------------

SCODE CDefWordBreaker::BreakText(
    TEXT_SOURCE *pTextSource,
    IWordSink   *pWordSink,
    IPhraseSink *pPhraseSink,
    DWORD       dwBase)
{
    LPWORD _aCharInfo1 = NULL;
    LPWORD _aCharInfo3 = NULL;

    if ( 0 == pTextSource )
        return E_INVALIDARG;

    if ( 0 == pWordSink || pTextSource->iCur == pTextSource->iEnd)
        return S_OK;

    if (pTextSource->iCur > pTextSource->iEnd)
    {
//        Win4Assert ( !"BreakText called with bad TEXT_SOURCE" );
        return E_FAIL;
    }

    SCODE sc = S_OK;

    ULONG cwc, cwcProcd;     // cwcProcd is # chars actually processed by Tokenize()

    cwc = 0;
    cwcProcd = 0;
    do {
      //
      // Flag for first time thru loop below. This is to fix the case
      // where the length of the buffer passed in is less than
      // MAX_II_BUFFER_LEN. In this case iEnd-iCur is <= MAX_II_BUFFER_LEN
      // and we break out the inner loop and call
      // pfnFillTextBuffer without having processed any characters,
      // and so pfnFillTextBuffer returns TRUE without adding any new
      // characters and this results in an infinite loop.
        BOOL fFirstTime = TRUE;
        while (pTextSource->iCur < pTextSource->iEnd) {
            cwc = pTextSource->iEnd - pTextSource->iCur;
            // Process in buckets of MAX_II_BUFER_LEN only
            if (cwc >= CDefWordBreaker::ccCompare) {
                cwc = CDefWordBreaker::ccCompare;
            } else if ( !fFirstTime) {
                break;
            } else {
            }

            if (_aCharInfo1) {
                delete [] _aCharInfo1;
                _aCharInfo1 = NULL;
            }
            if (_aCharInfo3) {
                delete [] _aCharInfo3;
                _aCharInfo3 = NULL;
            }
            _aCharInfo1 = new WORD[cwc + 1];
            _aCharInfo3 = new WORD[cwc + 1];
            if (_aCharInfo1 && _aCharInfo3) {
                Tokenize( pTextSource, cwc, pWordSink, cwcProcd, _aCharInfo1, _aCharInfo3, dwBase);
            }

//          Win4Assert( cwcProcd <= cwc );
            pTextSource->iCur += cwcProcd;
            fFirstTime = FALSE;
        }
    } while(SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)));

    cwc = pTextSource->iEnd - pTextSource->iCur;
    // we know that the remaining text should be less than ccCompare

    // Win4Assert( cwc < CDefWordBreaker::ccCompare );

    if (0 != cwc) {
        if (_aCharInfo1) {
            delete [] _aCharInfo1;
            _aCharInfo1 = NULL;
        }
        if (_aCharInfo3) {
            delete [] _aCharInfo3;
            _aCharInfo3 = NULL;
        }
        _aCharInfo1 = new WORD[cwc + 1];
        _aCharInfo3 = new WORD[cwc + 1];
        if (_aCharInfo1 && _aCharInfo1) {
            Tokenize(pTextSource, cwc, pWordSink, cwcProcd, _aCharInfo1, _aCharInfo3, dwBase);
        }
    }

    if (_aCharInfo1) {
        delete [] _aCharInfo1;
        _aCharInfo1 = NULL;
    }
    if (_aCharInfo3) {
        delete [] _aCharInfo3;
         _aCharInfo3 = NULL;
    }

    return sc;
} //BreakText

//+---------------------------------------------------------------------------
//
//  Member:     CDefWordBreaker::Tokenize
//
//  Synopsis:   Tokenize the input buffer into words
//
//  Arguments:  [pTextSource]  --  input text source
//              [cwc]          --  # chars to process
//              [pWordSink]    --  sink for words
//              [cwcProd]      --  # chars actually processed returned here
//
//  History:    10-Aug-95   SitaramR    Created
//
//----------------------------------------------------------------------------

void CDefWordBreaker::Tokenize( TEXT_SOURCE *pTextSource,
                                ULONG cwc,
                                IWordSink *pWordSink,
                                ULONG& cwcProcd,
                                PWORD _aCharInfo1,
                                PWORD _aCharInfo3,
                                DWORD dwBase)
{
    const WCHAR* pwcChunk = NULL;
    WCHAR        _awcBufZWS[MAX_Def_WordBrKr_Prcess_Len];

    pwcChunk = &pTextSource->awcBuffer[pTextSource->iCur];

    if (!ScanChunk(_aCharInfo1, _aCharInfo3, pwcChunk, cwc)) {
        return;
    }

    BOOL fWordHasZWS = FALSE;     // Does the current word have a zero-width-space ?
    unsigned uLenZWS;             // Length of a word minus embedded zero-width-spaces

    //
    // iBeginWord is the offset into _aCharInfo of the beginning character of
    // a word.  iCur is the first *unprocessed* character.
    // They are indexes into the mapped chunk.
    //

    unsigned iBeginWord = 0;
    unsigned iCur = 0;

    //
    // Pump words from mapped chunk to word sink
    //
    while (iCur < cwc)
    {
        //
        // Skip whitespace, punctuation, etc.
        //
        for (; iCur < cwc; iCur++)
            if (IsWordChar (iCur, _aCharInfo1, _aCharInfo3, pwcChunk))
                break;

        // iCur points to a word char or is equal to _cMapped

        iBeginWord = iCur;
        if (iCur < cwc)
            iCur++; // we knew it pointed at word character

        //
        // Find word break. Filter may output Unicode zero-width-space, which
        // should be ignored by the wordbreaker.
        //
        fWordHasZWS = FALSE;
        for (; iCur < cwc; iCur++)
        {
            if (!IsWordChar(iCur, _aCharInfo1, _aCharInfo3, pwcChunk))
            {
                if (pwcChunk[iCur] == ZERO_WIDTH_SPACE )
                    fWordHasZWS = TRUE;
                else
                    break;
            }
        }

        if (fWordHasZWS)
        {
            //
            // Copy word into _awcBufZWS after stripping zero-width-spaces
            //

            uLenZWS = 0;
            for ( unsigned i=iBeginWord; i<iCur; i++ )
            {
                if (pwcChunk[i] != ZERO_WIDTH_SPACE )
                    _awcBufZWS[uLenZWS++] = pwcChunk[i];
            }
        }

        // iCur points to a non-word char or is equal to _cMapped

        if (iCur < cwc)
        {
            // store the word and its source position
            if ( fWordHasZWS )
                pWordSink->PutWord( uLenZWS, _awcBufZWS,                       // stripped word
                                    iCur - iBeginWord, pTextSource->iCur + iBeginWord + dwBase);
            else
                pWordSink->PutWord( iCur - iBeginWord, pwcChunk + iBeginWord, // the word
                                    iCur - iBeginWord, pTextSource->iCur + iBeginWord + dwBase);

            iCur++; // we knew it pointed at non-word char
            iBeginWord = iCur; // in case we exit the loop now
        }

    } // next word

//    Win4Assert( iCur == _cMapped );
    // End of words in chunk.
    // iCur == _cMapped
    // iBeginWord points at beginning of word or == _cMapped

    if ( 0 == iBeginWord )
    {
        // A single word fills from beginning of this chunk
        // to the end. This is either a very long word or
        // a short word in a leftover buffer.

        // store the word and its source position
        if ( fWordHasZWS )
            pWordSink->PutWord( uLenZWS, _awcBufZWS,       // stripped word
                                iCur, pTextSource->iCur + dwBase); // its source pos.
        else
            pWordSink->PutWord( iCur, pwcChunk,           // the word
                                iCur, pTextSource->iCur + dwBase); // its source pos.

        //
        // Position it to not add the word twice.
        //
        iBeginWord = iCur;
    }

    //
    // If this is the last chunk from text source, then process the
    // last fragment
    //

    if ( cwc < CDefWordBreaker::ccCompare && iBeginWord != iCur )
    {
        // store the word and its source position
        if ( fWordHasZWS )
            pWordSink->PutWord( uLenZWS, _awcBufZWS,                        // stripped word
                                iCur - iBeginWord, pTextSource->iCur + iBeginWord + dwBase);
        else
            pWordSink->PutWord( iCur - iBeginWord, pwcChunk + iBeginWord,  // the word
                                iCur - iBeginWord, pTextSource->iCur + iBeginWord + dwBase);

        iBeginWord = iCur;
    }

    cwcProcd = iBeginWord;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\lexicon.h ===
#ifndef __CHTLEXICON_H_
#define __CHTLEXICON_H_

// Use one BYTE, return WORD to AP
// AP can use high BYTE as a private data
#define ATTR_DM             0x01
#define ATTR_COMPOUND       0x02
#define ATTR_RULE_WORD      0x04
#define ATTR_EUDP_WORD      0x08


#define MAX_CHAR_PER_WORD   10

#define CHT_UNICODE_BEGIN   0x4E00
#define CHT_UNICODE_END     0x9FA5

typedef struct tagSLexInfo {
    DWORD dwWordNumber;
    DWORD dwWordStringOffset;
    DWORD dwWordCountOffset;
    DWORD dwWordAttribOffset;
    DWORD dwTerminalCodeOffset;
} SLexInfo, *PSLexInfo;

typedef struct tagLexFileHeader {
    DWORD     dwMaxCharPerWord;
    SLexInfo  sLexInfo[MAX_CHAR_PER_WORD];     
} SLexFileHeader, *PSLexFileHeader;

typedef struct tagSAltLexInfo {
    DWORD dwWordNumber;
    DWORD dwWordStringOffset;
    DWORD dwWordGroupOffset;
} SAltLexInfo, *PSAltLexInfo;

typedef struct tagAltLexFileHeader {
    DWORD       dwMaxCharPerWord;
    SAltLexInfo sAltWordInfo[MAX_CHAR_PER_WORD];     
} SAltLexFileHeader, *PSAltLexFileHeader;
#else

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\chtbrkr.cpp ===
#include <windows.h>
#include "lexicon.h"
#include "rulelex.h"
#include "LexMgr.h"
#include "CHTBrKr.h"
#include "BaseLex.h"


CCHTWordBreaker::CCHTWordBreaker(void)
{
    m_pcLexicon = NULL;
    m_ppWordLattice = NULL;
    m_pdwCandidateNumber = NULL;
    m_dwSentenceLength = 0;
    m_dwLatticeLength = 0;
    m_pdwMaxWordLength = NULL;
    m_psBreakResult = NULL;
	m_pcRuleLex = NULL;
}
    
CCHTWordBreaker::~CCHTWordBreaker(void)
{
    DWORD i;

    if (m_pcLexicon) {
        delete m_pcLexicon;
        m_pcLexicon = NULL;
    }
    if (m_ppWordLattice) {
        for (i = 0; i < m_dwSentenceLength; ++i) {
            if (m_ppWordLattice[i]) {
                delete m_ppWordLattice[i];
            }
        }
        delete m_ppWordLattice;
        m_ppWordLattice = NULL;
    }
    if (m_pdwCandidateNumber) {
        delete m_pdwCandidateNumber;
        m_pdwCandidateNumber = NULL;
    }
    if (m_pdwMaxWordLength) {
        delete m_pdwMaxWordLength;
        m_pdwMaxWordLength = NULL;
    }
    if (m_psBreakResult) {
        if (m_psBreakResult->puWordLen) {
            delete m_psBreakResult->puWordLen;
        }
        if (m_psBreakResult->pbTerminalCode) {
            delete m_psBreakResult->pbTerminalCode;
        }
        if (m_psBreakResult->puWordAttrib) {
            delete m_psBreakResult->puWordAttrib;
        }
    }
    m_dwSentenceLength = 0;
    m_dwLatticeLength = 0;
}

BOOL CCHTWordBreaker::AllocLattice(
    DWORD dwLength)
{
    BOOL fRet = FALSE;
    DWORD i;

    m_pdwMaxWordLength= new DWORD[dwLength];
    if (!m_pdwMaxWordLength) { goto _exit; }

    m_pdwCandidateNumber = new DWORD[dwLength];
    if (!m_pdwCandidateNumber) { goto _exit; }
     
    m_ppWordLattice = new PSLatticeNode[dwLength];
    if (!m_ppWordLattice) { goto _exit; }
    for (i = 0; i < dwLength; ++i) {
        m_ppWordLattice[i] = NULL;
    }
    for (i = 0; i < dwLength; ++i) {
        m_ppWordLattice[i] = new SLatticeNode[MAX_CHAR_PER_WORD];
        if (!m_ppWordLattice[i]) { goto _exit; }
        m_dwLatticeLength = i + 1; // for DestroyLattice()
        m_pdwCandidateNumber[i] = 0;
    }
    m_dwLatticeLength = dwLength;
    fRet = TRUE;
_exit:
    if (!fRet) {
        DestroyLattice();
    }        
    return fRet;
}

void CCHTWordBreaker::DestroyLattice()
{
    DWORD i;

    if (m_pdwCandidateNumber) {
        delete m_pdwCandidateNumber;
        m_pdwCandidateNumber = NULL;
    }
    if (m_pdwMaxWordLength) {
        delete m_pdwMaxWordLength; 
        m_pdwMaxWordLength = NULL;
    }
    if (m_ppWordLattice) {
        for (i = 0; i < m_dwLatticeLength; ++i) {
            if (m_ppWordLattice[i]) {
                delete m_ppWordLattice[i];
            } 
        }
        if (m_ppWordLattice) {
            delete [] m_ppWordLattice;
            m_ppWordLattice = NULL;
        }
        m_dwLatticeLength = 0;
    }
}


BOOL CCHTWordBreaker::InitData(
    HINSTANCE hInstance) 
{
    BOOL fRet = FALSE;

    m_pcLexicon = new CCHTLexicon;
    if (!m_pcLexicon) { goto _exit; }
    fRet = m_pcLexicon->InitData(hInstance);
    if (!fRet) { goto _exit; }

    m_pcRuleLex = new CRuleLexicon;
    if (!m_pcRuleLex)  { goto _exit; }

    m_psBreakResult = new SBreakResult;
    if (!m_psBreakResult) { goto _exit; }
	FillMemory(m_psBreakResult, sizeof(SBreakResult), 0);
    m_psBreakResult->puWordLen = new UINT[LATTICE_LENGHT];
    m_psBreakResult->pbTerminalCode = new BYTE[LATTICE_LENGHT];
    m_psBreakResult->puWordAttrib = new UINT[LATTICE_LENGHT];
    if (!AllocLattice(LATTICE_LENGHT)) { goto _exit; }  
    fRet = TRUE;
_exit:
    if (!fRet) {
        if (m_pcLexicon) { 
            delete m_pcLexicon;
            m_pcLexicon = NULL;
        }
        if (m_pcRuleLex) {
            delete m_pcRuleLex;
            m_pcRuleLex = NULL;
        }
        if (m_psBreakResult) {
            if (m_psBreakResult->puWordLen) {
                delete m_psBreakResult->puWordLen;
            }
            if (m_psBreakResult->pbTerminalCode) {
                delete m_psBreakResult->pbTerminalCode;
            }
            if (m_psBreakResult->puWordAttrib) {
                delete m_psBreakResult->puWordAttrib;
            }
            m_psBreakResult = NULL;  
        }
        DestroyLattice();
    }
    return fRet;
}

BOOL CCHTWordBreaker::LatticeGrow(
    DWORD dwNewLength)
{
    BOOL fRet = FALSE;

    if (dwNewLength <= m_dwLatticeLength) { 
        fRet = TRUE;
        goto _exit;
    }
    DestroyLattice();
    if (AllocLattice(dwNewLength)) {
        fRet = TRUE;
    } else {
        AllocLattice(LATTICE_LENGHT);
    }
    if (m_psBreakResult) {
        if (m_psBreakResult->puWordLen) {
            delete m_psBreakResult->puWordLen;
        }
        if (m_psBreakResult->pbTerminalCode) {
            delete m_psBreakResult->pbTerminalCode;
        }
        if (m_psBreakResult->puWordAttrib) {
            delete m_psBreakResult->puWordAttrib;
        }
        m_psBreakResult->puWordLen = new UINT[dwNewLength];
        m_psBreakResult->pbTerminalCode = new BYTE[dwNewLength];
        m_psBreakResult->puWordAttrib  = new UINT[dwNewLength];
    }

_exit:
    return fRet;
}

DWORD CCHTWordBreaker::BreakText(
    LPCWSTR   lpcwszText,
    INT       nTextLen,
    CBaseLex* pcBaseLex,
    DWORD     dwMaxWordLen,
    BOOL      fBreakWithParser)
{
    m_psBreakResult->dwWordNumber = 0;

    if (!LatticeGrow(nTextLen)) { goto _exit; }

    if (BuildLattice(lpcwszText, nTextLen, pcBaseLex, dwMaxWordLen)) {
        GetResult();
        // process Surrogate Char begin
/*
	    INT nCurrentIndex;
        DWORD dwSurIndex;
        nCurrentIndex = 0;
        for (dwSurIndex = 0; dwSurIndex < m_psBreakResult->dwWordNumber; ++dwSurIndex) {
            if (m_psBreakResult->puWordLen[dwSurIndex] == 1) { // High word of surrogate char should be breaked into signal char word
                if (lpcwszText[nCurrentIndex] >= 0xd800 && lpcwszText[nCurrentIndex] <= 0xdbff) { // High word is 
				    if (nCurrentIndex >= nTextLen - 1) { // Should be an error
                    } else if (lpcwszText[nCurrentIndex + 1] >= 0xdc00 && lpcwszText[nCurrentIndex + 1] <= 0xdfff) { // Is surrogate char
				        DWORD dwMoveDataNum;
                        dwMoveDataNum = m_psBreakResult->dwWordNumber - (dwSurIndex + 1 + 1);
					    m_psBreakResult->puWordLen[dwSurIndex] = 2;
                        CopyMemory(&(m_psBreakResult->puWordLen[dwSurIndex + 1]), &(m_psBreakResult->puWordLen[dwSurIndex + 1 + 1]), dwMoveDataNum * sizeof(UINT));
                        CopyMemory(&(m_psBreakResult->pbTerminalCode[dwSurIndex + 1]), &(m_psBreakResult->pbTerminalCode[dwSurIndex + 1 + 1]), dwMoveDataNum * sizeof(BYTE));
                        CopyMemory(&(m_psBreakResult->puWordAttrib[dwSurIndex + 1]), &(m_psBreakResult->puWordAttrib[dwSurIndex + 1 + 1]), dwMoveDataNum * sizeof(UINT));
                        m_psBreakResult->dwWordNumber -= 1;
					    //nCurrentIndex -= 1;
                    } else {// Should be an error
                    }
                }
            }
            nCurrentIndex += m_psBreakResult->puWordLen[dwSurIndex];
        } */
        // process Surrogate Char end

        if (fBreakWithParser) {
#ifdef PARSER
            DWORD i, dwBeginIndex, dwParseLen;
		    PWORD pwTerminalCode;
            pwTerminalCode = NULL;
            dwParseLen = 0;
            pwTerminalCode = new WORD[m_psBreakResult->dwWordNumber];
            if (pwTerminalCode && m_psBreakResult->pbTerminalCode) {
                MultiByteToWideChar(950, MB_PRECOMPOSED, (const char *)m_psBreakResult->pbTerminalCode, 
			        m_psBreakResult->dwWordNumber, pwTerminalCode, m_psBreakResult->dwWordNumber); 
                for (dwBeginIndex = 0; dwBeginIndex < m_psBreakResult->dwWordNumber; dwBeginIndex += 1) {
                    if (m_psBreakResult->pbTerminalCode[dwBeginIndex] == ' ') { continue; }
                    for (dwParseLen = 1; dwBeginIndex + dwParseLen < m_psBreakResult->dwWordNumber; ++dwParseLen) {
                        if (m_psBreakResult->pbTerminalCode[dwBeginIndex + dwParseLen] == ' ') { break; }
                    }
                    for ( ; dwParseLen > 1; --dwParseLen) {
                        if (m_pcRuleLex->IsAWord(&pwTerminalCode[dwBeginIndex], dwParseLen)) { break; }  
                    }
                    if (dwParseLen > 1) { // adjust break result
                        for (i = 1; i < dwParseLen; ++i) {      
                            m_psBreakResult->puWordLen[dwBeginIndex] += m_psBreakResult->puWordLen[dwBeginIndex + i];
                        }
                        m_psBreakResult->puWordAttrib[dwBeginIndex] = ATTR_RULE_WORD;
                        DWORD dwMoveDataNum;
                        dwMoveDataNum = m_psBreakResult->dwWordNumber - (dwBeginIndex + dwParseLen);
                        CopyMemory(&(m_psBreakResult->puWordLen[dwBeginIndex + 1]),
                            &(m_psBreakResult->puWordLen[dwBeginIndex + dwParseLen]), dwMoveDataNum * sizeof(UINT));
                        CopyMemory(&(m_psBreakResult->pbTerminalCode[dwBeginIndex + 1]), &(m_psBreakResult->pbTerminalCode[dwBeginIndex + dwParseLen]), dwMoveDataNum * sizeof(BYTE));
                        CopyMemory(&(m_psBreakResult->puWordAttrib[dwBeginIndex + 1]), &(m_psBreakResult->puWordAttrib[dwBeginIndex + dwParseLen]), dwMoveDataNum * sizeof(UINT));
                        m_psBreakResult->dwWordNumber -= (dwParseLen - 1);
                    }
                }
		        if (pwTerminalCode) {
		            delete [] pwTerminalCode;
                }
            }
#endif
        }// if support parser
    } // if build lattice success

_exit:
    return m_psBreakResult->dwWordNumber;
}

DWORD CCHTWordBreaker::GetResult(void)
{
    DWORD dwRet = 0;
    DWORD dwLen = 0;
    SLocalPath sLocalPath[2];
    UINT  uBestIndex = 0, uCandIndex, uLocalPathIndex;
    DWORD dw2ndIndex, dw3rdIndex;
    DWORD i, j, k;


    m_psBreakResult->dwWordNumber = 0;

    uCandIndex = (uBestIndex + 1) % 2;    
    
    while (dwLen < m_dwSentenceLength) {
        uLocalPathIndex = 0;
        if (m_pdwCandidateNumber[dwLen] == 1) {
            sLocalPath[uBestIndex].dwLength[0] = 1;
            sLocalPath[uBestIndex].bTerminalCode[0] = m_ppWordLattice[dwLen][0].bTerminalCode;
            sLocalPath[uBestIndex].wAttribute[0] = m_ppWordLattice[dwLen][0].wAttr;
        } else {
            FillMemory(&sLocalPath[uBestIndex], sizeof(SLocalPath), 0);
            for (i = 0; i < m_pdwCandidateNumber[dwLen]; ++i) {
                FillMemory(&sLocalPath[uCandIndex], sizeof(SLocalPath), 0);
                ++sLocalPath[uCandIndex].uStep;
                sLocalPath[uCandIndex].dwLength[uLocalPathIndex] = m_ppWordLattice[dwLen][i].uLen;
                sLocalPath[uCandIndex].wUnicount[uLocalPathIndex] = m_ppWordLattice[dwLen][i].wCount;
                sLocalPath[uCandIndex].wAttribute[uLocalPathIndex] = m_ppWordLattice[dwLen][i].wAttr;
                sLocalPath[uCandIndex].bTerminalCode[uLocalPathIndex++] = m_ppWordLattice[dwLen][i].bTerminalCode;
                dw2ndIndex = dwLen + m_ppWordLattice[dwLen][i].uLen; 
                if (dw2ndIndex < m_dwSentenceLength) {
                    for (j = 0; j < m_pdwCandidateNumber[dw2ndIndex]; ++j) {
                        ++sLocalPath[uCandIndex].uStep;
                        sLocalPath[uCandIndex].dwLength[uLocalPathIndex] = m_ppWordLattice[dw2ndIndex][j].uLen;
                        sLocalPath[uCandIndex].wUnicount[uLocalPathIndex] = m_ppWordLattice[dw2ndIndex][j].wCount;
                        sLocalPath[uCandIndex].wAttribute[uLocalPathIndex] = m_ppWordLattice[dw2ndIndex][j].wAttr;
                        sLocalPath[uCandIndex].bTerminalCode[uLocalPathIndex++] = m_ppWordLattice[dw2ndIndex][j].bTerminalCode;
                        dw3rdIndex = dw2ndIndex + m_ppWordLattice[dw2ndIndex][j].uLen;
                        if (dw3rdIndex < m_dwSentenceLength) {
                            for (k = 0; k < m_pdwCandidateNumber[dw3rdIndex]; ++k) {
                                ++sLocalPath[uCandIndex].uStep;
                                sLocalPath[uCandIndex].dwLength[uLocalPathIndex] = m_ppWordLattice[dw3rdIndex][k].uLen;
                                sLocalPath[uCandIndex].wUnicount[uLocalPathIndex] = m_ppWordLattice[dw3rdIndex][k].wCount;
                                sLocalPath[uCandIndex].wAttribute[uLocalPathIndex] = m_ppWordLattice[dw3rdIndex][k].wAttr;
                                sLocalPath[uCandIndex].bTerminalCode[uLocalPathIndex++] = m_ppWordLattice[dw3rdIndex][k].bTerminalCode;
                                GetScore(&(sLocalPath[uCandIndex])); 
                                if (CompareScore(&(sLocalPath[uCandIndex]), &(sLocalPath[uBestIndex])) > 0) {
                                    CopyMemory(&sLocalPath[uBestIndex], &sLocalPath[uCandIndex], sizeof(SLocalPath));
                                }
                                --uLocalPathIndex;
                                --sLocalPath[uCandIndex].uStep;
                            }
                        } else {
                            GetScore(&(sLocalPath[uCandIndex])); 
                            if (CompareScore(&(sLocalPath[uCandIndex]), &(sLocalPath[uBestIndex])) > 0) {
                                CopyMemory(&sLocalPath[uBestIndex], &sLocalPath[uCandIndex], sizeof(SLocalPath));
                            }
                        }
                        --uLocalPathIndex;
                        --sLocalPath[uCandIndex].uStep;
                    }
                } else {
                    GetScore(&(sLocalPath[uCandIndex])); 
                    if (CompareScore(&(sLocalPath[uCandIndex]), &(sLocalPath[uBestIndex])) > 0) {
                        CopyMemory(&sLocalPath[uBestIndex], &sLocalPath[uCandIndex], sizeof(SLocalPath));
                    }
                }
                --uLocalPathIndex;
                --sLocalPath[uCandIndex].uStep;
            }
        }
        m_psBreakResult->puWordLen[m_psBreakResult->dwWordNumber] = sLocalPath[uBestIndex].dwLength[0];
        m_psBreakResult->pbTerminalCode[m_psBreakResult->dwWordNumber] = sLocalPath[uBestIndex].bTerminalCode[0];
        m_psBreakResult->puWordAttrib[m_psBreakResult->dwWordNumber] = sLocalPath[uBestIndex].wAttribute[0];
        ++m_psBreakResult->dwWordNumber;
        dwLen += sLocalPath[uBestIndex].dwLength[0];
    }

    return m_psBreakResult->dwWordNumber;
}

INT CCHTWordBreaker::CompareScore(
    PSLocalPath psLocalPath1,
    PSLocalPath psLocalPath2)
{
    if (psLocalPath1->uPathLength > psLocalPath2->uPathLength) {
        return 1;
    } else if (psLocalPath1->uPathLength < psLocalPath2->uPathLength) {
        return -1;
    } else if (psLocalPath1->uStep < psLocalPath2->uStep) {
        return 1;
    } else if (psLocalPath1->uStep > psLocalPath2->uStep) {
        return -1;
    } else {
    }

    if (psLocalPath1->fVariance > psLocalPath2->fVariance) {
        return -1;
    } 
    if (psLocalPath1->fVariance < psLocalPath2->fVariance) {
        return 1;
    } 
    if (psLocalPath1->uCompoundNum > psLocalPath2->uCompoundNum) {
        return -1;
    } 
    if (psLocalPath1->uCompoundNum < psLocalPath2->uCompoundNum) {
        return 1;
    } 
    if (psLocalPath1->uDMNum > psLocalPath2->uDMNum) {
        return -1;
    } 
    if (psLocalPath1->uDMNum < psLocalPath2->uDMNum) {
        return 1;
    } 
    if (psLocalPath1->wUniCountSum > psLocalPath2->wUniCountSum) {
        return 1;
    } 
    if (psLocalPath1->wUniCountSum < psLocalPath2->wUniCountSum) {
        return -1;
    } 
    return 0;
}

void CCHTWordBreaker::GetScore(
    PSLocalPath psLocalPath)
{
    UINT i;
    double fAverageSum;

    psLocalPath->uCompoundNum = 0;
    psLocalPath->uDMNum = 0;
    psLocalPath->uPathLength = 0;
    psLocalPath->fVariance = 0;
    psLocalPath->wUniCountSum = 0;

    for (i = 0; i < psLocalPath->uStep; ++i) {
        if (psLocalPath->wAttribute[i] & ATTR_COMPOUND) {
            psLocalPath->uCompoundNum++;    
        }
        if (psLocalPath->wAttribute[i] & ATTR_DM) {
            psLocalPath->uDMNum++;        
        }
        psLocalPath->uPathLength += psLocalPath->dwLength[i];
        psLocalPath->wUniCountSum += psLocalPath->wUnicount[i];
    }
    fAverageSum = (double)psLocalPath->uPathLength / psLocalPath->uStep; 
    for (i = 0; i < psLocalPath->uStep; ++i) {
        if (fAverageSum > psLocalPath->dwLength[i]) {
            psLocalPath->fVariance += (fAverageSum - psLocalPath->dwLength[i]);         
        } else {
            psLocalPath->fVariance += (psLocalPath->dwLength[i] - fAverageSum);    
        }
    }
}

         
BOOL CCHTWordBreaker::BuildLattice(
    LPCWSTR   lpcwszText,
    DWORD     dwTextLen,
    CBaseLex* pcBaseLex,
    DWORD     dwMaxWordLen)
{ 
    DWORD i, j;

    FillMemory(m_pdwCandidateNumber, sizeof(DWORD) * dwTextLen, 0);
    // we should use head link
    for (i = 0; i < dwTextLen; ++i) {
        m_pdwMaxWordLength[i] = 1;
        for (j = i; (j - i + 1) <= dwMaxWordLen && j < dwTextLen; ++j) {
            if (m_pcLexicon->GetWordInfo(&lpcwszText[i], (j - i + 1), 
                &(m_ppWordLattice[i][m_pdwCandidateNumber[i]].wCount),
                &(m_ppWordLattice[i][m_pdwCandidateNumber[i]].wAttr),
                &(m_ppWordLattice[i][m_pdwCandidateNumber[i]].bTerminalCode))) { 
                m_ppWordLattice[i][m_pdwCandidateNumber[i]++].uLen = (j - i + 1);
                if (j - i + 1 > m_pdwMaxWordLength[i]) {
                    m_pdwMaxWordLength[i] = j - i + 1 ;
                }
            } else if (pcBaseLex && pcBaseLex->GetWordInfo(&lpcwszText[i], (j - i + 1), 
                &(m_ppWordLattice[i][m_pdwCandidateNumber[i]].wAttr))) {
                m_ppWordLattice[i][m_pdwCandidateNumber[i]].wCount = APLEXICON_COUNT;
                m_ppWordLattice[i][m_pdwCandidateNumber[i]].bTerminalCode = ' ';
                m_ppWordLattice[i][m_pdwCandidateNumber[i]++].uLen = (j - i + 1);
                if (j - i + 1 > m_pdwMaxWordLength[i]) {
                    m_pdwMaxWordLength[i] = j - i + 1 ;
                }
            } else {
            }
        }
        if (!m_pdwCandidateNumber[i]) {
            m_ppWordLattice[i][0].uLen = 1;
            m_ppWordLattice[i][0].wCount = 0;
            m_ppWordLattice[i][0].wAttr = 0;
            m_ppWordLattice[i][0].fVariance = 0;
            m_ppWordLattice[i][0].bTerminalCode = ' ';
            ++m_pdwCandidateNumber[i];
        }
    }
    m_dwSentenceLength = dwTextLen;
    return TRUE;
}
/*
DWORD CCHTWordBreaker::LongestRuleWord(
    DWORD dwIndex)
{
    DWORD dwRet = 0, i;
    
    for (i = 0; i < m_pdwCandidateNumber[dwIndex]; ++i) {
        if (m_ppWordLattice[dwIndex][i].bAttr & ATTR_RULE_WORD) {
            if (m_ppWordLattice[dwIndex][i].uLen > dwRet) {
                dwRet = m_ppWordLattice[dwIndex][i].uLen;
            }
            
        }
    }
    return dwRet;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\export.cpp ===
#include <windows.h>

#include <objbase.h>
#include <initguid.h>
#include "IWBrKr.h"
#include "DefBrKr.h"

#include "rulelex.h"
#include "lexicon.h"
#include "LexMgr.h"
#include "chtbrkr.h"
#include "cierror.h"

static LONG g_lServerLockCnt = 0;
static LONG g_lComponentCnt = 0;

TCHAR g_tszModuleFileName[MAX_PATH];
HINSTANCE g_hInstance;

#define WBREAK_E_END_OF_TEXT             ((HRESULT)0x80041780L)

static WCHAR g_wszLicense[] = {L"Use of the IWordBreaker interface that is in violation of the license agreement, without the consent of the vendor(s) specified in the notice, may result in server civil and criminal penalties"};

TCHAR tszEnglishLangSpecificKey[] = TEXT("System\\CurrentControlSet\\Control\\ContentIndex\\Language\\English_US");

extern "C" BOOL CALLBACK DllMain(HINSTANCE, DWORD, LPVOID);

BOOL CALLBACK DllMain(
    HINSTANCE hInstance,        // instance handle of this library
    DWORD     fdwReason,        // reason called
    LPVOID    lpvReserve)       // reserve pointer
{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hInstance;
        GetModuleFileName(g_hInstance, g_tszModuleFileName, 
            sizeof(g_tszModuleFileName) / sizeof(TCHAR));
        break;
    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


// Export API 
STDAPI DllCanUnloadNow(void)
{
    if (g_lServerLockCnt) {
    } else if (g_lComponentCnt) {
    } else {
        return S_OK;
    }
    return S_FALSE;
}
       
STDAPI DllGetClassObject(
    const CLSID& clsid,
    const IID&   iid,
    void       **ppv)
{
    IChtBrKrClassFactory *pIChtBrKrClassFactory;
        HRESULT hr;


        InterlockedIncrement(&g_lServerLockCnt);

        if (clsid != CLSID_CHTBRKR && clsid != CLSID_WHISTLER_CHTBRKR) { 
                hr = CLASS_E_CLASSNOTAVAILABLE ;
        goto _exit;
        }

        pIChtBrKrClassFactory = new IChtBrKrClassFactory;

        if (!pIChtBrKrClassFactory) { 
                hr = E_OUTOFMEMORY; 
            goto _exit;
        }
 
    hr = pIChtBrKrClassFactory->QueryInterface(iid, ppv);

_exit:
        InterlockedDecrement(&g_lServerLockCnt);
 
        return hr;
}


// Factory
IChtBrKrClassFactory::IChtBrKrClassFactory(void)
    :m_lRefCnt(1)
{
    InterlockedIncrement(&g_lComponentCnt);
}

IChtBrKrClassFactory::~IChtBrKrClassFactory(void)
{
    InterlockedDecrement(&g_lComponentCnt);
}

STDMETHODIMP_(ULONG) IChtBrKrClassFactory::AddRef(void)
{
    return InterlockedIncrement(&m_lRefCnt);
}

STDMETHODIMP_(ULONG) IChtBrKrClassFactory::Release(void)
{
    if (InterlockedDecrement(&m_lRefCnt) == 0) {
        delete this;
        return 0;
    }
    return m_lRefCnt;
}

STDMETHODIMP IChtBrKrClassFactory::QueryInterface(
    const IID&   iid,
    void       **ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory)) {
        *ppv = static_cast<IChtBrKrClassFactory *>(this);
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP IChtBrKrClassFactory::LockServer(
    BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement(&g_lServerLockCnt);
    } else {
        InterlockedDecrement(&g_lServerLockCnt);
    }
    return S_OK;
}

STDMETHODIMP IChtBrKrClassFactory::CreateInstance(
    IUnknown  *pUnknownOuter,
    const IID& iid,
    void     **ppv)
{
    IWordBreaker *pIWordBreaker;
    HRESULT hr;

    *ppv = NULL;

    if (pUnknownOuter) { return CLASS_E_NOAGGREGATION; }
    
    pIWordBreaker = new IWordBreaker; 

    if (!pIWordBreaker) { return  E_OUTOFMEMORY; } 
    
    hr = pIWordBreaker->QueryInterface(iid, ppv);
     
    pIWordBreaker->Release();
    
    return hr;
}

SCODE _stdcall MyFillTestBuffer(
    TEXT_SOURCE __RPC_FAR *pTextSource)
{
    return WBREAK_E_END_OF_TEXT;   
}

// IWordBreaker
IWordBreaker::IWordBreaker(void)
    :m_lRefCnt(1),
     m_pcWordBreaker(NULL),
     m_pNonChineseTextSource(NULL),
     m_pNonChineseWordBreaker(NULL),
     m_pcDefWordBreaker(NULL),
     m_fIsQueryTime(FALSE)
{
    InterlockedIncrement(&g_lComponentCnt);
    // CHT word breaker
    m_pcWordBreaker = new CCHTWordBreaker;
    if (!m_pcWordBreaker) {
    } else if (m_pcWordBreaker->InitData(g_hInstance)) {
    } else {
        delete m_pcWordBreaker;
        m_pcWordBreaker = NULL;
    }

    // Default wordbreaker 
    m_pcDefWordBreaker = new CDefWordBreaker;

    // Non CHT Word breaker
    m_pNonChineseTextSource = new TEXT_SOURCE;
    if (m_pNonChineseTextSource) { 
        HKEY  hKey;
        TCHAR tszCLSID[MAX_PATH];
        DWORD dwBufSize = MAX_PATH;
        CLSID szCLSID;
        HRESULT hr;
        m_pNonChineseTextSource->pfnFillTextBuffer = MyFillTestBuffer;
#if 0
        if (RegCreateKey(HKEY_LOCAL_MACHINE, tszEnglishLangSpecificKey, &hKey) == ERROR_SUCCESS) {
            if (RegQueryValueEx(hKey, TEXT("WBreakerClass"), NULL, NULL, (LPBYTE)tszCLSID, &dwBufSize) == ERROR_SUCCESS) {
                CoInitialize(NULL);
                CLSIDFromString(tszCLSID, &szCLSID);
                hr = CoCreateInstance(szCLSID, NULL, CLSCTX_SERVER, IID_IWordBreaker,
                    (LPVOID*)&m_pNonChineseWordBreaker);
                if (!SUCCEEDED(hr)) {
                    m_pNonChineseWordBreaker = NULL;
                }
            }
        }
#endif
    }
}

IWordBreaker::~IWordBreaker(void)
{
    InterlockedDecrement(&g_lComponentCnt);

    if (m_pcWordBreaker) {
        delete m_pcWordBreaker;
    }
    if (m_pNonChineseTextSource) {
        delete m_pNonChineseTextSource;
    }
    if (m_pNonChineseWordBreaker) {
        if (m_pNonChineseWordBreaker->Release() == 0) {
            m_pNonChineseWordBreaker = NULL;
        }
    }
    if (m_pcDefWordBreaker) {
        delete m_pcDefWordBreaker;
    }
}

STDMETHODIMP IWordBreaker::QueryInterface(
    const IID&   iid,
    void       **ppv)
{
    *ppv = NULL;

    if ((iid == IID_IUnknown) || (iid == IID_IWordBreaker)) {
        *ppv = static_cast<IWordBreaker *>(this);
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) IWordBreaker::AddRef(void)
{
    return InterlockedIncrement(&m_lRefCnt);
}

STDMETHODIMP_(ULONG) IWordBreaker::Release(void)
{
    if (m_lRefCnt == 0 || InterlockedDecrement(&m_lRefCnt) == 0) {
        delete this;
        return 0;
    }
    return m_lRefCnt;
}

STDMETHODIMP IWordBreaker::Init(
    BOOL  fQuery, 
    ULONG ulMaxTokenSize, 
    BOOL  *pfLicense)
{
    m_uMaxCharNumberPerWord = ulMaxTokenSize;
    *pfLicense = FALSE;
    m_fIsQueryTime = fQuery;
        if (NULL != m_pNonChineseWordBreaker) {
            m_pNonChineseWordBreaker->Init(fQuery, ulMaxTokenSize, pfLicense);
        }
    return S_OK;
}

BOOL IsChineseChar(
    WCHAR wUnicode)
{
    BOOL fRet = FALSE;

    if (wUnicode >= 0x4E00 && wUnicode <= 0x9FA5) {
        fRet = TRUE;
    } else if (wUnicode >= 0xd800 && wUnicode <= 0xdbff) {
        fRet = TRUE; 
    } else if (wUnicode >= 0xdc00 && wUnicode <= 0xdfff) {
        fRet = TRUE;
    } else if (wUnicode >= 0x1100 && wUnicode <= 0x11ff) {
       fRet = TRUE;
    } else if (wUnicode >= 0x2e80 && wUnicode <= 0xffff) {
       fRet = FALSE;
    } else {
       fRet = FALSE;
    }

    return fRet;
}

BOOL IsSpecialFullShapeChar(
    WCHAR wChar)
{
    BOOL fRet;

    if (wChar >=0xff21 && wChar <=0xff3a) {
        fRet = TRUE;
    } else if (wChar >=0xff41 && wChar <=0xff5a) {
        fRet = TRUE;
    } else if (wChar >=0xff10 && wChar <=0xff19) {
        fRet = TRUE;
    } else {
        fRet = FALSE;
    }
    return fRet;
}


DWORD GetNormaizeWord(
    LPWSTR   lpwWordStr,
    UINT     uWordLen,
    LPWSTR*  lppwNormalizedWordStr) 
{
    DWORD dwNormalizedWordLen = 0;
    UINT  i;
    WCHAR wChar;

    for (i = 0; i < uWordLen; ++i) {
        if (!IsSpecialFullShapeChar(lpwWordStr[i])) {
            goto _exit;           
        }
    }
    *lppwNormalizedWordStr = new WCHAR[uWordLen];
    if (*lppwNormalizedWordStr) {
        for (dwNormalizedWordLen = 0; dwNormalizedWordLen < uWordLen; ++dwNormalizedWordLen) {
            wChar = lpwWordStr[dwNormalizedWordLen];
            if (wChar >=0xff21 && wChar <=0xff3a) { // A - Z
                (*lppwNormalizedWordStr)[dwNormalizedWordLen] = wChar - (0xff21 - 0x0041);
            } else if (wChar >=0xff41 && wChar <=0xff5a) { // a - z
                (*lppwNormalizedWordStr)[dwNormalizedWordLen] = wChar - (0xff41 - 0x0061);
            } else if (wChar >=0xff10 && wChar <=0xff19) { // 0 - 9
                (*lppwNormalizedWordStr)[dwNormalizedWordLen] = wChar - (0xff10 - 0x0030);
            } else {
                (*lppwNormalizedWordStr[dwNormalizedWordLen]) = wChar;
            }       
        }
    }

_exit:
    return dwNormalizedWordLen;
}

BOOL MyPutWordOrPhrase(
    CCHTWordBreaker* m_pcWordBreaker,
    TEXT_SOURCE      *pTextSource,
    IWordSink        *pWordSink,
    IPhraseSink      *pPhraseSink,
    DWORD            dwStartPosInTextStore,
    PDWORD           pdwPrivBufToTextSourceMapping,
    LPWSTR           lptszStencece, // Pure sentence, no enter in sentence
    DWORD            dwSentenceLen,
    DWORD            dwWordNum,
    PUINT            puBreakResult,
    BOOL             fPutWord,
    BOOL*            fIsAPhrase)

{
    DWORD  i, dwSentenceIndex = 0, dwWordLen;
    BOOL   fRet = TRUE;
    LPWSTR lpwNormalizedWordStr; 
    DWORD  dwNormalizedWordLen;

    for (i = 0; i < dwWordNum; ++i) {
        dwWordLen = pdwPrivBufToTextSourceMapping[dwSentenceIndex + puBreakResult[i] - 1] -
            pdwPrivBufToTextSourceMapping[dwSentenceIndex] + 1;
        if (fPutWord && pWordSink) {
            if (dwNormalizedWordLen = GetNormaizeWord(&(lptszStencece[dwSentenceIndex]), puBreakResult[i], &lpwNormalizedWordStr)) {
                pWordSink->PutAltWord(dwNormalizedWordLen, lpwNormalizedWordStr, dwWordLen, dwStartPosInTextStore + pdwPrivBufToTextSourceMapping[dwSentenceIndex]);
                delete [] lpwNormalizedWordStr;
            } 
            DWORD   dwAltWordNumber;
            LPWSTR  lpwAltWord;
            if (dwAltWordNumber = m_pcWordBreaker->GetAltWord(&lptszStencece[dwSentenceIndex], puBreakResult[i], &lpwAltWord)) {
                pWordSink->PutAltWord(puBreakResult[i], lpwAltWord, dwWordLen, dwStartPosInTextStore + pdwPrivBufToTextSourceMapping[dwSentenceIndex]);   
                delete [] lpwAltWord;
            }
                    pWordSink->PutWord(puBreakResult[i], &lptszStencece[dwSentenceIndex],
                dwWordLen, dwStartPosInTextStore + pdwPrivBufToTextSourceMapping[dwSentenceIndex]);
        } else if (!fPutWord && fIsAPhrase) {
            if (fIsAPhrase[i] && pPhraseSink) {
                        pPhraseSink->PutPhrase(
                    &(pTextSource->awcBuffer[dwStartPosInTextStore + pdwPrivBufToTextSourceMapping[dwSentenceIndex]]),
                    dwWordLen);                
            }
        } else {
        }
        dwSentenceIndex += puBreakResult[i];
    }
    return fRet;
}


DWORD FullShapeCharProcess(
    LPWSTR lptszStencece,
    DWORD  dwSentenceLen,
    DWORD  dwWordNum,
    PUINT  puBreakResult)
{
    DWORD dwSentenceIndex = 0;
    DWORD dwMergeWordCount = 0;

    for (DWORD i = 0; i < dwWordNum; ++i) {
        dwMergeWordCount = 0; 
        while (i + dwMergeWordCount < dwWordNum && puBreakResult[i + dwMergeWordCount] == 1 && 
            IsSpecialFullShapeChar(lptszStencece[dwSentenceIndex + dwMergeWordCount])) {
            ++dwMergeWordCount;
        } 
        if (dwMergeWordCount > 1) {
            puBreakResult[i] += (dwMergeWordCount - 1);
/*
            if (pfIsAPhrase) {
                CopyMemory(&(pfIsAPhrase[i + 1]), &(pfIsAPhrase[i + dwMergeWordCount]), 
                    sizeof(BOOL) * (dwWordNum - (i + dwMergeWordCount)));  
            }
*/
            if (puBreakResult) {
                CopyMemory(&(puBreakResult[i + 1]), &(puBreakResult[i + dwMergeWordCount]), 
                    sizeof(UINT) * (dwWordNum - (i + dwMergeWordCount)));   
            }
            dwWordNum -= (dwMergeWordCount - 1);
            dwSentenceIndex += dwMergeWordCount;
        } else {
            dwSentenceIndex += puBreakResult[i];
        }
    }

    return dwWordNum;
}

BOOL IsEnter(
    LPCWSTR lpwStr) 
{
    BOOL fRet;

    if (lpwStr[0] == 0x000D && lpwStr[1] == 0x000A) {
        fRet = TRUE;
    } else {
        fRet = FALSE;
    }

    return fRet;
}

STDMETHODIMP IWordBreaker::BreakText(
    TEXT_SOURCE *pTextSource, 
    IWordSink   *pWordSink, 
    IPhraseSink *pPhraseSink)
{
    LPTSTR           lptszStencece = NULL;
        PDWORD           pdwIndex = NULL;         
    PUINT            puResult, puResultAttrib;
    DWORD            dwBufferSize = 0, dwBufferUsed = 0;
        DWORD            dwIndex = 0;
    DWORD            dwWordNum;
    HRESULT          hr = S_OK;
    BOOL             fIsPreChineseLanguage, fIsCurChineseLanguage;
        BOOL             fIsEnter;
        DWORD            dwEnterCount = 0;
    PUINT            puOrigionalResult = NULL;
    PUINT            puNewResult = NULL; // after decompose compose word
    BOOL*            pfIsAPhrase = NULL;
    PUINT            puOrigionalResultAttrib = NULL;
    DWORD            dwNewResultNum = 0;
    DWORD            dwSentenceIndex, dwOrgWordIndex, dwSubWordNum;
    

    if (!pTextSource) {
        hr = E_INVALIDARG;
        goto _exit;
    }
    dwBufferSize = BUFFER_GROW_UINT;
    lptszStencece = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, dwBufferSize * sizeof(WCHAR));
    pdwIndex = (PDWORD)HeapAlloc(GetProcessHeap(), 0, dwBufferSize * sizeof(DWORD));
    if (!lptszStencece || !pdwIndex) {
        hr = E_OUTOFMEMORY; 
        goto _exit;
    }

    while (TRUE) {
        while (pTextSource->iCur < pTextSource->iEnd) {
                        fIsEnter = FALSE;
            fIsCurChineseLanguage = IsChineseChar(pTextSource->awcBuffer[pTextSource->iCur]); // Enter is not a Chinese char
            
                        // Process "Enter"
            // Rule: One Enter only -> connect
            //       More Than one Enter-> split
            //       Enter after a full width char -> split
                        if (!fIsCurChineseLanguage && dwBufferUsed != 0 && fIsPreChineseLanguage) {
                                if (pTextSource->iCur < pTextSource->iEnd - 1) {
                                    if (IsEnter(&(pTextSource->awcBuffer[pTextSource->iCur]))) {
                        if ((pTextSource->iCur + 3 < pTextSource->iEnd) && IsEnter(&(pTextSource->awcBuffer[pTextSource->iCur + 2]))) {
                        } else if (IsSpecialFullShapeChar(lptszStencece[dwBufferUsed - 1])) {
                        } else {
                                                fIsCurChineseLanguage = TRUE; // we treat "Enter" as Chinese char
                                                fIsEnter = TRUE;
                                                    ++dwEnterCount;
                        }
                                        }
                                }
                        }
                        if (dwBufferUsed == 0) { // first char
                fIsPreChineseLanguage = fIsCurChineseLanguage;
            } else if (fIsPreChineseLanguage && fIsCurChineseLanguage) {
            } else if (!fIsPreChineseLanguage && !fIsCurChineseLanguage) {
            } else { // language change, process it
_Break_Text:
                if (fIsPreChineseLanguage) {
/*                                      
                                        PWCHAR pwOutputDebugString;
                    pwOutputDebugString = new WCHAR[dwBufferUsed + 1];
                                        CopyMemory(pwOutputDebugString, lptszStencece, sizeof(WCHAR) * dwBufferUsed);
                    pwOutputDebugString[dwBufferUsed] = NULL;
                                        OutputDebugString(pwOutputDebugString);
*/                                      
                    dwWordNum = m_pcWordBreaker->BreakText(lptszStencece, dwBufferUsed);   
                    dwWordNum = m_pcWordBreaker->GetBreakResultWithAttribute(&puResult, &puResultAttrib);
                    puOrigionalResult = new UINT[dwWordNum];
                    puNewResult = new UINT[dwBufferUsed]; // alloc max size
                    pfIsAPhrase = new BOOL[dwWordNum];
                    puOrigionalResultAttrib = new UINT [dwWordNum];
                    if (puOrigionalResult && puNewResult && pfIsAPhrase && puOrigionalResultAttrib) {
                        dwNewResultNum = 0;
                        CopyMemory(puOrigionalResult, puResult, sizeof(UINT) * dwWordNum);
                        CopyMemory(puOrigionalResultAttrib, puResultAttrib, sizeof(UINT) * dwWordNum);
                        for (dwSentenceIndex = 0, dwOrgWordIndex = 0; dwOrgWordIndex < dwWordNum; ++dwOrgWordIndex) {
                            pfIsAPhrase[dwOrgWordIndex] = FALSE;
                            if (puOrigionalResult[dwOrgWordIndex] > 2) {
                                dwSubWordNum = m_pcWordBreaker->BreakText(&(lptszStencece[dwSentenceIndex]), 
                                    puOrigionalResult[dwOrgWordIndex], NULL, puOrigionalResult[dwOrgWordIndex] - 1, FALSE);   
                                dwSubWordNum = m_pcWordBreaker->GetBreakResult(&puResult);
                                if (puOrigionalResultAttrib[dwOrgWordIndex] == ATTR_RULE_WORD) {
                                    pfIsAPhrase[dwOrgWordIndex] = TRUE;    
                                } else {
                                    for (DWORD dwSubWordIndex = 0; dwSubWordIndex < dwSubWordNum; ++dwSubWordIndex) {
                                        if (puResult[dwSubWordIndex] > 1) {
                                            pfIsAPhrase[dwOrgWordIndex] = TRUE;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (pfIsAPhrase[dwOrgWordIndex]) {
                                CopyMemory(&(puNewResult[dwNewResultNum]), puResult, sizeof(UINT) * dwSubWordNum);
                                dwNewResultNum += dwSubWordNum;
                            } else {
                                puNewResult[dwNewResultNum++] = puOrigionalResult[dwOrgWordIndex];
                            }
                            dwSentenceIndex += puOrigionalResult[dwOrgWordIndex];
                        }
                        if (m_fIsQueryTime) { // Put Phrase at query time
                            MyPutWordOrPhrase(m_pcWordBreaker, pTextSource, pWordSink, pPhraseSink, pTextSource->iCur - dwBufferUsed - dwEnterCount * 2, 
                                pdwIndex, lptszStencece, dwBufferUsed, dwWordNum, puOrigionalResult, FALSE, pfIsAPhrase);
                        }
                        // special process for full width A-Z, a-z, 0-9
                        dwNewResultNum = FullShapeCharProcess(lptszStencece, dwBufferUsed, dwNewResultNum, puNewResult);
                        // Put Word
                        MyPutWordOrPhrase(m_pcWordBreaker, pTextSource, pWordSink, pPhraseSink, pTextSource->iCur - dwBufferUsed - dwEnterCount * 2, 
                            pdwIndex, lptszStencece, dwBufferUsed, dwNewResultNum, puNewResult, TRUE, NULL);
                    } else { // can not do special processing
                        MyPutWordOrPhrase(m_pcWordBreaker, pTextSource, pWordSink, pPhraseSink, pTextSource->iCur - dwBufferUsed - dwEnterCount * 2, 
                            pdwIndex, lptszStencece, dwBufferUsed, dwWordNum, puResult, TRUE, NULL);                            
                    }
                    if (puOrigionalResult) { delete [] puOrigionalResult; } 
                    if (puNewResult) { delete [] puNewResult; } 
                    if (pfIsAPhrase) { delete [] pfIsAPhrase; }
                    if (puOrigionalResultAttrib) { delete [] puOrigionalResultAttrib; }
                    puResult = NULL;
                                        dwEnterCount = 0;
                } else { // not TC language sentence
                    /*
                    m_pNonChineseTextSource->iCur = 0;
                    m_pNonChineseTextSource->iEnd = dwBufferUsed;  
                    m_pNonChineseTextSource->awcBuffer = &(pTextSource->awcBuffer[pTextSource->iCur - dwBufferUsed]);//lptszStencece;
                    */
                    m_pNonChineseTextSource->iCur = pTextSource->iCur - dwBufferUsed;
                    m_pNonChineseTextSource->iEnd = pTextSource->iCur;  
                    m_pNonChineseTextSource->awcBuffer = pTextSource->awcBuffer;
               //   if (m_pNonChineseWordBreaker) {
               //       m_pNonChineseWordBreaker->BreakText(m_pNonChineseTextSource, pWordSink, pPhraseSink);
               //   } else 
                                if (m_pcDefWordBreaker) {
                        //m_pcDefWordBreaker->BreakText(m_pNonChineseTextSource, pWordSink, pPhraseSink, pTextSource->iCur - dwBufferUsed);
                        m_pcDefWordBreaker->BreakText(m_pNonChineseTextSource, pWordSink, pPhraseSink, 0);
                    } /*else if (m_pNonChineseWordBreaker) {
                        //m_pNonChineseWordBreaker->BreakText(m_pNonChineseTextSource, pWordSink, pPhraseSink);
                    } */ else {
                    }
                }
                fIsPreChineseLanguage = fIsCurChineseLanguage;
                dwBufferUsed = 0;       
                                dwIndex = 0;
                                dwEnterCount = 0;
            }
            if (dwBufferUsed >= dwBufferSize) { // buffer full
                LPVOID lpMem1, lpMem2;
                lpMem1 = HeapReAlloc(GetProcessHeap(), 0, lptszStencece, 
                    (dwBufferSize + BUFFER_GROW_UINT) * sizeof(WCHAR));
                lpMem2 = HeapReAlloc(GetProcessHeap(), 0, pdwIndex, 
                    (dwBufferSize + BUFFER_GROW_UINT) * sizeof(DWORD));
                if (!lpMem1 || !lpMem2) { goto _Break_Text;
                } else {
                    lptszStencece = (LPTSTR)lpMem1;
                    pdwIndex = (PDWORD)lpMem2;
                    dwBufferSize += BUFFER_GROW_UINT;
                }
            }
                        if (pTextSource->iCur < pTextSource->iEnd) {
                                if (fIsEnter) {
                                    pTextSource->iCur += 2;
                                        dwIndex += 2;
                                } else {
                    lptszStencece[dwBufferUsed] = pTextSource->awcBuffer[pTextSource->iCur++];
                                        pdwIndex[dwBufferUsed] = dwIndex;
                                        ++dwBufferUsed;
                                        ++dwIndex;
                                }
                        }
        }
                if (dwBufferUsed) { goto _Break_Text; }
        if (FAILED(pTextSource->pfnFillTextBuffer(pTextSource))) {
            break;
        }
    }
_exit:
    if (lptszStencece) {
        HeapFree(GetProcessHeap(), 0, lptszStencece);
    }
        if (pdwIndex) {
            HeapFree(GetProcessHeap(), 0, pdwIndex);
        }
    return hr;
}

STDMETHODIMP IWordBreaker::ComposePhrase(
    const WCHAR *pwcNoun, 
    ULONG cwcNoun, 
    const WCHAR *pwcModifier,
    ULONG cwcModifier, 
    ULONG ulAttachmentType,
    WCHAR *pwcPhrase, 
    ULONG *pcwcPhrase)
{
    return E_NOTIMPL;
}
    
STDMETHODIMP IWordBreaker::GetLicenseToUse(
    const WCHAR **ppwcsLicense)
{
    *ppwcsLicense = g_wszLicense;
    
    return S_OK;
}

/*
    while (TRUE) {
        while (pTextSource->iCur != pTextSource->iEnd) {
            lptszStencece[dwBufferUsed] = pTextSource->awcBuffer[pTextSource->iCur++];
            if (lptszStencece[dwBufferUsed] >= 0x4E00 && lptszStencece[dwBufferUsed] <= 0x9FA5) {
                dwBufferUsed++;
                if (dwBufferUsed >= dwBufferSize) {
                    LPVOID lpMem;
                    lpMem = HeapReAlloc(GetProcessHeap(), 0, lptszStencece, dwBufferSize + BUFFER_GROW_UINT);
                    if (!lpMem) {
                        goto _heap_realloc_fail;
                    } else {
                        lptszStencece = (LPTSTR)lpMem ;
                        dwBufferSize += BUFFER_GROW_UINT;
                    }
                }
            } else {
                if (dwBufferUsed == 0) {
                    ++dwBufferUsed;    
                } else {
                    --pTextSource->iCur;
                }
_heap_realloc_fail:
                dwWordNum = pcWordBreaker->BreakText(lptszStencece, dwBufferUsed);   
                dwWordNum = pcWordBreaker->GetBreakResult(&puResult);
                // To do .....
                DWORD dwSrcPos;
                dwSrcPos = pTextSource->iCur - dwBufferUsed;
                for (i = 0; i < dwWordNum; ++i) {
                    pWordSink->PutWord(puResult[i], &pTextSource->awcBuffer[dwSrcPos], puResult[i], dwSrcPos);
                    dwSrcPos += puResult[i];
                }
                puResult = NULL;
                dwBufferUsed = 0;
            }
        }
        if (FAILED(pTextSource->pfnFillTextBuffer(pTextSource))) {
            break;
        }
    }
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\iwbrkr.h ===
#ifndef _CHTBRKR_H__
#define _CHTBRKR_H__

extern "C" TCHAR g_tszModuleFileName[MAX_PATH];
extern "C" HINSTANCE g_hInstance;

class CCHTWordBreaker;
class CDefWordBreaker;

// {1680E7C3-9430-4a51-9B82-1E7E7AEE5258}
DEFINE_GUID(CLSID_CHTBRKR, 0x1680E7C3, 0x9430, 0x4A51, 0x9B, 0x82, 
            0x1E, 0x7E, 0x7A, 0xEE, 0x52, 0x58);
// {954F1760-C1BC-11D0-9692-00A0C908146E}
DEFINE_GUID(CLSID_WHISTLER_CHTBRKR, 0x954F1760, 0xC1BC, 0x11D0, 0x96, 0x92, 
            0x00, 0xA0, 0xC9, 0x08, 0x14, 0x6E);

DEFINE_GUID(IID_IWordBreaker, 0xD53552C8, 0x77E3, 0x101A, 0xB5, 0x52, 
            0x08, 0x0, 0x2B ,0x33 ,0xB0, 0xE6);
typedef SCODE ( __stdcall __RPC_FAR *PFNFILLTEXTBUFFER )( 
    struct tagTEXT_SOURCE __RPC_FAR *pTextSource);
typedef struct tagTEXT_SOURCE{
    PFNFILLTEXTBUFFER pfnFillTextBuffer;
    const WCHAR *awcBuffer;
    ULONG iEnd;
    ULONG iCur;
}TEXT_SOURCE;

typedef enum tagWORDREP_BREAK_TYPE{
    WORDREP_BREAK_EOW = 0,
    WORDREP_BREAK_EOS = 1,
    WORDREP_BREAK_EOP = 2,
    WORDREP_BREAK_EOC = 3
} WORDREP_BREAK_TYPE;

class IChtBrKrClassFactory: public IClassFactory
{
public:
	 IChtBrKrClassFactory();
	 ~IChtBrKrClassFactory();
public:
	// IUnknown members
    STDMETHOD(QueryInterface)	(THIS_ REFIID refiid, VOID **ppv);
    STDMETHOD_(ULONG,AddRef)	(THIS);
    STDMETHOD_(ULONG,Release)	(THIS);

	// IFEClassFactory members
    STDMETHOD(CreateInstance)	(THIS_ LPUNKNOWN, REFIID, void **);
    STDMETHOD(LockServer)		(THIS_ BOOL);
private:
    LONG        m_lRefCnt;
};

DECLARE_INTERFACE_(IWordSink, IUnknown)
{
public:
    STDMETHOD(PutWord) (THIS_ ULONG cwc, const WCHAR *pwcInBuf, ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
    STDMETHOD(PutAltWord) (THIS_ ULONG cwc, const WCHAR *pwcInBuf, ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
    STDMETHOD(StartAltPhrase) (THIS) PURE;
    STDMETHOD(EndAltPhrase) (THIS) PURE;
    STDMETHOD(PutBreak) (THIS_ WORDREP_BREAK_TYPE breakType) PURE;        
};

DECLARE_INTERFACE_(IPhraseSink, IUnknown)
{
public:
    STDMETHOD(PutSmallPhrase) (THIS_ const WCHAR *pwcNoun, ULONG cwcNoun, const WCHAR *pwcModifier,
        ULONG cwcModifier, ULONG ulAttachmentType) PURE;
    STDMETHOD(PutPhrase) (THIS_ const WCHAR *pwcPhrase, ULONG cwcPhrase) PURE;
};


class IWordBreaker: public IUnknown
{
public:
    IWordBreaker();
    ~IWordBreaker();
public:
    STDMETHOD(QueryInterface)	(THIS_ REFIID refiid, VOID **ppv);
    STDMETHOD_(ULONG,AddRef)	(THIS);
    STDMETHOD_(ULONG,Release)	(THIS);

public:
    STDMETHOD(Init)	(THIS_ BOOL fQuery, ULONG ulMaxTokenSize, BOOL *pfLicense);
    STDMETHOD(BreakText) (THIS_ TEXT_SOURCE *pTextSource, IWordSink *pWordSink, IPhraseSink *pPhraseSink);
    STDMETHOD(ComposePhrase) (THIS_ const WCHAR *pwcNoun, ULONG cwcNoun, const WCHAR *pwcModifier,
        ULONG cwcModifier, ULONG ulAttachmentType, WCHAR *pwcPhrase, ULONG *pcwcPhrase);
    STDMETHOD(GetLicenseToUse) (THIS_  const WCHAR **ppwcsLicense);
private:
    UINT             m_uMaxCharNumberPerWord;
    LONG             m_lRefCnt;
    CCHTWordBreaker* m_pcWordBreaker;
    TEXT_SOURCE*     m_pNonChineseTextSource;
    IWordBreaker*    m_pNonChineseWordBreaker;
    CDefWordBreaker* m_pcDefWordBreaker;
    BOOL             m_fIsQueryTime;
};
   
#else
#endif //_CHTBRKR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\lexmgr.cpp ===
#include <windows.h>
#include "lexicon.h"
#include "lexmgr.h"
#include "PropNoun.h"
#include <stdio.h>
#include <imm.h>
#include <stdio.h>

CCHTLexicon::CCHTLexicon()
{
    m_psLexiconHeader = NULL;
    m_pbLexiconBase = NULL;
#ifdef CHINESE_PROP_NAME
    m_pcPropName = NULL;
#endif
    m_sAddInLexicon.dwMaxWordNumber = 0;
    m_sAddInLexicon.dwWordNumber = 0;
    m_sAddInLexicon.psWordData = NULL;
    FillMemory(m_sAddInLexicon.wWordBeginIndex, 
        sizeof(m_sAddInLexicon.wWordBeginIndex), 0);
}

CCHTLexicon::~CCHTLexicon()
{
    DWORD i;
    // Do not build one char word signature
    if (m_psLexiconHeader) {
        for (i = 0 ; i < m_psLexiconHeader->dwMaxCharPerWord; ++i) {
            if (m_sWordInfo[i].pbFirstCharSignature) {
                delete m_sWordInfo[i].pbFirstCharSignature;
			}
            if (m_sWordInfo[i].pbLastCharSignature) {
                delete m_sWordInfo[i].pbLastCharSignature;
			}
		}
	}
#ifdef CHINESE_PROP_NAME
    if (m_pcPropName) {
        delete m_pcPropName;
    }
#endif
    // Free add in lexicon
    if (m_sAddInLexicon.psWordData) {
        for (i = 0; i < m_sAddInLexicon.dwWordNumber; ++i) {
            delete m_sAddInLexicon.psWordData[i].lpwszWordStr;
            m_sAddInLexicon.psWordData[i].lpwszWordStr = NULL;
        }
        delete m_sAddInLexicon.psWordData;
        m_sAddInLexicon.psWordData = NULL;
    }
    m_sAddInLexicon.dwMaxWordNumber = 0;
    m_sAddInLexicon.dwWordNumber = 0;
}
 
BOOL CCHTLexicon::InitData(
    HINSTANCE hInstance)
{
    HRSRC   hResInfo;
    HGLOBAL hResData;
    BOOL    fRet = FALSE;
    TCHAR   tszLexiconResName[MAX_PATH];
    DWORD   i;

    // Init main lexicon
    lstrcpy(tszLexiconResName, TEXT("LEXICON"));
    if (!(hResInfo = FindResource(hInstance, tszLexiconResName, TEXT("BIN")))) {
    } else if (!(hResData = LoadResource(hInstance, hResInfo))) {
    } else if (!(m_pbLexiconBase = (LPBYTE)LockResource(hResData))) {
    } else {
        m_psLexiconHeader = (PSLexFileHeader)m_pbLexiconBase;
        for (i = 0 ; i < m_psLexiconHeader->dwMaxCharPerWord; ++i) {
            m_sWordInfo[i].lpwWordString = (LPWSTR)(m_pbLexiconBase + 
                m_psLexiconHeader->sLexInfo[i].dwWordStringOffset);
            m_sWordInfo[i].pbAttribute = (LPBYTE)(m_pbLexiconBase + 
                m_psLexiconHeader->sLexInfo[i].dwWordAttribOffset);
            m_sWordInfo[i].pwUnicount = (PWORD)(m_pbLexiconBase + 
                m_psLexiconHeader->sLexInfo[i].dwWordCountOffset);
            m_sWordInfo[i].pbTerminalCode = (LPBYTE)(m_pbLexiconBase + 
                m_psLexiconHeader->sLexInfo[i].dwTerminalCodeOffset);
        }
        BuildSignatureData();
        fRet = TRUE;
    }

    // Init alt lexicon
    lstrcpy(tszLexiconResName, TEXT("ALTWORD"));
    if (!(hResInfo = FindResource(hInstance, tszLexiconResName, TEXT("BIN")))) {
    } else if (!(hResData = LoadResource(hInstance, hResInfo))) {
    } else if (!(m_pbAltWordBase = (LPBYTE)LockResource(hResData))) {
    } else {
        m_psAltWordHeader = (PSAltLexFileHeader)m_pbAltWordBase;
        for (i = 0 ; i < m_psAltWordHeader->dwMaxCharPerWord; ++i) {
            m_sAltWordInfo[i].lpwWordString = (LPWSTR)(m_pbAltWordBase + 
                m_psAltWordHeader->sAltWordInfo[i].dwWordStringOffset);
            m_sAltWordInfo[i].pdwGroupID = (PDWORD)(m_pbAltWordBase + 
                m_psAltWordHeader->sAltWordInfo[i].dwWordGroupOffset);
        }
        fRet = TRUE;
    }


#ifdef CHINESE_PROP_NAME
    m_pcPropName = new CProperNoun(hInstance);
    if (m_pcPropName) {
        m_pcPropName->InitData();
    }
#endif

#ifdef _DEBUG
    FILE   *fp;
    DWORD  j;
    WCHAR  wUnicodeString[MAX_CHAR_PER_WORD + 1];
    CHAR   cANSIString[MAX_CHAR_PER_WORD * 2 + 1];
    WORD   wCount;
    fp = fopen("DM.dmp", "wt");
    for (i = 0 ; i < m_psLexiconHeader->dwMaxCharPerWord; ++i) {
        for (j = 0; j < m_psLexiconHeader->sLexInfo[i].dwWordNumber; ++j) {
            if (m_sWordInfo[i].pbAttribute[j] & ATTR_DM) {
                wCount = m_sWordInfo[i].pwUnicount[j];
                if (i == 0) {
                    wUnicodeString[0] = (WORD)(CHT_UNICODE_BEGIN + j);
                } else {
                    CopyMemory(wUnicodeString, &(m_sWordInfo[i].lpwWordString[j * (i + 1)]),
                        sizeof(WCHAR) * (i + 1));
                }
                wUnicodeString[i + 1] = '\0';
                WideCharToMultiByte(950, WC_COMPOSITECHECK, wUnicodeString, i + 1 + 1,
                  cANSIString, sizeof(cANSIString), NULL, NULL);
                fprintf(fp, "%s %d\n", cANSIString, wCount);
            } 
        }
    }
    if (fp) {
        fclose(fp);
    }
    fp = fopen("COMPOUND.dmp", "wt");
    for (i = 0 ; i < m_psLexiconHeader->dwMaxCharPerWord; ++i) {
        for (j = 0; j < m_psLexiconHeader->sLexInfo[i].dwWordNumber; ++j) {
            if (m_sWordInfo[i].pbAttribute[j] & ATTR_COMPOUND) {
                wCount = m_sWordInfo[i].pwUnicount[j];
                if (i == 0) {
                    wUnicodeString[0] = (WORD)(CHT_UNICODE_BEGIN + j);
                } else {
                    CopyMemory(wUnicodeString, &(m_sWordInfo[i].lpwWordString[j * (i + 1)]),
                        sizeof(WCHAR) * (i + 1));
                }
                wUnicodeString[i + 1] = '\0';
                WideCharToMultiByte(950, WC_COMPOSITECHECK, wUnicodeString, i + 1 + 1,
                  cANSIString, sizeof(cANSIString), NULL, NULL);
                fprintf(fp, "%s %d\n", cANSIString, wCount);
            } 
        }
    }
    if (fp) {
        fclose(fp);
    }
#endif
    // Init EUDP to special word
    LoadEUDP();
    
    return fRet;
}

void CCHTLexicon::BuildSignatureData(void)
{
    DWORD i, j, dwWordNumber;
    WORD  wFirstChar, wLastChar;

    for (i = 0; i < MAX_CHAR_PER_WORD; ++i) {
        m_sWordInfo[i].pbFirstCharSignature = NULL;
        m_sWordInfo[i].pbLastCharSignature = NULL;
    }

    // Do not build one char word signature
    for (i = 0 ; i < m_psLexiconHeader->dwMaxCharPerWord; ++i) {
        dwWordNumber = m_psLexiconHeader->sLexInfo[i].dwWordNumber; 
        if (i != 0 && dwWordNumber > WORD_NUM_TO_BUILD_SIGNATURE) {
            m_sWordInfo[i].pbFirstCharSignature = new BYTE[(CHT_UNICODE_END - CHT_UNICODE_BEGIN + 1) / 8 + 1];
            if (NULL == m_sWordInfo[i].pbFirstCharSignature) { continue; }
            FillMemory(m_sWordInfo[i].pbFirstCharSignature, (CHT_UNICODE_END - CHT_UNICODE_BEGIN + 1) / 8, 0); 
            for (j = 0; j < dwWordNumber; ++j) { 
                wFirstChar = m_sWordInfo[i].lpwWordString[(i + 1) * j];
                if (wFirstChar >= CHT_UNICODE_BEGIN) {
                    m_sWordInfo[i].pbFirstCharSignature[(wFirstChar - CHT_UNICODE_BEGIN) / 8] |=
                        (0x00000001 << ((wFirstChar - CHT_UNICODE_BEGIN) % 8));
                }
            }
            m_sWordInfo[i].pbLastCharSignature = new BYTE[(CHT_UNICODE_END - CHT_UNICODE_BEGIN + 1) / 8 + 1];
            if (NULL == m_sWordInfo[i].pbLastCharSignature)  { continue; }
            FillMemory(m_sWordInfo[i].pbLastCharSignature, (CHT_UNICODE_END - CHT_UNICODE_BEGIN + 1) / 8, 0); 
            for (j = 0; j < dwWordNumber; ++j) { 
                wLastChar = m_sWordInfo[i].lpwWordString[(i + 1) * (j + 1) - 1];
                if (wLastChar >= CHT_UNICODE_BEGIN) {
                    m_sWordInfo[i].pbLastCharSignature[(wLastChar - CHT_UNICODE_BEGIN) / 8] |=
                        (0x00000001 << ((wLastChar - CHT_UNICODE_BEGIN) % 8));
                }
            }
        } else {
            m_sWordInfo[i].pbFirstCharSignature = NULL;
            m_sWordInfo[i].pbLastCharSignature = NULL;
        }
    }
}


BOOL CCHTLexicon::GetWordInfo(
    LPCWSTR lpcwString, 
    DWORD   dwLength, 
    PWORD   pwUnicount, 
    PWORD   pwAttrib,
    PBYTE   pbTerminalCode)
{
    BOOL fRet;
    BYTE bMainLexAttrib;

    fRet = GetMainLexiconWordInfo(lpcwString, dwLength, pwUnicount, 
        &bMainLexAttrib, pbTerminalCode);
    *pwAttrib = bMainLexAttrib;
    if (fRet) { goto _exit; }

#ifdef CHINESE_PROP_NAME    
    if (dwLength == 3) {
        if (m_pcPropName->IsAChineseName(lpcwString, dwLength)) {
            *pbTerminalCode = ' ';
            *pwAttrib = ATTR_RULE_WORD;
            *pwUnicount = 100;
            fRet = TRUE;
            goto _exit;
        }
    }
#endif
    fRet = GetAddInWordInfo(lpcwString, dwLength, pwUnicount, 
        pwAttrib, pbTerminalCode);    
_exit:
    return fRet;
}

BOOL CCHTLexicon::GetMainLexiconWordInfo(
    LPCWSTR lpcwString, 
    DWORD   dwLength, 
    PWORD   pwUnicount, 
    PBYTE   pbAttrib,
    PBYTE   pbTerminalCode)
{
    INT    nBegin, nEnd, nMid;
    INT    nCmp;
    BOOL   fRet = FALSE;
    LPWSTR lpwLexString;
    DWORD  dwFirstCharIndex, dwLastCharIndex;

    if (dwLength > m_psLexiconHeader->dwMaxCharPerWord) { goto _exit; }
    
    if (lpcwString[0] < CHT_UNICODE_BEGIN || lpcwString[0] > CHT_UNICODE_END) {
        goto _exit; 
    }
    dwFirstCharIndex = lpcwString[0] - CHT_UNICODE_BEGIN;

    if (dwLength == 1) {
        *pwUnicount = m_sWordInfo[dwLength - 1].pwUnicount[dwFirstCharIndex];
        *pbAttrib = m_sWordInfo[dwLength - 1].pbAttribute[dwFirstCharIndex];
        *pbTerminalCode = m_sWordInfo[dwLength - 1].pbTerminalCode[dwFirstCharIndex];
        fRet = TRUE;         
    } else {
        // Check signature first
        if (m_sWordInfo[dwLength - 1].pbFirstCharSignature) {
            if (!(m_sWordInfo[dwLength - 1].pbFirstCharSignature[dwFirstCharIndex / 8] &
                (0x00000001 << (dwFirstCharIndex % 8)))) { goto _exit; }
        }
        if (lpcwString[dwLength - 1] >= CHT_UNICODE_BEGIN && lpcwString[dwLength - 1] <= CHT_UNICODE_END) {
            if (m_sWordInfo[dwLength - 1].pbLastCharSignature) {
                dwLastCharIndex = lpcwString[dwLength - 1] - CHT_UNICODE_BEGIN;
                if (!(m_sWordInfo[dwLength - 1].pbLastCharSignature[dwLastCharIndex / 8] &
                    (0x00000001 << (dwLastCharIndex % 8)))) { goto _exit; }
            }
        }
        nBegin = 0;
        nEnd = m_psLexiconHeader->sLexInfo[dwLength - 1].dwWordNumber - 1;
        lpwLexString = m_sWordInfo[dwLength - 1].lpwWordString;
        DWORD dwCompByteNum = sizeof(WCHAR) * dwLength;
        while (nBegin <= nEnd) {
            nMid = (nBegin + nEnd) / 2; 
            nCmp = memcmp(&(lpwLexString[nMid * dwLength]), lpcwString, dwCompByteNum);
            if (nCmp > 0) {
                nEnd = nMid - 1;
            } else if (nCmp < 0) {
                nBegin = nMid + 1;
            } else {
                *pwUnicount = m_sWordInfo[dwLength - 1].pwUnicount[nMid];
                *pbAttrib = m_sWordInfo[dwLength - 1].pbAttribute[nMid];
                *pbTerminalCode = m_sWordInfo[dwLength - 1].pbTerminalCode[nMid];
                fRet = TRUE;
                break;
            }
        }
    }
_exit:
    if (!fRet) {
        *pwUnicount = 0; 
        *pbAttrib = 0;
        *pbTerminalCode = ' ';
    }
    return fRet;
}


// Load EUDP
int CALLBACK EUDPCountA(
    LPCSTR  lpcszReading,
    DWORD   dwStyle,
    LPCSTR  lpcszString,
    LPVOID  lpvData)
{            
    PSAddInLexicon psAddInLexicon;

    if (lstrlenA(lpcszString) / sizeof(WCHAR) <= MAX_CHAR_PER_WORD) {
        psAddInLexicon = (PSAddInLexicon)lpvData;
        ++psAddInLexicon->dwWordNumber;
    }
    return 1;
}
int CALLBACK EUDPCountW(
    LPCWSTR lpcwszReading,
    DWORD   dwStyle,
    LPCWSTR lpcwszString,
    LPVOID  lpvData)
{
    PSAddInLexicon psAddInLexicon;
    
    if (lstrlenW(lpcwszString) <= MAX_CHAR_PER_WORD) {            
        psAddInLexicon = (PSAddInLexicon)lpvData;
        ++psAddInLexicon->dwWordNumber;
    }
    return 1;
}
int CALLBACK EUDPLoadA(
    LPCSTR  lpcszReading,
    DWORD   dwStyle,
    LPCSTR  lpcszString,
    LPVOID  lpvData)
{
    PSAddInLexicon psAddInLexicon;
    WORD           wStrLen;

    wStrLen = (WORD)lstrlenA(lpcszString);
    if (wStrLen / sizeof(WCHAR) <= MAX_CHAR_PER_WORD) {
         psAddInLexicon = (PSAddInLexicon)lpvData;
         psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].lpwszWordStr = new WORD[wStrLen / sizeof(WCHAR) + 1]; // zero end
         if (psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].lpwszWordStr) {
             MultiByteToWideChar(950, MB_PRECOMPOSED, lpcszString, wStrLen  + 1, psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].lpwszWordStr, wStrLen / sizeof(WCHAR) + 1);
             psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].wAttrib = ATTR_EUDP_WORD;     
             psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].wLen = wStrLen / sizeof(WCHAR);
             ++psAddInLexicon->dwWordNumber;
         }
    }
    return 1;
}
int CALLBACK EUDPLoadW(
    LPCWSTR lpcwszReading,
    DWORD   dwStyle,
    LPCWSTR lpcwszString,
    LPVOID  lpvData)
{            
   PSAddInLexicon psAddInLexicon;
   WORD           wStrLen;

   wStrLen = (WORD)lstrlenW(lpcwszString);
   if (wStrLen <= MAX_CHAR_PER_WORD) {
       psAddInLexicon = (PSAddInLexicon)lpvData;
       psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].lpwszWordStr = new WORD[wStrLen + 1];
       if (psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].lpwszWordStr) {
           CopyMemory(psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].lpwszWordStr, lpcwszString, (wStrLen + 1) * sizeof(WCHAR)); 
           psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].wAttrib = ATTR_EUDP_WORD;
           psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].wLen = wStrLen;
           ++psAddInLexicon->dwWordNumber;
       }
   }

   return 1;
}

int __cdecl CompSWordData(
    const void *arg1,
    const void *arg2)
{
    PSWordData psWordData1, psWordData2;
    
    psWordData1 = (PSWordData)arg1;
    psWordData2 = (PSWordData)arg2;

    if (psWordData1->wLen < psWordData2->wLen) {
        return -1;
    } else if (psWordData1->wLen > psWordData2->wLen) {
        return 1;
    } else {
        return memcmp(psWordData1->lpwszWordStr, 
            psWordData2->lpwszWordStr, psWordData1->wLen * sizeof(WCHAR));
    }

}

void CCHTLexicon::LoadEUDP(void)
{
    DWORD i;

    m_sAddInLexicon.dwWordNumber = 0;
    m_sAddInLexicon.dwMaxWordNumber = 0;
    m_sAddInLexicon.psWordData = NULL;

    OSVERSIONINFOA OSVerInfo;
    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionExA(&OSVerInfo);
    if (OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        ImmEnumRegisterWordW(HKL((ULONG_PTR) 0xE0080404), EUDPCountW, NULL,
            IME_REGWORD_STYLE_USER_PHRASE, NULL, &m_sAddInLexicon);
    } else {
        ImmEnumRegisterWordA(HKL((ULONG_PTR) 0xE0080404), EUDPCountA, NULL,
            IME_REGWORD_STYLE_USER_PHRASE, NULL, &m_sAddInLexicon);    
    }
    if (m_sAddInLexicon.dwWordNumber) {
        m_sAddInLexicon.dwMaxWordNumber = m_sAddInLexicon.dwWordNumber + EUDP_GROW_NUMBER;
        m_sAddInLexicon.psWordData = new SWordData[m_sAddInLexicon.dwMaxWordNumber];
        m_sAddInLexicon.dwWordNumber = 0;
        if (OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            ImmEnumRegisterWordW(HKL((ULONG_PTR) 0xE0080404), EUDPLoadW, NULL,
                IME_REGWORD_STYLE_USER_PHRASE, NULL, &m_sAddInLexicon);
        } else {
            ImmEnumRegisterWordA(HKL((ULONG_PTR) 0xE0080404), EUDPLoadA, NULL,
                IME_REGWORD_STYLE_USER_PHRASE, NULL, &m_sAddInLexicon);            
        }
        qsort(m_sAddInLexicon.psWordData, m_sAddInLexicon.dwWordNumber,
            sizeof(SWordData), CompSWordData);
        for (i = 0; i < m_sAddInLexicon.dwWordNumber; ++i) {
            ++m_sAddInLexicon.wWordBeginIndex[m_sAddInLexicon.psWordData[i].wLen - 1];
        }
        WORD wCount = m_sAddInLexicon.wWordBeginIndex[0];
        for (i = 1; i <= MAX_CHAR_PER_WORD; ++i) {
            WORD wTemp = m_sAddInLexicon.wWordBeginIndex[i];
            m_sAddInLexicon.wWordBeginIndex[i] = wCount;
            wCount += wTemp;
        }
    } else {
        m_sAddInLexicon.dwMaxWordNumber = 0;
    }
}

// Add AP word
BOOL CCHTLexicon::AddInLexiconInsert(
    LPCWSTR lpcwszWordStr,
    WORD    wAttrib)
{
    BOOL    fRet = FALSE;
    WORD    wStrLen, i, j;
    INT     nIndex;

    wStrLen = (WORD)lstrlenW(lpcwszWordStr);
    if (wStrLen > MAX_CHAR_PER_WORD) { goto _exit; }
    // if exit, just change it's attrib;
    // Be carefully, EUDP > Error word
    if ((nIndex = GetAddInWordInfoIndex(lpcwszWordStr, wStrLen)) != -1) {
        if (m_sAddInLexicon.psWordData[nIndex].wAttrib == ATTR_EUDP_WORD) {
        } else { 
            m_sAddInLexicon.psWordData[nIndex].wAttrib = wAttrib;
        }
        goto _exit;
    }
    // Enlarge space
    if (m_sAddInLexicon.dwMaxWordNumber == m_sAddInLexicon.dwWordNumber) {
        PSWordData psTempWordData;
        psTempWordData = new SWordData [m_sAddInLexicon.dwMaxWordNumber + EUDP_GROW_NUMBER]; 
        if (!psTempWordData) { goto _exit; }
        CopyMemory(psTempWordData, m_sAddInLexicon.psWordData,
            m_sAddInLexicon.dwWordNumber * sizeof(SWordData));
        delete [] m_sAddInLexicon.psWordData;
        m_sAddInLexicon.psWordData = psTempWordData;
        m_sAddInLexicon.dwMaxWordNumber += EUDP_GROW_NUMBER;
    }
    // Insert word
    for (i = m_sAddInLexicon.wWordBeginIndex[wStrLen - 1]; i < m_sAddInLexicon.wWordBeginIndex[wStrLen]; ++i) {
        if (memcmp(lpcwszWordStr, m_sAddInLexicon.psWordData[i].lpwszWordStr,
            wStrLen * sizeof(WCHAR)) < 0) {
             break;
        }
    }
    for (j = (WORD)m_sAddInLexicon.dwWordNumber; j > i; --j) { 
        m_sAddInLexicon.psWordData[j] = m_sAddInLexicon.psWordData[j - 1];
    }
    m_sAddInLexicon.psWordData[i].lpwszWordStr = new WORD[wStrLen + 1];
    CopyMemory(m_sAddInLexicon.psWordData[i].lpwszWordStr, lpcwszWordStr, 
        (wStrLen + 1) * sizeof(WORD));
    m_sAddInLexicon.psWordData[i].wAttrib = wAttrib;
    m_sAddInLexicon.psWordData[i].wLen = wStrLen;
    ++m_sAddInLexicon.dwWordNumber;
    for (i = wStrLen; i <= MAX_CHAR_PER_WORD; ++i) {
        ++m_sAddInLexicon.wWordBeginIndex[i];
    }
    fRet =  TRUE;
_exit:
#ifdef _DEBUG
    for (i = 1; i <= MAX_CHAR_PER_WORD; ++i) {
        for (j = m_sAddInLexicon.wWordBeginIndex[i - 1]; j < m_sAddInLexicon.wWordBeginIndex[i]; ++j) {
            if (m_sAddInLexicon.psWordData[j].wLen != i) {
                MessageBox(0, TEXT("Error string length"), TEXT("Error"), MB_OK);
            }
            if (j == m_sAddInLexicon.wWordBeginIndex[i] - 1) {
            } else if (memcmp(m_sAddInLexicon.psWordData[j].lpwszWordStr,
                m_sAddInLexicon.psWordData[j + 1].lpwszWordStr, 
                m_sAddInLexicon.psWordData[j].wLen * sizeof(WORD)) >= 0) {
                MessageBox(0, TEXT("Error string order"), TEXT("Error"), MB_OK);
            } else {
            }
        }
    }
#endif
    return fRet;
}

BOOL CCHTLexicon::GetAddInWordInfo(
    LPCWSTR lpcwString, 
    DWORD   dwLength, 
    PWORD   pwUnicount, 
    PWORD   pwAttrib,
    PBYTE   pbTerminalCode)
{
    BOOL   fRet = FALSE;
    INT    nIndex;

    if (dwLength > MAX_CHAR_PER_WORD) { goto _exit; }
    nIndex = GetAddInWordInfoIndex(lpcwString, dwLength);
    if (nIndex == -1) { goto _exit; }

    if (pwUnicount) {
        *pwUnicount = 10000;
    } 
    if (pwAttrib) {
        *pwAttrib = m_sAddInLexicon.psWordData[nIndex].wAttrib;
    }
    if (pbTerminalCode) {
        *pbTerminalCode = ' ';
    }
    fRet = TRUE;
_exit:
    return fRet;
}

// return -1 if not find
INT CCHTLexicon::GetAddInWordInfoIndex(
    LPCWSTR lpcwString, 
    DWORD   dwLength)
{
    INT  nRet = -1;
    INT  nBegin, nEnd, nMid;
    INT  nCmp;

    if (dwLength > MAX_CHAR_PER_WORD) { goto _exit; }
    if (m_sAddInLexicon.wWordBeginIndex[dwLength - 1] == m_sAddInLexicon.wWordBeginIndex[dwLength]) {
        goto _exit;
    }
    nBegin = m_sAddInLexicon.wWordBeginIndex[dwLength - 1];
    nEnd = m_sAddInLexicon.wWordBeginIndex[dwLength] - 1;
    while (nBegin <= nEnd) {
        nMid = (nBegin + nEnd) / 2; 
        nCmp = memcmp(m_sAddInLexicon.psWordData[nMid].lpwszWordStr,
            lpcwString, dwLength * sizeof(WCHAR));
        if (nCmp > 0) {
            nEnd = nMid - 1;
        } else if (nCmp < 0) {
            nBegin = nMid + 1;
        } else {
            nRet = nMid;
            break;
        }
    }
_exit:
    return nRet;
}



DWORD CCHTLexicon::GetAltWord(
    LPCWSTR   lpcwString,
    DWORD     dwLength,
    LPWSTR*   lppwAltWordBuf)
{
    INT    nBegin, nEnd, nMid;
    INT    nCmp;
    DWORD  dwRet = 0;
    LPWSTR lpwAltWordString;
    DWORD  dwGroupID;

    if (dwLength > m_psAltWordHeader->dwMaxCharPerWord) { goto _exit; }

    nBegin = 0;
    nEnd = m_psAltWordHeader->sAltWordInfo[dwLength - 1].dwWordNumber - 1;
    lpwAltWordString = m_sAltWordInfo[dwLength - 1].lpwWordString;
    DWORD dwCompByteNum;
    dwCompByteNum = sizeof(WCHAR) * dwLength;
    while (nBegin <= nEnd) {
            nMid = (nBegin + nEnd) / 2; 
            nCmp = memcmp(&(lpwAltWordString[nMid * dwLength]), lpcwString, dwCompByteNum);
            if (nCmp > 0) {
                nEnd = nMid - 1;
            } else if (nCmp < 0) {
                nBegin = nMid + 1;
            } else {
                dwGroupID = m_sAltWordInfo[dwLength - 1].pdwGroupID[nMid];
                // Fill AltWord
                *lppwAltWordBuf = new WCHAR[dwLength + 1];
                if (*lppwAltWordBuf) {
                    for (DWORD i = 0; i < m_psAltWordHeader->sAltWordInfo[dwLength - 1].dwWordNumber; ++i) {
                        if (i != (DWORD)nMid && m_sAltWordInfo[dwLength - 1].pdwGroupID[i] == dwGroupID) {
                            CopyMemory((LPVOID)*lppwAltWordBuf, 
                                (LPVOID)&(m_sAltWordInfo[dwLength - 1].lpwWordString[i * dwLength]), 
                                sizeof(WCHAR) * dwLength);
                            (*lppwAltWordBuf)[dwLength] = NULL;
                            ++dwRet;
                            goto _exit;
                        }
                    }
                }
                break;
            }
    }
_exit:
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\propnoun.h ===
#ifndef __PROPER_NOUN_H__
#define __PROPER_NOUN_H__

#define NAME_LENGTH                     (3)
#define FL_PROPER_NAME_THRESHOLD        (0.0005 * 0.0005)
#define FL_DEFAULT_CHAR_PROBABILITY     (0.00005)

typedef struct {
    DWORD dwUnicode;
    FLOAT flProbability;
} CharProb, *PCharProb;

typedef struct {
    WORD wPrevUnicode;
    WORD wNextUnicode;
} EngName, *PEngName;

typedef struct {
    DWORD dwTotalEngUnicodeNum;
    DWORD dwTotalEngNamePairNum;
    PWORD pwUnicode;
    PEngName pEngNamePair;
} EngNameData, *PEngNameData;


class CProperNoun {
public:
    CProperNoun(HINSTANCE hInstance);
    ~CProperNoun();

    BOOL InitData();

    BOOL IsAProperNoun(LPWSTR lpwszChar, UINT uCount);
    BOOL IsAChineseName(LPCWSTR lpcwszChar, UINT uCount);
    BOOL IsAEnglishName(LPCWSTR lpcwszChar, UINT uCount);

private:
    friend int __cdecl CharCompare(const void *item1, const void *item2);
    friend int __cdecl EngNameCompare(const void *item1, const void *item2);

    DOUBLE      m_dProperNameThreshold;
    PCharProb   m_pCharProb;
    DWORD       m_dwTotalCharProbNum;

    PEngNameData m_pEngNameData;

    static WCHAR m_pwszSurname[][3];
    static DWORD m_dwTotalSurnameNum;

    HANDLE      m_hProcessHeap;
    HINSTANCE   m_hInstance;
};

typedef CProperNoun * PCProperNoun;

#else

#endif  //  __PROPER_NOUN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\propnoun.cpp ===
#include <windows.h>
#include <assert.h>
#include "PropNoun.H"

int __cdecl CharCompare(
    const void *item1,
    const void *item2)
{
    PCharProb pChar1 = (PCharProb) item1;
    PCharProb pChar2 = (PCharProb) item2;
    
    if (pChar1->dwUnicode > pChar2->dwUnicode) {
        return 1;
    } else if (pChar1->dwUnicode < pChar2->dwUnicode) {
        return -1;
    } else {
        return 0;
    }
}

int __cdecl UnicodeCompare(
    const void *item1,
    const void *item2)
{
    int nSize1 = lstrlenW((LPWSTR) item1) * sizeof(WCHAR),
        nSize2 = lstrlenW((LPWSTR) item2) * sizeof(WCHAR);
    return memcmp(item1, item2, nSize1 > nSize2 ? nSize1 : nSize2);
}

int __cdecl EngNameCompare(
    const void *item1,
    const void *item2)
{
    PEngName p1 = (PEngName) item1;
    PEngName p2 = (PEngName) item2;

    if (p1->wPrevUnicode > p2->wPrevUnicode) {
        return 1;
    } else if (p1->wPrevUnicode < p2->wPrevUnicode) {
        return -1;
    } else {
        if (p1->wNextUnicode > p2->wNextUnicode) {
            return 1;
        } else if (p1->wNextUnicode < p2->wNextUnicode) {
            return -1;
        } else {
            return 0;
        }
    }
}

CProperNoun::CProperNoun(
    HINSTANCE hInstance) :
    m_dProperNameThreshold(FL_PROPER_NAME_THRESHOLD),
    m_pCharProb(NULL),
    m_dwTotalCharProbNum(0),
    m_pEngNameData(NULL),
    m_hProcessHeap(0),
    m_hInstance(hInstance)
{
}

CProperNoun::~CProperNoun()
{
}

BOOL CProperNoun::InitData()
{
    BOOL fRet = FALSE;
    HRSRC hResource;
    HGLOBAL hGlobal;

    m_hProcessHeap = GetProcessHeap();

    //  Find resource
    hResource = FindResource(m_hInstance, TEXT("CNAME"), TEXT("BIN"));
    if (!hResource) { goto _exit; }

    //  Load resource
    hGlobal = LoadResource(m_hInstance, hResource);
    if (!hGlobal) { goto _exit; }

    m_pCharProb = (PCharProb) LockResource(hGlobal);
    if (!m_pCharProb) { goto _exit; }
    m_dwTotalCharProbNum = SizeofResource(m_hInstance, hResource) / sizeof(CharProb);
/*
    //  Find resource
    hResource = FindResource(m_hInstance, TEXT("ENAME"),
        TEXT("BIN"));
    if (!hResource) { goto _exit; }

    //  Load resource
    hGlobal = LoadResource(m_hInstance, hResource);
    if (!hGlobal) { goto _exit; }

    m_pEngNameData = (PEngNameData) LockResource(hGlobal);
    m_pEngNameData->pwUnicode = (PWORD) ((PBYTE) m_pEngNameData +
        sizeof(m_pEngNameData->dwTotalEngUnicodeNum) +
        sizeof(m_pEngNameData->dwTotalEngNamePairNum));
    m_pEngNameData->pEngNamePair = (PEngName) ((PBYTE) m_pEngNameData +
        sizeof(m_pEngNameData->dwTotalEngUnicodeNum) +
        sizeof(m_pEngNameData->dwTotalEngNamePairNum) +
        sizeof(m_pEngNameData->pwUnicode[0]) * m_pEngNameData->dwTotalEngUnicodeNum);

//    m_pEngName = (PEngName) LockResource(hGlobal);
//    m_dwTotalEngNameNum = SizeofResource(m_hInstance, hResource) / sizeof(EngName);
*/
    qsort(m_pwszSurname, m_dwTotalSurnameNum, sizeof(m_pwszSurname[0]), UnicodeCompare);

    fRet = TRUE;

_exit:

    return fRet;
}

BOOL CProperNoun::IsAProperNoun(
    LPWSTR lpwszChar,
    UINT uCount)
{
    return (IsAChineseName(lpwszChar, uCount) || IsAEnglishName(lpwszChar, uCount));
}

BOOL CProperNoun::IsAChineseName(
    LPCWSTR lpcwszChar,
    UINT    uCount)
{
    static WCHAR wszChar[3] = { NULL };
    PWCHAR pwsResult;

    wszChar[0] = lpcwszChar[0];

    //  Find surname
    if (pwsResult = (PWCHAR) bsearch(wszChar, m_pwszSurname, m_dwTotalSurnameNum, sizeof(m_pwszSurname[0]),
        UnicodeCompare)) {
        FLOAT flProbability = 1;
        PCharProb pCharProb;
        CharProb CProb;

        //  Calculate probability to be a proper noun
        for (UINT i = 1; i < uCount; ++i) {
            CProb.dwUnicode = lpcwszChar[i];
            if (pCharProb = (PCharProb) bsearch(&CProb, m_pCharProb,
                m_dwTotalCharProbNum, sizeof(m_pCharProb[0]), CharCompare)) {
                flProbability *= pCharProb->flProbability;
            } else {
                flProbability *= (FLOAT) FL_DEFAULT_CHAR_PROBABILITY;
            }
        }

        if (flProbability >= m_dProperNameThreshold) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL CProperNoun::IsAEnglishName(
    LPCWSTR lpwszChar,
    UINT uCount)
{
    static EngName Name;

    Name.wPrevUnicode = lpwszChar[0];
    Name.wNextUnicode = lpwszChar[uCount - 1];

    if (bsearch(&Name, m_pEngNameData->pEngNamePair, m_pEngNameData->dwTotalEngUnicodeNum, sizeof(EngName), EngNameCompare)) {
        return TRUE;
    }

    return FALSE;
}

WCHAR CProperNoun::m_pwszSurname[][3] = {
    L"B",
    L"R",
    L"_",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"C",
    L"K",
    L"T",
    L"]",
    L"q",
    L"v",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"V",
    L"w",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"E",
    L"d",
    L"f",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"H",
    L"L",
    L"f",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"P",
    L"s",
    L"u",
    L"x",
    L"}",
    L"",
    L"",
    L"",
    L"L",
    L"Z",
    L"k",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"J",
    L"\\",
    L"",
    L"",
    L"",
    L"I",
    L"R",
    L"_",
    L"d",
    L"h",
    L"q",
    L"x",
    L"",
    L"J",
    L"S",
    L"]",
    L"p",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"L",
    L"V",
    L"]",
    L"c",
    L"u",
    L"}",
    L"",
    L"",
    L"",
    L"",
    L"Z",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"K",
    L"q",
    L"|",
    L"}",
    L"",
    L"",
    L"O",
    L"Z",
    L"d",
    L"h",
    L"i",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"\\",
    L"s",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"^",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"J",
    L"q",
    L"{",
    L"",
    L"",
    L"",
    L"O",
    L"P",
    L"R",
    L"d",
    L"k",
    L"s",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"q",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"Q",
    L"l",
    L"p",
    L"",
    L"",
    L"a",
    L"",
    L"",
    L"",
    L"p",
    L"u",
    L"",
    L"",
    L"",
    L"B",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"G",
    L"H",
    L"|",
    L"",
    L"",
    L"",
    L"P",
    L"c",
    L"p",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"F",
    L"N",
    L"R",
    L"d",
    L"j",
    L"s",
    L"",
    L"",
    L"",
    L"t",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"C",
    L"Q",
    L"e",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"Y",
    L"u",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"U",
    L"",
    L"",
    L"e",
    L"s",
    L"",
    L"\\",
    L"k"
};

DWORD CProperNoun::m_dwTotalSurnameNum = sizeof(m_pwszSurname) / sizeof(m_pwszSurname[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\rulelex.h ===
#ifndef _RULE_LEXICON_H_
#define _RULE_LEXICON_H_

class CRuleLexicon {
public:
    CRuleLexicon();
    ~CRuleLexicon();

    BOOL IsAWord(LPCWSTR lpsString, INT nLength);
};

typedef CRuleLexicon *PCRuleLexicon;

#else

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\rulelex.cpp ===
#include <windows.h>
#include "scntable.h"
#include "RuleLex.H"

CRuleLexicon::CRuleLexicon()
{
}

CRuleLexicon::~CRuleLexicon()
{
}

BOOL CRuleLexicon::IsAWord(
    LPCWSTR lpwszString,
    INT nLength)
{
    DFAState State;
    WCHAR wc;
    INT nCurrPos = 0;
    Transition t;

    do {
        State = g_nStartState;
        while (nCurrPos <= nLength) {
            if (nCurrPos == nLength) {
                ++nCurrPos;
                wc = ' ';
            } else {
                wc = lpwszString[nCurrPos++];
            }
            if (!(g_uFirstChar <= wc && wc <= g_uLastChar)) {
                return FALSE;
            }
            t = g_sMinimalDFA[State - 1][g_CharClass[wc - g_uFirstChar] - 1];
            switch(t.Action) {
            case Move:
                if (0 == t.NextState) {
                    return FALSE;
                } else {
                    State = t.NextState;
                }
                break;

            case Error:
                return FALSE;
                break;

            case Halt:
                if (t.Major && (nCurrPos > nLength)) {
                    return TRUE;
                } else {
                    return FALSE;
                }
                break;

            default:
                return FALSE;
            }
        }
    } while (nCurrPos <= nLength);

    if (nCurrPos == nLength) {
        return TRUE;
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\lexmgr.h ===
#ifndef __LEXMGR_H_
#define __LEXMGR_H_

#define WORD_NUM_TO_BUILD_SIGNATURE     0
#define IME_REGWORD_STYLE_USER_PHRASE   (IME_REGWORD_STYLE_USER_FIRST + 0)
#define EUDP_GROW_NUMBER                30 

class CProperNoun;

// note if use sizeof(), struct must be 8 bytes alignment. 
typedef struct tagSWordInfo {
    LPWSTR  lpwWordString;
    PWORD   pwUnicount;
    PBYTE   pbAttribute;
    PBYTE   pbTerminalCode;
    PBYTE   pbFirstCharSignature;
    PBYTE   pbLastCharSignature;
} SWordInfo, *PSWordInfo;

// note if use sizeof(), struct must be 8 bytes alignment. 
typedef struct tagSWordData {
    LPWSTR    lpwszWordStr;
    WORD      wAttrib;
    WORD      wLen;
} SWordData, *PSWordData;

typedef struct tagSAddInLexicon {
    DWORD       dwWordNumber;
    DWORD       dwMaxWordNumber;
    PSWordData  psWordData;
    WORD        wWordBeginIndex[MAX_CHAR_PER_WORD + 1];
} SAddInLexicon, *PSAddInLexicon;

typedef struct tagSAltWordInfo {
    LPWSTR  lpwWordString;
    PDWORD  pdwGroupID;
} SAltWordInfo, *PSAltWordInfo;

class CCHTLexicon {
public:
    CCHTLexicon();
    ~CCHTLexicon();
    BOOL InitData(HINSTANCE hInstance);

    BOOL GetWordInfo(LPCWSTR lpcwString, DWORD dwLength, PWORD pwUnicount,
        PWORD pwAttrib, PBYTE pbTerminalCode);
    BOOL AddInLexiconInsert(LPCWSTR lpcwEUDPStr, WORD wAttrib);
    DWORD GetAltWord(LPCWSTR lpcwString, DWORD dwLength, LPWSTR* lppwAltWordBuf);
private:
    void LoadEUDP(void);
    void BuildSignatureData(void);
    BOOL GetMainLexiconWordInfo(LPCWSTR lpcwString, DWORD dwLength, PWORD pwUnicount, PBYTE pbAttrib, PBYTE pbTerminalCode);
    BOOL GetAddInWordInfo(LPCWSTR lpcwString, DWORD dwLength, PWORD pwUnicount, PWORD pwAttrib, PBYTE pbTerminalCode);
    INT  GetAddInWordInfoIndex(LPCWSTR lpcwString, DWORD dwLength);
    BOOL GetAPLexiconWordInfo(LPCWSTR lpcwString, DWORD dwLength, PWORD pwUnicount, PWORD pwAttrib, PBYTE pbTerminalCode, PSAddInLexicon psAPLexicon);
private:
    PSLexFileHeader  m_psLexiconHeader;
    PBYTE            m_pbLexiconBase;
#ifdef CHINESE_PROP_NAME
    CProperNoun*     m_pcPropName;
#endif
    SWordInfo        m_sWordInfo[MAX_CHAR_PER_WORD];
    // special: for EUDP and AP's word
    SAddInLexicon    m_sAddInLexicon;
    // Alternative word
    PBYTE              m_pbAltWordBase;
    PSAltLexFileHeader m_psAltWordHeader;
    SAltWordInfo       m_sAltWordInfo[MAX_CHAR_PER_WORD];
};

typedef CCHTLexicon *PCCHTLexicon;

#else
#endif //__LEXMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\regcom.cpp ===
#include <windows.h>
#include "rulelex.h"
#include "lexicon.h"
#include "LexMgr.h"
#include "chtbrkr.h"
#include "IWBrKr.h"

TCHAR tszLangSpecificKey[] = TEXT("System\\CurrentControlSet\\Control\\ContentIndex\\Language\\Chinese_Traditional");

HRESULT COMRegister(
    BOOL fRegister)
{
    HKEY hKey;
    WCHAR tszCLSID[MAX_PATH];
    TCHAR tszBuf[MAX_PATH * 2 + 1];
    HRESULT hr = S_OK;

//HKEY_CLASSES_ROOT\\CLSID\\CLSID_CHTBRKR, {E1B6B375-3412-11D3-A9E2-00AA0059F9F6};
    if (0 == StringFromGUID2(CLSID_CHTBRKR, tszCLSID, sizeof(tszCLSID) / sizeof(TCHAR))) {
        hr = S_FALSE;
        goto _exit;
    }
    lstrcpyn(tszBuf, TEXT("CLSID\\"), sizeof(tszBuf) / sizeof(TCHAR));
    wcsncat(tszBuf, tszCLSID, sizeof(tszBuf) / sizeof(TCHAR) - lstrlen(TEXT("CLSID\\")) - 1);
    if (fRegister) {
        wcsncat(tszBuf, TEXT("\\InprocServer32"), sizeof(tszBuf) / sizeof(TCHAR) - 1);
        if (RegCreateKey(HKEY_CLASSES_ROOT, tszBuf, &hKey) != ERROR_SUCCESS) {
            hr = S_FALSE;
            goto _exit;
        }
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (LPBYTE)g_tszModuleFileName, 
        lstrlen(g_tszModuleFileName) * sizeof(TCHAR));
        RegCloseKey(hKey);
    } else {
        RegDeleteKey(HKEY_CLASSES_ROOT, tszBuf);
    }

// HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\ContentIndex\\
//     Language\\Chinese_Traditional
/*
    if (RegCreateKey(HKEY_LOCAL_MACHINE, tszLangSpecificKey, &hKey) != ERROR_SUCCESS) {
        hr = S_FALSE;
        goto _exit;        
    }
    if (fRegister) {
        RegSetValueEx(hKey, TEXT("WBreakerClass"), 0, REG_SZ, (LPBYTE)tszCLSID, 
            lstrlen(tszCLSID) * sizeof (TCHAR));
    } else {
        RegDeleteValue(hKey, TEXT("WBreakerClass")); 
    }
*/
_exit:
    return hr;

}

STDAPI DllRegisterServer(void)
{
    return COMRegister(TRUE);
}

STDAPI DllUnregisterServer(void) 
{
    return COMRegister(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\wordbrkr.h ===
#ifndef YYSTYPE
#define YYSTYPE int
#endif
#define	tSubZero	258
#define	tDegree	259
#define	tSection	260
#define	tTunnel	261
#define	tLane	262
#define	tDash	263
#define	tNumber	264
#define	tFloor	265
#define	tMinute	266
#define	tSecond	267
#define	tThis	268
#define	tNoise	269
#define	tDay1	270
#define	tDay2	271
#define	tYear	272
#define	tFirst	273
#define	tMonth	274
#define	tMonthly	275
#define	tHour1	276
#define	tHour2	277
#define	tHour3	278
#define	tQuarter	279
#define	tAny	280
#define	tOther1	281
#define	tOther2	282
#define	tRemain	283
#define	tOf	284
#define	tHalf	285
#define	tTh	286
#define	tThat	287
#define	tClass	288
#define	tAtMost	289
#define	tAtLeast	290
#define	tSeveral	291
#define	tSquare	292
#define	tCube	293
#define	tOver	294
#define	tAnd	295
#define	tWeakStrong	296
#define	tMoreThan1	297
#define	tMoreThan2	298
#define	tMoreThan3	299
#define	tNo	300
#define	tNot	301
#define	tOn	302
#define	tDesc	303
#define	tPnm	304
#define	tNdabe	305
#define	tNdaac	306
#define	tNdaad	307
#define	tNdaas	308
#define	tNdabb	309
#define	tNdabd1	310
#define	tNdabf	311
#define	tTpnm	312
#define	tWq	313
#define	tQq	314
#define	tDq	315
#define	tPq	316
#define	tDd	317
#define	tOs	318
#define	tUd	319
#define	tPn	320
#define	tEach	321
#define	tDs	322
#define	tTmp	323
#define	tOther	324
#define	tTdm10_	325
#define	tFirst1	326
#define	tFirst2	327
#define	tTdm4_	328
#define	tEach1	329
#define	tEach2	330
#define	tTdm2_3_	331
#define	tTdm6_	332
#define	tHour	333
#define	tAt	334
#define	tMore	335
#define	tDot	336
#define	tError	337


extern YYSTYPE yylval;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\cht2\srcs\scntable.h ===
#ifndef _SCANNER_TABLE_H_
#define _SCANNER_TABLE_H_

typedef INT DFAState;
typedef INT TokenNum;
typedef WCHAR CharClass;
typedef enum { Invalid_DFAAction, Move, Halt, Error } DFAAction;
typedef struct {
    DFAAction Action;
    DFAState NextState;
    TokenNum Major;
} Transition, *PTransition;

const INT g_nNumClasses = 66;

Transition g_sMinimalDFA [][g_nNumClasses] = {

    { { Move ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },
    { Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },
    { Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },
    { Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 }},

    { { Halt ,      1,      1 },{ Move ,     44,      1 },{ Move ,     44,      1 },{ Move ,     44,      1 },{ Halt ,     44,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Move ,      5,      1 },{ Halt ,      5,      1 },{ Halt ,      5,      1 },{ Move ,     14,      1 },
    { Move ,     14,      1 },{ Halt ,     14,      1 },{ Move ,     25,      1 },{ Move ,     16,      1 },{ Move ,     48,      1 },{ Move ,     62,      1 },{ Move ,     72,      1 },{ Halt ,     72,      1 },{ Move ,     82,      1 },{ Move ,     24,      1 },{ Halt ,     24,      1 },{ Move ,     10,      1 },{ Move ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },
    { Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Move ,     52,      1 },{ Move ,     36,      1 }},

    { { Move ,      1,      1 },{ Move ,      2,      1 },{ Move ,     44,      1 },{ Move ,     44,      1 },{ Halt ,     44,      1 },{ Move ,     21,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      6,      1 },{ Move ,      6,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     45,      1 },{ Move ,     45,      1 },{ Move ,      0,      0 },
    { Halt ,     45,      1 },{ Move ,     20,      1 },{ Move ,     66,      1 },{ Move ,     11,      1 },{ Move ,     22,      1 },{ Move ,     38,      1 },{ Move ,     66,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     66,      1 },{ Move ,      7,      1 },{ Move ,      8,      1 },{ Move ,     57,      1 },{ Move ,     66,      1 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,     55,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     43,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     29,      1 },{ Move ,      0,      0 },{ Move ,     12,      1 },{ Move ,     49,      1 },{ Move ,     46,      1 },
    { Move ,      0,      0 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     15,      1 },{ Move ,     77,      1 },{ Move ,     77,      1 },{ Move ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },
    { Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },
    { Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },
    { Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 }},

    { { Move ,      0,      0 },{ Move ,     74,      1 },{ Move ,     74,      1 },{ Move ,     74,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     70,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     60,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,     39,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     39,      1 },{ Move ,     30,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     45,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Move ,     20,      1 },{ Halt ,     20,      1 },{ Move ,     11,      1 },{ Move ,     22,      1 },{ Move ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },
    { Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Move ,     33,      1 },{ Move ,     31,      1 },{ Halt ,     31,      1 },{ Move ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 }},

    { { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 }},

    { { Halt ,     15,      1 },{ Move ,     27,      1 },{ Move ,     27,      1 },{ Move ,     27,      1 },{ Move ,     80,      1 },{ Halt ,     80,      1 },{ Halt ,     80,      1 },{ Halt ,     80,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Move ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },
    { Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },
    { Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     19,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     19,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },
    { Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 }},

    { { Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 }},

    { { Halt ,     49,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 }},

    { { Move ,      0,      0 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,      0,      0 },{ Move ,     21,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     26,      1 },{ Move ,     26,      1 },{ Move ,     26,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      5,      1 },{ Move ,      5,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,      5,      1 },{ Move ,     30,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     45,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Move ,     20,      1 },{ Halt ,     20,      1 },{ Move ,     11,      1 },{ Move ,     22,      1 },{ Move ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },
    { Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Move ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     15,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     15,      1 },{ Move ,     30,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },
    { Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },
    { Halt ,     55,      1 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 }},

    { { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 }},

    { { Move ,      0,      0 },{ Move ,     54,      1 },{ Move ,     54,      1 },{ Move ,     54,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Halt ,     54,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,     37,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     60,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     60,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     60,      1 },{ Move ,     24,      1 },{ Move ,     24,      1 },{ Move ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },
    { Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },
    { Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },
    { Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 }},

    { { Halt ,     24,      1 },{ Move ,     78,      1 },{ Move ,     78,      1 },{ Move ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },
    { Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },
    { Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },
    { Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 }},

    { { Move ,      0,      0 },{ Move ,     26,      1 },{ Move ,     26,      1 },{ Move ,     26,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,     75,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     48,      1 },{ Move ,     62,      1 },{ Move ,     72,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     27,      1 },{ Move ,     27,      1 },{ Move ,     27,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      5,      1 },{ Move ,      5,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     50,      1 },{ Halt ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Halt ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     28,      1 },{ Move ,     28,      1 },{ Move ,     28,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      5,      1 },{ Move ,      5,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     14,      1 },{ Halt ,     14,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     18,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     18,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     52,      1 },{ Move ,     36,      1 }},

    { { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },
    { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },
    { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Move ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },
    { Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 }},

    { { Move ,      0,      0 },{ Move ,     24,      1 },{ Move ,     24,      1 },{ Move ,     24,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     24,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },
    { Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },
    { Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Move ,     46,      1 },
    { Halt ,     46,      1 },{ Halt ,     46,      1 },{ Halt ,     46,      1 },{ Halt ,     46,      1 },{ Halt ,     46,      1 },{ Halt ,     46,      1 },{ Halt ,     46,      1 }},

    { { Halt ,     46,      1 },{ Move ,     28,      1 },{ Move ,     28,      1 },{ Move ,     28,      1 },{ Halt ,     28,      1 },{ Halt ,     28,      1 },{ Halt ,     28,      1 },{ Halt ,     28,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Move ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },
    { Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },
    { Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 }},

    { { Halt ,     67,      1 },{ Move ,     42,      1 },{ Move ,     42,      1 },{ Move ,     42,      1 },{ Halt ,     42,      1 },{ Halt ,     42,      1 },{ Halt ,     42,      1 },{ Halt ,     42,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Move ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },
    { Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },
    { Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 }},

    { { Move ,      0,      0 },{ Move ,     87,      1 },{ Move ,     87,      1 },{ Move ,     87,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     87,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Halt ,     64,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 }},

    { { Move ,      0,      0 },{ Move ,     30,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     45,      1 },{ Move ,     45,      1 },{ Move ,      0,      0 },
    { Halt ,     45,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,     55,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     46,      1 },
    { Move ,      0,      0 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     60,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     60,      1 },{ Move ,     40,      1 },{ Move ,     40,      1 },{ Move ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },
    { Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },
    { Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },
    { Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 }},

    { { Move ,      0,      0 },{ Move ,     41,      1 },{ Move ,     41,      1 },{ Move ,     41,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,     75,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     62,      1 },{ Move ,     72,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     42,      1 },{ Move ,     42,      1 },{ Move ,     42,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      5,      1 },{ Move ,      5,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     50,      1 },{ Halt ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     73,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     73,      1 },{ Move ,     44,      1 },{ Move ,     44,      1 },{ Move ,     44,      1 },{ Halt ,     44,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Move ,      5,      1 },{ Halt ,      5,      1 },{ Halt ,      5,      1 },{ Move ,     14,      1 },
    { Move ,     14,      1 },{ Halt ,     14,      1 },{ Move ,     25,      1 },{ Move ,     16,      1 },{ Move ,     48,      1 },{ Move ,     62,      1 },{ Move ,     72,      1 },{ Halt ,     72,      1 },{ Move ,     82,      1 },{ Move ,     24,      1 },{ Halt ,     24,      1 },{ Move ,     10,      1 },{ Move ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },
    { Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Move ,     52,      1 },{ Move ,     36,      1 }},

    { { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },
    { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },
    { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },
    { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 }},

    { { Halt ,     36,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },
    { Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Move ,     37,      1 },{ Halt ,     37,      1 },{ Halt ,     37,      1 },{ Halt ,     37,      1 },{ Halt ,     37,      1 },{ Halt ,     37,      1 }},

    { { Halt ,     37,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },
    { Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },
    { Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },
    { Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 }},

    { { Move ,      0,      0 },{ Move ,     41,      1 },{ Move ,     41,      1 },{ Move ,     41,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     64,      1 },{ Move ,     63,      1 },{ Move ,     63,      1 },{ Move ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 }},

    { { Halt ,     58,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     52,      1 },{ Move ,     36,      1 }},

    { { Move ,      0,      0 },{ Move ,     59,      1 },{ Move ,     59,      1 },{ Move ,     59,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     76,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     53,      1 },{ Move ,     53,      1 },{ Move ,     53,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     53,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     53,      1 },{ Move ,     54,      1 },{ Move ,     54,      1 },{ Move ,     54,      1 },{ Halt ,     54,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     79,      1 },{ Move ,     90,      1 }},

    { { Move ,      0,      0 },{ Move ,     86,      1 },{ Move ,     86,      1 },{ Move ,     86,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     56,      1 },{ Move ,     56,      1 },{ Move ,     56,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,     75,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     72,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     34,      1 },{ Move ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     50,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },
    { Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },
    { Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },
    { Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 }},

    { { Halt ,     47,      1 },{ Move ,     59,      1 },{ Move ,     59,      1 },{ Move ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },
    { Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Move ,     76,      1 },{ Halt ,     76,      1 },{ Halt ,     76,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 }},

    { { Move ,      0,      0 },{ Move ,     53,      1 },{ Move ,     53,      1 },{ Move ,     53,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     30,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     45,      1 },{ Move ,     45,      1 },{ Move ,      0,      0 },
    { Halt ,     45,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,     55,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     46,      1 },
    { Move ,      0,      0 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     56,      1 },{ Move ,     56,      1 },{ Move ,     56,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     56,      1 },{ Move ,     63,      1 },{ Move ,     63,      1 },{ Move ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Move ,      5,      1 },{ Move ,      5,      1 },{ Halt ,      5,      1 },{ Halt ,      5,      1 },{ Move ,     14,      1 },
    { Move ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },
    { Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 }},

    { { Halt ,     14,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Halt ,     64,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 }},

    { { Move ,      0,      0 },{ Move ,     65,      1 },{ Move ,     65,      1 },{ Move ,     65,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,     75,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     14,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     14,      1 },{ Move ,     68,      1 },{ Move ,     68,      1 },{ Move ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },
    { Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 }},

    { { Move ,      0,      0 },{ Move ,     69,      1 },{ Move ,     69,      1 },{ Move ,     69,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     69,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     34,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     34,      1 },{ Move ,     71,      1 },{ Move ,     71,      1 },{ Move ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },
    { Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 }},

    { { Move ,      0,      0 },{ Move ,     65,      1 },{ Move ,     65,      1 },{ Move ,     65,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     65,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     65,      1 },{ Move ,     74,      1 },{ Move ,     74,      1 },{ Move ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },
    { Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },
    { Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Move ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },
    { Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 }},

    { { Halt ,     35,      1 },{ Move ,     69,      1 },{ Move ,     69,      1 },{ Move ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },
    { Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },
    { Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },
    { Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 }},

    { { Move ,      0,      0 },{ Move ,     68,      1 },{ Move ,     68,      1 },{ Move ,     68,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     77,      1 },{ Move ,     77,      1 },{ Move ,     77,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     81,      1 },{ Move ,     40,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     13,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     78,      1 },{ Move ,     78,      1 },{ Move ,     78,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     89,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     71,      1 },{ Move ,     71,      1 },{ Move ,     71,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Halt ,     32,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     32,      1 },{ Move ,     84,      1 },{ Move ,     84,      1 },{ Move ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },
    { Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },
    { Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },
    { Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 }},

    { { Halt ,     84,      1 },{ Move ,     83,      1 },{ Move ,     83,      1 },{ Move ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },
    { Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },
    { Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },
    { Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 }},

    { { Move ,      0,      0 },{ Move ,     83,      1 },{ Move ,     83,      1 },{ Move ,     83,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     24,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     84,      1 },{ Move ,     84,      1 },{ Move ,     84,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     40,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     85,      1 },{ Move ,     85,      1 },{ Move ,     85,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     85,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     85,      1 },{ Move ,     86,      1 },{ Move ,     86,      1 },{ Move ,     86,      1 },{ Halt ,     86,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     79,      1 },{ Move ,     90,      1 }},

    { { Move ,      0,      0 },{ Move ,     87,      1 },{ Move ,     87,      1 },{ Move ,     87,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     52,      1 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     88,      1 },{ Move ,     88,      1 },{ Move ,     88,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     79,      1 },{ Move ,      0,      0 }},

    { { Halt ,     79,      1 },{ Move ,     85,      1 },{ Move ,     85,      1 },{ Move ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },
    { Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },
    { Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },
    { Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 }},

    { { Move ,      0,      0 },{ Move ,     88,      1 },{ Move ,     88,      1 },{ Move ,     88,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},
};
const UINT g_uFirstChar = 9;  //  included
const UINT g_uLastChar = 123;  //  included
const WCHAR g_CharClass [] = {
    1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 65, 0, 0, 64, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0,
    0, 66, 0, 0, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
    17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 0, 0, 0, 0, 0, 54, 28, 29, 30,
    31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
    51, 52, 53, 0
};
DFAState g_nStartState = 3;

#else  //  !_SCANNER_TABLE_H_

#endif //  _SCANNER_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\tracer\src\global.cpp ===
#include <windows.h>
#include "globvars.hxx"

// The code below is from globvars.cxx which is a part of pkmutill.lib
// I copied it here in order not to muck with precompiled header objects required to link with pkmutill.lib

#pragma warning(disable:4073)
#pragma init_seg(lib)

BOOL	g_fIsNT = TRUE;

// disable compiler warning which just tells us we're putting stuff in the library 
// initialization section.

class CInitGlobals
{
public:
    CInitGlobals()
    {
        g_fIsNT = IsNT();
    }
} g_InitGlobals;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\tracer\src\mutex.h ===
/*//////////////////////////////////////////////////////////////////////////////
//
//      Filename :  Mutex.h
//      Purpose  :  A mutex objects
//
//      Project  :  Tracer
//      Component:
//
//      Author   :  urib
//
//      Log:
//          Dec  8 1996 urib Creation
//          Jun 26 1997 urib Add error checking. Improve coding.
//
//////////////////////////////////////////////////////////////////////////////*/

#ifndef MUTEX_H
#define MUTEX_H
#include <Accctrl.h>
#include <Aclapi.h>

//////////////////////////////////////////////////////////////////////////////*/
//
//  CMutex class definition
//
//////////////////////////////////////////////////////////////////////////////*/

class CMutex
{
  public:
    // Creates a mutex or opens an existing one.
    void Init (PSZ pszMutexName = NULL);

    // Lets the class act as a mutex handle.
    operator HANDLE();

    // Releases the mutex so other threads could take it.
    void Release();

    // Closes the handle on scope end.
    ~CMutex();

  private:
    HANDLE  m_hMutex;

};

//////////////////////////////////////////////////////////////////////////////*/
//
//  CMutexCatcher class definition
//
//////////////////////////////////////////////////////////////////////////////*/

class CMutexCatcher
{
  public:
    // Constructor - waits on the mutex.
    CMutexCatcher(CMutex& m);

    // Releases the mutex on scope end.
    ~CMutexCatcher();

  private:
    CMutex* m_pMutex;
};


//////////////////////////////////////////////////////////////////////////////*/
//
//  CMutex class implementation
//
//////////////////////////////////////////////////////////////////////////////*/

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutex::Init
//      Purpose  :  Creates a mutex or opens an existing one.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
void CMutex::Init(PSZ pszMutexName)
{
    BOOL    fSuccess = TRUE;

    LPSECURITY_ATTRIBUTES   lpSecAttr = NULL;
    SECURITY_ATTRIBUTES SA;
    SECURITY_DESCRIPTOR SD;

    
    if(g_fIsWinNt)
    {
        PSID                 pSidAdmin = NULL;
        PSID                 pSidWorld = NULL;
        PACL                 pACL = NULL;
        EXPLICIT_ACCESS      ea[2] = {0};
        SA.nLength = sizeof(SECURITY_ATTRIBUTES);
        SA.bInheritHandle = TRUE;
        SA.lpSecurityDescriptor = &SD;
        SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
        SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
        DWORD                rc;

        if (!InitializeSecurityDescriptor (&SD, SECURITY_DESCRIPTOR_REVISION))
        {
            throw "CreateMutex failed";
        }
    
        if (!AllocateAndInitializeSid(&NtAuthority,
                                    1,            // 1 sub-authority
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    0,0,0,0,0,0,0,
                                    &pSidAdmin))
        {
            throw "CreateMutex failed";
        }

        if (!AllocateAndInitializeSid( &WorldSidAuthority,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0,0,0,0,0,0,0,
                                    &pSidWorld
                                    ))
        {
            FreeSid (pSidAdmin);
            throw "CreateMutex failed";
        }

        ea[0].grfAccessPermissions = SYNCHRONIZE;  
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance= NO_INHERITANCE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        ea[0].Trustee.ptstrName  = (LPTSTR) pSidWorld;

        ea[1].grfAccessPermissions = GENERIC_ALL | WRITE_DAC | WRITE_OWNER;
        ea[1].grfAccessMode = SET_ACCESS;
        ea[1].grfInheritance= NO_INHERITANCE;
        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        ea[1].Trustee.ptstrName  = (LPTSTR) pSidAdmin;

        rc = SetEntriesInAcl(2,
                            ea,
                            NULL,
                            &pACL);
        FreeSid (pSidAdmin);
        FreeSid (pSidWorld);

        if (ERROR_SUCCESS != rc)
        {
            throw "CreateMutex failed";
        }

        if (!SetSecurityDescriptorDacl(&SD, TRUE, pACL, FALSE))
        {
            throw "CreateMutex failed";
        }
        lpSecAttr = &SA;
    }

    m_hMutex = CreateMutex(lpSecAttr, FALSE, pszMutexName);
    if (NULL == m_hMutex)
    {
        char    rchError[1000];
        sprintf(rchError, "Tracer:CreateMutex failed with error %#x"
                " on line %d file %s\n",
                GetLastError(),
                __LINE__,
                __FILE__);
        OutputDebugString(rchError);
        throw "CreateMutex failed";
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutex::CMutex
//      Purpose  :  Lets the class act as a mutex handle.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   HANDLE
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
CMutex::operator HANDLE()
{
    return m_hMutex;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutex::Release()
//      Purpose  :  Releases the mutex so other threads could take it.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
void
CMutex::Release()
{
    BOOL    fSuccess = TRUE;

    if(m_hMutex != NULL)
    {
        fSuccess = ReleaseMutex(m_hMutex);
    }

    if (!fSuccess)
    {
        char    rchError[1000];
        sprintf(rchError, "Tracer:ReleaseMutex failed with error %#x"
                " on line %d file %s\n",
                GetLastError(),
                __LINE__,
                __FILE__);
        OutputDebugString(rchError);
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutex::~CMutex
//      Purpose  :  Closes the handle on scope end.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
CMutex::~CMutex()
{
    BOOL    fSuccess = TRUE;


    if(m_hMutex != NULL)
    {
        fSuccess = CloseHandle(m_hMutex);
    }

    if (!fSuccess)
    {
        char    rchError[1000];
        sprintf(rchError, "Tracer:ReleaseMutex failed with error %#x"
                " on line %d file %s\n",
                GetLastError(),
                __LINE__,
                __FILE__);
        OutputDebugString(rchError);
    }
}

//////////////////////////////////////////////////////////////////////////////*/
//
//  CMutexCatcher class implementation
//
//////////////////////////////////////////////////////////////////////////////*/

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutexCatcher::CMutexCatcher
//      Purpose  :  Constructor - waits on the mutex.
//
//      Parameters:
//          [in]    CMutex& m
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
CMutexCatcher::CMutexCatcher(CMutex& m)
    :m_pMutex(&m)
{
    DWORD dwResult;

    dwResult = WaitForSingleObject(*m_pMutex, INFINITE);
    // Wait for a minute and shout!

    if (WAIT_OBJECT_0 != dwResult)
    {
        char    rchError[1000];
        sprintf(rchError,
                "Tracer:WaitForSingleObject returned an error - %x"
                " something is wrong"
                " on line %d file %s\n",
                dwResult,
                __LINE__,
                __FILE__);
        OutputDebugString(rchError);
        throw "WaitForSingleObject failed";
    }

}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutexCatcher::~CMutexCatcher
//      Purpose  :  Constructor - waits on the mutex.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
CMutexCatcher::~CMutexCatcher()
{
    m_pMutex->Release();
}



#endif // MUTEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\tracer\src\cintf.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  CIntf.cpp
//      Purpose  :  Redirect all the C calls to the global tracer.
//
//      Project  :  Tracer
//
//      Author   :  urib
//
//      Log:
//          Dec  2 1996 urib Creation
//          Dec 10 1996 urib Fix TraceSZ to VaTraceSZ.
//          Feb 11 1997 urib Support UNICODE format string in the Trace.
//          Jan 20 1999 urib  Assert value is checked in the macro.
//
////////////////////////////////////////////////////////////////////////////////

#include "Tracer.h"

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)

void TraceAssert(  PSZ pszTestValue,
                   PSZ pszFile,
                   int iLineNo)
{
    g_pTracer->TraceAssert(pszTestValue, pszFile, iLineNo);
}
void TraceAssertSZ(PSZ pszTestValue, PSZ pszText, PSZ pszFile, int iLineNo)
{
    g_pTracer->TraceAssertSZ(pszTestValue, pszText, pszFile, iLineNo);
}
void TraceAssertWSZ(PSZ pszTestValue, PWSTR pwszText, PSZ pszFile, int iLineNo)
{
    char    rchBuffer[1000];
    wcstombs(rchBuffer, pwszText, 1000);
    rchBuffer[1000 - 1] = '\0';

    g_pTracer->TraceAssertSZ(pszTestValue, rchBuffer, pszFile, iLineNo);
}

BOOL IsFailure(BOOL fTestValue, PSZ pszFile, int iLineNo)
{
    return g_pTracer->IsFailure(fTestValue, pszFile, iLineNo);
}

BOOL IsBadAlloc (void* pTestValue, PSZ pszFile, int iLineNo)
{
    return g_pTracer->IsBadAlloc(pTestValue, pszFile, iLineNo);
}

BOOL IsBadHandle(HANDLE hTestValue, PSZ pszFile, int iLineNo)
{
    return g_pTracer->IsBadHandle(hTestValue, pszFile, iLineNo);
}

BOOL IsBadResult(HRESULT hrTestValue, PSZ pszFile, int iLineNo)
{
    return g_pTracer->IsBadResult(hrTestValue, pszFile, iLineNo);
}

void TraceSZ(ERROR_LEVEL el, TAG tag, PSZ pszFormatString, ...)
{
    va_list arglist;

    va_start(arglist, pszFormatString);

    g_pTracer->VaTraceSZ(0, "File: not supported in c files", 0, el, tag, pszFormatString, arglist);
}

void TraceWSZ(ERROR_LEVEL el, TAG tag, PWSTR pwszFormatString, ...)
{
    va_list arglist;

    va_start(arglist, pwszFormatString);

    g_pTracer->VaTraceSZ(0, "File: not supported in c files", 0, el, tag, pwszFormatString, arglist);
}

HRESULT RegisterTagSZ(PSZ pszTagName, TAG* ptag)
{
    return g_pTracer->RegisterTagSZ(pszTagName, *ptag);
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\tracer\src\tracerdefault.h ===
#ifndef _TRACER_DEFAULT_H_
#define _TRACER_DEFAULT_H_

#define LOG_FILE_SIZE               0x80000
#define MAX_TAG_NUMBER              5000

#define DEVICE_FLAG_DEFAULT           TRACER_DEVICE_FLAG_FILE
#define TRACER_ERROR_LEVEL_DEFAULT    elVerbose
#define TRACER_ASSERT_LEVEL_DEFAULT   (ASSERT_LEVEL_MESSAGE | ASSERT_LEVEL_POPUP)
#define PRINT_LOCATION_DEFAULT        0
#define PRINT_PROGRAM_NAME_DEFAULT    1
#define PRINT_TIME_DEFAULT            1
#define PRINT_THREAD_ID_DEFAULT       1
#define PRINT_ERROR_LEVEL_DEFAULT     0
#define PRINT_TAG_ID_DEFAULT          0
#define PRINT_TAG_NAME_DEFUALT        1
#define PRINT_PROCCESS_ID_DEFAULT     0

#define TAG_ERROR_LEVEL_DEFAULT       elError

#endif // _TRACER_DEFAULT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\tracer\inc\tracer.h ===
#ifndef _TRACER_H_
#define _TRACER_H_

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <stdarg.h>

//
// global defines.
//

#define MAX_FLAG_NAME 32
#define MAX_TAG_NAME  64

#define DEVICE_FLAG         0
#define ERROR_LEVEL_FLAG    1
#define ASSERT_LEVEL_FLAG   2
#define PRINT_LOCATION      3
#define PRINT_PROGRAM_NAME  4
#define PRINT_TIME          5
#define PRINT_THREAD_ID     6
#define PRINT_ERROR_LEVEL   7
#define PRINT_TAG_ID        8
#define PRINT_TAG_NAME      9
#define PRINT_PROCESS_ID    10
#define LAST_FLAG           11

#define TRACER_DEVICE_FLAG_FILE         0x00000001L
#define TRACER_DEVICE_FLAG_DEBUGOUT     0x00000002L
#define TRACER_DEVICE_FLAG_STDOUT       0x00000004L
#define TRACER_DEVICE_FLAG_STDERR       0x00000008L

//
// basic classes
//

typedef enum _ERROR_LEVEL
{
    elFirst = 0,
    elCrash,
    elError,
    elWarning,
    elInfo,
    elVerbose,
    elLast
} ERROR_LEVEL;

typedef ULONG TAG;

///////////////////////////////////////////////////////////////////////////////
// CTracerTagEntry
///////////////////////////////////////////////////////////////////////////////
class CTracerTagEntry
{
public:
    CTracerTagEntry() :
        m_TagErrLevel(elFirst)
    {
        m_pszTagName[0] = '\0';
    }

public:
    ERROR_LEVEL m_TagErrLevel;
    char  m_pszTagName[MAX_TAG_NAME];

};

///////////////////////////////////////////////////////////////////////////////
// CTracerFlagEntry
///////////////////////////////////////////////////////////////////////////////

class CTracerFlagEntry
{
public:
    CTracerFlagEntry() :
        m_ulFlagValue(0)
    {
        m_pszName[0] = '\0';
    }

public:
    ULONG m_ulFlagValue;
    char  m_pszName[MAX_FLAG_NAME];
};


///////////////////////////////////////////////////////////////////////////////
// CTracer
///////////////////////////////////////////////////////////////////////////////
typedef enum {
    logUseLogName,
    logUseAppName 
} LogState;

class CTracer
{
  public:

    // The virtual distructor is here to allow derived classes to
    //   define distructors
    virtual ~CTracer();

    // This function deallocates the tracer! it calls the Function pointer
    //   passed in the constructor or if not given - the default
    //   delete operator for the dll.
    virtual void Free();


    // The TraceSZ function output is defined by the tags and error level mode.
    //   The control of this mode is via the registry.
    //   (Default LOCAL_MACHINE\SOFTWARE\Microsoft\Tracer)
    //   TraceSZ gets the mode by calling IsEnabled.
    //-------------------------------------------------------------------------
    // accepts printf format for traces
    virtual void
    TraceSZ(DWORD, LPCSTR, int, ERROR_LEVEL, TAG, LPCSTR, ...);
    virtual void
    TraceSZ(DWORD, LPCSTR, int, ERROR_LEVEL, TAG, PCWSTR, ...);

    // Prints the implements the TraceSZ function.
    virtual void
    VaTraceSZ(DWORD, LPCSTR, int, ERROR_LEVEL, TAG, LPCSTR, va_list);
    virtual void
    VaTraceSZ(DWORD, LPCSTR, int, ERROR_LEVEL, TAG, PCWSTR, va_list);

    // Raw output functions
    virtual void
    RawVaTraceSZ(LPCSTR, va_list);
    virtual void
    RawVaTraceSZ(PCWSTR, va_list);

    // Create or open a new tag for tracing
    virtual HRESULT RegisterTagSZ(LPCSTR, TAG&);

    // Two Assert functions one allows attaching a string.
    //-------------------------------------------------------------------------
    // assert, different implementations possible - gui or text
    virtual void TraceAssertSZ(LPCSTR, LPCSTR, LPCSTR, int);

    // assert, different implementations possible - gui or text
    virtual void TraceAssert(LPCSTR, LPCSTR, int);

    // The following function are used to check return values and validity of
    //   pointers and handles. If the item checked is bad the function will
    //   return TRUE and a trace will be made for that.
    //-------------------------------------------------------------------------
    // Verify a boolean function return code
    virtual BOOL IsFailure(BOOL, LPCSTR, int);

    // verify allocation
    virtual BOOL IsBadAlloc(void*, LPCSTR, int);

    // Verify a Handle
    virtual BOOL IsBadHandle(HANDLE, LPCSTR, int);

    // Verify an OLE hresult function
    virtual BOOL IsBadResult(HRESULT, LPCSTR, int);

  public:

    TAG*       m_ptagNextTagId;
    // A array of tags.
    CTracerTagEntry*   m_aTags;

    // Contains the flags that control wich output devices are used.

    ULONG* m_pulNumOfFlagEntries;
    CTracerFlagEntry*   m_aFlags;

    // log file 

    LogState m_LogState;
    char* m_pszLogName;
};

extern "C" CTracer* g_pTracer;

class CSetLogFile
{
public:
    CSetLogFile()
    {
        g_pTracer->m_LogState = logUseAppName;
    }

    CSetLogFile(char* pszName)
    {
        g_pTracer->m_LogState = logUseLogName;
        g_pTracer->m_pszLogName = pszName;
    }

};
///////////////////////////////////////////////////////////////////////////////
// CTempTrace
///////////////////////////////////////////////////////////////////////////////

class CTempTrace
{
public:
    CTempTrace(LPCSTR  pszFile, int iLine);

    void TraceSZ(ERROR_LEVEL, ULONG, LPCSTR, ...);
    void TraceSZ(ERROR_LEVEL, ULONG, DWORD dwError, LPCSTR, ...);

    void TraceSZ(ERROR_LEVEL, ULONG, PCWSTR, ...);
    void TraceSZ(ERROR_LEVEL, ULONG, DWORD dwError, PCWSTR, ...);

private:

    LPCSTR  m_pszFile;
    int     m_iLine;

};

///////////////////////////////////////////////////////////////////////////////
// CTempTrace1
///////////////////////////////////////////////////////////////////////////////

class CTempTrace1
{
public:
    CTempTrace1(LPCSTR  pszFile, int iLine, TAG tag, ERROR_LEVEL el);

    void TraceSZ(LPCSTR, ...);
    void TraceSZ(DWORD dwError, LPCSTR, ...);

    void TraceSZ(PCWSTR, ...);
    void TraceSZ(DWORD dwError, PCWSTR, ...);

private:

    LPCSTR  m_pszFile;
    int     m_iLine;
    TAG    m_ulTag;
    ERROR_LEVEL m_el;

};

///////////////////////////////////////////////////////////////////////////////
// CLongTrace
///////////////////////////////////////////////////////////////////////////////

class CLongTrace
{
public:
    CLongTrace(LPCSTR  pszFile, int iLine);
    ~CLongTrace();
    BOOL Init(ERROR_LEVEL, TAG);

private:
    BOOL    m_fRelease;
    LPCSTR  m_pszFile;
    int     m_iLine;
};

///////////////////////////////////////////////////////////////////////////////
// CLongTraceOutput
///////////////////////////////////////////////////////////////////////////////

class CLongTraceOutput
{
public:
    CLongTraceOutput(LPCSTR  pszFile, int iLine);

    void TraceSZ(LPCSTR, ...);
    void TraceSZ(PCWSTR, ...);

private:
    LPCSTR  m_pszFile;
    int     m_iLine;
};

///////////////////////////////////////////////////////////////////////////////
// CTracerTag
///////////////////////////////////////////////////////////////////////////////

class CTracerTag
{
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
  public:

    CTracerTag(PSZ pszTagName)
    {
        HRESULT hrTagRegistrationResult;

        hrTagRegistrationResult = g_pTracer->RegisterTagSZ(pszTagName, m_ulTag);

        if(FAILED(hrTagRegistrationResult))
            throw "Tag could not be registered";

    }

    operator TAG()
    {
        return m_ulTag;
    }

  public:
    TAG m_ulTag;
#else  /* DEBUG */
  public:
    CTracerTag(PSZ){}
#endif /* DEBUG */
};


extern CTracerTag tagError;
extern CTracerTag tagWarning;
extern CTracerTag tagInformation;
extern CTracerTag tagVerbose;
extern CTracerTag tagGeneral;
//
// global defines
//

#define BAD_POINTER(ptr)    (NULL == (ptr))
#define BAD_HANDLE(h)       ((0 == ((HANDLE)h))||   \
                             (INVALID_HANDLE_VALUE == ((HANDLE)h)))
#define BAD_RESULT(hr)      (FAILED(hr))

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)

#ifdef    __cplusplus

#define CheckTraceRestrictions(el, tag) \
    ((g_pTracer->m_aTags[tag].m_TagErrLevel >= el) && \
    (g_pTracer->m_aFlags[ERROR_LEVEL_FLAG].m_ulFlagValue >= (ULONG)el) && \
    g_pTracer->m_aFlags[DEVICE_FLAG].m_ulFlagValue)

#define Trace(x) \
    {CTempTrace tmp(__FILE__, __LINE__);tmp.TraceSZ x;}

#define Trace1(el, tag, x)    \
    { \
        if (CheckTraceRestrictions(el, tag.m_ulTag)) \
        { \
            CTempTrace1 tmp(__FILE__, __LINE__, tag.m_ulTag, el); \
            tmp.TraceSZ x; \
        } \
    }

#define BeginLongTrace(x)   {CLongTrace tmp(__FILE__, __LINE__);if (tmp.Init x) {
#define LongTrace(x)        {CLongTraceOutput tmp(__FILE__, __LINE__);tmp.TraceSZ x;}
#define EndLongTrace        }}

#define RegisterTag(psz, tag)   g_pTracer->RegisterTagSZ((psz), tag)

#define IS_FAILURE(x)       g_pTracer->IsFailure((x), __FILE__, __LINE__)
#define IS_BAD_ALLOC(x)     g_pTracer->IsBadAlloc((void*)(x), __FILE__, __LINE__)
#define IS_BAD_HANDLE(x)    g_pTracer->IsBadHandle((HANDLE)(x), __FILE__, __LINE__)
#define IS_BAD_RESULT(x)    g_pTracer->IsBadResult((x), __FILE__, __LINE__)

#define Assert(x)           {if (!(x)) {g_pTracer->TraceAssert(#x, __FILE__, __LINE__);}}
#define AssertSZ(x, psz)    {if (!(x)) {g_pTracer->TraceAssertSZ(#x, (PSZ)(psz),__FILE__, __LINE__);}}

#define SET_TRACER(x)       SetTracer(x)

#define SET_TRACER_LOGGING_TO_FILE_OFF g_pTracer->m_aFlags[DEVICE_FLAG].m_ulFlagValue &= ~TRACER_DEVICE_FLAG_FILE;
#define USE_COMMON_LOG_FILE(name)  CSetLogFile SetLogFile(name);

#else  /* __cplusplus */

#define IS_FAILURE(x)       IsFailure((x), __FILE__, __LINE__)
#define IS_BAD_ALLOC(x)     IsBadAlloc((void*)(x), __FILE__, __LINE__)
#define IS_BAD_HANDLE(x)    IsBadHandle((HANDLE)(x), __FILE__, __LINE__)
#define IS_BAD_RESULT(x)    IsBadResult((x), __FILE__, __LINE__)

#define Assert(x)           {if (!(x)) {TraceAssert(#x,__FILE__, __LINE__);}}

#ifdef UNICODE
#define AssertSZ(x, psz)    {if (!(x)) {TraceAssertWSZ(#x, (pwsz), __FILE__, __LINE__);}}
#define Trace(x)            TraceWSZ x
#else
#define AssertSZ(x, psz)    {if (!(x)) {TraceAssertSZ(#x, (psz),__FILE__, __LINE__);}}
#define Trace(x)            TraceSZ x
#endif

#define RegisterTag(psz, tag)   RegisterTagSZ((psz), &(tag))

#endif /* __cplusplus */

#define GIS_FAILURE(x)      IsFailure((x), __FILE__, __LINE__)
#define GIS_BAD_ALLOC(x)    IsBadAlloc((void*)(x), __FILE__, __LINE__)
#define GIS_BAD_HANDLE(x)   IsBadHandle((HANDLE)(x), __FILE__, __LINE__)
#define GIS_BAD_RESULT(x)   IsBadResult((x), __FILE__, __LINE__)

#define GAssert(x)          {if (!(x)) {TraceAssert(#x, __FILE__, __LINE__);}}
#define GAssertSZ(x, psz)   {if (!(x)) {TraceAssertSZ(#x, (PSZ)(psz), __FILE__, __LINE__);}}

#define GTrace(x)           TraceSZ x

#define DECLARE_TAG(name, psz) static CTracerTag  name(psz);
#define DECLARE_GLOBAL_TAG(name, psz) CTracerTag  name(psz);
#define USES_TAG(name) extern CTracerTag name;

#else  // DEBUG

#define IS_FAILURE(x)       (!(x))
#define IS_BAD_ALLOC(x)     BAD_POINTER((void*)(x))
#define IS_BAD_HANDLE(x)    BAD_HANDLE((HANDLE)(x))
#define IS_BAD_RESULT(x)    BAD_RESULT(x)

#define Assert(x)
#define AssertSZ(x, psz)

#define Trace(x)
#define Trace1(el,tag,x)

#define BeginLongTrace(x)   {if (0) {
#define LongTrace(x)        ;
#define EndLongTrace        }}

#define RegisterTag(psz, tag)

#define SET_TRACER(x)
#define SET_TRACER_LOGGING_TO_FILE_OFF
#define USE_COMMON_LOG_FILE(name)  

#define GIS_FAILURE(x)      IS_FAILURE(x)
#define GIS_BAD_ALLOC(x)    IS_BAD_ALLOC(x)
#define GIS_BAD_HANDLE(x)   IS_BAD_HANDLE(x)
#define GIS_BAD_RESULT(x)   IS_BAD_RESULT(x)

#define GAssert(x)          Assert(x)
#define GAssertSZ(x, psz)   AssertSZ(x, psz)

#define GTrace(x)

#define DECLARE_TAG(name, psz)
#define DECLARE_GLOBAL_TAG(name, psz)
#define USES_TAG(name)

#endif // DEBUG

//
// Turn off Asserts for retail, even if USE_TRACER is specified
//
#if (!defined(DEBUG))

#ifdef Assert
#undef Assert
#define Assert(x)
#endif // Assert

#ifdef AssertSZ
#undef AssertSZ
#define AssertSZ(x, psz)
#endif // AssertSZ

#ifdef GAssert
#undef GAssert
#define GAssert(x)
#endif // GAssert

#ifdef GAssertSZ
#undef GAssertSZ
#define GAssertSZ(x, psz)
#endif // GAssertSZ

#endif // DEBUG

#ifndef PQS_CODE
#undef _ASSERTE

#if (defined (DEBUG) && !defined(_NO_TRACER)) 
#define _ASSERTE(x) Assert(x)
#else
#define _ASSERTE(x) 0
#endif

#endif // PQS_CODE


////////////////////////////////////////////////////////////////////////////////
//
// Define this to export the classes
//
////////////////////////////////////////////////////////////////////////////////
#ifdef  TRACER_EXPORT
#define TracerExported  __declspec( dllexport )
#else
#define TracerExported
#endif

////////////////////////////////////////////////////////////////////////////////
//
// class CTraced definition + implementation
//
//  pupose : A base class for every class who wants to use a special.
//
//
////////////////////////////////////////////////////////////////////////////////
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)

void __cdecl ShutdownTracer();

class TracerExported CTraced {
  public:
    // A Constructor - sets a default Tracer. replace it by calling SetTracer
    //   in the derived class constructor.
    CTraced()
    {
        m_pTracer = NULL;
    }

    // The destructor deletes the existing tracer.
    ~CTraced()
    {
        if (m_pTracer)
            m_pTracer->Free();
    }

    // replace the current tracer while erasing it.
    BOOL SetTracer(CTracer* pTracer)
    {
        CTracer* pTempTracer = m_pTracer;
        m_pTracer = pTracer;

        if (pTempTracer)
          pTempTracer->Free();

        return TRUE;
    }

    // Return a pointer to the tracer this function is called by the macro's so
    //   if one wants to supply a different mechanism he can override it.
    virtual CTracer* GetTracer()
    {
        if(m_pTracer)
            return m_pTracer;
        else
            return g_pTracer;
    }

  protected:
    // A pointer to the tracer.
    CTracer *m_pTracer;
};

#else  /* DEBUG */
class TracerExported CTraced {};
#endif /* DEBUG */

////////////////////////////////////////////////////////////////////////////////
//
// The C interface prototypes. The macros calls them.
//
////////////////////////////////////////////////////////////////////////////////
#ifdef    __cplusplus
extern "C"
{
#endif /* __cplusplus */

void TraceAssert(   PSZ, PSZ, int);
void TraceAssertSZ( PSZ, PSZ, PSZ, int);
void TraceAssertWSZ(PSZ, PWSTR, PSZ, int);

BOOL IsFailure  (BOOL   , PSZ, int);
BOOL IsBadAlloc (void*  , PSZ, int);
BOOL IsBadHandle(HANDLE , PSZ, int);
BOOL IsBadResult(HRESULT, PSZ, int);

void TraceSZ(ERROR_LEVEL, TAG, PSZ, ...);
void TraceWSZ(ERROR_LEVEL, TAG, PWSTR, ...);

HRESULT RegisterTagSZ(PSZ, TAG*);

#ifdef    __cplusplus
}
#endif /* __cplusplus */

#ifdef    __cplusplus
////////////////////////////////////////////////////////////////////////////////
//
// Some extra classes.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// An accumulating timer. Use it to define accuulator.
//       (See cpptest.cpp in the Sample)
//
// It is be used to compute average times of function etc.
//
//      timer - the vaiable name
//  tag   - the tag to trace to
//  string - a prefix
//
////////////////////////////////////////////////////////////////////////////////
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
#define AccumulatingTimer(timer, tag, string, actimer)  \
CTracerAccumulatingTimer        timer(tag, string, actimer)
#else
#define AccumulatingTimer(timer, tag, string, actimer)
#endif

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
class CTracerAccumulatingTimer
{
  public:
    CTracerAccumulatingTimer(
        TAG   tag,
        PSZ     pszSomeText = NULL,
        CTracerAccumulatingTimer *pTimer = NULL)
    :m_ulAccumulatedTimeInMiliseconds(0)
    ,m_ulEventNumber(0)
    ,m_tagTheTagToTraceTo(tag)
    ,m_pAccumulator(pTimer)
    {
        if (pszSomeText)
            strncpy(m_rchText, pszSomeText, MAX_PATH);
        else
            m_rchText[0] = '\0';
    }

    operator TAG(){return m_tagTheTagToTraceTo;}

    void AddEvent(ULONG ulEventDurationInMiliseconds, PSZ pszSomeText)
    {
        m_ulAccumulatedTimeInMiliseconds += ulEventDurationInMiliseconds;
        m_ulEventNumber++;

        Trace((
            elInfo,
            m_tagTheTagToTraceTo,
            "%s%s took %d miliseconds,"
            " average is %d miliseconds,"
            " accumulated %d miliseconds,"
            " op# %d",
            m_rchText,
            pszSomeText,
            ulEventDurationInMiliseconds,
            m_ulAccumulatedTimeInMiliseconds/m_ulEventNumber,
            m_ulAccumulatedTimeInMiliseconds,
            m_ulEventNumber));

        if(m_pAccumulator)
            m_pAccumulator->AddEvent(
                ulEventDurationInMiliseconds,
                m_rchText);
    }

  protected:
    // The time
    ULONG   m_ulAccumulatedTimeInMiliseconds;

    // The event counter
    ULONG   m_ulEventNumber;

    // The tag the trace will use.
    TAG     m_tagTheTagToTraceTo;

    // some text to specify which scope or code block is it
    char    m_rchText[MAX_PATH + 1];

    // pointer to accumulating time
    CTracerAccumulatingTimer        *m_pAccumulator;
};
#endif

////////////////////////////////////////////////////////////////////////////////
//
// A scope timer. It will trace the time that passed from the instanciation
//   to the end of the scope.
//       (See cpptest.cpp in the Sample)
//
// It is be used to compute times of function etc.
//
//  tag   - the tag to trace to
//  string - a prefix
//
////////////////////////////////////////////////////////////////////////////////
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
#define ScopeTimer(tag, string) CTracerScopeTimer       __scopetimer(tag, string)
#else
#define ScopeTimer(tag, string)
#endif

////////////////////////////////////////////////////////////////////////////////
//
// A scope timer that uses and updates an accumulator timer.
//   It will trace the time that passed from the instanciation
//   to the end of the scope and tell this time to the accumulator as well.
//       (See cpptest.cpp in the Sample)
//
//  tag   - the tag to trace to
//  string - a prefix
//  actimer - an AccumulatingTimer object.
//
//     comment - if both the scope timer and the accumulating timer has the
//                 same tags - the scope timer will not trace.
//
////////////////////////////////////////////////////////////////////////////////
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
#define ScopeAccumulatingTimer(tag, string, actimer) \
CTracerScopeTimer       __scopetimer(tag, string, actimer)
#else
#define ScopeAccumulatingTimer(tag, string, actimer)
#endif

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
class CTracerScopeTimer
{
  public:
    CTracerScopeTimer(
        TAG tag,
        PSZ pszSomeText = NULL,
        CTracerAccumulatingTimer *pTimer = NULL)
        :m_ulStartTimeInMiliseconds(GetTickCount())
        ,m_tagTheTagToTraceTo(tag)
        ,m_pAccumulator(pTimer)
    {
        if (pszSomeText)
            strncpy(m_rchText, pszSomeText, MAX_PATH);
        else
            m_rchText[0] = '\0';
    }


    ~CTracerScopeTimer()
    {
        ULONG   ulFinishTimeInMiliseconds = GetTickCount();
        ULONG   ulStartToFinishTimeInMiliseconds;

        if (ulFinishTimeInMiliseconds >
            m_ulStartTimeInMiliseconds)
            ulStartToFinishTimeInMiliseconds =
            ulFinishTimeInMiliseconds - m_ulStartTimeInMiliseconds;
        else
            ulStartToFinishTimeInMiliseconds =
                ulFinishTimeInMiliseconds + 1 +
                    (0xffffffff - m_ulStartTimeInMiliseconds);

        if(!m_pAccumulator ||
            (m_tagTheTagToTraceTo != (ULONG)(*m_pAccumulator)))
            Trace((
                elInfo,
                m_tagTheTagToTraceTo,
                "%s took %d miliseconds",
                m_rchText,
                ulStartToFinishTimeInMiliseconds));

        if(m_pAccumulator)
            m_pAccumulator->AddEvent(
                ulStartToFinishTimeInMiliseconds,
                m_rchText);
    }

  protected:
    // The counter
    ULONG   m_ulStartTimeInMiliseconds;

    // The tag the trace will use.
    TAG     m_tagTheTagToTraceTo;

    // some text to specify which scope or code block is it
    char    m_rchText[MAX_PATH + 1];

    // pointer to accumulating time
    CTracerAccumulatingTimer        *m_pAccumulator;
};
#endif
#endif /* __cplusplus */



#endif // _TRACER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\tracer\src\tracmain.cpp ===
#include "tracer.h"
#include "tracmain.h"
#include "tracerdefault.h"

#pragma warning( disable : 4073 )
#pragma init_seg(lib)
#pragma warning( default : 4073 )

BOOL    g_fIsWinNt = TRUE;
CInitTracerGlobals g_InitTracerGlobals;

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
////////////////////////////////////////////////////////////////////////////////
//
// Critical section object.
//
////////////////////////////////////////////////////////////////////////////////

class CTracerCriticalSection : protected CRITICAL_SECTION
{
  public:
    CTracerCriticalSection()
    {
        InitializeCriticalSection(this);
    }

    ~CTracerCriticalSection()
    {
        DeleteCriticalSection(this);
    }

    void Lock(ULONG = 0)
    {
        EnterCriticalSection(this);
    }

    void Unlock()
    {
        LeaveCriticalSection(this);
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// Critical section catcher
//
////////////////////////////////////////////////////////////////////////////////

class CTracerCriticalSectionCatcher
{
  public:
    CTracerCriticalSectionCatcher(CTracerCriticalSection& tcs)
        :m_refCritSect(tcs)
    {
        m_refCritSect.Lock();
    }

    ~CTracerCriticalSectionCatcher()
    {
        m_refCritSect.Unlock();
    }

  private:
    CTracerCriticalSection&   m_refCritSect;
};


static PSZ s_aTracerFlagsNames[] =
{
    "Device flag",
    "Error level",
    "Assert level",
    "Print location",
    "Print program name",
    "Print time",
    "Print thread id",
    "Print error level",
    "Print tag id",
    "Print tag name",
    "Print process id"
};

static PSZ s_aTagNames[] =
{
    "Out of Tag Array",
    "General traces",
    "Errors",
    "Warnings",
    "Information"
};

extern "C" CTracer*             g_pTracer = NULL;
static CNullTracer              s_ReplacementTracer;
static CMainTracer              s_MainTracer;

static CTracerCriticalSection   s_TracerCriticalSection;
static CLongTrace               *s_theLongTrace = NULL;

DECLARE_GLOBAL_TAG(tagError, "Errors");
DECLARE_GLOBAL_TAG(tagWarning, "Warnings");
DECLARE_GLOBAL_TAG(tagInformation, "Information");
DECLARE_GLOBAL_TAG(tagVerbose, "Verbose");
DECLARE_GLOBAL_TAG(tagGeneral, "General");

CNullTracer::CNullTracer()
{
    m_aTags = m_Tags;
    m_aFlags = m_Flags;
    m_ptagNextTagId = NULL;
    m_pulNumOfFlagEntries = NULL;
    g_pTracer = this;

}

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CMainTracer - implementation
//
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::CMainTracer
//      Purpose  :  Constructor.
//
//      Parameters:
//          [in]    PSZ         pszRegistryPath - the key to take our data from.
//          [in]    DEALLOCATOR pfuncDealloc - the function with whom to
//                                                deallocate ourselves.
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib   Creation
//          Sep  5 1999 orenk  Single allocation of tag array done here
//          Jun 12 2000 yairh Initialize mutex that protects log file creation.
//
////////////////////////////////////////////////////////////////////////////////

CMainTracer::CMainTracer()
{
    try
    {
        m_bNeedToCreatOrAttachToLogFile = TRUE;
        m_pszLogName = NULL;
        m_LogState = logUseAppName;

        m_mCreateLogFile.Init(NULL);

        m_mTagId.Init("Tracer_Tag_ID_Incrementation_Protector");
        CMutexCatcher   cMutexForTagIdIncrementation(m_mTagId);
        g_fIsWinNt = IsWinNt();

        char        pszErrBuffer[TRACER_MAX_TRACE];

        DWORD dwLen = GetEnvironmentVariable(
                                    "SystemDrive",
                                    m_pszSysDrive,
                                    MAX_PATH);
        if (0 == dwLen)
        {
            dwLen = GetSystemDirectory( m_pszSysDrive, MAX_PATH );

            if (1 >= dwLen || m_pszSysDrive[1] != ':' )
            {
                sprintf(pszErrBuffer, "%s Error %x\r\n",
                        "Failed to find System drive. "
                        "Tracing is disabled",
                        GetLastError());
                Log(TRACER_DEVICE_FLAG_DEBUGOUT, pszErrBuffer);
                return;
            }

            dwLen = 2;
            m_pszSysDrive[ dwLen ] = '\0';
        }

        if (dwLen > MAX_PATH)
        {
            Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                "System drive path is greater then MAX_PATH."
                "Tracing is disabled\r\n");
            return;
        }

        char    pszBuffer[MAX_PATH + 1];
        PSZ     pszFileName;
        ULONG   ulProgramNameLength;

        ulProgramNameLength = GetModuleFileName(
                                            NULL,
                                            pszBuffer,
                                            MAX_PATH);
        pszBuffer[ulProgramNameLength] = '\0';
        if (0 == _stricmp(pszBuffer + ulProgramNameLength - 4, ".exe"))
        {
            pszBuffer[ulProgramNameLength - 4] = '\0';
        }

        // Verify it is NULL terminated.
        pszFileName = strrchr(pszBuffer, '\\');

        // Remember only the file name.
        strncpy(
            m_pszProgramName,
            (pszFileName ? pszFileName + 1 : pszBuffer),
            TRACER_MAX_PROGRAM_NAME);

        ulProgramNameLength = strlen(m_pszProgramName);

        // My own preference.
        _strlwr(m_pszProgramName);

        m_fIsRunningAsService = ::IsRunningAsService();

        //
        // opening the shared memory
        //

        LPSECURITY_ATTRIBUTES lpSecAttr = NULL;
        SECURITY_DESCRIPTOR sdKeySecurity;
        SECURITY_ATTRIBUTES saKeyAttributes =
        {
            sizeof(SECURITY_ATTRIBUTES),
            &sdKeySecurity,
            FALSE
        };


        if(g_fIsWinNt)
        {
            if (!InitializeSecurityDescriptor(
                                    &sdKeySecurity,
                                    SECURITY_DESCRIPTOR_REVISION))
            {
                sprintf(pszErrBuffer, "%s Error %x\r\n",
                        "InitializeSecurityDescriptor failed "
                        "Tracing is disabled\r\n",
                        GetLastError());

                Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                    pszErrBuffer);
                return;
            }

            if (!SetSecurityDescriptorDacl(
                                &sdKeySecurity,
                                TRUE,
                                FALSE,
                                FALSE))
            {
                sprintf(pszErrBuffer, "%s Error %x\r\n",
                        "SetSecurityDescriptorDacl failed "
                        "Tracing is disabled\r\n",
                        GetLastError());

                Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                    pszErrBuffer);
                return;
            }

            lpSecAttr = &saKeyAttributes;
        }

        strcpy(pszBuffer, m_pszSysDrive);
        strcat(pszBuffer, "\\PKM_TRACER");

#if defined(_DONT_CREATE_TRACER_DIRECTROY)
        {
            //
            // in this option the tracer is disabled unless the TRACER directory
            // exist.
            //

            CAutoHandle ah;
            ah = CreateFile(
                        pszBuffer,
                        0,
                        0,
                        lpSecAttr,
                        OPEN_EXISTING ,
                        FILE_FLAG_BACKUP_SEMANTICS,
                        NULL);
            if (BAD_HANDLE((HANDLE)ah))
            {
                //
                // the directory does not exist.
                //
                return;
            }

        }
#else
        if (false == CreateDirectory(pszBuffer, NULL))
        {
            if (GetLastError() != ERROR_ALREADY_EXISTS)
            {
                sprintf(pszErrBuffer, "%s Error %x\r\n",
                        "Fail To create tracer directory"
                        "Tracing is disabled\r\n",
                        GetLastError());

                Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                    pszErrBuffer);
                return;
            }
        }
#endif


        strcat(pszBuffer, "\\");
        strcat(pszBuffer, m_pszProgramName);
        strcat(pszBuffer, ".trc");
        bool bExistingFile = false;
        m_ahSharedMemoryFile = CreateFile(
                                    pszBuffer,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    lpSecAttr,
                                    OPEN_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
        if (BAD_HANDLE((HANDLE)m_ahSharedMemoryFile))
        {
            sprintf(pszErrBuffer, "%s error %x\r\n",
                    "Fail To open the shared memory file."
                    "Tracing is disabled\r\n",
                    GetLastError());

            Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                pszErrBuffer);
            return;
        }

        if (ERROR_ALREADY_EXISTS  == GetLastError())
        {
            bExistingFile = true;
        }

        strcpy(pszBuffer, m_pszProgramName);
        strcat(pszBuffer, "_SharedMemory");

        m_ahSharedMemory = CreateFileMapping(
                                    (HANDLE)m_ahSharedMemoryFile,
                                    lpSecAttr,
                                    PAGE_READWRITE,
                                    0,
                                    (MAX_TAG_NUMBER + LAST_FLAG + 10) * sizeof(DWORD),
                                    pszBuffer);
        if (BAD_HANDLE((HANDLE)m_ahSharedMemory))
        {
             sprintf(pszErrBuffer, "%s error %x\r\n",
                    "Fail To open the shared memory object."
                    "Tracing is disabled\r\n",
                    GetLastError());

             Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                pszErrBuffer);

            return;
        }

        PBYTE pbMem = (PBYTE) MapViewOfFile(
                                (HANDLE) m_ahSharedMemory,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0);
        if (!pbMem)
        {
             sprintf(pszErrBuffer, "%s error %x\r\n",
                    "Fail To map view of file."
                    "Tracing is disabled\r\n",
                    GetLastError());

             Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                pszErrBuffer);

             return;
        }

        m_amSharedMemory = pbMem;

        if (bExistingFile)
        {
            bool fRet = ReadFromExistingSharedMemory(pbMem);
            if (false == fRet)
            {
                return;
            }
        }
        else
        {
            bool fRet = InitializeSharedMemory(pbMem);
            if (false == fRet)
            {
                return;
            }
        }

    }
    catch(...)
    {
        Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            "Fail To initialize the tracer."
            "Tracing is disabled\r\n");
        return;
    }

    g_pTracer = this;
}

CMainTracer::~CMainTracer()
{
}

bool CMainTracer::ReadFromExistingSharedMemory(PBYTE pbMem)
{
    bool bRet = ::ReadFromExistingSharedMemory(
                                        pbMem,
                                        &m_pulNumOfFlagEntries,
                                        &m_aFlags,
                                        &m_ptagNextTagId,
                                        &m_aTags);

    if (!bRet)
    {
        Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            "Invalid shared memory file"
            "Tracing is desabled\r\n");
        return false;
    }

    return true;
}

bool CMainTracer::InitializeSharedMemory(PBYTE pbMem)
{
    char* pszTracerStamp = (char*) (pbMem + TRACER_STAMP_OFFSET);
    strcpy(pszTracerStamp, TRACER_STAMP);

    ULONG* pulFlagsTableOffset = (ULONG*) (pbMem + TRACER_FLAGS_TABLE_OFFSET);
    ULONG* pulTagsTableOffset =  (ULONG*) (pbMem + TAGS_TABLE_OFFSET);

    *pulFlagsTableOffset = LAST_OFFSET;

    m_pulNumOfFlagEntries = (ULONG*) (pbMem + *pulFlagsTableOffset);
    *m_pulNumOfFlagEntries = LAST_FLAG;

    m_aFlags = (CTracerFlagEntry*) (m_pulNumOfFlagEntries + 1);

    for (ULONG ul = 0; ul < LAST_FLAG; ul++)
    {
        m_aFlags[ul].m_ulFlagValue = 0;
        strcpy(m_aFlags[ul].m_pszName, s_aTracerFlagsNames[ul]);
    }

    m_aFlags[DEVICE_FLAG].m_ulFlagValue        = DEVICE_FLAG_DEFAULT;
    m_aFlags[ERROR_LEVEL_FLAG].m_ulFlagValue   = TRACER_ERROR_LEVEL_DEFAULT;
    m_aFlags[ASSERT_LEVEL_FLAG].m_ulFlagValue  = TRACER_ASSERT_LEVEL_DEFAULT;
    m_aFlags[PRINT_LOCATION].m_ulFlagValue     = PRINT_LOCATION_DEFAULT;
    m_aFlags[PRINT_PROGRAM_NAME].m_ulFlagValue = PRINT_PROGRAM_NAME_DEFAULT;
    m_aFlags[PRINT_TIME].m_ulFlagValue         = PRINT_TIME_DEFAULT;
    m_aFlags[PRINT_THREAD_ID].m_ulFlagValue    = PRINT_THREAD_ID_DEFAULT;
    m_aFlags[PRINT_ERROR_LEVEL].m_ulFlagValue  = PRINT_ERROR_LEVEL_DEFAULT;
    m_aFlags[PRINT_TAG_ID].m_ulFlagValue       = PRINT_TAG_ID_DEFAULT;
    m_aFlags[PRINT_TAG_NAME].m_ulFlagValue     = PRINT_TAG_NAME_DEFUALT;
    m_aFlags[PRINT_PROCESS_ID].m_ulFlagValue   = PRINT_PROCCESS_ID_DEFAULT;

    *pulTagsTableOffset = (ULONG)(ULONG_PTR)(((PBYTE) (m_aFlags + (ULONG_PTR)(*m_pulNumOfFlagEntries))) - pbMem);

    m_ptagNextTagId = (TAG*) (pbMem + *pulTagsTableOffset);
    *m_ptagNextTagId = 0;
    m_aTags = (CTracerTagEntry*) (m_ptagNextTagId + 1);

    for (ul = 0; ul < TAG_LAST; ul++)
    {
        m_aTags[ul].m_TagErrLevel = TAG_ERROR_LEVEL_DEFAULT;
        strcpy(m_aTags[ul].m_pszTagName, s_aTagNames[ul]);
    }

    *m_ptagNextTagId  = TAG_LAST;

    return true;
}

HRESULT CMainTracer::RegisterTagSZ(LPCSTR pszTagName, TAG& ulTagId)
{
    CMutexCatcher   cMutexForTagIdIncrementation(m_mTagId);

    ULONG ul;
    for (ul = 0; ul < *m_ptagNextTagId; ul++)
    {
        if (0 == strncmp(pszTagName, m_aTags[ul].m_pszTagName, MAX_TAG_NAME - 1))
        {
            ulTagId = ul;
            return S_OK;
        }
    }

    if (*m_ptagNextTagId >= MAX_TAG_NUMBER)
    {
        char    pszBuffer[1000];

        _snprintf(pszBuffer, 999, "Tags Overflow!: tag \"%s\" exceeds array bounds (%d) and will be ignored."
                                  "Call the build man!!!\r\n",pszTagName, MAX_TAG_NUMBER);

        Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            pszBuffer);

        ulTagId = TAG_OUT_OF_TAG_ARRAY;
        return S_OK;
    }

    m_aTags[*m_ptagNextTagId].m_TagErrLevel = TAG_ERROR_LEVEL_DEFAULT;
    strncpy(m_aTags[*m_ptagNextTagId].m_pszTagName, pszTagName, MAX_TAG_NAME - 1);
    m_aTags[*m_ptagNextTagId].m_pszTagName[MAX_TAG_NAME] = '\0';
    ulTagId = *m_ptagNextTagId;

    (*m_ptagNextTagId)++;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::TraceSZ
//      Purpose  :  To trace out the printf formatted data according to the
//                    error level and tag.
//
//      Parameters:
//          [in]    DWORD       dwError
//          [in]    LPCSTR      pszFile
//          [in]    int         iLine
//          [in]    ERROR_LEVEL el
//          [in]    TAG         tag
//          [in]    LPCSTR      pszFormatString
//          [in]    ...
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Creation
//          Feb 11 1997 urib Support UNICODE format string.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CMainTracer::TraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    LPCSTR      pszFormatString,
    ...)
{
    va_list arglist;

    va_start(arglist, pszFormatString);

    VaTraceSZ(dwError, pszFile, iLine, el, tag, pszFormatString, arglist);
}

void
CMainTracer::TraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    PCWSTR      pwszFormatString,
    ...)
{
    va_list arglist;

    va_start(arglist, pwszFormatString);

    VaTraceSZ(dwError, pszFile, iLine, el, tag, pwszFormatString, arglist);
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::VaTraceSZ
//      Purpose  :  To trace out the printf formatted data according to the
//                    error level and tag.
//
//      Parameters:
//          [in]    DWORD       dwError
//          [in]    LPCSTR      pszFile
//          [in]    int         iLine
//          [in]    ERROR_LEVEL el
//          [in]    TAG         tag
//          [in]    LPCSTR      pszFormatString
//          [in]    va_list     arglist
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Creation
//          Dec 10 1996 urib Fix TraceSZ to VaTraceSZ.
//          Feb 11 1997 urib Support UNICODE format string.
//          Apr 12 1998 urib Add time to log.
//          Apr 12 1999 urib Make error level printing compatible between
//                             the two function versions. Don't add a second
//                             newline (From MicahK).
//          Sep  9 1999 orenk Check for tags out of array bounds.
//
//
////////////////////////////////////////////////////////////////////////////////
void
CMainTracer::VaTraceSZ(
            DWORD       dwError,
            LPCSTR      pszFile,
            int         iLine,
            ERROR_LEVEL el,
            TAG         tag,
            LPCSTR      pszFormatString,
            va_list     arglist)
{
    char        pszBuffer[TRACER_MAX_TRACE];
    int         iCharsWritten = 0;
    DWORD       dwDeviceFlags = m_aFlags[DEVICE_FLAG].m_ulFlagValue;
    SYSTEMTIME  st;


    bool fTwoLinesLogMsg = false;
    if (dwError || m_aFlags[PRINT_LOCATION].m_ulFlagValue)
    {
        if (pszFile)
        {
            iCharsWritten += sprintf(
                pszBuffer + iCharsWritten,
                "%s(%d) : ",
                pszFile,
                iLine
                );
        }
        if ( dwError )
        {
            iCharsWritten += sprintf(
                pszBuffer + iCharsWritten,
                "Err: 0x%08x=",
                dwError
                );

            DWORD dwMsgLen = GetErrorStringFromCode( dwError,
                                          pszBuffer+iCharsWritten,
                                          TRACER_MAX_TRACE - iCharsWritten );
            if ( dwMsgLen )
            {
                iCharsWritten += (int) dwMsgLen;
            }
        }

        if (iCharsWritten)
        {
            pszBuffer[iCharsWritten++] = '\r';
            pszBuffer[iCharsWritten++] = '\n';
            pszBuffer[iCharsWritten] = '\0';
            Log(dwDeviceFlags, pszBuffer);
            fTwoLinesLogMsg = true;
        }

    }

    iCharsWritten = 0;

    if (fTwoLinesLogMsg)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "   "
            );
    }

    GetLocalTime(&st);

    if (m_aFlags[PRINT_PROGRAM_NAME].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "%s ",
            m_pszProgramName
            );
    }

    if (m_aFlags[PRINT_TIME].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            " %02d:%02d:%02d.%03d ",
            st.wHour,
            st.wMinute,
            st.wSecond,
            st.wMilliseconds
            );
    }

    if (m_aFlags[PRINT_ERROR_LEVEL].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "el:%x ",
            el
            );
    }

    if (m_aFlags[PRINT_TAG_ID].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "tagid:%-3x ",
            tag
            );
    }

    if (m_aFlags[PRINT_TAG_NAME].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "tag:\"%s\" ",
            m_aTags[tag].m_pszTagName
            );
    }

    if (m_aFlags[PRINT_PROCESS_ID].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "pid:0x%-4x ",
            GetCurrentProcessId()
            );
    }

    if (m_aFlags[PRINT_THREAD_ID].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "tid:0x%-4x ",
            GetCurrentThreadId()
            );
    }


    int iRet;
    iRet = _vsnprintf(
        pszBuffer + iCharsWritten,
        TRACER_MAX_TRACE - iCharsWritten - 5, // I like this number.
        pszFormatString,
        arglist);

    if (-1 == iRet)
    {
        iCharsWritten = TRACER_MAX_TRACE;
    }
    else
    {
        iCharsWritten += iRet;
    }

    if (iCharsWritten > TRACER_MAX_TRACE - 3)
    {
        iCharsWritten = TRACER_MAX_TRACE - 3;
    }

    if (pszBuffer[iCharsWritten-1] != '\n')
    {
        pszBuffer[iCharsWritten++] = '\r';
        pszBuffer[iCharsWritten++] = '\n';
    }
    pszBuffer[iCharsWritten] = '\0';

    Log(dwDeviceFlags, pszBuffer);

}

void
CMainTracer::RawVaTraceSZ(
            LPCSTR      pszFormatString,
            va_list     arglist)
{
    char        pszBuffer[TRACER_MAX_TRACE];
    int         iCharsWritten = 0;
    iCharsWritten = _vsnprintf(
        pszBuffer,
        TRACER_MAX_TRACE - 5, // I like this number.
        pszFormatString,
        arglist);

    if (iCharsWritten < 0)
    {
        iCharsWritten = 0;
    }
    pszBuffer[iCharsWritten] = '\0';

    Log(m_aFlags[DEVICE_FLAG].m_ulFlagValue, pszBuffer);
}


void
CMainTracer::VaTraceSZ(
            DWORD       dwError,
            LPCSTR      pszFile,
            int         iLine,
            ERROR_LEVEL el,
            TAG         tag,
            PCWSTR      pwszFormatString,
            va_list     arglist)
{
    WCHAR       rwchBuffer[TRACER_MAX_TRACE];
    int         iCharsWritten = 0;
    DWORD       dwDeviceFlags = m_aFlags[DEVICE_FLAG].m_ulFlagValue;
    SYSTEMTIME  st;

    bool fTwoLinesLogMsg = false;

    if (dwError || m_aFlags[PRINT_LOCATION].m_ulFlagValue)
    {
        char rpszBuff[TRACER_MAX_TRACE];

        if (pszFile)
        {
            iCharsWritten += sprintf(
                rpszBuff+iCharsWritten,
                "%s(%d) : ",
                pszFile,
                iLine
                );
        }
        if ( dwError )
        {

            iCharsWritten += sprintf(
                rpszBuff + iCharsWritten,
                "Err: 0x%08x=",
                dwError
                );


            DWORD dwMsgLen = GetErrorStringFromCode(
                                          dwError,
                                          rpszBuff + iCharsWritten,
                                          TRACER_MAX_TRACE - iCharsWritten);
            iCharsWritten += dwMsgLen;
        }

        if (iCharsWritten)
        {
            rpszBuff[iCharsWritten++] = '\r';
            rpszBuff[iCharsWritten++] = '\n';
            rpszBuff[iCharsWritten] = '\0';
            Log(dwDeviceFlags, rpszBuff);
            fTwoLinesLogMsg = true;
        }
    }

    GetLocalTime(&st);
    iCharsWritten = 0;

    if (fTwoLinesLogMsg)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"   "
            );
    }

    if (m_aFlags[PRINT_PROGRAM_NAME].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"%S ",
            m_pszProgramName
            );
    }

    if (m_aFlags[PRINT_TIME].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L" %02d:%02d:%02d.%03d ",
            st.wHour,
            st.wMinute,
            st.wSecond,
            st.wMilliseconds
            );
    }

    if (m_aFlags[PRINT_ERROR_LEVEL].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"el:0x%x ",
            el
            );
    }

    if (m_aFlags[PRINT_TAG_ID].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"tagid:0x%x ",
            tag
            );
    }

    if (m_aFlags[PRINT_TAG_NAME].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"tag:\"%S\" ",
            m_aTags[tag].m_pszTagName
            );
    }

    if (m_aFlags[PRINT_PROCESS_ID].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"pid:0x%x ",
            GetCurrentProcessId()
            );
    }

    if (m_aFlags[PRINT_THREAD_ID].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"tid:0x%x ",
            GetCurrentThreadId()
            );
    }

    int iRet;
    iRet = _vsnwprintf(
        rwchBuffer + iCharsWritten,
        TRACER_MAX_TRACE - iCharsWritten - 5, // I like this number.
        pwszFormatString,
        arglist);

    if (-1 == iRet)
    {
        iCharsWritten = TRACER_MAX_TRACE;
    }
    else
    {
        iCharsWritten += iRet;
    }

    if (iCharsWritten > TRACER_MAX_TRACE - 3)
    {
        iCharsWritten = TRACER_MAX_TRACE - 3;
    }

    rwchBuffer[iCharsWritten++] = L'\r';
    rwchBuffer[iCharsWritten++] = L'\n';
    rwchBuffer[iCharsWritten] = L'\0';

    Log(dwDeviceFlags, rwchBuffer);

    iCharsWritten = 0;


}

void
CMainTracer::RawVaTraceSZ(
            LPCWSTR     pwszFormatString,
            va_list     arglist)
{
    WCHAR       rwchBuffer[TRACER_MAX_TRACE];
    int         iCharsWritten = 0;
    iCharsWritten += _vsnwprintf(
        rwchBuffer + iCharsWritten,
        TRACER_MAX_TRACE - iCharsWritten - 5, // I like this number.
        pwszFormatString,
        arglist);

    rwchBuffer[iCharsWritten] = L'\0';

    Log(m_aFlags[DEVICE_FLAG].m_ulFlagValue, rwchBuffer);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::Log
//      Purpose  :  To actually print the formatted data.
//
//      Parameters:
//          [in]        DWORD   dwDevicesFlags - flags to say where to print
//          [in]        LPSTR   pszText        - buffer to print.
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib  Creation
//          Feb 11 1997 urib  Support UNICODE format string.
//          Mar  2 1997 urib  Fix fprintf usage bug.
//          Jun  2 1997 urib  Fix bug - fclose file only if it is open!
//          Aug 13 1998 urib  Restore last error if we overrided it.
//          Jun 12 2000 yairh Protect writing only. Log file creation protection
//                              is inside CreatOrAttachToLogFile.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CMainTracer::Log(DWORD dwDevicesFlags, LPSTR pszText)
{
    LONG        lError = GetLastError();

    // debug trace
    if (TRACER_DEVICE_FLAG_DEBUGOUT & dwDevicesFlags)
        OutputDebugString(pszText);

    // Disk file trace
    if (TRACER_DEVICE_FLAG_FILE & dwDevicesFlags)
    {
        if (m_bNeedToCreatOrAttachToLogFile)
        {
            CreatOrAttachToLogFile();
        }

        if (m_pszLog)
        {
            CMutexCatcher   cMutexForTagIdIncrementation(m_mLogFile);
            ULONG ulSize = strlen(pszText);

            if (*m_pulNextFreeSpaceInLogFile + ulSize > LOG_FILE_SIZE - 0x10)
            {
                char pszBuf[MAX_PATH];
                char pszBuf1[MAX_PATH];

                strcpy(pszBuf, m_pszSysDrive);
                strcat(pszBuf, "\\PKM_TRACER\\");
                strcat(pszBuf, m_pszLogName);
                strcat(pszBuf, ".log");

                strcpy(pszBuf1, pszBuf);
                strcat(pszBuf1, ".old");
                CopyFile(pszBuf, pszBuf1, false);
                memset(m_pszLog, 0, LOG_FILE_SIZE);
                *m_pulNextFreeSpaceInLogFile = LOG_START_POINT;
                *(m_pszLog + sizeof(ULONG)) = '\r';
                *(m_pszLog + sizeof(ULONG) + sizeof(char)) = '\n';
            }

            memcpy(m_pszLog + *m_pulNextFreeSpaceInLogFile, pszText, ulSize);
            *m_pulNextFreeSpaceInLogFile = *m_pulNextFreeSpaceInLogFile + ulSize;
        }
    }
    // stderr trace
    if (TRACER_DEVICE_FLAG_STDERR & dwDevicesFlags)
        fprintf(stderr, "%s", pszText);

    // stdout trace
    if (TRACER_DEVICE_FLAG_STDOUT & dwDevicesFlags)
        fprintf(stdout, "%s", pszText);

    SetLastError(lError);
}

void
CMainTracer::Log(DWORD dwDevicesFlags, PWSTR pwszText)
{
    LONG        lError = GetLastError();

    // debug trace
    if (TRACER_DEVICE_FLAG_DEBUGOUT & dwDevicesFlags)
        OutputDebugStringW(pwszText);

    // Disk file trace
    if (TRACER_DEVICE_FLAG_FILE & dwDevicesFlags)
    {
        if (m_bNeedToCreatOrAttachToLogFile)
        {
            CreatOrAttachToLogFile();
        }
        if (m_pszLog)
        {
            CMutexCatcher   cMutexForTagIdIncrementation(m_mLogFile);
            ULONG ulSize = wcslen(pwszText);

            if (*m_pulNextFreeSpaceInLogFile + ulSize > LOG_FILE_SIZE - 0x10)
            {
                char pszBuf[MAX_PATH];
                char pszBuf1[MAX_PATH];

                strcpy(pszBuf, m_pszSysDrive);
                strcat(pszBuf, "\\PKM_TRACER\\");
                strcat(pszBuf, m_pszLogName);
                strcat(pszBuf, ".log");

                strcpy(pszBuf1, pszBuf);
                strcat(pszBuf1, ".old");
                CopyFile(pszBuf, pszBuf1, false);
                memset(m_pszLog, 0, LOG_FILE_SIZE);
                *m_pulNextFreeSpaceInLogFile = LOG_START_POINT;
                *(m_pszLog + sizeof(ULONG)) = '\r';
                *(m_pszLog + sizeof(ULONG) + sizeof(char)) = '\n';
            }

            ulSize = wcstombs(
                            m_pszLog + *m_pulNextFreeSpaceInLogFile,
                            pwszText,
                            ulSize);
            if (ulSize != -1)
            {
                *m_pulNextFreeSpaceInLogFile = *m_pulNextFreeSpaceInLogFile + ulSize;
            }
        }
    }

    // stderr trace
    if (TRACER_DEVICE_FLAG_STDERR & dwDevicesFlags)
        fprintf(stderr, "%S", pwszText);

    // stdout trace
    if (TRACER_DEVICE_FLAG_STDOUT & dwDevicesFlags)
        fprintf(stdout, "%S", pwszText);

    SetLastError(lError);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::TraceAssertSZ
//      Purpose  :  To trace data on the failed assertion.
//
//      Parameters:
//          [in]  LPCSTR pszTestSring - assertion test expression
//          [in]  LPCSTR pszText      - some text attached
//          [in]  LPCSTR pszFile      - source file name
//          [in]  int    iLine        - source line number
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib  Creation
//          Feb  2 1997 urib  First write the assert line and message box later.
//          Feb 11 1997 urib  Better service assert.
//          May 10 1999 urib  Add message to msgbox.
//
//////////////////////////////////////////////////////////////////////////////*/

void
CMainTracer::TraceAssertSZ(
      LPCSTR    pszTestSring,
      LPCSTR    pszText,
      LPCSTR    pszFile,
      int       iLine)
{
    char    buff[TRACER_MAX_TRACE + 1];
    DWORD dwAssertLevel = m_aFlags[ASSERT_LEVEL_FLAG].m_ulFlagValue;
    BOOL fBreak = FALSE;

    if ( dwAssertLevel & ASSERT_LEVEL_MESSAGE )
    {
        TraceSZ(
            0,
            pszFile,
            iLine,
            elError,
            tagError,
            "Assertion failed : %s : \"%s\" == 0 ",
            pszText,
            pszTestSring);
    }


    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    int id = 0;

    BOOL    fDebugAPIPresent = FALSE;
    LocalIsDebuggerPresent(&fDebugAPIPresent);

    if ( IsRunningAsService())
    {
        if ( dwAssertLevel & ASSERT_LEVEL_LOOP )
        {
            TraceSZ(0, pszFile, iLine,elCrash, tagError, "Stuck in assert."
                    "In order to release - set a breakpoint in file :%s"
                    " in line %d. When it breaks, set the next instruction "
                    "to be the \"ulNextInstruction\" line after the loop.",
                    __FILE__,
                    __LINE__);
            while (1)
                Sleep(1000);

            ULONG ulNextInstruction = 0;
        }
        else if (dwAssertLevel & ASSERT_LEVEL_POPUP)
        {
           _snprintf(
               buff, TRACER_MAX_TRACE,
               "Assert: %s: Expression: %s\r\n\r\nProcess: "
               "%s\r\n\r\nProcessID.ThreadID: %d.%d\r\n\r\nFile:"
               " %s\r\n\r\nLine: %u",
               pszText, pszTestSring, m_pszProgramName, pid, tid, pszFile, iLine );

            id = MessageBox(NULL,
                            buff,
                            m_pszProgramName,
                            MB_SETFOREGROUND | MB_DEFAULT_DESKTOP_ONLY |
                            MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL);

            //
            // If id == 0, then an error occurred.  There are two possibilities
            //   that can cause the error:  Access Denied, which means that this
            //   process does not have access to the default desktop, and
            //   everything else (usually out of memory).
            //

            if (!id)
            {
#ifdef _WIN32_WINNT
                    //
                    // Retry this one with the SERVICE_NOTIFICATION flag on.
                    // That should get us to the right desktop.
                    //
                    UINT uOldErrorMode = SetErrorMode(0);

                    id = MessageBox(NULL,
                            buff,
                            m_pszProgramName,
                            MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION |
                            MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL);

                    SetErrorMode(uOldErrorMode);
#endif //_WIN32_WINNT
            }

            if ( IDCANCEL == id )
            {
                fBreak = TRUE;
            }
        }
        else if( dwAssertLevel & ASSERT_LEVEL_BREAK )
        {
            fBreak = TRUE;
        }
    }
    else if ( dwAssertLevel & ASSERT_LEVEL_POPUP )
    {
       _snprintf(
           buff, TRACER_MAX_TRACE,
           "Assert: %s: Expression: %s\r\n\r\nProcess: "
           "%s\r\n\r\nProcessID.ThreadID: %d.%d\r\n\r\nFile:"
           " %s\r\n\r\nLine: %u",
           pszText, pszTestSring, m_pszProgramName, pid, tid, pszFile, iLine );

        id =  MessageBox(NULL, buff, m_pszProgramName, MB_ICONSTOP|MB_OKCANCEL);

        if ( IDCANCEL == id )
        {
            fBreak = TRUE;
        }

    }
    else if( dwAssertLevel & ASSERT_LEVEL_BREAK )
    {
        fBreak = TRUE;
    }
    if( fBreak )
    {
        if(fDebugAPIPresent)
        {
            while( !LocalIsDebuggerPresent(&fDebugAPIPresent) )
            {
                _snprintf(
                       buff,
                       TRACER_MAX_TRACE,
                       "In order to debug the assert you need to attach a debugger to process %d",
                       GetCurrentProcessId());

                MessageBox(NULL,
                        buff,
                        m_pszProgramName,
                        MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION |
                        MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OK);
            }
        }

        DebugBreak();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMainTracer::GetErrorStringFromCode
//
//  Synopsis:   Fetches the value of the error string from the error code
//
//  Arguments:  [dwError]   - Error code
//              [pszBuffer] - Buffer in which to put the error string
//              [ccBuffer]  - Maximum number of chars to put into the string,
//              including the null terminator.
//
//  Returns:    TRUE if successful, FALSE o/w
//
//  History:    12-13-98   srikants   Created
//
//  Notes:      Currently it handles only WIN32 errors. It needs to be enhanced
//              to include ole errors, search errors, etc.
//
//----------------------------------------------------------------------------

DWORD CMainTracer::GetErrorStringFromCode(
    DWORD dwError,
    char * pszBuffer,
    ULONG ccBuffer )
{
    Assert( dwError );  // This should not get called if dwError is 0
    Assert( pszBuffer );
    Assert( ccBuffer > 1 );

    DWORD dwLen = FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM,
                                  NULL,
                                  HRESULT_CODE(dwError),
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  pszBuffer,
                                  ccBuffer-1,
                                  NULL);

    return dwLen;

}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::LocalIsDebuggerPresent
//      Purpose  :  The wrapper around IsDebuggerPresent() API
//                  Will also return the information about whether the actual API is available or not
//
//      Parameters:
//          [BOOL* pfIsAPIAvailable]    - returns FALSE if there's no API (WIN95 case)
//
//      Log:
//          Feb 23 2000      eugenesa   Created
//
//////////////////////////////////////////////////////////////////////////////*/

typedef BOOL (WINAPI *PfnIsDebuggerPresent) (VOID);
static LPCSTR s_kernel32 = "kernel32";

BOOL
CMainTracer::LocalIsDebuggerPresent(BOOL* pfIsAPIAvailable)
{
    static PfnIsDebuggerPresent s_pfnIsDebuggerPresent  = (PfnIsDebuggerPresent)::GetProcAddress( ::GetModuleHandle(s_kernel32), "IsDebuggerPresent");

    if(s_pfnIsDebuggerPresent != NULL)
    {
        if(pfIsAPIAvailable)
        {
            *pfIsAPIAvailable = TRUE;
        }

        return s_pfnIsDebuggerPresent();
    }

    if(pfIsAPIAvailable)
    {
        *pfIsAPIAvailable = FALSE;
    }

    return FALSE;
}


/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::IsRunningAsService
//      Purpose  :  Access to the running mode - service/executable
//
//      Parameters:
//          [N/A]
//
//      Returns  :   BOOL
//
//      Log:
//          Feb 11 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
CMainTracer::IsRunningAsService()
{
    return m_fIsRunningAsService;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::CreatOrAttachToLogFile
//      Purpose  :  Create log file.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 12 2000 yairh Creation
//          Jun 12 2000 yairh Fix protection.
//
////////////////////////////////////////////////////////////////////////////////

void CMainTracer::CreatOrAttachToLogFile()
{
    CMutexCatcher cMutex(m_mCreateLogFile);
    if (!m_bNeedToCreatOrAttachToLogFile)
    {
        return;
    }

    char    pszBuffer[TRACER_MAX_TRACE + 1];
    char        pszErrBuffer[TRACER_MAX_TRACE];
    m_pszLog = NULL;

    LPSECURITY_ATTRIBUTES lpSecAttr = NULL;
    SECURITY_DESCRIPTOR sdKeySecurity;
    SECURITY_ATTRIBUTES saKeyAttributes =
    {
        sizeof(SECURITY_ATTRIBUTES),
        &sdKeySecurity,
        FALSE
    };


    if(g_fIsWinNt)
    {
        if (!InitializeSecurityDescriptor(
                                &sdKeySecurity,
                                SECURITY_DESCRIPTOR_REVISION))
        {
            sprintf(pszErrBuffer, "%s Error %x\r\n",
                    "InitializeSecurityDescriptor failed "
                    "Tracing is disabled\r\n",
                    GetLastError());

            Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                pszErrBuffer);
            return;
        }

        if (!SetSecurityDescriptorDacl(
                            &sdKeySecurity,
                            TRUE,
                            FALSE,
                            FALSE))
        {
            sprintf(pszErrBuffer, "%s Error %x\r\n",
                    "SetSecurityDescriptorDacl failed "
                    "Tracing is disabled\r\n",
                    GetLastError());

            Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                pszErrBuffer);
            return;
        }

        lpSecAttr = &saKeyAttributes;
    }

    //
    // log file initialization
    //
    m_bNeedToCreatOrAttachToLogFile = FALSE;

    if (logUseAppName == m_LogState)
    {
        m_pszLogName = m_pszProgramName;
    }

    bool bExistingFile = false;

    strcpy(pszBuffer, m_pszLogName);
    strcat(pszBuffer, "_LogFileProtector");
    m_mLogFile.Init(pszBuffer);

    strcpy(pszBuffer, m_pszSysDrive);
    strcat(pszBuffer, "\\PKM_TRACER\\");
    strcat(pszBuffer, m_pszLogName);
    strcat(pszBuffer, ".log");

    m_ahLogFile = CreateFile(
                        pszBuffer,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        lpSecAttr,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (BAD_HANDLE((HANDLE)m_ahLogFile))
    {
         sprintf(pszErrBuffer, "%s error %x\r\n",
                "Fail To open log file. "
                "Tracing is disabled\r\n",
                GetLastError());

         Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            pszErrBuffer);

        return;
    }

    if (ERROR_ALREADY_EXISTS  == GetLastError())
    {
        bExistingFile = true;
    }

    strcpy(pszBuffer, m_pszLogName);
    strcat(pszBuffer, "_LogFile");

    m_ahLog = CreateFileMapping(
                            (HANDLE)m_ahLogFile,
                            lpSecAttr,
                            PAGE_READWRITE,
                            0,
                            LOG_FILE_SIZE,
                            pszBuffer);

    if (BAD_HANDLE((HANDLE)m_ahLog))
    {
         sprintf(pszErrBuffer, "%s error %x\r\n",
                "Fail To open log file shared memory "
                "Tracing is disabled\r\n",
                GetLastError());

         Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            pszErrBuffer);

        return;
    }

    m_ulLogSize = LOG_FILE_SIZE;

    m_pszLog = (char*) MapViewOfFile(
                            (HANDLE) m_ahLog,
                            FILE_MAP_ALL_ACCESS,
                            0,
                            0,
                            0);
    if (!m_pszLog)
    {
         sprintf(pszErrBuffer, "%s error %x\r\n",
                "Fail To open log file map view of file "
                "Tracing is disabled\r\n",
                GetLastError());

         Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            pszErrBuffer);

        return;
    }

    m_amLog = (PBYTE) m_pszLog;

    m_pulNextFreeSpaceInLogFile = (ULONG*) m_pszLog;

    if (!bExistingFile)
    {
        memset(m_pszLog, 0, LOG_FILE_SIZE);
        *(m_pszLog + sizeof(ULONG)) = '\r'; // new line;
        *(m_pszLog + sizeof(ULONG) + sizeof(char)) = '\n'; // new line;
        *m_pulNextFreeSpaceInLogFile = LOG_START_POINT;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  ::IsRunningAsService
//      Purpose  :  To return if this process is running as a NT service.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   BOOL
//
//      Log:
//          Feb  1 1996 unknown source
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
IsRunningAsService()
{

    if(!g_fIsWinNt)
    {
        return FALSE;
    }

    HANDLE hProcessToken;
    DWORD groupLength = 50;

    PTOKEN_GROUPS groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);

    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
    PSID InteractiveSid;
    PSID ServiceSid;
    DWORD i;


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
    {
        LocalFree(groupInfo);
        return(FALSE);
    }


    if (groupInfo == NULL)
    {
        CloseHandle(hProcessToken);
        LocalFree(groupInfo);
        return(FALSE);
    }


    if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
        groupLength, &groupLength))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            CloseHandle(hProcessToken);
            LocalFree(groupInfo);
            return(FALSE);
        }


        LocalFree(groupInfo);

        groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);

        if (groupInfo == NULL)
        {
            CloseHandle(hProcessToken);
            return(FALSE);
        }


        if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
            groupLength, &groupLength))
        {
            CloseHandle(hProcessToken);
            LocalFree(groupInfo);
            return(FALSE);
        }
    }


    //
    //  We now know the groups associated with this token.  We want to look to see if
    //  the interactive group is active in the token, and if so, we know that
    //  this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know we're a service.
    //
    //  The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).
    //


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID,
        0, 0, 0, 0, 0, 0, 0, &InteractiveSid))
    {
        LocalFree(groupInfo);
        CloseHandle(hProcessToken);
        return(FALSE);
    }


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID,
        0, 0, 0, 0, 0, 0, 0, &ServiceSid))
    {
        FreeSid(InteractiveSid);
        LocalFree(groupInfo);
        CloseHandle(hProcessToken);
        return(FALSE);
    }


    for (i = 0; i < groupInfo->GroupCount ; i += 1)
    {
        SID_AND_ATTRIBUTES sanda = groupInfo->Groups[i];
        PSID Sid = sanda.Sid;

        //
        //      Check to see if the group we're looking at is one of
        //      the 2 groups we're interested in.
        //

        if (EqualSid(Sid, InteractiveSid))
        {

            //
            //  This process has the Interactive SID in its
            //  token.  This means that the process is running as
            //  an EXE.
            //

            FreeSid(InteractiveSid);
            FreeSid(ServiceSid);
            LocalFree(groupInfo);
            CloseHandle(hProcessToken);
            return(FALSE);
        }
        else if (EqualSid(Sid, ServiceSid))
        {
            //
            //  This process has the Service SID in its
            //  token.  This means that the process is running as
            //  a service running in a user account.
            //

            FreeSid(InteractiveSid);
            FreeSid(ServiceSid);
            LocalFree(groupInfo);
            CloseHandle(hProcessToken);
            return(TRUE);
        }
    }

    //
    //  Neither Interactive or Service was present in the current users token,
    //  This implies that the process is running as a service, most likely
    //  running as LocalSystem.
    //

    FreeSid(InteractiveSid);
    FreeSid(ServiceSid);
    LocalFree(groupInfo);
    CloseHandle(hProcessToken);

    return(TRUE);
}

CLongTrace::CLongTrace(LPCSTR  pszFile, int iLine)
:   m_iLine(iLine),
    m_fRelease(FALSE)
{
    if (NULL == pszFile)
    {
        m_pszFile = "Unknown File";
    }
    else
    {
        m_pszFile = pszFile;
    }
}

CLongTrace::~CLongTrace()
{
    if (m_fRelease)
    {
        s_theLongTrace = NULL;
        m_fRelease = FALSE;
        s_TracerCriticalSection.Unlock();
    }
}

BOOL CLongTrace::Init(ERROR_LEVEL el, TAG tag)
{
    // First grab the critical section
    s_TracerCriticalSection.Lock();
    m_fRelease = TRUE;
    s_theLongTrace = this;


    if (CheckTraceRestrictions(el,tag))
    {
        g_pTracer->TraceSZ(0, m_pszFile, m_iLine, el, tag, "");
        return TRUE;
    }

    // destructor unlocks critical section
    return FALSE;
}

CLongTraceOutput::CLongTraceOutput(LPCSTR  pszFile, int iLine)
:   m_iLine(iLine)
{
    if (NULL == pszFile)
    {
        m_pszFile = "Unknown File";
    }
    else
    {
        m_pszFile = pszFile;
    }
}

void CLongTraceOutput::TraceSZ(LPCSTR psz , ...)
{
    if (NULL == s_theLongTrace)
    {
        CHAR szMessage[1000];
        _snprintf(szMessage, 1000, "Bad LongTrace in File %s line %d!\n", m_pszFile, m_iLine);

        OutputDebugString(szMessage);
    }
    else
    {
        va_list arglist;

        va_start(arglist, psz);
        g_pTracer->RawVaTraceSZ(psz, arglist);
    }
}

void CLongTraceOutput::TraceSZ(PCWSTR pwcs , ...)
{
    if (NULL == s_theLongTrace)
    {
        CHAR szMessage[1000];
        _snprintf(szMessage, 1000, "Bad LongTrace in File %s line %d!\n", m_pszFile, m_iLine);

        OutputDebugString(szMessage);
    }
    else
    {
        va_list arglist;

        va_start(arglist, pwcs);
        g_pTracer->RawVaTraceSZ(pwcs, arglist);
    }
}

CTempTrace::CTempTrace(LPCSTR pszFile, int iLine) :
m_pszFile(pszFile)
{
    m_iLine = iLine;
}


void
CTempTrace::TraceSZ(ERROR_LEVEL el, TAG tag, LPCSTR psz, ...)
{
    if (CheckTraceRestrictions(el,tag))
    {
        LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

        va_list arglist;

        va_start(arglist, psz);
        g_pTracer->VaTraceSZ(0, pszFile, m_iLine, el, tag, psz, arglist);
    }
}

void
CTempTrace::TraceSZ(ERROR_LEVEL el, TAG tag, DWORD dwError, LPCSTR psz, ...)
{
    if (CheckTraceRestrictions(el,tag))
    {
        LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

        va_list arglist;

        va_start(arglist, psz);
        g_pTracer->VaTraceSZ(dwError, pszFile, m_iLine, el, tag, psz, arglist);
    }
}

void
CTempTrace::TraceSZ(ERROR_LEVEL el, TAG tag, PCWSTR pwcs, ...)
{
    if (CheckTraceRestrictions(el,tag))
    {
        LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

        va_list arglist;

        va_start(arglist, pwcs);
        g_pTracer->VaTraceSZ(0, pszFile , m_iLine, el, tag, pwcs, arglist);
    }
}

void
CTempTrace::TraceSZ(ERROR_LEVEL el, TAG tag, DWORD dwError, PCWSTR pwcs, ...)
{
    if (CheckTraceRestrictions(el,tag))
    {
        LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

        va_list arglist;

        va_start(arglist, pwcs);
        g_pTracer->VaTraceSZ(dwError, pszFile, m_iLine, el, tag, pwcs, arglist);
    }
}

CTempTrace1::CTempTrace1(LPCSTR pszFile, int iLine, TAG tag, ERROR_LEVEL el) :
    m_pszFile(pszFile),
    m_iLine(iLine),
    m_ulTag(tag),
    m_el(el)
{
}


void
CTempTrace1::TraceSZ(LPCSTR psz, ...)
{
    LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

    va_list arglist;

    va_start(arglist, psz);
    g_pTracer->VaTraceSZ(0, pszFile, m_iLine, m_el, m_ulTag, psz, arglist);
}

void
CTempTrace1::TraceSZ(DWORD dwError, LPCSTR psz, ...)
{
    LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

    va_list arglist;

    va_start(arglist, psz);
    g_pTracer->VaTraceSZ(dwError, pszFile, m_iLine, m_el, m_ulTag, psz, arglist);
}

void
CTempTrace1::TraceSZ(PCWSTR pwcs, ...)
{
    LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

    va_list arglist;

    va_start(arglist, pwcs);
    g_pTracer->VaTraceSZ(0, pszFile , m_iLine, m_el, m_ulTag, pwcs, arglist);
}

void
CTempTrace1::TraceSZ(DWORD dwError, PCWSTR pwcs, ...)
{
    LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

    va_list arglist;

    va_start(arglist, pwcs);
    g_pTracer->VaTraceSZ(dwError, pszFile, m_iLine, m_el, m_ulTag, pwcs, arglist);
}

void __cdecl ShutdownTracer()
{
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\tracer\src\tracer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  Tracer.cpp
//      Purpose  :  Redirect the tracing to the global tracer.
//
//      Project  :  Tracer
//
//      Author   :  t-urib
//
//      Log:
//          Jan 22 1996 t-urib Creation
//          Jan 27 1996 t-urib Add release/debug support.
//          Dec  8 1996 urib   Clean Up
//          Dec 10 1996 urib  Fix TraceSZ to VaTraceSZ.
//          Feb 11 1997 urib  Support UNICODE format string.
//          Jan 20 1999 urib  Assert macro checks the test value.
//          Feb 22 1999 urib  Fix const declarations.
//          Nov 15 2000 victorm  Add tracer restriction check to Is...() functions
//
////////////////////////////////////////////////////////////////////////////////

#include "Tracer.h"
#include "Tracmain.h"


#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)

////////////////////////////////////////////////////////////////////////////////
//
//  class CTracer implementation
//
////////////////////////////////////////////////////////////////////////////////

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::~CTracer
//      Purpose  :  It's good to define empty virtual constructor on base types.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
CTracer::~CTracer()
{
}


/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::Free
//      Purpose  :  To call the deletor passed in the constructor.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::Free()
{
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::TraceSZ
//      Purpose  :  To log the printf formatted data according to the tag and
//                    error level
//
//      Parameters:
//          [in]    DWORD       dwError
//          [in]    LPCSTR      pszFile,
//          [in]    int         iLine,
//          [in]    ERROR_LEVEL el   the tag and el parameters are used to
//                                    decide what traces will take place and to
//                                    what devices.
//          [in]    TAG         tag
//          [in]    PSZ/PWSTR   pszFormatString The traced data
//          [in]    ...                         Arguments (like in printf)
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Clean Up
//          Feb 11 1997 urib Support UNICODE format string.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::TraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    LPCSTR      pszFormatString,
    ...)
{
    va_list arglist;

    va_start(arglist, pszFormatString);

    g_pTracer->VaTraceSZ(dwError, pszFile, iLine, el, tag, pszFormatString, arglist);
}

void
CTracer::TraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    PCWSTR      pwszFormatString,
    ...)
{
    va_list arglist;

    va_start(arglist, pwszFormatString);

    g_pTracer->VaTraceSZ(dwError, pszFile, iLine, el, tag, pwszFormatString, arglist);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::VaTraceSZ
//      Purpose  :
//
//      Parameters:
//          [in]    ERROR_LEVEL el   the tag and el parameters are used to
//                                    decide what traces will take place and to
//                                    what devices.
//          [in]    TAG         tag
//          [in]    PSZ/PWSTR   pszFormatString The traced data
//          [in]    va_list     arglist         Arguments
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Clean Up
//          Dec 10 1996 urib Fix TraceSZ to VaTraceSZ.
//          Feb 11 1997 urib Support UNICODE format string.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::VaTraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    LPCSTR      pszFormatString,
    va_list     arglist)
{
    g_pTracer->VaTraceSZ(
        dwError,
        pszFile,
        iLine,
        el,
        tag,
        pszFormatString,
        arglist);
}

void
CTracer::VaTraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    PCWSTR      pwszFormatString,
    va_list     arglist)
{
    g_pTracer->VaTraceSZ(
        dwError,
        pszFile,
        iLine,
        el,
        tag,
        pwszFormatString,
        arglist);
}



/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::RawVaTraceSZ
//      Purpose  :  Traces without any extra information.
//
//      Parameters:
//          [in]    PSZ/PWSTR   pszFormatString The traced data
//          [in]    va_list     arglist         Arguments
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 11 1999 micahk Create
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::RawVaTraceSZ(
    LPCSTR      pszFormatString,
    va_list     arglist)
{
    g_pTracer->RawVaTraceSZ(
        pszFormatString,
        arglist);
}

void
CTracer::RawVaTraceSZ(
    PCWSTR      pwszFormatString,
    va_list     arglist)
{
    g_pTracer->RawVaTraceSZ(
        pwszFormatString,
        arglist);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::RegisterTagSZ
//      Purpose  :  To register the tag in the registry and return a tag ID.
//
//      Parameters:
//          [in]    LPCSTR   pszTagName - the tag name.
//          [out]   TAG&  tag        - the id returned for that name.
//
//      Returns  :   HRESULT - Standard error code
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
HRESULT
CTracer::RegisterTagSZ(LPCSTR pszTagName, TAG& tag)
{
    return g_pTracer->RegisterTagSZ(pszTagName, tag);
}


/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::TraceAssertSZ
//      Purpose  :  To trace the assert if happened.
//
//      Parameters:
//          [in]  LPCSTR pszTestSring - the expression text
//          [in]  LPCSTR pszText - some data attached
//          [in]  LPCSTR pszFile - the source file
//          [in]        int iLine - the source line
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib  Clean Up
//          Jan 20 1999 urib  Assert macro checks the test value.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::TraceAssertSZ(
    LPCSTR pszTestSring,
    LPCSTR pszText,
    LPCSTR pszFile,
    int iLine)
{
    g_pTracer->TraceAssertSZ(pszTestSring, pszText, pszFile, iLine);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::TraceAssert
//      Purpose  :  To trace the assert if happened.
//
//      Parameters:
//          [in]    LPCSTR  pszTestSring - the expression text
//          [in]    LPCSTR  pszFile - the source file
//          [in]    int     iLine - the source line
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib  Clean Up
//          Jan 20 1999 urib  Assert macro checks the test value.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::TraceAssert(
    LPCSTR pszTestSring,
    LPCSTR pszFile,
    int iLine)
{
    TraceAssertSZ(pszTestSring, "", pszFile, iLine);
}




////////////////////////////////////////////////////////////////////////////////
//
//  Is bad functions - return TRUE if the expression checked is bad!
//
////////////////////////////////////////////////////////////////////////////////

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::IsBadAlloc
//      Purpose  :  Do  what is needed when a memory allocatin fails.
//
//      Parameters:
//          [in]    void    *ptr
//          [in]    LPCSTR  pszFile - source file
//          [in]    int     iLine   - line in source file
//
//      Returns  :   BOOL returns if the ptr is a bad one.
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
CTracer::IsBadAlloc(
    void    *ptr,
    LPCSTR  pszFile,
    int     iLine)
{
    if(BAD_POINTER(ptr))
    {
        if (CheckTraceRestrictions(elError, TAG_ERROR))
		{
            TraceSZ(0,pszFile, iLine, elError, TAG_ERROR,
                    "Memory allocation failed");
        }
        return(TRUE);
    }
    return(FALSE);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::IsBadHandle
//      Purpose  :  Do  what is needed when a handle is not valid
//
//      Parameters:
//          [in]    HANDLE  h
//          [in]    LPCSTR  pszFile - source file
//          [in]    int     iLine   - line in source file
//
//      Returns  :   BOOL returns if the handle is a bad one.
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
CTracer::IsBadHandle(
    HANDLE  h,
    LPCSTR  pszFile,
    int     iLine)
{
    if(BAD_HANDLE(h))
    {
        if (CheckTraceRestrictions(elError, TAG_WARNING))
		{
            TraceSZ(0,pszFile, iLine, elError, TAG_WARNING,
                    "Handle is not valid");
        }
        return(TRUE);
    }
    return(FALSE);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::IsBadResult
//      Purpose  :  Do  what is needed when a functions returns bad result.
//
//      Parameters:
//          [in]    HRESULT hr
//          [in]    LPCSTR  pszFile - source file
//          [in]    int     iLine   - line in source file
//
//      Returns  :   BOOL returns if the result is an error.
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
CTracer::IsBadResult(
    HRESULT hr,
    LPCSTR  pszFile,
    int     iLine)
{
    if(BAD_RESULT(hr))
    {
        if (CheckTraceRestrictions(elError, TAG_WARNING))
		{
			TraceSZ(hr,pszFile, iLine, elError, TAG_WARNING,
					"Error encountered");
		}
        return(TRUE);
    }
    return(FALSE);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::IsFailure
//      Purpose  :  Do  what is needed when a API returns false
//
//      Parameters:
//          [in]        BOOL    fSuccess
//          [in]  LPCSTR     pszFile - source file
//          [in]        int     iLine   - line in source file
//
//      Returns  :   BOOL returns if the return value is false.
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
CTracer::IsFailure(
    BOOL    fSuccess,
    LPCSTR  pszFile,
    int     iLine)
{
    if(!fSuccess)
    {
        if (CheckTraceRestrictions(elError, TAG_WARNING))
		{
            DWORD   dwError = GetLastError();
    
            char*   pszMessageBuffer;
    
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwError,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (PSZ)&pszMessageBuffer,
                0,
                NULL );
    
            TraceSZ(dwError,pszFile, iLine, elError, TAG_WARNING,
                    "return code is %s,"
                    " GetLastError returned %d - %s ",
                    (fSuccess ? "TRUE" : "FALSE"),
                    dwError,
                    pszMessageBuffer);
    
            // Free the buffer allocated by the system
            LocalFree( pszMessageBuffer );
        }

    }
    return(!fSuccess);
}


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\abbrev.cpp ===
#include "base.h"
#include "formats.h"


const CAbbTerm g_aEngAbbList[] =
{
    {L"B.A.Ed",	    6,	NULL,	0}, // (Bachelor_of_Arts_in_Education)
    {L"B.A.Sc",	    6,	NULL,	0}, // (Bachelor_of_Agricultural_Science Bachelor_of_Applied_Science)
    {L"B.Ae.E",	    6,	NULL,	0}, // (Bachelor_of_Aeronautical_Engineering)
    {L"B.Arch",	    6,	NULL,	0}, // (Bachelor_of_Architecture)
    {L"B.Ch.E",	    6,	NULL,	0}, // (Bachelor_of_Chemical_Engineering)
    {L"B.Ed",	    4,	NULL,	0}, // (Bachelor_of_Education)
    {L"B.Eng",	    5,	NULL,	0}, // (Bachelor_of_Engineering)
    {L"B.Eng.Sci",	9,	NULL,	0}, // (Bachelor_of_Engineering_Science)
    {L"B.Engr",	    6,	NULL,	0}, // (Bachelor_of_Engineering)
    {L"B.Lit",	    5,	NULL,	0}, // (Bachelor_of_Literature)
    {L"B.Litt",	    6,	NULL,	0}, // (Bachelor_of_Literature)
    {L"B.Mus",	    5,	NULL,	0}, // (Bachelor_of_Music)
    {L"B.Pd",	    4,	NULL,	0}, // (Bachelor_of_Pedagogy)
    {L"B.Ph",	    4,	NULL,	0}, // (Bachelor_of_Philosophy)
    {L"B.Phil",	    6,	NULL,	0}, // (Bachelor_of_Philosophy)
    {L"B.R.E",	    5,	NULL,	0}, 
    {L"B.S.Arch",	8,	NULL,	0}, // (Bachelor_of_Science_in_Architecture)
    {L"B.S.Ch",	    6,	NULL,	0}, // (Bachelor_of_Science_in_Chemistry)
    {L"B.S.Ec",	    6,	NULL,	0}, // (Bachelor_of_Science_in_Economics)
    {L"B.S.Ed",	    6,	NULL,	0}, // (Bachelor_of_Science_in_Education)
    {L"B.S.For",	7,	NULL,	0}, // (Bachelor_of_Science_in_Forestry)
    {L"B.Sc",	    4,	NULL,	0}, // (Bachelor_of_Science)
    {L"B.Th",	    4,	NULL,	0}, // (Bachelor_of_Theology)
    {L"Ch.E",	    4,	NULL,	0}, // (chemical_engineer)
    {L"D.Bib",	    5,	NULL,	0}, 
    {L"D.Ed",	    4,	NULL,	0}, // (Doctor_of_Education)
    {L"D.Lit",	    5,	NULL,	0}, // (Doctor_of_Literature)
    {L"D.Litt",	    6,	NULL,	0}, 
    {L"D.Ph",	    4,	NULL,	0}, // (Doctor_of_Philosophy)
    {L"D.Phil",	    6,	NULL,	0}, // (Doctor_of_Philosophy)
    {L"D.Sc",	    4,	NULL,	0}, 
    {L"Ed.M",	    4,	NULL,	0}, // (Master_of_Education)
    {L"HH.D",	    4,	NULL,	0}, // (Doctor_of_Humanities)
    {L"L.Cpl",	    5,	NULL,	0}, // (Lance_corporal)
    {L"LL.B",	    4,	NULL,	0}, // (Bachelor_of_Laws)
    {L"LL.D",	    4,	NULL,	0}, // (Doctor_of_Laws)
    {L"LL.M",	    4,	NULL,	0}, // (Master_of_Laws)
    {L"Lit.B",	    5,	NULL,	0}, // (Bachelor_of_Literature)
    {L"Lit.D",	    5,	NULL,	0}, // (Doctor_of_Literature)
    {L"Litt.B",	    6,	NULL,	0}, // (Bachelor_of_Literature)
    {L"Litt.D",	    6,	NULL,	0}, // (Doctor_of_Literature)
    {L"M.A.Ed",	    6,	NULL,	0}, // (Master_of_Arts_in_Education)
    {L"M.Agr",	    5,	NULL,	0}, // (Master_of_Agriculture)
    {L"M.Div",	    5,	NULL,	0}, // (Master_of_Divinity)
    {L"M.Ed",	    4,	NULL,	0}, // (Master_of_Education)
    {L"M.Sc",	    4,	NULL,	0}, // (Master_of_Science)
    {L"M.Sgt",	    5,	NULL,	0}, // (Master_sergeant)
    {L"Mus.B",	    5,	NULL,	0}, // (Bachelor_of_Music)
    {L"Mus.D",	    5,	NULL,	0}, // (Doctor_of_Music)
    {L"Mus.Dr",	    6,	NULL,	0}, // (Doctor_of_Music)
    {L"Mus.M",	    5,	NULL,	0}, // (Master_of_Music)
    {L"N.Dak",	    5,	NULL,	0}, // (North_Dakota)
    {L"N.Ire",	    5,	NULL,	0}, // (Northern_Ireland)
    {L"N.Mex",	    5,	NULL,	0}, // (New_Mexico)
    {L"Pd.B",	    4,	L"pdb",	3}, // (Bachelor_of_Pedagogy) 
    {L"Pd.D",	    4,	L"pdd",	3}, // (Doctor_of_Pedagogy)
    {L"Pd.M",	    4,	L"pdm",	3}, // (Master_of_Pedagogy)
    {L"Ph.B",	    4,	L"phb",	3}, // (Bachelor_of_Philosophy)
    {L"Ph.C",	    4,	L"phc",	3}, // (pharmaceutical_chemist)
    {L"Ph.D",	    4,	L"phd",	3}, // (Doctor_of_Philosophy)
    {L"Ph.G",	    4,	L"phg",	3}, // (graduate_in_pharmacy)
    {L"Ph.M",	    4,	L"phm",	3}, // (Master_of_Philosophy)
    {L"Phar.B",	    6,	NULL,	0}, // (Bachelor_of_Pharmacy)
    {L"Phar.D",	    6,	NULL,	0}, // (Doctor_of_Pharmacy)
    {L"Phar.M",	    6,	NULL,	0}, // (Master_of_Pharmacy)
    {L"R.C.Ch",	    6,	NULL,	0}, // (Roman_Catholic_Church)
    {L"S.A",	    3,	NULL,	0}, 
    {L"S.Afr",	    5,	NULL,	0}, // (South_Africa)
    {L"S.Dak",	    5,	NULL,	0}, // (South_Dakota)
    {L"S.M.Sgt",	7,	NULL,	0}, // (Senior_master_sergeant)
    {L"S.Sgt",	    5,	NULL,	0}, // (Staff_sergeant)
    {L"Sc.B",	    4,	NULL,	0}, 
    {L"Sc.D",	    4,	NULL,	0}, 
    {L"Sgt.Maj",	7,	NULL,	0}, // (Sergeant_major)
    {L"Sup.Ct",	    6,	NULL,	0}, // (Superior_court Supreme_court)
    {L"T.Sgt",	    5,	NULL,	0}, // (Technical_sergeant)
    {L"Th.B",	    4,	NULL,	0}, // (Bachelor_of_Theology)
    {L"Th.D",	    4,	NULL,	0}, // (Doctor_of_Theology)
    {L"Th.M",	    4,	NULL,	0}, // (Master_of_Theology)
    {L"V.Adm",	    5,	NULL,	0}, // (Vice_admiral)
    {L"W.Va",	    4,	NULL,	0}, 
    {L"W.W.I",	    5,	NULL,	0}, 
    {L"W.W.II",	    6,	NULL,	0}, 
    {L"n.wt",	    4,	NULL,	0}, 
    {L"nt.wt",	    5,	NULL,	0}, // (net_weight)
    {L"s.ap",	    4,	NULL,	0}, 
    {L"x-div",	    5,	NULL,	0}, 
    {L"x-int",	    5,	NULL,	0}, 

    {L"\0",         0,  NULL,   0}
};



const CAbbTerm g_aFrenchAbbList[] =
{
    {L"LL.AA",      5,      NULL,   0},
    {L"LL.MM",      5,      NULL,   0},
    {L"NN.SS",      5,      NULL,   0},
    {L"S.Exc",      5,      NULL,   0},
    {L"eod.loc",    7,      NULL,   0},
    {L"eod.op",     6,      NULL,   0},
    {L"op.cit",     6,      NULL,   0},
    {L"op.laud",    7,      NULL,   0},
    {L"ouvr.cit",   8,      NULL,   0},
    {L"pet.cap",    7,      NULL,   0},
    {L"\0",         0,  NULL,   0}
};

const CAbbTerm g_aSpanishAbbList[] =
{
    {L"AA.AA",      5,      NULL,   0},
    {L"AA.RR",      5,      NULL,   0},
    {L"AA.SS",      5,      NULL,   0},
    {L"Bmo.P",      5,      NULL,   0},
    {L"EE.UU",      5,      NULL,   0},
    {L"N.Recop",    7,      NULL,   0},
    {L"Nov.Recop",  9,      NULL,   0},
    {L"RR.MM",      5,      NULL,   0},
    {L"RR.PP",      5,      NULL,   0},
    {L"Rvda.M",     6,      NULL,   0},
    {L"SS.AA",      5,      NULL,   0},
    {L"SS.AA.II",   8,      NULL,   0},
    {L"SS.AA.RR",   8,      NULL,   0},
    {L"SS.AA.SS",   8,      NULL,   0},
    {L"SS.MM",      5,      NULL,   0},
    {L"Smo.P",      5,      NULL,   0},
    {L"V.Em",       4,      NULL,   0},
    {L"art.cit",    7,      NULL,   0},
    {L"op.cit",     6,      NULL,   0},
    {L"\0",         0,  NULL,   0}
};

const CAbbTerm g_aItalianAbbList[] =
{
    {L"\0",         0,  NULL,   0}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\base.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  base.h
//      Project  :  pqs
//      Component:  wordbreaker
//
//      Author   :  urib
//
//      Log:
//          Jun 27 2000 urib  Move to use Trace(,, ()) instead of Trace((,,)).
//
////////////////////////////////////////////////////////////////////////////////
#ifndef  BASE_H
#define  BASE_H

#pragma once

#define PQS_CODE

#define STRICT
#include    <windows.h>

#include    "tracer.h"

//
// Append PQS to all our tags
//

//
// Append PQS to all our tags
//
typedef unsigned char*  PUSZ;

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
#define TRACER_ON
#endif

#ifdef  TRACER_ON

#undef  USES_TAG
#undef  Trace


#define Trace(el, tag, x)    \
    { \
        if (CheckTraceRestrictions(el, tag)) \
        { \
            CTempTrace1 tmp(__FILE__, __LINE__, tag, el); \
            tmp.TraceSZ x; \
        } \
    }


#else

#undef  Trace
#define Trace(el, tag, x)

#endif

#include    "excption.h"
#include    "MemoryManagement.h"
#include    "vartypes.h"

#endif /* BASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\tracer\src\tracmain.h ===
#ifndef _TRACMAIN_H_
#define _TRACMAIN_H_

extern BOOL g_fIsWinNt;

#include "tracer.h"
#include "mutex.h"

#ifndef BAD_HANDLE
#define BAD_HANDLE(h)       ((0 == (h))||(INVALID_HANDLE_VALUE == (h)))
#endif

#define TRACER_MAX_TRACE            1000
#define TRACER_MAX_PROGRAM_NAME     32
#define LOG_START_POINT             sizeof(ULONG)+2*sizeof(char)

// Assert Levels
#define ASSERT_LEVEL_MESSAGE           0x00000001      // Output a message
#define ASSERT_LEVEL_BREAK             0x00000002      // Int 3 on assertion
#define ASSERT_LEVEL_POPUP             0x00000004      // And popup message
#define ASSERT_LEVEL_LOOP              0x00000008      // Loop

#define TRACER_STAMP_OFFSET         0
#define TRACER_FLAGS_TABLE_OFFSET   4
#define TAGS_TABLE_OFFSET           8
#define LAST_OFFSET                 12

#define TRACER_STAMP        "y.h"   

#define TAG_OUT_OF_TAG_ARRAY    0
#define TAG_GENERAL             1
#define TAG_ERROR               2
#define TAG_WARNING             3
#define TAG_INFORMATION         4
#define TAG_LAST                5    
      

BOOL IsRunningAsService();

class CAutoHandle
{
  public:
    // Constructor
    CAutoHandle(HANDLE h = NULL)
        :m_h(h){}

    // Behave like a HANDLE in assignments
    CAutoHandle& operator=(HANDLE h)
    {
        if (m_h == h)
        {
            return *this;
        }
        else if (m_h)
        {
            CloseHandle(m_h);
        }

        m_h = h;
        return(*this);
    }

    // Every kind of a  handle needs different closing.
    virtual
    ~CAutoHandle()
    {
        if (!BAD_HANDLE(m_h))
        {
            CloseHandle(m_h);
            m_h = NULL;
        }
    }

    // Behave like a handle
    operator HANDLE() const
    {
        return m_h;
    }

    // Allow access to the actual memory of the handle.
    HANDLE* operator &()
    {
        return &m_h;
    }

  protected:
    // The handle.
    HANDLE  m_h;
};


class CAutoMapFile
{
  public:
    // Constructor
    CAutoMapFile()
        :m_p(NULL){}

    CAutoMapFile& operator=(PBYTE p)
    {
		if ( m_p == p )
		{
	        return(*this);
		}
		UnMap();
		m_p = p;
        return(*this);
    }

    virtual
    ~CAutoMapFile()
    {
		UnMap();
    }

    operator PBYTE() const
    {
        return m_p;
    }

	// Unmap memory map file
	void UnMap()
	{
		if (m_p)
		{
            UnmapViewOfFile(m_p);
			m_p = NULL;
		}
	}

  protected:
    PBYTE m_p;
};

inline bool ReadFromExistingSharedMemory(
    PBYTE pbMem,
    ULONG** ppulNumOfFlagEntries,
    CTracerFlagEntry** paFlags,
    ULONG** ppulNextTagId,
    CTracerTagEntry** paTags
    )
{
    char* pszTracerStamp = (char*) (pbMem + TRACER_STAMP_OFFSET);
    if (strcmp(pszTracerStamp,TRACER_STAMP))
    {
        return false;                
    }

    ULONG ulFlagsTableOffset = *((ULONG*) (pbMem + TRACER_FLAGS_TABLE_OFFSET));
    ULONG ulTagsTableOffset = *((ULONG*) (pbMem + TAGS_TABLE_OFFSET));

    *ppulNumOfFlagEntries = (ULONG*) (pbMem + ulFlagsTableOffset);
    *paFlags = (CTracerFlagEntry*) (*ppulNumOfFlagEntries + 1);

    *ppulNextTagId = (ULONG*) (pbMem + ulTagsTableOffset);
    *paTags = (CTracerTagEntry*) (*ppulNextTagId + 1);

    return true;
}

////////////////////////////////////////////////////////////////////////////////
//
// The Null tracer. Doesn't trace anything
//
////////////////////////////////////////////////////////////////////////////////

class CNullTracer : public CTracer
{
public:
    CNullTracer();
    virtual ~CNullTracer(){}
    virtual void Free(){}
    virtual void TraceSZ(DWORD, LPCSTR, int, ERROR_LEVEL, TAG, LPCSTR, ...){}
    virtual void TraceSZ(DWORD, LPCWSTR, int, ERROR_LEVEL, TAG, PCWSTR, ...){}
    virtual void
        VaTraceSZ(DWORD, LPCSTR, int iLine, ERROR_LEVEL, TAG, LPCSTR, va_list){}
    virtual void
        VaTraceSZ(DWORD, LPCSTR, int iLine, ERROR_LEVEL, TAG, PCWSTR, va_list){}
    virtual void
        RawVaTraceSZ(LPCSTR, va_list) {}
    virtual void
        RawVaTraceSZ(PCWSTR, va_list) {}
    virtual HRESULT RegisterTagSZ(LPCSTR, TAG& ulTag){ulTag = 0; return S_OK;}
    virtual void TraceAssertSZ(LPCSTR, LPCSTR, LPCSTR, int){}
    virtual void TraceAssert(LPCSTR, LPCSTR, int){}

    virtual BOOL IsFailure(BOOL b, LPCSTR, int){return !b;}
    virtual BOOL IsBadAlloc(void* p, LPCSTR, int){return !p;}
    virtual BOOL IsBadHandle(HANDLE h, LPCSTR, int){return BAD_HANDLE(h);}
    virtual BOOL IsBadResult(HRESULT hr, LPCSTR, int){return FAILED(hr);}

public:
    CTracerTagEntry m_Tags[1];
    CTracerFlagEntry m_Flags[LAST_FLAG];
};

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CMainTracer - definition
//
////////////////////////////////////////////////////////////////////////////////

class CMainTracer : public CTracer {
  public:
    // Constructors - szProgramName prefix for all traces,
    //  second parameter - log file or stream
    CMainTracer();

    // Some clean up is required.
    ~CMainTracer();

    // The TraceSZ function output is defined by the tags mode
    //  one can change the tags mode by calling Enable tag and
    //  get the mode by calling IsEnabled.
    //-------------------------------------------------------------------------
    // accepts printf format for traces

    virtual void
    TraceSZ(DWORD dwError, LPCSTR, int, ERROR_LEVEL, TAG, LPCSTR, ...);

    virtual void
    TraceSZ(DWORD dwError, LPCSTR, int, ERROR_LEVEL, TAG, PCWSTR,...);

    // Implement the TraceSZ function.
    virtual void
    VaTraceSZ(DWORD dwError, LPCSTR, int, ERROR_LEVEL, TAG, LPCSTR, va_list);
    virtual void
    VaTraceSZ(DWORD dwError, LPCSTR, int, ERROR_LEVEL, TAG, PCWSTR, va_list);

    // Raw output functions
    virtual void
    RawVaTraceSZ(LPCSTR, va_list);
    virtual void
    RawVaTraceSZ(PCWSTR, va_list);

    // assert, different implementations possible - gui or text
    virtual void TraceAssertSZ(LPCSTR, LPCSTR, LPCSTR, int);

    // Create or open a new tag for tracing
    HRESULT RegisterTagSZ(LPCSTR, TAG&);

public:

    // Actually print it.
    void    Log(DWORD, LPSTR);
    void    Log(DWORD, PWSTR);

    DWORD   GetErrorStringFromCode(DWORD dwError, char *pszBuffer, ULONG ccBuffer);

    bool ReadFromExistingSharedMemory(PBYTE pvMem);
    bool InitializeSharedMemory(PBYTE pvMem);

    BOOL    IsRunningAsService();
    BOOL    LocalIsDebuggerPresent(BOOL* pfIsAPIAvailable);
    
    void CreatOrAttachToLogFile();

  public:

    // Mutex to atomize the tag id registry incrementation.
    CMutex              m_mTagId;
    CMutex              m_mLogFile;
    CMutex              m_mCreateLogFile;

    char m_pszProgramName[MAX_PATH];
    char m_pszSysDrive[MAX_PATH];
    
    CAutoHandle m_ahSharedMemoryFile;
    CAutoHandle m_ahSharedMemory;
    CAutoMapFile m_amSharedMemory;

    CAutoHandle m_ahLogFile;
    CAutoHandle m_ahLog;
    CAutoMapFile m_amLog;

    char* m_pszLog;
    ULONG m_ulLogSize;
    ULONG* m_pulNextFreeSpaceInLogFile;

    BOOL    m_fIsRunningAsService;
    BOOL m_bNeedToCreatOrAttachToLogFile;
};

inline BOOL IsWinNt()
{
    OSVERSIONINFOA verinfo;
    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    if (GetVersionExA (&verinfo))
    {
        if (verinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            return TRUE;
        }
    }
    return FALSE;
}

class CInitTracerGlobals
{
public:
    CInitTracerGlobals()
    {
        g_fIsWinNt = IsWinNt();
    }
};

#endif // _TRACMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\formats.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Formats.cpp
//  Purpose  :  Global dictionaries
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      May 30 2000 yairh creation
//
////////////////////////////////////////////////////////////////////////////////

#include "base.h"
#include "tokenizer.h"

const CCliticsTerm g_aClitics[] =
{
    { L"l\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"l\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"d\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"d\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"j\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"j\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"m\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"m\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"n\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"n\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"s\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"s\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"q\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"q\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"t\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"t\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"un\'",          3 , HEAD_MATCH_TRUNCATE},
    { L"un\x0a0\'",     4 , HEAD_MATCH_TRUNCATE},
    { L"nell\'",        5 , HEAD_MATCH_TRUNCATE},
    { L"nell\x0a0\'",   6 , HEAD_MATCH_TRUNCATE},
    { L"all\'",         4 , HEAD_MATCH_TRUNCATE},
    { L"all\x0a0\'",    5 , HEAD_MATCH_TRUNCATE},
    { L"dell\'",        5 , HEAD_MATCH_TRUNCATE},
    { L"dell\x0a0\'",   6 , HEAD_MATCH_TRUNCATE},
    { L"Sull\'",        5 , HEAD_MATCH_TRUNCATE},
    { L"Sull\x0a0\'",   6 , HEAD_MATCH_TRUNCATE},
    { L"tutt\'",        5 , HEAD_MATCH_TRUNCATE},
    { L"tutt\x0a0\'",   6 , HEAD_MATCH_TRUNCATE},
    { L"qu\'",          3 , HEAD_MATCH_TRUNCATE},
    { L"qu\x0a0\'",     4 , HEAD_MATCH_TRUNCATE},
    { L"\'s",           2 , TAIL_MATCH_TRUNCATE},
    { L"\'ll",          3 , TAIL_MATCH_TRUNCATE},
    { L"\'m",           2 , TAIL_MATCH_TRUNCATE},
    { L"\'ve",          3 , TAIL_MATCH_TRUNCATE},
    { L"\'re",          3 , TAIL_MATCH_TRUNCATE},
    { L"\'d",           2 , TAIL_MATCH_TRUNCATE},

    { L"-je",           3 , TAIL_MATCH_TRUNCATE},
    { L"-tu",           3 , TAIL_MATCH_TRUNCATE},

    { L"-il",           3 , TAIL_MATCH_TRUNCATE},
    { L"-elle",         5 , TAIL_MATCH_TRUNCATE},
    { L"-on",           3 , TAIL_MATCH_TRUNCATE},
    { L"-ils",          4 , TAIL_MATCH_TRUNCATE},
    { L"-elles",        6 , TAIL_MATCH_TRUNCATE},

    { L"-t-il",         5 , TAIL_MATCH_TRUNCATE},
    { L"-t-elle",       7 , TAIL_MATCH_TRUNCATE},
    { L"-t-on",         5 , TAIL_MATCH_TRUNCATE},
    { L"-t-ils",        6 , TAIL_MATCH_TRUNCATE},
    { L"-t-elles",      8 , TAIL_MATCH_TRUNCATE},

    { L"-t'",           3 , TAIL_MATCH_TRUNCATE},
    { L"-t'y",          4 , TAIL_MATCH_TRUNCATE},
    { L"-t'en",         5 , TAIL_MATCH_TRUNCATE},

    { L"-m'",           3 , TAIL_MATCH_TRUNCATE},
    { L"-m'y",          4 , TAIL_MATCH_TRUNCATE},
    { L"-m'en",         5 , TAIL_MATCH_TRUNCATE},

    { L"-l'",           3 , TAIL_MATCH_TRUNCATE},
    { L"-l'y",          4 , TAIL_MATCH_TRUNCATE},
    { L"-l'en",         5 , TAIL_MATCH_TRUNCATE},

    { L"-z-y",          4 , TAIL_MATCH_TRUNCATE},
    { L"-z-en",         5 , TAIL_MATCH_TRUNCATE},
    { L"-y",            2 , TAIL_MATCH_TRUNCATE},
    { L"'y",            2 , TAIL_MATCH_TRUNCATE},
    { L"-y-en",         5 , TAIL_MATCH_TRUNCATE},

    { L"-nous",         5 , TAIL_MATCH_TRUNCATE},
    { L"-nous-y",       7 , TAIL_MATCH_TRUNCATE},
    { L"-nous-en",      9 , TAIL_MATCH_TRUNCATE},

    { L"-vous",         5 , TAIL_MATCH_TRUNCATE},
    { L"-vous-y",       7 , TAIL_MATCH_TRUNCATE},
    { L"-vous-en",      8 , TAIL_MATCH_TRUNCATE},

    { L"-toi",          4 , TAIL_MATCH_TRUNCATE},
    { L"-toi-z-y",      8 , TAIL_MATCH_TRUNCATE},
    { L"-toi-z-en",     9 , TAIL_MATCH_TRUNCATE},

    { L"-moi",          4 , TAIL_MATCH_TRUNCATE},
    { L"-moi-z-y",      8 , TAIL_MATCH_TRUNCATE},
    { L"-moi-z-en",     9 , TAIL_MATCH_TRUNCATE},

    { L"-lui",          4 , TAIL_MATCH_TRUNCATE},
    { L"-lui-en",       7 , TAIL_MATCH_TRUNCATE},

    { L"-leur",         5 , TAIL_MATCH_TRUNCATE},
    { L"-leur-en",      8 , TAIL_MATCH_TRUNCATE},

    { L"-eux",          4 , TAIL_MATCH_TRUNCATE},

    { L"-en",           3 , TAIL_MATCH_TRUNCATE},
    { L"'en",           3 , TAIL_MATCH_TRUNCATE},

    { L"-la",           3 , TAIL_MATCH_TRUNCATE},
    { L"-la-leur",      8 , TAIL_MATCH_TRUNCATE},
    { L"-la-vous",      8 , TAIL_MATCH_TRUNCATE},
    { L"-la-nous",      8 , TAIL_MATCH_TRUNCATE},
    { L"-la-nous-y",    10 , TAIL_MATCH_TRUNCATE},
    { L"-la-lui",       7 , TAIL_MATCH_TRUNCATE},
    { L"-la-lui-en",    10 , TAIL_MATCH_TRUNCATE},
    { L"-la-toi",       7 , TAIL_MATCH_TRUNCATE},
    { L"-la-moi",       7 , TAIL_MATCH_TRUNCATE},
    { L"-la-moi-z-y",   11, TAIL_MATCH_TRUNCATE},
    { L"-la-moi-z-en",  12 , TAIL_MATCH_TRUNCATE},

    { L"-le",           3 , TAIL_MATCH_TRUNCATE},
    { L"-le-leur",      8 , TAIL_MATCH_TRUNCATE},
    { L"-le-vous",      8 , TAIL_MATCH_TRUNCATE},
    { L"-le-nous",      8 , TAIL_MATCH_TRUNCATE},
    { L"-le-nous-y",    10 , TAIL_MATCH_TRUNCATE},
    { L"-le-lui",       7 , TAIL_MATCH_TRUNCATE},
    { L"-le-lui-en",    10 , TAIL_MATCH_TRUNCATE},
    { L"-le-toi",       7 , TAIL_MATCH_TRUNCATE},
    { L"-le-moi",       7 , TAIL_MATCH_TRUNCATE},
    { L"-le-moi-z-y",   11, TAIL_MATCH_TRUNCATE},
    { L"-le-moi-z-en",  12 , TAIL_MATCH_TRUNCATE},

    { L"-les",          4 , TAIL_MATCH_TRUNCATE},
    { L"-les-leur",     9 , TAIL_MATCH_TRUNCATE},
    { L"-les-vous",     9 , TAIL_MATCH_TRUNCATE},
    { L"-les-nous",     9 , TAIL_MATCH_TRUNCATE},
    { L"-les-nous-y",   11 , TAIL_MATCH_TRUNCATE},
    { L"-les-lui",      8 , TAIL_MATCH_TRUNCATE},
    { L"-les-lui-en",   11 , TAIL_MATCH_TRUNCATE},
    { L"-les-toi",      8 , TAIL_MATCH_TRUNCATE},
    { L"-les-moi",      8 , TAIL_MATCH_TRUNCATE},
    { L"-les-moi-z-y",  12, TAIL_MATCH_TRUNCATE},
    { L"-les-moi-z-en", 13 , TAIL_MATCH_TRUNCATE},
    
    { L"-ce",           3 , TAIL_MATCH_TRUNCATE},
    { L"-cis",          4 , TAIL_MATCH_TRUNCATE},
    { L"-cies-l",      8 , TAIL_MATCH_TRUNCATE},
    { L"-cies",         5 , TAIL_MATCH_TRUNCATE},
    { L"-cie",          4 , TAIL_MATCH_TRUNCATE},
    { L"-ci",           3 , TAIL_MATCH_TRUNCATE},
    { L"-l",           3 , TAIL_MATCH_TRUNCATE},
    { L"-cis-l",       7 , TAIL_MATCH_TRUNCATE},
    { L"-cies-ci",      8 , TAIL_MATCH_TRUNCATE},
    { L"-cie-l",       7 , TAIL_MATCH_TRUNCATE},

    { L"\0",            0 , NON_MATCH_TRUNCATE}
};


const CCliticsTerm g_SClitics =
{ L"s\'", 1, TAIL_MATCH_TRUNCATE }; 


const CCliticsTerm g_EmptyClitics =
{ L"\0", 0, NON_MATCH_TRUNCATE };


const CDateTerm g_aDateFormatList[] =
{
//    format       len Type            D_M1   D_M1    D_M2   D_M2    Year    Year
//                                    offset  len     len    offset  len     offset
    {L"#.#.##",     6,  0,              0,      1,      2,      1,      4,      2},
    {L"##.#.##",    7,  0,              0,      2,      3,      1,      5,      2},
    {L"#.##.##",    7,  0,              0,      1,      2,      2,      5,      2},
    {L"##.##.##",   8,  0,              0,      2,      3,      2,      6,      2},
    {L"#.#.###",    7,  0,              0,      1,      2,      1,      4,      3},
    {L"##.#.###",   8,  0,              0,      2,      3,      1,      5,      3},
    {L"#.##.###",   8,  0,              0,      1,      2,      2,      5,      3},
    {L"##.##.###",  9,  0,              0,      2,      3,      2,      6,      3},
    {L"#.#.####",   8,  0,              0,      1,      2,      1,      4,      4},
    {L"##.#.####",  9,  0,              0,      2,      3,      1,      5,      4},
    {L"#.##.####",  9,  0,              0,      1,      2,      2,      5,      4},
    {L"##.##.####", 10, 0,              0,      2,      3,      2,      6,      4},
    {L"###.#.#",    7,  YYMMDD_TYPE,    6,      1,      4,      1,      0,      3},
    {L"###.##.#",   8,  YYMMDD_TYPE,    7,      1,      4,      2,      0,      3},
    {L"###.#.##",   8,  YYMMDD_TYPE,    6,      2,      4,      1,      0,      3},
    {L"###.##.##",  9,  YYMMDD_TYPE,    7,      2,      4,      2,      0,      3},
    {L"####.#.#",   8,  YYMMDD_TYPE,    7,      1,      5,      1,      0,      4},
    {L"####.##.#",  9,  YYMMDD_TYPE,    8,      1,      5,      2,      0,      4},
    {L"####.#.##",  9,  YYMMDD_TYPE,    7,      2,      5,      1,      0,      4},
    {L"####.##.##", 10, YYMMDD_TYPE,    8,      2,      5,      2,      0,      4},
    {L"\0",         0,  0,}
};


const CTimeTerm g_aTimeFormatList[] =
{
//    format           len   hour   hour    min       min     sec     sec  AM/PM 
//                           offset  len     offset    len    offset   len
    {L"#:#",            3,    0,     1,      2,        1,       0,      0,   None   },
    {L"##:#",           4,    0,     2,      3,        1,       0,      0,   None   },
    {L"#:##",           4,    0,     1,      2,        2,       0,      0,   None   },
    {L"##:##",          5,    0,     2,      3,        2,       0,      0,   None   },
    {L"#:#:#",          5,    0,     1,      2,        1,       4,      1,   None   },
    {L"#:#:##",         6,    0,     1,      2,        1,       4,      2,   None   },
    {L"##:#:#",         6,    0,     2,      3,        1,       5,      1,   None   },
    {L"##:#:##",        7,    0,     2,      3,        1,       5,      2,   None   },
    {L"#:##:#",         6,    0,     1,      2,        2,       5,      1,   None   },
    {L"#:##:##",        7,    0,     1,      2,        2,       5,      2,   None   },
    {L"##:##:#",        7,    0,     2,      3,        2,       6,      1,   None   },
    {L"##:##:##",       8,    0,     2,      3,        2,       6,      2,   None   },

    {L"#AM",            3,    0,     1,      0,        0,       0,      0,   Am    },
    {L"##AM",           4,    0,     2,      0,        0,       0,      0,   Am    },
    {L"#:#AM",          5,    0,     1,      2,        1,       0,      0,   Am    },
    {L"##:#AM",         6,    0,     2,      3,        1,       0,      0,   Am    },
    {L"#:##AM",         6,    0,     1,      2,        2,       0,      0,   Am    },
    {L"##:##AM",        7,    0,     2,      3,        2,       0,      0,   Am    },
    {L"#:#:#AM",        7,    0,     1,      2,        1,       4,      1,   Am    },
    {L"#:#:##AM",       8,    0,     1,      2,        1,       4,      2,   Am    },
    {L"##:#:#AM",       8,    0,     2,      3,        1,       5,      1,   Am    },
    {L"##:#:##AM",      9,    0,     2,      3,        1,       5,      2,   Am    },
    {L"#:##:#AM",       8,    0,     1,      2,        2,       5,      1,   Am    },
    {L"#:##:##AM",      9,    0,     1,      2,        2,       5,      2,   Am    },
    {L"##:##:#AM",      9,    0,     2,      3,        2,       6,      1,   Am    },
    {L"##:##:##AM",     10,   0,     2,      3,        2,       6,      2,   Am    },
                        
    {L"#PM",            3,    0,     1,      0,        0,       0,      0,   Pm    },
    {L"##PM",           4,    0,     2,      0,        0,       0,      0,   Pm    },
    {L"#:#PM",          5,    0,     1,      2,        1,       0,      0,   Pm    },
    {L"##:#PM",         6,    0,     2,      3,        1,       0,      0,   Pm    },
    {L"#:##PM",         6,    0,     1,      2,        2,       0,      0,   Pm    },
    {L"##:##PM",        7,    0,     2,      3,        2,       0,      0,   Pm    },
    {L"#:#:#PM",        7,    0,     1,      2,        1,       4,      1,   Pm    },
    {L"#:#:##PM",       8,    0,     1,      2,        1,       4,      2,   Pm    },
    {L"##:#:#PM",       8,    0,     2,      3,        1,       5,      1,   Pm    },
    {L"##:#:##PM",      9,    0,     2,      3,        1,       5,      2,   Pm    },
    {L"#:##:#PM",       8,    0,     1,      2,        2,       5,      1,   Pm    },
    {L"#:##:##PM",      9,    0,     1,      2,        2,       5,      2,   Pm    },
    {L"##:##:#PM",      9,    0,     2,      3,        2,       6,      1,   Pm    },
    {L"##:##:##PM",     10,   0,     2,      3,        2,       6,      2,   Pm    },
                        
    {L"#a.m",           4,    0,     1,      0,        0,       0,      0,   Am    },
    {L"##a.m",          5,    0,     2,      0,        0,       0,      0,   Am    },
    {L"#:#a.m",         6,    0,     1,      2,        1,       0,      0,   Am    },
    {L"##:#a.m",        7,    0,     2,      3,        1,       0,      0,   Am    },
    {L"#:##a.m",        7,    0,     1,      2,        2,       0,      0,   Am    },
    {L"##:##a.m",       8,    0,     2,      3,        2,       0,      0,   Am    },
    {L"#:#:#a.m",       8,    0,     1,      2,        1,       4,      1,   Am    },
    {L"#:#:##a.m",      9,    0,     1,      2,        1,       4,      2,   Am    },
    {L"##:#:#a.m",      9,    0,     2,      3,        1,       5,      1,   Am    },
    {L"##:#:##a.m",     10,   0,     2,      3,        1,       5,      2,   Am    },
    {L"#:##:#a.m",      9,    0,     1,      2,        2,       5,      1,   Am    },
    {L"#:##:##a.m",     10,   0,     1,      2,        2,       5,      2,   Am    },
    {L"##:##:#a.m",     10,   0,     2,      3,        2,       6,      1,   Am    },
    {L"##:##:##a.m",    11,   0,     2,      3,        2,       6,      2,   Am    },
                        
    {L"#p.m",           4,    0,     1,      0,        0,       0,      0,   Pm    },
    {L"##p.m",          5,    0,     2,      0,        0,       0,      0,   Pm    },
    {L"#:#p.m",         6,    0,     1,      2,        1,       0,      0,   Pm    },
    {L"##:#p.m",        7,    0,     2,      3,        1,       0,      0,   Pm    },
    {L"#:##p.m",        7,    0,     1,      2,        2,       0,      0,   Pm    },
    {L"##:##p.m",       8,    0,     2,      3,        2,       0,      0,   Pm    },
    {L"#:#:#p.m",       8,    0,     1,      2,        1,       4,      1,   Pm    },
    {L"#:#:##p.m",      9,    0,     1,      2,        1,       4,      2,   Pm    },
    {L"##:#:#p.m",      9,    0,     2,      3,        1,       5,      1,   Pm    },
    {L"##:#:##p.m",     10,   0,     2,      3,        1,       5,      2,   Pm    },
    {L"#:##:#p.m",      9,    0,     1,      2,        2,       5,      1,   Pm    },
    {L"#:##:##p.m",     10,   0,     1,      2,        2,       5,      2,   Pm    },
    {L"##:##:#p.m",     10,   0,     2,      3,        2,       6,      1,   Pm    },
    {L"##:##:##p.m",    11,   0,     2,      3,        2,       6,      2,   Pm    },

    {L"#H",             2,    0,     1,      0,        0,       0,      0,   None   },
    {L"##H",            3,    0,     2,      0,        0,       0,      0,   None   },
    {L"#H#",            3,    0,     1,      2,        1,       0,      0,   None   },
    {L"##H#",           4,    0,     2,      3,        1,       0,      0,   None   },
    {L"#H##",           4,    0,     1,      2,        2,       0,      0,   None   },
    {L"##H##",          5,    0,     2,      3,        2,       0,      0,   None   },

    {L"\0",             0,    0,     0,      0,        0,       0,      0,   None   },

};

CAutoClassPointer<CClitics> g_pClitics;

CAutoClassPointer<CSpecialAbbreviationSet> g_pEngAbbList;
CAutoClassPointer<CSpecialAbbreviationSet> g_pFrnAbbList;
CAutoClassPointer<CSpecialAbbreviationSet> g_pItlAbbList;
CAutoClassPointer<CSpecialAbbreviationSet> g_pSpnAbbList;

CAutoClassPointer<CDateFormat> g_pDateFormat;
CAutoClassPointer<CTimeFormat> g_pTimeFormat;

CClitics::CClitics()
{
    DictStatus status;

    WCHAR* pTerm;
    int i;
    for (i = 0, pTerm = g_aClitics[i].pwcs;
         *pTerm != L'\0';
         i++, pTerm = g_aClitics[i].pwcs)
    {
        status = m_trieClitics.trie_Insert(
                                        pTerm,
                                        TRIE_IGNORECASE,
                                        const_cast<CCliticsTerm*>(&g_aClitics[i]),
                                        NULL);

        Assert (DICT_SUCCESS == status);
    }
}


CSpecialAbbreviationSet::CSpecialAbbreviationSet(const CAbbTerm* pAbbTermList)
{
    DictStatus status;

    WCHAR* pTerm;
    int i;
    for (i = 0, pTerm = pAbbTermList[i].pwcsAbb;
         *pTerm != L'\0';
         i++, pTerm = pAbbTermList[i].pwcsAbb)
    {
        status = m_trieAbb.trie_Insert(
                                    pTerm,
                                    TRIE_IGNORECASE,
                                    const_cast<CAbbTerm*>(&pAbbTermList[i]),
                                    NULL);

        Assert (DICT_SUCCESS == status);
    }

}


CDateFormat::CDateFormat()
{
    DictStatus status;

    WCHAR* pTerm;
    int i;
    for (i = 0, pTerm = g_aDateFormatList[i].pwcsFormat;
         *pTerm != L'\0';
         i++, pTerm = g_aDateFormatList[i].pwcsFormat)
    {
        status = m_trieDateFormat.trie_Insert(
                                        pTerm,
                                        TRIE_IGNORECASE,
                                        const_cast<CDateTerm*>(&g_aDateFormatList[i]),
                                        NULL);

        Assert (DICT_SUCCESS == status);
    }
}

CTimeFormat::CTimeFormat()
{
    DictStatus status;

    WCHAR* pTerm;
    int i;
    for (i = 0, pTerm = g_aTimeFormatList[i].pwcsFormat;
         *pTerm != L'\0';
         i++, pTerm = g_aTimeFormatList[i].pwcsFormat)
    {
        status = m_trieTimeFormat.trie_Insert(
                                        pTerm,
                                        TRIE_IGNORECASE,
                                        const_cast<CTimeTerm*>(&g_aTimeFormatList[i]),
                                        NULL);

        Assert (DICT_SUCCESS == status);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\custombreaking.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Tokenizer.cpp
//  Purpose  :  Tokenizer declerations
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      Jan 06 2000 yairh creation
//      Apr 05 2000 dovh - Fixed two problematic debug / tracer buffer size
//          problems.  (Fix Bug 15449).
//      May 07 2000 dovh - USE_WS_SENTINEL algorithm in BreakText
//
////////////////////////////////////////////////////////////////////////////////

#include "base.h"
#include "CustomBreaking.h"
#include "proparray.h"
#include "AutoPtr.h"
#include "excption.h"
#include "SpanishUtils.h"
#include "WbUtils.h"
#ifndef WHISTLER_BUILD
#include "LanguageResources_i.c"
#endif  // WHISTLER_BUILD


CAutoClassPointer<CCustomBreaker> g_apEngCustomBreaker;
CAutoClassPointer<CCustomBreaker> g_apEngUKCustomBreaker;
CAutoClassPointer<CCustomBreaker> g_apFrnCustomBreaker;
CAutoClassPointer<CCustomBreaker> g_apSpnCustomBreaker;
CAutoClassPointer<CCustomBreaker> g_apItlCustomBreaker;


CCustomWordTerm::CCustomWordTerm(const WCHAR* pwcs) :
    m_ulStartTxt(0),
    m_ulEndTxt(0),
    m_pwcs(NULL)
{
    ULONG ulLen = wcslen(pwcs);
    CAutoArrayPointer<WCHAR> ap;
    ap = new WCHAR[ulLen + 1];
    wcscpy(ap.Get(), pwcs);

    while ((m_ulStartTxt < ulLen) && 
           TEST_PROP(GET_PROP(ap.Get()[m_ulStartTxt]), CUSTOM_PUNCT_HEAD))
    {
        m_ulStartTxt++;
    }

    if (m_ulStartTxt == ulLen)
    {
        THROW_HRESULT_EXCEPTION(E_INVALIDARG);
    }

    m_ulEndTxt = ulLen;

    while(m_ulEndTxt &&
          TEST_PROP(GET_PROP(ap.Get()[m_ulEndTxt - 1]), CUSTOM_PUNCT_TAIL))
    {
        m_ulEndTxt--;
    }

    if (m_ulEndTxt <= m_ulStartTxt)
    {
        THROW_HRESULT_EXCEPTION(E_INVALIDARG);    
    }

    m_pwcs = ap.Detach();
    m_ulLen = ulLen;
}

bool CCustomWordTerm::CheckWord(
    const ULONG ulBufLen, 
    ULONG ulOffsetToBaseWord,
    ULONG ulBaseWordLen,
    const WCHAR* pwcsBuf,
    ULONG* pulMatchOffset,
    ULONG* pulMatchLen)
{
    ULONG ulStartTxt = m_ulStartTxt; 
  
    while (ulOffsetToBaseWord && 
           ulStartTxt && 
           m_pwcs[ulStartTxt] == pwcsBuf[ulOffsetToBaseWord])
    {
        ulOffsetToBaseWord--;
        ulStartTxt--;
        ulBaseWordLen++;
    }

    if (ulStartTxt)
    {
        return false;
    }
           
    ULONG ulEndTxt = m_ulEndTxt;

    while ((ulEndTxt < m_ulLen) &&
           (ulOffsetToBaseWord + ulBaseWordLen < ulBufLen) &&
           (m_pwcs[ulEndTxt] == pwcsBuf[ulOffsetToBaseWord + ulBaseWordLen ]))
    {
        ulEndTxt++;
        ulBaseWordLen++;
    }

    if (ulEndTxt != m_ulLen)
    {
        return false;
    }

    *pulMatchOffset = ulOffsetToBaseWord;
    *pulMatchLen = ulBaseWordLen;
    return true;  
}



void CCustomWordCollection::AddWord(const WCHAR* pwcs)
{
    CAutoClassPointer<CCustomWordTerm> ap;

    ap = new CCustomWordTerm(pwcs);
    m_vaWordCollection[m_ulCount] = ap.Get();
    m_ulCount++;
    ap.Detach();
}
    
bool CCustomWordCollection::CheckWord(
    const ULONG ulLen, 
    const ULONG ulOffsetToBaseWord,
    const ULONG ulBaseWordLen,
    const WCHAR* pwcsBuf,
    ULONG* pulMatchOffset,
    ULONG* pulMatchLen)
{
    for (ULONG ul = 0; ul < m_ulCount; ul++)
    {
        bool fRet = m_vaWordCollection[ul]->CheckWord(
                                                 ulLen,
                                                 ulOffsetToBaseWord,
                                                 ulBaseWordLen,
                                                 pwcsBuf, 
                                                 pulMatchOffset,
                                                 pulMatchLen);
        if (fRet)
        {
            return true;
        }
    }
    
    return false;
}

CCustomBreaker::CCustomBreaker(LCID lcid) :
    m_Trie(true),
    m_ulWordCount(0)
{
    CVarString vsPath;

    if (false == GetCustomWBFilePath(lcid, vsPath))
    {
        return;
    }

    CStandardCFile Words((LPWSTR)vsPath, L"r", false);
    if (!((FILE*)Words))
    {
        return;
    }

    WCHAR pwcsBuf[64];
    DictStatus status;

    while(fgetws(pwcsBuf, 64, (FILE*) Words))
    {
        m_ulWordCount++;

        ULONG ulLen = wcslen(pwcsBuf);

        if (ulLen && pwcsBuf[ulLen - 1] == L'\n')
        {
            pwcsBuf[ulLen - 1] = L'\0';
            ulLen--;
        }

        if (0 == ulLen)
        {
            continue;
        }

        try
        {
            CAutoClassPointer<CCustomWordCollection> apCollection = new CCustomWordCollection;
            apCollection->AddWord(pwcsBuf);

            WCHAR* pwcsKey = pwcsBuf + apCollection->GetFirstWord()->GetTxtStart();
            pwcsBuf[apCollection->GetFirstWord()->GetTxtEnd()] = L'\0';
            
            DictStatus status;
            CCustomWordCollection* pExistingCollection;
            
            status = m_Trie.trie_Insert(
                                    pwcsKey,
                                    TRIE_DEFAULT,
                                    apCollection.Get(),
                                    &pExistingCollection);
            if (DICT_ITEM_ALREADY_PRESENT == status)
            {
                pExistingCollection->AddWord(apCollection->GetFirstWord()->GetTxt());
            }
            else if (DICT_SUCCESS == status)
            {
                apCollection.Detach();
                continue;
            }
            
        }
        catch (CHresultException& h)
        {
            if (E_INVALIDARG == (HRESULT)h)
            {
                continue;
            }
            else
            {
                throw h;
            }
        }
    }
}

// 
// The idea behind the algorithm is to store a list of special patterns that should not
// be broken. We also want to be able to recognize those patterns when few punctuations 
// are attached to them. For example if .NET is a special pattern then in the following 
// patterns (.NET) .NET! .NET? we also want to recognize the .NET pattern and emit .NET
// It is more complicated in the next case - NET!. The expected behavior is not to break it.
// So algorithm need to identify when a punctuation is part of the token and not be broken
// and when it is just a breaker. 
// The algorithm is
// 1. Initialization.
//      for each token is the file 
//     	a. Remove punctuations from the beginning and ending of the token - we will 
//         reference it as the base form of the token.
//      b. Insert the base form to a dictionary. Each base form will be pointing to the 
//         generating token. Few tokens can be mapped to the same base form 
//         (NET? and NET!) so each base form will point to a collection of generating tokens 
// 2. Breaking.
//       For each pattern you get from the document
//          a.  perform 1a.
//          b.  look for the resulting base form in the dictionary. 
//          c.  per each item in the collection check whether the generating token exist in the 
//              pattern we got from the document.           
//          

bool CCustomBreaker::BreakText(
    ULONG ulLen,
    WCHAR* pwcsBuf,
    ULONG* pulOutLen,
    ULONG* pulOffset)
{
    DictStatus status;

    CCustomWordCollection* pCollection;
    short sCount = 0;
    
    ULONG ul = 0;
    while ((ul < ulLen) && 
           TEST_PROP(GET_PROP(pwcsBuf[ul]), CUSTOM_PUNCT_HEAD))
    {
        ul++;
    }

    ULONG ulOffsetToBase = ul;

    if (ulOffsetToBase == ulLen)
    {
        return false;
    }

    ULONG ulBaseLen = ulLen;

    while(ulBaseLen &&
          TEST_PROP(GET_PROP(pwcsBuf[ulBaseLen - 1]), CUSTOM_PUNCT_TAIL))
    {
        ulBaseLen--;
    }

    if (ulBaseLen <= ulOffsetToBase)
    {
        return false;    
    }

    ulBaseLen -= ulOffsetToBase;

    status = m_Trie.trie_Find(
                            pwcsBuf + ulOffsetToBase,
                            TRIE_LONGEST_MATCH,
                            1,
                            &pCollection,
                            &sCount);
    if (sCount)
    {
        bool bRet;

        bRet = pCollection->CheckWord(
                        ulLen, 
                        ulOffsetToBase,
                        ulBaseLen,
                        pwcsBuf,
                        pulOffset,
                        pulOutLen);
        return bRet;
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\custombreaking.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  CustomBreaking.h
//  Purpose  :  enable the user to specify in a file a list of tokens that 
//              should not be broken.
//
//  Project  :  WordBreakers
//  Component:  word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      Jul 20 2000 yairh creation
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _CUSTOM_BREAKING_H_
#define _CUSTOM_BREAKING_H_

#include "trie.h"
#include "vararray.h"
#include "AutoPtr.h"
#include "wbutils.h"

///////////////////////////////////////////////////////////////////////////////
// Class CCustomWordTerm
///////////////////////////////////////////////////////////////////////////////
class CCustomWordTerm
{
public:

    CCustomWordTerm(const WCHAR* pwcs);
    ~CCustomWordTerm()
    {
        delete m_pwcs;
    }

    bool CheckWord(
                const ULONG ulLen, 
                ULONG ulOffsetToBaseWord,
                ULONG ulBaseWordLen,
                const WCHAR* pwcsBuf,
                ULONG* pMatchOffset,
                ULONG* pulMatchLen);

    ULONG GetTxtStart()
    {
        return m_ulStartTxt;
    }

    ULONG GetTxtEnd()
    {
        return m_ulEndTxt;
    }

    WCHAR* GetTxt()
    {
        return m_pwcs;
    }

private:
    ULONG m_ulStartTxt;
    ULONG m_ulEndTxt;
    ULONG m_ulLen;
    WCHAR* m_pwcs;
     
};

///////////////////////////////////////////////////////////////////////////////
// Class CCustomWordCollection
///////////////////////////////////////////////////////////////////////////////
class CCustomWordCollection
{
public:

    CCustomWordCollection() :
        m_vaWordCollection(1),
        m_ulCount(0)
    {
    }

    void AddWord(const WCHAR* pwcs);
    
    CCustomWordTerm* GetFirstWord()
    {
        if (m_ulCount)
        {
            return m_vaWordCollection[(ULONG)0].Get();
        }
        return NULL;
    }

    bool CheckWord(
                const ULONG ulLen, 
                ULONG ulOffsetToBaseWord,
                ULONG ulBaseWordLen,
                const WCHAR* pwcsBuf,
                ULONG* pulMatchOffset,
                ULONG* pulMatchLen);
private:
    ULONG m_ulCount;
    CVarArray< CAutoClassPointer<CCustomWordTerm> > m_vaWordCollection;
};


///////////////////////////////////////////////////////////////////////////////
// Class CCustomBreaker
///////////////////////////////////////////////////////////////////////////////
class CCustomBreaker
{
public:

    CCustomBreaker(LCID lcid);

    bool IsNotEmpty()
    {
        return (m_ulWordCount > 0);
    }
    
    bool BreakText(
                ULONG ulLen,
                WCHAR* pwcsBuf,
                ULONG* pulOutLen,
                ULONG* pulOffset);


private:

    CTrie<CCustomWordCollection, CWbToUpper> m_Trie; 
    ULONG m_ulWordCount;
};

extern CAutoClassPointer<CCustomBreaker> g_apEngCustomBreaker;
extern CAutoClassPointer<CCustomBreaker> g_apEngUKCustomBreaker;
extern CAutoClassPointer<CCustomBreaker> g_apFrnCustomBreaker;
extern CAutoClassPointer<CCustomBreaker> g_apSpnCustomBreaker;
extern CAutoClassPointer<CCustomBreaker> g_apItlCustomBreaker;

#endif // _CUSTOM_BREAKING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\formats.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Formats.h
//  Purpose  :  Global dictionaries
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      May 30 2000 yairh creation
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _FORMATS_H_
#define _FORMATS_H_

#include "trie.h"
#include "wbutils.h"

///////////////////////////////////////////////////////////////////////////////
// Class CCliticsTerm
///////////////////////////////////////////////////////////////////////////////

#define NON_MATCH_TRUNCATE  0
#define HEAD_MATCH_TRUNCATE 1
#define TAIL_MATCH_TRUNCATE 2

struct CCliticsTerm
{
    WCHAR* pwcs;
    ULONG  ulLen;
    ULONG  ulOp;
};

///////////////////////////////////////////////////////////////////////////////
// Class CClitics
///////////////////////////////////////////////////////////////////////////////

class CClitics
{
public:
    CClitics();

    CTrie<CCliticsTerm, CWbToUpper> m_trieClitics;
};

///////////////////////////////////////////////////////////////////////////////
// Class CAbbTerm
///////////////////////////////////////////////////////////////////////////////

struct CAbbTerm
{
    WCHAR* pwcsAbb;
    ULONG ulAbbLen;
    WCHAR* pwcsCanonicalForm;
    ULONG ulCanLen;
};

///////////////////////////////////////////////////////////////////////////////
// Class CSpecialAbbreviation
///////////////////////////////////////////////////////////////////////////////

class CSpecialAbbreviationSet
{
public:
    CSpecialAbbreviationSet(const CAbbTerm* pAbbTermList);

    CTrie<CAbbTerm, CWbToUpper> m_trieAbb;
};


///////////////////////////////////////////////////////////////////////////////
// Class CDateTerm 
///////////////////////////////////////////////////////////////////////////////
struct CDateTerm 
{
    WCHAR* pwcsFormat;
    BYTE   bLen;
    BYTE   bType;
    BYTE   bD_M1Offset;
    BYTE   bD_M1Len;
    BYTE   bD_M2Offset;
    BYTE   bD_M2Len;
    BYTE   bYearOffset;
    BYTE   bYearLen;
};

#define YYMMDD_TYPE 1
///////////////////////////////////////////////////////////////////////////////
// Class CDateFormat 
///////////////////////////////////////////////////////////////////////////////

class CDateFormat
{
public:
    CDateFormat();

    CTrie<CDateTerm, CWbToUpper> m_trieDateFormat;
};

///////////////////////////////////////////////////////////////////////////////
// Class CTimeTerm 
///////////////////////////////////////////////////////////////////////////////
enum TimeFormat
{
    None = 0,
    Am,
    Pm
};

struct CTimeTerm 
{
    WCHAR* pwcsFormat;
    BYTE   bLen;
    BYTE   bHourOffset;
    BYTE   bHourLen;
    BYTE   bMinOffset;
    BYTE   bMinLen;
    BYTE   bSecOffset;
    BYTE   bSecLen;
    TimeFormat AmPm;
    
};

///////////////////////////////////////////////////////////////////////////////
// Class CTimeFormat 
///////////////////////////////////////////////////////////////////////////////

class CTimeFormat
{
public:
    CTimeFormat();

    CTrie<CTimeTerm, CWbToUpper> m_trieTimeFormat;
};


extern CAutoClassPointer<CClitics> g_pClitics;
extern CAutoClassPointer<CSpecialAbbreviationSet> g_pEngAbbList;
extern CAutoClassPointer<CSpecialAbbreviationSet> g_pFrnAbbList;
extern CAutoClassPointer<CSpecialAbbreviationSet> g_pSpnAbbList;
extern CAutoClassPointer<CSpecialAbbreviationSet> g_pItlAbbList;
extern CAutoClassPointer<CDateFormat> g_pDateFormat;
extern CAutoClassPointer<CTimeFormat> g_pTimeFormat;
extern const CCliticsTerm g_aClitics[];
extern const CCliticsTerm g_SClitics;
extern const CCliticsTerm g_EmptyClitics;

extern const CAbbTerm g_aEngAbbList[];
extern const CAbbTerm g_aFrenchAbbList[];
extern const CAbbTerm g_aSpanishAbbList[];
extern const CAbbTerm g_aItalianAbbList[];

extern const CDateTerm g_aDateFormatList[];
extern const CTimeTerm s_aTimeFormatList[];

#define  MAX_DATE_FORMAT_LEN 10
#define  MAX_TIME_FORMAT_LEN 12

#endif // _FORMATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\frenchtokenizer.cpp ===
#include "base.h"
#include "FrenchTokenizer.h"

void CFrenchTokenizer::OutputHyphenation(
    CTokenState& State,
    const CCliticsTerm* pCliticsTerm)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }

    ULONG ulCur = State.m_ulStart + ulAddToStart;
    ULONG ulEnd = State.m_ulEnd - ulDecFromEnd;

    while (ulCur < ulEnd)
    {
        if ( HAS_PROP_DASH(GET_PROP(m_pCurToken->m_State.m_pwcsToken[ulCur])))
        {
            m_pCurToken->m_State.m_pwcsToken[ulCur] = L'-';
        }
        ulCur++;
    }

    ulCur = State.m_ulStart + ulAddToStart;
    CCliticsTerm* pDashTerm = NULL;
    bool fFoundDashClitics = false;

    while (ulCur < ulEnd)
    {
        if (m_pCurToken->m_State.m_pwcsToken[ulCur] == L'-')
        {
            DictStatus status;

            short sResCount = 0;
            if (ulCur > State.m_ulStart)
            {
                status = g_pClitics->m_trieClitics.trie_Find(
                                            State.m_pwcsToken + ulCur,
                                            TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                            1,
                                            &pDashTerm,
                                            &sResCount);
                if (sResCount && (pDashTerm->ulLen == (ulEnd - ulCur)))
                {
                    Trace(
                        elVerbose,
                        s_tagTokenizerDecision,
                        ("%*.*S  has a %S clitcs",
                        State.m_ulEnd - State.m_ulStart,
                        State.m_ulEnd - State.m_ulStart,
                        State.m_pwcsToken + State.m_ulStart,
                        pDashTerm->pwcs
                        ));

                    fFoundDashClitics = true;
                    break;
                }
            }

        }
        ulCur++;
    }

    if (fFoundDashClitics)
    {
        Assert(pDashTerm);
        if (pDashTerm->ulOp == HEAD_MATCH_TRUNCATE)
        {
            ulAddToStart += pDashTerm->ulLen;
        }
        else if (pDashTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            ulDecFromEnd += pDashTerm->ulLen;
        }
    }

    if (ulDecFromEnd || ulAddToStart)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart,
                        State.m_pwcsToken + State.m_ulStart,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart - ulDecFromEnd - ulAddToStart,
                    State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\frenchtokenizer.h ===
#ifndef _FRENCH_TOKENIZER_H_
#define _FRENCH_TOKENIZER_H_

#include "tokenizer.h"

class CFrenchTokenizer : public CTokenizer
{
public:
    CFrenchTokenizer(
        TEXT_SOURCE* pTxtSource,
        IWordSink   * pWordSink,
        IPhraseSink * pPhraseSink,
        LCID lcid,
        BOOL bQueryTime,
        ULONG ulMaxTokenSize) :
        CTokenizer(pTxtSource, pWordSink, pPhraseSink, lcid, bQueryTime, ulMaxTokenSize)
    {
    }

    virtual ~CFrenchTokenizer()
    {
    }

protected:

    virtual void OutputHyphenation(
                CTokenState& State, 
                const CCliticsTerm* pCliticsTerm);


};

#endif // _FRENCH_TOKENIZER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\langsupport.cpp ===
#include "base.h"
#include "langsupport.h"

#define LANG_ENG_US 0
#define LANG_ENG_UK 1
#define LANG_FRN    2
#define LANG_SPN    3
#define LANG_ITL    4

#define NUM_OF_LANG 5

LangInfo g_rLangDefaultValues[NUM_OF_LANG] = 
{
    {L',', L'.', L':', false},  // US
    {L',', L'.', L':', true},   // UK
    {(WCHAR)0xA0, L',', L':', true},   // FRN
    {L'.', L',', L':', true},   // SPN
    {L'.', L',', L'.', true},   // ITL
};


CLangSupport::CLangSupport(LCID lcid)
{
    int i;
    WCHAR pwcs[4];

    CSpecialAbbreviationSet* pAbbSet;
    ULONG ulLang;

    switch (PRIMARYLANGID(LANGIDFROMLCID(lcid)))
    {
    case LANG_ENGLISH:
        if (lcid == MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT))
        {
            ulLang = LANG_ENG_US;
        }
        else
        {
            ulLang = LANG_ENG_UK;
        }
        pAbbSet = g_pEngAbbList.Get();
        break;
    case LANG_FRENCH:
        ulLang = LANG_FRN;
        pAbbSet = g_pFrnAbbList.Get();
        break;
    case LANG_SPANISH:
        ulLang = LANG_SPN;
        pAbbSet = g_pSpnAbbList.Get();
        break;
    case LANG_ITALIAN:
        ulLang = LANG_ITL;
        pAbbSet = g_pItlAbbList.Get();
        break;
    default:
        Assert(0);
    }

    *((LangInfo*)this) =  g_rLangDefaultValues[ulLang];
    m_pAbbSet = pAbbSet;

    i = GetLocaleInfo(
		    lcid,
		    LOCALE_SDECIMAL | LOCALE_NOUSEROVERRIDE ,
		    pwcs,
		    4);

    if (i > 0)
    {
        m_wchSDecimal = pwcs[0];
    }

    i = GetLocaleInfo(
		    lcid,
		    LOCALE_STHOUSAND | LOCALE_NOUSEROVERRIDE ,
		    pwcs,
		    4);
    if (i > 0)
    {
        m_wchSThousand = pwcs[0];
    }

    DWORD dwVal;
    i = GetLocaleInfo(
		    lcid,
		    LOCALE_IDATE | LOCALE_NOUSEROVERRIDE | LOCALE_RETURN_NUMBER,
		    (WCHAR*)&dwVal,
		    2);
    if (i > 0)
    {
        if ((dwVal == 1) || (dwVal == 2))
        {
            m_bDayMonthOrder = true;
        }
        else
        {
            m_bDayMonthOrder = false;
        }
    }

    i = GetLocaleInfo(
		    lcid,
		    LOCALE_STIME | LOCALE_NOUSEROVERRIDE ,
		    pwcs,
		    4);
    if (i > 0)
    {
        m_wchSTime = pwcs[0];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\global.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Global.cpp
//  Purpose  :  Global Initalization.
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      May 30 2000 yairh creation
//
////////////////////////////////////////////////////////////////////////////////

#include "base.h"
#include "tokenizer.h"
#include "formats.h"
#include "synchro.h"

extern CAutoClassPointer<CPropArray> g_pPropArray;
extern CAutoClassPointer<CSyncCriticalSection> g_apcsSpanishDictInit;

void InitializeGlobalData()
{
    CAutoClassPointer<CPropArray> apPropArray = new CPropArray;
    CAutoClassPointer<CClitics> apClitics = new CClitics;
    CAutoClassPointer<CSpecialAbbreviationSet> apEngAbbList = new CSpecialAbbreviationSet(g_aEngAbbList);
    CAutoClassPointer<CSpecialAbbreviationSet> apFrnAbbList = new CSpecialAbbreviationSet(g_aFrenchAbbList);
    CAutoClassPointer<CSpecialAbbreviationSet> apSpnAbbList = new CSpecialAbbreviationSet(g_aSpanishAbbList);
    CAutoClassPointer<CSpecialAbbreviationSet> apItlAbbList = new CSpecialAbbreviationSet(g_aItalianAbbList);
    CAutoClassPointer<CDateFormat> apDateFormat = new CDateFormat;
    CAutoClassPointer<CTimeFormat> apTimeFormat = new CTimeFormat;
    CAutoClassPointer<CSyncCriticalSection> apcsSpanishDictInit = new CSyncCriticalSection; 
     
    g_pPropArray = apPropArray.Detach(); 
    g_pClitics = apClitics.Detach();

    g_pEngAbbList = apEngAbbList.Detach() ;
    g_pFrnAbbList = apFrnAbbList.Detach();
    g_pSpnAbbList = apSpnAbbList.Detach() ;
    g_pItlAbbList = apItlAbbList.Detach() ;

    g_pDateFormat = apDateFormat.Detach();
    g_pTimeFormat = apTimeFormat.Detach();
    g_apcsSpanishDictInit = apcsSpanishDictInit.Detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WordBreaker.rc
//
#define IDS_PROJNAME                         100
#define IDR_ENGUSWRDBRK                      101
#define IDR_ENGUKWRDBRK                      102
#define IDR_FRNFRNWRDBRK                     103
#define IDR_ITLITLWRDBRK                     104
#define IDR_SPNMDRWRDBRK                     105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\langsupport.h ===
#ifndef _LANG_SUPPORT_H_
#define _LANG_SUPPORT_H_

#include "propflags.h"
#include "formats.h"
#include "tracer.h"

struct LangInfo
{
    WCHAR m_wchSThousand;
    WCHAR m_wchSDecimal;
    WCHAR m_wchSTime;

    bool m_bDayMonthOrder;

    LangInfo& operator= (LangInfo& I)
    {
        m_wchSThousand = I.m_wchSThousand;
        m_wchSDecimal = I.m_wchSDecimal;
        m_wchSTime = I.m_wchSTime;
        m_bDayMonthOrder = I.m_bDayMonthOrder;

        return *this;
    }

};

class CLangSupport : public LangInfo
{
public:

    CLangSupport(LCID lcid);

    WCHAR GetDecimalSeperator()
    {
        return m_wchSDecimal; 
    }

    WCHAR GetThousandSeperator()
    {
        return m_wchSThousand; 
    }

    WCHAR GetTimeSeperator()
    {
        return m_wchSTime; 
    }

    bool IsDayMonthOrder()
    {
        return m_bDayMonthOrder;
    }

    CSpecialAbbreviationSet* GetAbbSet()
    {
        return m_pAbbSet;
    }

private:

    CSpecialAbbreviationSet* m_pAbbSet;

};


#endif // _LANG_SUPPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\propflags.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  PropFlags.h
//  Purpose  :  properties definitions
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//    Jan 06 2000 yairh creation
//    May 07 2000 dovh - const array generation:
//                split PropArray.h => PropArray.h + PropFlags.h
//    May 11 2000 dovh - Simplify GET_PROP to do double indexing always.
//    Nov 11 2000 dovh - Special underscore treatment
//                       (Only added PROP_ALPHA_NUMERIC flag here)
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _PROP_FLAGS_H_
#define _PROP_FLAGS_H_

#define USE_WS_SENTINEL
// #undef USE_WS_SENTINEL

// #define DECLARE_BYTE_ARRAY
#undef DECLARE_BYTE_ARRAY

// #define DECLARE_ULONGLONG_ARRAY
#undef DECLARE_ULONGLONG_ARRAY

const WCHAR TRACE_CHAR[] = \
    {L'S',  L'E', L'U', L'L', L'N', L'~', L'!',  L'@',  L'#', L'$',  \
     L'%',  L'-', L'&', L'*', L'(', L')', L'-',  L'_',  L'=', L'+',  \
     L'\\', L'|', L'{', L'}', L'[', L']', L'\"', L'\'', L';', L':',  \
     L'?',  L'/', L'<', L'>', L'.', L',', L'w',  L'C',  L'T', L'B',  \
     L's',  L'X', L'S', L'\0'};

//
//  NOTE: DO NOT CHANGE THE ORDER.
//  UPDATE GEN_PROP_STRING_VALUE MACRO BELOW WHENEVER FLAGS DEFINITIONS CHANGE!
//

#define PROP_DEFAULT                ((ULONGLONG)0)

#define PROP_WS                     (((ULONGLONG)1)<< 0)
#define PROP_EOS                    (((ULONGLONG)1)<< 1)
#define PROP_UPPER_CASE             (((ULONGLONG)1)<< 2)
#define PROP_LOWER_CASE             (((ULONGLONG)1)<< 3)
#define PROP_PERIOD                 (((ULONGLONG)1)<< 4)
#define PROP_COMMA                  (((ULONGLONG)1)<< 5)
#define PROP_RESERVED_BREAKER       (((ULONGLONG)1)<< 6)
#define PROP_RESERVED               (((ULONGLONG)1)<< 7)

#define PROP_NUMBER                 (((ULONGLONG)1)<< 8)
#define PROP_TILDE                  (((ULONGLONG)1)<< 9)
#define PROP_EXCLAMATION_MARK       (((ULONGLONG)1)<<10)
#define PROP_AT                     (((ULONGLONG)1)<<11)
#define PROP_POUND                  (((ULONGLONG)1)<<12)
#define PROP_DOLLAR                 (((ULONGLONG)1)<<13)
#define PROP_PERCENTAGE             (((ULONGLONG)1)<<14)
#define PROP_MINUS                  (((ULONGLONG)1)<<15)

#define PROP_AND                    (((ULONGLONG)1)<<16)
#define PROP_ASTERISK               (((ULONGLONG)1)<<17)
#define PROP_LEFT_PAREN             (((ULONGLONG)1)<<18)
#define PROP_RIGHT_PAREN            (((ULONGLONG)1)<<19)
#define PROP_DASH                   (((ULONGLONG)1)<<20)
#define PROP_UNDERSCORE             (((ULONGLONG)1)<<21)
#define PROP_EQUAL                  (((ULONGLONG)1)<<22)
#define PROP_PLUS                   (((ULONGLONG)1)<<23)

#define PROP_BACKSLASH              (((ULONGLONG)1)<<24)
#define PROP_OR                     (((ULONGLONG)1)<<25)
#define PROP_LEFT_CURLY_BRACKET     (((ULONGLONG)1)<<26)
#define PROP_RIGHT_CURLY_BRACKET    (((ULONGLONG)1)<<27)
#define PROP_LEFT_BRAKCET           (((ULONGLONG)1)<<28)
#define PROP_RIGHT_BRAKCET          (((ULONGLONG)1)<<29)
#define PROP_DOUBLE_QUOTE           (((ULONGLONG)1)<<30)
#define PROP_APOSTROPHE             (((ULONGLONG)1)<<31)

#define PROP_SEMI_COLON             (((ULONGLONG)1)<<32)
#define PROP_COLON                  (((ULONGLONG)1)<<33)
#define PROP_QUESTION_MARK          (((ULONGLONG)1)<<34)
#define PROP_SLASH                  (((ULONGLONG)1)<<35)
#define PROP_LT                     (((ULONGLONG)1)<<36)
#define PROP_GT                     (((ULONGLONG)1)<<37)
#define PROP_W                      (((ULONGLONG)1)<<38)
#define PROP_CURRENCY               (((ULONGLONG)1)<<39)
#define PROP_BREAKER                (((ULONGLONG)1)<<40)
#define PROP_TRANSPERENT            (((ULONGLONG)1)<<41)
#define PROP_NBS                    (((ULONGLONG)1)<<42)
#define PROP_ALPHA_XDIGIT           (((ULONGLONG)1)<<43)
#define PROP_COMMERSIAL_SIGN        (((ULONGLONG)1)<<44)

#define WB_PROP_COUNT               45


//
//  The following is the contents of the GEN_PROP_STRING array
//  used by the array generator.
//
//  NOTE: DO NOT CHANGE THE ORDER.
//  UPDATE MACRO WHENEVER FLAGS DEFINITIONS CHANGE TO REFLECT CHANGES!
//
//  extern const WCHAR* GEN_PROP_STRING[ WB_PROP_COUNT ];
//

#define GEN_PROP_STRING_VALUE       \
{                                   \
                                    \
    L"PROP_WS",                     \
    L"PROP_EOS",                    \
    L"PROP_UPPER_CASE",             \
    L"PROP_LOWER_CASE",             \
    L"PROP_PERIOD",                 \
    L"PROP_COMMA",                  \
    L"PROP_RESERVED_BREAKER",       \
    L"PROP_RESERVED",               \
                                    \
    L"PROP_NUMBER",                 \
    L"PROP_TILDE",                  \
    L"PROP_EXCLAMATION_MARK",       \
    L"PROP_AT",                     \
    L"PROP_POUND",                  \
    L"PROP_DOLLAR",                 \
    L"PROP_PERCENTAGE",             \
    L"PROP_MINUS",                  \
                                    \
    L"PROP_AND",                    \
    L"PROP_ASTERISK",               \
    L"PROP_LEFT_PAREN",             \
    L"PROP_RIGHT_PAREN",            \
    L"PROP_DASH",                   \
    L"PROP_UNDERSCORE",             \
    L"PROP_EQUAL",                  \
    L"PROP_PLUS",                   \
                                    \
    L"PROP_BACKSLASH",              \
    L"PROP_OR",                     \
    L"PROP_LEFT_CURLY_BRACKET",     \
    L"PROP_RIGHT_CURLY_BRACKET",    \
    L"PROP_LEFT_BRAKCET",           \
    L"PROP_RIGHT_BRAKCET",          \
    L"PROP_DOUBLE_QUOTE",           \
    L"PROP_APOSTROPHE",             \
                                    \
    L"PROP_SEMI_COLON",             \
    L"PROP_COLON",                  \
    L"PROP_QUESTION_MARK",          \
    L"PROP_SLASH",                  \
    L"PROP_LT",                     \
    L"PROP_GT",                     \
    L"PROP_W",                      \
    L"PROP_CURRENCY",               \
    L"PROP_BREAKER"                 \
    L"PROP_TRANSPERENT"             \
    L"PROP_NBS"                     \
    L"PROP_ALPHA_XDIGIT"            \
    L"PROP_COMMERSIAL_SIGN"         \
}

#define PROP_ALPHA  (PROP_LOWER_CASE | PROP_UPPER_CASE)
#define PROP_ALPHA_NUMERIC (PROP_LOWER_CASE | PROP_UPPER_CASE | PROP_NUMBER)
#define PROP_DATE_SEPERATOR (PROP_DASH | PROP_SLASH | PROP_PERIOD)
#define PROP_XDIGIT (PROP_NUMBER | PROP_ALPHA_XDIGIT)

#define PROP_FIRST_LEVEL_BREAKER \
     (PROP_BREAKER | PROP_EXCLAMATION_MARK | PROP_ASTERISK | \
     PROP_LEFT_PAREN | PROP_RIGHT_PAREN | PROP_BACKSLASH | PROP_EQUAL | PROP_OR | \
     PROP_LEFT_CURLY_BRACKET | PROP_RIGHT_CURLY_BRACKET | PROP_LEFT_BRAKCET | PROP_RIGHT_BRAKCET | \
     PROP_DOUBLE_QUOTE | PROP_SEMI_COLON | PROP_QUESTION_MARK | PROP_SLASH | \
     PROP_COMMA | PROP_GT | PROP_LT | PROP_WS )
 
#define PROP_SECOND_LEVEL_BREAKER \
    (PROP_TILDE | PROP_AT | PROP_DOLLAR | PROP_PERCENTAGE | PROP_AND |\
     PROP_DASH | PROP_PLUS | PROP_COLON | PROP_PERIOD | PROP_POUND)

#define PROP_DEFAULT_BREAKER (PROP_FIRST_LEVEL_BREAKER | PROP_SECOND_LEVEL_BREAKER) 

//
// Hyphenation
//

#define HYPHENATION_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)
#define HYPHENATION_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_NBS)

//
// Abbreviation, acronym
//

#define ACRONYM_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)

#define ACRONYM_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_NBS)

#define ABBREVIATION_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | \
                                 PROP_NBS | PROP_APOSTROPHE)

#define ABBREVIATION_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_NBS | PROP_APOSTROPHE)

#define ABBREVIATION_EOS \
    (PROP_SEMI_COLON | PROP_COLON | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | PROP_NBS)

#define SPECIAL_ABBREVIATION_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)

#define SPECIAL_ABBREVIATION_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_NBS)

//
// Parenthesis
//
#define PAREN_PUNCT_TAIL (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_PERIOD | \
                          PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | PROP_NBS | PROP_APOSTROPHE)

#define PAREN_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | \
                          PROP_QUESTION_MARK | PROP_NBS | PROP_APOSTROPHE)

//
// Clitics
//

#define CLITICS_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)
#define CLITICS_PUNC_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_NBS)

//
// Numbers date time
//

#define NUM_DATE_TIME_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | \
                                  PROP_LEFT_BRAKCET | PROP_LEFT_CURLY_BRACKET | PROP_NBS)
#define NUM_DATE_TIME_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_RIGHT_BRAKCET | PROP_RIGHT_CURLY_BRACKET | PROP_NBS | \
     PROP_PERCENTAGE)

#define TIME_ADDITIONAL_PUNCT_HEAD (PROP_APOSTROPHE)

#define TIME_ADDITIONAL_PUNCT_TAIL (PROP_APOSTROPHE)

#define DATE_ADDITIONAL_PUNCT_HEAD (PROP_APOSTROPHE)

#define DATE_ADDITIONAL_PUNCT_TAIL (PROP_APOSTROPHE)


//
// Currency
//
#define CURRENCY_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | \
                             PROP_LEFT_BRAKCET | PROP_LEFT_CURLY_BRACKET | PROP_APOSTROPHE | \
                             PROP_NBS)

#define CURRENCY_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_RIGHT_BRAKCET | PROP_RIGHT_CURLY_BRACKET | \
     PROP_APOSTROPHE | PROP_NBS)

//
// Misc
//
#define MISC_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)

#define MISC_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_NBS)

//
// Commersial sign
// 
#define COMMERSIAL_SIGN_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)

#define COMMERSIAL_SIGN_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_NBS)

//
// EOS
//
#define EOS_SUFFIX \
        (PROP_WS | PROP_RIGHT_BRAKCET | PROP_RIGHT_PAREN | PROP_RIGHT_CURLY_BRACKET | \
         PROP_APOSTROPHE | PROP_NBS)


//
// default
//

#define SIMPLE_PUNCT_HEAD (PROP_NBS | PROP_UNDERSCORE | PROP_DEFAULT_BREAKER | PROP_APOSTROPHE)
#define SIMPLE_PUNCT_TAIL (PROP_NBS | PROP_UNDERSCORE | PROP_DEFAULT_BREAKER | PROP_APOSTROPHE)

#define MAX_NUM_PROP 64

//
//  PROP_FLAGS MACROS:
//

#ifndef DECLARE_ULONGLONG_ARRAY

#define GET_PROP(wch)                                               \
    ( g_pPropArray->m_apCodePage[wch >> 8][(UCHAR)wch] )

#ifdef DECLARE_BYTE_ARRAY
extern const BYTE g_BytePropFlagArray[  ];

#define IS_WS(wch) (g_BytePropFlagArray[wch] & PROP_WS)
#define IS_EOS(wch) (g_BytePropFlagArray[wch] & PROP_EOS)
#define IS_BREAKER(wch) (g_BytePropFlagArray[wch] & PROP_RESERVED_BREAKER)
#else
#define IS_WS(wch) (GET_PROP(wch).m_ulFlag & PROP_WS)
#define IS_EOS(wch) (GET_PROP(wch).m_ulFlag & PROP_EOS)
#define IS_BREAKER(wch) (GET_PROP(wch).m_ulFlag & PROP_DEFAULT_BREAKER)
#endif // DECLARE_BYTE_ARRAY

#else

class CPropFlag;
extern const ULONGLONG g_UllPropFlagArray[ ];

#define GET_PROP(wch) (g_PropFlagArray[wch])
#define IS_WS(wch) (g_UllPropFlagArray[wch] & PROP_WS)
#define IS_EOS(wch) (g_UllPropFlagArray[wch] & PROP_EOS)
#define IS_BREAKER(wch) (g_UllPropFlagArray[wch] & PROP_DEFAULT_BREAKER)

#endif // DECLARE_ULONGLONG_ARRAY

#define HAS_PROP_ALPHA(prop)        (prop.m_ulFlag & PROP_ALPHA)
#define HAS_PROP_EXTENDED_ALPHA(prop) (prop.m_ulFlag & (PROP_ALPHA | PROP_TRANSPERENT))
#define HAS_PROP_UPPER_CASE(prop)   (prop.m_ulFlag & PROP_UPPER_CASE)
#define HAS_PROP_LOWER_CASE(prop)   (prop.m_ulFlag & PROP_LOWER_CASE)
#define HAS_PROP_NUMBER(prop)       (prop.m_ulFlag & PROP_NUMBER)
#define HAS_PROP_CURRENCY(prop)     (prop.m_ulFlag & PROP_CURRENCY)
#define HAS_PROP_LEFT_PAREN(prop)   (prop.m_ulFlag & PROP_LEFT_PAREN)
#define HAS_PROP_RIGHT_PAREN(prop)  (prop.m_ulFlag & PROP_RIGHT_PAREN)
#define HAS_PROP_APOSTROPHE(prop)   (prop.m_ulFlag & PROP_APOSTROPHE)
#define HAS_PROP_BACKSLASH(prop)    (prop.m_ulFlag & PROP_BACKSLASH)
#define HAS_PROP_SLASH(prop)        (prop.m_ulFlag & PROP_SLASH)
#define HAS_PROP_PERIOD(prop)       (prop.m_ulFlag & PROP_PERIOD)
#define HAS_PROP_COMMA(prop)        (prop.m_ulFlag & PROP_COMMA)
#define HAS_PROP_COLON(prop)        (prop.m_ulFlag & PROP_COLON)
#define HAS_PROP_DASH(prop)         (prop.m_ulFlag & PROP_DASH)
#define HAS_PROP_W(prop)            (prop.m_ulFlag & PROP_W)
#define IS_PROP_SIMPLE(prop)        \
    (!prop.m_ulFlag ||              \
     ((prop.m_ulFlag & (PROP_ALPHA | PROP_TRANSPERENT | PROP_W | PROP_ALPHA_XDIGIT)) &&  \
      !(prop.m_ulFlag & ~(PROP_ALPHA | PROP_TRANSPERENT | PROP_W | PROP_ALPHA_XDIGIT)))) 

#define TEST_PROP(prop, i)          (prop.m_ulFlag & (i))
#define TEST_PROP1(prop1, prop2)    (prop1.m_ulFlag & prop2.m_ulFlag)

#endif // _PROP_FLAGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\proparray.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  PropArray.h
//      Purpose  :  properties definitions
//
//      Project  :  WordBreakers
//      Component:  English word breaker
//
//      Author   :  yairh
//
//      Log:
//
//      Jan 06 2000 yairh creation
//      May 07 2000 dovh - const array generation:
//                  split PropArray.h => PropArray.h + PropFlags.h
//      May 11 2000 dovh - Simplify GET_PROP to do double indexing always.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _PROP_ARRAY_H_
#define _PROP_ARRAY_H_

#include "PropFlags.h"

///////////////////////////////////////////////////////////////////////////////
// Class CPropFlag
///////////////////////////////////////////////////////////////////////////////

class CPropFlag
{
public:

    //
    // methods
    //

    CPropFlag();
    CPropFlag(ULONGLONG ul);

    void Clear();
    void Set(ULONGLONG ul);
    CPropFlag& operator= (const CPropFlag& f);
    CPropFlag& operator|= (const CPropFlag& f);

public:

    //
    // members
    //

    ULONGLONG m_ulFlag;
};

inline CPropFlag::CPropFlag(): m_ulFlag(0)
{
}

inline CPropFlag::CPropFlag(ULONGLONG ul): m_ulFlag(ul)
{
}

inline void CPropFlag::Clear()
{
    m_ulFlag = 0;
}

inline void CPropFlag::Set(ULONGLONG ul)
{
    m_ulFlag |= ul;

#ifdef DECLARE_BYTE_ARRAY
    if (ul & PROP_DEFAULT_BREAKER)
    {
        m_ulFlag |= PROP_RESERVED_BREAKER;
    }
#endif // DECLARE_BYTE_ARRAY

}

inline CPropFlag& CPropFlag::operator= (const CPropFlag& f)
{
    m_ulFlag = f.m_ulFlag;
    return *this;
}

inline CPropFlag& CPropFlag::operator|= (const CPropFlag& f)
{
    m_ulFlag |= f.m_ulFlag;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Class CTokenState
///////////////////////////////////////////////////////////////////////////////

class CPropArray
{
public:

    //
    // methods
    //

    CPropArray();
    ~CPropArray();

    CPropFlag& GetPropForUpdate(WCHAR wch);

public:

    //
    // members
    //

    CPropFlag* m_apCodePage[1<<8];

    CPropFlag m_aDefaultCodePage[1<<8];
};

inline CPropArray::CPropArray()
{
    for (WCHAR wch = 0; wch < (1<<8); wch++)
    {
        m_apCodePage[wch] = NULL;
    }

    //
    // White space characters
    //

    for(wch=0x0; wch <= 0x1F; wch++)   // control 0x0 - 0x1F
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }

    for(wch=0x80; wch <= 0x9F; wch++)   // control 0x80 - 0x9F
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }

    GetPropForUpdate(0x7F).Set(PROP_WS);  // control

    GetPropForUpdate(0x0020).Set(PROP_WS);   // space
    GetPropForUpdate(0x0022).Set(PROP_WS);  // quotation mark
    GetPropForUpdate(0x00AB).Set(PROP_WS);  // left angle double pointing quotation mark 
    GetPropForUpdate(0x00BB).Set(PROP_WS);  // right angle double pointing quotation mark
    GetPropForUpdate(0x201A).Set(PROP_WS);  // Single low-9 quotation mark
    GetPropForUpdate(0x201B).Set(PROP_WS);  // Single low-9 quotation mark
    GetPropForUpdate(0x201C).Set(PROP_WS);  // Left double quotation mark
    GetPropForUpdate(0x201D).Set(PROP_WS);  // Right double quotation mark
    GetPropForUpdate(0x201E).Set(PROP_WS);  // Double low-9 quotation mark
    GetPropForUpdate(0x201F).Set(PROP_WS);  // Double high-reversed-9 quotation mark

    GetPropForUpdate(0x2039).Set(PROP_WS);  // single left pointing quotation mark
    GetPropForUpdate(0x203A).Set(PROP_WS);  // single right pointing quotation mark

    GetPropForUpdate(0x301D).Set(PROP_WS);  // Reverse double prime quotation mark
    GetPropForUpdate(0x301E).Set(PROP_WS);  // Double prime quotation mark
    GetPropForUpdate(0x301F).Set(PROP_WS);  // Low double prime quotation mark

    for(wch=0x2000; wch <= 0x200B; wch++)   // space 0x2000 - 0x200B
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }
 
    GetPropForUpdate(0x3000).Set(PROP_WS);  // space
    GetPropForUpdate(0xFF02).Set(PROP_WS);  // Full width quotation mark

    // Geometrical shapes, arrows and other characters that can be ignored

    for(wch=0x2190; wch <= 0x21F3; wch++)   // Arrows
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }
    
    for(wch=0x2500; wch <= 0x257F; wch++)   // Box Drawing
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }
    
    for(wch=0x2580; wch <= 0x2595; wch++)   // Block Elements
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }

    for(wch=0x25A0; wch <= 0x25F7; wch++)   // Geometric Shapes
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }

    //
    // Exclmation mark
    //

    GetPropForUpdate(0x0021).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0x00A1).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0x01C3).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0x203C).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0x203D).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0x2762).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0xFF01).Set(PROP_EXCLAMATION_MARK);  // Full width

    //
    // Number sign
    //

    GetPropForUpdate(0x0023).Set(PROP_POUND);   // #
    GetPropForUpdate(0xFF03).Set(PROP_POUND);   // Full width

    //
    // Dollar sign
    //

    GetPropForUpdate(0x0024).Set(PROP_DOLLAR);  // $
    GetPropForUpdate(0xFF04).Set(PROP_DOLLAR);  // Full width

    //
    // Percentage sign
    //

    GetPropForUpdate(0x0025).Set(PROP_PERCENTAGE);
    GetPropForUpdate(0x2030).Set(PROP_PERCENTAGE);
    GetPropForUpdate(0x2031).Set(PROP_PERCENTAGE);
    GetPropForUpdate(0xFF05).Set(PROP_PERCENTAGE); // Full width

    //
    // Ampersand
    //

    GetPropForUpdate(0x0026).Set(PROP_AND);   // &

    //
    // Apostrophe
    //

    GetPropForUpdate(0x0027).Set(PROP_APOSTROPHE);
    GetPropForUpdate(0x2018).Set(PROP_APOSTROPHE);
    GetPropForUpdate(0x2019).Set(PROP_APOSTROPHE);
    GetPropForUpdate(0x2032).Set(PROP_APOSTROPHE);
    GetPropForUpdate(0xFF07).Set(PROP_APOSTROPHE);  // Full width

    //
    // Parenthesis
    //

    GetPropForUpdate(0x0028).Set(PROP_LEFT_PAREN);    // (
    GetPropForUpdate(0xFF08).Set(PROP_LEFT_PAREN);    // Full width
    GetPropForUpdate(0x0029).Set(PROP_RIGHT_PAREN);   // )
    GetPropForUpdate(0xFF09).Set(PROP_RIGHT_PAREN);   // Full width

    //
    // Asterisk
    //

    GetPropForUpdate(0x002A).Set(PROP_ASTERISK);   // *
    GetPropForUpdate(0x2217).Set(PROP_ASTERISK);
    GetPropForUpdate(0x2731).Set(PROP_ASTERISK);
    GetPropForUpdate(0xFF0A).Set(PROP_ASTERISK);   // Full width

    //
    // Plus sign
    //

    GetPropForUpdate(0x002B).Set(PROP_PLUS);  // +
    GetPropForUpdate(0xFF0B).Set(PROP_PLUS);  // Full width

    //
    // Comma
    //
    
    GetPropForUpdate(0x002C).Set(PROP_COMMA);
    GetPropForUpdate(0x3001).Set(PROP_COMMA);
    GetPropForUpdate(0xFF0C).Set(PROP_COMMA); // Full width
    GetPropForUpdate(0xFF64).Set(PROP_COMMA); // Half width

    //
    // HYPEHN
    //

    GetPropForUpdate(0x002D).Set(PROP_DASH);   // - 
    GetPropForUpdate(0x00AD).Set(PROP_DASH);   // soft hyphen
    GetPropForUpdate(0x2010).Set(PROP_DASH);
    GetPropForUpdate(0x2011).Set(PROP_DASH);
    GetPropForUpdate(0x2012).Set(PROP_DASH);
    GetPropForUpdate(0x2013).Set(PROP_DASH);
    GetPropForUpdate(0xFF0D).Set(PROP_DASH);   // Full width 
 
    //
    // MINUS
    //

    GetPropForUpdate(0x002D).Set(PROP_MINUS);
    GetPropForUpdate(0x2212).Set(PROP_MINUS);
    GetPropForUpdate(0xFF0D).Set(PROP_MINUS);    // Full width 

    //
    // Full stop period
    //

    GetPropForUpdate(0x002E).Set(PROP_PERIOD);   // .
    GetPropForUpdate(0x3002).Set(PROP_PERIOD);  
    GetPropForUpdate(0xFF0E).Set(PROP_PERIOD);   // Full width  

    //
    // SLASH
    //

    GetPropForUpdate(0x002F).Set(PROP_SLASH);   // /
    GetPropForUpdate(0xFF0F).Set(PROP_SLASH);   // Full width
 
    //
    // NUMBERS
    //

    for (wch = 0x0030; wch <= 0x0039 ; wch++)   // 0 - 9
    {
        GetPropForUpdate(wch).Set(PROP_NUMBER);
    }

    for (wch = 0xFF10; wch <= 0xFF19 ; wch++)   // 0 - 9 Full width
    {
        GetPropForUpdate(wch).Set(PROP_NUMBER);
    }

    //
    // HEX NUMBERS
    //

    for (wch = 0x0041; wch <= 0x0046 ; wch++)   // A - F
    {
        GetPropForUpdate(wch).Set(PROP_ALPHA_XDIGIT);
    }

    for (wch = 0x0061; wch <= 0x0066 ; wch++)   // a - f
    {
        GetPropForUpdate(wch).Set(PROP_ALPHA_XDIGIT);
    }

    for (wch = 0xFF21; wch <= 0xFF26 ; wch++)   // A - F Full width
    {
        GetPropForUpdate(wch).Set(PROP_ALPHA_XDIGIT);
    }

    for (wch = 0xFF41; wch <= 0xFF46 ; wch++)   // a - f Full width
    {
        GetPropForUpdate(wch).Set(PROP_ALPHA_XDIGIT);
    }

    //
    // Colon
    //

    GetPropForUpdate(0x003A).Set(PROP_COLON);  // :
    GetPropForUpdate(0x2236).Set(PROP_COLON);
    GetPropForUpdate(0xFF1A).Set(PROP_COLON);  // Full width :

    //
    // Semicolon
    //

    GetPropForUpdate(0x003B).Set(PROP_SEMI_COLON); // ;
    GetPropForUpdate(0xFF1B).Set(PROP_SEMI_COLON); // Full width ;

    //
    // Less then
    //

    GetPropForUpdate(0x003C).Set(PROP_LT);   // <
    GetPropForUpdate(0xFF1C).Set(PROP_LT);   // Full width <

    //
    // Equal sign 
    //

    GetPropForUpdate(0x003D).Set(PROP_EQUAL);   // =
    GetPropForUpdate(0x2260).Set(PROP_EQUAL);   // not equal sign
    GetPropForUpdate(0x2261).Set(PROP_EQUAL);   // identical to
    GetPropForUpdate(0xFF1D).Set(PROP_EQUAL);   // Full width =

    //
    // Greater then
    //

    GetPropForUpdate(0x003E).Set(PROP_GT);  // >
    GetPropForUpdate(0xFF1E).Set(PROP_GT);  // Full width >

    //
    // Question mark
    //

    GetPropForUpdate(0x003F).Set(PROP_QUESTION_MARK);  // ?
    GetPropForUpdate(0x00BF).Set(PROP_QUESTION_MARK);  // inverted question mark
    GetPropForUpdate(0x037E).Set(PROP_QUESTION_MARK);  // greek question mark
    GetPropForUpdate(0x203D).Set(PROP_QUESTION_MARK);  // interrobang
    GetPropForUpdate(0x2048).Set(PROP_QUESTION_MARK);  // question exclemation mark
    GetPropForUpdate(0x2049).Set(PROP_QUESTION_MARK);  // exclamation question mark
    GetPropForUpdate(0xFF1F).Set(PROP_QUESTION_MARK);  // Full width ?

    //
    // Commercial AT
    //

    GetPropForUpdate(0x0040).Set(PROP_AT);  // @
    GetPropForUpdate(0xFF20).Set(PROP_AT);  // Full width @

    //
    // Commersial signs
    //
    GetPropForUpdate(0x00A9).Set(PROP_COMMERSIAL_SIGN); // copy right sign
    GetPropForUpdate(0x00AE).Set(PROP_COMMERSIAL_SIGN); // registered sign
    GetPropForUpdate(0x2120).Set(PROP_COMMERSIAL_SIGN); // service mark
    GetPropForUpdate(0x2121).Set(PROP_COMMERSIAL_SIGN); // telephone sign 
    GetPropForUpdate(0x2122).Set(PROP_COMMERSIAL_SIGN); // trade mark sign

    //
    // Letters
    //

    // upper case

    for (wch = 0x0041; wch <= 0x005A; wch++)    // A - Z
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    for (wch = 0x00C0; wch <= 0x00D6; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    for (wch = 0x00D8; wch <= 0x00DE; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    for (wch = 0xFF21; wch <= 0xFF3A; wch++)    // Full width A - Z
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    // Latin extended

    for (wch = 0x0100; wch <= 0x017D; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    GetPropForUpdate(0x0181).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0182).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0184).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0186).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0187).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0189).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x018A).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x018B).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x018E).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x018F).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0190).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0191).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0193).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0194).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0196).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0197).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0198).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x019C).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x019D).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x019F).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A0).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A2).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A4).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A6).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A7).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A9).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01AA).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01AC).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01AE).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01AF).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B1).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B2).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B3).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B5).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B7).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B8).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01BC).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01C4).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01C5).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01C7).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01C8).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01CA).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01CB).Set(PROP_UPPER_CASE);

    for (wch = 0x01CD; wch <= 0x01DB; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }
    
    for (wch = 0x01DE; wch <= 0x01EE; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    GetPropForUpdate(0x01F1).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01F2).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01F4).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01F6).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01F7).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01F8).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01FA).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01FC).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01FE).Set(PROP_UPPER_CASE);

    for (wch = 0x0200; wch <= 0x0232; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    // Latin extended additional

    for (wch = 0x1E00; wch <= 0x1E94; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    for (wch = 0x1EA0; wch <= 0x1EF8; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    // lower case

    for (wch = 0x0061; wch <= 0x007A; wch++)  // a - z
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x00DF; wch <= 0x00F6; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x00F8; wch <= 0x00FF; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0xFF41; wch <= 0xFF5A; wch++)  // Full width a - z
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }
    // Latin extended
     
    for (wch = 0x0101; wch <= 0x017E; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    GetPropForUpdate(0x017F).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0180).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0183).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0185).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0188).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x018C).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x018D).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0192).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0195).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0199).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x019A).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x019B).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x019E).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01A1).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01A3).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01A5).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01A8).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01AB).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01AD).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01B0).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01B4).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01B6).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01B9).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01BA).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01BB).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01BD).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01BE).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01BF).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01C6).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01C9).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01CC).Set(PROP_LOWER_CASE);

    for (wch = 0x01CE; wch <= 0x01DC; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x01DD; wch <= 0x01EF; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    GetPropForUpdate(0x01F0).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01F3).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01F5).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01F9).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01FB).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01FD).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01FF).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01).Set(PROP_LOWER_CASE);

    for (wch = 0x0201; wch <= 0x0233; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x0250; wch <= 0x02AD; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    // Latin extended additional

    for (wch = 0x1E01; wch <= 0x1E95; wch+=2)         
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x1E96; wch <= 0x1E9B; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x1EA1; wch <= 0x1EF9; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    // special letters

    GetPropForUpdate(L'w').Set(PROP_W);
    GetPropForUpdate(L'W').Set(PROP_W);

    //
    // Bracket
    //
    
    GetPropForUpdate(0x005B).Set(PROP_LEFT_BRAKCET); // [
    GetPropForUpdate(0xFF3B).Set(PROP_LEFT_BRAKCET); // Full width [
    GetPropForUpdate(0x2329).Set(PROP_LEFT_BRAKCET); // left pointing angle bracket
    GetPropForUpdate(0x3008).Set(PROP_LEFT_BRAKCET); // left angle bracket
 
    GetPropForUpdate(0x005D).Set(PROP_RIGHT_BRAKCET); // ]
    GetPropForUpdate(0xFF3D).Set(PROP_RIGHT_BRAKCET); // Full width ]
    GetPropForUpdate(0x232A).Set(PROP_RIGHT_BRAKCET); // right pointing angle bracket
    GetPropForUpdate(0x3009).Set(PROP_RIGHT_BRAKCET); // right angle bracket
    GetPropForUpdate(0x300A).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x300B).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x300C).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0xFF62).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x300D).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0xFF63).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x300E).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x300F).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x3010).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x3011).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x3014).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x3015).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x3016).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x3017).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x3018).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x3019).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x301A).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x301B).Set(PROP_RIGHT_BRAKCET);


    GetPropForUpdate(0x007B).Set(PROP_LEFT_CURLY_BRACKET);  // {
    GetPropForUpdate(0xFF5B).Set(PROP_LEFT_CURLY_BRACKET);  // Full width {
    GetPropForUpdate(0x007D).Set(PROP_RIGHT_CURLY_BRACKET); // }
    GetPropForUpdate(0xFF5D).Set(PROP_RIGHT_CURLY_BRACKET); // Full width }

    //
    // Backslash
    //

    GetPropForUpdate(0x005C).Set(PROP_BACKSLASH);   // \ 
    GetPropForUpdate(0xFF3C).Set(PROP_BACKSLASH);   // Full width \ 

    //
    // Underscore
    //

    GetPropForUpdate(0x005F).Set(PROP_UNDERSCORE);  // _
    GetPropForUpdate(0xFF3F).Set(PROP_UNDERSCORE);  // Full width _

    //
    // Or
    //

    GetPropForUpdate(0x007C).Set(PROP_OR);  // |
    GetPropForUpdate(0xFF5C).Set(PROP_OR);  // Full width |

    //
    // Tilde
    //

    GetPropForUpdate(0x007E).Set(PROP_TILDE);   // ~
    GetPropForUpdate(0xFF5E).Set(PROP_TILDE);   // Full width ~
    GetPropForUpdate(0x223C).Set(PROP_TILDE);
    GetPropForUpdate(0xFF5E).Set(PROP_TILDE);

    //
    // NBS
    //

    GetPropForUpdate(0x00A0).Set(PROP_NBS);   // NBS
    GetPropForUpdate(0x202F).Set(PROP_NBS);   // narrow no break space
    GetPropForUpdate(0xFEFF).Set(PROP_NBS);   // zero width no break space

    //
    // End of sentence
    //

    GetPropForUpdate(0x002E).Set(PROP_EOS);   // .
    GetPropForUpdate(0xFF0E).Set(PROP_EOS);   // Full width .
    GetPropForUpdate(0x3002).Set(PROP_EOS);   // Ideographic full stop
    GetPropForUpdate(0xFF61).Set(PROP_EOS);   // Half width ideographic full stop

    GetPropForUpdate(0x2024).Set(PROP_EOS);  // One dot leader
    GetPropForUpdate(0x2025).Set(PROP_EOS);  // Two dot leader
    GetPropForUpdate(0x2026).Set(PROP_EOS);  // Three dot leader

    GetPropForUpdate(0x003F).Set(PROP_EOS);  // ?
    GetPropForUpdate(0xFF1F).Set(PROP_EOS);  // Full width ?
    GetPropForUpdate(0x00BF).Set(PROP_EOS);  // inverted question mark
    GetPropForUpdate(0x037E).Set(PROP_EOS);  // greek question mark
    GetPropForUpdate(0x203D).Set(PROP_EOS);  // interrobang
    GetPropForUpdate(0x2048).Set(PROP_EOS);  // question exclemation mark
    GetPropForUpdate(0x2049).Set(PROP_EOS);  // exclamation question mark


    GetPropForUpdate(0x0021).Set(PROP_EOS);
    GetPropForUpdate(0xFF01).Set(PROP_EOS);  // Full width
    GetPropForUpdate(0x00A1).Set(PROP_EOS);
    GetPropForUpdate(0x01C3).Set(PROP_EOS);
    GetPropForUpdate(0x203C).Set(PROP_EOS);
    GetPropForUpdate(0x203D).Set(PROP_EOS);
    GetPropForUpdate(0x2762).Set(PROP_EOS);

    GetPropForUpdate(0x003B).Set(PROP_EOS); // ;
    GetPropForUpdate(0xFF1B).Set(PROP_EOS); // Full width ;

    //
    // Currency
    //

    GetPropForUpdate(0x0024).Set(PROP_CURRENCY);  // dollar
    GetPropForUpdate(0xFF04).Set(PROP_CURRENCY);  // Full width dollar
    GetPropForUpdate(0x00A2).Set(PROP_CURRENCY);  // cent
    GetPropForUpdate(0xFFE0).Set(PROP_CURRENCY);  // Full width cent
    GetPropForUpdate(0x00A3).Set(PROP_CURRENCY);  // pound
    GetPropForUpdate(0xFFE1).Set(PROP_CURRENCY);  // Full width pound
    GetPropForUpdate(0x00A4).Set(PROP_CURRENCY);  // General currency sign
    GetPropForUpdate(0x00A5).Set(PROP_CURRENCY);  // yen
    GetPropForUpdate(0xFFE5).Set(PROP_CURRENCY);  // Full width yen
    GetPropForUpdate(0x09F2).Set(PROP_CURRENCY);  // Bengali Rupee Mark
    GetPropForUpdate(0x09F3).Set(PROP_CURRENCY);  // Bengali Rupee Sign
    GetPropForUpdate(0x0E3F).Set(PROP_CURRENCY);  // Baht (Thailand)
    GetPropForUpdate(0x20A0).Set(PROP_CURRENCY);  // Euro
    GetPropForUpdate(0x20A1).Set(PROP_CURRENCY);  // Colon (Costa Rica, El Salv.)
    GetPropForUpdate(0x20A2).Set(PROP_CURRENCY);  // Cruzeiro (Brazil)
    GetPropForUpdate(0x20A3).Set(PROP_CURRENCY);  // French Franc
    GetPropForUpdate(0x20A4).Set(PROP_CURRENCY);  // Lira (Italy, Turkey)
    GetPropForUpdate(0x20A5).Set(PROP_CURRENCY);  // Mill Sign (USA, 1/10 cent)
    GetPropForUpdate(0x20A6).Set(PROP_CURRENCY);  // Naira Sign (Nigeria)
    GetPropForUpdate(0x20A7).Set(PROP_CURRENCY);  // Peseta (Spain)
    GetPropForUpdate(0x20A8).Set(PROP_CURRENCY);  // Rupee
    GetPropForUpdate(0x20A9).Set(PROP_CURRENCY);  // Won (Korea)
    GetPropForUpdate(0xFFE6).Set(PROP_CURRENCY);  // Full width Won (Korea)
    GetPropForUpdate(0x20AA).Set(PROP_CURRENCY);  // New Sheqel (Israel)
    GetPropForUpdate(0x20AB).Set(PROP_CURRENCY);  // Dong (Vietnam)
    GetPropForUpdate(0x20AC).Set(PROP_CURRENCY);  // Euro sign  
    GetPropForUpdate(0x20AD).Set(PROP_CURRENCY);  // Kip sign  
    GetPropForUpdate(0x20AE).Set(PROP_CURRENCY);  // Tugrik sign  
    GetPropForUpdate(0x20AF).Set(PROP_CURRENCY);  // Drachma sign  

    //
    // Breaker
    //

    GetPropForUpdate(0x005E).Set(PROP_BREAKER);  // ^
    GetPropForUpdate(0xFF3E).Set(PROP_BREAKER);  // Full width ^
    GetPropForUpdate(0x00A6).Set(PROP_BREAKER);  // Broken vertical bar
    GetPropForUpdate(0xFFE4).Set(PROP_BREAKER);  // Full width Broken vertical bar
    GetPropForUpdate(0x00A7).Set(PROP_BREAKER);  // section sign
    GetPropForUpdate(0x00AB).Set(PROP_BREAKER);  // Not sign
    GetPropForUpdate(0x00B1).Set(PROP_BREAKER);  // Plus minus sign
    GetPropForUpdate(0x00B6).Set(PROP_BREAKER);  // Pargraph sign
    GetPropForUpdate(0x00B7).Set(PROP_BREAKER);  // Middle dot
    GetPropForUpdate(0x00D7).Set(PROP_BREAKER);  // Multiplication sign
    GetPropForUpdate(0x00F7).Set(PROP_BREAKER);  // Devision sign
    GetPropForUpdate(0x01C0).Set(PROP_BREAKER); 
    GetPropForUpdate(0x01C1).Set(PROP_BREAKER);  
    GetPropForUpdate(0x01C2).Set(PROP_BREAKER);  
    GetPropForUpdate(0x200C).Set(PROP_BREAKER);  // Formating character  
    GetPropForUpdate(0x200D).Set(PROP_BREAKER);  // Formating character
    GetPropForUpdate(0x200E).Set(PROP_BREAKER);  // Formating character
    GetPropForUpdate(0x200F).Set(PROP_BREAKER);  // Formating character
    GetPropForUpdate(0x2014).Set(PROP_BREAKER);  // Em dash  
    GetPropForUpdate(0x2015).Set(PROP_BREAKER);  // Horizontal bar  
    GetPropForUpdate(0x2016).Set(PROP_BREAKER);  // Double vertical line
    
    for (wch = 0x2020; wch <= 0x2027; wch++)          
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x2028; wch <= 0x202E; wch++)     // Formating characters          
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x2030; wch <= 0x2038; wch++)     // General punctuation     
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    GetPropForUpdate(0x203B).Set(PROP_BREAKER);

    for (wch = 0x203F; wch <= 0x2046; wch++)     // General punctuation     
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x204A; wch <= 0x206F; wch++)     // General punctuation     
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x2190; wch <= 0x21F3; wch++)     // Arrows     
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x2200; wch <= 0x22EF; wch++)     // Mathematical operators
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x2300; wch <= 0x239A; wch++)     // Miscellaneous technical
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    GetPropForUpdate(0x3003).Set(PROP_BREAKER);  // Ditto mark
    GetPropForUpdate(0x3012).Set(PROP_BREAKER);  // Postal mark
    GetPropForUpdate(0x3013).Set(PROP_BREAKER);  // Geta mark
    GetPropForUpdate(0x301C).Set(PROP_BREAKER);  // Wave dash
    GetPropForUpdate(0x3020).Set(PROP_BREAKER);  // Postal mark face

    GetPropForUpdate(0xFFE2).Set(PROP_BREAKER);  // Full width not sign

    //
    // Transperent (all charaters that can treated as non existing for breaking)
    //
    
    GetPropForUpdate(0x0060).Set(PROP_TRANSPERENT);   // grave accent
    GetPropForUpdate(0xFF40).Set(PROP_TRANSPERENT);   // Full width grave accent
    GetPropForUpdate(0x00A0).Set(PROP_TRANSPERENT);   // NBS
    GetPropForUpdate(0x00AF).Set(PROP_TRANSPERENT);   // Macron
    GetPropForUpdate(0xFFE3).Set(PROP_TRANSPERENT);   // Full width Macron
    GetPropForUpdate(0x00B4).Set(PROP_TRANSPERENT);   // Acute Accent
    GetPropForUpdate(0x00B8).Set(PROP_TRANSPERENT);   // Cedilla Accent

    GetPropForUpdate(0x202F).Set(PROP_TRANSPERENT);   // narrow no break space
    GetPropForUpdate(0xFEFF).Set(PROP_TRANSPERENT);   // zero width no break space

    GetPropForUpdate(0x00A8).Set(PROP_TRANSPERENT);   // Diaeresis

    for (wch = 0x02B0; wch <= 0x02EE; wch++)          // Modifiers
    {
        GetPropForUpdate(wch).Set(PROP_TRANSPERENT);
    }

    for (wch = 0x0300; wch <= 0x0362; wch++)          // Combining Diacritical Marks
    {
        GetPropForUpdate(wch).Set(PROP_TRANSPERENT);
    }

    GetPropForUpdate(0x2017).Set(PROP_TRANSPERENT);   // Double low line  
    GetPropForUpdate(0x203E).Set(PROP_TRANSPERENT);   // Over line  

    for (wch = 0x20D0; wch <= 0x20E3; wch++)          // Combining Diacritical Marks for symbols
    {
        GetPropForUpdate(wch).Set(PROP_TRANSPERENT);
    }

    for (wch = 0x302A; wch <= 0x302F; wch++)          // Diacritics
    {
        GetPropForUpdate(wch).Set(PROP_TRANSPERENT);
    }
    //
    //  Complement m_apCodePage:
    //
    //  Replace all NULL entries
    //  m_apCodePage[i] == NULL by
    //  the same code page: m_aDefaultCodePage ==
    //  A row of default values  (== zero)
    //

    for (USHORT usCodePage = 0; usCodePage < (1<<8); usCodePage++)
    {
        if ( !m_apCodePage[usCodePage] )
        {
            m_apCodePage[usCodePage] = m_aDefaultCodePage;
        }

    } // for

}

inline CPropArray::~CPropArray()
{
    for (int i=0; i< (1<<8); i++)
    {
        if (m_apCodePage[i] != m_aDefaultCodePage)
        {
            delete m_apCodePage[i];
        }
    }
}

inline CPropFlag& CPropArray::GetPropForUpdate(WCHAR wch)
{

    unsigned short usCodePage = wch >> 8;
    if (!m_apCodePage[usCodePage])
    {
        m_apCodePage[usCodePage] = new CPropFlag[1<<8];
    }

    return (m_apCodePage[usCodePage])[wch & 0xFF];
}


extern CAutoClassPointer<CPropArray> g_pPropArray;

#ifdef DECLARE_ULONGLONG_ARRAY
extern CPropFlag * g_PropFlagArray;
#endif // DECLARE_ULONGLONG_ARRAY


#endif // _PROP_ARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\spanishdict.cpp ===
#include "base.h"
#include "SpanishDict.h"

CSpanishDict::CSpanishDict(WCHAR* pwcsInitFilePath) :
    m_vaDictItem4(DICT_4_INIT_SIZE),
    m_vaDictItem8(DICT_8_INIT_SIZE),
    m_vaDictItemStr(DICT_STR_INIT_SIZE),
    m_ulDictItem4Count(0),
    m_ulDictItem8Count(0),
    m_ulDictItemStrCount(0)
{
    m_apSpanishSuffix = new CSpanishSuffixDict();
    
    CStandardCFile Words(pwcsInitFilePath, L"r");

    WCHAR pwcsBuf[MAX_LINE_LEN];
    char  pszBuf[MAX_LINE_LEN];

    while(fgets(pszBuf, MAX_LINE_LEN, (FILE*) Words))
    {
        if (pszBuf[0] == '\n')
        {
            continue;
        }
        
        int imbRet = MultiByteToWideChar(
                                     1252, // English / Spanish code page
                                     MB_PRECOMPOSED | MB_ERR_INVALID_CHARS, 
                                     pszBuf, -1, 
                                     pwcsBuf, 
                                     MAX_LINE_LEN);

        Assert(imbRet > 0);

        SpanishDictItem pItem(pwcsBuf);

        if (pItem.m_ulLen <= COMPRESS_4_SIZE)
        {
            m_vaDictItem4[m_ulDictItem4Count].ulStr = pItem.m_ulStrCompress;
            m_vaDictItem4[m_ulDictItem4Count].ulData = pItem.m_dwCompress;
            m_ulDictItem4Count++;
        }
        else if (pItem.m_ulLen <= COMPRESS_8_SIZE)
        {
            m_vaDictItem8[m_ulDictItem8Count].ullStr = pItem.m_ullStrCompress;
            m_vaDictItem8[m_ulDictItem8Count].ulData = pItem.m_dwCompress;
            m_ulDictItem8Count++;
        }
        else
        {
            m_vaDictItemStr[m_ulDictItemStrCount].pszStr = new unsigned char[pItem.m_ulLen + 1];
            
            bool bRet;
            bRet = g_apSpanishUtil->ConvertToChar(
                                            pItem.m_pwcs,
                                            pItem.m_ulLen,
                                            m_vaDictItemStr[m_ulDictItemStrCount].pszStr,
                                            pItem.m_ulLen + 1);

            Assert(bRet);
            m_vaDictItemStr[m_ulDictItemStrCount].ulData = pItem.m_dwCompress;
            m_ulDictItemStrCount++;
            
        }

    }
}


void CSpanishDict::BreakWord(
    ULONG ulLen, 
    WCHAR* pwcsWord, 
    bool* pfExistAlt, 
    ULONG* pulAltLen, 
    WCHAR* pwcsAlt)
{
    *pfExistAlt = false;
    if (ulLen <= 2)
    {
        return;
    }

    if (*pulAltLen < MAX_WORD_LEN)
    {
        return;
    }

    //
    // very fast heuristic to find non breakable words
    //

    if (pwcsWord[ulLen - 1] != L'e' &&
        pwcsWord[ulLen - 1] != L's' &&
        pwcsWord[ulLen - 2] != L'l')
    {
        return;
    }

    
    DictStatus status;
    short sResCount;

    WCHAR pwcsBuf[MAX_WORD_LEN];
    WCHAR* pwcs = pwcsWord;
    
    ULONG ul = ulLen;
    pwcsBuf[ul] = L'\0';
    while (ul > 0)
    {
        pwcsBuf[ul - 1] = *pwcs;
        ul--;
        pwcs++;
    }
    
    CSuffixTerm* prTerm[10];
    status = m_apSpanishSuffix->m_SuffixTrie.trie_Find(
                            pwcsBuf,
                            TRIE_ALL_MATCHES | TRIE_IGNORECASE,
                            10,
                            prTerm,
                            &sResCount);

    WCHAR pwcsTemp[MAX_WORD_LEN];
    ULONG ulTempLen;

    while (sResCount > 0)
    {
        CSuffixTerm* pTerm = prTerm[sResCount - 1];
        Assert(ulLen < MAX_WORD_LEN);
        wcsncpy(pwcsTemp, pwcsWord, ulLen);
        pwcsTemp[ulLen] = L'\0';

        ulTempLen = ulLen;
        bool bRet;
        ULONG ulCompressedData;

        if (!(pTerm->ulType & (TYPE11 | TYPE12 | TYPE13 |TYPE14)))
        {
            Assert(ulLen >= pTerm->ulCut);
            if (ulLen == pTerm->ulCut)
            {
                sResCount--;
                continue;
            }
            pwcsTemp[ulLen - pTerm->ulCut] = L'\0';
            ulTempLen = ulLen - pTerm->ulCut;


            bRet = Find(pwcsTemp, ulTempLen, ulCompressedData);

            if (pTerm->ulType == TYPE1 && (!bRet))
            {
                pwcsTemp[ulTempLen] = L's';
                pwcsTemp[ulTempLen + 1] = L'\0';
                bRet = Find(pwcsTemp, ulTempLen + 1, ulCompressedData);
            }

            if ( (!bRet) ||
                 (!(g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType)))
            {
                sResCount--;
                continue;
            }

            *pfExistAlt = true;
            wcscpy(pwcsAlt, pwcsTemp);
            *pulAltLen = ulTempLen;
            g_apSpanishUtil->ReplaceAccent(pwcsAlt, *pulAltLen, ulCompressedData);

            switch (pTerm->ulType)            
            {
            case TYPE1:
                return;
            case TYPE2:
                *pulAltLen += 3;
                wcscat(pwcsAlt, L"ndo");
                return;
            case TYPE3:
                *pulAltLen += 1;
                wcscat(pwcsAlt, L"n");
                return;
            case TYPE4:
                *pulAltLen += 3;
                wcscat(pwcsAlt, L"mos");
                return;
            case TYPE5:
                *pulAltLen += 1;
                wcscat(pwcsAlt, L"d");
                return;
            case TYPE6:
                *pulAltLen += 1;
                wcscat(pwcsAlt, L"r");
                return;
            case TYPE7:
            case TYPE8:
            case TYPE9:
            case TYPE10:
            case TYPE15:
            case TYPE16:
                return;
            default:
                Assert(false);
            }
        }
        else
        {
            *pfExistAlt = true;

            switch (pTerm->ulType)            
            {
            case TYPE11:
                {
                    Assert(ulTempLen >= pTerm->ulLen);
                    if (ulTempLen == pTerm->ulLen)                   
                    {
                        break;
                    }
                    pwcsTemp[ulTempLen - pTerm->ulLen] = L'\0';
                    ulTempLen -= pTerm->ulLen;

                    bRet = Find(pwcsTemp, ulTempLen, ulCompressedData);

                    if (bRet && 
                        (g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType))
                    {
                        wcscpy(pwcsAlt, pwcsTemp);
                        *pulAltLen = ulTempLen;
                        g_apSpanishUtil->ReplaceAccent(pwcsAlt, *pulAltLen, ulCompressedData);
                        *pfExistAlt = true;
                        return;
                    }
                }
                break;
            case TYPE12:
            case TYPE14:
                {
                    pwcsTemp[ulTempLen-3] = L's';   // removing the no form the nos
                    pwcsTemp[ulTempLen-2] = L'\0';  
                    bRet = Find(pwcsTemp, ulTempLen - 2, ulCompressedData);

                    if (bRet && 
                        (g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType))
                    {
                        wcscpy(pwcsAlt, pwcsTemp);
                        *pulAltLen = ulTempLen - 2;
                        g_apSpanishUtil->ReplaceAccent(pwcsAlt, *pulAltLen, ulCompressedData);
                        *pfExistAlt = true;
                        return;
                    }
                    
                    Assert(pTerm->ulLen >= 3);
                    Assert(ulTempLen >= pTerm->ulLen);
                    if (ulTempLen == pTerm->ulLen)
                    {
                        break;
                    }

                    ulTempLen -= pTerm->ulLen;
                    pwcsTemp[ulTempLen] = L'\0';

                    bRet = Find(pwcsTemp, ulTempLen, ulCompressedData);
                    if (bRet && 
                        (g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType))
                    {
                        wcscpy(pwcsAlt, pwcsTemp);
                        *pulAltLen = ulTempLen - 2;
                        *pfExistAlt = true;
                        g_apSpanishUtil->ReplaceAccent(pwcsAlt, *pulAltLen, ulCompressedData);
                        return;
                    }

                }
                break;

            case TYPE13:
                {
                    pwcsTemp[ulTempLen-1] = L'\0';  
                    bRet = Find(pwcsTemp, ulTempLen - 1, ulCompressedData);
                   

                    if (bRet && 
                        (g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType))
                    {
                        wcscpy(pwcsAlt, pwcsTemp);
                        *pulAltLen = ulTempLen - 1;
                        *pfExistAlt = true;
                        g_apSpanishUtil->ReplaceAccent(pwcsAlt, *pulAltLen, ulCompressedData);
                        return;
                    }
                    
                    Assert(pTerm->ulLen >= 3);
                    Assert(ulTempLen >= pTerm->ulLen);
                    Assert(ulTempLen >= pTerm->ulLen);
                    if (ulTempLen == pTerm->ulLen)
                    {
                        break;
                    }

                    ulTempLen -= pTerm->ulLen;
                    pwcsTemp[ulTempLen] = L'\0';

                    bRet = Find(pwcsTemp, ulTempLen, ulCompressedData);
                    
                    if (bRet && 
                        (g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType))
                    {
                        wcscpy(pwcsAlt, pwcsTemp);
                        *pulAltLen = ulTempLen - 2;
                        *pfExistAlt = true;
                        g_apSpanishUtil->ReplaceAccent(pwcsAlt, *pulAltLen, ulCompressedData);
                        return;
                    }

                }
                break;
            }
        }


        sResCount--;
    }

    pwcsAlt[0] = L'\0';
    *pfExistAlt = false;
}


bool CSpanishDict::Find(WCHAR* pwcs, ULONG ulLen, ULONG& ulData)
{
    bool bRet;

    if (ulLen <= COMPRESS_4_SIZE)
    {
        CompressDictItem4 Key;
        bRet = g_apSpanishUtil->CompressStr4(pwcs, ulLen, Key.ulStr);
        if (!bRet)
        {
            return false;
        }

        CompressDictItem4* pItem;    
        pItem = BinaryFind<CompressDictItem4>(
                                    (CompressDictItem4*)m_vaDictItem4,
                                    m_ulDictItem4Count,
                                    Key);

        if (!pItem)
        {
            return false;
        }

        ulData = pItem->ulData;
    }
    else if (ulLen <= COMPRESS_8_SIZE)
    {
        CompressDictItem8 Key;
        bRet = g_apSpanishUtil->CompressStr8(pwcs, ulLen, Key.ullStr);
        if (!bRet)
        {
            return false;
        }

        CompressDictItem8* pItem;    
        pItem = BinaryFind<CompressDictItem8>(
                                    (CompressDictItem8*)m_vaDictItem8,
                                    m_ulDictItem8Count,
                                    Key);

        if (!pItem)
        {
            return false;
        }

        ulData = pItem->ulData;
    }
    else
    {
        unsigned char psz[32];
        bool bRet;
        bRet = g_apSpanishUtil->ConvertToChar(pwcs, ulLen, psz, 32);
        if (!bRet)
        {
            return false;
        }

        PsudoCompressDictItemStr Key;
        Key.pszStr = psz;
        CompressDictItemStr* pItem;

        pItem = BinaryFind<CompressDictItemStr>(
                                    (CompressDictItemStr*)m_vaDictItemStr,
                                    m_ulDictItemStrCount,
                                    Key);

        if (!pItem)
        {
            return false;
        }

        ulData = pItem->ulData;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\spanishdict.h ===
#ifndef _SPANISH_DICT_H_
#define _SPANISH_DICT_H_

#include "trie.h"
#include "SpanishUtils.h"
#include "VarArray.h"

#define DICT_4_INIT_SIZE 5400  // base on the current dictionary size.
#define DICT_8_INIT_SIZE 12100
#define DICT_STR_INIT_SIZE 400

#define MAX_LINE_LEN 128
#define MAX_WORD_LEN 32

struct CompressDictItem4
{
    int Compare(CompressDictItem4 & item)
    {
        return ULONGCmp(ulStr, item.ulStr);
    }

    ULONG ulStr;
    ULONG ulData;
};

struct CompressDictItem8
{
    int Compare(CompressDictItem8 & item)
    {
        if (ullStr > item.ullStr)
        {
            return 1;
        }
        else if (ullStr < item.ullStr)
        {
            return -1;
        }
        return 0;
    }

    ULONGLONG ullStr;
    ULONG ulData;
};

struct CompressDictItemStr
{
    CompressDictItemStr() :
        pszStr(NULL),
        ulData(0)
    {
    }

    ~CompressDictItemStr()
    {
        delete[] pszStr;
    }

    int Compare(CompressDictItemStr& item)
    {
        return g_apSpanishUtil->aiStrcmp(pszStr, item.pszStr);
    }

    unsigned char* pszStr;
    ULONG ulData;
};

struct PsudoCompressDictItemStr : public CompressDictItemStr
{
    ~PsudoCompressDictItemStr()
    {
        pszStr = NULL; // we don't own the memory
    }    
};

template<class T>
T* BinaryFind(T* Array, ULONG ulArraySize, T& ItemToFind)
{
    Assert(ulArraySize);
    LONG lStart = 0;
    LONG lEnd = ulArraySize - 1;
    T* pCurrItem;

    while(lEnd >= lStart)
    {
        
        ULONG lCurrIndex = (lEnd + lStart) / 2;
        pCurrItem = &(Array[lCurrIndex]);
        int iRet = pCurrItem->Compare(ItemToFind);
        if (0 == iRet)
        {
            return pCurrItem;
        }
        else if (iRet > 0)
        {
            lEnd = lCurrIndex - 1;
        }
        else
        {
            lStart = lCurrIndex + 1; 
        }
    }

    return NULL;
}


class CSpanishDict
{
public:
    CSpanishDict(WCHAR* pwcsInitFilePath);

    void BreakWord(
            ULONG ulLen, 
            WCHAR* pwcsWord, 
            bool* pfExistAlt, 
            ULONG* pulAltLen, 
            WCHAR* pwcsAlt);

private:
    //
    // methods
    //

    bool Find(WCHAR* pwcs, ULONG ulLen, ULONG& ulData);
private:

    //
    // members
    //

    ULONG m_ulDictItem4Count;
    CVarArray<CompressDictItem4> m_vaDictItem4;

    ULONG m_ulDictItem8Count;
    CVarArray<CompressDictItem8> m_vaDictItem8;

    ULONG m_ulDictItemStrCount;
    CVarArray<CompressDictItemStr> m_vaDictItemStr;

    CAutoClassPointer<CSpanishSuffixDict> m_apSpanishSuffix;
};

#endif // _SPANISH_DICT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\spanishtokenizer.h ===
#ifndef _SPANISH_TOKENIZER_H_
#define _SPANISH_TOKENIZER_H_

#include "tokenizer.h"
#include "Synchro.h"
#include "SpanishDict.h"


extern CAutoClassPointer<CSpanishDict> g_apSpanishDict;

class CSpanishTokenizer : public CTokenizer
{
public:
    CSpanishTokenizer(
        TEXT_SOURCE* pTxtSource,
        IWordSink   * pWordSink,
        IPhraseSink * pPhraseSink,
        LCID lcid,
        BOOL bQueryTime,
        ULONG ulMaxTokenSize); 

    // destructor frees the passed buffer, if it exists
    virtual ~CSpanishTokenizer(void)
    {
    }

protected: 

    virtual void OutputSimpleToken(
                CTokenState& State,
                const CCliticsTerm* pTerm);

};

#endif // _SPANISH_TOKENIZER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\spanishutils.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  SpanishUtils.h
//  Purpose  :  Genral utilities for spanish
//
//  Project  :  WordBreakers
//  Component:  Spanish word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      Jun 20 2000 yairh creation
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _SPANISH_UTILS_H_
#define _SPANISH_UTILS_H_

#include "trie.h"


#define TYPE1  1<<0
#define TYPE2  1<<1
#define TYPE3  1<<2
#define TYPE4  1<<3
#define TYPE5  1<<4
#define TYPE6  1<<5
#define TYPE7  1<<6
#define TYPE8  1<<7
#define TYPE9  1<<8
#define TYPE10  1<<9
#define TYPE11  1<<10
#define TYPE12  1<<11
#define TYPE13  1<<12
#define TYPE14  1<<13
#define TYPE15  1<<14
#define TYPE16  1<<15

#define COMPRESS_4_SIZE 6
#define COMPRESS_8_SIZE 12


class CSpanishUtil
{
public:
    CSpanishUtil::CSpanishUtil();

    int aiWcscmp(const WCHAR* p, const WCHAR* t);
    int aiStrcmp(const unsigned char* p, const unsigned char* t);
    int aiWcsncmp(const WCHAR* p, const WCHAR* t, const int iLen);

    void ReplaceAccent(WCHAR* pwcs, ULONG ulLen, DWORD dwCompressedBuf)
    { 
        WORD w = (WORD) dwCompressedBuf; 
        BYTE bLoc;                         
        BYTE bc = 0;                      
        bc = (w & 0xF00) >> 8;  
        if (bc)
        {
            bLoc = (w & 0xF000) >> 12;
            Assert(bLoc < ulLen);
            pwcs[bLoc] = (WCHAR)m_rReverseAccentConvert[bc];                   
        }                               
        bc = w & 0xF;                    
        if (bc)
        {
            bLoc = (w & 0xF0) >> 4;
            Assert(bLoc < ulLen);
            pwcs[bLoc] = (WCHAR) m_rReverseAccentConvert[bc];                   
        }                               
    } 

    ULONG GetTypeFromCompressedData(DWORD dw)
    {
        return dw >> 16;
    }
    
    DWORD CompressData(
                ULONG ulType, 
                BYTE bLoc1,
                BYTE bChar1,
                BYTE bLoc2,
                BYTE bChar2)
    {
        return (ulType << 16) | (bLoc1 << 12) | (bChar1 << 8) | (bLoc2 << 4) | (bChar2);
    }

    ULONG AddTypeToCompressedData(ULONG ul, ULONG ulType)
    {
        return (ul | (ulType << 16));
    }


    bool CompressStr4(WCHAR* pwcsStr, ULONG ulLen, ULONG& ulCompress)
    {
        //
        // each char is 5 bits
        //

        int iShift = 27;
        ulCompress = 0;
        
        ULONG ul = 0;
        while(ul < ulLen)
        {
            Assert(iShift>=0);
            if ((*pwcsStr > 0xFF) || (m_rCharCompress[*pwcsStr] == 0) )
            {
                return false;
            }
            ulCompress |= m_rCharCompress[*pwcsStr] << iShift;

            iShift -= 5;
            pwcsStr++;
            ul++;
        }

        return true;
    }

    bool CompressStr8(WCHAR* pwcsStr, ULONG ulLen, ULONGLONG& ullCompress)
    {
        //
        // each char is 5 bits
        //

        int iShift = 59;
        ullCompress = 0;

        ULONG ul = 0;
        while(ul < ulLen)
        {
            Assert(iShift>=0);
            if ((*pwcsStr > 0xFF) || m_rCharCompress[*pwcsStr] == 0 )
            {
                return false;
            }
            ullCompress |= ((ULONGLONG)m_rCharCompress[*pwcsStr]) << iShift;

            iShift -= 5;
            pwcsStr++;
            ul++;
        }

        return true;
    }

    bool ConvertToChar(const WCHAR* pwcs, const ULONG ulLen, unsigned char* pszOut, ULONG ulOutLen)
    {
        if (ulOutLen < ulLen + 1)
        {
            return false;
        }

        ULONG ul = 0;
        
        while (ul < ulLen)
        {
            if (*pwcs > 0xFF)
            {
                return false;
            }
            *pszOut = *((char*)pwcs);
            pszOut++;
            pwcs++;
            ul++;
        }

        *pszOut = '\0';
        return true;
    }
public:

    //
    // members.
    //

    WCHAR m_rCharConvert[256];
    BYTE  m_rCharCompress[256];
    
    char  m_rAccentConvert[256];
    WCHAR m_rReverseAccentConvert[16];

};

extern CAutoClassPointer<CSpanishUtil> g_apSpanishUtil;

class CToAccUpper
{
public:
    static
    WCHAR
    MapToUpper(
        IN WCHAR wc
        )
    {
        if ( (wc & 0xff00) == 0 )
        {
            return ( g_apSpanishUtil->m_rCharConvert[wc] );
        }
        else
        {
            return ( towupper(wc) );
        } // if


    }
};

class SpanishDictItem
{
public:
    SpanishDictItem(ULONG  ulW, WCHAR* pwcsW, ULONG ulAL, WCHAR* pwcsA, ULONG ulC, ULONG ulT)
    {
        m_fOwnMemory = true;
        Assert(ulW == ulAL);

        m_ulLen = ulW;
        m_pwcs = new WCHAR[ulW + 1];
        wcsncpy(m_pwcs, pwcsW, ulW);
        m_pwcs[ulW] = L'\0';

        m_pwcsAlt = new WCHAR[ulAL + 1];
        wcsncpy(m_pwcsAlt, pwcsA, ulAL);
        m_pwcsAlt[ulAL] = L'\0';
        m_ulAltLen = ulAL;

        m_ulCounter = ulC;
        m_ulType = ulT;

        WCHAR* p = pwcsW;
        BYTE i = 0;
        BYTE k = 0;
        BYTE r[4] = {0};
        while (*p)
        {
            if (*p != pwcsA[i])
            {
                Assert(k < 4);
                Assert(i < 16);
                Assert(
                    g_apSpanishUtil->m_rCharConvert[*p] == 
                    g_apSpanishUtil->m_rCharConvert[pwcsA[i]]);
                
                r[k] = i;
                r[k+1] = g_apSpanishUtil->m_rAccentConvert[pwcsA[i]];
                k+=2;
            }

            i++;
            p++;
        }

        m_dwCompress = g_apSpanishUtil->CompressData(m_ulType, r[0], r[1], r[2], r[3]); 
        if (m_ulLen <= COMPRESS_4_SIZE)
        {
            bool b = g_apSpanishUtil->CompressStr4(m_pwcs, m_ulLen, m_ulStrCompress);
            Assert(b);
        }
        else if (m_ulLen <= COMPRESS_8_SIZE)
        {
            bool b = g_apSpanishUtil->CompressStr8(m_pwcs, m_ulLen, m_ullStrCompress);
            Assert(b);
        }

    }

    SpanishDictItem(WCHAR* pwcsBuf)
    {
        m_fOwnMemory = false;

        ULONG ul = wcslen(pwcsBuf);
        pwcsBuf[ul - 1] = L'\0';
        WCHAR* p = pwcsBuf;

        WCHAR* ppwcsParams[7];
        ppwcsParams[0] = p;
        int i = 1;
        while(*p)
        {
            if (*p == L';')
            {
                *p = L'\0';
                ppwcsParams[i] = p+1;
                i++;
            }
            p++;
        }

        m_pwcs = ppwcsParams[0];
        m_ulLen = _wtol(ppwcsParams[1]);
        m_pwcsAlt = ppwcsParams[2];
        m_ulAltLen = _wtol(ppwcsParams[3]);
        m_ulType = _wtol(ppwcsParams[4]);
        m_dwCompress = _wtol(ppwcsParams[5]);
        if (m_ulLen <= COMPRESS_4_SIZE)
        {
            m_ulStrCompress = _wtol(ppwcsParams[6]);
        }
        else if (m_ulLen <= COMPRESS_8_SIZE)
        {
            m_ullStrCompress = _wtoi64(ppwcsParams[6]);
        }


    }

    ~SpanishDictItem()
    {
        if (m_fOwnMemory)
        {
            delete[] m_pwcs;
            delete[] m_pwcsAlt;
        }
    }

    void AddType(ULONG ulType)
    {
        m_ulType |= ulType;
        m_dwCompress = g_apSpanishUtil->AddTypeToCompressedData(m_dwCompress, ulType);
    }

    int Serialize(WCHAR* pwcsBuf)
    {
        if (m_ulLen <= COMPRESS_4_SIZE)
        {
            return swprintf(
                        pwcsBuf, 
                        L"%s;%d;%s;%d;%d;%u;%u\n", 
                        m_pwcs, 
                        m_ulLen, 
                        m_pwcsAlt, 
                        m_ulAltLen, 
                        m_ulType, 
                        m_dwCompress,
                        m_ulStrCompress);
        }
        else if (m_ulLen <= COMPRESS_8_SIZE)
        {
            return swprintf(
                        pwcsBuf, 
                        L"%s;%d;%s;%d;%d;%u;%I64u\n", 
                        m_pwcs, 
                        m_ulLen, 
                        m_pwcsAlt, 
                        m_ulAltLen, 
                        m_ulType, 
                        m_dwCompress,
                        m_ullStrCompress);

        }
        return swprintf(
                    pwcsBuf, 
                    L"%s;%d;%s;%d;%d;%u;0\n", 
                    m_pwcs, 
                    m_ulLen, 
                    m_pwcsAlt, 
                    m_ulAltLen, 
                    m_ulType, 
                    m_dwCompress);

    }

    ULONG  m_ulLen;
    WCHAR* m_pwcs;
    ULONG  m_ulAltLen;
    WCHAR* m_pwcsAlt;
    ULONG  m_ulCounter;
    ULONG  m_ulType;
    DWORD  m_dwCompress;
    ULONG  m_ulStrCompress;
    ULONGLONG m_ullStrCompress;

    bool   m_fOwnMemory;

};


class CStandardCFile
{
  public:
    CStandardCFile(WCHAR *pwcsFileName, WCHAR *pwcsMode, bool fThrowExcptionOn = true)
    {
        m_pFile = _wfopen(pwcsFileName, pwcsMode);
        if (! m_pFile && fThrowExcptionOn)
        {
            throw CGenericException(L"Could not open file");
        }
    }

    ~CStandardCFile()
    {
        if (m_pFile)
        {
            fclose(m_pFile);
        }
    }

    operator FILE*()
    {
        return m_pFile;
    }

  protected:
    FILE    *m_pFile;
};

struct CSuffixTerm
{
    WCHAR* pwcs;
    ULONG ulLen;
    ULONG ulCut;
    ULONG ulType;
};

extern const CSuffixTerm g_rSpanishSuffix[] ;

class CSpanishSuffixDict
{
public:
    CSpanishSuffixDict();

    CTrie<CSuffixTerm, CToAccUpper> m_SuffixTrie;
};

#endif // _SPANISH_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6977EBD2_A246_11D3_BB8C_0090272FA362__INCLUDED_)
#define AFX_STDAFX_H__6977EBD2_A246_11D3_BB8C_0090272FA362__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif 

#define _ATL_APARTMENT_THREADED

#ifdef _PQS_LEAK_DETECTION
#undef new 
#endif

#include <atlbase.h>

#ifdef _PQS_LEAK_DETECTION
#define new DEBUG_NEW
#endif

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6977EBD2_A246_11D3_BB8C_0090272FA362__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\spanishutils.cpp ===
#include "base.h"
#include "SpanishUtils.h"

CAutoClassPointer<CSpanishUtil> g_apSpanishUtil = NULL;

const CSuffixTerm g_rSpanishSuffix[] =
{
    {L"et"  ,2, 2, TYPE1},    // te
    {L"es"  ,2, 2, TYPE1},	  // se
    {L"em"  ,2, 2, TYPE1},	  // me
    {L"son" ,3, 3, TYPE1},	  // nos
    {L"sol" ,3, 3, TYPE1},	  // los
    {L"sal" ,3, 3, TYPE1},	  // las
    {L"sel" ,3, 3, TYPE1},	  // les
    {L"ol"  ,2, 2, TYPE1},	  // lo
    {L"el"  ,2, 2, TYPE1},	  // le
    {L"al"  ,2, 2, TYPE1},    // la
    {L"etes",4, 4, TYPE1},    // sete

#ifdef DICT_GEN
    {L"odn\x0e1"   ,4, 3, TYPE2},  // ndo
#endif
    {L"etodn\x0e1" ,6, 5, TYPE2},  // ndote
    {L"esodn\x0e1" ,6, 5, TYPE2},  // ndose
    {L"emodn\x0e1" ,6, 5, TYPE2},  // ndome
    {L"olodn\x0e1" ,6, 5, TYPE2},  // ndolo
    {L"elodn\x0e1" ,6, 5, TYPE2},  // ndole
    {L"alodn\x0e1" ,6, 5, TYPE2},  // ndola
    {L"sonodn\x0e1",7, 6, TYPE2},  // ndonos
    {L"solodn\x0e1",7, 6, TYPE2},  // ndolos
    {L"salodn\x0e1",7, 6, TYPE2},  // ndolas
    {L"selodn\x0e1",7, 6, TYPE2},  // ndoles

    {L"etne"  ,4, 3, TYPE3},   //ente
    {L"esne"  ,4, 3, TYPE3},   //en	se
    {L"emne"  ,4, 3, TYPE3},   //enme	
    {L"sonne" ,5, 4, TYPE3},   //ennos	
    {L"solne" ,5, 4, TYPE3},   //enlos	
    {L"salne" ,5, 4, TYPE3},   //enlas	
    {L"selne" ,5, 4, TYPE3},   //enles	
    {L"olne"  ,4, 3, TYPE3},   //enlo	
    {L"elne"  ,4, 3, TYPE3},   //enle	
    {L"alne"  ,4, 3, TYPE3},   //enla
    {L"emetne",6, 5, TYPE3},   //enteme

    {L"etsom"  ,5, 5, TYPE4},  //moste
    {L"essom"  ,5, 5, TYPE4},  //mosse	
    {L"emsom"  ,5, 5, TYPE4},  //mosme	
    {L"sonsom" ,6, 6, TYPE4},  //mosnos	
    {L"solsom" ,6, 6, TYPE4},  //moslos	
    {L"salsom" ,6, 6, TYPE4},  //moslas	
    {L"selsom" ,6, 6, TYPE4},  //mosles	
    {L"olsom"  ,5, 5, TYPE4},  //moslo	
    {L"elsom"  ,5, 5, TYPE4},  //mosle	
    {L"alsom"  ,5, 5, TYPE4},  //mosla
    {L"etessom",7, 7, TYPE4},  //mossete

    {L"soetda",6, 5, TYPE5},   // adteos
    {L"emetda",6, 5, TYPE5},   // adteme
    {L"etda"  ,4, 3, TYPE5},   // adte 
    {L"esda"  ,4, 3, TYPE5},   // adse
    {L"emda"  ,4, 3, TYPE5},   // adem
    {L"sonda" ,5, 4, TYPE5},   // adnos
    {L"solda" ,5, 4, TYPE5},   // adlos
    {L"salda" ,5, 4, TYPE5},   // adlas
    {L"selda" ,5, 4, TYPE5},   // adles
    {L"olda"  ,4, 3, TYPE5},   // adlo
    {L"elda"  ,4, 3, TYPE5},   // adle
    {L"alda"  ,4, 3, TYPE5},   // adla

    {L"etr\x0e1" ,4, 3, TYPE6}, // rte
    {L"esr\x0e1" ,4, 3, TYPE6}, // rse	
    {L"emr\x0e1" ,4, 3, TYPE6}, // rme	
    {L"sonr\x0e1",5, 4, TYPE6}, // rnos	
    {L"solr\x0e1",5, 4, TYPE6}, // rlos	
    {L"salr\x0e1",5, 4, TYPE6}, // rlas	
    {L"selr\x0e1",5, 4, TYPE6}, // rles	
    {L"olr\x0e1" ,4, 3, TYPE6}, // rlo	
    {L"elr\x0e1" ,4, 3, TYPE6}, // rle	
    {L"alr\x0e1" ,4, 3, TYPE6}, // rla

    {L"emes" ,4, 4, TYPE7},  // seme
    {L"sones",5, 5, TYPE7},  // senos
    {L"soles",5, 5, TYPE7},  // selos
    {L"oles" ,4, 4, TYPE7},  // selo
    {L"seles",5, 5, TYPE7},  // seles
    {L"eles" ,4, 4, TYPE7},  // sele
    {L"sales",5, 5, TYPE7},  // sesal
    {L"ales" ,4, 4, TYPE7},  // sela

    {L"emem", 4, 4, TYPE16}, // meme
    {L"sonem",5, 5, TYPE16}, // menos
    
    {L"solem",5, 5, TYPE8}, // melos
    {L"olem" ,4, 4, TYPE8}, // melo
    {L"selem",5, 5, TYPE8}, // meles
    {L"elem" ,4, 4, TYPE8}, // mele
    {L"salem",5, 5, TYPE8}, // mesal
    {L"alem" ,4, 4, TYPE8}, // mela

    {L"emet" ,4, 4, TYPE9}, // teme
    {L"sonet",5, 5, TYPE9}, // tenos
    {L"solet",5, 5, TYPE9}, // telos
    {L"olet" ,4, 4, TYPE9}, // telo
    {L"selet",5, 5, TYPE9}, // teles
    {L"elet" ,4, 4, TYPE9}, // tele
    {L"salet",5, 5, TYPE9}, // tesal
    {L"alet" ,4, 4, TYPE9}, // tela

    {L"etsoets\x0e9",8, 4, TYPE10},	  // steoste
    {L"soets\x0e9"  ,6, 2, TYPE10},	  // steos

    {L"sole",4, 0,TYPE11},  // elos 
    {L"ole" ,3, 0,TYPE11},  // elo
    {L"eme" ,3, 0,TYPE11},  // eme
    {L"sele",4, 0,TYPE11},  // eles
    {L"ele" ,3, 0,TYPE11},  // ele
    {L"sale",4, 0,TYPE11},  // elas
    {L"ale" ,3, 0,TYPE11},  // ela

    {L"sona",4, 0,TYPE12},  // anos

    {L"ese",3, 0, TYPE13},  // ese
    {L"esa",3, 0, TYPE13},  // ase

    {L"sone",4, 0,TYPE14},  // enos

    {L"olner",5, 5, TYPE15}, // renlo

    {L"\0",0,0,0}
};


CSpanishUtil::CSpanishUtil()
{
    WCHAR wch;
    for (wch = 0; wch < 256; wch++)
    {
        m_rCharConvert[wch] = towupper(wch);
        m_rAccentConvert[wch] = 0;
        m_rCharCompress[wch] = 0;
    }

    memset(m_rReverseAccentConvert, 0, sizeof(char) * 16);

    m_rCharConvert[0xc0] = L'A';
    m_rCharConvert[0xc1] = L'A';
    m_rCharConvert[0xc2] = L'A';
    m_rCharConvert[0xc3] = L'A';
    m_rCharConvert[0xc4] = L'A';
    m_rCharConvert[0xc5] = L'A';
    m_rCharConvert[0xc8] = L'E';
    m_rCharConvert[0xc9] = L'E';
    m_rCharConvert[0xca] = L'E';
    m_rCharConvert[0xcb] = L'E';
    m_rCharConvert[0xcc] = L'I';
    m_rCharConvert[0xcd] = L'I';
    m_rCharConvert[0xce] = L'I';
    m_rCharConvert[0xcf] = L'I';
    m_rCharConvert[0xd2] = L'O';
    m_rCharConvert[0xd3] = L'O';
    m_rCharConvert[0xd4] = L'O';
    m_rCharConvert[0xd5] = L'O';
    m_rCharConvert[0xd6] = L'O';
    m_rCharConvert[0xd9] = L'U';
    m_rCharConvert[0xda] = L'U';
    m_rCharConvert[0xdb] = L'U';
    m_rCharConvert[0xdc] = L'U';

    m_rCharConvert[0xe0] = L'A';
    m_rCharConvert[0xe1] = L'A';
    m_rCharConvert[0xe2] = L'A';
    m_rCharConvert[0xe3] = L'A';
    m_rCharConvert[0xe4] = L'A';
    m_rCharConvert[0xe5] = L'A';
    m_rCharConvert[0xe8] = L'E';
    m_rCharConvert[0xe9] = L'E';
    m_rCharConvert[0xea] = L'E';
    m_rCharConvert[0xeb] = L'E';
    m_rCharConvert[0xec] = L'I';
    m_rCharConvert[0xed] = L'I';
    m_rCharConvert[0xee] = L'I';
    m_rCharConvert[0xef] = L'I';
    m_rCharConvert[0xf2] = L'O';
    m_rCharConvert[0xf3] = L'O';
    m_rCharConvert[0xf4] = L'O';
    m_rCharConvert[0xf5] = L'O';
    m_rCharConvert[0xf6] = L'O';
    m_rCharConvert[0xf9] = L'U';
    m_rCharConvert[0xfa] = L'U';
    m_rCharConvert[0xfb] = L'U';
    m_rCharConvert[0xfc] = L'U';

    for (wch = 0; wch < 256; wch++)
    {
        if (m_rCharConvert[wch] >= L'A' && m_rCharConvert[wch] <= L'Z')
        {
            m_rCharCompress[wch] = m_rCharConvert[wch] - L'A' + 1; 
        }
    }

    m_rCharCompress[0xD1] = 28;
    m_rCharCompress[0xF1] = 28;


    m_rAccentConvert[0xe1] = 1;
    m_rAccentConvert[0xf3] = 2;
    m_rAccentConvert[0xcd] = 3;
    m_rAccentConvert[0xe9] = 4;
    m_rAccentConvert[0xfa] = 5;
    m_rAccentConvert[0xfc] = 6;
    m_rAccentConvert[0x61] = 7;
    m_rAccentConvert[0x6f] = 8;
    m_rAccentConvert[0x69] = 9;
    m_rAccentConvert[0x65] = 10;
    m_rAccentConvert[0x75] = 11;

    m_rReverseAccentConvert[1] = (WCHAR)0xe1;
    m_rReverseAccentConvert[2] = (WCHAR)0xf3;
    m_rReverseAccentConvert[3] = (WCHAR)0xcd;
    m_rReverseAccentConvert[4] = (WCHAR)0xe9;
    m_rReverseAccentConvert[5] = (WCHAR)0xfa;
    m_rReverseAccentConvert[6] = (WCHAR)0xfc;
    m_rReverseAccentConvert[7] = (WCHAR)0x61;
    m_rReverseAccentConvert[8] = (WCHAR)0x6f;
    m_rReverseAccentConvert[9] = (WCHAR)0x69;
    m_rReverseAccentConvert[10] = (WCHAR)0x65;
    m_rReverseAccentConvert[11] = (WCHAR)0x75;

}

int CSpanishUtil::aiWcscmp(const WCHAR* p, const WCHAR* t)
{
    while (*p && *t && (m_rCharConvert[*p] == m_rCharConvert[*t]))
    {
        p++;
        t++;
    }

    if ((m_rCharConvert[*p] == m_rCharConvert[*t]))
    {
        return 0;
    }
    if ((m_rCharConvert[*p] > m_rCharConvert[*t]))
    {
        return 1;
    }

    return -1;
}

int CSpanishUtil::aiStrcmp(const unsigned char* p, const unsigned char* t)
{
    while (*p && *t && (m_rCharConvert[*p] == m_rCharConvert[*t]))
    {
        p++;
        t++;
    }

    if (m_rCharConvert[*p] == m_rCharConvert[*t])
    {
        return 0;
    }
    if (m_rCharConvert[*p] > m_rCharConvert[*t])
    {
        return 1;
    }

    return -1;
}

int CSpanishUtil::aiWcsncmp(const WCHAR* p, const WCHAR* t, const int iLen)
{
    int i = 0;
    while ((i < iLen) && *p && *t && (m_rCharConvert[*p] == m_rCharConvert[*t]))
    {
        p++;
        t++;
        i++;
    }

    if ((i == iLen) || (m_rCharConvert[*p] == m_rCharConvert[*t]))
    {
        return 0;
    }
    if (m_rCharConvert[*p] > m_rCharConvert[*t])
    {
        return 1;
    }

    return -1;
}



CSpanishSuffixDict::CSpanishSuffixDict()
{
    WCHAR* pwcsCur;
    int i;
    DictStatus status;

	for (i = 0, pwcsCur = g_rSpanishSuffix[i].pwcs; 
		 *pwcsCur != L'\0'; 
		 i++, pwcsCur = g_rSpanishSuffix[i].pwcs)
	{
        status = m_SuffixTrie.trie_Insert(
                                        pwcsCur,
                                        TRIE_IGNORECASE,
                                        const_cast<CSuffixTerm*>(&g_rSpanishSuffix[i]),
                                        NULL);

        Assert (DICT_SUCCESS == status);
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\spanishtokenizer.cpp ===
#include "base.h"
#include "SpanishTokenizer.h"
#include "WbUtils.h"

CAutoClassPointer<CSpanishDict> g_apSpanishDict;
CAutoClassPointer<CSyncCriticalSection> g_apcsSpanishDictInit;

CSpanishTokenizer::CSpanishTokenizer(
    TEXT_SOURCE* pTxtSource,
    IWordSink   * pWordSink,
    IPhraseSink * pPhraseSink,
    LCID lcid,
    BOOL bQueryTime,
    ULONG ulMaxTokenSize) :
    CTokenizer(pTxtSource, pWordSink, pPhraseSink, lcid, bQueryTime, ulMaxTokenSize)
{
    if (NULL == g_apSpanishDict.Get())
    {
        CSyncMutexCatcher cs(*(g_apcsSpanishDictInit.Get()));
        if (NULL == g_apSpanishDict.Get())
        {
            CAutoArrayPointer<WCHAR> apwcsPath;

            apwcsPath = CreateFilePath(L"SpanishDict.txt");

            if (NULL == g_apSpanishUtil.Get())
            {
                g_apSpanishUtil = new CSpanishUtil;
            }
        
            if (NULL == g_apSpanishDict.Get())
            {
                g_apSpanishDict = new CSpanishDict(apwcsPath.Get());
            }
        }
    }
}

void CSpanishTokenizer::OutputSimpleToken(
            CTokenState& State,
            const CCliticsTerm* pTerm)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = 
                    m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    if ((TAIL_MATCH_TRUNCATE == pTerm->ulOp) ||
        (HEAD_MATCH_TRUNCATE == pTerm->ulOp))
    {
        if (0 == ( State.m_ulEnd - State.m_ulStart - pTerm->ulLen ))
        {
            return;
        }

        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart,
                        &State.m_pwcsToken[State.m_ulStart],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }


        if (pTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            hr = m_apWordSink->PutWord(
                            State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                            &State.m_pwcsToken[State.m_ulStart],
                            State.m_ulEnd - State.m_ulStart,
                            ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

        }
        else
        {
            Assert(pTerm->ulOp == HEAD_MATCH_TRUNCATE);
            hr = m_apWordSink->PutWord(
                            State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                            &State.m_pwcsToken[State.m_ulStart + pTerm->ulLen],
                            State.m_ulEnd - State.m_ulStart,
                            ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }
        }

        return;
    }


    WCHAR pwcsAlt[MAX_WORD_LEN];
    ULONG ulAltLen = MAX_WORD_LEN;
    bool bAlt = false; 
    ULONG ulWordLen = State.m_ulEnd - State.m_ulStart;
    
    if (ulWordLen < 32)
    {
        g_apSpanishDict->BreakWord(
                                ulWordLen,
                                State.m_pwcsToken + State.m_ulStart,
                                &bAlt,
                                &ulAltLen,
                                pwcsAlt);
    }

    if (bAlt)
    {
        hr = m_apWordSink->PutAltWord(
                ulAltLen,
                pwcsAlt,
                State.m_ulEnd - State.m_ulStart,
                ulOffsetInTxtSourceBuffer
                );        

        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }
    }
    
    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer
                    );
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\tokenizer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Tokenizer.cpp
//  Purpose  :  Tokenizer implementation
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      Jan 06 2000 yairh creation
//      Apr 04 2000 dovh on behalf of dlee - Fix CTokenizer::OutputClitics
//          to avoid PutWord of length 0 (leads to multiple PutWord at
//          same location (duplicate keys), and index corruption!
//          Example: :...'s :...'s (. stands for junk character)
//      Apr 05 2000 dovh - Fixed two problematic debug / tracer buffer size
//          problems.  (Related to Bug 15449).
//      May 07 2000 dovh - USE_WS_SENTINEL algorithm in BreakText
//      May 11 2000 dovh - Simplify VerifyMisc test.
//      Nov 11 2000 dovh - Special underscore treatment
//          Add AddBackUnderscores '_' + alphanumeric treatment.
//
////////////////////////////////////////////////////////////////////////////////

#include "base.h"
#include "Tokenizer.h"
#include "PropArray.h"
#include "excption.h"
#include "formats.h"

DECLARE_TRIE_SENTINEL;
CWbToUpper g_WbToUpper;

CAutoClassPointer<CPropArray> g_pPropArray;

CTokenizer::CTokenizer(
    TEXT_SOURCE* pTxtSource,
    IWordSink   * pWordSink,
    IPhraseSink * pPhraseSink,
    LCID lcid,
    BOOL bQueryTime,
    ULONG ulMaxTokenSize) :
    m_pTxtSource(pTxtSource),
    m_apWordSink(pWordSink),
    m_apPhraseSink(pPhraseSink),
    m_Lcid(lcid),
    m_bQueryTime(bQueryTime),
    m_bNoMoreTxt(false),
    m_Token(ulMaxTokenSize),
    m_bWhiteSpaceGuarranteed(false)
{
    m_ulMaxTokenSize = min(ulMaxTokenSize, TOKENIZER_MAXBUFFERLIMIT);

    m_apLangSupport = new CLangSupport(lcid);

    m_pCurToken = &m_Token;

    if (pTxtSource->iEnd > pTxtSource->iCur)
    {
        CalculateUpdateEndOfBuffer();
    }
    else
    {
        m_ulUpdatedEndOfBuffer = pTxtSource->iEnd;
    }
}


void CTokenizer::BreakText()
{
    Trace(
        elVerbose,
        s_tagTokenizer,
        ("CTokenizer::BreakText()"));


    WCHAR wch;
    ULONGLONG ullflags(PROP_DEFAULT);

    //
    // USE_WS_SENTINEL Algorithm:
    //

    HRESULT hr = S_OK;

    if (m_pTxtSource->iCur >= m_ulUpdatedEndOfBuffer)
    {

        hr = FillBuffer();

    }

    while ( SUCCEEDED(hr) )
    {
        if ( m_bWhiteSpaceGuarranteed )
        {
            while (true)
            {
                wch = m_pTxtSource->awcBuffer[m_pTxtSource->iCur];

                ullflags = (GET_PROP(wch).m_ulFlag);

                if (ullflags & PROP_WS)
                {
                    if (m_pCurToken->IsNotEmpty())
                    {
                        ProcessToken();
                    }
                    m_pTxtSource->iCur++;

                    if (m_pTxtSource->iCur >= m_ulUpdatedEndOfBuffer)
                    {
                        hr = FillBuffer();
                        break;

                    }
                    continue;

                }

                //
                // The following lines are inline expenstion of what
                // used to be CToken::RecordChar:
                //

                Assert(m_pCurToken->m_ulBufPos < m_ulMaxTokenSize);
                m_pCurToken->m_awchBuf[m_pCurToken->m_ulBufPos] = wch;
                m_pCurToken->m_ulBufPos++;
                m_pCurToken->m_State.m_Properties.m_ulFlag |= ullflags;
                m_pTxtSource->iCur++;

            } // while
        }
        else
        {
            while (true)
            {
                if (m_pTxtSource->iCur >= m_ulUpdatedEndOfBuffer)
                {
                    Assert(m_pTxtSource->iCur == m_ulUpdatedEndOfBuffer);

                    //
                    // before we switch between buffers if the current token is not empty we
                    // need to proccess it. m_ulUpdatedEndOfBuffer always points to a breaker character
                    // (usually it is a WS) thus no token can start at a certain buffer and end in the
                    // proceeding buffer.
                    //

                    if (m_pCurToken->IsNotEmpty())
                    {
                        ProcessToken();
                    }

                    hr = FillBuffer();
                    if (FAILED(hr))
                    {
                        break;
                    }
                }

                wch = m_pTxtSource->awcBuffer[m_pTxtSource->iCur];

                ULONGLONG ullflags(GET_PROP(wch).m_ulFlag);

                if (ullflags & PROP_WS)
                {
                    if (m_pCurToken->IsNotEmpty())
                    {
                        ProcessToken();
                    }
                    m_pTxtSource->iCur++;
                    continue;
                }

                //
                // the following lines are inline expenstion of what used to be CToken::RecordChar.
                //

                Assert(m_pCurToken->m_ulBufPos < m_ulMaxTokenSize);
                m_pCurToken->m_awchBuf[m_pCurToken->m_ulBufPos] = wch;
                m_pCurToken->m_ulBufPos++;
                m_pCurToken->m_State.m_Properties.m_ulFlag |= ullflags;
                m_pTxtSource->iCur++;

            } // while

        } // if

    } // while ( !FAILED(hr) )

} // CTokenizer::BreakText

void CTokenizer::ProcessToken()
{
    ULONG ulOffset;

    if (m_pTxtSource->iCur < m_pCurToken->m_ulBufPos)
    {
        Trace(
            elWarning,
            s_tagTokenizer,
            ("CTokenizer::ProcessToken() wrong offset calculation"));

        //
        // BUGBUG need to understand why we got to this place.
        //
        Assert(0 && "Wrong offset calculation");

        ulOffset = m_pCurToken->m_ulBufPos + 1;
    }
    else if (m_pTxtSource->iCur == m_pCurToken->m_ulBufPos)
    {
        ulOffset = m_pCurToken->m_ulBufPos;
    }
    else
    {
        ulOffset = m_pTxtSource->iCur;
    }

    m_pCurToken->MarkEndToken(ulOffset);
    #ifdef DEBUG
        TraceToken();
    #endif

    //
    // simple token.
    //
    if (IS_PROP_SIMPLE(m_pCurToken->m_State.m_Properties))
    {
        OutputSimpleToken(
                        m_pCurToken->m_State,
                        &g_EmptyClitics);

    }
    else
    {
        ProcessTokenInternal();
    }

    if (m_pCurToken->m_fHasEos)
    {
        Trace(
            elVerbose,
            s_tagTokenizerDecision,
            ("EOS"));

        HRESULT hr;
        hr = m_apWordSink->PutBreak(WORDREP_BREAK_EOS);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    m_pCurToken->Clear();
}

void CTokenizer::ProcessTokenInternal()
{

    do
    {

        //
        // url
        //

        if (HAS_PROP_SLASH(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_COLON(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_ALPHA(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be <alpha>:// url", 
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyAlphaUrl())
            {
                break;
            }
        }

        if (HAS_PROP_PERIOD(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_W(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be www. url", 
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyWwwUrl())
            {
                break;
            }
        }


        //
        // Acronym
        //

        if (HAS_PROP_PERIOD(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_UPPER_CASE(m_pCurToken->m_State.m_Properties))
        {
            if (!HAS_PROP_LOWER_CASE(m_pCurToken->m_State.m_Properties) ||
                HAS_PROP_APOSTROPHE(m_pCurToken->m_State.m_Properties))
            {

                Trace(
                    elVerbose,
                    s_tagTokenizerSuspect,
                    ("%*.*S  suspected to be an acronym",
                    m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                    m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                    m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                    ));

                if (VerifyAcronym())
                {
                    break;
                }
            }

            //
            // Abbreviation
            //

            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be an abbreviation",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));
                

            if (VerifyAbbreviation())
            {
                break;
            }

            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be a special abbreviation", 
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifySpecialAbbreviation())
            {
                break;
            }

        }

        //
        // Hyphenation
        //
        if (HAS_PROP_DASH(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_ALPHA(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to have a hyphenation",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyHyphenation())
            {
                break;
            }
        }

        //
        // (s) parenthesis
        //

        if (HAS_PROP_LEFT_PAREN(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_RIGHT_PAREN(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_ALPHA(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to have a (s) Parenthesis",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyParens())
            {
                break;
            }
        }


        //
        // Currency
        //
        if (HAS_PROP_CURRENCY(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_NUMBER(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be a currency",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyCurrency())
            {
                break;
            }
        }

        //
        // Numbers / time / dates
        //

        if (HAS_PROP_NUMBER(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be a number or a time or a date",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyNumberOrTimeOrDate())
            {
                break;
            }
        }

        //
        // commersial signs
        //
        if (TEST_PROP(m_pCurToken->m_State.m_Properties, PROP_COMMERSIAL_SIGN) &&
            HAS_PROP_ALPHA(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to have a commesial sign",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyCommersialSign())
            {
                break;
            }
        }

        //
        // Misc - C++, J++, A+, A- .. C#
        //

        if ( TEST_PROP(m_pCurToken->m_State.m_Properties, (PROP_MINUS|PROP_PLUS|PROP_POUND)) &&
             HAS_PROP_ALPHA(m_pCurToken->m_State.m_Properties) )
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to belong to the misc list",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));


            if (VerifyMisc())
            {
                break;
            }
        }

        //
        // default
        //

        ProcessDefault();

    } while (false);

}

#ifdef DEBUG
void CTokenizer::TraceToken()
{
    WCHAR buf[MAX_NUM_PROP+1];

    size_t bufLen = wcslen(TRACE_CHAR);
    Assert(bufLen < MAX_NUM_PROP + 1);
    buf[bufLen] = L'\0';
    
    for(int i=0; i<bufLen; i++)
    {
        if(TEST_PROP(m_pCurToken->m_State.m_Properties, (1<<i)))
        {
          buf[i] = TRACE_CHAR[i];
        }
        else
        {
            buf[i] = L'_';
        }
    }

    Trace(
        elVerbose,
        s_tagTokenizerTrace,
        ("[%S] - %*.*S", 
        buf,
        m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
        m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
        m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
        ));


}
#endif // DEBUG

bool CTokenizer::VerifyAlphaUrl()
{
    //
    // looking for <alpha>:// pattern
    //

    CTokenState State(m_pCurToken->m_State);

    ULONG ul = State.m_ulStart;

    if (!HAS_PROP_ALPHA(GET_PROP(State.m_pwcsToken[ul])))
    {
        return false;
    }

    while (HAS_PROP_EXTENDED_ALPHA(GET_PROP(State.m_pwcsToken[ul])))
    {
        ul++;
    }

    if (!(HAS_PROP_COLON(GET_PROP(State.m_pwcsToken[ul]))))
    {
        return false;
    }
    ul++;

    if (!(HAS_PROP_SLASH(GET_PROP(State.m_pwcsToken[ul]))))
    {
        return false;
    }
    ul++;

    if (!(HAS_PROP_SLASH(GET_PROP(State.m_pwcsToken[ul]))))
    {
        return false;
    }

    {
        Trace(
            elVerbose,
            s_tagTokenizerDecision,
            ("%*.*S  is an <alpha>:// url",
            State.m_ulEnd - State.m_ulStart,
            State.m_ulEnd - State.m_ulStart,
            State.m_pwcsToken + State.m_ulStart
            ));

    }

    OutputUrl(State);

    return true;
}

bool CTokenizer::VerifyWwwUrl()
{
    CTokenState State(m_pCurToken->m_State);

    if (State.m_ulEnd - State.m_ulStart <= 4)
    {
        return false;
    }

    if (0 != _wcsnicmp(State.m_pwcsToken + State.m_ulStart, L"www.", 4))
    {
        return false;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a www. url",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputUrl(State);

    return true;
}

bool CTokenizer::VerifyAcronym()
{
    //
    // looking for I.B.M or I.B.M. or A.B.CC but not A.B.CC.
    //

    CTokenState State(m_pCurToken->m_State);

    CPropFlag   AbbPuctTail(ACRONYM_PUNCT_TAIL);
    CPropFlag   AbbPuctHead(ACRONYM_PUNCT_HEAD);
    bool fNeedToRemoveEos = true;

    if (TEST_PROP(State.m_Properties, (ACRONYM_PUNCT_TAIL | ACRONYM_PUNCT_HEAD)))
    {
        if (TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd- 1]), ABBREVIATION_EOS))
        {
            fNeedToRemoveEos = false;
        }

        ULONG ulCharRemoved = m_pCurToken->RemoveTailPunct(AbbPuctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(AbbPuctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulEnd = State.m_ulEnd;
    ULONG ulCur = State.m_ulStart;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulCur += pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulEnd -= pCliticsTerm->ulLen;
    }

    //
    // finding the last period
    //
    while ((ulEnd > ulCur) && 
           HAS_PROP_UPPER_CASE(GET_PROP(State.m_pwcsToken[ulEnd- 1])))
    {
        ulEnd--;
    }

    if ((ulEnd == ulCur) || 
        !HAS_PROP_PERIOD(GET_PROP(State.m_pwcsToken[ulEnd- 1])))
    {
        return false;
    }

    ULONG ulCounter = 0;

    while (ulCur < ulEnd)
    {
        if (ulCounter%2 == 0)
        {
            if (!HAS_PROP_UPPER_CASE(GET_PROP(State.m_pwcsToken[ulCur])))
            {
                return false;
            }
        }
        else
        {
            if (!HAS_PROP_PERIOD(GET_PROP(State.m_pwcsToken[ulCur])))
            {
                return false;
            }
        }
        ulCur++;
        ulCounter++;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is an acronym",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    if (fNeedToRemoveEos && (pCliticsTerm->ulOp != TAIL_MATCH_TRUNCATE))
    {
        m_pCurToken->m_fHasEos = false;
    }
    OutputAcronym(State, pCliticsTerm);

    return true;
}

bool CTokenizer::VerifyAbbreviation()
{
    //
    // looking for Sr. Jr.
    // we define abbreviation as a pattern with 2 letters ending with a dot and the first letter
    // is a capital one
    //

    CTokenState State(m_pCurToken->m_State);
    CPropFlag   AbbPuctTail(ABBREVIATION_PUNCT_TAIL);
    CPropFlag   AbbPuctHead(ABBREVIATION_PUNCT_HEAD);
    bool fNeedToRemoveEos = true;

    if (TEST_PROP(State.m_Properties, (ABBREVIATION_PUNCT_TAIL | ABBREVIATION_PUNCT_HEAD)))
    {
        if (TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd- 1]), ABBREVIATION_EOS))
        {
            fNeedToRemoveEos = false;
        }

        ULONG ulCharRemoved = m_pCurToken->RemoveTailPunct(AbbPuctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(AbbPuctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    if ((State.m_ulEnd - State.m_ulStart) != 3)
    {
        return false;
    }

    if (!HAS_PROP_UPPER_CASE(GET_PROP(State.m_pwcsToken[State.m_ulStart])))
    {
        return false;
    }

    if (!HAS_PROP_EXTENDED_ALPHA(GET_PROP(State.m_pwcsToken[State.m_ulStart + 1])))
    {
        return false;
    }

    if (!HAS_PROP_PERIOD(GET_PROP(State.m_pwcsToken[State.m_ulStart + 2])))
    {
        return false;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is an abbreviation",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));


    if (fNeedToRemoveEos)
    {
        m_pCurToken->m_fHasEos = false;
    }

    OutputAbbreviation(State);
    return true;

}

bool CTokenizer::VerifySpecialAbbreviation()
{
    CTokenState State(m_pCurToken->m_State);
    CPropFlag   AbbPuctTail(SPECIAL_ABBREVIATION_PUNCT_TAIL);
    CPropFlag   AbbPuctHead(SPECIAL_ABBREVIATION_PUNCT_HEAD);

    if (TEST_PROP(State.m_Properties, (SPECIAL_ABBREVIATION_PUNCT_TAIL | SPECIAL_ABBREVIATION_PUNCT_HEAD)))
    {
        ULONG ulCharRemoved = m_pCurToken->RemoveTailPunct(AbbPuctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(AbbPuctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }

        if (!HAS_PROP_PERIOD(State.m_Properties))
        {
            return false;
        }
    }

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }


    CAbbTerm* pTerm;
    short sResCount = 0;
    DictStatus status;

    CSpecialAbbreviationSet* pAbbSet = m_apLangSupport->GetAbbSet();
    status = pAbbSet->m_trieAbb.trie_Find(
                                State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                                TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                1,
                                &pTerm,
                                &sResCount);

    if (sResCount &&
        (pTerm->ulAbbLen == (State.m_ulEnd - State.m_ulStart - ulAddToStart - ulDecFromEnd)))
    {
        Trace(
            elVerbose,
            s_tagTokenizerDecision,
            ("%*.*S is an abbreviation",
            State.m_ulEnd - State.m_ulStart,
            State.m_ulEnd - State.m_ulStart,
            State.m_pwcsToken + State.m_ulStart
            ));

        OutputSpecialAbbreviation(State, pTerm, pCliticsTerm);
        return true;
    }

    return false;
}

bool CTokenizer::VerifyMisc()
{
    CTokenState State(m_pCurToken->m_State);
    CPropFlag   MiscPuctTail(MISC_PUNCT_TAIL);
    CPropFlag   MiscPuctHead(MISC_PUNCT_HEAD);

    if (TEST_PROP(State.m_Properties, (MISC_PUNCT_TAIL | MISC_PUNCT_HEAD)))
    {
        ULONG ulCharRemoved = m_pCurToken->RemoveTailPunct(MiscPuctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(MiscPuctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }

    int iEnd = State.m_ulEnd - ulDecFromEnd;
    int iStart = State.m_ulStart + ulAddToStart;
    if (iEnd <= iStart)
    {
        return false;
    }

    bool bPatternContainOnlyUpperCase = true;
    ULONG ulSuffixSize = 0;
    
    if (TEST_PROP(State.m_Properties, PROP_POUND))
    {
        //
        // look for A# C#
        //

        ULONG ulEnd = State.m_ulEnd - ulDecFromEnd;
        ULONG ulStart = State.m_ulStart + ulAddToStart;
        if (ulEnd - ulStart != 2)
        {
            return false;
        }

        if (!TEST_PROP(GET_PROP(State.m_pwcsToken[ulEnd - 1]), PROP_POUND))
        {
            return false;
        }

        if (!TEST_PROP(GET_PROP(State.m_pwcsToken[ulStart]), PROP_UPPER_CASE))
        {
            return false;
        }
        
        ulSuffixSize = 1;
    }
    else
    {
        //
        // look for C++ COM+ ...
        //

        ULONG ul = State.m_ulEnd - ulDecFromEnd - 1;
        while ((int)ul >= (int)(State.m_ulStart + ulAddToStart))
        {
            if (!TEST_PROP(GET_PROP(State.m_pwcsToken[ul]), PROP_PLUS | PROP_MINUS))
            {
                break;
            }
            ulSuffixSize++;
            ul--;
        }

        if (ulSuffixSize > 2)
        {
            return false;
        }

        while ((int)ul >= (int)(State.m_ulStart + ulAddToStart))
        {
            CPropFlag prop(GET_PROP(State.m_pwcsToken[ul]));
            if (!HAS_PROP_EXTENDED_ALPHA(prop))
            {
                return false;
            }
            if (!TEST_PROP(prop, PROP_UPPER_CASE))
            {
                bPatternContainOnlyUpperCase = false;
            }

            ul--;
        }
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S is detected",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputMisc(
            State,
            bPatternContainOnlyUpperCase,
            ulSuffixSize,
            pCliticsTerm);

    return true;

}

bool CTokenizer::VerifyHyphenation()
{
    //
    // looking for data-base
    //

    CPropFlag PunctHead(HYPHENATION_PUNCT_HEAD);
    CPropFlag PunctTail(HYPHENATION_PUNCT_TAIL);
    CTokenState State(m_pCurToken->m_State);

    if (TEST_PROP(State.m_Properties, (HYPHENATION_PUNCT_HEAD | HYPHENATION_PUNCT_TAIL)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved = m_pCurToken->RemoveHeadPunct(PunctHead, State);
        ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    if (!HAS_PROP_DASH(State.m_Properties))
    {
        return false;
    }

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }


    ULONG ulCur = State.m_ulStart + ulAddToStart;
    ULONG ulEnd = State.m_ulEnd - ulDecFromEnd;

    bool bReadAlpha = false;

    do
    {
        while (ulCur < ulEnd)
        {
            if (HAS_PROP_EXTENDED_ALPHA(GET_PROP(m_pCurToken->m_State.m_pwcsToken[ulCur])))
            {
                ulCur++;
                bReadAlpha = true;
                continue;
            }
            break;
        }

        if (!bReadAlpha)
        {
            return false;
        }

        if (ulCur < ulEnd)
        {
            if (!HAS_PROP_DASH(GET_PROP(m_pCurToken->m_State.m_pwcsToken[ulCur])))
            {
                return false;
            }
        }
        else
        {
            break;
        }

        ulCur++;
        bReadAlpha = false;
    }
    while (ulCur < ulEnd);

    if (!bReadAlpha)
    {
        //
        // last characters where not alpha ex. free-
        //
        return false;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is an hyphenation",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputHyphenation(State, pCliticsTerm);

    return true;
}

bool CTokenizer::VerifyParens()
{
    CPropFlag PunctTail(PAREN_PUNCT_TAIL);
    CPropFlag PunctHead(PAREN_PUNCT_HEAD);

    CTokenState State(m_pCurToken->m_State);

    if (TEST_PROP(State.m_Properties, (PAREN_PUNCT_TAIL | PAREN_PUNCT_HEAD)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved = m_pCurToken->RemoveTailPunct(PunctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(PunctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    //
    // looking for (s)
    //

    if ((State.m_ulEnd - State.m_ulStart) < 4)
    {
        return false;
    }

    if (0 != wcsncmp(State.m_pwcsToken + State.m_ulEnd - 3, L"(s)", 3))
    {
        return false;
    }

    for (ULONG ul = State.m_ulStart; ul < State.m_ulEnd - 3; ul++)
    {
        if (!HAS_PROP_EXTENDED_ALPHA(GET_PROP(State.m_pwcsToken[ul])))
        {
            return false;
        }
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  has (s) parenthesis",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputParens(State);

    return true;
}

const CCliticsTerm* CTokenizer::VerifyClitics(CTokenState& S)
{
    if (TEST_PROP(GET_PROP(S.m_pwcsToken[S.m_ulStart]), PROP_APOSTROPHE))
    {
        S.m_ulStart++;
        
        if ((TEST_PROP(GET_PROP(S.m_pwcsToken[S.m_ulEnd - 1]), PROP_APOSTROPHE)) &&
            (S.m_ulEnd > S.m_ulStart))
        {
            S.m_ulEnd--;
        }

        m_pCurToken->ComputeStateProperties(S);
    }

    if (!(HAS_PROP_APOSTROPHE(S.m_Properties)))
    {
        return &g_EmptyClitics;
    }

    CPropFlag PunctTail(CLITICS_PUNC_TAIL);
    CPropFlag PunctHead(CLITICS_PUNCT_HEAD);

    CTokenState State(S);

    if (TEST_PROP(State.m_Properties, (CLITICS_PUNC_TAIL | CLITICS_PUNCT_HEAD)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved = m_pCurToken->RemoveTailPunct(PunctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(PunctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    Trace(
        elVerbose,
        s_tagTokenizerSuspect,
        ("%*.*S  suspected to have an apostophe",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));



    ULONG ulApostrophePos = -1;
    ULONG ulCur;
    for (ulCur = State.m_ulStart; ulCur < State.m_ulEnd ; ulCur++)
    {

        if (TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur]), PROP_APOSTROPHE))
        {
            if ((-1 != ulApostrophePos) || (State.m_ulStart == ulCur))
            {
                //
                // this is not the first \' this is not a valid clitics
                // or the term start with a new apostrophe
                //
                return &g_EmptyClitics;
            }
            ulApostrophePos = ulCur;
            //
            // replace the apostrophe with an ascii apostrophe.
            //
            State.m_pwcsToken[ulCur] = L'\'';
            continue;
        }
    }

    //
    // looking for  xxxxs'
    //
    if ((ulApostrophePos == State.m_ulEnd - 1) &&
        (State.m_pwcsToken[ulApostrophePos - 1] == L's'))
    {

        Trace(
            elVerbose,
            s_tagTokenizerDecision,
            ("%*.*S  has a s' clitcs",
            State.m_ulEnd - State.m_ulStart,
            State.m_ulEnd - State.m_ulStart,
            State.m_pwcsToken + State.m_ulStart
            ));

        S = State;
        return &g_SClitics;

    }

    //
    // looking for tail clitics like xxx's
    //

    DictStatus status;

    CCliticsTerm* pTerm;
    short sResCount = 0;

    if (ulCur > State.m_ulStart)
    {
        status = g_pClitics->m_trieClitics.trie_Find(
                                    State.m_pwcsToken + ulApostrophePos,
                                    TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                    1,
                                    &pTerm,
                                    &sResCount);
        if (sResCount && pTerm->ulLen == (State.m_ulEnd - ulApostrophePos))
        {
            Trace(
                elVerbose,
                s_tagTokenizerDecision,
                ("%*.*S  has a %S clitcs",
                State.m_ulEnd - State.m_ulStart,
                State.m_ulEnd - State.m_ulStart,
                State.m_pwcsToken + State.m_ulStart,
                pTerm->pwcs
                ));

            S = State;
            return pTerm;
        }
    }

    //
    // looking for head clitics like l'xxxx
    //

    status = g_pClitics->m_trieClitics.trie_Find(
                                State.m_pwcsToken + State.m_ulStart,
                                TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                1,
                                &pTerm,
                                &sResCount);
    if (sResCount)
    {
        Trace(
            elVerbose,
            s_tagTokenizerDecision,
            ("%*.*S  has a %S clitcs",
            State.m_ulEnd - State.m_ulStart,
            State.m_ulEnd - State.m_ulStart,
            State.m_pwcsToken + State.m_ulStart,
            pTerm->pwcs
            ));

        S = State;
        return pTerm;
    }

    return &g_EmptyClitics;
}

bool CTokenizer::VerifyNumberOrTimeOrDate()
{
    CPropFlag PunctHead(NUM_DATE_TIME_PUNCT_HEAD);
    CPropFlag PunctTail(NUM_DATE_TIME_PUNCT_TAIL);
    CTokenState State(m_pCurToken->m_State);

    if (TEST_PROP(State.m_Properties,
                  (NUM_DATE_TIME_PUNCT_HEAD | NUM_DATE_TIME_PUNCT_TAIL)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved= m_pCurToken->RemoveHeadPunct(PunctHead, State);
        ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    if ((TEST_PROP(
            State.m_Properties,
            (GET_PROP(m_apLangSupport->GetTimeSeperator()).m_ulFlag))) ||
         HAS_PROP_ALPHA(State.m_Properties))
    {
        //
        // suspected to be time 12:33 14:22 15:22:33
        // or  AM/PM time format 12:22AM 13PM
        //


        Trace(
            elVerbose,
            s_tagTokenizerSuspect,
            ("%*.*S  suspected to be AM/PM time", 
            State.m_ulEnd - State.m_ulStart,
            State.m_ulEnd - State.m_ulStart,
            State.m_pwcsToken + State.m_ulStart
            ));

        if (VerifyTime(State))
        {
            return true;
        }

    }


    Trace(
        elVerbose,
        s_tagTokenizerSuspect,
        ("%*.*S  suspected to be a simple number", 
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    if (VerifyNumber(State))
    {
        return true;
    }

    if (TEST_PROP(State.m_Properties, PROP_DATE_SEPERATOR))
    {
        //
        // suspected to be a date 1999-05-04 or 1998/11/10 1999.05.04
        //

        Trace(
            elVerbose,
            s_tagTokenizerSuspect,
            ("%*.*S  suspected to be a date", 
            m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
            m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
            m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
            ));

        return VerifyDate(State);
    }


    return false;
}


bool CTokenizer::VerifyTime(CTokenState& S)
{
    CTokenState State(S);
    CPropFlag PunctHead(TIME_ADDITIONAL_PUNCT_HEAD);
    CPropFlag PunctTail(TIME_ADDITIONAL_PUNCT_TAIL);

    if (TEST_PROP(State.m_Properties,
                  (TIME_ADDITIONAL_PUNCT_HEAD | TIME_ADDITIONAL_PUNCT_TAIL)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved= m_pCurToken->RemoveHeadPunct(PunctHead, State);
        ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    if ((State.m_ulEnd - State.m_ulStart) > MAX_TIME_FORMAT_LEN)
    {
        return false;
    }

    WCHAR pwcsBuf[MAX_TIME_FORMAT_LEN + 1];
    ULONG ulCur = State.m_ulStart;
    WCHAR wcSeperator = 0xFFFF;
    ULONG ul = 0;

    //
    // formatting the text to a date format
    //

    while (ulCur < State.m_ulEnd)
    {
        CPropFlag prop(GET_PROP(State.m_pwcsToken[ulCur]));
        if (HAS_PROP_NUMBER(prop))
        {
            pwcsBuf[ul] = L'#';
        }
        else if (State.m_pwcsToken[ulCur] == m_apLangSupport->GetTimeSeperator())
        {
            if (0xFFFF == wcSeperator)
            {
                wcSeperator = State.m_pwcsToken[ulCur];
            }
            else if (wcSeperator != State.m_pwcsToken[ulCur])
            {
                return false;
            }
            pwcsBuf[ul] = L':';
        }
        else if (HAS_PROP_ALPHA(prop) || HAS_PROP_PERIOD(prop))
        {
            pwcsBuf[ul] = State.m_pwcsToken[ulCur];
        }
        else
        {
            return false;
        }

        ul++;
        ulCur++;
    }

    pwcsBuf[ul] = L'\0';

    CTimeTerm* pTerm;
    short sResCount = 0;
    DictStatus status;

    status = g_pTimeFormat->m_trieTimeFormat.trie_Find(
                                pwcsBuf,
                                TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                1,
                                &pTerm,
                                &sResCount);
    if (!(sResCount && (pTerm->bLen == ul)))
    {
        return false;
    }

    LONG lHour;
    LONG lMin;
    LONG lSec;
    TimeFormat AmPm;

    GetValuesFromTimeString(
                        pTerm,
                        State.m_pwcsToken + State.m_ulStart ,
                        &lHour,
                        &lMin,
                        &lSec,
                        &AmPm);

    if (None == AmPm)
    {
        if (lHour > 24)
        {
            return false;
        }
    }
    else
    {
        if (lHour > 12)
        {
            return false;
        }

        if (Am == AmPm)
        {
            if (12 == lHour)
            {
                lHour = 0;
            }
        }
        else
        {
            if (lHour < 12)
            {
                lHour += 12;
            }
        }

    }

    if (lMin > 59)
    {
        return false;
    }

    if (lSec > 59)
    {
        return false;
    }

    WCHAR pwcsTime[9] = {L'\0',L'\0',L'\0',L'\0',L'\0',L'\0',L'\0',L'\0',L'\0'};

    swprintf(pwcsTime, L"TT%02d%02d", lHour, lMin);

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a time -> %S",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart,
        pwcsTime));

    OutputTime(pwcsTime, State);

    return true;
}

bool CTokenizer::VerifyDate(CTokenState& S)
{
    CTokenState State(S);
    CPropFlag PunctHead(DATE_ADDITIONAL_PUNCT_HEAD);
    CPropFlag PunctTail(DATE_ADDITIONAL_PUNCT_TAIL);
    if (TEST_PROP(State.m_Properties,
                  (DATE_ADDITIONAL_PUNCT_HEAD | DATE_ADDITIONAL_PUNCT_TAIL)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved= m_pCurToken->RemoveHeadPunct(PunctHead, State);
        ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }


    WCHAR pwcsBuf[MAX_DATE_FORMAT_LEN + 1];

    if (State.m_ulEnd - State.m_ulStart > MAX_DATE_FORMAT_LEN)
    {
        return false;
    }

    ULONG ulCur = State.m_ulStart;
    WCHAR wcSeperator = 0xFFFF;
    ULONG ul = 0;

    //
    // formatting the text to a date format
    //

    while (ulCur < State.m_ulEnd)
    {
        CPropFlag prop(GET_PROP(State.m_pwcsToken[ulCur]));
        if (HAS_PROP_NUMBER(prop))
        {
            pwcsBuf[ul] = L'#';
        }
        else if (HAS_PROP_PERIOD(prop) ||
                 HAS_PROP_DASH(prop) ||
                 HAS_PROP_SLASH(prop))
        {
            if (0xFFFF == wcSeperator)
            {
                wcSeperator = State.m_pwcsToken[ulCur];
            }
            else if (wcSeperator != State.m_pwcsToken[ulCur])
            {
                return false;
            }
            pwcsBuf[ul] = L'.';
        }
        else
        {
            return false;
        }

        ul++;
        ulCur++;
    }

    pwcsBuf[ul] = L'\0';

    CDateTerm* pTerm;
    short sResCount = 0;
    DictStatus status;

    status = g_pDateFormat->m_trieDateFormat.trie_Find(
                                pwcsBuf,
                                TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                1,
                                &pTerm,
                                &sResCount);
    if (!(sResCount && (pTerm->bLen == ul)))
    {
        return false;
    }

    LONG lD_M1;
    LONG lD_M2;
    LONG lYear;

    GetValuesFromDateString(
                    pTerm,
                    State.m_pwcsToken + State.m_ulStart,
                    &lD_M1,
                    &lD_M2,
                    &lYear);

    LONG lDay;
    LONG lMonth;

    //
    // language dependent
    //

    if (m_apLangSupport->IsDayMonthOrder() ||
        pTerm->bType == YYMMDD_TYPE)
    {
        lDay = lD_M1;
        lMonth = lD_M2;
    }
    else
    {
        lDay = lD_M2;
        lMonth = lD_M1;
    }

    if (!((lDay > 0) && (lDay <= 31)))
    {
        return false;
    }

    if (!((lMonth > 0) && (lMonth <= 12)))
    {
        return false;
    }


    WCHAR pwcsDate1[11] = { L'D', L'D', L'0', L'0', L'0', L'0', L'0', L'0', L'0', L'0', L'\0'};
    WCHAR pwcsDate2[11];
    bool bY2K = false;

    if (lYear <= 99)  // Y2k bug
    {
        _ltow(lYear + 1900, pwcsDate1 + 2, 10);
        bY2K = true;
    }
    else if (lYear < 1000)
    {
        _ltow(lYear, pwcsDate1 + 3, 10);
    }
    else
    {
        _ltow(lYear, pwcsDate1 + 2, 10);
    }

    if (lMonth < 10)
    {
        pwcsDate1[6] = L'0';
        _ltow(lMonth, pwcsDate1 + 7, 10);
    }
    else
    {
        _ltow(lMonth, pwcsDate1 + 6, 10);
    }

    if (lDay < 10)
    {
        pwcsDate1[8] = L'0';
        _ltow(lDay, pwcsDate1 + 9, 10);
    }
    else
    {
        _ltow(lDay, pwcsDate1 + 8, 10);
    }

    if (bY2K)
    {
        wcscpy(pwcsDate2, pwcsDate1);
        pwcsDate2[2] = L'2';
        pwcsDate2[3] = L'0';
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a date",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    if (bY2K)
    {
        OutputDate(pwcsDate1, pwcsDate2, State);
    }
    else
    {
        OutputDate(pwcsDate1, NULL, State);
    }
    return true;
}

bool CTokenizer::VerifyNumber(CTokenState& S)
{
    CTokenState State(S);

    WCHAR pwcsNumber[TOKENIZER_MAXBUFFERLIMIT + 10];

    ULONG ulOutLen;
    ULONG ulOffsetToTxt;

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }

    bool fRet = CheckAndCreateNumber(
                            State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                            State.m_ulEnd - State.m_ulStart - ulAddToStart - ulDecFromEnd,
                            pwcsNumber,
                            &ulOffsetToTxt,
                            &ulOutLen);

    if (!fRet)
    {
        return false;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a number",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputNumbers(State, ulOutLen, pwcsNumber + ulOffsetToTxt, pCliticsTerm);

    return true;
}

bool CTokenizer::VerifyCurrency()
{
    //
    // format is either $12.22 or 12.22$
    //
    CPropFlag PunctHead(CURRENCY_PUNCT_HEAD);
    CPropFlag PunctTail(CURRENCY_PUNCT_TAIL);
    CTokenState State(m_pCurToken->m_State);

    if (TEST_PROP(State.m_Properties,
                  (CURRENCY_PUNCT_HEAD | CURRENCY_PUNCT_TAIL)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved= m_pCurToken->RemoveHeadPunct(PunctHead, State);
        ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }


    WCHAR wchCurrency;
    WCHAR pwcsCurrency[TOKENIZER_MAXBUFFERLIMIT + 10];
    WCHAR* pwcsStr = State.m_pwcsToken + State.m_ulStart;

    if (HAS_PROP_CURRENCY(GET_PROP(State.m_pwcsToken[State.m_ulStart + ulAddToStart])))
    {
        wchCurrency = State.m_pwcsToken[State.m_ulStart + ulAddToStart];
        pwcsStr += 1;
    }
    else if (HAS_PROP_CURRENCY(GET_PROP(State.m_pwcsToken[State.m_ulEnd - 1 - ulDecFromEnd])))
    {
        wchCurrency = State.m_pwcsToken[State.m_ulEnd - 1 - ulDecFromEnd];
    }
    else
    {
        return false;
    }

    ULONG ulOutLen;
    ULONG ulOffsetToTxt;

    if (false == CheckAndCreateNumber(
                                    pwcsStr + ulAddToStart,
                                    State.m_ulEnd - State.m_ulStart - 1 - ulAddToStart - ulDecFromEnd,
                                    pwcsCurrency,
                                    &ulOffsetToTxt,
                                    &ulOutLen))
    {
        return false;
    }

    Assert(ulOffsetToTxt + ulOutLen + 1 < m_ulMaxTokenSize + 4);
    pwcsCurrency[ulOffsetToTxt + ulOutLen] = wchCurrency;
    pwcsCurrency[ulOffsetToTxt + ulOutLen + 1] = L'\0';

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a currency",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputCurrency(ulOutLen+1, pwcsCurrency + ulOffsetToTxt , State, pCliticsTerm);

    return true;
}

bool CTokenizer::VerifyCommersialSign()
{
    CTokenState State(m_pCurToken->m_State);
    CPropFlag   CommPunctTail(COMMERSIAL_SIGN_PUNCT_TAIL);
    CPropFlag   CommPunctHead(COMMERSIAL_SIGN_PUNCT_HEAD);

    if (TEST_PROP(State.m_Properties, (COMMERSIAL_SIGN_PUNCT_TAIL | COMMERSIAL_SIGN_PUNCT_HEAD)))
    {
        ULONG ulCharRemoved = m_pCurToken->RemoveTailPunct(CommPunctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(CommPunctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    if (TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd - 1]),
                  PROP_COMMERSIAL_SIGN))
    {
        //
        // the length of the token must be greater then 1 since it includes an alpha
        // and the commersial sign
        //
        Assert((State.m_ulEnd - State.m_ulStart) > 1);
        OutputCommersialSignToken(State);
        return true;
    }

    return false;
}

void CTokenizer::ProcessDefault()
{
    CTokenState State(m_pCurToken->m_State);

    if (TEST_PROP(State.m_Properties, PROP_DEFAULT_BREAKER))
    {
        if (TEST_PROP(State.m_Properties, PROP_FIRST_LEVEL_BREAKER))
        {
            CPropFlag prop(PROP_FIRST_LEVEL_BREAKER);

            BreakCompundString(State, prop);

            return;
        }

        if (TEST_PROP(State.m_Properties, PROP_SECOND_LEVEL_BREAKER))
        {
            CPropFlag prop(PROP_SECOND_LEVEL_BREAKER);

            BreakCompundString(State, prop);

            return;
        }
    }

    //
    // this is a simple token
    //

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    if (pCliticsTerm == &g_EmptyClitics)
    {
        if (TEST_PROP(State.m_Properties, PROP_NBS))
        {
            CPropFlag prop(PROP_NBS);

            BreakCompundString(State, prop);

            return;
        }

        CPropFlag PunctHead(SIMPLE_PUNCT_HEAD);
        CPropFlag PunctTail(SIMPLE_PUNCT_TAIL);

        if (TEST_PROP(State.m_Properties,
                      (SIMPLE_PUNCT_HEAD | SIMPLE_PUNCT_TAIL)))
        {
            ULONG ulCharRemoved;
            ulCharRemoved= m_pCurToken->RemoveHeadPunct(PunctHead, State);
            ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);

            if ( TEST_PROP(State.m_Properties, PROP_UNDERSCORE) )
            {

                bool hasFrontUnderscore =
                    (State.m_ulStart > m_pCurToken->m_State.m_ulStart) &&
                    TEST_PROP( GET_PROP(State.m_pwcsToken[State.m_ulStart-1]),
                        PROP_UNDERSCORE ) &&
                    TEST_PROP( GET_PROP(State.m_pwcsToken[State.m_ulStart]),
                        PROP_ALPHA_NUMERIC );

                bool hasBackUnderscore =
                    (State.m_ulEnd < m_pCurToken->m_State.m_ulEnd) &&
                    TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd]),
                        PROP_UNDERSCORE) &&
                    TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd-1]),
                        PROP_ALPHA_NUMERIC);

                //
                //  Note: To change the policy to "leave ALL attached underscore
                //  seuences, simply change below condition to:
                //  if ( (hasFrontUnderscore || hasBackUnderscore) )
                //

                if ( (hasFrontUnderscore ^ hasBackUnderscore) )
                {
                    ulCharRemoved -=

                    AddBackUnderscores(
                        State,
                        hasFrontUnderscore,
                        hasBackUnderscore
                        );

                }

            } // if ( TEST_PROP(State.m_Properties, PROP_UNDERSCORE) )

            if (ulCharRemoved)
            {
                m_pCurToken->ComputeStateProperties(State);
            }
        }
    }

    if (State.m_ulEnd == State.m_ulStart)
    {
        //
        // case we remove all chracters in the above statement
        //
        return;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a simple token",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputSimpleToken(State, pCliticsTerm);
}

//
//  CTokenizer::AddBackUnderscores:
//
//  Treat cases of a "simple" token with head and/or tail underscore
//  sequence (consecutive underscores prefix or suffix); those
//  do not get flipped off and remain part of the token.
//  This routine is called after underscore removal, (as a result of
//  Remove[Head|Tail]Punct) and adds them back in.
//
//  return value: Number of underscores added back in.
//
ULONG
CTokenizer::AddBackUnderscores(
    IN CTokenState& State,
    IN bool hasFrontUnderscore,
    IN bool hasBackUnderscore
    )
{
    ULONG ulCharsAdded = 0;

    if ( hasFrontUnderscore )
    {
        // Move left over consecutive underscores
        ulCharsAdded = m_pCurToken->FindLeftmostUnderscore(State);

    }

    if ( hasBackUnderscore )
    {

        // Move right over consecutive underscores
        ulCharsAdded += m_pCurToken->FindRightmostUnderscore(State);

    } // if ( hasFrontUnderscore )

    return ulCharsAdded;

} // CTokenizer::AddBackUnderscores()

void CTokenizer::OutputUrl(CTokenState& State)
{
    HRESULT hr;

    ULONG ulOffsetInTxtSourceBuffer =
                m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    ULONG ulCur = State.m_ulStart;
    ULONG ulStart = ulCur;
    ULONG ulLenInTxtSourceBuffer = 0;
    ULONG ulOffsetDueToAnEscapeChar;

    while (ulCur < State.m_ulEnd)
    {
        ulLenInTxtSourceBuffer++;
        ulOffsetDueToAnEscapeChar = 0;

        if ((State.m_pwcsToken[ulCur] == L'%') &&
            (ulCur <= State.m_ulEnd - 2))
        {
            //
            // replacing escape charaters with real ones.
            //
            if (TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+1]) , PROP_XDIGIT) &&
                TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+2]) , PROP_XDIGIT))
            {
                short sVal;
                sVal = ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 1]);
                sVal *= 16;
                sVal += ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 2]);

                State.m_pwcsToken[ulCur+2] = sVal;
                for (ULONG ul = ulCur -1 ; ul >= ulStart; ul--)
                {
                    State.m_pwcsToken[ul+2] = State.m_pwcsToken[ul];
                }
                ulCur += 2;
                ulStart+=2;
                ulOffsetDueToAnEscapeChar = 2;
                ulLenInTxtSourceBuffer += 2;
            }
            else if ((ulCur <= State.m_ulEnd - 5)                                   &&
                     ((State.m_pwcsToken[ulCur+1] == L'u') ||
                      (State.m_pwcsToken[ulCur+1] == L'U'))                         &&
                     TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+2]) , PROP_XDIGIT)  &&
                     TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+3]) , PROP_XDIGIT)  &&
                     TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+4]) , PROP_XDIGIT)  &&
                     TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+5]) , PROP_XDIGIT))
            {
                short sVal;
                sVal = ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 2]);
                sVal *= 0x1000;
                sVal += ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 3]);
                sVal *= 0x100;
                sVal += ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 4]);
                sVal *= 0x10;
                sVal += ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 5]);

                State.m_pwcsToken[ulCur+5] = sVal;

                for (ULONG ul = ulCur -1 ; ul >= ulStart; ul--)
                {
                    State.m_pwcsToken[ul+5] = State.m_pwcsToken[ul];
                }
                ulCur += 5;
                ulStart+=5;
                ulOffsetDueToAnEscapeChar = 5;
                ulLenInTxtSourceBuffer += 5;
            }
        }

        if ( IS_BREAKER( State.m_pwcsToken[ulCur] ) )
        {
            if (ulCur - ulStart == 0)
            {
                //
                // only punctuation
                //
                ulCur++;
                ulStart = ulCur;
                ulOffsetInTxtSourceBuffer += ulOffsetDueToAnEscapeChar + 1;
                ulLenInTxtSourceBuffer = 0;
                continue;
            }

            hr = m_apWordSink->PutWord(
                                    ulCur - ulStart,
                                    &State.m_pwcsToken[ulStart],
                                    ulLenInTxtSourceBuffer - 1 - ulOffsetDueToAnEscapeChar,
                                    ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

            ulStart = ulCur + 1;
            ulOffsetInTxtSourceBuffer += ulLenInTxtSourceBuffer;
            ulLenInTxtSourceBuffer = 0;

        }
        ulCur++;

    }

    //
    // last word.
    //

    if (ulStart < ulCur)
    {
        hr = m_apWordSink->PutWord(
                            ulCur - ulStart,
                            &State.m_pwcsToken[ulStart],
                            ulLenInTxtSourceBuffer,
                            ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }
}

void CTokenizer::OutputNumbers(
    CTokenState& State,
    ULONG ulLen,
    WCHAR* pwcsNumber,
    const CCliticsTerm* pCliticsTerm)
{
    HRESULT hr;
    //
    // Input: 1.22 Output: 1.22, NN1D22
    //

    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    if (ulLen > m_ulMaxTokenSize)
    {
        hr = m_apWordSink->PutWord(
                        State.m_ulEnd - State.m_ulStart,
                        &State.m_pwcsToken[State.m_ulStart],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }
        return;
    }

    hr = m_apWordSink->PutAltWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pCliticsTerm->ulLen,
                        State.m_pwcsToken + State.m_ulStart + pCliticsTerm->ulLen,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pCliticsTerm->ulLen,
                        State.m_pwcsToken + State.m_ulStart,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    ulLen,
                    pwcsNumber,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }


}

void CTokenizer::OutputParens(CTokenState& State)
{
    HRESULT hr;
    //
    // format is xxx(s)
    // Input: xxx(s) Output: xxx
    //

    State.m_pwcsToken[State.m_ulEnd - 3] = L'\0';

    hr = m_apWordSink->PutWord(
                State.m_ulEnd - 3 - State.m_ulStart,
                &State.m_pwcsToken[State.m_ulStart],
                State.m_ulEnd - State.m_ulStart,
                m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State));
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

void CTokenizer::OutputAcronym(CTokenState& State, const CCliticsTerm* pCliticsTerm)
{
    HRESULT hr;
    //
    // Input: I.B.M Output: I.B.M, IBM
    //

    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;

    }

    hr = m_apWordSink->PutAltWord(
                State.m_ulEnd - ulDecFromEnd - (State.m_ulStart + ulAddToStart),
                State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                State.m_ulEnd - State.m_ulStart,
                ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

    ULONG ulCur = State.m_ulStart + ulAddToStart;
    ULONG ulNext = ulCur;

    while (ulCur < State.m_ulEnd)
    {
        if (!HAS_PROP_PERIOD(GET_PROP(State.m_pwcsToken[ulCur])))
        {
            State.m_pwcsToken[ulNext] = State.m_pwcsToken[ulCur];
            ulNext++;
            ulCur++;
            continue;
        }
        ulCur++;
    }

    if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        ulNext - (State.m_ulStart + ulAddToStart),
                        State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }


    hr = m_apWordSink->PutWord(
                    ulNext - ulDecFromEnd - (State.m_ulStart + ulAddToStart),
                    State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

void CTokenizer::OutputAbbreviation(CTokenState& State)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    hr = m_apWordSink->PutAltWord(
                State.m_ulEnd - State.m_ulStart - 1,
                &State.m_pwcsToken[State.m_ulStart],
                State.m_ulEnd - State.m_ulStart,
                ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

void CTokenizer::OutputSpecialAbbreviation(
    CTokenState& State,
    CAbbTerm* pTerm,
    const CCliticsTerm* pCliticsTerm)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    WCHAR* pwcsAbb = pTerm->pwcsAbb;
    ULONG  ulLen = pTerm->ulAbbLen;

    if (pTerm->pwcsCanonicalForm)
    {
        pwcsAbb = pTerm->pwcsCanonicalForm;
        ulLen = pTerm->ulCanLen;
    }

    if (TAIL_MATCH_TRUNCATE == pCliticsTerm->ulOp)
    {
        WCHAR pwcs[TOKENIZER_MAXBUFFERLIMIT];
        
        int iCount;
        iCount = _snwprintf(
                pwcs,
                TOKENIZER_MAXBUFFERLIMIT,
                L"%s%s",
                pwcsAbb,
                pCliticsTerm->pwcs);

        Assert(iCount < TOKENIZER_MAXBUFFERLIMIT);
        
        pwcs[TOKENIZER_MAXBUFFERLIMIT - 1] = L'\0';
        hr = m_apWordSink->PutAltWord(
                        ulLen + pCliticsTerm->ulLen,
                        pwcs,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    ulLen,
                    pwcsAbb,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

void CTokenizer::OutputHyphenation(CTokenState& State, const CCliticsTerm* pCliticsTerm)
{
    //
    // Input: Data-Base Output Data Base, DataBase (only in query time)
    //
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }

    ULONG ulCur = State.m_ulStart + ulAddToStart;
    ULONG ulStart = ulCur;
    ULONG ulRelPosInTxtSrcBuff = ulOffsetInTxtSourceBuffer;

    if (m_bQueryTime)
    {
        ULONG ulNext = ulCur;
        hr = m_apWordSink->StartAltPhrase();
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        ULONG ulAdd = ulAddToStart;
        while (ulCur < State.m_ulEnd)
        {
            if ( HAS_PROP_DASH(GET_PROP(m_pCurToken->m_State.m_pwcsToken[ulCur])))
            {
                hr = m_apWordSink->PutWord(
                                ulNext - ulStart,
                                &State.m_pwcsToken[ulStart],
                                ulNext - ulStart + ulAdd,
                                ulRelPosInTxtSrcBuff);
                if (FAILED(hr))
                {
                    THROW_HRESULT_EXCEPTION(hr);
                }

                ulRelPosInTxtSrcBuff += ulNext - ulStart + 1 + ulAdd;
                ulStart = ulNext;
                ulCur++;
                ulAdd = 0;
                continue;
            }

            State.m_pwcsToken[ulNext] = State.m_pwcsToken[ulCur];
            ulNext++;
            ulCur++;
        }

        Assert(ulCur > ulStart);

        if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            hr = m_apWordSink->PutAltWord(
                            ulNext - ulStart,
                            &State.m_pwcsToken[ulStart],
                            ulNext - ulStart,
                            ulRelPosInTxtSrcBuff);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

        }

        hr = m_apWordSink->PutWord(
                        ulNext - ulStart - ulDecFromEnd,
                        &State.m_pwcsToken[ulStart],
                        ulNext - ulStart,
                        ulRelPosInTxtSrcBuff);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        hr = m_apWordSink->StartAltPhrase();
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            hr = m_apWordSink->PutAltWord(
                    ulNext - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart - ulAddToStart,
                    ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

        }

        hr = m_apWordSink->PutWord(
                        ulNext - State.m_ulStart - ulDecFromEnd - ulAddToStart,
                        State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                        State.m_ulEnd - State.m_ulStart + ulAddToStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        hr = m_apWordSink->EndAltPhrase();
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }
    else
    {
       ULONG ulAdd = ulAddToStart;

        while (ulCur < State.m_ulEnd)
        {
            if (HAS_PROP_DASH(GET_PROP(m_pCurToken->m_State.m_pwcsToken[ulCur])))
            {
                hr = m_apWordSink->PutWord(
                                ulCur - ulStart,
                                &State.m_pwcsToken[ulStart],
                                ulCur - ulStart + ulAdd,
                                ulRelPosInTxtSrcBuff);
                if (FAILED(hr))
                {
                    THROW_HRESULT_EXCEPTION(hr);
                }

                ulRelPosInTxtSrcBuff += ulCur - ulStart + 1 + ulAdd;
                ulStart = ulCur + 1;
                ulAdd = 0;
            }
            ulCur++;
        }

        Assert(ulCur > ulStart);

        if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            hr = m_apWordSink->PutAltWord(
                            ulCur - ulStart,
                            &State.m_pwcsToken[ulStart],
                            ulCur - ulStart,
                            ulRelPosInTxtSrcBuff);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

        }

        hr = m_apWordSink->PutWord(
                        ulCur - ulStart - ulDecFromEnd,
                        &State.m_pwcsToken[ulStart],
                        ulCur - ulStart,
                        ulRelPosInTxtSrcBuff);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }
    }
}

void CTokenizer::OutputTime(WCHAR* pwcsTime, CTokenState& State)
{
    HRESULT hr;
    //
    // Output: TT1353
    //

    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    hr = m_apWordSink->PutAltWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }


    hr = m_apWordSink->PutWord(
                    6,
                    pwcsTime,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }
}

void CTokenizer::OutputDate(
    WCHAR* pwcsDate1,
    WCHAR* pwcsDate2,
    CTokenState& State)
{
    HRESULT hr;
    //
    // Output: DD19990921
    //

    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);
    hr = m_apWordSink->PutAltWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }


    if (pwcsDate2)
    {
        hr = m_apWordSink->PutAltWord(
                        10,
                        pwcsDate2,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    10,
                    pwcsDate1,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

void CTokenizer::OutputSimpleToken(CTokenState& State, const CCliticsTerm* pTerm)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    if (((TAIL_MATCH_TRUNCATE == pTerm->ulOp) ||
        (HEAD_MATCH_TRUNCATE == pTerm->ulOp)) && 
        (State.m_ulStart + pTerm->ulLen <  State.m_ulEnd))
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart,
                        &State.m_pwcsToken[State.m_ulStart],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }


        if (pTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            hr = m_apWordSink->PutWord(
                            State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                            &State.m_pwcsToken[State.m_ulStart],
                            State.m_ulEnd - State.m_ulStart,
                            ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

        }
        else
        {
            Assert(pTerm->ulOp == HEAD_MATCH_TRUNCATE);
            hr = m_apWordSink->PutWord(
                            State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                            &State.m_pwcsToken[State.m_ulStart + pTerm->ulLen],
                            State.m_ulEnd - State.m_ulStart,
                            ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }
        }

        return;
    }

    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State));
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}


void CTokenizer::OutputCurrency(
    ULONG ulLen,
    WCHAR* pwcsCurrency,
    CTokenState& State,
    const CCliticsTerm* pTerm)
{
    HRESULT hr;
    //
    // Output: CC12.22$
    //

    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    if (ulLen > m_ulMaxTokenSize)
    {
        hr = m_apWordSink->PutWord(
                        State.m_ulEnd - State.m_ulStart,
                        &State.m_pwcsToken[State.m_ulStart],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }
        return;
    }

    hr = m_apWordSink->PutAltWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }


    if (pTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                        &State.m_pwcsToken[State.m_ulStart],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }
    else if (pTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                        &State.m_pwcsToken[State.m_ulStart + pTerm->ulLen],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    ulLen,
                    pwcsCurrency,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }


}

void CTokenizer::OutputCommersialSignToken(
	CTokenState& State)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);
    hr = m_apWordSink->PutAltWord(
                    State.m_ulEnd - State.m_ulStart - 1,
                    State.m_pwcsToken + State.m_ulStart,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart,
                    State.m_pwcsToken + State.m_ulStart,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }
	
}

void CTokenizer::OutputMisc(
    CTokenState& State,
    bool bPatternContainOnlyUpperCase,
    ULONG ulSuffixSize,
    const CCliticsTerm* pCliticsTerm)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;


    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pCliticsTerm->ulLen,
                        State.m_pwcsToken + State.m_ulStart + pCliticsTerm->ulLen,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pCliticsTerm->ulLen,
                        State.m_pwcsToken + State.m_ulStart,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        ulDecFromEnd = pCliticsTerm->ulLen;
    }

    if (!bPatternContainOnlyUpperCase)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - ulAddToStart - ulDecFromEnd - ulSuffixSize,
                        State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

#define NUMBER_NO_ERROR 0
#define NUMBER_SEPERATOR_ERROR 1
#define NUMBER_ERROR 2

bool CTokenizer::CheckAndCreateNumber(
    WCHAR* pwcsStr,
    ULONG ulLen,
    WCHAR* pwcsOut,
    ULONG* pulOffsetToTxt,   // the actual output does not always start at the beginning of buffer
    ULONG* pulOutLen)
{

    int iRet;

    iRet = CheckAndCreateNumber(
                        pwcsStr,
                        ulLen,
                        m_apLangSupport->GetDecimalSeperator(),
                        m_apLangSupport->GetThousandSeperator(),
                        pwcsOut,
                        pulOffsetToTxt,
                        pulOutLen);
    if (NUMBER_NO_ERROR == iRet)
    {
        return true;
    }
    else if (NUMBER_ERROR == iRet)
    {
        return false;
    }

    iRet = CheckAndCreateNumber(
                        pwcsStr,
                        ulLen,
                        L'.',  // default value
                        0xFFFF, // no thousand sperator
                        pwcsOut,
                        pulOffsetToTxt,
                        pulOutLen);
    if (NUMBER_NO_ERROR == iRet)
    {
        return true;
    }

    return false;
}


//
//  return value:
//  NUMBER_NO_ERROR - success
//  NUMBER_SEPERATOR_ERROR - error due to sperators
//  NUMBER_ERROR - error since it's not a number.
//

int CTokenizer::CheckAndCreateNumber(
    WCHAR* pwcsStr,
    ULONG ulLen,
    WCHAR wchSDecimal,
    WCHAR wchSThousand,
    WCHAR* pwcsOut,
    ULONG* pulOffsetToTxt,   // the actual output does not always start at the beginning of buffer
    ULONG* pulOutLen)
{
    Assert(ulLen > 0);
    //
    // assumes that the out buffer is big enough.
    // looking for the following formats: 1111 1111.2222 1,111,111.222
    //

    ULONG ulCur = ulLen - 1;
    ULONG ulNumCharsBeforDigitSeperator = 0;
    ULONG ulNextChar = ulLen - 1 + 3;  // +3 is for the NN at the begging of the formated token +
                                       // additional 0 in the begining in case  .50

    bool fHasFraction = false;

    while ((((int)(ulCur)) >= 0) &&
           HAS_PROP_NUMBER(GET_PROP(pwcsStr[ulCur])))
    {
        pwcsOut[ulNextChar] = pwcsStr[ulCur];
        ulCur--;
        ulNextChar--;
        ulNumCharsBeforDigitSeperator++;
    }

    if (ulCur == ulLen - 1)
    {
        //
        // did not read any digits.
        //
        return NUMBER_ERROR;
    }

    if ((((int)ulCur) >= 0) && (pwcsStr[ulCur] == wchSDecimal))
    {
        fHasFraction = true;
        pwcsOut[ulNextChar] = L'D';
        ulCur--;
        ulNextChar--;
        ulNumCharsBeforDigitSeperator = 0;
    }

    ULONG ulNumOfThousandSeperator = 0;
    while (((int)ulCur) >= 0)
    {
        if (pwcsStr[ulCur] == wchSThousand)
        {
            if (3 != ulNumCharsBeforDigitSeperator)
            {
                return NUMBER_SEPERATOR_ERROR;
            }
            ulNumCharsBeforDigitSeperator = 0;
            ulNumOfThousandSeperator++;
        }
        else if(HAS_PROP_NUMBER(GET_PROP(pwcsStr[ulCur])))
        {
            pwcsOut[ulNextChar] = pwcsStr[ulCur];
            ulNumCharsBeforDigitSeperator++;
            ulNextChar--;
        }
        else
        {
            if (TEST_PROP(
                    GET_PROP(pwcsStr[ulCur]), PROP_DEFAULT_BREAKER))
            {
                return NUMBER_SEPERATOR_ERROR;
            }

            return NUMBER_ERROR;
        }

        ulCur--;
    }

    *pulOutLen = ulLen;

    if (L'D' == pwcsOut[ulNextChar+1])
    {
        Assert(ulNextChar >= 2);
        //
        // the number has the following format .50
        //
        pwcsOut[ulNextChar] = L'0';
        ulNextChar--;
        *pulOutLen += 1;
    }

    Assert(ulNextChar >= 1);
    pwcsOut[ulLen + 3] = L'\0';
    pwcsOut[ulNextChar] = L'N';
    pwcsOut[ulNextChar - 1] = L'N';

    *pulOutLen = *pulOutLen + 2 - ulNumOfThousandSeperator; // don't use += because 2 - ulNextChar + 1
    *pulOffsetToTxt = ulNextChar - 1;
                                                            // can be negative and since it is ULONG we
                                                            // can get the wrong result.
    if (fHasFraction)
    {
        while (HAS_PROP_NUMBER(GET_PROP(pwcsOut[*pulOutLen + *pulOffsetToTxt - 1])) &&
               (0 == ConvertCharToDigit(pwcsOut[*pulOutLen + *pulOffsetToTxt - 1])))
        {
            Assert(*pulOutLen > 3);
            (*pulOutLen)--;
        }

        if (L'D' == pwcsOut[*pulOutLen + *pulOffsetToTxt - 1])
        {
            (*pulOutLen)--;
        }
    }
    return NUMBER_NO_ERROR;
}



void CTokenizer::GetValuesFromDateString(
    CDateTerm* pFormat,
    WCHAR* pwcsDate,
    LONG* plD_M1,     // we can't tell in this stage whether this is a Day or a month.
    LONG* plD_M2,
    LONG* plYear)
{
    BYTE i;
    int iBase;

    *plD_M1 = 0;
    for ( i = pFormat->bD_M1Len, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plD_M1 += ConvertCharToDigit(pwcsDate[pFormat->bD_M1Offset + i - 1]) * iBase;
    }

    *plD_M2 = 0;
    for ( i = pFormat->bD_M2Len, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plD_M2 += ConvertCharToDigit(pwcsDate[pFormat->bD_M2Offset + i - 1]) * iBase;
    }

    *plYear = 0;
    for ( i = pFormat->bYearLen, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plYear += ConvertCharToDigit(pwcsDate[pFormat->bYearOffset + i - 1]) * iBase;
    }

}

void CTokenizer::GetValuesFromTimeString(
    CTimeTerm* pFormat,
    WCHAR* pwcsTime,
    LONG* plHour,
    LONG* plMin,
    LONG* plSec,
    TimeFormat* pAmPm)
{
    BYTE i;
    int iBase;

    *plHour = 0;
    for ( i = pFormat->bHourLen, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plHour += ConvertCharToDigit(pwcsTime[pFormat->bHourOffset + i - 1]) * iBase;
    }

    *plMin = 0;
    for ( i = pFormat->bMinLen, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plMin += ConvertCharToDigit(pwcsTime[pFormat->bMinOffset + i - 1]) * iBase;
    }

    *plSec = 0;
    for ( i = pFormat->bSecLen, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plSec += ConvertCharToDigit(pwcsTime[pFormat->bSecOffset + i - 1]) * iBase;
    }

    *pAmPm = pFormat->AmPm;

}

void CTokenizer::BreakCompundString(CTokenState& State, CPropFlag& propBreaker)
{
    //
    // still there are puctutaitons inside the token
    // we break them up and resubmit them.
    //
    ULONG ulStart = State.m_ulStart;
    ULONG ulCur = ulStart;

    while (ulCur < State.m_ulEnd)
    {
        if ( TEST_PROP1(GET_PROP(State.m_pwcsToken[ulCur]), propBreaker))
        {
            if (ulCur - ulStart == 0)
            {
                //
                // only punctuation
                //
                ulCur++;
                ulStart = ulCur;
                continue;
            }

            m_pCurToken->m_State.m_ulStart = 0;
            m_pCurToken->m_State.m_ulEnd = ulCur - ulStart;
             m_pCurToken->m_State.m_pwcsToken = State.m_pwcsToken + ulStart;
            m_pCurToken->ComputeStateProperties(m_pCurToken->m_State);
            //
            // we just created a sub token need to procces it
            //

            ProcessTokenInternal();
            ulStart = ulCur + 1;

        }
        ulCur++;
    }

    if (ulStart < ulCur)
    {
        //
        // last sub token
        //
        m_pCurToken->m_State.m_ulStart = 0;
        m_pCurToken->m_State.m_ulEnd = ulCur - ulStart;
        m_pCurToken->m_State.m_pwcsToken = State.m_pwcsToken + ulStart;
        m_pCurToken->ComputeStateProperties(m_pCurToken->m_State);
        //
        // we just created a sub token need to procces it
        //

        ProcessTokenInternal();
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\tokenizer.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Tokenizer.h
//  Purpose  :  Tokenizer declerations
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      Jan 06 2000 yairh creation
//      Apr 05 2000 dovh - Fixed two problematic debug / tracer buffer size
//          problems.  (Fix Bug 15449).
//      May 07 2000 dovh - USE_WS_SENTINEL algorithm in BreakText
//      Nov 11 2000 dovh - Special underscore treatment
//          Added inline support routines (FindLeftmostUnderscore etc.)
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _TOKENIZER_H_
#define _TOKENIZER_H_

#include "tracer.h"
#include "PropArray.h"
#include "Query.h"
#include "stdafx.h"
#include "cierror.h"
#include "LangSupport.h"
#include "Formats.h"

#define TOKENIZER_MAXBUFFERLIMIT 1024 // max size of a token is 1024 chars

DECLARE_TAG(s_tagTokenizer, "Tokenizer");
DECLARE_TAG(s_tagTokenizerOutput, "Tokenizer Output");
DECLARE_TAG(s_tagTokenizerTrace, "Tokenizer Trace");
DECLARE_TAG(s_tagTokenizerDecision, "Tokenizer Decision");
DECLARE_TAG(s_tagTokenizerSuspect, "Tokenizer Suspect");

#if defined(DEBUG)
///////////////////////////////////////////////////////////////////////////////
// Class CTraceWordSink
///////////////////////////////////////////////////////////////////////////////
class CTraceWordSink : public IWordSink
{
public:
    CTraceWordSink(IWordSink* p) : m_apWordSink(p)
    {
    }

    ULONG __stdcall AddRef()
    {
        return 1;
    }

    ULONG __stdcall Release()
    {
        return 0;
    }

    STDMETHOD(QueryInterface)(
        IN  REFIID  riid,
        IN  void    **ppvObject)
    {
        Assert(false);
        return E_FAIL;
    }

    STDMETHOD(PutWord)(
                ULONG cwc,
                WCHAR const* pwcInBuf,
                ULONG cwcSrcLen,
                ULONG cwcSrcPos)
    {
        Assert(cwc < TOKENIZER_MAXBUFFERLIMIT + 10);
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
        if (CheckTraceRestrictions(elVerbose, s_tagTokenizerOutput))
        {
            Trace(
                elVerbose,
                s_tagTokenizerOutput,
                ("PutWord: %*.*S, %d, %d, %d", 
                cwc,
                cwc,
                pwcInBuf,
                cwc, 
                cwcSrcLen, 
                cwcSrcPos));
        }
#endif

        return m_apWordSink->PutWord(cwc, pwcInBuf, cwcSrcLen, cwcSrcPos);
    }

    STDMETHOD(PutAltWord)(
                ULONG cwc,
                WCHAR const* pwcInBuf,
                ULONG cwcSrcLen,
                ULONG cwcSrcPos)
    {
        Assert(cwc < TOKENIZER_MAXBUFFERLIMIT + 10);
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
        if (CheckTraceRestrictions(elVerbose, s_tagTokenizerOutput))
        {
            Trace(
                elVerbose,
                s_tagTokenizerOutput,
                ("PutAltWord: %*.*S, %d, %d, %d", 
                cwc,
                cwc,
                pwcInBuf,
                cwc, 
                cwcSrcLen, 
                cwcSrcPos));
        }
#endif
        return m_apWordSink->PutAltWord(cwc, pwcInBuf, cwcSrcLen, cwcSrcPos);
    }

    STDMETHOD(StartAltPhrase)()
    {
        Trace(
            elVerbose,
            s_tagTokenizerOutput,
            ("StartAltPhrase"));

        return m_apWordSink->StartAltPhrase();
    }

    STDMETHOD(EndAltPhrase)()
    {
        Trace(
            elVerbose,
            s_tagTokenizerOutput,
            ("EndAltPhrase"));

        return m_apWordSink->EndAltPhrase();
    }

    STDMETHOD(PutBreak)(WORDREP_BREAK_TYPE breakType)
    {
        WCHAR* p;
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
        if (CheckTraceRestrictions(elVerbose, s_tagTokenizerOutput))
        {
            switch (breakType)
            {
            case WORDREP_BREAK_EOW:
                p = L"WORDREP_BREAK_EOW";
                break;
            case WORDREP_BREAK_EOS:
                p = L"WORDREP_BREAK_EOS";
                break;
            case WORDREP_BREAK_EOP:
                p = L"WORDREP_BREAK_EOP";
                break;
            case WORDREP_BREAK_EOC:
                p = L"WORDREP_BREAK_EOC";
                break;
            default:
                p = L"Unknown break type";
            }
            Trace(
                elVerbose,
                s_tagTokenizerOutput,
                ("PutBreak %S", p));
        }
#endif
        return m_apWordSink->PutBreak(breakType);
    }

    CTraceWordSink* operator ->()
    {
        return this;
    }
private:
    CComPtr<IWordSink> m_apWordSink;
};
#endif

///////////////////////////////////////////////////////////////////////////////
// Class CTokenState
///////////////////////////////////////////////////////////////////////////////

class CTokenState
{
public:
    //
    // methods
    //

    CTokenState();
    CTokenState(CTokenState& s);

    CTokenState& operator = (CTokenState& S);

    void Clear(ULONG ulEnd);

public:
    //
    // members
    //

    ULONG m_ulStart;
    ULONG m_ulEnd;
    CPropFlag m_Properties;
    WCHAR* m_pwcsToken;
};

inline CTokenState::CTokenState() : m_ulStart(0), m_ulEnd(0)
{
}

inline CTokenState::CTokenState(CTokenState& s) :
    m_ulStart(s.m_ulStart),
    m_ulEnd(s.m_ulEnd),
    m_pwcsToken(s.m_pwcsToken),
    m_Properties(s.m_Properties)
{
}

inline CTokenState& CTokenState::operator = (CTokenState& S)
{
    m_ulStart = S.m_ulStart;
    m_ulEnd = S.m_ulEnd;
    m_Properties = S.m_Properties;
    m_pwcsToken = S.m_pwcsToken;

    return *this;
}

inline void CTokenState::Clear(ULONG ulEnd)
{
    m_ulStart = 0;
    m_ulEnd = ulEnd;
    m_Properties.Clear();
    m_pwcsToken = NULL;
}


///////////////////////////////////////////////////////////////////////////////
// Class CToken
///////////////////////////////////////////////////////////////////////////////

class CToken
{
public:
    //
    // methods
    //

    CToken(ULONG ulMaxTokenSize);

    bool IsNotEmpty();
    void Clear();
    bool IsFull();
    void MarkEndToken(ULONG ulCurPosInTxtSourceBuffer);
    ULONG RemoveHeadPunct(CPropFlag& PunctProperties, CTokenState& State);
    ULONG RemoveTailPunct(CPropFlag& PunctProperties, CTokenState& State);
    void ComputeStateProperties(CTokenState& State);
    ULONG CalculateStateOffsetInTxtSourceBuffer(CTokenState& State);

    ULONG FindLeftmostUnderscore(CTokenState& State);
    ULONG FindRightmostUnderscore(CTokenState& State);

public:
    //
    // members
    //
    ULONG m_ulBufPos;
    bool m_fHasEos;
    ULONG m_ulOffsetInTxtSourceBuffer;

    ULONG m_ulMaxTokenSize;

    CTokenState m_State;

    WCHAR m_awchBuf[TOKENIZER_MAXBUFFERLIMIT + 1];

};

inline CToken::CToken(ULONG ulMaxTokenSize) :
    m_ulBufPos(0),
    m_fHasEos(false),
    m_ulOffsetInTxtSourceBuffer(0),
    m_ulMaxTokenSize(ulMaxTokenSize)
{
    m_awchBuf[0] = L'\0';
}

inline bool CToken::IsNotEmpty()
{
    return (m_ulBufPos > 0);
}

inline void CToken::Clear()
{
    m_ulBufPos = 0;
    m_awchBuf[0] = L'\0';
    m_State.Clear(0);
    m_fHasEos = false;
    m_ulOffsetInTxtSourceBuffer = 0;
}


inline bool CToken::IsFull()
{
    return (m_ulBufPos == m_ulMaxTokenSize);
}

inline void CToken::MarkEndToken(ULONG ulCurPosInTxtSourceBuffer)
{
    Assert(m_ulBufPos < m_ulMaxTokenSize + 1);
    m_awchBuf[m_ulBufPos] = L'\0';
    m_State.m_pwcsToken = m_awchBuf;
    m_State.m_ulStart = 0;
    m_State.m_ulEnd = m_ulBufPos;


    if (TEST_PROP(m_State.m_Properties, PROP_EOS) &&
        (m_ulBufPos < m_ulMaxTokenSize))
    {
        ULONG ulCur = m_State.m_ulEnd - 1;

        while (TEST_PROP(GET_PROP(m_awchBuf[ulCur]), EOS_SUFFIX))
        {
            ulCur--;
        }

        if (IS_EOS(m_awchBuf[ulCur]))
        {
            m_fHasEos = true;
        }
    }

    Assert(ulCurPosInTxtSourceBuffer >= m_ulBufPos);

    m_ulOffsetInTxtSourceBuffer = ulCurPosInTxtSourceBuffer - m_ulBufPos;
}

inline ULONG CToken::CalculateStateOffsetInTxtSourceBuffer(CTokenState& State)
{
    ULONG ulOffset =
        m_ulOffsetInTxtSourceBuffer +
        (State.m_pwcsToken - m_awchBuf) +
        State.m_ulStart;

    return ulOffset;
}

inline ULONG CToken::RemoveHeadPunct(CPropFlag& PunctProperties, CTokenState& State)
{
    Assert(m_State.m_ulStart <= State.m_ulStart);
    Assert(State.m_ulStart <= State.m_ulEnd);
    Assert(State.m_ulEnd <= m_State.m_ulEnd);

    for (ULONG ul = State.m_ulStart; ul < State.m_ulEnd; ul++)
    {
        if (!TEST_PROP1(GET_PROP(State.m_pwcsToken[ul]), PunctProperties) )
        {
            break;
        }
    }
    State.m_ulStart = ul;

    //
    // return num of characters removed
    //
    return ul;
}

inline ULONG CToken::RemoveTailPunct(CPropFlag& PunctProperties, CTokenState& State)
{
    Assert(m_State.m_ulStart <= State.m_ulStart);
    Assert(State.m_ulStart <= State.m_ulEnd);
    Assert(State.m_ulEnd <= m_State.m_ulEnd);

    for (ULONG ul = State.m_ulEnd; ul > State.m_ulStart; ul--)
    {
        if (!TEST_PROP1(GET_PROP(State.m_pwcsToken[ul - 1]), PunctProperties) )
        {
            break;
        }
    }

    ULONG ulNumOfRemovedChars = State.m_ulEnd - ul;
    State.m_ulEnd = ul;

    return ulNumOfRemovedChars;
}


inline void CToken::ComputeStateProperties(CTokenState& State)
{
    Assert(m_State.m_ulStart <= State.m_ulStart);
    Assert(State.m_ulStart <= State.m_ulEnd);
    Assert(State.m_ulEnd <= m_State.m_ulEnd);

    State.m_Properties.Clear();

    for (ULONG ul = State.m_ulStart; ul < State.m_ulEnd; ul++)
    {
        State.m_Properties |= GET_PROP(State.m_pwcsToken[ul]);
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//  Support routines for UNDERSCORE '_' treatment.
//
//  Current algorithm has the following behavior for tokens containing
//  ALPHANUMERIC characters and UNDERSCORES:
//
//  1.  Single underscores and consecutive underscore sequence surrounded by
//      alphanumeric characters (IE underscores buried within words) are
//      treated as alphanumeric characters, and do not break words, or get
//      omitted.  Examples: Foo_Bar => Foo_Bar, and X___Y => X___Y
//
//  2.  An underscore / underscore sequence tacked to the right (left) end
//      end of an alphanumeric (+ embedded underscores) token, will be part of
//      the token, as long as the sequence is attacked only to one side of the
//      alphanumeric token.  If there are BOTH header and trailer consecutive
//      underscore sequences, both header & trailer sequence will be omitted.
//      Examples: __Foo_Bar => __Foo_Bar , alpha_beta_ => alpha_beta_ ,
//      __HEADERFILE__ => __HEADERFILE__ , __MY_FILE_H__ => MY_FILE_H
//
//  3.  Caveat: Note that other than the two rules stated above underscores are
//      NOT treated as ALPHANUMERIC characters. he behavior on a mixed sequence
//      of underscores, and other  non-alphanumeric characters is undefined!
//
////////////////////////////////////////////////////////////////////////////////

//
//  Assumes: on entry State.m_ulStart is the first alphanumeric in token
//  returns: num of underscores scanned
//
inline ULONG
CToken::FindLeftmostUnderscore(CTokenState& State)
{
    Assert(m_State.m_ulStart < State.m_ulStart);
    Assert(State.m_ulStart <= State.m_ulEnd);
    Assert(State.m_ulEnd <= m_State.m_ulEnd);
    Assert( TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulStart-1]), PROP_UNDERSCORE) );

    ULONG ulNumUnderscores = 0;

    for (ULONG ul = State.m_ulStart;
        (ul > m_State.m_ulStart) &&
            (TEST_PROP(GET_PROP(State.m_pwcsToken[ul-1]), PROP_UNDERSCORE) );
        ul--)
        ;

    ulNumUnderscores = State.m_ulStart - ul;

    State.m_ulStart = ul;

    //
    // return num of underscores scanned
    //
    return (ulNumUnderscores);

} // CToken::FindLeftmostUnderscore

//
//  Assumes: on entry State.m_ulEnd is the last alphanumeric in token
//  returns: num of underscores scanned
//
inline ULONG
CToken::FindRightmostUnderscore(CTokenState& State)
{
    Assert(m_State.m_ulStart <= State.m_ulStart);
    Assert(State.m_ulStart <= State.m_ulEnd);
    Assert(State.m_ulEnd < m_State.m_ulEnd);
    Assert( TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd]), PROP_UNDERSCORE) );

    ULONG ulNumUnderscores = 0;

    for (ULONG ul = State.m_ulEnd;
        (ul < m_State.m_ulEnd) &&
            (TEST_PROP(GET_PROP(State.m_pwcsToken[ul]), PROP_UNDERSCORE) );
        ul++)
        ;

    ulNumUnderscores = ul - State.m_ulEnd;

    State.m_ulEnd = ul;

    //
    // return num of underscores scanned
    //
    return (ulNumUnderscores);

} // CToken::FindRightmostUnderscore


///////////////////////////////////////////////////////////////////////////////
// Class CTokenizer
///////////////////////////////////////////////////////////////////////////////

class CTokenizer
{
public:

    CTokenizer(
        TEXT_SOURCE* pTxtSource,
        IWordSink   * pWordSink,
        IPhraseSink * pPhraseSink,
        LCID lcid,
        BOOL bQueryTime,
        ULONG ulMaxTokenSize);


    // destructor frees the passed buffer, if it exists
    virtual ~CTokenizer(void)
    {
    }

    void BreakText();

protected:

    //
    // methods
    //

    void ProcessToken();
    void ProcessTokenInternal();
    void BreakCompundString(CTokenState& State, CPropFlag& prop);

    HRESULT FillBuffer();
    void CalculateUpdateEndOfBuffer();

    bool CheckAndCreateNumber(
                         WCHAR* pwcsStr,
                         ULONG ulLen,
                         WCHAR* pwcsOut,
                         ULONG* pulOffsetToTxt,
                         ULONG* pulOutLen);

    int CheckAndCreateNumber(
                         WCHAR* pwcsStr,
                         ULONG ulLen,
                         WCHAR wchSDecimal,
                         WCHAR wchSThousand,
                         WCHAR* pwcsOut,
                         ULONG* pulOffsetToTxt,
                         ULONG* pulOutLen);

    short ConvertHexCharToNumber(WCHAR wch);
    void GetValuesFromDateString(
        CDateTerm* pFormat,
        WCHAR* pwcsDate,
        LONG* plD_M1,     // we can't tell in this stage whether this is a Day or a month.
        LONG* plD_M2,
        LONG* plYear);

    void GetValuesFromTimeString(
        CTimeTerm* pFormat,
        WCHAR* pwcsTime,
        LONG* plHour,
        LONG* plMin,
        LONG* plSec,
        TimeFormat* pAmPm);

    LONG ConvertCharToDigit(WCHAR wch);
#ifdef DEBUG
    void TraceToken();
#endif DEBUG

    bool VerifyAlphaUrl();
    bool VerifyWwwUrl();
    bool VerifyAcronym();
    bool VerifyAbbreviation();
    bool VerifySpecialAbbreviation();
    bool VerifyHyphenation();
    bool VerifyParens();
    const CCliticsTerm* VerifyClitics(CTokenState& State);
    bool VerifyNumber(CTokenState& State);
    bool VerifyNumberOrTimeOrDate();
    bool VerifyTime(CTokenState& State);
    bool VerifyDate(CTokenState& State);
    bool VerifyCurrency();
    bool VerifyMisc();
    bool VerifyCommersialSign();

    void ProcessDefault();

    ULONG
    AddBackUnderscores(
        IN CTokenState& State,
        IN bool hasFrontUnderscore,
        IN bool hasBackUnderscore
        );
    bool CheckAndRemoveOneSidedUnderscores(CTokenState& State);

    void OutputUrl(
                CTokenState& State);
    void OutputAcronym(
                CTokenState& State,
                const CCliticsTerm* pCliticsTerm);
    void OutputAbbreviation(
                CTokenState& State);
    void OutputSpecialAbbreviation(
                CTokenState& State,
                CAbbTerm* pTerm,
                const CCliticsTerm* pCliticsTerm);
    virtual void OutputHyphenation(
                CTokenState& State,
                const CCliticsTerm* pCliticsTerm);
    void OutputParens(
                CTokenState& State);
    void OutputNumbers(
                CTokenState& State,
                ULONG ulLen,
                WCHAR* pwcsNumber,
                const CCliticsTerm* pCliticsTerm);
    void OutputTime(
                WCHAR* pwcsTime,
                CTokenState& State);
    void OutputDate(
                WCHAR* pwcsDate1,
                WCHAR* pwcsDate2,
                CTokenState& State);
    virtual void OutputSimpleToken(
                CTokenState& State,
                const CCliticsTerm* pTerm);
    void OutputCurrency(
                ULONG ulLen,
                WCHAR* pwcsCurrency,
                CTokenState& State,
                const CCliticsTerm* pTerm);
    void OutputMisc(
                CTokenState& State,
                bool bPatternContainOnlyUpperCase,
                ULONG ulSuffixSize,
                const CCliticsTerm* pCliticsTerm);
    void OutputCommersialSignToken(CTokenState& State);

    //
    // members
    //

    LCID m_Lcid;
    CAutoClassPointer<CLangSupport> m_apLangSupport;

    CToken* m_pCurToken;
    CToken m_Token;

#if defined(DEBUG)
    CTraceWordSink m_apWordSink;
#else
    CComPtr<IWordSink> m_apWordSink;
#endif
    CComPtr<IPhraseSink> m_apPhraseSink;
    TEXT_SOURCE* m_pTxtSource;

    BOOL m_bQueryTime;

    ULONG m_ulUpdatedEndOfBuffer;
    bool m_bNoMoreTxt;

    //
    //  All Chunks in buffer have a white space
    //
    bool m_bWhiteSpaceGuarranteed;
    ULONG m_ulMaxTokenSize;

};

inline HRESULT CTokenizer::FillBuffer()
{
    Trace(
        elVerbose,
        s_tagTokenizer,
        ("WBreakGetNextChar: Filling the buffer"));

    HRESULT hr;

    if (!m_bNoMoreTxt)
    {
        do
        {
            //
            // this loop usually performs only one rotations. we use it to solve the
            // problem when the user return 0 characters and a success return code.
            // the following code assumes that in case you get a success return code then
            // the buffer is not empty.
            //

            hr = m_pTxtSource->pfnFillTextBuffer(m_pTxtSource);
        } while ((m_pTxtSource->iEnd <= m_pTxtSource->iCur) && SUCCEEDED(hr));

        if ( FAILED(hr))
        {
             m_bNoMoreTxt = true;
        }
    }

    if (m_bNoMoreTxt && m_pTxtSource->iCur >= m_pTxtSource->iEnd)
    {
        //
        // we reached the end of the buffer.
        //
        return WBREAK_E_END_OF_TEXT;
    }

    CalculateUpdateEndOfBuffer();

    return S_OK;
}

inline void CTokenizer::CalculateUpdateEndOfBuffer()
{
    //
    // m_ulUpdatedEndOfBuffer is a marker for the last character that we can read
    // from the current buffer before and additional call to fill buffer is needed.
    // we use this marker to avoid terms spitted between two consecutive buffers.
    // in order to achieve the above m_ulUpdatedEndOfBuffer will point to a breaker
    // character. (the only exception to that is when we have a very long term that does
    // not contains breaker characters).
    //

    //
    // we split the buffer into chunks of TOKENIZER_MAXBUFFERLIMIT size. in each
    // chunk we make sure that there is a breaker.
    //

    ULONG ulStartChunk = m_pTxtSource->iCur;
    ULONG ulEndChunk ;
    bool fLastRound = false;

    Assert(m_pTxtSource->iEnd > m_pTxtSource->iCur);

    ulEndChunk = m_pTxtSource->iCur + m_ulMaxTokenSize > (m_pTxtSource->iEnd - 1) ?
            (m_pTxtSource->iEnd - 1) : m_pTxtSource->iCur + m_ulMaxTokenSize;
    ULONG ulCur;
    ULONG ulBreakerMarker = 0;
    m_bWhiteSpaceGuarranteed = false;

    while(true)
    {
        ulCur = ulEndChunk;

        //
        // per each chunk we go backward and try to find a WS.
        //
        while ((ulCur > ulStartChunk) &&
               (!IS_WS(m_pTxtSource->awcBuffer[ulCur])))
        {
            ulCur--;
        }

        if (ulCur == ulStartChunk)
        {

            //
            // the last chunk that we checked did not contain any WS
            //

            if (m_ulMaxTokenSize == (ulEndChunk - ulStartChunk))
            {
                //
                // full buffer case. we look for a default breaker.
                //

                ulCur = ulEndChunk;

                while ( (ulCur > ulStartChunk) &&
                        !IS_BREAKER( m_pTxtSource->awcBuffer[ulCur] )
                      )
                {
                    ulCur--;
                }

                //
                // if we found a breaker then ulBreakerMarker will set to it else
                // the term does not contain any breakers and we set the ulBreakerMarker
                // to the end of the term. this is the only case that we spilt terms.
                //
                ulBreakerMarker = ulCur > ulStartChunk ? ulCur : ulEndChunk;
            }
            else
            {
                if (ulStartChunk > m_pTxtSource->iCur)
                {
                    //
                    // case we had a previous chunk. in this case ulStartChunk points to
                    // a breaker
                    //

                    //
                    // ulStart points to the WS from the previous chunk.
                    //
                    ulBreakerMarker = ulStartChunk;
                }
                else
                {
                    ulBreakerMarker = m_pTxtSource->iEnd;
                }
            }

            break;
        }

        if (fLastRound)
        {
            //
            // ulCur points to a WS
            //
            ulBreakerMarker = ulCur + 1;
            m_bWhiteSpaceGuarranteed = true;

            break;
        }

        //
        // move to the next chunk
        //
        ulStartChunk = ulCur + 1; // ulStarChunk will points to a breaker
        if (ulStartChunk + m_ulMaxTokenSize < (m_pTxtSource->iEnd - 1))
        {
            ulEndChunk = ulStartChunk + m_ulMaxTokenSize;

        }
        else
        {
            ulEndChunk = m_pTxtSource->iEnd - 1;
            fLastRound = true;
        }
    }

    Assert(ulBreakerMarker <= m_pTxtSource->iEnd);
    m_ulUpdatedEndOfBuffer = ulBreakerMarker;

}


inline short CTokenizer::ConvertHexCharToNumber(WCHAR wch)
{
    //
    // assumes wch is a valid HEX character
    //
    Assert(wch >= L'0');

    if (wch <= L'9')
    {
        return (wch - L'0');
    }
    else if (wch <= L'F')
    {
        Assert(wch >= L'A');
        return (wch - L'A' + 10);
    }
    else if (wch <= L'f')
    {
        Assert(wch >= L'a');
        return (wch - L'a' + 10);
    }
    else if (wch <= 0xFF19)
    {
        Assert(wch >= 0xFF10);
        return (wch - 0xFF10);
    }
    else if (wch <= 0xFF26)
    {
        Assert(wch >= 0xFF21);
        return (wch - 0xFF21 + 10);
    }
    else
    {
        Assert((wch >= 0xFF41) && (wch <= 0xFF46));
        return (wch - 0xFF41 + 10);
    }

}

inline LONG CTokenizer::ConvertCharToDigit(WCHAR wch)
{
    Assert((wch >= L'0' && wch <= L'9') || ((wch >= 0xFF10) && (wch <= 0xFF19)));
    if (wch <= L'9')
    {
        return (wch - L'0');
    }

    return (wch - 0xFF10); // Full width characters.
}

#endif _TOKENIZER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\wbutils.h ===
#ifndef _WB_UTILS_H_
#define _WB_UTILS_H_

#include "excption.h"
#include "regkey.h"

inline WCHAR* CreateFilePath(const WCHAR* pwcsFile)
{
    HMODULE h;

    h = GetModuleHandle(L"LangWrbk.dll");
    if (NULL == h)
    {
        THROW_WIN32ERROR_EXCEPTION(GetLastError());
    }

    CAutoArrayPointer<WCHAR> apwcsPath;
    ULONG ulInitSize = 128;
    ULONG ulPathLen;

    do
    {
        ulInitSize *= 2;
    
        apwcsPath = new WCHAR[ulInitSize + wcslen(pwcsFile) + 1];

        ulPathLen = GetModuleFileName(
                                    h,
                                    apwcsPath.Get(),
                                    ulInitSize);
    } while (ulPathLen >= ulInitSize);

    if (0 == ulPathLen)
    {
        THROW_WIN32ERROR_EXCEPTION(GetLastError());
    }

    while ((ulPathLen > 0) && 
           (apwcsPath.Get()[ulPathLen - 1] != L'\\'))
    {
        ulPathLen--;
    }

    apwcsPath.Get()[ulPathLen] = L'\0';
    wcscat(apwcsPath.Get(), pwcsFile);

    return apwcsPath.Detach();
}


class CWbToUpper
{

public:

    CWbToUpper();

    //
    //  SOME ACCESS FUNCTIONS:
    //
    __forceinline
    static
    WCHAR
    MapToUpper(
        IN WCHAR wc
        )
    {
        extern CWbToUpper g_WbToUpper;
        if (wc < 0x100)
        {
            return g_WbToUpper.m_pwcsCaseMapTable[wc];
        }
        else
        {
            WCHAR wchOut;
            LCMapString( 
                LOCALE_NEUTRAL,
                LCMAP_UPPERCASE,
                &wc,
                1,
                &wchOut,
                1 );
            return wchOut;
        }
    }


public:

    WCHAR m_pwcsCaseMapTable[0x100];

};  // CFE_CWbToUpper

extern CWbToUpper g_WbToUpper;

inline CWbToUpper::CWbToUpper( )
{
    //
    // the code use to use LCMapString (with LANG_NEUTRAL) to initialize the UPPER array.
    // LCMapString behaves weirdly on Greek WIN98 (possibly  a bug)
    //
    
    for (WCHAR wch = 0; wch <= 0xFF; wch++)
    {
        m_pwcsCaseMapTable[wch] = wch;
    }

    for (WCHAR wch = 0x61; wch <= 0x7A; wch++)
    {
        m_pwcsCaseMapTable[wch] = wch - 0x20;
    }

    for (WCHAR wch = 0xE0; wch <= 0xFE; wch++)
    {
        m_pwcsCaseMapTable[wch] = wch - 0x20;
    }

}


#endif // _WB_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\wordbreaker.cpp ===
// WordBreaker.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f WordBreakerps.mk in the project directory.

#include "base.h"
#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "query.h"
#include "WordBreaker.h"

#include "WordBreaker_i.c"
#include "WrdBrk.h"
#include "Tokenizer.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_EngUSWrdBrk, CEngUSWrdBrk)
    OBJECT_ENTRY(CLSID_EngUKWrdBrk, CEngUKWrdBrk)
    OBJECT_ENTRY(CLSID_FrnFrnWrdBrk, CFrnFrnWrdBrk)
    OBJECT_ENTRY(CLSID_ItlItlWrdBrk, CItlItlWrdBrk)
    OBJECT_ENTRY(CLSID_SpnMdrWrdBrk, CSpnMdrWrdBrk)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

void InitializeGlobalData();

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        try
        {
            InitializeGlobalData();
        }
        catch (CException& ) 
        {
            return FALSE; 
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\wrdbrk.cpp ===
// WrdBrk.cpp : Implementation of CWrdBrk
#include "base.h"
#include "stdafx.h"
#include "query.h"
#include "WordBreaker.h"
#include "WrdBrk.h"

/////////////////////////////////////////////////////////////////////////////
// CWrdBrk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\ftferror.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  FTFError.h
//      Purpose  :  This file contains the definition to ftfs returned errors.
//
//      Project  :  FTFS
//      Component:  Common
//
//      Author   :  urib  (Copied from mapicode.h)
//
//      Log:
//          Jul 15 1996 urib  Creation
//          Oct 15 1996 urib  Add some errors.
//          Feb  3 1997 urib  Declare the map from Win32 error to HRESULT.
//          Sep 16 1997 urib  Add time out error.
//          Feb 26 1998 urib  Move FTF_STATUS error constants from comdefs.
//          Mar 11 1998 dovh  Add FTF_STATUS_REQUEST_QUEUE_ALMOST_FULL status.
//          May 11 1999 dovh  Add FTF_E_ALREADY_INITIALIZED status.
//          Jul 26 1999 urib  Fix constants names.
//          Feb 17 2000 urib  Add unsupported type error.
//          Feb 21 2000 urib  Add unsupported like operator error.
//          Feb 21 2000 urib  Add noise word only query error.
//
////////////////////////////////////////////////////////////////////////////////
#ifndef   FTFERROR_H
#define   FTFERROR_H

#include <winerror.h>

/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *
 *   where
 *
 *      S - Severity - indicates success/fail
 *
 *          0 - Success
 *          1 - Fail (COERROR)
 *
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *
 *      Code - is the facility's status code
 *
 */


#define     FACILITY_FTFS                    0x20

/* We do succeed sometimes...                */
#define     FTF_SUCCESS                      0L


/*
 *  We can't use OLE 2.0 macros to build sCodes because the definition has
 *  changed and we wish to conform to the new definition.
 */
#define MAKE_FTF_SCODE(sev,fac,code)                    \
    ((SCODE)        (((unsigned long)(sev)<<31) |       \
                     ((unsigned long)(fac)<<16) |       \
                     ((unsigned long)(code)   )  ))

/* The following two macros are used to build OLE 2.0 style sCodes */

#define MAKE_FTF_E( err )  (MAKE_FTF_SCODE( 1, FACILITY_FTFS, err ))
#define MAKE_FTF_S( warn ) (MAKE_FTF_SCODE( 0, FACILITY_FTFS, warn ))

/* General errors */

#define FTF_E_NOT_ENOUGH_MEMORY         E_OUTOFMEMORY
#define FTF_E_INVALID_PARAMETER         E_INVALIDARG

#define FTF_E_BAD_FORMAT                MAKE_FTF_E(ERROR_BAD_FORMAT)
#define FTF_E_INTERNAL_ERROR            MAKE_FTF_E(ERROR_INTERNAL_ERROR)
#define FTF_E_ITEM_NOT_FOUND            MAKE_FTF_E(ERROR_FILE_NOT_FOUND)
#define FTF_E_ITEM_ALREADY_EXISTS       MAKE_FTF_E(ERROR_FILE_EXISTS)
#define FTF_E_ALREADY_INITIALIZED       MAKE_FTF_E(ERROR_ALREADY_INITIALIZED)

#define FTF_E_TIMEOUT                   MAKE_FTF_E(ERROR_SEM_TIMEOUT)

#define FTF_E_NOT_INITIALIZED           MAKE_FTF_E(OLE_E_BLANK)

#define FTF_E_TOO_BIG                   MAKE_FTF_E( 0x302 )
#define FTF_E_NO_ICORPUSSTATISTICS      MAKE_FTF_E( 0x303 )
#define FTF_E_QUERY_SETS_FULL           MAKE_FTF_E( 0x304 )

#define FTF_W_PARTIAL_COMPLETION        MAKE_FTF_S( 0x313 )
#define FTF_W_ALREADY_INITIALIZED       MAKE_FTF_S( 0x314 )
//
//  FTF_STATUS_ MACRO DEFINITIONS:
//

#define FTF_E_EXPRESSION_PARSING_ERROR  MAKE_FTF_E(12)
#define FTF_E_PATTERN_TOO_SHORT         MAKE_FTF_E(21)
#define FTF_E_PATTERN_TOO_LONG          MAKE_FTF_E(22)
#define FTF_E_UNSUPPORTED_PROPERTY_TYPE MAKE_FTF_E(24)
#define FTF_E_UNSUPPORTED_REGEXP_OP     MAKE_FTF_E(25)
#define FTF_E_TOO_MANY_PROPERTIES       MAKE_FTF_E(26)
#define FTF_E_TOO_MANY_SPECIFIC_ALL     MAKE_FTF_E(27)
#define FTF_E_ONLY_NOISE_WORDS          ((HRESULT)0x80041605L)//QUERY_E_ALLNOISE


//
//  XML STACK ETC...
//
#define FTF_E_STACK_EMPTY               MAKE_FTF_E(201)
#define FTF_E_STACK_UNDERFLOW           MAKE_FTF_E(202)

#endif // FTFERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\comdefs.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  ComDefs.H
//      Purpose  :  Filtering Engine / Service common definitions including
//                  FLAGS, STATUS, and CONSTANT MACROS
//
//      Project  :  PQS
//      Component:  Filter
//
//      Author   :  dovh
//
//      Log      :  Aug-05-1995 dovh - Creation
//
//      May-25-1996 - Dov Harel (DovH): Added a few flags & status codes.
//          In particular replaced
//          FTF_STATUS_QUERY_ID_MISMATCH and FTF_STATUS_QUERY_ID_NOT_FOUND by
//          FTF_STATUS_REQUEST_ID_MISMATCH and FTF_STATUS_REQUEST_ID_NOT_FOUND
//          resp.  replaced FTF_FLAG_ACCEPT_ANY_QUERY_ID by
//          FTF_FLAG_ACCEPT_ANY_REQUEST_ID
//      Jun-10-1996 Dov Harel (DovH)
//          Added FTF_FLAG_WRITE_EMPTY_RESULTS_FILE
//      Sep-30-1996 Dov Harel (DovH)
//          Added FTF_FLAG_DUMP_RESTRICTED_SUBSET
//      Dec-11-1996 Dov Harel (DovH)
//          UNICODE Preparation: Convert char to TCHAR
//
//      Feb-18-1997 Dov Harel (DovH) - #define FTF_STATUS_SERVICE_IS_PAUSED ...
//      Nov-30-1997 Dov Harel (DovH) - #define FTF_STATUS_PATTERN_TOO_SHORT ...
//      Jan-26-1998 Uri Barash(UriB) - Move query db name define to Names.h
//      Jan-29-1997 dovh - Add FTF_FLAG_BATCH_FAILED flag.
//      Feb-23-1998 yairh - change all errors to be an HRESULT error
//      Jul-15-1997 dovh - Move #ifdef MINDEX to Diffs.h
//      Nov-12-1998 yairh - add query set defines
//      Jan-05-1999 urib - Move MAX_PATTERN_LENGTH here from mpat.h
//      Mar-02-1999 dovh - Move SET_FE_HANDLE/GET_FE_HANDLE here from Tls.h
//      May-18-1999 urib - Define the UNICODE word breaker character.
//      Feb-22-2000 urib - Move stuff away.
//
////////////////////////////////////////////////////////////////////////////////


#ifndef __FILTER__COMDEFS_H__
#define __FILTER__COMDEFS_H__

//
//  FTF_FLAG_ MACRO DEFINITIONS:
//

#define FTF_FLAG_CASE_INSENSITIVE_FLAG              0X00000001L
#define FTF_FLAG_SUBDIR_SEARCH                      0X00000002L
#define FTF_FLAG_ASYNC_REQUEST                      0X00000004L

#define FTF_FLAG_LOCAL_OPERATION                    0X00000010L
#define FTF_FLAG_DEMO_VIEW                          0X00000020L
#define FTF_FLAG_IGNORE_EXTERNAL_TERMS              0X00000040L
#define FTF_FLAG_RESERVED_07                        0X00000080L

#define FTF_FLAG_ACCEPT_ANY_REQUEST_ID              0X00000200L
#define FTF_FLAG_CHECK_EXP_ID_MATCH                 0X00000400L

#define FTF_FLAG_ADD_EXP_REQUEST                    0X00001000L
#define FTF_FLAG_REMOVE_EXP_REQUEST                 0X00002000L
#define FTF_FLAG_QUERY_MGR_CLIENT                   0X00004000L
#define FTF_FLAG_DOC_MGR_CLIENT                     0X00008000L

#define FTF_FLAG_EMPTY_DEFAULT_NOTIFY_SET           0X00010000L
#define FTF_FLAG_EMPTY_NOTIFY_SET                   0X00020000L
#define FTF_FLAG_WRITE_EMPTY_RESULTS_FILE           0X00040000L
#define FTF_FLAG_BATCH_FAILED                       0X00080000L

//
//  DUMP EXPRESSIONS OPTIONS (REUSED FLAGS)
//

#define FTF_FLAG_CONDENSE_BLANKS                    0X00000001L
#define FTF_FLAG_CONSEQUTIVE_EXP_IDS                0X00000002L
#define FTF_FLAG_RESERVED                           0X00000004L
#define FTF_FLAG_DUMP_RESTRICTED_SUBSET             0X00000008L

//
//  FTF_CONST_ MACRO DEFINITIONS:
//

#define FTF_CONST_MAX_NAME_LENGTH                            64
#define FTF_CONST_SHORT_FILENAME_LENGTH                      16
#define FTF_CONST_MEDIUM_FILENAME_LENGTH                     32
#define FTF_CONST_MAX_FILENAME_LENGTH                       128
#define FTF_CONST_MAX_PATH_LENGTH                           256
#define FTF_CONST_FILENAMES_BUFFER_SIZE                    3072
#define FTF_CONST_MAX_SUBMIT_FILECOUNT                       32
#define FTF_CONST_MAX_SUBMIT_DIRCOUNT                        32
#define FTF_CONST_MAX_REQUESTS_STATUS                       128
#define FTF_CONST_MAX_SUBMIT_EXPCOUNT                        32
#define FTF_CONST_EXPS_BUFFER_SIZE                         3072


//
//  FTF_CONST_SHUTDOWN_ OPTIONS (EXPEDIENCY LEVEL):
//

#define FTF_CONST_SHUTDOWN_ON_EMPTY_QUEUE                     1
#define FTF_CONST_SHUTDOWN_IMMEDIATE                          2


#define MAX_PATTERN_LENGTH                                  1024
#define TEXT_BUFFER_MAX_SIZE        (16384 - MAX_PATTERN_LENGTH)
//
// NOTICE: MAX_PHRASE_LEN >= UNDIRECTED_PROXIMITY_INTERVAL
//

#define MAX_PHRASE_LEN 50
#define UNDIRECTED_PROXIMITY_INTERVAL 50

#if UNDIRECTED_PROXIMITY_INTERVAL > MAX_PHRASE_LEN
#error BUG: MAX_PHRASE_LEN >= UNDIRECTED_PROXIMITY_INTERVAL
#endif

#define PQ_WORD_BREAK                                    0x0001L

typedef enum {
    DICT_SUCCESS,
    DICT_ITEM_ALREADY_PRESENT,
    DICT_ITEM_NOT_FOUND,
    DICT_FIRST_ITEM,
    DICT_LAST_ITEM,
    DICT_EMPTY_DICTIONARY,
    DICT_NULL_ITEM
} DictStatus;

#endif // __FILTER__COMDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\autohndl.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  AutoHndl.h
//      Purpose  :  To automatically close open handles.
//
//      Project  :  FTFS
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Jan 20 1997 urib  Creation
//          Jun 12 1997 urib  Define the BAD_HANDLE macro if needed.
//          Feb 22 2000 urib  fix bug 12038. Assignment doesn't free old handle.
//
////////////////////////////////////////////////////////////////////////////////


#ifndef AUTOHNDL_H
#define AUTOHNDL_H

#ifndef BAD_HANDLE
#define BAD_HANDLE(h)       ((0 == ((HANDLE)h))||   \
                             (INVALID_HANDLE_VALUE == ((HANDLE)h)))
#endif

////////////////////////////////////////////////////////////////////////////////
//
//  CAutoHandle class definition
//
////////////////////////////////////////////////////////////////////////////////

class CAutoHandle
{
public:
    // Constructor
    CAutoHandle(HANDLE h = NULL)
        :m_h(h){}

    // Behave like a HANDLE in assignments
    CAutoHandle& operator=(HANDLE h)
    {
        if ((!BAD_HANDLE(m_h)) &&   // A valid handle is kept by us
            (m_h != h))             // A new handle is different!
        {
            CloseHandle(m_h);
        }

        m_h = h;
        return(*this);
    }

    // Every kind of a  handle needs different closing.
    virtual
    ~CAutoHandle()
    {
        if (!BAD_HANDLE(m_h))
        {
            CloseHandle(m_h);
            m_h = NULL;
        }
    }

    // Behave like a handle
    operator HANDLE() const
    {
        return m_h;
    }

    // Allow access to the actual memory of the handle.
    HANDLE* operator &()
    {
        Assert(BAD_HANDLE(m_h));

        return &m_h;
    }

    HANDLE Detach()
    {
        HANDLE h = m_h;
        m_h = NULL;
        return h;
    }
protected:
    // The handle.
    HANDLE  m_h;


private:
    CAutoHandle(CAutoHandle&);
    CAutoHandle& operator=(CAutoHandle&);
};

////////////////////////////////////////////////////////////////////////////////
//
//  CAutoChangeNotificationHandle class definition
//
////////////////////////////////////////////////////////////////////////////////

class CAutoChangeNotificationHandle :public CAutoHandle
{
public:
    // Constructor
    CAutoChangeNotificationHandle(HANDLE h = NULL)
        :CAutoHandle(h){};

    // These operators are not derived and therefore must be reimplemented.
    CAutoChangeNotificationHandle& operator=(HANDLE h)
    {
        m_h = h;
        return(*this);
    }

    // The proper closing.
    virtual
    ~CAutoChangeNotificationHandle()
    {
        if (!BAD_HANDLE(m_h))
        {
            FindCloseChangeNotification(m_h);
            m_h = NULL;
        }
    }

private:
    CAutoChangeNotificationHandle(CAutoChangeNotificationHandle&);
    operator=(CAutoChangeNotificationHandle&);
};

#endif /* AUTOHNDL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\autoptr.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  AutoPtr.h
//      Purpose  :  To supply auto pointers of different kinds.
//                      CAutoPointer<T, Deletor> Generic pointer needs a deletor
//                                                 class to instaciate.
//                      CAutoMallocPonter<T>     A malloc allocated pointer.
//                      CAutoClassPointer<T>     A "new" allocated pointer
//                      CAutoArrayPointer<T>     A "new[]" allocated pointer
//                      CAutoOlePointer<T>       A pointer that should be
//                                                 "Release()".
//
//      Project  :  PersistentQuery
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//
//          Jan 15 1997 urib  Creation
//          Jan 19 1997 urib  Fix Ole pointer. Enable instanciation without
//                              ownership
//          Jun  9 1997 urib  Better OlePointer. Some safety fixes.
//          Nov 17 1997 urib  Add ole task pointer.
//          Jun 30 1998 dovh  Add Assert to CAutoPointer operator=
//          Feb 25 1999 urib  Add smart pointer typedef macro.
//          Jun 23 1999 urib  Add equality op.
//          Aug  5 1999 urib  Fix a memory leak bug in the assignment operator
//                              of CAutoPointer. Add assignment operation
//                              creation macro.
//          Dec  1 1999 urib  Change return type from int to bool in IsValid.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef AUTOPTR_H
#define AUTOPTR_H

#include "tracer.h"
#include <comdef.h>

#pragma once

////////////////////////////////////////////////////////////////////////////////
//
//  return type for 'identifier::operator ->'is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//
////////////////////////////////////////////////////////////////////////////////
#pragma warning(disable: 4284 4786)

template<class T, class Deletor>
class CAutoPointer
{
  protected:
    typedef Deletor m_Deletor;

  public:
    typedef T       m_PointerType;

    // Constructors
    CAutoPointer(T* pt = NULL, BOOL fOwnMemory = TRUE)
        :m_fIOwnTheMemory(fOwnMemory && (pt != NULL))
        ,m_ptThePointer(pt) {}

    CAutoPointer(const CAutoPointer<T, Deletor>& acp)
    {
        m_fIOwnTheMemory = acp.m_fIOwnTheMemory;
        m_ptThePointer = acp.Detach();
    }

    // Assignemnt operation.
    CAutoPointer<T, Deletor>&
    operator=(const CAutoPointer<T, Deletor>& acp)
    {
        if (m_ptThePointer != acp.m_ptThePointer)
        {
            if (m_fIOwnTheMemory)
                Deletor::DeleteOperation(m_ptThePointer);
            m_fIOwnTheMemory = acp.m_fIOwnTheMemory;
            m_ptThePointer = acp.Detach();
        }
        else
        {
            Assert( (!m_fIOwnTheMemory) || acp.m_fIOwnTheMemory );
            //  Note: R.H.S "inherits" memory oenership from L.H.S.,
            //  and L.H.S. ownership is cancelled by Detach!

            bool ftmp = acp.m_fIOwnTheMemory;
            acp.Detach();
            m_fIOwnTheMemory = ftmp;
        }

        return (*this);
    }

    CAutoPointer<T, Deletor>&
    operator=(int null)
    {
        Assert(null == 0);

        return operator=(reinterpret_cast<T*>(NULL));
    }

    bool
    operator==(const CAutoPointer<T, Deletor>& acp)
    {
        return m_ptThePointer == acp.m_ptThePointer;
    }


    // If it is our memory delete the pointer.
    ~CAutoPointer()
    {
        if(m_fIOwnTheMemory)
            Deletor::DeleteOperation(m_ptThePointer);
    }

    // Return the pointer and mark that it is no longer our memory.
    T*
    Detach() const
    {
        // This is to escape the const restriction. We don't change the pointer
        //   but we still do the marking.
        ((CAutoPointer<T, Deletor>*)this)->m_fIOwnTheMemory = FALSE;
        return (m_ptThePointer);
    }

    // Return the actual pointer if you want to use it someplace
    T*
    Get() const
    {
        return m_ptThePointer;
    }

    // Return if the pointer is valid.
    bool
    IsValid()
    {
        return !!m_ptThePointer;
    }


    // Indirection
    T&
    operator *() const
    {
        return * Get();
    }

    // Dereference
    T*
    operator ->() const
    {
        return Get();
    }

  protected:
    // The pointer to keep.
    T*      m_ptThePointer;

    // Is the memory ours?
    bool    m_fIOwnTheMemory;

};

#define CONSTRUCTORS(AutoPointer)                                       \
                                                                        \
AutoPointer(m_PointerType* pt = NULL,                                   \
            BOOL fOwnMemory = TRUE)                                     \
    :CAutoPointer<m_PointerType, m_Deletor>(pt, fOwnMemory)             \
{                                                                       \
}                                                                       \
                                                                        \
AutoPointer(const AutoPointer<m_PointerType>& aop)                      \
    :CAutoPointer<m_PointerType, m_Deletor>(aop)                        \
{                                                                       \
}                                                                       \


#define ASSIGNMENT_OPERATORS(AutoPointer)                               \
                                                                        \
AutoPointer<m_PointerType>&                                             \
operator=(const AutoPointer<m_PointerType>& acp)                        \
{                                                                       \
    CAutoPointer<m_PointerType, m_Deletor>::operator=(acp);             \
                                                                        \
    return *this;                                                       \
}                                                                       \
                                                                        \
AutoPointer<m_PointerType>&                                             \
operator=(int null)                                                     \
{                                                                       \
    CAutoPointer<m_PointerType, m_Deletor>::operator=(null);            \
                                                                        \
    return *this;                                                       \
}



////////////////////////////////////////////////////////////////////////////////
//
//  CAutoClassPointer class definition
//
////////////////////////////////////////////////////////////////////////////////
template <class T>
class CClassDeletor
{
  public:
    static
    void
    DeleteOperation(T* pt)
    {
        if (pt)
            delete pt;
    }
};

template<class T>
class CAutoClassPointer : public CAutoPointer<T, CClassDeletor<T> >
{
  public:
    CONSTRUCTORS(CAutoClassPointer);
    ASSIGNMENT_OPERATORS(CAutoClassPointer);
};


////////////////////////////////////////////////////////////////////////////////
//
//  CAutoOlePointer class definition
//
////////////////////////////////////////////////////////////////////////////////
template <class T>
class COleDeletor
{
  public:
    static
    void
    DeleteOperation(T* pt)
    {
        if (pt)
            pt->Release();
    }
};

template<class T>
class CAutoOlePointer : public CAutoPointer<T, COleDeletor<T> >
{
public:
    CONSTRUCTORS(CAutoOlePointer);
    ASSIGNMENT_OPERATORS(CAutoOlePointer);

public:
    T** operator &()
    {
        m_fIOwnTheMemory = TRUE;
        return &m_ptThePointer;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
//  CAutoTaskPointer class definition
//
////////////////////////////////////////////////////////////////////////////////
template <class T>
class CTaskDeletor
{
  public:
    static
    void
    DeleteOperation(T* pt)
    {
        if (pt)
            CoTaskMemFree(pt);
    }
};

template<class T>
class CAutoTaskPointer : public CAutoPointer<T, CTaskDeletor<T> >
{
public:
    CONSTRUCTORS(CAutoTaskPointer);
    ASSIGNMENT_OPERATORS(CAutoTaskPointer);

public:
    T** operator &()
    {
        m_fIOwnTheMemory = TRUE;
        return &m_ptThePointer;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
//  CAutoMallocPointer class definition
//
////////////////////////////////////////////////////////////////////////////////
template <class T>
class CMallocDeletor
{
  public:
    static
    void
    DeleteOperation(T* pt)
    {
        if (pt)
            free(pt);
    }
};

template<class T>
class CAutoMallocPointer : public CAutoPointer<T, CMallocDeletor<T> >
{
  public:

      CONSTRUCTORS(CAutoMallocPointer);
      ASSIGNMENT_OPERATORS(CAutoMallocPointer);

  public:

    T& operator[](size_t n)
    {
        return *(Get() + n);
    }
};

////////////////////////////////////////////////////////////////////////////////
//
//  CAutoArrayPointer class definition
//
////////////////////////////////////////////////////////////////////////////////
template <class T>
class CArrayDeletor
{
  public:
    static
    void
    DeleteOperation(T* pt)
    {
        if (pt)
            delete[] pt;
    }
};

template<class T>
class CAutoArrayPointer : public CAutoPointer<T, CArrayDeletor<T> >
{
public:
    CONSTRUCTORS(CAutoArrayPointer);
    ASSIGNMENT_OPERATORS(CAutoArrayPointer);

public:

    T& operator[](size_t n)
    {
        return *(Get() + n);
    }
};



//
//  Simple macro to define the standard COM pointer.
//
#define PQ_COM_SMARTPTR_TYPEDEF(Interface)      \
    _COM_SMARTPTR_TYPEDEF(Interface, IID_##Interface)

#endif /* AUTOPTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\excption.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  Excption.h
//      Purpose  :  To define the generic exception.
//
//      Project  :  pqs
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Jan 19 1997 urib  Creation
//          Mar  2 1997 urib  Add win32 error exception.
//          Jun 25 1997 urib  Move definition  of translator class to header.
//                              Change name to CExceptionTranslatorSetter.
//                              This is done because every thread needs to use
//                              it as it enters our scope.
//          Sep 16 1997 urib  Supply default parameter to CWin32ErrorException.
//          Oct 21 1997 urib  Added macros to throw exceptions that know their
//                            location.
//          Feb 12 1998 urib  Print error information from within Hresult
//                              Exception.
//          Feb 17 1998 urib  Move translator code from cpp to header.
//          Jun 22 1998 yairh add GetFile & GetLine methods
//          Jul 19 1998 urib  Specify calling convention on exception translator
//                              function.
//          Aug 17 1998 urib  Remove the ... catch clause.
//          Jan 10 1999 urib  Support a throwing new.
//          Jan 21 1999 urib  Fix THROW macros to force arguments to be WCHAR
//                              string even in non UNICODE environment.
//          Feb  1 1999 urib  Add null pointer exception. Add throwing new to
//                              COM macros.
//          Mar 15 2000 urib  Add missing "leaving function" trace.
//          Apr 12 2000 urib  Move new manipulation to memory management module.
//          Sep  6 2000 urib  Fix EnterLeave macros.
//          Oct 25 2000 urib  Check allocation failure on Generic exception.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef EXCPTION_H
#define EXCPTION_H

#include <eh.h>
#include <stdexcpt.h>
#include "Tracer.h"
#include "AutoPtr.h"
#include "FtfError.h"


////////////////////////////////////////////////////////////////////////////////
//
//  CException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CException
{
  public:
    CException(PWSTR pwszFile = NULL, ULONG ulLine = 0)
    {
        m_pwszFile = pwszFile;
        m_ulLine = ulLine;

        Trace(
            elError,
            tagError,(
            "CException:"
            "on file %S, line %d",
            (pwszFile ? pwszFile :
                L"Fix this exception to return "
                L"a file and line"),
            ulLine));
    }

    // Get an error string.
    virtual
    BOOL GetErrorMessage(
        PWSTR   pwszError,
        UINT    nMaxError,
        PUINT   pnHelpContext = NULL ) = NULL;

#if 0
    // Notify via message box.
    virtual
    int ReportError(
        UINT nType      = MB_OK,
        UINT nMessageID = 0 )
    {
        UNREFERENCED_PARAMETER(nMessageID);

        WCHAR   rwchErrorString[1000];

        GetErrorMessage(rwchErrorString, 1000);

        return MessageBoxW(
            NULL,
            rwchErrorString,
            L"Exception occured",
            nType);
    }
#endif

    virtual
    ~CException(){};

    PWSTR GetFile() { return m_pwszFile; }
    ULONG GetLine() { return m_ulLine; }

    virtual void PrintErrorMsg(
                char* pszFunction,
                ULONG_PTR dwThis,
                char* pszFile,
                int iLine,
                TAG tag = 0)
    {
        WCHAR   rwchError[1000];

        GetErrorMessage(rwchError, sizeof(rwchError)/sizeof(WCHAR));

        Trace(
            elError,
            tag,(
            "COM Exception Catcher:"
            "%s (this = %#x) threw an exception. "
            "Error is message\"%S\". "
            "Caught in file %s line %d.",
            pszFunction,
            dwThis,
            rwchError,
            pszFile,
            iLine));

    }

  protected:
    PWSTR   m_pwszFile;
    ULONG   m_ulLine;
};

////////////////////////////////////////////////////////////////////////////////
//
//  CStructuredException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CStructuredException : public CException
{
  public:
    CStructuredException(UINT uiSeCode)
        :m_uiSeCode(uiSeCode){};

    // Get an error string.
    virtual
    BOOL GetErrorMessage(
        PWSTR   pwszError,
        UINT    nMaxError,
        PUINT   pnHelpContext = NULL )
    {
        UNREFERENCED_PARAMETER(pnHelpContext);

        int iRet;
        iRet = _snwprintf(
            pwszError,
            nMaxError,
            L"Structured exception %#X",
            GetExceptionCode());

        pwszError[nMaxError - 1] = '\0';

        return iRet;
    }

    // Return the exception code.
    UINT
    GetExceptionCode()
    {
        return m_uiSeCode;
    }

    // The translator.
    static
    void _cdecl Translator(UINT ui, EXCEPTION_POINTERS*)
    {
        throw CStructuredException(ui);
    }

  private:
    UINT m_uiSeCode;

};


////////////////////////////////////////////////////////////////////////////////
//
//  CGenericException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CGenericException : public CException
{
  public:
    CGenericException(LPWSTR pwszTheError)
    {
        m_apwszTheError = _wcsdup(pwszTheError);
        if (!m_apwszTheError.IsValid())
        {
            m_apwszTheError =
                L"Memory allocation failed in the exception object creation";

            m_apwszTheError.Detach();
        }
    }

    // Get an error string.
    virtual
    BOOL GetErrorMessage(
        PWSTR   pwszError,
        UINT    nMaxError,
        PUINT   pnHelpContext = NULL )
    {
        UNREFERENCED_PARAMETER(pnHelpContext);

        int iRet;
        iRet = _snwprintf(
            pwszError,
            nMaxError,
            L"%s",
            m_apwszTheError);

        pwszError[nMaxError - 1] = '\0';

        return iRet;
    }

  private:
    CAutoMallocPointer<WCHAR>   m_apwszTheError;

};

////////////////////////////////////////////////////////////////////////////////
//
//  CHresultException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CHresultException : public CException
{
  public:
    CHresultException(HRESULT   hrResult = E_FAIL,
                      PWSTR     pwszFile = NULL,
                      ULONG     ulLine = 0)
        :m_hrResult(hrResult), CException(pwszFile, ulLine)
    {
        WCHAR   rwchError[1000];

        GetErrorMessage(rwchError, sizeof(rwchError)/sizeof(WCHAR));

        Trace(
            elError,
            tagError,(
            "Exception:"
            "%S",
            rwchError));
    }

    // Get an error string.
    virtual
    BOOL GetErrorMessage(
        PWSTR   pwszError,
        UINT    nMaxError,
        PUINT   pnHelpContext = NULL )
    {
        UNREFERENCED_PARAMETER(pnHelpContext);

        int iRet;
        iRet = _snwprintf(
            pwszError,
            nMaxError,
            L"HResult exception %#X",
            m_hrResult);

        pwszError[nMaxError - 1] = '\0';

        return iRet;
    }

    operator HRESULT()
    {
        return m_hrResult;
    }

    virtual void PrintErrorMsg(
                char* pszFunction,
                ULONG_PTR dwThis,
                char* pszFile,
                int iLine,
                DWORD dwError,
                TAG tag = 0)
    {
        WCHAR   rwchError[1000];

        GetErrorMessage(rwchError, sizeof(rwchError)/sizeof(WCHAR));

        Trace(
            elError,
            tag,(
            "COM Exception Catcher:"
            "%s (this = %#x) threw an hresult(%#x) exception. "
            "Error message is \"%S\". "
            "Caught in file %s line %d.",
            pszFunction,
            dwThis,
            dwError,
            rwchError,
            pszFile,
            iLine));

    }

  protected:
    HRESULT m_hrResult;

};

////////////////////////////////////////////////////////////////////////////////
//
//  CWin32ErrorException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CWin32ErrorException : public CHresultException
{
  public:
    CWin32ErrorException(LONG   lResult = GetLastError(),
                         PWSTR  pwszFile = NULL,
                         ULONG  ulLine = 0)
        :CHresultException(MAKE_FTF_E(lResult), pwszFile, ulLine){}
};

////////////////////////////////////////////////////////////////////////////////
//
//  CMemoryException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CMemoryException : public CWin32ErrorException
{
  public:
    CMemoryException(PWSTR pwszFile = NULL, ULONG ulLine = 0)
        :CWin32ErrorException(E_OUTOFMEMORY, pwszFile, ulLine){};

    // Get an error string.
    virtual
    BOOL GetErrorMessage(
        PWSTR   pwszError,
        UINT    nMaxError,
        PUINT   pnHelpContext = NULL )
    {
        UNREFERENCED_PARAMETER(pnHelpContext);

        int iRet;
        iRet = _snwprintf(pwszError, nMaxError, L"Memory exception !!!");
        pwszError[nMaxError - 1] = '\0';

        return iRet;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
//  Macros for exception throwing and catching
//
////////////////////////////////////////////////////////////////////////////////
#define __PQWIDE(str) L##str
#define PQWIDE(str) __PQWIDE(str)

#define THROW_MEMORY_EXCEPTION()                 \
    throw CMemoryException(PQWIDE(__FILE__), __LINE__)

#define THROW_HRESULT_EXCEPTION(hr)                 \
    throw CHresultException(hr, PQWIDE(__FILE__), __LINE__)

#define THROW_WIN32ERROR_EXCEPTION(hr)                 \
    throw CWin32ErrorException(hr, PQWIDE(__FILE__), __LINE__)


#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)

class   CEnterLeavePrinting
{
public:
    CEnterLeavePrinting(TAG tag, char* pszFuncName, void* pThisPointer)
        :m_tag(tag)
        ,m_pszFuncName(pszFuncName)
        ,m_pThisPointer(pThisPointer)
    {
        Trace(
            elVerbose,
            m_tag,(
            "Entering %s (this = %#x):",
            m_pszFuncName,
            pThisPointer));
    }
    ~CEnterLeavePrinting()
    {
        Trace(
            elVerbose,
            m_tag,(
            "Leaving  %s (this = %#x):",
            m_pszFuncName,
            m_pThisPointer));
    }
protected:

    TAG     m_tag;
    char*   m_pszFuncName;
    void*   m_pThisPointer;
};


//
//  Use this macro at the beginning of an HRESULT COM method
//
#define BEGIN_STDMETHOD(function, tag)                                      \
CEnterLeavePrinting print(tag, #function, this);                            \
try                                                                         \
{

//
//  Use this macro at the end of an HRESULT COM method
//
#define END_STDMETHOD(function, tag)                                        \
}                                                                           \
catch(CHresultException& hre)                                               \
{                                                                           \
    hre.PrintErrorMsg(                                                      \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                (HRESULT)hre),                                              \
                tag;                                                        \
    return hre;                                                             \
}                                                                           \
catch(CException& e)                                                        \
{                                                                           \
    e.PrintErrorMsg(                                                        \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                tag);                                                       \
    return E_FAIL;                                                          \
}

//
//  Use this macro at the end of a void COM method
//
#define END_VOIDMETHOD(function, tag)                                       \
}                                                                           \
catch(CHresultException& hre)                                               \
{                                                                           \
    hre.PrintErrorMsg(                                                      \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                tag,                                                        \
                (HRESULT)hre);                                              \
}                                                                           \
catch(CException& e)                                                        \
{                                                                           \
    e.PrintErrorMsg(                                                        \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                tag                                                         \
               );                                                           \
}
#else

//
//  Use this macro at the beginning of an HRESULT COM method
//
#define BEGIN_STDMETHOD(function, tag)                                      \
try                                                                         \
{

//
//  Use this macro at the end of an HRESULT COM method
//
#define END_STDMETHOD(function, tag)                                        \
}                                                                           \
catch(CHresultException& hre)                                               \
{                                                                           \
    hre.PrintErrorMsg(                                                      \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                (HRESULT)hre);                                              \
    return hre;                                                             \
}                                                                           \
catch(CException& e)                                                        \
{                                                                           \
    e.PrintErrorMsg(                                                        \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__);                                                  \
    return E_FAIL;                                                          \
}

//
//  Use this macro at the end of a void COM method
//
#define END_VOIDMETHOD(function, tag)                                       \
}                                                                           \
catch(CHresultException& hre)                                               \
{                                                                           \
    hre.PrintErrorMsg(                                                      \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                (HRESULT)hre);                                              \
}                                                                           \
catch(CException& e)                                                        \
{                                                                           \
    e.PrintErrorMsg(                                                        \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__);                                                  \
}

#endif // DEBUG
#endif /* EXCPTION_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\wrdbrk.h ===
// WrdBrk.h : Declaration of the CWrdBrk

#ifndef __WRDBRK_H_
#define __WRDBRK_H_

#include "resource.h"
#include "Query.h"
#include "autoptr.h"
#include "excption.h"
#include "tokenizer.h"
#include "FrenchTokenizer.h"
#include "SpanishTokenizer.h"


DECLARE_TAG(s_tagWordBreaker, "Word Breaker");

template <class T, const CLSID* pclsid, const long IDR, class Tokenizer>
class CBaseWrdBrk :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<T, pclsid>,
    public IWordBreaker
{
public:
    CBaseWrdBrk(LCID lcid) :
        m_fInitialize(FALSE),
        m_lcid(lcid)
    {
        Trace(
            elVerbose,
            s_tagWordBreaker,
            ("WordBreaker constructed"));

        m_pUnkMarshaler = NULL;
    }

// IWordBreaker
public:

DECLARE_REGISTRY_RESOURCEID(IDR)
DECLARE_NOT_AGGREGATABLE(T)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(T)
    COM_INTERFACE_ENTRY(IWordBreaker)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    STDMETHOD(Init)(
            BOOL fQuery,
            ULONG ulMaxTokenSize,
            BOOL * pfLicense )
    {
        BEGIN_STDMETHOD(CWrdBrk::Init, s_tagWordBreaker);

        Trace(
            elVerbose,
            s_tagWordBreaker,
            ("WordBreaker Init"));

        if (NULL == pfLicense)
        {
            return E_INVALIDARG;
        }

        m_fInitialize = TRUE;
        m_fQueryTime = fQuery;
        m_ulMaxTokenSize = ulMaxTokenSize;

        return S_OK;
        END_STDMETHOD(CWrdBrk::Init, s_tagWordBreaker);
    }

    STDMETHOD(BreakText)(
            TEXT_SOURCE * pTextSource,
            IWordSink   * pWordSink,
            IPhraseSink * pPhraseSink )
    {

        BEGIN_STDMETHOD(CWrdBrk::BreakText, s_tagWordBreaker);
        Trace(
            elVerbose,
            s_tagWordBreaker,
            ("WordBreaker Break Text, lcid - %x",
            m_lcid));

        if (NULL == pTextSource)
        {
            return E_INVALIDARG;
        }

        Tokenizer t(pTextSource,
                     pWordSink,
                     pPhraseSink,
                     m_lcid,
                     m_fQueryTime,
                     m_ulMaxTokenSize);
        t.BreakText();
        return S_OK;

        END_STDMETHOD(CWrdBrk::BreakText, s_tagWordBreaker);
    }

    STDMETHOD(ComposePhrase)(
            WCHAR const * pwcNoun,
            ULONG         cwcNoun,
            WCHAR const * pwcModifier,
            ULONG         cwcModifier,
            ULONG         ulAttachmentType,
            WCHAR       * pwcPhrase,
            ULONG       * pcwcPhrase )
    {
        BEGIN_STDMETHOD(CWrdBrk::ComposePhrase, s_tagWordBreaker);
        return E_NOTIMPL;
        END_STDMETHOD(CWrdBrk::ComposePhrase, s_tagWordBreaker);
    }

    STDMETHOD(GetLicenseToUse)(
            WCHAR const ** ppwcsLicense )
    {
        BEGIN_STDMETHOD(CWrdBrk::GetLicenseToUse, s_tagWordBreaker);

        if ( NULL == ppwcsLicense )
            return E_INVALIDARG;

        static WCHAR const * wcsCopyright = L"Copyright Microsoft Inc.";
        *ppwcsLicense = wcsCopyright;

        return( S_OK );
        END_STDMETHOD(CWrdBrk::GetLicenseToUse, s_tagWordBreaker);
    }

protected:

    BOOL m_fInitialize;
    BOOL m_fQueryTime;
    ULONG m_ulMaxTokenSize;
    LCID m_lcid;

public:

    CComPtr<IUnknown> m_pUnkMarshaler;

};

/////////////////////////////////////////////////////////////////////////////
// CEngUSWrdBrk
class ATL_NO_VTABLE CEngUSWrdBrk :
    public CBaseWrdBrk<CEngUSWrdBrk, &CLSID_EngUSWrdBrk, IDR_ENGUSWRDBRK, CTokenizer>
{
public:
    CEngUSWrdBrk() :
      CBaseWrdBrk<CEngUSWrdBrk, &CLSID_EngUSWrdBrk, IDR_ENGUSWRDBRK, CTokenizer>
          (MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
           SORT_DEFAULT ))

    {
    }

};

/////////////////////////////////////////////////////////////////////////////
// CEngUKWrdBrk

class ATL_NO_VTABLE CEngUKWrdBrk :
    public CBaseWrdBrk<CEngUKWrdBrk, &CLSID_EngUKWrdBrk, IDR_ENGUKWRDBRK, CTokenizer>
{
public:
    CEngUKWrdBrk() :
      CBaseWrdBrk<CEngUKWrdBrk, &CLSID_EngUKWrdBrk, IDR_ENGUKWRDBRK, CTokenizer>
          (MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK),
           SORT_DEFAULT ))

    {
    }

};

/////////////////////////////////////////////////////////////////////////////
// CFrnFrnWrdBrk

class ATL_NO_VTABLE CFrnFrnWrdBrk :
    public CBaseWrdBrk<CFrnFrnWrdBrk, &CLSID_FrnFrnWrdBrk, IDR_FRNFRNWRDBRK, CFrenchTokenizer>
{
public:
    CFrnFrnWrdBrk() :
      CBaseWrdBrk<CFrnFrnWrdBrk, &CLSID_FrnFrnWrdBrk, IDR_FRNFRNWRDBRK, CFrenchTokenizer>
          (MAKELCID(MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH),
           SORT_DEFAULT ))

    {
    }

};


/////////////////////////////////////////////////////////////////////////////
// CItlItlWrdBrk

class ATL_NO_VTABLE CItlItlWrdBrk :
    public CBaseWrdBrk<CItlItlWrdBrk, &CLSID_ItlItlWrdBrk, IDR_ITLITLWRDBRK, CTokenizer>
{
public:
    CItlItlWrdBrk() :
      CBaseWrdBrk<CItlItlWrdBrk, &CLSID_ItlItlWrdBrk, IDR_ITLITLWRDBRK, CTokenizer>
          (MAKELCID(MAKELANGID(LANG_ITALIAN, SUBLANG_ITALIAN),
           SORT_DEFAULT ))

    {
    }

};

/////////////////////////////////////////////////////////////////////////////
// CSpnMdrWrdBrk

class ATL_NO_VTABLE CSpnMdrWrdBrk :
    public CBaseWrdBrk<CSpnMdrWrdBrk, &CLSID_SpnMdrWrdBrk, IDR_SPNMDRWRDBRK, CSpanishTokenizer>
{
public:
    CSpnMdrWrdBrk() :
      CBaseWrdBrk<CSpnMdrWrdBrk, &CLSID_SpnMdrWrdBrk, IDR_SPNMDRWRDBRK, CSpanishTokenizer>
          (MAKELCID(MAKELANGID(LANG_SPANISH , SUBLANG_SPANISH_MODERN),
           SORT_DEFAULT ))

    {
    }

};


#endif //__WRDBRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\memorymanagement.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  MemoryManagement.h
//      Purpose  :  To collect all memory management issues.
//
//      Project  :  Persistent Query
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Apr 13 2000 urib  Creation
//
////////////////////////////////////////////////////////////////////////////////

#ifndef MEMORYMANAGEMENT_H
#define MEMORYMANAGEMENT_H

#include "Excption.h"
#include "Excption.h"

#if !(defined(_PQS_LEAK_DETECTION) && defined(_DEBUG))

////////////////////////////////////////////////////////////////////////////////
//
//  Debug OFF
//  Debug OFF
//  Debug OFF
//
////////////////////////////////////////////////////////////////////////////////

inline
void* __cdecl operator new(size_t s) throw (CMemoryException)
{
    void *p = malloc(s);
    if (NULL == p)
    {
        throw CMemoryException(L"Define _PQS_LEAK_DETECTION for real data here",
                               0);
    }

    return p;
}

#else // !(defined(_PQS_LEAK_DETECTION) && defined(_DEBUG))

////////////////////////////////////////////////////////////////////////////////
//
//  Debug ON
//  Debug ON
//  Debug ON
//
////////////////////////////////////////////////////////////////////////////////

#include    <new>
#include    <new.h>
#include    <crtdbg.h>
#include    <stdlib.h>
#include    "Injector.h"
#include    "Excption.h"



////////////////////////////////////////////////////////////////////////////////
//
//  Throws an exception in case it is recommended by the injector.
//
////////////////////////////////////////////////////////////////////////////////
inline
void Inject(
    ULONG           ulSize,
    const char *    szFileName,
    int             nLine)
{
    if (DoInjection(ulSize, szFileName, nLine))
    {
        THROW_MEMORY_EXCEPTION();
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//  Add injection to the CRT debug allocation routines.
//
////////////////////////////////////////////////////////////////////////////////
inline
void* dbgRealloc(
    void * p,
    size_t s,
    const char * szFileName,
    int nLine)
{
    Inject(s,szFileName,nLine);
    return _realloc_dbg(p, s, _NORMAL_BLOCK, szFileName, nLine);
}

inline
void* dbgMalloc(
        unsigned int s,
        const char * szFileName,
        int nLine
        )
{
    Inject(s,szFileName,nLine);
    return _malloc_dbg(s, _NORMAL_BLOCK, szFileName, nLine);
}

////////////////////////////////////////////////////////////////////////////////
//
//  Add exception throwing on NULL allocation. Add Injector support.
//
////////////////////////////////////////////////////////////////////////////////
inline
void* __cdecl operator new(size_t s, const char* pszFile, unsigned long ulLine)
						        throw (CMemoryException)
{
    Inject(s, pszFile, ulLine);

    void *p = _malloc_dbg(s, _NORMAL_BLOCK, pszFile, ulLine);
    if (NULL == p)
    {
        WCHAR   rwchFilename[1000];

        mbstowcs(rwchFilename,
                 pszFile,
                 sizeof(rwchFilename) / sizeof(rwchFilename[0]));


        throw CMemoryException(rwchFilename, ulLine);
    }

    return p;
}


////////////////////////////////////////////////////////////////////////////////
//
//  Unwinding placment delete operator exists only in VC 6 and up
//
////////////////////////////////////////////////////////////////////////////////
inline
void __cdecl operator delete(void * _P, const char *, unsigned long)
{
    ::operator delete(_P);
}



////////////////////////////////////////////////////////////////////////////////
//
//  Redirect malloc, realloc and new to the debug version specifying
//    allocation location.
//
////////////////////////////////////////////////////////////////////////////////

#undef  malloc
#define malloc(s)         dbgMalloc(s, __FILE__, __LINE__)

#undef  realloc
#define realloc(p, s)     dbgRealloc(p, s, __FILE__, __LINE__)

#define DEBUG_NEW new(__FILE__,__LINE__)
#define new DEBUG_NEW


#endif // !(defined(_PQS_LEAK_DETECTION) && defined(_DEBUG))


#endif MEMORYMANAGEMENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\varbuff.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  VarBuff.h
//      Purpose  :  To hold the definition for the variable length buffer.
//                    One should remember not to take pointers into the buffer
//                    since it can be reallocated automatically.
//                    Errors are reported via exceptions (CMemoryException()).
//
//      Project  :  FTFS
//      Component:
//
//      Author   :  urib
//
//      Log:
//          Feb  2 1997 urib  Creation
//          Feb 25 1997 urib  Fix compilation error in constructor.
//          Jan 26 1999 urib  Allow zero initial size.
//          May  1 2000 urib  Allow specification of allocated size.
//          May 14 2000 urib  Add support for embedded initial array.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef VARBUFF_H
#define VARBUFF_H

#include "Excption.h"
#include "AutoPtr.h"

////////////////////////////////////////////////////////////////////////////////
//
//  CVarBuffer class definition
//
////////////////////////////////////////////////////////////////////////////////

template<class T, ULONG ulInitialEmbeddedSizeInItems = 1>
class CVarBuffer
{
  public:
    // Constructor
    CVarBuffer(ULONG ulInitialSizeInItems = 0,
               ULONG ulInitialAllocatedSizeInItems = 10);

    // Concatenates the given buffer to this buffer.
    void    Cat(ULONG ulItems, T* pMemory);

    // Copies the given buffer to this buffer.
    void    Cpy(ULONG ulItems, T* pMemory);

    // Return the buffer's memory.
    T*      GetBuffer();

    // Returns the buffer's size. The size is set by the initial value given to
    //   the constructor, Cat, Cpy, operations beyond the current size or Calls
    //   to the SetSize function.
    ULONG   GetSize();

    // Set the buffer minimal size.
    void    SetSize(ULONG ulNewSizeInItems);

    // Act as a buffer.
    operator T*();

  protected:

    // This function enlarges the array.
    void    Double();

    bool    IsAllocated();

    T*      GetEmbeddedArray();

    // A pointer to the buffer
    CAutoMallocPointer<T>   m_aptBuffer;

    // An embedded initial buffer
    byte    m_rbEmbeddedBuffer[ulInitialEmbeddedSizeInItems * sizeof(T)];

    // The used portion of the buffer.
    ULONG   m_ulSizeInItems;

    // The allocated portion of the buffer.
    ULONG   m_ulAllocatedInItems;
};

//////////////////////////////////////////////////////////////////////////////*/
//
//  CVarBuffer class implementation
//
//////////////////////////////////////////////////////////////////////////////*/

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::CVarBuffer
//      Purpose  :  Initialize the buffer, allocate memory.
//                    Set the used buffer size to be ulInitialSizeInItems.
//                    May throw a CMemoryException on low memory.
//
//      Parameters:
//          [in]    ULONG ulInitialSizeInItems
//
//      Returns  :   [N/A]
//
//      Log:
//          Feb 25 1997 urib  Creation
//          Jan 28 1999 urib  Allow 0 size buffers.
//          May  1 2000 urib  Allow specification of allocated size.
//
////////////////////////////////////////////////////////////////////////////////
template<class T, ULONG ulInitialEmbeddedSizeInItems>
inline
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::CVarBuffer(
        ULONG ulInitialSizeInItems,
        ULONG ulInitialAllocatedSizeInItems)
    :m_aptBuffer(GetEmbeddedArray(), false)
    ,m_ulSizeInItems(ulInitialSizeInItems)
    ,m_ulAllocatedInItems(ulInitialEmbeddedSizeInItems)
{
    //
    //  Allocation cannot be smaller than size.
    //
    if (ulInitialAllocatedSizeInItems < ulInitialSizeInItems)
    {
        ulInitialAllocatedSizeInItems = ulInitialSizeInItems;
    }

    //
    //  Allocate if needed.
    //
    if (m_ulAllocatedInItems < ulInitialAllocatedSizeInItems)
    {
        m_aptBuffer = (T*) malloc (sizeof(T) * ulInitialAllocatedSizeInItems);
        if(!m_aptBuffer.IsValid())
        {
            THROW_MEMORY_EXCEPTION();
        }

        m_ulAllocatedInItems = ulInitialAllocatedSizeInItems;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Cat
//      Purpose  :  Concatenate this memory to the buffer's end. Reallocates
//                    if needed. Sets the size to the size before the
//                    call + ulItems.
//                    May throw a CMemoryException on low memory.
//
//      Parameters:
//          [in]    ULONG   ulItems
//          [in]    T*      ptMemory
//
//      Returns  :   [N/A]
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, ULONG ulInitialEmbeddedSizeInItems>
inline
void
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Cat(ULONG ulItems, T* ptMemory)
{
    // Remember the size before changing it
    ULONG ulLastSize = m_ulSizeInItems;

    // Change the size - allocate if needed
    SetSize(m_ulSizeInItems + ulItems);

    // Copy the new data to the buffer
    memcpy(GetBuffer() + ulLastSize, ptMemory, ulItems * sizeof(T));
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Cpy
//      Purpose  :  Copy this memory to the buffer (from the beginning).
//                    Set the used buffer size to be ulItems.
//                    May throw a CMemoryException on low memory.
//
//      Parameters:
//          [in]    ULONG   ulItems
//          [in]    T*      ptMemory
//
//      Returns  :   [N/A]
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, ULONG ulInitialEmbeddedSizeInItems>
inline
void
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Cpy(ULONG ulItems, T* ptMemory)
{
    m_ulSizeInItems = 0;
    Cat(ulItems, ptMemory);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::GetBuffer
//      Purpose  :  Return the actual memory. Don't save the return value in a
//                    pointer since the buffer may reallocate. Save the offset.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   T* - the buffer.
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, ULONG ulInitialEmbeddedSizeInItems>
inline
T*
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::GetBuffer()
{
    return m_aptBuffer.Get();
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::GetSize
//      Purpose  :  Return the size of the buffer. The return value of this
//                    function is set by SetSize, Cpy, Cat, and the size
//                    specified in the constructor.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   ULONG
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, ULONG ulInitialEmbeddedSizeInItems>
inline
ULONG
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::GetSize()
{
    return m_ulSizeInItems;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::SetSize
//      Purpose  :  Sets the size in items to be ulNewSizeInItems.
//                    May throw a CMemoryException on low memory.
//
//      Parameters:
//          [in]    ULONG ulNewSizeInItems
//
//      Returns  :   [N/A]
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, ULONG ulInitialEmbeddedSizeInItems>
inline
void
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::SetSize(ULONG ulNewSizeInItems)
{
    // While the buffer is not in the proper size keep growing.
    while (ulNewSizeInItems > m_ulAllocatedInItems)
        Double();

    // OK. We're big. Set the size.
    m_ulSizeInItems = ulNewSizeInItems;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::operator void*()
//      Purpose  :  To return a pointer to the buffer.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   T*
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, ULONG ulInitialEmbeddedSizeInItems>
inline
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::operator T*()
{
    return GetBuffer();
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Double
//      Purpose  :  Double the alocated memory size. Not the used size.
//                    May throw a CMemoryException on low memory.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, ULONG ulInitialEmbeddedSizeInItems>
inline
void
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Double()
{
    ULONG ulNewAllocatedSizeInItems = 2 * m_ulAllocatedInItems;

    T* ptTemp;

    if (!IsAllocated())
    {
        ptTemp = (T*)malloc(ulNewAllocatedSizeInItems * sizeof(T));
        if (!ptTemp)
        {
            THROW_MEMORY_EXCEPTION();
        }

        memcpy(ptTemp, m_aptBuffer.Get(), m_ulSizeInItems * sizeof(T));
    }
    else
    {
        ptTemp = (T*)realloc(m_aptBuffer.Get(),
            ulNewAllocatedSizeInItems * sizeof(T));
        if (!ptTemp)
        {
            THROW_MEMORY_EXCEPTION();
        }

        m_aptBuffer.Detach();
    }

    m_aptBuffer = ptTemp;

    m_ulAllocatedInItems = ulNewAllocatedSizeInItems;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::::IsAllocated()
//      Purpose  :  A predicate to easily test if we still use the embedded
//                    array or not.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   bool - true - an alternative array was allocated.
//
//      Log:
//          May 14 2000 urib  Creation
//
////////////////////////////////////////////////////////////////////////////////

template<class T, ULONG ulInitialEmbeddedSizeInItems>
inline
bool
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::IsAllocated()
{
    return m_aptBuffer.Get() != GetEmbeddedArray();
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulIni...zeInItems>::GetEmbeddedArray()
//      Purpose  :  Return the embedded array.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          May 14 2000 urib  Creation
//
////////////////////////////////////////////////////////////////////////////////

template<class T, ULONG ulInitialEmbeddedSizeInItems>
inline
T*
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::GetEmbeddedArray()
{
    return (T*) m_rbEmbeddedBuffer;
}

#endif /* VARBUFF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\vararray.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  VarArray.h
//      Purpose  :  To define a variable size array.
//
//      Project  :  FTFS
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Feb 23 1997 urib  Creation
//          Sep 14 1997 urib  Allow VarArray to behave like a C array - buffer.
//          Oct 21 1997 urib  Fix bug in resizing. Add a GetSize method.
//          Jan 26 1999 urib  Fix bug #23 VarArray constructor bug.
//          Apr 16 2000 LiorM Performance: CVarArray with and w/o ctor dtor
//          Dec 24 2000 urib  Add an initial embedded array
//          Jan  9 2001 urib  Fix a bug in SetSize.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef VARARRAY_H
#define VARARRAY_H

#include <new.h>
#include "Tracer.h"
#include "VarBuff.h"

////////////////////////////////////////////////////////////////////////////////
//
//  CVarArray class definition
//
////////////////////////////////////////////////////////////////////////////////

template <class T, ULONG ulInitialEmbeddedSizeInItems = 1, bool FSIMPLE = false>
class CVarArray :
    // Hide buffer functionallity.
    protected CVarBuffer<T, ulInitialEmbeddedSizeInItems>

{
public:
    typedef CVarBuffer<T, ulInitialEmbeddedSizeInItems> CVarBufferBaseType;

    // Constructor - user can specify recomended initial allocation size.
    CVarArray(ULONG ulInitialSizeInItems = 0)
        :CVarBufferBaseType(ulInitialSizeInItems)
    {
        if (!FSIMPLE)
        {

            ULONG ulCurrent;

            for (ulCurrent = 0; ulCurrent < ulInitialSizeInItems; ulCurrent++)
                Construct(GetCell(ulCurrent));

        }
    }

    // Returns the array size
    ULONG   GetSize()
    {
        return  CVarBufferBaseType::GetSize();
    }

    // Calls the buffer SetSize, and initialize the new cells.
    void    SetSize(ULONG ulNewSizeInItems)
    {
        if (!FSIMPLE)
        {
            ULONG ulSize = GetSize();

            //
            //  Optimization - if the increase is big we do't want to have
            //    several allocation caused by several GetCell calls.
            //
            CVarBufferBaseType::SetSize(ulNewSizeInItems);

            ULONG ulCurrent;

            //
            //  If size is decreasing destruct the erased cells
            //
            for (ulCurrent = ulNewSizeInItems; ulCurrent < ulSize; ulCurrent++)
                Destruct(GetCell(ulCurrent));

            //
            //  If size is increasing construct the new cells
            //
            for (ulCurrent = ulSize; ulCurrent < ulNewSizeInItems; ulCurrent++)
                Construct(GetCell(ulCurrent));
        }

        //
        //  Mark the true current size
        //
        CVarBufferBaseType::SetSize(ulNewSizeInItems);

        Assert(GetSize() == ulNewSizeInItems);
    }

    // Act like an array.
    T& operator[](ULONG ul)
    {
        return *GetCell(ul);
    }

    // Act like a C array - memory buffer.
    operator T* ()
    {
        return GetCell(0);
    }

    // Call cells destructors
    ~CVarArray()
    {
        if (!FSIMPLE)
        {
            ULONG ulCurrent;
            for (ulCurrent = 0; ulCurrent < GetSize(); ulCurrent++)
            {
                T* pt = GetCell(ulCurrent);

                Destruct(pt);
            }
        }
    }

  protected:
    // Helper fuction to return the address on a cell.
    T*  GetCell(ULONG ul)
    {
        if (GetSize() < ul + 1)
            SetSize(ul + 1);

        return GetBuffer() + ul;
    }

    static
    T*  Construct(void* p)
    {
#ifdef _PQS_LEAK_DETECTION
#undef new
#endif
        return new(p) T;
#ifdef _PQS_LEAK_DETECTION
#define new DEBUG_NEW
#endif
    }

    static
    void Destruct(T* pt)
    {
        pt->~T();
    }
};

#endif /* VARARRAY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\regkey.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  RegKey.h
//      Purpose  :  To contain a registry key.
//
//      Project  :  Common
//      Component:
//
//      Author   :  urib
//
//      Log:
//          Dec  5 1996 urib Creation
//          Jan  1 1997 urib Change GetValue to QueryValue.
//          Mar  2 1997 urib Add iterator of subkeys.
//          Apr 15 1997 urib Add QueryValue that recieves VarString.
//                             Move to UNICODE.
//          Jun 12 1997 urib Documentation fix.
//          Oct 21 1997 urib  Support boolean QueryValue.
//          Nov 18 1997 dovh  Added PWSTR SetValue.
//          Aug 17 1998 urib  More creation options. Better exceptions.
//          Feb 11 1999 urib  Fix prototypes const behavior.
//          Mar 15 2000 urib  Add CReadOnlyRegistryKey class.
//          Nov  8 2000 urib  Support evironment variables in registry values.
//
////////////////////////////////////////////////////////////////////////////////
#ifndef REGKEY_H
#define REGKEY_H

#include "Base.h"
#include "VarTypes.h"
#include "Excption.h"

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CRegistryKey - definition
//
////////////////////////////////////////////////////////////////////////////////

class CRegistryKey
{
  public:
    // Constructor - Initialize from an open handle and a path.
    CRegistryKey(
        HKEY       hkOpenedKey,
        PCWSTR     pwszPathToKey,
        DWORD      dwCreationDisposition = OPEN_ALWAYS,
        REGSAM     samDesired = KEY_ALL_ACCESS);

    // Close the key.
    ~CRegistryKey() {RegCloseKey(m_hkKey);}

    // Behave like a handle.
    operator HKEY() {return m_hkKey;}

    // Query string values
    LONG QueryValue(
        PCWSTR  pwszValueName,
        PWSTR   pwszBuffer,
        ULONG&  ulBufferSizeInBytes);

    // Query string values
    LONG QueryValue(
        PCWSTR      pwszValueName,
        CVarString& vsData);

    // Query 32 bit values
    LONG QueryValue(
        PCWSTR  pwszValueName,
        DWORD&  dwValue);

    // Query boolean values
    LONG QueryValue(
        PCWSTR  pwszValueName,
        bool&   fValue);

    // Set 32 bit values
    LONG SetValue(
        PCWSTR  pwszValueName,
        DWORD   dwValue);

    // Set wide charachter string values
    LONG
    CRegistryKey::SetValue(
        PCWSTR pwszValueName,
        PCWSTR pwszValueData
        );

    // Iterator for subkeys.
    class CIterator
    {
      public:
        // Advance one step.
        BOOL    Next();

        // Return the name of the current subkey.
        operator PWSTR() {return m_rwchSubKeyName;}

        // Free the iterator.
        ULONG
        Release() {delete this; return 0;}

      protected:
        // Hidden constructor so one can get this class only via GetIterator
        CIterator(CRegistryKey*   prkKey);

        // The index of the subkey enumerated.
        ULONG m_ulIndex;

        // Pointer to the registry key that created us.
        CRegistryKey*   m_prkKey;

        // the current subkey name.
        WCHAR   m_rwchSubKeyName[MAX_PATH + 1];

        // enable registry key to create us.
        friend CRegistryKey;
    };

    // Allocates and returns an iterator for subkeys
    CIterator* GetIterator();

protected:
    // Query string values without expanding environment variables
    LONG QueryStringValueNoEnvExpansion(
        PCWSTR  pwszValueName,
        PWSTR   pwszBuffer,
        ULONG&  ulBufferSizeInBytes,
        bool   *pfValueTypeExpand);

    // Query string values without expanding environment variables
    LONG QueryStringValueNoEnvExpansion(
        PCWSTR      pwszValueName,
        CVarString& vsData,
        bool       *pfValueTypeExpand);

private:
    // The registry key handle.
    HKEY m_hkKey;
};

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CReadOnlyRegistryKey - definition
//
////////////////////////////////////////////////////////////////////////////////
class CReadOnlyRegistryKey : public CRegistryKey
{
public:
    CReadOnlyRegistryKey(
        HKEY       hkOpenedKey,
        PCWSTR     pwszPathToKey)
        :CRegistryKey(
            hkOpenedKey,
            pwszPathToKey,
            OPEN_EXISTING,
            KEY_READ)
    {
    }

protected:
    // Set 32 bit values
    LONG
    SetValue(
        PCWSTR  pwszValueName,
        DWORD   dwValue);

    // Set wide charachter string values
    LONG
    SetValue(
        PCWSTR pwszValueName,
        PCWSTR pwszValueData
        );
};

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CRegistryKey - implementation
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::CRegistryKey
//      Purpose  :  CTor. Opens/creates the registry key.
//
//      Parameters:
//          [in]     HKEY       hkOpenedKey
//          [in]     PWSTR      pwszPathToKey
//
//      Returns  :   [N/A]
//
//      Log:
//          Apr 15 1997 urib  Creation
//          Aug 17 1998 urib  More creation options. Better exceptions.
//          Mar 15 2000 urib  Add default parameter to allow specifying the
//                              desired acces.
//
////////////////////////////////////////////////////////////////////////////////
inline
CRegistryKey::CRegistryKey(
    HKEY    hkOpenedKey,
    PCWSTR  pwszPathToKey,
    DWORD   dwCreationDisposition,
    REGSAM  samDesired)
    :m_hkKey(0)
{
    LONG    lRegistryReturnCode;
    DWORD   dwOpenScenario;

    switch (dwCreationDisposition)
    {
    case CREATE_ALWAYS: // Create a new key - erase existing one.
        lRegistryReturnCode = RegDeleteKey(hkOpenedKey, pwszPathToKey);
        if ((ERROR_SUCCESS != lRegistryReturnCode) &&
            (ERROR_FILE_NOT_FOUND != lRegistryReturnCode))
        {
            THROW_WIN32ERROR_EXCEPTION(lRegistryReturnCode);
        }

        // Fall through ...

    case OPEN_ALWAYS:   // Open key - if key does not exist, create it.
    case CREATE_NEW:    // Create a new key - fail if exists.
        lRegistryReturnCode = RegCreateKeyEx(
            hkOpenedKey,
            pwszPathToKey,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            samDesired,
            NULL,
            &m_hkKey,
            &dwOpenScenario);
        if (ERROR_SUCCESS != lRegistryReturnCode)
        {
            THROW_WIN32ERROR_EXCEPTION(lRegistryReturnCode);
        }
        else if ((REG_OPENED_EXISTING_KEY == dwOpenScenario) &&
                 (OPEN_ALWAYS != dwCreationDisposition))
        {
            THROW_WIN32ERROR_EXCEPTION(ERROR_ALREADY_EXISTS);
        }
        break;

    case OPEN_EXISTING: // Open existing key - fail if key doesn't exist.
        lRegistryReturnCode = RegOpenKeyEx(
            hkOpenedKey,
            pwszPathToKey,
            0,
            samDesired,
            &m_hkKey);
        if (ERROR_SUCCESS != lRegistryReturnCode)
        {
            THROW_WIN32ERROR_EXCEPTION(lRegistryReturnCode);
        }
        break;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryValue
//      Purpose  :  Query a registry string value into a buffer.
//
//      Parameters:
//          [in]    PCWSTR  pwszValueName
//          [out]   PWSTR   pwszBuffer
//          [out]   ULONG&  ulBufferSizeInBytes
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//          Nov  8 2000 urib  Support evironment variables in registry values.
//
////////////////////////////////////////////////////////////////////////////////
inline
LONG
CRegistryKey::QueryValue(
    PCWSTR  pwszValueName,
    PWSTR   pwszBuffer,
    ULONG&  ulBufferSizeInBytes)
{
    LONG    lRegistryReturnCode;
    ULONG   ulBufferSizeInWchar = ulBufferSizeInBytes / sizeof(WCHAR);

    bool    bIsExpanded;

    DWORD       dwResult;
    CVarString  vsBeforExpansion;

    Assert(sizeof(TCHAR) == sizeof(WCHAR));


    lRegistryReturnCode = QueryStringValueNoEnvExpansion(
        pwszValueName,
        pwszBuffer,
        ulBufferSizeInBytes,
        &bIsExpanded);
    if ((ERROR_SUCCESS != lRegistryReturnCode) &&
        (ERROR_MORE_DATA != lRegistryReturnCode))
    {
        return lRegistryReturnCode;
    }

    if  (bIsExpanded)
    {
        //
        //  We need the string value either for calculating the required length
        //    or for actually returning the data
        //
        if ((ERROR_MORE_DATA == lRegistryReturnCode) ||
            (NULL == pwszBuffer))
        {
            //
            // We are just calculating...
            //

            lRegistryReturnCode = QueryStringValueNoEnvExpansion(
                pwszValueName,
                vsBeforExpansion,
                &bIsExpanded);
            if (ERROR_SUCCESS != lRegistryReturnCode)
            {
                return lRegistryReturnCode;
            }
        }
        else
        {
            vsBeforExpansion.Cpy(pwszBuffer);
        }

        {
            WCHAR   wchDummieString;
            ULONG   ulExpansionBufferSizeInWchar = ulBufferSizeInWchar;

            if (NULL == pwszBuffer)
            {
                pwszBuffer = &wchDummieString;
                ulExpansionBufferSizeInWchar = 1;
            }

            dwResult = ExpandEnvironmentStrings(
                vsBeforExpansion,   // string with environment variables
                pwszBuffer,         // string with expanded strings
                ulExpansionBufferSizeInWchar);
                                    // maximum characters in expanded string
            if (0 == dwResult)
            {
                return ERROR_BAD_ENVIRONMENT;
            }

            //
            //  Return the final size number in bytes through ulBufferSizeInBytes
            //

            ulBufferSizeInBytes = dwResult * sizeof(WCHAR);

            if (dwResult > ulBufferSizeInWchar)
                return ERROR_MORE_DATA;

        }
    }

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryStringValueNoEnvExpansion
//      Purpose  :  Query a registry string value into a buffer.
//                    Do not expand environment variables
//
//      Parameters:
//          [in]    PCWSTR  pwszValueName
//          [out]   PWSTR   pwszBuffer
//          [out]   ULONG&  ulBufferSizeInBytes
//          [out]   bool*   pfValueTypeExpand
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//          Nov  8 2000 urib  Support evironment variables in registry values.
//
////////////////////////////////////////////////////////////////////////////////
inline
LONG
CRegistryKey::QueryStringValueNoEnvExpansion(
    PCWSTR  pwszValueName,
    PWSTR   pwszBuffer,
    ULONG&  ulBufferSizeInBytes,
    bool   *pbValueTypeExpand)
{
    LONG    lRegistryReturnCode;
    DWORD   dwValueType;

    lRegistryReturnCode = RegQueryValueEx(
        m_hkKey,
        pwszValueName,
        NULL,
        &dwValueType,
        (LPBYTE)pwszBuffer,
        &ulBufferSizeInBytes);

    if ((REG_SZ != dwValueType) &&
        (REG_EXPAND_SZ != dwValueType))
        return ERROR_BAD_FORMAT;

    if (pbValueTypeExpand)
    {
        *pbValueTypeExpand = (REG_EXPAND_SZ == dwValueType);
    }

    return lRegistryReturnCode;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryValue
//      Purpose  :  Query a registry string value into a CVarString.
//
//      Parameters:
//          [in]    PCWSTR      pwszValueName
//          [out]   CVarString& vsData
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
LONG
CRegistryKey::QueryValue(
    PCWSTR      pwszValueName,
    CVarString& vsData)
{
    LONG    lRegistryReturnCode;
    DWORD   dwBufferSize;

    lRegistryReturnCode = QueryValue(
        pwszValueName,
        NULL,
        dwBufferSize);
    if (ERROR_SUCCESS == lRegistryReturnCode)
    {
        vsData.SetMinimalSize(dwBufferSize + 1);

        lRegistryReturnCode = QueryValue(
            pwszValueName,
            (PWSTR)vsData,
            dwBufferSize);
    }

    return lRegistryReturnCode;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryStringValueNoEnvExpansion
//      Purpose  :  Query a registry string value into a CVarString.
//
//      Parameters:
//          [in]    PCWSTR      pwszValueName
//          [out]   CVarString& vsData
//          [out]   bool       *pbValueTypeExpand
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
LONG
CRegistryKey::QueryStringValueNoEnvExpansion(
    PCWSTR      pwszValueName,
    CVarString& vsData,
    bool       *pbValueTypeExpand)
{
    LONG    lRegistryReturnCode;
    DWORD   dwBufferSize;

    lRegistryReturnCode = QueryStringValueNoEnvExpansion(
        pwszValueName,
        NULL,
        dwBufferSize,
        pbValueTypeExpand);
    if (ERROR_SUCCESS == lRegistryReturnCode)
    {
        vsData.SetMinimalSize(dwBufferSize + 1);

        lRegistryReturnCode = QueryStringValueNoEnvExpansion(
            pwszValueName,
            (PWSTR)vsData,
            dwBufferSize,
            pbValueTypeExpand);
    }

    return lRegistryReturnCode;
}


/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryValue
//      Purpose  :  Query a registry 32 bit value.
//
//      Parameters:
//          [in]    PCWSTR   pwszValueName
//          [out]   DWORD&   dwValue
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
inline
LONG
CRegistryKey::QueryValue(
    PCWSTR  pwszValueName,
    DWORD&  dwValue)
{
    LONG    lRegistryReturnCode;
    DWORD   dwValueType;
    DWORD   dwValueSize;

    // Read disk flag
    dwValueSize = sizeof(dwValue);

    lRegistryReturnCode = RegQueryValueEx(
        m_hkKey,
        pwszValueName,
        NULL,
        &dwValueType,
        (LPBYTE)&dwValue,
        &dwValueSize);
    if (REG_DWORD != dwValueType)
        return ERROR_BAD_FORMAT;

    return lRegistryReturnCode;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryValue
//      Purpose  :  Query a registry boolean value.
//
//      Parameters:
//          [in]    PCWSTR  pwszValueName
//          [out]   bool&   fValue
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
inline
LONG
CRegistryKey::QueryValue(
    PCWSTR  pwszValueName,
    bool&   fValue)
{
    LONG    lRegistryReturnCode;
    DWORD   dwValueType;
    DWORD   dwValueSize;
    DWORD   dwValue;

    // Read disk flag
    dwValueSize = sizeof(dwValue);

    lRegistryReturnCode = RegQueryValueEx(
        m_hkKey,
        pwszValueName,
        NULL,
        &dwValueType,
        (LPBYTE)&dwValue,
        &dwValueSize);
    if (REG_DWORD != dwValueType)
        return ERROR_BAD_FORMAT;

    fValue = !!dwValue;

    return lRegistryReturnCode;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::SetValue
//      Purpose  :  To set a 32 bit registry value.
//
//      Parameters:
//          [in]    PCWSTR  pwszValueName
//          [in]    DWORD   dwValue
//
//      Returns  :   [N/A]
//
//      Log:
//          Apr 15 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
inline
LONG
CRegistryKey::SetValue(
    PCWSTR  pwszValueName,
    DWORD   dwValue)
{
    LONG    lRegistryReturnCode;

    lRegistryReturnCode = RegSetValueEx(
        m_hkKey,
        pwszValueName,
        NULL,
        REG_DWORD,
        (PUSZ)&dwValue,
        sizeof(DWORD));

    return lRegistryReturnCode;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::SetValue
//      Purpose  :  To set a wide character string value
//
//      Parameters:
//          [in]    PCWSTR  pwszValueName
//          [in]    PCWSTR  pwszValueData
//
//      Returns  :   [N/A]
//
//      Log:
//          Nov 16 1997 DovH Creation
//
//////////////////////////////////////////////////////////////////////////////*/
inline
LONG
CRegistryKey::SetValue(
    PCWSTR  pwszValueName,
    PCWSTR  pwszValueData
    )
{
    LONG    lRegistryReturnCode;

    lRegistryReturnCode =

    RegSetValueEx(
        m_hkKey,
        pwszValueName,
        NULL,
        REG_SZ,
        (BYTE*)pwszValueData,
        (wcslen(pwszValueData)+1) * sizeof(WCHAR)
        );

    return lRegistryReturnCode;

} // CRegistryKey::SetValue

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::GetIterator
//      Purpose  :  To return a subkey enumerator.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   CRegistryKey::CIterator*
//
//      Log:
//          Apr 15 1997 urib  Creation
//          Aug 17 1998 urib  Better exceptions.
//
//////////////////////////////////////////////////////////////////////////////*/
inline
CRegistryKey::CIterator*
CRegistryKey::GetIterator()
{
    CIterator* pit;
    pit = new CIterator(this);
    
    return pit;
}

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CRegistryKey::CIterator - implementation
//
////////////////////////////////////////////////////////////////////////////////

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey:CIterator::Next
//      Purpose  :  Advance to the next subkey.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   BOOL
//
//      Log:
//          Apr 15 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
inline
BOOL
CRegistryKey::CIterator::Next()
{
    LONG    lResult;

    lResult = RegEnumKey(
        *m_prkKey,
        m_ulIndex,
        m_rwchSubKeyName,
        MAX_PATH);

    if (ERROR_SUCCESS  == lResult)
    {
        m_ulIndex++;
        return TRUE;
    }
    else if (ERROR_NO_MORE_ITEMS == lResult)
        return FALSE;
    else
    {
        Assert(0);
        return FALSE;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CIterator::CRegistryKey::CIterator
//      Purpose  :  CTor.
//
//      Parameters:
//          [in]    CRegistryKey*   prkKey
//
//      Returns  :   [N/A]
//
//      Log:
//          Apr 15 1997 urib Creation
//          Aug 17 1998 urib  Better exceptions.
//
//////////////////////////////////////////////////////////////////////////////*/
inline
CRegistryKey::CIterator::CIterator(CRegistryKey*   prkKey)
    :m_ulIndex(0)
    ,m_prkKey(prkKey)
{
    if (!Next())
        THROW_WIN32ERROR_EXCEPTION(ERROR_CANTOPEN);
}

#endif // REGKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\gtable.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  GTable.h
//      Purpose  :  True Global tables class defilitions
//
//      Project  :  PQS
//      Component:  FILTER
//
//      Author   :  dovh
//
//      Log      :  Nov-11-1998 dovh - Creation
//
//      Dec-01-1998 dovh - Add tags.cxx functionality
//          replace read tags file.
//      Jan-18-1999 dovh - Add CFE_BitseTables.
//      Jan-26-1999 dovh - Add CFE_GlobalConstTable fields.
//      Feb-02-1999 dovh - Move AddSectionTags: Gtable ==> FEGlobal
//      May-16-1999 urib - Move separator map : Gtable ==> FEGlobal
//      Dec-11-2000 dovh - MapToUpper: Assert the argument is in the
//                         correct range
//
////////////////////////////////////////////////////////////////////////////////

#ifndef   __G_TABLE_H__
#define   __G_TABLE_H__
#include "excption.h"
//
//  G L O B A L   C O N S T A N T   M A C R O S :
//

#define PQS_HASH_SEQ_LEN             3
#define XML_HASH_SEQ_LEN             2

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CCToUpper Class Definition
//      Purpose  :  Encapsulate True Immutable Globals.
//
//      Log      :  Nov-11-1998 dovh - Creation
//
//////////////////////////////////////////////////////////////////////////////*/

class CToUpper
{

public:

    CToUpper();

    //
    //  SOME ACCESS FUNCTIONS:
    //
    __forceinline
    static
    WCHAR
    MapToUpper(
        IN WCHAR wc
        )
    {
        extern CToUpper g_ToUpper;
        Assert(wc < 0X10000);
        return g_ToUpper.m_pwcsCaseMapTable[wc];
    }


public:

    WCHAR m_pwcsCaseMapTable[0X10000];

};  // CFE_CToUpper

extern CToUpper g_ToUpper;

inline CToUpper::CToUpper( )
{
    for (WCHAR wch = 0; wch < 0XFFFF; wch++)
    {
        WCHAR wchOut;
        LCMapString(
            LOCALE_NEUTRAL,
            LCMAP_UPPERCASE,
            &wch,
            1,
            &wchOut,
            1 );

        //
        //  Run the full fledged accent removal technique!
        //

        WCHAR pwcsFold[5];

        int iResult = FoldString(
                MAP_COMPOSITE,
                &wchOut,
                1,
                pwcsFold,
                5);

        Assert(iResult);
        Assert(iResult < 5);
        m_pwcsCaseMapTable[wch] = pwcsFold[0];
    }

    m_pwcsCaseMapTable[0XFFFF] = 0XFFFF; // can't put that in the loop since wch is WCHAR (will result in infinit loop)
}

#endif // __G_TABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\trie.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  TRIE.H
//      Purpose  :  Basic C MACROS/DEFS used by the Trie package
//
//      Project  :  PQS
//      Component:  FE_CORE
//
//      Author   :  dovh
//
//      Log      :
//          MMM DD YYYY dovh  Creation
//          Dec 11 1996 DovH  UNICODE Preparation: Convert char to TCHAR.
//          Dec  1 1998 dovh  Use HCFE_GlobalHandle
//          Nov  2 1999 YairH Fix copilation errors.
//          Nov  8 1999 urib  Fix tabulation format.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __TRIE_H__
#define __TRIE_H__

#pragma once

#include "comdefs.h"
#include "gtable.h"
#include "autoptr.h"
#include "excption.h"
#include "tracer.h"

DECLARE_TAG(s_tagTrie, "Trie")

//
//  T R I E   P A C K A G E   F L A G S :
//

#define TRIE_DEFAULT                    0X00000000L

#define TRIE_IGNORECASE                 0X00000001L

#define TRIE_SHORTEST_MATCH             0X00000010L
#define TRIE_LONGEST_MATCH              0X00000020L
#define TRIE_ALL_MATCHES                0X00000040L
#define TRIE_FILTER_VERIFY              0X00000080L

#define TRIE_EXCHANGE_ITEM              0X00000100L
#define TRIE_OUT_BUFFER_EMPTY           0X00000200L

#define TRIE_NODE_SUFFIXCOUNT_INIT              0
#define TRIE_NODE_SUFFIXSIZE_INIT               2

#define DECLARE_TRIE_SENTINEL  CTrieNode<BYTE> g_trie_Sentinel


template <class T, class C = CToUpper >
class CTrieNode
{
public:
    CTrieNode();
    CTrieNode(short sSize);
    CTrieNode(
        T* NewItem,
        ULONG options,
        const WCHAR* NewString,
        ULONG ulCharToCopy = 0xffffffff);
    ~CTrieNode();

    void DeleteItem();

    void
    AddSuffix(
        ULONG options,
        CTrieNode<T, C>* newSuffix,
        USHORT index = 0xffff
        );

    void
    SplitNode(
        CTrieNode<T, C>* parent,            //  Parent of node
        short index,                     //  Index of node in parent->suffix
        const WCHAR * NewString,            //  String sharing prefix with node->string
        size_t charsMatched,
        T* item,                         //  Item associated with (sub)string
        ULONG options                    //  Insertion options
        );

    void Print(ULONG  ulOffset);

    int
    trie_StrMatchIns(
        const WCHAR * s,
        const WCHAR * t,
        size_t * matchCount
        );

    inline
    int
    trie_StrMatch(
        const WCHAR * s,
        const WCHAR * t,
        size_t * matchCount
        );

private:
    void DoubleSuffixArray();

public:
    short suffixCount;                          //  Number of suffixes
    short suffixSize;                           //  Size of suffixes array
    CTrieNode ** suffix;                        //  Pointer to suffixes array

    T* item;                                    //  Pointer to item corresponding to node

    size_t charCount;                           //  String length
    WCHAR* string;                              //  Zero terminated string

public:

};

extern CTrieNode<BYTE> g_trie_Sentinel;


template <class T, class C = CToUpper >
class CTrie
{
public:

    CTrie(bool fDeleteItemsOnDestruction = false);

    ~CTrie();

    DictStatus
    trie_Insert(                            //  Insert string into trie
        const WCHAR * string,               //  String key of item
        unsigned long options,              //  Insertion flags
        T * item,                           //  Item to be inserted
        T ** pTrieItem                      //  Matching item already in trie
        );

    DictStatus
    trie_Find(
        const WCHAR * string,         //  A string
        unsigned long options,        //  Search flags
        short outBufferSize,          //  Max number of results wanted
        T ** outBuffer,               //  Buffer to be filled with matching items
        short * resultCount           //  Number of matching prefixes returned
        );

    void Print();

private:
    CTrieNode<T, C>* root;
    bool fDeleteItems;
};


///////////////////////////////////////////////////////////////////////////////
// CTrieNode implementation
///////////////////////////////////////////////////////////////////////////////

template <class T, class C >
inline CTrieNode<T, C>::CTrieNode() :
    suffixCount(0),
    suffixSize(0),
    charCount(0),
    item(NULL),
    suffix(NULL)
{
    string = new WCHAR[1];
    string[0] = L'\0';
}

template <class T, class C >
inline CTrieNode<T, C>::CTrieNode(short sSize) :
    suffixCount(0),
    suffixSize(sSize),
    string(NULL),
    charCount(0),
    item(NULL),
    suffix(NULL)
{
    Assert(sSize > 0);
    suffix = new CTrieNode<T, C>*[suffixSize];
    memset(suffix,0, suffixSize*sizeof(CTrieNode<T, C>*));
}

template <class T, class C >
inline CTrieNode<T, C>::CTrieNode(
    T* NewItem,
    ULONG options,
    const WCHAR* NewString,
    ULONG ulCharToCopy) :
    suffixCount(TRIE_NODE_SUFFIXCOUNT_INIT),
    suffixSize(TRIE_NODE_SUFFIXSIZE_INIT)
{
    charCount = min(wcslen(NewString), ulCharToCopy);
    CAutoArrayPointer<WCHAR> apwcsNewString = new WCHAR[charCount + 1];
    string = apwcsNewString.Get();

    wcsncpy(string, NewString, charCount);
    string[charCount] = L'\0';

    suffix = new CTrieNode<T, C>*[suffixSize];
    memset(suffix, 0, sizeof(CTrieNode<T, C>*) * suffixSize);
    item = NewItem;

    apwcsNewString.Detach();
}

template <class T, class C >
inline void CTrieNode<T, C>::DeleteItem()
{
    for (short s = 0; s < suffixCount; s++)
    {
        if (suffix[s] != (CTrieNode<T, C>*)&g_trie_Sentinel)
        {
            suffix[s]->DeleteItem();
        }
    }
    delete item;
}

template <class T, class C >
inline CTrieNode<T, C>::~CTrieNode()
{
    Trace(
            elInfo,
            s_tagTrie,(
            "CTrieNode:"
            "Released"));

    for (short s = 0; s < suffixCount; s++)
    {
        if (suffix[s] != (CTrieNode<T, C>*)&g_trie_Sentinel)
        {
            delete suffix[s];
        }
    }
    delete[] suffix;
    delete string;

}

template <class T, class C >
inline
int
CTrieNode<T, C>::trie_StrMatch(
    const WCHAR * s,
    const WCHAR * t,
    size_t * matchCount
    )
{
    const WCHAR * s0 = s;
    const WCHAR * t0 = t;

    //
    //  Straigh K&R ptr version...
    //
    for ( ; *s0 == *t0; s0++, t0++ )
    {
        if (*s0 == TEXT('\0'))
        {
            *matchCount = s0 - s;
            Assert( (*s0 - *t0) == 0 );
            return (0);
        }
    }

    *matchCount = s0 - s;
    return ( *s0 - *t0 );

} // end trie_StrMatch

template <class T, class C >
inline
int
CTrieNode<T, C>::trie_StrMatchIns(
    const WCHAR * s,
    const WCHAR * t,
    size_t * matchCount
    )
{
    const WCHAR * s0 = s;
    const WCHAR * t0 = t;

    //
    //  Straigh K&R ptr version...
    //
    for ( ; C::MapToUpper(*s0) == C::MapToUpper(*t0); s0++, t0++ )
    {
        if (*s0 == TEXT('\0'))
        {
            *matchCount = s0 - s;
            Assert ( (C::MapToUpper(*s0) - C::MapToUpper(*t0)) == 0 );
            return (0);
        }
    }

    *matchCount = s0 - s;
    return ( C::MapToUpper(*s0) - C::MapToUpper(*t0) );

} // end trie_StrMatchIns



/*++
    Function trie_AddSuffix:

        Insert a new suffix into the suffix array of node.

    Routine Parameters:

        node - Add a newSuffix to node->suffix array.

        index - index in node->suffix to at which newSuffix should be added
            to preserve increasing lexicographic ordering on node->suffix.

        newSuffix - new suffix node to be added as child of node.

    Return value:

--*/

template <class T, class C >
inline void
CTrieNode<T, C>::AddSuffix(
    ULONG options,
    CTrieNode<T, C>* newSuffix,
    USHORT index
    )
{
    //
    //  Make sure there is enough room for the new child:
    //
    Assert(suffixCount <= suffixSize);
    if (suffixCount == suffixSize)
    {
        DoubleSuffixArray();
    }

    if (0xffff == index)
    {
        if (options & TRIE_IGNORECASE)
        {
            for ( index=0;
                  (index < suffixCount) &&
                  (C::MapToUpper(suffix[index]->string[0]) < C::MapToUpper(newSuffix->string[0]));
                  index++
                )
                ;
        }
        else
        {
            for ( index=0;
                  (index < suffixCount) &&
                  (suffix[index]->string[0] < newSuffix->string[0]);
                  index++
                )
                ;
        }
    }

#ifdef DEBUG
    if (options & TRIE_IGNORECASE)
    {
        Assert((index == 0 ) ||
               (index == suffixCount) ||
               (C::MapToUpper(suffix[index]->string[0]) > C::MapToUpper(newSuffix->string[0])));
    
    }
    else
    {
        Assert((index == 0 ) ||
               (index == suffixCount) ||
               (suffix[index]->string[0] > newSuffix->string[0]));
    }
#endif

    //
    //  Shift node->suffix[index .. node->suffixCount] one location to the right
    //  to make room for newSuffix at location index:
    //
    if ( index < suffixCount )
    {
        for (short i=suffixCount; i>index; i--)
        {
            suffix[i] = suffix[i-1];
        }
    }
    suffixCount++;

    //
    // WARNING: after the next line do not add more allocations. The new suffix
    // might be an automatic pointer that in this case will be released twice,
    // as part of the destruction of the class and as automatic pointer
    //

    suffix[index] = newSuffix;

} // end AddSuffix

/*++

    Function trie_SplitNode:

        Assume string and node->string has a non-empty common prefix, which
        is a strict substring of node->string.  Splits node->string into the common
        prefix, and the two suffixes (string may be a prefix of node->string) in which
        case the corresponding suffix is NULL, represented by trie_Sentinel?).
        Add two new children representing the admissible continuations of
        the common suffix.

    Return value:


    Log:

    Apr-14-1998 dovh - PerlWarn: change to ==:
        Assert( node = parent->suffix[ index ] );

--*/


template <class T, class C >
inline void
CTrieNode<T, C>::SplitNode(
    CTrieNode<T, C>* parent,            //  Parent of node
    short index,                     //  Index of node in parent->suffix
    const WCHAR * NewString,            //  String sharing prefix with node->string
    size_t charsMatched,
    T* item,                         //  Item associated with (sub)string
    ULONG options                    //  Insertion options
    )
{
    //
    //  Verify that the prefix common to string and node->string is
    //  a non-NULL proper prefix of node->string:
    //

    Assert( ( (options & TRIE_IGNORECASE) ?
              (C::MapToUpper(*string) == C::MapToUpper(*NewString)) :
              (*string == *NewString) )
        );

    Assert(charsMatched < wcslen(string));

    //
    //  Set up the prefix node to replace node as child of parent:
    //
    CAutoClassPointer<CTrieNode<T, C> > nodePrefix =
                new CTrieNode<T, C>(NULL, options, string, charsMatched);

    //
    //  Compute respective suffix of string and add as the second child
    //  of nodePrefix:
    //
    if ( wcslen(NewString) == charsMatched )
    {
        //
        //  TRIE_ITEM: Add trie_Sentinel to nodePrefix;
        //  nodePrefix should point to new item!
        //
        nodePrefix->AddSuffix(0,(CTrieNode<T, C>*)&g_trie_Sentinel, 0);
        nodePrefix->item = item;
    }
    else
    {
        Assert( charsMatched < wcslen(NewString) );

        //
        //  Allocate the string suffix node:
        //
        CAutoClassPointer<CTrieNode<T, C> > strSuffix =
                new CTrieNode(item, options, &NewString[charsMatched]);

        nodePrefix->AddSuffix(options, strSuffix.Get());
        strSuffix.Detach();
    }

    WCHAR* pwcsCurrStr = string;
    size_t CurrCharCount = charCount;
    try
    {
        size_t newCharCount = charCount - charsMatched;
        Assert(newCharCount > 0);
        CAutoArrayPointer<WCHAR> apwcsNewStr = new WCHAR[newCharCount + 1];
        wcscpy(apwcsNewStr.Get(), &(string[charsMatched]));

        string = apwcsNewStr.Get();
        charCount = newCharCount;

        //
        //  Add node as a child of nodePrefix:
        //  (Recall: node->string == respective suffix)
        //
        nodePrefix->AddSuffix(options, this);

        apwcsNewStr.Detach();
        delete[] pwcsCurrStr;
    }
    catch (CMemoryException& e)
    {
        string = pwcsCurrStr;
        charCount = CurrCharCount;

        throw e;
    }

    //
    //  Replace node by nodePrefix as the respective child of parent:
    //
    Assert( this == parent->suffix[ index ] );
    parent->suffix[ index ] = nodePrefix.Get();

    nodePrefix.Detach();

} // end trie_SplitNode

template <class T, class C >
inline void
CTrieNode<T, C>::Print(ULONG  ulOffset)
{
    for (ULONG i = 0; i < ulOffset; i++)
    {
        printf(" ");
    }
    if (this == (CTrieNode<T, C>*)&g_trie_Sentinel)
    {
        printf("Sentinel\n");
    }
    else
    {
        printf("%S\n",string);
    }

    for (short k = 0; k < suffixCount; k++)
    {
        suffix[k]->Print(ulOffset + 4);
    }
}

template <class T, class C >
inline void
CTrieNode<T, C>::DoubleSuffixArray()
{
    short newSize;

    if (0 == suffixSize)
    {
        newSize = TRIE_NODE_SUFFIXSIZE_INIT;
    }
    else
    {
        newSize = suffixSize * 2;
    }

    CTrieNode<T, C> ** newPSuffix;

    Assert(suffixCount == suffixSize);
    newPSuffix = new CTrieNode<T, C>*[newSize];
    memcpy(newPSuffix, suffix, suffixSize*sizeof(CTrieNode<T, C>*));
    delete[] suffix;
    suffix = newPSuffix;
    suffixSize = newSize;

} // end trie_DoubleNode

///////////////////////////////////////////////////////////////////////////////
// CTrie implementation
///////////////////////////////////////////////////////////////////////////////

template <class T, class C >
inline CTrie<T, C>::CTrie(bool fDeleteItemsOnDestruction) :
  fDeleteItems(fDeleteItemsOnDestruction)
{
    root = new CTrieNode<T, C>(TRIE_NODE_SUFFIXSIZE_INIT);
}

template <class T, class C >
inline CTrie<T, C>::~CTrie()
{
    if (fDeleteItems)
    {
        root->DeleteItem();
    }

    delete root;
}


/*++

    Function trie_Insert:

        Insert a given string into trie if it's not already a member trie.

    Routine Parameters:

        trie - Trie to insert item into.
        string - String key of item.
        options - Insertion options.  If options == 0 the item will be inserted
            only if the string key is not already in the tree.  If options
            is TRIE_EXCHANGE_ITEM the existing trie item will be replaced by
            the item argument in the Trie.  In that case the existing item
            associated with string in the trie will be returned in the
            *pTrieItem argument.
        item - New item to be inserted.
        pTrieItem - If an item associated with string already exists,
            then *pTrieItem points to that item upon return.

    Return value:

        DICT_SUCCESS if string was inserted successfully, else
        DICT_ITEM_ALREADY_PRESENT.


--*/
template <class T, class C >
inline DictStatus
CTrie<T, C>::trie_Insert(                            //  Insert string into trie
    const WCHAR * string,               //  String key of item
    unsigned long options,              //  Insertion flags
    T * item,                           //  Item to be inserted
    T ** pTrieItem                      //  Matching item already in trie
    )
{
    CTrieNode<T, C> * t, * c;

    int cmp = -1;
    const WCHAR * subString = string;
    size_t subStringSize = wcslen(subString);
    size_t strIndex = 0;
    size_t charsMatched = 0;
    CAutoClassPointer<CTrieNode<T, C> >  apNewSuffix;

    t = root;

    if (pTrieItem != NULL)
    {
        *pTrieItem = NULL;
    }

    while (true)
    {
        short i = 0;

        //
        //  Search in this level sorted alternatives list:
        //
        for ( i = 0;
              i < t->suffixCount;
              i++
            )
        {
            c = t->suffix[i];

            //  Quick "skip check":
            cmp = (options & TRIE_IGNORECASE) ?
                            (C::MapToUpper(*c->string) - C::MapToUpper(*subString)) :
                            (*c->string - *subString);
            if ( cmp < 0)
            {
                continue;
            }

            if (cmp > 0)
            {

                //
                //  First character of t->string does not match,
                //  insert a copy of subString before c (== t->suffix[i]):
                //
                apNewSuffix = new CTrieNode<T, C>(item, options, subString);
                t->AddSuffix(options, apNewSuffix.Get(), i);
                apNewSuffix.Detach();
                return DICT_SUCCESS;

            }
            else
            {
                //  At least one character matched.
                //  subStringSize = _tcslen(subString);

                cmp = (options & TRIE_IGNORECASE) ?
                    c->trie_StrMatchIns(c->string, subString, &charsMatched) :
                    c->trie_StrMatch(c->string, subString, &charsMatched);

                Assert(charsMatched <= min(c->charCount, subStringSize));

                if (cmp == 0)
                {
                    //  t->charCount (<= subStringSize) characters matched
                    //
                    Assert(c->charCount == subStringSize);
                    //  subString matched exactly:
                    //
                    if ((c->suffixCount == 0) ||
                        (c->suffix[0] == (CTrieNode<T, C>*)&g_trie_Sentinel))
                    {
                        //  string already present:
                        //
                        if (pTrieItem != NULL)
                        {
                            *pTrieItem = c->item;
                        }

                        if (options & TRIE_EXCHANGE_ITEM)
                        {
                            Assert(pTrieItem!= NULL);
                            c->item = item;
                        }

                        return(DICT_ITEM_ALREADY_PRESENT);
                    }
                    else
                    {
                        //
                        //  Insert the NULL trie_Sentinel at the front of
                        //  the c->suffix list; and terminate!
                        //
                        //  c should point to new item!
                        //
                        c->AddSuffix(options, (CTrieNode<T, C>*)&g_trie_Sentinel, 0);
                        c->item = item;
                        return( DICT_SUCCESS );

                    }

                }
                else
                {
                    //
                    //  cmp != 0:
                    //

                    if (charsMatched == c->charCount)
                    {
                        //  CASE I: t->string is shorter than subString,
                        //  and all of t->string matched.
                        //  Continue the search through the suffixes subtree:
                        //
                        strIndex += c->charCount;
                        Assert( strIndex < wcslen(string) );
                        subString = &string[strIndex];
                        subStringSize = wcslen(subString);

                        t = c;
                        i = -1;
                        continue;
                    }
                    else
                    {
                        //  CASE II: the child c and subString have a common prefix which is
                        //  a non-NULL strict prefix of c->string.  Split c into the common
                        //  prefix node (a new node which will replace c as a child of t),
                        //  with two children: c (with a corresponding suffix); and a new
                        //  node (with the respective suffix of subString);
                        //

                        c->SplitNode(
                            t,          //  Parent of node to split
                            i,          //  Index of node in parent->suffix
                            subString,  //  String sharing prefix with node->string
                            charsMatched,
                            item,
                            options
                            );
                        return( DICT_SUCCESS );

                    }

                } // end if (cmp == 0)

            } // end if (cmp > 0)

        } // end for

        //
        //  Either the new string was successfully inserted, in which case
        //  we would have returned already; or we reached the end of the
        //  suffix array:
        //

        //
        //  Insert a copy of subString at the end of t->suffix:
        //


        apNewSuffix = new CTrieNode<T, C>(item, options, subString);

        //
        //  Add item parameter to trie_NewNode!
        //
        t->AddSuffix(options, apNewSuffix.Get(), i);
        apNewSuffix.Detach();

        if (t->suffixCount == 1 && t->charCount != 0)
        {
            //
            //  First child of t and t is not the root of the trie;
            //  add a sentinel to t to designate
            //  that t->string is an actual item:
            //
            t->AddSuffix(options, (CTrieNode<T, C>*)&g_trie_Sentinel, 0);

        }
        return DICT_SUCCESS;

   } // end while

   Assert(0);
   return(DICT_ITEM_NOT_FOUND);

} // end trie_Insert

template <class T, class C >
inline DictStatus
CTrie<T, C>::trie_Find(
    const WCHAR * string,         //  A string
    unsigned long options,        //  Search flags
    short outBufferSize,          //  Max number of results wanted
    T ** outBuffer,               //  Buffer to be filled with matching items
    short * resultCount           //  Number of matching prefixes returned
    )

{
    CTrieNode<T, C> * node = root;
    CTrieNode<T, C> * child = NULL;
    int cmp = -1;
    DictStatus status = DICT_ITEM_NOT_FOUND;
    const WCHAR * subString = string;
    size_t strIndex = 0;
    size_t charsMatched = 0;
    int i;

    //  at least one option matches:
    Assert( options &
            (TRIE_SHORTEST_MATCH | TRIE_LONGEST_MATCH | TRIE_ALL_MATCHES)
          );

    //  at most one option matches:
    Assert ( ( ((options & TRIE_SHORTEST_MATCH)>>4) +
               ((options & TRIE_LONGEST_MATCH)>>5) +
               ((options & TRIE_ALL_MATCHES)>>6)
             ) == 1
           );

    //
    //  Initialization:
    //

    Assert(outBufferSize > 0);
    Assert(outBuffer);
    memset(outBuffer, 0, sizeof(CTrieNode<T, C>*) * outBufferSize);

    *resultCount = 0;

    while ( status != DICT_SUCCESS &&
            *resultCount < outBufferSize
          )
    {
        if (child != NULL)
        {
            strIndex += child->charCount;
            subString = &string[strIndex];
            node = child;
        }


        //
        //  Future: low & high can be improved by a partial binary search on
        //  the first character of string in node->suffix:
        //  if (node->suffixSize > threshold)
        //      trie_BinarySearch( &low, &high, subString[0]);
        //

        //
        //  Search in this level sorted alternatives list:
        //
        for ( i = 0;
              i < node->suffixCount;
              i++
            )
        {
            //  Quick "skip check":

            child = node->suffix[i];
            cmp = options & TRIE_IGNORECASE ?
                C::MapToUpper(*child->string) - C::MapToUpper(*subString) :
                *child->string - *subString;

            if ( cmp < 0 )
            {
                continue;
            }
            else
            {
                break;
            }

        } // end for

        Assert(cmp >= 0 || i == node->suffixCount);

        if (cmp != 0)
        {
            //
            //  First character did not match => subString mismatched;
            //  Bail out:
            //

            break;  //  From while loop!
        }

        //
        //  cmp == 0 => first character matched;
        //  Try to match more of subString:
        //
        //  Note: subStringSize == _tcslen(subString);
        //

        cmp = (options & TRIE_IGNORECASE) ?
            child->trie_StrMatchIns(child->string, subString, &charsMatched) :
            child->trie_StrMatch(child->string, subString, &charsMatched);

        Assert(charsMatched <= min(child->charCount, MAX_PATTERN_LENGTH));

        if (charsMatched != child->charCount)
        {
            //
            //  child->string did not match;
            //  there are no more prefixes of string in trie
            //

            //  return (status);
            break;  //  From while loop!
        }
        //
        //  Interesting case: all of child->string matched.
        //

        if (child->item != NULL)
        {
            //
            //  Child represents a real item:
            //  Add child->item to result set:
            //
            outBuffer[*resultCount] = child->item;

            if (0 == cmp)
            {
                status = DICT_SUCCESS;
            }

            if ( (options & TRIE_SHORTEST_MATCH) ==
                 TRIE_SHORTEST_MATCH
               )
            {
                //  (*resultCount)++;
                //  return(status);
                break;  //  From while loop!
            }
            else
            {
                if ( (options & TRIE_ALL_MATCHES) ==
                     TRIE_ALL_MATCHES
                   )
                {
                    (*resultCount)++;
                }
            }

            //
            //  Descend into subtree rooted at child:
            //
            continue;
        }
        else
        {
            //
            //  Child does not represent a real item;
            //  keep looking for matches.
            //  descend into subtree rooted at child:
            //
            continue;
        }

    } // end while

    if ( ((options & TRIE_LONGEST_MATCH)||
         (options & TRIE_SHORTEST_MATCH)) &&
         (outBuffer[*resultCount] != NULL))
    {
        (*resultCount)++;
    }

    return(status);

} // end trie_Find

template <class T, class C >
inline void
CTrie<T, C>::Print()
{
    root->Print(0);
}

#endif // __TRIE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\synchro.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  Synchro.h
//      Purpose  :  Synchronization objects
//
//      Project  :  Common
//      Component:
//
//      Author   :  urib
//
//      Log:
//          Aug 28 1997 urib  Creation.
//          Sep 16 1997 urib  Add CSyncMutexCatcher
//          Nov 13 1997 urib  Add interlocked  mutex.
//          Feb 18 1997 urib  Add critical section class to lock C style critical
//                              sections.(With DovH)
//
////////////////////////////////////////////////////////////////////////////////

#ifndef SYNCHRO_H
#define SYNCHRO_H

#include "Tracer.h"
#include "Excption.h"
#include "AutoHndl.h"

class ASyncObject;
class CSyncMutex;
class CSyncCriticalSection;
class CSyncOldCriticalSection;
class CSyncInterlockedMutex;
class CSyncMutexCatcher;

////////////////////////////////////////////////////////////////////////////////
//
//  ASyncMutexObject abstract class definition
//
////////////////////////////////////////////////////////////////////////////////

class ASyncMutexObject
{
  public:
    virtual void Lock(ULONG ulTimeOut = 60 * 1000) = NULL;
    virtual void Unlock() = NULL;
};

////////////////////////////////////////////////////////////////////////////////
//
//  CSyncMutex class definition
//
////////////////////////////////////////////////////////////////////////////////

class CSyncMutex : public ASyncMutexObject
{
  public:
    CSyncMutex(
        LPSECURITY_ATTRIBUTES   lpMutexAttributes = NULL,
        BOOL                    bInitialOwner = FALSE,
        LPCTSTR                 lpName = NULL)
    {
        m_ahMutex = CreateMutex(lpMutexAttributes, bInitialOwner, lpName);
        if(IS_BAD_HANDLE(m_ahMutex))
        {
            Trace(
                elError,
                tagError,(
                "CSyncMutex:"
                "Could not create mutex"));

            throw CWin32ErrorException();
        }
    }

    virtual void Lock(ULONG ulTimeOut)
    {
        DWORD   dwWaitResult;

        dwWaitResult = WaitForSingleObject(m_ahMutex, ulTimeOut);
        if (WAIT_ABANDONED == dwWaitResult)
        {
            Trace(
                elError,
                tagError,(
                "CSyncMutex:"
                "Mutex abandoned"));
        }
        else if (WAIT_TIMEOUT == dwWaitResult)
        {
            Trace(
                elError,
                tagError,(
                "CSyncMutex:"
                "Timeout"));
            throw CWin32ErrorException(ERROR_SEM_TIMEOUT);
        }
        else if (WAIT_FAILED == dwWaitResult)
        {
            IS_FAILURE(FALSE);
            Trace(
                elError,
                tagError,(
                "CSyncMutex:"
                "Wait for single object failed with error %d",
                GetLastError()));
            throw CWin32ErrorException();
        }

        Assert(WAIT_OBJECT_0 == dwWaitResult);
    }

    virtual void Unlock()
    {
        if (IS_FAILURE(ReleaseMutex(m_ahMutex)))
        {
            Trace(
                elError,
                tagError,(
                "~CSyncMutex:"
                "ReleaseMutex failed"));
        }
    }

    operator HANDLE()
    {
        return m_ahMutex;
    }
  protected:
    CAutoHandle m_ahMutex;
};

////////////////////////////////////////////////////////////////////////////////
//
//  CSyncCriticalSection class implementation
//
////////////////////////////////////////////////////////////////////////////////

class ASyncCriticalSection : protected CRITICAL_SECTION, public ASyncMutexObject
{
  public:

    ~ASyncCriticalSection()
    {
        DeleteCriticalSection(this);
    }

    virtual void Lock(ULONG = 0)
    {
        EnterCriticalSection(this);
    }

    virtual void Unlock()
    {
        LeaveCriticalSection(this);
    }
};

class CSyncCriticalSection : public ASyncCriticalSection
{
  public:
    CSyncCriticalSection()
    {
        Init();
    }

private:
    void Init()
    {
        __try
        {
            InitializeCriticalSection(this);
        }
        __except(GetExceptionCode() == STATUS_NO_MEMORY)
        {
            THROW_MEMORY_EXCEPTION();
        }
    
    }
};

#if _WIN32_WINNT >= 0x0500
class CSyncCriticalSectionWithSpinCount : public ASyncCriticalSection
{
public:
    CSyncCriticalSectionWithSpinCount(ULONG ulSpinCount = 4000)
    {
        BOOL fRet;
        fRet = InitializeCriticalSectionAndSpinCount(this, ulSpinCount);
        if (!fRet)
        {
            THROW_HRESULT_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
};
#endif

////////////////////////////////////////////////////////////////////////////////
//
//  CSyncOldCriticalSection class implementation
//
////////////////////////////////////////////////////////////////////////////////

class CSyncOldCriticalSection : public ASyncMutexObject
{
  public:
    CSyncOldCriticalSection(CRITICAL_SECTION* pCriticalSection)
        :m_pCriticalSection(pCriticalSection) {}

    virtual void Lock(ULONG = 0)
    {
        EnterCriticalSection(m_pCriticalSection);
    }

    virtual void Unlock()
    {
        LeaveCriticalSection(m_pCriticalSection);
    }

  protected:
    CRITICAL_SECTION *m_pCriticalSection;
};

////////////////////////////////////////////////////////////////////////////////
//
//  CSyncInterlockedMutex class definition
//
////////////////////////////////////////////////////////////////////////////////

class CSyncInterlockedMutex :public ASyncMutexObject
{
  public:
    CSyncInterlockedMutex()
        :m_lMutex(FALSE)
    {
    }

    virtual void Lock(ULONG ulTimeOut = 60 * 1000)
    {
        ULONG ulWaiting = 0;

        LONG    lLastValue;

        while (lLastValue = InterlockedExchange(&m_lMutex, 1))
        {
            Sleep(100);
            if ((ulWaiting += 100) > ulTimeOut)
            {
                throw CGenericException(L"TimeOut");
            }
        }
    }

    virtual void Unlock()
    {
        m_lMutex = FALSE;
    }

  private:
    LONG   m_lMutex;
};

////////////////////////////////////////////////////////////////////////////////
//
//  CSyncMutexCatcher class implementation
//
////////////////////////////////////////////////////////////////////////////////

class CSyncMutexCatcher
{
  public:
    CSyncMutexCatcher(ASyncMutexObject& smo, ULONG ulTimeOut = 60 * 1000)
        :m_refSyncObject(smo)
    {
        m_refSyncObject.Lock();
    }

    ~CSyncMutexCatcher()
    {
        m_refSyncObject.Unlock();
    }

  private:
    ASyncMutexObject&   m_refSyncObject;
};


#endif // SYNCHRO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\vartypes.h ===
/*//////////////////////////////////////////////////////////////////////////////
//
//      Filename :  VarTypes.h
//      Purpose  :  To define vaiable legth data types.
//                    Contains:
//                      CVarBuffer
//                      CVarString
//                      CVarArray
//
//      Project  :  FTFS
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Jan 30 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/

#ifndef VARTYPES_H
#define VARTYPES_H

#include "Base.h"
#include "AutoPtr.h"
#include "Excption.h"

/* An automatic string */
#include "VarStr.h"

/* An automatic buffer */
#include "VarBuff.h"

/* An automatic buffer */
#include "VarArray.h"

inline int ULONGCmp(ULONG ul1, ULONG ul2)
{
    if (ul1 != ul2)
    {
        if (ul1 > ul2)
        {
            return 1;
        }
        return -1;
    }
    return 0;
}

#endif /* VARTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\varstr.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  VarStr.h
//      Purpose  :  To hold definition for CVarString
//
//      Project  :  Persistent Query
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Feb  2 1997 urib  Creation
//          Jun 19 1997 urib  Add counted operators.
//          Jun 24 1997 urib  Fix bad const declarations.
//          Dec 29 1997 urib  Add includes.
//          Feb  2 1999 yairh fix bug in SetMinimalSize.
//          Feb  8 1999 urib  Enable different built in sizes.
//          Feb 25 1999 urib  Add SizedStringCopy.
//          Jul  5 1999 urib  Fix SizedStringCopy..
//          May  1 2000 urib  Cleanup.
//          Nov 23 2000 urib  Fix a bug in counted copy and cat.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef VARSTR_H
#define VARSTR_H

#pragma once

#include "AutoPtr.h"
#include "Excption.h"

////////////////////////////////////////////////////////////////////////////////
//
//  CVarString class definition
//
////////////////////////////////////////////////////////////////////////////////
template <ULONG ulStackSize = 0x10>
class TVarString
{
public:
    // Constructor - tips the implementation on the string size.
    TVarString(ULONG ulInitialSize = 0);
    // Constructor - copy this string.
    TVarString(PCWSTR);
    // Constructor - convert to UNICODE and copy this string.
    TVarString(const PSZ);
    // Copy Constructor
    TVarString(const TVarString&);
    ~TVarString();

    // Copy/Convert and copy the string.
    TVarString& Cpy(PCWSTR);
    TVarString& Cpy(const ULONG, PCWSTR);
    TVarString& Cpy(const PSZ);

    // Concatenate/Convert and concatenate the string to the existing string.
    TVarString& Cat(PCWSTR);
    TVarString& Cat(const ULONG, PCWSTR);
    TVarString& Cat(const PSZ);

    // Compare/Convert and compare the string to the existing string.
    int     Cmp(PCWSTR) const;
    int     Cmp(const PSZ) const;

    // Return the string length.
    ULONG   Len() const;

    // Allow access to the string memory.
    operator PWSTR() const;

    // Hint the implementation about the string size.
    void    SetMinimalSize(ULONG);

    // Set a specific character
    void    SetCharacter(ULONG, WCHAR);

    // Appends a backslash to the string if the last character is not a
    //   backslash.
    void    AppendBackslash();

    // Appends a slash to the string if the last character is not a
    //   slash.
    void    AppendSlash();

protected:
    // A predicate to see if memory is allocated or not.
    bool    IsAllocated();

    // The allocation size
    ULONG   m_ulSize;

    // This is the place for the standard string.
    WCHAR   m_rwchNormalString[ulStackSize + 1];

    // If the string is becoming too big we will allocate space for it.
    WCHAR*  m_pTheString;
private:
    TVarString&
    operator=(const TVarString& vsOther)
    {
        Cpy(vsOther);
        return *this;
    }
};


template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::TVarString(ULONG ulInitialSize)
    :m_pTheString(m_rwchNormalString)
    ,m_ulSize(ulStackSize)
{
    SetMinimalSize(ulInitialSize);

    m_pTheString[0] = L'\0';
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::TVarString(PCWSTR pwsz)
    :m_pTheString(m_rwchNormalString)
    ,m_ulSize(ulStackSize)
{
    Cpy(pwsz);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::TVarString(const PSZ psz)
    :m_pTheString(m_rwchNormalString)
    ,m_ulSize(ulStackSize)
{
    Cpy(psz);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::TVarString(const TVarString<ulStackSize>& vsOther)
    :m_pTheString(m_rwchNormalString)
    ,m_ulSize(ulStackSize)
{
    Cpy(vsOther);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::~TVarString()
{
    if (IsAllocated())
    {
        free(m_pTheString);
    }
}

template <ULONG ulStackSize>
inline
bool
TVarString<ulStackSize>::IsAllocated()
{
    return m_pTheString != m_rwchNormalString;
}

template <ULONG ulStackSize>
inline
void
TVarString<ulStackSize>::SetMinimalSize(ULONG ulNewSize)
{
    // We allocate a little more so if someone would like to add a slash
    //   or something, it will not cause us to realocate.
    //   On debug builds, I want to check for string overflows so I don't
    //   want the extra memory. Activating the reallocation mechanism is also'
    //   a good thing in debug builds.
#if !(defined(DEBUG))
    ulNewSize++;
#endif

    //
    // if the new size is smaller then what we have - bye bye
    //
    if (ulNewSize > m_ulSize)
    {
        //
        // We already allocated a string. Should change it's size
        //
        if (IsAllocated())
        {
            PWSTR pwszTemp = (PWSTR) realloc(
                m_pTheString,
                (ulNewSize + 1) * sizeof(WCHAR));

            if (NULL == pwszTemp)
            {
                THROW_MEMORY_EXCEPTION();
            }

            //
            // Save the new memory block.
            //
            m_pTheString = pwszTemp;

        }
        else
        {
            //
            // We move the string from the buffer to the allocation.
            //   Note that this is dangerous if someone took the buffer address.
            //   The user must always use the access method and never cache the
            //   string pointer.
            //
            m_pTheString = (PWSTR) malloc(sizeof(WCHAR) * (ulNewSize + 1));
            if (NULL == m_pTheString)
            {
                THROW_MEMORY_EXCEPTION();
            }

            wcsncpy(m_pTheString, m_rwchNormalString, m_ulSize + 1);
        }

        m_ulSize = ulNewSize;
    }
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cpy(PCWSTR pwsz)
{
    return Cpy(wcslen(pwsz), pwsz);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cpy(const ULONG ulCount, PCWSTR pwsz)
{
    SetMinimalSize(ulCount + 1);

    wcsncpy(m_pTheString, pwsz, ulCount);

    m_pTheString[ulCount] = L'\0';

    return *this;
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cpy(const PSZ psz)
{
    int iLen;
    iLen = MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                            psz,
                            -1,
                            NULL,
                            0);
    if (0 == iLen)
    {
        Assert(0 == iLen);
        THROW_HRESULT_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }
    
    SetMinimalSize(iLen);

    iLen = MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                            psz,
                            -1,
                            m_pTheString,
                            iLen);
    
    if (0 == iLen)
    {
        Assert(0 == iLen);
        THROW_HRESULT_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }

    return *this;
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cat(PCWSTR pwsz)
{
    ULONG ulLength = wcslen(pwsz);

    return Cat(ulLength, pwsz);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cat(const ULONG ulLength, PCWSTR pwsz)
{
    ULONG   ulCurrentLength = Len();

    SetMinimalSize(ulCurrentLength + ulLength + 1);

    wcsncpy(m_pTheString + ulCurrentLength, pwsz, ulLength);

    m_pTheString[ulCurrentLength + ulLength] = L'\0';

    return *this;
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cat(const PSZ psz)
{
    ULONG ulCurrentLength = Len();
    
    int iLen;
    iLen = MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                            psz,
                            -1,
                            NULL,
                            0);
    if (0 == iLen)
    {
        Assert(0 == iLen);
        THROW_HRESULT_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }
    
    SetMinimalSize(iLen + ulCurrentLength);
    
    iLen = MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                            psz,
                            -1,
                            m_pTheString + ulCurrentLength,
                            iLen);
    
    if (0 == iLen)
    {
        Assert(0 == iLen);
        THROW_HRESULT_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }

    return *this;
}

template <ULONG ulStackSize>
inline
int
TVarString<ulStackSize>::Cmp(PCWSTR pwsz) const
{
    return wcscmp(m_pTheString, pwsz);
}

template <ULONG ulStackSize>
inline
int
TVarString<ulStackSize>::Cmp(const PSZ psz) const
{
    int iLen;
    iLen = MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                            psz,
                            -1,
                            NULL,
                            0);
    if (0 == iLen)
    {
        Assert(0 == iLen);
        THROW_HRESULT_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }
    
    CAutoMallocPointer<WCHAR> apBuffer = (PWSTR) malloc((iLen) * sizeof(WCHAR));
    
    iLen = MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                            psz,
                            -1,
                            apBuffer.Get(),
                            iLen);
    
    if (0 == iLen)
    {
        Assert(0 == iLen);
        THROW_HRESULT_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
    }

    return Cmp(apBuffer.Get());
}

template <ULONG ulStackSize>
inline
ULONG
TVarString<ulStackSize>::Len() const
{
    return wcslen(m_pTheString);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::operator PWSTR() const
{
    return m_pTheString;
}

template <ULONG ulStackSize>
inline
void
TVarString<ulStackSize>::SetCharacter(ULONG ulIndex, WCHAR wch)
{
    SetMinimalSize(ulIndex + 2); // index to size + null

    if (L'\0' == m_pTheString[ulIndex])
    {
        m_pTheString[ulIndex + 1] = L'\0';
    }
    else if (L'\0' == wch)
    {
    }

    m_pTheString[ulIndex] = wch;
}

template <ULONG ulStackSize>
inline
void
TVarString<ulStackSize>::AppendSlash()
{
    if (L'/' != m_pTheString[Len() - 1])
        Cat(L"/");
}

template <ULONG ulStackSize>
inline
void
TVarString<ulStackSize>::AppendBackslash()
{
    if (L'\\' != m_pTheString[Len() - 1])
        Cat(L"\\");
}

typedef TVarString<4>       CShortVarString;
typedef TVarString<16>      CVarString;
typedef TVarString<256>     CLongVarString;
typedef TVarString<1024>    CHugeVarString;


////////////////////////////////////////////////////////////////////////////////
//
// String related utilities definition
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  ::SizedStringCopy
//      Purpose  :  This function copies ulSize wide characters from the source
//                    to the destination. It does not treat '\0' characters as
//                    end of string and does not append the end of string mark
//                    to the destination. Intended to be used instead of memcpy
//                    when copying wide string characters.
//
//      Parameters:
//          [in]    PWSTR pwszTarget
//          [in]    PCWSTR pwszSource
//          [in]    ULONG ulSize
//
//      Returns  :   PWSTR
//
//      Log:
//          Jan  2 2001 urib  Creation
//
////////////////////////////////////////////////////////////////////////////////

inline
PWSTR
SizedStringCopy(PWSTR pwszTarget, PCWSTR pwszSource, ULONG ulSize)
{
    return (PWSTR) memcpy(
                  (void*)pwszTarget,
                  (void*)pwszSource,
                  ulSize * sizeof(pwszSource[0]));
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  ::CoTaskDuplicateString
//      Purpose  :  strdup. Throwing though.
//
//      Parameters:
//          [in]    PCWSTR pwsz
//
//      Returns  :   PWSTR
//
//      Log:
//          Dec 25 2000 urib  Creation
//
////////////////////////////////////////////////////////////////////////////////

inline
PWSTR   CoTaskDuplicateString(PCWSTR pwsz)
{
    CAutoTaskPointer<WCHAR> apTempName =
        (PWSTR)CoTaskMemAlloc(sizeof(WCHAR) * (1 + wcslen(pwsz)));

    if (!apTempName.IsValid())
    {
         THROW_MEMORY_EXCEPTION();
    }

    wcscpy(apTempName.Get(), pwsz);

    return apTempName.Detach();
}

#endif /* VARSTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\analyze.h ===
// Analyze.h
//
// main CHART PARSING routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  31 MAR 2000	  bhshin	created

#ifndef _ANALYZE_H
#define _ANALYZE_H

#include "IndexRec.h"
#include "ChartPool.h"

BOOL AnalyzeString(PARSE_INFO *pPI, 
				   BOOL fQuery, 
				   const WCHAR *pwzInput, 
				   int cchInput,
				   int cwcSrcPos,
			       CIndexInfo *pIndexInfo,
				   WCHAR wchLast);

void InitAnalyze(PARSE_INFO *pPI);
void UninitAnalyze(PARSE_INFO *pPI);

BOOL IntializeLeafChartPool(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool);
BOOL InitializeActiveChartPool(PARSE_INFO *pPI, 
							   CLeafChartPool *pLeafChartPool,
							   int nLT,
							   CActiveChartPool *pActiveChartPool,
							   CEndChartPool *pEndChartPool);


BOOL ChartParsing(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, 
				  CEndChartPool *pEndChartPool, BOOL fQuery = FALSE);

#endif // #ifndef _ANALYZE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\analyze.cpp ===
// Analyze.cpp
//
// main CHART PARSING routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  31 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "Analyze.h"
#include "Lookup.h"
#include "Morpho.h"
#include "unikor.h"
#include "GuessIndex.h"
#include "WbData.h"
#include "Token.h"

//////////////////////////////////////////////////////////////////////////////
// Definitions

// threshold for making index terms
const int THRESHOLD_MAKE_INDEX	= 3; 
const int LENGTH_MAKE_INDEX     = 4;

//////////////////////////////////////////////////////////////////////////////
// Function Declarations

BOOL PreFiltering(const WCHAR *pwzToken, int cchInput, WCHAR wchLast, CIndexInfo *pIndexInfo);
BOOL PreProcessingLeafNode(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool);

BOOL MakeCombinedRecord(PARSE_INFO *pPI, int nLeftRec, int nRightRec, float fWeight);

BOOL MakeIndexTerms(PARSE_INFO *pPI, CEndChartPool *pEndChartPool,
					CIndexInfo *pIndexInfo, BOOL *pfNeedGuessing);

BOOL MakeQueryTerms(PARSE_INFO *pPI, CEndChartPool *pEndChartPool,
					CIndexInfo *pIndexInfo, BOOL *pfNeedGuessing);

BOOL TraverseIndexString(PARSE_INFO *pPI, BOOL fOnlySuffix, WORD_REC *pWordRec, CIndexInfo *pIndexInfo);

BOOL TraverseQueryString(PARSE_INFO *pPI, WORD_REC *pWordRec, WCHAR *pwzSeqTerm, int cchSeqTerm);


//////////////////////////////////////////////////////////////////////////////
// Function Implementation

// AnalyzeString
//
// lookup & process CHART PARSING (index time)
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  fQuery      	-> (BOOL) query flag
//  pwzInput		-> (const WCHAR*) input string to analyze (NOT decomposed)
//  cchInput		-> (int) length of input string to analyze
//  cwcSrcPos		-> (int) original source start position
//  pIndexList		-> (CIndexList *) output index list
//  wchLast			-> (WCHAR) last character of previous token
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 12APR00  bhshin  added PreFiltering
// 30MAR00  bhshin  began
BOOL AnalyzeString(PARSE_INFO *pPI,
				   BOOL fQuery, 
				   const WCHAR *pwzInput, 
				   int cchInput,
				   int cwcSrcPos,
			       CIndexInfo *pIndexInfo,
				   WCHAR wchLast)
{
	CLeafChartPool LeafChartPool;
	CEndChartPool EndChartPool;
	BOOL fNeedGuessing;
	WCHAR wchStart, wchEnd;

	if (cchInput > MAX_INPUT_TOKEN)
		return TRUE;
		
	InitAnalyze(pPI);

	// copy input string to process
	pPI->pwzInputString = new WCHAR[cchInput+1];
	if (pPI->pwzInputString == NULL)
		goto ErrorReturn;

	wcsncpy(pPI->pwzInputString, pwzInput, cchInput);
	pPI->pwzInputString[cchInput] = L'\0';

	// check string inside group
	if (cwcSrcPos > 0)
	{
		wchStart = *(pwzInput - 1);
		wchEnd = *(pwzInput + cchInput);
		
		// check inside group string
		if (fIsGroupStart(wchStart) && fIsGroupEnd(wchEnd))
		{
			// add index and keep going
			pIndexInfo->AddIndex(pPI->pwzInputString, cchInput, WEIGHT_HARD_MATCH, 0, cchInput-1);
			WB_LOG_ADD_INDEX(pPI->pwzInputString, cchInput, INDEX_INSIDE_GROUP);
		}
	}

	// check pre-filtering
	if (PreFiltering(pPI->pwzInputString, cchInput, wchLast, pIndexInfo))
	{
		// stop processing
		UninitAnalyze(pPI);
		return TRUE; 
	}

	// normalize string
	pPI->pwzSourceString = new WCHAR[cchInput*3+1];
	if (pPI->pwzSourceString == NULL)
		goto ErrorReturn;
	
	pPI->rgCharInfo = new CHAR_INFO_REC[cchInput*3+1];
	if (pPI->rgCharInfo == NULL)
		goto ErrorReturn;

	decompose_jamo(pPI->pwzSourceString, pPI->pwzInputString, pPI->rgCharInfo, cchInput*3+1);

	pPI->nLen = wcslen(pPI->pwzSourceString);
    pPI->nMaxLT = pPI->nLen-1;

	// person's name guessing
	GuessPersonName(pPI, pIndexInfo);

	// index time lookup (lookup all pos)
	if (!DictionaryLookup(pPI, pwzInput, cchInput, FALSE))
		goto ErrorReturn;

	if (!IntializeLeafChartPool(pPI, &LeafChartPool))
		goto ErrorReturn;

	if (!PreProcessingLeafNode(pPI, &LeafChartPool))
		goto ErrorReturn;

	if (!ChartParsing(pPI, &LeafChartPool, &EndChartPool))
		goto ErrorReturn;

	if (fQuery)
	{
		if (!MakeQueryTerms(pPI, &EndChartPool, pIndexInfo, &fNeedGuessing))
			goto ErrorReturn;
	}
	else
	{
		if (!MakeIndexTerms(pPI, &EndChartPool, pIndexInfo, &fNeedGuessing))
			goto ErrorReturn;
	}
	
	// if no all cover record, then guess index term
	if (fNeedGuessing)
	{
		GuessIndexTerms(pPI, &LeafChartPool, pIndexInfo);
	}
	else
	{
		// all cover but no index term (verb/adj/Ix) -> add itself
		if (pIndexInfo->IsEmpty())
		{
			WB_LOG_ROOT_INDEX(L"", TRUE);
			
			pIndexInfo->AddIndex(pwzInput, cchInput, WEIGHT_HARD_MATCH, 0, cchInput-1);
			WB_LOG_ADD_INDEX(pwzInput, cchInput, INDEX_PARSE);
		}
	}

	UninitAnalyze(pPI);

	return TRUE;

ErrorReturn:
	UninitAnalyze(pPI);

	return FALSE;
}

// InitAnalyze
//
// init the parse state struct required for parsing
//
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//          <- (PARSE_INFO*) initialized parse-info struct
//
// Result:
//  (void)
//
// 20MAR00  bhshin  began
void InitAnalyze(PARSE_INFO *pPI)
{
	pPI->pwzInputString = NULL;
    pPI->pwzSourceString = NULL;

    pPI->rgCharInfo = NULL;

    pPI->nMaxLT = 0;

    InitRecords(pPI);
}

// UninitAnalyze
//
// clean up the parse state struct
//
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (void)
//
// 20MAR00  bhshin  began
void UninitAnalyze(PARSE_INFO *pPI)
{
    UninitRecords(pPI);
    
    if (pPI->pwzInputString != NULL)
    {
        delete [] pPI->pwzInputString;
    }

    if (pPI->pwzSourceString != NULL)
    {
        delete [] pPI->pwzSourceString;
    }

    if (pPI->rgCharInfo != NULL)
    {
		delete [] pPI->rgCharInfo;
	}
}

// PreFiltering
//
// check filtered token with automata
//
// Parameters:
//  pwzToken	-> (const WCHAR*) current token string (NULL terminated)
//  cchInput	-> (int) length of input string to analyze
//  wchLast		-> (WCHAR) last character of previous token
//  pIndexInfo	-> (CIndexInfo *) output index list
//
// Result:
//  (BOOL) TRUE if it's filtered, otherwise return FALSE
//
// 20APR00  bhshin  added single length processing
// 14APR00  bhshin  began
BOOL PreFiltering(const WCHAR *pwzToken, int cchInput, WCHAR wchLast, CIndexInfo *pIndexInfo)
{
	WCHAR wzInput[MAX_INDEX_STRING+2];
	WCHAR *pwzInput;
	WCHAR wchPrev, wchCurr;
	BOOL fStop, fResult;

	// single length processing
	if (cchInput == 1) 
	{
		pIndexInfo->AddIndex(pwzToken, cchInput, WEIGHT_HARD_MATCH, 0, cchInput-1);
		WB_LOG_ADD_INDEX(pwzToken, cchInput, INDEX_PREFILTER);

		return TRUE;
	}

	if (wchLast == L'\0')
		return FALSE;

	// make string to check automata
	wzInput[0] = wchLast;
	wcscpy(wzInput+1, pwzToken);

	// automata
	pwzInput = wzInput;

	fResult = FALSE;
	fStop = FALSE;
	wchPrev = L'\0';

	// <...()> <, , , >
	// <...> <, , , >
	// <...> <, , , >
	// <...> <, >
	while (*pwzInput != L'\0')
	{
		wchCurr = *pwzInput;
		
		switch (wchPrev)
		{
		case 0x0000: // NULL
			// wchCurr != (   )
			if (wchCurr != 0xC744 && wchCurr != 0xB97C && wchCurr != 0xC5D0 && wchCurr != 0xB85C)
			{
				WCHAR wzLast[2];
				WCHAR wzDecomp[4];
				int cchDecomp;
				CHAR_INFO_REC rgCharInfo[4];

				wzLast[0] = wchCurr;
				wzLast[1] = L'\0';
				
				decompose_jamo(wzDecomp, wzLast, rgCharInfo, 4);
				cchDecomp = wcslen(wzDecomp);
				
				if (cchDecomp == 0)
					break;
					
				wchCurr = wzDecomp[cchDecomp-1];
				
				// check jong seong 
				if (wchCurr != 0x11AF)
					fStop = TRUE;
			}
			break;
		case 0xC744: // 
		case 0xB97C: // 
			if (wchCurr != 0xC704) // 
				fStop = TRUE;
			break;
		case 0xC5D0: // 
			if (wchCurr != 0xB300) // 
				fStop = TRUE;
			break;
		case 0xB85C: // 
			if (wchCurr != 0xC778) // 
				fStop = TRUE;
			break;
		case 0xC704: // 
		case 0xB300: // 
		case 0xC778: // 
			if (wchCurr == 0xD55C || wchCurr == 0xD574) //  
				fResult = TRUE;
			else if (wchCurr != 0xD558) // 
				fStop = TRUE;
			break;
		case 0xD574: // 
			if (wchCurr != 0xC11C) // 
				fStop = TRUE;
			break;
		case 0xD558: // 
			if (wchCurr == 0xC5EC) // 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0x11AF: // jong seong 
			if (wchCurr == 0xC218) // 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0xC218:
			if (wchCurr != 0xB97C) // 
				fStop = TRUE;
			break;
		default:
			fStop = TRUE;
			break;
		}

		if (fStop)
			return FALSE; // not filtered

		wchPrev = wchCurr;

		pwzInput++;
	}

	ATLTRACE("BLOCK: PreFiltering\n");

	return fResult; // filter string
}

// IntializeLeafChartPool
//
// init Leaf Chart Pool & copy records of PI into LeafChart
//
// Parameters:
//  pPI			   -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool <- (CLeafChartPool*) ptr to Leaf Chart Pool
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 31MAR00  bhshin  began
BOOL IntializeLeafChartPool(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool)
{
	int curr;

	if (pPI == NULL || pLeafChartPool == NULL)
		return FALSE;

	if (!pLeafChartPool->Initialize(pPI))
		return FALSE;

	// copy all the Record ID into CLeafChartPool
	for (curr = MIN_RECORD; curr < pPI->nCurrRec; curr++)
	{
		if (pLeafChartPool->AddRecord(curr) < MIN_RECORD)
			return FALSE;
	}

	return TRUE;
}

// PreProcessingLeafNode
//
// pre processing leaf chart pool
//
// Parameters:
//  pPI			   -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool <- (CLeafChartPool*) ptr to Leaf Chart Pool
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 31MAR00  bhshin  began
BOOL PreProcessingLeafNode(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool)
{
	int i;
	int curr, next;
	int currSub, nextSub;
	WORD_REC *pWordRec, *pRecSub;
	BYTE bPOS;
	int nFT, nLT;
	int nMaxEnding, iMaxEnding;
	int nMaxParticle, iMaxParticle;
	int cchFuncWord;

	if (pPI == NULL || pLeafChartPool == NULL)
		return FALSE;

	// traverse all the record of LeafChartPool
	for (i = 0; i < pPI->nLen; i++)
	{
		curr = pLeafChartPool->GetFTHead(i);
		
		while (curr != 0)
		{
			next = pLeafChartPool->GetFTNext(curr);

			pWordRec = pLeafChartPool->GetWordRec(curr);
			if (pWordRec == NULL)
				return FALSE;
			
			bPOS = HIBYTE(pWordRec->nRightCat); // currently, RightCat == LeftCat
			nFT = pWordRec->nFT;
			nLT = pWordRec->nLT;

			// delete NOUN/IJ records which have unmatched character boundary
			if (bPOS == POS_NF || bPOS == POS_NC || bPOS == POS_NO || bPOS == POS_NN || 
				bPOS == POS_IJ || bPOS == POS_IX)
			{
				if (!pPI->rgCharInfo[nFT].fValidStart || !pPI->rgCharInfo[nLT].fValidEnd)
					pLeafChartPool->DeleteRecord(curr);
			}
			// delete single length particle which is inside words
			else if (bPOS == POS_POSP)
			{
				if (compose_length(pWordRec->wzIndex) == 1 && 
					nLT != pPI->nLen-1)
					pLeafChartPool->DeleteRecord(curr);
			}
			
			// delete POS_NO record inside POS_NF record
			if (bPOS == POS_NF)
			{
				for (int j = nFT; j < nLT; j++)
				{
					currSub = pLeafChartPool->GetFTHead(j);

					while (currSub)
					{
						nextSub = pLeafChartPool->GetFTNext(currSub);

						pRecSub = pLeafChartPool->GetWordRec(currSub);
						if (pRecSub == NULL)
							return FALSE;
						
						// currently, RightCat == LeftCat
						if (pRecSub->nLT < nLT && HIBYTE(pRecSub->nRightCat) == POS_NO)
							pLeafChartPool->DeleteRecord(currSub);

						currSub = nextSub;
					}
				}
			}
			
			curr = next;
		}
	}

	// find the longest ENDING/PARTICLE from the end of word
	nMaxEnding = 0;
	iMaxEnding = 0; 
	nMaxParticle = 0;
	iMaxParticle = 0; 

	for (i = pPI->nLen-1; i >= 0; i--)
	{
		curr = pLeafChartPool->GetLTHead(i);
		
		while (curr != 0)
		{
			next = pLeafChartPool->GetLTNext(curr);

			pWordRec = pLeafChartPool->GetWordRec(curr);
			if (pWordRec == NULL)
				return FALSE;

			bPOS = HIBYTE(pWordRec->nRightCat); // currently, RightCat == LeftCat
			nFT = pWordRec->nFT;
			nLT = pWordRec->nLT;

			cchFuncWord = nLT - nFT + 1;
			
			if (bPOS == POS_FUNCW)
			{
				if (cchFuncWord > nMaxEnding)
				{
					nMaxEnding = cchFuncWord;
					iMaxEnding = curr;
				}
			}
			else if (bPOS == POS_POSP)
			{
				if (cchFuncWord > nMaxParticle)
				{
					nMaxParticle = cchFuncWord;
					iMaxParticle = curr;
				}
			}

			curr = next;
		}
	}

	// remove ENDING with same FT of longest functional record
	if (iMaxEnding != 0)
	{
		pWordRec = pLeafChartPool->GetWordRec(iMaxEnding);
		if (pWordRec == NULL)
			return FALSE;
		
		nFT = pWordRec->nFT;
		nLT = pWordRec->nLT;

		curr = pLeafChartPool->GetFTHead(nFT);
		
		while (curr != 0)
		{
			next = pLeafChartPool->GetFTNext(curr);

			if (curr == iMaxEnding)
			{
				curr = next;
				continue;
			}

			pWordRec = pLeafChartPool->GetWordRec(curr);
			if (pWordRec == NULL)
				return FALSE;

			bPOS = HIBYTE(pWordRec->nRightCat); // currently, RightCat == LeftCat
			
			// skip same length record
			if (nLT != pWordRec->nLT && bPOS == POS_FUNCW)
			{
				pLeafChartPool->DeleteRecord(curr);				
			}

			curr = next;
		}		
	}

	// remove PARTICLE with same FT of longest functional record
	if (iMaxParticle != 0)
	{
		pWordRec = pLeafChartPool->GetWordRec(iMaxParticle);
		if (pWordRec == NULL)
			return FALSE;
		
		nFT = pWordRec->nFT;
		nLT = pWordRec->nLT;

		curr = pLeafChartPool->GetFTHead(nFT);
		
		while (curr != 0)
		{
			next = pLeafChartPool->GetFTNext(curr);

			if (curr == iMaxParticle)
			{
				curr = next;
				continue;
			}

			pWordRec = pLeafChartPool->GetWordRec(curr);
			if (pWordRec == NULL)
				return FALSE;

			bPOS = HIBYTE(pWordRec->nRightCat); // currently, RightCat == LeftCat

			// skip same length record
			if (nLT != pWordRec->nLT && bPOS == POS_POSP)
			{
				pLeafChartPool->DeleteRecord(curr);				
			}

			curr = next;
		}		
	}
	
	return TRUE;
}

// ChartParsing
//
// implement chart parsing algorithm
//
// Parameters:
//  pPI			   -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
//  pEndChartPool   -> (CEndChartPool*) analyzed End Chart Pool
//  fQuery    -> (BOOL) query time flag
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 10APR00  bhshin  began
BOOL ChartParsing(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, 
				  CEndChartPool *pEndChartPool, BOOL fQuery /*=FALSE*/)
{
	int nRightRec, nLeftRec, nRecordID;
	float fWeight;
	WORD_REC *pRightRec;
	int nFT;
	int i, curr;

	if (pPI == NULL || pLeafChartPool == NULL || pEndChartPool == NULL)
		return FALSE;

	if (!pEndChartPool->Initialize(pPI))
		return FALSE;

	for (i = 1; i <= pPI->nLen; i++)
	{
		CActiveChartPool ActiveChartPool;
		
		if (!InitializeActiveChartPool(pPI, pLeafChartPool, i,
									   &ActiveChartPool, pEndChartPool))
		{
			return FALSE;
		}

		while (!ActiveChartPool.IsEmpty())
		{
			nRightRec = ActiveChartPool.Pop();
			pRightRec = &pPI->rgWordRec[nRightRec];
			
			nFT = pRightRec->nFT;

			// FT is zero, then combine's meaningless.
			if (nFT == 0)
				continue;

			if (!CheckValidFinal(pPI, pRightRec))
				continue;

			// LT of combined record is (FT-1)
			curr = pEndChartPool->GetLTHead(nFT-1);

			while (curr != 0)
			{
				nLeftRec = pEndChartPool->GetRecordID(curr);

				fWeight = CheckMorphotactics(pPI, nLeftRec, nRightRec, fQuery);
				if (fWeight != WEIGHT_NOT_MATCH)
				{
					nRecordID = MakeCombinedRecord(pPI, nLeftRec, nRightRec, fWeight);
					if (nRecordID >= MIN_RECORD)
					{
						ActiveChartPool.Push(nRecordID);
						pEndChartPool->AddRecord(nRecordID);
					}
				}

				curr = pEndChartPool->GetLTNext(curr);
			}
		}
	}

	return TRUE;
}

// InitializeActiveChartPool
//
// copy LT records of LeafChart into ActiveChart/EndChart
//
// Parameters:
//  pPI			   -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
//  pActiveChartPool -> (CActiveChartPool*) ptr to Active Chart Pool
//  pEndChartPool -> (CEndChartPool*) ptr to End Chart Pool
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 31MAR00  bhshin  began
BOOL InitializeActiveChartPool(PARSE_INFO *pPI, 
							   CLeafChartPool *pLeafChartPool,
							   int nLT,
							   CActiveChartPool *pActiveChartPool,
							   CEndChartPool *pEndChartPool)
{
	int curr;
	int nRecordID;
	
	if (pPI == NULL || pLeafChartPool == NULL ||
		pActiveChartPool == NULL || pEndChartPool == NULL)
		return FALSE;

	// intialize Active Chart Pool
	if (!pActiveChartPool->Initialize())
		return FALSE;
	
	// get the LT records of LeafChart
	curr = pLeafChartPool->GetLTHead(nLT);
	while (curr != 0)
	{
		nRecordID = pLeafChartPool->GetRecordID(curr);

		// add it to Active/End Chart Pool
		if (pActiveChartPool->Push(nRecordID) < MIN_RECORD)
			return FALSE;

		if (pEndChartPool->AddRecord(nRecordID) < MIN_RECORD)
			return FALSE;

		curr = pLeafChartPool->GetLTNext(curr);
	}

	return TRUE;
}

// MakeCombinedRecord
//
// check morphotactics & return corresponding weight value
//
// Parameters:
// pPI	     -> (PARSE_INFO*) ptr to parse-info struct
// nLeftRec  -> (int) left side record ID
// nRightRec -> (int) right side record ID
// fWeight   -> (float) new weight value
//
// Result:
//  (int) record ID of record pool, if faild, return 0
//
// 31MAR00  bhshin  began
int MakeCombinedRecord(PARSE_INFO *pPI, int nLeftRec, int nRightRec, float fWeight)
{
	WORD_REC *pLeftRec = NULL;
	WORD_REC *pRightRec = NULL;
	RECORD_INFO rec;
	BYTE bLeftPOS, bRightPOS;
	WCHAR wzIndex[MAX_INDEX_STRING];
	WCHAR *pwzIndex;
	
	if (pPI == NULL)
		return 0;
	
	if (nLeftRec < MIN_RECORD || nLeftRec >= pPI->nCurrRec)
		return 0;

	if (nRightRec < MIN_RECORD || nRightRec >= pPI->nCurrRec)
		return 0;

	pLeftRec = &pPI->rgWordRec[nLeftRec];
	pRightRec = &pPI->rgWordRec[nRightRec];

	rec.fWeight = fWeight;
	rec.nFT = pLeftRec->nFT;
	rec.nLT = pRightRec->nLT;
	rec.nDict = DICT_ADDED;
	rec.nLeftCat = pLeftRec->nLeftCat;
	rec.nRightCat = pRightRec->nRightCat;
	
	bLeftPOS = HIBYTE(pLeftRec->nLeftCat);
	bRightPOS = HIBYTE(pRightRec->nLeftCat);

	rec.nLeftChild = (unsigned short)nLeftRec;
	rec.nRightChild = (unsigned short)nRightRec;

	// add noun childs records number
	rec.cNounRec = pLeftRec->cNounRec + pRightRec->cNounRec;

	// check # of NO record
	rec.cNoRec = pLeftRec->cNoRec + pRightRec->cNoRec;

	// if it has more than 2 No record, then return
	if (rec.cNoRec > 2)
		return 0;

	// WB combine only successive No case.
	if (pLeftRec->cNoRec == 1 && pRightRec->cNoRec == 1)
	{
		if (HIBYTE(pLeftRec->nRightCat) != POS_NO ||
			HIBYTE(pRightRec->nLeftCat) != POS_NO)
			return 0;
	}

	// make combined index string
	// <index> = <left><.><right>
	int i = 0;

	pwzIndex = pLeftRec->wzIndex;
	
	// recordB is VA && recordA is FUNCW(ending) &&
	// Lemma(recordA) starts with "  "
	// string = Lemma(recordB) + "  "
	if (bLeftPOS == POS_VA && bRightPOS == POS_FUNCW && pLeftRec->nFT == 0)
	{
		// copy left index term
		while (*pwzIndex != L'\0')
		{
			if (*pwzIndex != L'.')
				wzIndex[i++] = *pwzIndex;

			pwzIndex++;
		}

		//  case
		if (pRightRec->wzIndex[0] == 0x11B7)
		{
			wzIndex[i++] = 0x11B7;
			goto Exit;
		}
		//  case
		else if (pRightRec->wzIndex[0] == 0x110B &&
			     pRightRec->wzIndex[1] == 0x1173 &&
				 pRightRec->wzIndex[2] == 0x11B7)
		{
			wzIndex[i++] = 0x110B;
			wzIndex[i++] = 0x1173;
			wzIndex[i++] = 0x11B7;
			goto Exit;
		}
		//  case
		else if (pRightRec->wzIndex[0] == 0x1100 &&
			     pRightRec->wzIndex[1] == 0x1175 &&
				 !fIsJongSeong(pRightRec->wzIndex[2]))
		{
			wzIndex[i++] = 0x1100;
			wzIndex[i++] = 0x1175;
			goto Exit;
		}
		else
		{
			i = 0; // undo forwarding copy
		}
	}

	if (i == 0)
	{
		if (bLeftPOS == POS_FUNCW || bLeftPOS == POS_POSP ||
			bLeftPOS == POS_VA || bLeftPOS == POS_IX)
		{
			wzIndex[i++] = L'X';
		}
		else
		{
			// remove <.> from left index string
			while (*pwzIndex != L'\0')
			{
				if (*pwzIndex != L'.')
					wzIndex[i++] = *pwzIndex;

				pwzIndex++;
			}
		}
	}

	wzIndex[i++] = L'.';

	pwzIndex = pRightRec->wzIndex;

	if (bRightPOS == POS_FUNCW || bRightPOS == POS_POSP ||
		bRightPOS == POS_VA || bRightPOS == POS_IX)
	{
		wzIndex[i++] = L'X';
	}
	else
	{
		// remove <.> from right index string
		while (*pwzIndex != L'\0')
		{
			if (*pwzIndex != L'.')
				wzIndex[i++] = *pwzIndex;

			pwzIndex++;
		}
	}

Exit:

	wzIndex[i] = L'\0';

	rec.pwzIndex = wzIndex;

	return AddRecord(pPI, &rec);
}

// MakeIndexTerms
//
// make index term (index time)
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  pEndChartPool   -> (CEndChartPool*) analyzed End Chart Pool
//  pIndexInfo		-> (CIndexInfo *) output index list
//  pfNeedGuessing  -> (BOOL*) output need to guess flag
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 06APR00  bhshin  began
BOOL MakeIndexTerms(PARSE_INFO *pPI, CEndChartPool *pEndChartPool,
					CIndexInfo *pIndexInfo, BOOL *pfNeedGuessing)
{
	int nLTMaxLen;
	int curr;
	WORD_REC *pWordRec;
	int cchRecord;
	float fBestWeight = 0;
	int cMinNoRec;
	BOOL fOnlySuffix = FALSE;

	// intialize guessing flag
	*pfNeedGuessing = TRUE;

	if (pPI == NULL || pEndChartPool == NULL)
		return FALSE;

	// if all cover record exist, then make index term
	nLTMaxLen = pEndChartPool->GetLTMaxLen(pPI->nMaxLT);

	// make index terms for all cover records
	if (nLTMaxLen < pPI->nLen)
		return TRUE;

	// LT of EndChartPool increasing length order
	curr = pEndChartPool->GetLTHead(pPI->nMaxLT);
	while (curr != 0)
	{
		pWordRec = pEndChartPool->GetWordRec(curr);
		if (pWordRec == NULL)
			break;

		if (!CheckValidFinal(pPI, pWordRec))
		{
			curr = pEndChartPool->GetLTNext(curr);
			continue;
		}

		cchRecord = pWordRec->nLT - pWordRec->nFT + 1;

		// get index string from tree traverse 
		if (cchRecord == nLTMaxLen && pWordRec->fWeight > THRESHOLD_MAKE_INDEX)
		{
			// Now, we find index terms. DO NOT guessing
			*pfNeedGuessing = FALSE;
			
			float fWeight = pWordRec->fWeight;
			int cNoRec = pWordRec->cNoRec;

			if (fBestWeight == 0)
			{
				fBestWeight = fWeight;
				cMinNoRec = cNoRec;
			}
			
			// we just traverse best weight list
			if (fWeight == fBestWeight && cMinNoRec == cNoRec)
			{
				WB_LOG_ROOT_INDEX(pWordRec->wzIndex, TRUE); // root
				TraverseIndexString(pPI, fOnlySuffix, pWordRec, pIndexInfo);

				// on index time, just pick up suffix on processing other than best
				if (pIndexInfo->IsEmpty() == FALSE)
				{
					fOnlySuffix = TRUE;
				}
			}
		}

		curr = pEndChartPool->GetLTNext(curr);
	}

	return TRUE;
}

// TraverseIndexString
//
// get the index string from tree traversing
//
// Parameters:
//  pPI			-> (PARSE_INFO*) ptr to parse-info struct
//  fOnlySuffix -> (BOOL) process only suffix (nFT == 0)
//  pWordRec    -> (WORD_REC*) parent WORD RECORD
//  pIndexInfo	-> (CIndexInfo *) output index list
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 07APR00  bhshin  began
BOOL TraverseIndexString(PARSE_INFO *pPI, BOOL fOnlySuffix, WORD_REC *pWordRec, CIndexInfo *pIndexInfo)
{
	WCHAR *pwzIndex;
	BYTE bPOS;
	WCHAR wzDecomp[MAX_INDEX_STRING*3+1];
	WCHAR wzIndex[MAX_INDEX_STRING+1];
	int cchIndex, cchRecord;
	int nLeft, nRight;
	WORD_REC *pWordLeft, *pWordRight;
	int nPrevX, nMiddleX, nLastX, idx;
	int nFT, nLT;
	
	if (pPI == NULL || pWordRec == NULL)
		return FALSE;

	if (pPI->rgCharInfo == NULL)
	{
		ATLTRACE("Character Info is NULL\n");
		return FALSE;
	}

	if (fOnlySuffix)
	{
		if (pWordRec->nFT > 0)
			return TRUE;
	}
	
	nLeft = pWordRec->nLeftChild;
	nRight = pWordRec->nRightChild;

	// if it has child node, then don't add index term 
	if (nLeft != 0 || nRight != 0)
	{
		// go to child traversing
		// recursively traverse Left/Right child
		if (nLeft != 0)
		{
			pWordLeft = &pPI->rgWordRec[nLeft];

			WB_LOG_ROOT_INDEX(pWordLeft->wzIndex, FALSE); // child
			TraverseIndexString(pPI, fOnlySuffix, pWordLeft, pIndexInfo);
		}

		if (nRight != 0)
		{
			pWordRight = &pPI->rgWordRec[nRight];

			WB_LOG_ROOT_INDEX(pWordRight->wzIndex, FALSE); // child
			TraverseIndexString(pPI, fOnlySuffix, pWordRight, pIndexInfo);
		}

		return TRUE;	
	}

	bPOS = HIBYTE(pWordRec->nLeftCat);

	// copy index string
	pwzIndex = pWordRec->wzIndex;

	// remove connection character(.) and functional character(X)
	nPrevX = 0;
	nMiddleX = 0;
	nLastX = 0;
	idx = 0;
	while (*pwzIndex != L'\0')
	{
		// check the existence of X
		if (*pwzIndex == L'X')
		{
			if (idx == 0)
				nPrevX++;
			else
				nLastX++;
		}
		else if (*pwzIndex != L'.')
		{
			// valid hangul jamo
			wzDecomp[idx++] = *pwzIndex;

			// check middle X
			nMiddleX = nLastX;
			nLastX = 0;
		}

		pwzIndex++;
	}
	wzDecomp[idx] = L'\0';

	compose_jamo(wzIndex, wzDecomp, MAX_INDEX_STRING);

	cchIndex = wcslen(wzIndex);
	cchRecord = pWordRec->nLT - pWordRec->nFT + 1;

	// lengh one index term
	if (cchIndex == 1)
	{
		// it should not have leading X or position of last X should be 1
		if (nPrevX > 0 || nLastX > 1)
			return TRUE;
	}

	// 1. it should not have middle X
	// 2. zero index string is not allowed
	if (nMiddleX == 0 && cchIndex > 0)
	{
		if (bPOS == POS_NF || bPOS == POS_NC || bPOS == POS_NO || bPOS == POS_NN || bPOS == POS_IJ ||
			(bPOS == POS_VA && pWordRec->nLeftChild > 0 && pWordRec->nRightChild > 0))
		{
			nFT = pPI->rgCharInfo[pWordRec->nFT].nToken;
			nLT = pPI->rgCharInfo[pWordRec->nLT].nToken;

			pIndexInfo->AddIndex(wzIndex, cchIndex, pWordRec->fWeight, nFT, nLT);		
			WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_PARSE);
		}
	}

	return TRUE;
}

// MakeQueryTerms
//
// make index term (query time)
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  pEndChartPool   -> (CEndChartPool*) analyzed End Chart Pool
//  pIndexInfo		-> (CIndexInfo *) output index list
//  pfNeedGuessing  -> (BOOL*) output need to guess flag
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 04DEC00  bhshin  began
BOOL MakeQueryTerms(PARSE_INFO *pPI, CEndChartPool *pEndChartPool,
					CIndexInfo *pIndexInfo, BOOL *pfNeedGuessing)
{
	int nLTMaxLen;
	int curr;
	WORD_REC *pWordRec;
	int cchRecord;
	float fBestWeight = 0;
	int cMinNoRec;
	BOOL fOnlySuffix = FALSE;
	WCHAR wzIndex[MAX_INDEX_STRING*2];
	int cchIndex, nFT, nLT;

	// intialize guessing flag
	*pfNeedGuessing = TRUE;

	if (pPI == NULL || pEndChartPool == NULL)
		return FALSE;

	// if all cover record exist, then make index term
	nLTMaxLen = pEndChartPool->GetLTMaxLen(pPI->nMaxLT);

	// make index terms for all cover records
	if (nLTMaxLen < pPI->nLen)
		return TRUE;

	// LT of EndChartPool increasing length order
	curr = pEndChartPool->GetLTHead(pPI->nMaxLT);
	while (curr != 0)
	{
		pWordRec = pEndChartPool->GetWordRec(curr);
		if (pWordRec == NULL)
			break;

		if (!CheckValidFinal(pPI, pWordRec))
		{
			curr = pEndChartPool->GetLTNext(curr);
			continue;
		}

		cchRecord = pWordRec->nLT - pWordRec->nFT + 1;

		// get index string from tree traverse 
		if (cchRecord == nLTMaxLen && pWordRec->fWeight > THRESHOLD_MAKE_INDEX)
		{
			// Now, we find index terms. DO NOT guessing
			*pfNeedGuessing = FALSE;
			
			float fWeight = pWordRec->fWeight;
			int cNoRec = pWordRec->cNoRec;

			if (fBestWeight == 0)
			{
				fBestWeight = fWeight;
				cMinNoRec = cNoRec;
			}
			
			// we just traverse best weight list
			if (fWeight == fBestWeight && cMinNoRec == cNoRec)
			{
				wzIndex[0] = L'\0';
				
				TraverseQueryString(pPI, pWordRec, wzIndex, MAX_INDEX_STRING*2);

				cchIndex = wcslen(wzIndex);
				if (cchIndex > 0)
				{
					nFT = pPI->rgCharInfo[pWordRec->nFT].nToken;
					nLT = pPI->rgCharInfo[pWordRec->nLT].nToken;

					pIndexInfo->AddIndex(wzIndex, cchIndex, pWordRec->fWeight, nFT, nLT);		
					WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_PARSE);
				}
			}
		}

		curr = pEndChartPool->GetLTNext(curr);
	}

	return TRUE;
}


// TraverseQueryString
//
// get the query string from tree traversing
//
// Parameters:
//  pPI			-> (PARSE_INFO*) ptr to parse-info struct
//  pWordRec    -> (WORD_REC*) parent WORD RECORD
//  pwzSeqTerm  -> (WCHAR *) output sequence index term buffer
//  cchSeqTerm -> (int) output buffer size
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 04DEC00  bhshin  began
BOOL TraverseQueryString(PARSE_INFO *pPI, WORD_REC *pWordRec, WCHAR *pwzSeqTerm, int cchSeqTerm)
{
	WCHAR *pwzIndex;
	BYTE bPOS;
	WCHAR wzDecomp[MAX_INDEX_STRING*3+1];
	WCHAR wzIndex[MAX_INDEX_STRING+1];
	int cchIndex, cchRecord;
	int nLeft, nRight;
	WORD_REC *pWordLeft, *pWordRight;
	int nPrevX, nMiddleX, nLastX, idx;
	int cchPrevSeqTerm;
	int nFT;
	WCHAR wchIndex;
	
	if (pPI == NULL || pWordRec == NULL)
		return FALSE;

	if (pPI->rgCharInfo == NULL)
	{
		ATLTRACE("Character Info is NULL\n");
		return FALSE;
	}

	nLeft = pWordRec->nLeftChild;
	nRight = pWordRec->nRightChild;

	// if it has child node, then don't add index term 
	if (nLeft != 0 || nRight != 0)
	{
		// go to child traversing
		// recursively traverse Left/Right child
		if (nLeft != 0)
		{
			pWordLeft = &pPI->rgWordRec[nLeft];

			WB_LOG_ROOT_INDEX(pWordLeft->wzIndex, FALSE); // child
			TraverseQueryString(pPI, pWordLeft, pwzSeqTerm, cchSeqTerm);
		}

		if (nRight != 0)
		{
			pWordRight = &pPI->rgWordRec[nRight];

			WB_LOG_ROOT_INDEX(pWordRight->wzIndex, FALSE); // child
			TraverseQueryString(pPI, pWordRight, pwzSeqTerm, cchSeqTerm);
		}

		return TRUE;	
	}

	bPOS = HIBYTE(pWordRec->nLeftCat);

	// copy index string
	pwzIndex = pWordRec->wzIndex;

	// remove connection character(.) and functional character(X)
	nPrevX = 0;
	nMiddleX = 0;
	nLastX = 0;
	idx = 0;
	while (*pwzIndex != L'\0')
	{
		// check the existence of X
		if (*pwzIndex == L'X')
		{
			if (idx == 0)
				nPrevX++;
			else
				nLastX++;
		}
		else if (*pwzIndex != L'.')
		{
			// valid hangul jamo
			wzDecomp[idx++] = *pwzIndex;

			// check middle X
			nMiddleX = nLastX;
			nLastX = 0;
		}

		pwzIndex++;
	}
	wzDecomp[idx] = L'\0';

	compose_jamo(wzIndex, wzDecomp, MAX_INDEX_STRING);

	cchIndex = wcslen(wzIndex);
	cchRecord = pWordRec->nLT - pWordRec->nFT + 1;

	// lengh one index term
	if (cchIndex == 1)
	{
		// it should not have leading X or position of last X should be 1
		if (nPrevX > 0 || nLastX > 1)
			return TRUE;
	}

	// 1. it should not have middle X
	// 2. zero index string is not allowed
	if (nMiddleX == 0 && cchIndex > 0)
	{
		if (bPOS == POS_NF || bPOS == POS_NC || bPOS == POS_NO || bPOS == POS_NN || bPOS == POS_IJ ||
			(bPOS == POS_VA && pWordRec->nLeftChild > 0 && pWordRec->nRightChild > 0))
		{
			// check buffer size
			cchPrevSeqTerm = wcslen(pwzSeqTerm);
			
			if (cchSeqTerm <= cchPrevSeqTerm + cchIndex)
				return FALSE; // output buffer too small

			// add conjoining symbol TAB
			if (cchPrevSeqTerm > 1 && cchIndex > 1)
				wcscat(pwzSeqTerm, L"\t");

			if (cchIndex == 1)
			{
				nFT = pWordRec->nFT;
				wchIndex = wzIndex[0];

				// check [,] suffix case, then just remove it
				if (nFT > 0 && (wchIndex == 0xB4E4 || wchIndex == 0xBFD0))
					return TRUE;
			}

			// concat index term
			wcscat(pwzSeqTerm, wzIndex);
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\chart.h ===
// Chart.h
// CChartPool class declaration
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  22 MAR 2000	  bhshin	created

#ifndef _CHART_POOL_H
#define _CHART_POOL_H

// CHART REC structure
// =====================
typedef struct tagCHART_REC
{
	int nFT, nLT;
	int nDict;
	int nLeftCat, nRightCat;
	int nLeftChild, nRightChild;
	WCHAR wzIndex[MAX_INDEX_STRING];
	int nNext;
} CHART_REC;

// CChartPool structure
// =====================
class CChartPool
{
// public enumeration
public:
	// sorting order
	enum SORT_ORDER {
		SORT_ASCEND,
		SORT_DESCNED,
	};

// member data
protected:
	CHART_REC *m_rgChartRec; // array of chart records

	int m_nMaxRec; 	// # of allocated records in pWordRec
	int m_nCurrRec; // next empty space in pWordRec
	int m_idxHead;	// head index in the sorted list with record length 

	SORT_ORDER m_Order;

// constructor & desctructor
public:
	CChartPool();
	~CChartPool();

	BOOL Initialize(SORT_ORDER Order);
	void Uninitialize(void);

// attribute
public:
	int GetHeadIndex(void) { return m_idxHead; }
	int GetNextIndex(int nRecord);

	CHART_REC* GetRecord(int nRecord); // 1 based index
	int GetCurrRecord(void) { return m_nCurrRec; } // total record number

// operators
public:
	BOOL AddRecord(RECORD_INFO *pRec);
	BOOL AddRecord(int nLeftRec, int nRightRec);

	void DeleteRecord(int nRecord);

	void DeleteSubRecord(int nRecord);
	void DeleteSubRecord(int nFT, int nLT, BYTE bPOS);

// internal operators
protected:
	void AddToList(int nRecord);
	void RemoveFromList(int nRecord);
};

#endif // #ifndef _CHART_POOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\chartpool.cpp ===
// ChartPool.cpp
//
// Leaf/End/Active ChartPool implementation
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "ChartPool.h"

// =======================
// LEAF CHART POOL
// =======================

// CLeafChartPool::CLeafChartPool
//
// constructor of CLeafChartPool
//
// Parameters:
//  (void)
//
// Result:
//  (void)
//
// 30MAR00  bhshin  began
CLeafChartPool::CLeafChartPool()
{
	m_pPI = NULL;

	m_rgLeafChart = NULL;
	m_nMaxRec = 0;
	m_nCurrRec = 0; 
	
	m_rgnFTHead = NULL;
	m_rgnLTHead = NULL;

	m_nMaxTokenAlloc = 0;
}

// CLeafChartPool::~CLeafChartPool
//
// destructor of CLeafChartPool
//
// Parameters:
//  (void)
//
// Result:
//  (void)
//
// 30MAR00  bhshin  began
CLeafChartPool::~CLeafChartPool()
{
	// uninitialize in destructor
	Uninitialize();
}

// CLeafChartPool::Initialize
//
// intialize LeafChartPool newly
//
// Parameters:
//  pPI	-> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 30MAR00  bhshin  began
BOOL CLeafChartPool::Initialize(PARSE_INFO *pPI)
{
	int i;
	int nTokens;
	
	if (pPI == NULL)
		return FALSE;

    // allocate new m_rgLeafChart
    if (m_rgLeafChart != NULL)
		free(m_rgLeafChart);

	m_nMaxRec = RECORD_INITIAL_SIZE;
    m_rgLeafChart = (LEAF_CHART*)malloc(m_nMaxRec * sizeof(LEAF_CHART));
    if (m_rgLeafChart == NULL)
    {
        m_nMaxRec = 0;
        return FALSE;
    }

	m_nCurrRec = MIN_RECORD;

    // allocate new FT/LT token arrays
    nTokens = wcslen(pPI->pwzSourceString) + 2;

	if (m_rgnFTHead != NULL)
        free(m_rgnFTHead);
    if (m_rgnLTHead != NULL)
        free(m_rgnLTHead);
        
    m_nMaxTokenAlloc = nTokens;
    m_rgnFTHead = (int*)malloc(m_nMaxTokenAlloc * sizeof(int));
    m_rgnLTHead = (int*)malloc(m_nMaxTokenAlloc * sizeof(int));

    if (m_rgnFTHead == NULL || m_rgnLTHead == NULL)
    {
		m_nMaxTokenAlloc = 0;
        return FALSE;
    }
	
	for (i = 0; i < m_nMaxTokenAlloc; i++)
	{
		m_rgnFTHead[i] = 0;
		m_rgnLTHead[i] = 0;
	}

	// save PARSE_INFO structure
	m_pPI = pPI;

	return TRUE;
}

// CLeafChartPool::Uninitialize
//
// un-intialize LeafChartPool
//
// Parameters:
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CLeafChartPool::Uninitialize()
{
	m_nMaxRec = 0;
	m_nCurrRec = 0;

	if (m_rgLeafChart != NULL)
		free(m_rgLeafChart);
	m_rgLeafChart = NULL;

	m_nMaxTokenAlloc = 0;

    if (m_rgnFTHead != NULL)
        free(m_rgnFTHead);
    m_rgnFTHead = NULL;
    
	if (m_rgnLTHead != NULL)
        free(m_rgnLTHead);
    m_rgnLTHead = NULL;
}

// CLeafChartPool::GetLeafChart
//
// get the record given ChartID
//
// Parameters:
// nChartID -> (int) ID of m_rgLeafChart 
//
// Result:
//  (LEAF_CHART*) NULL if error occurs, otherwise LEAF_CHART pointer
//
// 30MAR00  bhshin  began
LEAF_CHART* CLeafChartPool::GetLeafChart(int nChartID)
{
	// check chart ID overflow
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return NULL;

	return &m_rgLeafChart[nChartID];
}

// CLeafChartPool::GetRecordID
//
// get the record given RecordID
//
// Parameters:
// nChartID -> (int) ID of m_rgLeafChart 
//
// Result:
//  (int) 0 if error occurs, otherwise record id
//
// 30MAR00  bhshin  began
int CLeafChartPool::GetRecordID(int nChartID)
{
	// check chart ID 
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return 0;

	return m_rgLeafChart[nChartID].nRecordID;
}

// CLeafChartPool::GetWordRec
//
// get the record given RecordID
//
// Parameters:
// nChartID -> (int) ID of m_rgLeafChart 
//
// Result:
//  (WORD_REC*) NULL if error occurs, otherwise WORD_REC pointer
//
// 30MAR00  bhshin  began
WORD_REC* CLeafChartPool::GetWordRec(int nChartID)
{
	int nRecordID;

	// check chart ID 
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return NULL;

	nRecordID = m_rgLeafChart[nChartID].nRecordID;

	// check record ID
	if (nRecordID < MIN_RECORD || nRecordID >= m_pPI->nCurrRec)
		return NULL;

	return &m_pPI->rgWordRec[nRecordID];
}

// CLeafChartPool::GetFTHead
//
// get the chart ID of FT head 
//
// Parameters:
// nFT -> (int) FT value
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CLeafChartPool::GetFTHead(int nFT)
{
	if (nFT < 0 || nFT >= m_nMaxTokenAlloc)
		return 0;

	return m_rgnFTHead[nFT];
}

// CLeafChartPool::GetFTNext
//
// get the chart ID of FT next record
//
// Parameters:
// nChartID -> (int) chart ID
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CLeafChartPool::GetFTNext(int nChartID)
{
	LEAF_CHART *pLeafChart;

	pLeafChart = GetLeafChart(nChartID);
	if (pLeafChart == NULL)
		return 0;

	return pLeafChart->nFTNext;
}

// CLeafChartPool::GetLTHead
//
// get the chart ID of LT head 
//
// Parameters:
// nLT -> (int) LT value
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CLeafChartPool::GetLTHead(int nLT)
{
	if (nLT < 0 || nLT >= m_nMaxTokenAlloc)
		return 0;

	return m_rgnLTHead[nLT];
}

// CLeafChartPool::GetLTNext
//
// get the chart ID of LT next record
//
// Parameters:
// nChartID -> (int) chart ID
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CLeafChartPool::GetLTNext(int nChartID)
{
	LEAF_CHART *pLeafChart;

	pLeafChart = GetLeafChart(nChartID);
	if (pLeafChart == NULL)
		return 0;

	return pLeafChart->nLTNext;
}

// CLeafChartPool::AddRecord
//
// add a record into LeaftChartPool
//
// Parameters:
// nRecordID -> (int) record ID of rgWordRec 
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
int CLeafChartPool::AddRecord(int nRecordID)
{
    int nNewRecord;
	int curr;
	WORD_REC *pWordRec;

    if (m_rgLeafChart == NULL)
	{
		ATLTRACE("rgWordRec == NULL\n");
		return 0;
	}

	if (nRecordID < MIN_RECORD || nRecordID >= m_pPI->nCurrRec)
	{
		ATLTRACE("Invalid Record ID\n");
		return 0;
	}

	pWordRec = &m_pPI->rgWordRec[nRecordID];
	if (pWordRec == NULL)
	{
		ATLTRACE("Invalid Record ID\n");
		return 0;
	}

	// make sure this isn't a duplicate of another record
	for (curr = MIN_RECORD; curr < m_nCurrRec; curr++)
	{
		if (m_rgLeafChart[curr].nRecordID == nRecordID)
		{
			return curr; 
		}
	}

    // make sure there's enough room for the new record
	if (m_nCurrRec >= m_nMaxRec)
	{
        ATLTRACE("memory realloc in LeafChartPool\n");
		
		// alloc some more space in the array
        int nNewSize = m_nMaxRec + RECORD_CLUMP_SIZE;
        void *pNew;
        pNew = realloc(m_rgLeafChart, nNewSize * sizeof(LEAF_CHART));
        if (pNew == NULL)
        {
    		ATLTRACE("unable to malloc more records\n");
	    	return 0;
        }

        m_rgLeafChart = (LEAF_CHART*)pNew;
        m_nMaxRec = nNewSize;
	}

    nNewRecord = m_nCurrRec;
    m_nCurrRec++;

	m_rgLeafChart[nNewRecord].nRecordID = nRecordID;
	m_rgLeafChart[nNewRecord].nDict = DICT_FOUND;

	AddToFTList(nNewRecord);
	AddToLTList(nNewRecord);
	
	return nNewRecord;
}

// CLeafChartPool::AddRecord
//
// add a record into LeaftChartPool
//
// Parameters:
// pRec    -> (RECORD_INFO*) ptr to record info struct for new record
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
int CLeafChartPool::AddRecord(RECORD_INFO *pRec)
{
	// first, add record into record pool
	int nRecord = ::AddRecord(m_pPI, pRec);

	if (nRecord < MIN_RECORD)
	{
		// error occurs
		return nRecord;
	}

	return AddRecord(nRecord);
}

// CLeafChartPool::DeleteRecord
//
// delete a record into LeaftChartPool
//
// Parameters:
// nChartID -> (int) ID of m_rgLeafChart
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
void CLeafChartPool::DeleteRecord(int nChartID)
{
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return; // invalid chart ID

	if (m_rgLeafChart[nChartID].nDict == DICT_DELETED)
		return;

	RemoveFromFTList(nChartID);
	RemoveFromLTList(nChartID);

	m_rgLeafChart[nChartID].nDict = DICT_DELETED;
}

// CLeafChartPool::AddToFTList
//
// add the record to the appropriate FT list.
// note that this list is sorted in order of decreasing LT. (decreasing length)
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CLeafChartPool::AddToFTList(int nChartID)
{
	int curr, prev;
	int fDone;
	int nFT, nLT;
	WORD_REC *pWordRec;

	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nFT = pWordRec->nFT;
	nLT = pWordRec->nLT;
    
    curr = m_rgnFTHead[nFT];
	prev = -1;
	fDone = FALSE;
	while (!fDone)
	{
        ATLASSERT(curr < m_nCurrRec);

		pWordRec = GetWordRec(curr);

		if (curr != 0 && pWordRec != NULL && pWordRec->nLT < nLT)
		{
			// go to next record
			prev = curr;
			curr = m_rgLeafChart[curr].nFTNext;
            ATLASSERT(curr < m_nCurrRec);
		}
		else
		{
			// insert record here
			if (prev == -1)
			{
				// add before beginning of list
				m_rgLeafChart[nChartID].nFTNext = m_rgnFTHead[nFT];
				m_rgnFTHead[nFT] = nChartID;
			}
			else
			{
				// insert in middle (or end) of list
				m_rgLeafChart[nChartID].nFTNext = m_rgLeafChart[prev].nFTNext;
				m_rgLeafChart[prev].nFTNext = nChartID;
			}
			fDone = TRUE;
		}
	}
}

// CLeafChartPool::AddToLTList
//
// add the record to the appropriate LT list.
// note that this list is sorted in order of increasing FT. (decreasing length)
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CLeafChartPool::AddToLTList(int nChartID)
{
	int curr, prev;
	int fDone;
	int nFT, nLT;
	WORD_REC *pWordRec;

	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nFT = pWordRec->nFT;
	nLT = pWordRec->nLT;
    
    curr = m_rgnLTHead[nLT];
	prev = -1;
	fDone = FALSE;
	while (!fDone)
	{
        ATLASSERT(curr < m_nCurrRec);

		pWordRec = GetWordRec(curr);

		if (curr != 0 && pWordRec != NULL && pWordRec->nFT > nFT)
		{
			// go to next record
			prev = curr;
			curr = m_rgLeafChart[curr].nLTNext;
            ATLASSERT(curr < m_nCurrRec);
		}
		else
		{
			// insert record here
			if (prev == -1)
			{
				// add before beginning of list
				m_rgLeafChart[nChartID].nLTNext = m_rgnLTHead[nLT];
				m_rgnLTHead[nLT] = nChartID;
			}
			else
			{
				// insert in middle (or end) of list
				m_rgLeafChart[nChartID].nLTNext = m_rgLeafChart[prev].nLTNext;
				m_rgLeafChart[prev].nLTNext = nChartID;
			}
			fDone = TRUE;
		}
	}
}

// CLeafChartPool::RemoveFromFTList
//
// remove the given record from its FT list
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CLeafChartPool::RemoveFromFTList(int nChartID)
{
	int curr, next;
	int nFT;
	WORD_REC *pWordRec;

    ATLASSERT(nChartID < m_nCurrRec);
	
	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nFT = pWordRec->nFT;

    curr = m_rgnFTHead[nFT];
	if (curr == nChartID)
	{
		m_rgnFTHead[nFT] = m_rgLeafChart[nChartID].nFTNext;
	}
	else
	{
        ATLASSERT(curr < m_nCurrRec);
		while (curr != 0)
		{
			next = m_rgLeafChart[curr].nFTNext;
			if (next == nChartID)
			{
				m_rgLeafChart[curr].nFTNext = m_rgLeafChart[nChartID].nFTNext;
				break;
			}
			curr = next;
            ATLASSERT(curr < m_nCurrRec);
		}
	}
}

// CLeafChartPool::RemoveFromLTList
//
// remove the given record from its LT list
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CLeafChartPool::RemoveFromLTList(int nChartID)
{
	int curr, next;
	int nLT;
	WORD_REC *pWordRec;

    ATLASSERT(nChartID < m_nCurrRec);
	
	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nLT = pWordRec->nLT;

    ATLASSERT(nChartID < m_nCurrRec);

    curr = m_rgnLTHead[nLT];
	if (curr == nChartID)
	{
		m_rgnLTHead[nLT] = m_rgLeafChart[nChartID].nLTNext;
	}
	else
	{
        ATLASSERT(curr < m_nCurrRec);
		while (curr != 0)
		{
			next = m_rgLeafChart[curr].nLTNext;
			if (next == nChartID)
			{
				m_rgLeafChart[curr].nLTNext = m_rgLeafChart[nChartID].nLTNext;
				break;
			}
			curr = next;
            ATLASSERT(curr < m_nCurrRec);
		}
	}
}

// =======================
// END CHART POOL
// =======================

// CEndChartPool::CEndChartPool
//
// constructor of CEndChartPool
//
// 30MAR00  bhshin  began
CEndChartPool::CEndChartPool()
{
	m_pPI = NULL;

	m_rgEndChart = NULL;
	m_nMaxRec = 0;
	m_nCurrRec = 0; 
	
	m_rgnLTHead = NULL;
	m_rgnLTMaxLen = NULL;

	m_nMaxTokenAlloc = 0;
}

// CEndChartPool::~CEndChartPool
//
// destructor of CEndChartPool
//
// 30MAR00  bhshin  began
CEndChartPool::~CEndChartPool()
{
	// uninitialize in destructor
	Uninitialize();
}

// CEndChartPool::Initialize
//
// intialize EndChartPool newly
//
// Parameters:
//  pPI	-> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 30MAR00  bhshin  began
BOOL CEndChartPool::Initialize(PARSE_INFO *pPI)
{
	int i;
	int nTokens;
	
	if (pPI == NULL)
		return FALSE;

    // allocate new m_rgEndChart
    if (m_rgEndChart != NULL)
		free(m_rgEndChart);

	m_nMaxRec = RECORD_INITIAL_SIZE;
    m_rgEndChart = (END_CHART*)malloc(m_nMaxRec * sizeof(END_CHART));
    if (m_rgEndChart == NULL)
    {
        m_nMaxRec = 0;
        return FALSE;
    }

	m_nCurrRec = MIN_RECORD;

    // allocate new FT/LT token arrays
    nTokens = wcslen(pPI->pwzSourceString) + 2;

    if (m_rgnLTHead != NULL)
        free(m_rgnLTHead);
	if (m_rgnLTMaxLen != NULL)
		free(m_rgnLTMaxLen);

    m_nMaxTokenAlloc = nTokens;
    m_rgnLTHead = (int*)malloc(m_nMaxTokenAlloc * sizeof(int));
	m_rgnLTMaxLen = (int*)malloc(m_nMaxTokenAlloc * sizeof(int));

    if (m_rgnLTHead == NULL || m_rgnLTMaxLen == NULL)
    {
		m_nMaxTokenAlloc = 0;
        return FALSE;
    }
	
	for (i = 0; i < m_nMaxTokenAlloc; i++)
	{
		m_rgnLTHead[i] = 0;
		m_rgnLTMaxLen[i] = 0;
	}

	// save PARSE_INFO structure
	m_pPI = pPI;

	return TRUE;
}

// CEndChartPool::Uninitialize
//
// un-intialize EndChartPool
//
// Parameters:
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CEndChartPool::Uninitialize()
{
	m_nMaxRec = 0;
	m_nCurrRec = 0;

	if (m_rgEndChart != NULL)
		free(m_rgEndChart);
	m_rgEndChart = NULL;

	m_nMaxTokenAlloc = 0;

	if (m_rgnLTHead != NULL)
        free(m_rgnLTHead);
    m_rgnLTHead = NULL;

	if (m_rgnLTMaxLen != NULL)
		free(m_rgnLTMaxLen);
	m_rgnLTMaxLen = NULL;
}

// CEndChartPool::GetEndChart
//
// get the record given ChartID
//
// Parameters:
// nChartID -> (int) ID of m_rgEndChart 
//
// Result:
//  (END_CHART*) NULL if error occurs, otherwise END_CHART pointer
//
// 30MAR00  bhshin  began
END_CHART* CEndChartPool::GetEndChart(int nChartID)
{
	// check chart ID overflow
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return NULL;

	return &m_rgEndChart[nChartID];
}

// CEndChartPool::GetRecordID
//
// get the record given RecordID
//
// Parameters:
// nChartID -> (int) ID of m_rgEndChart 
//
// Result:
//  (int) 0 if error occurs, otherwise record id
//
// 30MAR00  bhshin  began
int CEndChartPool::GetRecordID(int nChartID)
{
	// check chart ID 
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return 0;

	return m_rgEndChart[nChartID].nRecordID;
}

// CEndChartPool::GetWordRec
//
// get the record given RecordID
//
// Parameters:
// nChartID -> (int) ID of m_rgEndChart 
//
// Result:
//  (WORD_REC*) NULL if error occurs, otherwise WORD_REC pointer
//
// 30MAR00  bhshin  began
WORD_REC* CEndChartPool::GetWordRec(int nChartID)
{
	int nRecordID;

	// check chart ID 
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return NULL;

	nRecordID = m_rgEndChart[nChartID].nRecordID;

	// check record ID
	if (nRecordID < MIN_RECORD || nRecordID >= m_pPI->nCurrRec)
		return NULL;

	return &m_pPI->rgWordRec[nRecordID];
}

// CEndChartPool::GetLTHead
//
// get the chart ID of LT head 
//
// Parameters:
// nLT -> (int) LT value
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CEndChartPool::GetLTHead(int nLT)
{
	if (nLT < 0 || nLT >= m_nMaxTokenAlloc)
		return 0;

	return m_rgnLTHead[nLT];
}

// CEndChartPool::GetLTMaxLen
//
// get the maximum length given LT
//
// Parameters:
// nLT -> (int) LT value
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 06APR00  bhshin  began
int CEndChartPool::GetLTMaxLen(int nLT)
{
	if (nLT < 0 || nLT >= m_nMaxTokenAlloc)
		return 0;

	return m_rgnLTMaxLen[nLT];
}

// CEndChartPool::GetLTNext
//
// get the chart ID of LT next record
//
// Parameters:
// nChartID -> (int) chart ID
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CEndChartPool::GetLTNext(int nChartID)
{
	END_CHART *pEndChart;

	pEndChart = GetEndChart(nChartID);
	if (pEndChart == NULL)
		return 0;

	return pEndChart->nLTNext;
}

// CEndChartPool::AddRecord
//
// add a record into LeaftChartPool
//
// Parameters:
// nRecordID -> (int) record ID of rgWordRec 
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
int CEndChartPool::AddRecord(int nRecordID)
{
    int nNewRecord;
	int curr;
	WORD_REC *pWordRec;

    if (m_rgEndChart == NULL)
	{
		ATLTRACE("rgWordRec == NULL\n");
		return 0;
	}

	if (nRecordID < MIN_RECORD || nRecordID >= m_pPI->nCurrRec)
	{
		ATLTRACE("Invalid Record ID\n");
		return 0;
	}

	pWordRec = &m_pPI->rgWordRec[nRecordID];
	if (pWordRec == NULL)
	{
		ATLTRACE("Invalid Record ID\n");
		return 0;
	}

	// make sure this isn't a duplicate of another record
	for (curr = MIN_RECORD; curr < m_nCurrRec; curr++)
	{
		if (m_rgEndChart[curr].nRecordID == nRecordID)
		{
			return curr; 
		}
	}

    // make sure there's enough room for the new record
	if (m_nCurrRec >= m_nMaxRec)
	{
		ATLTRACE("memory realloc in EndChartPool\n");

        // alloc some more space in the array
        int nNewSize = m_nMaxRec + RECORD_CLUMP_SIZE;
        void *pNew;
        pNew = realloc(m_rgEndChart, nNewSize * sizeof(END_CHART));
        if (pNew == NULL)
        {
    		ATLTRACE("unable to malloc more records\n");
	    	return 0;
        }

        m_rgEndChart = (END_CHART*)pNew;
        m_nMaxRec = nNewSize;
	}

    nNewRecord = m_nCurrRec;
    m_nCurrRec++;

	m_rgEndChart[nNewRecord].nRecordID = nRecordID;
	m_rgEndChart[nNewRecord].nDict = DICT_FOUND;

	AddToLTList(nNewRecord);
	
	return nNewRecord;
}

// CEndChartPool::AddRecord
//
// add a new record into LeaftChartPool
//
// Parameters:
// pRec    -> (RECORD_INFO*) ptr to record info struct for new record
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
int CEndChartPool::AddRecord(RECORD_INFO *pRec)
{
	// first, add record into record pool
	int nRecord = ::AddRecord(m_pPI, pRec);

	if (nRecord < MIN_RECORD)
	{
		// error occurs
		return nRecord;
	}

	return AddRecord(nRecord);
}

// CEndChartPool::DeleteRecord
//
// delete a record into LeaftChartPool
//
// Parameters:
// nChartID -> (int) ID of m_rgEndChart
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
void CEndChartPool::DeleteRecord(int nChartID)
{
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return; // invalid chart ID

	if (m_rgEndChart[nChartID].nDict == DICT_DELETED)
		return;

	RemoveFromLTList(nChartID);

	m_rgEndChart[nChartID].nDict = DICT_DELETED;
}

// CEndChartPool::AddToLTList
//
// add the record to the appropriate LT list.
// note that this list is sorted 
// in order of decreasing weight & increasing # of No
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 02JUN00  bhshin  changed sort order
// 30MAR00  bhshin  began
void CEndChartPool::AddToLTList(int nChartID)
{
	int curr, prev;
	int fDone;
	int nFT, nLT;
	float fWeight;
	int cNoRec;
	WORD_REC *pWordRec;

	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nFT = pWordRec->nFT;
	nLT = pWordRec->nLT;

	fWeight = pWordRec->fWeight;
	cNoRec = pWordRec->cNoRec;

	// check LTMaxLen
	if (m_rgnLTMaxLen[nLT] < nLT-nFT+1)
	{
		m_rgnLTMaxLen[nLT] = nLT-nFT+1;
	}
    
    curr = m_rgnLTHead[nLT];
	prev = -1;
	fDone = FALSE;
	while (!fDone)
	{
        ATLASSERT(curr < m_nCurrRec);

		pWordRec = GetWordRec(curr);

		if (curr != 0 && pWordRec != NULL && pWordRec->fWeight >= fWeight)
		{
			if (pWordRec->fWeight > fWeight || pWordRec->cNoRec < cNoRec)
			{
				// go to next record
				prev = curr;
				curr = m_rgEndChart[curr].nLTNext;
				ATLASSERT(curr < m_nCurrRec);

				continue;
			}
		}

		// otherwise, insert record here
		if (prev == -1)
		{
			// add before beginning of list
			m_rgEndChart[nChartID].nLTNext = m_rgnLTHead[nLT];
			m_rgnLTHead[nLT] = nChartID;
		}
		else
		{
			// insert in middle (or end) of list
			m_rgEndChart[nChartID].nLTNext = m_rgEndChart[prev].nLTNext;
			m_rgEndChart[prev].nLTNext = nChartID;
		}

		fDone = TRUE;
	}
}

// CEndChartPool::RemoveFromLTList
//
// remove the given record from its LT list
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CEndChartPool::RemoveFromLTList(int nChartID)
{
	int curr, next;
	int nFT, nLT;
	WORD_REC *pWordRec;
	BOOL fUpdateLTMaxLen = FALSE;

    ATLASSERT(nChartID < m_nCurrRec);
	
	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nFT = pWordRec->nFT;
	nLT = pWordRec->nLT;

    ATLASSERT(nChartID < m_nCurrRec);

	// LTMaxLen need to be update?
	// if final node, then change LTMaxLen
	if (m_rgEndChart[nChartID].nLTNext == 0)
		fUpdateLTMaxLen = TRUE;

    curr = m_rgnLTHead[nLT];
	if (curr == nChartID)
	{
		m_rgnLTHead[nLT] = m_rgEndChart[nChartID].nLTNext;

		if (fUpdateLTMaxLen)		
			m_rgnLTMaxLen[nLT] = 0;
	}
	else
	{
        ATLASSERT(curr < m_nCurrRec);
		while (curr != 0)
		{
			next = m_rgEndChart[curr].nLTNext;
			if (next == nChartID)
			{
				m_rgEndChart[curr].nLTNext = m_rgEndChart[nChartID].nLTNext;
		
				if (fUpdateLTMaxLen)		
				{
					pWordRec = GetWordRec(curr);
					if (pWordRec == NULL)
						return;
					m_rgnLTMaxLen[nLT] = pWordRec->nLT-pWordRec->nFT+1;
				}

				break;
			}
			curr = next;
            ATLASSERT(curr < m_nCurrRec);
		}
	}
}

// =======================
// ACTIVE CHART POOL
// =======================

// CActiveChartPool::CActiveChartPool
//
// constructor of CActiveChartPool
//
// 30MAR00  bhshin  began
CActiveChartPool::CActiveChartPool()
{
	m_rgnRecordID = NULL;
	
	m_nMaxRec = 0;
	m_nCurrRec = 0;
}

// CActiveChartPool::~CActiveChartPool
//
// destructor of CActiveChartPool
//
// 30MAR00  bhshin  began
CActiveChartPool::~CActiveChartPool()
{
	// uninitialize in destructor
	Uninitialize();
}

// CActiveChartPool::Initialize
//
// intialize rgnRecordID
//
// Parameters:
//  (NONE)
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 30MAR00  bhshin  began
BOOL CActiveChartPool::Initialize()
{
    // allocate new m_rgnRecordID
    if (m_rgnRecordID != NULL)
		free(m_rgnRecordID);

	m_nCurrRec = MIN_RECORD;
	m_nHeadRec = MIN_RECORD;

	m_nMaxRec = RECORD_INITIAL_SIZE;

    m_rgnRecordID = (int*)malloc(m_nMaxRec * sizeof(int));
    if (m_rgnRecordID == NULL)
    {
        m_nMaxRec = 0;
        return FALSE;
    }

	return TRUE;
}

// CActiveChartPool::Uninitialize
//
// un-intialize m_rgnRecordID
//
// Parameters:
//	(NONE)
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CActiveChartPool::Uninitialize()
{
	m_nMaxRec = 0;
	m_nCurrRec = 0;
	m_nHeadRec = 0;

	if (m_rgnRecordID != NULL)
		free(m_rgnRecordID);

	m_rgnRecordID = NULL;
}

// CActiveChartPool::Push
//
// add Record ID
//
// Parameters:
//  nRecordID  -> (int) record ID of record pool
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
int CActiveChartPool::Push(int nRecordID)
{
    int nNewRecord;

	// make sure there's enough room for the new record
	if (m_nCurrRec >= m_nMaxRec)
	{
		ATLTRACE("memory realloc in ActiveChartPool\n");
        
		// alloc some more space in the array
        int nNewSize = m_nMaxRec + RECORD_CLUMP_SIZE;
        void *pNew;
        pNew = realloc(m_rgnRecordID, nNewSize * sizeof(int));
        if (pNew == NULL)
        {
    		ATLTRACE("unable to malloc more records\n");
	    	return 0;
        }

        m_rgnRecordID = (int*)pNew;
        m_nMaxRec = nNewSize;
	}

	nNewRecord = m_nCurrRec;
	m_nCurrRec++;

	m_rgnRecordID[nNewRecord] = nRecordID;

	return nNewRecord;
}

// CActiveChartPool::Pop
//
// get a Record ID and remove it
//
// Parameters:
//	(NONE)
//
// Result:
//  (int) record id, if emtry then 0
//
// 30MAR00  bhshin  began
int CActiveChartPool::Pop()
{
	int nRecordID;

	if (m_nHeadRec >= m_nCurrRec)
	{
		// empty case
		nRecordID = 0;
	}
	else
	{
		nRecordID = m_rgnRecordID[m_nHeadRec];
		m_nHeadRec++;
	}

	return nRecordID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\chart.cpp ===
// Chart.cpp
// CChartPool class implementation
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  22 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "Chart.h"
#include "Unikor.h"

CChartPool::CChartPool()
{
	m_rgChartRec = NULL; 

	m_nMaxRec = 0; 	
	m_nCurrRec = 0; 

	m_Order = SORT_ASCEND;
}

CChartPool::~CChartPool()
{
	Uninitialize();
}

BOOL CChartPool::Initialize(SORT_ORDER Order)
{
	m_Order = Order;

    if (m_rgChartRec == NULL)
	{
		m_nMaxRec = RECORD_CLUMP_SIZE;
		m_rgChartRec = (CHART_REC*)malloc(m_nMaxRec * sizeof(CHART_REC));
		if (m_rgChartRec == NULL)
		{
			m_nMaxRec = 0;
			return FALSE;
		}
	}

	m_nCurrRec = MIN_RECORD;

	m_idxHead = 0;	

	return TRUE;
}

void CChartPool::Uninitialize()
{
	m_nMaxRec = 0;

	if (m_rgChartRec != NULL)
		free(m_rgChartRec);
	m_rgChartRec = NULL;
}

int CChartPool::GetNextIndex(int nRecord)
{
	if (m_rgChartRec == NULL)
		return 0;

	if (nRecord >= m_nCurrRec)
		return 0;

	return m_rgChartRec[nRecord].nNext;
}

CHART_REC* CChartPool::GetRecord(int nRecord)
{
	if (m_rgChartRec == NULL)
		return NULL;

	if (nRecord >= m_nCurrRec)
		return NULL;

	return &m_rgChartRec[nRecord];	
}

BOOL CChartPool::AddRecord(RECORD_INFO *pRec)
{
    int nNewRecord;
    int nFT, nLT, nDict;
	int nLeftCat, nRightCat;
	int nLeftChild, nRightChild;
    const WCHAR *pwzIndex;
	int curr;

    nFT = pRec->nFT;
    nLT = pRec->nLT;
    nDict = pRec->nDict;
	nLeftCat = pRec->nLeftCat;
	nRightCat = pRec->nRightCat;
	nLeftChild = pRec->nLeftChild;
	nRightChild = pRec->nRightChild;
	pwzIndex = pRec->pwzIndex;

    if (m_rgChartRec == NULL)
	{
		ATLTRACE("rgWordRec == NULL\n");
		return FALSE;
	}

    // make sure there's enough room for the new record
	if (m_nCurrRec >= m_nMaxRec)
	{
        // alloc some more space in the array
        int nNewSize = m_nMaxRec + RECORD_CLUMP_SIZE;
        void *pNew;
        pNew = realloc(m_rgChartRec, nNewSize * sizeof(CHART_REC));
        if (pNew == NULL)
        {
    		ATLTRACE("unable to malloc more records\n");
	    	return FALSE;
        }

        m_rgChartRec = (CHART_REC*)pNew;
        m_nMaxRec = nNewSize;
	}

	// make sure this isn't a duplicate of another record
	curr = m_idxHead;
    ATLASSERT(curr < m_nCurrRec);
	while (curr != 0)
	{
		if (m_rgChartRec[curr].nFT == nFT && m_rgChartRec[curr].nLT == nLT)
		{
			// verify that everything matches
			if (m_rgChartRec[curr].nLeftCat == nLeftCat
				&& m_rgChartRec[curr].nRightCat == nRightCat
				&& m_rgChartRec[curr].nLeftChild == nLeftChild
				&& m_rgChartRec[curr].nRightChild == nRightChild
                && !wcscmp(m_rgChartRec[curr].wzIndex, pwzIndex)
			   )
			{
				return TRUE; 
			}
		}

		curr = m_rgChartRec[curr].nNext;
	}

    nNewRecord = m_nCurrRec;
    m_nCurrRec++;

	m_rgChartRec[nNewRecord].nFT = nFT;
	m_rgChartRec[nNewRecord].nLT = nLT;
	m_rgChartRec[nNewRecord].nDict = nDict;
	m_rgChartRec[nNewRecord].nLeftCat = nLeftCat;
	m_rgChartRec[nNewRecord].nRightCat = nRightCat;
	m_rgChartRec[nNewRecord].nLeftChild = 0;
	m_rgChartRec[nNewRecord].nRightChild = 0;
	wcscpy(m_rgChartRec[nNewRecord].wzIndex, pwzIndex);

	// add record to length order list
	AddToList(nNewRecord);

	return TRUE;
}

BOOL CChartPool::AddRecord(int nLeftRec, int nRightRec)
{
	RECORD_INFO rec;
	WCHAR wzIndex[MAX_INDEX_STRING];
	CHART_REC *pLeftRec, *pRightRec;

	if (nLeftRec >= m_nCurrRec || nRightRec >= m_nCurrRec)
		return FALSE;

	pLeftRec = &m_rgChartRec[nLeftRec];
	pRightRec = &m_rgChartRec[nRightRec];

	if (pLeftRec == NULL || pRightRec == NULL)
		return FALSE;

	rec.nFT = pLeftRec->nFT;
	rec.nLT = pRightRec->nLT;
	rec.nDict = DICT_ADDED;
	rec.nLeftCat = pLeftRec->nLeftCat;
	rec.nRightCat = pRightRec->nRightCat;
	rec.nLeftChild = 0;
	rec.nRightChild = 0;

	if (rec.nRightCat == POS_POSP)
	{
		wcscpy(wzIndex, pLeftRec->wzIndex);
		//wcscat(wzIndex, L".");
	}
	else
	{
		ATLASSERT(rec.nRightCat == POS_FUNCW);

		wcscpy(wzIndex, L"");
		//wcscpy(wzIndex, L".");
	}

	rec.pwzIndex = wzIndex;

	return AddRecord(&rec);
}

void CChartPool::DeleteRecord(int nRecord)
{
	if (m_rgChartRec == NULL)
		return;

	if (nRecord >= m_nCurrRec)
		return;

	if (m_rgChartRec[nRecord].nDict == DICT_DELETED)
		return;

	RemoveFromList(nRecord);

	m_rgChartRec[nRecord].nDict = DICT_DELETED;
}

void CChartPool::DeleteSubRecord(int nRecord)
{
	int nFT, nLT;	
	int nSubFT, nSubLT;
	int curr, next;

	ATLASSERT(nRecord < m_nCurrRec);

	nFT = m_rgChartRec[nRecord].nFT;
	nLT = m_rgChartRec[nRecord].nLT;

	curr = m_idxHead;
	while (curr != 0)
	{
		nSubFT = m_rgChartRec[curr].nFT;
		nSubLT = m_rgChartRec[curr].nLT;

		next = m_rgChartRec[curr].nNext;

		if (curr != nRecord && nSubFT >= nFT && nSubLT <= nLT)
		{
			DeleteRecord(curr);
		}

		curr = next;
	}
}

void CChartPool::DeleteSubRecord(int nFT, int nLT, BYTE bPOS)
{
	int nSubFT, nSubLT;
	int curr, next;

	curr = m_idxHead;
	while (curr != 0)
	{
		nSubFT = m_rgChartRec[curr].nFT;
		nSubLT = m_rgChartRec[curr].nLT;

		next = m_rgChartRec[curr].nNext;

		// don't remove exact FT/LT record, we just delete 'sub'-record
		if ((nSubFT != nFT || nSubLT != nLT) && nSubFT >= nFT && nSubLT <= nLT)
		{
			if (m_rgChartRec[curr].nLeftCat == m_rgChartRec[curr].nRightCat &&
				HIBYTE(m_rgChartRec[curr].nRightCat) == bPOS)
			{
				DeleteRecord(curr);
			}
		}

		curr = next;
	}
}

void CChartPool::AddToList(int nRecord)
{
	int curr, prev;
	int fDone;
	int cchIndex;

    ATLASSERT(nRecord < m_nCurrRec);

    cchIndex = compose_length(m_rgChartRec[nRecord].wzIndex);
    
    curr = m_idxHead;
	prev = -1;
	fDone = FALSE;
	while (!fDone)
	{
        ATLASSERT(curr < m_nCurrRec);

		if (curr != 0 && compose_length(m_rgChartRec[curr].wzIndex) > cchIndex)
		{
			// go to next record
			prev = curr;
			curr = m_rgChartRec[curr].nNext;
            ATLASSERT(curr < m_nCurrRec);
		}
		else
		{
			// insert record here
			if (prev == -1)
			{
				// add before beginning of list
				m_rgChartRec[nRecord].nNext = m_idxHead;
				m_idxHead = nRecord;
			}
			else
			{
				// insert in middle (or end) of list
				m_rgChartRec[nRecord].nNext = m_rgChartRec[prev].nNext;
				m_rgChartRec[prev].nNext = nRecord;
			}
			fDone = TRUE;
		}
	}
}

void CChartPool::RemoveFromList(int nRecord)
{
	int curr,next;

    ATLASSERT(nRecord < m_nCurrRec);
	
    curr = m_idxHead;
	if (curr == nRecord)
	{
		m_idxHead = m_rgChartRec[nRecord].nNext;
	}
	else
	{
        ATLASSERT(curr < m_nCurrRec);
		while (curr != 0)
		{
			next = m_rgChartRec[curr].nNext;
			if (next == nRecord)
			{
				m_rgChartRec[curr].nNext = m_rgChartRec[nRecord].nNext;
				break;
			}
			curr = next;
            ATLASSERT(curr < m_nCurrRec);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\chartpool.h ===
// ChartPool.h
//
// Leaf/End/Active ChartPool declaration
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#ifndef _CHART_POOL_H
#define _CHART_POOL_H

// =======================
// LEAF CHART POOL
// =======================

typedef struct _tagLeafChart
{
	int nRecordID;
	int nFTNext;
	int nLTNext;
	unsigned char nDict;
} LEAF_CHART;

class CLeafChartPool
{
// member data
private:
	PARSE_INFO *m_pPI;

	LEAF_CHART *m_rgLeafChart;
	int m_nMaxRec;  // # of allocated records in m_rgLeafChart
	int m_nCurrRec; // next empty space in m_rgLeafChart
	
	int *m_rgnFTHead;
	int *m_rgnLTHead;

	int m_nMaxTokenAlloc;
	
// constructor & desctructor
public:
	CLeafChartPool();
	~CLeafChartPool();

	BOOL Initialize(PARSE_INFO *pPI);
	void Uninitialize();

// attribute
public:
	LEAF_CHART* GetLeafChart(int nChartID);
	int GetRecordID(int nChartID);
	WORD_REC* GetWordRec(int nChartID);
	
	int GetFTHead(int nFT);
	int GetFTNext(int nChartID);

	int GetLTHead(int nLT);
	int GetLTNext(int nChartID);

// operator
public:
	int AddRecord(int nRecordID);
	int AddRecord(RECORD_INFO *pRec);

	void DeleteRecord(int nChartID);

	void AddToFTList(int nChartID);
	void AddToLTList(int nChartID);

	void RemoveFromFTList(int nChartID);
	void RemoveFromLTList(int nChartID);
};

// =======================
// END CHART POOL
// =======================

typedef struct _tagEndChart
{
	int nRecordID;
	int nLTNext;
	unsigned char nDict;
} END_CHART;

class CEndChartPool
{
// member data
private:
	PARSE_INFO *m_pPI;

	END_CHART *m_rgEndChart; 
	int m_nMaxRec;  // # of allocated records in m_rgEndChart
	int m_nCurrRec; // next empty space in m_rgEndChart
	
	int *m_rgnLTHead;
	int *m_rgnLTMaxLen; // MAX_LENGTH for each LT

	int m_nMaxTokenAlloc;
	
// constructor & desctructor
public:
	CEndChartPool();
	~CEndChartPool();

	BOOL Initialize(PARSE_INFO *pPI);
	void Uninitialize();

// attribute
public:
	END_CHART* GetEndChart(int nChartID);
	int GetRecordID(int nChartID);
	WORD_REC* GetWordRec(int nChartID);
		
	int GetLTHead(int nLT);
	int GetLTMaxLen(int nLT);
	
	int GetLTNext(int nChartID);

// operator
public:
	int AddRecord(int nRecordID);
	int AddRecord(RECORD_INFO *pRec);
	
	void DeleteRecord(int nChartID);

	void AddToLTList(int nChartID);
	void RemoveFromLTList(int nChartID);
};

// =======================
// ACTIVE CHART POOL
// =======================

class CActiveChartPool
{
// member data
private:
	int *m_rgnRecordID;
	int m_nMaxRec;  // # of allocated records in m_rgnRecordID
	
	int m_nCurrRec; // next empty space in m_rgnRecordID
	int m_nHeadRec; // next pop position

// constructor & desctructor
public:
	CActiveChartPool();
	~CActiveChartPool();

	BOOL Initialize();
	void Uninitialize();

// attribute
public:
	BOOL IsEmpty() { return (m_nHeadRec >= m_nCurrRec) ? TRUE : FALSE; }

// operator
public:
	int Push(int nRecordID);
	int Pop();
};

#endif // #ifndef _CHART_POOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\ctplus.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
//  File:       ctplus.h
//
//  Contents:   Local definitions for ctplus.c
//
//  History:    23-May-96   pathal      Created.
//              28-Aug-97   Weibz       Add Hanguel char
//
//---------------------------------------------------------------------------

#ifndef _CTPLUS_0_H_
#define _CTPLUS_0_H_

#define HC       0x01                             // Hiragana char
#define IC       0x02                             // Ideograph char
#define KC       0x03                             // Katakana char
#define WS       0x04                             // Word seperator
#define VC       0x05                             // Hankaku (variant) char
#define PS       0x06                             // Phrase seperator
#define CH       0x07                             // Code page 0 - ASCII Char.
#define HG       0x08                             // Hanguel Char.

BYTE
GetCharType(WCHAR wc);

// Declare character types transitions
// Intuitively frequency ordered
//
typedef enum _CT {
   CT_START       = 0x00,
   CT_HIRAGANA    = 0x01,
   CT_KANJI       = 0x02,
   CT_KATAKANA    = 0x03,
   CT_WORD_SEP    = 0x04,
   CT_HANKAKU     = 0x05,
   CT_PHRASE_SEP  = 0x06,
   CT_ROMAJI      = 0x07,
   CT_HANGUEL     = 0x08,
} CT;


// Declare node types transitions
// Intuitively frequency ordered
//
typedef enum _WT {
   WT_START       = 0x00,
   WT_WORD_SEP    = 0x01,
   WT_PHRASE_SEP  = 0x02,
   WT_ROMAJI      = 0x03,
   WT_HANGUEL     = 0x04,
   WT_REACHEND    = 0x05,
} WT;


#define CT_MAX    0x09

#endif // _CTPLUS_0_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\guessindex.h ===
// GuessIndex.h
//
// guessing index terms
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  21 MAR 2000  bhshin     convert CIndexList into CIndexInfo
//  10 APR 2000	  bhshin	created

#ifndef _GUESS_INDEX_H
#define _GUESS_INDEX_H

#include "IndexRec.h"

BOOL GuessIndexTerms(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo);

void GuessPersonName(PARSE_INFO *pPI, CIndexInfo *pIndexInfo);

#endif // #ifndef _GUESS_INDEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\globals.h ===
// globals.h
// global structure decalrations
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  02 JUN 2000   bhshin    add cNounRec, cNoRec entry in WORD_REC
//  30 MAR 2000	  bhshin	created

#define MAX_INPUT_TOKEN     16

#define MAX_ENTRY_LENGTH	128
#define MAX_INDEX_STRING	128

typedef unsigned int Bit;

// RECORD structure info
// =====================
typedef struct {
	WCHAR wzIndex[MAX_INDEX_STRING]; // index string
	unsigned short nFT, nLT;		 // first and last token/char in input sentence
	unsigned char nDict;			 // dict source info (see DICT_* below)
	unsigned short nLeftCat;		 // left side CAT (CAT -> POS|Infl)
	unsigned short nRightCat;		 // right side CAT
	unsigned short nLeftChild;		 // left child record
	unsigned short nRightChild;		 // right child record
	float fWeight;					 // record weight value
	int cNounRec;					 // number of (Nf, Nc, Nn) record
	int cNoRec;						 // number of No record
} WORD_REC, *pWORD_REC;


// CHAR_INFO_REC structure
// =======================
typedef struct {
    union {
        // having a separate mask allows us to quickly init these values
        unsigned char mask;
        struct {
            Bit fValidStart : 1;    // pre-composed jamo starting char
            Bit fValidEnd : 1;      // pre-composed jamo ending char
        };
    };
    unsigned short nToken;
} CHAR_INFO_REC, *pCHAR_INFO_REC;


// MAPFILE structure
// =================
typedef struct {
    HANDLE hFile;
    HANDLE hFileMapping;
    void *pvData;
} MAPFILE, *pMAPFILE;


// PARSE INFO structure
// ====================
typedef struct {
    // pointer to original (unmodified) input string
    WCHAR *pwzInputString;

    // input string with normalizations
    WCHAR *pwzSourceString;

    // ptr to CharInfo array
    // a '1' in this array indicates that the character position is a valid
    // start position for records
    // (maps 1-1 with pwzSourceString)
    CHAR_INFO_REC *rgCharInfo;

    // source(normalized) string length
    int nLen;

    // largest valid LT value
    int nMaxLT;

    // the lexicon (mapped into memory)
    MAPFILE lexicon;

    // record management
    // =================
    // array of records
	WORD_REC *rgWordRec;

	// # of allocated records in pWordRec
	int nMaxRec;
	// next empty space in pWordRec
	int nCurrRec;

} PARSE_INFO, *pPARSE_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\guessindex.cpp ===
// GuessIndex.cpp
//
// guessing index terms
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  21 MAR 2000  bhshin     convert CIndexList into CIndexInfo
//  10 APR 2000   bhshin        created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "ChartPool.h"
#include "GuessIndex.h"
#include "unikor.h"
#include "Morpho.h"
#include "WbData.h"
#include "Lookup.h"
#include "LexInfo.h"
#include "_kor_name.h"
#include "uni.h"
#include <math.h>

//////////////////////////////////////////////////////////////////////////////
// Threshold for Korean name guessing

#define THRESHOLD_TWO_NAME        37
#define THRESHOLD_ONE_NAME        37

//////////////////////////////////////////////////////////////////////////////
// Particle pattern needed to check C/V

#define POSP_NEED_V                       1
#define POSP_NEED_C                       2

//////////////////////////////////////////////////////////////////////////////
// Particle pattern needed to check C/V

// , 
#define HANGUL_NEUN                     0xB294
#define HANGUL_REUL                     0xB97C

// , , , , 
#define HANGUL_NIM                      0xB2D8
#define HANGUL_SSI                      0xC528
#define HANGUL_DEUL                     0xB4E4
#define HANGUL_MICH                     0xBC0F 
#define HANGUL_DEUNG            0xB4F1 

//////////////////////////////////////////////////////////////////////////////
// Post position of name

//   
static const WCHAR POSP_OF_NAME[]   = L"\xC758\xB9CC\xB3C4";
//    
static const WCHAR POSP_OF_NAME_V[] = L"\xB791\xB098\xAC00\xC640";
//  
static const WCHAR POSP_OF_NAME_C[] = L"\xC774\xACFC";

#define HANGUL_RANG                     0xB791

//////////////////////////////////////////////////////////////////////////////
// Bit mask for Trigram tag value
// (2bit) + TRIGRAM(10bit) + BIGRAM(10bit) + UNIGRAM(10BIT)

const ULONG BIT_MASK_TRIGRAM = 0x3FF00000;
const ULONG BIT_MASK_BIGRAM     = 0x000FFC00;
const ULONG BIT_MASK_UNIGRAM = 0x000003FF;

//////////////////////////////////////////////////////////////////////////////
// Costants for guessing index

const float WEIGHT_GUESS_INDEX   =      20;

//////////////////////////////////////////////////////////////////////////////
// Internal function declarations

int MakeIndexStr(const WCHAR *pwzSrc, int cchSrc, WCHAR *pwzDst, int nMaxDst);

BOOL GuessNounIndexTerm(PARSE_INFO *pPI, int nMaxFT, int nMaxLT, 
                                            CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo);

BOOL ExistParticleRecord(PARSE_INFO *pPI, int nStart, int nEnd, CLeafChartPool *pLeafChartPool);

BOOL CheckGuessing(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo);

BOOL IsKoreanPersonName(PARSE_INFO *pPI, const WCHAR *pwzInput, int cchInput);

//////////////////////////////////////////////////////////////////////////////
// Function implementations

// GuessIndexTerms
//
// guessing index terms
//
// Parameters:
//  pPI                    -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
//  pIndexInfo     -> (CIndexInfo *) output index list
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 10APR00  bhshin  began
BOOL GuessIndexTerms(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo)
{
        int curr, next;
        WORD_REC *pWordRec;
        BYTE bPOS;
        int nFT, nLT;
        int nToken;
        WCHAR wzIndex[MAX_INDEX_STRING+1];
        int cchIndex;
        WCHAR wchLast;

        if (pPI == NULL || pLeafChartPool == NULL || pIndexInfo == NULL)
                return FALSE;

        // Check whether the input is worth for Guessing or Not
        if (!CheckGuessing(pPI, pLeafChartPool, pIndexInfo))
                return TRUE;

        // guessing index terms for all input
        cchIndex = wcslen(pPI->pwzInputString);
        wchLast = pPI->pwzInputString[cchIndex-1];
        
        //  STEP1:
        // gusessing index terms for all STRING
        if (wchLast != HANGUL_NEUN && wchLast != HANGUL_REUL)
        {
                pIndexInfo->AddIndex(pPI->pwzInputString, cchIndex, WEIGHT_GUESS_INDEX, 0, cchIndex-1);
                WB_LOG_ADD_INDEX(pPI->pwzInputString, cchIndex, INDEX_GUESS_NOUN);
        }

        // STEP1-1:
        // according to post-position, add guessing index terms 
        // if (last character of STRING in {  } )
    //    index_terms(STRING);
    //    index_terms(STRING-{/})
        if (cchIndex > 1 && (wchLast == HANGUL_MICH || wchLast == HANGUL_DEUNG))
        {
                pIndexInfo->AddIndex(pPI->pwzInputString, cchIndex, WEIGHT_GUESS_INDEX, 0, cchIndex-1);
                WB_LOG_ADD_INDEX(pPI->pwzInputString, cchIndex, INDEX_GUESS_NOUN);

                pIndexInfo->AddIndex(pPI->pwzInputString, cchIndex-1, WEIGHT_GUESS_INDEX, 0, cchIndex-2);
                WB_LOG_ADD_INDEX(pPI->pwzInputString, cchIndex-1, INDEX_GUESS_NOUN);
        }

        GuessNounIndexTerm(pPI, 0, pPI->nMaxLT, pLeafChartPool, pIndexInfo);

        /*
        // find fiducial Noun in LeafChartPool
        for (int i = pPI->nLen; i >= 0; i--)
        {
                // if it don't match character boundary, then skip
                if (!pPI->rgCharInfo[i].fValidStart)
                        continue;               
                
                curr = pLeafChartPool->GetFTHead(i);

                while (curr != 0)
                {
                        next = pLeafChartPool->GetFTNext(curr);

                        pWordRec = pLeafChartPool->GetWordRec(curr);
                        if (pWordRec == NULL)
                                break;

                        curr = next;

                        bPOS = HIBYTE(pWordRec->nLeftCat);
                        nFT = pWordRec->nFT;
                        nLT = pWordRec->nLT;

                        if (!pPI->rgCharInfo[nLT].fValidEnd)
                                continue;
                        
                        if (bPOS == POS_NF)
                        {
                                // add this NF record as index terms
                                cchIndex = MakeIndexStr(pWordRec->wzIndex, wcslen(pWordRec->wzIndex), wzIndex, MAX_INDEX_STRING);
                                wchLast = wzIndex[cchIndex-1];

                                if (wchLast != HANGUL_NEUN && wchLast != HANGUL_REUL)
                                {
                                        nToken = pPI->rgCharInfo[nFT].nToken;

                                        pIndexList->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-1);
                                        WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NF);
                                }

                                // Rear rest string case                                
                                if (nLT < pPI->nMaxLT)
                                {
                                        // make index term with rear rest string
                                        WCHAR *pwzRest = pPI->pwzSourceString + nLT + 1;

                                        // 1. NF is front record
                                        // 2. RearRestString & RearRestString is not Particle/CopulaEnding 
                                        if (nFT == 0 && !ExistParticleRecord(pPI, nLT + 1, pPI->nMaxLT, pLeafChartPool))
                                        {
                                                cchIndex = MakeIndexStr(pwzRest, wcslen(pwzRest), wzIndex, MAX_INDEX_STRING);
                                                wchLast = wzIndex[cchIndex-1];

                                                if (cchIndex > 1 && (wchLast != HANGUL_NEUN && wchLast != HANGUL_REUL))
                                                {
                                                        nToken = pPI->rgCharInfo[nLT+1].nToken;

                                                        pIndexList->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-1);
                                                        WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NF);
                                                }

                                                GuessNounIndexTerm(pPI, nLT + 1, pPI->nMaxLT, pLeafChartPool, pIndexList);
                                        }
                                }
                                
                                // Front rest string case
                                if (i > 0)
                                {
                                        // make index term with rest string
                                        cchIndex = MakeIndexStr(pPI->pwzSourceString, i, wzIndex, MAX_INDEX_STRING);
                                        wchLast = wzIndex[cchIndex-1];

                                        if (cchIndex > 1 && (wchLast != HANGUL_NEUN && wchLast != HANGUL_REUL))
                                        {       
                                                pIndexList->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, 0, cchIndex-1);
                                                WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NF);
                                        }
                                }

                                break; // go to next FT
                        }
                }
        }
        */
        
        return TRUE;
}

// MakeIndexStr
//
// make composed index string from decomposed string
//
// Parameters:
//  pwzSrc         -> (const WCHAR*) ptr to input decomposed string
//  cchSrc         -> (int) size of input string
//  pwzDst     -> (WCHAR*) ptr to output buffer
//  nMaxDst    -> (int) size of output buffer
//
// Result:
//  (int) character length of composed output
//
// 10APR00  bhshin  began
int MakeIndexStr(const WCHAR *pwzSrc, int cchSrc, WCHAR *pwzDst, int nMaxDst)
{
        WCHAR wzDecomp[MAX_INDEX_STRING*3+1];

        ZeroMemory(wzDecomp, sizeof(WCHAR)*(MAX_INDEX_STRING*3+1));

        // compose index string

        const int ccDecomp = ( sizeof( wzDecomp ) / sizeof( wzDecomp[0] ) ) - 1;

        wcsncpy( wzDecomp, pwzSrc, __min( cchSrc, ccDecomp ) );

        return compose_jamo(pwzDst, wzDecomp, nMaxDst);
}

// GuessNounIndexTerm
//
// remove particle from the end of words and guess noun index term
//
// Parameters:
// pPI                    -> (PARSE_INFO*) ptr to parse-info struct
// nMaxFT                 -> (int) 
// nMaxLT                 -> (int) 
// pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
// pIndexInfo     -> (CIndexInfo *) output index list
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 10APR00  bhshin  began
BOOL GuessNounIndexTerm(PARSE_INFO *pPI, int nMaxFT, int nMaxLT, 
                                            CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo)
{
        int curr, next;
        WORD_REC *pWordRec;
        BYTE bPOS, bPattern;
        int nLT;
        WCHAR wzIndex[MAX_INDEX_STRING];
        int cchIndex;
        WCHAR wchLast, wchPrevLast, wchFinal;
        int nToken;

        if (pPI == NULL)
                return FALSE;

        if (pLeafChartPool == NULL)
                return FALSE;

        if (pIndexInfo == NULL)
                return FALSE;

        for (int i = nMaxLT; i >= nMaxFT; i--)
        {
                // if it don't match character boundary, then skip
                if (!pPI->rgCharInfo[i].fValidStart)
                        continue;
                
                // need for C/V check
                wchFinal = *(pPI->pwzSourceString + i - 1);

                curr = pLeafChartPool->GetFTHead(i);

                while (curr != 0)
                {
                        next = pLeafChartPool->GetFTNext(curr);

                        pWordRec = pLeafChartPool->GetWordRec(curr);
                        if (pWordRec == NULL)
                                break;

                        bPOS = HIBYTE(pWordRec->nLeftCat);
                        bPattern = LOBYTE(pWordRec->nLeftCat);

                        nLT = pWordRec->nLT;

                        // looking for particle covering from i to end of input
                        if (nLT == nMaxLT && (bPOS == POS_POSP || IsCopulaEnding(pPI, pWordRec->nLeftCat)))
                        {
                                // In Particle case, check Consonent/Vowel condition
                                if (bPOS == POS_POSP && i > 0)
                                {
                                        if ((bPattern == POSP_NEED_V && !fIsJungSeong(wchFinal)) ||
                                            (bPattern == POSP_NEED_C && !fIsJongSeong(wchFinal)))
                                        {
                                                // C/V condition mismatched, then go to next
                                                curr = next;
                                                continue;
                                        }
                                }
                                
                                // make index term with string from nMaxFT to i-nMaxFT
                                cchIndex = MakeIndexStr(pPI->pwzSourceString + nMaxFT, i-nMaxFT, wzIndex, MAX_INDEX_STRING);
                                if (cchIndex > 1)
                                {
                                        wchLast = wzIndex[cchIndex-1];
                                        
                                        if (wchLast != HANGUL_NEUN && wchLast != HANGUL_REUL)
                                        {
                                                nToken = pPI->rgCharInfo[nMaxFT].nToken;

                                                pIndexInfo->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-1);
                                                WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NOUN);
                                        }

                                        wchPrevLast = wzIndex[cchIndex-2];
                                        
                                        if ((wchLast == HANGUL_NIM || wchLast == HANGUL_SSI || wchLast == HANGUL_DEUL) &&
                                                (wchPrevLast != HANGUL_NEUN && wchPrevLast != HANGUL_REUL))
                                        {
                                                wzIndex[cchIndex-1] = L'\0';

                                                nToken = pPI->rgCharInfo[nMaxFT].nToken;
                                                
                                                pIndexInfo->AddIndex(wzIndex, cchIndex-1, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-2);
                                                WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NOUN);
                                        }
                                }
                                else if (cchIndex == 1)
                                {
                                        nToken = pPI->rgCharInfo[nMaxFT].nToken;

                                        pIndexInfo->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-1);
                                        WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NOUN);
                                }

                                break; // go to next FT
                        }

                        curr = next;
                }
        }

        return TRUE;
}

// ExistParticleRecord
//
// looking for Particle/CopulaEnding record covering from Start to End
//
// Parameters:
// pPI            -> (PARSE_INFO*) ptr to parse-info struct
// nStart         -> (int) 
// nEnd           -> (int) 
// pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
//
// Result:
//  (BOOL) TRUE if found, otherwise return FALSE
//
// 10APR00  bhshin  began
BOOL ExistParticleRecord(PARSE_INFO *pPI, int nStart, int nEnd, CLeafChartPool *pLeafChartPool)
{
        int curr;
        WORD_REC *pWordRec;
        int nLT;
        BYTE bPOS;
        
        if (pPI == NULL || pLeafChartPool == NULL)
                return FALSE;

        curr = pLeafChartPool->GetFTHead(nStart);
        while (curr != 0)
        {
                pWordRec = pLeafChartPool->GetWordRec(curr);
                if (pWordRec == NULL)
                        continue;

                curr = pLeafChartPool->GetFTNext(curr);

                nLT = pWordRec->nLT;

                // record covering from Start to End found 
                if (nLT == nEnd)
                {
                        bPOS = HIBYTE(pWordRec->nLeftCat);

                        // Particle or Copula Ending
                        if (bPOS == POS_POSP || IsCopulaEnding(pPI, pWordRec->nLeftCat))
                                return TRUE;
                }
        }

        return FALSE;
}

// CheckGuessing
//
// Check whether the input is worth for Guessing or Not
//
// Parameters:
//  pPI                    -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
//  pIndexInfo     -> (CIndexInfo *) output index list
//
// Result:
//  (BOOL) TRUE if guessing needed, otherwise return FALSE
//
// 10APR00  bhshin  began
BOOL CheckGuessing(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo)
{
        int curr, next;
        WORD_REC *pWordRec;
        WCHAR wzIndex[MAX_INDEX_STRING];
        int cchIndex;
        int nToken;
        
        // If there is no jongseong (11BB), (11AD), (11B6), (CC2E), (C796) then guessing needed.
        if (wcsrchr(pPI->pwzSourceString, 0x11BB) == NULL &&
                wcsrchr(pPI->pwzSourceString, 0x11AD) == NULL &&
                wcsrchr(pPI->pwzSourceString, 0x11B6) == NULL &&
                wcsrchr(pPI->pwzInputString, 0xCC2E) == NULL &&
                wcsrchr(pPI->pwzInputString, 0xC796) == NULL)
                return TRUE; // guessing needed

        // make index terms for each Nf records in LeafChartPool
        // find fiducial Noun in LeafChartPool
        for (int i = pPI->nLen; i >= 0; i--)
        {
                // if it don't match character boundary, then skip
                if (!pPI->rgCharInfo[i].fValidStart)
                        continue;               
                
                curr = pLeafChartPool->GetFTHead(i);

                while (curr != 0)
                {
                        next = pLeafChartPool->GetFTNext(curr);

                        pWordRec = pLeafChartPool->GetWordRec(curr);
                        if (pWordRec == NULL)
                                break;

                        curr = next;

                        if (HIBYTE(pWordRec->nLeftCat) == POS_NF)
                        {
                                // add this NF record as index terms
                                cchIndex = MakeIndexStr(pWordRec->wzIndex, wcslen(pWordRec->wzIndex), wzIndex, MAX_INDEX_STRING);

                                nToken = pPI->rgCharInfo[pWordRec->nFT].nToken;                 

                                pIndexInfo->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-1);
                                WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NF);
                        }
                }
        }
        
        return FALSE;
}

// GuessPersonName
//
// recognize whether it can be a name or not
//
// Parameters:
//  pPI                 -> (PARSE_INFO*) ptr to parse-info struct
//  pIndexInfo  -> (CIndexInfo *) output index list
//
// Result:
//  (int) string length if it can be a person's name, othewise return 0
//
// 05JUN00  bhshin  change retrun type
// 02MAY00  bhshin  use probability result
// 20APR00  bhshin  began
void GuessPersonName(PARSE_INFO *pPI, CIndexInfo *pIndexInfo)
{
        WCHAR wchLast;
        WCHAR *pwzFind;
        const WCHAR *pwzInput;
        const WCHAR *pwzSource;
        int cchInput, cchName, cchSource;

        if (pPI == NULL)
                return;

        pwzInput = pPI->pwzInputString;
        pwzSource = pPI->pwzSourceString;

        cchInput = wcslen(pwzInput);

        if (cchInput >= 3)
        {
                pwzFind = wcschr(pwzInput, HANGUL_SSI);
                
                if (pwzFind != NULL)
                {
                        cchName = (int)(pwzFind - pwzInput);
                        return;
                }
        }

        // just handle length 2,3,4 case
        if (cchInput < 2 || cchInput > 5)
                return;

        wchLast = pwzInput[cchInput-1];
        if (wchLast == HANGUL_REUL || wchLast == HANGUL_NEUN)
                return;

        // looking for jongseong (11BB)
        if (wcsrchr(pwzSource, 0x11BB) != NULL)
                return;

        // check if original string is name
        if (cchInput <= 4)
        {
                if (IsKoreanPersonName(pPI, pwzInput, cchInput))
                {
                        pIndexInfo->AddIndex(pwzInput, cchInput, WEIGHT_HARD_MATCH, 0, cchInput-1);
                        WB_LOG_ADD_INDEX(pwzInput, cchInput, INDEX_GUESS_NAME);
                }
        }

        cchName = cchInput;
        cchSource = wcslen(pwzSource);

        if (cchInput >= 3 && cchInput <= 5 && cchSource > 4)
        {
                // looking for name posp

                if (wcsrchr(POSP_OF_NAME, wchLast) != NULL)
                {
                        cchName--;
                }
                else if (wcsrchr(POSP_OF_NAME_V, wchLast) != NULL)
                {
                        //  case
                        if (wchLast == HANGUL_RANG && fIsV(pwzSource[cchSource-4]))
                                cchName--;
                        else if (fIsV(pwzSource[cchSource-3]))
                                cchName--;
                }
                else if (wcsrchr(POSP_OF_NAME_C, wchLast) != NULL)
                {
                        cchSource = wcslen(pwzSource);

                        if (fIsC(pwzSource[cchSource-3]))
                                cchName--;
                }
        }

        // we handle just length 2,3,4 name.
        if (cchName > 4)
                return;

        if (cchName < cchInput)
        {
                if (IsKoreanPersonName(pPI, pwzInput, cchName))
                {
                        pIndexInfo->AddIndex(pwzInput, cchName, WEIGHT_HARD_MATCH, 0, cchName-1);
                        WB_LOG_ADD_INDEX(pwzInput, cchName, INDEX_GUESS_NAME);
                }
        }
}

// IsKoreanPersonName
//
// get the probability of korean name
//
// Parameters:
//  pPI                  -> (PARSE_INFO*) ptr to parse-info struct
//  pwzInput    -> (const WCHAR*) current input string (NULL terminated)
//  cchInput    -> (int) length of input string to analyze
//
// Result:
//  (BOOL) TRUE if it can be a person's name, othewise return FALSE
//
// 02MAY00  bhshin  began
BOOL IsKoreanPersonName(PARSE_INFO *pPI, const WCHAR *pwzInput, int cchInput)
{
        LEXICON_HEADER *pLex;
        unsigned char *pKorName;
        unsigned char *pTrigramTag;
        TRIECTRL *pTrieLast, *pTrieUni, *pTrieBi, *pTrieTri;
        WCHAR wzLastName[5];
        WCHAR wzName[5];
        const WCHAR *pwzName;
        const WCHAR *pwzLastName; 
        const WCHAR *pwzFirstName;
        int cchLast, cchFirst;
        ULONG ulFreq, ulTri, ulBi, ulUni;
        int nIndex;
        double fRetProb, fProb;
        ULONG rgTotal[3] = {TOTAL_KORNAME_TRIGRAM, TOTAL_KORNAME_BIGRAM, TOTAL_KORNAME_UNIGRAM};
        double rgWeight[3] = {0.1, 0.4, 0.5};

        pTrieLast = NULL;
        pTrieUni = NULL;
        pTrieBi = NULL;
        pTrieTri = NULL;

        if (pPI == NULL)
                return FALSE;

        pLex = (LEXICON_HEADER*)pPI->lexicon.pvData;
        if (pLex == NULL)
                return FALSE;

        pKorName = (unsigned char*)pLex;
        pKorName += pLex->rgnLastName;

        pTrieLast = TrieInit((LPBYTE)pKorName);
        if (pTrieLast == NULL)
                goto Exit;
        
        pKorName = (unsigned char*)pLex;
        pKorName += pLex->rgnNameUnigram;

        pTrieUni = TrieInit((LPBYTE)pKorName);
        if (pTrieUni == NULL)
                goto Exit;

        pKorName = (unsigned char*)pLex;
        pKorName += pLex->rgnNameBigram;

        pTrieBi = TrieInit((LPBYTE)pKorName);
        if (pTrieBi == NULL)
                goto Exit;

        pKorName = (unsigned char*)pLex;
        pKorName += pLex->rgnNameTrigram;

        pTrieTri = TrieInit((LPBYTE)pKorName);
        if (pTrieTri == NULL)
                goto Exit;

        pTrigramTag = (unsigned char*)pLex;
        pTrigramTag += pLex->rngTrigramTag;

        // last name
        fProb = 0;

        if (cchInput == 2)
        {
                wzLastName[0] = *pwzInput;
                wzLastName[1] = L'\0';

                if (!LookupNameFrequency(pTrieLast, wzLastName, &ulFreq))
                        goto Exit;

                if (ulFreq == 0)
                        goto Exit;

                fProb = (double)ulFreq / TOTAL_KORNAME_LASTNAME;

                pwzFirstName = pwzInput + 1;
        }
        else if (cchInput == 3) // length 3 case
        {
                wzLastName[0] = *pwzInput;
                wzLastName[1] = L'\0';

                if (!LookupNameFrequency(pTrieLast, wzLastName, &ulFreq))
                        goto Exit;

                if (ulFreq == 0)
                {
                        // guess length 2 last name

                        wcsncpy(wzLastName, pwzInput, 2);
                        wzLastName[2] = L'\0';
                        
                        if (!LookupNameFrequency(pTrieLast, wzLastName, &ulFreq))
                                goto Exit;

                        if (ulFreq == 0)
                                goto Exit;

                        fProb = (double)ulFreq / TOTAL_KORNAME_LASTNAME;

                        pwzFirstName = pwzInput + 2;
                }
                else
                {
                        fProb = (double)ulFreq / TOTAL_KORNAME_LASTNAME;

                        pwzFirstName = pwzInput + 1;
                }
        }
        else if (cchInput == 4)
        {
                // guess length 2 last name
                wcsncpy(wzLastName, pwzInput, 2);
                wzLastName[2] = L'\0';

                if (!LookupNameFrequency(pTrieLast, wzLastName, &ulFreq))
                        goto Exit;

                if (ulFreq == 0)
                        goto Exit;

                fProb = (double)ulFreq / TOTAL_KORNAME_LASTNAME;

                pwzFirstName = pwzInput + 2;
        }

        if (fProb == 0)
                goto Exit;

        fRetProb = log(fProb);
        
        pwzLastName = wzLastName;

        cchLast = wcslen(pwzLastName);
        cchFirst = cchInput - cchLast;

        ATLASSERT(cchLast == 1 || cchLast == 2);
        ATLASSERT(cchFirst == 1 || cchFirst == 2);

        // first -> [*][Last][First1]
        wzName[0] = L'*';
        wcscpy(wzName+1, pwzLastName);
        wzName[cchLast+1] = *pwzFirstName;
        wzName[cchLast+2] = L'\0';

        pwzName = wzName;

        fProb = 0;

        if (!LookupNameIndex(pTrieTri, pwzName, &nIndex))
                goto Exit;

        if (nIndex != -1)
        {
                LookupTrigramTag(pTrigramTag, nIndex, &ulTri, &ulBi, &ulUni);

                fProb += rgWeight[0] * (double)ulTri / rgTotal[0];
                fProb += rgWeight[1] * (double)ulBi / rgTotal[1];
                fProb += rgWeight[2] * (double)ulUni / rgTotal[2];
        }
        else
        {
                pwzName++; // skip *

                if (!LookupNameFrequency(pTrieBi, pwzName, &ulFreq))
                        goto Exit;

                fProb += rgWeight[1] * (double)ulFreq / rgTotal[1];

                pwzName += cchLast; // skip [Last]

                if (!LookupNameFrequency(pTrieUni, pwzName, &ulFreq))
                        goto Exit;

                fProb += rgWeight[2] * (double)ulFreq / rgTotal[2];
        }

        if (fProb == 0)
                goto Exit;

        fRetProb += log(fProb);

        // second -> [Last][First1][First2]
        if (cchFirst == 2)
        {
                wcscpy(wzName, pwzLastName);
                wzName[cchLast] = *pwzFirstName;
                wzName[cchLast+1] = *(pwzFirstName+1);
                wzName[cchLast+2] = L'\0';

                pwzName = wzName;
        
                fProb = 0;

                if (!LookupNameIndex(pTrieTri, pwzName, &nIndex))
                        goto Exit;

                if (nIndex != -1)
                {
                        LookupTrigramTag(pTrigramTag, nIndex, &ulTri, &ulBi, &ulUni);

                        fProb += rgWeight[0] * (double)ulTri / rgTotal[0];
                        fProb += rgWeight[1] * (double)ulBi / rgTotal[1];
                        fProb += rgWeight[2] * (double)ulUni / rgTotal[2];
                }
                else
                {
                        pwzName += cchLast; // skip [Last]
                        
                        if (!LookupNameFrequency(pTrieBi, pwzName, &ulFreq))
                                goto Exit;

                        fProb += rgWeight[1] * (double)ulFreq / rgTotal[1];

                        pwzName++; // skip [First1]

                        if (!LookupNameFrequency(pTrieUni, pwzName, &ulFreq))
                                goto Exit;

                        fProb += rgWeight[2] * (double)ulFreq / rgTotal[2];
                }

                if (fProb == 0)
                        goto Exit;
                
                fRetProb += log(fProb);
        }

        // third -> [First1][First2][*] or [Last][First1][*]
        if (cchFirst == 2)
        {
                wcscpy(wzName, pwzFirstName);
                wzName[cchFirst] = L'*';
                wzName[cchFirst+1] = L'\0';
        }
        else // cchFirst == 1
        {
                ATLASSERT(cchFirst == 1);
                
                wcscpy(wzName, pwzLastName);
                wzName[cchLast] = *pwzFirstName;
                wzName[cchLast+1] = L'*';
                wzName[cchLast+2] = L'\0';
        }

        pwzName = wzName;
                
        fProb = 0;

        if (!LookupNameIndex(pTrieTri, pwzName, &nIndex))
                goto Exit;

        if (nIndex != -1)
        {
                LookupTrigramTag(pTrigramTag, nIndex, &ulTri, &ulBi, &ulUni);

                fProb += rgWeight[0] * (double)ulTri / rgTotal[0];
                fProb += rgWeight[1] * (double)ulBi / rgTotal[1];
                fProb += rgWeight[2] * (double)ulUni / rgTotal[2];
        }
        else
        {
                if (cchFirst == 1)
                        pwzName += cchLast;
                else
                        pwzName++;
                
                if (!LookupNameFrequency(pTrieBi, pwzName, &ulFreq))
                        goto Exit;

                fProb = rgWeight[1] * (float)ulFreq / rgTotal[1];
        }

        if (fProb == 0)
                goto Exit;
        
        fRetProb += log(fProb);

        // make positive value
        fRetProb *= -1;

        TrieFree(pTrieLast);
        TrieFree(pTrieUni);
        TrieFree(pTrieBi);
        TrieFree(pTrieTri);

        // check threshold
        if (cchFirst == 2)
        {
                if (fRetProb < THRESHOLD_TWO_NAME)
                        return TRUE;
                else
                        return FALSE;
        }
        else // cchFirst == 1
        {
                ATLASSERT(cchFirst == 1);
                
                if (fRetProb < THRESHOLD_ONE_NAME)
                        return TRUE;
                else
                        return FALSE;
        }

Exit:
        if (pTrieLast != NULL)
                TrieFree(pTrieLast);

        if (pTrieUni != NULL)
                TrieFree(pTrieUni);
        
        if (pTrieBi != NULL)
                TrieFree(pTrieBi);
        
        if (pTrieTri != NULL)
                TrieFree(pTrieTri);

        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\indexrec.cpp ===
// IndexRec.cpp
//
// final index record & lists
// 
// Copyright 2001 Microsoft Corp.
//
// Modification History:
//  19 MAR 2001   bhshin        created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "IndexRec.h"
#include "Morpho.h"

// the number of records (in prgIndexRec) that we should allocate in a clump.
// this is used whenever we need to re-alloc the array
#define RECORD_CLUMP_SIZE   100

//======================================================
// CRecList
//======================================================

// CRecList::CRecList
//
// constructor
//
// Parameters:
//  (NONE)
//
// Result:
//  (NONE)
//
// 20MAR01  bhshin  began
CRecList::CRecList()
{
        m_prgnRecID = NULL; 
        m_nMaxRec = 0; 
        m_nCurrRec = MIN_RECORD; 
}

// CRecList::~CRecList
//
// destructor
//
// Parameters:
//  (NONE)
//
// Result:
//  (NONE)
//
// 20MAR01  bhshin  began
CRecList::~CRecList()
{
        Uninitialize(); 
}

// CRecList::Initialize
//
// initialize CRecList
//
// Parameters:
//  (NONE)
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 20MAR01  bhshin  began
BOOL CRecList::Initialize(void)
{
        m_nCurrRec = MIN_RECORD; 

    // allocate new IndexRec
    if (m_prgnRecID == NULL)
    {
        m_nMaxRec = RECORD_CLUMP_SIZE;
        m_prgnRecID = (int*)malloc(m_nMaxRec * sizeof(int));
        if (m_prgnRecID == NULL)
        {
            m_nMaxRec = 0;
            return FALSE;
        }
    }

        return TRUE;
}

// CRecList::Uninitialize
//
// unitialize CRecList
//
// Parameters:
//  (NONE)
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 20MAR01  bhshin  began
void CRecList::Uninitialize(void)
{
    // free IndexRec
    if (m_prgnRecID != NULL)
    {
                free(m_prgnRecID);
                m_prgnRecID = NULL;
    }

        m_nMaxRec = 0; 
        m_nCurrRec = MIN_RECORD; 
}

// CRecList::AddRec
//
// add record id
//
// Parameters:
//  nRecID -> (int) record id
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 20MAR01  bhshin  began
BOOL CRecList::AddRec(int nRecID)
{
        int *prgnRecID;
        int nMaxRec;

        if (m_prgnRecID == NULL)
                return FALSE;

        // make sure if there is enough room for new record (maximum 3 records can be added)
        if (m_nMaxRec <= m_nCurrRec)
        {
        nMaxRec = m_nMaxRec + RECORD_CLUMP_SIZE;
        
        prgnRecID = (int*)realloc(m_prgnRecID, nMaxRec * sizeof(int));
        if (prgnRecID == NULL)
            return FALSE;

                m_nMaxRec = nMaxRec;
        m_prgnRecID = prgnRecID;
        }

        m_prgnRecID[m_nCurrRec] = nRecID;
        m_nCurrRec++;

        return TRUE;
}

// CRecList::operator =
//
// assign operator
//
// Parameters:
//  objRecList -> (CRecList&)
//
// Result:
//  (CRecList&)
//
// 20MAR01  bhshin  began
CRecList& CRecList::operator = (CRecList& objRecList)
{
        int nRecord, nRecID;

        // re-initialize this
        Uninitialize();
        if (!Initialize())
                throw 0;
        
        for (nRecord = MIN_RECORD; nRecord < objRecList.m_nCurrRec; nRecord++)
        {
                nRecID = objRecList.m_prgnRecID[nRecord];
                if (!AddRec(nRecID))
                        throw 0;
        }

        return *this;
}

// CRecList::operator +=
//
// unary sum operator
//
// Parameters:
//  objRecList -> (CRecList&)
//
// Result:
//  (CRecList&)
//
// 20MAR01  bhshin  began
CRecList& CRecList::operator += (CRecList& objRecList)
{
        int nRecord, nRecID;
        
        for (nRecord = MIN_RECORD; nRecord < objRecList.m_nCurrRec; nRecord++)
        {
                nRecID = objRecList.m_prgnRecID[nRecord];
                if (!AddRec(nRecID))
                        throw 0;
        }

        return *this;
}


//======================================================
// CIndexInfo
//======================================================

// CIndexInfo::CIndexInfo
//
// default constructor of CIndexRec
//
// Parameters:
//  (NONE)
//
// Result:
//  (NONE)
//
// 19MAR01  bhshin  began
CIndexInfo::CIndexInfo()
{
        m_prgIndexRec = NULL;
        m_nMaxRec = 0;
        m_nCurrRec = MIN_RECORD;

        m_cchTextProcessed = 0;
        m_cwcSrcPos = 0;
        m_pWordSink = NULL; 
        m_pPhraseSink = NULL;

        m_wzRomaji[0] = L'\0';
        m_cchRomaji = 0;
        m_cchPrefix = 0;
        m_fAddRomaji = FALSE;

        m_nFinalHead = 0;
}

// CIndexInfo::~CIndexInfo
//
// destructor of CIndexRec
//
// Parameters:
//  (NONE)
//
// Result:
//  (NONE)
//
// 19MAR01  bhshin  began
CIndexInfo::~CIndexInfo()
{
        Uninitialize();
}

// CIndexInfo::IsExistIndex
//
// check if index term already exist.
//
// Parameters:
//  pwzIndex    -> (const WCHAR*) index string
//
// Result:
//  (BOOL)
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::IsExistIndex(const WCHAR *pwzIndex)
{
        for (int i = MIN_RECORD; i < m_nCurrRec; i++)
        {
                // found duplicate index term
                if (wcscmp(m_prgIndexRec[i].wzIndex, pwzIndex) == 0)
                        return TRUE;
        }

        return FALSE;
}

// CIndexInfo::SetRomajiInfo
//
// make final index list to put word
//
// Parameters:
//  pwzRomaji -> (WCHAR*) leading romaji string
//  cchRomaji -> (int) length of romaji string
//  cchPrefix -> (int) length of prefix (ex, http://)
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::SetRomajiInfo(WCHAR *pwzRomaji, int cchRomaji, int cchPrefix)
{
        if (pwzRomaji == NULL || cchRomaji > MAX_INDEX_STRING)
        {
                m_wzRomaji[0] = L'\0';
                m_cchRomaji = 0;
                m_cchPrefix = 0;

                return FALSE;
        }

        wcsncpy(m_wzRomaji, pwzRomaji, cchRomaji);
        m_wzRomaji[cchRomaji] = L'\0';
        m_cchRomaji = cchRomaji; 
        m_cchPrefix = cchPrefix; 

        return TRUE;
}

// CIndexInfo::Initialize
//
// initialize all the members of CIndexRec
//
// Parameters:
//  cchTextProcessed -> (int) length of text processed
//  cwcSrcPos       -> (int) position value of source string
//  pWordSink       -> (IWordSink) IWordSink for PutWord/PutAltWord
//  pPhraseSink      -> (IPhraseSink) IPhraseSink for PutWord/PutAltWord
//
// Result:
//  (BOOL) TRUE if it succeeds to initialize
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::Initialize(int cchTextProcessed, int cwcSrcPos, IWordSink *pWordSink, IPhraseSink *pPhraseSink)
{
        // parameter validations
        if (cchTextProcessed <= 0 || cwcSrcPos < 0)
                return FALSE;

        if (pWordSink == NULL)
                return FALSE;

    // allocate new IndexRec
    if (m_prgIndexRec == NULL)
    {
        m_nMaxRec = RECORD_CLUMP_SIZE;
        m_prgIndexRec = (INDEX_REC*)malloc(m_nMaxRec * sizeof(INDEX_REC));
        if (m_prgIndexRec == NULL)
        {
            m_nMaxRec = 0;
            return FALSE;
        }
    }

        m_cchTextProcessed = cchTextProcessed;
        m_cwcSrcPos = cwcSrcPos;
        m_pWordSink = pWordSink;
        m_pPhraseSink = pPhraseSink;

        return TRUE;
}

// CIndexInfo::Uninitialize
//
// initialize all the members of CIndexRec
//
// Parameters:
//  (NONE)
//
// Result:
//  (NONE)
//
// 19MAR01  bhshin  began
void CIndexInfo::Uninitialize()
{
    // free IndexRec
    if (m_prgIndexRec != NULL)
    {
                free(m_prgIndexRec);
                m_prgIndexRec = NULL;
    }

        m_nMaxRec = 0;
        m_nCurrRec = 0;

        m_cchTextProcessed = 0;
        m_cwcSrcPos = 0;
        m_pWordSink = NULL; 
        m_pPhraseSink = NULL;

        m_wzRomaji[0] = L'\0';
        m_cchRomaji = 0;
        m_cchPrefix = 0;
        m_fAddRomaji = FALSE;

        m_nFinalHead = 0;
}


// CIndexInfo::AddIndex
//
// add index term information 
//
// Parameters:
//  pwzIndex    -> (const WCHAR*) index string
//  cchIndex    -> (int) length of index string
//  nFT         -> (int) first position of original input
//      nLT                     -> (int) last position of original input
//  fWeight      -> (float) weight value of index record
//
// Result:
//  (BOOL)
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::AddIndex(const WCHAR *pwzIndex, int cchIndex, float fWeight, int nFT, int nLT)
{
        WCHAR wzIndex[MAX_INDEX_STRING+1];
        int nMaxRec, nNewRec;
        INDEX_REC *prgIndexRec;
        int nLTAdd;

        // parameter validation
        if (pwzIndex == 0 || cchIndex <= 0) 
                return FALSE;

        if (nFT < 0 || nLT < 0 || fWeight < 0)
                return FALSE;

        if ((m_cchRomaji + cchIndex) > MAX_INDEX_STRING)
                return FALSE;
        
        // make sure if there is enough room for new record (maximum 3 records can be added)
        if (m_nMaxRec <= m_nCurrRec + 3)
        {
        nMaxRec = m_nMaxRec + RECORD_CLUMP_SIZE;
        
        prgIndexRec = (INDEX_REC*)realloc(m_prgIndexRec, nMaxRec * sizeof(INDEX_REC));
        if (prgIndexRec == NULL)
            return FALSE;

                m_nMaxRec = nMaxRec;
        m_prgIndexRec = prgIndexRec;
        }

        // set up index string and correct LT value
        wcsncpy(wzIndex, pwzIndex, cchIndex);
        wzIndex[cchIndex] = L'\0';

        nLTAdd = nLT;
        if (nLT >= 0 && m_cchRomaji > 0)
                nLTAdd += m_cchRomaji;

        // if added record is leading one and there is just length one romaji, 
        // then conjoin leading romaji & leading index string, and add merged term
        if (nFT == 0 && m_cchRomaji == 1)
        {
                WCHAR wzMerge[MAX_INDEX_STRING+1];
                int ccMerge = ( sizeof( wzMerge ) / sizeof( wzMerge[0] ) ) - 1;

                int ccRomaji = wcslen( m_wzRomaji );
                int ccIndex = wcslen( wzIndex );

                if ( ( ccRomaji + ccIndex ) >= ccMerge )
                    return FALSE;

                wcscpy(wzMerge, m_wzRomaji);
                wcscat(wzMerge, wzIndex);

                if (!IsExistIndex(wzMerge))
                {
                        // add index term
                        nNewRec = m_nCurrRec;
                        m_nCurrRec++;
                
                        wcscpy(m_prgIndexRec[nNewRec].wzIndex, wzMerge);
                        m_prgIndexRec[nNewRec].cchIndex = cchIndex + m_cchRomaji;
                        m_prgIndexRec[nNewRec].nFT = nFT;
                        m_prgIndexRec[nNewRec].nLT = nLTAdd;
                        m_prgIndexRec[nNewRec].fWeight = fWeight;
                        m_prgIndexRec[nNewRec].nNext = 0;
                
                        WB_LOG_ADD_INDEX(wzMerge, cchIndex + m_cchRomaji, INDEX_SYMBOL);

                        ATLASSERT(m_prgIndexRec[nNewRec].nFT <= m_prgIndexRec[nNewRec].nLT);
                }

                // add index term removing prefix
                if (m_cchPrefix > 0)
                {
                        // add index term
                        if (!IsExistIndex(wzMerge + m_cchPrefix))
                        {
                                nNewRec = m_nCurrRec;
                                m_nCurrRec++;

                                wcscpy(m_prgIndexRec[nNewRec].wzIndex, wzMerge + m_cchPrefix);
                                m_prgIndexRec[nNewRec].cchIndex = cchIndex + m_cchRomaji - m_cchPrefix;
                                m_prgIndexRec[nNewRec].nFT = nFT + m_cchPrefix;
                                m_prgIndexRec[nNewRec].nLT = nLTAdd;
                                m_prgIndexRec[nNewRec].fWeight = fWeight;
                                m_prgIndexRec[nNewRec].nNext = 0;

                                WB_LOG_ADD_INDEX(wzMerge + m_cchPrefix, cchIndex + m_cchRomaji - m_cchPrefix, INDEX_SYMBOL);

                                ATLASSERT(m_prgIndexRec[nNewRec].nFT <= m_prgIndexRec[nNewRec].nLT);
                        }
                }
        }
        else
        {
                if (!IsExistIndex(wzIndex))
                {

                        // add index term
                        nNewRec = m_nCurrRec;
                        m_nCurrRec++;

                        wcscpy(m_prgIndexRec[nNewRec].wzIndex, wzIndex);
                        m_prgIndexRec[nNewRec].cchIndex = cchIndex;
                        m_prgIndexRec[nNewRec].nFT = nFT + m_cchRomaji;
                        m_prgIndexRec[nNewRec].nLT = nLTAdd;
                        m_prgIndexRec[nNewRec].fWeight = fWeight;
                        m_prgIndexRec[nNewRec].nNext = 0;

                        ATLASSERT(m_prgIndexRec[nNewRec].nFT <= m_prgIndexRec[nNewRec].nLT);
                }
                
                // if there is a romaji and it has not added yet, then add it just one time
                if (m_cchRomaji > 1 && m_fAddRomaji == FALSE)
                {
                        if (!IsExistIndex(m_wzRomaji))
                        {
                                // add index term
                                nNewRec = m_nCurrRec;
                                m_nCurrRec++;

                                wcscpy(m_prgIndexRec[nNewRec].wzIndex, m_wzRomaji);
                                m_prgIndexRec[nNewRec].cchIndex = m_cchRomaji;
                                m_prgIndexRec[nNewRec].nFT = 0;
                                m_prgIndexRec[nNewRec].nLT = m_cchRomaji - 1;
                                m_prgIndexRec[nNewRec].fWeight = WEIGHT_HARD_MATCH;
                                m_prgIndexRec[nNewRec].nNext = 0;

                                WB_LOG_ADD_INDEX(m_wzRomaji, m_cchRomaji, INDEX_SYMBOL);

                                ATLASSERT(m_prgIndexRec[nNewRec].nFT <= m_prgIndexRec[nNewRec].nLT);
                        }
                        
                        // if there is a prefix, then add index term removing the prefix
                        if (m_cchPrefix > 0)
                        {
                                if (!IsExistIndex(m_wzRomaji + m_cchPrefix))
                                {
                                        // add index term
                                        nNewRec = m_nCurrRec;
                                        m_nCurrRec++;

                                        wcscpy(m_prgIndexRec[nNewRec].wzIndex, m_wzRomaji + m_cchPrefix);
                                        m_prgIndexRec[nNewRec].cchIndex = m_cchRomaji - m_cchPrefix;
                                        m_prgIndexRec[nNewRec].nFT = m_cchPrefix;
                                        m_prgIndexRec[nNewRec].nLT = m_cchRomaji-m_cchPrefix-1;
                                        m_prgIndexRec[nNewRec].fWeight = WEIGHT_HARD_MATCH;
                                        m_prgIndexRec[nNewRec].nNext = 0;

                                        WB_LOG_ADD_INDEX(m_wzRomaji + m_cchPrefix, m_cchRomaji - m_cchPrefix, INDEX_SYMBOL);

                                        ATLASSERT(m_prgIndexRec[nNewRec].nFT <= m_prgIndexRec[nNewRec].nLT);
                                }
                        }

                        m_fAddRomaji = TRUE;
                }
        }

        return TRUE;
}

// CIndexInfo::FindAndMergeIndexTerm
//
// find index term matching FT, LT
//
// Parameters:
//      pIndexSrc -> (INDEX_REC *) index term to merge 
//      nFT   -> (int) FT position, -1 means don't care
//  nLT   -> (int) LT position, -1 means don't care
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::FindAndMergeIndexTerm(INDEX_REC *pIndexSrc, int nFT, int nLT)
{
        INDEX_REC *pIndexRec;
        WCHAR wchIndex;
        int cchIndex;
        int nFTAdd, nLTAdd;
        int nNewRec;
        WCHAR wzIndex[MAX_INDEX_STRING+1];
        BOOL fFound = FALSE;

        if (pIndexSrc == NULL)
                return FALSE;

        if (nFT < 0 && nLT < 0)
                return FALSE;

        for (int i = MIN_RECORD; i < m_nCurrRec; i++)
        {
                pIndexRec = &m_prgIndexRec[i];

                if (pIndexRec->cchIndex == 0)
                        continue;

                if (nFT != -1 && pIndexRec->nFT != nFT)
                        continue;

                if (nLT != -1 && pIndexRec->nLT != nLT)
                        continue;

                // found it

                // check [,] suffix case, then don't merge and just add itself
                if (pIndexRec->nFT > 0 && pIndexRec->cchIndex == 1)
                {
                        wchIndex = pIndexRec->wzIndex[0];
                        if (wchIndex == 0xB4E4 || wchIndex == 0xBFD0)
                                continue;
                }

                // check buffer size
                cchIndex = wcslen(pIndexRec->wzIndex);
                if (cchIndex == 0 || cchIndex + 1 >= MAX_INDEX_STRING)
                        continue;

                int ccIndexSrc = wcslen( pIndexSrc->wzIndex );

                if ( ( ccIndexSrc + cchIndex ) >= MAX_INDEX_STRING )
                    continue;
                        
                if (pIndexSrc->nFT == 0)
                {
                        wcscpy(wzIndex, pIndexSrc->wzIndex);
                        wcscat(wzIndex, pIndexRec->wzIndex);

                        nFTAdd = pIndexSrc->nFT;
                        nLTAdd = pIndexRec->nLT;
                }
                else
                {
                        wcscpy(wzIndex, pIndexRec->wzIndex);
                        wcscat(wzIndex, pIndexSrc->wzIndex);

                        nFTAdd = pIndexRec->nFT;
                        nLTAdd = pIndexSrc->nLT;
                }

                fFound = TRUE;

                // check it dupliate index exist
                if (!IsExistIndex(wzIndex))
                {
                        WB_LOG_ADD_INDEX(wzIndex, cchIndex+1, INDEX_PARSE);
                                
                        // add merged one
                        nNewRec = m_nCurrRec;
                        m_nCurrRec++;

                        wcscpy(m_prgIndexRec[nNewRec].wzIndex, wzIndex);
                        m_prgIndexRec[nNewRec].cchIndex = cchIndex+1;
                        m_prgIndexRec[nNewRec].nFT = nFTAdd;
                        m_prgIndexRec[nNewRec].nLT = nLTAdd;
                        m_prgIndexRec[nNewRec].fWeight = pIndexSrc->fWeight;
                        m_prgIndexRec[nNewRec].nNext = 0;
                }
        }

        return fFound;
}

// CIndexInfo::MakeSingleLengthMergedIndex
//
// make single length merged index term (MSN search)
//
// Parameters:
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::MakeSingleLengthMergedIndex()
{
        INDEX_REC *pIndexRec;
        int nFT;
        WCHAR wchIndex;
        BOOL fFound;

        if (m_pWordSink == NULL)
                return FALSE;

        WB_LOG_ROOT_INDEX(L"", TRUE); // set root empty

        for (int i = MIN_RECORD; i < m_nCurrRec; i++)
        {
                pIndexRec = &m_prgIndexRec[i];

                if (pIndexRec->cchIndex == 1)
                {
                        WB_LOG_REMOVE_INDEX(pIndexRec->wzIndex);                        

                        nFT = pIndexRec->nFT;

                        wchIndex = pIndexRec->wzIndex[0];
                        
                        // check [,] suffix case, then just remove it
                        if ((wchIndex == 0xB4E4 || wchIndex == 0xBFD0) && nFT > 0)
                        {
                                // make it empty
                                pIndexRec->cchIndex = 0;
                                pIndexRec->wzIndex[0] = L'\0';
                                pIndexRec->nFT = 0;
                                pIndexRec->nLT = 0;
                                pIndexRec->nNext = 0;

                                continue;
                        }
                        
                        // find conjoined term and make merged term and put it
                        fFound = FALSE;
                        
                        if (nFT == 0 && pIndexRec->nLT != -1)
                                fFound = FindAndMergeIndexTerm(pIndexRec, pIndexRec->nLT + 1, -1);
                        else
                                fFound = FindAndMergeIndexTerm(pIndexRec, -1, nFT-1);

                        if (fFound)
                        {
                                // make it empty
                                pIndexRec->cchIndex = 0;
                                pIndexRec->wzIndex[0] = L'\0';
                                pIndexRec->nFT = 0;
                                pIndexRec->nLT = 0;
                                pIndexRec->nNext = 0;

                                continue;
                        }
                }
        }

        return TRUE;
}

// CIndexInfo::InsertFinalIndex
//
// search index term starting with given FT and insert it to final list
//
// Parameters:
//  nFT  -> (int) first pos of index term
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::InsertFinalIndex(int nFT)
{
        INDEX_REC *pIndexRec;
        int cchIndex, nCurr, nPrev;
        BOOL fInsert;

        for (int nRecord = MIN_RECORD; nRecord < m_nCurrRec; nRecord++)
        {
                pIndexRec = &m_prgIndexRec[nRecord];

                cchIndex = pIndexRec->cchIndex;
                if (cchIndex == 0)
                        continue; // skip removed entry

                if (pIndexRec->nFT != nFT)
                        continue; // FT match index found
                
                // search inserting position. final list ordered by increamental length.
                nCurr = m_nFinalHead;
                nPrev = -1;
                fInsert = FALSE;
                while (!fInsert)
                {
                        if (nCurr != 0) 
                        {
                                if (m_prgIndexRec[nCurr].nFT != nFT || cchIndex > m_prgIndexRec[nCurr].cchIndex)
                                {
                                        nPrev = nCurr;
                                        nCurr = m_prgIndexRec[nCurr].nNext;
                                        continue;
                                }
                        }               

                        // insert it
                        if (nPrev == -1)
                        {
                                pIndexRec->nNext = m_nFinalHead;
                                m_nFinalHead = nRecord;
                        }
                        else
                        {
                                pIndexRec->nNext = m_prgIndexRec[nPrev].nNext;
                                m_prgIndexRec[nPrev].nNext = nRecord;
                        }

                        fInsert = TRUE;
                }
        }
        
        return TRUE;
}

// CIndexInfo::PutFinalIndexList
//
// put word final index list (index time)
//
// Parameters:
//  lpcwzSrc -> (LPCWSTR) source string to get source pos
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::PutFinalIndexList(LPCWSTR lpcwzSrc)
{
        int nCurr, nNext;
        int nNextFT;
        WCHAR *pwzFind;
        int cchProcessed, cwcSrcPos;
        INDEX_REC *pIndexRec;

        if (m_pWordSink == NULL)
                return FALSE;

        // fill final index list
        for (int i = 0; i < m_cchTextProcessed; i++)
        {
                InsertFinalIndex(i);    
        }
        
        // put final index list
        nCurr = m_nFinalHead;
        while (nCurr != 0)
        {
                ATLASSERT(nCurr < m_nCurrRec);

                pIndexRec = &m_prgIndexRec[nCurr];

                // skip removed record
                if (pIndexRec->cchIndex == 0)
                        continue; 

                // check if index term has substring or not
                pwzFind = wcsstr(lpcwzSrc, pIndexRec->wzIndex);
                if (pwzFind == NULL)
                        continue;
                        
                cwcSrcPos = m_cwcSrcPos + (int)(pwzFind - lpcwzSrc);
                cchProcessed = m_cchTextProcessed - (int)(pwzFind - lpcwzSrc);

                // get next FT
                nNext = pIndexRec->nNext;
                if (nNext == 0)
                        nNextFT = -1;
                else
                        nNextFT = m_prgIndexRec[nNext].nFT;

                if (pIndexRec->nFT != nNextFT)
                {
                        m_pWordSink->PutWord(pIndexRec->cchIndex, pIndexRec->wzIndex, 
                                                                 pIndexRec->cchIndex, cwcSrcPos);
                }
                else
                {
                        m_pWordSink->PutAltWord(pIndexRec->cchIndex, pIndexRec->wzIndex, 
                                                                    pIndexRec->cchIndex, cwcSrcPos);
                }

                nCurr = pIndexRec->nNext;
        }
        
        return TRUE;
}


// CIndexInfo::MakeSeqIndexList
//
// make final sequence index list
//
// Parameters:
//      nFT        -> (int) matching FT pos
//      plistFinal    -> (CRecList*) previous sequence list
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 20MAR01  bhshin  began
BOOL CIndexInfo::MakeSeqIndexList(int nFT/*=0*/, CRecList *plistFinal/*=NULL*/)
{
        int nRecord;
        INDEX_REC *pIndexRec;
        BOOL fFound = FALSE;

        for (nRecord = MIN_RECORD; nRecord < m_nCurrRec; nRecord++)
        {
                CRecList listTemp;

                pIndexRec = &m_prgIndexRec[nRecord];

                // skip removed entry & skip not FT matching entry
                if (pIndexRec->cchIndex != 0 && pIndexRec->nFT == nFT)
                {
                        fFound = TRUE;

                        try
                        {
                                if (pIndexRec->nLT >= m_cchTextProcessed-1)
                                {
                                        if (plistFinal == NULL)
                                        {
                                                m_FinalRecList.AddRec(nRecord);
                                        }
                                        else
                                        {
                                                listTemp = *plistFinal;

                                                if (!listTemp.AddRec(nRecord))
                                                        return FALSE;

                                                m_FinalRecList += listTemp;
                                        }
                                }
                                else
                                {
                                        if (plistFinal == NULL)
                                        {
                                                if (!listTemp.Initialize())
                                                        return FALSE;
                                        }
                                        else
                                        {
                                                listTemp = *plistFinal;
                                        }

                                        if (!listTemp.AddRec(nRecord))
                                                return FALSE;

                                        if (!MakeSeqIndexList(pIndexRec->nLT + 1, &listTemp))
                                                return FALSE;
                                }
                        }
                        catch (...)
                        {
                                return FALSE;
                        }
                }
        }

        if (!fFound && plistFinal != NULL)
        {
                try
                {
                        m_FinalRecList += *plistFinal;
                }
                catch(...)
                {
                        return FALSE;
                }
        }

        return TRUE;
}


// CIndexInfo::PutQueryIndexList
//
// call IWordSink::PutWord with collected index terms for Query time
//
// Parameters:
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 20MAR01  bhshin  began
BOOL CIndexInfo::PutQueryIndexList()
{
        int nRecordID;
        INDEX_REC *pIndexRec;
        WCHAR *pwzIndex;
        int cchIndex;
        WCHAR wzIndex[MAX_INDEX_STRING+1];
        
        if (m_pWordSink == NULL)
                return FALSE;

        if (!m_FinalRecList.Initialize())
                return FALSE;

        if (!MakeSeqIndexList())
                return FALSE;
        
        // put query index terms
        for (int i = MIN_RECORD; i < m_FinalRecList.m_nCurrRec; i++)
        {
                nRecordID = m_FinalRecList.m_prgnRecID[i];

                if (nRecordID < MIN_RECORD || nRecordID >= m_nCurrRec)
                        return FALSE; // invalid record id

                pIndexRec = &m_prgIndexRec[nRecordID];

                if (pIndexRec->nFT == 0 && m_nCurrRec > MIN_RECORD+1)
                        m_pWordSink->StartAltPhrase();

                cchIndex = 0;
                pwzIndex = pIndexRec->wzIndex;
                while (*pwzIndex != L'\0')
                {
                        if (*pwzIndex == L'\t')
                        {
                                if (cchIndex > 0)
                                {
                                        wzIndex[cchIndex] = L'\0';
                                        m_pWordSink->PutWord(cchIndex, wzIndex, 
                                                                                 m_cchTextProcessed, m_cwcSrcPos);

                                        cchIndex = 0;
                                }
                        }
                        else
                        {
                                wzIndex[cchIndex++] = *pwzIndex;
                        }

                        pwzIndex++;
                }
                        
                if (cchIndex > 0)
                {
                        wzIndex[cchIndex] = L'\0';
                        m_pWordSink->PutWord(cchIndex, wzIndex, 
                                                                 m_cchTextProcessed, m_cwcSrcPos);
                }
        }

        if (m_nCurrRec > MIN_RECORD+1)
                m_pWordSink->EndAltPhrase();

        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\cierror.h ===
#ifndef _CIERROR_H_
#define _CIERROR_H_
#ifndef FACILITY_WINDOWS
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 0x8
#define FACILITY_NULL                    0x0
#define FACILITY_ITF                     0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COFAIL           0x3
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: NOT_AN_ERROR1
//
// MessageText:
//
//  NOTE:  This dummy error message is necessary to force MC to output
//         the above defines inside the FACILITY_WINDOWS guard instead
//         of leaving it empty.
//
#define NOT_AN_ERROR1                    ((HRESULT)0x00081600L)

#endif // FACILITY_WINDOWS
//
// Range 0x1600-0x1850 is reserved by Content Index.
//
//
// Codes 0x1600-0x164f are reserved for QUERY
//
//
// MessageId: QUERY_E_FAILED
//
// MessageText:
//
//  Call failed for unknown reason.
//
#define QUERY_E_FAILED                   ((HRESULT)0x80041600L)

//
// MessageId: QUERY_E_INVALIDQUERY
//
// MessageText:
//
//  Invalid parameter.
//
#define QUERY_E_INVALIDQUERY             ((HRESULT)0x80041601L)

//
// MessageId: QUERY_E_INVALIDRESTRICTION
//
// MessageText:
//
//  The query restriction could not be parsed.
//
#define QUERY_E_INVALIDRESTRICTION       ((HRESULT)0x80041602L)

//
// MessageId: QUERY_E_INVALIDSORT
//
// MessageText:
//
//  An invalid sort order was requested.
//
#define QUERY_E_INVALIDSORT              ((HRESULT)0x80041603L)

//
// MessageId: QUERY_E_INVALIDCATEGORIZE
//
// MessageText:
//
//  An invalid categorization order was requested.
//
#define QUERY_E_INVALIDCATEGORIZE        ((HRESULT)0x80041604L)

//
// MessageId: QUERY_E_ALLNOISE
//
// MessageText:
//
//  The query contained only ignored words.
//
#define QUERY_E_ALLNOISE                 ((HRESULT)0x80041605L)

//
// MessageId: QUERY_E_TOOCOMPLEX
//
// MessageText:
//
//  The query was too complex to be executed.
//
#define QUERY_E_TOOCOMPLEX               ((HRESULT)0x80041606L)

//
// MessageId: QUERY_E_TIMEDOUT
//
// MessageText:
//
//  The query exceeded its execution time limit.
//
#define QUERY_E_TIMEDOUT                 ((HRESULT)0x80041607L)

//
// MessageId: QUERY_E_DUPLICATE_OUTPUT_COLUMN
//
// MessageText:
//
//  One or more columns in the output column list is a duplicate.
//
#define QUERY_E_DUPLICATE_OUTPUT_COLUMN  ((HRESULT)0x80041608L)

//
// MessageId: QUERY_E_INVALID_OUTPUT_COLUMN
//
// MessageText:
//
//  One or more columns in the output column list is not valid.
//
#define QUERY_E_INVALID_OUTPUT_COLUMN    ((HRESULT)0x80041609L)

//
// MessageId: QUERY_E_INVALID_DIRECTORY
//
// MessageText:
//
//  Invalid directory name.
//
#define QUERY_E_INVALID_DIRECTORY        ((HRESULT)0x8004160AL)

//
// MessageId: QUERY_E_DIR_ON_REMOVABLE_DRIVE
//
// MessageText:
//
//  Specified directory is on a removable medium.
//
#define QUERY_E_DIR_ON_REMOVABLE_DRIVE   ((HRESULT)0x8004160BL)

//
// MessageId: QUERY_S_NO_QUERY
//
// MessageText:
//
//  The catalog is in a state where indexing continues, but queries are not allowed.
//
#define QUERY_S_NO_QUERY                 ((HRESULT)0x8004160CL)

//
// Codes 0x1650-0x167f are reserved for qutil error codes
//
//
// MessageId: QPLIST_E_CANT_OPEN_FILE
//
// MessageText:
//
//  Can not open file.
//
#define QPLIST_E_CANT_OPEN_FILE          ((HRESULT)0x80041651L)

//
// MessageId: QPLIST_E_READ_ERROR
//
// MessageText:
//
//  Read error in file.
//
#define QPLIST_E_READ_ERROR              ((HRESULT)0x80041652L)

//
// MessageId: QPLIST_E_EXPECTING_NAME
//
// MessageText:
//
//  Expecting property name.
//
#define QPLIST_E_EXPECTING_NAME          ((HRESULT)0x80041653L)

//
// MessageId: QPLIST_E_EXPECTING_TYPE
//
// MessageText:
//
//  Expecting type specifier.
//
#define QPLIST_E_EXPECTING_TYPE          ((HRESULT)0x80041654L)

//
// MessageId: QPLIST_E_UNRECOGNIZED_TYPE
//
// MessageText:
//
//  Unrecognized type.
//
#define QPLIST_E_UNRECOGNIZED_TYPE       ((HRESULT)0x80041655L)

//
// MessageId: QPLIST_E_EXPECTING_INTEGER
//
// MessageText:
//
//  Expecting integer.
//
#define QPLIST_E_EXPECTING_INTEGER       ((HRESULT)0x80041656L)

//
// MessageId: QPLIST_E_EXPECTING_CLOSE_PAREN
//
// MessageText:
//
//  Expecting closing parenthesis.
//
#define QPLIST_E_EXPECTING_CLOSE_PAREN   ((HRESULT)0x80041657L)

//
// MessageId: QPLIST_E_EXPECTING_GUID
//
// MessageText:
//
//  Expecting GUID.
//
#define QPLIST_E_EXPECTING_GUID          ((HRESULT)0x80041658L)

//
// MessageId: QPLIST_E_BAD_GUID
//
// MessageText:
//
//  Invalid guid.
//
#define QPLIST_E_BAD_GUID                ((HRESULT)0x80041659L)

//
// MessageId: QPLIST_E_EXPECTING_PROP_SPEC
//
// MessageText:
//
//  Expecting property specifier.
//
#define QPLIST_E_EXPECTING_PROP_SPEC     ((HRESULT)0x8004165AL)

//
// MessageId: QPLIST_E_CANT_SET_PROPERTY
//
// MessageText:
//
//  Failed to set property name.
//
#define QPLIST_E_CANT_SET_PROPERTY       ((HRESULT)0x8004165BL)

//
// MessageId: QPLIST_E_DUPLICATE
//
// MessageText:
//
//  Duplicate property name.
//
#define QPLIST_E_DUPLICATE               ((HRESULT)0x8004165CL)

//
// MessageId: QPLIST_E_VECTORBYREF_USED_ALONE
//
// MessageText:
//
//  DBTYPE_VECTOR or DBTYPE_BYREF used alone.
//
#define QPLIST_E_VECTORBYREF_USED_ALONE  ((HRESULT)0x8004165DL)

//
// MessageId: QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE
//
// MessageText:
//
//  DBTYPE_BYREF must be used with DBTYPE_STR, DBTYPE_WSTR, DBTYPE_GUID
//   or DBTYPE_UI1 types.
//
#define QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE ((HRESULT)0x8004165EL)

//
// MessageId: QPARSE_E_UNEXPECTED_NOT
//
// MessageText:
//
//  Unexpected NOT operator.
//
#define QPARSE_E_UNEXPECTED_NOT          ((HRESULT)0x80041660L)

//
// MessageId: QPARSE_E_EXPECTING_INTEGER
//
// MessageText:
//
//  Expecting integer.
//
#define QPARSE_E_EXPECTING_INTEGER       ((HRESULT)0x80041661L)

//
// MessageId: QPARSE_E_EXPECTING_REAL
//
// MessageText:
//
//  Expecting real number.
//
#define QPARSE_E_EXPECTING_REAL          ((HRESULT)0x80041662L)

//
// MessageId: QPARSE_E_EXPECTING_DATE
//
// MessageText:
//
//  Expecting date.
//
#define QPARSE_E_EXPECTING_DATE          ((HRESULT)0x80041663L)

//
// MessageId: QPARSE_E_EXPECTING_CURRENCY
//
// MessageText:
//
//  Expecting currency.
//
#define QPARSE_E_EXPECTING_CURRENCY      ((HRESULT)0x80041664L)

//
// MessageId: QPARSE_E_EXPECTING_GUID
//
// MessageText:
//
//  Expecting GUID.
//
#define QPARSE_E_EXPECTING_GUID          ((HRESULT)0x80041665L)

//
// MessageId: QPARSE_E_EXPECTING_BRACE
//
// MessageText:
//
//  Expecting closing square bracket ']'.
//
#define QPARSE_E_EXPECTING_BRACE         ((HRESULT)0x80041666L)

//
// MessageId: QPARSE_E_EXPECTING_PAREN
//
// MessageText:
//
//  Expecting closing parenthesis ')'.
//
#define QPARSE_E_EXPECTING_PAREN         ((HRESULT)0x80041667L)

//
// MessageId: QPARSE_E_EXPECTING_PROPERTY
//
// MessageText:
//
//  Expecting property name.
//
#define QPARSE_E_EXPECTING_PROPERTY      ((HRESULT)0x80041668L)

//
// MessageId: QPARSE_E_NOT_YET_IMPLEMENTED
//
// MessageText:
//
//  Not yet implemented.
//
#define QPARSE_E_NOT_YET_IMPLEMENTED     ((HRESULT)0x80041669L)

//
// MessageId: QPARSE_E_EXPECTING_PHRASE
//
// MessageText:
//
//  Expecting phrase.
//
#define QPARSE_E_EXPECTING_PHRASE        ((HRESULT)0x8004166AL)

//
// MessageId: QPARSE_E_UNSUPPORTED_PROPERTY_TYPE
//
// MessageText:
//
//  Unsupported property type.
//
#define QPARSE_E_UNSUPPORTED_PROPERTY_TYPE ((HRESULT)0x8004166BL)

//
// MessageId: QPARSE_E_EXPECTING_REGEX
//
// MessageText:
//
//  Expecting regular expression.
//
#define QPARSE_E_EXPECTING_REGEX         ((HRESULT)0x8004166CL)

//
// MessageId: QPARSE_E_EXPECTING_REGEX_PROPERTY
//
// MessageText:
//
//  Regular expressions require a property of type string.
//
#define QPARSE_E_EXPECTING_REGEX_PROPERTY ((HRESULT)0x8004166DL)

//
// MessageId: QPARSE_E_INVALID_LITERAL
//
// MessageText:
//
//  Invalid literal.
//
#define QPARSE_E_INVALID_LITERAL         ((HRESULT)0x8004166EL)

//
// MessageId: QPARSE_E_NO_SUCH_PROPERTY
//
// MessageText:
//
//  No such property.
//
#define QPARSE_E_NO_SUCH_PROPERTY        ((HRESULT)0x8004166FL)

//
// MessageId: QPARSE_E_EXPECTING_EOS
//
// MessageText:
//
//  Expecting end of string.
//
#define QPARSE_E_EXPECTING_EOS           ((HRESULT)0x80041670L)

//
// MessageId: QPARSE_E_EXPECTING_COMMA
//
// MessageText:
//
//  Expecting comma.
//
#define QPARSE_E_EXPECTING_COMMA         ((HRESULT)0x80041671L)

//
// MessageId: QPARSE_E_UNEXPECTED_EOS
//
// MessageText:
//
//  Unexpected end of string.
//
#define QPARSE_E_UNEXPECTED_EOS          ((HRESULT)0x80041672L)

//
// MessageId: QPARSE_E_WEIGHT_OUT_OF_RANGE
//
// MessageText:
//
//  Weight must be between 0 and 1000 in short form queries and between 0.0 and 1.0 in long form queries.
//
#define QPARSE_E_WEIGHT_OUT_OF_RANGE     ((HRESULT)0x80041673L)

//
// MessageId: QPARSE_E_NO_SUCH_SORT_PROPERTY
//
// MessageText:
//
//  An invalid property was found in the sort specification.
//
#define QPARSE_E_NO_SUCH_SORT_PROPERTY   ((HRESULT)0x80041674L)

//
// MessageId: QPARSE_E_INVALID_SORT_ORDER
//
// MessageText:
//
//  An invalid sort order was specified.  Only [a] and [d] are supported.
//
#define QPARSE_E_INVALID_SORT_ORDER      ((HRESULT)0x80041675L)

//
// MessageId: QUTIL_E_CANT_CONVERT_VROOT
//
// MessageText:
//
//  Couldn't convert a virtual path to a physical path.
//
#define QUTIL_E_CANT_CONVERT_VROOT       ((HRESULT)0x80041676L)

//
// MessageId: QPARSE_E_INVALID_GROUPING
//
// MessageText:
//
//  An unsupported grouping type was specified.
//
#define QPARSE_E_INVALID_GROUPING        ((HRESULT)0x80041677L)

//
// MessageId: QUTIL_E_INVALID_CODEPAGE
//
// MessageText:
//
//  Invalid CiCodepage was specified.
//
#define QUTIL_E_INVALID_CODEPAGE         ((HRESULT)0xC0041678L)

//
// MessageId: QPLIST_S_DUPLICATE
//
// MessageText:
//
//  Exact duplicate property defined.
//
#define QPLIST_S_DUPLICATE               ((HRESULT)0x00041679L)

//
// MessageId: QPARSE_E_INVALID_QUERY
//
// MessageText:
//
//  Invalid query.
//
#define QPARSE_E_INVALID_QUERY           ((HRESULT)0x8004167AL)

//
// MessageId: QPARSE_E_INVALID_RANKMETHOD
//
// MessageText:
//
//  Invalid rank method.
//
#define QPARSE_E_INVALID_RANKMETHOD      ((HRESULT)0x8004167BL)

//
// 0x1680 - 0x169F are Filter daemon error codes
//
//
// MessageId: FDAEMON_W_WORDLISTFULL
//
// MessageText:
//
//  Wordlist has reached maximum size.  Additional documents should not be filtered.
//
#define FDAEMON_W_WORDLISTFULL           ((HRESULT)0x00041680L)

//
// MessageId: FDAEMON_E_LOWRESOURCE
//
// MessageText:
//
//  The system is running out of one of more resources needed for filtering, usually memory.
//
#define FDAEMON_E_LOWRESOURCE            ((HRESULT)0x80041681L)

//
// MessageId: FDAEMON_E_FATALERROR
//
// MessageText:
//
//  A critical error occurred during document filtering.  Consult system administrator.
//
#define FDAEMON_E_FATALERROR             ((HRESULT)0x80041682L)

//
// MessageId: FDAEMON_E_PARTITIONDELETED
//
// MessageText:
//
//  Documents not stored in content index because partition has been deleted.
//
#define FDAEMON_E_PARTITIONDELETED       ((HRESULT)0x80041683L)

//
// MessageId: FDAEMON_E_CHANGEUPDATEFAILED
//
// MessageText:
//
//  Documents not stored in content index because update of changelist failed.
//
#define FDAEMON_E_CHANGEUPDATEFAILED     ((HRESULT)0x80041684L)

//
// MessageId: FDAEMON_W_EMPTYWORDLIST
//
// MessageText:
//
//  Final wordlist was empty.
//
#define FDAEMON_W_EMPTYWORDLIST          ((HRESULT)0x00041685L)

//
// MessageId: FDAEMON_E_WORDLISTCOMMITFAILED
//
// MessageText:
//
//  Commit of wordlist failed.  Data not available for query.
//
#define FDAEMON_E_WORDLISTCOMMITFAILED   ((HRESULT)0x80041686L)

//
// MessageId: FDAEMON_E_NOWORDLIST
//
// MessageText:
//
//  No wordlist is being constructed.  May happen after fatal filter error.
//
#define FDAEMON_E_NOWORDLIST             ((HRESULT)0x80041687L)

//
// MessageId: FDAEMON_E_TOOMANYFILTEREDBLOCKS
//
// MessageText:
//
//  During document filtering the limit on buffers has been exceeded.
//
#define FDAEMON_E_TOOMANYFILTEREDBLOCKS  ((HRESULT)0x80041688L)

//
// ISearch error codes
//
//
// MessageId: SEARCH_S_NOMOREHITS
//
// MessageText:
//
//  End of hits has been reached.
//
#define SEARCH_S_NOMOREHITS              ((HRESULT)0x000416A0L)

//
// MessageId: SEARCH_E_NOMONIKER
//
// MessageText:
//
//  Retrival of hits as monikers is not supported (by filter passed into Init).
//
#define SEARCH_E_NOMONIKER               ((HRESULT)0x800416A1L)

//
// MessageId: SEARCH_E_NOREGION
//
// MessageText:
//
//  Retrival of hits as filter regions is not supported (by filter passed into Init).
//
#define SEARCH_E_NOREGION                ((HRESULT)0x800416A2L)

//
// Filter error codes
//
//
// MessageId: FILTER_E_TOO_BIG
//
// MessageText:
//
//  File is too large to filter.
//
#define FILTER_E_TOO_BIG                 ((HRESULT)0x80041730L)

//
// MessageId: FILTER_S_PARTIAL_CONTENTSCAN_IMMEDIATE
//
// MessageText:
//
//  A partial content scan of the disk needs to be scheduled for immediate execution.
//
#define FILTER_S_PARTIAL_CONTENTSCAN_IMMEDIATE ((HRESULT)0x00041731L)

//
// MessageId: FILTER_S_FULL_CONTENTSCAN_IMMEDIATE
//
// MessageText:
//
//  A full content scan of the disk needs to be scheduled for immediate execution.
//
#define FILTER_S_FULL_CONTENTSCAN_IMMEDIATE ((HRESULT)0x00041732L)

//
// MessageId: FILTER_S_CONTENTSCAN_DELAYED
//
// MessageText:
//
//  A content scan of the disk needs to be scheduled for execution later.
//
#define FILTER_S_CONTENTSCAN_DELAYED     ((HRESULT)0x00041733L)

//
// MessageId: FILTER_E_CONTENTINDEXCORRUPT
//
// MessageText:
//
//  The content index is corrupt. A content scan will to be scheduled after chkdsk or autochk is run.
//
#define FILTER_E_CONTENTINDEXCORRUPT     ((HRESULT)0xC0041734L)

//
// MessageId: FILTER_S_DISK_FULL
//
// MessageText:
//
//  The disk is getting full.
//
#define FILTER_S_DISK_FULL               ((HRESULT)0x00041735L)

//
// MessageId: FILTER_E_ALREADY_OPEN
//
// MessageText:
//
//  A file is already open. Cannot open another one while a file is open.
//
#define FILTER_E_ALREADY_OPEN            ((HRESULT)0x80041736L)

//
// MessageId: FILTER_E_UNREACHABLE
//
// MessageText:
//
//  The file is not reachable.
//
#define FILTER_E_UNREACHABLE             ((HRESULT)0x80041737L)

//
// MessageId: FILTER_E_IN_USE
//
// MessageText:
//
//  The document is in use by another process.
//
#define FILTER_E_IN_USE                  ((HRESULT)0x80041738L)

//
// MessageId: FILTER_E_NOT_OPEN
//
// MessageText:
//
//  The document is not opened.
//
#define FILTER_E_NOT_OPEN                ((HRESULT)0x80041739L)

//
// MessageId: FILTER_S_NO_PROPSETS
//
// MessageText:
//
//  The document has no property sets.
//
#define FILTER_S_NO_PROPSETS             ((HRESULT)0x0004173AL)

//
// MessageId: FILTER_E_NO_SUCH_PROPERTY
//
// MessageText:
//
//  There is no property with the given GUID.
//
#define FILTER_E_NO_SUCH_PROPERTY        ((HRESULT)0x8004173BL)

//
// MessageId: FILTER_S_NO_SECURITY_DESCRIPTOR
//
// MessageText:
//
//  The document has no security descriptor.
//
#define FILTER_S_NO_SECURITY_DESCRIPTOR  ((HRESULT)0x0004173CL)

//
// MessageId: FILTER_E_OFFLINE
//
// MessageText:
//
//  The document is offline.
//
#define FILTER_E_OFFLINE                 ((HRESULT)0x8004173DL)

//
// MessageId: FILTER_E_PARTIALLY_FILTERED
//
// MessageText:
//
//  The document was too large to filter in its entirety.  Portions of the document were not emitted.
//
#define FILTER_E_PARTIALLY_FILTERED      ((HRESULT)0x8004173EL)

//
// Word breaker error codes
//
//
// MessageId: WBREAK_E_END_OF_TEXT
//
// MessageText:
//
//  End of text reached in text source.
//
#define WBREAK_E_END_OF_TEXT             ((HRESULT)0x80041780L)

//
// MessageId: LANGUAGE_S_LARGE_WORD
//
// MessageText:
//
//  Word larger than maximum length.  May be truncated by word sink.
//
#define LANGUAGE_S_LARGE_WORD            ((HRESULT)0x00041781L)

//
// MessageId: WBREAK_E_QUERY_ONLY
//
// MessageText:
//
//  Feature only available in query mode.
//
#define WBREAK_E_QUERY_ONLY              ((HRESULT)0x80041782L)

//
// MessageId: WBREAK_E_BUFFER_TOO_SMALL
//
// MessageText:
//
//  Buffer too small to hold composed phrase.
//
#define WBREAK_E_BUFFER_TOO_SMALL        ((HRESULT)0x80041783L)

//
// MessageId: LANGUAGE_E_DATABASE_NOT_FOUND
//
// MessageText:
//
//  Langauge database/cache file could not be found.
//
#define LANGUAGE_E_DATABASE_NOT_FOUND    ((HRESULT)0x80041784L)

//
// MessageId: WBREAK_E_INIT_FAILED
//
// MessageText:
//
//  Initialization of word breaker failed.
//
#define WBREAK_E_INIT_FAILED             ((HRESULT)0x80041785L)

//
// MessageId: PSINK_E_QUERY_ONLY
//
// MessageText:
//
//  Feature only available in query mode.
//
#define PSINK_E_QUERY_ONLY               ((HRESULT)0x80041790L)

//
// MessageId: PSINK_E_INDEX_ONLY
//
// MessageText:
//
//  Feature only available in index mode.
//
#define PSINK_E_INDEX_ONLY               ((HRESULT)0x80041791L)

//
// MessageId: PSINK_E_LARGE_ATTACHMENT
//
// MessageText:
//
//  Attachment type beyond valid range.
//
#define PSINK_E_LARGE_ATTACHMENT         ((HRESULT)0x80041792L)

//
// MessageId: PSINK_S_LARGE_WORD
//
// MessageText:
//
//  Word larger than maximum length.  May be truncated by phrase sink.
//
#define PSINK_S_LARGE_WORD               ((HRESULT)0x00041793L)

//
// Content Index Framework Error Codes
//
//
// MessageId: CI_CORRUPT_DATABASE
//
// MessageText:
//
//  The content index is corrupt.
//
#define CI_CORRUPT_DATABASE              ((HRESULT)0xC0041800L)

//
// MessageId: CI_CORRUPT_CATALOG
//
// MessageText:
//
//  The content index meta data is corrupt.
//
#define CI_CORRUPT_CATALOG               ((HRESULT)0xC0041801L)

//
// MessageId: CI_INVALID_PARTITION
//
// MessageText:
//
//  The content index partition is invalid.
//
#define CI_INVALID_PARTITION             ((HRESULT)0xC0041802L)

//
// MessageId: CI_INVALID_PRIORITY
//
// MessageText:
//
//  The priority is invalid.
//
#define CI_INVALID_PRIORITY              ((HRESULT)0xC0041803L)

//
// MessageId: CI_NO_STARTING_KEY
//
// MessageText:
//
//  There is no starting key.
//
#define CI_NO_STARTING_KEY               ((HRESULT)0xC0041804L)

//
// MessageId: CI_OUT_OF_INDEX_IDS
//
// MessageText:
//
//  The content index is out of index ids.
//
#define CI_OUT_OF_INDEX_IDS              ((HRESULT)0xC0041805L)

//
// MessageId: CI_NO_CATALOG
//
// MessageText:
//
//  There is no catalog.
//
#define CI_NO_CATALOG                    ((HRESULT)0xC0041806L)

//
// MessageId: CI_CORRUPT_FILTER_BUFFER
//
// MessageText:
//
//  The filter buffer is corrupt.
//
#define CI_CORRUPT_FILTER_BUFFER         ((HRESULT)0xC0041807L)

//
// MessageId: CI_INVALID_INDEX
//
// MessageText:
//
//  The index is invalid.
//
#define CI_INVALID_INDEX                 ((HRESULT)0xC0041808L)

//
// MessageId: CI_PROPSTORE_INCONSISTENCY
//
// MessageText:
//
//  Inconsistency in property store detected.
//
#define CI_PROPSTORE_INCONSISTENCY       ((HRESULT)0xC0041809L)

//
// MessageId: CI_E_ALREADY_INITIALIZED
//
// MessageText:
//
//  The object is already initialzed.
//
#define CI_E_ALREADY_INITIALIZED         ((HRESULT)0x8004180AL)

//
// MessageId: CI_E_NOT_INITIALIZED
//
// MessageText:
//
//  The object is not initialzed.
//
#define CI_E_NOT_INITIALIZED             ((HRESULT)0x8004180BL)

//
// MessageId: CI_E_BUFFERTOOSMALL
//
// MessageText:
//
//  The buffer is too small.
//
#define CI_E_BUFFERTOOSMALL              ((HRESULT)0x8004180CL)

//
// MessageId: CI_E_PROPERTY_NOT_CACHED
//
// MessageText:
//
//  The given property is not cached.
//
#define CI_E_PROPERTY_NOT_CACHED         ((HRESULT)0x8004180DL)

//
// MessageId: CI_S_WORKID_DELETED
//
// MessageText:
//
//  The workid is deleted.
//
#define CI_S_WORKID_DELETED              ((HRESULT)0x0004180EL)

//
// MessageId: CI_E_INVALID_STATE
//
// MessageText:
//
//  The object is not in a valid state.
//
#define CI_E_INVALID_STATE               ((HRESULT)0x8004180FL)

//
// MessageId: CI_E_FILTERING_DISABLED
//
// MessageText:
//
//  Filtering is disabled in this content index.
//
#define CI_E_FILTERING_DISABLED          ((HRESULT)0x80041810L)

//
// MessageId: CI_E_DISK_FULL
//
// MessageText:
//
//  The disk is full and the specified operation cannot be done.
//
#define CI_E_DISK_FULL                   ((HRESULT)0x80041811L)

//
// MessageId: CI_E_SHUTDOWN
//
// MessageText:
//
//  Content Index has been shutdown.
//
#define CI_E_SHUTDOWN                    ((HRESULT)0x80041812L)

//
// MessageId: CI_E_WORKID_NOTVALID
//
// MessageText:
//
//  The workid is not valid.
//
#define CI_E_WORKID_NOTVALID             ((HRESULT)0x80041813L)

//
// MessageId: CI_S_END_OF_ENUMERATION
//
// MessageText:
//
//  There are no more documents to enumerate.
//
#define CI_S_END_OF_ENUMERATION          ((HRESULT)0x00041814L)    

//
// MessageId: CI_E_NOT_FOUND
//
// MessageText:
//
//  The object was not found.
//
#define CI_E_NOT_FOUND                   ((HRESULT)0x80041815L)

//
// MessageId: CI_E_USE_DEFAULT_PID
//
// MessageText:
//
//  The passed-in property id is not supported.
//
#define CI_E_USE_DEFAULT_PID             ((HRESULT)0x80041816L)

//
// MessageId: CI_E_DUPLICATE_NOTIFICATION
//
// MessageText:
//
//  There were two notifications for the same workid.
//
#define CI_E_DUPLICATE_NOTIFICATION      ((HRESULT)0x80041817L)

//
// MessageId: CI_E_UPDATES_DISABLED
//
// MessageText:
//
//  A document update was rejected because updates were disabled.
//
#define CI_E_UPDATES_DISABLED            ((HRESULT)0x80041818L)

//
// MessageId: CI_E_INVALID_FLAGS_COMBINATION
//
// MessageText:
//
//  The combination of flags specified is invalid.
//
#define CI_E_INVALID_FLAGS_COMBINATION   ((HRESULT)0x80041819L)

//
// MessageId: CI_E_OUTOFSEQ_INCREMENT_DATA
//
// MessageText:
//
//  The incremental data given to Load is not valid. It may be out of sequence.
//
#define CI_E_OUTOFSEQ_INCREMENT_DATA     ((HRESULT)0x8004181AL)

//
// MessageId: CI_E_SHARING_VIOLATION
//
// MessageText:
//
//  A sharing or locking violation caused a failure.
//
#define CI_E_SHARING_VIOLATION           ((HRESULT)0x8004181BL)

//
// MessageId: CI_E_LOGON_FAILURE
//
// MessageText:
//
//  A logon permission violation caused a failure.
//
#define CI_E_LOGON_FAILURE               ((HRESULT)0x8004181CL)

//
// MessageId: CI_E_NO_CATALOG
//
// MessageText:
//
//  There is no catalog.
//
#define CI_E_NO_CATALOG                  ((HRESULT)0x8004181DL)

//
// MessageId: CI_E_STRANGE_PAGEORSECTOR_SIZE
//
// MessageText:
//
//  Page size is not an integral multiple of the sector size of the volume where index is located.
//
#define CI_E_STRANGE_PAGEORSECTOR_SIZE   ((HRESULT)0x8004181EL)

//
// MessageId: CI_E_TIMEOUT
//
// MessageText:
//
//  Service is too busy.
//
#define CI_E_TIMEOUT                     ((HRESULT)0x8004181FL)

//
// MessageId: CI_E_NOT_RUNNING
//
// MessageText:
//
//  Service is not running.
//
#define CI_E_NOT_RUNNING                 ((HRESULT)0x80041820L)

//
// MessageId: CI_INCORRECT_VERSION
//
// MessageText:
//
//  The content index data on disk is for the wrong version.
//
#define CI_INCORRECT_VERSION             ((HRESULT)0xC0041821L)

//
// MessageId: CI_E_ENUMERATION_STARTED
//
// MessageText:
//
//  Enumeration has already been started for this query.
//
#define CI_E_ENUMERATION_STARTED         ((HRESULT)0xC0041822L)

//
// MessageId: CI_E_PROPERTY_TOOLARGE
//
// MessageText:
//
//  The specified variable length property is too large for the property cache.
//
#define CI_E_PROPERTY_TOOLARGE           ((HRESULT)0xC0041823L)

//
// MessageId: CI_E_CLIENT_FILTER_ABORT
//
// MessageText:
//
//  Filtering of object was aborted by client.
//
#define CI_E_CLIENT_FILTER_ABORT         ((HRESULT)0xC0041824L)

//
// MessageId: CI_S_NO_DOCSTORE
//
// MessageText:
//
//  For administrative connections from client without association to a docstore.
//
#define CI_S_NO_DOCSTORE                 ((HRESULT)0x00041825L)

//
// MessageId: CI_S_CAT_STOPPED
//
// MessageText:
//
//  The catalog has been stopped.
//
#define CI_S_CAT_STOPPED                 ((HRESULT)0x00041826L)

//
// MessageId: CI_E_CARDINALITY_MISMATCH
//
// MessageText:
//
//  Mismatch in cardinality of machine(s)/catalog(s)/scope(s).
//
#define CI_E_CARDINALITY_MISMATCH        ((HRESULT)0x80041827L)

//
// MessageId: CI_E_CONFIG_DISK_FULL
//
// MessageText:
//
//  The disk has reached its configured space limit.
//
#define CI_E_CONFIG_DISK_FULL            ((HRESULT)0x80041828L)

#endif // _CIERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\ctplus.c ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999.
//
//  File:       ctplus.c
//
//  Contents:   Contains character type (orthography) data and routine
//                    to get at it.
//
//  History:    23-May-96   pathal      Created.
//              28-Aug-97   weibz       Add Hanguel char support
//				02-Aug-00   bhshin		changed type from CH to WS (right single quote, _)
//
//---------------------------------------------------------------------------


#include <windows.h>
#include "ctplus.h"


//----------------------------------------------------------------------------
//  s_abBreakList
//
//  This array starts at -1, so that EOF can be found in the array.  It
//  depends on (EOF == -1) being true.  Also, all references to it must be
//  of the form (s_abCharTypeList+1)[x]
//
//  000
//  EOF
//
//  001-080
//  The lower 7F entries from the ASCII Code Page (0000-00ff) are mapped in place
//  (ex. UNICODE 0009 (HT) == 009)
//      The word characters are: $,0-9,A-Z,_,a-z
//      The word separators are: bs,tab,lf,vtab,cr,spc,
//                               ",#,%,&,',(,),*,+,comma,-,/,
//                               :,;,<,=,>,@,[,],`
//      The phrase seperators are: !,.,?,\,^,{,|,},~
//
//  NOTE: Symbols are treated as WS or PS.
//
//  081-0FF
//  The lower 7E entries from the Half Width Variant Code Page (FF00-FF7F) are
//  mapped to 081-0FF.
//
//  100-1FF
//  The lower FF entries from the General Punctuation Code Page (2000-2044) are
//  mapped to 100-1ff.
//
//  200-2FF
//  The lower FF entries from the CJK Auxiliary Code Page (3000-30FF) are mapped
//  to 200-2ff.
//
// pathal - 5/20/96
// Special default character processing for selection
// The following is a list of white space characters that T-Hammer will not right select on:
//          0x0009 (tab), 0x0020 (ansi space), 0x2005 (narrow space, 0x3000 (wide space)
// (Note: see AnalyzeHPBs for special end SPB processing of adjacent white space)
// The following is a list of nls characters to be treated as text by T-Hammer:
//      (in other words T-Hammer will neither right nor left-select on them):
//          0x001F (non-required hyphen), 0x0027 (single quote), 0x2019 (right quote),
//          0x200C (non-width optional break), 0x200D (non-width no break)
//----------------------------------------------------------------------------

const BYTE
s_abCharTypeList[0x301] =
    {
        (BYTE) -1,                                       // EOF (-1)
        PS,PS,PS,PS,PS,PS,PS,PS, WS,WS,WS,WS,PS,WS,PS,PS, // 000 - 015
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,CH,PS, // 016 - 031
        WS,PS,WS,WS,CH,CH,WS,PS,                          // sp ! " # $ % & '
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  0 1 2 3 4 5 6 7
        CH,CH,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  @ A B C D E F G
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  H I J K M L N O
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  P Q R S T U V Y
        CH,CH,CH,WS,PS,WS,PS,WS,                          //  X Y Z [ \ ] ^ _
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  ` a b c d e f g
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  h i j k m l n o
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  p q r s t u v y
        CH,CH,CH,PS,PS,PS,WS,PS,                          //  x y z { | } ~ del
        WS,PS,WS,WS,CH,CH,WS,WS,                          //  FF00-FF07 (sp ! " # $ % & ')
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  0 1 2 3 4 5 6 7
        VC,VC,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  @ A B C D E F G
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  H I J K M L N O
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  P Q R S T U V Y
        VC,VC,VC,WS,VC,WS,PS,WS,                          //  X Y Z [ \ ] ^ _
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  ` a b c d e f g
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  h i j k m l n o
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  p q r s t u v y
        VC,VC,VC,PS,PS,PS,WS,PS,                          //  x y z { | } ~ del
        VC,PS,WS,WS,WS,WS,VC,VC,                          //  FF60-FF67
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF68-FF6F
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF77
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF7E
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2000-2007
        WS,WS,WS,WS,CH,CH,WS,WS,                          //  2008-200F
        WS,CH,WS,WS,WS,KC,PS,WS,                          //  2010-2017
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2018-201F
        WS,WS,PS,PS,PS,PS,PS,CH,                          //  2020-2027
        PS,PS,CH,CH,CH,CH,CH,PS,                          //  2028-202F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2030-2037
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2038-203F
        WS,WS,WS,PS,WS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2040-204F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2050-205F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2060-206F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2070-207F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2080-208F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2090-209F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,CH,PS,PS,PS, //  20A0-20AF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20B0-20BF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20C0-20CF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20D0-20DF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20E0-20EF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20F0-20FF
        WS,WS,PS,HC,HC,IC,IC,HC,                          //  3000-3007
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3008-300F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3010-3017
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3018-301F
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3020-3027
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3028-302F
        WS,HC,IC,HC,IC,HC,HC,HC,                          //  3030-3037
        PS,PS,PS,PS,PS,PS,PS,WS,                          //  3038-303F
        WS,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3040-304F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3050-305F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3060-306F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3070-307F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3080-308F
        HC,HC,HC,HC,HC,PS,PS,PS,                          //  3090-3097
        PS,HC,HC,WS,WS,HC,HC,PS,                          //  3098-309F
        WS,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30A0-30AF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30B0-30BF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30C0-30CF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30D0-30DF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30E0-30EF
        KC,KC,KC,KC,KC,KC,IC,PS,                          //  30F0-30F7
        PS,PS,PS,WS,KC,KC,KC,PS,                          //  30F8-30FF
    };

//
// Type C1 bits are:
//
//   C1_UPPER                  0x0001      // upper case
//   C1_LOWER                  0x0002      // lower case
//   C1_DIGIT                  0x0004      // decimal digits             1
//   C1_SPACE                  0x0008      // spacing characters         2
//   C1_PUNCT                  0x0010      // punctuation characters     4
//   C1_CNTRL                  0x0020      // control characters         8
//   C1_BLANK                  0x0040      // blank characters          10
//   C1_XDIGIT                 0x0080      // other digits              20
//   C1_ALPHA                  0x0100      // any linguistic character  40
//
// But since I don't care about C1_UPPER and C1_LOWER I can right-shift
// the output of GetStringTypeEx and keep a 128 Byte lookup table.
//
// The precedence rules are: (Alpha, XDigit, Digit) --> CH
//                           (Punct) --> PS
//                           (Space, Blank, Control) --> WS
//

const BYTE
s_abCTypeList[128] =
    {
      WS, CH, WS, CH, PS, CH, WS, CH,   // 00 - 07
      WS, CH, WS, CH, PS, CH, WS, CH,   // 08 - 0F
      WS, CH, WS, CH, PS, CH, WS, CH,   // 10 - 17
      WS, CH, WS, CH, PS, CH, WS, CH,   // 18 - 1F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 40 - 47
      CH, CH, CH, CH, CH, CH, CH, CH,   // 48 - 4F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 50 - 57
      CH, CH, CH, CH, CH, CH, CH, CH,   // 58 - 5F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 60 - 67
      CH, CH, CH, CH, CH, CH, CH, CH,   // 68 - 6F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 70 - 77
      CH, CH, CH, CH, CH, CH, CH, CH,   // 78 - 7F
    };

//+---------------------------------------------------------------------------
//
//  Synopsis:   Returns the type of a character
//
//  Arguments:  [c]   -- Unicode Character
//
//  Returns:    type, one of CH, WS, PS, EOF
//
//  History:    10-Sep-97   Weibz
//
//  Notes:      This returns the type of a character, using the static
//              array s_abCharTypeList.  It adds 1 so that EOF (-1) can be in
//              the array, and accessed normally.
//
//              This is not done by overloading the [] opeator, because in
//              future versions it will not necessarly be a table lookup.
//
//  See above (typeof comments) for an explanation of the mapping
//
//----------------------------------------------------------------------------
BYTE
GetCharType(WCHAR wc )
{
    WCHAR wc2;

    // Map interesting stuff (0000, 2000, 3000, FF00) to the table range,
    // 0x0000 - 0x0300.
    //
    wc2 = (wc & 0x00FF);

    switch (wc & 0xFF00) {

        case 0xFF00:  // Half-Width Variants
            if (wc2 & 0x80) {
                return(CH);  // full width currency
            }
            wc2 |=  0x0080;
            break;

        case 0xFE00:  // Small Variants
            if ((wc2 <= 0x006B) && (wc2 != 0x0069)) {
                return(WS);
            }
            // Treat Small $ and arabic symbols as CH
            return(CH);
            // break;

        case 0x3000:  // CJK Auxiliary
            wc2 |=  0x0200;
            break;

        case 0x2000:  // General Punctuation
            wc2 |=  0x0100;
            break;

        case 0x0000:  // Code page 0
            // Use System NLS map for code page 0
            if (wc2 & 0x80)
            {
                WORD wCharType = 0;

                GetStringTypeExW( MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN ),
                                  CT_CTYPE1,
                                  &wc2,
                                  1,
                                  &wCharType );
                return s_abCTypeList[wCharType >> 2];
            }
            break;

        default:
            //
            // Treat the whole Hanja as Non-Hangul character
            //
            if ((wc >= 0x4E00) && (wc <= 0x9FFF)) {
                return(IC);
            }

			// compatibility range
			if ((wc >= 0xF900) && (wc <= 0xFAFF)) {
				return (IC);
			}

			// extensionA
			if ((wc >= 0x3400) && (wc <= 0x4DB5)) {
				return (IC);
			}

            //
            // Treat all CJK symbols as word separators
            // NOTE: This means that the stemmer must be smart about searching
            // for zipcodes when given one with a preceding zipcode char.
            //
            if ((wc >= 0x3200) && (wc <= 0x33DD)) {
                return(WS);
            }

            // Treat Hanguel Region as hanguel char.
            if ((wc >= 0xac00) && (wc <= 0xd7a3)) {
               return(HG);
            }

			// Treat Hanguel jamo range as hanguel char.
            if ((wc >= 0x3131) && (wc <= 0x318E)) {
               return(HG);
            }

            // If it's not interesting return PS as default
			// NOTE: This means that these characters are not handled by WBr.
            return(PS);
            // break;
    }

    return( (s_abCharTypeList+1)[wc2] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\indexrec.h ===
// IndexRec.h
//
// final index record & lists
// 
// Copyright 2001 Microsoft Corp.
//
// Modification History:
//  19 MAR 2001	  bhshin	created

#ifndef _INDEX_REC_H
#define _INDEX_REC_H

// INDEX_REC
//
// index term information structure
// 
// 19MAR01  bhshin  began
typedef struct
{
	WCHAR wzIndex[MAX_INDEX_STRING+1]; // index string
	int cchIndex; // length of index string
	int nFT;   	 // first position of original input
	int nLT;  	 // last position of original input
	float fWeight; // weight of index term 

	int nNext;	 // next INDEX_REC index for final list
} INDEX_REC, *pINDEX_REC;


// CRecList
//
// container of INDEX_REC id's
//
// 20MAR01  bhshin  began
class CRecList
{
// member data
public:
	int *m_prgnRecID; 
	int m_nMaxRec; // # of allocated record
	int m_nCurrRec; // next empty space of m_prgnRecID

// default constructor & destructor
public:
	CRecList();
	~CRecList(); 

// operators
public:
	// initializer & uninitializer
	//==================
	BOOL Initialize(void);
	void Uninitialize(void);

	BOOL AddRec(int nRecID);

	// operators
	//==================
	CRecList& operator = (CRecList& objRecList);
	CRecList& operator += (CRecList& objRecList);
	
};


// the index of the first "real" record (0 is reserved)
#define MIN_RECORD  1

// CIndexInfo
//
// container of INDEX_REC structure
// 
// 19MAR01  bhshin  began
class CIndexInfo
{
// member data
public:
	// record management
	//==================
	INDEX_REC *m_prgIndexRec; // array of INDEX_REC
	int m_nMaxRec; // # of allocated record
	int m_nCurrRec; // next empty space of prgIndexRec

	// PutWord/PutAltWord 
	//==================
	int m_cchTextProcessed; // length of text processed
	int m_cwcSrcPos; // position value of source string
	IWordSink *m_pWordSink; 
	IPhraseSink *m_pPhraseSink;

	// symbol processing
	//==================
	WCHAR m_wzRomaji[MAX_INDEX_STRING+1]; // romaji string
	int m_cchRomaji; // length of romaji
	int m_cchPrefix; // the prefix length
	BOOL m_fAddRomaji; // flag if romaji is added or not

	// final list head index
	//==================
	int m_nFinalHead;

	// final sequence index list
	//==================
	CRecList m_FinalRecList;

// default constructor & destructor
public:
	CIndexInfo();
	~CIndexInfo();

// attributes
public:
	BOOL IsExistIndex(const WCHAR *pwzIndex);
	BOOL SetRomajiInfo(WCHAR *pwzRomaji, int cchRomaji, int cchPrefix);

	BOOL IsEmpty(void) { return (m_nCurrRec == MIN_RECORD); }

// operators
public:
	// initializer & uninitializer
	//==================
	BOOL Initialize(int cchTextProcessed, int cwcSrcPos, IWordSink *pWordSink, IPhraseSink *pPhraseSink);
	void Uninitialize(void);

	BOOL AddIndex(const WCHAR *pwzIndex, int cchIndex, float fWeight, int nFT, int nLT);

	// single length processing
	//==================
	BOOL FindAndMergeIndexTerm(INDEX_REC *pIndexSrc, int nFT, int nLT);
	BOOL MakeSingleLengthMergedIndex(void);

	// index time final index list
	//==================
	BOOL InsertFinalIndex(int nFT);
	BOOL PutFinalIndexList(LPCWSTR lpcwzSrc);

	// query time final index list
	//==================
	BOOL MakeSeqIndexList(int nFT =0, CRecList *plistFinal = NULL);
	BOOL PutQueryIndexList(void);
};

#endif // #ifdef _INDEX_REC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\istemmer.h ===
// IStemmer.h : Declaration of the CStemmer

#ifndef __STEMMER_H_
#define __STEMMER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CStemmer
class ATL_NO_VTABLE CStemmer : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CStemmer, &CLSID_Stemmer>,
	public IStemmer
{
public:
	CStemmer()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_STEMMER)
DECLARE_NOT_AGGREGATABLE(CStemmer)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CStemmer)
	COM_INTERFACE_ENTRY(IStemmer)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IStemmer
public:
	STDMETHOD(GetLicenseToUse)(/*[out]*/ const WCHAR ** ppwcsLicense);
	STDMETHOD(StemWord)(/*[in]*/ WCHAR const * pwcInBuf, /*[in]*/ ULONG cwc, /*[in]*/ IStemSink * pStemSink);
	STDMETHOD(Init)(/*[in]*/ ULONG ulMaxTokenSize, /*[out]*/ BOOL *pfLicense);
};

#endif //__STEMMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\iwbreak.h ===
// IWBreak.h
//
// CWordBreak declaration
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  12 APR 2000   bhshin    added WordBreak operator
//  30 MAR 2000	  bhshin	created

#ifndef __WORDBREAKER_H_
#define __WORDBREAKER_H_

#include "resource.h"       // main symbols
extern "C"
{
#include "ctplus.h"			// WT
}

class CIndexInfo;
/////////////////////////////////////////////////////////////////////////////
// CWordBreaker

class ATL_NO_VTABLE CWordBreaker : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWordBreaker, &CLSID_WordBreaker>,
	public IWordBreaker
{
public:
	CWordBreaker()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WORDBREAKER)
DECLARE_NOT_AGGREGATABLE(CWordBreaker)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CWordBreaker)
	COM_INTERFACE_ENTRY(IWordBreaker)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IWordBreaker
public:
	STDMETHOD(GetLicenseToUse)(/*[out]*/ const WCHAR ** ppwcsLicense);
	STDMETHOD(ComposePhrase)(/*[in]*/ const WCHAR *pwcNoun, /*[in]*/ ULONG cwcNoun, /*[in]*/ const WCHAR *pwcModifier, /*[in]*/ ULONG cwcModifier, /*[in]*/ ULONG ulAttachmentType, /*[out]*/ WCHAR *pwcPhrase, /*[out]*/ ULONG *pcwcPhrase );
	STDMETHOD(BreakText)(/*[in]*/ TEXT_SOURCE *pTextSource, /*[in]*/ IWordSink *pWordSink, /*[in]*/ IPhraseSink *pPhraseSink);
	STDMETHOD(Init)(/*[in]*/ BOOL fQuery, /*[in]*/ ULONG ulMaxTokenSize, /*[out]*/ BOOL *pfLicense);

// Operator
public:
	int WordBreak(TEXT_SOURCE *pTextSource, WT Type, 
		          int cchTextProcessed, int cchHanguel,
		          IWordSink *pWordSink, IPhraseSink *pPhraseSink,
				  WCHAR *pwchLast);

	void AnalyzeRomaji(const WCHAR *pwcStem, int cchStem,
					   int iCur, int cchProcessed, int cchHanguel,
					   CIndexInfo *pIndexInfo, int *pcchPrefix);
						  
// Member data
protected:
	PARSE_INFO	m_PI;
	BOOL		m_fQuery;
	ULONG		m_ulMaxTokenSize;
};

#endif //__WORDBREAKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\korwbrk.cpp ===
// KorWbrk.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f KorWbrkps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "KorWbrk.h"
#include "KorWbrk_i.c"
#include "IWBreak.h"
#include "IStemmer.h"
#include "Lex.h"

CComModule _Module;
CRITICAL_SECTION g_CritSect;
MAPFILE g_LexMap;
BOOL g_fLoaded;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WordBreaker, CWordBreaker)
OBJECT_ENTRY(CLSID_Stemmer, CStemmer)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_KORWBRKLib);
        DisableThreadLibraryCalls(hInstance);

		WB_LOG_INIT();

		g_fLoaded = FALSE;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
		_Module.Term();

		if (g_fLoaded)
		{
			ATLTRACE("Unload lexicon...\n");

			UnloadLexicon(&g_LexMap);
		}

		WB_LOG_UNINIT();
	}

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\lex.h ===
// Lex.h
// lex management routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 2000	  bhshin	created

BOOL InitLexicon(MAPFILE *pLexMap);
BOOL LoadLexicon(const char *pszLexPath, MAPFILE *pLexMap);
void UnloadLexicon(MAPFILE *pLexMap);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\istemmer.cpp ===
// IStemmer.cpp
//
// CStemmer implementation
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  10 MAY 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "IStemmer.h"
#include <stdio.h>

/////////////////////////////////////////////////////////////////////////////
// CStemmer

// CStemmer::Init
//
// intialize WordBreaker object & lexicon
//
// Parameters:
//  ulMaxTokenSize  -> (ULONG) maximum input token length
//  *pfLicense		<- (BOOL*) always return TRUE
//
// Result:
//  (HRESULT) 
//
// 10MAY00  bhshin  began
STDMETHODIMP CStemmer::Init(ULONG ulMaxTokenSize, BOOL *pfLicense)
{
    if (pfLicense == NULL)
       return E_INVALIDARG;

    if (IsBadWritePtr(pfLicense, sizeof(DWORD)))
        return E_INVALIDARG;

    *pfLicense = TRUE;

	return S_OK;
}

// CStemmer::StemWord
//
// main stemming method
//
// Parameters:
//  pTextSource		-> (WCHAR const*) input string for stemming
//  cwc				-> (ULONG) input string length to process
//  pStemSink       -> (IStemSink*) pointer to the stem sink
//
// Result:
//  (HRESULT) 
//
// 10MAY00  bhshin  began
STDMETHODIMP CStemmer::StemWord(WCHAR const * pwcInBuf, ULONG cwc, IStemSink * pStemSink)
{
	if (pStemSink == NULL || pwcInBuf == NULL)
	{
		return E_FAIL;
	}
	
	pStemSink->PutWord(pwcInBuf, cwc);

	return S_OK;
}

// CStemmer::GetLicenseToUse
//
// return license information
//
// Parameters:
//  ppwcsLicense  -> (const WCHAR **) output pointer to the license information
//
// Result:
//  (HRESULT) 
//
// 10MAY00  bhshin  began
STDMETHODIMP CStemmer::GetLicenseToUse(const WCHAR ** ppwcsLicense)
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-2000";

    if (ppwcsLicense == NULL)  
       return E_INVALIDARG;

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) 
        return E_INVALIDARG;

    *ppwcsLicense = wcsCopyright;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\lex.cpp ===
// Lex.cpp
// lex management routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 2000   bhshin        created

#include "StdAfx.h"
#include "LexInfo.h"
#include "Lex.h"
#include <stdio.h>

// InitLexicon
// 
// finx lexicon & map the lexicon file into memory
//
// Parameters:
//  pLexMap     -> (MAPFILE*) output MAPFILE structure
//
// Result:
//  (TRUE if success, FALSE if failure)
//
// 16MAR00  bhshin  began
BOOL InitLexicon(MAPFILE *pLexMap)
{
    char szLexFile[_MAX_PATH];
        char szDllPath[_MAX_PATH];
        char szDrive[_MAX_DRIVE];
        char szDir[_MAX_DIR];
        char szFName[_MAX_FNAME];
        char szExt[_MAX_EXT];

    pLexMap->hFile = NULL;
    pLexMap->hFileMapping = NULL;
    pLexMap->pvData = NULL;

        // get the path of word breaker DLL
        if (GetModuleFileNameA(_Module.m_hInst, szDllPath, _MAX_PATH) == 0)
            return FALSE;

        szDllPath[ _MAX_PATH - 1 ] = 0;

        // make lexicon full path
        _splitpath(szDllPath, szDrive, szDir, szFName, szExt);

        strcpy(szLexFile, szDrive);
    strcat(szLexFile, szDir);
    strcat(szLexFile, LEXICON_FILENAME);

        return LoadLexicon(szLexFile, pLexMap);
}

// LoadLexicon
// 
// map the lexicon file into memory
//
// Parameters:
//  pszLexPath  -> (const char*) lexicon file path
//  pLexMap     -> (MAPFILE*) output MAPFILE structure
//
// Result:
//  (TRUE if success, FALSE if failure)
//
// 16MAR00  bhshin  began
BOOL LoadLexicon(const char *pszLexPath, MAPFILE *pLexMap)
{
    char *pData;
        unsigned short nVersion;
        
        if (pszLexPath == NULL)
                return FALSE;

        if (pLexMap == NULL)
                return FALSE;

        // open the file for reading
    pLexMap->hFile = CreateFile(pszLexPath, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (pLexMap->hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    // create a file mapping
    pLexMap->hFileMapping = CreateFileMappingA(pLexMap->hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (pLexMap->hFileMapping == NULL)
        return FALSE;

    // map the entire file for reading
    pLexMap->pvData = MapViewOfFileEx(pLexMap->hFileMapping, FILE_MAP_READ, 0, 0, 0, 0);
    if (pLexMap->pvData == NULL)
        return FALSE;

    // check the version # in the first 2 bytes (swap bytes)
    pData = (char*)pLexMap->pvData;
    nVersion = pData[0];
    nVersion |= (pData[1] << 8);
    if (nVersion < LEX_VERSION)
    {
        ATLTRACE("Outdated lexicon file\n");
        ATLTRACE("Expected v.%d, found v.%d\n", LEX_VERSION, nVersion);
        return FALSE;
    }

        // check the magic signature
        if (strcmp(pData+2, LEXICON_MAGIC_SIG) != 0)
                return FALSE;

        return TRUE;
}

// UnloadLexicon
// 
// unmap the lexicon file into memory
//
// Parameters:
//  pLexMap  -> (MAPFILE*) input MAPFILE structure
//
// Result:
//  (void)
//
// 16MAR00  bhshin  began
void UnloadLexicon(MAPFILE *pLexMap)
{
    if (pLexMap->pvData != NULL)
        UnmapViewOfFile(pLexMap->pvData);
    
        if (pLexMap->hFileMapping != NULL)
        CloseHandle(pLexMap->hFileMapping);

    if (pLexMap->hFile != NULL)
        CloseHandle(pLexMap->hFile);

    pLexMap->hFile = NULL;
    pLexMap->hFileMapping = NULL;
    pLexMap->pvData = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\iwbreak.cpp ===
// IWBreak.cpp
//
// CWordBreak implementation
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  18 APR 2000   bhshin    added WordBreak destructor
//  30 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "IWBreak.h"
#include "Lex.h"
#include "Token.h"
#include "Record.h"
#include "Analyze.h"
#include "IndexRec.h"
#include "unikor.h"
#include "Morpho.h"

extern CRITICAL_SECTION g_CritSect;
extern MAPFILE g_LexMap;
extern BOOL g_fLoaded;

/////////////////////////////////////////////////////////////////////////////
// CWordBreaker member functions

// CWordBreaker::Init
//
// intialize WordBreaker object & lexicon
//
// Parameters:
//  fQuery			-> (BOOL) query time flag
//  ulMaxTokenSize  -> (ULONG) maximum input token length
//  *pfLicense		<- (BOOL*) always return TRUE
//
// Result:
//  (HRESULT) 
//
// 30MAR00  bhshin  began
STDMETHODIMP CWordBreaker::Init(BOOL fQuery, ULONG ulMaxTokenSize, BOOL *pfLicense)
{
	if (pfLicense == NULL)
       return E_INVALIDARG;

    if (IsBadWritePtr(pfLicense, sizeof(DWORD)))
        return E_INVALIDARG;

	// store intitializing information
	m_fQuery = fQuery;
	m_ulMaxTokenSize = ulMaxTokenSize;

    *pfLicense = TRUE;

	if (!g_fLoaded)
	{
		// load lexicon file
		ATLTRACE(L"Load lexicon...\r\n");

		if (!InitLexicon(&g_LexMap))
			return LANGUAGE_E_DATABASE_NOT_FOUND;

		g_fLoaded = TRUE;
	}

	m_PI.lexicon = g_LexMap;

	WB_LOG_PRINT_HEADER(fQuery);

	return S_OK;
}

// CWordBreaker::BreakText
//
// main word breaking method
//
// Parameters:
//  pTextSource		-> (TEXT_SOURCE*) pointer to the structure of source text
//  pWordSink		-> (IWordSink*) pointer to the word sink
//  pPhraseSink     -> (IPhraseSink*) pointer to the phrase sink
//
// Result:
//  (HRESULT) 
//
// 30MAR00  bhshin  began
STDMETHODIMP CWordBreaker::BreakText(TEXT_SOURCE *pTextSource, IWordSink *pWordSink, IPhraseSink *pPhraseSink)
{
	WT Type;
	int cchTextProcessed, cchProcessed, cchHanguel;
	WCHAR wchLast = L'\0';

	if (pTextSource == NULL)
		return E_INVALIDARG;

	if (pWordSink == NULL)
		return S_OK;

	if (pTextSource->iCur == pTextSource->iEnd)
		return S_OK;

	ATLASSERT(pTextSource->iCur < pTextSource->iEnd);

    do
    {
        while (pTextSource->iCur < pTextSource->iEnd)
        {
			Tokenize(TRUE, pTextSource, pTextSource->iCur, &Type, &cchTextProcessed, &cchHanguel);

			if (Type == WT_REACHEND)
				break;

			cchProcessed = WordBreak(pTextSource, Type, cchTextProcessed, cchHanguel, pWordSink, pPhraseSink, &wchLast);
			if (cchProcessed < 0)
				return E_UNEXPECTED;

			pTextSource->iCur += cchProcessed;
		}

    } while (SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)));

    while ( pTextSource->iCur < pTextSource->iEnd )
	{
		Tokenize(FALSE, pTextSource, pTextSource->iCur, &Type, &cchTextProcessed, &cchHanguel);
       
		cchProcessed = WordBreak(pTextSource, Type, cchTextProcessed, cchHanguel, pWordSink, pPhraseSink, &wchLast);
		if (cchProcessed < 0)
			return E_UNEXPECTED;

		pTextSource->iCur += cchProcessed;
	}
	
	return S_OK;
}

// CWordBreaker::ComposePhrase
//
// convert a noun and modifier back into a source phrase (NOT USED)
//
// Parameters:
//  pwcNoun			 -> (const WCHAR*) input noun
//  cwcNoun			 -> (ULONG) length of input noun
//  pwcModifier      -> (const WCHAR *)  input modifier
//  cwcModifier		 -> (ULONG) length of input modifier
//  ulAttachmentType -> (ULONG) value about the method of composition
//  pwcPhrase        -> (WCHAR *) pointer to the returned buffer
//  pcwcPhrase		 -> (ULONG *) length of returned string
//
// Result:
//  (HRESULT) 
//
// 30MAR00  bhshin  began
STDMETHODIMP CWordBreaker::ComposePhrase(const WCHAR *pwcNoun, ULONG cwcNoun, const WCHAR *pwcModifier, ULONG cwcModifier, ULONG ulAttachmentType, WCHAR *pwcPhrase, ULONG *pcwcPhrase)
{
    if (m_fQuery)
        return E_NOTIMPL;
    
    return WBREAK_E_QUERY_ONLY;
}

// CWordBreaker::GetLicenseToUse
//
// return license information
//
// Parameters:
//  ppwcsLicense  -> (const WCHAR **) output pointer to the license information
//
// Result:
//  (HRESULT) 
//
// 30MAR00  bhshin  began
STDMETHODIMP CWordBreaker::GetLicenseToUse(const WCHAR ** ppwcsLicense)
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-2000";

    if (ppwcsLicense == NULL)  
       return E_INVALIDARG;

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) 
        return E_INVALIDARG;

    *ppwcsLicense = wcsCopyright;
    
	return S_OK;
}

// CWordBreaker::WordBreak
//
// main hangul word breaking operator
//
// Parameters:
//  pTextSource		 -> (TEXT_SOURCE*) pointer to the structure of source text
//  Type			 -> (WT) word token type
//  cchTextProcessed -> (int) input length to process
//  cchHanguel       -> (int) hangul token length (hanguel+romaji case only)
//  pWordSink		 -> (IWordSink*) pointer to the word sink
//  pPhraseSink      -> (IPhraseSink*) pointer to the phrase sink
//  pwchLast		 -> (WCHAR*) input & output last character of previous token
//
// Result:
//  (int) -1 if error occurs, text length to process
//
// 30MAR00  bhshin  began
int CWordBreaker::WordBreak(TEXT_SOURCE *pTextSource, WT Type, 
							int cchTextProcessed, int cchHanguel,
							IWordSink *pWordSink, IPhraseSink *pPhraseSink,
							WCHAR *pwchLast)
{
	const WCHAR *pwcStem;
	int iCur;
	int cchToken, cchProcessed, cchHg;
	int cchPrefix;
	
	ATLASSERT(cchTextProcessed > 0);
	
	if (cchTextProcessed <= 0)
		return -1;

	iCur = pTextSource->iCur;
	pwcStem = pTextSource->awcBuffer + iCur;
	cchProcessed = cchTextProcessed;
	cchToken = cchTextProcessed;

	// check too long token 
	if (cchToken > (int)m_ulMaxTokenSize || cchToken > MAX_INDEX_STRING)
	{
		cchProcessed = (m_ulMaxTokenSize < MAX_INDEX_STRING) ? m_ulMaxTokenSize : MAX_INDEX_STRING;

		pWordSink->PutWord(cchProcessed,
						   pwcStem,
						   cchProcessed,
						   pTextSource->iCur);

		return cchProcessed;
	}
	
	//=================================================
	// query & index time
	//=================================================

	if (Type == WT_PHRASE_SEP)
	{
		// phrase separator
		*pwchLast = L'\0';

		pWordSink->PutBreak(WORDREP_BREAK_EOS);
	}
	else if (Type == WT_WORD_SEP)
	{
		if (!fIsWhiteSpace(*pwcStem))
			*pwchLast = L'\0';
		
		// Korean WB do not add EOW.
	}
	else if (Type == WT_ROMAJI)
	{
		// symbol, alphabet, hanja, romaji + hanguel

		// get next token
		iCur += cchToken;
		Tokenize(FALSE, pTextSource, iCur, &Type, &cchToken, &cchHg);

		if (Type == WT_ROMAJI)
		{
			if (cchHg > 0)
			{
				// romaji+(hanguel+romaji) case -> put word itself
				cchProcessed += cchToken;
				iCur += cchToken;
				cchProcessed += GetWordPhrase(FALSE, pTextSource, iCur);

				WB_LOG_START(pwcStem, cchProcessed);

				pWordSink->PutWord(cchProcessed,
								   pwcStem,
								   cchProcessed,
								   pTextSource->iCur);

				WB_LOG_ADD_INDEX(pwcStem, cchProcessed, INDEX_SYMBOL);
			}
			else
			{
				WB_LOG_START(pwcStem, cchProcessed);
				
				// {romaj}{romaj} case : -> breaking first {romaji}
				CIndexInfo IndexInfo;

				if (!IndexInfo.Initialize(cchProcessed, pTextSource->iCur, pWordSink, pPhraseSink))
					goto ErrorReturn;

				AnalyzeRomaji(pwcStem, cchProcessed, pTextSource->iCur, cchProcessed, 
				              cchHanguel, &IndexInfo, &cchPrefix);

				if (m_fQuery)
				{
					IndexInfo.AddIndex(pwcStem, cchProcessed+cchToken, WEIGHT_HARD_MATCH, 0, cchProcessed+cchToken-1);
					WB_LOG_ADD_INDEX(pwcStem, cchProcessed, INDEX_QUERY);

					if (!IndexInfo.PutQueryIndexList())
						goto ErrorReturn;
				}
				else
				{
					if (!IndexInfo.PutFinalIndexList(pTextSource->awcBuffer + pTextSource->iCur))
						goto ErrorReturn;
				}
			}
		}
		else if (Type == WT_HANGUEL)
		{
			// romaji(hanguel+romaji) + hanguel case
			WCHAR wzRomaji[MAX_INDEX_STRING+1];
			int cchRomaji;

			cchRomaji = (cchProcessed > MAX_INDEX_STRING) ? MAX_INDEX_STRING : cchProcessed;

			wcsncpy(wzRomaji, pwcStem, cchRomaji);
			wzRomaji[cchRomaji] = L'\0';

			WB_LOG_START(pwcStem, cchProcessed+cchToken);
			
			cchProcessed += cchToken;
			
			// start position include romanji
			CIndexInfo IndexInfo;

			if (!IndexInfo.Initialize(cchProcessed, pTextSource->iCur, pWordSink, pPhraseSink))
				goto ErrorReturn;

			if (cchHanguel > 0)
			{
				AnalyzeRomaji(pwcStem, cchRomaji, pTextSource->iCur, cchRomaji, 
					         cchHanguel, &IndexInfo, &cchPrefix);
			}
			else
			{
				cchPrefix = CheckURLPrefix(pwcStem, cchProcessed-cchToken);
			}

			// analyze string starts from last hangul
			pwcStem = pTextSource->awcBuffer + iCur;

			if (cchRomaji > 0)
				IndexInfo.SetRomajiInfo(wzRomaji, cchRomaji, cchPrefix);

			// analyze string always with indexing mode on symbol processing
			if (!AnalyzeString(&m_PI, m_fQuery, pwcStem, cchToken, iCur, &IndexInfo, *pwchLast))
				goto ErrorReturn;

			if (m_fQuery)
			{
				if (cchRomaji > 0)
					IndexInfo.SetRomajiInfo(NULL, 0, 0);	

				IndexInfo.AddIndex(pTextSource->awcBuffer + pTextSource->iCur, cchProcessed, WEIGHT_HARD_MATCH, 0, cchProcessed+cchToken-1);
				WB_LOG_ADD_INDEX(pTextSource->awcBuffer + pTextSource->iCur, cchProcessed, INDEX_QUERY);

				if (!IndexInfo.PutQueryIndexList())
					goto ErrorReturn;
			}
			else
			{
				if (!IndexInfo.MakeSingleLengthMergedIndex())
					goto ErrorReturn;
				
				if (!IndexInfo.PutFinalIndexList(pTextSource->awcBuffer + pTextSource->iCur))
					goto ErrorReturn;
			}
			
			*pwchLast = *(pwcStem + cchToken - 1);
		}
		else // next: WT_START, WT_PHRASE_SEP, WT_WORD_SEP, WT_REACHEND
		{
			WB_LOG_START(pwcStem, cchProcessed);
			
			CIndexInfo IndexInfo;

			if (!IndexInfo.Initialize(cchProcessed, pTextSource->iCur, pWordSink, pPhraseSink))
				goto ErrorReturn;

			AnalyzeRomaji(pwcStem, cchProcessed, pTextSource->iCur, cchProcessed, 
				          cchHanguel, &IndexInfo, &cchPrefix);

			if (m_fQuery)
			{
				IndexInfo.AddIndex(pwcStem, cchProcessed, WEIGHT_HARD_MATCH, 0, cchProcessed-1);
				WB_LOG_ADD_INDEX(pwcStem, cchProcessed, INDEX_QUERY);

				if (!IndexInfo.PutQueryIndexList())
					goto ErrorReturn;
			}
			else
			{
				if (!IndexInfo.PutFinalIndexList(pTextSource->awcBuffer + pTextSource->iCur))
					goto ErrorReturn;
			}
		}
	}
	else if (Type == WT_HANGUEL)
	{
		// hangul input

		WB_LOG_START(pwcStem, cchProcessed);
		
		CIndexInfo IndexInfo;

		if (!IndexInfo.Initialize(cchProcessed, iCur, pWordSink, pPhraseSink))
			goto ErrorReturn;

		if (!AnalyzeString(&m_PI, m_fQuery, pwcStem, cchProcessed, iCur, &IndexInfo, *pwchLast))
			goto ErrorReturn;

		if (m_fQuery)
		{
			IndexInfo.AddIndex(pwcStem, cchProcessed, WEIGHT_HARD_MATCH, 0, cchProcessed-1);
			WB_LOG_ADD_INDEX(pwcStem, cchProcessed, INDEX_QUERY);

			if (!IndexInfo.PutQueryIndexList())
				goto ErrorReturn;
		}
		else
		{
			if (!IndexInfo.MakeSingleLengthMergedIndex())
				goto ErrorReturn;
			
			if (!IndexInfo.PutFinalIndexList(pwcStem))
				goto ErrorReturn;
		}
	
		*pwchLast = *(pwcStem + cchProcessed - 1);
	}

	WB_LOG_PRINT_ALL();
	WB_LOG_END();
	
	return cchProcessed;

ErrorReturn:

	WB_LOG_END();
	
	return -1;
}

// CWordBreaker::AnalyzeRomaji
//
// helper function for romaji token wordbreaking
//
// Parameters:
//  pwcStem		     -> (const WCHAR*) input token string
//  cchStem          -> (int) length of input romaji token
//  iCur             -> (int) source string position
//  cchProcessed     -> (int) input length to process
//  cchHanguel       -> (int) hangul token length (hanguel+romaji case only)
//  pIndexInfo		-> (CIndexInfo *) output index list
//  pcchPrefix       -> (int*) output prefix length
//
// Result:
//  (void) 
//
// 23NOV00  bhshin  began
void CWordBreaker::AnalyzeRomaji(const WCHAR *pwcStem, int cchStem,
								 int iCur, int cchProcessed, int cchHanguel,
							     CIndexInfo *pIndexInfo, int *pcchPrefix)
{
	int cchPrefix = 0;
	
	// hanguel+romaji case
	if (cchHanguel < cchProcessed)
	{
		// hanguel
		if (cchHanguel > 0)
		{
			pIndexInfo->AddIndex(pwcStem, cchHanguel, WEIGHT_HARD_MATCH, 0, cchHanguel-1);
			WB_LOG_ADD_INDEX(pwcStem, cchHanguel, INDEX_SYMBOL);
		}

		// romaji
		if ((cchStem-cchHanguel) > 0)
		{
			pIndexInfo->AddIndex(pwcStem + cchHanguel, cchStem - cchHanguel, WEIGHT_HARD_MATCH, cchHanguel, cchStem-1);
			WB_LOG_ADD_INDEX(pwcStem + cchHanguel, cchStem - cchHanguel, INDEX_SYMBOL);
		}
	}

	if (cchHanguel == 1 || (cchStem-cchHanguel) == 1) 
	{
		// romaji(hangul+romaji)
		pIndexInfo->AddIndex(pwcStem, cchStem, WEIGHT_HARD_MATCH, 0, cchStem-1);
		WB_LOG_ADD_INDEX(pwcStem, cchStem, INDEX_SYMBOL);
	}
	
	// check URL prefix
	cchPrefix = CheckURLPrefix(pwcStem, cchProcessed);
	if (cchPrefix > 0 && cchPrefix < cchProcessed)
	{
		pIndexInfo->AddIndex(pwcStem + cchPrefix, cchStem - cchPrefix, WEIGHT_HARD_MATCH, cchPrefix, cchStem-1);
		WB_LOG_ADD_INDEX(pwcStem + cchPrefix, cchStem - cchPrefix, INDEX_SYMBOL);
	}

	*pcchPrefix = cchPrefix; // return it
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\lexinfo.h ===
// lex_info.h
// declaration of lexicon header structure
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  03 JUL 2000   bhshin    reorder sub-lexicon
//  10 MAY 2000   bhshin    added Korean name trie
//  12 APR 2000   bhshin    added rgnCopulaEnd
//  13 MAR 2000	  bhshin	created

// current lexicon version
#define LEX_VERSION 0x0010

// lexicon filename 
#define LEXICON_FILENAME	"korwbrkr.lex"

// lexicon magin signature
#define LEXICON_MAGIC_SIG	"WBRK"

typedef struct {
	unsigned short nVersion;
	char szMagic[4];
	unsigned short nPadding;
	unsigned long rgnLastName;		// offset to last name trie
	unsigned long rgnNameUnigram;   // offset to name unigram trie
	unsigned long rgnNameBigram;    // offset to name bigram trie
	unsigned long rgnNameTrigram;   // offset to name trigram trie
    unsigned long rgnIRTrie;		// offset to main trie
	unsigned long rgnMultiTag;		// offset to multi tag table
	unsigned long rgnEndIndex;		// offset to ending rule index
	unsigned long rgnEndRule;		// offset to ending rule	
	unsigned long rgnPartIndex;		// offset to particle rule index
	unsigned long rgnPartRule;		// offset to particle rule
	unsigned long rgnCopulaEnd;		// offset to copula ending table
	unsigned long rngTrigramTag;	// offset to name trigram tag data
} LEXICON_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\lookup.h ===
// Lookup.h
//
// dictionary lookup routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#ifndef _LOOKUP_H
#define _LOOKUP_H

#include "trie.h"

BOOL DictionaryLookup(PARSE_INFO *pPI, const WCHAR *pwzInput, int cchInput, BOOL fQuery);

BOOL LookupNameFrequency(TRIECTRL *pTrieCtrl, const WCHAR *pwzName, ULONG *pulFreq);

BOOL LookupNameIndex(TRIECTRL *pTrieCtrl, const WCHAR *pwzName, int *pnIndex);

BOOL LookupTrigramTag(unsigned char *pTrigramTag, int nIndex, ULONG *pulTri, ULONG *pulBi, ULONG *pulUni);

#endif // #ifndef _LOOKUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\morpho.cpp ===
// Morpho.cpp
//
// morphotactics and weight handling routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  14 AUG 2000   bhshin    remove CheckVaFollowNoun
//  12 APR 2000   bhshin    added IsCopulaEnding
//  30 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "LexInfo.h"
#include "Morpho.h"
#include "Record.h"
#include "unikor.h"
#include "WbData.h"

// POS weight value
const int WEIGHT_POS_NF		=	10;
const int WEIGHT_POS_NO		=	10;
const int WEIGHT_POS_OTHER  =	10;

//////////////////////////////////////////////////////////////////////////////
// Function Declarations

float PredefinedMorphotactics(PARSE_INFO *pPI, WORD wLeftCat, WORD wRightCat);
BOOL IsClassXXCat(WORD wCat);
BOOL CheckVaFollowNoun(WORD_REC *pWordRec);
BOOL CheckFollwingNo(WORD_REC *pRightRec);
WORD_REC* GetRightEdgeRec(PARSE_INFO *pPI, WORD_REC *pWordRec);
WORD_REC* GetLeftEdgeRec(PARSE_INFO *pPI, WORD_REC *pWordRec);

//////////////////////////////////////////////////////////////////////////////
// Data For CheckMorphotactics

static const WCHAR *LEFT_STR1[]   = {L"\xACE0",        // 
                                     L"\xC774\xACE0"}; // 
static const WCHAR *RIGHT_STR1[]  = {L"\xC2F6",        // 
                                     L"\xC2F6\xC5B4\xD558",		   // 
									 L"\xC2F6\xC5B4\xD574",        // 
									 L"\xC2F6\xC5B4\xD558\xC5EC",  // 
                                     L"\xC788",        // 
									 L"\xACC4\xC2DC",  // 
									 L"\xACC4\xC154",  // 
									 L"\xD504",        // 
									 L"\xD30C"};       // 

static const WCHAR *LEFT_STR2[]   = {L"\x3139",        // 
                                     L"\xC77C",        //  
									 L"\xC744"};	   // 
static const WCHAR *RIGHT_STR2[]  = {L"\xBED4\xD558",		// 
                                     L"\xBED4\xD574",		// 
									 L"\xBED4\xD558\xC5EC", // 
									 L"\xB4EF\xC2F6",		// 
									 L"\xC131\xC2F6",		// 
									 L"\xB4EF\xD558",		// 
                                     L"\xB4EF\xD558\xC5EC", // 
									 L"\xB4EF\xD574",		// 
									 L"\xBC95\xD558",		// 
									 L"\xBC95\xD574",		// 
									 L"\xBC95\xD558\xC5EC", // 
									 L"\xB9CC\xD558",		// 
									 L"\xB9CC\xD574",		// 
									 L"\xB9CC\xD558\xC5EC"};// 

static const WCHAR *LEFT_STR3[]   = {L"\x3134",  // 
                                     L"\xC740",  // 
									 L"\xC778",  // 
									 L"\xB294"}; // 
static const WCHAR *RIGHT_STR3[]  = {L"\xCCB4\xD558",			// 
                                     L"\xCCB4\xD574",			// 
									 L"\xCCB4\xD558\xC5EC",		//  
									 L"\xCC99\xD558",			// 
									 L"\xCC99\xD558\xC5EC",		// 
                                     L"\xCC99\xD574",			// 
									 L"\xC591\xD558",			// 
									 L"\xC591\xD574",			// 
									 L"\xC591\xD558\xC5EC",		// 
									 L"\xB4EF\xC2F6",			// 
									 L"\xB4EF\xD558",			// 
									 L"\xB4EF\xD574",			// 
									 L"\xB4EF\xD558\xC5EC",		// 
									 L"\xC131\xC2F6",			// 
									 L"\xC148\xCE58"};			// 

static const WCHAR *LEFT_STR4[]   = {L"\xC9C0"};	// 
static const WCHAR *RIGHT_STR4[]  = {L"\xC54A"};	// 

    
static const WCHAR *LEFT_STR5[]   = {L"\xC57C",					// 
                                     L"\xC5B4\xC57C",			// 
									 L"\xC544\xC57C",			// 
									 L"\xC5EC\xC57C",			// 
									 L"\xC774\xC5B4\xC57C"};	// 
static const WCHAR *RIGHT_STR5[]  = {L"\xD558",					// 
                                     L"\xD558\xC5EC",			// 
									 L"\xD574"};				// 

static const WCHAR *LEFT_STR6[]   = {L"\xAC8C"};				// 
static const WCHAR *RIGHT_STR6[]  = {L"\xD558",					// 
                                     L"\xD558\xC5EC",			// 
									 L"\xD574",					// 
									 L"\xB418",					// 
									 L"\xB3FC"};				// 

// CompareIndexTerm
//
// compare decompose index term string with string list
//
// Parameters:
//  pwzLeft			-> (const WCHAR *) decomposed left index string
//  pwzRight		-> (const WCHAR *) decomposed right index string
//  ppwzLeftList 	-> (const WCHAR **) composed string list to compare with left
//  nLeftList		-> (int) left string list size
//  ppwzRightList 	-> (const WCHAR **) composed string list to compare with right
//  nRightList		-> (int) right string list size
//
// Result:
//  (BOOL) return TRUE if Copular Ending, otherwise return FALSE
//
// 30MAR00  bhshin  began
inline BOOL CompareIndexTerm(const WCHAR *pwzLeft, const WCHAR *pwzRight,
							 const WCHAR **ppwzLeftList, int nLeftList,
							 const WCHAR **ppwzRightList, int nRightList)
{
	int i;
	WCHAR wzLeft[MAX_INDEX_STRING+1];
	WCHAR wzRight[MAX_INDEX_STRING+1];

	compose_jamo(wzLeft, pwzLeft, MAX_INDEX_STRING);

	for (i = 0; i < nLeftList; i++)
	{
		if (wcscmp(wzLeft, ppwzLeftList[i]) == 0)
			break;
	}

	if (i == nLeftList)
		return FALSE;

	compose_jamo(wzRight, pwzRight, MAX_INDEX_STRING);

	for (i = 0; i < nRightList; i++)
	{
		if (wcscmp(wzRight, ppwzRightList[i]) == 0)
			return TRUE;
	}

	return FALSE;
}

static const WCHAR *VA_LEMMA[] = {L"\xAC00",				// 
                                  L"\xAC00\xC9C0",			// 
							      L"\xAC00\xC838",			// 
								  L"\xACC4\xC2DC",			// 
								  L"\xACC4\xC154",          // 
								  L"\xB098",				// 
								  L"\xB098\xAC00",          // 
								  L"\xB0B4",                // 
								  L"\xB193",                // 
								  L"\xB300",				// 
								  L"\xB450",                // 
								  L"\xB46C",                // 
								  L"\xB4DC\xB9AC",          // 
								  L"\xB4DC\xB824",          // 
								  L"\xB2E4\xC624",          // 
								  L"\xBA39",                // 
								  L"\xBC14\xCE58",			// 
								  L"\xBC14\xCCD0",			// 
								  L"\xBC84\xB987\xD558",	// 
								  L"\xBC84\xB987\xD574",	// 
								  L"\xBC84\xB987\xD558\xC5EC",  // 
								  L"\xBC84\xB9AC",			//  
								  L"\xBC84\xB824",			//  
								  L"\xBCF4",				//   
								  L"\xBD10",				//   
								  L"\xBE60\xC9C0",			//  
								  L"\xBE60\xC838",			// 
								  L"\xC624",				// 
								  L"\xC640",				// 
								  L"\xC788",                // 
								  L"\xC8FC",				// 
								  L"\xC918",                // 
								  L"\xC9C0",                // 
								  L"\xC838",                // 
								  L"\xD130\xC9C0",			// 
								  L"\xD130\xC838",          // 
							      L"\xD558",				// 
								  L"\xD574",				// 
								  L"\xD558\xC5EC"};			// 

inline BOOL CompareVaLemma(const WCHAR *pwzIndex)
{
	WCHAR wzLemma[MAX_ENTRY_LENGTH+1];
	
	// we should compare list with composed lemma.
	compose_jamo(wzLemma, pwzIndex, MAX_ENTRY_LENGTH);
	
	int cLemmaList = sizeof(VA_LEMMA)/sizeof(VA_LEMMA[0]);

	for (int i = 0; i < cLemmaList; i++)
	{
		if (wcscmp(wzLemma, VA_LEMMA[i]) == 0)
			return TRUE;
	}

	return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// Function Implementation

// CheckMorphotactics
//
// check morphotactics & return corresponding weight value
//
// Parameters:
// pPI	     -> (PARSE_INFO*) ptr to parse-info struct
// nLeftRec  -> (int) left side record
// nRightRec -> (int) right side record
// fQuery    -> (BOOL) query time flag
//
// Result:
//  (float) weight value, if not matched then return -1
//
// 17APR00  bhshin  changed return type
// 31MAR00  bhshin  began
float CheckMorphotactics(PARSE_INFO *pPI, int nLeftRec, int nRightRec, BOOL fQuery)
{
	WORD_REC *pLeftRec = NULL;
	WORD_REC *pRightRec = NULL;
	WORD_REC *pLeftEdgeRec = NULL;
	WORD_REC *pRightEdgeRec = NULL;
	BYTE bLeftPOS, bRightPOS;
	int cchLeft, cchRight, cNoRec;
	float fWeight;
	WCHAR wzRight[MAX_ENTRY_LENGTH+1];
	WCHAR wzLeft[MAX_ENTRY_LENGTH+1];
	
	if (pPI == NULL)
		return WEIGHT_NOT_MATCH;
	
	if (nLeftRec < MIN_RECORD || nLeftRec >= pPI->nCurrRec)
		return WEIGHT_NOT_MATCH;

	if (nRightRec < MIN_RECORD || nRightRec >= pPI->nCurrRec)
		return WEIGHT_NOT_MATCH;

	pLeftRec = &pPI->rgWordRec[nLeftRec];
	pRightRec = &pPI->rgWordRec[nRightRec];

	if (pLeftRec == NULL || pRightRec == NULL)
		return WEIGHT_NOT_MATCH;

	bLeftPOS = HIBYTE(pLeftRec->nRightCat);
	bRightPOS = HIBYTE(pRightRec->nLeftCat);

	if (bRightPOS == POS_VA && IsLeafRecord(pRightRec))
	{
		// get the right edge record of LeftRec
		pLeftEdgeRec = GetRightEdgeRec(pPI, pLeftRec);
		if (pLeftEdgeRec == NULL)
			return WEIGHT_NOT_MATCH; // error

		// get the left edge record of RightRec
		pRightEdgeRec = GetLeftEdgeRec(pPI, pRightRec);
		if (pRightEdgeRec == NULL)
			return WEIGHT_NOT_MATCH; // error
	
		if (CompareVaLemma(pRightEdgeRec->wzIndex))
		{
			// CASE I
			if (IsClassXXCat(pLeftRec->nRightCat))
			{
				cchLeft = compose_length(&pPI->pwzSourceString[pLeftEdgeRec->nFT], 
										 pLeftEdgeRec->nLT - pLeftEdgeRec->nFT + 1);

				cchRight = compose_length(&pPI->pwzSourceString[pRightEdgeRec->nFT], 
										  pRightEdgeRec->nLT - pRightEdgeRec->nFT + 1);
				
				if (cchLeft > 1 || cchRight > 1)
				{
					
					return (pLeftRec->fWeight + pRightRec->fWeight) / 3;
				}
			}

			// CASE II
			if (bLeftPOS == POS_FUNCW)
			{
				// (0x110b,0x1165), (0x110b,0x1161)
				if ((wcscmp(pLeftEdgeRec->wzIndex, L"\x110B\x1165") == 0 || 
					 wcscmp(pLeftEdgeRec->wzIndex, L"\x110B\x1161") == 0) &&
					pLeftRec->nFT > 0)
				{
					return (pLeftRec->fWeight + pRightRec->fWeight) / 3;
				}
			}
		}

		// CASE III : hard coded matching list
		if (bLeftPOS == POS_FUNCW)
		{
			if (CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR1, sizeof(LEFT_STR1)/sizeof(LEFT_STR1[0]),
								 RIGHT_STR1, sizeof(RIGHT_STR1)/sizeof(RIGHT_STR1[0])) ||
				CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR2, sizeof(LEFT_STR2)/sizeof(LEFT_STR2[0]),
								 RIGHT_STR2, sizeof(RIGHT_STR2)/sizeof(RIGHT_STR2[0])) ||
				CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR3, sizeof(LEFT_STR3)/sizeof(LEFT_STR3[0]),
								 RIGHT_STR3, sizeof(RIGHT_STR3)/sizeof(RIGHT_STR3[0])) ||			
				CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR4, sizeof(LEFT_STR4)/sizeof(LEFT_STR4[0]),
								 RIGHT_STR4, sizeof(RIGHT_STR4)/sizeof(RIGHT_STR4[0])) ||		
				CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR5, sizeof(LEFT_STR5)/sizeof(LEFT_STR5[0]),
								 RIGHT_STR5, sizeof(RIGHT_STR5)/sizeof(RIGHT_STR5[0])) ||		
				CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR6, sizeof(LEFT_STR6)/sizeof(LEFT_STR6[0]),
								 RIGHT_STR6, sizeof(RIGHT_STR6)/sizeof(RIGHT_STR6[0])))
			{
				return (pLeftRec->fWeight + pRightRec->fWeight) / 3;
			}
		}
		else if ((bLeftPOS == POS_NF || bLeftPOS == POS_NC || bLeftPOS == POS_NN || bLeftPOS == POS_NO) && 
		     CheckVaFollowNoun(pRightRec))
		{
			// recordA in {Nf Nc Nn No} & recordB in Va & CheckVaFollowNoun(recordB)
			return (pLeftRec->fWeight + pRightRec->fWeight + WEIGHT_HARD_MATCH) / 3;	
		}			
	} // if (bRightPOS == POS_VA)
	else if (bRightPOS == POS_FUNCW || bRightPOS == POS_POSP)
	{
		// get the right edge record of LeftRec
		pLeftEdgeRec = GetRightEdgeRec(pPI, pLeftRec);
		if (pLeftEdgeRec == NULL)
			return WEIGHT_NOT_MATCH; // error

		cchLeft = compose_length(&pPI->pwzSourceString[pLeftEdgeRec->nFT], 
								 pLeftEdgeRec->nLT - pLeftEdgeRec->nFT + 1);

		if ((bLeftPOS == POS_FUNCW || bLeftPOS == POS_POSP) && cchLeft > 1 &&
			IsCopulaEnding(pPI, pRightRec->nLeftCat))
		{
			return (pLeftRec->fWeight + pRightRec->fWeight + 0) / 3;
		}
		else 
		{
			// get the left edge record of RightRec
			pRightEdgeRec = GetLeftEdgeRec(pPI, pRightRec);
			if (pRightEdgeRec == NULL)
				return WEIGHT_NOT_MATCH; // error

			cchRight = compose_length(&pPI->pwzSourceString[pRightEdgeRec->nFT], 
									  pRightEdgeRec->nLT - pRightEdgeRec->nFT + 1);

			// (recordA in No && recordA is ENDING && Length(Lemma(recordB)) == 1) => block
			if (bLeftPOS != POS_NO || bRightPOS != POS_FUNCW || cchRight > 1)
			{
				fWeight = PredefinedMorphotactics(pPI, pLeftRec->nRightCat, pRightRec->nLeftCat);
				if (fWeight == WEIGHT_NOT_MATCH)
					return fWeight;

				return (pLeftRec->fWeight + pRightRec->fWeight + fWeight) / 3;
			}
		}
	} // if (bRightPOS == POS_FUNCW || bRightPOS == POS_POSP)
	else if (bRightPOS == POS_NO && IsLeafRecord(pRightRec))
	{
		compose_jamo(wzRight, pRightRec->wzIndex, MAX_ENTRY_LENGTH);
		
		if (IsOneJosaContent(*wzRight))
		{
			if ((bLeftPOS == POS_NC || bLeftPOS == POS_NF) && pLeftRec->cNoRec == 0)
			{	
				pRightRec->cNoRec = 0;
				return (pLeftRec->fWeight + pRightRec->fWeight + 10) / 3;
			}
		}
		else if (bLeftPOS == POS_NC || bLeftPOS == POS_NF || bLeftPOS == POS_NN)
		{
			if (pLeftRec->cNoRec == 0)
				return (pLeftRec->fWeight + pRightRec->fWeight + 10) / 3;
		}
		else if (bLeftPOS == POS_NO)
		{
			cNoRec = pLeftRec->cNoRec + pRightRec->cNoRec;

			if (cNoRec == 2 && CheckFollwingNo(pRightRec))
				return (pLeftRec->fWeight + pRightRec->fWeight + 10) / 3;
		}
	} // if (bRightPOS == POS_NO)
	else if (bRightPOS == POS_NF || bRightPOS == POS_NC || bRightPOS == POS_NN)
	{
		if (bLeftPOS == POS_NF || bLeftPOS == POS_NC || bLeftPOS == POS_NN)
		{
			return (pLeftRec->fWeight + pRightRec->fWeight + 10) / 3;
		}
		else if (bLeftPOS == POS_NO)
		{
			// only if query time, then don't match No + Noun
			if (fQuery)
				return WEIGHT_NOT_MATCH;
			
			compose_jamo(wzLeft, pLeftRec->wzIndex, MAX_ENTRY_LENGTH);	
			
			if (pRightRec->cNoRec == 0 && pLeftRec->nFT == 0 && 
				IsLeafRecord(pLeftRec) && IsNoPrefix(*wzLeft))
				return (pLeftRec->fWeight + pRightRec->fWeight + 10) / 3;
		}
	} // if (bRightPOS == POS_NF || bRightPOS == POS_NC || bRightPOS == POS_NN)

	return WEIGHT_NOT_MATCH;
}

// GetWeightFromPOS
//
// get the base weight value from POS
//
// Parameters:
// bPOS -> (BYTE) Part of Speech of record
//
// Result:
//  (int) defined weight value
//
// 30MAR00  bhshin  began
int GetWeightFromPOS(BYTE bPOS)
{
	if (bPOS == POS_NF)
		return WEIGHT_POS_NF;

	if (bPOS == POS_NO)
		return WEIGHT_POS_NO;

	// others (NC, NN, VA, IJ, IX, FUNCW, POSP)
	return WEIGHT_POS_OTHER;
}

// PredefinedMorphotactics
//
// check pre-defined(lexicon) morphotactics
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  wLeftCat		-> (WORD) category(POS+Infl) of left record
//  wRightCat		-> (WORD) category(POS+Infl) of right record
//
// Result:
//  (float) -1 if not matched, otherwise return WEIGHT_PRE_MORPHO(10)
//
// 30MAR00  bhshin  began
float PredefinedMorphotactics(PARSE_INFO *pPI, WORD wLeftCat, WORD wRightCat)
{
	LEXICON_HEADER *pLex;
	unsigned char *pIndex;
	unsigned char *pRules;
	BYTE bRightPOS, bRightInfl, bLeftPOS, bLeftInfl;
	int nStart, nEnd;

	pLex = (LEXICON_HEADER*)pPI->lexicon.pvData;
	if (pLex == NULL)
		return WEIGHT_NOT_MATCH;

	bLeftPOS = HIBYTE(wLeftCat);
	bLeftInfl = LOBYTE(wLeftCat);

	bRightPOS = HIBYTE(wRightCat);
	bRightInfl = LOBYTE(wRightCat);

	// we just accept NOUN/VA.
	if (bLeftPOS == POS_IJ || bLeftPOS == POS_IX || bLeftPOS == POS_FUNCW || bLeftPOS == POS_POSP)
		return WEIGHT_NOT_MATCH;
	
	if (bRightPOS == POS_FUNCW)
	{
		pIndex = (unsigned char*)pLex;
		pIndex += pLex->rgnEndIndex;

		pRules = (unsigned char*)pLex;
		pRules += pLex->rgnEndRule;
	}
	else
	{
		ATLASSERT(bRightPOS == POS_POSP);

		// it should be NOUN
		if (bLeftPOS != POS_NF && bLeftPOS != POS_NC &&
			bLeftPOS != POS_NO && bLeftPOS != POS_NN)
			return WEIGHT_NOT_MATCH;

		pIndex = (unsigned char*)pLex;
		pIndex += pLex->rgnPartIndex;

		pRules = (unsigned char*)pLex;
		pRules += pLex->rgnPartRule;
	}

	nStart = (*(pIndex + bRightInfl*2) << 8) | *(pIndex + bRightInfl*2 + 1);
	nEnd = (*(pIndex + (bRightInfl+1)*2) << 8) | *(pIndex + (bRightInfl+1)*2 + 1);

	for (int i = nStart; i < nEnd; i++)
	{
		if (*(pRules + i) == 0xFF)
		{
			i++;
			
			// it should be NOUN
			if (bLeftPOS == POS_NF || bLeftPOS == POS_NC ||
				bLeftPOS == POS_NO || bLeftPOS == POS_NN)
			{
				if (*(pRules + i) == bLeftInfl)
					return WEIGHT_HARD_MATCH;
			}
		}
		else
		{
			// if no leading 0xFF and right is Ending, then left should be VA.
			if (bRightPOS == POS_FUNCW && bLeftPOS != POS_VA)
				continue;

			if (*(pRules + i) == bLeftInfl)
				return WEIGHT_HARD_MATCH;
		}
	}

	return WEIGHT_NOT_MATCH;
}

//===============================
// CLASS XX table
//===============================

#define NUM_OF_VAINFL	52

static const BYTE rgClassXX[] = {
	0, // reserved
	1, // INFL_VERB_NULL
	0, // INFL_VERB_REG0
	0, // INFL_VERB_REG1
	0, // INFL_VERB_REG2
	1, // INFL_VERB_REG3
	1, // INFL_VERB_REG4
	0, // INFL_VERB_REG5
	0, // INFL_VERB_P0	
	0, // INFL_VERB_P1	
	1, // INFL_VERB_P2	
	0, // INFL_VERB_T0	
	0, // INFL_VERB_T1	
	0, // INFL_VERB_L0	
	0, // INFL_VERB_L1	
	0, // INFL_VERB_YE0	
	1, // INFL_VERB_YE1	
	1, // INFL_VERB_YE2	
	0, // INFL_VERB_S0	
	0, // INFL_VERB_S1	
	0, // INFL_VERB_LU0	
	1, // INFL_VERB_LU1	
	0, // INFL_VERB_U0	
	1, // INFL_VERB_U1	
	0, // INFL_VERB_LE0	
	1, // INFL_VERB_LE1	
	0, // INFL_VERB_WU0	
	1, // INFL_VERB_WU1	
	
	0, // INFL_ADJ_REG0	
	0, // INFL_ADJ_REG1	
	0, // INFL_ADJ_REG2	
	1, // INFL_ADJ_REG3	
	1, // INFL_ADJ_REG4	
	0, // INFL_ADJ_REG5	
	0, // INFL_ADJ_P0
	0, // INFL_ADJ_P1
	1, // INFL_ADJ_P2
	0, // INFL_ADJ_L0
	0, // INFL_ADJ_L1
	0, // INFL_ADJ_YE0
	1, // INFL_ADJ_YE1
	1, // INFL_ADJ_YE2
	0, // INFL_ADJ_S0
	0, // INFL_ADJ_S1
	0, // INFL_ADJ_LU0
	1, // INFL_ADJ_LU1
	0, // INFL_ADJ_U0
	1, // INFL_ADJ_U1
	0, // INFL_ADJ_LE0
	1, // INFL_ADJ_LE1
	0, // INFL_ADJ_H0
	0, // INFL_ADJ_H1
	1, // INFL_ADJ_H2
	0, // INFL_ADJ_ANI0
};


// IsClassXXCat
//
// check category included in ClassXX
//
// Parameters:
//  wCat		-> (WORD) category(POS+Infl) 
//
// Result:
//  (BOOL) return TRUE if ClassXX, otherwise return FALSE
//
// 30MAR00  bhshin  began
BOOL IsClassXXCat(WORD wCat)
{
	BYTE bPOS = HIBYTE(wCat);
	BYTE bInfl = LOBYTE(wCat);

	if (bPOS != POS_VA)
		return FALSE;

	if (bInfl >= NUM_OF_VAINFL)
		return FALSE;

	return rgClassXX[bInfl];
}

// IsCopulaEnding
//
// check input category is copula ending
//
// Parameters:
//  pPI			-> (PARSE_INFO*) ptr to parse-info struct
//  wCat		-> (WORD) category(POS+Infl) 
//
// Result:
//  (BOOL) return TRUE if Copular Ending, otherwise return FALSE
//
// 30MAR00  bhshin  began
BOOL IsCopulaEnding(PARSE_INFO *pPI, WORD wCat)
{
	LEXICON_HEADER *pLex;
	unsigned char *pCopulaEnd;
	BYTE bPOS, bInfl;

	bPOS = HIBYTE(wCat);
	bInfl = LOBYTE(wCat);

	// check ENDING
	if (bPOS != POS_FUNCW)
		return FALSE;

	// lookup copula table

	pLex = (LEXICON_HEADER*)pPI->lexicon.pvData;
	if (pLex == NULL)
		return FALSE;

	pCopulaEnd = (unsigned char*)pLex;
	pCopulaEnd += pLex->rgnCopulaEnd;

	return *(pCopulaEnd + bInfl);
}

// CheckVaFollowNoun
//
// check this VA record can follow Noun
//
// Parameters:
//  pWordRec -> (WORD_REC*) input VA record
//
// Result:
//  (BOOL) return TRUE if it can follow Noun, otherwise return FALSE
//
// 17APR00  bhshin  began
BOOL CheckVaFollowNoun(WORD_REC *pWordRec)
{
	WCHAR *pwzIndex;
	WCHAR wzIndex[MAX_INDEX_STRING];
	BOOL fStop, fResult;
	WCHAR wchPrev, wchCurr;
	
	if (pWordRec == NULL)
		return FALSE;

	// make string to compare
	compose_jamo(wzIndex, pWordRec->wzIndex, MAX_INDEX_STRING);

	// automata
	pwzIndex = wzIndex;

	fResult = FALSE;
	fStop = FALSE;
	wchPrev = L'\0';
	
	//====================================
	// //   //
	// /
	// /    /
	// /
	//          
	// /
	// /////
	// //
	//====================================
	while (*pwzIndex != L'\0')
	{
		wchCurr = *pwzIndex;

		switch (wchPrev)
		{
		case L'\0':
			// 
			if (wcsrchr(L"\xD558\xD574\xB418\xB3FC\xBC1B\xC5C6\xAC19\xC788\xC9D3\xC9C0\xB2F5 ", wchCurr))	
				fResult = TRUE;
			// 
			else if (wcsrchr(L"\xB2F9\xC2DC\xB4DC\xB9CC\xC2A4\xB2E4 ", wchCurr) == NULL)
				fStop = TRUE;
			break;
		case 0xD558: // 
			if (wchCurr != 0xC5EC)	// 
				fStop = TRUE;
			break;
		case 0xB2F9: // 
			if (wchCurr == 0xD558 || wchCurr == 0xD574) // , 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0xC2DC: // 
			if (wchCurr == 0xD0A4 || wchCurr == 0xCF1C) // , 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0xB4DC: // 
			if (wchCurr == 0xB9AC || wchCurr == 0xB824) // , 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0xB9CC: // 
			if (wchCurr == 0xB4E4  || wchCurr == 0xB4DC) // , 
			{
				fResult = TRUE;
				wchCurr = 0xB4E4; // '' make automata ambiguous, so change it to 
			}
			else
				fStop = TRUE;
			break;
		case 0xC2A4: // 
			if (wchCurr == 0xB7FD || wchCurr == 0xB7F0 || wchCurr == 0xB808) // , , 
				fResult = TRUE;
			else if (wchCurr != 0xB7EC) // 
				fStop = TRUE;
			break;
		case 0xB7EC: // 
			if (wchCurr == 0xC6B0 || wchCurr == 0xC6CC || wchCurr == 0xC774) // , , 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0xB2E4: // 
			if (wchCurr == 0xC6B0 || wchCurr == 0xC6CC) // , 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		default:
			fStop = TRUE;
			break;
		}
		
		if (fStop)
			return FALSE;

		wchPrev = wchCurr;

		pwzIndex++;
	}
	
	return fResult;
}

// CheckFollwingNo
//
// check No [ ] to combine
//
// Parameters:
//  pRightRec -> (WORD_REC*) right record
//
// Result:
//  (BOOL) return TRUE if it's [ ], otherwise return FALSE
//
// 02JUN00  bhshin  began
BOOL CheckFollwingNo(WORD_REC *pRightRec)
{
	int cchIndex;
	WCHAR *pwzIndex;

	if (pRightRec == NULL)
		return FALSE;

	// check right record
	pwzIndex = pRightRec->wzIndex;
	if (pwzIndex == NULL)
		return FALSE;

	cchIndex = wcslen(pwzIndex);
	if (cchIndex < 3)
		return FALSE;

	// recordB = [] (0x1102 + 0x1175 + 0x11B7)
	// recordB = [] (0x1103 + 0x1173 + 0x11AF)
	if ((pwzIndex[0] == 0x1102 &&
		 pwzIndex[1] == 0x1175 &&
		 pwzIndex[2] == 0x11B7) ||
		
		(pwzIndex[0] == 0x1103 && 
		 pwzIndex[1] == 0x1173 && 
		 pwzIndex[2] == 0x11AF))
	{
		return TRUE;
	}

	return FALSE;
}

// CheckValidFinal
//
// check input record is valid as final
//
// Parameters:
//  pPI			-> (PARSE_INFO*) ptr to parse-info struct
//  pWordRec -> (WORD_REC*) input record to check
//
// Result:
//  (BOOL) return TRUE if it's valid final, otherwise return FALSE
//
// 17APR00  bhshin  began
BOOL CheckValidFinal(PARSE_INFO *pPI, WORD_REC *pWordRec)
{
	int nLT;
	WORD wRightCat;

	if (pWordRec == NULL)
		return FALSE;

	nLT = pWordRec->nLT;
	wRightCat = pWordRec->nRightCat;

	if (nLT == pPI->nMaxLT && HIBYTE(wRightCat) == POS_VA && !IsClassXXCat(wRightCat))
		return FALSE;
		
	return TRUE;
}

// GetRightEdgeRec
//
// find the right most record and copy the index string of found record
//
// Parameters:
//  pPI		 -> (PARSE_INFO*) ptr to parse-info struct
//  pWordRec -> (WORD_REC*) input record to check
//
// Result:
//  (WORD_REC*) return NULL if error occurs
//
// 01JUN00  bhshin  began
WORD_REC* GetRightEdgeRec(PARSE_INFO *pPI, WORD_REC *pWordRec)
{
	int nRightChild;
	WORD_REC *pRightRec;
	
	if (pPI == NULL || pWordRec == NULL)
		return FALSE;

	pRightRec = pWordRec;
	nRightChild = pWordRec->nRightChild;

	while (nRightChild != 0)
	{
		pRightRec = &pPI->rgWordRec[nRightChild];
		if (pRightRec == NULL)
			return FALSE;
		
		nRightChild = pRightRec->nRightChild;
	}

	return pRightRec;	
}

// GetLeftEdgeRec
//
// find the left edge record and copy the index string of found record
//
// Parameters:
//  pPI		 -> (PARSE_INFO*) ptr to parse-info struct
//  pWordRec -> (WORD_REC*) input record to check
//
// Result:
//  (WORD_REC*) return NULL if error occurs
//
// 01JUN00  bhshin  began
WORD_REC* GetLeftEdgeRec(PARSE_INFO *pPI, WORD_REC *pWordRec)
{
	int nLeftChild;
	WORD_REC *pLeftRec;
	
	if (pPI == NULL || pWordRec == NULL)
		return FALSE;

	pLeftRec = pWordRec;
	nLeftChild = pWordRec->nLeftChild;

	while (nLeftChild != 0)
	{
		pLeftRec = &pPI->rgWordRec[nLeftChild];
		if (pLeftRec == NULL)
			return FALSE;
		
		nLeftChild = pLeftRec->nLeftChild;
	}

	return pLeftRec;	
}

// IsLeafRecord
//
// check input record has no child record
//
// Parameters:
//  pWordRec -> (WORD_REC*) input record to check
//
// Result:
//  (WORD_REC*) return TRUE if it has no child
//
// 05JUN00  bhshin  began
BOOL IsLeafRecord(WORD_REC *pWordRec)
{
	if (pWordRec == NULL)
		return FALSE; // error

	if (pWordRec->nLeftChild != 0 || pWordRec->nRightChild != 0)
		return FALSE; // child exist

	// it can have functional child record
	if (pWordRec->nLeftCat != pWordRec->nRightCat)
		return FALSE; // child exit

	return TRUE; // it has no child
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\morpho.h ===
// Morpho.h
//
// morphotactics and weight handling routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#ifndef _MORPHO_H
#define _MORPHO_H

// pre-defined morphotactics weight
const float WEIGHT_NOT_MATCH  =   -1;
const float WEIGHT_SOFT_MATCH	=	 0;
const float WEIGHT_VA_MATCH   =    8;
const float WEIGHT_HARD_MATCH	=	10;

float CheckMorphotactics(PARSE_INFO *pPI, int nLeftRec, int nRightRec, BOOL fQuery);
int GetWeightFromPOS(BYTE bPOS);
BOOL IsCopulaEnding(PARSE_INFO *pPI, WORD wCat);
BOOL CheckValidFinal(PARSE_INFO *pPI, WORD_REC *pWordRec);
BOOL IsLeafRecord(WORD_REC *pWordRec);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\lookup.cpp ===
// Lookup.cpp
//
// dictionary lookup routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "Lookup.h"
#include "LexInfo.h"
#include "trie.h"
#include "unikor.h"
#include "Morpho.h"
#include "WbData.h"

#define		MASK_MULTI_TAG		0x00008000
#define		MASK_TAG_INDEX		0x00007FFF

#define		SIZE_OF_TRIGRAM_TAG		7

//////////////////////////////////////////////////////////////////////////////
// function declaration

BOOL LookupIRDict(PARSE_INFO *pPI, TRIECTRL *pTrieCtrl, unsigned char *pMultiTag, 
				  const WCHAR *pwzSource, int nIndex, BOOL fQuery);

//////////////////////////////////////////////////////////////////////////////
// function implementation

// DictionaryLookup
//
// dictionary lookup and create a record for every valid word
// Before call this, InitRecord should be called
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  pwzInput		-> (const WCHAR*) input string to analyze (NOT decomposed)
//  cchInput		-> (int) length of input string to analyze
//  fQuery          -> (BOOL) flag if it's query time
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 09AUG00  bhshin  added fQuery parameter
// 30MAR00  bhshin  began
BOOL DictionaryLookup(PARSE_INFO *pPI, const WCHAR *pwzInput, int cchInput, BOOL fQuery)
{	
	LEXICON_HEADER *pLex;
	unsigned char *pIRDict;
	unsigned char *pMultiTag;
	TRIECTRL *pTrieCtrl;
	int i;

	if (pPI == NULL)
		return FALSE;

	// allocate record storage
	if (ClearRecords(pPI) == FALSE)
		return FALSE;

	pLex = (LEXICON_HEADER*)pPI->lexicon.pvData;
	if (pLex == NULL)
		return FALSE;
	
	pIRDict = (unsigned char*)pLex;
	pIRDict += pLex->rgnIRTrie;

	pMultiTag = (unsigned char*)pLex;
	pMultiTag += pLex->rgnMultiTag;

	pTrieCtrl = TrieInit((LPBYTE)pIRDict);
	if (pTrieCtrl == NULL)
		return FALSE;

	// start to lookup all the substring
	for (i = 0; i < pPI->nLen; i++)
	{
		LookupIRDict(pPI, pTrieCtrl, pMultiTag, pPI->pwzSourceString, i, fQuery);
	}

	TrieFree(pTrieCtrl);

	return TRUE;
}


// LookupIRDict
//
// lookup IR main dictionary and if entry found, then add record
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  pTrieCtrl		-> (TRIECTRL *) ptr to trie control returned by TrieInit
//  pMultiTag		-> (unsigned char*) multiple tag table
//  pwzSource		-> (const WCHAR*) input normalized(decomposed) string (NULL terminated)
//  nIndex			-> index to start search
//  fQuery          -> (BOOL) flag if it's query time
//
// Result:
//  (BOOL) TRUE if successfully entry found, FALSE otherwise
//
// 09AUG00  bhshin  added fQuery parameter
// 30MAR00  bhshin  began
BOOL LookupIRDict(PARSE_INFO *pPI, TRIECTRL *pTrieCtrl, unsigned char *pMultiTag, 
				  const WCHAR *pwzSource, int nIndex, BOOL fQuery)
{
	BOOL fResult = FALSE;
	TRIESCAN TrieScan;
	unsigned long ulFinal;
	int idxInput, idxTag;
	unsigned char cTags;
	RECORD_INFO rec;
	WCHAR wzIndex[MAX_ENTRY_LENGTH+1];
	BYTE bPOS, bInfl;
	WORD wCat;

	if (pTrieCtrl == NULL || pMultiTag == NULL)
		return FALSE;

	if (pwzSource == NULL)
		return FALSE;

    memset(&TrieScan, 0, sizeof(TRIESCAN));

	idxInput = nIndex;
	
	while (pwzSource[idxInput] != L'\0')
    {
        if (!TrieGetNextState(pTrieCtrl, &TrieScan))
            goto Exit;

        while (TrieScan.wch != pwzSource[idxInput])
        {
            if (!TrieSkipNextNode(pTrieCtrl, &TrieScan, pwzSource[idxInput]))
                goto Exit;
        }

		if (TrieScan.wFlags & TRIE_NODE_VALID)
		{
			ulFinal = TrieScan.aTags[0].dwData;

			if (ulFinal & MASK_MULTI_TAG)
			{
				// process multiple tag
				idxTag = ulFinal & MASK_TAG_INDEX;

				cTags = pMultiTag[idxTag++];

				int nTag = 0;
				while (nTag < cTags)
				{
					bPOS = pMultiTag[idxTag++];
					bInfl = pMultiTag[idxTag++];

					// on query time, we just look up NOUN rec.
					if (fQuery && !IsNounPOS(bPOS))
					{
						nTag++;
						continue; // while (nTag < cTags)
					}

					wCat = MAKEWORD(bInfl, bPOS);
					
					rec.nFT = (unsigned short)nIndex;
					rec.nLT = (unsigned short)idxInput;
					rec.nDict = DICT_FOUND;
					
					// newly added record has its cat as Left/Right cat
					rec.nLeftCat = wCat;
					rec.nRightCat = wCat;

					// newly added record has no child
					rec.nLeftChild = 0;
					rec.nRightChild = 0;

					rec.fWeight = (float)GetWeightFromPOS(bPOS);

					ATLASSERT(rec.nLT-rec.nFT+1 < MAX_ENTRY_LENGTH);

					wcsncpy(wzIndex, &pPI->pwzSourceString[rec.nFT], rec.nLT-rec.nFT+1);
					wzIndex[rec.nLT-rec.nFT+1] = L'\0';
					
					rec.pwzIndex = wzIndex;

					if (bPOS == POS_NF || bPOS == POS_NC || bPOS == POS_NN)
						rec.cNounRec = 1;
					else
						rec.cNounRec = 0;

					rec.cNoRec = 0;

					if (bPOS == POS_NO)
						rec.cNoRec = 1;

					AddRecord(pPI, &rec);

					nTag++;
				}
			}
			else
			{
				// single tag case
				wCat = (WORD)ulFinal;

				// on query time, we just look up NOUN rec.
				if (fQuery && !IsNounPOS(HIBYTE(wCat)))
				{
					idxInput++;
					continue; // while (pwzSource[idxInput] != L'\0')
				}

				rec.nFT = (unsigned short)nIndex;
				rec.nLT = (unsigned short)idxInput;
				rec.nDict = DICT_FOUND;

				// newly added record has its cat as Left/Right cat
				rec.nLeftCat = wCat;
				rec.nRightCat = wCat;

				// newly added record has no child
				rec.nLeftChild = 0;
				rec.nRightChild = 0;

				rec.fWeight = (float)GetWeightFromPOS(HIBYTE(wCat));

				ATLASSERT(rec.nLT-rec.nFT+1 < MAX_ENTRY_LENGTH);

				wcsncpy(wzIndex, &pPI->pwzSourceString[rec.nFT], rec.nLT-rec.nFT+1);
				wzIndex[rec.nLT-rec.nFT+1] = L'\0';
				
				rec.pwzIndex = wzIndex;

				bPOS = HIBYTE(wCat);

				if (bPOS == POS_NF || bPOS == POS_NC || bPOS == POS_NN)
					rec.cNounRec = 1;
				else
					rec.cNounRec = 0;

				rec.cNoRec = 0;

				if (bPOS == POS_NO)
					rec.cNoRec = 1;

				AddRecord(pPI, &rec);
			}

			fResult = TRUE;
		}

		idxInput++;
    }

Exit:
	return fResult;
}

// LookupNameFrequency
//
// look up Korean name frequency
//
// Parameters:
//  pTrieCtrl		-> (TRIECTRL *) ptr to trie
//  pwzName		    -> (const WCHAR*) input name (NULL terminated)
//  pulFreq			-> (ULONG*) output frequency value
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 02MAY00  bhshin  began
BOOL LookupNameFrequency(TRIECTRL *pTrieCtrl, const WCHAR *pwzName, ULONG *pulFreq)
{
	TRIESCAN TrieScan;
	WCHAR wzDecomp[15];
	CHAR_INFO_REC rgCharInfo[15];

	if (pTrieCtrl == NULL || pwzName == NULL)
		return FALSE;

	decompose_jamo(wzDecomp, pwzName, rgCharInfo, 15);

	if (TrieCheckWord(pTrieCtrl, &TrieScan, (WCHAR*)wzDecomp))
	{
		if (TrieScan.wFlags & TRIE_NODE_VALID)
		{
			// found. get the frequency value
			*pulFreq = TrieScan.aTags[0].dwData;
		}
		else
		{
			// not found
			*pulFreq = 0L; 
		}
	}
	else
	{
		// not found
		*pulFreq = 0L; 
	}

	return TRUE;
}

// LookupNameIndex
//
// look up Korean name index (for trigram lookup)
//
// Parameters:
//  pTrieCtrl		-> (TRIECTRL *) ptr to trie
//  pwzName		    -> (const WCHAR*) input name (NULL terminated)
//  pnIndex		    -> (int*) output index of trie (-1 means not found)
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 10MAY00  bhshin  began
BOOL LookupNameIndex(TRIECTRL *pTrieCtrl, const WCHAR *pwzName, int *pnIndex)
{
	TRIESCAN TrieScan;
	WCHAR wzDecomp[15];
	CHAR_INFO_REC rgCharInfo[15];

	if (pTrieCtrl == NULL || pwzName == NULL)
		return FALSE;

	// the key of trie is decomposed string
	decompose_jamo(wzDecomp, pwzName, rgCharInfo, 15);

	if (TrieCheckWord(pTrieCtrl, &TrieScan, (WCHAR*)wzDecomp))
	{
		if (TrieScan.wFlags & TRIE_NODE_VALID)
		{
			// found. get the frequency value
			*pnIndex = TrieScan.aTags[0].dwData;
		}
		else
		{
			// not found
			*pnIndex = -1; 
		}
	}
	else
	{
		// not found
		*pnIndex = -1; 
	}

	return TRUE;
}

// LookupNameIndex
//
// look up Korean name index (for trigram lookup)
//
// Parameters:
//  pTrigramTag	-> (unsigned char *) ptr to trie
//  nIndex		-> (int) index of data
//  pulTri		-> (ULONG*) output index of trie
//  pulBi		-> (ULONG*) output index of trie
//  pulUni		-> (ULONG*) output frequency of
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 10MAY00  bhshin  began
BOOL LookupTrigramTag(unsigned char *pTrigramTag, int nIndex, ULONG *pulTri, ULONG *pulBi, ULONG *pulUni)
{
	int idxData;
	
	if (pTrigramTag == NULL)
		return FALSE;

	if (pulTri == NULL || pulBi == NULL || pulUni == NULL)
		return FALSE;

	idxData = nIndex * SIZE_OF_TRIGRAM_TAG;

	// trigram
	*pulTri = (*(pTrigramTag + idxData++)) << 8;
	*pulTri += (*(pTrigramTag + idxData++));

	// bigram
	*pulBi = (*(pTrigramTag + idxData++)) << 8;
	*pulBi += (*(pTrigramTag + idxData++));

	// unigram
	*pulUni = (*(pTrigramTag + idxData++)) << 16;
	*pulUni += (*(pTrigramTag + idxData++)) << 8;
	*pulUni += (*(pTrigramTag + idxData++));

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by KorWbrk.rc
//
#define IDS_PROJNAME                    100
#define IDR_WORDBREAKER                 101
#define IDR_STEMMER                     102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\record.h ===
// Record.h
// record maintenance routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  02 JUN 2000   bhshin    add cNounRec, cNoRec entry in RECORD_INFO
//  17 MAR 2000	  bhshin	created

#ifndef _RECORD_H
#define _RERORD_H

// the number of records (in pWordRec) that we should allocate in a clump.
// this is used whenever we need to re-alloc the array
#define RECORD_INITIAL_SIZE 100
#define RECORD_CLUMP_SIZE   100

// the index of the first "real" record (0 is reserved)
#define MIN_RECORD  1

// nDict types
#define DICT_DELETED    0       // deleted record
#define DICT_FOUND      1       // found in dictionary
#define DICT_ADDED		2		// added while morphotactics processing 

// info about new record to create
typedef struct tagRECORD_INFO
{
	unsigned short nFT, nLT;
	unsigned char nDict;
	unsigned short nLeftCat, nRightCat;
	unsigned short nLeftChild, nRightChild;
	const WCHAR *pwzIndex;
	float fWeight;
	int cNounRec, cNoRec;
} RECORD_INFO;

// utility functions
// =====================
inline 
int IsNounPOS(int nPOS)
{ 
	return (nPOS == POS_NF || nPOS == POS_NC || nPOS == POS_NO || nPOS == POS_NN); 
}

// =======================
// Initialization Routines
// =======================

void InitRecords(PARSE_INFO *pPI);
void UninitRecords(PARSE_INFO *pPI);
BOOL ClearRecords(PARSE_INFO *pPI);

// =========================
// Adding / Removing Records
// =========================

int AddRecord(PARSE_INFO *pPI, RECORD_INFO *pRec);
void DeleteRecord(PARSE_INFO *pPI, int nRecord);

#endif // #ifndef _RECORD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\record.cpp ===
// Record.cpp
// record maintenance routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "Unikor.h"

// =======================
// internal helper function
// =======================

int comp_index_str(const WCHAR *src, const WCHAR *dst)
{
	int ret = 0;

	while (*dst)
	{
		if (*src == L'.')
			src++;

		if (*dst == L'.')
			dst++;

		if (ret = (int)(*src - *dst))
			break;

		src++;
		dst++;
	}

	if (ret == 0)
		ret = *src;

    if (ret < 0)
		ret = -1 ;
    else if (ret > 0)
        ret = 1 ;

    return ret;
}

// =======================
// Initialization Routines
// =======================

// InitRecords
//
// initialize the record-related members in the PARSE_INFO struct to
// a reasonable default value.
//
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (void)
//
// 20MAR00  bhshin  began
void InitRecords(PARSE_INFO *pPI)
{
    pPI->nMaxRec = 0;
	pPI->rgWordRec = NULL;
}

// UninitRecords
//
// cleanup any record-related members in the PARSE_INFO struct
//
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (void)
//
// 20MAR00  bhshin  began
void UninitRecords(PARSE_INFO *pPI)
{
	pPI->nMaxRec = 0;

	if (pPI->rgWordRec != NULL)
		free(pPI->rgWordRec);
	pPI->rgWordRec = NULL;
}

// ClearRecords
//
// init/re-init the record structures.
//
// this should be called once before each sentence is processed
//
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (BOOL) TRUE if succeed, FALSE otherwise
//
// 20MAR00  bhshin  began
BOOL ClearRecords(PARSE_INFO *pPI)
{
    // allocate new WordRec (or re-use an existing one)
    if (pPI->rgWordRec == NULL)
    {
        pPI->nMaxRec = RECORD_INITIAL_SIZE;
        pPI->rgWordRec = (WORD_REC*)malloc(pPI->nMaxRec * sizeof(WORD_REC));
        if (pPI->rgWordRec == NULL)
        {
            pPI->nMaxRec = 0;
            return FALSE;
        }
    }

	pPI->nCurrRec = MIN_RECORD;

	return TRUE;
}

// =========================
// Adding / Removing Records
// =========================

// AddRecord
//
// add a new record
// 
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//  pRec    -> (RECORD_INFO*) ptr to record info struct for new record
//
// Result:
//  (int) 0 if error occurs, otherwise return record index
//
// 30MAR00  bhshin  changed return type (BOOL -> index)
// 20MAR00  bhshin  began
int AddRecord(PARSE_INFO *pPI, RECORD_INFO *pRec)
{
    int nNewRecord;
    unsigned short nFT, nLT;
	unsigned char nDict;
	unsigned short nLeftCat, nRightCat;
	unsigned short nLeftChild, nRightChild;
    const WCHAR *pwzIndex;
	float fWeight;
	int cNounRec;
	int cNoRec;
	int curr;
	BYTE bLeftPOS, bRightPOS;

    nFT = pRec->nFT;
    nLT = pRec->nLT;
    fWeight = pRec->fWeight;
	nDict = pRec->nDict;
	nLeftCat = pRec->nLeftCat;
	nRightCat = pRec->nRightCat;
	nLeftChild = pRec->nLeftChild;
	nRightChild = pRec->nRightChild;
	cNoRec = pRec->cNoRec;
	cNounRec = pRec->cNounRec;
	pwzIndex = pRec->pwzIndex;

	bLeftPOS = HIBYTE(nLeftCat);
	bRightPOS = HIBYTE(nRightCat);

    if (pPI->rgWordRec == NULL)
	{
		ATLTRACE("rgWordRec == NULL\n");
		return 0;
	}

	// make sure this isn't a duplicate of another record
	for (curr = MIN_RECORD; curr < pPI->nCurrRec; curr++)
	{
		if (pPI->rgWordRec[curr].nFT == nFT && 
			pPI->rgWordRec[curr].nLT == nLT)
		{
            // exact index string match
			/*
			if (pPI->rgWordRec[curr].nRightCat == nRightCat &&
				pPI->rgWordRec[curr].nLeftCat == nLeftCat && 
				wcscmp(pPI->rgWordRec[curr].wzIndex, pwzIndex) == 0)
			{
				// duplicate record found
				return curr; 
			}
			*/

			// Nf, just one Noun and compare index string 
			if (pPI->rgWordRec[curr].cNounRec == 1 &&
				comp_index_str(pPI->rgWordRec[curr].wzIndex, pwzIndex) == 0)
			{
				if (HIBYTE(pPI->rgWordRec[curr].nLeftCat) == POS_NF &&
					HIBYTE(pPI->rgWordRec[curr].nRightCat) == POS_NF &&
					(bLeftPOS == POS_NF || bLeftPOS == POS_NC || bLeftPOS == POS_NN) &&
					(bRightPOS == POS_NF || bRightPOS == POS_NC || bRightPOS == POS_NN))
				{
					return curr;
				}
				else if (HIBYTE(pPI->rgWordRec[curr].nLeftCat) == POS_NF &&
						 (bLeftPOS == POS_NF || bLeftPOS == POS_NC || bLeftPOS == POS_NN) &&
						 pPI->rgWordRec[curr].nRightCat == nRightCat)
				{
					return curr;
				}
				else if (HIBYTE(pPI->rgWordRec[curr].nRightCat) == POS_NF &&
						 (bRightPOS == POS_NF || bRightPOS == POS_NC || bRightPOS == POS_NN) &&
						 pPI->rgWordRec[curr].nLeftCat == nLeftCat)
				{
					return curr;
				}
			}
		}
	}

    // make sure there's enough room for the new record
	if (pPI->nCurrRec >= pPI->nMaxRec)
	{
        // alloc some more space in the array
        int nNewSize = pPI->nMaxRec + RECORD_CLUMP_SIZE;
        void *pNew;
        pNew = realloc(pPI->rgWordRec, nNewSize * sizeof(WORD_REC));
        if (pNew == NULL)
        {
    		ATLTRACE("unable to malloc more records\n");
	    	return 0;
        }

        pPI->rgWordRec = (WORD_REC*)pNew;
        pPI->nMaxRec = nNewSize;
	}

    nNewRecord = pPI->nCurrRec;
    pPI->nCurrRec++;

	pPI->rgWordRec[nNewRecord].nFT = nFT;
	pPI->rgWordRec[nNewRecord].nLT = nLT;
	pPI->rgWordRec[nNewRecord].fWeight = fWeight;
	pPI->rgWordRec[nNewRecord].nDict = nDict;
	pPI->rgWordRec[nNewRecord].nLeftCat = nLeftCat;
	pPI->rgWordRec[nNewRecord].nRightCat = nRightCat;
	pPI->rgWordRec[nNewRecord].nLeftChild = nLeftChild;
	pPI->rgWordRec[nNewRecord].nRightChild = nRightChild;
	pPI->rgWordRec[nNewRecord].cNoRec = cNoRec;
	pPI->rgWordRec[nNewRecord].cNounRec = cNounRec;

	// copy index string
	if (wcslen(pwzIndex) >= MAX_INDEX_STRING)
	{
		ATLTRACE("index string is too long\n");
		pwzIndex = L"";	// empty index string
	}

	wcscpy(pPI->rgWordRec[nNewRecord].wzIndex, pwzIndex);

	return nNewRecord;
}

// DeleteRecord
//
// delete the given record
// 
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//  nRecord -> (int) index of the record to remove
//
// Result:
//  (void) 
//
// 20MAR00  bhshin  began
void DeleteRecord(PARSE_INFO *pPI, int nRecord)
{
	// don't attempt to delete records twice
    if (pPI->rgWordRec[nRecord].nDict == DICT_DELETED)
        return;

	// just mark delete record
	pPI->rgWordRec[nRecord].nDict = DICT_DELETED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A6BE11CB_1933_40BA_B930_0B3CDA65DC1B__INCLUDED_)
#define AFX_STDAFX_H__A6BE11CB_1933_40BA_B930_0B3CDA65DC1B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "globals.h"
#include "cierror.h"
#include "wblog.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A6BE11CB_1933_40BA_B930_0B3CDA65DC1B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\token.h ===
// Token.h
// Tokenizing routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 2000	  bhshin	created

#ifndef _TOEKN_H
#define _TOKEN_H

extern "C"
{
#include "ctplus.h"
}

void Tokenize(BOOL bMoreText, TEXT_SOURCE *pTextSource, int iCur, 
			  WT *pType, int *pcchTextProcessed, int *pcchHanguel);

int CheckURLPrefix(const WCHAR *pwzIndex, int cchIndex);
int GetWordPhrase(BOOL bMoreText, TEXT_SOURCE *pTextSource, int iCur);

// fIsWhiteSpace
inline int
fIsWhiteSpace(WCHAR wch)
{
	// TAB, SPACE, Ideography Space
	return  (wch == 0x0009 || wch == 0x0020 || wch == 0x3000);
}

// fIsParamark
inline int
fIsParamark(WCHAR wch)
{
	return  (wch == 0x000d || wch == 0x000a);
}

// fIsWS
inline int
fIsWS(WCHAR wch)
{
	return (fIsWhiteSpace(wch) || fIsParamark(wch) || wch == 0x0000);
}

// fIsCH
inline int
fIsCH(WCHAR wch)
{
	BYTE  ct;
	
	ct = GetCharType(wch);

	return (ct == CH || ct == VC);
}

// fIsDelimeter
inline int
fIsDelimeter(WCHAR wch)
{
	// : ; & + ^ ~ @ " " *
	switch (wch)
	{
	case 0x003A: // :
	case 0xFF1A: // full width :
	case 0x003B: // ;
	case 0xFF1B: // full width ;
	case 0x0026: // &
	case 0xFF06: // full width &
	case 0x002B: // +
	case 0xFF0B: // full width +
	case 0x005E: // ^
	case 0xFF3E: // full width ^
	case 0x007E: // ~
	case 0xFF5E: // full width ~
	case 0x0040: // @
	case 0xFF20: // full width @
	case 0x0022: // "
	case 0x201C: // left double quotation mark
	case 0x201D: // right double quotation mark
	case 0xFF02: // full width "
	case 0x002A: // *
	case 0xFF0A: // full width *
		return TRUE;
	default:
		break;
	}

	return FALSE;
}

// fIsPunc
inline int
fIsPunc(WCHAR wch)
{
	return (wch == 0x0021 || wch == 0x002C || wch == 0x002E || wch == 0x003F ||
		    wch == 0x201A || wch == 0x2026 || wch == 0x3002 ||
			wch == 0xFF01 || wch == 0xFF0C || wch == 0xFF0E || wch == 0xFF1F);
}

// fIsGroupStart
inline int
fIsGroupStart(WCHAR wchChar)
{
	BOOL fGroupStart = FALSE;
	
	switch (wchChar)
	{
	case 0x0022: // "
	case 0x0027: // '
	case L'(':
	case L'{':
	case L'[':
	case L'<':
	case 0x2018: // left single quotation mark
	case 0x201C: // left double quotation mark
	case 0xFF08: // fullwidth '('
	case 0xFF5B: // fullwidth '{'
	case 0xFF3B: // fullwidth '['
	case 0xFF1C: // fullwidth '<'
	case 0x3008: // CJK punctuation '<'
	case 0x300A: // CJK punctuation double '<'
	case 0x300C: // CJK corner bracket
	case 0x300E: // White cornder bracket
	case 0x3010: // Lenticular bracket
	case 0x3014: // Shell bracket
		fGroupStart = TRUE;
		break;
	default:
		break;
	}

	return fGroupStart;
}

// fIsGroupEnd
inline int
fIsGroupEnd(WCHAR wchChar)
{
	BOOL fGroupEnd = FALSE;
	
	switch (wchChar)
	{
	case 0x0022: // "
	case 0x0027: // '
	case L')':
	case L'}':
	case L']':
	case L'>':
	case 0x2019: // right single quotation mark
	case 0x201D: // right double quotation mark
	case 0xFF09: // fullwidth ')'
	case 0xFF5D: // fullwidth '}'
	case 0xFF3D: // fullwidth ']'
	case 0xFF1E: // fullwidth '>'
	case 0x3009: // CJK punctuation '>'
	case 0x300B: // CJK punctuation double '>'
	case 0x300D: // CJK corner bracket
	case 0x300F: // White cornder bracket
	case 0x3011: // Lenticular bracket
	case 0x3015: // Shell bracket
		fGroupEnd = TRUE;
		break;
	default:
		break;
	}

	return fGroupEnd;
}

//fIsGroup
inline int
fIsGroup(WCHAR wchChar)
{
	return (fIsGroupStart(wchChar) || fIsGroupEnd(wchChar));
}

//fIsAlpha
inline int
fIsAlpha(WCHAR wchChar)
{
	return ((wchChar >= L'A' && wchChar <= L'Z') || 
		    (wchChar >= L'a' && wchChar <= L'z') ||
			(wchChar >= 0x00C0 && wchChar <= 0x0217));
}

//fIsColon
inline int
fIsColon(WCHAR wchChar)
{
	return (wchChar == L':');
}

//fIsSlash
inline int
fIsSlash(WCHAR wchChar)
{
	return (wchChar == L'/');
}



#endif // #ifndef _TOEKN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\token.cpp ===
// Token.cpp
// Tokenizing routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Token.h"

// Tokenize
//
// tokenize input TEXT_SOURCE buffer and return token type 
// and processed string length
//
// Parameters:
//  bMoreText			-> (BOOL) flag whether dependent on callback of TEXT_SOURCE or not
//  pTextSource			-> (TEXT_SOURCE*) source text information structure
//  iCur				-> (int) current buffer pos
//  pType				-> (WT*) output token type
//  pcchTextProcessed	-> (int*) output processed text length
//  pcchHanguel         -> (int*) output processed hanguel token length
//
// Result:
//  (void)
//
// 16MAR00  bhshin  porting from CWordBreaker::Tokenize
void Tokenize(BOOL bMoreText, TEXT_SOURCE *pTextSource, int iCur, 
			  WT *pType, int *pcchTextProcessed, int *pcchHanguel)
{
    ULONG cwc, i;
    BYTE  ct;
    BOOL  fRomanWord = FALSE;
    BOOL  fHanguelWord = FALSE;
	BOOL  fHanjaWord = FALSE;
    const WCHAR *pwcInput, *pwcStem;

    *pcchTextProcessed = 0;
	*pcchHanguel = 0;
    *pType =  WT_START;

	cwc = pTextSource->iEnd - iCur;
    pwcStem = pwcInput = pTextSource->awcBuffer + iCur;

    for (i = 0; i < cwc; i++, pwcInput++) 
	{
		ct = GetCharType(*pwcInput);

		// we take VC(full width char) for CH.
		if (ct == VC)
			ct = CH;

		switch (ct) 
		{
		case CH: // alpha+num
			// check to see if there is a Hanguel word before this char
			if (fHanguelWord) 
			{
				// {Hanguel}{Romanji} -> make it one token
				fHanguelWord = FALSE;
				fRomanWord = TRUE;
				*pcchHanguel = (DWORD)(pwcInput - pwcStem);
				*pType = WT_ROMAJI;
			}

			// check to see if there is an Hanja word before this char
			if (fHanjaWord) 
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			if (!fRomanWord) 
			{
				pwcStem = pwcInput;
				fRomanWord = TRUE;
				*pType = WT_ROMAJI;
			}
			break;
		case IC: // hanja case
			// check to see if there is an English word before this char
			if (fRomanWord) 
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			// check to see if there is a Hanguel word before this char
			if (fHanguelWord) 
			{
				// {Hanguel}{Romanji} -> make it one token
				fHanguelWord = FALSE;
				fHanjaWord = TRUE;
				*pcchHanguel = (DWORD)(pwcInput - pwcStem);
				*pType = WT_ROMAJI;
			}

			if (!fHanjaWord) 
			{
				pwcStem = pwcInput;
				fHanjaWord = TRUE;
				*pType = WT_ROMAJI;
			}
			break;

		case HG:
			// check to see if there is an English word before this char
			if (fRomanWord || fHanjaWord) 
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			if (!fHanguelWord) 
			{
				pwcStem = pwcInput;
				fHanguelWord = TRUE;
				*pType = WT_HANGUEL;
			}
			break;
		case WS:
			if (fRomanWord && i < cwc-1 &&
				!fIsWS(*pwcInput) && fIsCH(*(pwcInput+1)) &&
				!fIsGroup(*pwcInput) && !fIsDelimeter(*pwcInput))
			{
				// add symbol
				break;
			}

			// handle "http://"
			if ((fIsColon(*pwcInput) || fIsSlash(*pwcInput)) && 
				fRomanWord && i < cwc-3 &&
				CheckURLPrefix(pwcStem, (int)(pwcInput-pwcStem)+3))
			{
				// add symbol
				break;
			}
						
			if (fRomanWord || fHanguelWord || fHanjaWord) 
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			*pType = WT_WORD_SEP;
			*pcchTextProcessed = 1;
			return;
		case PS:
			if (fRomanWord && i < cwc-1 &&
				!fIsWS(*pwcInput) && fIsCH(*(pwcInput+1)) &&
				!fIsGroup(*pwcInput) && !fIsDelimeter(*pwcInput))
			{
				// add symbol
				break;
			}

			if (fRomanWord || fHanguelWord || fHanjaWord) 
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			*pType = WT_PHRASE_SEP;
			*pcchTextProcessed = 1;
			return;
		default:
			if (fRomanWord || fHanguelWord || fHanjaWord)
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			*pType = WT_WORD_SEP;
			*pcchTextProcessed = 1;
			return;
		}	
	}

	if (bMoreText) 
	{
		*pcchTextProcessed = 0;
		*pType = WT_REACHEND;
	}
	else
		*pcchTextProcessed = cwc;
}

// CheckURLPrefix
//
// check URL prefix 
//
// Parameters:
//  pwzInput	-> (const WCHAR*) input string to check
//  cchInput	-> (int) length of input string to check
//
// Result:
//  (int)	length of URL prefix string
//
// 25JUL00  bhshin  created
int CheckURLPrefix(const WCHAR *pwzInput, int cchInput)
{
	// [alpha+][:][/][/] eg) http://, ftp:// 
		
	int cchPrefix = 0;

	if (cchInput <= 0)
		return 0;

    if (!fIsAlpha(pwzInput[cchPrefix]))
    {
        return 0;
    }

    while (cchPrefix < cchInput && fIsAlpha(pwzInput[cchPrefix])) 
    {
        cchPrefix++;
    }

    if (cchPrefix >= cchInput || !fIsColon(pwzInput[cchPrefix]))
    {
        return 0;
    }

	cchPrefix++;

    if (cchPrefix >= cchInput || !fIsSlash(pwzInput[cchPrefix]))
    {
        return 0;
    }
    
	cchPrefix++;

    if (cchPrefix >= cchInput || !fIsSlash(pwzInput[cchPrefix]))
    {
        return 0;
    }

	cchPrefix++;

	return cchPrefix;
}

// GetWordPhrase
//
// check URL prefix 
//
// Parameters:
//  bMoreText			-> (BOOL) flag whether dependent on callback of TEXT_SOURCE or not
//  pTextSource			-> (TEXT_SOURCE*) source text information structure
//  iCur				-> (int) current buffer pos
//
// Result:
//  (int)	length of word phrase
//
// 01AUG00  bhshin  created
int GetWordPhrase(BOOL bMoreText, TEXT_SOURCE *pTextSource, int iCur)
{
	WT Type;
	int iPos, cchToken, cchHg;
	int cchProcessed;
	
	cchProcessed = 0;
	iPos = iCur;

	while (TRUE)
	{
		Tokenize(FALSE, pTextSource, iPos, &Type, &cchToken, &cchHg);

		if (Type != WT_HANGUEL && Type != WT_ROMAJI)
			break;

		cchProcessed += cchToken;
		iPos += cchToken;
	}

	return cchProcessed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\trie.h ===
#ifndef TRIE_H
#define TRIE_H

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; lpbNode points to the first byte of the next node in this state, and
lpbDown points to the first byte referenced by the down pointer, if any */

typedef struct tagTAGDATA
{
	DWORD	cTag;			// Count of tagged nodes below this node in the subtree
	DWORD	dwData;			// Stored tagged data for this node
} TAGDATA;

#define MAXTAGS 8
#if MAXTAGS > 8
#error No more than 8 tags are allowed
#endif

typedef struct tagTRIESCAN
{
	WCHAR	wch;			// Unicode character
	WORD	wFlags;			// see below
	WORD	wMask;			// which tags are valid
	WORD	__pad0;			// 
	DWORD	cWords;			// Words in subtree (only valid if TRIE_NODE_COUNT is set)
	DWORD	cSkipWords;		// Words in subtrees ignored when following a skip pointer
	LPBYTE	lpbNode;		// Address of next byte within the compressed trie
	LPBYTE	lpbDown;		// Address referenced by down pointer, if any
	LPBYTE	lpbRight;		// Address referenced by right pointer, if any
	LPBYTE	lpbSRDown;		// Last single-ref address referenced
	TAGDATA	aTags[MAXTAGS];	// The list of tag counts/data
} TRIESCAN, *PTRIESCAN, *LPTRIESCAN;

// Trie node flags, only the lower 16 bits of the flags are saved in the trie

#define TRIE_NODE_VALID         0x00000001      // wch is the last letter of a valid word
#define TRIE_NODE_END           0x00000002      // Last node in the state (no more alternatives to wch)
#define TRIE_NODE_COUNT         0x00000004		// The count of words in the subtree is stored in the node
#define TRIE_NODE_TAGGED        0x00000008      // The node has tagged data
#define TRIE_NODE_DOWN          0x00000010      // iDown is valid (word so far is a valid prefix)
#define TRIE_NODE_RIGHT         0x00000020      // iRight is valid (word connects to a substate)
#define TRIE_DOWN_INLINE        0x00000040      // iDown omitted, since it points to next node in memory
#define TRIE_DOWN_MULTI         0x00000080      // iDown is a second reference or worse
#define TRIE_DOWN_ABS           0x00000100		// iDown is an absolute immediate offset into the trie
#define	TRIE_NODE_SKIP			0x00000200		// Either iRight is a skip pointer or EOS is a 'soft' EOS
#define	TRIE_NODE_SKIP_COUNT	0x00000400		// cSkipWords is valid

/* Macro to access the data in the node, works for dawgs and tries */

#define DAWGDATA(pdawg)       ((pdawg)->wch)
#define DAWGDOWNFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_DOWN)
#define DAWGENDFLAG(pdawg)    ((pdawg)->wFlags & TRIE_NODE_END)
#define DAWGWORDFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_VALID)

/* Fixed-length part of the compressed trie header */

typedef struct tagTRIESTATS
{
	WORD	version;						// Version of this particular compressed trie
	WORD	__pad0;							//
	BYTE	wTagsMask;						// Which tags are in use
	BYTE	wEnumMask;						// Which tags have enumeration
	BYTE	wDataMask;						// Which tags have stored data
	BYTE	cTagFields;						// Total tags in use
	WORD	cMaxWord;						// Number of characters in longest word
	WORD	cMaxState;						// Number of nodes in longest state (max alternatives)
	WORD	cCharFlagsCodesMax;             // Bytes in longest char/flags code
	WORD	cTagsCodesMax;                  // Bytes in longest tagged data code
	WORD	cMRPointersCodesMax;			// Bytes in longest MR pointer code
	WORD	cSROffsetsCodesMax;             // Bytes in longest Single-ref code
	DWORD	cWords;							// Number of words in dictionary
	DWORD	cUniqueSROffsets;               // Unique offsets in Single-ref segment
	DWORD	cUniqueCharFlags;               // Unique char/flags pairs
	DWORD	cUniqueTags;                    // Unique tagged data values
	DWORD	cUniqueMRPointers;              // Unique multi-ref pointers
	DWORD	cbHeader;						// Bytes in header & tables
	DWORD	cbTrie;							// Bytes in trie
} TRIESTATS, *PTRIESTATS, *LPTRIESTATS;

/* Primary unit of a node.  Nodes usually contain a pointer too */

typedef struct tagCHARFLAGS {
        wchar_t wch;
        short wFlags;
} CHARFLAGS, *PCHARFLAGS, *LPCHARFLAGS;

/* Control structure used to decompress the trie */

typedef struct tagTRIECTRL
{
	TRIESTATS  *lpTrieStats;				// Pointer to base of header segment
	WORD       *lpwCharFlagsCodes;			// decoding table for Char/flags
	WORD       *lpwTagsCodes;				// decoding table for tagged data
	WORD       *lpwMRPointersCodes;			// decoding table for multiref pointers
	WORD       *lpwSROffsetsCodes;			// decoding table for singleref offsets
	CHARFLAGS  *lpCharFlags;				// table to convert codes to char/flags
	DWORD      *lpwTags;					// table to convert codes to tagged data
	DWORD      *lpwMRPointers;				// table to convert codes to multiref pointers
	DWORD      *lpwSROffsets;				// table to convert codes to Singleref offsets
	BYTE       *lpbTrie;					// Pointer to the trie.
} TRIECTRL, *PTRIECTRL, *LPTRIECTRL;

/* Useful Constants */

#define TRIE_MAX_DEPTH          128     // We'll fail on any words longer than this

// The prototypes below are plain C     (this is required for use with C++)

/* Given a pointer to a mapped file or resource containing a compressed trie,
read the trie into memory, making all the allocations required */

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte);

/* Free all the allocations associated with a trie */

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl);

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI
TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

BOOL WINAPI
TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch);

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI
TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguisha valid word from a valid prefix, caller must test
wFlags for fTrieNodeValid. */

BOOL WINAPI
TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t * lpwszWord);

int WINAPI
TrieWordToIndex(
        TRIECTRL   *ptc,                // Trie in which to find word index
        wchar_t    *pwszWord            // Word for which we're looking
);

BOOL WINAPI
TrieIndexToWord(
        TRIECTRL   *ptc,                // Trie in which to find indexed word
        DWORD       nIndex,             // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int         cwc                 // Max characters in buffer (including NULL)
);

int WINAPI
TrieWordToTagIndex(
        TRIECTRL   *ptc,                // Trie in which to find word index
        wchar_t    *pwszWord,           // Word for which we're looking
        int         tag                 // Which tag to enumerate
);

BOOL WINAPI
TrieTagIndexToWord(
        TRIECTRL   *ptc,                // Trie in which to find indexed word
        DWORD       nIndex,             // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int         cwc,                // Max characters in buffer (including NULL)
        int         tag                 // Which tag to enumerate
);

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                // Returned values
        BYTE       *pbValid             // Mask for valid return values
);

int WINAPI
TriePrefixToRange(
        TRIECTRL   *ptc,                // Trie in which to find prefix range
        wchar_t    *pwszWord,           // Prefix for which we're looking
        int        *piStart				// Start of range with this prefix
);

/**** Subroutines for traversing Directed Acyclic Word Graphs ****/

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; iDown indexes the first node in the state wch transitions to. DAWG is a special
kind of trie: a "Directed Acyclic Word Graph," essentially an ending-compressed trie. */

typedef struct tagDAWGNODE
{
    DWORD   wch;            // Unicode character
    DWORD   wFlags;         // see below
    DWORD   cWords;         // Words below this node in the subtree
	DWORD	cSkipWords;		// Words below skipped nodes
    DWORD   iDown;          // Offset of first node in next state
    DWORD   iRight;         // Offset to first node in next substate
    DWORD   cTags[8];       // Count of tagged nodes below this node in the subtree
    DWORD   dwData[8];      // Stored tagged data for this node
} DAWGNODE, *PDAWGNODE, *LPDAWGNODE;

/* Given a trie and a pointer to a node in it, find the next node in that state.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. Returns a pointer to the new node, NULL if there is
no next node (i.e. if this is the end of a state).*/

DAWGNODE * WINAPI DawgGetNextNode(void *pTrie, DAWGNODE *pTrieNode);

/* From this node, find the first node in the state it points to.  This is equivalent
to traversing a down pointer or extending the word one letter and finding the first
alternative.  Returns a pointer to the first node in the new state, NULL if there is
no down pointer. To find the first state in the trie, use pTrieNode == NULL */

DAWGNODE * WINAPI DawgGetNextState(void *pTrie, DAWGNODE *pTrieNode);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns a pointer to the terminal node in pTrie Returns
NULL if there is no path through the trie that corresponds to pwszWord. To distinguish
a valid word from a valid prefix, caller must test wFlags for fTrieNodeValid. */

DAWGNODE * WINAPI DawgCheckWord(void *pTrie, wchar_t *pwszWord);

/* Walk the trie from pTrieNode, calling pfnTrieWord on every valid word.  pvParam is passed through
to pfnTrieWord.  If pfnTrieWord returns non-zero, the enumeration stops.  pwszWord must point to a
space of cwchTrieWordMax+1 wchar_t's.  To walk the entire trie, pass NULL for pTrieNode. Returns
the number of words traversed. pfnTrieWord may be null if all you want is the count of words. */

int WINAPI
DawgEnumerate(
        void *pTrie,                    // Trie to enumerate
        DAWGNODE *pTrieNodeStart,       // point to enumerate from, NULL if all
        wchar_t *pwszWord,              // buffer to hold words being enumerated
        void *pvParam,                  // parameter to pass to pfnTrieWord
        int (*pfnTrieWord)(wchar_t *pwszWord, void *pvParam)
);

// end plain C Prototypes

#ifdef __cplusplus
}
#endif

#endif // TRIE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\uni.cpp ===
// uni.cpp
// Unicode tables
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 00  bhshin   porting for WordBreaker from uni.c

#include "stdafx.h"
#include "uni.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\trie.c ===
#include "trie.h"

#ifndef UNDER_CE
#   include "assert.h"
#else
#   define assert(x)
#endif

#define fNLGNewMemory(pp,cb) ((*pp) = GlobalAlloc(GPTR, cb))       
#define NLGFreeMemory		 GlobalFree

/******************************Public*Routine******************************\
* TrieInit
*
* Given a pointer to a resource or mapped file of a mapped file this
* function allocates and initializes the trie structure.
*
* Returns NULL for failure, trie control structure pointer for success.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte)
{
    LPWORD lpwTables;
    TRIECTRL *lpTrieCtrl;
    LPTRIESTATS lpTrieStats;

    lpTrieStats = (LPTRIESTATS) lpByte;

	if (lpTrieStats == NULL)
		return(NULL);

	// Check the version number.  This code currently only supports version 1 tries  

	if (lpTrieStats->version > 1)
		return NULL;

    //
    // Allocate space for the control structure and the table of SR offsets
    //

    if (!fNLGNewMemory(&lpTrieCtrl, sizeof(TRIECTRL)))
        return NULL;

    //
    // Allocate space for the complete header, copy the fixed part and read in the rest
    //

    lpByte += lpTrieStats->cbHeader;
    lpTrieCtrl->lpTrieStats = lpTrieStats;

    //
    // Set up the table pointers (all these tables are inside the TRIECTRL allocation)
    //

    lpwTables = (LPWORD)(lpTrieStats+1);

    lpTrieCtrl->lpwCharFlagsCodes = lpwTables;
    lpwTables += lpTrieStats->cCharFlagsCodesMax;

    if (lpTrieStats->cCharFlagsCodesMax & 1)               // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwTagsCodes = lpwTables;
    lpwTables += lpTrieStats->cTagsCodesMax;

    if (lpTrieStats->cTagsCodesMax & 1)                     // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwMRPointersCodes = lpwTables;
    lpwTables += lpTrieStats->cMRPointersCodesMax;

    if (lpTrieStats->cMRPointersCodesMax & 1)               // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwSROffsetsCodes = lpwTables;
    lpwTables += lpTrieStats->cSROffsetsCodesMax;

    if (lpTrieStats->cSROffsetsCodesMax & 1)                           // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpCharFlags = (LPCHARFLAGS)lpwTables;
    lpwTables = (LPWORD)(lpTrieCtrl->lpCharFlags + lpTrieStats->cUniqueCharFlags);

    lpTrieCtrl->lpwTags = (DWORD *)lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueTags);

    lpTrieCtrl->lpwMRPointers = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueMRPointers);

    lpTrieCtrl->lpwSROffsets = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueSROffsets);

    //
    // These tables should exactly fill the allocation
    //

    if ((LPBYTE)lpwTables - (LPBYTE)lpTrieStats != (int)lpTrieStats->cbHeader)
	{	
		NLGFreeMemory(lpTrieCtrl);		
		return NULL;
	}

    //
    // Init trie pointers
    //

    lpTrieCtrl->lpbTrie = (LPBYTE)lpByte;

    return (void *)lpTrieCtrl;
}

/******************************Public*Routine******************************\
* TrieFree
*
* Free the resources allocated for the control structure.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl)
{
    //
    // Finally free the control structure and all the tables.  STILL MUST FREE THIS FOR ROM
    //

    NLGFreeMemory(lpTrieCtrl);
}

/* Deompress a single symbol using base-256 huffman from a compressed data structure. piSymbol
points to a space to hold the decompressed value, which is an index to a frequency-ordered
table of symbols (0 is most frequent).  pcCodes is a table of code lengths returned from
HuffmanComputeTable.  pbData is a pointer to memory that contains the encoded data.  The
return value is the number of bytes decoded. */

int DecompressSymbol(WORD *piSymbol, WORD *pcCodes, unsigned char *pbData)
{
    int cBytes = 0;
    WORD wCode = 0, wiSymbol = 0;

    /* At each stage in this loop, we're trying to see if we've got a length-n code.
    dwCode is which length-n code it would have to be.  If there aren't that many length-n codes,
    we have to try n+1.  To do that, we subtract the number of length-n codes and shift in
    the next byte. dwiSymbol is the symbol number of the first length-n code. */

    while (1)
    {
        wCode += *pbData++;
        ++cBytes;

        if (wCode < *pcCodes)
        {
			break;
        }
        wiSymbol += *pcCodes;
        wCode -= *pcCodes++;
        wCode <<= 8;
    }

    /* Now that dwCode is a valid number of a length-cBytes code, we can just add it to
    dwiSymbol, because we've already added the counts of the shorter codes to it. */

    wiSymbol += wCode;

    *piSymbol = wiSymbol;

    return cBytes;
}

DWORD Get3ByteAddress(BYTE *pb)
{
    return ((((pb[0] << 8) | pb[1]) << 8) | pb[2]) & 0x00ffffff;
}

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
    TRIESTATS  *lpTrieStats;
    DWORD       wOffset;
    DWORD       wOffset2;
    WORD        wCode;
    DWORD       dwCode;
    BYTE        wMask;
    BYTE        bMask;
    int         iTag;

    lpTrieStats = lpTrieCtrl->lpTrieStats;

    /* If this is an initial call, use the first byte in the trie */

    if (lpTrieScan->wFlags == 0)
    {
        lpTrieScan->lpbSRDown = 0;
        lpTrieScan->lpbNode = lpTrieCtrl->lpbTrie;
    }

    /* Decompress the char/flags */

    lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwCharFlagsCodes, lpTrieScan->lpbNode);
    lpTrieScan->wch      = lpTrieCtrl->lpCharFlags[wCode].wch;
    lpTrieScan->wFlags   = lpTrieCtrl->lpCharFlags[wCode].wFlags;

    // Decompress skip enumeration

    if (lpTrieScan->wFlags & TRIE_NODE_SKIP_COUNT)
    {
		// Values greater than 127 are really 15 or 21 bit values.

        dwCode = (DWORD) *lpTrieScan->lpbNode++;

        if (dwCode >= 0x00c0)
        {
            dwCode  = ((dwCode & 0x003f) << 15);
            dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
            dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
        }
        else if (dwCode >= 0x0080)
            dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

        lpTrieScan->cSkipWords = dwCode;
    }

    /* Code to decompress enumeration goes here */

    if (lpTrieScan->wFlags & TRIE_NODE_COUNT)
    {
		// Values greater than 127 are really 15 or 21 bit values.

        dwCode = (DWORD) *lpTrieScan->lpbNode++;

        if (dwCode >= 0x00c0)
        {
            dwCode  = ((dwCode & 0x003f) << 15);
            dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
            dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
        }
        else if (dwCode >= 0x0080)
            dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

        lpTrieScan->cWords = dwCode;

		// Decompress the tagged enumeration counts

        wMask = 1;
        for (iTag = 0; iTag < MAXTAGS; iTag++)
        {
            if (lpTrieCtrl->lpTrieStats->wEnumMask & wMask)
            {
            // Values greater than 127 are really 15 or 21 bit values.

                dwCode = (DWORD) *lpTrieScan->lpbNode++;

                if (dwCode >= 0x00c0)
                {
                    dwCode  = ((dwCode & 0x003f) << 15);
                    dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
                    dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
                }
                else if (dwCode >= 0x0080)
                    dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

                lpTrieScan->aTags[iTag].cTag = dwCode;
            }
            else
                lpTrieScan->aTags[iTag].cTag = 0;

            wMask <<= 1;
        }
    }
    else
		lpTrieScan->cWords = 0;

    // Any tagged data for this node follows the counts

    lpTrieScan->wMask = 0;

    if (lpTrieScan->wFlags & TRIE_NODE_TAGGED)
    {
		// If there is only one tagged field, the mask byte won't be stored

        if (lpTrieCtrl->lpTrieStats->cTagFields == 1)
            bMask = lpTrieCtrl->lpTrieStats->wDataMask;
        else
            bMask = *lpTrieScan->lpbNode++;

		// Now that we know which elements are stored here, pull them in their proper place

        wMask = 1;
        for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
        {
            if (lpTrieCtrl->lpTrieStats->wDataMask & bMask & wMask)
            {
                lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwTagsCodes, lpTrieScan->lpbNode);
                lpTrieScan->aTags[iTag].dwData = lpTrieCtrl->lpwTags[wCode];
                lpTrieScan->wMask |= wMask;
            }

            bMask  &= ~wMask;
            wMask <<= 1;
        }
    }

    // There are two flavors of right pointers: Multiref and Skip.

    if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
    {
        if (lpTrieScan->wFlags & TRIE_NODE_SKIP)
        {
            lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,lpTrieScan->lpbNode);
            wOffset2 = lpTrieCtrl->lpwSROffsets[wCode];     // Only add this after entire node is decompressed
        }
        else
        {
            /* Multiref: The down pointer is encoded directly */

            lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwMRPointersCodes, lpTrieScan->lpbNode);
            lpTrieScan->lpbRight = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
        }
    }
    else
        lpTrieScan->lpbRight = NULL;

    // There are 4 kinds of down pointer: Absolute, Inline, Multiref, and Singleref Offset.
    // Each requires different decompression

    if (lpTrieScan->wFlags & TRIE_DOWN_ABS)
    {
        // Immediate.  The next 3 bytes are the absolute offset from the base of the trie.

        lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + Get3ByteAddress(lpTrieScan->lpbNode);
        lpTrieScan->lpbNode += 3;
    }
    else if (lpTrieScan->wFlags & TRIE_DOWN_INLINE)
    {
        /* Inline: The down pointer points to the next sequential byte (so it isn't stored) */

        lpTrieScan->lpbSRDown = lpTrieScan->lpbDown = lpTrieScan->lpbNode;
    }
    else if (lpTrieScan->wFlags & TRIE_DOWN_MULTI)
    {
        /* Multiref: The down pointer is encoded directly */

        lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwMRPointersCodes,
                lpTrieScan->lpbNode);

        lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
    }
    else if (lpTrieScan->wFlags & TRIE_NODE_DOWN)
    {
        /* SR Offset.  The down pointer is encoded as an offset from the LAST downpointer
        into this singleref segment.  So we have to keep the old one around so we can add to it */

        lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,
                lpTrieScan->lpbNode);

        if (lpTrieScan->lpbSRDown == 0)
        {
                lpTrieScan->lpbSRDown = lpTrieScan->lpbNode;  // We offset from the end of the first node when going into a new state.
        }

        wOffset = lpTrieCtrl->lpwSROffsets[wCode];
        lpTrieScan->lpbSRDown += wOffset;
        lpTrieScan->lpbDown = lpTrieScan->lpbSRDown;
    }
    else
        lpTrieScan->lpbDown = NULL;

	// We couldn't deal with this until now, since skip pointers are always delta encoded from the end of node

    if ((lpTrieScan->wFlags & (TRIE_NODE_RIGHT | TRIE_NODE_SKIP)) == (TRIE_NODE_RIGHT | TRIE_NODE_SKIP))
        lpTrieScan->lpbRight = lpTrieScan->lpbNode + wOffset2;

} // TrieDecompressNode

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
	// Are we at EOS?

    if (lpTrieScan->wFlags & TRIE_NODE_END)
    {
		// Is this is a hard EOS?

        if (!(lpTrieScan->wFlags & TRIE_NODE_SKIP))
        {
			// If we can follow a right pointer, do so, else fail
        
            if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
                lpTrieScan->lpbNode = lpTrieScan->lpbRight;
            else
                return FALSE;
        }

		// Either we're at a soft EOS or we've followed a right pointer.
		// Both these require us to reset the SRDown for proper decompression

        lpTrieScan->lpbSRDown = 0;
    }

	// Decompress the node at return success

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

BOOL WINAPI TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch)
{
	// If this is the last node in the normal or skip state, quit here

    if (lpTrieScan->wFlags & TRIE_NODE_END)
        return FALSE;

	// If there isn't a right pointer or if the target letter is alphabetically less then
	// the current letter scan right normally.  Otherwise, follow the skip pointer.

    if (!(lpTrieScan->wFlags & TRIE_NODE_RIGHT) || (wch < lpTrieScan->wch))
        return TrieGetNextNode(lpTrieCtrl, lpTrieScan);

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode   = lpTrieScan->lpbRight;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
    /* Flags can't normally be zero; that always means "top node" */

    if (lpTrieScan->wFlags == 0)
    {
        TrieDecompressNode(lpTrieCtrl, lpTrieScan);
        return TRUE;
    }

    if (!(lpTrieScan->wFlags & TRIE_NODE_DOWN))
        return FALSE;

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode = lpTrieScan->lpbDown;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;

} // TrieGetNextState

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguish a valid word from a valid prefix, caller must test
wFlags for TRIE_NODE_VALID. */

BOOL WINAPI TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t far* lpwszWord)
{
    /* Start at the root of the trie and loop through all the letters in the word */

    memset(lpTrieScan,0,sizeof(*lpTrieScan));

    while (*lpwszWord)
    {
        /* Each new letter means we need to go to a new state.  If there is none,
                the word is not in this trie */

        if (!TrieGetNextState(lpTrieCtrl, lpTrieScan))
            return FALSE;

        /* Now we walk across the state looking for this character.  If we don't find
        it, this word is not in this trie */

        while (lpTrieScan->wch != *lpwszWord)
        {
            if (!TrieSkipNextNode(lpTrieCtrl, lpTrieScan, *lpwszWord))
                return FALSE;
        }

        ++lpwszWord;
    }

    return TRUE;

} // TrieCheckWord

// Find the index to the word in the trie.

DWORD CountWords(TRIECTRL *ptc, TRIESCAN *pts)
{
    TRIESCAN        ts     = *pts;
    DWORD           cWords = 0;

    if (!TrieGetNextState(ptc, &ts))
		return cWords;

    do
    {
        if (ts.wFlags & TRIE_NODE_VALID)
            cWords++;

        cWords += CountWords(ptc, &ts);
    } while (TrieGetNextNode(ptc, &ts));

    return cWords;
}

int WINAPI TrieWordToIndex(TRIECTRL *ptc, wchar_t *pwszWord)
{
    TRIESCAN    ts;
    int         ich = 0;
    int         index = 0;
    BOOL        bValid;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
		return FALSE;

    do
    {
        bValid = ts.wFlags & TRIE_NODE_VALID;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

			// If we reached the end of word at a valid state, return the index

            if ((pwszWord[ich] == L'\0') && ts.wFlags & TRIE_NODE_VALID)
                return index;

			// Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return -1;
        }
        else
        {
			// Now, follow the skip pointer if exist and the alphabetic character is greater then
			// the pivot point. Otherwise, goto the next node.  Add the sub tree count.  If it's cached
			// use it, otherwise compute it recursively.

            if ((ts.wFlags & TRIE_NODE_SKIP_COUNT) && (pwszWord[ich] > ts.wch))
            {
                index += ts.cSkipWords;

				// This can't fail if TRIE_NODE_SKIP_COUNT is set

                TrieSkipNextNode(ptc, &ts, pwszWord[ich]);
            }
            else
            {
                index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

                if (!TrieGetNextNode(ptc, &ts))
                    return -1;
            }
        }

		// If the node we just visited was valid, increment the index

        if (bValid)
            index++;

    } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc)
{
    TRIESCAN        ts;
    int             ich = 0;
    DWORD           cWords;
    DWORD           cSkips;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
		// If we're at the end of the buffer, fail
        if (ich + 1 >= cwc)
            return FALSE;

		// Remember this node's character

        pwszWord[ich] = ts.wch;

		// If we're on a valid word AND we've reached the index we're looking for, exit the loop

        if (ts.wFlags & TRIE_NODE_VALID)
        {
            if (!nIndex)
                break;

            nIndex--;
        }

		// Get the count of words in this subtree.
        cWords = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);
        cSkips = (ts.wFlags & TRIE_NODE_SKIP_COUNT) ? ts.cSkipWords : 0x7fffffff;

		// Scan to the right until the word count of the subtree would be greater than or equal to the index
		// we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.
		// If we can use a skip count, do so.

        if (nIndex < cWords)
        {
            if (!TrieGetNextState(ptc, &ts))
                return FALSE;

            ich++;                                  // Advance the character position
        }
        else
        {
            if (nIndex >= cSkips)
            {
                nIndex -= cSkips;

                ts.lpbSRDown = 0;
                ts.lpbNode = ts.lpbRight;
                
                TrieDecompressNode(ptc, &ts);
            }
            else
            {
                nIndex -= cWords;

                if (!TrieGetNextNode(ptc, &ts))
                    return FALSE;
            }
        }

    } while (TRUE);

    pwszWord[++ich] = L'\0';                        // Null terminate the string
    return ts.wFlags & TRIE_NODE_VALID;             // Return validity
}

int WINAPI TriePrefixToRange(TRIECTRL *ptc, wchar_t *pwszWord, int *piStart)
{
    TRIESCAN    ts;
    int         ich = 0;
    int         cnt;
    BOOL        bValid;

    memset(&ts, 0, sizeof(TRIESCAN));
	*piStart = 0;

    if (!TrieGetNextState(ptc, &ts))
        return 0;

    // Deal with special case of empty string

    if (pwszWord || !*pwszWord)
        return ptc->lpTrieStats->cWords;

    do
    {
		// Get the count of words below this prefix
        cnt = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

		// If the node we just arrived at is valid, increment the count
        bValid = ts.wFlags & TRIE_NODE_VALID;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

			// If we reached the end of prefix, return the count remaining below

            if (pwszWord[ich] == L'\0')
            {
                if (bValid)
                    cnt++;

                return cnt;
            }

			// Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return 0;
        }
        else
        {
			// Add the sub tree count.

			*piStart += cnt;

			// Try the next letter in this state

            if (!TrieGetNextNode(ptc, &ts))
                return 0;
        }

        if (bValid)
            (*piStart)++;

    } while (TRUE);
}

// TAGS

// Find the index to the word in the trie.

DWORD CountTags(TRIECTRL *ptc, TRIESCAN *pts, DWORD wMask, int iTag)
{
    TRIESCAN        ts    = *pts;
    DWORD           cTags = 0;

    if (!TrieGetNextState(ptc, &ts))
        return cTags;

    do
    {
        if (ts.wFlags & wMask)
            cTags++;

        cTags += CountTags(ptc, &ts, wMask, iTag);
    } while (TrieGetNextNode(ptc, &ts));

    return cTags;
}

int WINAPI TrieWordToTagIndex(TRIECTRL *ptc, wchar_t *pwszWord, int iTag)
{
    TRIESCAN        ts;
    int             ich = 0;
    int             index = 0;
    BOOL            bValid;
    DWORD           wMask = 1 << iTag;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
        bValid = ts.wFlags & wMask;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

			// If we reached the end of word at a valid state, return the index

            if ((pwszWord[ich] == L'\0') && ts.wFlags & wMask)
                return index;

			// Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return -1;
        }
        else
        {
			// Add the sub tree count.  If it's cached use it, otherwise compute it recursively.

            index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

            if (!TrieGetNextNode(ptc, &ts))
                return -1;
        }

		// If the node we just visited was valid, increment the index

        if (bValid)
            index++;
    } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieTagIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc, int iTag)
{
    TRIESCAN        ts;
    int             ich = 0;
    DWORD           cTags;
    DWORD           wMask = 1 << iTag;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
		// If we're at the end of the buffer, fail

        if (ich + 1 >= cwc)
            return FALSE;

		// Remember this node's character

        pwszWord[ich] = ts.wch;

		// If we're on a valid word AND we've reached the index we're looking for, exit the loop

        if (ts.wFlags & wMask)
        {
            if (!nIndex)
                break;

            nIndex--;
        }

		// Get the count of words in this subtree.

        cTags = (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

		// Scan to the right until the word count of the subtree would be greater than or equal to the index
		// we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.

        if (nIndex < cTags)
        {
            if (!TrieGetNextState(ptc, &ts))
                return FALSE;

            ich++;                                                  // Advance the character position
        }
        else
        {
            nIndex -= cTags;

            if (!TrieGetNextNode(ptc, &ts))
                return FALSE;
        }
    } while (TRUE);

    pwszWord[++ich] = L'\0';                        // Null terminate the string
    return ts.wFlags & wMask;                       // Return validity
}

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                        // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                        // Returned values
        BYTE       *pbValid                     // Mask for valid return values
)
{
	TRIESCAN        ts;
    int             iTag;
    WORD            wMask = 1;
    BYTE            bMask = ptc->lpTrieStats->wTagsMask;

    if (!TrieCheckWord(ptc, &ts, pwszWord))
        return FALSE;

    if (ts.wFlags & TRIE_NODE_TAGGED)
    {
        for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
        {
            if (ts.wMask & wMask)
            {
                    pdw[iTag] = ts.aTags[iTag].dwData;
                    bMask |= wMask;
            }

            wMask <<= 1;
        }
    }

   *pbValid = (BYTE) wMask;

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\unikor.cpp ===
// unikor.cpp
// Korean Unicode routines
// Copyright 1998-2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 00  bhshin   porting for WordBreaker from uni_kor.c

#include "stdafx.h"
#include "unikor.h"

#pragma setlocale(".949")

// Hangul Jamo Map
// this table maps from the "conjoining jamo" area (u1100 - u11F9)
// to the compatibility Jamo area (u3131 - u318E)
//
// subtract HANGUL_JAMO_BASE (u1100) before indexing into this table
// make sure the the char is not > HANGUL_JAMO_MAX (u11F9) before indexing
//
// to build the complete Unicode character, add the value from this
// table to HANGUL_xJAMO_PAGE (u3100).
//
// 30JUN99  GaryKac  created
unsigned char g_rgchXJamoMap[] = {
    0x31,       // 1100 - 
    0x32,       // 1101 - 
    0x34,       // 1102 - 
    0x37,       // 1103 - 
    0x38,       // 1104 - 
    0x39,       // 1105 - 
    0x41,       // 1106 - 
    0x42,       // 1107 - 
    0x43,       // 1108 - 
    0x45,       // 1109 - 
    0x46,       // 110A - 
    0x47,       // 110B - 
    0x48,       // 110C - 
    0x49,       // 110D - 
    0x4A,       // 110E - 
    0x4B,       // 110F - 

    0x4C,       // 1110 - 
    0x4D,       // 1111 - 
    0x4E,       // 1112 - 
    0x64,       // 1113 -  - no match, use fill
    0x65,       // 1114 - 
    0x66,       // 1115 - 
    0x64,       // 1116 -  - no match
    0x64,       // 1117 -  - no match
    0x64,       // 1118 -  - no match
    0x64,       // 1119 -  - no match
    0x40,       // 111A - 
    0x64,       // 111B -  - no match
    0x6E,       // 111C - 
    0x71,       // 111D - 
    0x72,       // 111E - 
    0x64,       // 111F -  - no match

    0x73,       // 1120 - 
    0x44,       // 1121 - 
    0x74,       // 1122 - 
    0x75,       // 1123 - 
    0x64,       // 1124 -  - no match
    0x64,       // 1125 -  - no match
    0x64,       // 1126 -  - no match
    0x76,       // 1127 - 
    0x64,       // 1128 -  - no match
    0x77,       // 1129 - 
    0x64,       // 112A -  - no match
    0x78,       // 112B - 
    0x79,       // 112C - 
    0x7A,       // 112D - 
    0x7B,       // 112E - 
    0x7C,       // 112F - 

    0x64,       // 1130 -  - no match
    0x64,       // 1131 -  - no match
    0x7D,       // 1132 - 
    0x64,       // 1133 -  - no match
    0x64,       // 1134 -  - no match
    0x64,       // 1135 -  - no match
    0x7E,       // 1136 - 
    0x64,       // 1137 -  - no match
    0x64,       // 1138 -  - no match
    0x64,       // 1139 -  - no match
    0x64,       // 113A -  - no match
    0x64,       // 113B -  - no match
    0x64,       // 113C - no match
    0x64,       // 113D - no match
    0x64,       // 113E - no match
    0x64,       // 113F - no match

    0x7F,       // 1140 - ^
    0x64,       // 1141 -  - no match
    0x64,       // 1142 -  - no match
    0x64,       // 1143 -  - no match
    0x64,       // 1144 -  - no match
    0x82,       // 1145 - 
    0x83,       // 1146 - ^
    0x84,       // 1147 - 
    0x64,       // 1148 -  - no match
    0x64,       // 1149 -  - no match
    0x64,       // 114A -  - no match
    0x64,       // 114B -  - no match
    0x64,       // 114C -  - no match
    0x64,       // 114D -  - no match
    0x64,       // 114E - no match
    0x64,       // 114F - no match

    0x64,       // 1150 - no match
    0x64,       // 1151 - no match
    0x64,       // 1152 -  - no match
    0x64,       // 1153 -  - no match
    0x64,       // 1154 - no match
    0x64,       // 1155 - no match
    0x64,       // 1156 -  - no match
    0x84,       // 1157 - 
    0x85,       // 1158 - 
    0x86,       // 1159 - 
    0x64,       // 115A - unused
    0x64,       // 115B - unused
    0x64,       // 115C - unused
    0x64,       // 115D - unused
    0x64,       // 115E - unused
    0x64,       // 115F - fill

    0x64,       // 1160 - fill
    0x4F,       // 1161 - 
    0x50,       // 1162 - 
    0x51,       // 1163 - 
    0x52,       // 1164 - 
    0x53,       // 1165 - 
    0x54,       // 1166 - 
    0x55,       // 1167 - 
    0x56,       // 1168 - 
    0x57,       // 1169 - 
    0x58,       // 116A - 
    0x59,       // 116B - 
    0x5A,       // 116C - 
    0x5B,       // 116D - 
    0x5C,       // 116E - 
    0x5D,       // 116F - 

    0x5E,       // 1170 - 
    0x5F,       // 1171 - 
    0x60,       // 1172 - 
    0x61,       // 1173 - 
    0x62,       // 1174 - 
    0x63,       // 1175 - 
    0x64,       // 1176 -  - no match
    0x64,       // 1177 -  - no match
    0x64,       // 1178 -  - no match
    0x64,       // 1179 -  - no match
    0x64,       // 117A -  - no match
    0x64,       // 117B -  - no match
    0x64,       // 117C -  - no match
    0x64,       // 117D -  - no match
    0x64,       // 117E -  - no match
    0x64,       // 117F -  - no match

    0x64,       // 1180 -  - no match
    0x64,       // 1181 -  - no match
    0x64,       // 1182 -  - no match
    0x64,       // 1183 -  - no match
    0x87,       // 1184 - 
    0x88,       // 1185 - 
    0x64,       // 1186 -  - no match
    0x64,       // 1187 -  - no match
    0x89,       // 1188 - 
    0x64,       // 1189 -  - no match
    0x64,       // 118A -  - no match
    0x64,       // 118B -  - no match
    0x64,       // 118C -  - no match
    0x64,       // 118D -  - no match
    0x64,       // 118E -  - no match
    0x64,       // 118F -  - no match

    0x64,       // 1190 -  - no match
    0x8A,       // 1191 - 
    0x8B,       // 1192 - 
    0x64,       // 1193 -  - no match
    0x8C,       // 1194 - 
    0x64,       // 1195 -  - no match
    0x64,       // 1196 -  - no match
    0x64,       // 1197 -  - no match
    0x64,       // 1198 -  - no match
    0x64,       // 1199 -  - no match
    0x64,       // 119A -  - no match
    0x64,       // 119B -  - no match
    0x64,       // 119C -  - no match
    0x64,       // 119D -  - no match
    0x8D,       // 119E - .
    0x64,       // 119F -  - no match

    0x64,       // 11A0 - . - no match
    0x8E,       // 11A1 - .
    0x64,       // 11A2 - .. - no match
    0x64,       // 11A3 - unused
    0x64,       // 11A4 - unused
    0x64,       // 11A5 - unused
    0x64,       // 11A6 - unused
    0x64,       // 11A7 - unused
    0x31,       // 11A8 - 
    0x32,       // 11A9 - 
    0x33,       // 11AA - 
    0x34,       // 11AB - 
    0x35,       // 11AC - 
    0x36,       // 11AD - 
    0x37,       // 11AE - 
    0x39,       // 11AF - 

    0x3A,       // 11B0 - 
    0x3B,       // 11B1 - 
    0x3C,       // 11B2 - 
    0x3D,       // 11B3 - 
    0x3E,       // 11B4 - 
    0x3F,       // 11B5 - 
    0x40,       // 11B6 - 
    0x41,       // 11B7 - 
    0x42,       // 11B8 - 
    0x44,       // 11B9 - 
    0x45,       // 11BA - 
    0x46,       // 11BB - 
    0x47,       // 11BC - 
    0x48,       // 11BD - 
    0x4A,       // 11BE - 
    0x4B,       // 11BF - 

    0x4C,       // 11C0 - 
    0x4D,       // 11C1 - 
    0x4E,       // 11C2 - 
    0x64,       // 11C3 -  - no match
    0x64,       // 11C4 -  - no match
    0x64,       // 11C5 -  - no match
    0x66,       // 11C6 - 
    0x67,       // 11C7 - 
    0x68,       // 11C8 - ^
    0x64,       // 11C9 -  - no match
    0x64,       // 11CA -  - no match
    0x64,       // 11CB -  - no match
    0x69,       // 11CC - 
    0x64,       // 11CD -  - no match
    0x6A,       // 11CE - 
    0x64,       // 11CF -  - no match

    0x64,       // 11D0 -  - no match
    0x64,       // 11D1 -  - no match
    0x64,       // 11D2 -  - no match
    0x6B,       // 11D3 - 
    0x64,       // 11D4 -  - no match
    0x64,       // 11D5 -  - no match
    0x64,       // 11D6 -  - no match
    0x6C,       // 11D7 - ^
    0x64,       // 11D8 -  - no match
    0x6D,       // 11D9 - 
    0x64,       // 11DA -  - no match
    0x64,       // 11DB -  - no match
    0x6E,       // 11DC - 
    0x6F,       // 11DD - 
    0x64,       // 11DE -  - no match
    0x70,       // 11DF - ^

    0x64,       // 11E0 -  - no match
    0x64,       // 11E1 -  - no match
    0x71,       // 11E2 - 
    0x64,       // 11E3 -  - no match
    0x64,       // 11E4 -  - no match
    0x64,       // 11E5 -  - no match
    0x78,       // 11E6 - 
    0x7A,       // 11E7 - 
    0x7C,       // 11E8 - 
    0x64,       // 11E9 -  - no match
    0x7D,       // 11EA - 
    0x7F,       // 11EB - ^
    0x64,       // 11EC -  - no match
    0x64,       // 11ED -  - no match
    0x80,       // 11EE - 
    0x64,       // 11EF -  - no match

    0x81,       // 11F0 - 
    0x82,       // 11F1 - 
    0x83,       // 11F2 - ^
    0x64,       // 11F3 -  - no match
    0x84,       // 11F4 - 
    0x64,       // 11F5 -  - no match
    0x64,       // 11F6 -  - no match
    0x64,       // 11F7 -  - no match
    0x64,       // 11F8 -  - no match
    0x86,       // 11F9 - 
    0x64,       // 11FA - unused
    0x64,       // 11FB - unused
    0x64,       // 11FC - unused
    0x64,       // 11FD - unused
    0x64,       // 11FE - unused
    0x64,       // 11FF - unused
};


// decompose_jamo
//
// break the precomposed hangul syllables into the composite jamo
//
// Parameters:
//  wzDst        -> (WCHAR*) ptr to output buffer
//               <- (WCHAR*) expanded (decomposed) string
//  wzSrc        -> (WCHAR*) input string to expand
//  rgCharInfo   -> (CHAR_INFO*) ptr to CharInfo buffer
//               <- (char*) CharStart info for string
//  wzMaxDst     -> (int) size of output buffer
//
// Note: this code assumes that wzDst is large enough to hold the
// decomposed string.  it should be 3x the size of wzSrc.
//
// Result:
//  (void)
//
// 16MAR00  bhshin   porting for WordBreaker
void
decompose_jamo(WCHAR *wzDst, const WCHAR *wzSrc, CHAR_INFO_REC *rgCharInfo, int nMaxDst)
{
    const WCHAR *pwzS;
    WCHAR *pwzD, wch;
    CHAR_INFO_REC *pCharInfo = rgCharInfo;
    unsigned short nToken = 0;
    
    pwzS = wzSrc;
    pwzD = wzDst;
    for (; *pwzS != L'\0'; pwzS++, nToken++)
    {
        ATLASSERT(nMaxDst > 0);
        
		wch = *pwzS;

        if (fIsHangulSyllable(wch))
        {
            int nIndex = (wch - HANGUL_PRECOMP_BASE);
            int nL, nV, nT;
            WCHAR wchL, wchV, wchT;

            nL = nIndex / (NUM_JUNGSEONG * NUM_JONGSEONG);
            nV = (nIndex % (NUM_JUNGSEONG * NUM_JONGSEONG)) / NUM_JONGSEONG;
            nT = nIndex % NUM_JONGSEONG;

            // output L
            wchL = HANGUL_CHOSEONG + nL;
            *pwzD++ = wchL;
            pCharInfo->nToken = nToken;
            pCharInfo->fValidStart = 1;
            pCharInfo->fValidEnd = 0;
            pCharInfo++;

            // output V
            wchV = HANGUL_JUNGSEONG + nV;
            *pwzD++ = wchV;
            pCharInfo->nToken = nToken;
            pCharInfo->fValidStart = 0;
			if (nT != 0)
	            pCharInfo->fValidEnd = 0;	// 3-char syllable - not a valid end
			else
	            pCharInfo->fValidEnd = 1;	// 2-char syllable - mark end as valid
            pCharInfo++;

            // output T (if present)
            if (nT != 0)
            {
                wchT = HANGUL_JONGSEONG + (nT-1);
                *pwzD++ = wchT;
	            pCharInfo->nToken = nToken;
                pCharInfo->fValidStart = 0;
                pCharInfo->fValidEnd = 1;
                pCharInfo++;
            }
        }
        else
        {
            // just copy over the char
            *pwzD++ = *pwzS;
            pCharInfo->nToken = nToken;
            pCharInfo->fValidStart = 1;
            pCharInfo->fValidEnd = 1;
            pCharInfo++;
        }
    }
    *pwzD = L'\0';
    pCharInfo->nToken = nToken;
    pCharInfo++;
}


// compose_jamo
//
// take the jamo chars and combine them into precomposed forms
//
// Parameters:
//  pwzDst  <- (WCHAR*) human-readable bit string
//  pwzSrc  -> (WCHAR*) string buffer to write output string
//  wzMaxDst -> (int) size of output buffer
//
// Result:
//  (int)  number of chars in output string
//
// 11APR00  bhshin   check output buffer overflow
// 16MAR00  bhshin   porting for WordBreaker
int
compose_jamo(WCHAR *wzDst, const WCHAR *wzSrc, int nMaxDst)
{
    const WCHAR *pwzS;
    WCHAR *pwzD, wchL, wchV, wchT, wchS;
    int nChars=0;

    pwzS = wzSrc;
    pwzD = wzDst;
    for (; *pwzS != L'\0';)
    {
        ATLASSERT(nChars < nMaxDst);

		// output buffer overflow
		if (nChars >= nMaxDst)
		{
			// make output string empty
			*wzDst = L'0';
			return 0;
		}
        
		wchL = *pwzS;
        wchV = *(pwzS+1);

        // if the L or V aren't valid, consume 1 char and continue
        if (!fIsChoSeong(wchL) || !fIsJungSeong(wchV))
        {
            if (fIsHangulJamo(wchL))
            {
                // convert from conjoining-jamo to compatibility-jamo
                wchS = g_rgchXJamoMap[wchL-HANGUL_JAMO_BASE];
                wchS += HANGUL_xJAMO_PAGE;
                *pwzD++ = wchS;
                pwzS++;
            }
            else
            {
                // just copy over the unknown char
                *pwzD++ = *pwzS++;
            }
            nChars++;
            continue;
        }

        wchL -= HANGUL_CHOSEONG;
        wchV -= HANGUL_JUNGSEONG;
        pwzS += 2;

        // calc (optional) T
        wchT = *pwzS;
        if (!fIsJongSeong(wchT))
            wchT = 0;
        else
        {
            wchT -= (HANGUL_JONGSEONG-1);
            pwzS++;
        }

        wchS = ((wchL * NUM_JUNGSEONG + wchV) * NUM_JONGSEONG) + wchT + HANGUL_PRECOMP_BASE;
        ATLASSERT(fIsHangulSyllable(wchS));
        
        *pwzD++ = wchS;
        nChars++;
    }
    *pwzD = L'\0';

    return nChars;
}

// compose_length
//
// get the composed string length of input decomposed jamo
//
// Parameters:
//  wszInput  <- (const WCHAR*) input decomposed string (NULL terminated)
//
// Result:
//  (int)  number of chars in composed string
//
// 21MAR00  bhshin   created
int 
compose_length(const WCHAR *wszInput)
{
	const WCHAR *pwzInput;
	
	pwzInput = wszInput;
	
	int cch = 0;
	while (*pwzInput != L'\0')
	{
		if (!fIsChoSeong(*pwzInput) && !fIsJongSeong(*pwzInput))
			cch++;

		pwzInput++;
	}

	return cch;
}

// compose_length
//
// get the composed string length of input decomposed jamo
//
// Parameters:
//  wszInput  <- (const WCHAR*) input decomposed string (NULL terminated)
//  cchInput  <- (int) length of input string
//
// Result:
//  (int)  number of chars in composed string
//
// 15MAY00  bhshin   created
int 
compose_length(const WCHAR *wszInput, int cchInput)
{
	const WCHAR *pwzInput;
	
	pwzInput = wszInput;
	
	int cch = 0;
	int idxInput = 0;
	while (*pwzInput != L'\0' && idxInput < cchInput)
	{
		if (!fIsChoSeong(*pwzInput) && !fIsJongSeong(*pwzInput))
			cch++;

		pwzInput++;
		idxInput++;
	}

	return cch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\uni.h ===
// uni.h
// Unicode api
// Copyright 1998 Microsoft Corp.
//
// Modification History:
//  16 MAR 00  bhshin   porting for WordBreaker from uni.c

#ifndef _UNI_H_
#define _UNI_H_

#define HANGUL_CHOSEONG         0x1100
#define HANGUL_CHOSEONG_MAX     0x1159
#define HANGUL_JUNGSEONG        0x1161
#define HANGUL_JUNGSEONG_MAX    0x11A2
#define HANGUL_JONGSEONG        0x11A8
#define HANGUL_JONGSEONG_MAX    0x11F9


// fIsC
//
// return fTrue if the given char is a consonant (ChoSeong or JungSeong)
//
// this assumes that the text has already been decomposed and
// normalized
//
// 24NOV98  GaryKac  began
__inline int
fIsC(WCHAR wch)
{
    return ((wch >= HANGUL_CHOSEONG && wch <= HANGUL_CHOSEONG_MAX) || 
		    (wch >= HANGUL_JONGSEONG && wch <= HANGUL_JONGSEONG_MAX)) ? TRUE : FALSE;
}


// fIsV
//
// return fTrue if the given char is a vowel (JongSeong)
//
// this assumes that the text has already been decomposed and
// normalized
//
// 24NOV98  GaryKac  began
__inline int
fIsV(WCHAR wch)
{
    return (wch >= HANGUL_JUNGSEONG && wch <= HANGUL_JUNGSEONG_MAX) ? TRUE : FALSE;
}


#endif  // _UNI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\wbdata.h ===
// WbData.h
//
// static data & search routines for Korean Word Breaker
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  20 APR 2000	  bhshin	created

#ifndef _WBDATA_H
#define _WBDATA_H

BOOL IsOneJosaContent(WCHAR wchInput);
BOOL IsNoPrefix(WCHAR wchInput);

#endif // #ifndef _WBDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\wbdata.cpp ===
// WbData.cpp
//
// static data & search routines for Korean Word Breaker
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  02 JUN 2000   bhshin    added IsOneJosaContentRec helper
//  20 APR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "WbData.h"
#include "unikor.h"

////////////////////////////////////////////////////////////////////////////////
// Function for binary search

int BinarySearchForWCHAR(const WCHAR *pwchrgTable, int crgTable, WCHAR wchSearch)
{
	int iLeft, iRight, iMiddle;
	int nComp;
	
	iLeft = 0;
	iRight = crgTable;

	while (iLeft <= iRight) 
	{
		iMiddle = (iLeft + iRight) >> 1;
		
		nComp = pwchrgTable[iMiddle] - wchSearch;

		if (nComp < 0) 
		{
			iLeft = iMiddle + 1;
		}
		else
		{
			if (nComp == 0) 
				return iMiddle; // found
			else if (nComp > 0) 
				iRight = iMiddle - 1;
		}
	}	

	return -1; // not found
}

////////////////////////////////////////////////////////////////////////////////
// One Josa Content Word (sorted list)

static const WCHAR wchrgOneJosaContent[] = {
	0xAC00, // 
	0xAC01, // 
	0xAC04, // 
	0xAC10, // 
	0xAC1C, // 
	0xAC1D, // 
	0xAC74, // 
	0xAC8C, // 
	0xACBD, // 
	0xACC4, // 
	0xACE0, // 
	0xACF5, // 
	0xACF6, // 
	0xACFC, // 
	0xAD00, // 
	0xAD11, // 
	0xAD6C, // 
	0xAD6D, // 
	0xAD70, // 
	0xAD8C, // 
	0xAE30, // 
	0xAE38, // 
	0xAE54, // 
	0xAECF, // 
	0xAED8, // 
	0xAF34, // 
	0xAFBC, // 
	0xB098, // 
	0xB0B4, // 
	0xB124, // 
	0xB140, // 
	0xB144, // 
	0xB2E8, // 
	0xB2F4, // 
	0xB2F9, // 
	0xB300, // 
	0xB301, // 
	0xB370, // 
	0xB3C4, // 
	0xB3D9, // 
	0xB780, // 
	0xB791, // 
	0xB825, // 
	0xB839, // 
	0xB85C, // 
	0xB85D, // 
	0xB860, // 
	0xB8CC, // 
	0xB8E8, // 
	0xB958, // 
	0xB960, // 
	0xB9AC, // 
	0xB9BC, // 
	0xB9C9, // 
	0xB9CC, // 
	0xB9DD, // 
	0xB9E1, // 
	0xB9E4, // 
	0xBA74, // 
	0xBA85, // 
	0xBAA8, // 
	0xBB38, // 
	0xBB3C, // 
	0xBBFC, // 
	0xBC18, // 
	0xBC1C, // 
	0xBC29, // 
	0xBC30, // 
	0xBC31, // 
	0xBC94, // 
	0xBC95, // 
	0xBCC4, // 
	0xBCF4, // 
	0xBCF5, // 
	0xBD80, // 
	0xBD84, // 
	0xBE44, // 
	0xBED8, // 
	0xC0AC, // 
	0xC0B0, // 
	0xC0C1, // 
	0xC0C8, // 
	0xC0DD, // 
	0xC11D, // 
	0xC120, // 
	0xC124, // 
	0xC131, // 
	0xC18C, // 
	0xC190, // 
	0xC218, // 
	0xC21C, // 
	0xC220, // 
	0xC2DC, // 
	0xC2DD, // 
	0xC2E4, // 
	0xC2EC, // 
	0xC528, // 
	0xC529, // 
	0xC544, // 
	0xC548, // 
	0xC554, // 
	0xC560, // 
	0xC561, // 
	0xC591, // 
	0xC5B4, // 
	0xC5C5, // 
	0xC5EC, // 
	0xC624, // 
	0xC625, // 
	0xC639, // 
	0xC655, // 
	0xC694, // 
	0xC695, // 
	0xC6A9, // 
	0xC6D0, // 
	0xC728, // 
	0xC774, // 
	0xC778, // 
	0xC77C, // 
	0xC784, // 
	0xC790, // 
	0xC791, // 
	0xC7A5, // 
	0xC7AC, // 
	0xC801, // 
	0xC804, // 
	0xC810, // 
	0xC815, // 
	0xC81C, // 
	0xC870, // 
	0xC871, // 
	0xC885, // 
	0xC88C, // 
	0xC8FC, // 
	0xC99D, // 
	0xC9C0, // 
	0xC9C4, // 
	0xC9C8, // 
	0xC9D1, // 
	0xC9DD, // 
	0xC9F8, // 
	0xCB5D, // 
	0xCBE4, // 
	0xCC3D, // 
	0xCC44, // 
	0xCC45, // 
	0xCC98, // 
	0xCC9C, // 
	0xCCA0, // 
	0xCCA9, // 
	0xCCAD, // 
	0xCCB4, // 
	0xCD0C, // 
	0xCE21, // 
	0xCE35, // 
	0xCE58, // 
	0xD0D5, // 
	0xD1B5, // 
	0xD30C, // 
	0xD310, // 
	0xD488, // 
	0xD48D, // 
	0xD544, // 
	0xD559, // 
	0xD560, // 
	0xD56D, // 
	0xD574, // 
	0xD589, // 
	0xD615, // 
	0xD638, // 
	0xD654, // 
	0xD68C, // 
};

BOOL IsOneJosaContent(WCHAR wchInput)
{
	int cOneJosaContent = sizeof(wchrgOneJosaContent)/sizeof(wchrgOneJosaContent[0]);
	
	if (BinarySearchForWCHAR(wchrgOneJosaContent, cOneJosaContent, wchInput) == -1)
		return FALSE;
	else
		return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
// One Josa Content Word (sorted list)

static const WCHAR wchrgNoPrefix[] = {
	0xAC00, // 
	0xACE0, // 
	0xACFC, // 
	0xAD6C, // 
	0xAE09, // 
	0xB0A8, // 
	0xB2E4, // 
	0xB300, // 
	0xBB34, // 
	0xBBF8, // 
	0xBC18, // 
	0xBC31, // 
	0xBC94, // 
	0xBCF8, // 
	0xBD80, // 
	0xBD88, // 
	0xBE44, // 
	0xC0DD, // 
	0xC120, // 
	0xC131, // 
	0xC18C, // 
	0xC18D, // 
	0xC591, // 
	0xC5EC, // 
	0xC5ED, // 
	0xC5F0, // 
	0xC655, // 
	0xC694, // 
	0xC6D0, // 
	0xC7AC, // 
	0xC800, // 
	0xC8FC, // 
	0xC900, // 
	0xC904, // 
	0xC911, // 
	0xC9DD, // 
	0xCD08, // 
	0xCD1D, // 
	0xCD5C, // 
	0xCE5C, // 
	0xD070, // 
	0xD0C8, // 
	0xD1B5, // 
	0xD53C, // 
	0xD55C, // 
	0xD587, // 
	0xD5DB, // 
	0xD638, // 
};

BOOL IsNoPrefix(WCHAR wchInput)
{
	int cNoPrefix = sizeof(wchrgNoPrefix)/sizeof(wchrgNoPrefix[0]);
	
	if (BinarySearchForWCHAR(wchrgNoPrefix, cNoPrefix, wchInput) == -1)
		return FALSE;
	else
		return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\wblog.h ===
// WbLog.cpp
//
// wordbreaker log routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  05 JUL 2000	  bhshin	created

#ifndef _WB_LOG_H
#define _WB_LOG_H

#ifdef _WB_LOG

#define WB_LOG_INIT					WbLogInit
#define WB_LOG_UNINIT				WbLogUninit
#define WB_LOG_PRINT				WbLogPrint
#define WB_LOG_PRINT_HEADER(a)		WbLogPrintHeader(a)
#define WB_LOG_PRINT_BREAK(a)		WbLogPrintBreak(a)

#define WB_LOG_START(a,b)			g_WbLog.Init(a,b)
#define WB_LOG_END					g_WbLog.Reset
#define WB_LOG_ROOT_INDEX(a,b)		g_WbLog.SetRootIndex(a,b)
#define WB_LOG_ADD_INDEX(a,b,c)		g_WbLog.AddIndex(a,b,c)
#define WB_LOG_REMOVE_INDEX(a)      g_WbLog.RemoveIndex(a)
#define WB_LOG_PRINT_ALL			g_WbLog.PrintWbLog

void WbLogInit();
void WbLogUninit();
void WbLogPrint(LPCWSTR lpwzFormat, ...);
void WbLogPrintHeader(BOOL fQuery);
void WbLogPrintBreak(int nLen);

typedef enum _tagIndexType
{
	INDEX_QUERY = 0, // query term
	INDEX_BREAK,	 // word break, sentence break
	INDEX_PREFILTER,
	INDEX_PARSE,
	INDEX_GUESS_NOUN,
	INDEX_GUESS_NF,
	INDEX_GUESS_NAME,
	INDEX_GUESS_NAME_SSI,
	INDEX_INSIDE_GROUP,
	INDEX_SYMBOL,
} INDEX_TYPE;

typedef struct _tagLogInfo
{
	WCHAR		wzIndex[MAX_INDEX_STRING+1]; // index string
	WCHAR	    wzRoot[MAX_INDEX_STRING+1];
	INDEX_TYPE  IndexType;
	BOOL		fRootChanged;
	BOOL		fPrint;

} LOG_INFO, *pLOG_INFO;

#define MAX_LOG_NUMBER	512

class CWbLog
{
// member data
private:
	LOG_INFO   m_LogInfo[MAX_LOG_NUMBER];
	WCHAR	   m_wzSource[MAX_INDEX_STRING+1]; 
	int		   m_iCurLog;
	BOOL	   m_fInit;

	WCHAR	   m_wzRootIndex[MAX_INDEX_STRING+1]; 

// method
public:
	CWbLog(){ Reset(); }

	void Reset()
	{
		m_wzRootIndex[0] = L'\0';
		m_wzSource[0] = L'\0';
		m_iCurLog = 0;
		m_fInit = FALSE;
	}

	void Init(LPCWSTR lpwzSource, int cchTextProcessed)
	{
		int cchSrc;

		cchSrc = (cchTextProcessed > MAX_INDEX_STRING) ? MAX_INDEX_STRING : cchTextProcessed;
		
		wcsncpy(m_wzSource, lpwzSource, cchSrc);
		m_wzSource[cchTextProcessed] = L'\0';

		m_iCurLog = 0;
		
		m_wzRootIndex[0] = L'\0';

		m_fInit = TRUE;
	}

	void SetRootIndex(LPCWSTR lpwzIndex, BOOL fIsRoot);
	void AddIndex(const WCHAR *pwzIndex, int cchIndex, INDEX_TYPE typeIndex);
	void RemoveIndex(const WCHAR *pwzIndex);
	void PrintWbLog(void);
};

extern CWbLog g_WbLog;

#else

#define WB_LOG_INIT					/##/
#define WB_LOG_UNINIT				/##/
#define WB_LOG_PRINT				/##/
#define WB_LOG_PRINT_HEADER			/##/
#define WB_LOG_PRINT_BREAK			/##/

#define WB_LOG_START(a,b)			/##/
#define WB_LOG_END					/##/
#define WB_LOG_ROOT_INDEX(a,b)		/##/
#define WB_LOG_ADD_INDEX(a,b,c)		/##/
#define WB_LOG_REMOVE_INDEX(a)      /##/
#define WB_LOG_PRINT_ALL			/##/

#endif // #ifdef _WB_LOG

#endif // #ifndef _WB_LOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\unikor.h ===
// unikor.h
// unicode tables and compose/decompose routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  21 MAR 00  bhshin   added compose_length function
//  16 MAR 00  bhshin   porting for WordBreaker from uni_kor.h

#ifndef _UNIKOR_H_
#define _UNIKOR_H_

// Conjoining Jamo range
#define HANGUL_JAMO_BASE    0x1100
#define HANGUL_JAMO_MAX     0x11F9

#define HANGUL_CHOSEONG         0x1100
#define HANGUL_CHOSEONG_MAX     0x1159
#define HANGUL_JUNGSEONG        0x1161
#define HANGUL_JUNGSEONG_MAX    0x11A2
#define HANGUL_JONGSEONG        0x11A8
#define HANGUL_JONGSEONG_MAX    0x11F9

#define HANGUL_FILL_CHO     0x115F
#define HANGUL_FILL_JUNG    0x1160

#define NUM_CHOSEONG        19  // (L) Leading Consonants
#define NUM_JUNGSEONG       21  // (V) Vowels
#define NUM_JONGSEONG       28  // (T) Trailing Consonants

// Compatibility Jamo range
#define HANGUL_xJAMO_PAGE   0x3100
#define HANGUL_xJAMO_BASE   0x3131
#define HANGUL_xJAMO_MAX    0x318E

// Pre-composed forms
#define HANGUL_PRECOMP_BASE 0xAC00
#define HANGUL_PRECOMP_MAX  0xD7A3

// Halfwidth compatibility range
#define HANGUL_HALF_JAMO_BASE   0xFFA1
#define HANGUL_HALF_JAMO_MAX    0xFFDC

// function prototypes
void decompose_jamo(WCHAR *wzDst, const WCHAR *wzSrc, CHAR_INFO_REC *rgCharInfo, int nMaxDst);
int compose_jamo(WCHAR *wzDst, const WCHAR *wzSrc, int nMaxDst);
int compose_length(const WCHAR *wszInput);
int compose_length(const WCHAR *wszInput, int cchInput);

// fIsHangulJamo
//
// return TRUE if the given char is a hangul jamo char
//
// this assumes that the text has already been decomposed and
// normalized
//
// 23NOV98  GaryKac  began
__inline int
fIsHangulJamo(WCHAR wch)
{
    return (wch >= HANGUL_JAMO_BASE && wch <= HANGUL_JAMO_MAX) ? TRUE : FALSE;
}


// fIsHangulSyllable
//
// return TRUE if the given char is a precomposed hangul syllable
//
// 23NOV98  GaryKac  began
__inline int
fIsHangulSyllable(WCHAR wch)
{
    return (wch >= HANGUL_PRECOMP_BASE && wch <= HANGUL_PRECOMP_MAX) ? TRUE : FALSE;
}


// fIsOldHangulJamo
//
// return TRUE if the given char is a old (compatibility) Jamo with
// no conjoining semantics
//
// 23NOV98  GaryKac  began
__inline int
fIsOldHangulJamo(WCHAR wch)
{
    return (wch >= HANGUL_xJAMO_BASE && wch <= HANGUL_xJAMO_MAX) ? TRUE : FALSE;
}


// fIsHalfwidthJamo
//
// return TRUE if the given char is a halfwidth Jamo
//
// 23NOV98  GaryKac  began
__inline int
fIsHalfwidthJamo(WCHAR wch)
{
    return (wch >= HANGUL_HALF_JAMO_BASE && wch <= HANGUL_HALF_JAMO_MAX) ? TRUE : FALSE;
}


// fIsChoSeong
//
// return TRUE if the given char is a ChoSeong (Leading Consonant)
//
// this assumes that the text has already been decomposed and
// normalized
//
// 23NOV98  GaryKac  began
__inline int
fIsChoSeong(WCHAR wch)
{
    return (wch >= HANGUL_CHOSEONG && wch <= HANGUL_CHOSEONG_MAX) ? TRUE : FALSE;
}


// fIsJungSeong
//
// return TRUE if the given char is a JungSeong (Vowel)
//
// this assumes that the text has already been decomposed and
// normalized
//
// 23NOV98  GaryKac  began
__inline int
fIsJungSeong(WCHAR wch)
{
    return (wch >= HANGUL_JUNGSEONG && wch <= HANGUL_JUNGSEONG_MAX) ? TRUE : FALSE;
}


// fIsJongSeong
//
// return TRUE if the given char is a JongSeong (Trailing Consonant)
//
// this assumes that the text has already been decomposed and
// normalized
//
// 23NOV98  GaryKac  began
__inline int
fIsJongSeong(WCHAR wch)
{
    return (wch >= HANGUL_JONGSEONG && wch <= HANGUL_JONGSEONG_MAX) ? TRUE : FALSE;
}


#endif  // _UNIKOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\wblog.cpp ===
// WbLog.cpp
//
// wordbreaker log routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  05 JUL 2000	  bhshin	created

#include "stdafx.h"
#include "KorWbrk.h"
#include "WbLog.h"
#include "unikor.h"
#include <stdio.h>

#ifdef _WB_LOG

#define MAX_LOG_LENGTH	1024

// global variables
static HANDLE g_hWbLog = INVALID_HANDLE_VALUE;
static const char g_szWbLogFile[] = "_wb_log.txt";

CWbLog g_WbLog;

// WbLogInit
//
// create & initialize log file
//
// Parameters:
//
// Result:
//  (void)
//
// 05JUL00  bhshin  created
void WbLogInit()
{
	DWORD dwWritten;
	static const BYTE szBOM[] = {0xFF, 0xFE};

	// initialize log level
	g_hWbLog = CreateFile(g_szWbLogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, 
		                  CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (g_hWbLog == INVALID_HANDLE_VALUE) 
		return;

	// write BOM
	if (!WriteFile(g_hWbLog, &szBOM, 2, &dwWritten, 0))
	{
		CloseHandle(g_hWbLog);
		g_hWbLog = INVALID_HANDLE_VALUE;
		return;
	}

	return;
}

// WbLogUninit
//
// uninitialize log file
//
// Parameters:
//
// Result:
//  (void)
//
// 05JUL00  bhshin  created
void WbLogUninit()
{
	if (g_hWbLog != INVALID_HANDLE_VALUE)
		CloseHandle(g_hWbLog);
}

// WbLogPrint
//
// print log string
//
// Parameters:
//  lpwzFormat -> (LPCWSTR) input log format
//
// Result:
//  (void)
//
// 05JUL00  bhshin  created
void WbLogPrint(LPCWSTR lpwzFormat, ...)
{
	va_list args;
	int nBuf, cchBuffer;
	WCHAR wzBuffer[MAX_LOG_LENGTH];
	DWORD dwWritten;

	va_start(args, lpwzFormat);

	nBuf = _vsnwprintf(wzBuffer, MAX_LOG_LENGTH, lpwzFormat, args);

	// was there an error? was the expanded string too long?
	if (nBuf < 0)
	{
		va_end(args);
		return;
	}

	if (g_hWbLog == INVALID_HANDLE_VALUE)
	{
		va_end(args);
		return;
	}

	cchBuffer = wcslen(wzBuffer);

	if (cchBuffer > 0)
	{
		WriteFile(g_hWbLog, wzBuffer, cchBuffer*2, &dwWritten, 0);
	}

	va_end(args);
}

// WbLogPrintHeader
//
// print log header
//
// Parameters:
//  fQuery -> (BOOL) Query flag of IWordBreak::Init
//
// Result:
//  (void)
//
// 06JUL00  bhshin  created
void WbLogPrintHeader(BOOL fQuery)
{
	WbLogPrint(L"\r\n");
	WbLogPrintBreak(100);
	WbLogPrint(L"fQuery = %s\r\n\r\n", fQuery ? L"TRUE" : L"FALSE");
	WbLogPrint(L"\r\n");
	WbLogPrint(L"%-15s %-15s %-20s [%s]", L"Input Token", L"Index Term", L"Root Index String", L"Index Type");
	WbLogPrint(L"\r\n");
	WbLogPrintBreak(100);
}

// WbLogPrintBreak
//
// print log header
//
// Parameters:
//	nLen -> (int) length of break string
//
// Result:
//  (void)
//
// 07JUL00  bhshin  created
void WbLogPrintBreak(int nLen)
{
	WCHAR wzBuffer[MAX_LOG_LENGTH];	
	
	memset(wzBuffer, '?', sizeof(WCHAR)*nLen);

	_wcsnset(wzBuffer, L'-', nLen);
	wzBuffer[nLen] = L'\0';

	WbLogPrint(L"%s\r\n", wzBuffer);
}

// CWbLog::SetRootIndex
//
// set top record's index string when TraverseIndexString
//
// Parameters:
//	 lpwzIndex	-> (const WCHAR*) decomposed index string
//   fIsRoot    -> (BOOL) top index flag
//
// Result:
//  (void)
//
// 07JUL00  bhshin  created
void CWbLog::SetRootIndex(LPCWSTR lpwzIndex, BOOL fIsRoot)
{ 
	WCHAR wzRoot[MAX_INDEX_STRING]; 

	if (fIsRoot && /*wcslen(m_wzRootIndex) > 0 &&*/ m_iCurLog > 0)
	{
		// root changed
		m_LogInfo[m_iCurLog-1].fRootChanged = TRUE;
	}

	compose_jamo(wzRoot, lpwzIndex, MAX_INDEX_STRING);
	wcscpy(m_wzRootIndex, wzRoot);
}

// CWbLog::AddIndex
//
// add index term
//
// Parameters:
//	 pwzIndex	-> (const WCHAR*) index term string
//   cchIndex   -> (int) length of index term
//	 typeIndex  -> (INDEX_TYPE) index type
//
// Result:
//  (void)
//
// 05JUL00  bhshin  created
void CWbLog::AddIndex(const WCHAR *pwzIndex, int cchIndex, INDEX_TYPE typeIndex)
{
	if (m_iCurLog >= MAX_LOG_NUMBER)
		return;

	if (cchIndex >= MAX_INDEX_STRING)
		return;

	wcsncpy(m_LogInfo[m_iCurLog].wzIndex, pwzIndex, cchIndex);
	m_LogInfo[m_iCurLog].wzIndex[cchIndex] = L'\0';

	wcscpy(m_LogInfo[m_iCurLog].wzRoot, m_wzRootIndex);
	m_LogInfo[m_iCurLog].IndexType = typeIndex;

	m_LogInfo[m_iCurLog].fRootChanged = FALSE;

	m_iCurLog++;
}

// CWbLog::RemoveIndex
//
// add index term
//
// Parameters:
//	 pwzIndex	-> (const WCHAR*) index term string
//
// Result:
//  (void)
//
// 30AUG00  bhshin  created
void CWbLog::RemoveIndex(const WCHAR *pwzIndex)
{
	for (int i = 0; i < m_iCurLog; i++)
	{
		if (wcscmp(m_LogInfo[i].wzIndex, pwzIndex) == 0)
		{
			m_LogInfo[i].fPrint = FALSE; // delete it
		}
	}
}

// CWbLog::PrintWbLog
//
// add index term
//
// Parameters:
//
// Result:
//  (void)
//
// 05JUL00  bhshin  created
void CWbLog::PrintWbLog()
{
	DWORD dwWritten;
	static WCHAR *rgwzIndexType[] = 
	{
		L"Query",			// INDEX_QUERY
		L"Break",			// INDEX_BREAK
		L"PreFilter",       // INDEX_PREFILTER
		L"Parse",			// INDEX_PARSE
		L"GuessNoun",		// INDEX_GUESS_NOUN
		L"GuessNF",			// INDEX_GUESS_NF
		L"GuessName",		// INDEX_GUESS_NAME
		L"GuessNameSSI",	// INDEX_GUESS_NAME_SSI
		L"GuessGroup",		// INDEX_INSIDE_GROUP
		L"Symbol",			// INDEX_SYMBOL
	};

	if (g_hWbLog == INVALID_HANDLE_VALUE)
		return; // not initialized

	if (m_iCurLog == 0)
	{
		WCHAR wzBuffer[MAX_LOG_LENGTH];

		swprintf(wzBuffer, 
				 L"%-15s %-15s %-5s\r\n", 
				 m_wzSource, 
				 L"NoIndex", 
				 m_wzRootIndex);

		WriteFile(g_hWbLog, wzBuffer, wcslen(wzBuffer)*2, &dwWritten, NULL);

		WbLogPrintBreak(100);
		
		return;
	}

	for (int i = 0; i < m_iCurLog; i++)
	{
		WCHAR wzBuffer[MAX_LOG_LENGTH];

		swprintf(wzBuffer, 
				 L"%-15s %-15s %-20s [%s]\r\n", 
				 m_wzSource, 
				 m_LogInfo[i].wzIndex, 
				 m_LogInfo[i].wzRoot,
				 rgwzIndexType[m_LogInfo[i].IndexType]);

		WriteFile(g_hWbLog, wzBuffer, wcslen(wzBuffer)*2, &dwWritten, NULL);

		if (i == m_iCurLog-1)
			break;

		if (m_LogInfo[i].fRootChanged ||
			m_LogInfo[i].IndexType != m_LogInfo[i+1].IndexType)
		{
			WbLogPrint(L"%20s", L" ");
			WbLogPrintBreak(80);
		}
	}

	WbLogPrintBreak(100);
}

#endif // #ifdef _WB_LOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cbreaktree.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CBreakTree - class CBreakTree 
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CBREAKTREE_HPP_
#define _CBREAKTREE_HPP_

class CBreakTree
{
public:
	virtual void Init(CTrie* pTrie, CTrie* pTrigramTrie) = 0;
    virtual unsigned int TrigramBreak(WCHAR* pwchBegin, WCHAR* pwchEnd) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cfilemanager.cpp ===
//------------------------------------------------------------------------------------------
//	CFileManager.cpp
//
//	A managing map files.
//
//  Created By: aarayas
//
//  History: 01/12/2001
//
//------------------------------------------------------------------------------------------
#include "CFileManager.h"

//------------------------------------------------------------------------------------------
//	CFileManager::CFileManager
//
//	Initialize a CFileManager
//
//--------------------------------------------------------------------------- aarayas ------
CFileManager::CFileManager()
{
	m_fFileOpen = false;
	m_hFile = NULL;
	m_hFileMap = NULL;
	m_dwFileSize1 = 0;
	m_dwFileSize2 = 0;
	m_pMem = NULL;
}

//------------------------------------------------------------------------------------------
//	CFileManager::CFileManager
//
//	Initialize a CFileManager
//
//--------------------------------------------------------------------------- aarayas ------
CFileManager::~CFileManager()
{
	if (m_fFileOpen)
	{
		Close();
	}
}

//------------------------------------------------------------------------------------------
//	CFileManager::Load
//
//	Load file.
//
//--------------------------------------------------------------------------- aarayas ------
bool CFileManager::Load(const WCHAR* pwszFileName, void** pMem, unsigned int* size)
{
	// Open files.
	m_hFile = CMN_CreateFileW(pwszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (m_hFile != INVALID_HANDLE_VALUE)
    {
	    m_dwFileSize1 = CMN_GetFileSize(m_hFile, &m_dwFileSize2);
    
		if (m_dwFileSize1 != 0 && m_dwFileSize1 != 0xFFFFFFFF)
		{
			m_hFileMap = CMN_CreateFileMapping(m_hFile, NULL, PAGE_READONLY, 0, 0, NULL);

			if (m_hFileMap != NULL)
			{
				m_pMem = CMN_MapViewOfFile(m_hFileMap, FILE_MAP_READ, 0, 0, 0);

				if (m_pMem != NULL)
				{
					// Create new size.
					*size = m_dwFileSize1;
					*pMem = m_pMem;
					m_fFileOpen = true;
					return true;
				}
				CMN_CloseHandle(m_hFileMap);
			}
		}
		CMN_CloseHandle(m_hFile);
	}

	m_hFileMap = NULL;
	m_hFile = NULL;
	m_dwFileSize1 = 0;
	m_dwFileSize2 = 0;

	return false;
}

//------------------------------------------------------------------------------------------
//	CFileManager::Close
//
//	Close file.
//
//--------------------------------------------------------------------------- aarayas ------
bool CFileManager::Close()
{
	if (m_fFileOpen)
	{
		m_fFileOpen = false;

		if (m_pMem && !CMN_UnmapViewOfFile(m_pMem))
		{
			return false;
		}

		m_pMem = 0;

	    if (m_hFileMap && !CMN_CloseHandle(m_hFileMap))
		{
			return false;
		}

		m_hFileMap = 0;

	    if (!CMN_CloseHandle(m_hFile))
		{
			return false;
		}

		m_hFile = 0;
		m_dwFileSize1 = 0;
		m_dwFileSize2 = 0;
	}
	return true;
}

//------------------------------------------------------------------------------------------
//	CFileManager::CreateFile
//
//	Create Files
//
//--------------------------------------------------------------------------- aarayas ------
bool CFileManager::CreateFile(const WCHAR* pwszFileName, bool fWrite)
{
	bool fRet = true;

	if (fWrite)
		m_hFile = CMN_CreateFileW(	pwszFileName, GENERIC_WRITE, 0, (LPSECURITY_ATTRIBUTES)0,CREATE_ALWAYS,
									FILE_ATTRIBUTE_NORMAL, (HANDLE)0);
	else
		m_hFile = CMN_CreateFileW(	pwszFileName, GENERIC_READ, 0, (LPSECURITY_ATTRIBUTES)0,OPEN_EXISTING,
									FILE_ATTRIBUTE_NORMAL, (HANDLE)0);

	if (m_hFile == INVALID_HANDLE_VALUE || m_hFile == 0)
	{
		m_hFile = 0;
		m_fFileOpen = false;
		fRet = false;
	}
	else
		m_fFileOpen = true;

	return fRet;
}

//------------------------------------------------------------------------------------------
//	CFileManager::MovePointer
//
//	Move file pointer
//  Parameter:
//		dwMoveMethod
//				FILE_BEGIN		- The starting point is zero or the beginning of the file. 
//				FILE_CURRENT	- The starting point is the current value of the file pointer. 
//				FILE_END		- The starting point is the current end-of-file position. 
//
//--------------------------------------------------------------------------- aarayas ------
bool CFileManager::MovePointer(DWORD dwMoveMethod)
{
	bool fRet = false;

	if (m_fFileOpen && m_hFile)
	{
		if (SetFilePointer( m_hFile,		// handle of file
							0,				// number of bytes to move file pointer
							0,				// address of high-order word of distance to move
							dwMoveMethod	// how to move
							) == 0)
		{
			fRet = true;
		}
	}

	return fRet;
}

//------------------------------------------------------------------------------------------
//	CFileManager::Write
//
//	Write to files.
//
//--------------------------------------------------------------------------- aarayas ------
bool CFileManager::Write(const void* lpBuffer,DWORD nNumberOfBytesToWrite)
{
	bool fRet = false;

	if (m_fFileOpen && m_hFile)
	{
		DWORD cb;

		if (WriteFile(m_hFile, (LPCVOID)lpBuffer, nNumberOfBytesToWrite, &cb, (LPOVERLAPPED)0))
		{
			if (cb == nNumberOfBytesToWrite)
				fRet = true;
		}
	}

	return fRet;
}

//------------------------------------------------------------------------------------------
//	CFileManager::Read
//
//	Write to files.
//
//--------------------------------------------------------------------------- aarayas ------
bool CFileManager::Read(void* lpBuffer,DWORD nNumberOfBytesToRead)
{
	bool fRet = false;

	if (m_fFileOpen && m_hFile)
	{
		DWORD cb;

		if (ReadFile(m_hFile, (void*)lpBuffer, nNumberOfBytesToRead, &cb, (LPOVERLAPPED)0))
		{
			if (cb == nNumberOfBytesToRead)
				fRet = true;
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\kor2\src\_kor_name.h ===
// kor\_kor_name.h
// Korean Name definitions
// Copyright 2000 Microsoft Corp.
//
// *** do not edit this file ***
//
// this file is automatically generated from kor_name.bat script
//
// generated on Mon 3 Jul 2000 at 18:15:57
//

const ULONG TOTAL_KORNAME_UNIGRAM = 3050628;
const ULONG TOTAL_KORNAME_BIGRAM = 4568990;
const ULONG TOTAL_KORNAME_TRIGRAM = 3987666;

const ULONG TOTAL_KORNAME_LASTNAME = 1536850;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cfilemanager.h ===
//------------------------------------------------------------------------------------------
//	CFileManager.h
//
//	A managing map files.
//
//  Created By: aarayas
//
//  History: 01/12/2001
//
//------------------------------------------------------------------------------------------
#ifndef _CFILEMANAGER_H_
#define _CFILEMANAGER_H_
#include "FileManager.h"

class CFileManager
{
public:
	CFileManager();
	~CFileManager();
	bool Load(const WCHAR*, void**, unsigned int*);
	bool MovePointer(DWORD);
	bool CreateFile(const WCHAR*,bool);
	bool Write(const void*,DWORD);
	bool Read(void*,DWORD);
	bool Close();

private:
	bool m_fFileOpen;
    HANDLE m_hFile;
	HANDLE m_hFileMap;
	DWORD m_dwFileSize1;		// File size low
	DWORD m_dwFileSize2;		// File files high
	void* m_pMem;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cmn_createfilew.c ===
/*****************************************************************************

  Natural Language Group Common Library

  CMN_CreateFileW.c - windows 95 safe version of CreateFileW

  History:
		DougP	11/20/97	Created

	1997 Microsoft Corporation
*****************************************************************************/

#include "precomp.h"
#undef CMN_CreateFileW
#undef CreateFileW

HANDLE WINAPI
CMN_CreateFileW (
    PCWSTR pwzFileName,  // pointer to name of the file 
    DWORD dwDesiredAccess,  // access (read-write) mode 
    DWORD dwShareMode,  // share mode 
    LPSECURITY_ATTRIBUTES pSecurityAttributes, // pointer to security descriptor 
    DWORD dwCreationDistribution,   // how to create 
    DWORD dwFlagsAndAttributes, // file attributes 
    HANDLE hTemplateFile)    // handle to file with attributes to copy  
{
	HINSTANCE hFile;
	Assert(pwzFileName);
	hFile = CreateFileW (
		pwzFileName,  // pointer to name of the file 
		dwDesiredAccess,  // access (read-write) mode 
		dwShareMode,  // share mode 
		pSecurityAttributes, // pointer to security descriptor 
		dwCreationDistribution,   // how to create 
		dwFlagsAndAttributes, // file attributes 
		hTemplateFile);
#if defined(_M_IX86)
	if (!hFile && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
	{		// must be in win95 - arghhh!
		char szFileName[MAX_PATH];
		  // Lenox convinced me this is a safe limit for w95
		  //(if it's NT we're not here)

		BOOL fcharerr;
		char chdef = ' ';
		int res = WideCharToMultiByte (CP_ACP, 0, pwzFileName,
				-1,
				szFileName, sizeof(szFileName), &chdef, &fcharerr);
		if (res && !fcharerr)
			hFile = CreateFileA (
				szFileName,  // pointer to name of the file 
				dwDesiredAccess,  // access (read-write) mode 
				dwShareMode,  // share mode 
				pSecurityAttributes, // pointer to security descriptor 
				dwCreationDistribution,   // how to create 
				dwFlagsAndAttributes, // file attributes 
				hTemplateFile);
		else if (fcharerr)
			SetLastError(ERROR_NO_UNICODE_TRANSLATION);
	}
#endif
#if defined(_DEBUG)
	if (!hFile || hFile == INVALID_HANDLE_VALUE)
		CMN_OutputSystemErrW(L"Can't CreateFile", pwzFileName);
#endif
	return hFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cmn_debug.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       Debug.h
//
//  History:    22-May-95   PatHal      Created.
//
//---------------------------------------------------------------------------

#ifndef _DEBUG_
#define _DEBUG_

#ifdef _DEBUG

#ifdef __cplusplus
extern "C" {
#endif
// in NLGlib.h
// extern void DebugAssert(LPCTSTR, LPCTSTR, UINT);
// extern void SetAssertOptions(DWORD);
//

// Optional assert behavior
#define AssertOptionWriteToFile     0x01
#define AssertOptionShowAlert       0x02
// Continue and exit are mutually exclusive
#define AssertOptionContinue        0x00
#define AssertOptionExit            0x04
#define AssertOptionCallDebugger    0x08
#define AssertOptionUseVCAssert     0x10

#define AssertDefaultBehavior       (AssertOptionUseVCAssert)

#define bAssertWriteToFile()    ((fAssertFlags & AssertOptionWriteToFile) != 0)
#define bAssertShowAlert()      ((fAssertFlags & AssertOptionShowAlert) != 0)
#define bAssertExit()           ((fAssertFlags & AssertOptionExit) != 0)
#define bAssertCallDebugger()   ((fAssertFlags & AssertOptionCallDebugger) != 0)
#define bAssertUseVCAssert()    ((fAssertFlags & AssertOptionUseVCAssert) != 0)


#define Assert(a) { if (!(a)) DebugAssert((LPCTSTR)L#a, TEXT(__FILE__), __LINE__); }
#define AssertSz(a,t) { if (!(a)) DebugAssert((LPCTSTR)t, TEXT(__FILE__), __LINE__); }

#ifdef __cplusplus
}
#endif

#else // _DEBUG

#define Assert(a)
#define AssertSz(a,t)

#endif // _DEBUG

#endif // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\common.h ===
/****************************** Module Header ******************************\
* Module Name: common.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* History:
\***************************************************************************/

#ifndef _COMMON_
#define _COMMON_

extern HANDLE ghHeap;

#ifdef _DEBUG_PRINT
    #define _DBGERROR     0x00000001
    #define _DBGWARNING 0x00000002
    #define _DBGVERBOSE 0x00000004
    #define _DBGALL           0xFFFFFFFF
    extern ULONG gThDebugFlag;

    #define DBGERROR(_params_)   {if (gThDebugFlag & _DBGERROR)DbgPrint _params_ ; }
    #define DBGWARNING(_params_) {if (gThDebugFlag & _DBGWARNING)DbgPrint _params_ ; }
    #define DBGVERBOSE(_params_) {if (gThDebugFlag & _DBGVERBOSE)DbgPrint _params_ ; }
    #define DBGPRINT(_params_)   DbgPrint _params_
#else
    #define DBGERROR(_params_)
    #define DBGWARNING(_params_)
    #define DBGVERBOSE(_params_)
    #define DBGPRINT(_params_)
#endif

// misc defines
//
#define SUCCESS(s)      ((s) == ERROR_SUCCESS)
#define NO_SUCCESS(s)   ((s) != ERROR_SUCCESS)

#define ThAlloc( cbSize ) HeapAlloc( ghHeap, HEAP_ZERO_MEMORY, (cbSize));
#define ThFree( pv )                       HeapFree(  ghHeap, 0, (pv));
#define ThReAlloc( pv, cbSize)      HeapReAlloc( ghHeap, 0, (pv), (cbSize));

#ifdef _DEBUG
#define MAX_PROCINFO 16

typedef struct _tagBLOCKINFO {
    struct _tagBLOCKINFO *pbiNext;
    BYTE *pb;           // Start of block
    ULONG ulSize;       // Length of block
    BOOL fReferenced;   // Ever referenced
    PROCESS_INFORMATION ProcInfo[MAX_PROCINFO];
} BLOCKINFO, *PBLOCKINFO;

BOOL fCreateBlockInfo(BYTE *pbNew, ULONG cbSizeNew);
VOID FreeBlockInfo(BYTE *pbToFree);
VOID UpdateBlockInfo(BYTE *pbOld, BYTE *pbNew, ULONG cbSizeNew);
ULONG sizeofBlock(BYTE *pb);

VOID ClearMemoryRefs(VOID);
VOID NoteMemoryRef(VOID *pv);
VOID CheckMemoryRefs(VOID);
BOOL fValidPointer(VOID *pv, ULONG cbSize);

#define bThNewGarbage    0xA3
#define bThOldGarbage    0xA4
#define bThFreeGarbage   0xA5
#define bThDebugByte     0xE1

#define sizeofDebugByte 1

#else
#define sizeofDebugByte 0
#endif

#endif // _COMMON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cmn_outputsystemerr.c ===
/*****************************************************************************

  Natural Language Group Common Library

  CMN_OutputDebugStringW.c -
    DEBUG ONLY
    local helper functions that puts specific error message to debug output
    for errors on library functions

  History:
        DougP   9/9/97  Created

The end user license agreement (EULA) for CSAPI, CHAPI, or CTAPI covers this source file.  Do not disclose it to third parties.

You are not entitled to any support or assistance from Microsoft Corporation regarding your use of this program.

 1997-1998 Microsoft Corporation.  All rights reserved.
******************************************************************************/

#include "precomp.h"

#if defined(_DEBUG)
#undef CMN_OutputDebugStringW

VOID
WINAPI
CMN_OutputDebugStringW(const WCHAR * pwzOutputString)
{
#if defined(_M_IX86)
    char szOutputString[MAX_PATH];
    BOOL fcharerr;
    char chdef = '?';
    int res = WideCharToMultiByte (CP_ACP, 0, pwzOutputString,
            -1,
            szOutputString, sizeof(szOutputString), &chdef, &fcharerr);
    OutputDebugStringA(szOutputString);
#else
    OutputDebugStringW(pwzOutputString);
#endif
}

void WINAPI CMN_OutputSystemErrA(const char *pszMsg, const char *pszComponent)
{
    CMN_OutputErrA(GetLastError(), pszMsg, pszComponent);
}

void WINAPI CMN_OutputErrA(DWORD dwErr, const char *pszMsg, const char *pszComponent)
{
    char szMsgBuf[256];
    OutputDebugStringA(pszMsg);
    OutputDebugStringA(" \"");
    if (pszComponent)
        OutputDebugStringA(pszComponent);
    OutputDebugStringA("\": ");
    if (!FormatMessageA(
            FORMAT_MESSAGE_FROM_SYSTEM, // source and processing options
            NULL, // pointer to message source
            dwErr, // requested message identifier
            0, // language identifier for requested message
            szMsgBuf, // pointer to message buffer
            sizeof(szMsgBuf)/sizeof(szMsgBuf[0]), // maximum size of message buffer
            0 // address of array of message inserts
        ))
        OutputDebugStringA("Couldn't decode err msg");
    else
        OutputDebugStringA(szMsgBuf);
    OutputDebugStringA("\r\n");
}

void WINAPI CMN_OutputSystemErrW(const WCHAR *pwzMsg, const WCHAR *pwzComponent)
{
    CMN_OutputErrW(GetLastError(), pwzMsg, pwzComponent);
}

void WINAPI CMN_OutputErrW(DWORD dwErr, const WCHAR *pwzMsg, const WCHAR *pwzComponent)
{
    char wcMsgBuf[256];
    CMN_OutputDebugStringW(pwzMsg);
    OutputDebugStringA(" \"");
    if (pwzComponent)
        CMN_OutputDebugStringW(pwzComponent);
    OutputDebugStringA("\": ");
    if (!FormatMessageA(
            FORMAT_MESSAGE_FROM_SYSTEM, // source and processing options
            NULL, // pointer to message source
            dwErr, // requested message identifier
            0, // language identifier for requested message
            wcMsgBuf, // pointer to message buffer
            sizeof(wcMsgBuf)/sizeof(wcMsgBuf[0]), // maximum size of message buffer
            0 // address of array of message inserts
        ))
        OutputDebugStringA("Couldn't decode err msg");
    else
        OutputDebugStringA(wcMsgBuf);
    OutputDebugStringA("\r\n");
}
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthaibreaktree.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiBreakTree - class CThaiBreakTree 
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "CThaiBreakTree.hpp"

//+---------------------------------------------------------------------------
//
//  Function:   ExtractPOS
//
//  Synopsis:   The functions takes a tag and return Part Of Speech Tags.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline WCHAR ExtractPOS(DWORD dwTag)
{
    return (WCHAR) ( (dwTag & iPosMask) >> iPosShift);
}

//+---------------------------------------------------------------------------
//
//  Function:   ExtractFrq
//
//  Synopsis:   The functions takes a tag and return Frquency of words.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BYTE ExtractFrq(DWORD dwTag)
{
    return (BYTE) ( (dwTag & 0x300) >> iFrqShift);
}

//+---------------------------------------------------------------------------
//
//  Function:   DetermineFrequencyWeight
//
//  Synopsis:   The functions returns the frequency weight of a words.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void DetermineFrequencyWeight(BYTE frq, unsigned int* uiWeight)
{
    switch (frq)
    {
    case frqpenInfrequent:
        (*uiWeight) -= 2;
        break;
    case frqpenSomewhat:
        (*uiWeight)--;
        break;
    case frqpenVery:
        (*uiWeight) += 2;
        break;
    case frqpenNormal:
    default:
        (*uiWeight)++;
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DetermineFrequencyWeight
//
//  Synopsis:   The functions returns the frequency weight of a words.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void DetermineFrequencyWeight(BYTE frq, DWORD* uiWeight)
{
    switch (frq)
    {
    case frqpenInfrequent:
        (*uiWeight) -= 2;
        break;
    case frqpenSomewhat:
        (*uiWeight)--;
        break;
    case frqpenVery:
        (*uiWeight) += 2;
        break;
    case frqpenNormal:
    default:
        (*uiWeight)++;
        break;
    }
}
//+---------------------------------------------------------------------------
//
//  Class:		CThaiTrieIter
//
//  Synopsis:	Constructor - initialize local variables
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiBreakTree::CThaiBreakTree() :  iNodeIndex(0), iNumNode(0),
                                    pszBegin(NULL), pszEnd(NULL),
                                    breakTree(NULL), breakArray(NULL),
                                    tagArray(NULL), maximalMatchingBreakArray(NULL),
                                    maximalMatchingTAGArray(NULL),
                                    POSArray(NULL), maximalMatchingPOSArray(NULL)
{
    // Allocate memory need for CThaiBreakTree.
#if defined (NGRAM_ENABLE)
	breakTree = new ThaiBreakNode[MAXTHAIBREAKNODE];
#endif
    breakArray = new BYTE[MAXBREAK];
    tagArray = new DWORD[MAXBREAK];
    POSArray = new WCHAR[MAXBREAK];
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiTrieIter
//
//  Synopsis:	Destructor - clean up code
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiBreakTree::~CThaiBreakTree()
{
    // Clean up all memory used.
#if defined (NGRAM_ENABLE)
	if (breakTree)
        delete breakTree;
    if (maximalMatchingBreakArray)
        delete maximalMatchingBreakArray;
    if (maximalMatchingTAGArray)
        delete maximalMatchingTAGArray;
    if (maximalMatchingPOSArray)
        delete maximalMatchingPOSArray;
#endif
    if (breakArray)
        delete breakArray;
    if (tagArray)
        delete tagArray;
    if (POSArray)
        delete POSArray;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:	Associate the class to the string.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
#if defined (NGRAM_ENABLE)
void CThaiBreakTree::Init(CTrie* pTrie, CTrie* pSentTrie, CTrie* pTrigramTrie)
#else
void CThaiBreakTree::Init(CTrie* pTrie, CTrie* pTrigramTrie)
#endif
{
    assert(pTrie != NULL);
    thaiTrieIter.Init(pTrie);
    thaiTrieIter1.Init(pTrie);

#if defined (NGRAM_ENABLE)
    assert(pSentTrie != NULL);
    thaiSentIter.Init(pSentTrie);
#endif
	assert(pTrigramTrie != NULL);
	thaiTrigramIter.Init(pTrigramTrie);
}

#if defined (NGRAM_ENABLE)
//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:	reset iterator to top of the tree
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void CThaiBreakTree::Reset()
{
	iNodeIndex = 0;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:	Move to the next break.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline bool CThaiBreakTree::MoveNext()
{
	iNodeIndex = breakTree[iNodeIndex].NextBreak;
	return (iNodeIndex != 0);
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   Move down to next level.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline bool CThaiBreakTree::MoveDown()
{
	iNodeIndex = breakTree[iNodeIndex].Down;
	return (iNodeIndex != 0);
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   create new node to position, and return index to the node.
//
//              * return Unable to Create Node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline unsigned int CThaiBreakTree::CreateNode(int iPos, BYTE iBreakLen, DWORD dwTAG)
{
    assert(iNumNode < MAXTHAIBREAKNODE);

    if  (iNumNode >= MAXTHAIBREAKNODE)
    {
        return UNABLETOCREATENODE;
    }
    breakTree[iNumNode].iPos = iPos;
    breakTree[iNumNode].iBreakLen = iBreakLen;
    breakTree[iNumNode].dwTAG = dwTAG;
    breakTree[iNumNode].NextBreak = 0;
    breakTree[iNumNode].Down = 0;

    iNumNode++;
    return (iNumNode - 1);
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   Generate a Tree of possible break from the given string.
//
//              * Note - false if there aren't enough memory to create node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
enum thai_parse_state {
                        END_SENTENCE,    // Reached the end of sentence.
                        LONGEST_MATCH,   // Longest possible matched.
                        NOMATCH_FOUND,   // Unable to find word.
                        ERROR_OUTMEMORY, // Out of Memory.
                      };

bool CThaiBreakTree::GenerateTree(WCHAR* pszBegin, WCHAR* pszEnd1)
{
    // Declare and initialize local variables.
    unsigned int iIndexBreakTree = 0;
    unsigned int iPrevIndexBreakTree = 0;
    unsigned int iParentNode = 0;
    WCHAR* pszBeginWord = pszBegin;
    WCHAR* pszIndex = pszBegin;
    unsigned int iNumCluster = 1;
    unsigned int iNumLastCluster;
    unsigned int iWordLen = 0;
	unsigned int iNodeAnalyze = 0;
    thai_parse_state parseState = END_SENTENCE;
    bool fFoundMatch = false;
    bool fAddToNodeAnalyze = false;
    bool fDoneGenerateTree = false;
    pszEnd = pszEnd1;

#if defined (_DEBUG)
    memset(breakTree,0,sizeof(ThaiBreakNode)*MAXTHAIBREAKNODE);
#endif
    iNodeIndex = 0;
    iNumNode = 0;

    while (true)
    {
        // Reset Iterator for generating break for new word.
        fFoundMatch = false;
        thaiTrieIter.Reset();
		
		if (iIndexBreakTree != 0)
        {
            while (true)
            {
			    // If this is not the first node than set pszBeginWord after the last break.
			    pszBeginWord = pszBegin + breakTree[iNodeAnalyze].iPos + breakTree[iNodeAnalyze].iBreakLen;
                fAddToNodeAnalyze = true;

                // Are we at the end of the sentence.
                if ( (pszBeginWord == pszEnd) ||
                     (breakTree[iNodeAnalyze].dwTAG == TAGPOS_PURGE) )
                {
                    iNodeAnalyze++;             // Move to next node.
                    if (iNodeAnalyze >= iNumNode)
                    {
                        fDoneGenerateTree = true;
                        break;
                    }
                }   
                else
                    break;
            }
        }
        pszIndex = pszBeginWord;
        iParentNode = iNodeAnalyze;

        if (fDoneGenerateTree)
            break;

		// Get next level of tree.
        while (TRUE)
        {
            iNumLastCluster = iNumCluster;
            iNumCluster = GetCluster(pszIndex);
            if (thaiTrieIter.MoveCluster(pszIndex, iNumCluster))
            {
                pszIndex += iNumCluster;
                if (thaiTrieIter.fWordEnd)
                {
                    fFoundMatch = true;
                    // if first node add first node
                    if (iIndexBreakTree == 0)
                    {
                        CreateNode(pszBeginWord - pszBegin, pszIndex - pszBeginWord, thaiTrieIter.dwTag);
                        iIndexBreakTree++;
                    }
                    else
                    {
						if (fAddToNodeAnalyze)
						{
                            fAddToNodeAnalyze = false;
							breakTree[iNodeAnalyze].NextBreak = CreateNode(pszBeginWord - pszBegin, pszIndex - pszBeginWord, thaiTrieIter.dwTag);

                            // Determine if an error has occur.
                            if (breakTree[iNodeAnalyze].NextBreak == UNABLETOCREATENODE)
                            {
                                breakTree[iNodeAnalyze].NextBreak = 0;
                                parseState = ERROR_OUTMEMORY;
                                break;
                            }

                            iPrevIndexBreakTree = breakTree[iNodeAnalyze].NextBreak;
							iNodeAnalyze++;
						}
						else
						{
                            breakTree[iPrevIndexBreakTree].Down = CreateNode(pszBeginWord - pszBegin, pszIndex - pszBeginWord, thaiTrieIter.dwTag);

                            // Determine if an error has occur.
                            if (breakTree[iPrevIndexBreakTree].Down == UNABLETOCREATENODE)
                            {
                                breakTree[iPrevIndexBreakTree].Down = 0;
                                parseState = ERROR_OUTMEMORY;
                                break;
                            }

                            iPrevIndexBreakTree = iIndexBreakTree;
						}
       	                iIndexBreakTree++;
                    }
                }

				if (pszIndex >= pszEnd)
				{
					assert(pszIndex <= pszEnd);			// assert should never come up - if it appear likely bug in GetCluster funciton.
                    parseState = END_SENTENCE;
					break;
				}
            }
            else
            {
                if (fFoundMatch)
                    parseState = LONGEST_MATCH;
                else
                    parseState = NOMATCH_FOUND;
                break;

            }
        }

	    if (parseState == LONGEST_MATCH)
        {
            // We found a matched.
            assert(breakTree[iPrevIndexBreakTree].Down == 0);  // at this point breakTree[iPreveIndexBreakTree].Down should equal null.(optimization note)
            if (breakTree[iParentNode].NextBreak != iPrevIndexBreakTree) 
            {
                assert(breakTree[iPrevIndexBreakTree].dwTAG != TAGPOS_UNKNOWN);  // shouldn't assert because the end node should ever be unknown.
                DeterminePurgeEndingSentence(pszBeginWord, breakTree[iParentNode].NextBreak);
            }
        }
        else if (parseState == NOMATCH_FOUND)
        {
            // Should mark node as unknown.
            if (fAddToNodeAnalyze)
            {
                fAddToNodeAnalyze = false;
                iWordLen = pszIndex - pszBeginWord;
                
                // Make sure we don't only have a cluster of text before making a node.
                if (iWordLen == 0)
                {
                    // If we have an UNKNOWN word of one character only current node mark it as unknown.
                    assert(iNodeAnalyze == iParentNode);                // Since we have a no match iNodeAnalyze better equal iParentNode
                    breakTree[iNodeAnalyze].iBreakLen += iNumCluster;
                    breakTree[iNodeAnalyze].dwTAG = DeterminePurgeOrUnknown(iNodeAnalyze,breakTree[iNodeAnalyze].iBreakLen);
                }
                else
                {
                    if (breakTree[iNodeAnalyze].iBreakLen + iWordLen < 8)
                                            // The reason we are using 8 is because from corpora analysis
                                            // the average Thai word is about 7.732 characters.
                                            // TODO: We should add orthographic analysis here to get a better on boundary
                                            // of unknown word.
                    {
                        assert(iNodeAnalyze == iParentNode);                // Since we have a no match iNodeAnalyze better equal iParentNode
                        breakTree[iNodeAnalyze].iBreakLen += iWordLen;
                        breakTree[iNodeAnalyze].dwTAG = DeterminePurgeOrUnknown(iNodeAnalyze,breakTree[iNodeAnalyze].iBreakLen);
                    }
                    else
                    {
                        if (GetWeight(pszIndex - iNumLastCluster))
                            breakTree[iNodeAnalyze].NextBreak = CreateNode(pszBeginWord - pszBegin, iWordLen - iNumLastCluster, TAGPOS_UNKNOWN);
                        else
                            breakTree[iNodeAnalyze].NextBreak = CreateNode(pszBeginWord - pszBegin, iWordLen, TAGPOS_UNKNOWN);

                        // Determine if an error has occur.
                        if (breakTree[iNodeAnalyze].NextBreak == UNABLETOCREATENODE)
                        {
                            breakTree[iNodeAnalyze].NextBreak = 0;
                            parseState = ERROR_OUTMEMORY;
                            break;
                        }
                        iNodeAnalyze++;
                        iIndexBreakTree++;
                    }
                }
            }
            else
            {
                breakTree[iPrevIndexBreakTree].Down = CreateNode(pszBeginWord - pszBegin, pszIndex - pszBeginWord, TAGPOS_UNKNOWN);

                // Determine if an error has occur.
                if (breakTree[iPrevIndexBreakTree].Down == UNABLETOCREATENODE)
                {
                    breakTree[iPrevIndexBreakTree].Down = 0;
                    parseState = ERROR_OUTMEMORY;
                    break;
                }
                iIndexBreakTree++;
            }
        }
        else if (parseState == END_SENTENCE)
        {
            // If we find ourself at the end of a sentence and no match.
            if (!fFoundMatch)
            {
                if (fAddToNodeAnalyze)
                {
                    fAddToNodeAnalyze = false;
                    iWordLen = pszIndex - pszBeginWord;
                
                    // Make sure we don't only have a cluster of text before making a node.
                    if (iWordLen == 0)
                    {
                        // If we have an UNKNOWN word of one character only current node mark it as unknown.
                        assert(iNodeAnalyze == iParentNode);                // Since we have a no match iNodeAnalyze better equal iParentNode
                        breakTree[iNodeAnalyze].iBreakLen += iNumCluster;
                        breakTree[iNodeAnalyze].dwTAG = DeterminePurgeOrUnknown(iNodeAnalyze,breakTree[iNodeAnalyze].iBreakLen);
                    }
                    else
                    {
                        if (breakTree[iNodeAnalyze].iBreakLen + iWordLen < 8)
                                                // The reason we are using 8 is because from corpora analysis
                                                // the average Thai word is about 7.732 characters.
                                                // TODO: We should add orthographic analysis here to get a better on boundary
                                                // of unknown word.
                        {
                            assert(iNodeAnalyze == iParentNode);                // Since we have a no match iNodeAnalyze better equal iParentNode
                            breakTree[iNodeAnalyze].iBreakLen += iWordLen;
                            breakTree[iNodeAnalyze].dwTAG = DeterminePurgeOrUnknown(iNodeAnalyze,breakTree[iNodeAnalyze].iBreakLen);
                        }
                        else
                        {
                            if (GetWeight(pszIndex - iNumLastCluster))
                                breakTree[iNodeAnalyze].NextBreak = CreateNode(pszBeginWord - pszBegin, iWordLen - iNumLastCluster, TAGPOS_UNKNOWN);
                            else
                                breakTree[iNodeAnalyze].NextBreak = CreateNode(pszBeginWord - pszBegin, iWordLen, TAGPOS_UNKNOWN);

                            // Determine if an error has occur.
                            if (breakTree[iNodeAnalyze].NextBreak == UNABLETOCREATENODE)
                            {
                                breakTree[iNodeAnalyze].NextBreak = 0;
                                parseState = ERROR_OUTMEMORY;
                                break;
                            }
                            iNodeAnalyze++;
                            iIndexBreakTree++;
                        }
                    }
                }
                else
                {
                    breakTree[iPrevIndexBreakTree].Down = CreateNode(pszBeginWord - pszBegin, pszIndex - pszBeginWord, TAGPOS_UNKNOWN);

                    // Determine if an error has occur.
                    if (breakTree[iPrevIndexBreakTree].Down == UNABLETOCREATENODE)
                    {
                        breakTree[iPrevIndexBreakTree].Down = 0;
                        parseState = ERROR_OUTMEMORY;
                        break;
                    }
                }
                iIndexBreakTree++;
            }
            // If the beginning of node the branch isn't equal to leaf node perphase it is possible to
            // do some ending optimization.
            else if (breakTree[iParentNode].NextBreak != iPrevIndexBreakTree) 
            {
                assert(breakTree[iPrevIndexBreakTree].dwTAG != TAGPOS_UNKNOWN);  // shouldn't assert because the end node should ever be unknown.
                DeterminePurgeEndingSentence(pszBeginWord, breakTree[iParentNode].NextBreak);
            }
        }
        else if ( (breakTree[iNodeAnalyze].iBreakLen == 0) || (parseState == ERROR_OUTMEMORY) )
            break;
    }

    return (parseState != ERROR_OUTMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   Traverse all the tree and look for the least number of token.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiBreakTree::MaximalMatching()
{
    // If maximal matching break array has not been allocate, than allocate it.
    if (!maximalMatchingBreakArray)
        maximalMatchingBreakArray = new BYTE[MAXBREAK];
    if (!maximalMatchingTAGArray)
        maximalMatchingTAGArray = new DWORD[MAXBREAK];
    if (!maximalMatchingPOSArray)
        maximalMatchingPOSArray = new WCHAR[MAXBREAK];

    maxLevel = MAXUNSIGNEDINT;
    maxToken = 0;
    iNumUnknownMaximalPOSArray = MAXBREAK;
    Traverse(0,0,0);

    return true;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   The function determine if the node if the node should,
//              be tag as unknown or purge.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline DWORD CThaiBreakTree::DeterminePurgeOrUnknown(unsigned int iCurrentNode, unsigned int iBreakLen)
{
    // Declare and initialize local variables.
    unsigned int iNode = breakTree[iCurrentNode].Down;

    while (iNode != 0)
    {
        if ( (breakTree[iNode].iBreakLen == iBreakLen)     ||
             (breakTree[iNode].iBreakLen < iBreakLen)      &&
             ( (breakTree[iNode].dwTAG != TAGPOS_UNKNOWN)  ||
               (breakTree[iNode].dwTAG != TAGPOS_PURGE)    ))
        {
            // Since we are purging this break just make sure the NextBreak is Null.
            assert(breakTree[iCurrentNode].NextBreak == 0);
            return TAGPOS_PURGE;
        }

        iNode = breakTree[iNode].Down;
    }
    return TAGPOS_UNKNOWN;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   Ending optimization - if we have found the end of a sentence,
//              and possible break.  Purge the branch for unnecessary break.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void CThaiBreakTree::DeterminePurgeEndingSentence(WCHAR* pszBeginWord, unsigned int iNode)
{
    while (breakTree[iNode].Down != 0)
    {
        // Determine if the next string has a possiblity to become a word.
        // TODO: We may need to change this once the GetWeight add soundex
        //       functionality.
        if (GetWeight(pszBeginWord + breakTree[iNode].iBreakLen) == 0)
        {
            // Since we are purging this break just make sure the NextBreak is Null.
            assert(breakTree[iNode].NextBreak == 0);
            breakTree[iNode].dwTAG = TAGPOS_PURGE;
        }
        iNode = breakTree[iNode].Down;
    }
}
#endif


//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiBreakTree::GetLongestSubstring(WCHAR* pszBegin, unsigned int iWordLen)
{
    // Declare and initialize local variables.
    unsigned int iNumCluster = 1;
	unsigned int lastWeight = 0;
    unsigned int Weight = 0;
    bool fBeginNewWord;
    WCHAR* pszIndex = pszBegin;
    
    // Short circuit the length is less of string is less than 1.
    if ((pszEnd - pszBegin) == 1)
        return Weight;
    else if (pszEnd == pszBegin)
        return 1000;

    // Reset Iterator for generating break for new word.
    fBeginNewWord = true;

    // Get next level of tree.
    while (true)
    {
        iNumCluster = GetCluster(pszIndex);
        if (thaiTrieIter.MoveCluster(pszIndex, iNumCluster, fBeginNewWord))
        {
            fBeginNewWord = false;
            pszIndex += iNumCluster;
            if (thaiTrieIter.fWordEnd)
			{
				lastWeight = Weight;
                Weight = (unsigned int) (pszIndex - pszBegin);
			}
        }
        else
		{
			if ((Weight == iWordLen) && (lastWeight < Weight) && (lastWeight > 0))
			{
			Weight = lastWeight;
			}
            break;
		}
    }
    return Weight;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiBreakTree::GetWeight(WCHAR* pszBegin)
{
    // Declare and initialize local variables.
    unsigned int iNumCluster = 1;
    unsigned int Weight = 0;
    bool fBeginNewWord;
    WCHAR* pszIndex = pszBegin;
    
    // Short circuit the length is less of string is less than 1.
    if ((pszEnd - pszBegin) == 1)
        return Weight;
    else if (pszEnd == pszBegin)
        return 1000;

    // Reset Iterator for generating break for new word.
    fBeginNewWord = true;

    // Get next level of tree.
    while (true)
    {
        iNumCluster = GetCluster(pszIndex);
        if (thaiTrieIter.MoveCluster(pszIndex, iNumCluster, fBeginNewWord))
        {
            fBeginNewWord = false;
            pszIndex += iNumCluster;
            if (thaiTrieIter.fWordEnd)
                Weight = (unsigned int) (pszIndex - pszBegin);
        }
        else
            break;
    }
    return Weight;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiBreakTree::GetWeight(WCHAR* pszBegin, DWORD* pdwTag)
{
    // Declare and initialize local variables.
    unsigned int iNumCluster = 1;
    unsigned int Weight = 0;
    bool fBeginNewWord;
    WCHAR* pszIndex = pszBegin;
    
    // Short circuit the length is less of string is less than 1.
    if ((pszEnd - pszBegin) == 1)
        return Weight;
    else if (pszEnd == pszBegin)
        return 1000;

    // Reset Iterator for generating break for new word.
    fBeginNewWord = true;

    // Get next level of tree.
    while (true)
    {
        iNumCluster = GetCluster(pszIndex);
        if (thaiTrieIter.MoveCluster(pszIndex, iNumCluster, fBeginNewWord))
        {
            fBeginNewWord = false;
            pszIndex += iNumCluster;
            if (thaiTrieIter.fWordEnd)
			{
                Weight = (unsigned int) (pszIndex - pszBegin);
				*pdwTag = thaiTrieIter.dwTag;
			}
        }
        else
            break;
    }
    return Weight;
}


//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   Traverse the tree.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiBreakTree::Traverse(unsigned int iLevel, unsigned int iCurrentNode, unsigned int iNumUnknown)
{
    assert (iLevel < MAXBREAK);
    // Process node.
    breakArray[iLevel] = breakTree[iCurrentNode].iBreakLen;
    tagArray[iLevel] = breakTree[iCurrentNode].dwTAG;
    if (tagArray[iLevel] ==  TAGPOS_UNKNOWN)
        iNumUnknown++;

    // Have we found the end of the sentence.
    if (breakTree[iCurrentNode].NextBreak == 0)
    {
        if (breakTree[iCurrentNode].dwTAG != TAGPOS_PURGE)
            AddBreakToList(iLevel + 1, iNumUnknown);
        if (breakTree[iCurrentNode].Down != 0)
        {
            if (tagArray[iLevel] == TAGPOS_UNKNOWN)
                iNumUnknown--;
            return Traverse(iLevel,breakTree[iCurrentNode].Down, iNumUnknown);
        }
        else
            return true;
    }
    else
        Traverse(iLevel + 1, breakTree[iCurrentNode].NextBreak, iNumUnknown);

    if (breakTree[iCurrentNode].Down != 0)
    {
       if (tagArray[iLevel] == TAGPOS_UNKNOWN)
           iNumUnknown--;

        Traverse(iLevel,breakTree[iCurrentNode].Down, iNumUnknown);
    }

    return true;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiBreakTree::SoundexSearch(WCHAR* pszBegin)
{
    // Declare and initialize local variables.
    unsigned int iNumCluster = 1;
    unsigned int iNumNextCluster = 1;
    unsigned int iLongestWord = 0;
    unsigned int iPenalty = 0;
    WCHAR* pszIndex = pszBegin;
    
    // Short circuit the length is less of string is less than 1.
    if ( (pszBegin+1) >= pszEnd )
        return iLongestWord;

    // Reset Iterator for generating break for new word.
    thaiTrieIter1.Reset();

    // Get next level of tree.
    while (true)
    {
        iNumCluster = GetCluster(pszIndex);
        
        // Determine iNumNextCluster let iNumNextCluster = 0, if we reached the end of string.
        if (pszIndex + iNumCluster >= pszEnd)
            iNumNextCluster = 0;
        else
            iNumNextCluster = GetCluster(pszIndex+iNumCluster);

        // Determine penalty
        switch (thaiTrieIter1.MoveSoundexByCluster(pszIndex, iNumCluster, iNumNextCluster))
        {
        case SUBSTITUTE_SOUNDLIKECHAR:
            iPenalty += 2;
            break;
        case SUBSTITUTE_DIACRITIC:
            iPenalty++;
            break;
        case UNABLE_TO_MOVE:
            iPenalty += 2;
            break;
		case STOP_MOVE:
            iPenalty += 1000;
            break;
        default:
        case NOSUBSTITUTE:
            break;
        }

        // Update Index.
        if (iPenalty <= 2)
        {
            pszIndex += iNumCluster;
            if (thaiTrieIter1.fWordEnd)
                iLongestWord = (unsigned int) (pszIndex - pszBegin);
        }
        else
            break;
    }
    return iLongestWord;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   The information used here is a reference to the orthographic
//              analysis work done on the Thai languages.  (see paper: Natural
//              Language Processing in Thailand 1993 Chulalongkorn. p 361).
//
//  Arguments:  pszBoundaryChar - Contain pointer to at least two thai character
//                                character next to each other which we will
//                                use to calculate wheather we should or
//                                should not merge the two word.
//
//              iPrevWordLen - 
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline bool CThaiBreakTree::ShouldMerge(const WCHAR* pwszPrevWord, unsigned int iPrevWordLen, unsigned int iMergeWordLen, DWORD dwPrevTag)
{
    const WCHAR* pwszBoundary = pwszPrevWord + iPrevWordLen - 1;

    assert(iMergeWordLen != 0);
    assert(iPrevWordLen != 0);

    // There are very few words in Thai that are 4 character or less, therefore we should
    // found a pair that less than 4 character we should merge.
    // Or if merge word length is one than also merge.
    // Of if last cluster of the word is a Thanthakhat(Karan) we should always merge.
    if (iPrevWordLen + iMergeWordLen <= 4 || iMergeWordLen == 1 ||
        (iMergeWordLen == 2 && *(pwszBoundary + iMergeWordLen) == THAI_Thanthakhat))
        return true;

    if (iPrevWordLen >=2)
    {
        const WCHAR* pwszPrevCharBoundary = pwszBoundary - 1;

        // TO IMPROVE: It better to check the last character of Previous word, it can give us a
        // much better guess 
        if ((*pwszPrevCharBoundary == THAI_Vowel_Sign_Mai_HanAkat || *pwszBoundary == THAI_Vowel_Sign_Mai_HanAkat) ||
            (*pwszPrevCharBoundary == THAI_Tone_Mai_Tri           || *pwszBoundary == THAI_Tone_Mai_Tri)           ||
            (*pwszPrevCharBoundary == THAI_Sara_Ue                || *pwszBoundary == THAI_Sara_Ue)                )
            return true;
    }

    // If the first character of the next word is mostly likly the beginning
    // character and last character of the previous word is not sara-A than
    // we have a high probability that we found a begin of word boundary,
    // therefore we shouldn't merge.
    if ( (IsThaiMostlyBeginCharacter(pwszBoundary[1]) && *pwszBoundary != THAI_Vowel_Sara_A) )
        return false;

    // If the last character of the previous word is mostly likely an ending
    // character than, than there is a high probability that the found a boundary.
    // There are very few words in Thai that are 4 character or less, therefore we should
    // found a pair that less than 4 character we should merge.
    if (IsThaiMostlyLastCharacter(*pwszBoundary))
        return false;

	// O10.192931 Adding Diacritic check rules.  We might want to expand this to more diacritic
	// for now Mai HanAkart would do.  It is highly unlikely that a word contain more than 1 of Mai HanAkart diacritic.
	if (IsContain(pwszPrevWord,iPrevWordLen,THAI_Vowel_Sign_Mai_HanAkat) && IsContain(pwszBoundary + 1,iMergeWordLen,THAI_Vowel_Sign_Mai_HanAkat))
		return false;

	if (iMergeWordLen == 3 && GetCluster(pwszBoundary + 1) == iMergeWordLen)
	{
		if (*(pwszBoundary + 2) == THAI_Vowel_Sara_I)
		{
			if (*(pwszBoundary+3) == THAI_Tone_Mai_Ek || *(pwszBoundary+3) == THAI_Tone_Mai_Tro)
				return false;
		}
	}

	// if previous tag is equal to Title Noun than the next word is highly likly to be a name.
	if (ExtractPOS(dwPrevTag) == 6)
		return false;

	// O11.134455. For the case of trailling punctuation.
	if (dwPrevTag == TAGPOS_PUNC && iMergeWordLen > 1 && iPrevWordLen > 1)
		return false;

    // The reason we are using 8 is because from corpora analysis
    // the average Thai word is about 7.732 characters. Or, if previous word is already
    // an unknown, to keep the amount of unknown low the unknown to previous words.
    if ( (iPrevWordLen + iMergeWordLen < 8) || (dwPrevTag == TAGPOS_UNKNOWN) )
        return true;

    return false;
}


//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//              8/17/99 optimize some code.
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void CThaiBreakTree::AddBreakToList(unsigned int iNumBreak, unsigned int iNumUnknown)
{
#if defined (_DEBUG)
    breakArray[iNumBreak] = 0;
#endif
    if (CompareSentenceStructure(iNumBreak, iNumUnknown))
    {
        maxToken = maxLevel = iNumBreak;                          // This is ugly but it save 5 clock cycle.
        memcpy(maximalMatchingBreakArray,breakArray,maxToken);
        memcpy(maximalMatchingTAGArray,tagArray,sizeof(DWORD)*maxToken);
        maximalMatchingBreakArray[maxToken] = 0;
        maximalMatchingTAGArray[maxToken] = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   The function compares sentence structure of
//              maximalMatchingPOSArray with posArray.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline bool CThaiBreakTree::CompareSentenceStructure(unsigned int iNumBreak, unsigned int iNumUnknownPOSArray)
{
    if ( (iNumBreak < maxLevel) && (iNumUnknownMaximalPOSArray >= iNumUnknownPOSArray) )
    {
        iNumUnknownMaximalPOSArray = iNumUnknownPOSArray;
        return true;
    }
    else if (iNumBreak == maxLevel)
    {
        // true - maximal matching has a larger unknown.
        if (iNumUnknownMaximalPOSArray > iNumUnknownPOSArray)
        {
            iNumUnknownMaximalPOSArray = iNumUnknownPOSArray;
            return true;
        }

        for(unsigned int i = 0; i <= iNumBreak; i++)
        {
            maximalMatchingPOSArray[i] = ExtractPOS(maximalMatchingTAGArray[i]);
            POSArray[i] = ExtractPOS(tagArray[i]);
        }

        // Determine if the sentence structure is like any one of the sentence
        // sentence structure in our corpora.
        if ( (IsSentenceStruct(POSArray, iNumBreak)) &&
             (!IsSentenceStruct(maximalMatchingPOSArray, iNumBreak)) )
        {
            iNumUnknownMaximalPOSArray = iNumUnknownPOSArray;
            return true;
        }
        else if (iNumUnknownMaximalPOSArray == iNumUnknownPOSArray)
        {
            // Determine the frequency of word used in the sentence.
            unsigned int iFrequencyArray = 500;
            unsigned int iFrequencyMaximalArray = 500;
            
            for(unsigned int i = 0; i <= iNumBreak; i++)
            {
                DetermineFrequencyWeight(ExtractFrq(maximalMatchingTAGArray[i]),&iFrequencyMaximalArray);
                DetermineFrequencyWeight(ExtractFrq(tagArray[i]),&iFrequencyArray);
            }
            return (iFrequencyArray > iFrequencyMaximalArray);
        }
    }
    return false;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiBreakTree::IsSentenceStruct(const WCHAR* pos, unsigned int iPosLen)
{
	// Declare and initialize all local variables.
	unsigned int i = 0;

	thaiSentIter.Reset();

	if (!thaiSentIter.Down())
		return FALSE;

    while (TRUE)
	{
		thaiSentIter.GetNode();
		if (thaiSentIter.pos == pos[i])
		{
			i++;
			if (thaiSentIter.fWordEnd && i == iPosLen)
            {
				return TRUE;
            }
			else if (i == iPosLen) break;
			// Move down the Trie Branch.
			else if (!thaiSentIter.Down()) break;
		}
		// Move right of the Trie Branch
		else if (!thaiSentIter.Right()) break;
	}
	return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
float CThaiBreakTree::BigramProbablity(DWORD dwTag1,DWORD dwTag2)
{
	unsigned int iWeight = 4;

	// TODO : Use the distribution of word category to determine optimial search - exmaple
	//        NOUN VERB ADVERB CLASSIFIER CONJETURE PREP et....
	// TODO : Once we got trigram use it to create bigram probability as well.
    if ( (dwTag1 != TAGPOS_UNKNOWN) &&
         (dwTag2 != TAGPOS_UNKNOWN) )
	{
        WCHAR pos1 = ExtractPOS(dwTag1);
        WCHAR pos2 = ExtractPOS(dwTag2);

		// case NCMN VATT
		///     a common noun is often followed by attributive verb(adjective)
		//      Example: (In Thai) book good, people nice
		if (pos1 == 5 && pos2 == 13)
			iWeight += 10;
		// case NTTL NPRP
		//      a title noun is often followed by proper noun
		//      Example: Dr. Athapan, Mr. Sam
		else if (pos1 == 6 && pos2 == 1)
			iWeight += 5;
		// case JSBR (XVAM || VSTA)
		//      a subordinating conjunction is often followed by preverb auxillary or Active verb
		//      Example: (In Thai) Because of , Because see
		else if (pos1 == 39 && (pos2 == 15 || pos2 == 12))
			iWeight += 10;
		// case ADVN NCMN
		//      a Adverb normal form is often followed by Common noun (Bug 55057).
		//      Example: (In Thai) under table.
		else if (pos1 == 28 && pos2 == 5)
			iWeight += 5;
		// case VACT XVAE
		else if (pos1 == 11 && pos2 == 18)
			iWeight += 5;
		// case VACT DDBQ
		//      Active verb follow by Definite determiner.
		//      Example: (In Thai) working for, singing again.
		else if (pos1 == 11 && pos2 == 21)
			iWeight += 10;
		// case VATT VACT
		//		adjective are followed by verb.
		//		Example: (In Thai keyboard)sivd;jk
		else if (pos1 == 13 && pos2 == 11)
			iWeight += 2;
		// case XVAE VACT
		//      a post verb auxilliary are often followed by an active verb.
		//      Example: (In Thai) come singing, go work.
		else if (pos1 == 18 && pos2 == 11)
			iWeight += 10;
		// case CLTV NCMN
		//      a Collective classfier are often followed by Common Noun
		//      Example: (In Thai) group people, flock bird
		else if (pos1 == 33 && pos2 == 5)
			iWeight += 5;
		// case NEG (VACT || VSTA || VATT || XVAM || XVAE)
		//      a negator (ie. not) is often followed by some kind of VERB.
		//      Example: He is not going.
		else if (pos1 == 46 && (pos2 == 11 || pos2 == 12 || pos2 == 13 || pos2 == 15 || pos2 == 16))
			iWeight += 8;
		// case EAFF or EITT
		//      Ending for affirmative, and interrogative are more often ending of the pair
		//      Example: (In Thai) Krub, Ka, 
		else if (pos2 == 44 || pos2 == 45)
			iWeight += 3;
		// case VATT and VATT
		//      Attributive Verb and Attributive Verb occur when often in spoken laguages.
		//      Example: she is reall really cute.  
		else if (pos1 == 13 && pos2 == 13)
			iWeight += 2;
		// case NCMN and DDAC
		//      Common Noun and Definitive determiner classifier.
		//      Example: Food here (Thai)
		else if (pos1 == 5 && pos2 == 20)
			iWeight += 3;
		// case CMTR and JCMP
		//      Measurement classifier and Comparative conjunction, are likly to appear in Thai.
		//      Example: year about (Thai) -> English about a year.
		else if (pos1 == 34 && pos2 == 38)
			iWeight += 5;
		// case XVBB and VACT
		else if (pos1 == 17 && pos2 == 11)
			iWeight += 5;
		// case NCMN and NCMN
		//      Common Noun and Common Noun
		//      Example: electric bulb(in thai)
		else if (pos1 == 5 && pos2 == 5)
			iWeight += 1;
	}

	DetermineFrequencyWeight(ExtractFrq(dwTag1), &iWeight);
	DetermineFrequencyWeight(ExtractFrq(dwTag2), &iWeight);
	return (float) iWeight;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CThaiBreakTree::TrigramProbablity(DWORD dwTag1,DWORD dwTag2,DWORD dwTag3)
{
	DWORD iWeight = 6;

    if ( (dwTag1 != TAGPOS_UNKNOWN) &&
         (dwTag2 != TAGPOS_UNKNOWN) &&
         (dwTag3 != TAGPOS_UNKNOWN) )
    {
        WCHAR pos1 = ExtractPOS(dwTag1);
        WCHAR pos2 = ExtractPOS(dwTag2);
        WCHAR pos3 = ExtractPOS(dwTag3);

		// optimization we if any POS is none than trigram shouldn't therefor no need to search.
		if ( pos1 != 0 && pos2 != 0 && pos3 != 0)
		{
			WCHAR posArray[4];
			posArray[0] = pos1;
			posArray[1] = pos2;
			posArray[2] = pos3;
			posArray[3] = 0;
			iWeight += thaiTrigramIter.GetProb(posArray);
		}
    }
	DetermineFrequencyWeight(ExtractFrq(dwTag1), &iWeight);
	DetermineFrequencyWeight(ExtractFrq(dwTag2), &iWeight);
	DetermineFrequencyWeight(ExtractFrq(dwTag3), &iWeight);
	
    // We reached zero probablity.
    return (DWORD)iWeight;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiBreakTree::TrigramBreak(WCHAR* pwchBegin, WCHAR* pwchEnd1)
{
    // Declare and initialize local variables.
    WCHAR* pwchBeginWord = pwchBegin;
    WCHAR* pwchIndex = pwchBegin;
    unsigned int iWordLen;
    unsigned int iNumCluster = 1;
    unsigned int iNumLastCluster;
    unsigned int iBreakIndex = 0;
    BYTE nextBreakArray[MAXBREAK];
    DWORD nextTagArray[MAXBREAK];
    unsigned int iNextBreakIndex;           // index for array nextBreakArray and nextTagArray.
    bool fFoundMatch;
    unsigned int iWeight;
    unsigned int iSumWeight;
    unsigned int iPrevWeight;
	unsigned int iCurrWeight;
    BYTE iSoundexWordLen;
    DWORD iPrevProbability;
    DWORD iCurrentProbability;
	DWORD dwTagTemp;
	DWORD dwLastTag;
    int i;                                  // temporary int for use as need.
    bool fBeginNewWord;
	bool fEndWord = false;

    pszEnd = pwchEnd1;
    breakArray[0] = 0;
    POSArray[0] = 0;
    tagArray[0] = 0;
    nextBreakArray[0] = 0;
    nextTagArray[0] = 0;

    while (true)
    {
        // Reset Iterator for generating break for new word.
        fFoundMatch = false;
        fBeginNewWord = true;


        // Get begin word string for next round of word break.
        pwchIndex = pwchBeginWord;        
        iNextBreakIndex = 0;

        if (pwchIndex == pszEnd)
            break;

        while(true)
        {
            iNumLastCluster = iNumCluster;
            iNumCluster = GetCluster(pwchIndex);
            if (!thaiTrieIter.MoveCluster(pwchIndex, iNumCluster, fBeginNewWord))
			{
				if ((iNumCluster == 0) && (pwchIndex == pszEnd))
					fEndWord = true;
				else
					break;
			}

            fBeginNewWord = false;
            pwchIndex += iNumCluster;
            if (thaiTrieIter.fWordEnd)
            {
				if (thaiTrieIter.m_fThaiNumber)
				{
					// If we have Thai number accumulate it as one break.
					assert(iNumCluster == 1);
					fFoundMatch = true;
					nextBreakArray[0]= (BYTE)(pwchIndex - pwchBeginWord);
					nextTagArray[0] = TAGPOS_NCNM;
					iNextBreakIndex = 1;
				}
				else
				{
					fFoundMatch = true;
					nextBreakArray[iNextBreakIndex] =  (BYTE)(pwchIndex - pwchBeginWord);
					nextTagArray[iNextBreakIndex] = thaiTrieIter.dwTag;
					iNextBreakIndex++;              
				}
				if (pwchIndex >= pszEnd)
				{
					assert(pwchIndex <= pszEnd);			// assert should never come up - if it appear likely bug in GetCluster funciton.
					assert(iNextBreakIndex != 0);

					if 	( iNumCluster == 1							&&
						  *(pwchIndex - 1) == L'.'					&&
						  iBreakIndex > 0							&&
						  iNextBreakIndex == 1						&&
						  tagArray[iBreakIndex - 1] == TAGPOS_ABBR	)
					{
						// backtrack one if we have abbrivation case.
						// ex. B.K.K. (in Thai). (more info O11.145042.)
						breakArray[iBreakIndex - 1] += nextBreakArray[iNextBreakIndex - 1];
						return iBreakIndex;
					}

					breakArray[iBreakIndex] = nextBreakArray[iNextBreakIndex - 1];
					tagArray[iBreakIndex] = nextTagArray[iNextBreakIndex - 1];
					return (++iBreakIndex);
				}
            }
            else if ((pwchIndex >= pszEnd && iNextBreakIndex == 0) || fEndWord)
            {
                assert(pwchIndex <= pszEnd);			// assert should never come up - if it appear likely bug in GetCluster funciton.
                iWordLen = (unsigned int) (pwchIndex - pwchBeginWord);
                switch (iWordLen)
                {
                case 0:
                    if (iBreakIndex > 0)
                    {
                        // if We have a length of one character add it to previous node.
                        breakArray[iBreakIndex - 1] +=  (BYTE) iNumCluster;
                        tagArray[iBreakIndex - 1] = TAGPOS_UNKNOWN;
                    }
                    else
                    {
                        // if this is the first break create a new break.
                        breakArray[iBreakIndex] = (BYTE) iNumCluster;
                        tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                        iBreakIndex++;
                    }
                    break;
                case 1:
                    if (iBreakIndex > 0)
                    {
                        // if We have a length of one character add it to previous node.
                        breakArray[iBreakIndex - 1] +=  (BYTE) iWordLen;
                        tagArray[iBreakIndex - 1] = TAGPOS_UNKNOWN;
                    }
                    else
                    {
                        // if this is the first break create a new break.
                        breakArray[iBreakIndex] =  (BYTE) iWordLen;
                        tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                        iBreakIndex++;
                    }
                    break;
                default:
					if ( iBreakIndex > 0 &&
						 ShouldMerge(pwchBeginWord - breakArray[iBreakIndex - 1], breakArray[iBreakIndex - 1],
						             iWordLen , tagArray[iBreakIndex - 1]) )
					{
						breakArray[iBreakIndex - 1] += (BYTE) iWordLen;
						tagArray[iBreakIndex - 1] = TAGPOS_UNKNOWN;
					}
					else
					{
						breakArray[iBreakIndex] = (BYTE) iWordLen;
						tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
						iBreakIndex++;
					}
                }
                return iBreakIndex;
            }
			else if (pwchIndex >= pszEnd)
			{
				// O10.229346. If we get here we are at the end of word or end of sentence,
				// We will need to decide what to depending on if we found the word or not.
				break;
			}
        }

		if (fFoundMatch)        // Longest Matching.
		{
            // If we only found one break, than say it the maximum.
            if (1 == iNextBreakIndex)
			{
				if (	nextBreakArray[0] == 2						&&
						iNumCluster + iNumLastCluster == 2			&&
						iBreakIndex > 0								&&
						*(pwchBeginWord+1) == L'.'					&&
						tagArray[iBreakIndex - 1] == TAGPOS_ABBR	)
				{
					// backtrack one if we have abbrivation case.
					// ex. B.K.K. (in Thai). (more info O11.145042.)
					breakArray[iBreakIndex - 1] += nextBreakArray[0];
					pwchBeginWord += nextBreakArray[0];
				}
				else if (	iBreakIndex > 0						&&
							IsThaiEndingSign(*pwchBeginWord)	&&
							iNumCluster == 1					)
				{
					breakArray[iBreakIndex - 1] += nextBreakArray[0];
					pwchBeginWord += nextBreakArray[0];

				}
				else
				{
					breakArray[iBreakIndex] = nextBreakArray[0];
					tagArray[iBreakIndex] = nextTagArray[0];
					pwchBeginWord += breakArray[iBreakIndex];          // update begin word for next round.
					iBreakIndex++;
				}
			}
			else
            {
				bool fWeightCompare = false;

                iSumWeight = 0;
                iPrevWeight = 0;
				iCurrWeight = 0;
                iPrevProbability = 0;
                iCurrentProbability = 0;
				dwLastTag = TAGPOS_UNKNOWN;
				tagArray[iBreakIndex] = TAGPOS_UNKNOWN;

                for (i = (iNextBreakIndex - 1); i >= 0 ; i--)
			    {
					if ( iBreakIndex == 0)
					{
						iWeight = GetWeight(pwchBeginWord + nextBreakArray[i], &dwTagTemp);

						if (iWeight != 0)
							// Bigram Probability
							iCurrentProbability = (DWORD)BigramProbablity(nextTagArray[i], dwTagTemp);
					}
					else
					{
						iWeight = GetWeight(pwchBeginWord + nextBreakArray[i], &dwTagTemp);

						if (iBreakIndex == 1)
							// Get Trigram Probability.
							iCurrentProbability = TrigramProbablity(tagArray[iBreakIndex - 1], nextTagArray[i], dwTagTemp);	
						else if (iBreakIndex >= 2)
						{
							// Get Trigram Probability.
							iCurrentProbability = TrigramProbablity(tagArray[iBreakIndex - 2], tagArray[iBreakIndex - 1], nextTagArray[i]);
							if (iWeight != 0)
								iCurrentProbability += (DWORD)BigramProbablity(nextTagArray[i],dwTagTemp);
						}
					}

					fWeightCompare = false;

					iCurrWeight = iWeight + nextBreakArray[i];

					if (iPrevProbability == 0 && (iCurrWeight+1) == iSumWeight && iCurrentProbability > 5)
					{
						fWeightCompare = true;
					}
					else if (iCurrWeight == iSumWeight && ( Maximum(iWeight,nextBreakArray[i]) <= iPrevWeight ||
															iCurrentProbability > iPrevProbability))
					{
						fWeightCompare = true;
					}
					else if (	iWeight >= iPrevWeight - 1						&& 
								iPrevProbability > 0 && iPrevProbability < 10	&&
								iCurrentProbability > iPrevProbability * 5000	)
					{
						// O11.187913.  We'll trust our trigram data more if the current probability is
						// so much greater than previous probability.
						//
						// * Note: we could probably use one of GA algorithm to get better value than 5K.
						fWeightCompare = true;
					}

                    // Store the string the best maximum weight, if the pair is equal
                    // store the string with maxim
				    if ( iCurrWeight > iSumWeight             ||
						 fWeightCompare)
//    					 ( (iCurrWeight == iSumWeight)          &&
//                           ( (Maximum(iWeight,nextBreakArray[i]) <= iPrevWeight) || (iCurrentProbability > iPrevProbability) ) ))
	    			{
                        if (iCurrentProbability >= iPrevProbability || iSumWeight < iCurrWeight)
                        {
					        iSumWeight = Maximum(iWeight,1) + nextBreakArray[i];
					        iPrevWeight = Maximum(iWeight,nextBreakArray[i]);
                            breakArray[iBreakIndex] = nextBreakArray[i];
                            tagArray[iBreakIndex] = nextTagArray[i];
                            iPrevProbability = iCurrentProbability;
							dwLastTag = dwTagTemp;
                        }
				    }
			    }
		        pwchBeginWord += breakArray[iBreakIndex];          // update begin word for next round.
	            iBreakIndex++;
            }
		}
        else
        {
            // NOMATCH_FOUND
            iWordLen = (unsigned int)(pwchIndex - pwchBeginWord);
            if (iBreakIndex > 0)
            {
                i = iBreakIndex - 1;        // set i to previous break
                if (iWordLen == 0)
                {
					if (iNumCluster == 1 && *pwchBeginWord == L',' &&
						IsThaiChar(*(pwchBeginWord-breakArray[i])) )
					{
						// We should not merge comma into the word, only merge comma to
						// Number.
						// TODO: Should add TAGPOS_PUNCT.
                        breakArray[iBreakIndex] = (BYTE) iNumCluster;
                        tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                        pwchBeginWord += (BYTE) iNumCluster;   // update begin word for next round.
                        iBreakIndex++;
					}
					else if (iNumCluster > 1 && *pwchBeginWord == L'.')
					{
						// O11.134455. This is an ellipse case we shouldn't merge this string.
                        breakArray[iBreakIndex] = (BYTE) iNumCluster;
                        tagArray[iBreakIndex] = TAGPOS_PUNC;
                        pwchBeginWord += (BYTE) iNumCluster;   // update begin word for next round.
                        iBreakIndex++;
					}
                    else if (ShouldMerge(pwchBeginWord - breakArray[i], breakArray[i], iNumCluster, tagArray[i]))
                    {
                        // If word length is null use the cluster add to previous node.
                        breakArray[i] += (BYTE) iNumCluster;
                        tagArray[i] = TAGPOS_UNKNOWN;
                        pwchBeginWord += iNumCluster;          // update begin word for next round.
                    }
                    else
                    {
                        // Add the unknown word to list.
                        breakArray[iBreakIndex] = (BYTE) iNumCluster;
                        tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                        pwchBeginWord += (BYTE) iNumCluster;   // update begin word for next round.
                        iBreakIndex++;
                    }
                }
                else
                {
					// Try checking for abbrivations.
					if (iWordLen == 1 && iNumCluster == 2 && pwchIndex[1] == L'.')
					{
						// The word is an abbrivated words.
						// TODO: #1. Add TAGPOS_ABBRV.
						// TODO: #2. May need to add rules code abbrivated word with 3 letters.
						breakArray[iBreakIndex] = iWordLen + iNumCluster;
						tagArray[iBreakIndex] = TAGPOS_ABBR;
	                    pwchBeginWord += breakArray[iBreakIndex];
                        iBreakIndex++;
					}
					else if (iWordLen == 1						&&
							 tagArray[i] == TAGPOS_ABBR			&&
							 *(pwchBeginWord+1) == L'.'			&&
							 IsThaiConsonant(*pwchBeginWord)	&&
							 pwchBeginWord+1 < pszEnd )
					{
						// O11.145042. This is the case where we are a <abbrivated><consonant><period>, the
						// likely hood is the character is also an abbrivation.
						breakArray[iBreakIndex - 1] += iWordLen + 1;
	                    pwchBeginWord += iWordLen + 1;
					}
					// Abbreviation are usally 3 characters.
                    else if (	iWordLen == 2						&&
								IsThaiConsonant(*(pwchBeginWord+2))	&&
								*(pwchBeginWord+3) == L'.'				&&
								tagArray[i] != TAGPOS_UNKNOWN		)
					{
						// O11.80619. This is the case where we are a <known word><abbrivated>
						breakArray[iBreakIndex] = iWordLen + 1;
						tagArray[iBreakIndex] = TAGPOS_ABBR;
	                    pwchBeginWord += breakArray[iBreakIndex];
                        iBreakIndex++;
					}
					// Perhase Misspelled word try use sounding to spell the words.
                    // Try soundex two word back.
                    else if ( (iBreakIndex >= 2)																																&&
                         ( (iSoundexWordLen = (BYTE) SoundexSearch(pwchBeginWord - breakArray[i] - breakArray[i - 1])) > (BYTE) (breakArray[i] + breakArray[i - 1]) )	&&
                            GetWeight(pwchBeginWord - breakArray[i] - breakArray[i - 1] + iSoundexWordLen) )
                    {
                        // Resize the word.
                        pwchBeginWord = (pwchBeginWord - breakArray[i] - breakArray[i - 1]) + iSoundexWordLen;          // update begin word for next round.
                        breakArray[i - 1] = iSoundexWordLen;
                        tagArray[i - 1] = thaiTrieIter.dwTag;
                        iBreakIndex--;                         // Decrement iBreakIndex.
                    }
                    // Try soundex one words back.
                    else if (((iSoundexWordLen = (BYTE) SoundexSearch(pwchBeginWord - breakArray[i])) > (BYTE) breakArray[i]) &&
                            GetWeight(pwchBeginWord - breakArray[i] + iSoundexWordLen) &&
							ExtractPOS(tagArray[i]) != 6)  // Make sure that previous word is not a NTTL.
                    {
                        // Resize the word
                        pwchBeginWord = (pwchBeginWord - breakArray[i]) + iSoundexWordLen;          // update begin word for next round.
                        breakArray[i] = iSoundexWordLen;
                        tagArray[i] = thaiTrieIter.dwTag;
                    }
                    // Try soundex on this word.
                    else if (((iSoundexWordLen = (BYTE) SoundexSearch(pwchBeginWord)) > (BYTE) iWordLen) &&
                            GetWeight(pwchBeginWord + iSoundexWordLen) )
                    {
                        // Resize the word.
                        breakArray[iBreakIndex] = iSoundexWordLen;
                        tagArray[iBreakIndex] = thaiTrieIter.dwTag;
                        pwchBeginWord += iSoundexWordLen;          // update begin word for next round.
                        iBreakIndex++;
                    }
                    else if ( ShouldMerge(pwchBeginWord - breakArray[i], breakArray[i], iWordLen , tagArray[i]) )
                    {
                        // Merge the words.
                        breakArray[i] += (BYTE) iWordLen;
                        tagArray[i] = TAGPOS_UNKNOWN;
                        pwchBeginWord += iWordLen;          // update begin word for next round.
                    }
                    else
                    {
                        // Add the unknown word to list.
                        breakArray[iBreakIndex] = (BYTE) iWordLen;
                        tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                        pwchBeginWord += iWordLen;          // update begin word for next round.
                        iBreakIndex++;
                    }
                }
            }
            else
            {
                // Add unknown word to list and mark it.
                if (iWordLen == 0)
                {
                    // If word length is null use the cluster add to previous node.
                    breakArray[iBreakIndex] = (BYTE) iNumCluster;
                    tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                    pwchBeginWord += iNumCluster;          // update begin word for next round.
                }
                else
                {
					// We we are here there are 2 case that can happen:
					// 1. We take too little into our unknown.
					// 2. We take too much into our unknown word.

					// Have we taken too little check if this unknown word is an abbrivated words.
					if (iWordLen == 1 && iNumCluster == 2 && pwchIndex[1] == L'.')
						breakArray[iBreakIndex] = iWordLen + iNumCluster;
					// Try to see if we are taking to much, see if we can get a Weight from last cluster.
                    else if ( (iWordLen - iNumLastCluster > 0) && GetWeight(pwchIndex - iNumLastCluster) )
					{
                        breakArray[iBreakIndex] = iWordLen - iNumLastCluster;
						if (breakArray[iBreakIndex] == 1)
						{
							iWeight = GetWeight(pwchIndex - iNumLastCluster);
							if (iWeight > iNumLastCluster && iWeight < 40)
								breakArray[iBreakIndex] += (BYTE) iWeight;
							else
								breakArray[iBreakIndex] += (BYTE) iNumLastCluster;

						}
					}
					// We may have a case of iWordLen is 1 and iNumCluster, we have a case of misspelled
					// an extra character is incorrectly inserted over a correct word.
                    else if (iWordLen == 1)
					{
						iWeight = GetWeight(pwchIndex - iWordLen);
						if (iWeight > iNumCluster && iWeight < 40)
							breakArray[iBreakIndex] = iWordLen + iWeight;
						else
							breakArray[iBreakIndex] = iWordLen + iNumCluster;
					}
					else
                        breakArray[iBreakIndex] = (BYTE) iWordLen;
					if (iNumLastCluster + iNumCluster == iWordLen && *(pwchBeginWord+iNumLastCluster) == L'.')
					{
						tagArray[iBreakIndex] = TAGPOS_ABBR;
					}
					else
						tagArray[iBreakIndex] = TAGPOS_UNKNOWN;

                    pwchBeginWord += breakArray[iBreakIndex];    // update begin word for next round.
                }
                iBreakIndex++;
            }
        }
    }
    return iBreakIndex;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiBreakTree::Soundex(WCHAR* word)
{
    return thaiTrieIter.Soundex(word);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCluster
//
//  Synopsis:   The function return the next number of character which represent
//              a cluster of Thai text.
//
//              ie. Kor Kai, Kor Kai -> 1
//                  Kor Kai, Sara Um -> 2
//
//              * Note this function will not return no more than 3 character,
//                for cluster as this would represent invalid sequence of character.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiBreakTree::GetCluster(const WCHAR* pszIndex)
{
    bool fHasSaraE;
    int iRetValue = 0;
    bool fNeedEndingCluster = false;

	if (pszIndex == pszEnd)
		return 0;

    while (true)
    {
        fHasSaraE= false;

        // Take all begin cluster character.
        while (IsThaiBeginClusterCharacter(*pszIndex))
        {
            if (*pszIndex == THAI_Vowel_Sara_E)
                fHasSaraE = true;
            pszIndex++;
            iRetValue++;

        }

        if (IsThaiConsonant(*pszIndex))
        {
            pszIndex++;
            iRetValue++;

            while (IsThaiUpperAndLowerClusterCharacter(*pszIndex))
            {
                // Mai Han Akat is a special type of cluster that will need at lease
                // one ending cluster.
                if (*pszIndex == THAI_Vowel_Sign_Mai_HanAkat)
                    fNeedEndingCluster = true;

                // In Thai it isn't possible to make a sound if we have the SaraE
                // following by vowel below vowel.
                else if ( fHasSaraE                             &&
                        ( (*pszIndex == THAI_Vowel_Sara_II)     || 
                          (*pszIndex == THAI_Tone_MaiTaiKhu)    ||
                          (*pszIndex == THAI_Vowel_Sara_I)      ||
                          (*pszIndex == THAI_Sara_Uee)          ))
                    fNeedEndingCluster = true;
                pszIndex++;
                iRetValue++;
            }

            while (IsThaiEndingClusterCharacter(*pszIndex))
            {
                pszIndex++;
                iRetValue++;
                fNeedEndingCluster = false;
            }
/*
			// Include period as part of a cluster.  Bug#57106
			if (*pszIndex == 0x002e)
			{
				pszIndex++;
				iRetValue++;
				fNeedEndingCluster = false;
			}
*/
        }

        if (fNeedEndingCluster)
            fNeedEndingCluster = false;
        else
            break;
    }

    if (iRetValue == 0)
	{
		// O11.134455.  Ellipse case we go to combine ellipses to one cluster.
		if (*pszIndex == 0x002e)
		{
			while (*pszIndex == 0x002e && pszIndex <= pszEnd)
			{
				pszIndex++;
				iRetValue++;
			}
		}
		else
	        iRetValue++;   // The character is probably a punctuation.
	}

	if (pszIndex > pszEnd)
	{
		// We need to do this as we have gone over end buff boundary.
		iRetValue -= (int) (pszIndex - pszEnd);
		pszIndex = pszEnd;
	}
    return iRetValue;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//				
//  Arguments:
//
//			wzWord			- input string.								(in)
//			iWordLen		- input string length.						(in)	
//			Alt				- find close alternate word					(in)
//			pBreakPos		- array of break position allways 5 byte.	(out)
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiBreakTree::FindAltWord(WCHAR* pwchBegin,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos)
{
    // Declare and initialize local variables.
    unsigned int iNumCluster = 1;
	WCHAR* pwchBeginWord = pwchBegin;
    WCHAR* pwchIndex = pwchBegin;
	bool fBeginNewWord = true;
	unsigned int iBreakIndex = 0;
	unsigned int iBreakTemp  = 0;
	unsigned int iBreakTemp1 = 0;
	unsigned int iBreakTemp2 = 0;

	pszEnd = pwchBegin + iWordLen;
    
	// TODO: Need to clean this code up.
	switch(Alt)
	{
	case 3:
		while (true)
		{
			iNumCluster = GetCluster(pwchIndex);

			if (!thaiTrieIter1.MoveCluster(pwchIndex, iNumCluster, fBeginNewWord))
				return iBreakIndex;

			fBeginNewWord = false;
			pwchIndex += iNumCluster;
			if (thaiTrieIter1.fWordEnd)
			{
				iBreakTemp  = (unsigned int)(pwchIndex - pwchBeginWord);

				// reached the end of word unable to find alt word.
				if (iBreakTemp >= iWordLen)
					return 0;

				iBreakTemp1 = GetWeight(pwchIndex);

				// reached the end of word unable to find alt word.
				if (iBreakTemp + iBreakTemp1 >= iWordLen)
					return 0;

				iBreakTemp2 = GetWeight(pwchIndex+iBreakTemp1);
				if (iBreakTemp + iBreakTemp1 + iBreakTemp2 == iWordLen)
				{
					pBreakPos[0] = (BYTE)iBreakTemp;
					pBreakPos[1] = (BYTE)iBreakTemp1;
					pBreakPos[2] = (BYTE)iBreakTemp2;
					return 3;
				}
			}
			if (pwchIndex >= pszEnd)
				return iBreakIndex;
		}
		break;
	case 2:
		while (true)
		{
			iNumCluster = GetCluster(pwchIndex);

			if (!thaiTrieIter1.MoveCluster(pwchIndex, iNumCluster, fBeginNewWord))
				return iBreakIndex;

			fBeginNewWord = false;
			pwchIndex += iNumCluster;
			if (thaiTrieIter1.fWordEnd)
			{
				iBreakTemp  = (unsigned int)(pwchIndex - pwchBeginWord);

				// reached the end of word unable to find alt word.
				if (iBreakTemp >= iWordLen)
					return 0;

				iBreakTemp1 = GetWeight(pwchIndex);
				if (iBreakTemp + iBreakTemp1  == iWordLen)
				{
					pBreakPos[0] = (BYTE)iBreakTemp;
					pBreakPos[1] = (BYTE)iBreakTemp1;
					return 2;
				}
			}
			if (pwchIndex >= pszEnd)
				return iBreakIndex;
		}
		break;
	default:
	case 1:
		while (iBreakIndex < Alt)
		{
			iNumCluster = GetCluster(pwchIndex);

			if (!thaiTrieIter1.MoveCluster(pwchIndex, iNumCluster, fBeginNewWord))
				return iBreakIndex;

			fBeginNewWord = false;
			pwchIndex += iNumCluster;
			if (thaiTrieIter1.fWordEnd)
			{
				fBeginNewWord = true;

				iBreakTemp  = (unsigned int)(pwchIndex - pwchBeginWord);

				// reached the end of word unable to find alt word.
				if (iBreakTemp >= iWordLen)
					return 0;

				iBreakTemp1 = GetLongestSubstring(pwchBeginWord,iWordLen);

				if (iBreakTemp1 > iBreakTemp && iBreakTemp1 < iWordLen)
					pBreakPos[iBreakIndex] = (BYTE) iBreakTemp1;
				else
					pBreakPos[iBreakIndex] =  (BYTE) iBreakTemp;
				pwchBeginWord += pBreakPos[iBreakIndex];
				iWordLen -= pBreakPos[iBreakIndex];
				iBreakIndex++;
			}
			if (pwchIndex >= pszEnd)
				return iBreakIndex;
		}
		break;
    }

	return iBreakIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthaisenttrieiter.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiSentTrieIter
//
//  History:
//      created 8/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "CThaiSentTrieIter.hpp"

//+---------------------------------------------------------------------------
//
//  Class:   CThaiSentTrieIter
//
//  Synopsis:   Bring interation index to the first node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiSentTrieIter::GetNode()
{
	pos = (WCHAR) trieScan.wch - 0x0100;
	fWordEnd = (trieScan.wFlags & TRIE_NODE_VALID) &&
				(!(trieScan.wFlags & TRIE_NODE_TAGGED) ||
				(trieScan.aTags[0].dwData & iDialectMask));

	if (fWordEnd)
	{
        dwTag = (DWORD) (trieScan.wFlags & TRIE_NODE_TAGGED ?
                            trieScan.aTags[0].dwData :
                            0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthaisenttrieiter.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiSentTrieIter - contain the header for class CThaiSentTrieIter
//
//  History:
//      created 8/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAISENTTRIEITER_HPP_
#define _CTHAISENTTRIEITER_HPP_

#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "lexheader.h"
#include "trie.h"
//#include "NLGlib.h"
#include "ProofBase.h"
#include "thwbdef.hpp"
#include "CTrie.hpp"

class CThaiSentTrieIter : public CTrieIter {
public:
	void GetNode();
    WCHAR pos;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthaibreaktree.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiBreakTree - class CThaiBreakTree 
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAIBREAKTREE_H_
#define _CTHAIBREAKTREE_H_

#include <windows.h>
#include <assert.h>
#include "CThaiTrieIter.hpp"
#include "CThaiSentTrieIter.hpp"
#include "CThaiTrigramTrieIter.hpp"
#include "CBreakTree.hpp"
#include "lextable.hpp"

#define MAXTHAIBREAKNODE    255000
#define MAXUNSIGNEDINT      4294967295
#define UNABLETOCREATENODE  MAXUNSIGNEDINT

class CThaiWordBreak;

class ThaiBreakNode
{
public:
    ThaiBreakNode() {};

	int iPos;
	BYTE iBreakLen;
    DWORD dwTAG;
	unsigned int NextBreak;
	unsigned int Down;
};

class CThaiBreakTree : public CBreakTree
{
    friend class CThaiWordBreak;
public:
	CThaiBreakTree();
	~CThaiBreakTree();

#if defined (NGRAM_ENABLE)
	void Init(CTrie* pTrie, CTrie* pSentTrie, CTrie* pTrigramTrie);
#else
	void Init(CTrie* pTrie, CTrie* pTrigramTrie);
#endif

#if defined (NGRAM_ENABLE)
	inline void Reset();
	inline bool MoveNext();
	inline bool MoveDown();
    inline unsigned int CreateNode(int iPos, BYTE iBreakLen, DWORD dwPOS);
    bool GenerateTree(WCHAR* pszBegin, WCHAR* pszEnd);
    bool MaximalMatching();
#endif
    int Soundex(WCHAR* word);

    unsigned int TrigramBreak(WCHAR* pwchBegin, WCHAR* pwchEnd);
	int FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos);

protected:
#if defined (NGRAM_ENABLE)
    inline DWORD DeterminePurgeOrUnknown(unsigned int iCurrentNode, unsigned int iBreakLen);
    inline void DeterminePurgeEndingSentence(WCHAR* pszBeginWord, unsigned int iNode);
#endif
    inline unsigned int Maximum(unsigned int x, unsigned y) { if (x > y) return x; else return y;}

	unsigned int GetLongestSubstring(WCHAR* pszBegin, unsigned int iWordLen);
    unsigned int GetWeight(WCHAR* pszBegin);
	unsigned int GetWeight(WCHAR* pszBegin, DWORD* pdwTag);
	float BigramProbablity(DWORD dwTag1,DWORD dwTag2);
    DWORD TrigramProbablity(DWORD dwTag1,DWORD dwTag2,DWORD dwTag3);
    unsigned int SoundexSearch(WCHAR* pszBegin);
    inline bool ShouldMerge(const WCHAR* pwszPrevWord, unsigned int iPrevWordLen, unsigned int iMergeWordLen, DWORD dwPrevTag);
    bool Traverse(unsigned int iLevel, unsigned int iCurrentNode, unsigned int iNumUnknown);
    unsigned int GetCluster(const WCHAR* pszIndex);


    void MaximalMatchingAddBreakToList(unsigned int iNumBreak);
    inline void AddBreakToList(unsigned int iNumBreak, unsigned int iNumUnknown);
    inline bool CompareSentenceStructure(unsigned int iNumBreak, unsigned int iNumUnknown);
    bool IsSentenceStruct(const WCHAR* pos, unsigned int iPosLen);

	ThaiBreakNode* breakTree;

    CThaiTrieIter thaiTrieIter;
    CThaiTrieIter thaiTrieIter1;
    CThaiSentTrieIter thaiSentIter;
	CThaiTrigramTrieIter thaiTrigramIter;
    
	WCHAR* pszBegin;
	WCHAR* pszEnd;

	unsigned int iNodeIndex;
	unsigned int iNumNode;

    // Array of break and part-of-speech use for Traverse the Tree.
    BYTE* breakArray;
    DWORD* tagArray;
    WCHAR* POSArray;
    unsigned int iNumUnknownMaximalPOSArray;

    // Array of break for use with maximal matching array;
    unsigned int maxToken;
    unsigned int maxLevel;
    BYTE* maximalMatchingBreakArray;
    DWORD* maximalMatchingTAGArray;
    WCHAR* maximalMatchingPOSArray;

    // Array of break for use with trigram array.
    BYTE* trigramBreakArray;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthaitrieiter.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiTrieIter - class CThaiTrieIter use for traversing trie.
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAITRIEITER_H_
#define _CTHAITRIEITER_H_

#include "ctrie.hpp"
#include "thwbdef.hpp"
#include "WB_Asserts.h"
#include "lextable.hpp"
#include "wzmanip.h"
BOOL IsThaiUpperAndLowerClusterCharacter(WCHAR wc);
BOOL IsThaiBeginClusterCharacter(WCHAR wc);
BOOL IsThaiEndingClusterCharacter(WCHAR wc);
BOOL IsThaiConsonant(WCHAR wc);
bool IsThaiMostlyBeginCharacter(WCHAR wc);
bool IsThaiMostlyLastCharacter(WCHAR wc);
bool IsContain(const WCHAR* pwcWord, unsigned int iWordLen, WCHAR wc);
bool IsThaiEndingSign(WCHAR wc);
//unsigned int GetCluster(WCHAR* pszIndex);
DWORD POSCompress(const WCHAR* szTag);
WCHAR* POSDecompress(DWORD dwTag);



enum SOUNDEXSTATE {
                        UNABLE_TO_MOVE,
                        NOSUBSTITUTE,
                        SUBSTITUTE_DIACRITIC,
                        SUBSTITUTE_SOUNDLIKECHAR,
						STOP_MOVE
                   };

class CThaiTrieIter : public CTrieIter {
public:
    CThaiTrieIter();
    ~CThaiTrieIter();
    void Init(CTrie* ctrie);
	BOOL MoveCluster(const WCHAR* szCluster, unsigned int iNumCluster);
    bool MoveCluster(WCHAR* szCluster, unsigned int iNumCluster, bool fBeginNewWord);
    SOUNDEXSTATE MoveSoundexByCluster(WCHAR* szCluster, unsigned int iNumCluster, unsigned int iNumNextCluster);
    int Soundex(WCHAR* word);
	bool m_fThaiNumber;
protected:
    unsigned int GetScore(WCHAR* idealWord, WCHAR* soundLikeWord);
    bool Traverse(unsigned int iCharPos, unsigned int scoring);
	inline void CopyScan();

	// Trie Iterator - extra iterator for use as 
	TRIESCAN trieScan1;

    WCHAR* soundexWord;
    WCHAR* resultWord;
    WCHAR* tempWord;
    unsigned int iResultScore;

    // For optimization quick look up table.
    TRIESCAN* pTrieScanArray;
private:
    bool CheckNextCluster(const WCHAR* szCluster, unsigned int iNumCluster);
    bool GetScanFirstChar(WCHAR wc, TRIESCAN* pTrieScan);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthaitrieiter.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiTrieIter - class CThaiTrieIter use for traversing trie.
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "CThaiTrieIter.hpp"

#define WORDSIZE 64
static unsigned int iStackSize = 0;

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiBeginClusterCharacter
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsThaiBeginClusterCharacter(WCHAR wc)
{
    return ( ( wc >= THAI_Vowel_Sara_E ) && (wc <= THAI_Vowel_Sara_AI_MaiMaLai) );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiUpperAndLowerClusterCharacter
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsThaiUpperAndLowerClusterCharacter(WCHAR wc)
{
	return (	( (wc == THAI_Vowel_Sign_Mai_HanAkat) )									||
				( (wc >= THAI_Vowel_Sign_Sara_Am) && (wc <= THAI_Vowel_Sign_Phinthu) )	||
				( (wc >= THAI_Tone_MaiTaiKhu) && (wc <= THAI_Nikhahit) )   );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiEndingClusterCharacter
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsThaiEndingClusterCharacter(WCHAR wc)
{
    return ( 
			 // (wc == THAI_Sign_PaiYanNoi)    || // take this line out to fix O11.PaiYanNoi issue.
             (wc == THAI_Vowel_Sara_A)      ||
             (wc == THAI_Vowel_Sara_AA)     ||
             (wc == THAI_Vowel_LakKhangYao) ||
             (wc == THAI_Vowel_MaiYaMok)    );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiMostlyBeginCharacter
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool IsThaiMostlyBeginCharacter(WCHAR wc)
{
    return ( (wc >= THAI_Vowel_Sara_E && wc <= THAI_Vowel_Sara_AI_MaiMaLai) || // Character always in front of a word.
             (wc == THAI_Cho_Ching)                                         || // Character always in front of a word.
             (wc == THAI_Pho_Phung)                                         || // Character always in front of a word.
             (wc == THAI_Fo_Fa)                                             || // Character always in front of a word.
             (wc == THAI_Ho_Nok_Huk)                                        || // Character always in front of a word.
             (wc == THAI_Ho_Hip)                                            || // Character most like in front of a word.
             (wc == THAI_Pho_Samphao)                                       || // Character most like in front of a word.
             (wc == THAI_Kho_Rakhang)                                       || // Character most like in front of a word.
             (wc == THAI_Fo_Fan)                                            || // Character most like in front of a word.
             (wc == THAI_So_So)                                             || // Character most like in front of a word.
             (wc == THAI_Tho_NangmonTho)                                    ); // Character most like in front of a word.
}

//+---------------------------------------------------------------------------
//
//  Function:   IsContain
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool IsContain(const WCHAR* pwcWord, unsigned int iWordLen, WCHAR wc)
{
	const WCHAR* pwc = pwcWord;
	const WCHAR* pwcEnd = pwcWord + iWordLen;

	while (pwc < pwcEnd)
	{
		if (*pwc == wc)
			return true;
		pwc++;
	}

	return false;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiMostlyLastCharacter
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool IsThaiMostlyLastCharacter(WCHAR wc)
{
    return ( (wc == THAI_Vowel_Sign_Sara_Am) || // Always the end of word.
             (wc == THAI_Sign_PaiYanNoi)     || // Always the end of word.
             (wc == THAI_Vowel_MaiYaMok)     || // Always the end of word.
             (wc == THAI_Vowel_LakKhangYao)  || // Most likely the end of word.
             (wc == THAI_Thanthakhat)        ); // Most likely the end of word.

}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiToneMark
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool IsThaiToneMark(WCHAR wc)
{
    return ( (wc >= 0x0e48) && (wc <= 0x0e4b) ||
             (wc == 0x0e31));

}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiEndingSign
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/02 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool IsThaiEndingSign(WCHAR wc)
{
	return ((bool) (wc == THAI_Vowel_MaiYaMok || wc == THAI_Sign_PaiYanNoi));
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCluster
//
//  Synopsis:   The function return the next number of character which represent
//              a cluster of Thai text.
//
//              ie. Kor Kai, Kor Kai -> 1
//                  Kor Kai, Sara Um -> 2
//
//              * Note this function will not return no more than 3 character,
//                for cluster as this would represent invalid sequence of character.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
/*
unsigned int GetCluster(WCHAR* pszIndex)
{
    int iRetValue = 0;

    // Take all begin cluster character.
    while (IsThaiBeginClusterCharacter(*pszIndex))
    {
        pszIndex++;
        iRetValue++;
    }

    if (IsThaiConsonant(*pszIndex))
    {
        pszIndex++;
        iRetValue++;

        while (IsThaiUpperAndLowerClusterCharacter(*pszIndex))
        {
            pszIndex++;
            iRetValue++;
        }

        while (IsThaiEndingClusterCharacter(*pszIndex))
        {
            pszIndex++;
            iRetValue++;
        }
    }

    if (iRetValue == 0)
        // The character is probably a punctuation.
        iRetValue++;

    return iRetValue;
}

*/
//+---------------------------------------------------------------------------
//
//  Function:   IsThaiConsonant
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsThaiConsonant(WCHAR wc)
{
	return ( (wc >= THAI_Ko_Kai) && (wc <= THAI_Ho_Nok_Huk) );
}

//+---------------------------------------------------------------------------
//
// Define the different part of speech for Thai.
//
//----------------------------------------------------------------------------
WCHAR wzPOSLookup[POSTYPE][46] =
							{	L"NONE",				// 0 . No tags.
								L"NPRP",				// 1 . Proper noun
								L"NCNM",				// 2 . Cardinal number
								L"NONM",				// 3 . Ordinal number
								L"NLBL",				// 4 . Label noun
								L"NCMN",				// 5 . Common noun
								L"NTTL",				// 6 . Title noun
								L"PPRS",				// 7 . Personal pronoun
								L"PDMN",				// 8 . Demonstrative pronoun
								L"PNTR",				// 9 . Interrogative pronoun
								L"PREL",				// 10. Relative pronoun
								L"VACT",				// 11. Active verb
								L"VSTA",				// 12. Stative verb
								L"VATT",				// 13. Attributive verb
								L"XVBM",				// 14. Pre-verb auxiliary, before negator
								L"XVAM",				// 15. Pre-verb auxiliary, after negator
								L"XVMM",				// 16. Pre-verb, before or after negator
								L"XVBB",				// 17. Pre-verb auxiliary, in imperative mood
								L"XVAE",				// 18. Post-verb auxiliary
								L"DDAN",				// 19. Definite determiner, after noun without classifier in between
								L"DDAC",				// 20. Definite determiner, allowing classifier in between
								L"DDBQ",				// 21. Definite determiner, between noun and classifier or preceding quantitative expression
								L"DDAQ",				// 22. Definite determiner, following quantitative expression
								L"DIAC",				// 23. Indefinite determiner, following noun; allowing classifier in between
								L"DIBQ",				// 24. Indefinite determiner, between noun and classifier or preceding quantitative expression
								L"DIAQ",				// 25. Indefinite determiner, following quantitative expression
								L"DCNM",				// 26. Determiner, cardinal number expression
								L"DONM",				// 27. Determiner, ordinal number expression
								L"ADVN",				// 28. Adverb with normal form
								L"ADVI",				// 29. Adverb with iterative form
								L"ADVP",				// 30. Adverb with prefixed form
								L"ADVS",				// 31. Sentential adverb
								L"CNIT",				// 32. Unit classifier
								L"CLTV",				// 33. Collective classifier
								L"CMTR",				// 34. Measurement classifier
								L"CFQC",				// 35. Frequency classifier
								L"CVBL",				// 36. Verbal classifier
								L"JCRG",				// 37. Coordinating conjunction
								L"JCMP",				// 38. Comparative conjunction
								L"JSBR",				// 39. Subordinating conjunction
								L"RPRE",				// 40. Preposition
								L"INT",                 // 41. Interjection
								L"FIXN",				// 42. Nominal prefix
								L"FIXV",				// 43. Adverbial prefix
								L"EAFF",				// 44. Ending for affirmative sentencev
								L"EITT",				// 45. Ending for interrogative sentence
								L"NEG",                 // 46. Negator
								L"PUNC",				// 47. Punctuation
								L"ADVI ADVN",
								  // 48.
								L"ADVI ADVN NCMN",
								  // 49.
								L"ADVI ADVN VSTA",
								  // 50.
								L"ADVI VATT",
								  // 51.
								L"ADVN ADVP",
								  // 52.
								L"ADVN ADVP ADVS",
								  // 53.
								L"ADVN ADVP DIAQ DIBQ JCMP JSBR RPRE",
								  // 54.
								L"ADVN ADVP NCMN VATT",
								  // 55.
								L"ADVN ADVP VSTA",
								  // 56.
								L"ADVN ADVS DDAC DDAN DIAC VATT XVAE",
								  // 57.
								L"ADVN ADVS DDAN NCMN VATT VSTA",
								  // 58.
								L"ADVN ADVS NCMN",
								  // 59.
								L"ADVN ADVS NCMN VATT",
								  // 60.
								L"ADVN ADVS VACT",
								  // 61.
								L"ADVN ADVS VATT",
								  // 62.
								L"ADVN CFQC NCMN RPRE VSTA",
								  // 63.
								L"ADVN CLTV CNIT NCMN RPRE",
								  // 64.
								L"ADVN DCNM",
								  // 65.
								L"ADVN DDAC DDAN",
								  // 66.
								L"ADVN DDAC DDAN NCMN PDMN",
								  // 67.
								L"ADVN DDAC DDAN PDMN",
								  // 68.
								L"ADVN DDAN DDBQ",
								  // 69.
								L"ADVN DDAN DIAC PDMN VSTA",
								  // 70.
								L"ADVN DDAN FIXN PDMN",
								  // 71.
								L"ADVN DDAN NCMN",
								  // 72.
								L"ADVN DDAQ",
								  // 73.
								L"ADVN DDBQ",
								  // 74.
								L"ADVN DDBQ RPRE VATT",
								  // 75.
								L"ADVN DDBQ VATT VSTA XVAE",
								  // 76.
								L"ADVN DIAC",
								  // 77.
								L"ADVN DIAC PDMN",
								  // 78.
								L"ADVN DIBQ",
								  // 79.
								L"ADVN DIBQ NCMN",
								  // 80.
								L"ADVN DIBQ VACT VSTA",
								  // 81.
								L"ADVN DIBQ VATT",
								  // 82.
								L"ADVN DONM JCMP",
								  // 83.
								L"ADVN DONM JSBR NCMN RPRE VATT XVAE",
								  // 84.
								L"ADVN EITT PNTR",
								  // 85.
								L"ADVN FIXN",
								  // 86.
								L"ADVN JCMP",
								  // 87.
								L"ADVN JCRG",
								  // 88.
								L"ADVN JCRG JSBR",
								  // 89.
								L"ADVN JCRG JSBR XVBM XVMM",
								  // 90.
								L"ADVN JCRG RPRE VACT VSTA XVAE",
								  // 91.
								L"ADVN JSBR",
								  // 92.
								L"ADVN JSBR NCMN",
								  // 93.
								L"ADVN JSBR RPRE VATT",
								  // 94.
								L"ADVN JSBR RPRE XVAE",
								  // 95.
								L"ADVN JSBR VSTA",
								  // 96.
								L"ADVN JSBR XVAE XVBM",
								  // 97.
								L"ADVN NCMN",
								  // 98.
								L"ADVN NCMN RPRE VACT VATT VSTA",
								  // 99.
								L"ADVN NCMN RPRE VACT XVAE",
								  // 100.
								L"ADVN NCMN RPRE VATT",
								  // 101.
								L"ADVN NCMN VACT VATT VSTA",
								  // 102.
								L"ADVN NCMN VACT VSTA",
								  // 103.
								L"ADVN NCMN VATT",
								  // 104.
								L"ADVN NCMN VATT VSTA",
								  // 105.
								L"ADVN NEG",
								  // 106.
								L"ADVN NPRP VATT",
								  // 107.
								L"ADVN PDMN VACT",
								  // 108.
								L"ADVN PNTR",
								  // 109.
								L"ADVN RPRE",
								  // 110.
								L"ADVN RPRE VACT VATT XVAE",
								  // 111.
								L"ADVN RPRE VACT XVAM XVBM",
								  // 112.
								L"ADVN RPRE VATT VSTA",
								  // 113.
								L"ADVN RPRE VSTA",
								  // 114.
								L"ADVN VACT",
								  // 115.
								L"ADVN VACT VATT",
								  // 116.
								L"ADVN VACT VATT VSTA",
								  // 117.
								L"ADVN VACT VATT VSTA XVAM XVBM",
								  // 118.
								L"ADVN VACT VSTA",
								  // 119.
								L"ADVN VACT VSTA XVAE",
								  // 120.
								L"ADVN VACT XVAE",
								  // 121.
								L"ADVN VATT",
								  // 122.
								L"ADVN VATT VSTA",
								  // 123.
								L"ADVN VATT VSTA XVAM XVBM XVMM",
								  // 124.
								L"ADVN VATT XVBM",
								  // 125.
								L"ADVN VSTA",
								  // 126.
								L"ADVN VSTA XVAE",
								  // 127.
								L"ADVN VSTA XVBM",
								  // 128.
								L"ADVN XVAE",
								  // 129.
								L"ADVN XVAM",
								  // 130.
								L"ADVN XVBM XVMM",
								  // 131.
								L"ADVP JSBR RPRE VATT",
								  // 132.
								L"ADVP VATT",
								  // 133.
								L"ADVS DDAC JCRG",
								  // 134.
								L"ADVS DDAC JSBR",
								  // 135.
								L"ADVS DDAN VSTA",
								  // 136.
								L"ADVS DIAC",
								  // 137.
								L"ADVS DONM",
								  // 138.
								L"ADVS JCRG JSBR",
								  // 139.
								L"ADVS JCRG JSBR RPRE",
								  // 140.
								L"ADVS JSBR",
								  // 141.
								L"ADVS JSBR RPRE",
								  // 142.
								L"ADVS NCMN",
								  // 143.
								L"ADVS VATT",
								  // 144.
								L"CFQC CLTV CNIT DCNM JCRG JSBR NCMN RPRE XVBM",
								  // 145.
								L"CFQC CNIT PREL",
								  // 146.
								L"CFQC NCMN",
								  // 147.
								L"CLTV CNIT NCMN",
								  // 148.
								L"CLTV CNIT NCMN RPRE",
								  // 149.
								L"CLTV CNIT NCMN VSTA",
								  // 150.
								L"CLTV NCMN",
								  // 151.
								L"CLTV NCMN VACT VATT",
								  // 152.
								L"CLTV NCMN VATT",
								  // 153.
								L"CMTR CNIT NCMN",
								  // 154.
								L"CMTR NCMN",
								  // 155.
								L"CMTR NCMN VATT VSTA",
								  // 156.
								L"CNIT DDAC NCMN VATT",
								  // 157.
								L"CNIT DONM NCMN RPRE VATT",
								  // 158.
								L"CNIT FIXN FIXV JSBR NCMN",
								  // 159.
								L"CNIT JCRG JSBR NCMN PREL RPRE VATT",
								  // 160.
								L"CNIT JSBR RPRE",
								  // 161.
								L"CNIT NCMN",
								  // 162.
								L"CNIT NCMN RPRE",
								  // 163.
								L"CNIT NCMN RPRE VATT",
								  // 164.
								L"CNIT NCMN VACT",
								  // 165.
								L"CNIT NCMN VSTA",
								  // 166.
								L"CNIT NCNM",
								  // 167.
								L"CNIT PPRS",
								  // 168.
								L"DCNM DDAC DIAC DONM VATT VSTA",
								  // 169.
								L"DCNM DDAN DIAC",
								  // 170.
								L"DCNM DIAC NCMN NCNM",
								  // 171.
								L"DCNM DIBQ NCMN",
								  // 172.
								L"DCNM DONM",
								  // 173.
								L"DCNM NCMN",
								  // 174.
								L"DCNM NCNM",
								  // 175.
								L"DCNM NCNM VACT",
								  // 176.
								L"DCNM VATT",
								  // 177.
								L"DDAC DDAN",
								  // 178.
								L"DDAC DDAN DIAC NCMN",
								  // 179.
								L"DDAC DDAN DIAC VATT",
								  // 180.
								L"DDAC DDAN EAFF PDMN",
								  // 181.
								L"DDAC DDAN PDMN",
								  // 182.
								L"DDAC DIAC VSTA",
								  // 183.
								L"DDAC NCMN",
								  // 184.
								L"DDAN DDBQ",
								  // 185.
								L"DDAN DIAC PNTR",
								  // 186.
								L"DDAN NCMN",
								  // 187.
								L"DDAN NCMN RPRE VATT",
								  // 188.
								L"DDAN PDMN",
								  // 189.
								L"DDAN RPRE",
								  // 190.
								L"DDAN VATT",
								  // 191.
								L"DDAQ VATT",
								  // 192.
								L"DDBQ DIBQ",
								  // 193.
								L"DDBQ JCRG JSBR",
								  // 194.
								L"DDBQ JCRG NCMN",
								  // 195.
								L"DIAC PDMN",
								  // 196.
								L"DIBQ JSBR RPRE VSTA",
								  // 197.
								L"DIBQ NCMN",
								  // 198.
								L"DIBQ VATT",
								  // 199.
								L"DIBQ VATT VSTA",
								  // 200.
								L"DIBQ XVBM",
								  // 201.
								L"DONM NCMN RPRE",
								  // 202.
								L"DONM VACT VATT VSTA",
								  // 203.
								L"DONM VATT",
								  // 204.
								L"EAFF XVAE XVAM XVBM",
								  // 205.
								L"EITT JCRG",
								  // 206.
								L"FIXN FIXV NCMN",
								  // 207.
								L"FIXN FIXV RPRE VSTA",
								  // 208.
								L"FIXN JSBR NCMN PREL RPRE VSTA XVBM",
								  // 209.
								L"FIXN NCMN",
								  // 210.
								L"FIXN VACT",
								  // 211.
								L"FIXN VACT VSTA",
								  // 212.
								L"FIXV JSBR RPRE",
								  // 213.
								L"JCMP JSBR",
								  // 214.
								L"JCMP RPRE VSTA",
								  // 215.
								L"JCMP VATT VSTA",
								  // 216.
								L"JCMP VSTA",
								  // 217.
								L"JCRG JSBR",
								  // 218.
								L"JCRG JSBR NCMN RPRE",
								  // 219.
								L"JCRG JSBR RPRE",
								  // 220.
								L"JCRG RPRE",
								  // 221.
								L"JCRG RPRE VATT VSTA",
								  // 222.
								L"JCRG VSTA",
								  // 223.
								L"JSBR NCMN",
								  // 224.
								L"JSBR NCMN XVAE",
								  // 225.
								L"JSBR NCMN XVAM XVBM XVMM",
								  // 226.
								L"JSBR PREL",
								  // 227.
								L"JSBR PREL RPRE",
								  // 228.
								L"JSBR PREL XVBM",
								  // 229.
								L"JSBR RPRE",
								  // 230.
								L"JSBR RPRE VACT",
								  // 231.
								L"JSBR RPRE VACT VSTA",
								  // 232.
								L"JSBR RPRE VACT XVAE XVAM",
								  // 233.
								L"JSBR RPRE VATT",
								  // 234.
								L"JSBR RPRE VSTA",
								  // 235.
								L"JSBR RPRE XVAM",
								  // 236.
								L"JSBR VACT",
								  // 237.
								L"JSBR VACT VSTA",
								  // 238.
								L"JSBR VATT XVBM XVMM",
								  // 239.
								L"JSBR VSTA",
								  // 240.
								L"JSBR XVBM",
								  // 241.
								L"NCMN NCNM",
								  // 242.
								L"NCMN NCNM NPRP",
								  // 243.
								L"NCMN NLBL NPRP",
								  // 244.
								L"NCMN NPRP",
								  // 245.
								L"NCMN NPRP RPRE",
								  // 246.
								L"NCMN NTTL",
								  // 247.
								L"NCMN PDMN PPRS",
								  // 248.
								L"NCMN PDMN VATT",
								  // 249.
								L"NCMN PNTR",
								  // 250.
								L"NCMN PPRS PREL VACT",
								  // 251.
								L"NCMN RPRE",
								  // 252.
								L"NCMN RPRE VACT VATT",
								  // 253.
								L"NCMN RPRE VATT",
								  // 254.
								L"NCMN VACT",
								  // 255.
								L"NCMN VACT VATT",
								  // 256.
								L"NCMN VACT VATT VSTA XVAE",
								  // 257.
								L"NCMN VACT VSTA",
								  // 258.
								L"NCMN VACT VSTA XVAM",
								  // 259.
								L"NCMN VACT VSTA XVBB",
								  // 260.
								L"NCMN VATT",
								  // 261.
								L"NCMN VATT VSTA",
								  // 262.
								L"NCMN VATT XVAM",
								  // 263.
								L"NCMN VSTA",
								  // 264.
								L"NCMN XVBM",
								  // 265.
								L"NPRP RPRE",
								  // 266.
								L"NPRP VATT",
								  // 267.
								L"NTTL PPRS",
								  // 268.
								L"PDMN PPRS",
								  // 269.
								L"PDMN VATT",
								  // 270.
								L"PDMN VATT VSTA",
								  // 271.
								L"PPRS PREL",
								  // 272.
								L"PPRS VATT",
								  // 273.
								L"RPRE VACT",
								  // 274.
								L"RPRE VACT VATT",
								  // 275.
								L"RPRE VACT VSTA",
								  // 276.
								L"RPRE VACT VSTA XVAE",
								  // 277.
								L"RPRE VACT XVAE",
								  // 278.
								L"RPRE VATT",
								  // 279.
								L"RPRE VATT VSTA",
								  // 280.
								L"RPRE VSTA",
								  // 281.
								L"VACT VATT",
								  // 282.
								L"VACT VATT VSTA",
								  // 283.
								L"VACT VATT XVAE XVAM XVBM",
								  // 284.
								L"VACT VSTA",
								  // 285.
								L"VACT VSTA XVAE",
								  // 286.
								L"VACT VSTA XVAE XVAM",
								  // 287.
								L"VACT VSTA XVAE XVAM XVMM",
								  // 288.
								L"VACT VSTA XVAM",
								  // 289.
								L"VACT VSTA XVAM XVMM",
								  // 290.
								L"VACT XVAE",
								  // 291.
								L"VACT XVAM",
								  // 292.
								L"VACT XVAM XVMM",
								  // 293.
								L"VACT XVMM",
								  // 294.
								L"VATT VSTA",
								  // 295.
								L"VSTA XVAE",
								  // 296.
								L"VSTA XVAM",
								  // 297.
								L"VSTA XVAM XVMM",
								  // 298.
								L"VSTA XVBM",
								  // 299.
								L"XVAM XVBM",
								  // 300.
								L"XVAM XVBM XVMM",
								  // 301.
								L"XVAM XVMM",
								  // 302.
                                L"UNKN",
								  // 303. Unknown
                                L"ABBR"
								  // 304. Abbrivation
                            };

//+---------------------------------------------------------------------------
//
//  Function:   POSCompress
//
//  Synopsis:   Part Of Speech Compress - translating string to unique id.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD POSCompress(const WCHAR* szTag)
{
	int i;

	for (i = 0; i < POSTYPE; i++)
	{
		if (wcscmp(szTag, &wzPOSLookup[i][0]) == 0)
		{
			return (DWORD)i;
		}
	}
	return POSTYPE;
}

//+---------------------------------------------------------------------------
//
//  Function:   POSDecompress
//
//  Synopsis:   Part Of Speech Decompress - Decompress tag get 
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline WCHAR* POSDecompress(DWORD dwTag)
{
    return (&wzPOSLookup[dwTag][0]);
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:  Constructor:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrieIter::CThaiTrieIter() : resultWord(NULL), soundexWord(NULL), tempWord(NULL),
                                 pTrieScanArray(NULL), m_fThaiNumber(false)
{
    resultWord = new WCHAR[WORDSIZE];
    tempWord = new WCHAR[WORDSIZE];
    pTrieScanArray = new TRIESCAN[53];
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:  Destructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrieIter::~CThaiTrieIter()
{
    if (resultWord)
        delete resultWord;
    if (tempWord)
        delete tempWord;
    if (pTrieScanArray)
        delete pTrieScanArray;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiTrieIter::Init(CTrie* ctrie)
{
    // Declare varialbes.
    WCHAR wc;

    // Initialize parent.
    CTrieIter::Init(ctrie);

    // Initialize Hash table.
    for (wc = THAI_Ko_Kai; wc <= THAI_Ho_Nok_Huk; wc++)
        GetScanFirstChar(wc,&pTrieScanArray[wc - THAI_Ko_Kai]);
    for (wc = THAI_Vowel_Sara_E; wc <= THAI_Vowel_Sara_AI_MaiMaLai; wc++)
        GetScanFirstChar(wc,&pTrieScanArray[wc - THAI_Ko_Kai - 17]);
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiTrieIter::GetScanFirstChar(WCHAR wc, TRIESCAN* pTrieScan)
{
    // Reset the trie scan.
	memset(&trieScan1, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(pTrieCtrl, &trieScan1))
        return false;

    while (wc != trieScan1.wch)
    {
        // Keep moving the the right of the trie.
        if (!TrieGetNextNode(pTrieCtrl, &trieScan1))
        {
        	memset(pTrieScan, 0, sizeof(TRIESCAN));
            return false;
        }
    }
    memcpy(pTrieScan, &trieScan1, sizeof(TRIESCAN));

    return true;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis:   The function move trieScan to the relevant node matching with
//              with the cluster of Thai character.
//
//  Arguments:  szCluster - contain the thai character cluster.
//              iNumCluster  - contain the size of character.
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CThaiTrieIter::MoveCluster(const WCHAR* szCluster, unsigned int iNumCluster)
{
    // Declare and initailze local variables.
    unsigned int i = 0;

//    Assert(iNumCluster <= 6, "Invalid cluster");

    CopyScan();

    if (!TrieGetNextState(pTrieCtrl, &trieScan1))
        return FALSE;

    while (TRUE)
    {
        if (szCluster[i] == trieScan1.wch)
        {
            i++;
            if (i == iNumCluster)
            {
            	memcpy(&trieScan, &trieScan1, sizeof(TRIESCAN));
                GetNode();
                return TRUE;
            }
        	// Move down the Trie Branch.
            else if (!TrieGetNextState(pTrieCtrl, &trieScan1)) break;
        }
    	// Move the Trie right one node.
        else if (!TrieGetNextNode(pTrieCtrl, &trieScan1)) break;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis:   The function move trieScan to the relevant node matching with
//              with the cluster of Thai character.
//
//  Arguments:  szCluster - contain the thai character cluster.
//              iNumCluster  - contain the size of character.
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiTrieIter::MoveCluster(WCHAR* szCluster, unsigned int iNumCluster, bool fBeginNewWord)
{
    // Declare and initailze local variables.
    unsigned int i = 0;

    Assert(iNumCluster <= 6, "Invalid cluster");

	// No need to move.
	if (iNumCluster == 0)
		return false;

    // Use a look indexes for where the first character is at.
    if (fBeginNewWord)
    {
		m_fThaiNumber = false;
        // Quick look up for proper characters.
        if (szCluster[i] >= THAI_Ko_Kai && szCluster[i] <= THAI_Ho_Nok_Huk)
            memcpy(&trieScan,&pTrieScanArray[(szCluster[i] - THAI_Ko_Kai)], sizeof(TRIESCAN));
        else if (szCluster[i] >= THAI_Vowel_Sara_E && szCluster[i] <= THAI_Vowel_Sara_AI_MaiMaLai)
            memcpy(&trieScan,&pTrieScanArray[(szCluster[i] - THAI_Ko_Kai - 17)], sizeof(TRIESCAN));
        else
			{
            Reset();
			m_fThaiNumber = IsThaiNumeric(szCluster[i]);
			}

        if (trieScan.wch == szCluster[i])
            i++;

        if (i == iNumCluster)
        {
            GetNode();
            return true;
        }
    }
    CopyScan();

    if (!TrieGetNextState(pTrieCtrl, &trieScan1))
        return false;

	if (m_fThaiNumber)
		{
		fWordEnd = true;
		if (IsThaiNumeric(szCluster[i]) || szCluster[i] == L',' || szCluster[i] == L'.')
			return true;
		else
			return false;
		}

    while (true)
    {
        if (szCluster[i] == trieScan1.wch)
        {
            i++;

            if ((i == iNumCluster) ||
				( (szCluster[i] == THAI_Vowel_MaiYaMok || szCluster[i] == THAI_Sign_PaiYanNoi)/* && (i+1 == iNumCluster )*/) )
            {
                memcpy(&trieScan, &trieScan1, sizeof(TRIESCAN));
                GetNode();
                return true;
            }
            // Move down the Trie Branch.
            else if (!TrieGetNextState(pTrieCtrl, &trieScan1)) break;
        }
		// Let Nikhahit equal Sara Am.
		// TODO: case Nikhahit Mai To and Sara AA should equal to Mai To Sara Am.  TO risk for this version.
		// This bug was found because Thairath newspaper doesn't write this properly on their web page.
		else if (szCluster[i] == THAI_Nikhahit && szCluster[i+1] == THAI_Vowel_Sara_AA &&
			     trieScan1.wch == THAI_Vowel_Sign_Sara_Am)
		{
			if (szCluster[i+1] == THAI_Vowel_Sara_AA)
				i++;

            i++;
            if ((i == iNumCluster) ||
				( (szCluster[i] == THAI_Vowel_MaiYaMok || szCluster[i] == THAI_Sign_PaiYanNoi)/* && (i+1 == iNumCluster )*/) )
            {
                memcpy(&trieScan, &trieScan1, sizeof(TRIESCAN));
                GetNode();
                return true;
            }
            // Move down the Trie Branch.
            else if (!TrieGetNextState(pTrieCtrl, &trieScan1)) break;
		}
        // Move the Trie right one node.
        else if (!TrieGetNextNode(pTrieCtrl, &trieScan1)) break;
    }

    if (fBeginNewWord)
        Reset();

    return false;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
SOUNDEXSTATE CThaiTrieIter::MoveSoundexByCluster(WCHAR* szCluster, unsigned int iNumCluster, unsigned int iNumNextCluster)
{
    // Declare and initailze local variables.
    unsigned int i = 0 , x = 0;
    bool fStoreScan = false;
	TRIESCAN trieScanPush;

    Assert(iNumCluster <= 6, "Invalid cluster");
    Assert(iNumNextCluster <= 6, "Invalid cluster");

    CopyScan();

    if (!TrieGetNextState(pTrieCtrl, &trieScan1))
        return UNABLE_TO_MOVE;

	if (IsThaiEndingSign(*szCluster))
		return STOP_MOVE;

    // Match as much as possible
    while (true)
    {
        if (szCluster[i] == trieScan1.wch)
        {
            i++;
            if (i == iNumCluster)
            {
            	memcpy(&trieScan, &trieScan1, sizeof(TRIESCAN));
                GetNode();
                return NOSUBSTITUTE;
            }
            // Move down the Trie Branch.
            else if (!TrieGetNextState(pTrieCtrl, &trieScan1)) break;

            // Save our current scan position.
            memcpy(&trieScanPush, &trieScan1, sizeof(TRIESCAN));
            fStoreScan = true;
        }
    	// Move the Trie right one node.
        else if (!TrieGetNextNode(pTrieCtrl, &trieScan1)) break;
    }

    // Try doing some tonemark substitution.
    if (fStoreScan && IsThaiToneMark(szCluster[i]) )
    {
        // Restore trieScan1 to last matched.
        memcpy(&trieScan1, &trieScanPush, sizeof(TRIESCAN));

        while (true)
        {
            if (IsThaiToneMark(trieScan1.wch))
            {           
                if ( (i + 1) == iNumCluster)
                {
                    if (CheckNextCluster(szCluster+iNumCluster,iNumNextCluster))
                    {
                        memcpy(&trieScan, &trieScan1, sizeof(TRIESCAN));
                        GetNode();
                        return SUBSTITUTE_DIACRITIC;
                    }
                } 
            }
            // Move the Trie right one node.
            // Goes through all the none Tonemark.
            if (!TrieGetNextNode(pTrieCtrl, &trieScan1)) break;
        }
    }

    // Try doing droping the current tonemark.  
    // Example is case can be best found "Click" is spelt in Thai from the
    //  different group at Microsoft.
    if (fStoreScan && !IsThaiToneMark(szCluster[i]) )
    {
        // Restore trieScan1 to last matched.
        memcpy(&trieScan1, &trieScanPush, sizeof(TRIESCAN));

        while (true)
        {
            if (IsThaiToneMark(trieScan1.wch))
            {
                if ( (i + 1) == iNumCluster)
                {
                    if (CheckNextCluster(szCluster+iNumCluster,iNumNextCluster))
                    {
                        memcpy(&trieScan, &trieScan1, sizeof(TRIESCAN));
                        GetNode();
                        return SUBSTITUTE_DIACRITIC;
                    }
                } 
            }
            // Move the Trie right one node.
            // Drop all the Tonemark.
            if (!TrieGetNextNode(pTrieCtrl, &trieScan1)) break;
        }
    }

    return UNABLE_TO_MOVE;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis: set trieScan1 = trieScan.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void CThaiTrieIter::CopyScan()
{
	// Let trieScan1 = trieScan
	memcpy(&trieScan1,&trieScan, sizeof(TRIESCAN));
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:  the function traverse through the whole dictionary
//              to find the best possible match words.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiTrieIter::Soundex(WCHAR* word)
{
	// Reset Trie.
    Reset();

    // Move Down.
    Down();

    // Clean soundexWord.
    memset(resultWord, 0, sizeof(WCHAR) * WORDSIZE);
    memset(tempWord, 0, sizeof(WCHAR) * WORDSIZE);

    soundexWord = word;

    iResultScore = GetScore(L"\x0e04\x0e25\x0e34\x0e01\x0e01\x0e01",soundexWord);
    iResultScore = 2000;

#if defined (_DEBUG)
    iStackSize = 0;
#endif
    Traverse(0,1000);

    return iResultScore;
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiTrieIter::GetScore(WCHAR* idealWord, WCHAR* inputWord)
{
    unsigned int iScore = 1000;
    unsigned int idealWordLen = wcslen(idealWord);
    unsigned int iInputWordLen = wcslen(inputWord);
    unsigned int iIndexBegin = 0;
    unsigned int i;
	unsigned int x = 0;
    unsigned int iMaxCompare;
    bool fShouldExit;

    for (i=0; i < iInputWordLen; i++)
    {
        iMaxCompare = ( (iIndexBegin + 2) < idealWordLen ) ? (iIndexBegin + 2) : idealWordLen;
        if (i <= idealWordLen)
        {
            x = iIndexBegin;
            fShouldExit = false;
            while (true)
            {
                if ((x >= iMaxCompare) || (fShouldExit) )
                    break;

                if (idealWord[x] == inputWord[i])
                {
                    x++;
                    iIndexBegin = x;
                    break;
                }
                if (IsThaiUpperAndLowerClusterCharacter(inputWord[i]))
                    iScore += 5;
                else
                    iScore += 10;
                x++;
                fShouldExit = true;
            }
        }
        else
        {
            if (IsThaiUpperAndLowerClusterCharacter(inputWord[i]))
                iScore += 20;
            else
                iScore += 30;
        }
    }

    while (x <= idealWordLen)
    {
        if (IsThaiUpperAndLowerClusterCharacter(idealWord[x]))
            iScore += 5;
        else
            iScore += 10;
        x++;
    }

    return iScore;
}


//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiTrieIter::Traverse(unsigned int iCharPos, unsigned int score)
{
    TRIESCAN trieScanLevel;

#if defined(_DEBUG)   
    iStackSize++;
#endif

    // push current trieScan into local stack trieScanLevel.
    memcpy(&trieScanLevel,&trieScan, sizeof(TRIESCAN));

    // Get Node information
    GetNode();

    // Store the current character to result word.
    tempWord[iCharPos] = wc;
    tempWord[iCharPos + 1] = 0;

    // Determine the distance between two string.
    score = GetScore(tempWord, soundexWord);
 
    // See if we have reached the end of a word.
    if (fWordEnd)
    {
        tempWord[iCharPos + 1] = 0;
    
        // Is Soundex score lower than we have.
        if (score <  iResultScore)
        {
//            wcscpy(resultWord,tempWord);
			Wzncpy(resultWord,tempWord,WORDSIZE);
            iResultScore = score;
        }
    }

    // See if we can prune the result of the words.
    if (score > (iResultScore + APPROXIMATEWEIGHT))
    {
#if defined(_DEBUG)
        iStackSize--;
#endif
        return true;
    }

    // Move down Trie branch.
    if (Down())
    {
        Traverse(iCharPos + 1, score);

        if (Right())
            Traverse(iCharPos + 1, score);

        // restore trieScan
        memcpy(&trieScan,&trieScanLevel, sizeof(TRIESCAN));

        if (Right())
            Traverse(iCharPos, score);
    }

#if defined(_DEBUG)
    iStackSize--;
#endif

    return true;
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:  This function will trieScan1 to the next cluster if
//              the move is possible.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiTrieIter::CheckNextCluster(const WCHAR* szCluster, unsigned int iNumCluster)
{
    // Declare and initailze local variables.
    unsigned int i = 0;
    TRIESCAN trieScan2;

    Assert(iNumCluster <= 6, "Invalid cluster");

    // If there are no cluster to check consider cluster found.
    if (0 == iNumCluster)
        return true;

    memcpy(&trieScan2, &trieScan1, sizeof(TRIESCAN));

    // Move down the Trie Branch.
    if (!TrieGetNextState(pTrieCtrl, &trieScan2)) 
        return false;

    while (true)
    {
        if (szCluster[i] == trieScan2.wch)
        {
            i++;
            if (i == iNumCluster)
            {
                return true;
            }
        	// Move down the Trie Branch.
            else if (!TrieGetNextState(pTrieCtrl, &trieScan2)) break;
        }
    	// Move the Trie right one node.
        else if (!TrieGetNextNode(pTrieCtrl, &trieScan2)) break;
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthaitrigrambreak.h ===
//+---------------------------------------------------------------------------
//
//
//  CThaiBreakTree - class CThaiBreakTree 
//
//  History:
//      created 11/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAITRIGRAMBREAK_H_
#define _CTHAITRIGRAMBREAK_H_

#include <windows.h>
#include <assert.h>
#include "CThaiTrieIter.hpp"
#include "CThaiSentTrieIter.hpp"
#include "CThaiTrigramTrieIter.hpp"

class CThaiTrigramBreak
{

public:
	CThaiTrigramBreak();
	~CThaiTrigramBreak();
	void Init(CTrie* pTrie, CTrie* pTrigramTrie);

protected:
    inline unsigned int Maximum(unsigned int x, unsigned y) { if (x > y) return x; else return y;}

    CThaiTrieIter thaiTrieIter;
	CThaiTrigramTrieIter thaiTrigramIter;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthaitrigramtrieiter.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiTrigramTrieIter - contain the header for class CThaiTrigramTrieIter
//
//  History:
//      created 8/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAITRIGRAMTRIEITER_HPP_
#define _CTHAITRIGRAMTRIEITER_HPP_

#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "lexheader.h"
#include "trie.h"
//#include "NLGlib.h"
#include "ProofBase.h"
#include "thwbdef.hpp"
#include "CTrie.hpp"

class CThaiTrigramTrieIter : public CTrieIter {
public:
    CThaiTrigramTrieIter();
    ~CThaiTrigramTrieIter();
    DWORD GetProb(WCHAR pos1, WCHAR pos2, WCHAR pos3);
	DWORD GetProb(const WCHAR* posArray);
    void Init(CTrie* ctrie);
	void GetNode();
    WCHAR pos;
private:
    // For optimization quick look up table.
    WCHAR pos1Cache;
    WCHAR pos2Cache;
    TRIESCAN trieScanCache;

    TRIESCAN* pTrieScanArray;
    bool GetScanFirstChar(WCHAR wc, TRIESCAN* pTrieScan);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthaitrigrambreak.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiTrigramBreak - class CThaiTrigramBreak 
//
//  History:
//      created 11/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "CThaiTrigramBreak.h"

//+---------------------------------------------------------------------------
//
//  Class:		CThaiTrigramBreak
//
//  Synopsis:	Constructor - initialize local variables
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 11/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrigramBreak::CThaiTrigramBreak()
{
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiTrigramBreak
//
//  Synopsis:	Destructor - clean up code
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 11/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrigramBreak::~CThaiTrigramBreak()
{
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiTrigramBreak
//
//  Synopsis:	Associate the class to the string.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiTrigramBreak::Init(CTrie* pTrie, CTrie* pTrigramTrie)
{
	assert(pTrigramTrie != NULL);
	thaiTrigramIter.Init(pTrigramTrie);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthwb.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiWordBreak
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "cthwb.hpp"

//+---------------------------------------------------------------------------
//
//  Function:   ExtractALT
//
//  Synopsis:   The functions takes a tag and return Alternate Tags.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BYTE ExtractALT(DWORD dwTag)
{
    return (BYTE) ( (dwTag & iAltMask) >> iAltShift);
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:   constructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiWordBreak::CThaiWordBreak()
{
	wordCount[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:   destructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiWordBreak::~CThaiWordBreak()
{
	wordCount[0] = 0;
#if defined (_DEBUG)
	assert(listWordBreak.length == 0);
#endif
}


//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:   Initialize ThaiWordBreak.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
PTEC CThaiWordBreak::Init(const WCHAR* wzFileName, const WCHAR* wzFileNameTrigram)
{
    // Declare and Initialize local variables.
    PTEC retValue = m_trie.Init(wzFileName);
    if (retValue == ptecNoErrors)
    {
		retValue = m_trie_trigram.Init(wzFileNameTrigram);
	}

	// new memory management
	listWordBreak.Init(&m_trie,&m_trie_trigram);
	for (int i = 0; i < 10; i++)
	{
		listWordBreak.CreateWordBreak();
	}

	return retValue;
}


//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:   Initialize ThaiWordBreak.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
PTEC CThaiWordBreak::InitRc(LPBYTE pThaiDic, LPBYTE pThaiTrigram, BOOL fSkipHeader)
{
    // Declare and Initialize local variables.
    PTEC retValue = m_trie.InitRc(pThaiDic, fSkipHeader);
    if (retValue == ptecNoErrors)
		retValue = m_trie_trigram.InitRc(pThaiTrigram, fSkipHeader);

	// new memory management
	listWordBreak.Init(&m_trie,&m_trie_trigram);
	for (int i = 0; i < 10; i++)
	{
		listWordBreak.CreateWordBreak();
	}

	return retValue;
}



//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:   UnInitialize ThaiWordBreak.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiWordBreak::UnInit()
{
	// new memory management
	listWordBreak.Flush();

	m_trie.UnInit();
#if defined (NGRAM_ENABLE)
    m_trie_sentence_struct.UnInit();
#endif
	m_trie_trigram.UnInit();
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
enum merge_direction	{
							NO_MERGE,
							MERGE_RIGHT,
							MERGE_LEFT,
							MERGE_BOTH_DIRECTIONS,
							NOT_SURE_WHICH_DIRECTION
						};
merge_direction DetermineMergeDirection(WCHAR wc)
{
	if (wc == 0x0020) // space
		return NO_MERGE;
	else if (   wc == 0x0022 || // quotation mark
		        wc == 0x0027 )  // apostrophe
		return NOT_SURE_WHICH_DIRECTION;
	else if (	wc == 0x0028 || // left parenthesis
				wc == 0x003C || // less than sign
				wc == 0x005B || // left square bracket
				wc == 0x007B || // left curly bracket
				wc == 0x2018 || // left single quotation mark
				wc == 0x201C || // left double quotation mark
				wc == 0x201F )  // left double quotation mark reverse
		return MERGE_RIGHT;

	// TODO: need to add MERGE_BOTH_DIRECTIONS for character joiner characters.

	// all other character merge left.
	return MERGE_LEFT;
}
//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD_PTR CThaiWordBreak::CreateWordBreaker()
{
	CThaiBreakTree* breakTree	= NULL;
	breakTree = new CThaiBreakTree();
#if defined (NGRAM_ENABLE)
	if (breakTree)
		breakTree->Init(&m_trie, &m_trie_sentence_struct, &m_trie_trigram);
#else
	if (breakTree)
		breakTree->Init(&m_trie, &m_trie_trigram);
#endif
	return (DWORD_PTR)breakTree;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiWordBreak::DeleteWordBreaker(DWORD_PTR dwBreaker)
{
	CThaiBreakTree* breakTree	= (CThaiBreakTree*) dwBreaker;

	if (breakTree)
	{
		delete breakTree;
		return true;
	}

	return false;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:	This funciton segment Thai word use for Indexing.
//				
//  Arguments:
//			wzString		- input string.				(in)
//			iStringLen		- input string length.		(in)	
//			pBreakPos		- array of break position.	(out)
//			pThwb_Struct	- array structure of THWB.	(out)
//			iBreakMax		- length of pBreakPos and
//							  pThwb_Struct.				(out)
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiWordBreak::IndexWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,THWB_STRUCT* pThwb_Struct,unsigned int iBreakMax)
{
    unsigned int iBreakIndex       = 0;            // Contain number of Breaks.
	CThaiBreakTree* breakTree	= NULL;
	breakTree = new CThaiBreakTree();

	if (breakTree)
	{
		breakTree->Init(&m_trie, &m_trie_trigram);

		iBreakIndex = FindWordBreak((DWORD_PTR)breakTree,wzString,iStringLen,pBreakPos,iBreakMax,WB_INDEX,true,pThwb_Struct);

		delete breakTree;
	}

	return iBreakIndex;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//				
//  Arguments:
//
//			wzWord			- input string.								(in)
//			iWordLen		- input string length.						(in)	
//			Alt				- find close alternate word					(in)
//			pBreakPos		- array of break position allways 5 byte.	(out)
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiWordBreak::FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos)
{
    unsigned int iBreakIndex       = 0;            // Contain number of Breaks.
	CThaiBreakTree* breakTree	= NULL;
	breakTree = new CThaiBreakTree();

	if (breakTree)
	{
		breakTree->Init(&m_trie, &m_trie_trigram);

		iBreakIndex = breakTree->FindAltWord(wzWord,iWordLen,Alt,pBreakPos);

		delete breakTree;
	}

	return iBreakIndex;
}


//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:	This funciton segment Thai text segment them depending on the modes specifies.
//
//				WB_LINEBREAK - is used when the application needs to break for line wrapping,
//                             this mode takes into the consideration of punctuations.
//
//				WB_NORMAL - is used when application wants determine word for searching,
//                          autocorrect, etc.
//
//				WB_SPELLER - not yet implemented, but same as normal with additional soundex
//                           rules.
//				
//  Arguments:
//
//			wzString		- input string.				(in)
//			iStringLen		- input string length.		(in)	
//			pBreakPos		- array of break position.	(out)
//			iBreakMax		- length of pBreakPos		(out)
//			mode			- either WB_LINEBREAK, etct (in)
//			fFastWordBreak	- true for fast algorithm	(in)
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiWordBreak::FindWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakMax, BYTE mode, bool fFastWordBreak)
{
    unsigned int iBreakIndex       = 0;            // Contain number of Breaks.
	CThaiBreakTree* breakTree	= NULL;

#if defined(OLD)
	breakTree = new CThaiBreakTree();
#else
	// new memory management
	WordBreakElement* pWordBreakElement = NULL;
	pWordBreakElement = listWordBreak.GetFreeWB();
	breakTree = pWordBreakElement->breakTree;
	listWordBreak.MarkWordBreak(pWordBreakElement,false);  // Mark word break as in use.
#endif

	if (breakTree)
	{
#if defined(OLD)
		breakTree->Init(&m_trie, &m_trie_trigram);

		assert(mode != WB_INDEX);	// If this assert come up, use function IndexWordBreak

		iBreakIndex = FindWordBreak((DWORD_PTR)breakTree,wzString,iStringLen,pBreakPos,iBreakMax,mode,fFastWordBreak,0);

		delete breakTree;
#else
		iBreakIndex = FindWordBreak((DWORD_PTR)breakTree,wzString,iStringLen,pBreakPos,iBreakMax,mode,fFastWordBreak,0);
		listWordBreak.MarkWordBreak(pWordBreakElement,true); // Mark word break as free.
#endif

	}
	else
	{
		assert(false);
	}

	return iBreakIndex;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:	This funciton segment Thai text segment them depending on the modes specifies.
//
//				WB_LINEBREAK - is used when the application needs to break for line wrapping,
//                             this mode takes into the consideration of punctuations.
//
//				WB_NORMAL - is used when application wants determine word for searching,
//                          autocorrect, etc.
//
//				WB_SPELLER - not yet implemented, but same as normal with additional soundex
//                           rules.
//
//				WB_INDEX - is used when application wanted to do Thai indexing.
//
//
//  Arguments:
//
//			wzString		- input string.				(in)
//			iStringLen		- input string length.		(in)	
//			pBreakPos		- array of break position.	(out)
//			iBreakMax		- length of pBreakPos		(out)
//							  must be greater than 1.
//			mode			- either WB_LINEBREAK, etct (in)
//			fFastWordBreak	- true for fast algorithm	(in)
//			pThwb_Struct	- array structure of THWB.	(out)
//
//  Modifies:
//
//  History:    created 11/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiWordBreak::FindWordBreak(DWORD_PTR dwBreaker, WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakMax, BYTE mode, bool fFastWordBreak, THWB_STRUCT* pThwb_Struct)
{
    // Declare and Initialize all local variables.
    WCHAR* pwszRunStart            = wzString;
    const WCHAR* pwszMax                 = wzString + iStringLen;
    WCHAR* pwch				       = wzString;
	bool fThaiRun		           = true;
	bool fCaretBreak		       = false;
	int iRunCount                  = 0;
    unsigned int i                 = 0;
    unsigned int iBreakIndex       = 0;            // Contain number of Breaks.
	merge_direction dirPrevious = NO_MERGE;
	merge_direction dirCurrent  = NO_MERGE;

	CThaiBreakTree* breakTree = (CThaiBreakTree*) dwBreaker;

	// check for possible invalid arguments.
	assert(wzString != NULL);
	assert(iBreakMax > 0);
	assert(pBreakPos != NULL);
	if ((wzString == NULL) || (iBreakMax == 0) || (pBreakPos == NULL))
		return 0;

    switch (mode)
    {
    case WB_LINEBREAK:
	case 2:					// to be compatible with old api.
    	do
        {
		    while ((TWB_IsCharPunctW(*pwch) || TWB_IsCharWordDelimW(*pwch))  && iBreakIndex < iBreakMax && pwch < pwszMax)
			{
				dirCurrent = DetermineMergeDirection(*pwch);
				switch (dirCurrent)
				{
				case NO_MERGE:
					if ( pwch + 1 < pwszMax && *(pwch + 1) == THAI_Vowel_MaiYaMok && iBreakIndex > 0)
					{
						// Mai Ya Mok case only.
						pBreakPos[iBreakIndex - 1] += 2;	
						dirCurrent = MERGE_LEFT;
						pwch++;
					}
					else
						pBreakPos[iBreakIndex++] = 1;
					break;

				case MERGE_RIGHT:
					if (dirPrevious == MERGE_RIGHT)
						pBreakPos[iBreakIndex - 1]++;
					else if (!TWB_IsCharPunctW(*(pwch + 1)))
						pBreakPos[iBreakIndex++] = 1;
					else
						pBreakPos[iBreakIndex++] = 1;
					break;

				case NOT_SURE_WHICH_DIRECTION:
					if (pwch == wzString					||	// if pwch is first character.
						TWB_IsCharWordDelimW(*(pwch - 1))   )  // if previous character is delimiter.
					{
						pBreakPos[iBreakIndex++] = 1;
						dirCurrent = MERGE_RIGHT;
					}
					else
					{
						pBreakPos[iBreakIndex - 1]++;
						dirCurrent = MERGE_LEFT;
					}
					break;
				case MERGE_LEFT:
				default:
					if (iBreakIndex == 0)
						if (pwch == wzString)
							pBreakPos[iBreakIndex++] = 1;
						else
							pBreakPos[iBreakIndex]++;
					else
						pBreakPos[iBreakIndex - 1]++;
					break;
				}
				dirPrevious = dirCurrent; 
				pwch++;
                pwszRunStart = pwch;
			}

			assert(pwszRunStart == pwch);

		    if( iBreakIndex >= iBreakMax || pwch >= pwszMax)
			    break;

            // Detect if this is a Thai Run.
		    fThaiRun = IsThaiChar(*pwch);
		    do
            {
                pwch++;
			    iRunCount++;
            } while ((IsThaiChar(*pwch)==fThaiRun    &&
                     iRunCount < (MAXBREAK - 2)      &&
                     *pwch                           &&
                     !TWB_IsCharWordDelimW(*pwch)    &&
                     (pwch < pwszMax)                )  ||
					 ( ( *pwch == 0x2c || *pwch == 0x2e) && (iRunCount < (MAXBREAK - 2)) && (pwch < pwszMax) ));

            if (fThaiRun)
            {
				unsigned int iBreak = breakTree->TrigramBreak(pwszRunStart,pwch);
				for (i=0; i < iBreak && iBreakIndex <iBreakMax; i++)
				{
					// First Thai character of the run.
					if (dirPrevious == MERGE_RIGHT)
					{
						assert(iBreakIndex != 0);
						pBreakPos[iBreakIndex - 1] += breakTree->breakArray[i];
					}
					else
						pBreakPos[iBreakIndex++] = breakTree->breakArray[i];

					dirPrevious = NO_MERGE;

				}
            }
		    else
            {
                // Not a Thai Run simply put the whole thing in the break array.
                assert(pwch > pwszRunStart);        // pwch must be greater than pwszRunStart, since we just walk.
				if (dirPrevious == MERGE_RIGHT)
				{
					assert(iBreakIndex != 0);
					pBreakPos[iBreakIndex - 1] += (BYTE) (pwch - pwszRunStart);
				}
				else
					pBreakPos[iBreakIndex++] = (BYTE) (pwch - pwszRunStart);
            }
            iRunCount = 0;
            pwszRunStart = pwch;

        // Make sure we haven't pass iBreakMax define by user else return whatever we got.
        } while(iBreakIndex < iBreakMax && pwch < pwszMax);
        break;
    case WB_INDEX:
		// Make sure argument is the same.
		assert(pThwb_Struct != NULL);
		if (pThwb_Struct == NULL)
			return 0;
    	do
        {
		    while (TWB_IsCharWordDelimW(*pwch) && pwszMax > pwch)
		        pwch++;

		    if( pwszRunStart < pwch)
            {
                pBreakPos[iBreakIndex++] = (BYTE)(pwch - pwszRunStart);
                pwszRunStart = pwch;
            }

		    if( iBreakIndex >= iBreakMax || pwch >= pwszMax)
			    break;

            // Detect if this is a Thai Run.
		    fThaiRun = IsThaiChar(*pwch); //TODO: Add comma and period to Thai range.
		    do
            {
                pwch++;
			    iRunCount++;
            } while ((IsThaiChar(*pwch)==fThaiRun    &&
                     iRunCount < (MAXBREAK - 2)      &&
                     *pwch                           &&
                     !TWB_IsCharWordDelimW(*pwch)    &&
                     (pwch < pwszMax)                )  ||

					 ( ( *pwch == 0x2c || *pwch == 0x2e) && (iRunCount < (MAXBREAK - 2)) && (pwch < pwszMax) ));

            if (fThaiRun)
            {
				unsigned int iBreak = breakTree->TrigramBreak(pwszRunStart,pwch);
				for (i=0; i < iBreak && iBreakIndex <iBreakMax; i++)
				{
					pThwb_Struct[iBreakIndex].fThai = true;
					pThwb_Struct[iBreakIndex].alt = ExtractALT(breakTree->tagArray[i]);
					pBreakPos[iBreakIndex++] = breakTree->breakArray[i];
				}
            }
		    else
            {
                // Not a Thai Run simply put the whole thing in the break array.
                assert(pwch > pwszRunStart);        // pwch must be greater than pwszRunStart, since we just walk.
				pThwb_Struct[iBreakIndex].fThai = false;
				pThwb_Struct[iBreakIndex].alt = 0;
                pBreakPos[iBreakIndex++] = (BYTE)(pwch - pwszRunStart);
            }
            iRunCount = 0;
            pwszRunStart = pwch;

        // Make sure we haven't pass iBreakMax define by user else return whatever we got.
        } while(iBreakIndex < iBreakMax && pwch < pwszMax);
		break;
    case WB_CARETBREAK:
		fCaretBreak = true;
    case WB_NORMAL:
    default: 
    	do
        {
		    while (TWB_IsCharWordDelimW(*pwch) && pwszMax > pwch)
		        pwch++;

			if (fCaretBreak)
				{
				// 010.181686. Taking care of puntuation.
			    while (TWB_IsCharPunctW(*pwch) && pwszMax > pwch)
			        pwch++;
				}

		    if( pwszRunStart < pwch)
            {
				if (fCaretBreak && *pwszRunStart == L' ' && iBreakIndex > 0)
				{
					// 010.182719. For the MaiYaMok case we only accept if
					//             space follow by MaiYaMok
					if (*pwch == THAI_Vowel_MaiYaMok  &&
						wzString < (pwszRunStart-1)   &&
						IsThaiChar(*(pwszRunStart-1)) &&
						pwch == (pwszRunStart+1)       )
					{
						pBreakPos[iBreakIndex - 1] += 2;
						pwch++;
					}
					else
						// This is a caret movement features, should merge space to
						// the right words.
						pBreakPos[iBreakIndex - 1] += (BYTE)(pwch - pwszRunStart);
				}
				else
					pBreakPos[iBreakIndex++] = (BYTE)(pwch - pwszRunStart);
                pwszRunStart = pwch;
            }

		    if( iBreakIndex >= iBreakMax || pwch >= pwszMax)
			    break;

            // Detect if this is a Thai Run.
		    fThaiRun = IsThaiChar(*pwch); //TODO: Add comma and period to Thai range.

			if (!fCaretBreak)
			{
				do
				{
					pwch++;
					iRunCount++;
				} while ((IsThaiChar(*pwch)==fThaiRun    &&
					     iRunCount < (MAXBREAK - 2)      &&
						*pwch                            &&
						!TWB_IsCharWordDelimW(*pwch)     &&
						(pwch < pwszMax)                )  ||
						( ( *pwch == 0x2c || *pwch == 0x2e) && (iRunCount < (MAXBREAK - 2)) && (pwch < pwszMax) ));
			}
			else
			{
				do
				{
					pwch++;
					iRunCount++;
				} while ((IsThaiChar(*pwch)==fThaiRun    &&
					     iRunCount < (MAXBREAK - 2)      &&
						*pwch                            &&
						!TWB_IsCharWordDelimW(*pwch)     &&
						!TWB_IsCharPunctW(*pwch)         &&
						(pwch < pwszMax)                )  ||
						( ( *pwch == 0x2c || *pwch == 0x2e) && (iRunCount < (MAXBREAK - 2)) && (pwch < pwszMax) ));
			}

            if (fThaiRun)
            {
#if defined (NGRAM_ENABLE)
                if (!fFastWordBreak)
                {
                    if (WordBreak(pwszRunStart,pwch))
                        for (i=0; i < breakTree.maxToken && iBreakIndex <iBreakMax; i++)
                            pBreakPos[iBreakIndex++] = breakTree->maximalMatchingBreakArray[i];
                }
                else
                {
                    unsigned int iBreak = breakTree->TrigramBreak(pwszRunStart,pwch);
                    for (i=0; i < iBreak && iBreakIndex <iBreakMax; i++)
                        pBreakPos[iBreakIndex++] = breakTree->breakArray[i];
                }
#else
				unsigned int iBreak = breakTree->TrigramBreak(pwszRunStart,pwch);
				for (i=0; i < iBreak && iBreakIndex <iBreakMax; i++)
					pBreakPos[iBreakIndex++] = breakTree->breakArray[i];
#endif
            }
		    else
            {
                // Not a Thai Run simply put the whole thing in the break array.
                assert(pwch > pwszRunStart);        // pwch must be greater than pwszRunStart, since we just walk.
                pBreakPos[iBreakIndex++] = (BYTE)(pwch - pwszRunStart);
            }
            iRunCount = 0;
            pwszRunStart = pwch;

        // Make sure we haven't pass iBreakMax define by user else return whatever we got.
        } while(iBreakIndex < iBreakMax && pwch < pwszMax);
        break;
    }

#if defined (_DEBUG)
	unsigned int iTotalChar = 0;
	for (i = 0; i < iBreakIndex; i++)
	{
		iTotalChar += pBreakPos[i];
	}
	if (iBreakIndex < iBreakMax)
		assert(iStringLen == iTotalChar);
#endif

	return iBreakIndex;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
#if defined (NGRAM_ENABLE)
BOOL CThaiWordBreak::WordBreak(WCHAR* pszBegin, WCHAR* pszEnd)
{
    // Declare and Initialize all local variables.
    bool fWordEnd = false;
	bool fCorrectPath = false;
    WCHAR* pszIndex = pszBegin;
    int iNumCluster = 1;

    assert(pszBegin < pszEnd);          // Make sure pszEnd is at least greater pszBegin.

    breakTree.GenerateTree(pszBegin, pszEnd);
    breakTree.MaximalMatching();

   	return (breakTree.maxToken > 0);

}
#endif

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CThaiWordBreak::Find(const WCHAR* wzString, DWORD* pdwPOS)
{
    return m_trie.Find(wzString, pdwPOS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthwb.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiWordBreak
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAIWORDBREAK_H_
#define _CTHAIWORDBREAK_H_
#include "thwbdef.hpp"
#include "ctrie.hpp"
#include "CThaiTrieIter.hpp"
#include "lextable.hpp"
#include "CThaiBreakTree.hpp"
#include "CThaiTrigramTrieIter.hpp"
#include "listWordBreak.hpp"	// new memory management

class CThaiBreakTree;

class CThaiWordBreak {
public:
	CThaiWordBreak();
	~CThaiWordBreak();
	PTEC Init(const WCHAR* wzFileName, const WCHAR* wzFileNameTrigram);
	PTEC InitRc(LPBYTE , LPBYTE, BOOL);
	void UnInit();

	int IndexWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,THWB_STRUCT* pThwb_Struct,unsigned int iBreakMax);
	int FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos);

	int FindWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakMax, BYTE mode, bool fFastWordBreak = true);

	DWORD_PTR CreateWordBreaker();
	bool DeleteWordBreaker(DWORD_PTR dwBreaker);
	int FindWordBreak(DWORD_PTR dwBreaker,WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakMax, BYTE mode, bool fFastWordBreak = true, THWB_STRUCT* pThwb_Struct = NULL);

    BOOL Find(const WCHAR* wzString, DWORD* pdwPOS);
    int Soundex(WCHAR* word) {return 0;} //breakTree.Soundex(word);} -- re-entrant bug fix
protected:
#if defined (NGRAM_ENABLE)
	BOOL WordBreak(WCHAR* pszBegin, WCHAR* pszEnd);
#endif

	CTrie m_trie;
#if defined (NGRAM_ENABLE)
    CTrie trie_sentence_struct;
#endif
	CTrie m_trie_trigram;
    CThaiTrieIter m_thaiTrieIter;

	// new memory management
	ListWordBreak listWordBreak;

	int wordCount[MAXBREAK];

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\cthaitrigramtrieiter.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiTrigramTrieIter
//
//  History:
//      created 8/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "CThaiTrigramTrieIter.hpp"


bool IsTagEqual(WCHAR pos1, WCHAR pos2)
{
    // if unambigious tags.
    if (pos1 < 48 || pos1 == 304)
        return (pos1 == pos2);
    else
    {
        switch (pos1)
        {
        case 48:                // 48. ADVI ADVN
            return ((pos2 == 29) || (pos2 == 28));
        case 49:                // 49. ADVI ADVN NCMN
            return ((pos2 == 29) || (pos2 == 28) || (pos2 == 5));
        case 50:                // 50. ADVI ADVN VSTA
            return ((pos2 == 29) || (pos2 == 28) || (pos2 == 12));
        case 51:                // 51. ADVI VATT
            return ((pos2 == 29) || (pos2 == 13));
        case 52:                // 52. ADVN ADVP
            return ((pos2 == 28) || (pos2 == 30));
        case 53:                // 53. ADVN ADVP ADVS
            return ((pos2 == 28) || (pos2 == 30) || (pos2 == 31));
        case 54:                // 54. ADVN ADVP DIAQ DIBQ JCMP JSBR RPRE *
            return ((pos2 == 28) || (pos2 == 30) || (pos2 == 25));
        case 55:                // 55. ADVN ADVP NCMN VATT
            return ((pos2 == 28) || (pos2 == 30) || (pos2 == 5) || (pos2 == 13));
        case 56:                // 56. ADVN ADVP VSTA
            return ((pos2 == 28) || (pos2 == 30) || (pos2 == 12));
        case 57:                // 57. ADVN ADVS DDAC DDAN DIAC VATT XVAE *
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 20));
        case 58:                // 58. ADVN ADVS DDAN NCMN VATT VSTA *
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 19));
        case 59:                // 59. ADVN ADVS NCMN
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 5));
        case 60:                // 60. ADVN ADVS NCMN VATT
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 5) || (pos2 == 13));
        case 61:                // 61. ADVN ADVS VACT
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 11));
        case 62:                // 62. ADVN ADVS VATT
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 13));
        case 63:                // 63. ADVN CFQC NCMN RPRE VSTA *
            return ((pos2 == 28) || (pos2 == 35) || (pos2 == 5));
        case 64:                // 64. ADVN CLTV CNIT NCMN RPRE
            return ((pos2 == 28) || (pos2 == 33) || (pos2 == 32) || (pos2 == 5) || (pos2 == 40));
        case 65:                // 65. ADVN DCNM
            return ((pos2 == 28) || (pos2 == 26));
        case 66:                // 66. ADVN DDAC DDAN
            return ((pos2 == 28) || (pos2 == 20) || (pos2 == 19));
        case 67:                // 67. ADVN DDAC DDAN NCMN PDMN
            return ((pos2 == 28) || (pos2 == 20) || (pos2 == 19) || (pos2 == 5) || (pos2 == 8));
        case 68:                // 68. ADVN DDAC DDAN PDMN
            return ((pos2 == 28) || (pos2 == 20) || (pos2 == 19) || (pos2 == 8));
        case 69:                // 69. ADVN DDAN DDBQ
            return ((pos2 == 28) || (pos2 == 19) || (pos2 == 21));
        case 70:                // 70. ADVN DDAN DIAC PDMN VSTA
            return ((pos2 == 28) || (pos2 == 19) || (pos2 == 23) || (pos2 == 8) || (pos2 == 12));
        case 71:                // 71. ADVN DDAN FIXN PDMN
            return ((pos2 == 28) || (pos2 == 19) || (pos2 == 42) || (pos2 == 8));
        case 72:                // 72. ADVN DDAN NCMN
            return ((pos2 == 28) || (pos2 == 19) || (pos2 == 5));
        case 73:                // 73. ADVN DDAQ
            return ((pos2 == 28) || (pos2 == 22));
        case 74:                // 74. ADVN DDBQ
            return ((pos2 == 28) || (pos2 == 21));
        case 75:                // 75. ADVN DDBQ RPRE VATT
            return ((pos2 == 28) || (pos2 == 21) || (pos2 == 40) || (pos2 == 13));
        case 76:                // 76. ADVN DDBQ VATT VSTA XVAE *
            return ((pos2 == 28) || (pos2 == 21) || (pos2 == 13) || (pos2 == 12));
        case 77:                // 77. ADVN DIAC
            return ((pos2 == 28) || (pos2 == 21));
        case 78:                // 78. ADVN DIAC PDMN
            return ((pos2 == 28) || (pos2 == 21) || (pos2 == 8));
        case 79:                // 79. ADVN DIBQ
            return ((pos2 == 28) || (pos2 == 24));
        case 80:                // 80. ADVN DIBQ NCMN
            return ((pos2 == 28) || (pos2 == 24) || (pos2 == 5));
        case 81:                // 81. ADVN DIBQ VACT VSTA
            return ((pos2 == 28) || (pos2 == 24) || (pos2 == 11) || (pos2 == 12));
        case 82:                // 82. ADVN DIBQ VATT
            return ((pos2 == 28) || (pos2 == 24) || (pos2 == 13));
        case 83:                // 83. ADVN DONM JCMP
            return ((pos2 == 28) || (pos2 == 27) || (pos2 == 38));
        case 84:                // 84. ADVN DONM JSBR NCMN RPRE VATT XVAE *
            return ((pos2 == 28) || (pos2 == 27) || (pos2 == 39) || (pos2 == 5));
        case 85:                // 85. ADVN EITT PNTR
            return ((pos2 == 28) || (pos2 == 45) || (pos2 == 9));
        case 86:                // 86. ADVN FIXN
            return ((pos2 == 28) || (pos2 == 42));
        case 87:                // 87. ADVN JCMP
            return ((pos2 == 28) || (pos2 == 38));
        case 88:                // 88. ADVN JCRG
            return ((pos2 == 28) || (pos2 == 37));
        case 89:                // 89. ADVN JCRG JSBR
            return ((pos2 == 28) || (pos2 == 37) || (pos2 == 39));
        case 90:                // 90. ADVN JCRG JSBR XVBM XVMM
            return ((pos2 == 28) || (pos2 == 37) || (pos2 == 39) || (pos2 == 14) || (pos2 == 16));
        case 91:                // 91. ADVN JCRG RPRE VACT VSTA XVAE *
            return ((pos2 == 28) || (pos2 == 37) || (pos2 == 40) || (pos2 == 11));
        case 92:                // 92. ADVN JSBR
            return ((pos2 == 28) || (pos2 == 39));
        case 93:                // 93. ADVN JSBR NCMN
            return ((pos2 == 28) || (pos2 == 39) || (pos2 == 5));
        case 94:                // 94. ADVN JSBR RPRE VATT
            return ((pos2 == 28) || (pos2 == 39) || (pos2 == 40) || (pos2 == 13));
        case 95:                // 95. ADVN JSBR RPRE XVAE
            return ((pos2 == 28) || (pos2 == 39) || (pos2 == 40) || (pos2 == 18));
        case 96:                // 96. ADVN JSBR VSTA
            return ((pos2 == 28) || (pos2 == 39) || (pos2 == 12));
        case 97:                // 97. ADVN JSBR XVAE XVBM
            return ((pos2 == 28) || (pos2 == 39) || (pos2 == 18) || (pos2 == 14));
        case 98:                // 98. ADVN NCMN
            return ((pos2 == 28) || (pos2 == 5));
        case 99:                // 99. ADVN NCMN RPRE VACT VATT VSTA
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 40) || (pos2 == 11) || (pos2 == 12));
        case 100:               // 100. ADVN NCMN RPRE VACT XVAE
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 40) || (pos2 == 18));
        case 101:               // 101. ADVN NCMN RPRE VATT
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 40) || (pos2 == 13));
        case 102:               // 102. ADVN NCMN VACT VATT VSTA
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 11) || (pos2 == 13) || (pos2 == 12));
        case 103:               // 103. ADVN NCMN VACT VSTA",
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 11) || (pos2 == 12));
        case 104:               // 104. ADVN NCMN VATT
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 13));
        case 105:               // 105. ADVN NCMN VATT VSTA
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 13) || (pos2 == 12));
        case 106:               // 106. ADVN NEG
            return ((pos2 == 28) || (pos2 == 46));
        case 107:               // 107. ADVN NPRP VATT
            return ((pos2 == 28) || (pos2 == 1) || (pos2 == 13));
        case 108:               // 108. ADVN PDMN VACT
            return ((pos2 == 28) || (pos2 == 8) || (pos2 == 11));
        case 109:               // 109. ADVN PNTR",
            return ((pos2 == 28) || (pos2 == 9));
        case 110:               // 110. ADVN RPRE",
            return ((pos2 == 28) || (pos2 == 40)); 
        case 111:               // 111. ADVN RPRE VACT VATT XVAE",
            return ((pos2 == 28) || (pos2 == 40) || (pos2 == 11) || (pos2 == 13));  
        case 112:               // 112. ADVN RPRE VACT XVAM XVBM
            return ((pos2 == 28) || (pos2 == 40) || (pos2 == 11) || (pos2 == 15) || (pos2 == 14)); 
        case 113:               // 113. ADVN RPRE VATT VSTA
            return ((pos2 == 28) || (pos2 == 40) || (pos2 == 13) || (pos2 == 12)); 
        case 114:               // 114. ADVN RPRE VSTA
            return ((pos2 == 28) || (pos2 == 40) || (pos2 == 12)); 
        case 115:               // 115. ADVN VACT
            return ((pos2 == 28) || (pos2 == 11)); 
        case 116:               // 116. ADVN VACT VATT
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 13)); 
        case 117:               // 117. ADVN VACT VATT VSTA
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 13) || (pos2 == 12));
        case 118:               // 118. ADVN VACT VATT VSTA XVAM XVBM
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 13) || (pos2 == 12) || (pos2 == 15) || (pos2 == 14));
        case 119:               // 119. ADVN VACT VSTA
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 12));
        case 120:               // 120. ADVN VACT VSTA XVAE
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 12) || (pos2 == 18));
        case 121:               // 121. ADVN VACT XVAE
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 18));
        case 122:               // 122. ADVN VATT
            return ((pos2 == 28) || (pos2 == 13));
        case 123:               // 123. ADVN VATT VSTA
            return ((pos2 == 28) || (pos2 == 13) || (pos2 == 12));
        case 124:               // 124. ADVN VATT VSTA XVAM XVBM XVMM
            return ((pos2 == 28) || (pos2 == 13) || (pos2 == 12) || (pos2 == 15) || (pos2 == 14));
        case 125:               // 125. ADVN VATT XVBM
            return ((pos2 == 28) || (pos2 == 13) || (pos2 == 14));
        case 126:               // 126. ADVN VSTA
            return ((pos2 == 28) || (pos2 == 12));
        case 127:               // 127. ADVN VSTA XVAE
            return ((pos2 == 28) || (pos2 == 12) || (pos2 == 18));
        case 128:               // 128. ADVN VSTA XVBM",
            return ((pos2 == 28) || (pos2 == 12) || (pos2 == 14));
        case 129:               // 129. ADVN XVAE
            return ((pos2 == 28) || (pos2 == 18));
        case 130:               // 130. ADVN XVAM
            return ((pos2 == 28) || (pos2 == 15));
        case 131:               // 131. ADVN XVBM XVMM
            return ((pos2 == 28) || (pos2 == 14) || (pos2 == 16));
        case 132:               // 132. ADVP JSBR RPRE VATT
            return ((pos2 == 30) || (pos2 == 39) || (pos2 == 40) || (pos2 == 13));
        case 133:               // 133. ADVP VATT
            return ((pos2 == 30) || (pos2 == 13));
        case 134:               // 134. ADVS DDAC JCRG
            return ((pos2 == 31) || (pos2 == 20) || (pos2 == 37));
        case 135:               // 135. ADVS DDAC JSBR
            return ((pos2 == 31) || (pos2 == 20) || (pos2 == 39));
        case 136:               // 136. ADVS DDAN VSTA
            return ((pos2 == 31) || (pos2 == 19) || (pos2 == 12));
        case 137:               // 137. ADVS DIAC
            return ((pos2 == 31) || (pos2 == 23));
        case 138:               // 138. ADVS DONM
            return ((pos2 == 31) || (pos2 == 27));
        case 139:               // 139. ADVS JCRG JSBR
            return ((pos2 == 31) || (pos2 == 37) || (pos2 == 39));
        case 140:               // 140. ADVS JCRG JSBR RPRE
            return ((pos2 == 31) || (pos2 == 37) || (pos2 == 39) || (pos2 == 40));
        case 141:               // 141. ADVS JSBR
            return ((pos2 == 31) || (pos2 == 39));
        case 142:               // 142. ADVS JSBR RPRE
            return ((pos2 == 31) || (pos2 == 39) || (pos2 == 40));
        case 143:               // 143. ADVS NCMN
            return ((pos2 == 31) || (pos2 == 5));
        case 144:               // 144. ADVS VATT
            return ((pos2 == 31) || (pos2 == 13));
        case 145:               // 145. CFQC CLTV CNIT DCNM JCRG JSBR NCMN RPRE XVBM
            return ((pos2 == 35) || (pos2 == 33) || (pos2 == 32));
        case 146:               // 146. CFQC CNIT PREL
            return ((pos2 == 35) || (pos2 == 32) || (pos2 == 10));
        case 147:               // 147. CFQC NCMN
            return ((pos2 == 35) || (pos2 == 5));
        case 148:               // 148. CLTV CNIT NCMN
            return ((pos2 == 33) || (pos2 == 32) || (pos2 == 5));
        case 149:               // 149. CLTV CNIT NCMN RPRE
            return ((pos2 == 33) || (pos2 == 32) || (pos2 == 5) || (pos2 == 40));
        case 150:               // 150. CLTV CNIT NCMN VSTA
            return ((pos2 == 33) || (pos2 == 32) || (pos2 == 5) || (pos2 == 12));
        case 151:               // 151. CLTV NCMN
            return ((pos2 == 33) || (pos2 == 5));
        case 152:               // 152. CLTV NCMN VACT VATT
            return ((pos2 == 33) || (pos2 == 5) || (pos2 == 11) || (pos2 == 13));
        case 153:               // 153. CLTV NCMN VATT
            return ((pos2 == 33) || (pos2 == 5) || (pos2 == 13));
        case 154:               // 154. CMTR CNIT NCMN
            return ((pos2 == 34) || (pos2 == 32) || (pos2 == 5));
        case 155:               // 155. CMTR NCMN
            return ((pos2 == 34) || (pos2 == 5));
        case 156:               // 156. CMTR NCMN VATT VSTA
            return ((pos2 == 34) || (pos2 == 5) || (pos2 == 13) || (pos2 == 12));
        case 157:               // 157. CNIT DDAC NCMN VATT
            return ((pos2 == 32) || (pos2 == 20) || (pos2 == 5) || (pos2 == 13));
        case 158:               // 158. CNIT DONM NCMN RPRE VATT
            return ((pos2 == 32) || (pos2 == 27) || (pos2 == 5) || (pos2 == 40) || (pos2 == 13));
        case 159:               // 159. CNIT FIXN FIXV JSBR NCMN
            return ((pos2 == 32) || (pos2 == 42) || (pos2 == 43) || (pos2 == 39) || (pos2 == 5));
        case 160:               // 160. CNIT JCRG JSBR NCMN PREL RPRE VATT
            return ((pos2 == 32) || (pos2 == 37) || (pos2 == 39) || (pos2 == 5) || (pos2 == 40));
        case 161:               // 161. CNIT JSBR RPRE
            return ((pos2 == 32) || (pos2 == 39) || (pos2 == 40));
        case 162:               // 162. CNIT NCMN
            return ((pos2 == 32) || (pos2 == 5));
        case 163:               // 163. CNIT NCMN RPRE
            return ((pos2 == 32) || (pos2 == 5) || (pos2 == 40));
        case 164:               // 164. CNIT NCMN RPRE VATT
            return ((pos2 == 32) || (pos2 == 5) || (pos2 == 40) || (pos2 == 13));
        case 165:               // 165. CNIT NCMN VACT
            return ((pos2 == 32) || (pos2 == 5) || (pos2 == 11));
        case 166:               // 166. CNIT NCMN VSTA
            return ((pos2 == 32) || (pos2 == 5) || (pos2 == 12));
        case 167:               // 167. CNIT NCNM
            return ((pos2 == 32) || (pos2 == 5));
        case 168:               // 168. CNIT PPRS
            return ((pos2 == 32) || (pos2 == 7));
        case 169:               // 169. DCNM DDAC DIAC DONM VATT VSTA *
            return ((pos2 == 26) || (pos2 == 20) || (pos2 == 23));
        case 170:               // 170. DCNM DDAN DIAC  
            return ((pos2 == 26) || (pos2 == 19) || (pos2 == 23));
        case 171:               // 171. DCNM DIAC NCMN NCNM
            return ((pos2 == 26) || (pos2 == 23) || (pos2 == 5) || (pos2 == 2));
        case 172:               // 172. DCNM DIBQ NCMN
            return ((pos2 == 26) || (pos2 == 24) || (pos2 == 5));
        case 173:               // 173. DCNM DONM
            return ((pos2 == 26) || (pos2 == 27));
        case 174:               // 174. DCNM NCMN
            return ((pos2 == 26) || (pos2 == 2));
        case 175:               // 175. DCNM NCNM
            return ((pos2 == 26) || (pos2 == 5));
        case 176:               // 176. DCNM NCNM VACT
            return ((pos2 == 26) || (pos2 == 5) || (pos2 == 11));
        case 177:               // 177. DCNM VATT
            return ((pos2 == 26) || (pos2 == 13));
        case 178:               // 178. DDAC DDAN
            return ((pos2 == 20) || (pos2 == 19));
        case 179:               // 179. DDAC DDAN DIAC NCMN
            return ((pos2 == 20) || (pos2 == 19) || (pos2 ==23) || (pos2 ==5));
        case 180:               // 180. DDAC DDAN DIAC VATT
            return ((pos2 == 20) || (pos2 == 19) || (pos2 ==23) || (pos2 ==13));
        case 181:               // 181. DDAC DDAN EAFF PDMN
            return ((pos2 == 20) || (pos2 == 19) || (pos2 ==44) || (pos2 ==8));
        case 182:               // 182. DDAC DDAN PDMN
            return ((pos2 == 20) || (pos2 == 19) || (pos2 ==8));
        case 183:               // 183. DDAC DIAC VSTA
            return ((pos2 == 20) || (pos2 == 23) || (pos2 ==12));
        case 184:               // 184. DDAC NCMN
            return ((pos2 == 20) || (pos2 == 5));
        case 185:               // 185. DDAN DDBQ
            return ((pos2 == 20) || (pos2 == 21));
        case 186:               // 186. DDAN DIAC PNTR
            return ((pos2 == 20) || (pos2 == 23) || (pos2 == 9));
        case 187:               // 187. DDAN NCMN
            return ((pos2 == 20) || (pos2 == 5));
        case 188:               // 188. DDAN NCMN RPRE VATT
            return ((pos2 == 20) || (pos2 == 5) || (pos2 == 40) || (pos2 == 13));
        case 189:               // 189. DDAN PDMN
            return ((pos2 == 20) || (pos2 == 8));
        case 190:				// 190. DDAN RPRE
            return ((pos2 == 20) || (pos2 == 40));
        case 191:               // 191. VATT
            return (pos2 == 13);
		case 192:				// 192. DDAQ VATT
            return ((pos2 == 22) || (pos2 == 13));
		case 193:				// 193. DDBQ DIBQ
            return ((pos2 == 21) || (pos2 == 24));
		case 194:				// 194. DDBQ JCRG JSBR
            return ((pos2 == 21) || (pos2 == 37) || (pos2 == 39));
		case 195:				// 195. DDBQ JCRG NCMN
            return ((pos2 == 21) || (pos2 == 37) || (pos2 == 5));
		case 196:				// 196. DIAC PDMN
            return ((pos2 == 23) || (pos2 == 8));
		case 197:				// 197. DIBQ JSBR RPRE VSTA
            return ((pos2 == 24) || (pos2 == 39) || (pos2 == 40) || (pos2 == 12));
		case 198:				// 198. DIBQ NCMN
            return ((pos2 == 24) || (pos2 == 5));
		case 199:				// 199. DIBQ VATT
            return ((pos2 == 24) || (pos2 == 13));
		case 200:				// 200. DIBQ VATT VSTA
            return ((pos2 == 24) || (pos2 == 13) || (pos2 == 12));
		case 201:				// 201. DIBQ XVBM
            return ((pos2 == 24) || (pos2 == 14));
		case 202:				// 202. DONM NCMN RPRE
            return ((pos2 == 27) || (pos2 == 5) || (pos2 == 40));
		case 203:				// 203. DONM VACT VATT VSTA
            return ((pos2 == 27) || (pos2 == 11) || (pos2 == 13) || (pos2 == 12));
		case 204:				// 204. DONM VATT
            return ((pos2 == 27) || (pos2 == 13));
		case 205:				// 205. EAFF XVAE XVAM XVBM
            return ((pos2 == 44) || (pos2 == 18) || (pos2 == 15) || (pos2 == 14));
		case 206:				// 206. EITT JCRG
            return ((pos2 == 45) || (pos2 == 37));
		case 207:				// 207. FIXN FIXV NCMN
            return ((pos2 == 42) || (pos2 == 43) || (pos2 == 5));
		case 208:				// 208. FIXN FIXV RPRE VSTA
            return ((pos2 == 42) || (pos2 == 43) || (pos2 == 40) || (pos2 == 12));
		case 209:				// 209. FIXN JSBR NCMN PREL RPRE VSTA XVBM *
            return ((pos2 == 42) || (pos2 == 39) || (pos2 == 5) || (pos2 == 10));
		case 210:				// 210. FIXN NCMN
			return ((pos2 == 42) || (pos2 == 5));
		case 211:				// 211. FIXN VACT",
			return ((pos2 == 42) || (pos2 == 11));
		case 212:				// 212. FIXN VACT VSTA",
			return ((pos2 == 42) || (pos2 == 11) || (pos2 == 12));
		case 213:				// 213. FIXV JSBR RPRE",
			return ((pos2 == 42) || (pos2 == 39) || (pos2 == 40));
		case 214:				// 214. JCMP JSBR",
			return ((pos2 == 38) || (pos2 == 39));
		case 215:				// 215. JCMP RPRE VSTA",
			return ((pos2 == 38) || (pos2 == 40) || (pos2 == 12));
		case 216:				// 216. JCMP VATT VSTA",
			return ((pos2 == 38) || (pos2 == 13) || (pos2 == 12));
		case 217:				// 217. JCMP VSTA",
			return ((pos2 == 38) || (pos2 == 12));
		case 218:				// 218. JCRG JSBR",
			return ((pos2 == 37) || (pos2 == 39));
		case 219:				// 219. JCRG JSBR NCMN RPRE
			return ((pos2 == 37) || (pos2 == 39) || (pos2 == 5) || (pos2 == 40));
		case 220:				// 220. JCRG JSBR RPRE",
			return ((pos2 == 37) || (pos2 == 39) || (pos2 == 40));
		case 221:				// 221. JCRG RPRE
			return ((pos2 == 37) || (pos2 == 40));
		case 222:				// 222. JCRG RPRE VATT VSTA
			return ((pos2 == 37) || (pos2 == 40)|| (pos2 == 13)|| (pos2 == 12));
		case 223:				// 223. JCRG VSTA
			return ((pos2 == 37) || (pos2 == 12));
		case 224:				// 224. JSBR NCMN
			return ((pos2 == 39) || (pos2 == 5));
		case 225:				// 225. JSBR NCMN XVAE
			return ((pos2 == 39) || (pos2 == 5) || (pos2 == 18));
		case 226:				// 226. JSBR NCMN XVAM XVBM XVMM
			return ((pos2 == 39) || (pos2 == 5) || (pos2 == 15) || (pos2 == 14) || (pos2 ==16));
		case 227:				// 227. JSBR PREL
			return ((pos2 == 39) || (pos2 == 10));
		case 228:				// 228. JSBR PREL RPRE
			return ((pos2 == 39) || (pos2 == 10) || (pos2 == 40));
		case 229:				// 229. JSBR PREL XVBM
			return ((pos2 == 39) || (pos2 == 10) || (pos2 == 14));
		case 230:				// 230. JSBR RPRE
			return ((pos2 == 39) || (pos2 == 40));
		case 231:				// 231. JSBR RPRE VACT
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 11));
		case 232:				// 232. JSBR RPRE VACT VSTA
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 11)|| (pos2 == 12));
		case 233:				// 233. JSBR RPRE VACT XVAE XVAM
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 11)|| (pos2 == 18)|| (pos2 == 15));
		case 234:				// 234. JSBR RPRE VATT
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 13));
		case 235:				// 235. JSBR RPRE VSTA
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 12));
		case 236:				// 236. JSBR RPRE XVAM
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 15));
		case 237:				// 237. JSBR VACT
			return ((pos2 == 39) || (pos2 == 11));
		case 238:				// 238. JSBR VACT VSTA
			return ((pos2 == 39) || (pos2 == 11) || (pos2 == 12));
		case 239:				// 239. JSBR VATT XVBM XVMM
			return ((pos2 == 39) || (pos2 == 13) || (pos2 == 14) || (pos2 == 16));
		case 240:				// 240. JSBR VSTA
			return ((pos2 == 39) || (pos2 == 12));
		case 241:				// 241. JSBR XVBM
			return ((pos2 == 39) || (pos2 == 14)); 
		case 242:				// 242. NCMN NCNM
			return ((pos2 == 5) || (pos2 == 2)); 
		case 243:				// 243. NCMN NCNM NPRP
			return ((pos2 == 5) || (pos2 == 2) || (pos2 == 1)); 
		case 244:				// 244. NCMN NLBL NPRP
			return ((pos2 == 5) || (pos2 == 4) || (pos2 == 1)); 
		case 245:				// 245. NCMN NPRP
			return ((pos2 == 5) || (pos2 == 1)); 
		case 246:				// 246. NCMN NPRP RPRE
			return ((pos2 == 5) || (pos2 == 1) || (pos2 == 40)); 
		case 247:				// 247. NCMN NTTL
			return ((pos2 == 5) || (pos2 == 6)); 
		case 248:				// 248. NCMN PDMN PPRS
			return ((pos2 == 5) || (pos2 == 8) || (pos2 == 7)); 
		case 249:				// 249. NCMN PDMN VATT
			return ((pos2 == 5) || (pos2 == 8) || (pos2 == 13)); 
		case 250:				// 250. NCMN PNTR
			return ((pos2 == 5) || (pos2 == 9)); 
		case 251:				// 251. NCMN PPRS PREL VACT
			return ((pos2 == 5) || (pos2 == 7) || (pos2 == 10) || (pos2 == 11)); 
		case 252:				// 252. NCMN RPRE
			return ((pos2 == 5) || (pos2 == 40)); 
		case 253:				// 253. NCMN RPRE VACT VATT
			return ((pos2 == 5) || (pos2 == 40) || (pos2 == 11) || (pos2 == 13)); 
		case 254:				// 254. NCMN RPRE VATT
			return ((pos2 == 5) || (pos2 == 40) || (pos2 == 13)); 
		case 255:				// 255. NCMN VACT
			return ((pos2 == 5) || (pos2 == 11)); 
		case 256:				// 256. NCMN VACT VATT
			return ((pos2 == 5) || (pos2 == 11) || (pos2 == 13)); 
		case 257:				// 257. NCMN VACT VATT VSTA XVAE
			return ((pos2 == 5) || (pos2 == 11) || (pos2 == 13) || (pos2 == 12) || (pos2 == 18)); 
		case 258:				// 258. NCMN VACT VSTA
			return ((pos2 == 5) || (pos2 == 11) || (pos2 == 12)); 
		case 259:				// 259. NCMN VACT VSTA XVAM
			return ((pos2 == 5) || (pos2 == 11) || (pos2 == 12) || (pos2 == 15)); 
		case 260:				// 260. NCMN VACT VSTA XVBB
			return ((pos2 == 5) || (pos2 == 11) || (pos2 == 12) || (pos2 == 17)); 
		case 261:				// 261. NCMN VATT
			return ((pos2 == 5) || (pos2 == 13)); 
		case 262:				// 262. NCMN VATT VSTA
			return ((pos2 == 5) || (pos2 == 13) || (pos2 == 12)); 
		case 263:				// 263. NCMN VATT XVAM
			return ((pos2 == 5) || (pos2 == 13) || (pos2 == 15)); 
		case 264:				// 264. NCMN VSTA
			return ((pos2 == 5) || (pos2 == 12)); 
		case 265:				// 265. NCMN XVBM
			return ((pos2 == 5) || (pos2 == 14)); 
		case 266:				// 266. NPRP RPRE
			return ((pos2 == 1) || (pos2 == 40)); 
		case 267:				// 267. NPRP VATT
			return ((pos2 == 1) || (pos2 == 13)); 
		case 268:				// 268. NTTL PPRS
			return ((pos2 == 6) || (pos2 == 7)); 
		case 269:				// 269. PDMN PPRS
			return ((pos2 == 8) || (pos2 == 7)); 
		case 270:				// 270. PDMN VATT
			return ((pos2 == 8) || (pos2 == 13)); 
		case 271:				// 271. PDMN VATT VSTA
			return ((pos2 == 8) || (pos2 == 13) || (pos2 == 12)); 
		case 272:				// 272. PPRS PREL
			return ((pos2 == 7) || (pos2 == 10)); 
		case 273:				// 273. PPRS VATT
			return ((pos2 == 7) || (pos2 == 13)); 
		case 274:				// 274. RPRE VACT
			return ((pos2 == 40) || (pos2 == 11)); 
		case 275:				// 275. RPRE VACT VATT
			return ((pos2 == 40) || (pos2 == 11) || (pos2 == 13)); 
		case 276:				// 276. RPRE VACT VSTA
			return ((pos2 == 40) || (pos2 == 11) || (pos2 == 12)); 
		case 277:				// 277. RPRE VACT VSTA XVAE
			return ((pos2 == 40) || (pos2 == 11) || (pos2 == 12) || (pos2 == 18)); 
		case 278:				// 278. RPRE VACT XVAE
			return ((pos2 == 40) || (pos2 == 11) || (pos2 == 18)); 
		case 279:				// 279. RPRE VATT
			return ((pos2 == 40) || (pos2 == 13)); 
		case 280:				// 280. RPRE VATT VSTA
			return ((pos2 == 40) || (pos2 == 13) || (pos2 == 12)); 
		case 281:				// 281. RPRE VSTA
			return ((pos2 == 40) || (pos2 == 12)); 
		case 282:				// 282. VACT VATT
			return ((pos2 == 11) || (pos2 == 13)); 
		case 283:				// 283. VACT VATT VSTA
			return ((pos2 == 11) || (pos2 == 13) || (pos2 == 12)); 
		case 284:				// 284. VACT VATT XVAE XVAM XVBM
			return ((pos2 == 11) || (pos2 == 13) || (pos2 == 18) || (pos2 == 15) || (pos2 == 14)); 
		case 285:				// 285. VACT VSTA
			return ((pos2 == 11) || (pos2 == 12)); 
		case 286:				// 286. VACT VSTA XVAE
			return ((pos2 == 11) || (pos2 == 12) || (pos2 == 18)); 
		case 287:				// 287. VACT VSTA XVAE XVAM
			return ((pos2 == 11) || (pos2 == 12) || (pos2 == 18) || (pos2 == 15)); 
		case 288:				// 288. VACT VSTA XVAE XVAM XVMM",
			return ((pos2 == 11) || (pos2 == 12) || (pos2 == 18) || (pos2 == 15) || (pos2 == 16)); 
		case 289:				// 289. VACT VSTA XVAM",
			return ((pos2 == 11) || (pos2 == 12) || (pos2 == 15)); 
		case 290:				// 290. VACT VSTA XVAM XVMM",
			return ((pos2 == 11) || (pos2 == 12) || (pos2 == 15) || (pos2 == 16)); 
		case 291:				// 291. VACT XVAE",
			return ((pos2 == 11) || (pos2 == 18)); 
		case 292:				// 292. VACT XVAM",
			return ((pos2 == 11) || (pos2 == 15)); 
		case 293:				// 293. VACT XVAM XVMM",
			return ((pos2 == 11) || (pos2 == 15) || (pos2 == 16)); 
		case 294:				// 294. VACT XVMM",
			return ((pos2 == 11) || (pos2 == 16)); 
		case 295:				// 295. VATT VSTA",
			return ((pos2 == 13) || (pos2 == 12)); 
		case 296:				// 296. VSTA XVAE",
			return ((pos2 == 12) || (pos2 == 18)); 
		case 297:				// 297. VSTA XVAM",
			return ((pos2 == 12) || (pos2 == 15)); 
		case 298:				// 298. VSTA XVAM XVMM",
			return ((pos2 == 12) || (pos2 == 15) || (pos2 == 16)); 
		case 299:				// 299. VSTA XVBM",
			return ((pos2 == 12) || (pos2 ==14)); 
		case 300:				// 300. XVAM XVBM",
			return ((pos2 == 15) || (pos2 == 14)); 
		case 301:				// 301. XVAM XVBM XVMM",
			return ((pos2 == 15) || (pos2 == 14) || (pos2 == 16)); 
		case 302:				// 302. XVAM XVMM",
			return ((pos2 == 15) || (pos2 == 16)); 
		default:
			return false;
        }
    }
}
//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrigramTrieIter
//
//  Synoposis:  Constructor:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrigramTrieIter::CThaiTrigramTrieIter() : pTrieScanArray(NULL)
{
    pTrieScanArray = new TRIESCAN[50];
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrigramTrieIter
//
//  Synoposis:  Destructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrigramTrieIter::~CThaiTrigramTrieIter()
{
    if (pTrieScanArray)
        delete pTrieScanArray;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrigramTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiTrigramTrieIter::Init(CTrie* ctrie)
{
    // Declare varialbes.
    WCHAR pos;

    // Initialize parent.
    CTrieIter::Init(ctrie);

    pos1Cache = 0;
    pos2Cache = 0;

    // Initialize Hash table.
    for (pos = 1; pos <= 47; pos++)
        GetScanFirstChar(pos,&pTrieScanArray[pos]);
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrigramTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiTrigramTrieIter::GetScanFirstChar(WCHAR wc, TRIESCAN* pTrieScan)
{
    // Reset the trie scan.
	memset(&trieScan, 0, sizeof(TRIESCAN));

    // Encrypt
    wc += 0x0100;

    if (!TrieGetNextState(pTrieCtrl, &trieScan))
        return false;

    while (wc != trieScan.wch)
    {
        // Keep moving the the right of the trie.
        if (!TrieGetNextNode(pTrieCtrl, &trieScan))
        {
        	memset(pTrieScan, 0, sizeof(TRIESCAN));
            return false;
        }
    }
    memcpy(pTrieScan, &trieScan, sizeof(TRIESCAN));

    return true;
}


//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrigramTrieIter
//
//  Synopsis:   Bring interation index to the first node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiTrigramTrieIter::GetNode()
{
	pos = (WCHAR) trieScan.wch - 0x0100;
/*
	fWordEnd = (trieScan.wFlags & TRIE_NODE_VALID) &&
				(!(trieScan.wFlags & TRIE_NODE_TAGGED) ||
				(trieScan.aTags[0].dwData & iDialectMask));
*/
	fWordEnd = (trieScan.wFlags & TRIE_NODE_VALID);

	if (fWordEnd)
	{
        dwTag = (DWORD) (trieScan.wFlags & TRIE_NODE_TAGGED ?
                            trieScan.aTags[0].dwData :
                            0);
	}
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrigramTrieIter
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CThaiTrigramTrieIter::GetProb(WCHAR pos1, WCHAR pos2, WCHAR pos3)
{
   	// Declare and initialize all local variables.
	int i = 0;

    if (pos1 == pos1Cache && pos2 == pos2Cache)
    {
        memcpy(&trieScan,&trieScanCache, sizeof(TRIESCAN));

        if (!Down()) return 0;
        while (true)
        {
            GetNode();
            if (IsTagEqual(pos3,pos) && fWordEnd)
            {
                return dwTag;
            }
            else if (!Right()) break;               
        }
        return 0;
    }
    if (pos1 >= 1 && pos1 <= 47)
        memcpy(&trieScan,&pTrieScanArray[pos1], sizeof(TRIESCAN));
	Reset();

	if (!Down())
		return false;

	while (true)
	{
		GetNode();
		if (IsTagEqual(pos1,pos))
		{
            if (!Down()) break;
            while (true)
            {
        		GetNode();
                if (IsTagEqual(pos2,pos))
	        	{
                    pos1Cache = pos1;
                    pos2Cache = pos2;
                    memcpy(&trieScanCache,&trieScan, sizeof(TRIESCAN));

                    if (!Down()) break;
                    while (true)
                    {
                		GetNode();
                        if (IsTagEqual(pos3,pos) && fWordEnd)
	                	{
                            return dwTag;
                        }
                		else if (!Right()) break;               
                    }
                    return 0;
                }
        		else if (!Right()) break;               
            }
            return 0;
		}
		// Move right of the Trie Branch
		else if (!Right()) break;
	}
	return 0;
}

DWORD CThaiTrigramTrieIter::GetProb(const WCHAR* posArray)
{
	// Declare and initialize all local variables.
	int i = 0;

	Reset();

	if (!Down())
		return 0;

	while (TRUE)
	{
		GetNode();
		if (pos == posArray[i])
		{
			i++;
			if (fWordEnd && posArray[i] == '\0')
            {
				return dwTag;
            }
			// Move down the Trie Branch.
			else if (!Down()) break;
		}
		// Move right of the Trie Branch
		else if (!Right()) break;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\dbgmemp.h ===
#ifndef _DBGMEMP_H
#define _DBGMEMP_H

#include <windows.h>
#include <string.h>
#include "cmn_debug.h"              // For our local version of Assert()

// Define ENABLE_DBG_HANDLES if you want to be enable the moveable block
// portion of the memory allocator
#undef ENABLE_DBG_HANDLES

// The base allocator type
typedef struct head             /* Private memory block header */
{
    DWORD dwTag;                /* Block validation ID */
    struct head* pheadNext;     /* Next in list of allocated blocks */
    int idBlock;                /* Block "name" */

    DWORD cbBlock;              /* Size of caller's memory block */
    int cLock;                  /* Lock count of object */

    LPBYTE pbBase;              /* The VirtualAlloc'd block */
} HEAD;

#define HEAD_TAG  ( MAKELONG( MAKEWORD('H','E'),MAKEWORD('A','D') ))
#define PAD(a,n)  ( ((a)+(n)-1) / (n) * (n) )


// byte patterns for filling memory
#define bNewGarbage    0xA3
#define bOldGarbage    0xA4
#define bFreeGarbage   0xA5
#define bDebugByte     0xE1

// Flags for enabling particular types of optional behavior
// if fMove is true, blah blah
// if fExtraReadPage is true, blah blah
// if fPadBlocks is true, all memory allocations will be padded to 4-byte boundaries
#define fMove           FALSE
#define fExtraReadPage  FALSE
#ifdef _M_ALPHA
// Enable dword alignment (padding to 4 byte boundaries) for the Alpha
#define fPadBlocks      TRUE
#else // not _M_ALPHA
#define fPadBlocks      FALSE
#endif // _M_ALPHA


// Protos that must be shared between our source files
HEAD    *GetBlockHeader(void*);
LPVOID  PvAllocateCore(UINT, DWORD);

#ifdef ENABLE_DBG_HANDLES
#define minGHandle      0xA0000000L
#define cGHandles       0x4000L
#define limGHandle      (minGHandle+cGHandles)

HGLOBAL WINAPI  HgAllocateMoveable(UINT uFlags, DWORD cb);
HGLOBAL WINAPI  HgModifyMoveable(HGLOBAL hMem, DWORD cb, UINT uFlags);
void            **PpvFromHandle(HGLOBAL);

#else // NOT ENABLE_DBG_HANDLES

#define HgAllocateMoveable(a, b)    (NULL)
#define HgModifyMoveable(a, b, c)   (NULL)
#define PpvFromHandle(a)            (NULL)

#endif // ENABLE_DBG_HANDLES


/* F A C T U A L  H A N D L E */
/*----------------------------------------------------------------------------
    %%Macro: FActualHandle

    Returns TRUE if the handle came from actual Global memory manager.
----------------------------------------------------------------------------*/
#define FActualHandle(hMem)     FALSE

#endif // _DBGMEMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\debug.c ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       Debug.cpp
//
//  Contents:   Debug code.
//
//  History:    05-Apr-94   v-kentc     Created.
//
//---------------------------------------------------------------------------

#include "precomp.h"
#include <assert.h>

int __cdecl _purecall()
{
    AssertSz(FALSE, TEXT("'__purecall called'"));
    return 0;
}

#ifdef _DEBUG

static DWORD fAssertFlags = AssertDefaultBehavior;
static FILE *pAssertFile;

void WINAPI SetAssertOptions(DWORD dwNewOptions)
{
    fAssertFlags = dwNewOptions;
}

static void
OpenAssertFile()
{
    // REVIEW - do we want a unicode file name? If so
    // pAssertFile = _wfopen(L"asserts.txt", L"a");
    pAssertFile = fopen("asserts.txt", "a");
    if (NULL != pAssertFile)
        fflush(pAssertFile);
}

void WINAPI DebugAssert(LPCTSTR pText, LPCTSTR pFile, UINT uLineNo)
{
    TCHAR buf[256];

    if (bAssertWriteToFile() || bAssertShowAlert())
    {
        if (pText)
            wsprintf(buf, TEXT("Assert %ws in file %ws - line %d"), pText, pFile, uLineNo);
        else
            wsprintf(buf, TEXT("Assert in file %ws - line %d"), pFile, uLineNo);
    }

    if (bAssertWriteToFile())
    {
        if (NULL == pAssertFile)
            OpenAssertFile();

        if (NULL != pAssertFile)
        {
            fwprintf(pAssertFile, buf);
            fflush(pAssertFile);
        }
    }

    if (bAssertShowAlert())
    {
         MessageBox(NULL, buf, TEXT("THammer"), MB_SETFOREGROUND | MB_OK);
    }

    if (bAssertUseVCAssert())
    {
       _assert((PVOID)pText, (PVOID)pFile, uLineNo);
    }

    if (bAssertCallDebugger())
    {
        DebugBreak();
    }

    if (bAssertExit())
    {
        if (pAssertFile)
            fclose(pAssertFile);
        exit(EXIT_FAILURE);
    }
}

#endif // !_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\ctrie.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CTrie - class CTrie encapsulation for Trie data structure.
//
//  History:
//      created 6/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTRIE_H_
#define _CTRIE_H_

#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "lexheader.h"
#include "trie.h"
//#include "NLGlib.h"
#include "ProofBase.h"
#include "thwbdef.hpp"
#include "CFileManager.h"

#define lidThai 0x41e
#define lidViet 0x42a

// 1111 0000 0000 0000 0000 0000 0000 0000   -- Alt Mask
// 0000 1111 1111 1111 1111 0000 0000 0000   -- Pos Mas

const int iDialectMask = 1;
const int iRestrictedMask = 16;
const int iPosMask = 268431360;   // 0x0FFFF000
const int iAltMask = 4026531840;  // 0xF0000000
const int iFrqShift = 8;
const int iPosShift = 12;
const int iAltShift = 28;

class CTrie;

class CTrieIter {
public:
	// Initialization functions.
	CTrieIter();
    CTrieIter(const CTrieIter& trieIter);
	virtual void Init(CTrie*);
	virtual void Init(TRIECTRL*);

	// Interation functions.
	virtual void Reset();
	virtual BOOL Down();
	virtual BOOL Right();
	virtual void GetNode();

	// Local variables.
	WCHAR wc;
	BOOL fWordEnd;
	BOOL fRestricted;
	BYTE frq;
	DWORD posTag;
    DWORD dwTag;        // Uncompress word tags.
protected:
	//Trie
	TRIECTRL* pTrieCtrl;

	// Trie Iterator.
	TRIESCAN trieScan;
};

class CTrie {
	friend class CTrieIter;
public:
	CTrie();
	~CTrie();

	static PTEC retcode(int mjr, int mnr) { return MAKELONG(mjr, mnr); }


	bool Init(const WCHAR* szFileName);
	PTEC InitRc(LPBYTE lpMap, BOOL fSkipHeader);
	void UnInit();
	BOOL Find(const WCHAR* szWord, DWORD* pdwPOS);

protected:
//	PMFILE pMapFile;
	TRIECTRL *pTrieCtrl;
	CTrieIter* pTrieScan;

	CFileManager* pFileManager;
	BYTE *m_pMap;
//	TRIECTRL * m_pTrieCtrl;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\lexheader.h ===
/****************************************************
*** lexheader.h

structure to head proofing tool lex files

DougP
-------------
The end user license agreement (EULA) for CSAPI, CHAPI, or CTAPI covers this source file.  Do not disclose it to third parties.

You are not entitled to any support or assistance from Microsoft Corporation regarding your use of this program.

 1998 Microsoft Corporation.  All rights reserved.
******************************************************************************/
#ifndef _LEXHEADER_H_
#define _LEXHEADER_H_

#include "vendor.h"

typedef DWORD LEXVERSION; // version

typedef enum
{
    lxidSpeller=0x779ff320,
    lxidThesaurus,
    lxidHyphenator,
    lxidGrammar,
    lxidMorphology,
    lxidLanguageId,
} LEXTYPEID;    // lxid

#define maxlidLexHeader 8
typedef struct
{
    LEXTYPEID   lxid;   // should be one of Lex...
    LEXVERSION  version;    // minimum version number of corresponding engine w/
                        // build number of THIS lex file
    VENDORID    vendorid;   // vendor id (must match engine - from vendor.h)
    LANGID      lidArray[maxlidLexHeader];  // LID's for this lex
                                        // terminate w/ 0
} LEXHEADER;    // lxhead

// The following enumeration was copied from lexdata.h -- aarayas
typedef short FREQPENALTY;    //frqpen
enum {
    frqpenNormal,
    frqpenVery,
    frqpenSomewhat,
    frqpenInfrequent,
    frqpenMax,  // needs to be last
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\ctrie.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CTrie - class CTrie encapsulation for Trie data structure.
//
//  History:
//      created 6/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "ctrie.hpp"

#define VERSIONMAJOR 1
#define VERSIONMINOR 0

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   constructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CTrieIter::CTrieIter()
{
	// Initialize local variables.
	Reset();
	wc = 0;
	fWordEnd = FALSE;
	fRestricted = FALSE;
	frq = 0;
    dwTag = 0;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   copy constructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CTrieIter::CTrieIter(const CTrieIter& trieIter)
{
	// Copy all variables from Initial trie.
   	memcpy(&trieScan, &trieIter.trieScan, sizeof(TRIESCAN));
	pTrieCtrl = trieIter.pTrieCtrl;
    wc = trieIter.wc;
	fWordEnd = trieIter.fWordEnd;
	fRestricted = trieIter.fRestricted;
	frq = trieIter.frq;
    dwTag = trieIter.dwTag;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTrieIter::Init(CTrie* ctrie)
{
	// Initialize TrieCtrl
	pTrieCtrl = ctrie->pTrieCtrl;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTrieIter::Init(TRIECTRL* pTrieCtrl1)
{
	// Initialize TrieCtrl
	pTrieCtrl = pTrieCtrl1;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Bring interation index to the first node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTrieIter::Reset()
{
	// Reset Trie.
	memset(&trieScan, 0, sizeof(TRIESCAN));
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Move Iteration index down one node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CTrieIter::Down()
{
	// Move the Trie down one node.
	return TrieGetNextState(pTrieCtrl, &trieScan);
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Move Iteration index right one node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CTrieIter::Right()
{
	// Move the Trie right one node.
	return TrieGetNextNode(pTrieCtrl, &trieScan);
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Bring interation index to the first node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTrieIter::GetNode()
{
	wc = trieScan.wch;
	fWordEnd = (trieScan.wFlags & TRIE_NODE_VALID) &&
				(!(trieScan.wFlags & TRIE_NODE_TAGGED) ||
				(trieScan.aTags[0].dwData & iDialectMask));

	if (fWordEnd)
	{
		fRestricted = (trieScan.wFlags & TRIE_NODE_TAGGED) &&
						(trieScan.aTags[0].dwData & iRestrictedMask);
		frq = (BYTE) (trieScan.wFlags & TRIE_NODE_TAGGED ?
						(trieScan.aTags[0].dwData & 0x300) >> iFrqShift :
						frqpenNormal);

		posTag = (DWORD) (trieScan.wFlags & TRIE_NODE_TAGGED ?
							(trieScan.aTags[0].dwData & iPosMask) >> iPosShift :
							0);

        dwTag = (DWORD) (trieScan.wFlags & TRIE_NODE_TAGGED ?
                            trieScan.aTags[0].dwData :
                            0);
	}
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CTrie::CTrie()
{
//	pMapFile = NULL;
	pTrieCtrl = NULL;
	pTrieScan = NULL;
	pFileManager = NULL;
	pFileManager = new CFileManager();
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CTrie::~CTrie()
{
	UnInit();
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   Initialize Trie.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CTrie::Init(const WCHAR* pwszFileName)
{
	// Declare and Initialize all local variables.
	unsigned int uiFileSize;
	bool retValue = false;
    PTEC ptec = ptecModuleError;

	// The function assume that pTrieCtrl is NULL, else there are possible memory leak.
	// possibility of this could be call Initilization without Terminating.
	assert(pTrieCtrl == NULL);

	// Initialize pMapFile and pTrieCtrl to NULL.		
	pTrieCtrl = NULL;

	if (pFileManager->Load(pwszFileName,(void**)&m_pMap,&uiFileSize))
	{
		pTrieCtrl = TrieInit(m_pMap);

		if (pTrieCtrl)
		{
			// We were able to load and point to the Trie okay.
			pTrieScan = new CTrieIter();
			pTrieScan->Init(this);
			retValue = true;
		}
	}

	return retValue;
/*
	pMapFile = OpenMapFileW(szFileName);

    if (pMapFile == NULL)
	{
		// Unable to load map files, return invalid read error.
        ptec = retcode(ptecIOErrorMainLex, ptecFileRead);
	}
	else if (pMapFile->pvMap == NULL)
	{
		// Return Invalid format and close the files.
        ptec = retcode(ptecIOErrorMainLex, ptecInvalidFormat);
        CloseMapFile(pMapFile);
	}
	else
	{
        BYTE *pmap = (BYTE *) pMapFile->pvMap;

        // find the header
        LEXHEADER *plxhead = (LEXHEADER *) pmap;
        pmap += sizeof(LEXHEADER);

          // verify that it's a valid lex file
        if (!(plxhead->lxid == lxidSpeller && plxhead->vendorid == vendoridMicrosoft &&
              PROOFMAJORVERSION(plxhead->version) == VERSIONMAJOR ))
        {
			// If we reached here than the lexicon is no in a valid Thai wordbreak format.
            ptec = retcode(ptecIOErrorMainLex, ptecInvalidFormat);
        }
		else
		{
            // Make sure the language matches check the first dialect of the lexicon.
			// CTrie also support both Thai and Vietnamese language.
			if ( (plxhead->lidArray[0] != lidThai) && (plxhead->lidArray[0] != lidViet) )
			{
				// If we reached here than we are not using Thai lexicon.
                ptec = retcode(ptecIOErrorMainLex, ptecInvalidLanguage);
            }
            else
            {
				// The size of the copyright notice
                int cCopyright = 0;
				WCHAR* pwzCopyright = NULL;
				int cLexSup = 0;

				cCopyright = * (int *) pmap;
                pmap += sizeof(int);

				// The copyright notice itself
                pwzCopyright = (WCHAR *) pmap;
                pmap += cCopyright * sizeof(WCHAR);

                // Skip Supplemental data for Thai word break.
				cLexSup = * (int *) pmap;
                pmap += sizeof(int);
                pmap += cLexSup;

                pTrieCtrl = TrieInit(pmap);
                if (pTrieCtrl)
				{
					// We were able to load and point to the Trie okay.
					//MessageBoxW(0,L"Was able to initialize Trie",pwsz,MB_OK);
					pTrieScan = new CTrieIter();
					pTrieScan->Init(this);
					ptec = ptecNoErrors;
				}
				else
				{
					// We were not able to initailize main lexicon.
	                ptec = retcode(ptecIOErrorMainLex, ptecInvalidMainLex);
				}
			}
		}
	}

	return ptec;
*/
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   Initialize Trie.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 2/2000 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
PTEC CTrie::InitRc(LPBYTE pmap, BOOL fSkipHeader)
{
	// Declare and Initialize all local variables.
    PTEC ptec = ptecModuleError;

	// The function assume that pMapFile and pTrieCtrl is NULL, else there are possible memory leak.
	// possibility of this could be call Initilization without Terminating.
	assert(pTrieCtrl == NULL);
	assert(pTrieScan == NULL);

	// Initialize pTrieCtrl to NULL.		
	pTrieCtrl = NULL;
	pTrieScan = NULL;

	if (!fSkipHeader)
	{
		LEXHEADER *plxhead = (LEXHEADER *) pmap;
		pmap += sizeof(LEXHEADER);

		// The size of the copyright notice
		int cCopyright = 0;
		const WCHAR* pwzCopyright = NULL;
		int cLexSup = 0;

		cCopyright = * (int *) pmap;
		pmap += sizeof(int);

		// The copyright notice itself
		pwzCopyright = (WCHAR *) pmap;
		pmap += cCopyright * sizeof(WCHAR);

		// Skip Supplemental data for Thai word break.
		cLexSup = * (int *) pmap;
		pmap += sizeof(int);
		pmap += cLexSup;
	}

    pTrieCtrl = TrieInit(pmap);
    if (pTrieCtrl)
	{
		// We were able to load and point to the Trie okay.
		//MessageBoxW(0,L"Was able to initialize Trie",L"ThWB",MB_OK);
		pTrieScan = new CTrieIter();
		pTrieScan->Init(this);
		ptec = ptecNoErrors;
	}
	else
	{
		// We were not able to initailize main lexicon.
	    ptec = retcode(ptecIOErrorMainLex, ptecInvalidMainLex);
	}

	return ptec;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   UnInitialize Trie.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTrie::UnInit()
{
	// Free up memory allocated by Trie.
	if (pTrieCtrl)
	{
		TrieFree(pTrieCtrl);
		pTrieCtrl = NULL;
	}

	// Close the map files.
//	if (pMapFile)
//	{
//        CloseMapFile(pMapFile);
//		pMapFile = NULL;
//	}
	if (pFileManager && pFileManager->Close())
	{
		m_pMap = NULL;
		delete pFileManager;
		pFileManager = NULL;
	}

	if (pTrieScan)
	{
		delete pTrieScan;
		pTrieScan = NULL;
	}

}


//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   searches for the given string in the trie
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CTrie::Find(const WCHAR* szWord, DWORD* pdwPOS)
{
	// Declare and initialize all local variables.
	int i = 0;

	if (pTrieScan == NULL)
		return FALSE;

	pTrieScan->Reset();

	if (!pTrieScan->Down())
		return FALSE;

	while (TRUE)
	{
		pTrieScan->GetNode();
		if (pTrieScan->wc == szWord[i])
		{
			i++;
			if (pTrieScan->fWordEnd && szWord[i] == '\0')
            {
                *pdwPOS = pTrieScan->posTag;
				return TRUE;
            }
			else if (szWord[i] == '\0') break;
			// Move down the Trie Branch.
			else if (!pTrieScan->Down()) break;
		}
		// Move right of the Trie Branch
		else if (!pTrieScan->Right()) break;
	}
    *pdwPOS = POS_UNKNOWN;
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\lexicon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Thai WordBreak
//
//  Thai WordBreak Interface Header File.
//
//  History:
//      created 5/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "lexheader.h"
#include "trie.h"
//#include "NLGlib.h"
#include "ProofBase.h"

class Lexicon
{
public:
	Lexicon(WCHAR* szFileName);
	~Lexicon();
protected:
	PMFILE pMapFile;
	TRIECTRL *pTrieCtrl;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\filemanager.h ===
//------------------------------------------------------------------------------------------
//	FileManager.h
//
//	Contain code for loading and writting files.
//
//  Created By: aarayas
//
//  History: 01/11/2001
//
//------------------------------------------------------------------------------------------
#ifndef _FILEMANAGER_H_
#define _FILEMANAGER_H_
#include <stdio.h>
#include <windows.h>

HANDLE CMN_CreateFileW(
	PCWSTR pwzFileName,							// pointer to name of the file
	DWORD dwDesiredAccess,						// access (read-write) mode
	DWORD dwShareMode,							// share mode
    LPSECURITY_ATTRIBUTES pSecurityAttributes,	// pointer to security descriptor
    DWORD dwCreationDistribution,				// how to create
    DWORD dwFlagsAndAttributes,					// file attributes
    HANDLE hTemplateFile);						// handle to file with attributes to copy

HANDLE CMN_CreateFileMapping(
	HANDLE hFile,                       // handle to file
	LPSECURITY_ATTRIBUTES lpAttributes, // security
	DWORD flProtect,                    // protection
	DWORD dwMaximumSizeHigh,            // high-order DWORD of size
	DWORD dwMaximumSizeLow,             // low-order DWORD of size
	LPCSTR lpName                      // object name
);

DWORD CMN_GetFileSize(
	HANDLE hFile,           // handle to file
	LPDWORD lpFileSizeHigh  // high-order word of file size
);

BOOL CMN_CloseHandle(
	HANDLE hObject   // handle to object
);

LPVOID CMN_MapViewOfFile(
	HANDLE hFileMappingObject,   // handle to file-mapping object
	DWORD dwDesiredAccess,       // access mode
	DWORD dwFileOffsetHigh,      // high-order DWORD of offset
	DWORD dwFileOffsetLow,       // low-order DWORD of offset
	SIZE_T dwNumberOfBytesToMap  // number of bytes to map
);

BOOL CMN_UnmapViewOfFile(
	LPCVOID lpBaseAddress   // starting address
);

FILE* CMN_FOpen( const WCHAR* filename, const WCHAR* mode );
#endif // _FILEMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\filemanager.cpp ===
//------------------------------------------------------------------------------------------
//	FileManager.cpp
//
//	Contain code for loading and writting files.
//
//  Created By: aarayas
//
//  History: 01/11/2001
//
//------------------------------------------------------------------------------------------
#include "FileManager.h"

//------------------------------------------------------------------------------------------
//	CMN_CreateFileW
//
//	create file 
//
//--------------------------------------------------------------------------- aarayas ------
HANDLE CMN_CreateFileW(
	PCWSTR pwzFileName,							// pointer to name of the file
	DWORD dwDesiredAccess,						// access (read-write) mode
	DWORD dwShareMode,							// share mode
    LPSECURITY_ATTRIBUTES pSecurityAttributes,	// pointer to security descriptor
    DWORD dwCreationDistribution,				// how to create
    DWORD dwFlagsAndAttributes,					// file attributes
    HANDLE hTemplateFile)						// handle to file with attributes to copy
{
	HANDLE hFile = NULL;
	hFile = CreateFileW(pwzFileName, dwDesiredAccess, dwShareMode, pSecurityAttributes,
						dwCreationDistribution,dwFlagsAndAttributes, hTemplateFile);
	return hFile;
}

//------------------------------------------------------------------------------------------
//	CMN_CreateFileMapping
//
//	create file mapping
//
//--------------------------------------------------------------------------- aarayas ------
HANDLE CMN_CreateFileMapping(
	HANDLE hFile,                       // handle to file
	LPSECURITY_ATTRIBUTES lpAttributes, // security
	DWORD flProtect,                    // protection
	DWORD dwMaximumSizeHigh,            // high-order DWORD of size
	DWORD dwMaximumSizeLow,             // low-order DWORD of size
	LPCSTR lpName                      // object name
)
{
#ifdef UNDER_CE
	return CreateFileMapping(hFile,lpAttributes,flProtect,dwMaximumSizeHigh,dwMaximumSizeLow,lpName);
#else
	return CreateFileMappingA(hFile,lpAttributes,flProtect,dwMaximumSizeHigh,dwMaximumSizeLow,lpName);
#endif
}

//------------------------------------------------------------------------------------------
//	CMN_GetFileSize
//
//	Get File Size.
//
//--------------------------------------------------------------------------- aarayas ------
DWORD CMN_GetFileSize(
	HANDLE hFile,           // handle to file
	LPDWORD lpFileSizeHigh  // high-order word of file size
)
{
	return GetFileSize(hFile,lpFileSizeHigh);
}

//------------------------------------------------------------------------------------------
//	CMN_CloseHandle
//
//	Close Handle
//
//--------------------------------------------------------------------------- aarayas ------
BOOL CMN_CloseHandle(
	HANDLE hObject   // handle to object
)
{
	return CloseHandle(hObject);
}

//------------------------------------------------------------------------------------------
//	CMN_MapViewOfFile
//
//	Map View Of File
//
//--------------------------------------------------------------------------- aarayas ------
LPVOID CMN_MapViewOfFile(
	HANDLE hFileMappingObject,   // handle to file-mapping object
	DWORD dwDesiredAccess,       // access mode
	DWORD dwFileOffsetHigh,      // high-order DWORD of offset
	DWORD dwFileOffsetLow,       // low-order DWORD of offset
	SIZE_T dwNumberOfBytesToMap  // number of bytes to map
)
{
	return MapViewOfFile(hFileMappingObject,dwDesiredAccess,dwFileOffsetHigh,dwFileOffsetLow,dwNumberOfBytesToMap);
}

//------------------------------------------------------------------------------------------
//	CMN_UnmapViewOfFile
//
//	Unmap View Of File
//
//--------------------------------------------------------------------------- aarayas ------
BOOL CMN_UnmapViewOfFile(
	LPCVOID lpBaseAddress   // starting address
)
{
	return UnmapViewOfFile(lpBaseAddress);
}

//------------------------------------------------------------------------------------------
//	CMN_FOpen
//
//	File open - wrapper for fopen
//
//--------------------------------------------------------------------------- aarayas ------
FILE* CMN_FOpen( const WCHAR* pwszFilename, const WCHAR* pwszMode )
{
#ifdef UNDER_CE
	return _wfopen(pwszFilename, pwszMode);
#else
	char* pszFileName = NULL;
	char* pszMode = NULL;
	unsigned int uiFilenameLen = (unsigned int)wcslen(pwszFilename)+1;
	unsigned int uiModeLen = (unsigned int)wcslen(pwszMode)+1;
	FILE* pfRetValue = NULL;

	pszFileName = new char[uiFilenameLen];
	pszMode = new char[uiModeLen];

	if (pszFileName && pszMode)
	{
		ZeroMemory(pszFileName,uiFilenameLen);
		ZeroMemory(pszMode,uiModeLen);

		// TODO: We shouldn't be using MultibyteToWideChar for WIN2K platform, 
		//       need to clean this up.
		WideCharToMultiByte(874,0,pwszFilename,uiFilenameLen,pszFileName,uiFilenameLen,NULL,NULL);
		WideCharToMultiByte(874,0,pwszMode,uiModeLen,pszMode,uiModeLen,NULL,NULL);

		pfRetValue = fopen(pszFileName,pszMode);

		delete pszFileName;
		delete pszMode;
	}

	return pfRetValue;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\listwordbreak.cpp ===
//------------------------------------------------------------------------------------------
//	ListPoint.cpp
//
//
//
//------------------------------------------------------------------------------------------

#include "listWordBreak.hpp"

//------------------------------------------------------------------------------------------
//	WordBreakElement::WordBreakElement
//
//	Initialize a WordBreak element.
//
//------------------------------------------------------------------------------------------
WordBreakElement::WordBreakElement(CTrie* pTrie, CTrie* pTrieTrigram)
{
	breakTree = NULL;
	fFree = false;
	breakTree = new CThaiBreakTree();
	if (breakTree)
	{
		breakTree->Init(pTrie, pTrieTrigram);
		fFree = true;
	}
	else
	{
		breakTree = NULL;
		assert(false);
	}
}


//------------------------------------------------------------------------------------------
//	WordBreakElement::~WordBreakElement
//
//	Destructor
//
//------------------------------------------------------------------------------------------
WordBreakElement::~WordBreakElement()
{
	if (breakTree != NULL)
	{
		delete breakTree;
		breakTree = NULL;
	}

	// The ThaiWordBreak should be free if all goes well.
	assert(fFree);
}


//------------------------------------------------------------------------------------------
//	ListWordBreak::ListWordBreak
//------------------------------------------------------------------------------------------
ListWordBreak::ListWordBreak()
{
	m_pTrie = NULL;
	m_pTrieTrigram = NULL;
#if defined (_DEBUG)
	fInit = false;
#endif
}

//------------------------------------------------------------------------------------------
//	ListWordBreak::Init
//------------------------------------------------------------------------------------------
bool ListWordBreak::Init(CTrie* pTrie,CTrie* pTrieTrigram)
{
	assert(pTrie != NULL);
	assert(pTrieTrigram != NULL);
	m_pTrie = pTrie;
	m_pTrieTrigram = pTrieTrigram;
#if defined (_DEBUG)
	fInit = true;
#endif
	return true;
}

//------------------------------------------------------------------------------------------
//	ListWordBreak::CreateWordBreak
//
//	Create a WordBeakElement and place it at the end of the list of the list
//------------------------------------------------------------------------------------------
bool ListWordBreak::CreateWordBreak()
{
#if defined (_DEBUG)
	assert(fInit);
#endif
	WordBreakElement* pWordBreakElement = NULL;
	pWordBreakElement = new WordBreakElement(m_pTrie,m_pTrieTrigram);
	if (pWordBreakElement)
	{
		Append((void*)pWordBreakElement);
		return true;
	}
	return false;
}

//------------------------------------------------------------------------------------------
//	ListWordBreak::GetNode
//
//	get data of the current node.
//------------------------------------------------------------------------------------------
bool ListWordBreak::GetNode(CThaiBreakTree* pThaiBreakTree, bool* pfFree)
{
#if defined (_DEBUG)
	assert(fInit);
#endif
	WordBreakElement* element = (WordBreakElement*)List::GetData();

	if (element == NULL)
		return false;

	
	pThaiBreakTree = element->breakTree;
	*pfFree = element->fFree;
	return true;
}

//------------------------------------------------------------------------------------------
//	ListWordBreak::Flush
//
//	delete everything in the list.
//------------------------------------------------------------------------------------------
void ListWordBreak::Flush()
{
#if defined (_DEBUG)
	assert(fInit);
#endif
	WordBreakElement* element = NULL;

	// delete all the list elements
    while (true)
	{
		element = (WordBreakElement*)List::Remove();
		if (element)
		{
//			assert(element->fFree);
			delete element;
		}
		else
		{
			break;
		}
	}
}

//------------------------------------------------------------------------------------------
//	ListWordBreak::GetFreeWB
//
//  fCreateNode - If list is full create new WordBreak.
//------------------------------------------------------------------------------------------
WordBreakElement* ListWordBreak::GetFreeWB(bool fCreateNode)
{
#if defined (_DEBUG)
	assert(fInit);
#endif
	// Declare local variables.
	WordBreakElement* element = NULL;

	// Move to beginning of the list.
	MoveFirst();

	while(true)
	{
		// Get current WordBreakElement.
		element = (WordBreakElement*)GetData();

		// Determine if the current WordBreakElement is free to be use.
		if (element && element->fFree)
		{
			return element;
		}

		// Move to Next Node.
		if (!MoveNext())
		{
			// Can we create a new WordBreak?
			if (fCreateNode && CreateWordBreak())
			{
				// Move to beggining of the list.
				MoveFirst();
			}
			else
			{
				// If unable to create new WordBreak drop out.
				break;
			}
		}
	}

	// Return NULL
	return NULL;
}

//------------------------------------------------------------------------------------------
//	ListWordBreak::MarkWordBreak
//
//  Input:
//    pWordBreakElement - pointer to a WordBreakElement.
//    fFree - true  = WordBreak is free to be used.
//          - false = WordBreak is in used.
//------------------------------------------------------------------------------------------
void ListWordBreak::MarkWordBreak(WordBreakElement* pWordBreakElement, bool fFree)
{
#if defined (_DEBUG)
	assert(fInit);
#endif
	pWordBreakElement->fFree = fFree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\lextable.hpp ===
//+---------------------------------------------------------------------------
//
//
//  Lextable.hpp
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _LEXTABLE_HPP_
#define _LEXTABLE_HPP_
#include <windows.h>

/*************************************************
    Lexical Table definition
*************************************************/
#define Lex_UpperFlag             0x01         /* upper case */
#define Lex_LowerFlag             0x02         /* lower case */
#define Lex_DigitFlag             0x04         /* decimal digits */
#define Lex_SpaceFlag             0x08         /* spacing characters */
#define Lex_PunctFlag             0x10         /* punctuation characters */
#define Lex_ControlFlag             0x20         /* control characters */
#define Lex_LexiconFlag 0x40
#define Lex_VowelFlag 0x80
#define NTRANSTAB 256

#define INUPPERPAGES(ch) (ch & 0xff00)  // this is the same as ch > 0x00ff

/*************************************************
    Lexical Table
*************************************************/
const BYTE rgFlags[NTRANSTAB] =
{
	0x00, // 00        
	0x20, // 01        
	0x20, // 02        
	0x20, // 03        
	0x20, // 04        
	0x20, // 05        
	0x20, // 06        
	0x20, // 07        
	0x20, // 08        
	0x28, // 09    X   
	0x28, // 0a    X   
	0x28, // 0b    X   
	0x28, // 0c    X   
	0x28, // 0d    X   
	0x20, // 0e        
	0x20, // 0f        
	0x20, // 10        
	0x20, // 11        
	0x20, // 12        
	0x20, // 13        
	0x20, // 14        
	0x20, // 15        
	0x20, // 16        
	0x20, // 17        
	0x20, // 18        
	0x20, // 19        
	0x20, // 1a        
	0x20, // 1b        
	0x20, // 1c        
	0x20, // 1d        
	0x20, // 1e        
	0x20, // 1f        
	0x08, // 20    X   
	0x10, // 21     P   (!)
	0x10, // 22     P   (")
	0x10, // 23     P   (#)
	0x10, // 24     P   ($)
	0x10, // 25     P   (%)
	0x10, // 26     P   (&)
	0x50, // 27     PE  (')
	0x10, // 28     P   (()
	0x10, // 29     P   ())
	0x10, // 2a     P   (*)
	0x10, // 2b     P   (+)
	0x10, // 2c     P   (,)
	0x50, // 2d     PE  (-)
	0x50, // 2e     PE  (.)
	0x50, // 2f     PE  (/)
	0x44, // 30   D  E  (0)
	0x44, // 31   D  E  (1)
	0x44, // 32   D  E  (2)
	0x44, // 33   D  E  (3)
	0x44, // 34   D  E  (4)
	0x44, // 35   D  E  (5)
	0x44, // 36   D  E  (6)
	0x44, // 37   D  E  (7)
	0x44, // 38   D  E  (8)
	0x44, // 39   D  E  (9)
	0x10, // 3a     P   (:)
	0x10, // 3b     P   (;)
	0x10, // 3c     P   (<)
	0x10, // 3d     P   (=)
	0x10, // 3e     P   (>)
	0x10, // 3f     P   (?)
	0x10, // 40     P   (@)
	0xc1, // 41 U    EV (A)
	0x41, // 42 U    E  (B)
	0x41, // 43 U    E  (C)
	0x41, // 44 U    E  (D)
	0xc1, // 45 U    EV (E)
	0x41, // 46 U    E  (F)
	0x41, // 47 U    E  (G)
	0x41, // 48 U    E  (H)
	0xc1, // 49 U    EV (I)
	0x41, // 4a U    E  (J)
	0x41, // 4b U    E  (K)
	0x41, // 4c U    E  (L)
	0x41, // 4d U    E  (M)
	0x41, // 4e U    E  (N)
	0xc1, // 4f U    EV (O)
	0x41, // 50 U    E  (P)
	0x41, // 51 U    E  (Q)
	0x41, // 52 U    E  (R)
	0x41, // 53 U    E  (S)
	0x41, // 54 U    E  (T)
	0xc1, // 55 U    EV (U)
	0x41, // 56 U    E  (V)
	0x41, // 57 U    E  (W)
	0x41, // 58 U    E  (X)
	0x41, // 59 U    E  (Y)
	0x41, // 5a U    E  (Z)
	0x10, // 5b     P   ([)
	0x10, // 5c     P   (\)
	0x10, // 5d     P   (])
	0x10, // 5e     P   (^)
	0x10, // 5f     P   (_)
	0x10, // 60     P   (`)
	0xc2, // 61  L   EV (a)
	0x42, // 62  L   E  (b)
	0x42, // 63  L   E  (c)
	0x42, // 64  L   E  (d)
	0xc2, // 65  L   EV (e)
	0x42, // 66  L   E  (f)
	0x42, // 67  L   E  (g)
	0x42, // 68  L   E  (h)
	0xc2, // 69  L   EV (i)
	0x42, // 6a  L   E  (j)
	0x42, // 6b  L   E  (k)
	0x42, // 6c  L   E  (l)
	0x42, // 6d  L   E  (m)
	0x42, // 6e  L   E  (n)
	0xc2, // 6f  L   EV (o)
	0x42, // 70  L   E  (p)
	0x42, // 71  L   E  (q)
	0x42, // 72  L   E  (r)
	0x42, // 73  L   E  (s)
	0x42, // 74  L   E  (t)
	0xc2, // 75  L   EV (u)
	0x42, // 76  L   E  (v)
	0x42, // 77  L   E  (w)
	0x42, // 78  L   E  (x)
	0x42, // 79  L   E  (y)
	0x42, // 7a  L   E  (z)
	0x10, // 7b     P   ({)
	0x10, // 7c     P   (|)
	0x10, // 7d     P   (})
	0x10, // 7e     P   (~)
	0x20, // 7f         ()
	0x10, // 80     P   ()
	0x20, // 81         ()
	0x20, // 82         ()
	0x20, // 83         ()
	0x20, // 84         ()
	0x20, // 85         ()
	0x20, // 86         ()
	0x20, // 87         ()
	0x20, // 88         ()
	0x20, // 89         ()
	0x20, // 8a         ()
	0x20, // 8b         ()
	0x20, // 8c         ()
	0x20, // 8d         ()
	0x20, // 8e         ()
	0x20, // 8f         ()
	0x20, // 90         ()
	0x20, // 91         ()
	0x20, // 92         ()
	0x20, // 93         ()
	0x20, // 94         ()
	0x20, // 95         ()
	0x20, // 96         ()
	0x20, // 97         ()
	0x20, // 98         ()
	0x20, // 99         ()
	0x20, // 9a         ()
	0x20, // 9b         ()
	0x20, // 9c         ()
	0x20, // 9d         ()
	0x20, // 9e         ()
	0x20, // 9f         ()
	0x08, // a0    X    ()
	0x10, // a1     P   ()
	0x10, // a2     P   ()
	0x10, // a3     P   ()
	0x10, // a4     P   ()
	0x10, // a5     P   ()
	0x10, // a6     P   ()
	0x10, // a7     P   ()
	0x10, // a8     P   ()
	0x10, // a9     P   ()
	0x10, // aa     P   ()
	0x10, // ab     P   ()
	0x10, // ac     P   ()
	0x10, // ad     P   ()
	0x10, // ae     P   ()
	0x10, // af     P   ()
	0x10, // b0     P   ()
	0x10, // b1     P   ()
	0x54, // b2   D PE  ()
	0x54, // b3   D PE  ()
	0x10, // b4     P   ()
	0x10, // b5     P   ()
	0x10, // b6     P   ()
	0x10, // b7     P   ()
	0x10, // b8     P   ()
	0x54, // b9   D PE  ()
	0x10, // ba     P   ()
	0x10, // bb     P   ()
	0x54, // bc   D PE  ()
	0x54, // bd   D PE  ()
	0x54, // be   D PE  ()
	0x10, // bf     P   ()
	0xc1, // c0 U    EV ()
	0xc1, // c1 U    EV ()
	0xc1, // c2 U    EV ()
	0xc1, // c3 U    EV ()
	0xc1, // c4 U    EV ()
	0xc1, // c5 U    EV ()
	0x41, // c6 U    E  ()
	0x41, // c7 U    E  ()
	0xc1, // c8 U    EV ()
	0xc1, // c9 U    EV ()
	0xc1, // ca U    EV ()
	0xc1, // cb U    EV ()
	0xc1, // cc U    EV ()
	0xc1, // cd U    EV ()
	0xc1, // ce U    EV ()
	0xc1, // cf U    EV ()
	0x41, // d0 U    E  ()
	0x41, // d1 U    E  ()
	0xc1, // d2 U    EV ()
	0xc1, // d3 U    EV ()
	0xc1, // d4 U    EV ()
	0xc1, // d5 U    EV ()
	0xc1, // d6 U    EV ()
	0x10, // d7     P   ()
	0xc1, // d8 U    EV ()
	0xc1, // d9 U    EV ()
	0xc1, // da U    EV ()
	0xc1, // db U    EV ()
	0xc1, // dc U    EV ()
	0x41, // dd U    E  ()
	0x41, // de U    E  ()
	0x42, // df  L   E  ()
	0xc2, // e0  L   EV ()
	0xc2, // e1  L   EV ()
	0xc2, // e2  L   EV ()
	0xc2, // e3  L   EV ()
	0xc2, // e4  L   EV ()
	0xc2, // e5  L   EV ()
	0x42, // e6  L   E  ()
	0x42, // e7  L   E  ()
	0xc2, // e8  L   EV ()
	0xc2, // e9  L   EV ()
	0xc2, // ea  L   EV ()
	0xc2, // eb  L   EV ()
	0xc2, // ec  L   EV ()
	0xc2, // ed  L   EV ()
	0xc2, // ee  L   EV ()
	0xc2, // ef  L   EV ()
	0x42, // f0  L   E  ()
	0x42, // f1  L   E  ()
	0xc2, // f2  L   EV ()
	0xc2, // f3  L   EV ()
	0xc2, // f4  L   EV ()
	0xc2, // f5  L   EV ()
	0xc2, // f6  L   EV ()
	0x10, // f7     P   ()
	0xc2, // f8  L   EV ()
	0xc2, // f9  L   EV ()
	0xc2, // fa  L   EV ()
	0xc2, // fb  L   EV ()
	0xc2, // fc  L   EV ()
	0x42, // fd  L   E  ()
	0x42, // fe  L   E  ()
	0x42, // ff  L   E  ()
};

const BYTE rgPunctFlags[NTRANSTAB] =
{
	0x00, // 00     
	0x00, // 01     
	0x00, // 02     
	0x00, // 03     
	0x00, // 04     
	0x00, // 05     
	0x00, // 06     
	0x00, // 07     
	0x00, // 08     
	0x08, // 09    W
	0x08, // 0a    W
	0x08, // 0b    W
	0x08, // 0c    W
	0x08, // 0d    W
	0x00, // 0e     
	0x00, // 0f     
	0x00, // 10     
	0x00, // 11     
	0x00, // 12     
	0x00, // 13     
	0x00, // 14     
	0x00, // 15     
	0x00, // 16     
	0x00, // 17     
	0x00, // 18     
	0x00, // 19     
	0x00, // 1a     
	0x00, // 1b     
	0x00, // 1c     
	0x00, // 1d     
	0x00, // 1e     
	0x00, // 1f     
	0x08, // 20    W
	0x04, // 21   T  (!)
	0x05, // 22 L T  (")
	0x01, // 23 L    (#)
	0x01, // 24 L    ($)
	0x04, // 25   T  (%)
	0x00, // 26      (&)
	0x05, // 27 L T  (')
	0x01, // 28 L    (()
	0x04, // 29   T  ())
	0x08, // 2a    W (*)
	0x00, // 2b      (+)
	0x04, // 2c   T  (,)
	0x02, // 2d  J   (-)
	0x04, // 2e   T  (.)
	0x02, // 2f  J   (/)
	0x00, // 30      (0)
	0x00, // 31      (1)
	0x00, // 32      (2)
	0x00, // 33      (3)
	0x00, // 34      (4)
	0x00, // 35      (5)
	0x00, // 36      (6)
	0x00, // 37      (7)
	0x00, // 38      (8)
	0x00, // 39      (9)
	0x04, // 3a   T  (:)
	0x04, // 3b   T  (;)
	0x09, // 3c L  W (<)
	0x08, // 3d    W (=)
	0x0c, // 3e   TW (>)
	0x04, // 3f   T  (?)
	0x02, // 40  J   (@)
	0x00, // 41      (A)
	0x00, // 42      (B)
	0x00, // 43      (C)
	0x00, // 44      (D)
	0x00, // 45      (E)
	0x00, // 46      (F)
	0x00, // 47      (G)
	0x00, // 48      (H)
	0x00, // 49      (I)
	0x00, // 4a      (J)
	0x00, // 4b      (K)
	0x00, // 4c      (L)
	0x00, // 4d      (M)
	0x00, // 4e      (N)
	0x00, // 4f      (O)
	0x00, // 50      (P)
	0x00, // 51      (Q)
	0x00, // 52      (R)
	0x00, // 53      (S)
	0x00, // 54      (T)
	0x00, // 55      (U)
	0x00, // 56      (V)
	0x00, // 57      (W)
	0x00, // 58      (X)
	0x00, // 59      (Y)
	0x00, // 5a      (Z)
	0x01, // 5b L    ([)
	0x02, // 5c  J   (\)
	0x04, // 5d   T  (])
	0x00, // 5e      (^)
	0x00, // 5f      (_)
	0x00, // 60      (`)
	0x00, // 61      (a)
	0x00, // 62      (b)
	0x00, // 63      (c)
	0x00, // 64      (d)
	0x00, // 65      (e)
	0x00, // 66      (f)
	0x00, // 67      (g)
	0x00, // 68      (h)
	0x00, // 69      (i)
	0x00, // 6a      (j)
	0x00, // 6b      (k)
	0x00, // 6c      (l)
	0x00, // 6d      (m)
	0x00, // 6e      (n)
	0x00, // 6f      (o)
	0x00, // 70      (p)
	0x00, // 71      (q)
	0x00, // 72      (r)
	0x00, // 73      (s)
	0x00, // 74      (t)
	0x00, // 75      (u)
	0x00, // 76      (v)
	0x00, // 77      (w)
	0x00, // 78      (x)
	0x00, // 79      (y)
	0x00, // 7a      (z)
	0x01, // 7b L    ({)
	0x00, // 7c      (|)
	0x04, // 7d   T  (})
	0x00, // 7e      (~)
	0x00, // 7f      ()
	0x01, // 80 L    ()
	0x00, // 81      ()
	0x00, // 82      ()
	0x00, // 83      ()
	0x00, // 84      ()
	0x00, // 85      ()
	0x00, // 86      ()
	0x00, // 87      ()
	0x00, // 88      ()
	0x00, // 89      ()
	0x00, // 8a      ()
	0x00, // 8b      ()
	0x00, // 8c      ()
	0x00, // 8d      ()
	0x00, // 8e      ()
	0x00, // 8f      ()
	0x00, // 90      ()
	0x00, // 91      ()
	0x00, // 92      ()
	0x00, // 93      ()
	0x00, // 94      ()
	0x00, // 95      ()
	0x00, // 96      ()
	0x00, // 97      ()
	0x00, // 98      ()
	0x00, // 99      ()
	0x00, // 9a      ()
	0x00, // 9b      ()
	0x00, // 9c      ()
	0x00, // 9d      ()
	0x00, // 9e      ()
	0x00, // 9f      ()
	0x08, // a0    W ()
	0x00, // a1      ()
	0x00, // a2      ()
	0x00, // a3      ()
	0x00, // a4      ()
	0x00, // a5      ()
	0x00, // a6      ()
	0x00, // a7      ()
	0x00, // a8      ()
	0x00, // a9      ()
	0x00, // aa      ()
	0x00, // ab      ()
	0x00, // ac      ()
	0x00, // ad      ()
	0x00, // ae      ()
	0x00, // af      ()
	0x00, // b0      ()
	0x00, // b1      ()
	0x00, // b2      ()
	0x00, // b3      ()
	0x00, // b4      ()
	0x00, // b5      ()
	0x00, // b6      ()
	0x00, // b7      ()
	0x00, // b8      ()
	0x00, // b9      ()
	0x00, // ba      ()
	0x00, // bb      ()
	0x00, // bc      ()
	0x00, // bd      ()
	0x00, // be      ()
	0x00, // bf      ()
	0x00, // c0      ()
	0x00, // c1      ()
	0x00, // c2      ()
	0x00, // c3      ()
	0x00, // c4      ()
	0x00, // c5      ()
	0x00, // c6      ()
	0x00, // c7      ()
	0x00, // c8      ()
	0x00, // c9      ()
	0x00, // ca      ()
	0x00, // cb      ()
	0x00, // cc      ()
	0x00, // cd      ()
	0x00, // ce      ()
	0x00, // cf      ()
	0x00, // d0      ()
	0x00, // d1      ()
	0x00, // d2      ()
	0x00, // d3      ()
	0x00, // d4      ()
	0x00, // d5      ()
	0x00, // d6      ()
	0x00, // d7      ()
	0x00, // d8      ()
	0x00, // d9      ()
	0x00, // da      ()
	0x00, // db      ()
	0x00, // dc      ()
	0x00, // dd      ()
	0x00, // de      ()
	0x00, // df      ()
	0x00, // e0      ()
	0x00, // e1      ()
	0x00, // e2      ()
	0x00, // e3      ()
	0x00, // e4      ()
	0x00, // e5      ()
	0x00, // e6      ()
	0x00, // e7      ()
	0x00, // e8      ()
	0x00, // e9      ()
	0x00, // ea      ()
	0x00, // eb      ()
	0x00, // ec      ()
	0x00, // ed      ()
	0x00, // ee      ()
	0x00, // ef      ()
	0x00, // f0      ()
	0x00, // f1      ()
	0x00, // f2      ()
	0x00, // f3      ()
	0x00, // f4      ()
	0x00, // f5      ()
	0x00, // f6      ()
	0x00, // f7      ()
	0x00, // f8      ()
	0x00, // f9      ()
	0x00, // fa      ()
	0x00, // fb      ()
	0x00, // fc      ()
	0x00, // fd      ()
	0x00, // fe      ()
	0x00, // ff      ()
};

/*************************************************
    Functions definition - define lextable.cpp
*************************************************/
BOOL IsUpperPunctW(const WCHAR ch);
BOOL IsUpperWordDelimW(WCHAR wc);
BOOL TWB_IsCharPunctW(WCHAR ch);
BOOL TWB_IsCharWordDelimW(WCHAR ch);
bool IsThaiChar(const WCHAR ch);
bool IsThaiNumeric(const WCHAR ch);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\lextable.cpp ===
//+---------------------------------------------------------------------------
//
//
//  Lextable.hpp
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "lextable.hpp"

//+---------------------------------------------------------------------------
//
//  Function:   IsUpperPunctW
//
//  Synopsis:   Returns true if wc is a punctuation character in the upper
//              unicode range
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsUpperPunctW(const WCHAR wc)
{
    BOOL fRet = FALSE;

    if ((wc & 0xff00) == 0x2000)  // is Unicode punctuation
    {
        fRet = TRUE;
    }
    else
    {
        switch(wc)
        {
        case 0x01C3:     // Yet another latin exclamation mark
        case 0x037E:     // Greek question mark
        case 0x03D7:     // greek question mark
        case 0x055C:     // Armenian exclamation mark
        case 0x055E:     // Armenian question mark
        case 0x0589:     // armenian period
        case 0x061F:     // Arabic question mark
        case 0x06d4:     // arabic period
        case 0x2026:     // horizontal ellipsis
        case 0x2029:     // paragraph separator
        case 0x203C:     // Double eclamation mark
        case 0x2762:     // Heavy exclamation mark
        case 0x3002:     // ideographic period
        case 0xFE52:     // small period
        case 0xFE56:     // Small question mark
        case 0xFE57:     // Small exclamation mark
        case 0xFF01:     // Fullwidth exclamation mark
        case 0xFF0E:     // fullwidth period
        case 0xFF1F:     // Fullwidth question mark
        case 0xFF61:     // halfwidth ideographic period
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsUpperWordDelimW
//
//  Synopsis:   figures out whether an upper unicode char is a word delimiter
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsUpperWordDelimW(WCHAR wc)
{
    return (wc & 0xfff0) == 0x2000 ||
        wc == 0x2026 || // ellipsis
        wc == 0x2013 || // en dash
        wc == 0x2014;   // em dash
}

//+---------------------------------------------------------------------------
//
//  Function:   TWB_IsCharPunctW
//
//  Synopsis:   figures out whether charater is a punctuation
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL TWB_IsCharPunctW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? IsUpperPunctW(ch) : rgFlags[(UCHAR) ch] & Lex_PunctFlag;
}

//+---------------------------------------------------------------------------
//
//  Function:   TWB_IsCharPunctW
//
//  Synopsis:   figures out whether charater is a word delimiter
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL TWB_IsCharWordDelimW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? IsUpperWordDelimW(ch) : rgPunctFlags[(UCHAR) ch] & Lex_SpaceFlag;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiChar
//
//  Synopsis:   determine if the character is a Thai character
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:      13/12/99 - take out Thai numbers as Thai Characters since
//                         we want to consider them like english numbers.
//
//----------------------------------------------------------------------------
bool IsThaiChar(const WCHAR wch)
{
	return ( wch >= 0x0e01 && wch <= 0x0e59);
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiNumeric
//
//  Synopsis:   determine if the character is a Thai character
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 5/00 aarayas
//
//----------------------------------------------------------------------------
bool IsThaiNumeric(const WCHAR wch)
{
	return ( wch >= 0x0e50 && wch <= 0x0e59);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\list.cpp ===
//------------------------------------------------------------------------------------------
//      list.cpp
//
//      Routines to manage a singly-linked list of "things".
//
//      A "ListElement" is allocated for each item to be put on the list; it is de-allocated
//      when the item is removed. This means we don't need to keep a "next" pointer in every
//      object we want to put on a list.
// 
//      NOTE: Mutual exclusion must be provided by the caller.  If you want a synchronized
//      list, you must use the routines in synchlist.cc.
//
//------------------------------------------------------------------------------------------

#include "list.hpp"

//------------------------------------------------------------------------------------------
//      ListElement::ListElement
//
//      Initialize a list element, so it can be added somewhere on a list.
//
//      "itemPtr" is the item to be put on the list.  It can be a pointer to anything.
//      "sortKey" is the priority of the item, if any.
//------------------------------------------------------------------------------------------
ListElement::ListElement(void *itemPtr, int sortKey)
{
        item = itemPtr;
        key = sortKey;
        next = NULL;    // assume we'll put it at the end of the list 
        previous = NULL;
}

//------------------------------------------------------------------------------------------
//      List::List
//
//      Initialize a list, empty to start with.
//
//      Elements can now be added to the list.
//------------------------------------------------------------------------------------------
List::List()
{ 
        first = last = iterator = NULL;
        length = 0;
}

//------------------------------------------------------------------------------------------
//      List::~List
//
//      Prepare a list for deallocation.  If the list still contains any ListElements,
//      de-allocate them.  However, note that we do *not* de-allocate the "items" on the
//      list -- this module allocates and de-allocates the ListElements to keep track of
//      each item, but a given item may be on multiple lists, so we can't de-allocate them here.
//------------------------------------------------------------------------------------------
List::~List()
{ 
        Flush();
}

//------------------------------------------------------------------------------------------
//      List::Append
//
//      Append an "item" to the end of the list.
//
//      Allocate a ListElement to keep track of the item. If the list is empty, then this will
//      be the only element.  Otherwise, put it at the end.
//
//      "item" is the thing to put on the list, it can be a pointer to anything.
//------------------------------------------------------------------------------------------
void List::Append(void *item)
{
        ListElement *element = new ListElement(item, 0);

        if (IsEmpty())
        {
                // list is empty
                first = element;
                last = element;
    }
        else
        {
                // else put it after last
                last->next = element;
                element->previous = last;
                last = element;
    }
    length++;
}

//------------------------------------------------------------------------------------------
//      List::Prepend
//
//      Put an "item" on the front of the list.
//      
//      Allocate a ListElement to keep track of the item. If the list is empty, then this will
//      be the only element.  Otherwise, put it at the beginning.
//
//      "item" is the thing to put on the list, it can be a pointer to anything.
//------------------------------------------------------------------------------------------
void List::Prepend(void *item)
{
    ListElement *element = new ListElement(item, 0);

    if (IsEmpty())
        {
                // list is empty
                first = element;
                last = element;
    }
        else
        {
                // else put it before first
                element->next = first;
                first->previous = element;
                first = element;
    }
    length++;
}

//------------------------------------------------------------------------------------------
//      List::Remove
//
//      Remove the first "item" from the front of the list.
//
//      Returns:
//
//      Pointer to removed item, NULL if nothing on the list.
//------------------------------------------------------------------------------------------
void* List::Remove()
{
        // Same as SortedRemove, but ignore the key
        return SortedRemove(NULL);
}

//------------------------------------------------------------------------------------------
//      List::Flush
//
//      Remove everything from the list.
//
//------------------------------------------------------------------------------------------
void List::Flush()
{
    while (Remove() != NULL)
                ;        // delete all the list elements
}


//------------------------------------------------------------------------------------------
//      List::Mapcar
//
//      Apply a function to each item on the list, by walking through  
//      the list, one element at a time.
//
//      "func" is the procedure to apply to each element of the list.
//------------------------------------------------------------------------------------------
void List::Mapcar(VoidFunctionPtr func)
{
    for (ListElement *ptr = first; ptr != NULL; ptr = ptr->next)
    {
            (*func)( ptr->item );
    }
}

//------------------------------------------------------------------------------------------
//      List::IsEmpty
//
//      Returns TRUE if the list is empty (has no items).
//------------------------------------------------------------------------------------------
bool List::IsEmpty() 
{
        return (first == NULL);
}

//------------------------------------------------------------------------------------------
//      List::MoveFirst
//
//      move to the first node in the list.
//
//------------------------------------------------------------------------------------------
void List::MoveFirst()
{
        iterator = first;
}

//------------------------------------------------------------------------------------------
//      List::MoveNext
//
//      move to the next state of the list.
//
//------------------------------------------------------------------------------------------
bool List::MoveNext()
{
        if (iterator == NULL || iterator->next == NULL)
        {
                return false;
        }

        iterator = iterator->next;
        return true;
}

//------------------------------------------------------------------------------------------
//      List::GetData
//
//      get data of the current iterator.
//
//------------------------------------------------------------------------------------------
void* List::GetData()
{
        // make sure iterator is set.
        if (iterator == NULL)
                return NULL;

        // return the data.
    return iterator->item;
}


//------------------------------------------------------------------------------------------
//      List::SortedInsert
//
//      Insert an "item" into a list, so that the list elements are sorted in increasing order
//      by "sortKey".
//      
//      Allocate a ListElement to keep track of the item. If the list is empty, then this will
//      be the only element. Otherwise, walk through the list, one element at a time, to find
//      where the new item should be placed.
//
//      "item" is the thing to put on the list, it can be a pointer to anything.
//      "sortKey" is the priority of the item.
//------------------------------------------------------------------------------------------
void List::SortedInsert(void *item, int sortKey)
{
    ListElement *element = new ListElement(item, sortKey);
    ListElement *ptr;           // keep track

    if (IsEmpty())
        {
                // if list is empty, put
        first = element;
        last = element;
    }
        else if (sortKey < first->key)
        {       
                // item goes on front of list
                element->next = first;
                first->previous = element;
                first = element;
    }
        else
        {
                // look for first elt in list bigger than item
        for (ptr = first; ptr->next != NULL; ptr = ptr->next)
                {
            if (sortKey < ptr->next->key)
                        {
                                element->next = ptr->next;
                                element->previous = ptr;
                                ptr->next->previous = element;
                                ptr->next = element;
                                return;
                        }
                }

                // item goes at end of list
                last->next = element;
                element->previous = last;
                last = element;
    }
    length++;
}

//------------------------------------------------------------------------------------------
//      List::SortedRemove
//
//      Remove the first "item" from the front of a sorted list.
// 
//      Returns:
//
//      Pointer to removed item, NULL if nothing on the list. Sets *keyPtr to the priority value
//  of the removed item (this is needed by interrupt.cc, for instance).
//
//      "keyPtr" is a pointer to the location in which to store the priority of the removed item
//------------------------------------------------------------------------------------------
void* List::SortedRemove(int *keyPtr)
{
    ListElement *element = first;
    void *thing;

        // if empty nothing to remove just return.
    if (IsEmpty()) 
        {
                return NULL;
        }

    thing = first->item;
    if (first == last)
        {
                // list had one item, now has none 
        first = NULL;
                last = NULL;
    }
        else
        {
                first = element->next;
                if (first != NULL)
                {
                        first->previous = NULL;
                }
        }

    if (keyPtr != NULL)
        {
        *keyPtr = element->key;
        }
    delete element;
    length--;
    return thing;
}

//------------------------------------------------------------------------------------------
//      List::insertAfter
//
//      insert a new item after this one
//------------------------------------------------------------------------------------------
void List::insertAfter(ListElement * listEl, void *item)   
{
    ListElement *newElement = new ListElement(item, 0);
    newElement->next = listEl->next;
    newElement->previous = listEl;
    listEl->next = newElement;

    if (last == listEl)
        {
                last = newElement;
        }

    length++;
}

//------------------------------------------------------------------------------------------
//      List::insertBefore
//
//      insert a new item before this one
//------------------------------------------------------------------------------------------
void List::insertBefore(ListElement * listEl, void *item)   
{
    ListElement *newElement = new ListElement(item, 0);
    newElement->next = listEl;
    newElement->previous = listEl->previous;
    listEl->previous = newElement;

    if (first == listEl)
        {
                first = newElement;
        }

    length++;
}


//------------------------------------------------------------------------------------------
//      List::removeAt
//
//      removes listEl from the list. Do not delete it from memory
//------------------------------------------------------------------------------------------
void List::removeAt(ListElement * listEl)   
{
    if(first != listEl)
        {
                (listEl->previous)->next = listEl->next;
        }
    else 
        {
                first = listEl->next;
        }

    if(last != listEl)
        {
                (listEl->next)->previous = listEl->previous;
        }
    else 
        {
                last = listEl->previous;
        }
    length --;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\list.hpp ===
//------------------------------------------------------------------------------------------
//      list.hpp
//
//      Data structures to manage link lists.  
//
//  A list can contain any type of data structure as an item on the list: thread control
//      blocks, pending interrupts, etc.  That is why each item is a "void *", or in other words,
//      a "pointers to anything".
//------------------------------------------------------------------------------------------

#ifndef LIST_HPP
#define LIST_HPP

#include <stddef.h>
#include "unidef.h"
//------------------------------------------------------------------------------------------
//      This declares the type "VoidFunctionPtr" to be a "pointer to a function taking an
//      integer argument and returning nothing".  With such a function pointer
//      (say it is "func"), we can call it like this:
//
//      (*func) (17);
//
//      Used by MapCar in list.h 
//------------------------------------------------------------------------------------------
typedef void (*VoidFunctionPtr)(void * arg); 

//------------------------------------------------------------------------------------------
//      The following class defines a list element -- which is used to keep track of one item
//      on a list.
//
//      Internal data structures kept public so that List operations can access them directly.
//------------------------------------------------------------------------------------------
class ListElement
{
public:
        ListElement(void *itemPtr, int sortKey);        // initialize a list element
        ListElement *next;                                                      // next element on list, 
                                                                                                // NULL if this is the last
        ListElement *previous;                                          // previous element on the list
                                                                    // NULL if this is the first element

        int key;                                                                        // priority, for a sorted list
        void *item;                                                                     // pointer to item on the list
protected:
        ListElement();
};

//------------------------------------------------------------------------------------------
// The following class defines a "list" -- a singly linked list of
// list elements, each of which points to a single item on the list.
//
// By using the "Sorted" functions, the list can be kept in sorted
// in increasing order by "key" in ListElement.
//------------------------------------------------------------------------------------------
class List
{
public:
        List();                                                                         // initialize the list
    ~List();                                                                    // de-allocate the list

    void  Prepend(void *item);                                  // Put item at the beginning of the list
    void  Append(void *item);                                   // Put item at the end of the list
    void* Remove();                                                             // Take item off the front of the list
        virtual void  Flush();                              // Remove everything in the list

    void  Mapcar(VoidFunctionPtr func);                 // Apply "func" to every element on the list
    bool  IsEmpty();                                                    // is the list empty? 
    void  insertAfter(ListElement * listEl, void *item);
    void  insertBefore(ListElement  * listEl, void *item);
    void  removeAt(ListElement * listEl);
  
    // Routines to put/get items on/off list in order (sorted by key)
    void  SortedInsert(void *item, int sortKey);// Put item into list
    void* SortedRemove(int *keyPtr);                    // Remove first item from list

        int length;                                                                     // Length of list
    ListElement *first;                                                 // Head of the list, NULL if list is empty
    ListElement *last;                                                  // Last element of list

        // Interator function.
        virtual void MoveFirst();
        virtual bool MoveNext();
        void* GetData();
        ListElement *iterator;
};

#endif // LIST_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\mapio.c ===
/*+---------------------------------------------------------------------------
//
//  mapio.c - mapped file i/o routines
//
//  History:
//      9/4/97 DougP    Create this header
                        allow and deal with input map files of zero length
	11/20/97	DougP	Move these routines from misc.c to here
						Add option to spec codepage
//
//  1997 Microsoft Corporation
//----------------------------------------------------------------------------*/
#include <windows.h>
#include <assert.h>
#include "NLGlib.h"

//#ifdef WINCE
void Assert(x)
{
	if (x)
		MessageBox(0,"assert","assert",MB_OK);
}
//#endif

BOOL WINAPI CloseMapFile(PMFILE pmf)
{
    if (pmf==NULL) {
        return FALSE;
    }

      // only unmap what existed - DougP
    if (pmf->pvMap && !UnmapViewOfFile(pmf->pvMap)) {
       return FALSE;
    }

      // ditto
    if (pmf->hFileMap && !CloseHandle(pmf->hFileMap)) {
        return FALSE;
    }

    if (!CloseHandle(pmf->hFile)) {
        return FALSE;
    }

    NLGFreeMemory(pmf);

    return TRUE;
}

PMFILE WINAPI OpenMapFileWorker(const WCHAR * pwszFileName,BOOL fDstUnicode)
{
    PMFILE pmf;
    const WCHAR * pwszExt;

    if (!fNLGNewMemory(&pmf, sizeof(MFILE)))
    {
        goto Error;
    }

    pmf->fDstUnicode = fDstUnicode;

#ifdef WINCE
    pmf->hFile = CreateFileForMapping(
#else
    pmf->hFile = CMN_CreateFileW(
#endif
	 pwszFileName, GENERIC_READ, FILE_SHARE_READ,
	 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (pmf->hFile == INVALID_HANDLE_VALUE)
    {
        goto Error;
    }

    pmf->cbSize1 = GetFileSize(pmf->hFile, &pmf->cbSize2);
    if (pmf->cbSize1 == 0xFFFFFFFF)
    {
        CMN_OutputSystemErrW(L"Can't get size for", pwszFileName);
        CloseHandle(pmf->hFile);
        goto Error;
    }
    else if (pmf->cbSize1 == 0)
    {
          // can't map a zero length file so mark this appropriately
        pmf->hFileMap = 0;
        pmf->pvMap = 0;
        pmf->fSrcUnicode    = TRUE;
    }
    else
    {
#ifdef	WINCE
	pmf->hFileMap = CreateFileMapping(pmf->hFile, NULL, PAGE_READONLY, 0, 0, NULL);
#else
	pmf->hFileMap = CreateFileMappingA(pmf->hFile, NULL, PAGE_READONLY, 0, 0, NULL);
#endif
        if (pmf->hFileMap == NULL)
        {
            CMN_OutputSystemErrW(L"Can't Map", pwszFileName);
            CloseHandle(pmf->hFile);
            goto Error;
        }

        // Map the entire file starting at the first byte
        //
        pmf->pvMap = MapViewOfFile(pmf->hFileMap, FILE_MAP_READ, 0, 0, 0);
        if (pmf->pvMap == NULL)
        {
            CloseHandle(pmf->hFileMap);
            CloseHandle(pmf->hFile);
            goto Error;
        }

        // HACK:  Since IsTextUnicode returns false for sorted stem files, preset
        // unicode status here based on utf file extension
        pwszExt = pwszFileName;
        while (*pwszExt && *pwszExt != L'.' ) pwszExt++;

        if (*pwszExt && !wcscmp(pwszExt, L".utf"))
        {
            pmf->fSrcUnicode = TRUE;
        }
        else if (pmf->cbSize1 >= 2 && *(WORD *)pmf->pvMap == 0xFEFF)
        {
            // Safe to assume that anything starting with a BOM is Unicode
            pmf->fSrcUnicode = TRUE;
        }
        else
	{
#ifdef	WINCE
	    pmf->fSrcUnicode = TRUE;
#else
	    pmf->fSrcUnicode = IsTextUnicode(pmf->pvMap, pmf->cbSize1, NULL);
#endif
        }

        if (pmf->fSrcUnicode)
        {
            pmf->pwsz = (WCHAR *)pmf->pvMap;
        }
        else
        {
            pmf->psz = (PSTR)pmf->pvMap;
        }
    }

	pmf->uCodePage = CP_ACP;	// DWP - use default unless client specifies otherwise
    return pmf;

Error:
    if (pmf)
    {
        NLGFreeMemory(pmf);
    }
    return NULL;
}

#ifndef WINCE
PMFILE WINAPI OpenMapFileA(const char * pszFileName)
{
    WCHAR * pwszFileName;
    DWORD cchFileNameLen;
    int iRet;

    cchFileNameLen = lstrlenA(pszFileName) + 1;
    if (!fNLGNewMemory(&pwszFileName, cchFileNameLen * sizeof(WCHAR)))
    {
        return NULL;
    }

    iRet = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszFileName, -1,
        pwszFileName, cchFileNameLen);
    if (iRet ==0)
    {
        NLGFreeMemory(pwszFileName);
        return NULL;
    }

    return (OpenMapFileWorker(pwszFileName, FALSE));
}

#endif

BOOL WINAPI ResetMap(PMFILE pmf)
{
    if (pmf == NULL) {
        return FALSE;
    }

    if (pmf->fSrcUnicode) {
        pmf->pwsz = (WCHAR*)pmf->pvMap;
        if (*pmf->pwsz == 0xFEFF) {
            pmf->pwsz++;
        }
    } else {
        pmf->psz = (CHAR*)pmf->pvMap;
    }

    return TRUE;
}

// Same side effect as GetMapLine (incrememnt map pointer) but without returning contents
// in buffer.  This is useful in situations where the line may be longer than the max  cch and
// when the buffer isn't actually needed (counting lines, etc.)
//
BOOL WINAPI NextMapLine(PMFILE pmf)
{
    DWORD cbOffset;

    if (!pmf || !pmf->hFileMap) // check for zero length file
        return FALSE;

    if (pmf->fSrcUnicode)
    {
        WCHAR wch;
        cbOffset = (DWORD) ((PBYTE)pmf->pwsz - (PBYTE)pmf->pvMap);

        // test for EOF
        Assert (cbOffset <= pmf->cbSize1);
        if (cbOffset == pmf->cbSize1)
            return FALSE;

        while (cbOffset < pmf->cbSize1)
        {
            cbOffset += sizeof(WCHAR);
            wch = *pmf->pwsz++;

            // Break out if this is the newline or the control-Z
            if (wch == 0x001A || wch == L'\n')
                break;
        }
    }
    else
    {
        CHAR ch;
        cbOffset = (DWORD) ((PBYTE)pmf->psz - (PBYTE)pmf->pvMap);

        // test for EOF
        Assert (cbOffset <= pmf->cbSize1);
        if (cbOffset == pmf->cbSize1)
            return FALSE;

        while (cbOffset < pmf->cbSize1)
        {
            cbOffset += sizeof(CHAR);
            ch = *pmf->psz++;

            // Break out if this is the newline or the control-Z
            if (ch == 0x1A || ch == '\n')
                break;
        }
    }

    return TRUE;
}


PVOID WINAPI GetMapLine(PVOID pv0, DWORD cbMac, PMFILE pmf)
{
    PVOID pv1;
    DWORD cbOffset, cbBuff;

    Assert(pv0);
    // Make sure that the buffer is at least as big as the caller says it is.
    // (If the buffer was allocated with the debug memory allocator, this access
    // should cause an exception if pv0 isn't at least cbMac bytes long.
    Assert(((char *)pv0)[cbMac-1] == ((char *)pv0)[cbMac-1]);

    if (!pmf || !pmf->hFileMap) // check for zero length file
        return NULL;

    if (pmf->fSrcUnicode != pmf->fDstUnicode)
    {
        if (!fNLGNewMemory(&pv1, cbMac))
            return NULL;

        cbBuff = cbMac;
    }
    else
    {
        pv1 = pv0;
    }

    if (pmf->fSrcUnicode)
    {
        WCHAR wch, *pwsz = pv1;
        cbOffset = (DWORD) ((PBYTE)pmf->pwsz - (PBYTE)pmf->pvMap);

        // test for EOF
        Assert (cbOffset <= pmf->cbSize1);
        if (cbOffset == pmf->cbSize1)
            goto Error;

        // don't want deal with odd-sized buffers
        if (cbMac % sizeof(WCHAR) != 0)
            cbMac -= (cbMac % sizeof(WCHAR));

        // reserve space for terminating 0
        //
        Assert (cbMac > 0);
        cbMac -= sizeof(WCHAR);

        while (cbOffset < pmf->cbSize1)
        {
            cbOffset += sizeof(WCHAR);
            wch = *pmf->pwsz++;

            switch (wch)
            {
            case L'\r':
            case L'\n':      // end of line
            case 0xFEFF:     // Unicode BOM
                break;
            case 0x001A:     // ctrl-Z
                wch = L'\n'; // Replace it so that the last line can be read
                break;
            default:
                *pwsz++ = wch;
                cbMac -= sizeof(WCHAR);
            }

            // Break out if this is the newline or buffer is full
            if (wch == L'\n' || cbMac <= 0)
                break;
        }
        *pwsz = L'\0';
    }
    else
    {
        CHAR ch, *psz = pv1;
        cbOffset = (DWORD) ((PBYTE)pmf->psz - (PBYTE)pmf->pvMap);

        // test for EOF
        Assert (cbOffset <= pmf->cbSize1);
        if (cbOffset == pmf->cbSize1)
            goto Error;

        // reserve space for terminating 0
        //
        Assert (cbMac > 0);
        cbMac -= sizeof(CHAR);

        while (cbOffset < pmf->cbSize1)
        {
            cbOffset += sizeof(CHAR);
            ch = *pmf->psz++;

            switch (ch)
            {
            case '\r':
            case '\n':      // end of line
                break;
            case 0x1A:      // ctrl-Z
                ch = '\n';  // Replace it so that the last line can be read
                break;
            default:
                cbMac -= sizeof(CHAR);
                *psz++ = ch;
            }

            // Break out if this is the newline or buffer is full
            if (ch == '\n' || cbMac <= 0)
                break;
        }
        *psz = '\0';
    }

    if (pmf->fSrcUnicode != pmf->fDstUnicode)
    {
        DWORD cch = cbBuff;     // our argument is a count of bytes

        if (pmf->fDstUnicode)
        {
            // MultiByteToWideChar wants the size of the destination in wide characters
            cch /= sizeof(WCHAR);
            cch = MultiByteToWideChar(pmf->uCodePage, MB_PRECOMPOSED,(PSTR)pv1,-1, (WCHAR *)pv0,cch);
        }
        else
        {
            cch = WideCharToMultiByte(pmf->uCodePage, 0, (WCHAR *)pv1, -1, (PSTR)pv0, cch, NULL, NULL);
        }
        if (cch == 0)
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                // Ignore truncation (for consistency with no-conversion cases)
                //
                if (pmf->fDstUnicode)
                {
                    ((WCHAR *)pv0)[(cbBuff / sizeof(WCHAR)) - 1] = 0;
                }
                else
                {
                    ((CHAR *)pv0)[cbBuff - 1] = 0;
                }
            }
            else
            {
                // not a truncation error
                NLGFreeMemory(pv1);
                return NULL;
            }
        }
        NLGFreeMemory(pv1);
    }

    return(pv0);

Error:
    if (pmf->fSrcUnicode != pmf->fDstUnicode)
    {
        NLGFreeMemory(pv1);
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\listwordbreak.hpp ===
//------------------------------------------------------------------------------------------
//	ListWordBreak.hpp
//
//	Data structures for List Of Points
//
//------------------------------------------------------------------------------------------

#ifndef LISTWORDBREAK_HPP
#define LISTWORDBREAK_HPP
#include "list.hpp"
#include "CThaiBreakTree.hpp"
#include "CTrie.hpp"

//------------------------------------------------------------------------------------------
//	The following class defines a WordBeakElement -- which is used to store WordBreak element.
//------------------------------------------------------------------------------------------
class WordBreakElement
{
public:
	WordBreakElement(CTrie* pTrie, CTrie* pTrieTrigram);
	~WordBreakElement();
	
	CThaiBreakTree* breakTree;
	bool fFree;
};

//------------------------------------------------------------------------------------------
//	The following class defines a ListWordBreak -- singly link list of WordBreak.
//
//	ListPoint is subclass of List it encapsulate the internal memory management of the list.
//------------------------------------------------------------------------------------------
class ListWordBreak : public List
{
public:
	ListWordBreak();
	bool Init(CTrie* pTrie,CTrie* pTrieTrigram); 
    bool CreateWordBreak();
	bool GetNode(CThaiBreakTree*, bool*);
	void Flush();
	WordBreakElement* GetFreeWB(bool fCreateNode = true);
	void MarkWordBreak(WordBreakElement* pWordBreakElement, bool fFree);

protected:
    void  Prepend(void *item) {List::Prepend(item);}
    void  Append(void *item) {List::Append(item);}
    void* Remove();

	CTrie* m_pTrie;
	CTrie* m_pTrieTrigram;

#if defined (_DEBUG)
	bool fInit;
#endif
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\misc.h ===
/* Simple but direct hash function that hashes across several bits by
multiplying by the greatest prime less than bits**2 and masking off the excess. */


extern WCHAR g_szLogLine[];
extern BOOL g_bEnvStrings;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\memcore.c ===
////////////////////////////////////////////////////////////////////////////////
// File: memCore.c
//
// This module which replaces the Win32 Global heap functions used by Word
// with functions which place objects at the end of a physical page.  In
// this way, we hope to catch out-of-bounds memory references exactly where
// they happen, helping to isolate heap corruption problems.
//
//
// This module is not enabled for ship builds.
//
// lenoxb:  4/05/94
//
////////////////////////////////////////////////////////////////////////////////


#include "precomp.h"

#if defined(_DEBUG) && (defined(_M_IX86) || defined (_M_ALPHA))

#include "dbgmemp.h"

static DWORD s_cbMemPage = 0;     // Initialize to 0 so init can check

static void *          FreePvCore(void*);
static LPVOID           PvReallocCore(PVOID, DWORD, UINT);

static LPVOID           DoAlloc(UINT, DWORD);
static void AddToList(struct head*);
static void RemoveFromList(struct head*);
static void TrackHeapUsage(long dcb);

static DWORD idBlockNext;

static struct head* phead;
static CRITICAL_SECTION csMine;

    #undef GlobalAlloc
    #undef GlobalReAlloc
    #undef GlobalFree
    #undef GlobalLock
    #undef GlobalUnlock
    #undef GlobalSize
    #undef GlobalHandle

BOOL g_fTrackHeapUsage;
DWORD g_cbAllocMax;
DWORD g_cbAlloc;

/*
 *Function Name:InitDebugMem
 *
 *Parameters:
 *
 *Description:  Initialize Memory Manager
 *
 *Returns:
 *
 */

void WINAPI InitDebugMem(void)
{
    SYSTEM_INFO SysInfo;

    Assert(!s_cbMemPage);
    InitializeCriticalSection(&csMine);

    GetSystemInfo( &SysInfo );  // get the system memory page size
    s_cbMemPage = SysInfo.dwPageSize;
}

BOOL WINAPI FiniDebugMem(void)
{
    Assert(s_cbMemPage);
    s_cbMemPage = 0;
    DeleteCriticalSection(&csMine);

    if (!phead) // no outstanding mem blocks
        return FALSE;
    else
    {
        struct head* pheadThis = phead;
        char buf[256];

        OutputDebugStringA("Unfreed Memory Blocks\n");
        for ( ; pheadThis; pheadThis = pheadThis->pheadNext)
        {
            sprintf(buf, "ID %d size %d\n",
                    pheadThis->idBlock,
                    pheadThis->cbBlock
                    );
            OutputDebugStringA(buf);
        }
    }
    return TRUE;
}



/* D B  G L O B A L  A L L O C */
/*----------------------------------------------------------------------------
    %%Function: dbGlobalAlloc
    %%Contact: lenoxb

    Replacement for GlobalAlloc
    Now an Internal Routine
----------------------------------------------------------------------------*/
static void * WINAPI dbGlobalAlloc(UINT uFlags, DWORD cb)
{
    /* Send "tough" requests to actual memory manager */
    if ((uFlags & GMEM_DDESHARE) || ((uFlags & GMEM_MOVEABLE) && !fMove))
        return GlobalAlloc(uFlags,cb);

    if (uFlags & GMEM_MOVEABLE)
    {
        return HgAllocateMoveable(uFlags, cb);
    }

    return (void *) PvAllocateCore(uFlags, cb);
}



/* D B  G L O B A L  F R E E */
/*----------------------------------------------------------------------------
    %%Function: dbGlobalFree
    %%Contact: lenoxb

    Replacement for GlobalFree()
    Now an internal routine
----------------------------------------------------------------------------*/
static void * WINAPI dbGlobalFree(void * hMem)
{
    void** ppv;

    if (!fMove && FActualHandle(hMem))
        return GlobalFree(hMem);

    ppv = PpvFromHandle(hMem);
    if (ppv)
    {
        if (FreePvCore(*ppv) != NULL)
            return hMem;

        *ppv = NULL;
        return NULL;
    }

    return FreePvCore (hMem);
}


/* D B  G L O B A L  S I Z E */
/*----------------------------------------------------------------------------
    %%Function: dbGlobalSize
    %%Contact: lenoxb

    Replacement for GlobalSize()
    Now an internal routine
----------------------------------------------------------------------------*/
static DWORD WINAPI dbGlobalSize(void * hMem)
{
    void** ppv;
    HEAD * phead;

    if (!fMove && FActualHandle(hMem))
        return GlobalSize(hMem);

    if (hMem == 0)
        return 0;

    ppv = PpvFromHandle(hMem);
    phead = GetBlockHeader(ppv ? *ppv : hMem);
    return phead ? phead->cbBlock : 0;
}



/* D B  G L O B A L  R E  A L L O C */
/*----------------------------------------------------------------------------
    %%Function: dbGlobalReAlloc
    %%Contact: lenoxb

    Replacement for GlobalReAlloc()
    Now an internal routine
----------------------------------------------------------------------------*/
static void * WINAPI dbGlobalReAlloc(void * hMem, DWORD cb, UINT uFlags)
{
    LPVOID pvNew;
    void** ppv;

    if (!fMove && FActualHandle(hMem))
        return GlobalReAlloc(hMem,cb,uFlags);

    /* REVIEW: what's supposed to happen when hMem==NULL */

    ppv = PpvFromHandle(hMem);
    if (uFlags & GMEM_MODIFY)       /* Modify block attributes */
    {
        if (uFlags & GMEM_MOVEABLE)
        {
            return HgModifyMoveable(hMem, cb, uFlags);
        }
        else
        {
            HEAD * phead;

            if (ppv == NULL)        /* Already fixed */
                return hMem;

            phead = GetBlockHeader(*ppv);
            if (phead->cLock != 0)      /* Don't realloc a locked block */
                return NULL;

            *ppv = NULL;
            return phead+1;
        }
    }

    if (ppv)
    {
        pvNew = PvReallocCore (*ppv, cb, uFlags);
        if (pvNew == NULL)
            return NULL;

        *ppv = pvNew;
        return hMem;
    }

    if (!(uFlags & GMEM_MOVEABLE))
        return NULL;

    return PvReallocCore (hMem, cb, uFlags);
}

/***********************************************
  External interface for routines that can track usage
***********************************************/
void* WINAPI dbgMallocCore(size_t cb, BOOL fTrackUsage)
{
    void* pv;

    // make sure we're initialized
    if (s_cbMemPage == 0)
        InitDebugMem();

    EnterCriticalSection(&csMine);
    pv = dbGlobalAlloc(GMEM_FIXED, cb);
    if (fTrackUsage)
        TrackHeapUsage((long)dbGlobalSize(pv));
    LeaveCriticalSection(&csMine);
    return pv;
}

void * WINAPI dbgFreeCore(void* pv, BOOL fTrackUsage)
{
    void * hRes;
    // make sure we're initialized
    if (s_cbMemPage == 0)
        InitDebugMem();
    EnterCriticalSection(&csMine);
    if (fTrackUsage)
        TrackHeapUsage(-(long)dbGlobalSize(pv));
    hRes = dbGlobalFree(pv);
    LeaveCriticalSection(&csMine);
    return hRes;
}

void* WINAPI dbgReallocCore(void* pv, size_t cb, BOOL fTrackUsage)
{
    long cbOld, cbNew;

    // make sure we're initialized
    if (s_cbMemPage == 0)
        InitDebugMem();
    EnterCriticalSection(&csMine);
    cbOld = dbGlobalSize(pv);
    pv = dbGlobalReAlloc(pv,cb,GMEM_MOVEABLE);
    if (pv && fTrackUsage)
    {
        cbNew = dbGlobalSize(pv);
        TrackHeapUsage(cbNew - cbOld);
    }
    LeaveCriticalSection(&csMine);
    return pv;
}

/**************************************************************
  Normal Public Interface
**************************************************************/

void* WINAPI dbgMalloc(size_t cb)
{
    return dbgMallocCore(cb, FALSE);
}

void* WINAPI dbgCalloc(size_t c, size_t cb)
{
    void *pMem = dbgMallocCore(cb * c, FALSE);
    if (pMem)
    {
        memset(pMem, 0, cb * c);
    }
    return pMem;
}

HLOCAL WINAPI dbgFree(void* pv)
{
    return dbgFreeCore(pv, FALSE);
}

void* WINAPI dbgRealloc(void* pv, size_t cb)
{
    return dbgReallocCore(pv, cb, FALSE);
}

static void TrackHeapUsage(long dcb)
{
    long cbAlloc=0, cbAllocMax=0;

    if (!g_fTrackHeapUsage)
        return;

    g_cbAlloc += dcb;
    g_cbAllocMax = (g_cbAllocMax > g_cbAlloc ? g_cbAllocMax : g_cbAlloc);
    cbAlloc = g_cbAlloc;
    cbAllocMax = g_cbAllocMax;
    LeaveCriticalSection(&csMine);

    Assert(cbAlloc >= 0);
    Assert(cbAllocMax >= 0);
}

//////////////////////////////////////
/// NLG (ex T-Hammer) interfaces   ///
//////////////////////////////////////

BOOL WINAPI
fNLGNewMemory(
             OUT PVOID *ppv,
             IN  ULONG cb)
{
    Assert(ppv != NULL && cb != 0);

    *ppv = dbgMalloc(cb);
    return *ppv != NULL;
}


DWORD WINAPI
NLGMemorySize(
             VOID *pvMem)
{
    Assert (pvMem != NULL);

    return dbGlobalSize(pvMem);
}

BOOL WINAPI
fNLGResizeMemory(
                IN OUT PVOID *ppv,
                IN ULONG cbNew)
{
    PVOID pv;
    Assert( ppv != NULL && *ppv != NULL && cbNew != 0 );

    // Note that the semantics of GMEM_MOVEABLE are different
    // between Alloc and ReAlloc; with ReAlloc, it only means that
    // it's OK for the realloc'ed block to start at a different location
    // than the original...
    pv = dbgRealloc(*ppv, cbNew);
    if (pv != NULL)
    {
        *ppv = pv;
    }
    return (pv != NULL);
}

VOID WINAPI
NLGFreeMemory(
             IN PVOID pvMem)
{
    Assert(pvMem != NULL);

    dbgFree(pvMem);
}

// These two are the same in retail and debug;
// find a home for the retail versions...

BOOL WINAPI
fNLGHeapDestroy(
               VOID)
{
    return TRUE;
}



/* G E T  B L O C K  H E A D E R */
/*----------------------------------------------------------------------------
    %%Function: GetBlockHeader
    %%Contact: lenoxb
tmp
    Returns memory block header associated with indicated handle.
    Generates access violation if passed an invalid handle.
------------------------------------------tmp----------------------------------*/
static HEAD * GetBlockHeader(void* pvMem)
{
    HEAD * phead = ((HEAD *) pvMem) - 1;

    Assert (!IsBadWritePtr(phead, sizeof *phead));
    return phead;
}


/* P V  A L L O C A T E  C O R E */
/*----------------------------------------------------------------------------
    %%Function: PvAllocateCore
    %%Contact: lenoxb

    Workhorse routine to allocate memory blocks
----------------------------------------------------------------------------*/
static LPVOID PvAllocateCore (UINT uFlags, DWORD cb)
{
    HEAD headNew;
    HEAD *pAllocHead;
    DWORD cbTotal, cbPadded, cbPages;


    if (fPadBlocks)
        cbPadded = PAD(cb,4);       /* For RISC platforms, makes sure the block is aligned */
    else
        cbPadded = cb;

    cbTotal = PAD(cbPadded + sizeof headNew, s_cbMemPage);

    if (fExtraReadPage)
        cbPages = cbTotal+1;
    else
        cbPages = cbTotal;
    cbPages += s_cbMemPage;

    headNew.dwTag = HEAD_TAG;
    headNew.cbBlock = cb;
    headNew.cLock = 0;
    headNew.idBlock = idBlockNext++;
    headNew.pheadNext = NULL;
    headNew.pbBase = VirtualAlloc(NULL,
                                  cbPages, MEM_RESERVE, PAGE_READWRITE
                                 );
    if (headNew.pbBase == NULL)
        return NULL;
    pAllocHead = VirtualAlloc(headNew.pbBase,
                              cbTotal, MEM_COMMIT, PAGE_READWRITE
                             );
    if (pAllocHead == NULL)
    {
        VirtualFree(headNew.pbBase, 0, MEM_RELEASE);
        return NULL;
    }
    headNew.pbBase = (LPBYTE)pAllocHead;


    if (fExtraReadPage)
    {
        if (!VirtualAlloc(headNew.pbBase+cbTotal,1, MEM_COMMIT, PAGE_READONLY))
        {
            VirtualFree(headNew.pbBase, 0, MEM_RELEASE);
            return NULL;
        }
    }

    // FUTURE: do something with PAGE_GUARD?
    if (!VirtualAlloc(headNew.pbBase + cbPages - s_cbMemPage,
                      1, MEM_COMMIT, PAGE_NOACCESS))
    {
        // the entire reserved range must be either committed or decommitted
        VirtualFree(headNew.pbBase, cbTotal, MEM_DECOMMIT);
        VirtualFree(headNew.pbBase, 0, MEM_RELEASE);
        return FALSE;
    }

    if ((uFlags & GMEM_ZEROINIT) == 0)
        memset(headNew.pbBase, bNewGarbage, cbTotal);

    pAllocHead = ((HEAD *)(headNew.pbBase + cbTotal - cbPadded));
    pAllocHead[-1] = headNew;
    AddToList(pAllocHead-1);
    return pAllocHead;
}


/* P V  R E A L L O C  C O R E */
/*----------------------------------------------------------------------------
    %%Function: PvReallocCore
    %%Contact: lenoxb

    Workhorse routine to move memory blocks
----------------------------------------------------------------------------*/
static LPVOID PvReallocCore (PVOID pvMem, DWORD cb, UINT uFlags)
{
    LPVOID pvNew;
    DWORD cbOld;

    pvNew = (LPVOID) PvAllocateCore(uFlags, cb);
    if (!pvNew)
        return NULL;

    cbOld = dbGlobalSize(pvMem);
    if (cbOld>0 && cb>0)
        memcpy(pvNew, pvMem, cbOld<cb ? cbOld : cb);

    FreePvCore (pvMem);
    return pvNew;
}


/* F R E E  P V  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FreePvCore
    %%Contact: lenoxb

    Workhourse routine to free memory blocks.
----------------------------------------------------------------------------*/
static void * FreePvCore (void* pvMem)
{
    HEAD * phead;

    if (pvMem)
    {
        phead = GetBlockHeader(pvMem);
        if (phead->cLock != 0)
            return pvMem;

        RemoveFromList(phead);
        VirtualFree(phead->pbBase, 0, MEM_RELEASE);
    }

    return NULL;
}


struct head* dbgHead(void)
{
    struct head* pheadThis = phead;

    if (pheadThis == NULL)
        return NULL;

    for (pheadThis=phead; pheadThis->pheadNext; pheadThis = pheadThis->pheadNext)
        continue;
    return pheadThis;
}

static void AddToList(struct head* pheadAdd)
{
    EnterCriticalSection(&csMine);
    pheadAdd->pheadNext = phead;
    phead = pheadAdd;
    LeaveCriticalSection(&csMine);
}

static void RemoveFromList(struct head* pheadRemove)
{
    struct head* pheadThis;
    struct head* pheadPrev;
    BOOL fFoundNode = FALSE;

    Assert(pheadRemove != NULL);

    EnterCriticalSection(&csMine);
    pheadPrev = NULL;
    for (pheadThis = phead; pheadThis; pheadThis = pheadThis->pheadNext)
    {
        if (pheadThis == pheadRemove)
        {
            if (pheadPrev == NULL)
            {
                Assert(pheadThis == phead);
                phead = pheadThis->pheadNext;
            }
            else
            {
                pheadPrev->pheadNext = pheadThis->pheadNext;
            }

            fFoundNode = TRUE;
            goto LExit;
        }

        pheadPrev = pheadThis;
    }

    LExit:
    LeaveCriticalSection(&csMine);
    Assert(fFoundNode);  // Not on the list? Never happens.
}


#else // !defined(DEBUG) && defined(NTX86) || defined (M_ALPHA)
void    * WINAPI dbgCalloc(size_t c, size_t cb)
{
    void *pMem = dbgMalloc(cb * c);
    if (pMem)
    {
        memset(pMem, 0, cb * c);
    }
    return pMem;
}

#endif //defined(DEBUG) && defined(NTX86) || defined (M_ALPHA)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\thwbdef.hpp ===
//+---------------------------------------------------------------------------
//
//
//  THWBDEF.HPP - contain different definition use in Thai Word Break.
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBDEF_HPP_
#define _THWBDEF_HPP_
#include <windows.h>
#include "thwbplat.h"

#define THAI_Ko_Kai					0x0e01
#define THAI_Kho_Rakhang            0x0e06
#define THAI_Cho_Ching              0x0e09
#define THAI_So_So                  0x0e0b
#define THAI_Tho_NangmonTho         0x0e11
#define THAI_Pho_Phung              0x0e1c
#define THAI_Fo_Fa                  0x0e1d
#define THAI_Fo_Fan                 0x0e1f
#define THAI_Pho_Samphao            0x0e20
#define THAI_Ho_Hip                 0x0e2b
#define THAI_Ho_Nok_Huk				0x0e2e
#define THAI_Sign_PaiYanNoi         0x0e2f
#define THAI_Vowel_Sara_A           0x0e30
#define THAI_Vowel_Sign_Mai_HanAkat 0x0e31
#define THAI_Vowel_Sara_AA          0x0e32
#define THAI_Vowel_Sign_Sara_Am		0x0e33
#define THAI_Vowel_Sara_I           0x0e34
#define THAI_Vowel_Sara_II          0x0e35
#define THAI_Sara_Ue                0x0e36
#define THAI_Sara_Uee               0x0e37
#define THAI_Vowel_Sign_Phinthu		0x0e3a
#define THAI_Vowel_Sara_E           0x0e40
#define THAI_Vowel_Sara_AI_MaiMaLai 0x0e44
#define THAI_Vowel_LakKhangYao      0x0e45
#define THAI_Vowel_MaiYaMok         0x0e46
#define THAI_Tone_MaiTaiKhu         0x0e47
#define THAI_Tone_Mai_Ek			0x0e48
#define THAI_Tone_Mai_Tro           0x0e49
#define THAI_Tone_Mai_Tri           0x0e4a
#define THAI_Thanthakhat            0x0e4c
#define THAI_Nikhahit               0x0e4d

#define POSTYPE		                305
#define POS_UNKNOWN                 (POSTYPE - 1)
#define TAGPOS_NCNM                 0x0002301
#define TAGPOS_PUNC                 0x002F301
#define TAGPOS_UNKNOWN              0x012F301
#define TAGPOS_ABBR                 0x0130301
#define TAGPOS_PURGE                0x0131301


#define MAXBREAK                    256

// Soundex definition.
#define APPROXIMATEWEIGHT           60

#define WB_LINEBREAK	0
#define WB_NORMAL		1
//#define WB_LINEBREAK	2	// Number 2 is also linebreak.
#define WB_SPELLER		3
#define WB_INDEX		4
#define WB_CARETBREAK   5

typedef struct THWB_STRUCT
{
	bool fThai;
	BYTE alt;
} THWB_STRUCT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\thwbint.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Thai WordBreak
//
//  Thai WordBreak Interface Header File.
//
//  History:
//      created 6/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBINT_H_
#define _THWBINT_H_

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "ProofBase.h"						// Include for definition of PTEC.
#include "thwbdef.hpp"
#include "thwbplat.h"

#define VERSIONMAJOR 1
#define VERSIONMINOR 0

#if defined(__cplusplus)
extern "C" {
#endif

#if defined (NGRAM_ENABLE)
PTEC WINAPI ThaiWordBreakInit(const WCHAR* szFileName, const WCHAR* szFileNameSentStruct, const WCHAR* szFileNameTrigram);
#else
PTEC WINAPI ThaiWordBreakInit(const WCHAR* szFileName, const WCHAR* szFileNameTrigram);
#endif
PTEC WINAPI ThaiWordBreakInitResource(LPBYTE pThaiDic, LPBYTE pThaiTrigram, BOOL fSkipHeader);
void WINAPI ThaiWordBreakTerminate();
BOOL WINAPI ThaiWordBreakSearch(const WCHAR* szWord, DWORD* pdwPOS);
int WINAPI THWB_FindWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakLen, unsigned int mode);
int WINAPI ThaiSoundEx(WCHAR* word);

int WINAPI THWB_IndexWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,THWB_STRUCT* pThwb_Struct,unsigned int iBreakMax);
int WINAPI THWB_FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos);
THWB_STRUCT* WINAPI THWB_CreateThwbStruct(unsigned int iNumStruct);
void WINAPI THWB_DeleteThwbStruct(THWB_STRUCT* pThwb_Struct);


DWORD_PTR WINAPI THWB_CreateWordBreaker();
int WINAPI THWB_FindWB(DWORD_PTR dwBreaker, WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakLen, unsigned int mode);
BOOL WINAPI THWB_DeleteWordBreaker(DWORD_PTR dwBreaker);


#if defined(__cplusplus)
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\precomp.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       precomop.h
//
//  Contents:   Internal include file for Token Hammer.
//
//  History:    22-May-95       PatHal          Created
//
//---------------------------------------------------------------------------

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#define _UNICODE 1
#define UNICODE 1

#include <windows.h>
#include <memory.h>
#include <malloc.h>
#ifndef WINCE
#include <stdio.h>
#include <wchar.h>
#endif
#include <string.h>

#ifndef WINCE
#include "cmn_debug.h"
#endif
#include "common.h"
#include "misc.h"
//#include "NLGlib.h"

#define unreference(x)  (x)

#endif //_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\thwbplat.h ===
//+---------------------------------------------------------------------------
//
//
//  THWBPLAT.H - contain different definition use in Thai Word Break.
//
//  History:
//      created 3/00 aarayas
//
//  2000 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBPLAT_H_
#define _THWBPLAT_H_

#ifdef _OFFICE_
#define DWORD_PTR DWORD
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\proofbase.h ===
/********************************************************************
  ProofBase.h - Base API definitions for CSAPI, CTAPI, & CHAPI
    Speller, Thesaurus, and Hyphenator

  Version 3.0 - all api's

    History:
    5/97    DougP   Created
    12/97   DougP   Copied from ProofAPI.h and Separated into tool section files
	5/99	aarayas	Copied Vendor.h into proofbase to elminate many files to copied for Thai wordbreak.

    The Natural Language Group maintains this file.

The end user license agreement (EULA) for CSAPI, CHAPI, or CTAPI covers this source file.  Do not disclose it to third parties.

You are not entitled to any support or assistance from Microsoft Corporation regarding your use of this program.

 1997-1998 Microsoft Corporation.  All rights reserved.
********************************************************************/

#if !defined(PROOFBASE_H)
#define PROOFBASE_H

#pragma pack(push, proofapi_h, 8)   // default alignment

// The Following code was taken from NLG group vendor.h
#if !defined(VENDOR_H)
#define VENDOR_H

/* unified codes */
// I originally used an enum here - but RC doesn't like it

typedef int VENDORID;   // vendorid

#define  vendoridSoftArt            1
#define  vendoridInso               2

  // these came from the original list from the speller
  // but don't conflict with any others - so they are safe for all tools
#define vendoridInformatic         17     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define vendoridAmebis             18     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define vendoridLogos              19     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define vendoridDatecs             20     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define vendoridFilosoft           21     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define vendoridLingsoft           22     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define vendoridPolderland         23     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */


#define  vendoridMicrosoft          64
#define  vendoridSynapse            65              /* Synapse - French(Spelling:Mssp3fr.lex, Mssp3fr.dll) */
#define  vendoridFotonija           66              /* Fotonija - Lithuanian(Spelling:Mssp_lt.lex, Msplt32.dll) - added 3/25/97 */
#define  vendoridFotonja        vendoridFotonija                /* To make up for earlier misspelling */
#define  vendoridHizkia             67              /* Hizkia -Basque (Spelling:Mssp_eu.lex, Mspeu32.dll) - added 5/21/97 */
#define  vendoridExpertSystem       68              /* ExpertSystem - Italian(Spelling:Mssp3lt.lex, Mssp3lt.dll) - added 7/17/97 */
#define  vendoridWYSIWYG            69      /* Various languages as an addon - 2/2/98 */

  // next five added at Ireland's request 3/27/98
#define  vendoridSYS                70  // Croatian - Spelling:Mssp_cr.lex, Mspcr32.dll
#define  vendoridTilde              71  // Latvian - Spelling:Mssp_lv.lex, Msplv32.dll
#define  vendoridSignum             72  // Spanish - Spelling:Mssp3es.lex, Mssp3es.dll
#define  vendoridProLing            73  // Ukrainian - Spelling:Mssp3ua.lex, Mssp3ua.dll
#define  vendoridItautecPhilcoSA    74  // Brazilian - Spelling:mssp3PB.lex, Mssp3PB.dll

#define vendoridPriberam             75     /* Priberam Informtica - Portuguese - 7/13/98 */
#define vendoridTranquility     76  /* Tranquility Software - Vietnamese - 7/22/98 */

#define vendoridColtec          77  /* Coltec - Arabic - added 8/17/98 */

/*************** legacy codes ******************/

/* Spell Engine Id's */
#define sidSA    vendoridSoftArt      /* Reserved */
#define sidInso  vendoridInso      /* Inso */
#define sidHM    sidInso      /* Inso was Houghton Mifflin */
#define sidML    3      /* MicroLytics */
#define sidLS    4      /* LanSer Data */
#define sidCT    5      /* Center of Educational Technology */
#define sidHS    6      /* HSoft - Turkish(mssp_tr.lex, Msptr32.dll)*/
#define sidMO    7      /* Morphologic - Romanian(Mssp_ro.lex, Msthro32.dll) and Hungarian(Mssp_hu.lex, Msphu32.dll) */
#define sidTI    8      /* TIP - Polish(Mssp_pl.lex, Mspl32.dll) */
#define sidTIP sidTI
#define sidKF    9      /* Korean Foreign Language University */
#define sidKFL sidKF
#define sidPI    10     /* Priberam Informatica Lince - Portuguese(Mssp3PT.lex, Mssp3PT.dll) */
#define sidPIL sidPI
#define sidColtec   11  /* Coltec (Arabic) */
#define sidGS    sidColtec     /* Glyph Systems - this was an error */
#define sidRA    12     /* Radiar (Romansch) */
#define sidIN    13     /* Intracom - Greek(Mssp_el.lex, Mspel32.dll) */
#define sidSY    14     /* Sylvan */
#define sidHI    15     /* Hizkia (obsolete - use vendoridHizkia) */
#define sidFO    16     /* Forma - Slovak(Mssp_sk.lex, Mspsk32.dll) */
#define sidIF    vendoridInformatic     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define sidAM    vendoridAmebis     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define sidLO    vendoridLogos     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define sidDT    vendoridDatecs     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define sidFS    vendoridFilosoft     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define sidLI    vendoridLingsoft     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define sidPL    vendoridPolderland     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */

  /* Thesaurus Engine Id's */
#define teidSA    vendoridSoftArt
#define teidInso  vendoridInso    /* Inso */
#define teidHM    teidInso    /* Inso was Houghton-Mifflin */
#define teidIF    3    /* Informatic */
#define teidIN    4    /* Intracom */
#define teidMO    5    /* MorphoLogic */
#define teidTI    6    /* TiP */
#define teidPI    7    /* Priberam Informatica Lince */
#define teidAM    8    /* Amebis */
#define teidDT    9    /* Datecs */
#define teidES   10    /* Expert System */
#define teidFS   11    /* Filosoft */
#define teidFO   12    /* Forma */
#define teidHS   13    /* HSoft */
#define teidLI   14    /* Lingsoft */
#define teidLO   15    /* Logos */
#define teidPL   16    /* Polderland */

/* HYphenation Engine ID's */
#define hidSA    vendoridSoftArt
#define hidHM    vendoridInso      /* Houghton Mifflin */
#define hidML    3      /* MicroLytics */
#define hidLS    4      /* LanSer Data */
#define hidFO    5      /* Forma */
#define hidIF    6      /* Informatic */
#define hidAM    7      /* Amebis */
#define hidDT    8      /* Datecs */
#define hidFS    9      /* Filosoft */
#define hidHS   10      /* HSoft */
#define hidLI   11      /* Lingsoft */
#define hidLO   12      /* Logos */
#define hidMO   13      /* MorphoLogic */
#define hidPL   14      /* Polderland */
#define hidTI   15      /* TiP */

/* Grammar Id Engine Defines */
#define geidHM    1    /* Houghton-Mifflin */
#define geidRF    2    /* Reference */
#define geidES    3    /* Expert System */
#define geidLD    4    /* Logidisque */
#define geidSMK   5    /* Sumitomo Kinzoku (Japanese) */
#define geidIF    6    /* Informatic */
#define geidMO    7    /* MorphoLogic */
#define geidMS    8    /* Microsoft Reserved */
#define geidNO    9    /* Novell */
#define geidCTI  10    /* CTI (Greek) */
#define geidAME  11    /* Amebis (Solvenian) */
#define geidTIP  12    /* TIP (Polish) */

#endif  /* VENDOR_H */


  // you may wish to include lid.h for some convenient langid defs
#if !defined(lidUnknown)
#   define lidUnknown   0xffff
#endif

/*************************************************************
     PART 1 - Structure Defs
**************************************************************/
/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) --------- */

/* hardcoded ordinals are the exported dll entry points */
// individual def files have these as well so be sure to change them
// if you change these
#define idllProofVersion        20
#define idllProofInit           21
#define idllProofTerminate      22
#define idllProofOpenLex        23
#define idllProofCloseLex       24
#define idllProofSetOptions     25
#define idllProofGetOptions     26

typedef unsigned long PTEC;     // ptec

/******************* Proofing Tool Error Codes ************************/
    /* Major Error Codes in low two bytes (WORD) of PTEC */
enum {
    ptecNoErrors,
    ptecOOM,            /* memory error */
    ptecModuleError,    /* Something wrong with parameters, or state of spell module. */
    ptecIOErrorMainLex,  /* Read,write,or share error with Main Dictionary. */
    ptecIOErrorUserLex,  /* Read,write,or share error with User Dictionary. */
    ptecNotSupported,   /* No support for requested operation */
    ptecBufferTooSmall, /* Insufficient room for return info */
    ptecNotFound,       /* Hyphenator and Thesaurus only */
    ptecModuleNotLoaded,    /* underlying module not loaded (Glue Dll's) */
};

/* Minor Error Codes in high two bytes of PTEC */
/* (Not set unless major code also set) */
enum {
    ptecModuleAlreadyBusy=128,  /* For non-reentrant code */
    ptecInvalidID,              /* Not yet inited or already terminated.*/
    ptecInvalidWsc,             /* Illegal values in WSC struct (speller only) */
    ptecInvalidMainLex,     /* Mdr not registered with session */
    ptecInvalidUserLex,     /* Udr not registered with session */
    ptecInvalidCmd,             /* Command unknown */
    ptecInvalidFormat,          /* Specified dictionary not correct format */
    ptecOperNotMatchedUserLex,  /* Illegal operation for user dictionary type. */
    ptecFileRead,               /* Generic read error */
    ptecFileWrite,              /* Generic write error */
    ptecFileCreate,             /* Generic create error */
    ptecFileShare,              /* Generic share error */
    ptecModuleNotTerminated,    /* Module not able to be terminated completely.*/
    ptecUserLexFull,            /* Could not update Udr without exceeding limit.*/
    ptecInvalidEntry,           /* invalid chars in string(s) */
    ptecEntryTooLong,           /* Entry too long, or invalid chars in string(s) */
    ptecMainLexCountExceeded,   /* Too many Mdr references */
    ptecUserLexCountExceeded,   /* Too many udr references */
    ptecFileOpenError,          /* Generic Open error */
    ptecFileTooLargeError,      /* Generic file too large error */
    ptecUserLexReadOnly,        /* Attempt to add to or write RO udr */
    ptecProtectModeOnly,        /* (obsolete) */
    ptecInvalidLanguage,        /* requested language not available */
};


#define ProofMajorErr(x) LOWORD(x)
#define ProofMinorErr(x) HIWORD(x)

/************* Structure def macros *************
Smoke and mirrors to allow initialization of some members when
using C++
***********************************/
#if !defined(__cplusplus)
#   define STRUCTUREBEGIN(x) typedef struct {
#   define STRUCTUREEND0(x) } x;
#   define STRUCTUREEND1(x, y) } x;
#   define STRUCTUREEND2(x, y, z) } x;
#   define STRUCTUREEND3(x, y, z, w) } x;
#else
#   define STRUCTUREBEGIN(x) struct x {
#   define STRUCTUREEND0(x) };
#   define STRUCTUREEND1(x, y) public: x() : y {} };
#   define STRUCTUREEND2(x, y, z) public: x() : y, z {} };
#   define STRUCTUREEND3(x, y, z, w) public: x() : y, z, w {} };
#endif

typedef DWORD PROOFVERNO;   // version

  /* Proof Information Structure - return info from ToolVersion */
STRUCTUREBEGIN(PROOFINFO)   // info
    WCHAR           *pwszCopyright; /* pointer to copyright buffer -
                                            can be NULL if size is zero */
    PROOFVERNO  versionAPI;   /* API */
    PROOFVERNO  versionVendor;  /* includes buildnumber */
    VENDORID        vendorid;   /* from vendor.h */
      /* size of copyright buffer in chars - client sets */
    DWORD           cchCopyright;   /* no error if too small or zero */
    DWORD           xcap;   /* tool dependent */
STRUCTUREEND2(PROOFINFO, pwszCopyright(0), cchCopyright(0))

/* xcap is the bitwise-or of */
enum {
    xcapNULL                    =   0x00000000,
    xcapWildCardSupport         =   0x00000001, // Speller only
    xcapMultiLexSupport         =   0x00000002,
    xcapUserLexSupport          =   0x00000008, // a must for spellers
    xcapLongDefSupport          =   0x00000010, // Thesaurus only
    xcapExampleSentenceSupport  =   0x00000020, // Thesaurus only
    xcapLemmaSupport            =   0x00000040, // Thesaurus only
    xcapAnagramSupport          =   0x00000100, // Speller only
};  // xcap

typedef void * PROOFLEX;    // lex

typedef enum {
    lxtChangeOnce=0,
    lxtChangeAlways,
    lxtUser,
    lxtExclude,
    lxtMain,
    lxtMax,
    lxtIgnoreAlways=lxtUser,
} PROOFLEXTYPE; // lxt


  // note this API does not support external user dictionaries with
  // Change (lxtChangeAlways or lxtChangeOnce) properties
  // It does support either UserLex (the norm) or Exclude types
  // Opening a udr with type Exclude automatically makes it apply to
  // the entire session
STRUCTUREBEGIN(PROOFLEXIN)  /* Dictionary Input Info - lxin - all parameters in only */
    const WCHAR     *pwszLex;   // full path of dictionary to open
    BOOL            fCreate;    /* create if not already exist? (UDR's only) */
    PROOFLEXTYPE    lxt;    /* lxtMain, lxtUser, or lxtExclude (Speller UDR's only) */
    LANGID          lidExpected;    // expected LANGID of dictionary
STRUCTUREEND3(PROOFLEXIN, lidExpected(lidUnknown), fCreate(TRUE), lxt(lxtMain))


STRUCTUREBEGIN(PROOFLEXOUT)    /* Dictionary Output Info - lxout */
    WCHAR       *pwszCopyright; /* pointer to copyright buffer (MDR only)
                                        -- can be NULL if size (below) is zero -
								pointer is in, contents out */
    PROOFLEX    lex;            /* [out] id for use in subsequent calls */
    DWORD       cchCopyright;   /* [in] client sets - no error if too small or zero */
    PROOFVERNO  version;        /* [out] version of lexfile - includes buildnumber */
    BOOL        fReadonly;      /* [out] set if can't be written on */
    LANGID      lid;            /* [out] LANGID actually used */
STRUCTUREEND2(PROOFLEXOUT, pwszCopyright(0), cchCopyright(0))

typedef void *PROOFID;  // id (or sid, hid, or tid)

#define PROOFMAJORVERSION(x)            (HIBYTE(HIWORD(x)))
#define PROOFMINORVERSION(x)            (LOBYTE(HIWORD(x)))
#define PROOFMAJORMINORVERSION(x)       (HIWORD(x))
#define PROOFBUILDNO(x)                 (LOWORD(x))
#define PROOFMAKEVERSION1(major, minor, buildno)    (MAKELONG(buildno, MAKEWORD(minor, major)))
#define PROOFMAKEVERSION(major, minor)  PROOFMAKEVERSION1(major, minor, 0)

#define PROOFTHISAPIVERSION             PROOFMAKEVERSION(3, 0)

STRUCTUREBEGIN(PROOFPARAMS) // xpar [in]
    DWORD   versionAPI; // API version requested
STRUCTUREEND1(PROOFPARAMS, versionAPI(PROOFTHISAPIVERSION))



/*************************************************************
     PART 2 - Function Defs
**************************************************************/
#if defined(__cplusplus)
extern "C" {
#endif

/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) --------------

the functions in this section are for documentation only -
separate versions exist for each tool.

  ---------------------------------------------- */
/****************************************************************
*** PROOFVERSION
This is the only routine that can be called outside of a session.
ToolInit begins a session.

The version numbers are in hex format with
the high byte representing the major version number,
the next byte the minor revision number, and the
low order bytes represent an optional build number.
For example, version 1.00 is 0x01000000.  Version 2.13
is 0x020d0000.  Engines that support
this API should return 0x03000000 for iAPIVersion.

The engine ID identifies the core engine creator.  The list
in vendor.h identifies the possible values.  For example,
the Inso derived speller returns VendorIdInso.   iVendorVersion
is up to the vendor to manage and determine.

This routine may return in xcap the functionality
supported by the module.  Since modules are usually
dynamically linked, the application should read the
information and verify that required functionality is
present.
Errors:
    ptecModuleError - bad memory (can't write on pinfo)
**********************************/
// PTEC WINAPI ToolVersion(ToolInfo *pInfo);
typedef PTEC (WINAPI *PROOFVERSION) (PROOFINFO *pinfo);

/***********************************************************
*** ToolInit
This is the entry point for a session.  With the exception
of ToolVersion, this routine must return successfully before
use of any other routines.  ToolInit initializes internal
structures and resources needed for subsequent calls into the
module.  For example, SpellerInit initializes the UserLex,
ChangeOnce, and ChangeAlways built-in UDR's.  In general,
modules allocate and free resources as needed, transparent to
the application.  pToolId is the handle to those variables.
Modules store any data from the PROOFPARAMS structure internally
and do not rely on the data in the structure remaining intact.

Errors:
    ptecModuleError - bad memory (can't write on pxpar)
    ptecNotSupported - incompatible version
    ptecOOM - insufficient memory
*****************************************/
// PTEC WINAPI ToolInit(PROOFID *pToolid, const PROOFPARAMS *pxpar);
typedef PTEC (WINAPI *PROOFINIT) (PROOFID *pid, const PROOFPARAMS *pxpar);


/************************************************************
*** ToolTerminate
This function marks the end of the session.  It attempts to
close all dictionaries and free up any and all other resources
allocated by the module since ToolInit.

Do not call ToolTerminate if  ToolInit was not successful.

If fForce is TRUE, ToolTerminate is guaranteed to succeed.  If
fForce is false, it may fail.  For example, there may be errors
writing the user dictionaries out to disk.  After ToolTerminate
(whether it succeeds or fails), all other module routines with
the exception of ToolTerminate and ToolVersion are unusable
until the module is successfully reinitialized using ToolInit.

If this call fails, successful re-initialization of the module
is not guaranteed on all platforms.  In addition, failure to
successfully terminate each session may lock memory and file
resources in an unrecoverable way until terminate is successful.
If the terminate call fails, the main application should either
fix the problem (e.g., insert floppy in drive) and try to
terminate again, or should terminate using the fForce flag
switch.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
***********************************************/
// PTEC WINAPI ToolTerminate(PROOFID id, BOOL fForce);
typedef PTEC (WINAPI *PROOFTERMINATE) (PROOFID id, BOOL fForce);


/*****************************************************************
*** ToolSetOptions
Set the value of an option for a tool.  The value to set is in iOptVal.

Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecNotSupported    - iOptionSelect unknown
********************************************/
// PTEC WINAPI ToolSetOptions(PROOFID id, int iOptionSelect, int iOptVal);
typedef PTEC (WINAPI *PROOFSETOPTIONS) (PROOFID id, DWORD iOptionSelect, const DWORD iOptVal);


/*****************************************************************
*** ToolGetOptions
Get the current value of an option from a tool.  Returns in *piOptVal;
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError - can't write at piOptVal
    ptecNotSupported    - iOptionSelect unknown
********************************************/
// PTEC WINAPI ToolGetOptions(PROOFID id, int iOptionSelect, int *piOptVal);
typedef PTEC (WINAPI *PROOFGETOPTIONS) (PROOFID id, DWORD iOptionSelect, DWORD *piOptVal);


/*****************************************************************
*** ToolOpenLex
The dictionary file (main or user) is opened and verified, but not
necessarily loaded.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError - memory error
    ptecIOErrorMainLex - Can't open or read Main Lex
    ptecIOErrorMainLex, ptecInvalidFormat
    ptecIOErrorMainLex, ptecInvalidLanguage - requested LANGID not in this lex
    ptecOOM
    ptecIOErrorUserLex, ptecUserLexCountExceeded - second exclusion dictionary
                                                 - too many Udrs
    ptecIOErrorUserLex, ptecFileOpenError
    ptecIOErrorUserLex, ptecFileCreate - couldn't create a UDR
    ptecIOErrorUserLex, ptecFileRead
    ptecIOErrorUserLex, ptecInvalidFormat
********************************************/
// PTEC WINAPI ToolOpenLex(PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);
typedef PTEC (WINAPI *PROOFOPENLEX) (PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);


/*****************************************************************
*** ToolCloseLex
Closes the specified dictionary and disassociates that dictionary
from any subsequent checks.  In the case of user dictionaries,
updates the disk file (if any).  If the dictionary file cannot
be updated, the call fails unless the fForce parameter is also set.

If fForce is true, ToolCloseLex is guaranteed to successfully
remove the dictionary from the dictionary list and effectively
close the file.  In this case, it the file could not be updated,
the changes are lost, but the function is considered successful,
and therefore returns ptecNOERRORS.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError, ptecInvalidMainLex - lex is illegal
    ptecIOErrorUserLex, ptecFileWrite
    ptecIOErrorUserLex, ptecOperNotMatchedUserLex - can't close a built-in UDR
// PTEC WINAPI ToolCloseLex(PROOFID id, PROOFLEX dict, BOOL fforce);
*****************************/
typedef PTEC (WINAPI *PROOFCLOSELEX) (PROOFID id, PROOFLEX lex, BOOL fforce);
// fForce forces closing the specified user dictionary, even if the
// dictionary cannot be updated.  Has no meaning for main
// dictionaries.


/******************************** Special Glue DLL API ******************
For the glue dll's (converts the API for clients to tools that use API v1 for
speller, hyphenator, v2 for thesaurus), we need to set the name of the previous version
DLL to use - and the code page (that it can't figure out from the LANGID)
to use for any data conversion.
The glue dll's use the lid to set the code page for data conversion.

BOOL WINAPI ToolSetDllName(const WCHAR *pwszDllName, const UINT uCodePage);
*************************************************************************/
#define idllProofSetDllName     19
typedef BOOL (WINAPI *PROOFSETDLLNAME)(const WCHAR *pwszDllName, const UINT uCodePage);


#if defined(__cplusplus)
}
#endif
#pragma pack(pop, proofapi_h)   // restore to whatever was before

#endif // PROOFBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\nlglib.h ===
/****************************** Module Header ******************************\
* Module Name: NLGLib.h
*
* Copyright (c) 1997, Microsoft Corporation
*
* History:
1/26/98 DougP   prefix dbgMalloc, dbgFree, and dbgRealloc with CMN_
                whack defs of malloc, free, and realloc
\***************************************************************************/

#ifndef _NLGLIB_H_
#define _NLGLIB_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>      // For the definition of FILE


// Mapped file stuff
//
typedef struct _TAG_MFILE {
    HANDLE hFile;
    HANDLE hFileMap;
    DWORD cbSize1;
    DWORD cbSize2;
    PVOID pvMap;
    BOOL fSrcUnicode;
    BOOL fDstUnicode;
    union {
        WCHAR * pwsz;
        CHAR * psz;
    };
        UINT uCodePage; // codepage for conversions
} MFILE, *PMFILE;

// ----------------------------------------------------------------------
// misc.c
// ----------------------------------------------------------------------
#ifdef _UNICODE
#define OpenMapFile OpenMapFileW
#define OpenDataFile OpenDataFileW
#define OpenOutFile OpenOutFileW
#else
#define OpenMapFile OpenMapFileA
#endif

BOOL WINAPI ResetMap(PMFILE pmf);
BOOL WINAPI CloseMapFile(PMFILE pmf);
PMFILE WINAPI OpenMapFileA(const char *pszFileName);
PVOID WINAPI GetMapLine(PVOID pv0, DWORD cbMac, PMFILE pmf);
BOOL WINAPI NextMapLine(PMFILE pmf);

PMFILE WINAPI OpenMapFileWorker(const WCHAR * pwszFileName, BOOL fDstUnicode);
#define OpenMapFileW(pwszFileName) OpenMapFileWorker(pwszFileName, TRUE)
#define OpenDataFileW(pwszFileName) OpenMapFileWorker(pwszFileName, TRUE)
#define OpenOutFileW(pwszFileName) OpenMapFileWorker(pwszFileName, TRUE)


// Inverse Probability Log (IPL) stuff
//
typedef BYTE IPL;
#define IPL_UNKNOWN     0xFF

// All ipl values must be strictly less than this.
// This corresponds to a probability of 1 in 4 billion, so
// it supports a corpus of 4 billion items (chars, words, sentences, etc.)
//
#define IPL_LIMIT     32

// Multiplier is used to boost precision of low ipls
//
#define IPL_MULTIPLIER      8    // 256 divided by 32 = 8

#define Ipl2Freq( ipl, cTotalFreq)     ((cTotalFreq) >> (ipl))

IPL WINAPI Freq2Ipl( double );

DWORD WINAPI GetCRC32( IN BYTE *pb, IN DWORD cb);
WORD WINAPI GetCRC16( IN BYTE *pb, IN DWORD cb);


// ----------------------------------------------------------------------
// mapsort.c
// ----------------------------------------------------------------------
// Sort and Unique stuff
//
#ifdef _UNICODE
#define MapSort MapSortW
#define MapUnique MapUniqueW
#define Member MemberW
#define RecordString RecordStringW
#else // _UNICODE not defined
#define MapSort MapSortA
#define MapUnique MapUniqueA
#endif // _UNICODE

BOOL WINAPI MapSortW( CONST WCHAR * pszFileName);
BOOL WINAPI MapSortA( CHAR * pszFileName);
BOOL WINAPI MapUniqueW( CONST WCHAR * pwszFileName);
BOOL WINAPI MapUniqueA( CHAR * pszFileName);

// ----------------------------------------------------------------------
// mcodes.c
// ----------------------------------------------------------------------

// WARNING WARNING WARNING
// cpheme creation mode - should be consistent with T-Hammer
#define CPHEME_MODE_STRICT    0x0001
#define CPHEME_MODE_DUPLICATE 0x0002
#define STEM_ATTR_COMPV       0x0010

typedef struct _tagMETABASES {
    WCHAR wcOphemeBase;
    WCHAR wcMinTrieChar;
    WCHAR wcStemBase;
    WCHAR wcFcnBase;
    WCHAR wcSelBase;
} METABASE, *PMETABASE;

// Stem/Morph Code file stuff
//
void WINAPI ReadBases( METABASE *pMetaBases );
void WINAPI WriteBases( METABASE *pMetaBases );

void WINAPI
WriteFcnCodes(
    WCHAR **ppwzMorphs,
    DWORD cMorphs,
    PWORD pwSelections);

void WINAPI
WriteCodesBin(
    CONST WCHAR *pwzFileName,
    WCHAR **ppwzMorphs,
    DWORD cMorphs,
    WCHAR **ppwzAttr1,
    WCHAR **ppwzAttr2,
    PWORD pwAttributes);

BOOL WINAPI
GetCodes(
    WCHAR *wszCodesFile,
    WCHAR **ppwszBuffer,
    WCHAR **ppwszCodes,
    DWORD *pcCodes,
    DWORD cCodesMac);

BOOL WINAPI
GetCodesUnsorted(
    WCHAR *wszCodesFile,
    WCHAR **ppwszBuffer,
    WCHAR **ppwszCodes,
    DWORD *pcCodes,
    DWORD cCodesMac);

BOOL WINAPI
GetCodeAttributes(
    WCHAR *wszCodesFile,
    WCHAR **ppwszCodes,
    DWORD  cCodes,
    WCHAR **ppwszBuffer,
    WCHAR **ppwszAttr1,
    WCHAR **ppwszAttr2,
    WORD *pwAttrFlags);

BOOL WINAPI
LoadMCatMappingTable(
    WCHAR *wszCodesFile,
    WCHAR **ppwszCodes,
    DWORD  cCodes,
    WCHAR **ppwszTBits,
    DWORD  cTBits,
    WORD *pwTBitToMCat,
    WORD *pwSubMToMCat);

BOOL WINAPI
MCatFromTBit(
    DWORD iTBit,
    DWORD *piMCat,
    WORD *pwTBitToMCat,
    DWORD cTBits);

BOOL WINAPI
MCatFromSubM(
    DWORD iSubM,
    DWORD *piMCat,
    WORD *pwSubMToMCat,
    DWORD cCodes);

BOOL WINAPI
EnumSubMFromMCat(
    DWORD iMCat,
    DWORD *piSubM,
    WORD *pwSubMToMCat,
    DWORD cCodes);

// ----------------------------------------------------------------------
// ctplus0.c
// ----------------------------------------------------------------------
// Character type routines
BYTE WINAPI
GetCharType(WCHAR wc );


// ----------------------------------------------------------------------
// fileio.c
// ----------------------------------------------------------------------

// File I/O Wrappers
//
HANDLE WINAPI ThCreate( CONST WCHAR * );
HANDLE WINAPI ThOpen( CONST WCHAR * );
UINT WINAPI ThRead( HANDLE , LPVOID , UINT );
UINT WINAPI ThWrite( HANDLE, LPCVOID , UINT );

// CRT Unicode routines
//
int WINAPI UStrCmp(const WCHAR *pwsz1, const WCHAR *pwsz2);
DWORD WINAPI MemberW(WCHAR * ,WCHAR **, DWORD);
DWORD WINAPI RecordString(WCHAR *, WCHAR **, WCHAR *, DWORD *, DWORD *);
void WINAPI PutLine(const WCHAR *, FILE *);
WCHAR * WINAPI GetLine(WCHAR *, int , FILE *);

#define PrimeHash(wOld, wNew, cBitsMax) (((wOld) + (wNew))*hashPrime[cBitsMax]&hashMask[cBitsMax])


extern const unsigned int hashPrime[];
extern const unsigned int hashMask[];

// #include "ctplus0.h"

//-----------------------------------------------------------+
// memory allocation:
// In the debug version, we compile in the debugging memory
// allocator and aim our allocation macros at it.
// In retail, the macros just use LocalAlloc
//-----------------------------------------------------------+
#if defined(_DEBUG)
    void    * WINAPI dbgMalloc(size_t cb);
    void    * WINAPI dbgCalloc(size_t c, size_t cb);
    void    * WINAPI dbgFree(void* pv);
    void    * WINAPI dbgRealloc(void* pv, size_t cb);
    void    * WINAPI dbgMallocCore(size_t cb, BOOL fTrackUsage);
    void    * WINAPI dbgFreeCore(void* pv, BOOL fTrackUsage);
    void    * WINAPI dbgReallocCore(void* pv, size_t cb, BOOL fTrackUsage);

    #if 0
        #define malloc  dbgMalloc
        #define free    dbgFree
        #define realloc dbgRealloc
        #define calloc  dbgCalloc
    #endif

    //DWORD WINAPI     dbGlobalSize(HANDLE);
    //HANDLE WINAPI   dbGlobalAlloc(UINT, DWORD);
    //HANDLE WINAPI   dbGlobalFree(HANDLE);
    //HANDLE WINAPI   dbGlobalReAlloc(HANDLE, DWORD, UINT);
    #if defined(ENABLE_DBG_HANDLES)
        HANDLE WINAPI   dbGlobalHandle(LPCVOID);
        BOOL WINAPI      dbGlobalUnlock(HANDLE);
        LPVOID WINAPI    dbGlobalLock(HANDLE);
    #endif // ENABLE_DBG_HANDLES

    #define dbHeapInit InitDebugMem
      // it is a good idea (essential if you're MT) to call these before any mem allocs
    void WINAPI InitDebugMem(void);
      // and this after all mem allocs
    BOOL WINAPI FiniDebugMem(void);  // returns true if not all memory released

    // these are alternative entrypoints
    BOOL    WINAPI fNLGNewMemory( PVOID *ppv, ULONG cbSize);
    DWORD   WINAPI NLGMemorySize(PVOID pvMem);
    BOOL    WINAPI fNLGResizeMemory(PVOID *ppv, ULONG cbNew);
    VOID    WINAPI NLGFreeMemory(PVOID pv);
    BOOL    WINAPI fNLGHeapDestroy( VOID );
#else // NOT (DEBUG)
    #define InitDebugMem()  ((void)0)
    #define FiniDebugMem() (FALSE)

    #define dbgMalloc(cb)   LocalAlloc( LMEM_FIXED, cb )
    void    * WINAPI dbgCalloc(size_t c, size_t cb);
    #define dbgFree(pv)     LocalFree( pv )
    #define dbgRealloc(pv, cb)  LocalReAlloc(pv, cb, LMEM_MOVEABLE)

    #define fNLGHeapDestroy( )          TRUE
    // When fNLGNewMemory fails the passed in ptr will be side-effected to NULL
    #define fNLGNewMemory( ppv, cbSize) ((*(ppv) = LocalAlloc( LMEM_FIXED, cbSize )) != NULL)
    #define NLGFreeMemory( pv)          LocalFree( pv )

#endif //  (DEBUG)


/*************************************************
    Lexical Table functions
        implementation in lextable.c
*************************************************/
#define Lex_UpperFlag             0x01         /* upper case */
#define Lex_LowerFlag             0x02         /* lower case */
#define Lex_DigitFlag             0x04         /* decimal digits */
#define Lex_SpaceFlag             0x08         /* spacing characters */
#define Lex_PunctFlag             0x10         /* punctuation characters */
#define Lex_ControlFlag             0x20         /* control characters */
#define Lex_LexiconFlag 0x40
#define Lex_VowelFlag 0x80
#define NTRANSTAB 256

extern const BYTE Lex_rgchKey[NTRANSTAB];
extern const BYTE Lex_rgFlags[NTRANSTAB];
#define INUPPERPAGES(ch) (ch & 0xff00)  // this is the same as ch > 0x00ff

// don't count on any of the above constants - use these functions below

// The speller uses this to make equivalent classes
WCHAR WINAPI fwcUpperKey(const WCHAR wc);
BOOL WINAPI IsUpperPunct(const WCHAR ch);
__inline WCHAR WINAPI CMN_Key(const WCHAR ch)
{
#if defined(_VIET_)
	// When we are ready for merge we should add these data to core Lex_rgFlgas.
	if (INUPPERPAGES(ch))
	{
		if ( (ch == 0x0102) ||
		     (ch == 0x0110) ||
			 (ch == 0x01A0) ||
			 (ch == 0x01AF) )
		{
			return (ch + 1);
		}
		return fwcUpperKey(ch);
	}
	else if ( (ch == 0x00D0) )				// This seem very weird that we map it like this in NT.
	{
		return 0x0111;
	}
	else if ( (ch == 0x00C3) )
	{
		return 0x0103;
	}
	else if ( (ch == 0x00D5) )
	{
		return 0x01A1;
	}
	else if ( (ch == 0x00DD) )
	{
		return 0x01B0;
	}
	else if ( (ch == 0x00D4) ||
			  (ch == 0x00CA) ||
			  (ch == 0x00C2) )
	{
		return (ch + 0x0020);
	}
	else if ( (ch == 0x00f4) ||				// These are special case there are no key that should map to these characters.
			  (ch == 0x00ea) ||
			  (ch == 0x00e2) )
	{
		return ch;
	}
	else
	{
		return ((WCHAR) Lex_rgchKey[(UCHAR) ch]);
	}

#else
    return (WCHAR) (INUPPERPAGES(ch) ?
                    fwcUpperKey(ch) :
                    (WCHAR) Lex_rgchKey[(UCHAR) ch]);
#endif
}
__inline BOOL WINAPI CMN_IsCharUpperW(WCHAR ch)
{
#if defined(_VIET_)
	// When we are ready for merge we should add these data to core Lex_rgFlgas.
	if ( (ch == 0x0111) ||
	     (ch == 0x0103) ||
		 (ch == 0x01A1) ||
		 (ch == 0x01B0) )
	{
		return FALSE;
	}
	else if ( (ch == 0x0102) ||
			  (ch == 0x0110) ||
			  (ch == 0x01A0) ||
			  (ch == 0x01AF) ||
			  (ch == 0x00D4) ||
			  (ch == 0x00CA) ||
			  (ch == 0x00D0) ||
			  (ch == 0x00C3) ||
			  (ch == 0x00D5) ||
			  (ch == 0x00DD) ||
			  (ch == 0x00C2) )
	{
		return TRUE;
	}
	else if (INUPPERPAGES(ch))
	{
		return FALSE;
	}
	else
	{
		return Lex_rgFlags[(UCHAR) ch] & Lex_UpperFlag;
	}

#else
    return INUPPERPAGES(ch) ? FALSE : Lex_rgFlags[(UCHAR) ch] & Lex_UpperFlag;
#endif
}
__inline BOOL WINAPI CMN_IsCharLowerW(WCHAR ch)
{
#if defined(_VIET_)
	// When we are ready for merge we should add these data to core Lex_rgFlgas.
	if ( (ch == 0x0111) ||
	     (ch == 0x0103) ||
		 (ch == 0x01A1) ||
		 (ch == 0x01B0) )
	{
		return TRUE;
	}
	else if ( (ch == 0x0102) ||
			  (ch == 0x0110) ||
			  (ch == 0x01A0) ||
			  (ch == 0x01AF) ||
			  (ch == 0x00D4) ||
			  (ch == 0x00CA) ||
			  (ch == 0x00D0) ||
			  (ch == 0x00C3) ||
			  (ch == 0x00D5) ||
			  (ch == 0x00DD) ||
			  (ch == 0x00C2) )
	{
		return FALSE;
	}
	else if (INUPPERPAGES(ch))
	{
		return FALSE;
	}
	else
	{
		return Lex_rgFlags[(UCHAR) ch] & Lex_LowerFlag;
	}
#else
    return INUPPERPAGES(ch) ? FALSE : Lex_rgFlags[(UCHAR) ch] & Lex_LowerFlag;
#endif
}
__inline BOOL WINAPI CMN_IsCharAlphaW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? !IsUpperPunct(ch) : Lex_rgFlags[(UCHAR) ch] & (Lex_LowerFlag | Lex_UpperFlag);
}
__inline BOOL WINAPI CMN_IsCharAlphaNumericW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? !IsUpperPunct(ch) : Lex_rgFlags[(UCHAR) ch] & (Lex_LowerFlag | Lex_UpperFlag | Lex_DigitFlag);
}
__inline BOOL WINAPI CMN_IsCharDigitW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? FALSE : Lex_rgFlags[(UCHAR) ch] & Lex_DigitFlag;
}
__inline BOOL WINAPI CMN_IsCharStrictDigitW(WCHAR ch)
{     // only allows digits 0-9 - no superscripts, no fractions
    return (
        INUPPERPAGES(ch) ?
            FALSE :
            (Lex_rgFlags[(UCHAR) ch] & (Lex_DigitFlag | Lex_PunctFlag)) ==
                    Lex_DigitFlag
    );
}
BOOL WINAPI IsUpperSpace(WCHAR ch);
__inline BOOL WINAPI CMN_IsCharSpaceW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        IsUpperSpace(ch) :
        Lex_rgFlags[(UCHAR) ch] & Lex_SpaceFlag;
}
__inline BOOL WINAPI CMN_IsCharPunctW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? IsUpperPunct(ch) : Lex_rgFlags[(UCHAR) ch] & Lex_PunctFlag;
}
__inline BOOL WINAPI CMN_IsCharPrintW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        !CMN_IsCharSpaceW(ch) :
        Lex_rgFlags[(UCHAR) ch] &
            (Lex_PunctFlag | Lex_UpperFlag | Lex_LowerFlag | Lex_DigitFlag);
}
__inline BOOL WINAPI CMN_IsCharInLexiconW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        (!IsUpperPunct(ch) || ch == 0x2019 || ch == 0x2018) :
        Lex_rgFlags[(UCHAR) ch] & Lex_LexiconFlag;
}
__inline BOOL WINAPI CMN_IsCharVowelW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? FALSE : Lex_rgFlags[(UCHAR) ch] & Lex_VowelFlag;
}
__inline BOOL WINAPI CMN_IsCharGraphW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        TRUE :
        Lex_rgFlags[(UCHAR) ch] &
            (Lex_LowerFlag |
                Lex_UpperFlag |
                Lex_DigitFlag |
                Lex_PunctFlag);
}

  // Some punctuation flags
#define Lex_PunctLead             0x01         /* leading punctuation */
#define Lex_PunctJoin             0x02         /* joining punctuation */
#define Lex_PunctTrail            0x04         /* trailing punctuation */
    // reuse Lex_SpaceFlag here
extern const BYTE Lex_rgPunctFlags[NTRANSTAB];
__inline BOOL WINAPI CMN_IsLeadPunctW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        (ch == 0x201c || ch == 0x2018) :
        (Lex_rgPunctFlags[(UCHAR) ch] & Lex_PunctLead);
}
__inline BOOL WINAPI CMN_IsJoinPunctW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? FALSE : Lex_rgPunctFlags[(UCHAR) ch] & Lex_PunctJoin;
}
__inline BOOL WINAPI CMN_IsTrailPunctW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        (ch == 0x201d || ch == 0x2019) :
        (Lex_rgPunctFlags[(UCHAR) ch] & Lex_PunctTrail);
}
BOOL WINAPI IsUpperWordDelim(WCHAR ch);
__inline BOOL WINAPI CMN_IsCharWordDelimW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        IsUpperWordDelim(ch) :
        Lex_rgPunctFlags[(UCHAR) ch] & Lex_SpaceFlag;
}

  // implementation in lexfuncs.c
WCHAR WINAPI CMN_CharUpperW(const WCHAR ch);
WCHAR WINAPI CMN_CharLowerW(const WCHAR ch);
BOOL WINAPI CMN_IsStringEqualNoCaseW(const WCHAR *pwz1, const WCHAR *pwz2);
BOOL WINAPI CMN_IsStringEqualNoCaseNumW(const WCHAR *pwz1, const WCHAR *pwz2, int cch);
DWORD WINAPI CMN_CharUpperBuffW(WCHAR *pwz, DWORD cchLength);
DWORD WINAPI CMN_CharLowerBuffW(WCHAR *pwz, DWORD cchLength);
int WINAPI CMN_CompareStringNoCaseW(const WCHAR *pwz1, const WCHAR *pwz2);
int WINAPI CMN_CompareStringNoCaseNumW(const WCHAR *pwz1, const WCHAR *pwz2, int cch);
  // note that this version does not set errno on errors
long WINAPI CMN_wcstol( const wchar_t *nptr, const wchar_t * *endptr, int base );

__inline int WINAPI CMN_wtoi( const wchar_t *string )
{
    return CMN_wcstol(string, NULL, 10);
}

__inline wchar_t * WINAPI CMN_wcsupr( wchar_t *string )
{
    CMN_CharUpperBuffW(string, wcslen(string));
    return string;
}

__inline wchar_t * WINAPI CMN_wcslwr( wchar_t *string )
{
    CMN_CharLowerBuffW(string, wcslen(string));
    return string;
}


////////////////////
// debug.c
/////////////////////
#if defined(_DEBUG)

extern void WINAPI DebugAssert(LPCTSTR, LPCTSTR, UINT);
extern void WINAPI SetAssertOptions(DWORD);

#else // _DEBUG

#define DebugAssert(a, b, c)
#define SetAssertOptions(a)

#endif // _DEBUG defined

/****************************************************************

  These are versions of some WINAPI functions that normally don't work
  on win95 with Unicode (not supported).  They have the same arguments
  as the API functions

    If UNICODE is not defined, they become the A versions
    If UNICODE is defined and x86, they become our W version
    If UNICODE is defined and not x86, they become API W version

****************************************************************/

#include <sys/stat.h>   // this needs to be before the redefs we do below
#include <stdlib.h>     // as does this

  // want to do these substitutions regardless
#define IsCharLowerW        CMN_IsCharLowerW
#define IsCharUpperW        CMN_IsCharUpperW
#define IsCharAlphaW        CMN_IsCharAlphaW
#define IsCharAlphaNumericW CMN_IsCharAlphaNumericW
#define CharUpperBuffW      CMN_CharUpperBuffW
#define CharLowerBuffW      CMN_CharLowerBuffW
#define _wcsicmp            CMN_CompareStringNoCaseW
#define _wcsnicmp           CMN_CompareStringNoCaseNumW
#define towupper            CMN_CharUpperW
#define towlower            CMN_CharLowerW
#define wcstol              CMN_wcstol
#define _wtoi               CMN_wtoi
#define _wcsupr             CMN_wcsupr
#define _wcslwr             CMN_wcslwr

#undef iswdigit
#define iswdigit            CMN_IsCharDigitW
#undef iswspace
#define iswspace            CMN_IsCharSpaceW
#undef iswpunct
#define iswpunct            CMN_IsCharPunctW
#undef iswprint
#define iswprint            CMN_IsCharPrintW
#undef iswalpha
#define iswalpha            CMN_IsCharAlphaW
#undef iswalnum
#define iswalnum            CMN_IsCharAlphaNumericW
#undef iswgraph
#define iswgraph            CMN_IsCharGraphW
#undef iswupper
#define iswupper            CMN_IsCharUpperW
#undef iswlower
#define iswlower            CMN_IsCharLowerW

  // function defs for our versions
int WINAPI CMN_LoadStringW(HINSTANCE hModule, UINT uiId, WCHAR * wszString, int cchStringMax);
int WINAPI CMN_LoadStringWEx(HINSTANCE hModule, UINT uiId, WCHAR * wszString, int cchStringMax, LANGID lid);

  // these two functions replace the associated RTL functions - however
  // they can't be just replaced - as they use a third argument to maintain state
  // instead of static variables within the function.
  // Use these the same as the RTL functions, but declare TCHAR *pnexttoken before use
  // and pass its address as the third parameter
wchar_t * WINAPI CMN_wcstok (wchar_t * string, const wchar_t * control, wchar_t **pnextoken);
char * WINAPI CMN_strtok (char * string, const char * control, char **pnextoken);
#if defined(UNICODE)
#define CMN_tcstok CMN_wcstok
#else
#define CMN_tcstok CMN_strtok
#endif

#if defined(_M_IX86) && !defined(WINCE) && !defined(NTONLY)
#define CreateFileW         CMN_CreateFileW
#define LoadLibraryW        CMN_LoadLibraryW
#define GetModuleFileNameW  CMN_GetModuleFileNameW
#define GetFileAttributesW  CMN_GetFileAttributesW
  // FindResourceW works in win95
  // as does FindResourceExW

//#define PostMessageW        ERR_Does_not_work_in_w95    // no easy replacement for this one
#define FindWindowW         ERR_No_w95_equiv_yet

#define lstrcpynW           CMN_lstrcpynW
#define lstrcatW            CMN_lstrcatW
#define lstrcmpiW           CMN_lstrcmpiW
#define lstrcpyW            CMN_lstrcpyW
#define lstrlenW            CMN_lstrlenW
#define lstrcmpW            CMN_lstrcmpW
#define wsprintfW           swprintf
#define _wstat              CMN_wstat

#define CharNextW           CMN_CharNextW

#define LoadStringW         CMN_LoadStringW
#define _wfopen             CMN_wfopen

HANDLE WINAPI
CMN_CreateFileW (
    PCWSTR pwzFileName,  // pointer to name of the file
    DWORD dwDesiredAccess,  // access (read-write) mode
    DWORD dwShareMode,  // share mode
    LPSECURITY_ATTRIBUTES pSecurityAttributes, // pointer to security descriptor
    DWORD dwCreationDistribution,   // how to create
    DWORD dwFlagsAndAttributes, // file attributes
    HANDLE hTemplateFile);    // handle to file with attributes to copy

HINSTANCE WINAPI CMN_LoadLibraryW(const WCHAR *pwszLibraryFileName);

DWORD WINAPI CMN_GetModuleFileNameW( HINSTANCE hModule,  // handle to module to find filename for
    WCHAR *lpFilename,  // pointer to buffer to receive module path
    DWORD nSize);  // size of buffer, in characters

DWORD WINAPI CMN_GetFileAttributesW(const WCHAR *lpFileName); // address of the name of a file or directory

// note: Even though WINAPI returns WCHAR *, I define this as returning void
void WINAPI CMN_lstrcpynW( WCHAR *lpString1, // address of target buffer
                const WCHAR *lpString2, // address of source string
                int iMaxLength);  // number of bytes or characters to copy

#define CMN_lstrcmpiW _wcsicmp    // just use c-runtime for now
#define CMN_lstrcpyW wcscpy
#define CMN_lstrcatW    wcscat
#define CMN_lstrlenW(pwz)    ((int) wcslen(pwz))
#define CMN_lstrcmpW        wcscmp

#define CMN_CharNextW(pwz)  (pwz + 1)

FILE *WINAPI CMN_wfopen(const WCHAR *pwzFileName, const WCHAR *pwzUnimode);
int WINAPI CMN_wstat(const WCHAR *pwzPath, struct _stat *pStatBuffer);


#else   // there is no win95 - and it must be NT
#define CMN_CreateFileW         CreateFileW
#define CMN_LoadLibraryW        LoadLibraryW
#define CMN_GetModuleFileNameW  GetModuleFileNameW
#define CMN_GetFileAttributesW  GetFileAttributesW
#define CMN_lstrcpynW           lstrcpynW
#define CMN_lstrcmpiW           lstrcmpiW
#define CMN_lstrcpyW            lstrcpyW
#define CMN_lstrcatW            lstrcatW
#define CMN_lstrcmpW            lstrcmpW
#define CMN_wfopen              _wfopen
#define CMN_wstat               _wstat
#define CMN_CharNextW           CharNextW
#endif

  // Outputs Readable Error String to the Debug Output
#if defined (_DEBUG)
        void WINAPI CMN_OutputSystemErrA(const char *pszMsg, const char *pszComponent);
        void WINAPI CMN_OutputSystemErrW(const WCHAR *pwzMsg, const WCHAR *pwzComponent);
        void WINAPI CMN_OutputErrA(DWORD dwErr, const char *pszMsg, const char *pszComponent);
        void WINAPI CMN_OutputErrW(DWORD dwErr, const WCHAR *pwzMsg, const WCHAR *pwzComponent);
#       if defined (UNICODE)
#               define CMN_OutputSystemErr CMN_OutputSystemErrW
#               define CMN_OutputErr CMN_OutputErrW
#       else
#               define CMN_OutputSystemErr CMN_OutputSystemErrA
#               define CMN_OutputErr CMN_OutputErrA
#       endif
#else   //!_DEBUG
#       define CMN_OutputSystemErr(x, y)
#       define CMN_OutputSystemErrA(x, y)
#       define CMN_OutputSystemErrW(x, y)
#       define CMN_OutputErr(n, x, y)
#       define CMN_OutputErrA(n, x, y)
#       define CMN_OutputErrW(n, x, y)
#endif

///////////////////////
// LexWin95.c
///////////////////////

#define LoadLibraryW2A CMN_LoadLibraryW
#define CreateFileW2A CMN_CreateFileW

// Add anything new here, within the extern "C" clause

#ifdef __cplusplus
}       // ends the extern "C" clause

  // here's some C++ specific stuff
inline BOOL IsMapFileUnicode(PMFILE pmf, BOOL fDefault=TRUE)
{
    if (pmf->hFileMap)
            return pmf->fSrcUnicode;
      // must be zero length, set and return default
    return pmf->fSrcUnicode = fDefault;
}
inline void MapFileCodePage(PMFILE pmf, UINT uCP)
{
        pmf->uCodePage = uCP;
}

#if defined(CPPMEMORY)
inline void * _cdecl operator new (size_t size)
{
#if defined(DEBUG)
    return dbgMalloc(size);
#else
    return LocalAlloc( LMEM_FIXED, size );
#endif
}

inline void _cdecl operator delete(void *pMem)
{
    if (!pMem)
        return;
#if defined(DEBUG)
    dbgFree(pMem);
#else
    LocalFree(pMem);
#endif
}
#endif // CPPMEMORY


#endif // __cplusplus


#endif // _NLGLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\thwbint.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Thai WordBreak
//
//  Thai WordBreak Interface Header File.
//
//  History:
//      created 5/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "thwbint.h"
#include "lexheader.h"
#include "trie.h"
//#include "NLGlib.h"
#include "ProofBase.h"
#include "ctrie.hpp"
#include "cthwb.hpp"
#include "thwbdef.hpp"

HINSTANCE g_hInst;

static PTEC retcode(int mjr, int mnr) { return MAKELONG(mjr, mnr); }
#define lidThai 0x41e

// class trie.
//CTrie trie;

// class CThaiWordBreak
CThaiWordBreak* thaiWordBreak = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   ThaiWordBreakInit
//
//  Synopsis:   Initialize Thai Word Break - initialize variables of Thai Word Break.
//
//  Arguments:  szFileName - contain the path of the word list lexicon.
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
#if defined (NGRAM_ENABLE)
PTEC WINAPI ThaiWordBreakInit(const WCHAR* szFileName, const WCHAR* szFileNameSentStruct, const WCHAR* szFileNameTrigram)
#else
PTEC WINAPI ThaiWordBreakInit(const WCHAR* szFileName, const WCHAR* szFileNameTrigram)
#endif
{
	if (thaiWordBreak == NULL)
		{
		thaiWordBreak = new CThaiWordBreak;
		if (thaiWordBreak == NULL)
			return retcode(ptecIOErrorMainLex, ptecFileRead);
		}

#if defined (NGRAM_ENABL