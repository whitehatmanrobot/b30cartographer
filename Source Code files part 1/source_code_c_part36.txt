            szCurPos = APICharNext(szCurPos);
                if(*szCurPos == chDirSep)
                        szDirSepPos = szCurPos;
        }
        if(!szDirSepPos)
                return !NOERROR;

        *((ICHAR* )rgchNewDir + (szDirSepPos - szPackage)) = 0;

        // NOTE: we do not bother with getting and setting the current directory

        HINSTANCE hInst;
        PDllRegister fpEntry;
        HRESULT hResult;

        hResult = OLE::CoInitialize(0); // While perhaps not strictly necessary, regsrvr32 appears to do this,
                                                                 // and some DLLs expect it
		if ( hResult != S_OK )
			return hResult;

        bool fError = false;
        if( (hInst = WIN::LoadLibraryEx(szPackage, NULL, LOAD_WITH_ALTERED_SEARCH_PATH)) == 0 )
                fError = true;
        else if ( WIN::SetCurrentDirectory(rgchNewDir) == 0 )
                fError = true;
        if ( fError )
                hResult = HRESULT_FROM_WIN32(WIN::GetLastError());

        // At this point we don't want to have an impersonation token; we want to use our process token
        if (!WIN::SetThreadToken(0, 0))
			hResult = HRESULT_FROM_WIN32(WIN::GetLastError());

        if (S_OK == hResult)
        {
                if ((fpEntry = (PDllRegister)WIN::GetProcAddress(hInst, szFn)) == 0)
                {
                        hResult = HRESULT_FROM_WIN32(WIN::GetLastError());
                }
                else
                {
                        hResult = (*fpEntry)();
                }
        }
        if(hInst)
                WIN::FreeLibrary(hInst);

        OLE::CoUninitialize();
        return hResult;
}

int SelfReg(const ICHAR* /*szModifier*/, const ICHAR* szPackage)
{
        return SelfRegOrUnreg(szPackage, szDllRegisterServer);
}

int SelfUnreg(const ICHAR* /*szModifier*/, const ICHAR* szPackage)
{
        return SelfRegOrUnreg(szPackage, szDllUnregisterServer);
}

static char g_rgchMIFName[10] = {0};
static char g_rgchMIFMessage[256] = {0}; // error message
static char g_rgchMIFCompany[128] = {0}; // vendor name
static char g_rgchMIFProduct [64] = {0}; // product code
static char g_rgchMIFVersion[128] = {0}; // product name and version
static char g_rgchMIFLocale  [64] = {0}; // language (and platform)

int WINAPI UIHandlerMIF(LPVOID /*pvContext*/, UINT /*iMessageType*/, LPCSTR szMessage)
{
        if (szMessage)  // ignore extraneous messages
                lstrcpynA(g_rgchMIFMessage, szMessage, sizeof(g_rgchMIFMessage));
        return 0;  // return no action to allow normal error handling
}

int RequestMIF(const ICHAR* /*szModifier*/, const ICHAR* szFile)
{
        g_rgchMIFMessage[0] = 0;
        g_rgchMIFCompany[0] = 0;
        g_rgchMIFProduct[0] = 0;
        g_rgchMIFVersion[0] = 0;
        g_rgchMIFLocale [0] = 0;
        if (szFile && *szFile)  // ignore if no file given
        {
#ifdef UNICODE
                BOOL fDefaultUsed;
                int cb = WideCharToMultiByte(CP_ACP, 0, szFile, -1, g_rgchMIFName, 8 + 1, 0, &fDefaultUsed);
                if (!cb || fDefaultUsed)
                        return 1;
#else
                if (lstrlen(szFile) > 8)
                        return 1;
                StringCchCopy(g_rgchMIFName, ARRAY_ELEMENTS(g_rgchMIFName), szFile);
#endif
                MsiSetExternalUIA(UIHandlerMIF, INSTALLLOGMODE_FATALEXIT | INSTALLLOGMODE_ERROR, 0);
                g_fStatusMIF = true;
        }
        return 0;
}

void ConfigureMIF(const ICHAR* szPackage)
{
        PMSIHANDLE hSumInfo;
        if (szPackage && *szPackage && MsiGetSummaryInformation(0, szPackage, 0, &hSumInfo) == NOERROR)
        {
                UINT iType;
                DWORD cchBuf;
				// Initialize globals so that we do not reuse something from a previous install.
				g_rgchMIFCompany[0] = g_rgchMIFProduct[0] = g_rgchMIFVersion[0] = g_rgchMIFLocale[0] = 0;
                cchBuf = sizeof(g_rgchMIFCompany);  MsiSummaryInfoGetPropertyA(hSumInfo, PID_AUTHOR,    &iType, 0, 0, g_rgchMIFCompany, &cchBuf);
                cchBuf = sizeof(g_rgchMIFProduct);  MsiSummaryInfoGetPropertyA(hSumInfo, PID_REVNUMBER, &iType, 0, 0, g_rgchMIFProduct, &cchBuf);
                cchBuf = sizeof(g_rgchMIFVersion);  MsiSummaryInfoGetPropertyA(hSumInfo, PID_SUBJECT,   &iType, 0, 0, g_rgchMIFVersion, &cchBuf);
                cchBuf = sizeof(g_rgchMIFLocale);   MsiSummaryInfoGetPropertyA(hSumInfo, PID_TEMPLATE,  &iType, 0, 0, g_rgchMIFLocale,  &cchBuf);
        }
        else if (szPackage)  // could not open package, just log package path
#ifdef UNICODE
                WideCharToMultiByte(CP_ACP, 0, szPackage, -1, g_rgchMIFProduct, sizeof(g_rgchMIFProduct), 0, 0);
#else
                lstrcpyn(g_rgchMIFProduct, szPackage, sizeof(g_rgchMIFProduct));
#endif
}

typedef DWORD (WINAPI *T_InstallStatusMIF)(char* szFileName, char* szCompany, char* szProduct, char* szVersion, char* szLocale, char* szSerialNo, char* szMessage, BOOL bStatus);

void GenerateMIF(UINT iStatus)
{
        MsiSetExternalUIA(0, 0, 0);  // cancel message filter, probably not necessary as the process will be ending
        g_fStatusMIF = false;        // reset MIF request flag in case some future code makes more MSI calls rather than exit

        //According to John Delo, this is only called client side, so no harm is done
        //if a user copy is loaded.
        HINSTANCE hInstMIF = WIN::LoadLibraryEx(TEXT("ISMIF32.DLL"), NULL, 0);
        if (!hInstMIF)
                return;  // no failure if DLL not present, simply indicates that SMS not present
        T_InstallStatusMIF F_InstallStatusMIF = (T_InstallStatusMIF)WIN::GetProcAddress(hInstMIF, "InstallStatusMIF");
        AssertSz(F_InstallStatusMIF, "Missing entry point in ISMIF32.DLL");
        if (F_InstallStatusMIF)
        {
                char* szSerialNo= 0;          // product serial number - not available
                DWORD cchBuf;
                BOOL bStat;
                if (iStatus == ERROR_SUCCESS || iStatus == ERROR_INSTALL_SUSPEND ||
                         iStatus == ERROR_SUCCESS_REBOOT_REQUIRED || iStatus == ERROR_SUCCESS_REBOOT_INITIATED)
                {
                        bStat = TRUE;
                        g_rgchMIFMessage[0] = 0;  // cancel any non-fatal error message
                }
                else
                {
                        bStat = FALSE;
                        if (g_rgchMIFMessage[0] == 0)  // no message captured by error filter
                        {
                                LANGID langid = WIN::GetSystemDefaultLangID();  // prefer system language over user's for MIF file
                                if (iStatus < ERROR_INSTALL_SERVICE_FAILURE  // not an MSI error, don't load other MSI string resources
                                 || 0 == MsiLoadStringA((HINSTANCE)-1, iStatus, g_rgchMIFMessage, sizeof(g_rgchMIFMessage), langid))  // no MSI resource string
                                {
                                        cchBuf = WIN::FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, iStatus, langid, g_rgchMIFMessage, sizeof(g_rgchMIFMessage), 0);
                                        if (cchBuf)
                                                g_rgchMIFMessage[cchBuf-2] = 0; // found in system message file, remove CR/LF
                                        else
                                                StringCchPrintfA(g_rgchMIFMessage, ARRAY_ELEMENTS(g_rgchMIFMessage),
                                                                "Installer error %i", iStatus);
                                }
                        }
                }
                AssertNonZero(TRUE == (*F_InstallStatusMIF)(g_rgchMIFName, g_rgchMIFCompany, g_rgchMIFProduct, g_rgchMIFVersion, g_rgchMIFLocale, szSerialNo, g_rgchMIFMessage, bStat));
        }
        WIN::FreeLibrary(hInstMIF);
}

HRESULT __stdcall RegisterProxyInfo()
{
        if (!g_hKernel)
                g_hKernel = WIN::LoadLibrary(MSI_KERNEL_NAME);

        if (!g_hKernel)
                return SELFREG_E_CLASS;

        PDllRegister fpEntry;
        fpEntry = (PDllRegister)WIN::GetProcAddress(g_hKernel, szDllRegisterServer);
        HRESULT hr = fpEntry ? (*fpEntry)() : !NOERROR;

        return hr;
}

#include "clibs.h"

void * operator new(size_t cb)
{

        return GlobalAlloc(GMEM_FIXED, cb);

}

void operator delete(void *pv)
{
        if (pv == 0)
                return;

        GlobalFree(pv);

}



//----------------------------------------------------------------------
// FIsOwnerSystemOrAdmin -- return whether owner sid is a LocalSystem
//  sid or Admin sid
//
bool FIsOwnerSystemOrAdmin(PSECURITY_DESCRIPTOR rgchSD)
{
	// grab owner SID from the security descriptor
	DWORD dwRet;
	PSID psidOwner;
	BOOL fDefaulted;
	if (!GetSecurityDescriptorOwner(rgchSD, &psidOwner, &fDefaulted))
	{
		ReportErrorToDebugOutput(TEXT("FIsOwnerSystemOrAdmin: Unable to get owner SID from security descriptor."), GetLastError());
		return false;
	}

	// if there is no owner, it is not owned by system or admin
	if (!psidOwner)
		return false;

	// compare SID to system & admin
	char* psidLocalSystem;
	if (ERROR_SUCCESS != (dwRet = GetLocalSystemSID(&psidLocalSystem)))
	{
		ReportErrorToDebugOutput(TEXT("FIsOwnerSystemOrAdmin: Cannot obtain local system SID."), dwRet);
		return false; // error can't get system sid
	}
	if (0 == EqualSid(psidOwner, psidLocalSystem))
	{
		// not owned by system, (continue by checking Admin)
		char* psidAdmin;
		if (ERROR_SUCCESS != (dwRet = GetAdminSID(&psidAdmin)))
		{
			ReportErrorToDebugOutput(TEXT("FIsOwnerSystemOrAdmin: Cannot obtain local system SID."), dwRet);
			return false; // error can't get admin sid
		}

		// check for admin ownership
		if (0 == EqualSid(psidOwner, psidAdmin))
			return false; // don't TRUST! neither admin or system
	}
	return true;
}

bool FIsKeyLocalSystemOrAdminOwned(HKEY hKey)
{
	// reading just the owner doesn't take very much space
	CAPITempBuffer<char, 64> rgchSD;
	DWORD cbSD = 64;
	LONG dwRet = WIN::RegGetKeySecurity(hKey, OWNER_SECURITY_INFORMATION, (PSECURITY_DESCRIPTOR)rgchSD, &cbSD);
	if (ERROR_SUCCESS != dwRet)
	{
		if (ERROR_INSUFFICIENT_BUFFER == dwRet)
		{
			if (!rgchSD.SetSize(cbSD))
				return false;
			dwRet = WIN::RegGetKeySecurity(hKey, OWNER_SECURITY_INFORMATION, (PSECURITY_DESCRIPTOR)rgchSD, &cbSD);
		}

		if (ERROR_SUCCESS != dwRet)
		{
			ReportErrorToDebugOutput(TEXT("FIsKeyLocalSystemOrAdminOwned: Could not get owner security info."), dwRet);
			return false;
		}
	}

	return FIsOwnerSystemOrAdmin(rgchSD);
}


bool PurgeUserOwnedSubkeys(HKEY hKey)
{
	// enumerate all subkeys and check that ownership = system or admin
	DWORD dwRes;
	DWORD dwIndex = 0;
	CTempBuffer<ICHAR, MAX_PATH+1>szSubKey;
	DWORD cSubKey = szSubKey.GetSize();
	while (ERROR_SUCCESS == (dwRes = RegEnumKey(hKey, dwIndex, szSubKey, cSubKey)))
	{
		HKEY hEnumKey;
		// Win64: called only from PurgeUserOwnedInstallerKeys and this deals w/
		// configuration data.
		if (ERROR_SUCCESS != (dwRes = MsiRegOpen64bitKey(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hEnumKey)))
		{
			CAPITempBuffer<ICHAR, cchMaxStringCchPrintf+1>szError;
			StringCchPrintf(szError, szError.GetSize(), TEXT("PurgeUserOwnedSubkeys: Could not open subkey: %s"), static_cast<ICHAR*>(szSubKey));
			ReportErrorToDebugOutput(szError, dwRes);
			return false;
		}
		if (!FIsKeyLocalSystemOrAdminOwned(hEnumKey))
		{
			// delete key + subkeys (will be re-created later on next install)
			// key is not owned by system or admin!
			CTempBuffer<ICHAR, cchMaxStringCchPrintf+1>szErr;
			StringCchPrintf(szErr, szErr.GetSize(), TEXT("PurgeUserOwnedSubkeys: %s not owned by System or Admin. Deleting key + subkeys.\n"), static_cast<ICHAR*>(szSubKey));
			ReportErrorToDebugOutput(szErr, 0);

			// delete key + subkeys
			// Win64 WARNING: FDeleteRegTree will delete subkeys only in the 64-bit hive
			if (!FDeleteRegTree(hKey, szSubKey))
			{
				ReportErrorToDebugOutput(TEXT("PurgeUserOwnedSubkeys: Could not delete SubKey tree."), 0);
				return false;
			}
		}
		else
			dwIndex++;
		RegCloseKey(hEnumKey);
	}
	if (ERROR_NO_MORE_ITEMS != dwRes)
	{
		ReportErrorToDebugOutput(TEXT("PurgeUserOwnedSubkeys: Could not enumerate subkeys."), dwRes);
		return false;
	}
	return true;
}

bool PurgeUserOwnedInstallerKeys(HKEY hRoot, TCHAR* szKey)
{
	UINT dwRes = 0;
	HKEY hKey = 0;
	if (ERROR_SUCCESS != (dwRes = MsiRegOpen64bitKey(hRoot, szKey, 0, KEY_ALL_ACCESS, &hKey)))
	{
		if (ERROR_FILE_NOT_FOUND != dwRes)
		{
			CAPITempBuffer<ICHAR, cchMaxStringCchPrintf+1>szError;
			StringCchPrintf(szError, szError.GetSize(), TEXT("PurgeUserOwnedInstallerKeys: Could not open key '%s'"), szKey);
			ReportErrorToDebugOutput(szError, dwRes);
			return false;
		}
	}
	else
	{
		if (!FIsKeyLocalSystemOrAdminOwned(hKey))
		{
			// key is not owned by system or admin!
			CAPITempBuffer<ICHAR, cchMaxStringCchPrintf+1>szError;
			StringCchPrintf(szError, szError.GetSize(), TEXT("PurgeUserOwnedInstallerKeys: Key '%s' not owned by System or Admin. Deleting key + subkeys.\n"), szKey);
			ReportErrorToDebugOutput(szError, 0);

			// delete key + subkeys
			// Win64 WARNING: FDeleteRegTree will delete subkeys only in the 64-bit hive
			if (!FDeleteRegTree(hRoot, szKey))
			{
				ReportErrorToDebugOutput(TEXT("PurgeUserOwnedInstallerKeys: Could not delete tree."), 0);
				return false;
			}
		}
		// Win64 WARNING: PurgeUserOwnedSubkeys will delete subkeys only in the 64-bit hive
		else if (!PurgeUserOwnedSubkeys(hKey))
			return false;
		RegCloseKey(hKey);
	}
	return true;
}

SERVICE_STATUS          g_ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   g_sshStatusHandle;

bool g_fWeWantToStop = false;

bool SetInstallerACLs();

void ReportErrorToDebugOutput(const ICHAR* szMessage, DWORD dwError)
{
	// only output if debugging policy set
	static int s_dmDiagnosticMode = -1;
	if (-1 == s_dmDiagnosticMode)
	{
		// disable initially
		s_dmDiagnosticMode = 0;

		// check for Debug policy in our policy key
		HKEY hPolicyKey = 0;
		// Win64: I've checked and it's in a 64-bit location.
		if (ERROR_SUCCESS == MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szPolicyKey, 0, KEY_READ, &hPolicyKey))
		{
			CAPITempBuffer<ICHAR, 40> rgchValue;
			DWORD cbBuf = rgchValue.GetSize() * sizeof(ICHAR);
			LONG lResult = RegQueryValueEx(hPolicyKey, szDebugValueName, 0, 0, (LPBYTE)&rgchValue[0], &cbBuf);
			// 40 characters should be more than enough. So if the call fails, we ignore it.
			if (ERROR_SUCCESS == lResult)
			{
				unsigned int uiValue = *(unsigned int*)(const ICHAR*)rgchValue;
				s_dmDiagnosticMode = uiValue & (dmDebugOutput|dmVerboseDebugOutput);
			}
			RegCloseKey(hPolicyKey);
		}
	}

	if (0 == (s_dmDiagnosticMode & (dmDebugOutput|dmVerboseDebugOutput)))
		return; // no debug output warranted

	// StringCchPrintf limited to 1024 *bytes* (eugend: MSDN says so, but it turned out that in Unicode it's 1024 chars)
	ICHAR szBuf[cchMaxStringCchPrintf+1];
	if (dwError)
		StringCchPrintf(szBuf, ARRAY_ELEMENTS(szBuf), TEXT("Error: %d. %s.\r\n"), dwError, szMessage);
	else
		StringCchPrintf(szBuf, ARRAY_ELEMENTS(szBuf), TEXT("%s"), szMessage);

	OutputDebugString(szBuf);
}


bool RunningOnWow64()
{
#if defined(_WIN64) || ! defined(UNICODE)
	// 64bit builds don't run in Wow64
	return false;
#else

	// this never changes, so cache the results for efficiency
	static int iWow64 = -1;
	if (iWow64 != -1)
		return (iWow64 ? true : false);

	// OS version
	OSVERSIONINFO osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	AssertNonZero(GetVersionEx(&osviVersion)); // fails only if size set wrong

	// on NT5 or later 32bit build. Check for 64 bit OS
	if ((osviVersion.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
		 (osviVersion.dwMajorVersion >= 5))
	{
		// QueryInformation for ProcessWow64Information returns a pointer to the Wow Info.
		// if running native, it returns NULL.
		PVOID Wow64Info = 0;
		if (NT_SUCCESS(NTDLL::NtQueryInformationProcess(GetCurrentProcess(), ProcessWow64Information, &Wow64Info, sizeof(Wow64Info), NULL)) &&
			Wow64Info != NULL)
		{
			// running 32bit on Wow64.
			iWow64 = 1;
			return true;
		}
	}
	iWow64 = 0;
	return false;
#endif
}


bool ServiceSupported()
/*---------------------------------------------------------------------------
Returns fTrue if the OS supports services, fFalse otherwise. Currently true
only for NT4.0
---------------------------------------------------------------------------*/
{
	// OS version
	OSVERSIONINFO osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	AssertNonZero(GetVersionEx(&osviVersion)); // fails only if size set wrong

	if ((osviVersion.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
		 (osviVersion.dwMajorVersion >= 4))
	{
		// if running on wow64, service is not supported
		return !RunningOnWow64();
	}
	else
	{
		return false;
	}
}

bool FInstallInProgress()
{
	typedef HRESULT (__stdcall *PfnDllCanUnloadNow)();
	HINSTANCE hKernel = WIN::LoadLibrary(MSI_KERNEL_NAME);
	Assert(hKernel);
	PfnDllCanUnloadNow pfn = (PfnDllCanUnloadNow)WIN::GetProcAddress(hKernel, "DllCanUnloadNow");
	Assert(pfn);
	if (pfn)
	{
		HRESULT hRes = pfn();
		if (S_OK == hRes)
			return false;
	}
	WIN::FreeLibrary(hKernel);
	return true;
}


HRESULT RegisterShellData()
{
	//
	// Note: 32-bit builds on Win64 builds also need to register shell data.
	// This is because anything which is not already registered via the
	// hivecls.inx file is registered here. Since msiexec /regserver runs during
	// GUI mode setup when registry redirection is not active, we want the 32-bit
	// msiexec to explicitly do the remaining registrations.
	//

	// GetModuleFileName does not guarantee null termination if buffer is exactly the right size
	szRegFilePath[ARRAY_ELEMENTS(szRegFilePath)-1] = TEXT('\0');
	if (WIN::GetModuleFileName(g_hInstance, szRegFilePath, ARRAY_ELEMENTS(szRegFilePath)-1) == 0)
		return WIN::GetLastError();
	szRegFilePath[ARRAY_ELEMENTS(szRegFilePath)-1] = TEXT('\0');

	int cErr = 0;
	const ICHAR** psz = rgszRegShellData;
	while (*(psz+1))
	{
		ICHAR szFormattedData[cchMaxStringCchPrintf+1];
		if (*psz++ == 0) // not remove-only data
		{
			const ICHAR* szTemplate = *psz++;
			const ICHAR* szArg1 = *psz++;
			const ICHAR* szArg2 = *psz++;
			if (szArg2)
				StringCchPrintf(szFormattedData, ARRAY_ELEMENTS(szFormattedData), szTemplate, szArg1, szArg2);
			else
				StringCchPrintf(szFormattedData, ARRAY_ELEMENTS(szFormattedData), szTemplate, szArg1);
			HKEY hkey;
			if (RegCreateKeyAPI(HKEY_CLASSES_ROOT, szFormattedData, 0, 0, 0,
											KEY_READ|KEY_WRITE, 0, &hkey, 0) != ERROR_SUCCESS)
				cErr++;

			if (*psz) // skip value-less entries
			{
				szTemplate = *psz++;
				StringCchPrintf(szFormattedData, ARRAY_ELEMENTS(szFormattedData), szTemplate, *psz++);
				if (REG::RegSetValueEx(hkey, 0, 0, REG_SZ, (CONST BYTE*)szFormattedData, (lstrlen(szFormattedData)+1)*sizeof(ICHAR)) != ERROR_SUCCESS)
					cErr++;
			}
			else
			{
				psz += 2;
			}

			REG::RegCloseKey(hkey);
		}
		else
		{
			psz += 5;
		}
	}
	//
	// The SHCNF_FLUSH flag is *absolutely* necessary here. See comments above
	// similar SHChangeNotify call in UnregisterShellData() below for details
	// on why it is so crucial.
	//
	SHELL32::SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST | SHCNF_FLUSH, 0,0);
	return cErr ? E_FAIL : NOERROR;
}

HRESULT UnregisterShellData()
{

	//
	// Since the 32-bit msiexec also does its own registration on Win64
	// we need to do the same for unregistering the information. For reasons
	// on why the 32-bit msiexec needs to do its own registration on Win64,
	// see the comments at the beginning of RegisterShellData()
	//
	int cErr = 0;
	const ICHAR** psz = rgszRegShellData;
	while (*++psz)
	{
		ICHAR szFormattedData[cchMaxStringCchPrintf+1];
		const ICHAR* szTemplate = *psz++;
		const ICHAR* szArg1 = *psz++;
		const ICHAR* szArg2 = *psz++;
		if (szArg2)
			StringCchPrintf(szFormattedData, ARRAY_ELEMENTS(szFormattedData), szTemplate, szArg1, szArg2);
		else
			StringCchPrintf(szFormattedData, ARRAY_ELEMENTS(szFormattedData), szTemplate, szArg1);

		// NT won't delete a key with subkeys, but 9x will.  This standardizes our behavior
		HKEY hDeadKey = 0;
		if (ERROR_SUCCESS == RegOpenKeyAPI(HKEY_CLASSES_ROOT, szFormattedData, 0, KEY_ENUMERATE_SUB_KEYS | STANDARD_RIGHTS_WRITE,  &hDeadKey))
		{
			if (ERROR_NO_MORE_ITEMS == RegEnumKey(hDeadKey, 0, szFormattedData, 80))
			{
				long lResult = REG::RegDeleteKey(hDeadKey, TEXT(""));
				/* //!! ignore failure until we determine the correct behavior.
				if((ERROR_KEY_DELETED != lResult) &&
					(ERROR_FILE_NOT_FOUND != lResult) && (ERROR_SUCCESS != lResult))
					cErr++;
				*/
			}
			RegCloseKey(hDeadKey), hDeadKey=0;
		}
		psz++;
		psz++;

	}
	
	//
	// The SHCNF_FLUSH flag is *absolutely* necessary here.
	//
	// We need the SHCNF_FLUSH flag here because mshtml.dll that shipped with
	// IE5.5 and IE5.5 SP1 has a bug because of which if the SHCNE_ASSOCCHANGED
	// event is sent in quick succession and mshtml.dll happens to be loaded in
	// explorer (say if you have a folder open with web view on), then explorer
	// AVs (on Win2K). This will happen when someone does a msiexec /regserver 
	// since it results in an UnregisterShellData followed by a RegisterShellData. 
	// Since this happens during msiexec /regserver, an AV happens whenever one
	// tries to install a newer version of MSI on to Win2K. (see bug 416074 for
	// more details) Adding the SHCNF_FLUSH flag ensures that this call does not 
	// return until the notification events are delivered to all recepients. This
	// changes the timing in such a way that mshtml no longer AVs.
	//
	SHELL32::SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST | SHCNF_FLUSH, 0,0);
	return cErr ? E_FAIL : NOERROR;
}


//____________________________________________________________________________
//
// EXE server command line processing
//____________________________________________________________________________

DWORD g_rghRegClass[CLSID_COUNT];

extern HANDLE g_hShutdownTimer;

// This should be called when g_cInstances changes
void ReportInstanceCountChange()
{
	if (g_fAutomation && !g_cInstances)
		WIN::PostQuitMessage(0); // terminate message loop

#ifdef SERVICE_NAME
	ReportStatusToSCMgr(g_ssStatus.dwCurrentState, 0, 0, 0);
#endif
}

void DisplayError(const DWORD dwError);

HRESULT RegisterNoService()
/*---------------------------------------------------------------------------
Unregisters any current registration and then registers us as an EXE server
-----------------------------------------------------------------------------*/
{
	g_fRegService = fFalse;
	OLE::CoInitialize(0);
	HRESULT hRes = DllUnregisterServer();
	if (hRes == NOERROR)
	{
		if (ServiceSupported())
		{
			DWORD dwError = RemoveService();
			if (dwError && 
				dwError != ERROR_SERVICE_DOES_NOT_EXIST &&
				dwError != ERROR_SERVICE_MARKED_FOR_DELETE)
				hRes = dwError;
		}
	}

	if (hRes == NOERROR)
		hRes = UnregisterShellData();

	if (hRes == NOERROR)
		hRes = DllRegisterServer();

	if (hRes == NOERROR)
		hRes = RegisterShellData();

	OLE::CoUninitialize();
	return hRes;
}

HRESULT RegisterServer(Bool fCustom)
/*---------------------------------------------------------------------------
Unregisters any current registration and then registers us as an NT service
if possible, and an EXE server otherwise
-----------------------------------------------------------------------------*/
{
	g_fRegService = fTrue;
	OLE::CoInitialize(0);
	HRESULT hRes = DllUnregisterServer();

	if (hRes == NOERROR)
	{
		if (ServiceSupported())
		{
			DWORD dwError = 0;
			if (!fCustom)
			{
				dwError = RemoveService();
			}
			if (dwError && 
				dwError != ERROR_SERVICE_DOES_NOT_EXIST &&
				dwError != ERROR_SERVICE_MARKED_FOR_DELETE)
				hRes = dwError;
		}
	}

	if (hRes == NOERROR)
		hRes = UnregisterShellData();

	if (hRes == NOERROR)
	{
		hRes = DllRegisterServer();
		if (ServiceSupported())
		{
			DWORD dwError = 0;
			if (!fCustom)
				dwError = InstallService();
			if (dwError)
				hRes = dwError;
		}
	}

	if (hRes == NOERROR)
		hRes = RegisterShellData();

	OLE::CoUninitialize();
	return hRes;
}


HRESULT Unregister()
/*---------------------------------------------------------------------------
Unregisters any current registration.
-----------------------------------------------------------------------------*/
{
	OLE::CoInitialize(0);
	HRESULT hRes = DllUnregisterServer();
	if (hRes == NOERROR)
		hRes = UnregisterShellData();

	if (hRes == NOERROR)
	{
		if (ServiceSupported())
		{
			DWORD dwError = RemoveService();
			if (dwError && 
				dwError != ERROR_SERVICE_DOES_NOT_EXIST &&
				dwError != ERROR_SERVICE_MARKED_FOR_DELETE)
				hRes = dwError;
		}
	}

	OLE::CoUninitialize();
	return hRes;
}

const ICHAR rgchNewLine[] = {'\n', '\r'};
HANDLE g_hStdOut = 0;

#define LOCALE_RETURN_NUMBER          0x20000000   // return number instead of string

void DisplayError(const DWORD dwError)
/*---------------------------------------------------------------------------
Puts up a message box if stdout is not available, otherwise writes to
stdout.
-----------------------------------------------------------------------------*/
{
	ICHAR rgchBuffer[cchMaxStringCchPrintf+1] = {0};
	UINT iCodepage;
	LANGID iLangId = 0;
	if (dwError < ERROR_INSTALL_SERVICE_FAILURE  // not an MSI error, don't load other MSI string resources
	 || 0 == (iCodepage = MsiLoadString((HINSTANCE)-1, dwError, rgchBuffer, ARRAY_ELEMENTS(rgchBuffer), 0)))
	{
		iCodepage = WIN::GetACP(); // correct for Win9X and NT4, but NT5 may change message file language
#ifdef UNICODE
		HINSTANCE hLib = WIN::LoadLibrary(TEXT("KERNEL32"));
		FARPROC pfEntry = WIN::GetProcAddress(hLib, "GetUserDefaultUILanguage");  // NT5 only
		if (pfEntry)
		{
			iLangId = (LANGID)(*pfEntry)();
			ICHAR rgchBuf[10];
			if (0 != WIN::GetLocaleInfo(iLangId, LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER, rgchBuf, sizeof(rgchBuf)/sizeof(*rgchBuf)))
				iCodepage = *(int*)(rgchBuf);
		}
#endif
		DWORD cchMsg = WIN::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, dwError, iLangId, rgchBuffer, ARRAY_ELEMENTS(rgchBuffer), 0);
		if (cchMsg != 0)  // message found in system message file
			rgchBuffer[cchMsg-2] = 0; // remove CR/LF
		else
			StringCchPrintf(rgchBuffer, ARRAY_ELEMENTS(rgchBuffer), TEXT("Install error %i"), dwError);
	}
	if (!g_fQuiet && (g_hStdOut == 0 || g_hStdOut == INVALID_HANDLE_VALUE))
	{
#ifdef SERVICE_NAME
		MsiMessageBox(0, rgchBuffer, 0, MB_OK | MB_ICONEXCLAMATION, iCodepage, 0);
#else //!! is this possible?
		WIN::MessageBox(0, rgchBuffer, szCaption, MB_OK);
#endif
		return;
	}
	if (g_hStdOut != 0 && g_hStdOut != INVALID_HANDLE_VALUE) 
	{
		unsigned long cWritten;
		WIN::WriteFile(g_hStdOut, rgchBuffer, IStrLen(rgchBuffer) * sizeof(ICHAR), &cWritten, 0);
		WIN::WriteFile(g_hStdOut, rgchNewLine, sizeof (rgchNewLine), &cWritten, 0);
	}
}

extern const ICHAR COMMAND_OPTIONS[];
extern CommandProcessor COMMAND_FUNCTIONS[];
extern int Properties(const ICHAR* /*unused*/, const ICHAR* szProperty);

extern int SetProductToPatch(ICHAR chInstallType, const ICHAR* szProduct);

const int cchMaxOptionModifier = 30;
const int cchMaxParameter = 1024;

const ICHAR* g_pchOption = 0;

//
// These routines below return only the
// first byte for two byte characters
// Luckily that's ok given how they are currently used
ICHAR SkipWhiteSpace(const ICHAR*& rpch)
{
	ICHAR ch;
	for (; (ch = *rpch) == ' ' || ch == '\t'; rpch++)
		;
	return ch;
}

ICHAR ParseUnQuotedToken(const ICHAR*& rszCommandLine, ICHAR*& rszToken)
{
	const ICHAR* pchStart = rszCommandLine;
	ICHAR ch = *rszCommandLine;
	while (ch != 0 && ch != ' ' && ch != '\t')
	{
		rszCommandLine = INextChar(rszCommandLine);
		ch = *rszCommandLine;
	}

	INT_PTR cch = rszCommandLine - pchStart;                            //--merced: changed int to INT_PTR
	memcpy(rszToken, pchStart, (unsigned int)cch * sizeof(ICHAR));      //--merced: added (unsigned int)
	rszToken += cch;
	return ch;
}

ICHAR ParseQuotedToken(const ICHAR*& rszCommandLine, ICHAR*& rszToken)
// upon entry, rszCommandLine should point to the opening quotes ('"')
// upon return, rszCommandLine will point to the first character after
//  the closing quotes, or to the null terminator if there was no
//  closing quotes. rszToken will contain the quoted token (w/o the quotes)
{
	ICHAR ch;
	const ICHAR* pchStart;
	unsigned int cch;

	rszCommandLine = ICharNext(rszCommandLine);
	pchStart = rszCommandLine;
	while ((ch = *rszCommandLine) != '\"' && *rszCommandLine != 0)
	{
		if (ch == '\\')
		{
			if (*(rszCommandLine+1) == '`') // \` => `
			{
				ch = '`';
				Assert((rszCommandLine - pchStart) < UINT_MAX);     //--merced: 64-bit ptr subtraction may lead to values too big for cch
				cch = (unsigned int)(rszCommandLine - pchStart);    //--merced: added (unsigned int)
				memcpy(rszToken, pchStart, cch * sizeof(ICHAR));
				rszToken += cch;
				*rszToken++ = ch;
				rszCommandLine++;
				pchStart = rszCommandLine+1;
			}
		}
		else if (ch == '`') //  ` => "
		{
			ch = '\"';
			Assert((rszCommandLine - pchStart) < UINT_MAX);         //--merced: 64-bit ptr subtraction may lead to values too big for cch
			cch = (unsigned int) (rszCommandLine - pchStart);       //--merced: added (unsigned int)
			memcpy(rszToken, pchStart, cch * sizeof(ICHAR));
			rszToken += cch;
			*rszToken++ = ch;
			pchStart = rszCommandLine + 1;
		}

		rszCommandLine = ICharNext(rszCommandLine);
	}

	Assert((rszCommandLine - pchStart) < UINT_MAX);                 //--merced: 64-bit ptr subtraction may lead to values too big for cch
	cch = (unsigned int) (rszCommandLine - pchStart);               //--merced: added (unsigned int)
	memcpy(rszToken, pchStart, cch * sizeof(ICHAR));
	rszToken += cch;

	if (*rszCommandLine == '\"')
		ch = *(++rszCommandLine);

	return ch;
}

ICHAR ParseValue(const ICHAR*& rszCommandLine, ICHAR*& rszToken)
{
	ICHAR ch = *rszCommandLine;
	if (ch == '\"')
	{
		ch = ParseQuotedToken(rszCommandLine, rszToken);
	}
	else if (ch != '/' && ch != '-') // the option has an associated value
	{
		ch = ParseUnQuotedToken(rszCommandLine, rszToken);
	}
	return ch;
}

Bool ParseProperty(const ICHAR*& rszCommandLine, CTempBufferRef<ICHAR>& rszToken)
{
	// Multibyte friendly, except for the call to SkipWhiteSpace
	const ICHAR* pchSeparator = rszCommandLine;

	// an additional catch on properties.  Prevents bad things like:
	//  "Property=Value Property=Value" which would current get
	// read as the first property name starts with a quote.
	if ((*rszCommandLine != TEXT('%')) && !IsCharAlphaNumeric(*rszCommandLine))
		return fFalse;

	while (*pchSeparator && (' ' != *pchSeparator) && ('=' != *pchSeparator))
		pchSeparator = INextChar(pchSeparator);
	if ('='!= *pchSeparator)
		return fFalse;

	else
	{
		const ICHAR* pchStart = ICharNext(pchSeparator);
		const ICHAR* pchEnd = pchStart;
		ICHAR chStop = ' ';
		Bool fQuote = fFalse;

		if ('\"' == *pchStart)
		{
			chStop = '\"';
			fQuote = fTrue;
			pchEnd = ICharNext(pchEnd);
		}
		// read to the first space, or EOS
		while (*pchEnd)
		{
			if (chStop == *pchEnd)
			{
				if (fQuote)
				{
					ICHAR* pchSkip = ICharNext(pchEnd);
					if (chStop == *pchSkip)
						pchEnd = pchSkip;
					else break;
				}
				else break;
			}
			pchEnd = ICharNext(pchEnd);

		}

		// check for space or EOS at end
		if (*pchEnd && (chStop != *pchEnd))
			return fFalse;


		if (fQuote)
			pchEnd = ICharNext(pchEnd);

		if ( unsigned int(pchEnd - rszCommandLine) + 1 > INT_MAX )
		{
			ReportErrorToDebugOutput(TEXT("Property value is too long.\r\n"), 0);
			return fFalse;
		}
		else
		{
			int cch = int(pchEnd - rszCommandLine) + 1;
			if ( rszToken.GetSize() < cch )
			{
				rszToken.SetSize(cch);
				if ( !(ICHAR*)rszToken )
					return fFalse;
			}
			lstrcpyn(rszToken, rszCommandLine, cch);
			pchEnd = ICharNext(pchEnd);
			rszCommandLine = pchEnd;
			return fTrue;
		}
	}

}

#ifdef CA_CLSID
// this is a simplied version of the copy in the engine, but is not designed
// to be as robust when called from WinLogon or via an API. It is critical
// that the service register itself with CoRegisterClassObject(), otherwise
// somebody could spoof the service and play man-in-the-middle on us. There 
// is no support for retry, because the service must always be running by
// the time a CA server is created.
static IMsiServer* CreateMsiServerProxyForCAServer()
{
	IMsiServer* piUnknown;
	HRESULT hRes;
	if ((hRes = OLE32::CoCreateInstance(IID_IMsiServer, 0, CLSCTX_LOCAL_SERVER, IID_IUnknown,
										  (void**)&piUnknown)) != NOERROR)
	{
		ICHAR rgchBuf[100];
		StringCchPrintf(rgchBuf, ARRAY_ELEMENTS(rgchBuf), TEXT("Failed to connect to server. Error: 0x%X"), hRes);
		ReportErrorToDebugOutput(rgchBuf, 0); // error included in message
		return 0;
	}
	IMsiServer *piServer = 0;
	piUnknown->QueryInterface(IID_IMsiServer, (void**)&piServer);
	piUnknown->Release();
	if (!piServer)
		return 0;
	return piServer;
}
#endif

extern CAPITempBuffer<ICHAR, cchMaxCommandLine> g_szCommandLine;
extern CAPITempBuffer<ICHAR, cchMaxCommandLine> g_szTransforms;
IUnknown* CreateCustomActionServer();

/*---------------------------------------------------------------------------
	_XcptFilter

	Filter function that calls UnhandleExceptionFilter when an exception
	occurs. This is what gets Just in Time debugging working on NT - in
	most apps this function is provided by the C runtime but since we
	don't link to it, we provide our own filter.
----------------------------------------------------------------- SHAMIKB -*/
int __cdecl _XcptFilter(unsigned long, struct _EXCEPTION_POINTERS *pXcpt)
{
	return UnhandledExceptionFilter ( pXcpt );
}

int ServerMain(HINSTANCE hInstance)
{
	ICHAR  rgchOptionValue[cchMaxParameter];
	ICHAR  rgchOptionModifier[cchMaxOptionModifier];

	GetVersionInfo (NULL, NULL, NULL, NULL, &g_fWinNT64);

	g_szCommandLine[0] = 0;
	g_szTransforms[0] = 0;

	// alternative cmd line if being run from RunOnce key
	CAPITempBuffer<ICHAR, MAX_PATH> rgchRunOnceCmdLine;

	ICHAR* szCmdLine = GetCommandLine(); //!! need to skip program name -- watch out for "
#ifdef DEBUG
	// leave some extra space for the extra stuff below.
	CTempBuffer<ICHAR, 1024 + 128> rgchDebugBuf;
	int cchLength = lstrlen(szCmdLine);
	if (cchLength > 1024)
		rgchDebugBuf.SetSize(cchLength + 128);

	Bool fTooLong = fFalse;

	if (cchLength > (cchMaxStringCchPrintf - 23))
	{
		fTooLong = fTrue;
		ReportErrorToDebugOutput(TEXT("Warning:  display of command line truncated.\r\n"), 0);
	}
//                                                                      1         2
//                                                             12345678901234567890123
	StringCchPrintf(rgchDebugBuf, rgchDebugBuf.GetSize(), TEXT("MSIEXEC: Command-line: %s\r\n"), szCmdLine);
	ReportErrorToDebugOutput(rgchDebugBuf, 0);
	if (fTooLong)
		ReportErrorToDebugOutput(TEXT("\r\n"), 0);
#endif

	// skip program name -- handle quoted long file name correctly
	ICHAR chStop;
	if (*szCmdLine == '\"')
	{
		chStop = '\"';
		szCmdLine++;
	}
	else
		chStop = ' ';

	while (*szCmdLine && *szCmdLine != chStop)
		szCmdLine = INextChar(szCmdLine);

	if (*szCmdLine)
		szCmdLine = INextChar(szCmdLine);

	g_hInstance = hInstance;
	g_hStdOut = WIN::GetStdHandle(STD_OUTPUT_HANDLE);
	if (g_hStdOut == INVALID_HANDLE_VALUE || ::GetFileType(g_hStdOut) == 0)
		g_hStdOut = 0;  // non-zero if stdout redirected or piped

	int iReturnStatus;
	Bool fClassRegistrationFailed = fFalse;
	Bool fLocalServer = fFalse;

	#ifdef MODULE_INITIALIZE //!! Is this the right place for this?
			MODULE_INITIALIZE();
	#endif

	// parse command line
	iReturnStatus = 0;
	int ch;
	int chOption;
	chOption = 0;
	ICHAR rgchOptionParam1[cchMaxParameter] = {TEXT("")};
	ICHAR rgchOptionParam2[cchMaxParameter] = {TEXT("")};
	ICHAR* pszOptionValue = rgchOptionParam1;
	ICHAR* pszOptionModifier = rgchOptionParam2;
	ICHAR* pch;
	fLocalServer = fFalse;
	g_fCustomActionServer = fFalse;

	int cOptions = 0;
	Bool fModifier;
	while ((ch = *szCmdLine) == ' ' || ch == '\t') // eat whitespace
		szCmdLine++;

	// when we are run from RunOnce, the command line options are stored in a seperate registry value
	// since the max length of a RunOnce command is only 256
	if(szCmdLine   && (*szCmdLine == '/' || *szCmdLine == '-') &&
		szCmdLine+1 && (*(szCmdLine+1) | 0x20) == (CHECKRUNONCE_OPTION | 0x20))
	{
		szCmdLine += 2;
		ch = SkipWhiteSpace(szCmdLine);

		pch = rgchOptionParam1;
		ch = ParseValue(szCmdLine, pch);

		HKEY hKey;
		DWORD cchBuf = rgchRunOnceCmdLine.GetSize()*sizeof(ICHAR);
		DWORD dwType = REG_NONE;

		LONG lResult = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szMsiRunOnceEntriesKey, 0, KEY_READ, &hKey);

		if(lResult == ERROR_SUCCESS)
		{
			lResult = WIN::RegQueryValueEx(hKey, (ICHAR*)rgchOptionParam1, 0, &dwType, (LPBYTE)(ICHAR*)rgchRunOnceCmdLine, &cchBuf);

			if(lResult == ERROR_MORE_DATA)
			{
				rgchRunOnceCmdLine.SetSize(cchBuf/sizeof(ICHAR));
				lResult = WIN::RegQueryValueEx(hKey, (ICHAR*)rgchOptionParam1, 0, &dwType, (LPBYTE)(ICHAR*)rgchRunOnceCmdLine, &cchBuf);
			}

			WIN::RegCloseKey(hKey);
		}

		if(lResult != ERROR_SUCCESS || dwType != REG_SZ)
		{
#ifdef DEBUG
			StringCchPrintf(rgchDebugBuf, rgchDebugBuf.GetSize(), TEXT("MSIEXEC: No command line in RunOnceEntries key, value: '%s'. Exiting...\r\n"), (ICHAR*)rgchOptionParam1);
			ReportErrorToDebugOutput(rgchDebugBuf, 0);
#endif //DEBUG
			return 0; // no command line to run - just return with no error
		}

		// switch to new command line
		szCmdLine = (ICHAR*)rgchRunOnceCmdLine;
		while ((ch = *szCmdLine) == ' ' || ch == '\t') // eat whitespace
			szCmdLine++;

#ifdef DEBUG
		StringCchPrintf(rgchDebugBuf, rgchDebugBuf.GetSize(), TEXT("MSIEXEC: Switching to command line from RunOnceEntries key, value: '%s'.\r\n"), (ICHAR*)rgchOptionParam1);
		ReportErrorToDebugOutput(rgchDebugBuf, 0);

		cchLength = lstrlen(szCmdLine);
		if (cchLength > 1024)
			rgchDebugBuf.SetSize(cchLength + 128);

		fTooLong = fFalse;

		if (cchLength > (cchMaxStringCchPrintf - 23))
		{
			fTooLong = fTrue;
			ReportErrorToDebugOutput(TEXT("Warning:  display of command line truncated.\r\n"), 0);
		}
//                                                                         1         2
//                                                                12345678901234567890123
		StringCchPrintf(rgchDebugBuf, rgchDebugBuf.GetSize(), TEXT("MSIEXEC: Command-line: %s\r\n"), szCmdLine);
		ReportErrorToDebugOutput(rgchDebugBuf, 0);
		if (fTooLong)
			ReportErrorToDebugOutput(TEXT("\r\n"), 0);
#endif //DEBUG
	}

	while (ch != 0)
	{
		if (ch != '/' && ch != '-') // no switch
		{
			// possibly a property...
			CTempBuffer<ICHAR, MAX_PATH> rgchPropertyAndValue;
			if (!ParseProperty(szCmdLine, rgchPropertyAndValue))
			{
				DisplayHelp();
				iReturnStatus = ERROR_INVALID_COMMAND_LINE;
				break;
			}
			else
			{
				// Note:  This is now the only acceptable place to recognize
				// properties from the command line.  The /o option is being
				// disabled as of 06/01/98
				Properties(pszOptionModifier, rgchPropertyAndValue);
				ch = SkipWhiteSpace(szCmdLine);
			}
		}
		else // switch found
		{
			szCmdLine++; // skip switch
			chOption = *szCmdLine | 0x20; // make lower case
			szCmdLine = ICharNext(szCmdLine);
			for (const ICHAR* pchOptions = COMMAND_OPTIONS; *pchOptions; pchOptions++)
				if ((*pchOptions | 0x20) == chOption)
					break;

			if (*pchOptions == 0) // couldn't find the option letter
			{
				DisplayHelp();
				iReturnStatus = ERROR_INVALID_COMMAND_LINE;
				break;
			}
			else // found the option letter
			{
				if ((*szCmdLine != ' ') && (*szCmdLine != 0) && (*szCmdLine != '\t'))
					fModifier = fTrue;
				else
					fModifier = fFalse;

				ch = SkipWhiteSpace(szCmdLine);

				pch = rgchOptionParam1;

				// ADVERTISE_INSTANCE_OPTION has zero arguments, no modifiers allowed
				if (*pchOptions == ADVERTISE_INSTANCE_OPTION && fModifier)
				{
					DisplayHelp();
					iReturnStatus = ERROR_INVALID_COMMAND_LINE;
					break;
				}

				// QUIET_OPTION and ADVERTISE_INSTANCE_OPTION are the only ones that allow zero arguments
				if (((*pchOptions != QUIET_OPTION && *pchOptions != ADVERTISE_INSTANCE_OPTION) || fModifier))
					ch = ParseValue(szCmdLine, pch);

				ch = SkipWhiteSpace(szCmdLine);

				*pch = 0;

				if ((*pchOptions == REPAIR_PACKAGE_OPTION) ||
					 (*pchOptions == QUIET_OPTION) ||
					 (*pchOptions == ADVERTISE_PACKAGE_OPTION) ||
					 (*pchOptions == LOG_OPTION))
				{
					if (fModifier)
					{
						pch = rgchOptionParam2;
						pszOptionModifier = rgchOptionParam1;
						pszOptionValue = rgchOptionParam2;

						if (*pchOptions != QUIET_OPTION)
						{
							// second argument
							ch = ParseValue(szCmdLine, pch);
							ch = SkipWhiteSpace(szCmdLine);
							*pch= 0;
						}
					}
				}


				if ((*pchOptions < 'a') || (*pchOptions > 'z'))    // 'action' option
				{
					if (g_pchOption) // we already found an 'action' option
					{
						if(*pchOptions == APPLY_PATCH_OPTION &&
							*g_pchOption == NETWORK_PACKAGE_OPTION)
						{
							// have a "/a {admin} /p {patch}" combination
							if(SetProductToPatch(*g_pchOption,rgchOptionValue) != 0)
							{
								DisplayHelp();
								iReturnStatus = ERROR_INVALID_COMMAND_LINE;
								break;
							}

							g_pchOption = pchOptions;
							lstrcpyn(rgchOptionValue, pszOptionValue, cchMaxParameter);
							lstrcpyn(rgchOptionModifier, pszOptionModifier, cchMaxOptionModifier);
						}
						else if(*g_pchOption == APPLY_PATCH_OPTION &&
								  *pchOptions == NETWORK_PACKAGE_OPTION)
						{
							// have a "/p {patch} /a {admin}" combination
							if(SetProductToPatch(*pchOptions,pszOptionValue) != 0)
							{
								DisplayHelp();
								iReturnStatus = ERROR_INVALID_COMMAND_LINE;
								break;
							}
						}
						else
						{
							DisplayHelp();
							iReturnStatus = ERROR_INVALID_COMMAND_LINE;
							break;
						}
					}
					else
					{
#if defined(DEBUG) && 0 // this is only used when debugging the command-line processor
						// StringCchPrintf limited to 1024 *bytes* (eugend: MSDN says so, but it turned out that in Unicode it's 1024 chars)
						ICHAR rgch[cchMaxStringCchPrintf+1];
						StringCchPrintf(rgch, ARRAY_ELEMENTS(rgch), TEXT("MSIEXEC: Option: [%c], Modifier [%s], Value: [%s]\r\n"), *pchOptions, pszOptionModifier, pszOptionValue);
						OutputDebugString(rgch);
#endif
						g_pchOption = pchOptions;
						lstrcpyn(rgchOptionValue, pszOptionValue, cchMaxParameter);
						lstrcpyn(rgchOptionModifier, pszOptionModifier, cchMaxOptionModifier);

						// if embedding is provided on the command line, the rest of the command
						// line is the Hex-encoded cookie. Because the command line processor would
						// throw help if it encountered the cookie, we have to abort command line
						// processing.
						if (*g_pchOption == EMBEDDING_OPTION)
							break;
					}
				}
				else
				{
#if defined(DEBUG) && 0 // this is only used when debugging the command-line processor
					// StringCchPrintf limited to 1024 *bytes* (eugend: MSDN says so, but it turned out that in Unicode it's 1024 chars)
					ICHAR rgch[cchMaxStringCchPrintf+1];
					StringCchPrintf(rgch, ARRAY_ELEMENTS(rgch), TEXT("MSIEXEC: Option: [%c], Modifier [%s], Value: [%s]\r\n"), *pchOptions, pszOptionModifier, pszOptionValue);
					OutputDebugString(rgch);
#endif
					if((*COMMAND_FUNCTIONS[pchOptions - COMMAND_OPTIONS])(pszOptionModifier, pszOptionValue) != 0)
					{
						DisplayHelp();
						iReturnStatus = ERROR_INVALID_COMMAND_LINE;
						break;
					}
				}
				pszOptionValue       = rgchOptionParam1;
				pszOptionValue[0]    = 0;
				pszOptionModifier    = rgchOptionParam2;
				pszOptionModifier[0] = 0;
			}
		}
	}

	// execute the 'action' option if we've found one and we haven't errored
	if (iReturnStatus == 0)
	{
		if (g_pchOption)
		{
#if defined(DEBUG) && 0 // this is only used when debugging the command-line processor
			// StringCchPrintf limited to 1024 *bytes* (eugend: MSDN says so, but it turned out that in Unicode it's 1024 chars)
			ICHAR rgch[cchMaxStringCchPrintf+1];
			StringCchPrintf(rgch, ARRAY_ELEMENTS(rgch), TEXT("MSI: (msiexec) Option: [%c], Modifier [%s], Value: [%s]\r\n"), *g_pchOption, rgchOptionModifier, rgchOptionValue);
			OutputDebugString(rgch);
#endif
			iReturnStatus = (*COMMAND_FUNCTIONS[g_pchOption - COMMAND_OPTIONS])(rgchOptionModifier, rgchOptionValue);
			if(*g_pchOption == SELF_REG_OPTION || *g_pchOption == SELF_UNREG_OPTION)//!! hack -- never display selfreg and selfunreg errors - since we call ourselves on selfreg/unreg from execute.cpp
				return iReturnStatus;
			if (iReturnStatus == 0) // Success
			{
				if (*g_pchOption == EMBEDDING_OPTION)
					g_fCustomActionServer = fTrue;
				else
					fLocalServer = fTrue;
			}
			else if (iReturnStatus == iNoLocalServer)  // Success
			{
				fLocalServer = fFalse;
				g_fCustomActionServer = fFalse;
				iReturnStatus = 0;
			}
			else // Failure
			{
				// Display errors that the API hasn't already displayed

				if (*g_pchOption == REG_SERVER_OPTION || *g_pchOption == UNREG_SERVER_OPTION)    //!! hack -- always display register and unregister errors
					DisplayError(iReturnStatus);
				else
				{
					switch (iReturnStatus)
					{
						case ERROR_INSTALL_SUSPEND:
						case ERROR_INSTALL_USEREXIT:
						case ERROR_INSTALL_FAILURE:
						case ERROR_INSTALL_REBOOT:
						case ERROR_INSTALL_REBOOT_NOW:
						case ERROR_SUCCESS_REBOOT_REQUIRED:
						case ERROR_SUCCESS_REBOOT_INITIATED:
						case ERROR_APPHELP_BLOCK:
							break;
						case ERROR_FILE_NOT_FOUND:
						case ERROR_INVALID_NAME:
						case ERROR_PATH_NOT_FOUND:
							iReturnStatus = ERROR_INSTALL_PACKAGE_OPEN_FAILED;
						default:
							DisplayError(iReturnStatus);
							break;
					}
				}
			}
		}
		else
		{
			DisplayHelp();
			iReturnStatus = ERROR_INVALID_COMMAND_LINE;
		}
	}

	if (iReturnStatus == 0 && (fLocalServer || g_fCustomActionServer))
	{
		if (g_fCustomActionServer)
		{
			// CA server must be in an MTA or COM will serialize access to the object, which isn't
			// condusive to asynchronous actions.
			OLE32::CoInitializeEx(0, COINIT_MULTITHREADED);
		}
		else
			CoInitialize(0);

		// The custom action server should NEVER register itself as the handler for ANY COM
		// classes. There is no need to register the custom action server class itself, because
		// we provide the pointer to the service directly, not via COM. Since this process makes
		// API calls into the service that must remain trusted, any incoming connection just opens up
		// a possible route of attack on this process, and thus indirectly on the service.
		if (fLocalServer && !g_fCustomActionServer)
		{
			int iCLSID;
			for (iCLSID = 0; iCLSID < CLSID_COUNT; iCLSID++)
			{
				if (OLE::CoRegisterClassObject(MODULE_CLSIDS[iCLSID], &g_rgcfModule[iCLSID],
						CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE, &g_rghRegClass[iCLSID]) != NOERROR)
				{
					fClassRegistrationFailed = fTrue;
					break;
				}
			}
		}

		if (g_fCustomActionServer)
		{
			// the cookie comes in on the command line in a form of hex encoding, which needs
			// to be converted back to full 8-bit bytes before the server is registered with
			// the service. We assume the cookie is 128 bits to start.
			unsigned char rgchCookie[iRemoteAPICookieSize];
			int iInputChar = 0;
			ICHAR *pchNext = szCmdLine;
			memset(rgchCookie, 0, sizeof(rgchCookie));
			for (;;)
			{
				int iValue = 0;
				if ((*pchNext >= '0') && (*pchNext <= '9'))
					iValue = (*pchNext-TEXT('0'))* ((iInputChar % 2) ? 1 : 0x10);
				else if ((*pchNext >= 'A') && (*pchNext <= 'F'))
					iValue = (*pchNext-TEXT('A')+10)* ((iInputChar % 2) ? 1 : 0x10);
				else
					break;
				if (iInputChar >= iRemoteAPICookieSize*2)
					return ERROR_INSTALL_SERVICE_FAILURE;
				rgchCookie[iInputChar/2] |= iValue;
				iInputChar++;
				pchNext++;
			}

			if (iInputChar != iRemoteAPICookieSize*2)
				return ERROR_INSTALL_SERVICE_FAILURE;

			// after the cookie comes an optional character which is "C" if the process is owned by
			// a client process, which enables AllowSetWindowFocus. If its followed by an "M", its
			// service owned and should map HKCU to the appropriate hive when elevated.
			bool fClientOwned = false;
			bool fMapHKCU = false;
			
			// skip over the space which ended the cookie read
			if (*pchNext)
				pchNext++;

			if (*pchNext == 'C')
				fClientOwned = true;
			else if ((*pchNext == 'M') || (*pchNext == 'E'))
			{
				if (*pchNext == 'M')
					fMapHKCU = true;
				
				// if the the service wants to send a thread token, the process should
				// stall until the service has a chance to manipulate the thread
				// token. Open the named event and wait on it. Don't pump messages
				// because we want to stall any incoming COM calls as well.
				pchNext+=2;

				HANDLE hEvent = OpenEvent(SYNCHRONIZE, FALSE, pchNext);
				if (!hEvent || hEvent == INVALID_HANDLE_VALUE)
				{
					ReportErrorToDebugOutput(TEXT("ServerMain (CA): Open synchronization event failed"), GetLastError());
					return ERROR_INSTALL_SERVICE_FAILURE;
				}
				DWORD dwRes = WaitForSingleObject(hEvent, INFINITE);
				CloseHandle(hEvent);
				if (dwRes != WAIT_OBJECT_0)
				{
					ReportErrorToDebugOutput(TEXT("ServerMain (CA): Wait on synchronization event failed"), dwRes);
					return ERROR_INSTALL_SERVICE_FAILURE;
				}
			}

			// Per bug 193684, we need to map HKCU to HKCU\{user sid} rather than HKCU\.Default in the elevated case
			// This is done by having the custom action process initially created in suspended mode, then setting
			// the thread token to the user, and then resuming.  The process token is therefore local_system.
			// So, at this point, if we are an elevated custom action server, we are impersonating the user since
			// our thread token is the user's token. This mean's opening HKCU should give us the right hive.
			// This remapping does not occur in the Terminal Server per-machine install case because the user thread
			// token will not have been set. (Terminal Server requires HKCU\.Default so that proper propogation occurs.)
			// but we still need to save off the impersonation token for use by potential typelib registrations.

			// IMPORTANT: this code must be executed before the first COM call since the custom action
			//            server is initialized as a multi-threaded apartment.  We must therefore guarantee
			//            that we are acting on the primary thread of the process which is the only thread
			//            that is impersonating the user.  All subsequent threads will be local_system			
			HANDLE hImpersonationToken = INVALID_HANDLE_VALUE;
			if (!OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, TRUE, &hImpersonationToken))
			{
				// if there is no token, that's OK
				hImpersonationToken = INVALID_HANDLE_VALUE;
				if (GetLastError() != ERROR_NO_TOKEN)
				{
					return ERROR_INSTALL_SERVICE_FAILURE;
				}
			}
			
			// remap HKCU to the correct hive by flushing and then enumerating the key while in the correct
			// impersonation state. If on TS and per-machine, sthop impersonating now so we will properly open up
			// .Default so that the propogation can occur.  Note that if a CustomAction chooses to close HKCU,
			// then the handle cached in the advapi32!predefinedhandletable is removed.  This means that any
			// subsequent open of an HKCU key will always be .Default.  This problem would have existed before
			// on Win2K when CA's were run in-proc.  CAs should not be closing HKCU (this is bad!). Even attempting
			// to maintain an open handle to HKCU within the server won't work since predefined keys are not ref-counted
			// in the cache table.
			if (!fMapHKCU)
			{
				// revert now to ensure that the refresh of HKCU below will retrieve HKU\.Default. In impersonated
				// servers, this is a no-op
				RevertToSelf();
			}

			if (ERROR_SUCCESS != RegCloseKey(HKEY_CURRENT_USER))
			{
				AssertSz(0, TEXT("Unable to close the HKCU key!"));
			}
			RegEnumKey(HKEY_CURRENT_USER, 0, NULL, 0);

			// if we were supposed to remap to HKCU, there is still a thread token. Clear it now. This
			// will never be true in a non-elevated server.
			if (fMapHKCU)
			{
				// now stop the impersonation so we are back to our elevated state
				RevertToSelf();
			}

			// the custom action server determines its own security context when connecting
			// to the service by examining its process token. This must be done AFTER
			// the reg-key remapping above, as the thread (user) token may not have rights
			// to access the process token information.
			UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
			ULONG ReturnLength;
			char* psidLocalSystem;
			HANDLE hToken;
			#ifdef _WIN64
				icacCustomActionContext icacContext = icac64Impersonated;
			#else // _WIN32
				icacCustomActionContext icacContext = icac32Impersonated;
			#endif
			if (WIN::OpenProcessToken(WIN::GetCurrentProcess(), TOKEN_QUERY, &hToken))
			{
				if ((ERROR_SUCCESS == GetLocalSystemSID(&psidLocalSystem)) && WIN::GetTokenInformation(hToken, TokenUser, TokenInformation, sizeof(TokenInformation),   &ReturnLength))
				{
					icacContext = EqualSid((PISID)((PTOKEN_USER)TokenInformation)->User.Sid, psidLocalSystem) ?
						#ifdef _WIN64
						icac64Elevated : icac64Impersonated;
						#else // _WIN32
						icac32Elevated : icac32Impersonated;
						#endif
				}
				WIN::CloseHandle(hToken);
			}
			else
			{
				UINT uiErr = GetLastError();
				TCHAR szError[MAX_PATH] = {0};
				StringCchPrintf(szError, ARRAY_ELEMENTS(szError), TEXT("OpenProcessToken failed with %d"), uiErr);
				AssertSz(0, szError);
			}


			// if an elevated custom action server, initialize security so that only the system
			// and admins can connect to us. This keeps rogue users from connecting
			// to our CA server and getting us to run DLLs at elevated privileges. For impersonated
			// servers, only system, admin, and interactive users can connect. 
			char rgchSD[256];
			DWORD cbSD = sizeof(rgchSD);

			sdSecurityDescriptor sdCOMSecurity = sdCOMSecure;
			if ((icacContext == icac32Impersonated) || (icacContext == icac64Impersonated))
				sdCOMSecurity = sdCOMNotSecure;

			DWORD dwRet = ERROR_SUCCESS;
			if (ERROR_SUCCESS != (dwRet = GetSecurityDescriptor(rgchSD, cbSD, sdCOMSecurity, fFalse)))
			{
				if (hImpersonationToken != INVALID_HANDLE_VALUE)
					CloseHandle(hImpersonationToken);
				return dwRet;
			}

			DWORD cbAbsoluteSD = cbSD;
			DWORD cbDacl       = cbSD;
			DWORD cbSacl       = cbSD;
			DWORD cbOwner      = cbSD;
			DWORD cbGroup      = cbSD;

			const int cbDefaultBuf = 256;

			Assert(cbSD <= cbDefaultBuf); // we're using temp buffers here to be safe, but we'd like the default size to be big enough

			CTempBuffer<char, cbDefaultBuf> rgchAbsoluteSD(cbAbsoluteSD);
			CTempBuffer<char, cbDefaultBuf> rgchDacl(cbDacl);
			CTempBuffer<char, cbDefaultBuf> rgchSacl(cbSacl);
			CTempBuffer<char, cbDefaultBuf> rgchOwner(cbOwner);
			CTempBuffer<char, cbDefaultBuf> rgchGroup(cbGroup);

			if (!MakeAbsoluteSD(rgchSD, rgchAbsoluteSD, &cbAbsoluteSD, (PACL)(char*)rgchDacl, &cbDacl, (PACL)(char*)rgchSacl, &cbSacl, rgchOwner, &cbOwner, rgchGroup, &cbGroup))
			{
				DWORD dwError = WIN::GetLastError();
				if (hImpersonationToken != INVALID_HANDLE_VALUE)
					CloseHandle(hImpersonationToken);
				return dwError;
			}

			AssertSz(IsValidSecurityDescriptor(rgchAbsoluteSD), TEXT("Invalid SD in ServerMain of CA Server"));

			// using RPC_C_AUTHN_LEVEL_CALL instead of RPC_C_AUTHN_LEVEL_CONNECT means that the identity of
			// the client is authenticated on a per-call basis (not just when the initial connection is made.)
			// this is what allows COM to reject other processes that try to do a "man-in-the-middle" attack
			// on the link between the CA server
			HRESULT hRes;
			if ((hRes = OLE32::CoInitializeSecurity(rgchAbsoluteSD, -1, NULL, NULL,
				RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_NONE, NULL)) != S_OK)
			{
				if (hImpersonationToken != INVALID_HANDLE_VALUE)
					CloseHandle(hImpersonationToken);
				ReportErrorToDebugOutput(TEXT("ServerMain (CA): CoInitializeSecurity failed"), hRes);
				return ERROR_INSTALL_SERVICE_FAILURE;
			}

			// create an event to watch for the shutdown signal
			HANDLE hOwningProcess = 0;
			HANDLE hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
			if (!hShutdownEvent)
			{
				if (hImpersonationToken != INVALID_HANDLE_VALUE)
					CloseHandle(hImpersonationToken);
				return ERROR_INSTALL_SERVICE_FAILURE;
			}

			// the CA server now needs to contact the service and introduce itself.
			{
				PMsiCustomAction piCustomAction = 0;
				PMsiRemoteAPI piRemoteAPI = 0;
				PMsiServer piService = CreateMsiServerProxyForCAServer();
				if (!piService)
				{
					if (hImpersonationToken != INVALID_HANDLE_VALUE)
						CloseHandle(hImpersonationToken);
					ReportErrorToDebugOutput(TEXT("ServerMain (CA): Connection to Service failed."), 0);
					return ERROR_INSTALL_SERVICE_FAILURE;
				}

				// the Register call awakens the CA remote thread in the service, which could immediately generate
				// a RunCustomAction call, so the processes must be ACLed and ready to accept calls
				// BEFORE this call is made (actually before the message pump below).
				DWORD iProcessId = 0;
				DWORD dwPrivileges = 0;

				IUnknown* piUnknown = CreateCustomActionServer();
				if (!piUnknown)
				{
					if (hImpersonationToken != INVALID_HANDLE_VALUE)
						CloseHandle(hImpersonationToken);
					return ERROR_INSTALL_SERVICE_FAILURE;
				}
				piUnknown->QueryInterface(IID_IMsiCustomAction, (void**)&piCustomAction);
				piUnknown->Release();

				icacCustomActionContext icacContextFromService = icacContext;
				if (S_OK != piService->RegisterCustomActionServer(&icacContextFromService, rgchCookie, iRemoteAPICookieSize, piCustomAction, &iProcessId, &piRemoteAPI, &dwPrivileges))
				{
					if (hImpersonationToken != INVALID_HANDLE_VALUE)
						CloseHandle(hImpersonationToken);
					ReportErrorToDebugOutput(TEXT("ServerMain (CA): Process not registered with service."), 0);
					return ERROR_INSTALL_SERVICE_FAILURE;
				};

				// we need a handle to our owner process so that when it dies we can also exit. In some
				// cases this is the service, but it could also be a client process
				hOwningProcess = OpenProcess(SYNCHRONIZE, false, iProcessId);
				if (!hOwningProcess)
				{
					if (hImpersonationToken != INVALID_HANDLE_VALUE)
						CloseHandle(hImpersonationToken);
					ReportErrorToDebugOutput(TEXT("ServerMain (CA): Could not open synchronization handle."), GetLastError());
					return ERROR_INSTALL_SERVICE_FAILURE;
				}

				if (!OLE32::CoIsHandlerConnected(piRemoteAPI))
				{
					if (hImpersonationToken != INVALID_HANDLE_VALUE)
						CloseHandle(hImpersonationToken);
					return ERROR_INSTALL_SERVICE_FAILURE;
				}

				// the config interface holds in-proc only functions used to configure the object
				IMsiCustomActionLocalConfig* piConfig = NULL;
				piCustomAction->QueryInterface(IID_IMsiCustomActionLocalConfig, (void**)&piConfig);
				AssertSz(piConfig, "QI to configure CA server failed!");

				piConfig->SetCookie((icacContext == icacContextFromService) ? NULL : &icacContextFromService, rgchCookie);
				piConfig->SetShutdownEvent(hShutdownEvent);
				HRESULT hrRes = piConfig->SetClientInfo(iProcessId, fClientOwned, dwPrivileges, hImpersonationToken);
				if (hImpersonationToken != INVALID_HANDLE_VALUE)
				{
					CloseHandle(hImpersonationToken);
					hImpersonationToken = INVALID_HANDLE_VALUE;
				}
				if (ERROR_SUCCESS != hrRes)
				{
					ReportErrorToDebugOutput(TEXT("ServerMain (CA): Impersonation token not saved."), 0);
					return ERROR_INSTALL_SERVICE_FAILURE;
				};

				// SetRemoteAPI must go last, as it signals the event allowing pending action calls to unblock
				piConfig->SetRemoteAPI(piRemoteAPI);
				piConfig->Release();
			}

			// message pump for custom action server.
			g_scServerContext = scCustomActionServer;
			MSG msg;
			DWORD dwRes = 0;
			bool fBreak = false;
			HANDLE rghWaitHandles[] = { hOwningProcess, hShutdownEvent };
			for (;;)
			{
				dwRes = MsgWaitForMultipleObjects(2, rghWaitHandles, FALSE, INFINITE, QS_ALLINPUT);

				// if process exited
				if (dwRes == WAIT_OBJECT_0)
					break;

				// if shutdown event signaled
				if (dwRes == WAIT_OBJECT_0 + 1)
				{
					CloseHandle(hShutdownEvent);
					break;
				}

				// otherwise message
				if (dwRes == WAIT_OBJECT_0 + 2)
				{
					// if we don't flush the message queue, we'll miss messages. Also could
					// be no messages.
					while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
					{
						if (msg.message == WM_QUIT)
						{
							fBreak = true;
							break;
						}
						TranslateMessage(&msg);
						DispatchMessage(&msg);
					}
					if (fBreak)
						break;
				}
				else
				{
					// error
					break;
				}
			}

			// do not close hShutdownEvent unless the event itself was the cause of shutdown, because there
			// is no guarantee that another thread isn't about to try and set the event.
		}
		else
		{
			// message pump for regular server (non-CA server)
			g_scServerContext = scServer;
			MSG msg;
			while (GetMessage(&msg, 0, 0, 0) || (g_fAutomation && g_cInstances))
			{
				WIN::TranslateMessage(&msg);
				WIN::DispatchMessage(&msg);
			}
		}

		if (fLocalServer && !g_fCustomActionServer)
		{
			for (int iCLSID = 0; iCLSID < CLSID_COUNT; iCLSID++)
			{
				if (g_rghRegClass[iCLSID] != 0)
					OLE::CoRevokeClassObject(g_rghRegClass[iCLSID]);
			}
		}

		CoUninitialize();
		#ifdef MODULE_TERMINATE //!! Is this the right place for this?
				MODULE_TERMINATE();
		#endif
	}

	if (fClassRegistrationFailed)
	{
		DisplayError(ERROR_INSTALL_SERVICE_FAILURE); //??
		return ERROR_INSTALL_SERVICE_FAILURE;
	}
	else
		return iReturnStatus;
}

int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPSTR /*lpCmdLine*/,
	int /*nCmdShow*/)
{
	//
	// Initialize the common controls since we use a manifest now and support
	// theming. If this is not done, then a lot of dialogs fail to get created
	// on Whistler and higher platforms.
	//
	INITCOMMONCONTROLSEX iccData = {sizeof(INITCOMMONCONTROLSEX), ICC_PROGRESS_CLASS};	
	int					 iRetVal = ERROR_SUCCESS;
		
	// try except structure to get JIT debugging working
	__try
	{
		COMCTL32::InitCommonControlsEx(&iccData);
		iRetVal = ServerMain(hInstance);
	}
	__except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )
	{
	} /* end of try - except */

	COMCTL32::Unbind();
	ExitProcess(iRetVal);
	
	// To keep the compiler happy
	return 0;
}



//____________________________________________________________________________
//
// Functions to handle service command-line arguments
//____________________________________________________________________________


int RemoveService()
/*---------------------------------------------------------------------------
Removes the service by stopping it if necessary and then marking the service
for deletion from the service control manager database.
-----------------------------------------------------------------------------*/
{
	SC_HANDLE   schService;
	SC_HANDLE   schSCManager;
	int iRetval = 0;
	int cRetry = 0;

	schSCManager = WIN::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (schSCManager)
	{
		schService = WIN::OpenService(schSCManager, SERVICE_NAME, SERVICE_ALL_ACCESS);

		if (schService)
		{
			// try to stop the service
			if (WIN::ControlService(schService, SERVICE_CONTROL_STOP, &g_ssStatus))
			{
				 //
				 // Initialize dwCurrentState to a different value so that
				 // in case of a failure in QueryServiceStatus, if g_ssStatus
				 // happens to have some garbage that makes it look like the
				 // service was stopped, then bad things might happen later on.
				 // So we need to catch the failure right here.
				 //
				 g_ssStatus.dwCurrentState = SERVICE_RUNNING;
				 //
				 // Try for at the most 5 seconds to stop the service. If it
				 // doesn't work out, bail out and report an error. At least
				 // we won't go into an infinite loop.
				 //
				 Sleep(1000);
				 while (QueryServiceStatus(schService, &g_ssStatus) && cRetry++ < 5)
				 {
					  if (g_ssStatus.dwCurrentState == SERVICE_STOP_PENDING)
							Sleep(1000);
					  else
							break;
				 }

				 if (g_ssStatus.dwCurrentState != SERVICE_STOPPED)
					iRetval = E_FAIL; //??
			}
			else // control service may have failed because service was already stopped
			{
				iRetval = WIN::GetLastError();
				
				switch (iRetval)
				{
				case ERROR_SERVICE_NOT_ACTIVE:
				case ERROR_SERVICE_NEVER_STARTED:
				case ERROR_SERVICE_DOES_NOT_EXIST:
					iRetval = ERROR_SUCCESS;
					break;
				case ERROR_INVALID_SERVICE_CONTROL:
					iRetval = ERROR_INSTALL_ALREADY_RUNNING;
					break;
				default:
					ReportErrorToDebugOutput(TEXT("ControlService failed."), iRetval);
					break;
				}
			}

			if (iRetval == 0)
			{
				if (WIN::DeleteService(schService) != TRUE)
					iRetval = WIN::GetLastError();
			}

			WIN::CloseServiceHandle(schService);
		}
		else // !schService
		{
			iRetval = WIN::GetLastError();
			switch (iRetval)
			{
			//
			// If the service does not exist or is already marked for delete
			// then it should be treated as success.
			//
			case ERROR_SERVICE_DOES_NOT_EXIST:
			case ERROR_SERVICE_MARKED_FOR_DELETE:
				iRetval = ERROR_SUCCESS;
				break;
			default:
				ReportErrorToDebugOutput(TEXT("OpenService failed."), iRetval);
				break;
			}
		}

		WIN::CloseServiceHandle(schSCManager);
	}
	else // !schSCManager
	{
		iRetval = WIN::GetLastError();
		ReportErrorToDebugOutput(TEXT("OpenSCManager failed."), iRetval);
	}

	return iRetval;
}

const ICHAR* szDependencies = TEXT("RpcSs\0") ;// list of service dependencies - "dep1\0dep2\0\0"

int InstallService()
/*---------------------------------------------------------------------------
Installs the service with the Service Control Manager
---------------------------------------------------------------------------*/
{
	SC_HANDLE   schService;
	SC_HANDLE   schSCManager;	 
	ICHAR szPath[MAX_PATH + 3] = TEXT(""); // '+ 3' is for SERVICE_OPTION
	int iRetval = ERROR_SUCCESS;
	int cRetry = 0;

	// GetModuleFileName does not guarantee null termination if buffer is exactly the right size
	if (WIN::GetModuleFileName(NULL, szPath, MAX_PATH-1) == 0)
		return WIN::GetLastError();
	szPath[MAX_PATH-1] = TEXT('\0');

	ICHAR szServiceOption[4] = { ' ', '/', SERVICE_OPTION, 0 };
	StringCchCat(szPath, ARRAY_ELEMENTS(szPath), szServiceOption);
	ICHAR szServiceInfo[256] = TEXT("");

	if (MsiLoadString((HINSTANCE)-1, IDS_SERVICE_DISPLAY_NAME, szServiceInfo, ARRAY_ELEMENTS(szServiceInfo), 0) == 0)
	{
		AssertNonZero(MsiLoadString((HINSTANCE)-1, IDS_SERVICE_DISPLAY_NAME, szServiceInfo, ARRAY_ELEMENTS(szServiceInfo), LANG_ENGLISH) != 0);
	}

	if ((schSCManager = WIN::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS)) != NULL)
	{
		do
		{
			iRetval = ERROR_SUCCESS;	// Reset iRetval since it might have got set to a non-success code below.
			if (cRetry)
				Sleep(500);	// If this is not our first pass through the loop, we want to wait half a second before proceeding.
			
			schService = WIN::CreateService(schSCManager, SERVICE_NAME,
			   szServiceInfo, SERVICE_ALL_ACCESS,
				SERVICE_WIN32_SHARE_PROCESS, SERVICE_DEMAND_START,
				SERVICE_ERROR_NORMAL, szPath, NULL, NULL,
				szDependencies, 0,0);

			if (schService != NULL)
			{
				if (MsiLoadString((HINSTANCE)-1, IDS_MSI_SERVICE_DESCRIPTION, szServiceInfo, ARRAY_ELEMENTS(szServiceInfo), 0) == 0)
				{
					AssertNonZero(MsiLoadString((HINSTANCE)-1, IDS_SERVICE_DISPLAY_NAME, szServiceInfo, ARRAY_ELEMENTS(szServiceInfo), LANG_ENGLISH) != 0);
				}
				SERVICE_DESCRIPTION servdesc;
				servdesc.lpDescription = szServiceInfo;

				// don't need to check for existence of the API.
				// if it fails, we're not going to do anything different.
				ADVAPI32::ChangeServiceConfig2(schService, SERVICE_CONFIG_DESCRIPTION, &servdesc);	
				WIN::CloseServiceHandle(schService);
				break;	// We succeeded in creating the service. Break out of the loop.
			}
			else
			{
				iRetval = WIN::GetLastError();
				//
				// Since in our server registration code we remove and reinstall
				// the service, it is possible that we get back
				// ERROR_SERVICE_MARKED_FOR_DELETE code since the service control
				// manager may not be done yet. At this point, our best bet is to
				// keep trying. Right now we do it for about 7 seconds.
				//
				// Note: We must not reset the error code here -- it must be
				// done at the top, right before the call to CreateService.
				// This is because even if we don't break out of the loop here
				// we might do so in the while condition below because we overshot
				// our self-imposed time limit of 7 seconds. In this case we want
				// to make sure that iRetval does not errorneously contain a
				// success code.
				//
				if (ERROR_SERVICE_MARKED_FOR_DELETE != iRetval)
					break;	// We encountered some other error. Bail out.
			}
		} while (cRetry++ < 14 /* 14 half second intervals */);

		WIN::CloseServiceHandle(schSCManager);
	}
	else
	{
		iRetval = WIN::GetLastError();
	}

	return iRetval;
}

BOOL WINAPI HandlerRoutine(DWORD dwCtrlType)
{

	switch(dwCtrlType)
	{
		case CTRL_SHUTDOWN_EVENT:
		case CTRL_LOGOFF_EVENT:
			g_fWeWantToStop = true;
			ServiceStop();
			// fall-thru
		default:
			return FALSE;
	}
}

int StartService(const ICHAR* /*szModifier*/,const ICHAR* /*szOption*/)
/*---------------------------------------------------------------------------
Starts the service by registering it with the Service Control Dispatcher.
This function is invoked by OLE calling us with the SERVICE_OPTION
command-line flag.
---------------------------------------------------------------------------*/
{
	// We support one service with entrypoint ServiceMain

	SERVICE_TABLE_ENTRY dispatchTable[] =
	{
		{ (ICHAR*)SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain},
		{ NULL, NULL }
	};

	if (!StartServiceCtrlDispatcher(dispatchTable))
	{
		ReportErrorToDebugOutput(TEXT("StartServiceCtrlDispatcher failed."), GetLastError());
		return 1;
	}

	return iNoLocalServer;
}


//____________________________________________________________________________
//
// Service-related functions
//____________________________________________________________________________

void WINAPI ServiceMain(DWORD /*dwArgc*/, LPTSTR * /*lpszArgv*/)
/*---------------------------------------------------------------------------
This is the entrypoint used by the Service Control Manager to start the
service. The ServiceThreadMain thread is started to run the message
loop.
---------------------------------------------------------------------------*/
{
	g_sshStatusHandle = WIN::RegisterServiceCtrlHandler(SERVICE_NAME, ServiceControl);

	if (!g_sshStatusHandle)
	{
		ReportErrorToDebugOutput(TEXT("RegisterServiceCtrlHandler failed."), GetLastError());
		return;
	}

	// SERVICE_STATUS members that don't change
	g_ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	g_ssStatus.dwServiceSpecificExitCode = 0;

	if (!ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000, 0))
		return;

	if (CreateThread(0, 0, ServiceThreadMain, 0, 0, &g_dwThreadId) == NULL)
	{
		ReportStatusToSCMgr(SERVICE_STOPPED, GetLastError(), 3000, 0);
		return;
	}
	g_scServerContext = scService;

	if (!WIN::SetConsoleCtrlHandler(HandlerRoutine, TRUE))
	{
		AssertSz(0, "Could not add console control handler.");
	}

}

//--------------------------------------------------------------
// FDeleteRegTree -- Delete a registry tree from szSubKey down
//
bool FDeleteRegTree(HKEY hKey, ICHAR* szSubKey)
{
	HKEY hSubKey;
	// Win64: called only from PurgeUserOwnedInstallerKeys & PurgeUserOwnedSubkeys
	// and these deals w/ configuration data.
	LONG lError = MsiRegOpen64bitKey(hKey, szSubKey, 0, KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_WRITE, &hSubKey);
	if (lError != ERROR_SUCCESS)
		return lError == ERROR_FILE_NOT_FOUND ? true : false;

	CTempBuffer<ICHAR, 500>szName;
	DWORD cchName = szName.GetSize();

	unsigned int iIndex = 0;
	while ((lError = RegEnumKeyEx(hSubKey, iIndex, szName, &cchName, 0, 0, 0, 0)) == ERROR_SUCCESS)
	{
		if (!FDeleteRegTree(hSubKey, szName))
		{
			RegCloseKey(hSubKey);
			return false;
		}

		cchName = szName.GetSize();
	}
	if (lError != ERROR_NO_MORE_ITEMS)
	{
		RegCloseKey(hSubKey);
		return false;
	}

	RegCloseKey(hSubKey);

	if (ERROR_SUCCESS != (lError = RegDeleteKey(hKey, szSubKey)))
	{
		// StringCchPrintf limited to 1024 *bytes* (eugend: MSDN says so, but it turned out that in Unicode it's 1024 chars)
		ICHAR szBuf[cchMaxStringCchPrintf+1];
		StringCchPrintf(szBuf, ARRAY_ELEMENTS(szBuf), TEXT("FDeleteRegTree: Unable to delete subkey: %s"), szSubKey);
		ReportErrorToDebugOutput(szBuf, lError);
		return false;
	}
	return true;
}

unsigned long __stdcall ServiceThreadMain(void *)
/*---------------------------------------------------------------------------
This is the service's worker thread. It initializes the server's security
and then runs a message loop. The message loop will terminate when
the WM_QUIT sent by ServerStop() is received.
---------------------------------------------------------------------------*/
{
	if (!ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000, 0))
		return 0;

	OLE32::CoInitializeEx(0, COINIT_MULTITHREADED);

	SetTestFlags();

	// ACL our reg keys and files
	if (!SetInstallerACLs())
	{
		ReportStatusToSCMgr(SERVICE_STOPPED, WIN::GetLastError(), 0, 0);
		return 0;
	}

	// Initialize the server's security to allow interactive users and LocalSystem to
	// connect. Note: this is not sufficient to prevent a non-interactive user
	// from connecting, but anything more would require an access check in each
	// server method call. The best check to do would probably be this one, as suggested
	// by Scott Field:
	//
	//
	// "actually, don't call LookupAccountSid() - thats slow and none mapped can be returned for other reasons.
	//  Instead, look for SE_GROUP_LOGON_ID in the Attributes field of SID_AND_ATTRIBUTES structure.
	//  The tricky part of this is to actually get the right token to look at, and, refresh your object
	//  across physical logon/logoff."
	//

	HRESULT hRes = NOERROR;


	char rgchSD[256];
	DWORD cbSD = sizeof(rgchSD);

	DWORD dwRet = ERROR_SUCCESS;

	// This privilege is turned on and left for the entirety of 
	// the service.
	AcquireRefCountedTokenPrivileges(itkpSD_READ);

	if (ERROR_SUCCESS != (dwRet = GetSecurityDescriptor(rgchSD, cbSD, sdSystemAndInteractiveAndAdmin, fFalse)))
		return dwRet;

	DWORD cbAbsoluteSD = cbSD;
	DWORD cbDacl       = cbSD;
	DWORD cbSacl       = cbSD;
	DWORD cbOwner      = cbSD;
	DWORD cbGroup      = cbSD;

	const int cbDefaultBuf = 256;

	Assert(cbSD <= cbDefaultBuf); // we're using temp buffers here to be safe, but we'd like the default size to be big enough

	CTempBuffer<char, cbDefaultBuf> rgchAbsoluteSD(cbAbsoluteSD);
	CTempBuffer<char, cbDefaultBuf> rgchDacl(cbDacl);
	CTempBuffer<char, cbDefaultBuf> rgchSacl(cbSacl);
	CTempBuffer<char, cbDefaultBuf> rgchOwner(cbOwner);
	CTempBuffer<char, cbDefaultBuf> rgchGroup(cbGroup);

	if (!MakeAbsoluteSD(rgchSD, rgchAbsoluteSD, &cbAbsoluteSD, (PACL)(char*)rgchDacl, &cbDacl, (PACL)(char*)rgchSacl, &cbSacl, rgchOwner, &cbOwner, rgchGroup, &cbGroup))
	{
		return GetLastError();
	}

	if ((hRes = OLE32::CoInitializeSecurity(rgchAbsoluteSD, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
		RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_NONE, NULL)) != S_OK)
	{
		ReportErrorToDebugOutput(TEXT("ServiceThreadMain: CoInitializeSecurity failed"), hRes);
		ReportStatusToSCMgr(SERVICE_STOPPED, WIN::GetLastError(), 0, 0);
		return 0;
	}

	if (!ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000, 0))
		return 0;

	// create a waitable timer for shutdown notification
	SECURITY_ATTRIBUTES SA;
	SA.bInheritHandle = FALSE;
	SA.nLength = sizeof(SECURITY_ATTRIBUTES);
	if (ERROR_SUCCESS != (dwRet = GetSecureSecurityDescriptor(reinterpret_cast<char**>(&(SA.lpSecurityDescriptor)), fFalse, fTrue)))
	{
		ReportErrorToDebugOutput(TEXT("ServiceThreadMain: CreateSD for CreateWaitableTimer failed."), hRes);
		ReportStatusToSCMgr(SERVICE_STOPPED, WIN::GetLastError(), 0, 0);
		return 0;
	}

	g_hShutdownTimer = KERNEL32::CreateWaitableTimerW(&SA, TRUE, NULL);
	if (!g_hShutdownTimer)
	{
		ReportErrorToDebugOutput(TEXT("ServiceThreadMain: CreateWaitableTimer failed."), WIN::GetLastError());
		ReportStatusToSCMgr(SERVICE_STOPPED, WIN::GetLastError(), 0, 0);
		return 0;
	}
	LARGE_INTEGER liDueTime = {0,0};
	liDueTime.QuadPart = -iServiceShutdownTime;
	if (!KERNEL32::SetWaitableTimer(g_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE))
	{
		ReportErrorToDebugOutput(TEXT("ServiceThreadMain: SetWaitableTimer failed."), WIN::GetLastError());
		ReportStatusToSCMgr(SERVICE_STOPPED, WIN::GetLastError(), 0, 0);
		CloseHandle(g_hShutdownTimer);
		return 0;
	}

	int iCLSID;
	hRes = NOERROR;
	for (iCLSID = 0; iCLSID < CLSID_COUNT; iCLSID++)
	{
		if (!ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000, 0))
		{
			CloseHandle(g_hShutdownTimer);
			return 0;
		}

		hRes = OLE::CoRegisterClassObject(MODULE_CLSIDS[iCLSID],
				&g_rgcfModule[iCLSID], CLSCTX_SERVER, REGCLS_MULTIPLEUSE,
				&g_rghRegClass[iCLSID]);
		if (hRes != NOERROR)
		{
			ReportErrorToDebugOutput(TEXT("ServiceThreadMain: Class registration failed"), hRes);
			ReportStatusToSCMgr(SERVICE_STOPPED, WIN::GetLastError(), 0, 0);
			break;
		}
	}

	if (hRes == NOERROR)
	{
		if (!ReportStatusToSCMgr(SERVICE_RUNNING, NO_ERROR, 0, 0))
		{
			CloseHandle(g_hShutdownTimer);
			return 0;
		}

		HANDLE rghWaitArray[1] = {g_hShutdownTimer};

		for (;;)
		{
			// g_fWeWantToStop is set by the service control manager when it wants us
			// to shut down.
			if (g_fWeWantToStop && !FInstallInProgress())
			{
				break;
			}

			MSG msg;
			DWORD iWait = WIN::MsgWaitForMultipleObjects(1, rghWaitArray, FALSE, INFINITE, QS_ALLINPUT);
			if (iWait == WAIT_OBJECT_0 + 1)  
			{		
				// window message, need to pump until the queue is clear
				MSG msg;
				while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
				{
					WIN::TranslateMessage(&msg);
					WIN::DispatchMessage(&msg);
				}
				continue;
			}
			else if (iWait == WAIT_OBJECT_0)
			{
				// timer triggered. If an install is in progress, reset the timer, otherwise
				// shutdown the service
				if (!FInstallInProgress())
				{
					// no install is running so we'll tell the SCM that we're stopping
					g_ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
					ReportStatusToSCMgr(g_ssStatus.dwCurrentState, NO_ERROR, 0, 0);
					ServiceStop();
					break;
				}
				else
				{
					LARGE_INTEGER liDueTime = {0,0};
					liDueTime.QuadPart = -iServiceShutdownTime;
					KERNEL32::SetWaitableTimer(g_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE);
				}
				continue;
			}
			else if (iWait == 0xFFFFFFFF) // should be the same on 64bit;
			{
				// error
				AssertSz(0, "Error in MsgWait");
				break;
			}
		}
	}
	CloseHandle(g_hShutdownTimer);

	for (iCLSID = 0; iCLSID < CLSID_COUNT; iCLSID++)
	{
		if (g_rghRegClass[iCLSID] != 0)
			OLE::CoRevokeClassObject(g_rghRegClass[iCLSID]);
	}
	OLE::CoUninitialize();
	ReportStatusToSCMgr(SERVICE_STOPPED, NO_ERROR, 0, 0);
	return 0;
}


VOID ServiceStop()
/*---------------------------------------------------------------------------
If a ServiceStop procedure is going to take longer than 3 seconds to
execute, it should spawn a thread to execute the stop code, and return.
Otherwise, the ServiceControlManager will believe that the service has
stopped responding. We don't take this long so we just post our message
and return.
---------------------------------------------------------------------------*/
{
	PostThreadMessage(g_dwThreadId, WM_QUIT, 0, 0);
}

VOID WINAPI ServiceControl(DWORD dwCtrlCode)
/*---------------------------------------------------------------------------
This is the service's control handler which handles STOP and SHUTDOWN
messages.
---------------------------------------------------------------------------*/
{
	switch(dwCtrlCode)
	{
		case SERVICE_CONTROL_STOP:
			if (g_cInstances)
			{
				ReportStatusToSCMgr(g_ssStatus.dwCurrentState, 0, 0, 0);
				return;
			}
			// fall through
		case SERVICE_CONTROL_SHUTDOWN: //?? Do we care about our clients at this point?
			g_fWeWantToStop = true; // signal that we want to stop ASAP (after our in progress install is done, if one is running)
			if (!FInstallInProgress())
			{
				// no install is running so we'll tell the SCM that we're stopping; otherwise we reject the stop request
                ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0, 0);
				ServiceStop();
				return;
			}
			break;
		case SERVICE_CONTROL_INTERROGATE: // Update the service status.
			break;

		default: // invalid control code
			AssertSz(0, "Invalid control code sent to MSI service");
			break;
	}
	ReportStatusToSCMgr(g_ssStatus.dwCurrentState, NO_ERROR, 0, 0);
}

BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode,
								 DWORD dwWaitHint, DWORD dwMsiError)
/*---------------------------------------------------------------------------
Reports the service's state to the service control manager. If dwMsiError
is != 0 then it is used and the dwWin32ExitCode is ignored. Otherwise,
dwWin32ExitCode is used and dwMsiError is ignored.
---------------------------------------------------------------------------*/
{
	static DWORD dwCheckPoint = 1;
	BOOL fResult = TRUE;

	if (dwCurrentState == SERVICE_START_PENDING)
		g_ssStatus.dwControlsAccepted = 0;
	else if (g_cInstances > 0)
		g_ssStatus.dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN;
	else
		g_ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;

	g_ssStatus.dwCurrentState  = dwCurrentState;
	if (dwMsiError)
	{
		g_ssStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
		g_ssStatus.dwServiceSpecificExitCode = dwMsiError;
	}
	else
	{
		g_ssStatus.dwWin32ExitCode = dwWin32ExitCode;
	}

	g_ssStatus.dwWaitHint = dwWaitHint;

	if (( dwCurrentState == SERVICE_RUNNING ) ||
		 (dwCurrentState == SERVICE_STOPPED ) )
		g_ssStatus.dwCheckPoint = 0;
	else
		g_ssStatus.dwCheckPoint = dwCheckPoint++;

	if ((fResult = WIN::SetServiceStatus(g_sshStatusHandle, &g_ssStatus)) == 0)
		ReportErrorToDebugOutput(TEXT("SetServiceStatus failed."), GetLastError());

	return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msisip\sources.inc ===
TARGETNAME=msisip
!INCLUDE ..\..\MsiMake.inc

TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\libcmt.lib \
        $(SDK_LIB_PATH)\strsafe.lib

C_DEFINES=$(C_DEFINES)
USE_NOLIBS=1
USE_NATIVE_EH=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\msisip.def

INCLUDES=$(INCLUDES);$(INC_DIR);$(TOOLS_INC_DIR);$(RES_OBJDIR)

SOURCES=..\msisip.cpp \
	..\msisip.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\cabddfsz\cabddfsz.cpp ===
#define W32
#define MSI


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "MsiQuery.h" // MSI API

//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

const char szHelp[] = "MSI CabDDFSz. Syntax: {database} {DDF} {Darwin} {version} {Builddir}";

//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

int __cdecl main(int argc, char* argv[])
{
	if (argc != 6)
	{
		printf(szHelp);
		return -1;
	}
	
	MSIHANDLE hDB = 0;
	MSIHANDLE hView = 0;

	HANDLE DDFFile;

	DDFFile = CreateFileA(argv[2], GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (DDFFile == INVALID_HANDLE_VALUE)
	{
		printf("Open DDF Failed. GetLastError: %d\n", GetLastError());
		return -1;
	}

 	// create buffer for file. Note we fail if its really big. Who wants a DDF file that big?
 	DWORD cbFile;
 	cbFile = GetFileSize(DDFFile, NULL);

 	char *rgchBuf = new char[cbFile+2];

	DWORD cbRead;
 	if (!ReadFile(DDFFile, rgchBuf, cbFile, &cbRead, NULL))
	{
	 	CloseHandle(DDFFile);
		printf("Read DDF Failed. GetLastError: %d\n", GetLastError());
		return -1;
	}
 	
 	CloseHandle(DDFFile);
	rgchBuf[cbRead]='\0';
 	
	printf("Open...");
	if (!MsiOpenDatabaseA(argv[1], (char *)MSIDBOPEN_TRANSACT, &hDB))
	{
		char *szCurrent = rgchBuf;
		int iSequence = 0;
		while (szCurrent && *szCurrent) 
		{
			// we want to skip any lines that begin with a ';' or 
			// set values.
			if (*szCurrent == ';')
			{
				szCurrent = strchr(szCurrent, '\n');
				szCurrent++;
				continue;
			}
				
			if (0 == strncmp(szCurrent, ".Set", 4))
			{
				szCurrent = strchr(szCurrent, '\n');
				szCurrent++;
				continue;
			}

			// all other lines are in DDF format, which is
			// filename			name in cab
			// which for us is
			// filename			filekey
			// filename can have %DARWIN%, %VERSION%, %BUILDDIR%, in it
			// which are replaced by the values given on the command line
			iSequence++;

			// copy the filename, replacing as needed
			char rgchFileName[256];
			rgchFileName[0] = 0;
			char *szFileName = rgchFileName;
			while (!isspace(*szCurrent))
			{
				if (*szCurrent == '%') 
				{
					*szFileName = '\0';
					if (0 == strncmp(szCurrent, "%DARWIN%", 8))
					{
						strcat(szFileName, argv[3]);
						szCurrent += 8;
						szFileName += strlen(argv[3]);
						continue;
					} 
					if (0 == strncmp(szCurrent, "%VERSION%", 9))
					{
						strcat(szFileName, argv[4]);
						szCurrent += 9;
						szFileName += strlen(argv[4]);
						continue;
					} 
					if (0 == strncmp(szCurrent, "%BUILDDIR%", 10))
					{
						strcat(rgchFileName, argv[5]);
						szCurrent += 10;
						szFileName += strlen(argv[5]);
						continue;
					} 
				}
				*szFileName++ = *szCurrent++;
			}
			*szFileName = '\0';

			// eat whitespace
			while (*szCurrent && isspace(*szCurrent))
				szCurrent++;

			// the rest of this line is the file key. If no endline, the rest of file is
			char *szFileKey = szCurrent;
			szCurrent = strchr(szCurrent, '\r');
			if (szCurrent != NULL)
			{
				*szCurrent = '\0';
				szCurrent+=2;
			}

			// get the file size, version and language

			HANDLE hFile = CreateFileA(rgchFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			if (hFile == INVALID_HANDLE_VALUE)
			{
				printf("Open File for %s, Failed. GetLastError: %d\n", rgchFileName, GetLastError());
				MsiCloseHandle(hDB);
				return -1;
			}

			// note that we assume the file is less than 4GB
			DWORD uiFileSize = GetFileSize(hFile, NULL);
			CloseHandle(hFile);

			char rgchFileVersion[50];
			DWORD cchFileVersion = 50;
			char rgchFileLanguage[100];
			DWORD cchFileLanguage = 50;
			UINT iStat = MsiGetFileVersionA(rgchFileName, rgchFileVersion, &cchFileVersion, rgchFileLanguage, &cchFileLanguage);
			if (iStat == ERROR_FILE_INVALID)
			{
				rgchFileVersion[0] = '\0';
				rgchFileLanguage[0] = '\0';
			}
			else if (iStat != ERROR_SUCCESS) 
			{
				printf("Failed to get version info for file %s.\n", rgchFileName);
				MsiCloseHandle(hDB);
				return -1;
			}

			// build and execute the query
			MSIHANDLE hView;
			char szQuery[500];
			sprintf(szQuery, "UPDATE `File` SET `FileSize`=%d, `Version`='%s', `Language`='%s', `Sequence`=%d WHERE `File`='%s'", uiFileSize, rgchFileVersion, rgchFileLanguage, iSequence, szFileKey);			
			if (ERROR_SUCCESS != MsiDatabaseOpenViewA(hDB, szQuery, &hView) ||
				ERROR_SUCCESS != MsiViewExecute(hView, 0))
			{
				printf("Failed to get version info for file %s.\n", rgchFileName);
				MsiCloseHandle(hDB);
				return -1;
			}

			MsiCloseHandle(hView);
			printf("Updated %s. Size: %d, Version %s, Language: %s\n", rgchFileName, uiFileSize, rgchFileVersion, rgchFileLanguage);

		}	
		MsiDatabaseCommit(hDB);
		MsiCloseHandle(hDB);
	}
	else
		printf("Failed to Open Database");

	delete[] rgchBuf;
	printf("Done.\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msisip\msisip.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msisip.cpp
//
//  Contents:   MSI SIP implementation
//
//--------------------------------------------------------------------------

#include "_msisip.h"

#define CUTOFF 8 // cutoff for using insSort instead of QSort

//////////////////////////////////////////////////////////////////////////////
//
// standard DLL exports ...
//----------------------------------------------------------------------------
//

BOOL WINAPI DllMain(HANDLE /*hInstDLL*/, DWORD /*fdwReason*/, LPVOID /*lpvReserved*/)
{
	return TRUE;
}

STDAPI DllRegisterServer(void)
{
	SIP_ADD_NEWPROVIDER sProv;

	HRESULT hr = S_OK;

	// must first init struct to 0
	memset(&sProv, 0x00, sizeof(SIP_ADD_NEWPROVIDER));

	// add registration info
	sProv.cbStruct               = sizeof(SIP_ADD_NEWPROVIDER);
	sProv.pwszDLLFileName        = MSI_NAME;
	sProv.pgSubject              = &gMSI;
//	sProv.pwszIsFunctionName is unsupported because we can't convert hFile to IStorage
	sProv.pwszGetFuncName        = MSI_SIP_GETSIG_FUNCTION;
	sProv.pwszPutFuncName        = MSI_SIP_PUTSIG_FUNCTION;
	sProv.pwszCreateFuncName     = MSI_SIP_CREATEHASH_FUNCTION;
	sProv.pwszVerifyFuncName     = MSI_SIP_VERIFYHASH_FUNCTION;
	sProv.pwszRemoveFuncName     = MSI_SIP_REMOVESIG_FUNCTION;
	sProv.pwszIsFunctionNameFmt2 = MSI_SIP_MYFILETYPE_FUNCTION;

	// register MSI SIP provider with crypto
	HINSTANCE hInstCrypto = LoadLibrary(CRYPT32_DLL);
	if (!hInstCrypto)
	{
		// ERROR, unable to load crypt32.dll
		return E_FAIL; // - fatal error
	}

	PFnCryptSIPAddProvider pfnCryptSIPAddProvider = (PFnCryptSIPAddProvider) GetProcAddress(hInstCrypto, CRYPTOAPI_CryptSIPAddProvider);
	if (!pfnCryptSIPAddProvider)
	{
		// ERROR, unable to get proc address on CryptSIPAddProvider
		FreeLibrary(hInstCrypto);
		return E_FAIL; // - fatal error
	}

	if (!pfnCryptSIPAddProvider(&sProv))
		hr = E_FAIL;

	FreeLibrary(hInstCrypto);

	return hr;
}


STDAPI DllUnregisterServer(void)
{
	HINSTANCE hInstCrypto = LoadLibrary(CRYPT32_DLL);
	if (!hInstCrypto)
	{
		// ERROR, unable to load crypt32.dll
		return E_FAIL; // - fatal error
	}

	PFnCryptSIPRemoveProvider pfnCryptSIPRemoveProvider = (PFnCryptSIPRemoveProvider) GetProcAddress(hInstCrypto, CRYPTOAPI_CryptSIPRemoveProvider);
	if (!pfnCryptSIPRemoveProvider)
	{
		// ERROR, unable to get proc address on CryptSIPRemoveProvider
		FreeLibrary(hInstCrypto);
		return E_FAIL; // - fatal error
	}

	// unregister MSI SIP provider, ignore return
	pfnCryptSIPRemoveProvider(&gMSI);

	FreeLibrary(hInstCrypto);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// STANDARD SIP FUNCTIONS
//----------------------------------------------------------------------------
//
//  these are the functions that are exported (registered) to the Trust 
//  System.
//


/////////////////////////////////////////////////////////////////////////////////
// BOOL WINAPI MsiSIPGetSignedDataMsg(...)
//
// PURPOSE:
//   this is the function that will be called when the Trust System is trying
//   to retrieve the digital signature from the MSI package 
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      ERROR_NOT_ENOUGH_MEMORY:        error allocating memory
//      TRUST_E_SUBJECT_FORM_UNKNOWN:   unknown subject type.
//      ERROR_INVALID_PARAMETER:        bad argument passed in
//      ERROR_BAD_FORMAT:               file/data format is not correct
//                                      for the requested SIP.
//      ERROR_INSUFFICIENT_BUFFER:      pbData was not big enough to hold
//                                      the data.  pdwDataLen
//                                      contains the required size.
//
BOOL WINAPI MsiSIPGetSignedDataMsg(IN     SIP_SUBJECTINFO *pSubjectInfo,    /* SIP subject information */
								   OUT    DWORD           *pdwEncodingType, /* encoding type */
								   IN     DWORD           dwIndex,          /* index location of signature (0) */
								   IN OUT DWORD           *pdwDataLen,      /* length of digital signature */
								   OUT    BYTE            *pbData)          /* digital signature byte stream */
{
	BOOL fRet = FALSE; // init to FALSE
	bool fOLEInitialized = false;
	DWORD dwLastError = 0; // init to ERROR_SUCCESS

	//  check the parameters passed in
	if (!pSubjectInfo || !pdwDataLen || !pdwEncodingType || dwIndex != 0
		|| !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
	{
		SetLastError((DWORD)ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	// load ole32.dll
	HINSTANCE hInstOLE = LoadLibrary(OLE32_DLL);
	if (!hInstOLE)
		return FALSE;

#ifndef UNICODE
	// fix bad version of ole32.dll on Win9X
	PatchOLE(hInstOLE);
#endif // !UNICODE

	// OLE::CoInitialize(NULL)
	if (!MyCoInitialize(hInstOLE, &fOLEInitialized))
	{
		dwLastError = GetLastError();
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		SetLastError(dwLastError);
		return FALSE;
	}

	if (!VerifySubjectGUID(hInstOLE, pSubjectInfo->pgSubjectType))
	{
		dwLastError = GetLastError();
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		SetLastError(dwLastError);
		return FALSE;
	}

	if (!pbData)
	{
		//  just calling to get length, init to 0
		*pdwDataLen = 0;
	}

	//  default to certificate/message encoding
	*pdwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;

	// open the storage (read, write exclusive)
	PStorage pStorage(0);
	pStorage = GetStorageFromSubject(pSubjectInfo, (STGM_DIRECT|STGM_READ|STGM_SHARE_DENY_WRITE), hInstOLE, /*fCloseFile*/false);
	if (!pStorage)
	{
		// retry in transact mode without denying write -- expensive because makes a copy
		pStorage = GetStorageFromSubject(pSubjectInfo, (STGM_TRANSACTED|STGM_READ|STGM_SHARE_DENY_NONE), hInstOLE, /*fCloseFile*/false);
	}

	if (pStorage)
	{
		// retrieve digital signature
		if (GetSignatureFromStorage(*pStorage, pbData, dwIndex, pdwDataLen))
			fRet = TRUE;
	}

	// grab the last error if we haven't yet done so and we had a failure
	if (!fRet && ERROR_SUCCESS == dwLastError)
		dwLastError = GetLastError();

	// force release
	pStorage = 0;

	// OLE::CoUninitialize()
	MyCoUninitialize(hInstOLE, fOLEInitialized);

	// Unload ole32.dll
	FreeLibrary(hInstOLE);

	// update the last error if failure
	if (ERROR_SUCCESS != dwLastError)
		SetLastError(dwLastError);

	return fRet;
}

/////////////////////////////////////////////////////////////////////////////////
// BOOL WINAPI MsiSIPPutSignedDataMsg(...)
//
// PURPOSE:
//   this is the function that will be called when the Trust System wants the SIP
//   to store the digital signature in the MSI package
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                        Errors occured.  See GetLastError()
//
// Last Errors:
//      ERROR_NOT_ENOUGH_MEMORY:        error allocating memory
//      TRUST_E_SUBJECT_FORM_UNKNOWN:   unknown subject type.
//      CRYPT_E_BAD_LEN:                the length specified was insufficient.
//      ERROR_INVALID_PARAMETER:        bad argument passed in
//      ERROR_BAD_FORMAT:               file/data format is not correct
//                                      for the requested SIP.
//
BOOL WINAPI MsiSIPPutSignedDataMsg(IN  SIP_SUBJECTINFO *pSubjectInfo,      /* SIP subject info */
								   IN  DWORD           /*dwEncodingType*/, /* encoding type */
								   OUT DWORD           *pdwIndex,          /* index of digital signature (0) */
								   IN  DWORD           dwDataLen,          /* length of digital signature */
								   IN  BYTE            *pbData)            /* digital signature byte stream */
{
	BOOL fRet = FALSE; // init to FALSE
	bool fOLEInitialized = false;
	DWORD dwLastError = 0; // init to ERROR_SUCCESS

	// check parameters
	if (!pSubjectInfo || !pdwIndex || !pbData || (dwDataLen < 1)
		|| !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
	{
		SetLastError((DWORD)ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	
	*pdwIndex = 0;

	// load ole32.dll
	HINSTANCE hInstOLE = LoadLibrary(OLE32_DLL);
	if (!hInstOLE)
		return FALSE;

#ifndef UNICODE
	// fix bad version of ole32.dll on Win9X
	PatchOLE(hInstOLE);
#endif // !UNICODE

	// OLE::CoInitialize(NULL)
	if (!MyCoInitialize(hInstOLE, &fOLEInitialized))
	{
		dwLastError = GetLastError();
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		SetLastError(dwLastError);
		return FALSE;
	}

	if (!VerifySubjectGUID(hInstOLE, pSubjectInfo->pgSubjectType))
	{
		dwLastError = GetLastError();
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		SetLastError(dwLastError);
		return FALSE;
	}

	// open storage (write, write exclusive, transacted [prevents data corruption, rollback if no commit])
	PStorage pStorage(GetStorageFromSubject(pSubjectInfo, (STGM_TRANSACTED | STGM_WRITE | STGM_SHARE_DENY_WRITE), hInstOLE, /*fCloseFile*/true));
	if (pStorage)
	{
		// save digital signature
		if (PutSignatureInStorage(*pStorage, pbData, dwDataLen, pdwIndex))
		{
			// try to save changes
			if (SUCCEEDED(pStorage->Commit(STGC_OVERWRITE)))
				fRet = TRUE;
		}
	}

	// grab the last error if we haven't yet done so and we had a failure
	if (!fRet && ERROR_SUCCESS == dwLastError)
		dwLastError = GetLastError();

	// force release
	pStorage = 0;

	// OLE::CoUninitialize()
	MyCoUninitialize(hInstOLE, fOLEInitialized);

	// Unload ole32.dll
	FreeLibrary(hInstOLE);

	// update the last error if failure
	if (ERROR_SUCCESS != dwLastError)
		SetLastError(dwLastError);

	return fRet;
}

/////////////////////////////////////////////////////////////////////////////////
// BOOL WINAPI MsiSIPRemoveSignedDataMsg(...)
//
// PURPOSE:
//   this is the function that will be called when the Trust System wants to
//   remove the "old" digital signature 
//
// Returns: 
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      TRUST_E_SUBJECT_FORM_UNKNOWN:   unknown subject type.
//      CRYPT_E_NO_MATCH:               could not find the specified index
//      ERROR_INVALID_PARAMETER:        bad argument passed in
//      ERROR_BAD_FORMAT:               file/data format is not correct
//                                      for the requested SIP.
//
BOOL WINAPI MsiSIPRemoveSignedDataMsg(IN SIP_SUBJECTINFO *pSubjectInfo, /* SIP subject info */
									  IN DWORD           dwIndex)       /* index of digital signature stream (0) */
{
	BOOL fRet = FALSE; // init to FALSE
	bool fOLEInitialized = false;
	DWORD dwLastError = 0; // init to ERROR_SUCCESS

	// check parameters
	if (!pSubjectInfo || dwIndex != 0 || !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
	{
		SetLastError((DWORD)ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	// load ole32.dll
	HINSTANCE hInstOLE = LoadLibrary(OLE32_DLL);
	if (!hInstOLE)
		return FALSE;

#ifndef UNICODE
	// fix bad version of ole32.dll on Win9X
	PatchOLE(hInstOLE);
#endif // !UNICODE

	// OLE::CoInitialize(NULL)
	if (!MyCoInitialize(hInstOLE, &fOLEInitialized))
	{
		dwLastError = GetLastError();
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		SetLastError(dwLastError);
		return FALSE;
	}

	if (!VerifySubjectGUID(hInstOLE, pSubjectInfo->pgSubjectType))
	{
		dwLastError = GetLastError();
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		SetLastError(dwLastError);
		return FALSE;
	}

	// open storage -- ReadWrite, WriteExclusive, Transacted (prevent corruption of direct)
	PStorage pStorage(GetStorageFromSubject(pSubjectInfo, (STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_DENY_WRITE), hInstOLE, /*fCloseFile*/true));
	if (pStorage)
	{
		// delete digital signature stream
		if (RemoveSignatureFromStorage(*pStorage, dwIndex))
		{
			// try to save changes
			if (SUCCEEDED(pStorage->Commit(STGC_OVERWRITE)))
				fRet = TRUE;
		}
	}

	// grab the last error if we haven't yet done so and we had a failure
	if (!fRet && ERROR_SUCCESS == dwLastError)
		dwLastError = GetLastError();

	// force release
	pStorage = 0;

	// OLE::CoUninitialize()
	MyCoUninitialize(hInstOLE, fOLEInitialized);

	// Unload ole32.dll
	FreeLibrary(hInstOLE);

	// update the last error if failure
	if (ERROR_SUCCESS != dwLastError)
		SetLastError(dwLastError);

	return fRet;
}


/////////////////////////////////////////////////////////////////////////////////
// BOOL WINAPI MsiSIPCreateIndirectData(...)
//
// PURPOSE:
//   this is the function that will be called when the Trust System asks the
//   SIP to hash the MSI package
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      NTE_BAD_ALGID:                  Bad Algorithm Identifyer
//      ERROR_NOT_ENOUGH_MEMORY:        error allocating memory
//      TRUST_E_SUBJECT_FORM_UNKNOWN:   unknown subject type.
//      ERROR_INVALID_PARAMETER:        bad argument passed in
//      ERROR_BAD_FORMAT:               file/data format is not correct
//                                      for the requested SIP.
//
//
BOOL WINAPI MsiSIPCreateIndirectData(IN     SIP_SUBJECTINFO   *pSubjectInfo, /* SIP subject info */
									 IN OUT DWORD             *pdwDataLen,   /* length of indirect data */
									 OUT    SIP_INDIRECT_DATA *psData)       /* indirect data (serialized) */
{
	BOOL fRet = FALSE; // init to FALSE
	bool fOLEInitialized = false;
	DWORD dwLastError = 0; // init to ERROR_SUCCESS

	// check parameters
	if (!pSubjectInfo || !pdwDataLen || !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType))
		|| !pSubjectInfo->DigestAlgorithm.pszObjId)
	{
		SetLastError((DWORD)ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	// load ole32.dll
	HINSTANCE hInstOLE = LoadLibrary(OLE32_DLL);
	if (!hInstOLE)
		return FALSE;

#ifndef UNICODE
	// fix bad version of ole32.dll on Win9X
	PatchOLE(hInstOLE);
#endif // !UNICODE

	// OLE::CoInitialize(NULL)
	if (!MyCoInitialize(hInstOLE, &fOLEInitialized))
	{
		dwLastError = GetLastError();
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		SetLastError(dwLastError);
		return FALSE;
	}

	if (!VerifySubjectGUID(hInstOLE, pSubjectInfo->pgSubjectType))
	{
		dwLastError = GetLastError();
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		SetLastError(dwLastError);
		return FALSE;
	}

	// load advapi32.dll
	HINSTANCE hInstAdvapi = LoadLibrary(ADVAPI32_DLL);
	if (!hInstAdvapi)
	{
		// OLE::CoUnintialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		return FALSE;
	}

	// set up function ptrs for Crypt API implemented in advapi32.dll
	// -- requires IE 3.02 or > (for free with Win98, WinNT 4.0 SP3 or >, Win2K)
	PFnCryptReleaseContext pfnCryptReleaseContext = (PFnCryptReleaseContext) GetProcAddress(hInstAdvapi, CRYPTOAPI_CryptReleaseContext);
	if (!pfnCryptReleaseContext)
		dwLastError = GetLastError();
	PFnCryptCreateHash pfnCryptCreateHash = (PFnCryptCreateHash) GetProcAddress(hInstAdvapi, CRYPTOAPI_CryptCreateHash);
	if (!pfnCryptCreateHash)
		dwLastError = GetLastError();
	PFnCryptHashData pfnCryptHashData = (PFnCryptHashData) GetProcAddress(hInstAdvapi, CRYPTOAPI_CryptHashData);
	if (!pfnCryptHashData)
		dwLastError = GetLastError();
	PFnCryptGetHashParam pfnCryptGetHashParam = (PFnCryptGetHashParam) GetProcAddress(hInstAdvapi, CRYPTOAPI_CryptGetHashParam);
	if (!pfnCryptGetHashParam)
		dwLastError = GetLastError();
	PFnCryptDestroyHash pfnCryptDestroyHash = (PFnCryptDestroyHash) GetProcAddress(hInstAdvapi, CRYPTOAPI_CryptDestroyHash);
	if (!pfnCryptDestroyHash)
		dwLastError = GetLastError();

	if (!pfnCryptReleaseContext || !pfnCryptCreateHash || !pfnCryptHashData || !pfnCryptGetHashParam || !pfnCryptDestroyHash)
	{
		// unload advapi32.dll
		FreeLibrary(hInstAdvapi);
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		// set last error
		SetLastError(dwLastError);
		return FALSE;
	}

	//  assign our version number
	pSubjectInfo->dwIntVersion = WIN_CERT_REVISION_2_0;

	//
	//  the SPC Sig Info data structure allows us (sip) to store
	//  encoded information that only we look at....
	//
	SPC_SIGINFO sSpcSigInfo;
	memset((void*)&sSpcSigInfo, 0x00, sizeof(SPC_SIGINFO));
	sSpcSigInfo.dwSipVersion = MSI_SIP_CURRENT_VERSION;
	memcpy((void*)&sSpcSigInfo.gSIPGuid, &gMSI, sizeof(GUID));

	// load crypt32.dll for CryptEncodeObject, CertOIDToAlgId
	HINSTANCE hInstCrypto = LoadLibrary(CRYPT32_DLL);
	if (!hInstCrypto)
	{
		// retrieve last error
		dwLastError = GetLastError();
		// unload advapi32.dll
		FreeLibrary(hInstAdvapi);
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		// set last error
		SetLastError(dwLastError);
		return FALSE;
	}

	// get proc address on CryptEncodeObject (used by all below)
	PFnCryptEncodeObject pfnCryptEncodeObject = (PFnCryptEncodeObject) GetProcAddress(hInstCrypto, CRYPTOAPI_CryptEncodeObject);
	if (!pfnCryptEncodeObject)
	{
		// retrieve last error
		dwLastError = GetLastError();
		// unload advapi32.dll
		FreeLibrary(hInstAdvapi);
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		// unload crypt32.dll
		FreeLibrary(hInstCrypto);
		// set last error
		SetLastError(dwLastError);
		return FALSE;
	}

	// grab the crypto provider containing implementation of crypto algorithms for hashing
	HCRYPTPROV hProv = GetProvider(pSubjectInfo, hInstAdvapi);
	if (!hProv)
	{
		// retrieve last error
		dwLastError = GetLastError();
		// unload advapi32.dll
		FreeLibrary(hInstAdvapi);
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		// unload crypt32.dll
		FreeLibrary(hInstCrypto);
		// set last error
		SetLastError(dwLastError);
		return FALSE;
	}


	//
	//  the following calculates the length that the signature
	//  will be once we add our (sip) stuff to it and encode it.
	//

	/* initialize to size of structure */
	DWORD dwRetLen = sizeof(SIP_INDIRECT_DATA);

	/* add size of algorithm identifier */
	// crypt_algorithm_identifier...
		// obj id
	dwRetLen += lstrlenA(pSubjectInfo->DigestAlgorithm.pszObjId);
	dwRetLen += 1;  // null term.
		// parameters (none)...

	/* add size of encoded attribute */
	// crypt_attribute_type_value size...
	dwRetLen += lstrlenA(SPC_SIGINFO_OBJID);
	dwRetLen += 1; // null term.

	// size of the value (flags)....
	DWORD dwEncLen = 0;
	if (!pfnCryptEncodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, SPC_SIGINFO_OBJID, &sSpcSigInfo, NULL, &dwEncLen))
	{
		// retrieve last error
		dwLastError = GetLastError();
		// release crypto provider if we acquired it
		if ((hProv != pSubjectInfo->hProv) && (hProv))
		{
			pfnCryptReleaseContext(hProv, 0);
		}
		// unload advapi32.dll
		FreeLibrary(hInstAdvapi);
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		// unload crypt32.dll
		FreeLibrary(hInstCrypto);
		// set last error
		SetLastError(dwLastError);
		return FALSE;
	}
	if (dwEncLen > 0)
	{
		/* add size of encoding */
		dwRetLen += dwEncLen;
		HCRYPTHASH hHash = 0;
		DWORD      dwAlgId;

		// hash of subject
		PFnCertOIDToAlgId pfnCertOIDToAlgId = (PFnCertOIDToAlgId) GetProcAddress(hInstCrypto, CRYPTOAPI_CertOIDToAlgId);
		if (!pfnCertOIDToAlgId)
		{
			dwLastError = GetLastError();
			fRet = FALSE;
		}
		else if ((dwAlgId = pfnCertOIDToAlgId(pSubjectInfo->DigestAlgorithm.pszObjId)) == 0)
		{
			dwLastError = (DWORD)NTE_BAD_ALGID;
			fRet = FALSE;
		}
		else if (!(pfnCryptCreateHash(hProv, dwAlgId, NULL, 0, &hHash)))
		{
			dwLastError = GetLastError();
			fRet = FALSE;
		}
		// just to get hash length
		else if (pfnCryptHashData(hHash,(const BYTE *)" ",1,0))
		{
			DWORD cbDigest = 0;
            if (pfnCryptGetHashParam(hHash, HP_HASHVAL, NULL, &cbDigest,0))
			{
				if (cbDigest > 0)
				{
					/* add size of hash */
					dwRetLen += cbDigest;
					fRet = TRUE;
				}
			}
			else
			{
				dwLastError = GetLastError();
				fRet = FALSE;
			}
		}
		if (hHash)
		{
			pfnCryptDestroyHash(hHash);
		}
	}

	if (!fRet)
	{
		// release crypto provider if we acquired it
		if ((hProv != pSubjectInfo->hProv) && (hProv))
		{
			pfnCryptReleaseContext(hProv, 0);
		}
		// unload advapi32.dll
		FreeLibrary(hInstAdvapi);
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		// unload crypt32.dll
		FreeLibrary(hInstCrypto);
		// set last error
		SetLastError(dwLastError);
		return FALSE;
	}

	PStorage pStorage(0);
	if (!psData)
	{
		// only want size -- set size and set TRUE status
		*pdwDataLen = dwRetLen;
		fRet = TRUE;
	}
	else if (psData && *pdwDataLen < dwRetLen)
	{
		// psData is not big enough
		SetLastError((DWORD)ERROR_INSUFFICIENT_BUFFER);
		*pdwDataLen = dwRetLen; // set size required in input param
		fRet = FALSE;
	}
	// if psData, open storage (read, write exclusive)
	else if (psData && (pStorage = GetStorageFromSubject(pSubjectInfo, (STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE), hInstOLE,/*fCloseFile*/true)))
	{
		//  hash the MSI package
		DWORD cbDigest = 0;
		BYTE  *pbDigest = DigestStorage(hInstOLE, hInstAdvapi, *pStorage, hProv, pSubjectInfo->DigestAlgorithm.pszObjId, &cbDigest);
		if (pbDigest)
		{
			dwEncLen = 0;
			if (!pfnCryptEncodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, SPC_SIGINFO_OBJID, &sSpcSigInfo, NULL, &dwEncLen))
			{
				dwLastError = GetLastError();
				dwEncLen = 0;
				fRet = FALSE;
			}
			if (dwEncLen > 0)
			{
				BYTE *pbAttrData = (BYTE *)new BYTE[dwEncLen];

				if (pbAttrData)
				{
					if (pfnCryptEncodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, SPC_SIGINFO_OBJID, &sSpcSigInfo, pbAttrData, &dwEncLen))
					{
						//  assign allocated memory to our structure.  
						//  This is like this because it MUST be serialized!
						//
						fRet = FALSE;

						/* initialize offset pointer */
						BYTE* pbOffset = (BYTE*)psData + sizeof(SIP_INDIRECT_DATA);
						int cbRemainingLength = *pdwDataLen - sizeof(SIP_INDIRECT_DATA);
						
						int iLen = lstrlenA(SPC_SIGINFO_OBJID) + 1;
						if ( cbRemainingLength < iLen )
						{
							dwLastError = ERROR_INSUFFICIENT_BUFFER;
							goto CreateIndirectData_EndSerializedCopy;
						}

						/* copy object Id */
						HRESULT hRes = StringCbCopyA((char *)pbOffset, cbRemainingLength, SPC_SIGINFO_OBJID);
						if ( FAILED(hRes) )
						{
							dwLastError = hRes;
							goto CreateIndirectData_EndSerializedCopy;
						}
						psData->Data.pszObjId   = (LPSTR)pbOffset;
						pbOffset += iLen; // update offset pointer
						cbRemainingLength -= iLen;
						
						if ( cbRemainingLength < dwEncLen)
						{
							dwLastError = ERROR_INSUFFICIENT_BUFFER;
							goto CreateIndirectData_EndSerializedCopy;
						}

						/* copy encoded attribute */
						memcpy((void *)pbOffset,pbAttrData,dwEncLen);
						psData->Data.Value.pbData   = (BYTE *)pbOffset;
						psData->Data.Value.cbData   = dwEncLen;
						pbOffset += dwEncLen; // update offset pointer
						cbRemainingLength -= dwEncLen;
						
						iLen = lstrlenA((char *)pSubjectInfo->DigestAlgorithm.pszObjId) + 1;
						if ( cbRemainingLength < iLen )
						{
							dwLastError = ERROR_INSUFFICIENT_BUFFER;
							goto CreateIndirectData_EndSerializedCopy;
						}

						/* copy digest algorithm */
						hRes = StringCbCopyA((char *)pbOffset, cbRemainingLength, (char *)pSubjectInfo->DigestAlgorithm.pszObjId);
						if ( FAILED(hRes) )
						{
							dwLastError = hRes;
							goto CreateIndirectData_EndSerializedCopy;
						}
						psData->DigestAlgorithm.pszObjId            = (char *)pbOffset;
						psData->DigestAlgorithm.Parameters.cbData   = 0;
						psData->DigestAlgorithm.Parameters.pbData   = NULL;
						pbOffset += iLen; // update offset pointer
						cbRemainingLength -= iLen;
					
						if ( cbRemainingLength < cbDigest )
						{
							dwLastError = ERROR_INSUFFICIENT_BUFFER;
							goto CreateIndirectData_EndSerializedCopy;
						}

						/* copy hash digest */
						memcpy((void *)pbOffset,pbDigest,cbDigest);
						psData->Digest.pbData   = (BYTE *)pbOffset;
						psData->Digest.cbData   = cbDigest;
                        
						*pdwDataLen = dwRetLen; // set to amount of data copied
						fRet = TRUE;
					}// if (EncodeObject)
CreateIndirectData_EndSerializedCopy:
					delete [] pbAttrData;
				}// if (pbAttrData)
			}// if (dwRetLen)

			delete [] pbDigest;
		}// if (pbDigest)
	}

	// grab the last error if we haven't yet done so and we had a failure
	if (!fRet && ERROR_SUCCESS == dwLastError)
		dwLastError = GetLastError();

	// release crypto provider if we acquired it
	if ((hProv != pSubjectInfo->hProv) && (hProv))
	{
		pfnCryptReleaseContext(hProv, 0);
	}

	// force release
	pStorage = 0;

	// OLE::CoUninitialize()
	MyCoUninitialize(hInstOLE, fOLEInitialized);

	// Unload ole32.dll
	FreeLibrary(hInstOLE);

	// unload crypt32.dll
	FreeLibrary(hInstCrypto);

	// unload advapi32.dll
	if (hInstAdvapi)
		FreeLibrary(hInstAdvapi);

	// update the last error if failure
	if (ERROR_SUCCESS != dwLastError)
		SetLastError(dwLastError);

	return fRet;
}

/////////////////////////////////////////////////////////////////////////////////
// BOOL WINAPI MsiSIPVerifyIndirectData(...)
//
// PURPOSE:
//   this is the function that will be called when the Trust System is trying
//   to verify a hash in the digital signature for a MSI package 
//
// Returns: 
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      NTE_BAD_ALGID:                  Bad Algorithm Identifyer
//      ERROR_NOT_ENOUGH_MEMORY:        error allocating memory
//      TRUST_E_SUBJECT_FORM_UNKNOWN:   unknown subject type.
//      CRYPT_E_NO_MATCH:               could not find the specified index
//      CRYPT_E_SECURITY_SETTINGS:      due to security settings, the file
//                                      was not verified.
//      ERROR_INVALID_PARAMETER:        bad argument passed in
//      ERROR_BAD_FORMAT:               file/data format is not correct
//                                      for the requested SIP.
//
BOOL WINAPI MsiSIPVerifyIndirectData(IN SIP_SUBJECTINFO   *pSubjectInfo, /* SIP subject info */
									 IN SIP_INDIRECT_DATA *psData)       /* indirect hash data from digital signature */
{
	BOOL fRet = FALSE; // init to FALSE
	bool fOLEInitialized = false;
	DWORD dwLastError = 0; // init to ERROR_SUCCESS

	// check parameters
	if (!pSubjectInfo || !psData || !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
	{
		SetLastError((DWORD)ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	// load ole32.dll
	HINSTANCE hInstOLE = LoadLibrary(OLE32_DLL);
	if (!hInstOLE)
		return FALSE;

#ifndef UNICODE
	// fix bad version of ole32.dll on Win9X
	PatchOLE(hInstOLE);
#endif // !UNICODE

	// OLE::CoInitialize(NULL)
	if (!MyCoInitialize(hInstOLE, &fOLEInitialized))
	{
		dwLastError = GetLastError();
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		SetLastError(dwLastError);
		return FALSE;
	}

	if (!VerifySubjectGUID(hInstOLE, pSubjectInfo->pgSubjectType))
	{
		dwLastError = GetLastError();
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		SetLastError(dwLastError);
		return FALSE;
	}

	// load advapi32.dll
	HINSTANCE hInstAdvapi = LoadLibrary(ADVAPI32_DLL);
	if (!hInstAdvapi)
	{
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		return FALSE;
	}

	// grab the crypto provider containing implementation of crypto algorithms for hashing
	HCRYPTPROV hProv = GetProvider(pSubjectInfo, hInstAdvapi);
	if (!hProv)
	{
		// unload advapi32.dll
		FreeLibrary(hInstAdvapi);
		// OLE::CoUninitialize
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		return FALSE;
	}

	// open storage (read, write-exclusive)
	PStorage pStorage(0);
	if (pStorage = GetStorageFromSubject(pSubjectInfo, (STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE), hInstOLE,/*fCloseFile*/false))
	{
		// rehash the MSI package
		DWORD cbDigest = 0;
		BYTE *pbDigest = DigestStorage(hInstOLE, hInstAdvapi, *pStorage, hProv, psData->DigestAlgorithm.pszObjId, &cbDigest);
		if (pbDigest)
		{
			// compare the hashes
			if ((cbDigest != psData->Digest.cbData) || (memcmp(pbDigest, psData->Digest.pbData, cbDigest) != 0))
			{
				// ERROR, hashes do not match
				dwLastError = TRUST_E_BAD_DIGEST;
			}
			else
				fRet = TRUE; // signature hashes match

			delete[] pbDigest;
		}
	}

	// obtain last error if failure and dwLastError hasn't been set yet
	if (!fRet && ERROR_SUCCESS == dwLastError)
		dwLastError = GetLastError();

	// release crypto provider if we acquired it
	if ((hProv != pSubjectInfo->hProv) && (hProv))
	{
		PFnCryptReleaseContext pfnCryptReleaseContext = (PFnCryptReleaseContext) GetProcAddress(hInstAdvapi, CRYPTOAPI_CryptReleaseContext);
		if (pfnCryptReleaseContext)
			pfnCryptReleaseContext(hProv, 0);
		else if (fRet)
		{
			// only need to save off if haven't had an error yet
			dwLastError = GetLastError();
			fRet = FALSE;
		}
	}

	// force release
	pStorage = 0;

	// OLE::CoUninitialize()
	MyCoUninitialize(hInstOLE, fOLEInitialized);

	// Unload ole32.dll
	FreeLibrary(hInstOLE);

	// unload advapi32.dll
	if (hInstAdvapi)
		FreeLibrary(hInstAdvapi);

	// update the last error if failure
	if (ERROR_SUCCESS != dwLastError)
		SetLastError(dwLastError);

	return fRet;
}

/////////////////////////////////////////////////////////////////////////////////
// BOOL WINAPI MsiSIPIsMyTypeOfFile(...)
//
// PURPOSE:
//   this is the function that will be called when the Trust System is trying
//   to figure out which SIP to load... 
//
BOOL WINAPI MsiSIPIsMyTypeOfFile( IN WCHAR *pwszFileName, OUT GUID *pgSubject)
{
	BOOL fRet = FALSE; // init to FALSE
	bool fOLEInitialized = false;
	DWORD dwLastError = 0; // init to ERROR_SUCCESS

	// verify arguments
	if (!pwszFileName || !pgSubject)
		return FALSE;

	// load ole32.dll
	HINSTANCE hInstOLE = LoadLibrary(OLE32_DLL);
	if (!hInstOLE)
		return FALSE;

#ifndef UNICODE
	// fix bad version of ole32.dll on Win9X
	PatchOLE(hInstOLE);
#endif // !UNICODE

	// OLE::CoInitialize(NULL)
	if (!MyCoInitialize(hInstOLE, &fOLEInitialized))
	{
		dwLastError = GetLastError();
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		SetLastError(dwLastError);
		return FALSE;
	}

	PFnStgOpenStorage pfnStgOpenStorage = (PFnStgOpenStorage) GetProcAddress(hInstOLE, OLEAPI_StgOpenStorage);
	if (!pfnStgOpenStorage)
	{
		// OLE::CoUninitialize()
		MyCoUninitialize(hInstOLE, fOLEInitialized);
		// unload ole32.dll
		FreeLibrary(hInstOLE);
		return FALSE;
	}

	// attempt to open the file (readOnly, no share denials) as a storage
	PStorage pStorage(0);
	HRESULT hr = pfnStgOpenStorage(pwszFileName, (IStorage*)0, STGM_DIRECT|STGM_READ|STGM_SHARE_DENY_WRITE, (SNB)0, 0, &pStorage);
	if (FAILED(hr))
	{
		// retry in transacted mode in case file was already opened for writing (expensive in transact mode because makes a copy)
		hr = pfnStgOpenStorage(pwszFileName, (IStorage*)0, STGM_TRANSACTED|STGM_READ|STGM_SHARE_DENY_NONE, (SNB)0, 0, &pStorage);
	}
	if (SUCCEEDED(hr) && pStorage)
	{
		// obtain the STATSTG structure on the storage so we can see if this is our storage
		// MSI files have a particular CLSID
		STATSTG statstg;
		hr = pStorage->Stat(&statstg, STATFLAG_NONAME);
		if (SUCCEEDED(hr))
		{
			// iidMsi* is the low-order 32-bits
			itofEnum itof = itofUnknown; // init to unknown
				
			// Is this a database (or MergeModule)?
			if (statstg.clsid.Data1 == iidMsiDatabaseStorage1 || statstg.clsid.Data1 == iidMsiDatabaseStorage2)
				itof = itofDatabase;
			// else Is this a transform?
			else if (statstg.clsid.Data1 == iidMsiTransformStorage1 || statstg.clsid.Data1 == iidMsiTransformStorage2 || statstg.clsid.Data1 == iidMsiTransformStorageTemp)
				itof = itofTransform;
			// else Is this a patch?
			else if (statstg.clsid.Data1 == iidMsiPatchStorage1 || statstg.clsid.Data1 == iidMsiPatchStorage2)
				itof = itofPatch;

			// check final part of clsid
			if (itof != itofUnknown && 0 == memcmp(&statstg.clsid.Data2, &STGID_MsiDatabase2.Data2, sizeof(GUID)-sizeof(DWORD)))
			{
				// recognized MSI format
				*pgSubject = gMSI;
				fRet = TRUE;
			}
		}
	}

	// force release of IStorage ptr
	pStorage = 0;

	// OLE::CoUninitialize()
	MyCoUninitialize(hInstOLE, fOLEInitialized);

	// unload ole32.dll
	FreeLibrary(hInstOLE);

	return fRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// MSI SIP HELPER FUNCTIONS
//----------------------------------------------------------------------------
//
//  these are the functions that the exported (registered) SIP functions use
//

/////////////////////////////////////////////////////////////////////////////////
// BOOL GetSignatureFromStorage(...) 
//
// PURPOSE:
//    retrieves the digital signature from the MSI
//
// REQUIREMENTS:
//     (1) if pbData is NULL, return the size of the digital signature stream
//     (2) if pbData is not NULL, read the digital signature stream data into pbData
//
BOOL GetSignatureFromStorage(IStorage& riStorage, BYTE *pbData, DWORD /*dwSigIndex*/, DWORD *pdwDataLen)
{
	// open the signature stream
	PStream pStream(0);
	HRESULT hr = riStorage.OpenStream(wszDigitalSignatureStream, 0, (STGM_SHARE_EXCLUSIVE | STGM_READ), 0, &pStream);
	if (FAILED(hr) || !pStream)
	{
		SetLastError((DWORD)ERROR_BAD_FORMAT);
		return FALSE;
	}

	// determine the size of the stream
	STATSTG statstg;
	hr = pStream->Stat(&statstg, STATFLAG_NONAME);
	if (FAILED(hr))
	{
		SetLastError((DWORD)ERROR_BAD_FORMAT);
		return FALSE;
	}

	//!! ISSUE: ULARGE_INTEGER and 64-bit
	DWORD cbSize = statstg.cbSize.LowPart;

	if (!pbData)
	{
		//  just tell them how big it is
		*pdwDataLen = cbSize;
		return TRUE;
	}

	//
	//  we have the buffer, get the signature out of the file, check to make
	//  sure that pdwDataLen is large enough to hold it, and copy it into
	//  the pbData.
	//
	if (*pdwDataLen < cbSize)
	{
		// insufficient buffer
		*pdwDataLen = cbSize;
		SetLastError(ERROR_INSUFFICIENT_BUFFER);
		return FALSE;
	}

	// read digital signature into pbData
	DWORD cbRead = 0;
	hr = pStream->Read((void*)pbData, cbSize, &cbRead);
	if (FAILED(hr) || cbSize != cbRead)
	{
		SetLastError((DWORD)ERROR_BAD_FORMAT);
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
// BOOL PutSignatureInStorage(...)
//
// PURPOSE:
//    stores the digital signature in the MSI
//
// REQUIREMENTS:
//    Store the digital signature as a "system" stream in the MSI
// 
BOOL PutSignatureInStorage(IStorage& riStorage, BYTE *pbData, DWORD dwDataLen, DWORD *pdwIndex)
{
	//  
	//  We have a signature, store it in our file and add any table pointers, 
	//  offsets, etc. to enable us to find "this" signature.  If we handle 
	//  which type of signature goes where, we need to assign the pdwIndex.  
	//  Otherwise, just use it.
	//

	*pdwIndex = 0;

	// create digital signature stream
	PStream pStream(0);
	HRESULT hr = riStorage.CreateStream(wszDigitalSignatureStream, (STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_WRITE), 0, 0, &pStream);
	if (FAILED(hr) || !pStream)
	{
		SetLastError((DWORD)ERROR_BAD_FORMAT);
		return FALSE;
	}

	// write digital signature blob to stream
	DWORD cbWritten;
	hr = pStream->Write((void*)pbData, dwDataLen, &cbWritten);
	if (FAILED(hr) || dwDataLen != cbWritten)
	{
		SetLastError((DWORD)ERROR_BAD_FORMAT);
		return FALSE;
	}

	// commit stream (for transacted storage visibility)
	if (SUCCEEDED(pStream->Commit(STGC_OVERWRITE)))
		return TRUE;

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////////
// BOOL RemoveSignatureFromStorage(...)
//
// PURPOSE:
//    removes the digital signature in the MSI
//
// REQUIREMENTS:
//    Delete the digital signature stream from the MSI if it is there
// 
BOOL RemoveSignatureFromStorage(IStorage& riStorage, DWORD /*dwIndex*/)
{
	//
	//  we have been asked to remove a signature from the file.  If we 
	//  can, do it and return true otherwise return false... eg: if we 
	//  can't find the dwIndex signature in the file
	//

	// destroy the digital signature stream
	HRESULT hr = riStorage.DestroyElement(wszDigitalSignatureStream);
	if (FAILED(hr) && STG_E_FILENOTFOUND != hr)
	{
		SetLastError((DWORD)ERROR_BAD_FORMAT);
		return FALSE;
	}
	else
		SetLastError((DWORD)ERROR_SUCCESS); // clear LastError for STG_E_FILENOTFOUND

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
// void FreeSortedStorageElements(...)
//
//    frees the memory that OLE allocated for the names in the STATSTG struct
//
void FreeSortedStorageElements(HINSTANCE hInstOLE, STATSTG *psStatStg, DWORD cStgElem)
{
	if (!psStatStg || 0 == cStgElem || !hInstOLE)
		return;

	PFnCoTaskMemFree pfnCoTaskMemFree = (PFnCoTaskMemFree) GetProcAddress(hInstOLE, OLEAPI_CoTaskMemFree);
	if (!pfnCoTaskMemFree)
		return;

	for (int i = 0; i < cStgElem; i++)
	{
		// free the system allocated name
		if (psStatStg[i].pwcsName)
		{
			pfnCoTaskMemFree(psStatStg[i].pwcsName);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
// int CompareSTATSTG(...)
//
//    performs locale-insensitive compares of two STATSTG struct pwcsName members
//      returns  0    if stg1.pwcsName = stg2.pwcsName
//      returns neg   if stg1.pwcsName < stg2.pwcsName
//      returns pos   if stg1.pwcsName > stg2.pwcsName
//
int CompareSTATSTG(const STATSTG sStatStg1, const STATSTG sStatStg2)
{
	// Assert(psStatStg1->pwcsName && psStatStg2->pwcsName);

	unsigned int iLenStr1 = lstrlenW(sStatStg1.pwcsName) * sizeof(OLECHAR);
	unsigned int iLenStr2 = lstrlenW(sStatStg2.pwcsName) * sizeof(OLECHAR);

	int iRet = memcmp((void*)sStatStg1.pwcsName, (void*)sStatStg2.pwcsName, (iLenStr1 < iLenStr2) ? iLenStr1 : iLenStr2);
	if (0 == iRet)
	{
		// str match
		if (iLenStr1 == iLenStr2)
			return 0; // str1 == str2
		else if (iLenStr1 < iLenStr2)
			return -1; // str1 < str2
		else
			return 1; // str1 > str2
	}
	return iRet;
}

/////////////////////////////////////////////////////////////////////////////////
// void SwapStatStg(...)
//
//    swaps two STATSTG structures
//
void SwapStatStg(STATSTG *psStatStg, unsigned int iPos1, unsigned int iPos2)
{
	STATSTG sStatStgTmp = psStatStg[iPos1];
	psStatStg[iPos1]    = psStatStg[iPos2];
	psStatStg[iPos2]    = sStatStgTmp;
}


/////////////////////////////////////////////////////////////////////////////////
// void InsSortStatStg(...)
//
//    performs an InsertSort
//
void InsSortStatStg(STATSTG *psStatStg, unsigned int iFirst, unsigned int iLast)
{
	if (iLast <= iFirst)
		return; // nothing to do

	unsigned int iMax;
	while (iLast > iFirst)
	{
		// init iMax to first elem in list
		iMax = iFirst;

		// find highest elem in list
		for (unsigned int j = iFirst + 1; j <= iLast; j++)
		{
			if (CompareSTATSTG(psStatStg[j], psStatStg[iMax]) >= 0)
				iMax = j;
		}

		// move the highest elem to last pos
		SwapStatStg(psStatStg, iMax, iLast);

		iLast--;
	}
}


/////////////////////////////////////////////////////////////////////////////////
// void QSortStatStg(...)
//
//    performs a quick sort
//
void QSortStatStg(STATSTG *psStatStg, unsigned int iLeft, unsigned int iRight)
{
	if (iLeft >= iRight)
		return; // 1 elem, nothing to sort ... Assert (iLeft <= iRight)

	// below a certain size, it is faster to use a O(n^2) algm
	if ((iRight - iLeft + 1) < CUTOFF)
	{
		// use O(n^2) algm for sorting
		InsSortStatStg(psStatStg, iLeft, iRight);
	}
	else // implementation of a quicksort --> O(nlogn)
	{
		// choose partition elem
		unsigned int iPivotIndex = (iLeft + iRight)/2;

		// swap element to beginning of array
		SwapStatStg(psStatStg, iLeft, iPivotIndex);

		unsigned int iLow = iLeft;
		unsigned int iHigh = iRight+1;

		// partition the array such that everything on left is less than pivot value
		//  and everything on right is greater than pivot value
		for (;;)
		{
			do
			{
				// find first iLow such that psStatStg[iLow] > psStatStg[iLeft]
				// we'll then swap this element to the right
				iLow++;
			}
			while (iLow <= iRight && CompareSTATSTG	(psStatStg[iLow], psStatStg[iLeft]) <= 0);

			do
			{
				// find first iHigh such that psStatStg[iHigh] < psStatStg[iLeft]
				// we'll then swap this element to the left
				iHigh--;
			}
			while (iHigh > iLeft && CompareSTATSTG(psStatStg[iHigh], psStatStg[iLeft]) >= 0);

			if (iHigh < iLow)
				break;

			SwapStatStg(psStatStg, iLow, iHigh);
		}

		// put partition element in place
		SwapStatStg(psStatStg, iLeft, iHigh);

		// sort arrays [iLeft, iHigh-1], [iLow, iRight]
		if (iLeft != iHigh)
			QSortStatStg(psStatStg, iLeft, iHigh-1);

		// sort right partition
		if (iLow != iRight)
			QSortStatStg(psStatStg, iLow, iRight);
	}

}

/////////////////////////////////////////////////////////////////////////////////
// BOOL GetSortedStorageElements(...)
//
//    gets elements of storage in sorted order
//
BOOL GetSortedStorageElements(HINSTANCE hInstOLE, IStorage& riStorage, unsigned int *pcStgElem, STATSTG **ppsStatStg)
{
	// grab an enumerator
	IEnumSTATSTG *piEnum = NULL;
	HRESULT hr = riStorage.EnumElements(0, 0, 0, &piEnum);
	if (FAILED(hr) || !piEnum)
	{
		SetLastError(HRESULT_CODE(hr));
		return FALSE;
	}

	//
	// count the elements in storage
	//
	STATSTG rgsStatStg[10];
	ULONG cFetchedElem = -1;
	unsigned int cStgElem = 0;    // init to 0
	while (0 != cFetchedElem)
	{
		// cFetchedElem becomes 0 when we request elements and no more remain in enumeration
		hr = piEnum->Next(10, rgsStatStg, &cFetchedElem);
		if (FAILED(hr))
		{
			piEnum->Release();
			SetLastError(HRESULT_CODE(hr));
			return FALSE;
		}

		// add to count
		cStgElem += cFetchedElem;

		// release memory
		FreeSortedStorageElements(hInstOLE, rgsStatStg, cFetchedElem);
	}

	//
	// allocate an array of cStgElem and grab all elements in storage
	//
	STATSTG *psStatStg = NULL; // init to NULL
	if (cStgElem > 0)
	{
		// allocate STATSTG array
		psStatStg = (STATSTG*) new STATSTG[cStgElem];
		if (!psStatStg)
		{
			if (piEnum)
				piEnum->Release();
			
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			return FALSE;
		}

		// initialize array to 0
		memset((void*)psStatStg, 0, sizeof(STATSTG)*cStgElem);

		// reset the enumerator and grab all items
		piEnum->Reset();
		hr = piEnum->Next(cStgElem, psStatStg, &cFetchedElem);
		if (FAILED(hr) || cStgElem != cFetchedElem)
		{
			if (psStatStg)
			{
				FreeSortedStorageElements(hInstOLE, psStatStg, cStgElem);
				delete [] psStatStg;
				psStatStg = NULL;
			}

			piEnum->Release();
			SetLastError(HRESULT_CODE(hr));
			return FALSE;
		}

		// sort the storage elements, 0 based index
		QSortStatStg(psStatStg, 0, cStgElem-1);
	}

	// release the enumerator
	piEnum->Release();

	// set OUT parameters
	*pcStgElem = cStgElem;
	*ppsStatStg = psStatStg;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
// BOOL DigestStorageHelper(...)
//
//    recursive function for hashing storage it its substorages
//
BOOL DigestStorageHelper(HINSTANCE hInstOLE, HINSTANCE hInstAdvapi, IStorage& riStorage, bool fSubStorage, HCRYPTHASH hHash)
{
	if (!hInstOLE || !hInstAdvapi)
		return FALSE;

	HRESULT hr;
	DWORD   dwLastError = 0; // init to ERROR_SUCCESS

	//
	//  for each section of the file, allocate and fill pbData and cbData and 
	//  call this function.  Don't forget to exclude
	//  other signatures, any offsets or CRCs that may change when we 
	//  actually put the signature in the file.
	//

	PFnCryptHashData pfnCryptHashData = (PFnCryptHashData) GetProcAddress(hInstAdvapi, CRYPTOAPI_CryptHashData);
	if (!pfnCryptHashData)
		return FALSE;

	// grab elements of storage in sorted order
	unsigned int cSortedStatStg;
	STATSTG* psSortedStatStg = NULL;

	if (!GetSortedStorageElements(hInstOLE, riStorage, &cSortedStatStg, &psSortedStatStg) || !psSortedStatStg)
		return FALSE;

	// for each element, perform hashing
	unsigned int cStatStg = cSortedStatStg;
	STATSTG *psStatStg = psSortedStatStg;

	for (unsigned int i = 0; i < cSortedStatStg; i++)
	{
		switch (psStatStg[i].type)
		{
		case STGTY_STORAGE:
			{
				// Recurse on the storage
				PStorage pInnerStorage(0);
				hr = riStorage.OpenStorage(psStatStg[i].pwcsName, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE, 0, 0, &pInnerStorage);
				if (FAILED(hr) || !pInnerStorage)
				{
					FreeSortedStorageElements(hInstOLE, psSortedStatStg, cSortedStatStg);
					delete [] psSortedStatStg;
					SetLastError(HRESULT_CODE(hr));
					return FALSE;
				}
				if (!DigestStorageHelper(hInstOLE, hInstAdvapi, *pInnerStorage, /* fSubStorage = */ true, hHash))
				{
					dwLastError = GetLastError();
					FreeSortedStorageElements(hInstOLE, psSortedStatStg, cSortedStatStg);
					delete [] psSortedStatStg;
					SetLastError(dwLastError);
					return FALSE;
				}
				break;
			}
		case STGTY_STREAM:
			{

				// skip the digital signature stream, but only if it is the original storage file (digital signature
				// stream in embedded substorages is not ignored)
				if (!fSubStorage)
				{
	#ifdef UNICODE
					if (0 == lstrcmp(psStatStg[i].pwcsName, wszDigitalSignatureStream))
						break;
	#else // !UNICODE
					// convert pwcsName to ANSI
					char *szStream = NULL;
					int cch = WideCharToMultiByte(CP_ACP, 0, psStatStg[i].pwcsName, -1, NULL, 0, NULL, NULL);
					if (cch)
					{
						szStream = new char[cch];
						if (!szStream)
						{
							dwLastError = ERROR_NOT_ENOUGH_MEMORY;
							FreeSortedStorageElements(hInstOLE, psSortedStatStg, cSortedStatStg);
							delete [] psSortedStatStg;
							SetLastError(dwLastError);
							return FALSE;
						}
						szStream[0] = '\0';
						cch = WideCharToMultiByte(CP_ACP, 0, psStatStg[i].pwcsName, -1, szStream, sizeof(szStream)/sizeof(szStream[0]), NULL, NULL);
					}

					if (cch == 0)
					{
						// WideCharToMultiByte failed
						dwLastError = GetLastError();
						FreeSortedStorageElements(hInstOLE, psSortedStatStg, cSortedStatStg);
						delete [] psSortedStatStg;
						if (szStream)
							delete [] szStream;
						SetLastError(dwLastError);
						return FALSE;
					}

					// skip the digital signature stream
					if (0 == lstrcmp(szStream, szDigitalSignatureStream))
						break;

					if (szStream)
						delete [] szStream;
	#endif // UNICODE
				}

				// open the stream so we can hash it
				PStream pStream(0);
				hr = riStorage.OpenStream(psStatStg[i].pwcsName, 0, (STGM_SHARE_EXCLUSIVE | STGM_READ), 0, &pStream);
				if (FAILED(hr) || !pStream)
				{
					FreeSortedStorageElements(hInstOLE, psSortedStatStg, cSortedStatStg);
					delete [] psSortedStatStg;
					SetLastError(HRESULT_CODE(hr));
					return FALSE;
				}

				// determine the size of the stream so we can allocate memory to hold its data
				STATSTG statstg;
				hr = pStream->Stat(&statstg, STATFLAG_NONAME);
				if (FAILED(hr))
				{
					FreeSortedStorageElements(hInstOLE, psSortedStatStg, cSortedStatStg);
					delete [] psSortedStatStg;
					SetLastError(HRESULT_CODE(hr));
					return FALSE;
				}

				//!! ISSUE: ULARGE_INTEGER and 64-bit
				DWORD cbData = statstg.cbSize.LowPart;

				// allocate a buffer to hold stream data
				BYTE *pbData = new BYTE[cbData];
				if (!pbData)
				{
					FreeSortedStorageElements(hInstOLE, psSortedStatStg, cSortedStatStg);
					delete [] psSortedStatStg;
					SetLastError((DWORD)ERROR_NOT_ENOUGH_MEMORY);
					return FALSE;
				}

				// read data from stream into memory buffer
				DWORD cbRead = 0;
				hr = pStream->Read((void*)pbData, cbData, &cbRead);
				if (FAILED(hr) || cbData != cbRead)
				{
					FreeSortedStorageElements(hInstOLE, psSortedStatStg, cSortedStatStg);
					delete [] psSortedStatStg;
					SetLastError(HRESULT_CODE(hr));
					return FALSE;
				}

				// add stream's data to crypt hash
				if (!pfnCryptHashData(hHash, pbData, cbData, 0))
				{
					dwLastError = GetLastError();
					FreeSortedStorageElements(hInstOLE, psSortedStatStg, cSortedStatStg);
					delete [] psSortedStatStg;
					SetLastError(dwLastError);
					return FALSE;
				}

				// free the stream data buffer
				delete [] pbData;
				break;
			}
		default:
			{
				// SPC_BAD_STRUCTURED_STORAGE
				FreeSortedStorageElements(hInstOLE, psSortedStatStg, cSortedStatStg);
				delete [] psSortedStatStg;
				SetLastError(ERROR_BAD_FORMAT);
				return FALSE;
			}
		}
	} // end for each sorted element

	// free our sorted statstg list
	FreeSortedStorageElements(hInstOLE, psSortedStatStg, cSortedStatStg);
	delete [] psSortedStatStg;

	// hash our CLSID
	STATSTG statstg;
	hr = riStorage.Stat(&statstg, STATFLAG_NONAME);
	if (FAILED(hr))
	{
		SetLastError(HRESULT_CODE(hr));
		return FALSE;
	}

	if (!pfnCryptHashData(hHash, (BYTE*)&statstg.clsid, sizeof(statstg.clsid), 0))
		return FALSE;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
// BYTE *DigestStorage(...)
//
// PURPOSE:
//    creates a cryptographically unique hash of the MSI
//
// REQUIREMENTS:
//
// 
BYTE *DigestStorage(HINSTANCE hInstOLE, HINSTANCE hInstAdvapi, IStorage& riStorage, HCRYPTPROV hProv, char *pszDigestObjId, DWORD *pcbDigestRet)
{
	DWORD dwLastError = 0; // init to ERROR_SUCCESS

	// load crypt32.dll
	HINSTANCE hInstCrypto = LoadLibrary(CRYPT32_DLL);
	if (!hInstCrypto || !hInstOLE || !hInstAdvapi)
		return NULL;

	// determine algorithm to use
	PFnCertOIDToAlgId pfnCertOIDToAlgId = (PFnCertOIDToAlgId) GetProcAddress(hInstCrypto, CRYPTOAPI_CertOIDToAlgId);
	if (!pfnCertOIDToAlgId)
		return NULL;
	DWORD dwAlgId = pfnCertOIDToAlgId(pszDigestObjId);
	if (!dwAlgId)
	{
		SetLastError((DWORD)NTE_BAD_ALGID);
		return NULL;
	}

	PFnCryptCreateHash pfnCryptCreateHash = (PFnCryptCreateHash) GetProcAddress(hInstAdvapi, CRYPTOAPI_CryptCreateHash);
	if (!pfnCryptCreateHash)
		dwLastError = GetLastError();
	PFnCryptGetHashParam pfnCryptGetHashParam = (PFnCryptGetHashParam) GetProcAddress(hInstAdvapi, CRYPTOAPI_CryptGetHashParam);
	if (!pfnCryptGetHashParam)
		dwLastError = GetLastError();
	PFnCryptDestroyHash pfnCryptDestroyHash = (PFnCryptDestroyHash) GetProcAddress(hInstAdvapi, CRYPTOAPI_CryptDestroyHash);
	if (!pfnCryptDestroyHash)
		dwLastError = GetLastError();

	if (!pfnCryptCreateHash || !pfnCryptGetHashParam || !pfnCryptDestroyHash)
	{
		// unload crypt32.dll
		FreeLibrary(hInstCrypto);
		SetLastError(dwLastError);
		return NULL;
	}

	HCRYPTHASH hHash;
	if (!(pfnCryptCreateHash(hProv ,dwAlgId, NULL, 0, &hHash)))
	{
		dwLastError = GetLastError();
		// unload crypt32.dll
		FreeLibrary(hInstCrypto);
		SetLastError(dwLastError);
		return NULL;
	}

	if (!DigestStorageHelper(hInstOLE, hInstAdvapi, riStorage, /* fSubStorage = */ false, hHash))
	{
		dwLastError = GetLastError();
		// unload crypt32.dll
		FreeLibrary(hInstCrypto);
		SetLastError(dwLastError);
		return NULL;
	}

    //
	//  ok, we've hashed all of the pieces of our file that we care about, now
	//  get the allocate and get the hash value and return it.
	//
	BYTE *pbDigest  = NULL;
	*pcbDigestRet   = 0;

	pfnCryptGetHashParam(hHash, HP_HASHVAL, NULL, pcbDigestRet,0);

	if (pcbDigestRet)
	{
		pbDigest = new BYTE[*pcbDigestRet];
		if (pbDigest)
		{
			memset((void*)pbDigest, 0x00, *pcbDigestRet);
			if (!(pfnCryptGetHashParam(hHash, HP_HASHVAL, pbDigest, pcbDigestRet, 0)))
			{
				delete [] pbDigest;
				pbDigest = NULL;
			}
		}
		else
		{
			// unload crypt32.dll
			FreeLibrary(hInstCrypto);
			SetLastError((DWORD)ERROR_NOT_ENOUGH_MEMORY);
			return NULL;
		}
	}

	pfnCryptDestroyHash(hHash);

	// unload crypt32.dll
	FreeLibrary(hInstCrypto);

	return pbDigest;
}


/////////////////////////////////////////////////////////////////////////////////
// IStorage* GetStorageFromSubject(...)
//
// PURPOSE:
//     obtains an IStorage interface to the MSI file
//
// REQUIREMENTS:
//     (1) Close the file handle in SIP_SUBJECTINFO if open and set to NULL if fCloseFile is true
//     (2)  Return an IStorage interface to the MSI file
//
//
IStorage* GetStorageFromSubject(SIP_SUBJECTINFO *pSubjectInfo, DWORD grfMode, HINSTANCE hInstOLE, bool fCloseFile)
{
	// we have to go through OLE and not the file handle, so if it is valid,
	// we'll close it and mark it as such (NULL) to the caller (i.e. signcode.exe)
	// 
	// file handle is only closed if fCloseFile is true -- this is safe when FILE_SHARE_READ is specified on
	//  open file handle ... when opened for writing, we must close the file handle
	if (fCloseFile && NULL != pSubjectInfo->hFile && INVALID_HANDLE_VALUE != pSubjectInfo->hFile)
	{
		CloseHandle(pSubjectInfo->hFile);
		pSubjectInfo->hFile = NULL;
	}

	PFnStgOpenStorage pfnStgOpenStorage = (PFnStgOpenStorage) GetProcAddress(hInstOLE, OLEAPI_StgOpenStorage);
	if (!pfnStgOpenStorage)
		return 0;

	// open the storage with the specified access -- caller will have to release
	IStorage *piStorage = 0;
	HRESULT hr = pfnStgOpenStorage(pSubjectInfo->pwsFileName, (IStorage*)0, grfMode, (SNB)0, 0, &piStorage);
	if (FAILED(hr) || !piStorage)
	{
		// ERROR, unsupported file type
		SetLastError((DWORD)ERROR_BAD_FORMAT);
		return 0;
	}

	return piStorage;
}

/////////////////////////////////////////////////////////////////////////////////
// HCRYPTPROV GetProvider(...)
//
// PURPOSE:
//    returns a handle to Crypto Provider
//
// REQUIREMENTS:
//    (1) if crypt provider specified in SIP_SUBJECTINFO, return it
//    (2) if not provided, load the default crypto provider on the system
//
//    callee is required to call FreeLibrary(*phInstAdvapi) if *phInstAdvapi != NULL
//
HCRYPTPROV GetProvider(SIP_SUBJECTINFO *pSubjectInfo, HINSTANCE hInstAdvapi)
{
	HCRYPTPROV hRetProv;

	// use provided crypto provider if it exists, else load the default provider
	if (!(pSubjectInfo->hProv))
	{
		PFnCryptAcquireContext pfnCryptAcquireContext = (PFnCryptAcquireContext) GetProcAddress(hInstAdvapi, CRYPTOAPI_CryptAcquireContext);
		if (!pfnCryptAcquireContext || !(pfnCryptAcquireContext(&hRetProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)))
		{
			hRetProv = NULL;
		}
	}
	else
	{
		hRetProv = pSubjectInfo->hProv;
	}
    
	return hRetProv;
}

//////////////////////////////////////////////////////////////////////////////////
// BOOL MyCoInitialize(...)
//
BOOL MyCoInitialize(HINSTANCE hInstOLE, bool *pfOLEInitialized)
{
	if (!pfOLEInitialized)
		return FALSE;

	*pfOLEInitialized = false;

	PFnCoInitialize pfnCoInitialize = (PFnCoInitialize) GetProcAddress(hInstOLE, OLEAPI_CoInitialize);
	if (!pfnCoInitialize)
		return FALSE;

	// OLE::CoInitialize() -- initialize OLE/COM
	HRESULT hr = pfnCoInitialize(NULL);
	if (SUCCEEDED(hr))
	{
		*pfOLEInitialized = true;
	}
	else if (RPC_E_CHANGED_MODE != hr)
	{
		SetLastError(HRESULT_CODE(hr));
		return FALSE;
	}

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////
// void MyCoUnInitialize(...)
//
void MyCoUninitialize(HINSTANCE hInstOLE, bool fOLEInitialized)
{
	if (fOLEInitialized)
	{
		// OLE::CoUnitialize()
		PFnCoUninitialize pfnCoUninitialize = (PFnCoUninitialize) GetProcAddress(hInstOLE, OLEAPI_CoUninitialize);
		if (!pfnCoUninitialize)
			return;

		pfnCoUninitialize();
	}
}

//////////////////////////////////////////////////////////////////////////////////
// BOOL VerifySubjectGUID(...)
//
BOOL VerifySubjectGUID(HINSTANCE hInstOLE, GUID *pgSubject)
{
	PFnIsEqualGUID pfnIsEqualGUID = (PFnIsEqualGUID) GetProcAddress(hInstOLE, OLEAPI_IsEqualGUID);
	if (!pfnIsEqualGUID)
		return FALSE;

	if (!pgSubject || !pfnIsEqualGUID(*pgSubject, gMSI))
	{
		// GUIDs do not match pgSubject = NULL OR pgSubject != gMSI
		SetLastError((DWORD)TRUST_E_SUBJECT_FORM_UNKNOWN);
		return FALSE;
	}

	// subject verified
	return TRUE;
}

//____________________________________________________________________________
//
// Explicit loader for OLE32.DLL on Win9X, to fix version with bad stream name handling
//____________________________________________________________________________

#ifndef UNICODE

// code offsets to patched code in all released versions of OLE32.DLL with the upper case bug
const int iPatch1120 = 0x4099F;  // beta release, shipped with IE 4.01
const int iPatch1718 = 0x4A506;  // shipped with US builds of Win98 and IE4.01SP1
const int iPatch1719 = 0x3FD82;  // shipped with Visual Studio 6.0 and some Win98
const int iPatch2512 = 0x39D5B;  // beta build
const int iPatch2612 = 0x39DB7;  // intl builds of Win98 and IE4.01SP1
const int iPatch2618 = 0x39F0F;  // web release of Win98

const int cbPatch = 53; // length of patch sequence
const int cbVect1 = 22; // offset to __imp__WideCharToMultiByte@32
const int cbVect2 = 38; // offset to __imp__CharUpperA@4

char asmRead[cbPatch];  // buffer to read DLL code for detection of bad code sequence
char asmOrig[cbPatch] = {  // bad code sequence, used for verification of original code sequence
'\x53','\x8D','\x45','\xF4','\x53','\x8D','\x4D','\xFC','\x6A','\x08','\x50','\x6A','\x01','\x51','\x68','\x00','\x02','\x00','\x00','\x53','\xFF','\x15',
'\x18','\x14','\x00','\x00', //__imp__WideCharToMultiByte@32  '\x65F01418
'\x88','\x5C','\x05','\xF4','\x8B','\xF0','\x8D','\x4D','\xF4','\x51','\xFF','\x15',
'\x40','\x11','\x00','\x00', //__imp__CharUpperA@4  '\x65F01140
'\x6A','\x01','\x8D','\x45','\xFC','\x50','\x8D','\x4D','\xF4','\x56','\x51'
};

const int cbVect1P = 25; // offset to __imp__WideCharToMultiByte@32
const int cbVect2P = 49; // offset to __imp__CharUpperA@4

char asmRepl[cbPatch] = {  // replacement code sequence that fixes stream name bug in memory
// replaced code
'\x8D','\x45','\x08','\x50','\x8D','\x75','\xF4','\x53','\x8D','\x4D','\xFC',
'\x6A','\x08','\x56','\x6A','\x01','\x51','\x68','\x00','\x02','\x00','\x00','\x53','\xFF','\x15',
'\x18','\x14','\x00','\x00', //__imp__WideCharToMultiByte@32  '\x65F01418
'\x39','\x5D','\x08','\x75','\x1C','\x88','\x5C','\x28','\xF4','\x6A','\x01',
'\x8D','\x4D','\xFC','\x51','\x50','\x56','\x56','\xFF','\x15',
'\x40','\x11','\x00','\x00', //__imp__CharUpperA@4  '\x65F01140
};

static bool PatchCode(HINSTANCE hLib, int iOffset)
{
    HANDLE hProcess = GetCurrentProcess();
    char* pLoad = (char*)(int)(hLib);
    char* pBase = pLoad + iOffset;
    DWORD cRead;
    BOOL fReadMem = ReadProcessMemory(hProcess, pBase, asmRead, sizeof(asmRead), &cRead);
    if (!fReadMem)
	{
		// ReadProcessMemory failed on OLE32.DLL
		return false;
	}
    *(int*)(asmOrig + cbVect1)  = *(int*)(asmRead + cbVect1);
    *(int*)(asmOrig + cbVect2)  = *(int*)(asmRead + cbVect2);
    *(int*)(asmRepl + cbVect1P) = *(int*)(asmRead + cbVect1);
    *(int*)(asmRepl + cbVect2P) = *(int*)(asmRead + cbVect2);
    if (memcmp(asmRead, asmOrig, sizeof(asmOrig)) != 0)
        return false;
    DWORD cWrite;
    BOOL fWriteMem = WriteProcessMemory(hProcess, pBase, asmRepl, sizeof(asmRepl), &cWrite);
    if (!fWriteMem)
	{
		// WriteProcessMemory failed on OLE32.DLL
		return false;
	}
    return true;
}

void PatchOLE(HINSTANCE hLib)
{
    if (hLib && (PatchCode(hLib, iPatch2612)
              || PatchCode(hLib, iPatch1718)
              || PatchCode(hLib, iPatch1719)
              || PatchCode(hLib, iPatch2618)
              || PatchCode(hLib, iPatch2512)
              || PatchCode(hLib, iPatch1120)))
	{
		// OutputDebugString(TEXT("MSISIP: Detected OLE32.DLL bad code sequence, successfully corrected");
	}	
}

#endif // !UNICODE

#if 0   // source code demonstrating fix to OLE32.DLL Version 4.71, Win 9x only
// original source code
    Length = WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wBuffer, 1, Buffer, sizeof (Buffer), NULL, NULL);
// patched source code
    Length = WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wBuffer, 1, Buffer, sizeof (Buffer), NULL, &fUsedDefault);
    if (fUsedDefault) goto return_char;
// unchanged code
    Buffer[Length] = '\0';
    CharUpperA (Buffer);
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, Buffer, Length, wBuffer, 1);
return_char:
    return wBuffer[0];

// original compiled code                              patched code
    push ebx                                            lea  eax, [ebp+8]
    lea  eax, [ebp-12]                                  push eax
    push ebx                                            lea  esi, [ebp-12]
    lea  ecx, [ebp-4]                                   push ebx
    push 8                                              lea  ecx, [ebp-4]
    push eax                                            push 8
    push 1                                              push esi
    push ecx                                            push 1
    push 200h                                           push ecx
    push ebx                                            push 200h
    call dword ptr ds:[__imp__WideCharToMultiByte@32]   push ebx
    mov  byte ptr [ebp+eax-12], bl                      call dword ptr ds:[__imp__WideCharToMultiByte@32]
    mov  esi,eax                                        cmp  [ebp+8], ebx
    lea  ecx, [ebp-12]                                  jnz  towupper_retn
    push ecx                                            mov  byte ptr [ebp+eax-12], bl
    call dword ptr ds:[__imp__CharUpperA@4]             push 1
    push 1                                              lea  ecx, [ebp-4]
    lea  eax, [ebp-4]                                   push ecx
    push eax                                            push eax
    lea  ecx, [ebp-12]                                  push esi
    push esi                                            push esi
    push ecx                                            call dword ptr ds:[__imp__CharUpperA@4]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msisip\_msisip.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       _msisip.h
//
//--------------------------------------------------------------------------

#ifndef __MSISIP_H_
#define __MSISIP_H_

#include "common.h"
#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <mssip.h>
#include <strsafe.h>

// MSI SIP constants
#define MSI_NAME                    L"MSISIP.DLL"
#define MSI_SIP_MYFILETYPE_FUNCTION L"MsiSIPIsMyTypeOfFile"
#define MSI_SIP_GETSIG_FUNCTION     L"MsiSIPGetSignedDataMsg"
#define MSI_SIP_PUTSIG_FUNCTION     L"MsiSIPPutSignedDataMsg"
#define MSI_SIP_CREATEHASH_FUNCTION L"MsiSIPCreateIndirectData"
#define MSI_SIP_VERIFYHASH_FUNCTION L"MsiSIPVerifyIndirectData"
#define MSI_SIP_REMOVESIG_FUNCTION  L"MsiSIPRemoveSignedDataMsg"
#define MSI_SIP_CURRENT_VERSION     0x00000001

/* from common.h */
// MSI_SUBJTYPE_IMAGE = {000C10F1-0000-0000-C000-000000000046}
// typedef CComPointer<IStream>  PStream;
// typedef CComPointer<IStorage> PStorage;
GUID gMSI = GUID_IID_MsiSigningSIPProvider;
const GUID STGID_MsiDatabase2 = GUID_STGID_MsiDatabase2;

// digital signature location (stream name)
const WCHAR wszDigitalSignatureStream[] = L"\005DigitalSignature";
const char  szDigitalSignatureStream[]  =  "\005DigitalSignature";

// IsMyTypeOfFile enum
enum itofEnum
{
	itofUnknown     = -1,// unknown class
	itofDatabase    = 0, // any database class (includes MergeModule)
	itofTransform   = 1, // any transform class
	itofPatch       = 2, // any patch class
};

// helper function prototypes
IStorage*   GetStorageFromSubject(SIP_SUBJECTINFO *pSubjectInfo, DWORD grfMode, HINSTANCE hInstOLE, bool fCloseFile);
HCRYPTPROV  GetProvider(SIP_SUBJECTINFO *pSubjectInfo, HINSTANCE hInstAdvapi);
BOOL        GetSortedStorageElements(HINSTANCE hInstOLE, IStorage& riStorage, unsigned int *pcStgElem, STATSTG **ppsStatStg);
BOOL        DigestStorageHelper(HINSTANCE hInstOLE, HINSTANCE hInstAdvapi, IStorage& riStorage, bool fSubStorage, HCRYPTHASH hHash);
int			CompareSTATSTG(const STATSTG sStatStg1, const STATSTG sStatStg2);
void        SwapStatStg(STATSTG *psStatStg, unsigned int iPos1, unsigned int iPos2);
void        InsSortStatStg(STATSTG *psStatStg, unsigned int iFirst, unsigned int iLast);
void		QSortStatStg(STATSTG *psStatStg, unsigned int iLeft, unsigned int iRight);
void        FreeSortedStorageElements(HINSTANCE hInstOLE, STATSTG *psStatStg, DWORD cStgElem);
BOOL        MyCoInitialize(HINSTANCE hInstOLE, bool *pfOLEInitialized);
void		MyCoUninitialize(HINSTANCE hInstOLE, bool fOLEInitialized);
BOOL        VerifySubjectGUID(HINSTANCE hInstOLE, GUID *pgSubject);

// main Storage SIP functions
BOOL  GetSignatureFromStorage(IStorage& riStorage, BYTE *pbData, DWORD dwSigIndex, DWORD *pdwDataLen);
BOOL  PutSignatureInStorage(IStorage& riStorage, BYTE *pbData, DWORD dwDataLen, DWORD *pdwIndex);
BOOL  RemoveSignatureFromStorage(IStorage& riStorage, DWORD dwIndex);
BYTE* DigestStorage(HINSTANCE hInstOLE, HINSTANCE hInstAdvapi, IStorage& riStorage, HCRYPTPROV hProv, char *pszDigestObjId, DWORD *pcbDigestRet);

//--------------------------------------------------------------------------------------
// OLE API
//--------------------------------------------------------------------------------------

// ole32.dll

#define OLE32_DLL TEXT("ole32.dll")

#define OLEAPI_StgOpenStorage "StgOpenStorage"
typedef HRESULT (__stdcall *PFnStgOpenStorage)(const OLECHAR* pwcsName, IStorage* pstgPriority, DWORD grfMode, SNB snbExclude, DWORD, IStorage** ppstgOpen);

#define OLEAPI_CoTaskMemFree "CoTaskMemFree"
typedef void (__stdcall *PFnCoTaskMemFree)(LPVOID pv);

#define OLEAPI_CoInitialize "CoInitialize"
typedef HRESULT (__stdcall *PFnCoInitialize)(LPVOID pv);

#define OLEAPI_CoUninitialize "CoUninitialize"
typedef void (__stdcall *PFnCoUninitialize)();

#define OLEAPI_IsEqualGUID "IsEqualGUID"
typedef BOOL (__stdcall *PFnIsEqualGUID)(REFGUID rguid1, REFGUID rguid2);

// functions to fix bad ole32.dll version on Win9X
void PatchOLE(HINSTANCE hLib);
static bool PatchCode(HINSTANCE hLib, int iOffset);

//--------------------------------------------------------------------------------------
// CRYPTO API
//--------------------------------------------------------------------------------------

// crypt32.dll

#define CRYPT32_DLL TEXT("crypt32.dll")

#define CRYPTOAPI_CryptSIPAddProvider  "CryptSIPAddProvider"
typedef BOOL (WINAPI *PFnCryptSIPAddProvider)(SIP_ADD_NEWPROVIDER *psNewProv);

#define CRYPTOAPI_CryptSIPRemoveProvider "CryptSIPRemoveProvider"
typedef BOOL (WINAPI *PFnCryptSIPRemoveProvider)(GUID *pgProv);

#define CRYPTOAPI_CryptEncodeObject "CryptEncodeObject"
typedef BOOL (WINAPI *PFnCryptEncodeObject)(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded);

#define CRYPTOAPI_CertOIDToAlgId "CertOIDToAlgId"
typedef DWORD (WINAPI *PFnCertOIDToAlgId)(LPCSTR pszObjId);

// advapi32.dll

#define ADVAPI32_DLL TEXT("advapi32.dll")

#define CRYPTOAPI_CryptCreateHash "CryptCreateHash"
typedef BOOL (WINAPI *PFnCryptCreateHash)(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash);

#define CRYPTOAPI_CryptHashData "CryptHashData"
typedef BOOL (WINAPI *PFnCryptHashData)(HCRYPTHASH hHash, CONST BYTE *pbData, DWORD dwDataLen, DWORD dwFlags);

#define CRYPTOAPI_CryptDestroyHash "CryptDestroyHash"
typedef BOOL (WINAPI *PFnCryptDestroyHash)(HCRYPTHASH hHash);

#define CRYPTOAPI_CryptGetHashParam "CryptGetHashParam"
typedef BOOL (WINAPI *PFnCryptGetHashParam)(HCRYPTHASH hHash, DWORD dwParam, BYTE*pbData, DWORD *pdwDataLen, DWORD dwFlags);

#ifdef UNICODE
#define CRYPTOAPI_CryptAcquireContext "CryptAcquireContextW"
typedef BOOL (WINAPI *PFnCryptAcquireContext)(HCRYPTPROV *phProv, LPTSTR pszContainer, LPTSTR pszProvider, DWORD dwProvType, DWORD dwFlags);
#else // !UNICODE
#define CRYPTOAPI_CryptAcquireContext "CryptAcquireContextA"
typedef BOOL (WINAPI *PFnCryptAcquireContext)(HCRYPTPROV *phProv, LPTSTR pszContainer, LPTSTR pszProvider, DWORD dwProvType, DWORD dwFlags);
#endif // UNICODE

#define CRYPTOAPI_CryptReleaseContext "CryptReleaseContext"
typedef BOOL (WINAPI *PFnCryptReleaseContext)(HCRYPTPROV hProv, ULONG_PTR dwFlags);

#endif __MSISIP_H_ // __MSISIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\cmdparse\cmdparse.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cmdparse.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include "cmdparse.h"

CmdLineOptions::CmdLineOptions(const sCmdOption* options)
 : m_cOptions(0), m_pOptionResults(0)
{
	if(options == 0)
		return;
	
	// count up number of options we have to deal with
	for(const sCmdOption* pCurrentOption = options; pCurrentOption->chOption != 0; pCurrentOption++)
	{
		m_cOptions++;
	}

	// set up our list of option results
	m_pOptionResults = new sCmdOptionResults[m_cOptions];
	
	if(m_pOptionResults == 0)
		return;

	memset(m_pOptionResults, 0, sizeof(sCmdOptionResults)*m_cOptions);
	for(int i = 0; i < m_cOptions; i++)
	{
		m_pOptionResults[i].chOption       = options[i].chOption | 0x20;
		m_pOptionResults[i].iType          = options[i].iType;
		m_pOptionResults[i].szArgument     = 0;
		m_pOptionResults[i].fOptionPresent = FALSE;
	}
}

CmdLineOptions::~CmdLineOptions()
{
	if(m_pOptionResults)
		delete m_pOptionResults;
}

BOOL CmdLineOptions::Initialize(int argc, TCHAR* argv[])
{
	// loop through all parameters on command line
	int iPreviousOptionIndex = -1;
	int iPreviousOptionType  =  0;
	BOOL fArgExpected = FALSE;
	BOOL fArgRequired = FALSE;
	for(int i = 1; i < argc; i++)
	{
		// if we have a command character
		if ('-' == *argv[i] || '/' == *argv[i])
		{
			// fail if we require an arg here
			if(fArgRequired)
				return FALSE;

			// option should be single char
			if(argv[i][1] == 0 ||
				argv[i][2] != 0)
			{
				return FALSE;
			}
			
			// get the command letter
			TCHAR chOption = argv[i][1] | 0x20;

			BOOL fUnknownOption = TRUE;
			for(int j = 0; j < m_cOptions; j++)
			{
				if(chOption == m_pOptionResults[j].chOption)
				{
					if(m_pOptionResults[j].fOptionPresent)
					{
						// argument already present - can't have same arg twice
						return FALSE;
					}
					
					m_pOptionResults[j].fOptionPresent = TRUE;
					fUnknownOption = FALSE;
					iPreviousOptionIndex = j;
					break;
				}
			}

			if(fUnknownOption)
				return FALSE;
		}
		else
		{
			// argument
			if(fArgExpected == FALSE)
				return FALSE;

			m_pOptionResults[iPreviousOptionIndex].szArgument = argv[i];

			iPreviousOptionIndex = -1; // finished with this option
		}

		iPreviousOptionType = iPreviousOptionIndex >= 0 ? (m_pOptionResults[iPreviousOptionIndex].iType) : 0;
		fArgExpected = (iPreviousOptionType & ARGUMENT_OPTIONAL) == ARGUMENT_OPTIONAL ? TRUE : FALSE;
		fArgRequired = (iPreviousOptionType & ARGUMENT_REQUIRED) == ARGUMENT_REQUIRED ? TRUE : FALSE;
	}

	if(fArgRequired == TRUE)
	{
		// last option was missing a required argument
		return FALSE;
	}

	// finally, make sure that all required options are present
	for(int k = 0; k < m_cOptions; k++)
	{
		if((m_pOptionResults[k].iType & OPTION_REQUIRED) == OPTION_REQUIRED &&
			 m_pOptionResults[k].fOptionPresent == FALSE)
		{
			return FALSE;
		}
	}


	return TRUE;
}

BOOL CmdLineOptions::OptionPresent(TCHAR chOption)
{
	if(m_cOptions == 0)
		return FALSE;
	
	for(int i = 0; i < m_cOptions; i++)
	{
		if((chOption | 0x20) == m_pOptionResults[i].chOption)
		{
			return m_pOptionResults[i].fOptionPresent;
		}
	}

	return FALSE;
}

const TCHAR* CmdLineOptions::OptionArgument(TCHAR chOption)
{
	if(m_cOptions == 0)
		return NULL;

	for(int i = 0; i < m_cOptions; i++)
	{
		if((chOption | 0x20) == m_pOptionResults[i].chOption)
		{
			return m_pOptionResults[i].szArgument;
		}
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\cmdparse\cmdparse.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cmdparse.h
//
//--------------------------------------------------------------------------

#define OPTION_REQUIRED   0x1 // this option is required on the command-line
#define ARGUMENT_OPTIONAL 0x2 // this option takes an argument (optionally)
#define ARGUMENT_REQUIRED 0x6 // this option requires an argument

struct sCmdOption
{
	TCHAR    chOption;
	int      iType;
};

struct sCmdOptionResults
{
	TCHAR    chOption;
	int      iType;
	BOOL     fOptionPresent;
	TCHAR*   szArgument;
};

class CmdLineOptions
{
public:

	BOOL         Initialize(int argc, TCHAR* argv[]);
	BOOL         OptionPresent(TCHAR chOption);
	const TCHAR* OptionArgument(TCHAR chOption);

	CmdLineOptions(const sCmdOption* options);
	~CmdLineOptions();

private:
	int m_cOptions;
	sCmdOptionResults* m_pOptionResults;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\cmdparse\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\cmdparse\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\cmdparse\sources.inc ===
TARGETNAME=cmdtest
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

USE_LIBCMT=1

TARGETPATH=$(MSI_BUILD_TARGET)

C_DEFINES=$(C_DEFINES) -D_EXE
USE_NOLIBS=1

INCLUDES=$(BUILD_COMMONDIR);$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\cmdtest.cpp \
	..\cmdparse.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\cmdparse\cmdtest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cmdtest.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>   // printf/wprintf
#include <tchar.h>
#include "cmdparse.h"

const sCmdOption rgCmdOptions[] =
{
	'a',	OPTION_REQUIRED|ARGUMENT_REQUIRED,
	'b',  OPTION_REQUIRED|ARGUMENT_OPTIONAL,
	'c',	OPTION_REQUIRED,
	'd',  ARGUMENT_REQUIRED,
	'e',  ARGUMENT_OPTIONAL,
	'f',  0,
	'g',  0,
	0, 0,
};

extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
	CmdLineOptions cmdLine(rgCmdOptions);

	if(cmdLine.Initialize(argc, argv) == FALSE)
	{
		_tprintf(TEXT("Command-line error.\r\n"));
	}
	else
	{
		const sCmdOption* pOption = rgCmdOptions;

		for(int i = 0; pOption[i].chOption; i++)
		{
			BOOL fPresent = cmdLine.OptionPresent(pOption[i].chOption);
			_tprintf(TEXT("Option: %c is %spresent."), pOption[i].chOption, fPresent ? TEXT("") : TEXT("not "));
			if(fPresent)
			{
				const TCHAR* szArgument = cmdLine.OptionArgument(pOption[i].chOption);
				_tprintf(TEXT("  Argument: %s\r\n"), szArgument ? szArgument : TEXT("[none]"));
			}
			else
			{
				_tprintf(TEXT("\r\n"));
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\dbutils.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       dbutils.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// dbutils.h
//		Various useful MSI Database functions
// 

#ifndef _MSI_DB_UTILS_H_
#define _MSI_DB_UTILS_H_

namespace MsiDBUtils {

	UINT CheckDependency(MSIHANDLE hRecDependency, MSIHANDLE hDatabase);
	UINT CheckExclusion(MSIHANDLE hRecSignature, MSIHANDLE hDatabase);

	UINT GetSourceDirLong(LPCTSTR szDefaultDir, LPTSTR szSourceDir, size_t* pcchSourceDir);
	UINT GetTargetDirShort(LPCTSTR szDefaultDir, LPTSTR szTargetDir, size_t* pcchTargetDir);
	UINT GetTargetDirLong(LPCTSTR szDefaultDir, LPTSTR szTargetDir, size_t* pcchTargetDir);

	UINT CopyTable(LPCTSTR szTable, MSIHANDLE hTarget, MSIHANDLE hSource);

	UINT CreateTableA(LPCSTR szTable, MSIHANDLE hTarget, MSIHANDLE hSource);
	UINT CreateTableW(LPCWSTR wzTable, MSIHANDLE hTarget, MSIHANDLE hSource);

	UINT GetFilePathA(MSIHANDLE hDatabase, LPCSTR szFileKey, LPSTR szPath, size_t* pcchPath, bool fLong);
	UINT GetFilePathW(MSIHANDLE hDatabase, LPCWSTR szFileKey, LPWSTR szPath, size_t* pcchPath, bool fLong);

	UINT GetDirectoryPathA(MSIHANDLE hDatabase, LPCSTR szDirKey, LPSTR szPath, size_t* pcchPath, bool fLong);
	UINT GetDirectoryPathW(MSIHANDLE hDatabase, LPCWSTR szDirKey, LPWSTR szPath, size_t* pcchPath, bool fLong);

	UINT GetSourceDirA(LPCSTR szDefaultDir, LPSTR szSourceDir, size_t* pcchSourceDir, bool fLong);
	UINT GetSourceDirW(LPCWSTR wzDefaultDir, LPWSTR wzSourceDir, size_t* pcchSourceDir, bool fLong);

	BOOL TableExistsW(LPCWSTR szTable, MSIHANDLE hDatabase);
	BOOL TableExistsA(LPCSTR szTable, MSIHANDLE hDatabase);

	// because we use namespaces to avoid collisions, #define will not work for determining
	// A or W given a generic name. So we use inline functions which will get optimized out
	inline UINT GetSourceDir(LPCTSTR wzDefaultDir, LPTSTR wzSourceDir, size_t* pcchSourceDir, bool fLong) {
#if defined(_UNICODE) || defined(UNICODE)
		return GetSourceDirW(wzDefaultDir, wzSourceDir, pcchSourceDir, fLong);
#else
		return GetSourceDirA(wzDefaultDir, wzSourceDir, pcchSourceDir, fLong);
#endif
	};

	inline UINT GetDirectoryPath(MSIHANDLE hDatabase, LPCTSTR szDirKey, LPTSTR szPath, size_t* pcchPath, bool fLong) {
#if defined(_UNICODE) || defined(UNICODE)
	return GetDirectoryPathW(hDatabase, szDirKey, szPath, pcchPath, fLong);
#else
	return GetDirectoryPathA(hDatabase, szDirKey, szPath, pcchPath, fLong);
#endif
	};

	inline UINT GetFilePath(MSIHANDLE hDatabase, LPCTSTR szFileKey, LPTSTR szPath, size_t* pcchPath, bool fLong) {
#if defined(_UNICODE) || defined(UNICODE)
	return GetFilePathW(hDatabase, szFileKey, szPath, pcchPath, fLong);
#else
	return GetFilePathA(hDatabase, szFileKey, szPath, pcchPath, fLong);
#endif
	};

	inline BOOL TableExists(LPCTSTR szTable, MSIHANDLE hDatabase) {
#if defined(_UNICODE) || defined(UNICODE)
	return TableExistsW(szTable, hDatabase);
#else
	return TableExistsA(szTable, hDatabase);
#endif
	};

	inline UINT CreateTable(LPCTSTR szTable, MSIHANDLE hTarget, MSIHANDLE hSource) {
#if defined(_UNICODE) || defined(UNICODE)
		return CreateTableW(szTable, hTarget, hSource);
#else
		return CreateTableA(szTable, hTarget, hSource);
#endif
	};

	UINT DuplicateTableW(MSIHANDLE hSource, LPCWSTR wzSourceTable, MSIHANDLE hTarget, LPCWSTR wzTargetTable, bool fTemporary);
	UINT GetColumnCreationSQLSyntaxW(MSIHANDLE hRecNames, MSIHANDLE hRecTypes, int iColumn, LPWSTR wzBuffer, DWORD *cchBuffer);

} // namespace


#endif	// _MSI_DB_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\dbutils.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dbutils.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// dbutils.cpp
//		Implements some common DB operations
// 
#pragma once

// this ensures that UNICODE and _UNICODE are always defined together for this
// object file
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#else
#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif
#endif

#include <windows.h>
#include "query.h"
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "msiquery.h"
#include "utils.h"
#include "dbutils.h"

#define MAX_TABLENAME	32				// maximum size of a table name
#define MAX_COLUMNNAME	32				// maximum size of a column name
#define MAX_COLUMNTYPE	5				// maximum size of a column type string

///////////////////////////////////////////////////////////////////////
// TableExists
// returns true if the table exists (persist or temp)
BOOL MsiDBUtils::TableExistsA(LPCSTR szTable, MSIHANDLE hDatabase)
{
	// check the table state
	UINT iResult = ::MsiDatabaseIsTablePersistentA(hDatabase, szTable);

	// if the table exists (persistent or not, who cares)
	if (MSICONDITION_TRUE == iResult || MSICONDITION_FALSE == iResult)
		return TRUE;

	return FALSE;	// table does not exist
}	// end of TableExists

///////////////////////////////////////////////////////////////////////
// TableExists
// returns true if the table exists (persist or temp)
BOOL MsiDBUtils::TableExistsW(LPCWSTR szTable, MSIHANDLE hDatabase)
{
	// check the table state
	UINT iResult = ::MsiDatabaseIsTablePersistentW(hDatabase, szTable);

	// if the table exists (persistent or not, who cares)
	if (MSICONDITION_TRUE == iResult || MSICONDITION_FALSE == iResult)
		return TRUE;

	return FALSE;	// table does not exist
}	// end of TableExists

///////////////////////////////////////////////////////////////////////
// CheckDependencies
// Checks to see if the dependency record is satisfied by an entry in
// the hDatabase ModuleSignature table
// hRecDependency records are:
//			first: Required ModuleID
//			second: Required Module Language
//			third: Required Module Vresion
// returns ERROR_FUNCTION_FALED if the given dependency is not met
// ERROR_SUCCESS if it is, various error codes otherwise
UINT MsiDBUtils::CheckDependency(MSIHANDLE hRecDependency, MSIHANDLE hDatabase)
{	
	UINT iResult;

	if (!TableExists(_T("ModuleSignature"), hDatabase))
	{
		// there is no ModuleSignature table, so no hope of satisfying
		return ERROR_FUNCTION_FAILED;
	}

	// variables to retrieve dependency information
	TCHAR szReqVersion[256];
	DWORD cchReqVersion = 256;
	int nReqLanguage;

	// variables to retrieve signatureinformation
	TCHAR szSigVersion[256];
	DWORD cchSigVersion = 256;
	int nSigLanguage;

	// open a view on the module signature table
	PMSIHANDLE hView;
	if (ERROR_SUCCESS != (iResult = ::MsiDatabaseOpenView(hDatabase, _T("SELECT `ModuleID`,`Language`,`Version` FROM `ModuleSignature` WHERE `ModuleID`=?"), &hView)))
		return iResult;
	if (ERROR_SUCCESS != (iResult = ::MsiViewExecute(hView, hRecDependency)))
		return iResult;

	// get the required version and language
	cchReqVersion = 256;
	nReqLanguage = ::MsiRecordGetInteger(hRecDependency, 2);
	::MsiRecordGetString(hRecDependency, 3, szReqVersion, &cchReqVersion);

	// assume won't find a match
	BOOL bFound = FALSE;

	// loop through signature rows trying to find a match
	PMSIHANDLE hRecSignature;
	while (ERROR_SUCCESS == ::MsiViewFetch(hView, &hRecSignature))
	{
		// get all of the signature information
		cchSigVersion = 256;
		nSigLanguage = ::MsiRecordGetInteger(hRecSignature, 2);
		::MsiRecordGetString(hRecSignature, 3, szSigVersion, &cchSigVersion);

		// if the languages are in the same group
		if (LangSatisfy(nReqLanguage, nSigLanguage))
		{
			//	if there is a required version and the signature version 
			// is less than the required version
			if ( (cchReqVersion > 0) && (1 == VersionCompare(szSigVersion, szReqVersion)))
				bFound = FALSE;
			else	// found something in the signature table to fill the dependency
			{
				bFound = TRUE;
				break;			// found something quit looking
			}
		}
		else	
			bFound = FALSE;

	}

	return (bFound) ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
}	// end of CheckDependencies

///////////////////////////////////////////////////////////////////////
// CheckExclusion
// Pre: hRecModuleSig is a standard module signature
//      hDatabase is well, a database
// returns ERROR_FUNCTION_FALED if the given module should be 
// excluded, ERROR_SUCCESS if not, various error codes otherwise
UINT MsiDBUtils::CheckExclusion(MSIHANDLE hRecModuleSig, MSIHANDLE hDatabase)
{	
	UINT iResult;

	if (!TableExists(_T("ModuleExclusion"), hDatabase))
	{
		// there is no ModuleExclusion table, so everybody passes muster
		return ERROR_SUCCESS;
	}

	// variables to retrieve sig information
	TCHAR szSigVersion[256];
	DWORD cchSigVersion = 256/sizeof(TCHAR);

	// opes the module exclusion table

	// open a view on the module exclusion table
	PMSIHANDLE hView;
	if (ERROR_SUCCESS != (iResult = ::MsiDatabaseOpenView(hDatabase, _T("SELECT `ExcludedLanguage`,`ExcludedMinVersion`,`ExcludedMaxVersion` FROM `ModuleExclusion` WHERE `ExcludedID`=?"), &hView)))
		return iResult;
	if (ERROR_SUCCESS != (iResult = ::MsiViewExecute(hView, hRecModuleSig)))
		return iResult;

	int nModuleLanguage = ::MsiRecordGetInteger(hRecModuleSig, 2);
	::MsiRecordGetString(hRecModuleSig, 3, szSigVersion, &cchSigVersion);

	// loop through signature rows trying to find a match
	PMSIHANDLE hRecExclusion;
	while (ERROR_SUCCESS == ::MsiViewFetch(hView, &hRecExclusion))
	{
		
		// first check the language
		int nReqLanguage = ::MsiRecordGetInteger(hRecExclusion, 1);
		
		if (nReqLanguage != 0) {
			// find out if the language satisfies
			bool bSat = LangSatisfy(nReqLanguage, nModuleLanguage);

			// negative languages mean exclude everything BUT what's listed
			if (((nReqLanguage < 0) && bSat) ||
				((nReqLanguage > 0) && !bSat)) {
				// language is positive, and we don't match,
				// or language is negative and we DO match
				// so we won't be excluded, regardless of version info
				continue;
			}
		}

		// the language wants to exclude, check versions
		bool bMinExcl = true;		
		bool bMaxExcl = true;
		
		// both version fields are null, so we are excluded
		if (::MsiRecordIsNull(hRecExclusion, 2) && 
			::MsiRecordIsNull(hRecExclusion, 3)) {
			return ERROR_FUNCTION_FAILED;
		}

		// now check min version
		if (!::MsiRecordIsNull(hRecExclusion, 2))
		{
			TCHAR szExclVersion[256];
			unsigned long cchExclVersion = 256/sizeof(TCHAR);
			::MsiRecordGetString(hRecExclusion, 2, szExclVersion, &cchExclVersion);

			if (::VersionCompare(szExclVersion, szSigVersion) == -1)
				bMinExcl = false;
		} 
			
		// check max version
		if (!::MsiRecordIsNull(hRecExclusion, 3)) {
			TCHAR szExclVersion[256];
			unsigned long cchExclVersion = 256/sizeof(TCHAR);
			::MsiRecordGetString(hRecExclusion, 3, szExclVersion, &cchExclVersion);

			if (::VersionCompare(szExclVersion, szSigVersion) == 1) 
				bMaxExcl = false;
		} 
		
		// if we're excluded on versions, we're done
		if (bMinExcl && bMaxExcl) {
			return ERROR_FUNCTION_FAILED;
		}
	}

	return ERROR_SUCCESS;
}	// end of CheckExclusions

///////////////////////////////////////////////////////////////////////
// GetDirectoryPathA
// ANSI wrapper for GetDirectoryPathW
UINT MsiDBUtils::GetDirectoryPathA(MSIHANDLE hDatabase, LPCSTR szDirKey, LPSTR szPath, size_t* pcchPath, bool fLong)
{
	WCHAR wzDirKey[255];
	WCHAR wzPath[MAX_PATH];
	size_t cchDirKey=255;
	size_t cchPath=MAX_PATH;
	AnsiToWide(szDirKey, wzDirKey, &cchDirKey);
	UINT result = GetDirectoryPathW(hDatabase, wzDirKey, wzPath, &cchPath, fLong);
	*pcchPath = MAX_PATH;
	WideToAnsi(wzPath, szPath, pcchPath);
	return result;
}	// end of GetDirectoryPath

///////////////////////////////////////////////////////////////////////
// GetDirectoryPath
// Walks up the directory tree, creating a path.
// hDatabase is database
// wzDirKey is WCHAR Primary Key into dir table to start walk
// [out] wzPath is the resulting path
// [in/out] pcchPath is the length of the path
// ***** HACK. Should be rewritten for efficiency.
UINT MsiDBUtils::GetDirectoryPathW(MSIHANDLE hDatabase, LPCWSTR wzDirKey, LPWSTR wzPath, size_t* pcchPath, bool fLong)
{
	UINT iResult = ERROR_SUCCESS;	// assume everything will be okay

	// SQL strings
	LPCWSTR sqlDirWalker = L"SELECT `Directory_Parent`,`DefaultDir` FROM `Directory` WHERE `Directory`.`Directory`=? AND `Directory`.`Directory` <> 'TARGETDIR' AND `Directory`.`Directory` <> 'TargetDir'";

	// string buffers
	WCHAR wzDefaultDir[MAX_PATH];
	WCHAR wzPathBuffer[MAX_PATH];
	DWORD cchDefaultDir = MAX_PATH;
	size_t cchPathBuffer = MAX_PATH;

	// store the directory key in a record
	PMSIHANDLE hRec = ::MsiCreateRecord(1);
	if (ERROR_SUCCESS != (iResult = ::MsiRecordSetStringW(hRec, 1, wzDirKey)))
		return iResult;

	// get the directory key's parent and default dir
	PMSIHANDLE hView;
	if (ERROR_SUCCESS != (iResult = ::MsiDatabaseOpenViewW(hDatabase, sqlDirWalker, &hView)))
		return iResult;

	// NULL out the path
	wcscpy(wzPath, L"");

	// walk the tree
	do
	{
		// always should be able execute the view
		if (ERROR_SUCCESS != (iResult = ::MsiViewExecute(hView, hRec)))
			return iResult;

		// get the directory entry
		if (ERROR_SUCCESS == (iResult = ::MsiViewFetch(hView, &hRec)))
		{
			// reset the size of the strings
			cchDefaultDir = MAX_PATH;
			cchPathBuffer = MAX_PATH;

			::MsiViewClose(hView);

			// get the default dir out of the record
			if (ERROR_SUCCESS != (iResult = ::MsiRecordGetStringW(hRec, 2, wzDefaultDir, &cchDefaultDir)))
				break;

			// get the short name from the default dir
			if (ERROR_SUCCESS != (iResult = GetSourceDirW(wzDefaultDir, wzPathBuffer, &cchPathBuffer, fLong)))
				break;
				

			// if the buffer is not a dot
			if (*wzPathBuffer != L'.')
			{
				// if there is space to copy it all over
				if (*pcchPath > wcslen(wzPathBuffer) + wcslen(wzPath) + 1)
				{
					WCHAR wzBuffer[MAX_PATH * 2];		// !!! this should be done better

					wcscpy(wzBuffer, L"\\");
					wcscat(wzBuffer, wzPathBuffer);
					wcscat(wzBuffer, wzPath);

					// copy the buffer back into the path
					wcscpy(wzPath, wzBuffer);
				}
				else	// not enough buffer space
				{
					// set the buffer space needed and bail
					*pcchPath = wcslen(wzPathBuffer) + wcslen(wzPath) + 1;
					iResult = ERROR_INSUFFICIENT_BUFFER;
					break;
				}
			}
		}
	}	while (ERROR_SUCCESS == iResult);

	// if we eventually just ran out of things to look for
	if (ERROR_NO_MORE_ITEMS == iResult ||
		 ERROR_SUCCESS == iResult)		// or everything is okay
	{
		*pcchPath = wcslen(wzPath);
		iResult = ERROR_SUCCESS;	// set everything okay
	}

	return iResult;
}	// end of GetDirectoryPath

///////////////////////////////////////////////////////////////////////
// GetFilePathA
// ANSI wrapper for GetFilePathW
UINT MsiDBUtils::GetFilePathA(MSIHANDLE hDatabase, LPCSTR szFileKey, LPSTR szPath, size_t* pcchPath, bool fLong)
{
	WCHAR wzFileKey[255];
	WCHAR wzPath[MAX_PATH];
	size_t cchFileKey=255;
	size_t cchPath=MAX_PATH;
	AnsiToWide(szFileKey, wzFileKey, &cchFileKey);
	UINT result = GetFilePathW(hDatabase, wzFileKey, wzPath, &cchPath, fLong);
	*pcchPath = MAX_PATH;
	WideToAnsi(wzPath, szPath, pcchPath);
	return result;
}	// end of GetFilePath

///////////////////////////////////////////////////////////////////////
// GetFilePathW
// takes a key to the file table and returns a full path from a Darwin 
// root directory
// hDatabase is database
// wzFileKey is WCHAR into File Table of hDatabase
// [out] wzPath returns the path
// [in/out] pcchPath is length of wzPath
UINT MsiDBUtils::GetFilePathW(MSIHANDLE hDatabase, LPCWSTR wzFileKey, LPWSTR wzPath, size_t* pcchPath, bool fLong)
{
	UINT iResult;

	// SQL string
	LPCWSTR sqlFileDirKey = L"SELECT `Directory`,`FileName` FROM `Directory`,`File`,`Component` WHERE `File`.`File`=? AND `File`.`Component_`=`Component`.`Component` AND `Component`.`Directory_`=`Directory`.`Directory`";

	// store the file key in a record
	PMSIHANDLE hRec = ::MsiCreateRecord(1);
	if (ERROR_SUCCESS != (iResult = ::MsiRecordSetStringW(hRec, 1, wzFileKey)))
		return iResult;

	// get the File's Directory Key and name
	PMSIHANDLE hView;
	if (ERROR_SUCCESS != (iResult = ::MsiDatabaseOpenViewW(hDatabase, sqlFileDirKey, &hView)))
		return iResult;
	if (ERROR_SUCCESS != (iResult = ::MsiViewExecute(hView, hRec)))
		return iResult;

	// directory key and file name and path buffer
	WCHAR wzDirKey[MAX_PATH];
	WCHAR wzFilename[MAX_PATH];
	WCHAR wzPathBuffer[MAX_PATH];
	DWORD cchDirKey = MAX_PATH;
	DWORD cchFilename = MAX_PATH;
	size_t cchPathBuffer = MAX_PATH;

	// get the file's directory key
	if (ERROR_SUCCESS != (iResult = ::MsiViewFetch(hView, &hRec)))
		return iResult;

	// get the default dir out of the record
	if (ERROR_SUCCESS != (iResult = ::MsiRecordGetStringW(hRec, 1, wzDirKey, &cchDirKey)))
		return iResult;

	// get the filename out of the record
	if (ERROR_SUCCESS != (iResult = ::MsiRecordGetStringW(hRec, 2, wzFilename, &cchFilename)))
		return iResult;

	// get the path for the directory key for this file
	if (ERROR_SUCCESS != (iResult = GetDirectoryPathW(hDatabase, wzDirKey, wzPathBuffer, &cchPathBuffer, fLong)))
		return iResult;

	// get the length of the short or long
	WCHAR *wzLong = wcschr(wzFilename, L'|');
	if (wzLong) 
		*(wzLong++) = L'\0';
	else 
		wzLong = wzFilename;

	// put it all together if there is room
	if (*pcchPath > wcslen(fLong ? wzLong : wzFilename) + cchPathBuffer + 1)
	{
		wcscpy(wzPath, wzPathBuffer);
		wcscat(wzPath, L"\\");
		wcscat(wzPath, fLong ? wzLong : wzFilename);
	}
	else	// not enough room, bail
	{
		wcscpy(wzPath, L"");
		*pcchPath = cchFilename + cchPathBuffer + 1;
		iResult = ERROR_INSUFFICIENT_BUFFER;
	}

	return iResult;
}	// end of GetFilePath

///////////////////////////////////////////////////////////////////////
// GetSourceDirShortA
// ANSI wrapper of GetSourceDirW
UINT MsiDBUtils::GetSourceDirA(LPCSTR szDefaultDir, LPSTR szSourceDir, size_t* pcchSourceDir, bool fLong)
{
	WCHAR wzDefaultDir[MAX_PATH];
	WCHAR wzSourceDir[MAX_PATH];
	size_t cchDefaultDir=MAX_PATH;
	size_t cchSourceDir=MAX_PATH;
	AnsiToWide(szDefaultDir, wzSourceDir, &cchSourceDir);
	UINT result = GetSourceDirW(wzDefaultDir, wzSourceDir, pcchSourceDir, fLong);
	*pcchSourceDir = MAX_PATH;
	WideToAnsi(wzSourceDir, szSourceDir, pcchSourceDir);
	return result;
}	// end of GetSourceDirA

///////////////////////////////////////////////////////////////////////
// GetSourceDirShortW
// parses a Darwin DefaultDir string (a|b:c|d) and returns the short source
// directory
// ***** Effeciency issue?????
UINT MsiDBUtils::GetSourceDirW(LPCWSTR wzDefaultDir, LPWSTR wzSourceDir, size_t* pcchSourceDir, bool fLong)
{
	UINT iResult = ERROR_SUCCESS;	// assume everything will be okay

	// pointers to delimiting characters
	const WCHAR* pwzColon;
	const WCHAR* pwzBar;
	size_t cch = 0;		// count of characters to copy to szSourceDir

	// check for a colon
	pwzColon = wcschr(wzDefaultDir, L':');
	if (pwzColon)
	{
		// move just past the colon
		pwzColon++;

		// check for a vertical bar after the colon
		pwzBar = wcschr(pwzColon, L'|');
		if (pwzBar)
		{
			if (fLong)
			{
				// LFN - count characters after the bar
				cch = wcslen(pwzBar);
				if (*pcchSourceDir > cch)
				{
					wcsncpy(wzSourceDir, pwzBar+1, cch);
					*(wzSourceDir + cch) = L'\0';	// null terminate the copied string
				}
				else	// not enough space
				{
					iResult = ERROR_INSUFFICIENT_BUFFER;
				}
			}
			else
			{
				// SFN - count characters just before the bar but after the colon
				cch = (int)(pwzBar - pwzColon);
				if (*pcchSourceDir > cch)
				{
					wcsncpy(wzSourceDir, pwzColon, cch);
					*(wzSourceDir + cch) = L'\0';	// null terminate the copied string
				}
				else	// not enough space
				{
					iResult = ERROR_INSUFFICIENT_BUFFER;
				}
			}
		}
		else	// there is no vertical bar
		{
			// if there is enough buffer space
			cch = wcslen(pwzColon);
			if (*pcchSourceDir > cch)
			{
				// simply copy over string after the colon
				wcscpy(wzSourceDir, pwzColon);
			}
			else	// not enough space
			{
				iResult = ERROR_INSUFFICIENT_BUFFER;
			}
		}
	}
	else	// there is no colon
	{
		// check for a vertical bar
		pwzBar = wcschr(wzDefaultDir, L'|');
		if (pwzBar)
		{
			if (fLong)
			{
				// LFN - count characters after the bar
				cch = wcslen(pwzBar);
				if (*pcchSourceDir > cch)
				{
					wcsncpy(wzSourceDir, pwzBar+1, cch);
					*(wzSourceDir + cch) = L'\0';	// null terminate the copied string
				}
				else	// not enough space
				{
					iResult = ERROR_INSUFFICIENT_BUFFER;
				}
			}
			else
			{
				// if there is enough space for the characters just before the bar
				cch = (int)(pwzBar - wzDefaultDir);
				if (*pcchSourceDir > cch)
				{
					wcsncpy(wzSourceDir, wzDefaultDir, cch);
					*(wzSourceDir + cch) = L'\0';	// null terminate the copied string
				}
				else	// not enough space
				{
					iResult = ERROR_INSUFFICIENT_BUFFER;
				}
			}
		}
		else	// there is no vertical bar
		{
			// if there is enough buffer space
			cch = wcslen(wzDefaultDir);
			if (*pcchSourceDir > cch)
			{
				// simply copy over string
				wcscpy(wzSourceDir, wzDefaultDir);
			}
			else	// not enough space
			{
				iResult = ERROR_INSUFFICIENT_BUFFER;
			}
		}
	}

	// set the size of what needs to be copied or what was copied before leaving
	*pcchSourceDir = cch;
	return iResult;
}	// end of GetSourceDirW

///////////////////////////////////////////////////////////////////////
// GetTargetDirShort
UINT MsiDBUtils::GetTargetDirShort(LPCTSTR szDefaultDir, LPTSTR szTargetDir, size_t* pcchTargetDir)
{
	return ERROR_SUCCESS;
}	// end of GetTargetDirShort

///////////////////////////////////////////////////////////////////////
// GetTargetDirLong
UINT MsiDBUtils::GetTargetDirLong(LPCTSTR szDefaultDir, LPTSTR szTargetDir, size_t* pcchTargetDir)
{
	return ERROR_SUCCESS;
}	// end of GetTargetDirLong

///////////////////////////////////////////////////////////////////////
// CopyTable
// copies a table completely from source database to target
// szTable is TCHAR table name
// hTarget is handle to target database
// hSource is source database
UINT MsiDBUtils::CopyTable(LPCTSTR szTable, MSIHANDLE hTarget, MSIHANDLE hSource)
{
	UINT iResult;

	TCHAR sqlCopy[64];
	_stprintf(sqlCopy, _T("SELECT * FROM `%s`"), szTable);

	// get a view on both databases
	PMSIHANDLE hViewTarget;
	PMSIHANDLE hViewSource;

	if (ERROR_SUCCESS != (iResult = ::MsiDatabaseOpenView(hSource, sqlCopy, &hViewSource)))
		return iResult;
	if (ERROR_SUCCESS != (iResult = ::MsiViewExecute(hViewSource, NULL)))
		return iResult;

	if (ERROR_SUCCESS != (iResult = ::MsiDatabaseOpenView(hTarget, sqlCopy, &hViewTarget)))
		return iResult;
	if (ERROR_SUCCESS != (iResult = ::MsiViewExecute(hViewTarget, NULL)))
		return iResult;

	// loop through copying each record
	PMSIHANDLE hCopyRow;
	do
	{
		// if this is a good fetch
		if (ERROR_SUCCESS == (iResult = ::MsiViewFetch(hViewSource, &hCopyRow)))
		{
			// put the row in the target
			iResult = ::MsiViewModify(hViewTarget, MSIMODIFY_INSERT, hCopyRow);
		}
	} while(ERROR_SUCCESS == iResult);	// while there is a row to copy

	// no more items is good
	if (ERROR_NO_MORE_ITEMS == iResult)
		iResult = ERROR_SUCCESS;

	return iResult;
}	// end of CopyTable

///////////////////////////////////////////////////////////////////////
// CreateTableA
// ANSI wrapper to CreateTableW
UINT MsiDBUtils::CreateTableA(LPCSTR szTable, MSIHANDLE hTarget, MSIHANDLE hSource)
{
	WCHAR wzTable[255];
	size_t cchTable = 255;
	AnsiToWide(szTable, wzTable, &cchTable);
	return CreateTableW(wzTable, hTarget, hSource);
}	// end of CreateTableA

///////////////////////////////////////////////////////////////////////
// CreateTableW
// copies a table schema from source database to target, no data is 
// copied.
// wzTable is WCHAR table name
// hTarget is destination DB handle
// hSource is source DB handle
UINT MsiDBUtils::CreateTableW(LPCWSTR wzTable, MSIHANDLE hTarget, MSIHANDLE hSource)
{
	return DuplicateTableW(hSource, wzTable, hTarget, wzTable, false);
}

// simple string object that can only concatenate
class StringCat
{
public:
	StringCat();
	~StringCat();
	
	void wcscat(LPCWSTR str);
	size_t wcslen() const { return m_dwLen; };
	operator LPCWSTR() { return m_pBuf; };
private:
	size_t m_dwBuf;
	size_t m_dwLen;
	LPWSTR m_pBuf;
};

StringCat::StringCat()
{
	m_dwBuf = 1024;
	m_dwLen = 0;
	m_pBuf = new WCHAR[1024];
	m_pBuf[0]=0;
}

StringCat::~StringCat()
{
	if (m_pBuf) delete[] m_pBuf;
}

void StringCat::wcscat(LPCWSTR str)
{
	if (!m_pBuf)
		return;
	size_t dwNewLen = ::wcslen(str);
	if (m_dwLen+dwNewLen+1 > m_dwBuf)
	{
		m_dwBuf = m_dwLen+dwNewLen+20;
		WCHAR* pTemp = new WCHAR[m_dwBuf];
		if (pTemp)
		{
			wcsncpy(pTemp, m_pBuf, m_dwLen+1);
		}
		delete[] m_pBuf;
		m_pBuf = pTemp;
	}
	::wcscat(&(m_pBuf[m_dwLen]), str);
	m_dwLen += dwNewLen;
}


UINT SharedGetColumnCreationSQLW(MSIHANDLE hRecNames, MSIHANDLE hRecTypes, int iColumn, bool fTemporary, StringCat& sqlColumnSyntax)
{
	// string to hold name of column
	WCHAR wzColumn[MAX_COLUMNNAME];
	DWORD cchColumn = MAX_COLUMNNAME;

	// string to hold column information
	WCHAR wzColumnType[MAX_COLUMNTYPE];
	DWORD cchColumnType = MAX_COLUMNTYPE;
	
	// get the column name and type
	::MsiRecordGetStringW(hRecNames, iColumn, wzColumn, &cchColumn);
	::MsiRecordGetStringW(hRecTypes, iColumn, wzColumnType, &cchColumnType);

	// point the string at the second part of the column type
	WCHAR* pwzTypeDigits = wzColumnType + 1;

	// tack column name on the end of SQL statement
	sqlColumnSyntax.wcscat(L"`");
	sqlColumnSyntax.wcscat(wzColumn);
	sqlColumnSyntax.wcscat(L"` ");

	// tack on the appropriate 
	switch (*wzColumnType)
	{
	case L's':
	case L'S':
	case L'l':		// localizable is checked later
	case L'L':
		// if the number is a 0 use the long char
		if (L'0' == *pwzTypeDigits)
			sqlColumnSyntax.wcscat(L"LONGCHAR");
		else	// just copy over character and how many digits, eg: CHAR(#)
		{
			sqlColumnSyntax.wcscat(L"CHAR(");
			sqlColumnSyntax.wcscat(pwzTypeDigits);
			sqlColumnSyntax.wcscat(L")");
		}
		break;
	case L'i':
	case L'I':
		// if the number is a 2 use short
		if (L'2' == *pwzTypeDigits)
			sqlColumnSyntax.wcscat(L"SHORT");
		else if (L'4' == *pwzTypeDigits)	// if 4 use LONG
			sqlColumnSyntax.wcscat(L"LONG");
		else
			return ERROR_INVALID_PARAMETER;
		break;       
	case L'v':
	case L'V':
	case L'o':
	case L'O':
		sqlColumnSyntax.wcscat(L"OBJECT");
		break;
	default:	// unknown, throw error
		return ERROR_INVALID_PARAMETER;
	}

	// treat the first char as a short int and convert it to a char
	char chType = wzColumnType[0] % 256;
	if (!IsCharUpperA(chType)) 
		sqlColumnSyntax.wcscat(L" NOT NULL");

	if (fTemporary)
		sqlColumnSyntax.wcscat(L" TEMPORARY");

	// if the letter is an L it is localizable
	if (L'L' == *wzColumnType || L'l' == *wzColumnType)
		sqlColumnSyntax.wcscat(L" LOCALIZABLE");

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// DuplicateTableW
// copies a table schema from source database to target, no data is 
// copied. Table can be renamed, source and target handles can be
// the same
// hSource is source DB handle
// wzSourceTable is WCHAR table name in source DB
// hTarget is destination DB handle
// wzTargetTable is WCHAR table name in target DB
UINT MsiDBUtils::GetColumnCreationSQLSyntaxW(MSIHANDLE hRecNames, MSIHANDLE hRecTypes, int iColumn, LPWSTR wzBuffer, DWORD *cchBuffer)
{
	if (!wzBuffer || !cchBuffer)
		return ERROR_INVALID_PARAMETER;

	UINT iResult = 0;
	StringCat sqlCreateColumn;

	if (ERROR_SUCCESS != (iResult = SharedGetColumnCreationSQLW(hRecNames, hRecTypes, iColumn, false, sqlCreateColumn)))
		return iResult;

	if (sqlCreateColumn.wcslen()+1 < *cchBuffer)
	{
		wcscpy(wzBuffer, sqlCreateColumn);
		*cchBuffer = sqlCreateColumn.wcslen()+1;
		return ERROR_SUCCESS;
	}
	else
	{
		*cchBuffer = sqlCreateColumn.wcslen()+1;
		return ERROR_MORE_DATA;
	}
}

///////////////////////////////////////////////////////////////////////
// DuplicateTableW
// copies a table schema from source database to target, no data is 
// copied. Table can be renamed, source and target handles can be
// the same
// hSource is source DB handle
// wzSourceTable is WCHAR table name in source DB
// hTarget is destination DB handle
// wzTargetTable is WCHAR table name in target DB
UINT MsiDBUtils::DuplicateTableW(MSIHANDLE hSource, LPCWSTR wzSourceTable, MSIHANDLE hTarget, LPCWSTR wzTargetTable, bool fTemporary)
{
	UINT iResult;

	WCHAR sqlCreate[64];
	swprintf(sqlCreate, L"SELECT * FROM `%s`", wzSourceTable);

	// get all rows and columns from source
	PMSIHANDLE hViewSource;
	if (ERROR_SUCCESS != (iResult = ::MsiDatabaseOpenViewW(hSource, sqlCreate, &hViewSource)))
		return iResult;
	if (ERROR_SUCCESS != (iResult = ::MsiViewExecute(hViewSource, NULL)))
		return iResult;

	// get the record with all the columns in it
	PMSIHANDLE hRecNames;
	PMSIHANDLE hRecTypes;
	if (ERROR_SUCCESS != (iResult = ::MsiViewGetColumnInfo(hViewSource, MSICOLINFO_NAMES, &hRecNames)))
		return iResult;
	if (ERROR_SUCCESS != (iResult = ::MsiViewGetColumnInfo(hViewSource, MSICOLINFO_TYPES, &hRecTypes)))
		return iResult;

	// setup the next SQL statement (can't use query object, have to build SQL one first)
	StringCat sqlCreateTable;
	sqlCreateTable.wcscat(L"CREATE TABLE `");
	sqlCreateTable.wcscat(wzTargetTable);
	sqlCreateTable.wcscat(L"` (");	// open the componets in the SQL statement

	// loop through all columns in record
	UINT cColumns = ::MsiRecordGetFieldCount(hRecNames);
	for (UINT i = 1; i <= cColumns; i++)
	{
		if (ERROR_SUCCESS != (iResult = SharedGetColumnCreationSQLW(hRecNames, hRecTypes, i, fTemporary, sqlCreateTable)))
			return iResult;

		// if this is not the last component 
		if (i < cColumns)
		{
			//tack on a comma separator
			sqlCreateTable.wcscat(L", ");
		}
	}

	// get the primary keys
	PMSIHANDLE hRecPrimary;
	::MsiDatabaseGetPrimaryKeysW(hSource, wzSourceTable, &hRecPrimary);

	// get the primary key column name
	// string to hold name of column
	WCHAR wzColumn[MAX_COLUMNNAME];
	DWORD cchColumn = MAX_COLUMNNAME;
	::MsiRecordGetStringW(hRecNames, 1, wzColumn, &cchColumn);

	// now tack on column as the primary key
	sqlCreateTable.wcscat(L" PRIMARY KEY `");
	sqlCreateTable.wcscat(wzColumn);
	sqlCreateTable.wcscat(L"` ");


	// get the number of primary key columns in record
	cColumns = ::MsiRecordGetFieldCount(hRecPrimary);
	
	// loop through all columns in record starting at second (already have the first)
	for (i = 2; i <= cColumns; i++)
	{
		// get the next primary key column name
		cchColumn = MAX_COLUMNNAME;
		::MsiRecordGetStringW(hRecNames, i, wzColumn, &cchColumn);

		// now tack on column as another primary key
		sqlCreateTable.wcscat(L", `");
		sqlCreateTable.wcscat(wzColumn);
		sqlCreateTable.wcscat(L"`");
	}

	sqlCreateTable.wcscat(L")");	// close the SQL statement

	if (fTemporary)
		sqlCreateTable.wcscat(L" HOLD");
		
	// get all rows and columns from source
	PMSIHANDLE hViewTarget;
	if (ERROR_SUCCESS != (iResult = ::MsiDatabaseOpenViewW(hTarget, sqlCreateTable, &hViewTarget)))
		return iResult;
	if (ERROR_SUCCESS != (iResult = ::MsiViewExecute(hViewTarget, NULL)))
		return iResult;

	return ERROR_SUCCESS;
}	// end of DuplicateTableW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\query.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       query.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// query.cpp
//		Implements a simple class wrapper around a MSI view. 
// 

// this ensures that UNICODE and _UNICODE are always defined together for this
// object file
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#else
#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif
#endif

#include <windows.h>
#include <assert.h>
#include "query.h"

///////////////////////////////////////////////////////////
// constructor
CQuery::CQuery()
{
	// invalidate the handles
	m_hView = NULL;
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
CQuery::~CQuery()
{
	// if the view wasn't closed
	if (m_hView)
		::MsiCloseHandle(m_hView);
}	// end of destructor

///////////////////////////////////////////////////////////
// Open
// Pre:	database handle is valid
// Pos:	m_hView is open on databse
UINT CQuery::Open(MSIHANDLE hDatabase, LPCTSTR szSQLFormat, ...)
{
	size_t dwBuf = 512;
	TCHAR *szSQL = new TCHAR[dwBuf];
	if (!szSQL)
		return ERROR_FUNCTION_FAILED;
	
	// store the result SQL string
	va_list listSQL; 
	va_start(listSQL, szSQLFormat); 
	while (-1 == _vsntprintf(szSQL, dwBuf, szSQLFormat, listSQL))
	{
		dwBuf *= 2;
		delete[] szSQL;
		szSQL = new TCHAR[dwBuf];
		if (!szSQL)
		{
			va_end(listSQL);
			return ERROR_FUNCTION_FAILED;
		}
	}
	va_end(listSQL);

	if (m_hView)
		::MsiCloseHandle(m_hView);

	// open the view
	UINT iResult = ::MsiDatabaseOpenView(hDatabase, szSQL, &m_hView);
	delete[] szSQL;

	return iResult;
}	// end of Open

///////////////////////////////////////////////////////////
// Close
// Pre:	none
// Pos:	view handle is closed
//			SQL string is blanked
UINT CQuery::Close()
{
	UINT iResult = ERROR_SUCCESS;		// assume everything will be okay

	// close the handle and null the handle
	iResult = ::MsiViewClose(m_hView);
	
	return iResult;
}	// end of Close

///////////////////////////////////////////////////////////
// Execute
// Pre:	view handle is open
// Pos:	view is executed
//			result is returned
UINT CQuery::Execute(MSIHANDLE hParams /*= NULL*/)
{
	// execute the view and return the result
	return ::MsiViewExecute(m_hView, hParams);
}	// end of Execute

///////////////////////////////////////////////////////////
// OpenExecute
// Pre:	database handle is valid
// Pos:	m_hView is open and executed on databse
UINT CQuery::OpenExecute(MSIHANDLE hDatabase, MSIHANDLE hParam, LPCTSTR szSQLFormat, ...)
{
	size_t dwBuf = 512;
	TCHAR *szSQL = new TCHAR[dwBuf];
	if (!szSQL)
		return ERROR_FUNCTION_FAILED;
	
	// store the result SQL string
	va_list listSQL; 
	va_start(listSQL, szSQLFormat); 
	while (-1 == _vsntprintf(szSQL, dwBuf, szSQLFormat, listSQL))
	{
		dwBuf *= 2;
		delete[] szSQL;
		szSQL = new TCHAR[dwBuf];
		if (!szSQL)
		{
			va_end(listSQL);
			return ERROR_FUNCTION_FAILED;
		}
	}
	va_end(listSQL);

	if (m_hView)
		::MsiCloseHandle(m_hView);

	// open the view
	UINT iResult = ::MsiDatabaseOpenView(hDatabase, szSQL, &m_hView);
	delete[] szSQL;

	if (ERROR_SUCCESS != iResult)
		return iResult;

	return Execute(hParam);
}	// end of OpenExecute

///////////////////////////////////////////////////////////
// Fetch
// Pre:	view handle is open
//			view is executed
// Pos:	record is returned
//			result is returned
UINT CQuery::Fetch(MSIHANDLE* phRecord)
{
	// fetch from the view and return the result
	return ::MsiViewFetch(m_hView, phRecord);
}	// end of Fetch

///////////////////////////////////////////////////////////
// FetchOnce
// Pre:	database handle is valid
// Pos:	m_hView is open, executed, and one record is fetched
UINT CQuery::FetchOnce(MSIHANDLE hDatabase, MSIHANDLE hParam, MSIHANDLE* phRecord, LPCTSTR szSQLFormat, ...)
{
	size_t dwBuf = 512;
	TCHAR *szSQL = new TCHAR[dwBuf];
	if (!szSQL)
		return ERROR_FUNCTION_FAILED;
	
	// store the result SQL string
	va_list listSQL; 
	va_start(listSQL, szSQLFormat); 
	while (-1 == _vsntprintf(szSQL, dwBuf, szSQLFormat, listSQL))
	{
		dwBuf *= 2;
		delete[] szSQL;
		szSQL = new TCHAR[dwBuf];
		if (!szSQL)
		{
			va_end(listSQL);
			return ERROR_FUNCTION_FAILED;
		}
	}
	va_end(listSQL);

	if (m_hView)
		::MsiCloseHandle(m_hView);

	// open the view
	UINT iResult = ::MsiDatabaseOpenView(hDatabase, szSQL, &m_hView);
	delete[] szSQL;
	if (ERROR_SUCCESS != iResult)
		return iResult;
	
	if (ERROR_SUCCESS != (iResult = Execute(hParam)))
		return iResult;

	return Fetch(phRecord);
}	// end of FetchOnce

///////////////////////////////////////////////////////////
// Modify
// Pre:	view handle is open
//			view is executed
// Pos:	modification is done
//			result is returned
UINT CQuery::Modify(MSIMODIFY eInfo, MSIHANDLE hRec)
{
	// execute the view and return the result
	return ::MsiViewModify(m_hView, eInfo, hRec);
}	// end of GetColumnInfo

///////////////////////////////////////////////////////////
// GetError
// Pre:	view handle is open
//			view is executed

UINT CQuery::GetError()
{
	TCHAR szDummyBuf[1024];
	unsigned long cchDummyBuf = sizeof(szDummyBuf)/sizeof(TCHAR);
	// execute the view and return the result
	return ::MsiViewGetError(m_hView, szDummyBuf, &cchDummyBuf);
}	// end of GetColumnInfo

///////////////////////////////////////////////////////////
// GetColumnInfo
// Pre:	view handle is open
//			view is executed
// Pos:	record is returned
//			result is returned
UINT CQuery::GetColumnInfo(MSICOLINFO eInfo, MSIHANDLE* phRec)
{
	// execute the view and return the result
	return ::MsiViewGetColumnInfo(m_hView, eInfo, phRec);
}	// end of GetColumnInfo


/////////////////////////////////////////////////////////////////////////////
// query.cpp -- CManageTable implementation
//		Implements a simple class wrapper around a MSI table for managing
//      hold counts and will clean up all hold counts it has managed upon
//      release.  Upon creation, can specify that a table has already
//      been held in memory prior to the Class managing it.  It will add
//      a hold count for this case and then release upon class destruction 
// 
CManageTable::CManageTable(MSIHANDLE hDatabase, LPCTSTR szTable, bool fAlreadyLocked) : m_hDatabase(hDatabase), m_iLockCount(0)
{
	assert(m_hDatabase != 0);

	if (fAlreadyLocked)
		m_iLockCount++; // add a hold count for the table, we're managing after a HOLD
	if (lstrlen(szTable) +1 > sizeof(m_szTable)/sizeof(TCHAR))
		m_szTable[0] = '\0'; // set failure state, buffer not big enough for string
	else
		lstrcpy(m_szTable, szTable);
}

CManageTable::~CManageTable()
{
	// check failure state
	if (m_szTable[0] == '\0')
	{
		m_iLockCount = 0;
		return;
	}

	// clean up all hold counts that this class is managing upon release
	CQuery qUnLock;
	for (int i = 1; i <= m_iLockCount; i++)
	{
		qUnLock.OpenExecute(m_hDatabase, 0, TEXT("ALTER TABLE `%s` FREE"), m_szTable);
	}
	m_iLockCount = 0; // reset
}

UINT CManageTable::LockTable()
{
	// check failure state
	if (m_szTable[0] == '\0')
		return ERROR_FUNCTION_FAILED;

	assert(m_iLockCount >= 0);
	CQuery qLock;
	UINT iStat = qLock.OpenExecute(m_hDatabase, 0, TEXT("ALTER TABLE `%s` HOLD"), m_szTable);
	if (ERROR_SUCCESS == iStat)
		m_iLockCount++; // only add to lock count if successful
	return iStat;
}

UINT CManageTable::UnLockTable()
{
	// check failure state
	if (m_szTable[0] == '\0')
		return ERROR_FUNCTION_FAILED;

	assert(m_iLockCount > 0);
	CQuery qUnLock;
	UINT iStat = qUnLock.OpenExecute(m_hDatabase, 0, TEXT("ALTER TABLE `%s` FREE"), m_szTable);
	if (ERROR_SUCCESS == iStat)
		m_iLockCount--; // only release lock count if successful
	return iStat;
}

void CManageTable::AddLockCount()
{
	m_iLockCount++; // HOLD added to this table by an external query
}

void CManageTable::RemoveLockCount()
{
	m_iLockCount--; // FREED by an external query
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\query.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       query.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// query.h
//		A simple MSI View wrapper
// 

#ifndef _MSI_SQL_QUERY_H_
#define _MSI_SQL_QUERY_H_

#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include "msiquery.h"

/////////////////////////////////////////////////////////////////////////////
// CQuery

class CQuery
{
public:
	CQuery();
	~CQuery();

	// basic operations
	UINT Open(MSIHANDLE hDatabase, LPCTSTR szSQLFormat, ...);
	UINT Close();
	UINT Execute(MSIHANDLE hParams = NULL);
	UINT Fetch(MSIHANDLE* phRecord);
	UINT Modify(MSIMODIFY eInfo, MSIHANDLE hRec);
	UINT GetError();
	inline MSIDBERROR GetError(LPTSTR szBuf, unsigned long &cchBuf) { return ::MsiViewGetError(m_hView, szBuf, &cchBuf); }
	inline bool IsOpen() { return (m_hView != 0); }
	
	UINT GetColumnInfo(MSICOLINFO eInfo, MSIHANDLE* phRec);

	// "advanced" operations
	UINT OpenExecute(MSIHANDLE hDatabase, MSIHANDLE hParam, LPCTSTR szSQLFormat, ...);
	UINT FetchOnce(MSIHANDLE hDatabase, MSIHANDLE hParam, MSIHANDLE* phRecord, LPCTSTR szSQLFormat, ...);

private:
	MSIHANDLE m_hView;
};	// end of CQuery

/////////////////////////////////////////////////////////////////////////////
// CManageTable -- Simple class to manage a table held in memory.  Ensures
//                 that a table is "freed" from memory for each hold count
//                 that the class knows about.  
//
//  use fAlreadyLocked=true to specify that the table that is being managed
//   has already had a hold applied
class CManageTable
{
public:
	 CManageTable(MSIHANDLE hDatabase, LPCTSTR szTable, bool fAlreadyLocked);
	~CManageTable();

	// basic operations
	UINT LockTable();       // add a hold count to the table
	UINT UnLockTable();     // release a hold count from the table
	void AddLockCount();    // some other query added a hold count, so increase the lock count
	void RemoveLockCount(); // some other query removed a hold count, so decrease the lock count

private: // private data
	int       m_iLockCount;  // hold count on table, release called in destructor for each hold count until 0
	TCHAR	  m_szTable[64]; // name of table held in memory
	MSIHANDLE m_hDatabase;   // handle to database
};

class CDeleteOnExit 
{
public:
	CDeleteOnExit(LPTSTR *ptr);

	~CDeleteOnExit();
private:
	LPTSTR *m_pPtr;
};

#endif	// _MSI_SQL_QUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\msiice.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       MsiICE.h
//
//--------------------------------------------------------------------------
#ifndef _MSIICE_H_
#define _MSIICE_H_

class CQuery; 

struct ICEInfo_t {
	TCHAR* szName;
	TCHAR* szCreateModify;
	TCHAR* szDesc;
	TCHAR* szHelp;
};

extern const struct ICEInfo_t g_ICEInfo[];
extern const int g_iNumICEs;
extern const int g_iFirstICE;

// used to define errors
enum ietEnum
{
	ietFail = 0,
	ietError = 1,
	ietWarning = 2,
	ietInfo = 3,
};
	
struct ErrorInfo_t {
public:
	unsigned int iICENum;
	ietEnum iType;
	TCHAR* szMessage;
	TCHAR* szLocation;
};
#define ICE_ERROR(_A_,_B_,_C_,_D_,_E_) static const ErrorInfo_t _A_ = { _B_ , (ietEnum)_C_ , TEXT( _D_ ) , TEXT( _E_ ) };

#define ICE_QUERY0(_N_, _S_) namespace _N_ { const TCHAR szSQL[] = TEXT(_S_); };
#define ICE_QUERY1(_N_, _S_, _C1_) namespace _N_ { const TCHAR szSQL[] = TEXT(_S_); enum iColumn {_C1_=1}; };
#define ICE_QUERY2(_N_, _S_, _C1_, _C2_) namespace _N_ { const TCHAR szSQL[] = TEXT(_S_); enum iColumn {_C1_=1, _C2_=2}; };
#define ICE_QUERY3(_N_, _S_, _C1_, _C2_, _C3_) namespace _N_ { const TCHAR szSQL[] = TEXT(_S_); enum iColumn {_C1_=1, _C2_=2, _C3_=3}; };
#define ICE_QUERY4(_N_, _S_, _C1_, _C2_, _C3_, _C4_) namespace _N_ { const TCHAR szSQL[] = TEXT(_S_); enum iColumn {_C1_=1, _C2_=2, _C3_=3, _C4_=4}; };
#define ICE_QUERY5(_N_, _S_, _C1_, _C2_, _C3_, _C4_, _C5_) namespace _N_ { const TCHAR szSQL[] = TEXT(_S_); enum iColumn {_C1_=1, _C2_=2, _C3_=3, _C4_=4, _C5_=5}; };
#define ICE_QUERY6(_N_, _S_, _C1_, _C2_, _C3_, _C4_, _C5_, _C6_) namespace _N_ { const TCHAR szSQL[] = TEXT(_S_); enum iColumn {_C1_=1, _C2_=2, _C3_=3, _C4_=4, _C5_=5, _C6_=6}; };
#define ICE_QUERY7(_N_, _S_, _C1_, _C2_, _C3_, _C4_, _C5_, _C6_, _C7_) namespace _N_ { const TCHAR szSQL[] = TEXT(_S_); enum iColumn {_C1_=1, _C2_=2, _C3_=3, _C4_=4, _C5_=5, _C6_=6, _C7_=7}; };

// help web file
const TCHAR szIce01Help[] = TEXT("");

// old style ICE system. These should be converted to new style whenever the ICEs 
// are significantly modified
const TCHAR szIce10Help[] = TEXT("");
const TCHAR szIce11Help[] = TEXT("");
const TCHAR szIce13Help[] = TEXT("");
const TCHAR szIce18Help[] = TEXT("");
const TCHAR szIce01[] = TEXT("ICE01");
const TCHAR szIce10[] = TEXT("ICE10");
const TCHAR szIce11[] = TEXT("ICE11");
const TCHAR szIce13[] = TEXT("ICE13");
const TCHAR szIce18[] = TEXT("ICE18");
const TCHAR szIceHelp[] = TEXT("");

// warning ICE won't execute
const TCHAR szIceWarning[] = TEXT("%s\t3\tTable '%s' missing.  %s could not complete all of its validation.\thttp://robmen2/ICEs/icewarn.html");
const TCHAR szIceMissingTable[] = TEXT("Table '%s' missing.  %s could not complete all of its validation.");
const TCHAR szIceMissingTableLoc[] = TEXT("");

// constants
const int iMinBuf = 50;
const int iMaxBuf = 255;
const int iSuperBuf = 1024;
const int iHugeBuf = 4096;

static const WCHAR *rgwzSystemProperties[] =
{
	L"SourceDir",
	L"TARGETDIR",
	L"ADDLOCAL",
	L"ADVERTISE",
	L"ADDDEFAULT",
	L"ADDSOURCE",
	L"REMOVE",
	L"REINSTALL",
	L"REINSTALLMODE",
	L"COMPADDLOCAL",
	L"COMPADDSOURCE",
	L"FILEADDLOCAL",
	L"FILEADDSOURCE",
	L"PATCH",
	L"ACTION",
	L"ALLUSERS",
	L"ARPAUTHORIZEDCDFPREFIX",
	L"ARPCOMMENTS",
	L"ARPCONTACT",
	L"ARPINSTALLLOCATION",
	L"ARPNOREPAIR",
	L"ARPREADME",
	L"ARPSIZE",
	L"ARPSYSTEMCOMPONENT",
	L"ARPURLINFOABOUT",
	L"ARPURLUPDATEINFO",
	L"ARPNOMODIFY",
	L"ARPNOREMOVE",
	L"AVAILABLEFREEREG",
	L"CCP_DRIVE",
	L"DISABLEADVTSHORTCUTS",
	L"DISABLEMEDIA",
	L"DISABLEROLLBACK",
	L"EXECUTEACTION",
	L"EXECUTEMODE",
	L"INSTALLLEVEL",
	L"LOGACTION",
	L"Privileged",
	L"PROMTROLLBACKCOST",
	L"PRIMARYFOLDER",
	L"REBOOT",
	L"ROOTDRIVE",
	L"SEQUENCE",
	L"SHORTFILENAMES"
	L"TRANSFORMS",
	L"TRANSFORMSATSOURCE",
	L"LIMITUI",
	L"DefaultUIFont",
	L"AdminProperties",
	L"COMPANYNAME",
	L"ProductID",
	L"PIDKEY",
	L"UserLanguageID",
	L"USERNAME",
	L"ProductLanguage",
	L"ARPHELPLINK",
	L"ARPHELPTELEPHONE",
	L"ProductCode",
	L"ProductName",
	L"ProductVersion",
	L"Manufacturer",
	L"PIDTemplate",
	L"DiskPrompt",
	L"DiskSerial",
	L"ComponentDownload",
	L"LeftUnit",
	L"UpgradeCode",
	L"IsAdminPackage",
	L"AppDataFolder",
	L"CommonFilesFolder",
	L"DesktopFolder",
	L"FavoritesFolder",
	L"FontsFolder",
	L"NetHoodFolder",
	L"PersonalFolder",
	L"PrintHoodFolder",
	L"ProgramFilesFolder",
	L"ProgramMenuFolder",
	L"RecentFolder",
	L"SendToFolder",
	L"StartMenuFolder",
	L"StartupFolder",
	L"System16Folder",
	L"SystemFolder",
	L"TempFolder",
	L"TemplateFolder",
	L"WndowsFolder",
	L"WindowsVolume",
	L"AdminUser",
	L"ComputerName",
	L"LogonUser",
	L"OLEAdvtSupport",
	L"ServicePackLevel",
	L"SharedWindows",
	L"ShellAdvtSupport",
	L"SystemLanguageID",
	L"TTCSupport",
	L"Version9X",
	L"VersionDatabase",
	L"VersionNT",
	L"WindowsBuild",
	L"Alpha",
	L"BorderSide",
	L"BorderTop",
	L"CaptionHeight",
	L"ColorBits",
	L"Intel",
	L"PhysicalMemory",
	L"ScreenX",
	L"ScreenY",
	L"TextHeight",
	L"VirtualMemory",
	L"CostingComplete",
	L"Installed",
	L"OutOfDiskSpace",
	L"OutOfNoRbDiskSpace",
	L"Preselected",
	L"PrimaryVolumePath",
	L"PrimaryVolumeSpaceAvailable",
	L"PrimaryVolumeSpaceRequired",
	L"PrimaryVolumeSpaceRemaining",
	L"RESUME",
	L"UpdateStarted",
	L"ReplacedInUseFiles",
	L"NOUSERNAME",
	L"NOCOMPANYNAME",
	L"Date",
	L"Time",
	// Darwin 1.1 Properties
	L"AdminToolsFolder",
	L"MyPicturesFolder",
	L"LocalAppDataFolder",
	L"CommonAppDataFolder",
	L"ARPPRODUCTICON",
	L"ServicePackLevelMinor",
	L"RedirectedDllSupport",
	L"RemoteAdminTS",
	L"SecureCustomProperties",
	// Darwin 1.5 Properties
	L"System64Folder",
	L"ProgramFiles64Folder",
	L"CommonFiles64Folder",
	L"MSICHECKCRCS",
	L"Intel64",
	L"IA64",
	L"VersionNT64",
	L"MsiHiddenProperties",
	L"MsiNTProductType",
	L"MsiNTSuiteBackOffice",
	L"MsiNTSuiteDataCenter",
	L"MsiNTSuiteEnterprise",
	L"MsiNTSuiteSmallBusiness",
	L"MsiNTSuiteSmallBusinessRestricted",
	L"MsiNTSuitePersonal",
	L"AMD64"
};
static const int cwzSystemProperties = sizeof(rgwzSystemProperties)/sizeof(WCHAR *);

// Const TCHAR String and Size (CWSS)
#define CTSS(_A_) { TEXT(_A_), (sizeof(TEXT(_A_))/sizeof(TCHAR))-1 }
struct _ctss_t { TCHAR *tz; DWORD cch; };
static const _ctss_t rgDirProperties[] =
{
	CTSS("AdminProperties"),
	CTSS("AppDataFolder"),
	CTSS("CommonFilesFolder"),
	CTSS("DesktopFolder"),
	CTSS("FavoritesFolder"),
	CTSS("FontsFolder"),
	CTSS("NetHoodFolder"),
	CTSS("PersonalFolder"),
	CTSS("PrintHoodFolder"),
	CTSS("ProgramFilesFolder"),
	CTSS("ProgramMenuFolder"),
	CTSS("RecentFolder"),
	CTSS("SendToFolder"),
	CTSS("StartMenuFolder"),
	CTSS("StartupFolder"),
	CTSS("System16Folder"),
	CTSS("SystemFolder"),
	CTSS("TempFolder"),
	CTSS("TemplateFolder"),
	CTSS("WndowsFolder"),
	CTSS("WindowsVolume"),
	CTSS("PrimaryVolumePath"),
	CTSS("AdminToolsFolder"),
	CTSS("MyPicturesFolder"),
	CTSS("LocalAppDataFolder"),
	CTSS("CommonAppDataFolder"),
	// Darwin 1.5 Properties
	CTSS("System64Folder"),
	CTSS("ProgramFiles64Folder"),
	CTSS("CommonFiles64Folder")
};
static const int cDirProperties = sizeof(rgDirProperties)/sizeof(_ctss_t);


const TCHAR szErrorOut[] = TEXT("[1]\t0\tAPI Function Error: [2]. Error Code: [3]");
const TCHAR szErrorOut2[] = TEXT("[1]\t0\tICE Internal Error [2]. API Returned: [3].");
const TCHAR szLastError[] = TEXT("%s\t0\t%s");

// this is the old-style ICE functions. Should be removed once nobody uses them anymore.
BOOL IsTablePersistent(BOOL fDisplayWarning, MSIHANDLE hInstall, MSIHANDLE hDatabase, const TCHAR* szTable, const TCHAR* szIce);
void APIErrorOut(MSIHANDLE hInstall, UINT iErr, const TCHAR* szIce, TCHAR* szApi);

// common functions
void APIErrorOut(MSIHANDLE hInstall, UINT iErr, const UINT iIce, const UINT iErrorNo);
void ICEErrorOut(MSIHANDLE hInstall, MSIHANDLE hRecord, const ErrorInfo_t Info, ...);

void DisplayInfo(MSIHANDLE hInstall, unsigned long lICENum);
bool IsTablePersistent(bool fDisplayWarning, MSIHANDLE hInstall, MSIHANDLE hDatabase, int iICE, const TCHAR* szTable);
void ValidateDependencies(MSIHANDLE hInstall, MSIHANDLE hDatabase, TCHAR* szDependent, const TCHAR* sqlOrigin, const TCHAR* sqlDependent,
						  const TCHAR* szIceError, const TCHAR* szIce, const TCHAR* szHelp);
const TCHAR* MyCharNext(const TCHAR* sz);

bool MarkChildDirs(MSIHANDLE hInstall, MSIHANDLE hDatabase, int iICE, 
				   MSIHANDLE hDir, const TCHAR* szColumn, int iDummy, int iMark, bool fIgnoreTarget = false, int iMark2 = -1, int iDummyTarget = -2);
bool MarkProfile(MSIHANDLE hInstall, MSIHANDLE hDatabase, const int iICE, bool fChildrenOnly = false, bool fIgnoreTarget = false, bool fPerUserOnly = false);
bool CheckComponentIsHKCU(MSIHANDLE hInstall, MSIHANDLE hDatabase, int iICE, 
						  CQuery &qFetch, 
					 const ErrorInfo_t *NonRegistry, const ErrorInfo_t *NullPath, 
					 const ErrorInfo_t *NoRegTable, const ErrorInfo_t *NoRegEntry,
					 const ErrorInfo_t *NotOwner, const ErrorInfo_t *NonHKCU,
					 const ErrorInfo_t *IsHKCU);
bool GeneratePrimaryKeys(UINT iICE, MSIHANDLE hInstall, MSIHANDLE hDatabase, LPCTSTR szTable, LPTSTR *szHumanReadable, LPTSTR *szTabDelimited);
UINT GetSummaryInfoPropertyString(MSIHANDLE hSummaryInfo, UINT uiProperty, UINT &puiDataType, LPTSTR *szValueBuf, DWORD &cchValueBuf);
UINT IceRecordGetString(MSIHANDLE hRecord, UINT iColumn, LPTSTR *szBuffer, DWORD *cchBuffer, DWORD *cchLength);
bool IceGetSummaryInfo(MSIHANDLE hInstall, MSIHANDLE hDatabase, UINT iIce, MSIHANDLE *phSummaryInfo);
UINT ComponentsInSameFeature(MSIHANDLE hInstall, MSIHANDLE hDatabase, int iICE, const TCHAR* szComp1, const TCHAR* szComp2, bool* fSameFeature);

#define ReturnIfFailed( _ICE_, _ERRORNO_, _ACTION_) { UINT iPrivate_##_ICE_##_##_ERRORNO_##_Stat; if (ERROR_SUCCESS != (iPrivate_##_ICE_##_##_ERRORNO_##_Stat = _ACTION_)) { APIErrorOut(hInstall, iPrivate_##_ICE_##_##_ERRORNO_##_Stat, _ICE_, _ERRORNO_); return ERROR_SUCCESS; } }

#define ICE_FUNCTION_DECLARATION(_NUM_) UINT ICE##_NUM_##Internal(MSIHANDLE hInstall); UINT  __stdcall ICE##_NUM_##(MSIHANDLE hInstall) { try { return ICE##_NUM_##Internal(hInstall); }	catch (...) { return ERROR_NO_MORE_ITEMS;	} } UINT ICE##_NUM_##Internal(MSIHANDLE hInstall)

#define DELETE_IF_NOT_NULL(_STRING_) if(_STRING_ != NULL) { delete[] _STRING_; _STRING_ = NULL; }

#define OUT_OF_MEMORY_RETURN(_ICE_, _STRING_) if(_STRING_ == NULL) { APIErrorOut(hInstall, GetLastError(), _ICE_, __LINE__); return ERROR_SUCCESS; }

#endif // _MSIICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\list.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       list.h
//
//--------------------------------------------------------------------------

// list.h - defines and implements a linked list that stores items
//

#ifndef _LINKED_LIST_H_
#define _LINKED_LIST_H_

typedef void* POSITION;

/////////////////////////////////////////////////////////////////////////////
// CList

template <class T>
class CList
{
public:
	CList() : m_pHead(NULL), m_pTail(NULL), m_cCount(0) 
		{ }
	~CList()
		{	RemoveAll();	}

	POSITION AddTail(T pData);

	POSITION InsertBefore(POSITION posInsert, T pData);
	POSITION InsertAfter(POSITION posInsert, T pData);

	T RemoveHead();
	T RemoveTail();
	T RemoveAt(POSITION& rpos);
	void RemoveAll();
	void Remove(T pData);

	UINT GetCount() const;
	POSITION GetHeadPosition() const;
	T GetHead() const;
	T GetAt(POSITION pos) const;
	T GetNext(POSITION& rpos) const;
	T GetPrev(POSITION& rpos) const;
	POSITION Find(T pFind) const;


private:
	// embedded class
	class CNode
	{
	public:
		CNode(T pData, CNode* pPrev = NULL, CNode* pNext = NULL) : m_pData(pData), m_pPrev(pPrev), m_pNext(pNext) 
			{ }

		T m_pData;
		CNode* m_pPrev;
		CNode* m_pNext;
	};	// end of CNode

	CNode* m_pHead;
	CNode* m_pTail;

	UINT m_cCount;
};	// end of CList

template <class T>
POSITION CList<T>::AddTail(T pData)
{
	// if there is a tail
	if (m_pTail)
	{
		// create the new tail, then point at it
		m_pTail->m_pNext = new CNode(pData, m_pTail);
		m_pTail = m_pTail->m_pNext;
	}
	else	// there is no tail yet
		m_pTail = new CNode(pData);

	// if there is no head, point it at the tail
	if (!m_pHead)
		m_pHead = m_pTail;

	// increment the count
	m_cCount++;

	// return list node added as a void item
	return (POSITION)m_pTail;
}

template <class T>
POSITION CList<T>::InsertBefore(POSITION posInsert, T pData)
{
	// get the node and the node before to insert
	CNode* pNode = ((CNode*)posInsert);
	CNode* pPrev = pNode->m_pPrev;

	// create a node with the pointers wired up correctly
	pNode->m_pPrev = new CNode(pData, pPrev, pNode);

	// if there is a previous
	if (pPrev)
		pPrev->m_pNext = pNode->m_pPrev;
	else	// new head node
		m_pHead = pNode->m_pPrev;

	// increment the count
	m_cCount++;

	return (POSITION)pNode->m_pPrev;
}	// end of InsertBefore

template <class T>
POSITION CList<T>::InsertAfter(POSITION posInsert, T pData)
{
	// get the node and the node after to insert
	CNode* pNode = ((CNode*)posInsert);
	CNode* pNext = pNode->m_pNext;

	// create a node with the pointers wired up correctly
	pNode->m_pNext = new CNode(pData, pNode, pNext);

	// if there is a next
	if (pNext)
		pNext->m_pPrev = pNode->m_pNext;
	else	// new tail node
		m_pTail = pNode->m_pNext;

	// increment the count
	m_cCount++;

	return (POSITION)pNode->m_pNext;
}	// end of InsertAfter

template <class T>
T CList<T>::RemoveHead()
{
	T pData = NULL;	// assume no data will be returned

	// if there is a head
	if (m_pHead)
	{
		// get the data out of the node
		pData = m_pHead->m_pData;

		// climb down the list
		m_pHead = m_pHead->m_pNext;

		// if you are still in the list
		if (m_pHead)
		{
			// delete the top of the list
			delete m_pHead->m_pPrev;
			m_pHead->m_pPrev = NULL;
		}
		else	// deleting the last object
		{
			delete m_pTail;
			m_pTail = NULL;
		}

		m_cCount--;	// decrement the count
	}

	return pData;	// return how many left
}

template <class T>
T CList<T>::RemoveTail()
{
	T pData = NULL;	// assume no data will be returned

	// if there is a tail
	if (m_pTail)
	{
		// get the data out of the node
		pData = m_pTail->m_pData;

		// climb back up the list
		m_pTail = m_pTail->m_pPrev;

		// if you are still in the list
		if (m_pTail)
		{
			// delete the end of the list
			delete m_pTail->m_pNext;
			m_pTail->m_pNext = NULL;
		}
		else	// deleting the last object
		{
			delete m_pHead;
			m_pHead = NULL;
		}

		m_cCount--;	// decrement the count
	}

	return pData;	// return how many left
}

template <class T>
POSITION CList<T>::Find(T pFind) const
{
	POSITION pos = GetHeadPosition();
	POSITION oldpos = pos;
	T *pNode = NULL;
	while (pos)
	{
		oldpos = pos;
		if (GetNext(pos) == pFind)
			return oldpos;
	}
	return NULL;
}

template <class T>
T CList<T>::RemoveAt(POSITION& rpos) 
{
	if (!rpos) return NULL;

	CNode *pNode = ((CNode *)rpos);

	T data = pNode->m_pData;
	if (pNode->m_pPrev)
		pNode->m_pPrev->m_pNext = pNode->m_pNext;
	else
		m_pHead = pNode->m_pNext;

	if (pNode->m_pNext)
		pNode->m_pNext->m_pPrev = pNode->m_pPrev;
	else
		m_pTail = pNode->m_pPrev;
	m_cCount--;

	delete pNode;
	return data;
}

template <class T>
UINT CList<T>::GetCount() const
{
	return m_cCount;	// return count of items
}

template <class T>
POSITION CList<T>::GetHeadPosition() const
{
	// return list node as a void item
	return (POSITION)m_pHead;
}

template <class T>
T CList<T>::GetHead() const
{
	// if there is no head bail
	if (!m_pHead)
		return NULL;

	// return head node data
	return m_pHead->m_pData;;
}

template <class T>
T CList<T>::GetAt(POSITION pos) const
{
	// return data
	return ((CNode*)pos)->m_pData;
}

template <class T>
T CList<T>::GetNext(POSITION& rpos) const
{
	// get the data to return
	T pData = ((CNode*)rpos)->m_pData;

	// increment the position
	rpos = (POSITION)((CNode*)rpos)->m_pNext;

	return pData;
}

template <class T>
T CList<T>::GetPrev(POSITION& rpos) const
{
	// get the data to return
	T pData = ((CNode*)rpos)->m_pData;

	// decrement the position
	rpos = (POSITION)((CNode*)rpos)->m_pPrev;

	return pData;
}

template <class T>
void CList<T>::RemoveAll()
{
	// while there is a tail, kill it
	while (m_pTail)
		RemoveTail();
}

template <class T>
void CList<T>::Remove(T pData)
{
	POSITION pos = Find(pData);
	if (pos) RemoveAt(pos);
}

#endif	// _LINKED_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\regutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       regutil.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// regutil.h
//		Utilities for the evil self-reg.
//		Used for Dev self-host purposes only
//
#include <objbase.h>

HRESULT RegisterCoObject(REFCLSID rclsid, WCHAR *wzDesc, WCHAR *wzProgID, int nCurVer,
								 WCHAR *wzInProc, WCHAR *wzLocal);
HRESULT RegisterCoObject9X(REFCLSID rclsid, CHAR *wzDesc, CHAR *wzProgID, int nCurVer,
								 CHAR *wzInProc, CHAR *wzLocal);
HRESULT UnregisterCoObject(REFCLSID rclsid, BOOL bDll = TRUE);
HRESULT UnregisterCoObject9X(REFCLSID rclsid, BOOL bDll = TRUE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\trace.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       trace.h
//
//--------------------------------------------------------------------------

#ifndef _TRACE_H_
#define _TRACE_H_


#if defined(DEBUG) || defined(_DEBUG)

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include "assert.h"


#define ERRMSG FormattedErrorMessage
#define ASSERT(x) assert(x);
void FormattedErrorMessage(HRESULT hr);

#else	// not DEBUG

#include <windows.h>

#define ERRMSG(x)
#define ASSERT(x)

#endif // DEBUG

void FormattedDebugStringA(LPCSTR szFormatter, ...);
void FormattedDebugStringW(LPCWSTR szFormatter, ...);

#if defined(UNICODE) || defined(_UNICODE)
#define TRACE FormattedDebugStringW
#else
#define TRACE FormattedDebugStringA
#endif

#define TRACEW FormattedDebugStringW
#define TRACEA FormattedDebugStringA

#endif // _TRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\trace.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       trace.cpp
//
//--------------------------------------------------------------------------

// this ensures that UNICODE and _UNICODE are always defined together for this
// object file
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#else
#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif
#endif
#include <tchar.h>
#include "trace.h"

#if defined(DEBUG) || defined(_DEBUG)

/////////////////////////////////////////////////////////////////////////////
// FormattedDebugStringA
void FormattedDebugStringA(LPCSTR szFormatter, ...) 
{ 
	char szBufDisplay[1025] = {0}; 

	va_list listDisplay; 
	va_start(listDisplay, szFormatter); 

	_vsnprintf(szBufDisplay, 1024, szFormatter, listDisplay); 
	::OutputDebugStringA(szBufDisplay); 
} 

/////////////////////////////////////////////////////////////////////////////
// FormattedDebugStringW
void FormattedDebugStringW(LPCWSTR wzFormatter, ...) 
{ 
	WCHAR wzBufDisplay[1025] = {0}; 

	va_list listDisplay; 
	va_start(listDisplay, wzFormatter); 

	_vsnwprintf(wzBufDisplay, 1024, wzFormatter, listDisplay); 
	::OutputDebugStringW(wzBufDisplay); 
} 

/////////////////////////////////////////////////////////////////////////////
// FormattedErrorMessage
void FormattedErrorMessage(HRESULT hr)
{
	void* pMsgBuf;
	::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
							NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							(LPTSTR) &pMsgBuf,
							0, NULL);
	TRACE(_T(">>> System Error: %s\n"), (LPTSTR)pMsgBuf);
	LocalFree( pMsgBuf );
}

#else
void FormattedDebugStringA(LPCSTR szFormatter, ...) { };
void FormattedDebugStringW(LPCWSTR wzFormatter, ...) { };
#endif DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\regutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       regutil.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// regutil.cpp
//		Utilities for the evil self-reg.
//		Used for Dev self-host purposes only
//		All release DLLs should register via MSI package only
//
// 

#include "regutil.h"
#include <strsafe.h>

static HRESULT InternalRegisterCoObject(bool bWide, REFCLSID rclsid, const void * const tzDesc , 
								 const void * const tzProgID, int nCurVer,
								 const void * const tzInProc, const void * const tzLocal);
static HRESULT InternalUnregisterCoObject(bool bWide, REFCLSID rclsid, BOOL bDll /*= TRUE*/);

///////////////////////////////////////////////////////////
// RegisterCoObject
//	REFCLSID rclsid	[in]	CLSID of the object
// WCHAR *wzDesc		[in]	description of object
// WCHAR *wzProgID	[in]	the program ID
// int nCurVer			[in]	current version
// WCHAR *wzInProc	[in]	InProcessServer
// WCHAR *wzLocal	[in]	LocalServer
HRESULT RegisterCoObject(REFCLSID rclsid, WCHAR *wzDesc, WCHAR *wzProgID, int nCurVer,
						 WCHAR *wzInProc, WCHAR *wzLocal) {
	return InternalRegisterCoObject(true, rclsid, wzDesc, wzProgID, nCurVer, wzInProc, wzLocal);
};

///////////////////////////////////////////////////////////
// RegisterCoObject
//	REFCLSID rclsid	[in]	CLSID of the object
// CHAR *szDesc		[in]	description of object
// CHAR *szProgID	[in]	the program ID
// int nCurVer			[in]	current version
// CHAR *szInProc	[in]	InProcessServer
// CHAR *szLocal	[in]	LocalServer
HRESULT RegisterCoObject9X(REFCLSID rclsid, CHAR *szDesc, CHAR *szProgID, int nCurVer,
						   CHAR *szInProc, CHAR *szLocal) {
	return InternalRegisterCoObject(false, rclsid, szDesc, szProgID, nCurVer, szInProc, szLocal);
};




///////////////////////////////////////////////////////////////////////
// rather than do a lot of code duplication, we define two functions that call the appropriate
// system call, then use function pointers to choose between them. This cleans up the code a lot.
// We can't use pointers into the system calls themselves 
typedef long (* SetValue_t)(HKEY, const void *, DWORD, CONST BYTE *, DWORD);
typedef long (* OpenKey_t)(HKEY, const void *, PHKEY);
typedef long (* CreateKey_t)(HKEY, const void *, PHKEY phkResult);
typedef long (* DeleteKey_t)(HKEY, const void *);
typedef long (* QueryValue_t)(HKEY, const void *, LPBYTE, LPDWORD);

static long InternalSetValueW(HKEY hKey, const void *lpValueName, DWORD dwType, CONST BYTE *lpData, DWORD cbData) {
	return RegSetValueExW(hKey, (const WCHAR *)lpValueName, 0, dwType, lpData, cbData); }
static long InternalSetValueA(HKEY hKey, const void *lpValueName, DWORD dwType, CONST BYTE *lpData, DWORD cbData) {
	return RegSetValueExA(hKey, (const char *)lpValueName, 0, dwType, lpData, cbData); }
static long InternalOpenKeyW(HKEY hKey, const void *lpSubKey, PHKEY phkResult) {
	return RegOpenKeyExW(hKey, (const WCHAR *)lpSubKey, 0, KEY_ALL_ACCESS, phkResult); }
static long InternalOpenKeyA(HKEY hKey, const void *lpSubKey, PHKEY phkResult) {
	return RegOpenKeyExA(hKey, (const char *)lpSubKey, 0, KEY_ALL_ACCESS, phkResult); }
static long InternalCreateKeyW(HKEY hKey, const void *lpSubKey, PHKEY phkResult) {
	return RegCreateKeyExW(hKey, (const WCHAR *)lpSubKey, 0, NULL/*lpClass*/, REG_OPTION_NON_VOLATILE, 
		KEY_ALL_ACCESS, NULL, phkResult, NULL); }
static long InternalCreateKeyA(HKEY hKey, const void *lpSubKey, PHKEY phkResult) {
	return RegCreateKeyExA(hKey, (const char *)lpSubKey, 0, NULL/*lpClass*/, REG_OPTION_NON_VOLATILE, 
		KEY_ALL_ACCESS, NULL, phkResult, NULL); }
static long InternalDeleteKeyW(HKEY hKey, const void *lpSubKey) { return RegDeleteKeyW(hKey, (const WCHAR *)lpSubKey); }
static long InternalDeleteKeyA(HKEY hKey, const void *lpSubKey) { return RegDeleteKeyA(hKey, (const char *)lpSubKey); }
static long InternalQueryValueW(HKEY hKey, const void *lpValueName, LPBYTE lpData, LPDWORD lpcbData) {
	return RegQueryValueExW(hKey, (const WCHAR *)lpValueName, 0, NULL, lpData, lpcbData); }
static long InternalQueryValueA(HKEY hKey, const void *lpValueName, LPBYTE lpData, LPDWORD lpcbData) {
	return RegQueryValueExA(hKey, (const char *)lpValueName, 0, NULL, lpData, lpcbData); }

///////////////////////////////////////////////////////////////////////
// for some of the paramaters, just use macros
// prepends an L to a string constant if unicode at runtime
#define REG_A_OR_W(_STR_) (bWide ? (const BYTE *) L##_STR_ : (const BYTE *) _STR_)
// determines the byte size of a value, based on runtime
#define REG_BYTESIZE(_STR_) (bWide ? ((lstrlenW((const WCHAR *)_STR_)+1)*sizeof(WCHAR)) : (lstrlenA((const char*)_STR_)+1)*sizeof(char))

///////////////////////////////////////////////////////////////////////
// these function pointers are used only by the registration system
// and are local to this file only. They use the types above
static SetValue_t pfSetValue = NULL;
static OpenKey_t pfOpenKey = NULL;
static CreateKey_t pfCreateKey = NULL;
static DeleteKey_t pfDeleteKey = NULL;
static QueryValue_t pfQueryValue = NULL;

static inline void SetPlatformRegOps(bool bWide) {
	if (pfSetValue == NULL) {
		pfSetValue = bWide ? InternalSetValueW : InternalSetValueA;
		pfOpenKey = bWide ? InternalOpenKeyW : InternalOpenKeyA;
		pfCreateKey = bWide ? InternalCreateKeyW : InternalCreateKeyA;
		pfDeleteKey = bWide ? InternalDeleteKeyW : InternalDeleteKeyA;
		pfQueryValue = bWide ? InternalQueryValueW : InternalQueryValueA;
	}
}

static HRESULT InternalRegisterCoObject(bool bWide, REFCLSID rclsid, const void * const tzDesc, const void * const tzProgID, 
								 int nCurVer,
								 const void * const tzInProc, const void * const tzLocal)
{
	SetPlatformRegOps(bWide);

	HKEY hk = 0;
	HKEY hkParent = 0;
	LONG lResult;

	byte tzBuf[512]; // can be either char or WCHAR at runtime
	byte tzCLSID[512];

	if (bWide)
		StringCchPrintfW((WCHAR *)tzCLSID, sizeof(tzCLSID)/sizeof(WCHAR),
				  L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", 
				  rclsid.Data1, rclsid.Data2, rclsid.Data3,
				  rclsid.Data4[0], rclsid.Data4[1],
				  rclsid.Data4[2], rclsid.Data4[3], rclsid.Data4[4],
				  rclsid.Data4[5], rclsid.Data4[6], rclsid.Data4[7]);
	else
		StringCchPrintfA((CHAR *)tzCLSID, sizeof(tzCLSID), 
				  "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", 
				  rclsid.Data1, rclsid.Data2, rclsid.Data3,
				  rclsid.Data4[0], rclsid.Data4[1],
				  rclsid.Data4[2], rclsid.Data4[3], rclsid.Data4[4],
				  rclsid.Data4[5], rclsid.Data4[6], rclsid.Data4[7]);

	// HKEY_CLASSES_ROOT\CLSID\{...} = "Description"
	if (bWide)
		StringCchPrintfW((WCHAR *)tzBuf, sizeof(tzBuf)/sizeof(WCHAR), L"CLSID\\%ls", reinterpret_cast<WCHAR*>(tzCLSID));
	else
		StringCchPrintfA((CHAR *)tzBuf, sizeof(tzBuf), "CLSID\\%hs", reinterpret_cast<CHAR*>(tzCLSID));

	lResult = (*pfCreateKey)(HKEY_CLASSES_ROOT, tzBuf, &hk);
	if (ERROR_SUCCESS != lResult) 
		return E_FAIL;

	lResult = (*pfSetValue)( hk, NULL, REG_SZ, (BYTE*)tzDesc, REG_BYTESIZE(tzDesc));
	if( ERROR_SUCCESS != lResult )
	{
		RegCloseKey(hk);
		return E_FAIL;
	}

	// make this the parent key
	hkParent = hk; 
	hk = 0;

	// if this is an inprocess server
	if (tzInProc) 
	{
		// HKEY_CLASSES_ROOT\CLSID\{...}\InProcServer32 = <this>
		lResult = (*pfCreateKey)(hkParent, REG_A_OR_W("InProcServer32"), &hk);
		if (ERROR_SUCCESS != lResult) 
		{
			RegCloseKey(hkParent);
			return E_FAIL;
		}
	
		lResult = (*pfSetValue)( hk, NULL, REG_SZ, (const BYTE *)tzInProc, REG_BYTESIZE(tzInProc));
		if (ERROR_SUCCESS != lResult)
		{
			RegCloseKey(hkParent);
			RegCloseKey(hk);
			return E_FAIL;
		}

		// HKEY_CLASSES_ROOT\CLSID\{...}\InProcServer32:ThreadingModel = Both
		lResult = (*pfSetValue)( hk, (void *)REG_A_OR_W("ThreadingModel"), REG_SZ, 
			REG_A_OR_W("Both"), REG_BYTESIZE(REG_A_OR_W("Both")));
	
		// close the key
		RegCloseKey(hk); 
		hk = 0;
	}

	// if this is a local server
	if (tzLocal) 
	{
		// HKEY_CLASSES_ROOT_\CLSID\{...}\LocalServer32 = <this>
		lResult = (*pfCreateKey)( hkParent, REG_A_OR_W("LocalServer32"), &hk );
		if (ERROR_SUCCESS != lResult) 
		{
			RegCloseKey(hkParent);
			return E_FAIL;
		}

		lResult = (*pfSetValue)( hk, NULL, REG_SZ, (const BYTE *)tzLocal, REG_BYTESIZE(tzLocal));
		if (ERROR_SUCCESS != lResult)
		{
			RegCloseKey(hkParent);
			RegCloseKey(hk);
			return E_FAIL;
		}

		// close the key
		RegCloseKey(hk);
		hk = 0;
	}

	// HKEY_CLASSES_ROOT\CLSID\{...}\VersionIndependentProgID = "ProgId"
	lResult = (*pfCreateKey)(hkParent, REG_A_OR_W("VersionIndependentProgID"), &hk);
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hkParent);
		return E_FAIL;
	}

	lResult = (*pfSetValue)(  hk, NULL, REG_SZ, (const BYTE *)tzProgID, REG_BYTESIZE(tzProgID) );
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hkParent);
		RegCloseKey(hk);
		return E_FAIL;
	}

	// close the key
	RegCloseKey(hk); 
	hk = 0;

	// HKEY_CLASSES_ROOT\CLSID\{...}\ProgID = "ProgId".nCurVer
	if (bWide) {
		lResult = StringCchPrintfW((WCHAR *)tzBuf, sizeof(tzBuf)/sizeof(WCHAR), L"%ls.%d", tzProgID, nCurVer );
	}
	else
		StringCchPrintfA((CHAR *) tzBuf, sizeof(tzBuf), "%hs.%d", tzProgID, nCurVer );

	lResult = (*pfCreateKey)(hkParent, REG_A_OR_W("ProgID"), &hk);
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hkParent);
		return E_FAIL;
	}

	lResult = (*pfSetValue)(  hk, NULL, REG_SZ, tzBuf, REG_BYTESIZE(tzBuf) );
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hkParent);
		RegCloseKey(hk);
		return E_FAIL;
	}

	// close the open keys
	RegCloseKey(hk); 
	RegCloseKey(hkParent); 
	hk = 0;
	hkParent = 0;

	// HKEY_CLASSES_ROOT\ProgID = "Description"
	lResult = (*pfCreateKey)(HKEY_CLASSES_ROOT, (WCHAR *)tzProgID, &hk);
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hk);
		return E_FAIL;
	}

	lResult = (*pfSetValue)( hk, NULL, REG_SZ, (const BYTE *)tzDesc, REG_BYTESIZE(tzDesc));
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hk);
		return E_FAIL;
	}

	// set the parent key to this current key
	hkParent = hk; 
	hk = 0;

	// HKEY_CLASSES_ROOT\ProgId\CurVer = VersionDependentProgID
	lResult = (*pfCreateKey)(hkParent, REG_A_OR_W("CurVer"), &hk);
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hkParent);
		return E_FAIL;
	}

	lResult = (*pfSetValue)( hk, NULL, REG_SZ, tzBuf, REG_BYTESIZE(tzBuf));
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hkParent);
		RegCloseKey(hk);
		return E_FAIL;
	}

	// HKEY_CLASSES_ROOT\ProgID\CLSID = {}
	// also want to set the CLSID here, in case some program tries
	// to find things through here
	lResult = (*pfCreateKey)(hkParent, REG_A_OR_W("CLSID"), &hk);
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hkParent);
		return E_FAIL;
	}

	lResult = (*pfSetValue)( hk, NULL, REG_SZ, tzCLSID, REG_BYTESIZE(tzCLSID));
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hkParent);
		RegCloseKey(hk);
		return E_FAIL;
	}

	// close the open keys
	RegCloseKey(hk); 
	RegCloseKey(hkParent); 
	hk = 0;
	hkParent = 0;

	// HKEY_CLASSES_ROOT\ProgID.# = "Description"
	if (bWide)
		StringCchPrintfW((WCHAR *)tzBuf, sizeof(tzBuf)/sizeof(WCHAR), L"%ls.%d", tzProgID, nCurVer );
	else
		StringCchPrintfA((CHAR *) tzBuf, sizeof(tzBuf), "%hs.%d", tzProgID, nCurVer );

	lResult = (*pfCreateKey)(HKEY_CLASSES_ROOT, (WCHAR *)tzBuf, &hk);
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hk);
		return E_FAIL;
	}

	lResult = (*pfSetValue)( hk, NULL, REG_SZ, (const BYTE *)tzDesc, REG_BYTESIZE(tzDesc));
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hk);
		return E_FAIL;
	}
	// set the parent key to this currnet key
	hkParent = hk; 
	hk = 0;


	// HKEY_CLASSES_ROOT\ProgId.#\CLSID = CLSID
	lResult = (*pfCreateKey)(hkParent, REG_A_OR_W("CLSID"), &hk);
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hkParent);
		return E_FAIL;
	}

	lResult = (*pfSetValue)( hk, NULL, REG_SZ, tzCLSID, REG_BYTESIZE(tzCLSID));
	if (ERROR_SUCCESS != lResult) 
	{
		RegCloseKey(hkParent);
		RegCloseKey(hk);
		return E_FAIL;
	}

	// close the open keys
	RegCloseKey(hk); 
	RegCloseKey(hkParent); 
	hk = 0;
	hkParent = 0;

	return S_OK;
}	// end of RegisterCoObject

///////////////////////////////////////////////////////////
// DeleteKeyRecursively
// NOTE: RECURSIVE function
static HRESULT DeleteKeyRecursively(HKEY hk, bool bWide=true)
{
	HRESULT hr = S_OK;	// assume everything will be okay
	
	LONG lResult;
	ULONG lIgnore;
	byte tzBuf[512];

	// next key index and sub key
	int nKeyIndex = 0;
	HKEY hkSub = 0;

	while (1)
	{
		tzBuf[0] = 0;;
		tzBuf[1] = 0;;
		lIgnore = 512 / sizeof(TCHAR);

		// get all the keys in this key
		if (bWide)
			lResult = RegEnumKeyExW(hk, nKeyIndex, (WCHAR *)tzBuf, &lIgnore, 0, NULL, NULL, NULL);
		else
			lResult = RegEnumKeyExA(hk, nKeyIndex, (char *)tzBuf, &lIgnore, 0, NULL, NULL, NULL);

		if (ERROR_NO_MORE_ITEMS == lResult) 
			break;	// bail
		else if (ERROR_MORE_DATA == lResult)
		{
			hr = E_FAIL;
			break;
		}
		else if (ERROR_SUCCESS != lResult)
		{
			hr = E_FAIL;
			break;
		}

		// open a sub key
		lResult = (*pfOpenKey)(hk, tzBuf, &hkSub);
		if (ERROR_SUCCESS != lResult) 
		{
			hr = E_FAIL;
			break;
		}

		// call this function again with the sub key
		hr = DeleteKeyRecursively(hkSub, bWide);
		if (FAILED(hr)) 
			break;	// bail with whatever failed

		// finally, try to delete this key
		lResult = (*pfDeleteKey)(hk, tzBuf);
		if (ERROR_SUCCESS != lResult) 
		{
			hr = E_FAIL;
			break;
		}

		RegCloseKey(hkSub); 
		hkSub = 0;
	}

	// if a sub key was left over close it
	if(hkSub) 
		RegCloseKey(hkSub);

	return hr;
}	// end of DeleteKeyRecursively

///////////////////////////////////////////////////////////
// UnregisterCoObject
static HRESULT InternalUnregisterCoObject(bool bWide, REFCLSID rclsid, BOOL bDll /*= TRUE*/)
{
	HRESULT hr = S_OK;		// assume everything will be okay

	SetPlatformRegOps(bWide);

	LONG lResult;
	unsigned long lIgnore;
	HKEY hk = 0;
	HKEY hkClsid = 0;
	byte tzBuf[512];
	byte tzCLSID[512];

	// Open HKEY_CLASSES_ROOT\{CLSID}\ProgID and ...\VersionIndependentProgID to remove those trees
	if (bWide)
		StringCchPrintfW((WCHAR *)tzCLSID, sizeof(tzCLSID)/sizeof(WCHAR), L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", 
				  rclsid.Data1, rclsid.Data2, rclsid.Data3,
				  rclsid.Data4[0], rclsid.Data4[1],
				  rclsid.Data4[2], rclsid.Data4[3], rclsid.Data4[4],
				  rclsid.Data4[5], rclsid.Data4[6], rclsid.Data4[7]);
	else
		StringCchPrintfA((CHAR *)tzCLSID, sizeof(tzCLSID), "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", 
				  rclsid.Data1, rclsid.Data2, rclsid.Data3,
				  rclsid.Data4[0], rclsid.Data4[1],
				  rclsid.Data4[2], rclsid.Data4[3], rclsid.Data4[4],
				  rclsid.Data4[5], rclsid.Data4[6], rclsid.Data4[7] );


	// Open HKEY_CLASSES_ROOT\{CLSID}\ProgID and ...\VersionIndependentProgID to remove those trees
	if (bWide)
		StringCchPrintfW((WCHAR *)tzBuf, sizeof(tzBuf)/sizeof(WCHAR), L"CLSID\\%ls", reinterpret_cast<WCHAR*>(tzCLSID));
	else
		StringCchPrintfA((CHAR *)tzBuf, sizeof(tzBuf), "CLSID\\%hs", reinterpret_cast<char *>(tzCLSID));

	lResult = (*pfOpenKey)(HKEY_CLASSES_ROOT, tzBuf, &hkClsid);
	if (ERROR_SUCCESS == lResult)
	{
		// if this is a DLL
		if (bDll) 
		{
			// just delete InProcServer32 
			lResult = (*pfDeleteKey)(hkClsid, REG_A_OR_W("InProcServer32"));
			if (ERROR_SUCCESS != lResult)
				hr = E_FAIL;	// set that we failed, but try to continue to clean up
		} 
		else	// must be an exe
		{
			// just delete LocalServer32 
			lResult = (*pfDeleteKey)(hkClsid, REG_A_OR_W("LocalServer32"));
			if (ERROR_SUCCESS != lResult)
				hr = E_FAIL;	// set that we failed, but try to continue to clean up
		}

		// delete ProgID
		lResult = (*pfOpenKey)(hkClsid, REG_A_OR_W("ProgID"), &hk);
		if (ERROR_SUCCESS == lResult) 
		{
			lIgnore = 512/sizeof(TCHAR);
			lResult = (*pfQueryValue)(hk, NULL, tzBuf, &lIgnore);
			if (ERROR_SUCCESS == lResult)
			{
				lResult = (*pfOpenKey)(HKEY_CLASSES_ROOT, tzBuf, &hk);
				if (ERROR_SUCCESS == lResult) 
				{
					hr = DeleteKeyRecursively(hk, bWide);	// delete everything under hk

					// delete and close the found key
					lResult = (*pfDeleteKey)(HKEY_CLASSES_ROOT, tzBuf);
					RegCloseKey(hk); 
					hk = 0;
				}
				else if (ERROR_FILE_NOT_FOUND != lResult)	// failed to get the key
					hr = E_FAIL;
			} 
			else if (ERROR_FILE_NOT_FOUND != lResult)
				hr = E_FAIL;
		}
		else if (ERROR_FILE_NOT_FOUND != lResult)	// failed to get the value
			hr = E_FAIL;

		// delete VersionIndependentProgID
		lResult = (*pfOpenKey)(hkClsid, REG_A_OR_W("VersionIndependentProgID"), &hk);
		if (ERROR_SUCCESS == lResult) 
		{
			lIgnore = 255;
			lResult = (*pfQueryValue)(hk, NULL, tzBuf, &lIgnore);
			if (ERROR_SUCCESS == lResult) 
			{
				lResult = (*pfOpenKey)(HKEY_CLASSES_ROOT, tzBuf, &hk);
				if (ERROR_SUCCESS == lResult) 
				{
					hr = DeleteKeyRecursively(hk, bWide);	// delete everything under hk

					// delete and close the found key
					lResult = (*pfDeleteKey)(HKEY_CLASSES_ROOT, tzBuf);
					RegCloseKey(hk); 
					hk = 0;
				}
				else if (ERROR_FILE_NOT_FOUND != lResult)	// failed to get the key
					hr = E_FAIL;
			}
			else if (ERROR_FILE_NOT_FOUND != lResult)
				hr = E_FAIL;
		}
		else if (ERROR_FILE_NOT_FOUND != lResult)	// failed to get the value
			hr = E_FAIL;

		// delete everything under the clsid key
		hr = DeleteKeyRecursively(hkClsid, bWide);

		// close the clsid key (so we can delete it next)
		RegCloseKey(hkClsid); 
		hkClsid = 0;
	}
	else if (ERROR_FILE_NOT_FOUND != lResult)	// failed to get the value
		hr = E_FAIL;

	// open the clsid key
	lResult = (*pfOpenKey)(HKEY_CLASSES_ROOT, REG_A_OR_W("CLSID"), &hk);
	if(ERROR_SUCCESS == lResult ) 
	{
		lResult = (*pfDeleteKey)(hk, tzCLSID);

		RegCloseKey(hk);
	}
	else if (ERROR_FILE_NOT_FOUND != lResult)
		hr = E_FAIL;


	return hr;	// return the final result
}	// end of UnregisterCoObject

HRESULT UnregisterCoObject(REFCLSID rclsid, BOOL bDll) {
	return InternalUnregisterCoObject(true, rclsid, bDll);
}
HRESULT UnregisterCoObject9X(REFCLSID rclsid, BOOL bDll) {
	return InternalUnregisterCoObject(false, rclsid, bDll);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\utils.cpp ===
/////////////////////////////////////////////////////////////////////////////
// utils.cpp
//		Various handly util operations
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

// this ensures that UNICODE and _UNICODE are always defined together for this
// object file
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#else
#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif
#endif

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include "utils.h"
#include "trace.h"
#include "query.h"

///////////////////////////////////////////////////////////
// AnsiToWide
//	Pre:	sz is the ansi string
//			cchwz is size of wz string
//	Pos:	wz is the wide string
//			if return 0, cchwz is the size string should be
//	NOTE:	if sz is NULL, sets wz to NULL
int AnsiToWide(LPCSTR sz, LPWSTR wz, size_t* cchwz)
{
	if (!sz)
	{
		wz = NULL;
		*cchwz = 0;
		return 0;
	}

	int cchWide = ::MultiByteToWideChar(CP_ACP, 0, sz, -1, wz, static_cast<int>(*cchwz));
	if (0 == cchWide)
	{
		// assume insufficient buffer return count need next time around
		*cchwz = ::MultiByteToWideChar(CP_ACP, 0, sz, -1, 0, 0);
		return 0;
	}

	return cchWide;
}	// end of AnsiToWide

////////////////////////////////////////////////////////////
// WideToAnsi
//	Pre:	wz is the wide string
//			cchsz is size of sz string
//	Pos:	sz is the ansi string
//			if return 0, cchsz is the size string should be
//	NOTE:	if wz is NULL, sets sz to NULL
int WideToAnsi(LPCWSTR wz, LPSTR sz, size_t* cchsz)
{
	if (!wz)
	{
		sz = NULL;
		*cchsz = 0;
		return 0;
	}

	int cchAnsi = ::WideCharToMultiByte(CP_ACP, 0, wz, -1, sz, static_cast<int>(*cchsz), NULL, NULL);
	if (0 == cchAnsi)
	{
		DWORD dwResult = GetLastError();

		BOOL bX = dwResult == ERROR_INVALID_PARAMETER;
		BOOL bY = dwResult == ERROR_INVALID_FLAGS;
		BOOL bZ = dwResult == ERROR_INSUFFICIENT_BUFFER;

		// get the size need to be
		*cchsz = ::WideCharToMultiByte(CP_ACP, 0, wz, -1, 0, 0, NULL, NULL);
		return 0;	// return empty
	}

	return cchAnsi;
}	// end of WideToAnsi
  
////////////////////////////////////////////////////////////
// FileExists
BOOL FileExistsA(LPCSTR szFilename)
{
	// if the attribute is not invalid and it's not a directory
	DWORD dwAttrib = GetFileAttributesA(szFilename);
	return (0xFFFFFFFF != dwAttrib) && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
}	// end of FileExists

////////////////////////////////////////////////////////////
// FileExists
BOOL FileExistsW(LPCWSTR wzFilename)
{
	// if the attribute is not invalid and it's not a directory
	DWORD dwAttrib = GetFileAttributesW(wzFilename);
	return (0xFFFFFFFF != dwAttrib) && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
}	// end of FileExists

////////////////////////////////////////////////////////////
// PathExists
BOOL PathExists(LPCTSTR szPath)
{
	// if the attribute is not invalid and it's a directory
	DWORD dwAttrib = GetFileAttributes(szPath);
	return (0xFFFFFFFF != dwAttrib) && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
}	// end of PathExists


////////////////////////////////////////////////////////////
// CreateFilePath
BOOL CreateFilePathA(LPCSTR szFilePath)
{
	ASSERT(strlen(szFilePath) <= MAX_PATH);	// insure the file path fits
	
	// copy the filepath into buffer path
	CHAR szPath[MAX_PATH];
	LPCSTR pchEnd = szFilePath;
	while (*pchEnd != '\0')
	{
		pchEnd = CharNextExA(CP_ACP, pchEnd, 0);
	}
	int iBytes = static_cast<UINT>(pchEnd - szFilePath)+1;
	memcpy(szPath, szFilePath, iBytes);

	// find the last back slash and null terminate it
	char* pchSlash = NULL;
	for (char* pchNext = szPath; pchNext = CharNextExA(CP_ACP, pchNext, 0); )
	{
		if (*pchNext == '\0')
			break;
		if (*pchNext == '\\')
			pchSlash = pchNext;
	}

	if (pchSlash)
		*pchSlash = '\0';	

	// now create that path
	return CreatePathA(szPath);
}	// end of CreateFilePath

////////////////////////////////////////////////////////////
// CreateFilePath
BOOL CreateFilePathW(LPCWSTR wzFilePath)
{
	ASSERT(lstrlenW(wzFilePath) <= MAX_PATH);	// insure the file path fits
	
	if (!wzFilePath || (lstrlenW(wzFilePath) >= MAX_PATH))
		return FALSE;

	// copy the filepath into buffer path
	WCHAR wzPath[MAX_PATH];
	lstrcpynW(wzPath, wzFilePath, sizeof(wzPath)/sizeof(wzPath[0]));

	// find the last back slash and null terminate it
	WCHAR* pwzEnd = wcsrchr(wzPath, L'\\');
	if (pwzEnd)
		*pwzEnd = L'\0';	

	// now create that path
	return CreatePathW(wzPath);
}	// end of CreateFilePath

////////////////////////////////////////////////////////////
// CreatePath
BOOL CreatePathA(LPCSTR szPath)
{
	BOOL bResult = TRUE;	// assume everything will be okay

	UINT cchCount = 0;
	LPCSTR pchEnd = szPath; 
	while (*pchEnd != '\0')
	{
		pchEnd = CharNextExA(CP_ACP, pchEnd, 0);
		cchCount++;
	}
	int iBytes = static_cast<UINT>(pchEnd - szPath);

	LPSTR pszPathBuf = new CHAR[iBytes + 2];	// plus two to make sure we can add a '\' and terminating null
	LPSTR pchCurrent = pszPathBuf;
	if (!pszPathBuf)
		return FALSE;

	// copy over the path into the buffer and cat on a '\' (there may already be one, but it doesn't matter)
	memcpy(pszPathBuf, szPath, iBytes);
	pszPathBuf[iBytes] = '\\';
	pszPathBuf[iBytes+1] = '\0';

	// increment the length to account for the added '\'
	cchCount++;
	
    // if the string starts with <char>:\, skip over it when beginning the directory
    // search
    UINT i= 0;
    if (cchCount >= 3 && IsCharAlphaA(pszPathBuf[0]) && pszPathBuf[1] == ':' && pszPathBuf[2] == '\\')
    {
        i = 3;
        pchCurrent += 3;
    }
	else if (cchCount >= 5 && pszPathBuf[0] == '\\' && pszPathBuf[1] == '\\')
	{
		// search for the server-share delimiter
		pchCurrent = &(pszPathBuf[2]);
		while (pchCurrent && *pchCurrent != '\\')
		{
			if (*pchCurrent == '\0')
			{
				// of the form \\server. This is not supported
				return FALSE;
			}
			else
				pchCurrent = CharNextExA(CP_ACP, pchCurrent, 0);
		}

		// known to be single byte '\' char
		pchCurrent++;
	
		// search for a share-path delimiter
		while (pchCurrent && *pchCurrent != '\\')
		{
			if (*pchCurrent == '\0')
			{
				// of the form \\server\share. This is a valid empty path
				// on that share.
				return TRUE;
			}
			else
				pchCurrent = CharNextExA(CP_ACP, pchCurrent, 0);
		}

		// known to be single byte '\' char
		pchCurrent++;
		i = static_cast<UINT>(pchCurrent - pszPathBuf);
	}


	for (; i < cchCount; i++)
	{
		// if we're at a slash
		if (*pchCurrent == '\\')
		{
			// change the slash to a null terminator temporarily
			*pchCurrent = '\0';
			TRACEA("Creating directory: %hs\r\n", pszPathBuf);

            // check to see if the directory already exists
            DWORD lDirResult = GetFileAttributesA(pszPathBuf);

            if (lDirResult == 0xFFFFFFFF)
            {
                bResult = (::CreateDirectoryA(pszPathBuf, NULL) != 0);
            }
            else if ((lDirResult & FILE_ATTRIBUTE_DIRECTORY) == 0) 
            {
                // exists, but not a directory...fail
                bResult = FALSE;
            }
			else
			{
				// exists and is a directory. Even if something earlier failed
				// earlier up the path tree this means all is OK.
				bResult = TRUE;
			}

    		// put the current back to a back slash
			*pchCurrent = '\\';
		}

		// tack on the character and continue
		pchCurrent = CharNextExA(CP_ACP, pchCurrent, 0);
	}

	delete [] pszPathBuf;	// clean up path buffer
	return bResult;
}	// end of CreatePath

////////////////////////////////////////////////////////////
// CreatePath
BOOL CreatePathW(LPCWSTR wzPath)
{
	BOOL bResult = TRUE;	// assume everything will be okay

	LPWSTR pwzPathBuf = new WCHAR[lstrlenW(wzPath) + 2];	// plus two to make sure we can add a '\' and terminating null
	LPWSTR pchCurrent;

	// copy over the path into the buffer and cat on a '\' (there may already be one, but it doesn't matter)
	lstrcpyW(pwzPathBuf, wzPath);
	lstrcatW(pwzPathBuf, L"\\");

	// parse through the path to create
	pchCurrent = pwzPathBuf;
	UINT cchCount = lstrlenW(pwzPathBuf);

	// if the string starts with <char>:\ or \\server\share, skip over it 
	// when beginning the directory search
	UINT i= 0;
	if (cchCount >= 3 && pwzPathBuf[1] == ':' && pwzPathBuf[2] == '\\')
	{
		i = 3;
		pchCurrent += 3;
	} 
	else if (cchCount >= 5 && pwzPathBuf[0] == '\\' && pwzPathBuf[1] == '\\')
	{
		// search for the server-share delimiter
		pchCurrent = wcschr(&(pwzPathBuf[2]), '\\');
		if (!pchCurrent)
		{
			// of the form \\server. This is not supported
			return FALSE;
		}
		pchCurrent++;

		// search for a share-path delimiter
		pchCurrent = wcschr(pchCurrent, '\\');
		if (!pchCurrent)
		{
			// of the form \\server\share. This is a valid empty path
			// on that share.
			return TRUE;
		}
		pchCurrent++;
		i = static_cast<UINT>(pchCurrent - pwzPathBuf);
	}

    for ( ; i < cchCount; i++)
    {
        // if we're at a slash
        if (*pchCurrent == L'\\')
        {
            // change the slash to a null terminator temporarily
            *pchCurrent = L'\0';
            TRACEW(L"Creating directory: %ls\r\n", pwzPathBuf);

            // check to see if the directory already exists
            DWORD lDirResult = GetFileAttributesW(pwzPathBuf);

            if (lDirResult == 0xFFFFFFFF)
            {
                bResult = (::CreateDirectoryW(pwzPathBuf, NULL) != 0);
            }
            else if ((lDirResult & FILE_ATTRIBUTE_DIRECTORY) == 0) 
            {
                  // exists, but not a directory...fail
                  bResult = FALSE;
            }
			else
			{
				// exists and is a directory. Even if something earlier failed
				// earlier up the path tree this means all is OK.
				bResult = TRUE;
			}

            // put the current back to a back slash
            *pchCurrent = L'\\';
        }

        // tack on the character and continue
        pchCurrent++;
    }

	delete [] pwzPathBuf;	// clean up path buffer
	return bResult;
}	// end of CreatePath


////////////////////////////////////////////////////////////
// VersionCompare
//	returns -1 if V1 > V2, 0 if V1 == V2, 1 if V1 < V2
int VersionCompare(LPCTSTR v1, LPCTSTR v2) 
{

	if (!v1 || !v2) return 0;
	
	UINT aiVersionInfo[2][4] = {{0,0,0,0}, {0,0,0,0}};

	int iFields = 0;
	// any fields not scanned are still 0, errors in scanning do not matter
	iFields = _stscanf(v1, _T("%u.%u.%u.%u"), &aiVersionInfo[0][0],
									&aiVersionInfo[0][1],
									&aiVersionInfo[0][2],
									&aiVersionInfo[0][3]);
	iFields = _stscanf(v2, _T("%u.%u.%u.%u"), &aiVersionInfo[1][0],
									&aiVersionInfo[1][1],
									&aiVersionInfo[1][2],
									&aiVersionInfo[1][3]);
	for (int i=0; i < 4; i++) 
	{
		if (aiVersionInfo[0][i] > aiVersionInfo[1][i]) return -1;
		if (aiVersionInfo[0][i] < aiVersionInfo[1][i]) return 1;
	}
	return 0;
}

////////////////////////////////////////////////////////////
// LangSatisfy
// returns true if QueryLang meets the requirements set by
// RequiredLang
bool LangSatisfy(long nRequiredLang, 
				 long nQueryLang) 
{
	// both languages must be positive
	// both are pass by value, so just muck with them
	nRequiredLang = labs(nRequiredLang);
	nQueryLang = labs(nQueryLang);
	
	// if RequiredLang is neutral, all is good
	if (!nRequiredLang) return true;

	// a language neutral item satisfies any required language
	if (!nQueryLang) return true;
	
	// check the primary Lang ID
	if ((nRequiredLang ^ nQueryLang) & 0x1FF)
		// they don't match, so language fails
		return false;

	// now check the sublang, (either neutral is OK)
	return (!(nRequiredLang & 0xFD00) || 
			!(nQueryLang & 0xFD00) ||
			!((nRequiredLang ^ nQueryLang) & 0xFD00));
}	

////////////////////////////////////////////////////////////
// StrictLangSatisfy
// returns true if QueryLang meets the requirements set by
// RequiredLang, but requirements are strict, meaning that 
// neutral requirements will only be satisfied by neutral
// items, not any item.
// eg: Requiring 1033 will accept 1033, 9, or 0
//     Requiring 9 will accept only 9 or 0.
bool StrictLangSatisfy(long nRequiredLang, 
				 long nQueryLang) 
{
	// both languages must be positive
	// both are pass by value, so just muck with them
	nRequiredLang = labs(nRequiredLang);
	nQueryLang = labs(nQueryLang);
	
	// if RequiredLang is neutral, all is good
	if (!nQueryLang) return true;
	
	// check the primary Lang ID
	if ((nRequiredLang ^ nQueryLang) & 0x1FF)
		// they don't match, so language fails
		return false;

	// now check the sublang, (neutral query is OK)
	return (!(nQueryLang & 0xFD00) || 
			!((nRequiredLang ^ nQueryLang) & 0xFD00));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\varutil.h ===
/////////////////////////////////////////////////////////////////////////////
// varutil.h
//		Utilities for the VARIANT type
//
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#include <wtypes.h>
#include <oaidl.h>

HRESULT VariantAsBOOL(VARIANT* pvarItem, BOOL* pbItem);
HRESULT VariantAsBSTR(VARIANT* pvarItem, BSTR* pbstrItem);
HRESULT VariantAsLong(VARIANT* pvarItem, long* plItem);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\utils.h ===
/////////////////////////////////////////////////////////////////////////////
// utils.h
//		Handy utility functions
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#ifndef _COMMON_UTILS_H_
#define _COMMON_UTILS_H_

#include <wtypes.h>

int AnsiToWide(LPCSTR sz, LPWSTR wz, size_t* cchwz);
int WideToAnsi(LPCWSTR wz, LPSTR sz, size_t* cchsz);

BOOL FileExistsA(LPCSTR szFilename);
BOOL FileExistsW(LPCWSTR szFilename);
BOOL PathExistsA(LPCSTR szPath);
BOOL PathExistsW(LPCWSTR wzPath);

BOOL CreateFilePathA(LPCSTR szFilePath);
BOOL CreateFilePathW(LPCWSTR wzFilePath);
BOOL CreatePathA(LPCSTR szPath);
BOOL CreatePathW(LPCWSTR wzPath);

#if defined(_UNICODE) || defined(UNICODE)
#define CreateFilePath CreateFilePathW
#define CreatePath CreatePathW
#define FileExists FileExistsW
#define PathExists PathExistsW
#else
#define CreateFilePath CreateFilePathA
#define CreatePath CreatePathA
#define FileExists FileExistsA
#define PathExists PathExistsA
#endif // else unicode

int VersionCompare(LPCTSTR v1, LPCTSTR v2);
bool LangSatisfy(long nRequiredLang, long nQueryLang);
bool StrictLangSatisfy(long nRequiredLang, long nQueryLang);

#endif	// _COMMON_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\common\utilinc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       UtilInc.cpp
//
//--------------------------------------------------------------------------

// we have to include the cpp files because the tools makefile doesn't like 
// linking files across directories. Grrr. 
#include "query.cpp"
#include "trace.cpp"
#include "utils.cpp"
#include "dbutils.cpp"

#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "msiice.h"   // must be in this directory or on INCLUDE path
#include "msidefs.h"  // must be in this directory or on INCLUDE path

//!! Fix warnings and remove pragma
#pragma warning(disable : 4018) // signed/unsigned mismatch

// The new APIError out that takes ints instead of strings. 
void APIErrorOut(MSIHANDLE hInstall, UINT iErr, const UINT iIce, const UINT iErrorNo)
{	
	//NOTE: should not fail on displaying messages
	PMSIHANDLE hRecErr = ::MsiCreateRecord(3);

	if ((iIce > g_iFirstICE+g_iNumICEs-1) || (iIce < g_iFirstICE))
	{
		::MsiRecordSetString(hRecErr, 0, TEXT("ICE??\t1\tInvalid ICE Number to APIErrorOut!"));
		if (!::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecErr))
			throw 0;
		return;
	}

	::MsiRecordSetString(hRecErr, 0, szErrorOut2);
	::MsiRecordSetString(hRecErr, 1, g_ICEInfo[iIce-g_iFirstICE].szName);
	::MsiRecordSetInteger(hRecErr, 2, iErrorNo);
	::MsiRecordSetInteger(hRecErr, 3, iErr);

	// post error
	if (!::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecErr))
		throw 0;

	// try and provide more useful error info
	PMSIHANDLE hRecLastErr = ::MsiGetLastErrorRecord();
	if (hRecLastErr)
	{ 
		if (::MsiRecordIsNull(hRecLastErr, 0))
			::MsiRecordSetString(hRecLastErr, 0, TEXT("Error [1]: [2]{, [3]}{, [4]}{, [5]}"));
		TCHAR rgchBuf[iSuperBuf];
		DWORD cchBuf = sizeof(rgchBuf)/sizeof(TCHAR);
		MsiFormatRecord(hInstall, hRecLastErr, rgchBuf, &cchBuf);
	
		TCHAR szError[iHugeBuf] = {0};
		_stprintf(szError, szLastError, g_ICEInfo[iIce-g_iFirstICE].szName, rgchBuf);

		::MsiRecordClearData(hRecErr);
		::MsiRecordSetString(hRecErr, 0, szError);
		if (!::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecErr))
			throw 0;
	}
}
////////////////////////////////////////////////////////////
// DisplayInfo -- outputs generic info for all ICEs
//  generic info includes creation date, last modification
//  date, and description
//
void DisplayInfo(MSIHANDLE hInstall, unsigned long lICENum)
{

	if ((lICENum > g_iNumICEs+g_iFirstICE-1) || (lICENum < 1))
	{
		PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
		::MsiRecordSetString(hRecErr, 0, TEXT("ICE??\t1\tInvalid ICE Number to APIErrorOut!"));
		if (!::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecErr))
			throw 0;
		return;
	}

	//NOTE: should not fail here
	// ice description
	PMSIHANDLE hRecInfo = ::MsiCreateRecord(2);
	::MsiRecordSetString(hRecInfo, 0, _T("[1]\t3\t[1] - [2]"));
	::MsiRecordSetString(hRecInfo, 1, g_ICEInfo[lICENum-g_iFirstICE].szName);
	::MsiRecordSetString(hRecInfo, 2, g_ICEInfo[lICENum-g_iFirstICE].szDesc);
	if (!::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecInfo))
		throw 0;

	// creation/modification date
	::MsiRecordSetString(hRecInfo, 0, _T("[1]\t3\t[2]"));
	::MsiRecordSetString(hRecInfo, 2, g_ICEInfo[lICENum-g_iFirstICE].szCreateModify);
	if (!::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecInfo))
		throw 0;
	
}

bool IsTablePersistent(bool fDisplayWarning, MSIHANDLE hInstall, MSIHANDLE hDatabase, int iICE, const TCHAR* szTable)
{
	bool fPersistent;
	MSICONDITION cond = ::MsiDatabaseIsTablePersistent(hDatabase, szTable);
	switch (cond)
	{
	case MSICONDITION_ERROR: // error
		{
			APIErrorOut(hInstall, UINT(MSICONDITION_ERROR), iICE, 2001);
			fPersistent = false;
			break;
		}
	case MSICONDITION_FALSE: //!! temporary, error??
		{
			APIErrorOut(hInstall, UINT(MSICONDITION_FALSE), iICE, 2002);
			fPersistent = false;
			break;
		}
	case MSICONDITION_NONE: // not found
		{
			fPersistent = false;
			break;
		}
	case MSICONDITION_TRUE: // permanent
		{
			fPersistent = true;
			break;
		}
	}

	if (!fDisplayWarning)
		return fPersistent; // nothing else to do

	if (!fPersistent) // display ICE info message that table was missing
	{
		PMSIHANDLE hDummyRec = ::MsiCreateRecord(1);
		ErrorInfo_t tempError;
		tempError.iICENum = iICE;
		tempError.iType = ietInfo;
		tempError.szMessage = (TCHAR *)szIceMissingTable;
		tempError.szLocation = (TCHAR *)szIceMissingTableLoc;
		
		ICEErrorOut(hInstall, hDummyRec, tempError, szTable, g_ICEInfo[iICE-g_iFirstICE].szName);
	}

	return fPersistent;
}

void ICEErrorOut(MSIHANDLE hInstall, MSIHANDLE hRecord, const ErrorInfo_t Info, ...)
{
	va_list listArgs; 
	va_start(listArgs, Info);

	const TCHAR szErrorTemplate[] = TEXT("%s\t%d\t%s\t%s%s\t%s");
	unsigned long lICENum = Info.iICENum;

	TCHAR szError[iHugeBuf] = {0};
	TCHAR szError2[iHugeBuf] = {0};
	_stprintf(szError, szErrorTemplate, g_ICEInfo[lICENum-g_iFirstICE].szName, Info.iType,
		Info.szMessage, szIceHelp, g_ICEInfo[lICENum-g_iFirstICE].szHelp, Info.szLocation);

	_vstprintf(szError2, szError, listArgs); 
	va_end(listArgs);
	// post the message
	::MsiRecordSetString(hRecord, 0, szError2);
	if (!::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecord))
		throw 0;
}

/////////////////////////////////////////////////////////////////////////////
// MarkChildDirs()
// marks all directories that are the provided dir or children of the 
// provided directory with the provided number.
//!! DEV NOTE: for MarkChildDirs to work correctly, iDummy, iMark, iMark2, and iDummyMark
//             must all be different.  iMark2 and iDummyMark initialized to -1, -2 respectively
static const TCHAR sqlProfileMarkRootDir[] = TEXT("UPDATE `Directory` SET `%s`=%d WHERE (`Directory`=?) AND (`%s`=0)");
static const TCHAR sqlProfileMarkDir[] = TEXT("UPDATE `Directory` SET `%s`=%d WHERE (`Directory_Parent`=?) AND (`%s`=0)");
static const TCHAR sqlProfileMarkTargetDir[] = TEXT("UPDATE `Directory` SET `%s`=%d WHERE (`Directory_Parent`=?) AND (`%s`=0)");
static const TCHAR sqlProfileGetMarked[] = TEXT("SELECT `Directory`, `%s`, `DefaultDir` FROM `Directory` WHERE (`%s`=%d) OR (`%s`=%d)");
bool MarkChildDirs(MSIHANDLE hInstall, MSIHANDLE hDatabase, int iICE, 
				   MSIHANDLE hDir, const TCHAR* szColumn, int iDummy, int iMark, bool fIgnoreTarget /*=false*/, int iMark2 /*=-1*/, int iDummyTarget /*=-2*/)
{
	// mark the root directory with iDummy
	CQuery qMark;
	ReturnIfFailed(iICE, 2001, qMark.OpenExecute(hDatabase, hDir, sqlProfileMarkRootDir, szColumn, iDummy, szColumn));
	qMark.Close();
		
	// repeatedly fetch every record marked with iDummy. Mark all of its children
	// with iDummy, then change the mark to iMark. When the query for items marked
	// iDummy fails, everything marked, plus anything that falls in a subtree
	// of anything marked will be marked with a iMark
	CQuery qFetchMarked;
	bool bMarked = true;
	bool bFirstTime = true;
	PMSIHANDLE hMarkedRec;
	ReturnIfFailed(iICE, 2002, qFetchMarked.Open(hDatabase, sqlProfileGetMarked, szColumn, szColumn, iDummy, szColumn, iDummyTarget));
	ReturnIfFailed(iICE, 2003, qMark.Open(hDatabase, sqlProfileMarkDir, szColumn, iDummy,  szColumn));
	CQuery qMarkTarget;
	ReturnIfFailed(iICE, 2008, qMarkTarget.Open(hDatabase, sqlProfileMarkDir, szColumn, iDummyTarget,  szColumn));

	TCHAR* szDefaultDir = NULL;
	DWORD  cchDefaultDir = 0;
	bool bTarget = false;

	while (bMarked) 
	{
		bMarked = false;
		ReturnIfFailed(iICE, 2004,  qFetchMarked.Execute(NULL));
		UINT iStat;
		while (ERROR_SUCCESS == (iStat = qFetchMarked.Fetch(&hMarkedRec))) 
		{
			bTarget = false;
			if (fIgnoreTarget)
			{
				if (!bFirstTime && ::MsiRecordGetInteger(hMarkedRec, 2) == iDummyTarget)
				{
					bTarget = true;
					ReturnIfFailed(iICE, 2009, IceRecordGetString(hMarkedRec, 3, &szDefaultDir, &cchDefaultDir, NULL));
				}
				if (bFirstTime || (bTarget && _tcsncmp(szDefaultDir, TEXT(".:"), 2) == 0))
				{
					// mark all children of this record with iTarget since they can now possibly be valid if
					// maintain .: syntax
					// update as iMark2 (for target)
					::MsiRecordSetInteger(hMarkedRec, 2, iMark2);
					ReturnIfFailed(iICE, 2010, qFetchMarked.Modify(MSIMODIFY_UPDATE, hMarkedRec));
					ReturnIfFailed(iICE, 2011, qMarkTarget.Execute(hMarkedRec));
				}
				else
				{
					// mark all children of this record and update this record
					// this record will have to be in RemoveFile table
					::MsiRecordSetInteger(hMarkedRec, 2, iMark);
					ReturnIfFailed(iICE, 2012, qFetchMarked.Modify(MSIMODIFY_UPDATE, hMarkedRec));
					ReturnIfFailed(iICE, 2013, qMark.Execute(hMarkedRec));
				}
			}
			else
			{
				// mark all children of this record and update this record
				::MsiRecordSetInteger(hMarkedRec, 2, iMark);
				ReturnIfFailed(iICE, 2005, qFetchMarked.Modify(MSIMODIFY_UPDATE, hMarkedRec));
				ReturnIfFailed(iICE, 2006, qMark.Execute(hMarkedRec));
			}

			// set the marked flag to true so we will look again
			bMarked = true;

			// close for re-execution
			qMark.Close();
			qMarkTarget.Close();
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, iICE, 2007);
			return false;
		}
		qFetchMarked.Close();
		bFirstTime = false;
	}
	if (szDefaultDir)
		delete [] szDefaultDir;
	return true;
}


/////////////////////////////////////////////////////////////////////////////
// MarkProfileDirs()
// marks all directories that fall in the users profile with a "1" in the 
// column Directory._Profile (the column is created 
typedef struct profileFolder
{
	const TCHAR*	pName;
	bool			bPerUser;
} ProfileFolder;

static ProfileFolder rgProfileFolder[] = {
	{TEXT("AppDataFolder"), true},
	{TEXT("DesktopFolder"), false},
	{TEXT("FavoritesFolder"), true},
	{TEXT("NetHoodFolder"), true},
	{TEXT("PersonalFolder"), true},
	{TEXT("PrintHoodFolder"), true},
	{TEXT("ProgramMenuFolder"), false},
	{TEXT("RecentFolder"), true},
	{TEXT("SendToFolder"), true},
	{TEXT("StartMenuFolder"), false},
	{TEXT("StartupFolder"), false},
	{TEXT("TemplateFolder"), false},
	{TEXT("MyPicturesFolder"), true},
	{TEXT("LocalAppDataFolder"), true},
	{TEXT("AdminToolsFolder"), false}
};

static const int cszProfileProperties = sizeof(rgProfileFolder)/sizeof(ProfileFolder);

static const TCHAR sqlProfileModifyDir[] = TEXT("ALTER TABLE `Directory` ADD `_Profile` SHORT TEMPORARY HOLD");
static const TCHAR sqlProfileInitColumn[] = TEXT("UPDATE `Directory` SET `_Profile`=0");
bool MarkProfile(MSIHANDLE hInstall, MSIHANDLE hDatabase, int iICE, bool fChildrenOnly /*=false*/, bool fIgnoreTarget /*=false*/, bool fPerUserOnly /*=false*/)
{
	const TCHAR sqlProfileUnmarkActual[] = TEXT("UPDATE `Directory` SET `_Profile`=0 WHERE `Directory`=?");
	
	// add a _ICE38Profile column to the directory table, init to 0
	CQuery qCreate;
	ReturnIfFailed(iICE, 1001, qCreate.OpenExecute(hDatabase, NULL, sqlProfileModifyDir));
	qCreate.Close();
	ReturnIfFailed(iICE, 1002, qCreate.OpenExecute(hDatabase, NULL, sqlProfileInitColumn));
	qCreate.Close();

	// mark every root directory that fits one of the profile properties
	PMSIHANDLE hDummyRec = ::MsiCreateRecord(1);
	for (int i=0; i < cszProfileProperties; i++) {
		if(rgProfileFolder[i].bPerUser == true || fPerUserOnly == false)
		{
			::MsiRecordSetString(hDummyRec, 1, rgProfileFolder[i].pName);
			if (!MarkChildDirs(hInstall, hDatabase, iICE, hDummyRec, TEXT("_Profile"), 1, 2, fIgnoreTarget, 3, 4))
				return false;
		}
	};

	if (fChildrenOnly) {
		CQuery qUnmarkActual;
		ReturnIfFailed(iICE, 1003, qUnmarkActual.Open(hDatabase, sqlProfileUnmarkActual));
		for (int i=0; i < cszProfileProperties; i++) {
			if(rgProfileFolder[i].bPerUser == true || fPerUserOnly == false)
			{
				::MsiRecordSetString(hDummyRec, 1, rgProfileFolder[i].pName);
				ReturnIfFailed(iICE, 1004, qUnmarkActual.Execute(hDummyRec));
			}
		}
	};
	
	return true;
}

bool GeneratePrimaryKeys(UINT iICE, MSIHANDLE hInstall, MSIHANDLE hDatabase, LPCTSTR szTable, LPTSTR *szHumanReadable, LPTSTR *szTabDelimited)
{
	// determine number of primary keys
	PMSIHANDLE hRecKeys;
	ReturnIfFailed(iICE, 2000, ::MsiDatabaseGetPrimaryKeys(hDatabase, szTable, &hRecKeys));

	unsigned int iNumFields = ::MsiRecordGetFieldCount(hRecKeys); // num fields = num primary keys

	// allocate record for error message (moniker + table + column + numPrimaryKeys)
	
	// start the moniker and template
	TCHAR szTemplate[iHugeBuf] = TEXT("[1]");
	DWORD cchTemplate = sizeof(szTemplate)/sizeof(TCHAR);
	TCHAR szMoniker[iHugeBuf] = TEXT("[1]");
	DWORD cchMoniker = sizeof(szMoniker)/sizeof(TCHAR);
	for (int i = 2; i <= iNumFields; i++) // cycle rest of primary keys
	{
		TCHAR szBuf[20] = TEXT("");

		// add key to moniker
		_stprintf(szBuf, TEXT(".[%d]"), i);
		lstrcat(szMoniker, szBuf);

		// add key to template
		_stprintf(szBuf, TEXT("\t[%d]"), i);
		lstrcat(szTemplate, szBuf);
	}

	// allocate and fill output buffers
	*szHumanReadable = new TCHAR[lstrlen(szMoniker)+1];
	lstrcpy(*szHumanReadable, szMoniker);
	*szTabDelimited = new TCHAR[lstrlen(szTemplate)+1];
	lstrcpy(*szTabDelimited, szTemplate);
	return true;
}

UINT GetSummaryInfoPropertyString(MSIHANDLE hSummaryInfo, UINT uiProperty, UINT &puiDataType, LPTSTR *szValueBuf, DWORD &cchValueBuf)
{
	unsigned long  cchDummy = cchValueBuf;
	UINT iStat;
	if (!*szValueBuf)
	{
		cchDummy = 50;
		cchValueBuf = cchDummy;
		if(!(*szValueBuf = new TCHAR[++cchDummy]))
		{
			cchValueBuf = 0;
			return ERROR_FUNCTION_FAILED;
		}
			
	}
	
	int iValue;
	FILETIME ft;
	if (ERROR_SUCCESS != (iStat = ::MsiSummaryInfoGetProperty(hSummaryInfo, uiProperty, &puiDataType, &iValue, &ft, *szValueBuf, &cchDummy)))
	{
		if (ERROR_MORE_DATA == iStat)
		{
			if (szValueBuf)
				delete[] *szValueBuf;
			cchValueBuf = cchDummy;
			*szValueBuf = new TCHAR[++cchDummy];
			iStat = ::MsiSummaryInfoGetProperty(hSummaryInfo, uiProperty, &puiDataType, &iValue, &ft, *szValueBuf, &cchDummy);
		}
		if (ERROR_SUCCESS != iStat) 
		{
			return ERROR_FUNCTION_FAILED;
		}
	}
	return ERROR_SUCCESS;
}

UINT IceRecordGetString(MSIHANDLE hRecord, UINT iColumn, LPTSTR *szBuffer, DWORD *cchBuffer, DWORD *cchLength)
{
	UINT iStat; 
	
	DWORD cchDummy;
	if (!*szBuffer)
	{
		cchDummy = (cchBuffer && *cchBuffer) ? *cchBuffer : 50;
		*szBuffer = new TCHAR[cchDummy];
		if (cchBuffer)
			*cchBuffer = cchDummy;
	}
	else
	{
		if (cchBuffer)
			cchDummy = *cchBuffer;
		else
		{
			delete[] *szBuffer;
			cchDummy = 50;
			*szBuffer = new TCHAR[cchDummy];
		}
	}
	
	if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecord, iColumn, *szBuffer, &cchDummy)))
	{
		if (iStat != ERROR_MORE_DATA)
			return iStat;

		delete[] *szBuffer;
		*szBuffer = new TCHAR[++cchDummy];
		if (cchBuffer) *cchBuffer = cchDummy;
		if (ERROR_SUCCESS != (iStat =  MsiRecordGetString(hRecord, iColumn, *szBuffer, &cchDummy)))
			return iStat;
	}
	
	if (ERROR_SUCCESS == iStat)
	{
		// successful
		if (cchLength) *cchLength = cchDummy;
	}
	return ERROR_SUCCESS;
}

ICE_ERROR(IceSummaryUnsupported, 00, ietWarning, "Your validation engine does not support SummaryInfo validation. This ICE may skip some checks.", ""); 
bool IceGetSummaryInfo(MSIHANDLE hInstall, MSIHANDLE hDatabase, UINT iIce, MSIHANDLE *phSummaryInfo)
{
	if (!phSummaryInfo)
		return false;
		
	TCHAR *szString = NULL;
	DWORD cchString = 0;
	UINT iType = 0;
	ReturnIfFailed(iIce, 1000, ::MsiGetSummaryInformation(hDatabase, NULL, 0, phSummaryInfo));
	ReturnIfFailed(iIce, 1001, GetSummaryInfoPropertyString(*phSummaryInfo, PID_SUBJECT, iType, &szString, cchString));
	if (VT_LPSTR == iType) 
	{
		if (_tcsncmp(_T("Internal Consistency Evaluators"), szString, 31) == 0)
		{
			MsiCloseHandle(*phSummaryInfo);
			*phSummaryInfo = 0;
			PMSIHANDLE hErrorRec = ::MsiCreateRecord(1);
			ErrorInfo_t ActualError = IceSummaryUnsupported;
			ActualError.iICENum = iIce;
			ICEErrorOut(hInstall, hErrorRec, ActualError);
			delete[] szString, szString = NULL;
			return false;
		}
	}
	delete[] szString, szString=NULL;
	return true;
}

/////////////////////////////////////////////////////////////////////////////
// ComponentsInSameFeature
// returns whether or not 2 components are in the same feature.  Does not
// check for Parent Feature to Feature relationships
static const TCHAR sqlUtilCreateFeatureC[] = TEXT("ALTER TABLE `FeatureComponents` ADD `_Util` INT TEMPORARY");
static const TCHAR sqlUtilSelFeatureC_Comp1[] = TEXT("SELECT `Feature_` FROM `FeatureComponents` WHERE `Component_`=?");
static const TCHAR sqlUtilMarkFeatureC[] = TEXT("UPDATE `FeatureComponents` SET `_Util`=1 WHERE `Feature_`=?");
static const TCHAR sqlUtilSelFeatureC_Comp2[] = TEXT("SELECT `Feature_` FROM `FeatureComponents` WHERE (`Component_`=? AND `_Util`=1)");

UINT ComponentsInSameFeature(MSIHANDLE hInstall, MSIHANDLE hDatabase, int iICE, const TCHAR* szComp1, const TCHAR* szComp2, bool* fSameFeature)
{
	if (!fSameFeature)
		return ERROR_FUNCTION_FAILED;

	*fSameFeature = FALSE;

	UINT iStat;
	// create temporary marking column in FeatureComponents table
	CQuery qCreateFeatureC;
	ReturnIfFailed(iICE, 3000, qCreateFeatureC.OpenExecute(hDatabase, 0, sqlUtilCreateFeatureC));
	qCreateFeatureC.Close();

	// create szComp1 rec
	PMSIHANDLE hRecComp1 = ::MsiCreateRecord(1);
	ReturnIfFailed(iICE, 3002, ::MsiRecordSetString(hRecComp1, 1, szComp1));

	// grab every feature with Componet_=szComp1.
	// then mark every location in FeatureC with Feature_=[Feature]
	CQuery qSelFeatureC_Comp1;
	PMSIHANDLE hRecFeature;
	ReturnIfFailed(iICE, 3003, qSelFeatureC_Comp1.OpenExecute(hDatabase, hRecComp1, sqlUtilSelFeatureC_Comp1));
	CQuery qMarkFeatureC;
	ReturnIfFailed(iICE, 3004, qMarkFeatureC.Open(hDatabase, sqlUtilMarkFeatureC));
	while (ERROR_SUCCESS == (iStat = qSelFeatureC_Comp1.Fetch(&hRecFeature)))
	{
		ReturnIfFailed(iICE, 3005, qMarkFeatureC.Execute(hRecFeature));
		qMarkFeatureC.Close();
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		ReturnIfFailed(iICE, 3006, iStat);
	qSelFeatureC_Comp1.Close();

	// create szComp2 rec
	PMSIHANDLE hRecComp2 = ::MsiCreateRecord(1);
	ReturnIfFailed(iICE, 3007, ::MsiRecordSetString(hRecComp2, 1, szComp2));

	// look for *marked* feature matching this component
	CQuery qSelFeatureC_Comp2;
	PMSIHANDLE hFoundMatchFeature = 0;
	if (ERROR_SUCCESS == qSelFeatureC_Comp2.FetchOnce(hDatabase, hRecComp2, &hFoundMatchFeature, sqlUtilSelFeatureC_Comp2))
		*fSameFeature = true; // found match

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\compdecl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       comp.h
//
//--------------------------------------------------------------------------

// comp.h - Evaluation COM Object Component declaration

#ifndef _EVALUATION_COM_COMPONENT_H_
#define _EVALUATION_COM_COMPONENT_H_

#include <objbase.h>

/////////////////////////////////////////////////////////////////////////////
// global variables

#ifdef _EVALCOM_DLL_ONLY_
long g_cComponents = 0;							// count of components
#else
extern long g_cComponents;
#endif

const char g_szFriendlyName[] = "MSI EvalCOM Object";	// friendly name of component
const char g_szVerIndProgID[] = "MSI.EvalCOM";			// version independent ProgID
const char g_szProgID[] = "MSI.EvalCOM.1";				// ProgID

DEFINE_GUID(IID_IUnknown,
	0x00000, 0, 0, 
	0xC0, 0, 0, 0, 0, 0, 0, 0x46);

#endif	// _EVALUATION_COM_COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\evalcom.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       evalcom.cpp
//
//--------------------------------------------------------------------------

#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#include <tchar.h>

/////////////////////////////////////////////////////////////////////////////

#define _EVALCOM_DLL_ONLY_

#include <objbase.h>
#include <initguid.h>
#include "factory.h"
#include "compdecl.h"
#include "trace.h"

bool g_fWin9X = false;

/////////////////////////////////////////////////////////////////////////////
// global variables
static HMODULE g_hInstance = NULL;		// DLL instance handle

///////////////////////////////////////////////////////////////////////
// checks the OS version to see if we're on Win9X. If we are, we need
// to map system calls to ANSI, because everything internal is unicode.
void CheckWinVersion() {
	OSVERSIONINFOA osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	::GetVersionExA(&osviVersion); // fails only if size set wrong
	if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
		g_fWin9X = true;
}

///////////////////////////////////////////////////////////
// DllMain - entry point to DLL
BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved)
{
	TRACE(_T("DllMain - called.\n"));

	// if attaching dll
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		g_hInstance = (HMODULE)hModule;
		CheckWinVersion();
	}

	return TRUE;
}	// DllMain


///////////////////////////////////////////////////////////
// DllCanUnloadNow - returns if dll can unload yet or not
STDAPI DllCanUnloadNow()
{
	TRACE(_T("DllCanUnloadNow - called.\n"));

	// if there are no components loaded and no locks
	if ((g_cComponents == 0) && (g_cServerLocks))
		return S_OK;
	else	// someone is still using it don't let go
		return S_FALSE;
}	// DLLCanUnloadNow


///////////////////////////////////////////////////////////
// DllGetClassObject - get a class factory and interface
STDAPI DllGetClassObject(const CLSID& clsid, const IID& iid, void** ppv)
{
	TRACE(_T("DllGetClassObject - called, CLSID: %d, IID: %d.\n"), clsid, iid);

	// if this clsid is not supported
	if (clsid != CLSID_EvalCom)
		return CLASS_E_CLASSNOTAVAILABLE;

	// try to create a class factory
	CFactory* pFactory = new CFactory;
	if (!pFactory)
		return E_OUTOFMEMORY;

	// get the requested interface
	HRESULT hr = pFactory->QueryInterface(iid, ppv);
	pFactory->Release();

	return hr;
}	// end of DllGetClassObject


///////////////////////////////////////////////////////////
// DllRegisterServer - registers component
STDAPI DllRegisterServer()
{
	return FALSE;

	//TRACE(_T("DllRegisterServer - called.\n"));

/* NOTE:  need to make support both ANSI and UNICODE if uncommented (currently UNICODE only)
	BOOL bResult = FALSE;		// assume everything won't work

	WCHAR szRegFilePath[MAX_PATH + 1];
	DWORD cszRegFilePath = MAX_PATH + 1;

	int cchFilePath = ::GetModuleFileName(g_hInstance, szRegFilePath, cszRegFilePath);

	LPCWSTR szRegCLSID = L"CLSID\\{DC550E10-DBA5-11d1-A850-006097ABDE17}\\InProcServer32";
	LPCWSTR szThreadModelKey = L"CLSID\\{DC550E10-DBA5-11d1-A850-006097ABDE17}\\InProcServer32\\ThreadingModel";
	LPCWSTR szThreadModel = L"Apartment";
	
	HKEY hkey;
	if (ERROR_SUCCESS == ::RegCreateKeyEx(HKEY_CLASSES_ROOT, szRegCLSID, 0, 0, 0, KEY_READ|KEY_WRITE, 0, &hkey, 0))
	{
		if (ERROR_SUCCESS == ::RegSetValueEx(hkey, 0, 0, REG_SZ, (CONST BYTE*)szRegFilePath, (wcslen(szRegFilePath) + 1) * sizeof(WCHAR)))
			bResult = TRUE;
		{
			HKEY hkeyModel;
			if (ERROR_SUCCESS == ::RegCreateKeyEx(HKEY_CLASSES_ROOT, szThreadModelKey, 0, 0, 0, KEY_READ|KEY_WRITE, 0, &hkeyModel, 0))
			{
				if (ERROR_SUCCESS == ::RegSetValueEx(hkeyModel, 0, 0, REG_SZ, (CONST BYTE*)szThreadModel, (wcslen(szThreadModel) + 1) * sizeof(WCHAR)))
					bResult = TRUE;
			}

			// close the threading model key
			::RegCloseKey(hkeyModel);
		}
		
		// close the CLSID key
		::RegCloseKey(hkey);
	}

	return bResult;
*/
}	// end of DllRegisterServer


///////////////////////////////////////////////////////////
// DllUnregsiterServer - unregisters component
STDAPI DllUnregisterServer()
{
	return FALSE;

	//TRACE(_T("DllUnregisterServer - called.\n"));

/*NOTE:  Need to make both UNICODE and ANSI if uncommented (currently UNICODE only)
	BOOL bResult = TRUE;		// assume everything won't work

	WCHAR szRegFilePath[MAX_PATH + 1];
	DWORD cszRegFilePath = MAX_PATH + 1;

	int cchFilePath = ::GetModuleFileName(g_hInstance, szRegFilePath, cszRegFilePath);

	LPCWSTR szRegKill = L"CLSID";
	LPCWSTR szRegCLSID = L"CLSID\\{DC550E10-DBA5-11d1-A850-006097ABDE17}";

	HKEY hkey;
	if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_CLASSES_ROOT, szRegCLSID, 0, KEY_ALL_ACCESS, &hkey))
	{
		if (ERROR_SUCCESS == ::RegDeleteKey(hkey, L"InProcServer32"))
		{
			::RegCloseKey(hkey);			
			if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_CLASSES_ROOT, szRegKill, 0, KEY_ALL_ACCESS, &hkey))
			{
				if (ERROR_SUCCESS == ::RegDeleteKey(hkey, L"{DC550E10-DBA5-11d1-A850-006097ABDE17}"))
					bResult = FALSE;

				::RegCloseKey(hkey);			
			}
		}
	}

	return bResult;
*/
}	// end of DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\evalres.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       evalres.cpp
//
//--------------------------------------------------------------------------

// evalres.cpp - Evaluate COM Object Component Result Interface implemenation

#include "compdecl.h"
#include "evalres.h"

#include "trace.h"	// add debug stuff

///////////////////////////////////////////////////////////
// constructor - component
CEvalResult::CEvalResult(UINT uiType)
{
	// initial count
	m_cRef = 1;

	// set the result type and create the string list
	m_uiType = uiType;
	m_plistStrings = new CStringList;

	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor - component
CEvalResult::~CEvalResult()
{
	// release the string list
	m_plistStrings->Release();

	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor

///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT CEvalResult::QueryInterface(const IID& iid, void** ppv)
{
	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IEvalResult*>(this);
	else if (iid == IID_IEvalResult)
		*ppv = static_cast<IEvalResult*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CEvalResult::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CEvalResult::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// IEvalResult interface methods

///////////////////////////////////////////////////////////
// GetResultType
HRESULT CEvalResult::GetResultType(UINT* puiResultType)
{
	// set the result type
	*puiResultType = m_uiType;

	// return okay
	return S_OK;
}	// end of GetResultType

///////////////////////////////////////////////////////////
// GetResult
HRESULT CEvalResult::GetResult(IEnumString** ppResult)
{
	// addref the string list before returning it
	m_plistStrings->AddRef();
	*ppResult = m_plistStrings;

	// return okay
	return S_OK;
}	// end of GetResult


/////////////////////////////////////////////////////////////////////////////
// non-interface method

///////////////////////////////////////////////////////////
// AddString
UINT CEvalResult::AddString(LPCOLESTR szAdd)
{
	LPWSTR pszAdd;

	// create memory for the string
	pszAdd = new WCHAR[wcslen(szAdd) + 1];

	// copy over the string
	wcscpy(pszAdd, szAdd);

	// add the string to the end of the list
	m_plistStrings->AddTail(pszAdd);

	// return success
	return ERROR_SUCCESS;
}	// end of AddString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\evalres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       evalres.h
//
//--------------------------------------------------------------------------

// evalres.h - Evaluation COM Object Component Result Interface declaration

#ifndef _EVALUATION_RESULT_COM_H_
#define _EVALUATION_RESULT_COM_H_

#include "strlist.h"			// linked list
#include "iface.h"

///////////////////////////////////////////////////////////////////
// Evaluation Result Component
class CEvalResult : public IEvalResult
{
public:
	// constructor/destructor
	CEvalResult(UINT uiType);			// type of evaluation error
	~CEvalResult();

	// IUnknown interface methods
	HRESULT __stdcall QueryInterface(const IID& iid, void** ppv);
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();

	// IEvalResult interface methods
	HRESULT __stdcall GetResultType(UINT* puiResultType);
	HRESULT __stdcall GetResult(IEnumString** pResult);

	// non-interface method
	UINT AddString(LPCOLESTR szAdd);		// string to add

private:
	long m_cRef;		// reference count

	// result info
	UINT m_uiType;						// type of result
	CStringList* m_plistStrings;	// list of evaluation result strings
};	// end of CEvalResult

#endif	// _EVALUATION_RESULT_COM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\eval.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       eval.h
//
//--------------------------------------------------------------------------

// eval.h - Evaluation COM Object Component Interface declaration

#ifndef _EVALUATION_COM_CLASS_H_
#define _EVALUATION_COM_CLASS_H_

#ifndef W32
#define W32
#endif	// W32

#ifndef MSI
#define MSI
#endif	// MSI

#include <windows.h>
#include <tchar.h>
#include "evalenum.h"

#include "msiquery.h"

///////////////////////////////////////////////////////////
// function definitions
//typedef INSTALLUILEVEL (WINAPI* LPMSISETINTERNALUI)(INSTALLUILEVEL dwUILevel, HWND *phWnd);

///////////////////////////////////////////////////////////////////
// Evaluation Component
class CEval : public IEval
{

public:
	// constructor/destructor
	CEval();
	~CEval();

	// IUnknown
	HRESULT __stdcall QueryInterface(const IID& iid, void** ppv);
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();

	// IEval interfaces
	// open/close methods
	HRESULT __stdcall OpenDatabase(LPCOLESTR szDatabase);				// database to evaluate
	HRESULT __stdcall OpenEvaluations(LPCOLESTR szEvaluation);		// database that contains ices
	HRESULT __stdcall CloseDatabase();
	HRESULT __stdcall CloseEvaluations();

	// set methods
	HRESULT __stdcall SetDisplay(LPDISPLAYVAL pDisplayFunction,		// function to handle display
										  LPVOID pContext);						// context passed back to display

	// evaluation methods
	HRESULT __stdcall Evaluate(LPCOLESTR szRunEvaluations = NULL);	// evaluations to run
	HRESULT __stdcall GetResults(IEnumEvalResult** ppResults,		// result enumerator
										  ULONG* pcResults);						// number of results

	// status callback functions
	HRESULT __stdcall SetStatusCallback(const LPEVALCOMCALLBACK, void *pContext);

////////////////////////////
private:		// functions //
	BOOL IsURL(LPCWSTR szPath);						// path to see if is URL

	// initializes download DLLs
	UINT InitializeDownload();
	
	// MSI externalUI message handler
	static int WINAPI MsiMessageHandler(void *pContext, UINT iMessageType, LPCWSTR szMessage);

	// function that filters all results
	BOOL ResultMessage(UINT uiType, LPCWSTR szICE, LPCWSTR szDescription, LPCWSTR szLocation);

///////////////////////
private:		// data //
	bool GetTempFileName(WCHAR *);
	long m_cRef;		// reference count
	bool m_bCancel;		// set to true if we should cancel

	// dynamic link libraries
	HINSTANCE m_hInstWininet;
	HINSTANCE m_hInstUrlmon;
	HINSTANCE m_hInstMsi;

	MSIHANDLE m_hDatabase;			// handle to database to evaluate
	BOOL m_bOpenedDatabase;			// flag if COM Object opened database

	void *m_tzLocalCUB;			    // path to local copy of CUB file (runtime TCHAR, can be WCHAR or char)
	BOOL m_bURL;					// flag if using a URL

	// results
	CEvalResultEnumerator* m_peResultEnumerator;	// enumerator to hold all the results

	LPDISPLAYVAL m_pDisplayFunc;	// user specified display function
	LPVOID m_pContext;				// user specified context for display function

	LPEVALCOMCALLBACK m_pfnStatus;
	LPVOID m_pStatusContext;

};	// end of CEval

extern bool g_fWin9X;

#endif	// _EVALUATION_COM_CLASS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\evalenum.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       evalenum.h
//
//--------------------------------------------------------------------------

// evalenum.h - Evaluation COM Object Component Result Enumerator Interface declaration

#ifndef _EVALUATION_ENUM_COM_H_
#define _EVALUATION_ENUM_COM_H_

#include "evalres.h"

///////////////////////////////////////////////////////////////////
// Evaluation Result Enumerator Component
class CEvalResultEnumerator : public IEnumEvalResult
{
public:
	// constructor/destructor
	CEvalResultEnumerator();
	~CEvalResultEnumerator();

	// IUnknown interface methods
	HRESULT __stdcall QueryInterface(const IID& iid, void** ppv);
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();

	// IEnumEvalResult interface methods
	HRESULT __stdcall Next(ULONG cResults,					// count of results to return
								  IEvalResult** rgpResults,	// interface for results
								  ULONG* pcResultsFetched);	// number of results returned
	HRESULT __stdcall Skip(ULONG cResults);				// count of results to skip
	HRESULT __stdcall Reset(void);
	HRESULT __stdcall Clone(IEnumEvalResult** ppEnum);	// enumerator to clone to

	// non-interface methods
	UINT AddResult(CEvalResult* pResult);		// result to add
	UINT GetCount();

private:
	long m_cRef;		// reference count

	// results
	POSITION m_pos;							// cursor position in list
	CList<CEvalResult*> m_listResults;	// list of evaluation result strings
};	// end of CEvalResultEnumerator

#endif	// _EVALUATION_ENUM_COM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\eval.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       eval.cpp
//
//--------------------------------------------------------------------------

// eval.cpp - Evaluation COM Object Component Interface implemenation

#include "eval.h"
#include <wininet.h>	// internet functionality
#include <urlmon.h>
#include "compdecl.h"
#include "evalres.h"
#include "wchar.h"
#include "trace.h"


/////////////////////////////////////////////////////////////////////////////
// global variables
static const WCHAR g_wzSequenceMarker[] = L"#";
static const WCHAR g_wzSequenceTable[] = L"_ICESequence";

#define MAX_TABLENAME 64

///////////////////////////////////////////////////////////
// constructor
CEval::CEval() : m_hInstWininet(NULL), m_hInstUrlmon(NULL), m_hInstMsi(NULL)
{
	TRACE(_T("CEval::constructor - called.\n"));

	// initial count
	m_cRef = 1;

	// handles to open later
	m_hDatabase = NULL;

	m_bOpenedDatabase = FALSE;		// assume we won't open the database

	// download information
	m_tzLocalCUB = NULL;
	m_bURL = FALSE;				// assume not a URL

	// no results yet
	m_peResultEnumerator = NULL;
	m_bCancel = false;

	// null out all the user display stuff
	m_pDisplayFunc	= NULL;
	m_pContext = NULL;

	m_pfnStatus = NULL;
	m_pStatusContext = NULL;

	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
CEval::~CEval()
{
	TRACE(_T("CEval::destructor - called.\n"));

	// close the database
	if (m_hDatabase && m_bOpenedDatabase)
		MSI::MsiCloseHandle(m_hDatabase);

	// clean up the local CUB
	if (m_tzLocalCUB)
		delete [] m_tzLocalCUB;

	// release any results
	if (m_peResultEnumerator)
		m_peResultEnumerator->Release();

	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor

///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT CEval::QueryInterface(const IID& iid, void** ppv)
{
	TRACE(_T("CEval::QueryInterface - called, IID: %d\n"), iid);

	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IEval*>(this);
	else if (iid == IID_IEval)
		*ppv = static_cast<IEval*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CEval::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CEval::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// IVal interfaces


void DeleteTempFile(LPCWSTR wzTempFileName)
{
	
	// attempt to delete the temp file
	if (g_fWin9X)
	{
		char szTempFileName[MAX_PATH];
		WideCharToMultiByte(CP_ACP, 0, wzTempFileName, -1, szTempFileName, MAX_PATH, NULL, NULL);
		DeleteFileA(szTempFileName);
	}
	else
		DeleteFileW(wzTempFileName);
}

void DeleteTempFile(LPCSTR szTempFileName)
{
	
	// attempt to delete the temp file
	if (g_fWin9X)
		DeleteFileA(szTempFileName);
	else
	{
		WCHAR wzTempFileName[MAX_PATH];
		MultiByteToWideChar(CP_ACP, 0, szTempFileName, -1, wzTempFileName, MAX_PATH);
		DeleteFileW(wzTempFileName);
	}
}

///////////////////////////////////////////////////////////////////////
// CopyTable
// copies a table completely from source database to target
// szTable is table name
// hTarget is handle to target database
// hSource is source database
UINT CopyTable(LPCWSTR szTable, MSIHANDLE hTarget, MSIHANDLE hSource)
{
	UINT iResult;

	WCHAR sqlCopy[64];
	swprintf(sqlCopy, L"SELECT * FROM `%s`", szTable);

	// get a view on both databases
	PMSIHANDLE hViewTarget;
	PMSIHANDLE hViewSource;

	if (ERROR_SUCCESS != (iResult = ::MsiDatabaseOpenViewW(hSource, sqlCopy, &hViewSource)))
		return iResult;
	if (ERROR_SUCCESS != (iResult = ::MsiViewExecute(hViewSource, NULL)))
		return iResult;

	if (ERROR_SUCCESS != (iResult = ::MsiDatabaseOpenViewW(hTarget, sqlCopy, &hViewTarget)))
		return iResult;
	if (ERROR_SUCCESS != (iResult = ::MsiViewExecute(hViewTarget, NULL)))
		return iResult;

	// loop through copying each record
	PMSIHANDLE hCopyRow;
	do
	{
		// if this is a good fetch
		if (ERROR_SUCCESS == (iResult = ::MsiViewFetch(hViewSource, &hCopyRow)))
		{
			// put the row in the target
			// failures are IGNORED! (means duplicate keys??)
			::MsiViewModify(hViewTarget, MSIMODIFY_INSERT, hCopyRow);
		}
	} while(ERROR_SUCCESS == iResult);	// while there is a row to copy

	// no more items is good
	if (ERROR_NO_MORE_ITEMS == iResult)
		iResult = ERROR_SUCCESS;

	MsiViewClose(hViewTarget);
	MsiViewClose(hViewSource);
	return iResult;
}	// end of CopyTable

///////////////////////////////////////////////////////////
// OpenDatabase
HRESULT CEval::OpenDatabase(LPCOLESTR wzDatabase)
{
	// if no database path was passed in
	if (!wzDatabase)
		return E_POINTER;

	// if there already was a database specified close it
	if (m_hDatabase)
		MSI::MsiCloseHandle(m_hDatabase);

	UINT iResult = ERROR_SUCCESS;	// assume everything will be okay

	// if a handle was passed in (starts with #)
	if (L'#' == *wzDatabase)
	{
		// convert string to valid handle
		LPCOLESTR szParse = wzDatabase + 1;
		int ch;
		while ((ch = *szParse) != 0)
		{
			// if the character is not a number (thus not part of the address of the handle)
			if (ch < L'0' || ch > L'9')
			{
				m_hDatabase = 0;						// null out the handle
				iResult = ERROR_INVALID_HANDLE;	// invalid handle
				break;									// quit trying to make this work
			}
			m_hDatabase = m_hDatabase * 10 + (ch - L'0');
			szParse++; // W32::CharNext not implemented on Win95 as Unicode 
		}

		// this didn't open the database so we don't close it
		m_bOpenedDatabase = FALSE;
	}
	else
	{
		// this opened the database so we close it
		m_bOpenedDatabase = TRUE;

		// open the database from string path
		iResult = MSI::MsiOpenDatabaseW(wzDatabase, reinterpret_cast<const unsigned short *>(MSIDBOPEN_READONLY), &m_hDatabase);
	}

	return HRESULT_FROM_WIN32(iResult);
}	// end of OpenDatabase

///////////////////////////////////////////////////////////
// OpenEvaluations
HRESULT CEval::OpenEvaluations(LPCOLESTR wzEvaluation)
{
	// if no evaluation path was passed in
	if (!wzEvaluation)
		return E_POINTER;

	UINT iResult = ERROR_OPEN_FAILED;	// assume we won't open the file

	BOOL bURL = IsURL(wzEvaluation);		// set if this is a URL
	BOOL bResult = FALSE;	// assume everything is bad

	// try to find the file
	WIN32_FIND_DATAA findDataA;			// used to make sure it's not a directory
	WIN32_FIND_DATAW findDataW;			
	WIN32_FIND_DATAW *findData = &findDataW;
	HANDLE hFile;
	char* szEvalAnsi;

	if (g_fWin9X)
	{
		int cchAnsi = W32::WideCharToMultiByte(CP_ACP, 0, wzEvaluation, -1, 0, 0, 0, 0);
		szEvalAnsi = new char[cchAnsi];
		W32::WideCharToMultiByte(CP_ACP, 0, wzEvaluation, -1, szEvalAnsi, cchAnsi, 0, 0);
		hFile = W32::FindFirstFileA(szEvalAnsi, &findDataA);
		findData = (WIN32_FIND_DATAW *)&findDataA;
	}
	else
		hFile = W32::FindFirstFileW(wzEvaluation, &findDataW);

	// if file is specified and it's not a file directory
	if ((hFile != INVALID_HANDLE_VALUE) && !(findData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	{
		// the file actually exists on disk already. 
		// allocate and copy information over from passed in file
		if (g_fWin9X) 
		{
			m_tzLocalCUB = new char[wcslen(wzEvaluation) + 1];
			strcpy(static_cast<char *>(m_tzLocalCUB), szEvalAnsi);
		}
		else
		{
			m_tzLocalCUB = new WCHAR[wcslen(wzEvaluation) + 1];
			wcscpy(static_cast<WCHAR *>(m_tzLocalCUB), wzEvaluation);
		}
		return TRUE;
	}

	TRACE(_T("CEval::SetEvaluations - try download? %d.\n"), bURL);

	// if the file was not found and we can try to download it
	if (bURL)
	{
		// allocate space for the fixed URL
		DWORD cchURL;
		cchURL = wcslen(wzEvaluation) + 1;

		void *tzURL;
		tzURL = g_fWin9X ? static_cast<void *>(new char[cchURL + 2]) : static_cast<void *>(new WCHAR[cchURL + 2]);
		DWORD dwLastError	= 0;		// assume no error

		// try to get the fixed URL
		if ((g_fWin9X && !InternetCanonicalizeUrlA(szEvalAnsi, static_cast<char *>(tzURL), &cchURL, NULL)) ||
		    (!g_fWin9X && !InternetCanonicalizeUrlW(wzEvaluation, static_cast<WCHAR *>(tzURL), &cchURL, NULL)))
		{
			// get the error
			 dwLastError = W32::GetLastError();

			// if the error was just not enough space
			if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
			{
				TRACE(_T("CEval::SetEvaluations - error #%d:INSUFFICIENT_BUFFER... trying again.\n"), dwLastError);

				// reallocate URL string to correct size
				delete [] tzURL;
				tzURL = g_fWin9X ? static_cast<void *>(new char[cchURL + 2]) : static_cast<void *>(new WCHAR[cchURL + 2]);

				// try again
				if ((g_fWin9X && InternetCanonicalizeUrlA(szEvalAnsi, static_cast<char *>(tzURL), &cchURL, NULL)) ||
					(!g_fWin9X && InternetCanonicalizeUrlW(wzEvaluation, static_cast<WCHAR *>(tzURL), &cchURL, NULL)))
					dwLastError = 0;
			}
		}

		TRACE(_T("CEval::SetEvaluations - error #%d: after canoncalize.\n"), dwLastError);

		// if we made it we're good to download
		if (0 == dwLastError)
		{
			HRESULT hResult;
			m_tzLocalCUB = g_fWin9X ? static_cast<void *>(new char[MAX_PATH]) : static_cast<void *>(new WCHAR[MAX_PATH]);

			// do the download
			if (g_fWin9X)
				// note: m_tzLocalCUB is cast to a TCHAR* instead of a char* because the header file
				// incorrectly defines URLDownloadToCacheFileA as taking a TCHAR.
				hResult = URLDownloadToCacheFileA(NULL, static_cast<char *>(tzURL), static_cast<TCHAR *>(m_tzLocalCUB), URLOSTRM_USECACHEDCOPY, 0, NULL);
			else
				hResult = URLDownloadToCacheFileW(NULL, static_cast<WCHAR *>(tzURL), static_cast<WCHAR *>(m_tzLocalCUB), URLOSTRM_USECACHEDCOPY, 0, NULL);

			// if the download was successful
			if (FAILED(hResult))
			{
				delete [] m_tzLocalCUB;
				m_tzLocalCUB = NULL;
				TRACE(_T("CEval::SetEvaluations - failed download.\n"));
				ERRMSG(hResult);
			}
		}
	}

	TRACE(_T("CEval::SetEvaluations - returning: %d\n"), bResult);

	return bResult;
}	// end of OpenEvaluations

///////////////////////////////////////////////////////////
// CloseDatabase
HRESULT CEval::CloseDatabase()
{
	UINT iResult = ERROR_SUCCESS;		// assume everything is good

	// if there is an open database close it
	if (m_hDatabase)
		iResult = MSI::MsiCloseHandle(m_hDatabase);

	// if the result was okay
	if (ERROR_SUCCESS == iResult)
		m_hDatabase = NULL;

	return HRESULT_FROM_WIN32(iResult);
}	// end of CloseDatabase

///////////////////////////////////////////////////////////
// CloseEvaluations
HRESULT CEval::CloseEvaluations()
{
	UINT iResult = ERROR_SUCCESS;		// assume everything is good

	if (!m_tzLocalCUB) 
		return S_FALSE;

	// delete the storage for local CUB name.
	// DO NOT delete the file itself, as it is either the original or a cache copy managed
	// by the internet cache system.
	delete[] m_tzLocalCUB;
	m_tzLocalCUB = NULL;

	return S_OK;
}	// end of CloseEvaluations

///////////////////////////////////////////////////////////
// SetDisplay
HRESULT CEval::SetDisplay(LPDISPLAYVAL pDisplayFunction, LPVOID pContext)
{
	// if no function pointer was passed in
	if (!pDisplayFunction)
		return E_POINTER;

	// set the function and context
	m_pDisplayFunc = pDisplayFunction;
	m_pContext = pContext;

	return S_OK;
}	// end of SetDisplay

///////////////////////////////////////////////////////////
// Evaluate
HRESULT CEval::Evaluate(LPCOLESTR wzRunEvaluations /*= NULL*/)
{
	PMSIHANDLE hEvaluation;
	HRESULT iFunctionResult = S_OK;

	// if the database or evaluation file is not specified
	if (!m_hDatabase || !m_tzLocalCUB)
		return E_PENDING;		

	// release any previous results
	m_bCancel = false;
	if (m_peResultEnumerator)
		m_peResultEnumerator->Release();

	// create a new enumerator
	m_peResultEnumerator = new CEvalResultEnumerator;

	UINT iResult = ERROR_SUCCESS;	// assume everything will be okay

	// status message
	if (m_pfnStatus) (*m_pfnStatus)(ieStatusGetCUB, NULL, m_pStatusContext);

	WCHAR wzTempFileName[MAX_PATH];
	char szTempFileName[MAX_PATH];
	if (!GetTempFileName(wzTempFileName))
	{
		ResultMessage(ieError, L"INIT", L"Failed to retrieve temp file name. Could not complete evaluation.", NULL);
		if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
		return E_FAIL;
	}

	// if running on Win9X, convert to sz
	if (g_fWin9X)  
		WideCharToMultiByte(CP_ACP, 0, wzTempFileName, -1, szTempFileName, MAX_PATH, NULL, NULL);

	// copy the CUB file to the new filename so we don't destroy the original CUB file.
	if (g_fWin9X ? (!::CopyFileA(static_cast<char *>(m_tzLocalCUB), szTempFileName, FALSE)) :
				   (!::CopyFileW(static_cast<WCHAR *>(m_tzLocalCUB), wzTempFileName, FALSE)))
	{
		ResultMessage(ieError, L"INIT", L"Failed to copy CUB file. Could not complete evaluation.", NULL);
		if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
		return E_FAIL;
	}

	// convert the attributes to non-read-only
	g_fWin9X ? W32::SetFileAttributesA(szTempFileName, FILE_ATTRIBUTE_TEMPORARY) : W32::SetFileAttributesW(wzTempFileName, FILE_ATTRIBUTE_TEMPORARY);

	// open the copy of the CUB file
	if (g_fWin9X ? (::MsiOpenDatabaseA(szTempFileName, reinterpret_cast<const char *>(MSIDBOPEN_TRANSACT), &hEvaluation)) 
				 : (::MsiOpenDatabaseW(wzTempFileName, reinterpret_cast<const WCHAR *>(MSIDBOPEN_TRANSACT), &hEvaluation)))
	{
		ResultMessage(ieError, L"INIT", L"Failed to open copy of CUB file. Could not complete evaluation.", NULL);
		if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
		return E_FAIL;
	}

	// status message
	if (m_pfnStatus) (*m_pfnStatus)(ieStatusCreateEngine, NULL, m_pStatusContext);

	// set no UI
	MSI::MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

	// set external message handler
	MSI::MsiSetExternalUIW(MsiMessageHandler, INSTALLLOGMODE_ERROR|INSTALLLOGMODE_WARNING|INSTALLLOGMODE_USER, static_cast<void *>(this));

	// convert the database into a temporary string format: #address_of_db
	WCHAR wzDBBuf[16];
	swprintf(wzDBBuf, L"#%i", hEvaluation);

	// try to create an engine from the database
	MSIHANDLE hEngine = NULL;
	iResult = MsiOpenPackageW(wzDBBuf, &hEngine);
	switch (iResult) 
	{
 	case ERROR_SUCCESS:
		break;
	case ERROR_INSTALL_LANGUAGE_UNSUPPORTED:
		ResultMessage(ieError, L"INIT", L"Failed to create MSI Engine, language unsupported. Could not complete evaluation.", NULL);
		if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
		return HRESULT_FROM_WIN32(iResult);
	default:
		ResultMessage(ieError, L"INIT", L"Failed to create MSI Engine. Could not complete evaluation.", NULL);
		if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
		return HRESULT_FROM_WIN32(iResult);
	}

	// get a database handle
	hEvaluation = MSI::MsiGetActiveDatabase(hEngine);
	if (!hEvaluation)
	{
		ResultMessage(ieError, L"INIT", L"Failed to retrieve DB from engine. Could not complete evaluation.", NULL);
		if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
		return HRESULT_FROM_WIN32(iResult);
	}

	// status message
	if (m_pfnStatus) (*m_pfnStatus)(ieStatusMerge, NULL, m_pStatusContext);

	// merge in the database to be evaluated. The convoluted process is to 
	// first merge the CUB file into a temporary database, then drop everything from
	// the CUB file, then merge the database into the now empty CUB file, then
	// merge everything from the CUB file back into the CUB file. This gets us 3 things:
	// 1. The resulting schema in the data is completely from the database.
	// 2. If there are conflicts between the CUB and database, the database wins
	// 3. Because of 2, we can easily manipulate what merge errors get displayed without
	//    worrying about the CUB file mucking with the database.

	// first drop the Property table from the CUB file. It should have been empty anyway.
	// failure in this case means that there was no property table.
	{
		{
			PMSIHANDLE hViewDropProperty;
			MSI::MsiDatabaseOpenViewW(hEvaluation, L"DROP TABLE `Property`", &hViewDropProperty);
			MSI::MsiViewExecute(hViewDropProperty, 0);
		}

		// next move the CUB to an empty package
		WCHAR wzTempCUB[MAX_PATH] = L"";
		if (!GetTempFileName(wzTempCUB))
		{
			ResultMessage(ieError, L"INIT", L"Failed to retrieve temp file name. Could not complete evaluation.", NULL);
			if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
			return E_FAIL;
		}

		PMSIHANDLE hTempDB;
		iResult = MSI::MsiOpenDatabaseW(wzTempCUB, reinterpret_cast<const WCHAR *>(MSIDBOPEN_CREATEDIRECT), &hTempDB);
		if (ERROR_SUCCESS != iResult)
		{
			if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
			return HRESULT_FROM_WIN32(iResult);
		}
		iResult = MSI::MsiDatabaseMerge(hTempDB, hEvaluation, NULL);
		if (ERROR_SUCCESS != iResult)
		{
			if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
			DeleteTempFile(wzTempCUB);
			return HRESULT_FROM_WIN32(iResult);
		}

		// drop every table from the CUB File
		{
			PMSIHANDLE hViewCUBTables;
			iResult = MSI::MsiDatabaseOpenViewW(hEvaluation, L"SELECT DISTINCT `Table` FROM `_Columns`", &hViewCUBTables);
			if (ERROR_SUCCESS != iResult)
			{
				if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
				DeleteTempFile(wzTempCUB);
				return HRESULT_FROM_WIN32(iResult);
			}
			if (ERROR_SUCCESS != (iResult = MSI::MsiViewExecute(hViewCUBTables, 0)))
			{
				if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
				DeleteTempFile(wzTempCUB);
				return HRESULT_FROM_WIN32(iResult);
			}

			PMSIHANDLE hRecCUBTable = 0;
			while (ERROR_SUCCESS == MSI::MsiViewFetch(hViewCUBTables, &hRecCUBTable))
			{
				// get the table name
				PMSIHANDLE hViewDrop;
				WCHAR szTableName[128];
				DWORD cchTableName = 128;
				iResult = MSI::MsiRecordGetStringW(hRecCUBTable, 1, szTableName, &cchTableName);
				if (ERROR_SUCCESS != iResult)
				{
					// table names are restricted to 72. If we need more than 128, something is
					// horribly wrong
					if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
					ResultMessage(ieError, L"MERGE", L"CUB File table name is too long. Could not complete evaluation.", NULL);
					DeleteTempFile(wzTempCUB);
					return HRESULT_FROM_WIN32(iResult);
				}

				// now drop it from the CUB file.
				WCHAR szSQL[256];
				swprintf(szSQL, L"DROP Table `%ls`", szTableName);
				iResult = MSI::MsiDatabaseOpenViewW(hEvaluation, szSQL, &hViewDrop);
				if (ERROR_SUCCESS != iResult)
				{
					if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
					DeleteTempFile(wzTempCUB);
					return HRESULT_FROM_WIN32(iResult);
				}
				if (ERROR_SUCCESS != (iResult = MSI::MsiViewExecute(hViewDrop, 0)))
				{
					if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
					DeleteTempFile(wzTempCUB);
					return HRESULT_FROM_WIN32(iResult);
				}			
				MsiViewClose(hViewDrop);
			}
			MsiViewClose(hViewCUBTables);
		}

		// now the CUB file data is in the temp database and the CUB file itself is empty. 
		// merge in the database, there cannot be any merge conflicts at this point
		iResult = MSI::MsiDatabaseMergeW(hEvaluation, m_hDatabase, L"MergeConflicts");
		switch (iResult)
		{
		case ERROR_SUCCESS:
			break;
		case ERROR_DATATYPE_MISMATCH:
		case ERROR_FUNCTION_FAILED:
			// this should never happen now, because the target is completely empty
			ResultMessage(ieError, L"MERGE", L"Failed to merge CUB file and database.", NULL);
			if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
			DeleteTempFile(wzTempCUB);
			return S_FALSE;
		default:
			if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
			DeleteTempFile(wzTempCUB);
			return HRESULT_FROM_WIN32(iResult);
		}

		CopyTable(L"_Streams", hEvaluation, m_hDatabase);
		CopyTable(L"_Storages", hEvaluation, m_hDatabase);
		
		// do special handling for the binary table and custom action table
		{
			struct SpecialTable_t
			{
				LPCWSTR szTableName;
				LPCWSTR szQuery;
				LPCWSTR szDrop;
				bool fPresent;
			} rgTableInfo[] = 
			{
				{ L"Binary", L"SELECT `Name`, `Data` FROM `Binary`", L"DROP TABLE `Binary`" },
				{ L"CustomAction", L"SELECT `Action`, `Type`, `Source`, `Target` FROM `CustomAction`", L"DROP TABLE `CustomAction`" }
			};
			
			for (int i=0; i < sizeof(rgTableInfo)/sizeof(SpecialTable_t); i++)
			{
				// if the table doesn't exist, we're OK, there's no need to merge or
				// drop, it will be copied OK below.
				rgTableInfo[i].fPresent = true;
				iResult = MSI::MsiDatabaseIsTablePersistentW(hEvaluation, rgTableInfo[i].szTableName);
				if (iResult == MSICONDITION_NONE)
				{
					rgTableInfo[i].fPresent = false;
					continue;
				}
				if (iResult == MSICONDITION_ERROR)
				{
					if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
					DeleteTempFile(wzTempCUB);
					return HRESULT_FROM_WIN32(iResult);
				}

				// open queries to select data from the table by column name
				PMSIHANDLE hViewCUB;
				PMSIHANDLE hViewMerged;
				iResult = MSI::MsiDatabaseOpenViewW(hEvaluation, rgTableInfo[i].szQuery, &hViewMerged);
				if (ERROR_SUCCESS != iResult)
				{
					// failure to open the query when the table exists means that something is wrong with the
					// database schema in this table					
					if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
					ResultMessage(ieError, L"MERGE", L"Fatal schema conflict between CUB file and database. Unable to perform evaluation.", NULL);
					DeleteTempFile(wzTempCUB);
					return HRESULT_FROM_WIN32(iResult);
				}
				if (ERROR_SUCCESS != (iResult = MSI::MsiViewExecute(hViewMerged, 0)))
				{
					if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
					DeleteTempFile(wzTempCUB);
					return HRESULT_FROM_WIN32(iResult);
				}			

				iResult = MSI::MsiDatabaseOpenViewW(hTempDB, rgTableInfo[i].szQuery, &hViewCUB);
				if (ERROR_SUCCESS != iResult)
				{
					// failure to open the query means the CUB is bad
					if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
					DeleteTempFile(wzTempCUB);
					return HRESULT_FROM_WIN32(iResult);
				}
				if (ERROR_SUCCESS != (iResult = MSI::MsiViewExecute(hViewCUB, 0)))
				{
					if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
					DeleteTempFile(wzTempCUB);
					return HRESULT_FROM_WIN32(iResult);
				}			
				
				// fetch each row from the copy of the CUB and insert into the full database
				PMSIHANDLE hRecCUB = 0;
				while (ERROR_SUCCESS == MSI::MsiViewFetch(hViewCUB, &hRecCUB))
				{
					if (ERROR_SUCCESS != MsiViewModify(hViewMerged, MSIMODIFY_INSERT, hRecCUB))
					{
						// failure to insert is a merge conflict.
						ResultMessage(ieError, L"MERGE", L"Fatal conflict between CUB file and Database. ICE Action already exists. Unable to perform evaluation.", NULL);
						if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	

						// clean up by closing handles
						MsiViewClose(hViewMerged);
						MsiViewClose(hViewCUB);
						MsiCloseHandle(hRecCUB);
						MsiCloseHandle(hViewCUB);
						MsiCloseHandle(hViewMerged);

						// and deleting temporary files
						MsiCloseHandle(hEngine);
						MsiCloseHandle(hTempDB);
						MsiCloseHandle(hEvaluation);
						DeleteTempFile(wzTempCUB);
						DeleteTempFile(wzTempFileName);
						return S_FALSE;
					}
				}
				MsiViewClose(hViewCUB);
				MsiViewClose(hViewMerged);
			}
	
			// due to the merging hijinks above, the Binary table is hopelessly confused. Unless we commit,
			// we can't drop these tables from the database before the merge or we'll be deleting the 
			// streams out from underneath the records. This results in a crash at worst. At best, the 
			// engine will be unable to find the data to stream out into files. This is unfortunate,
			// but because we made a private copy of the CUB file above, is not really a problem beyond
			// the perf issues.
			MsiDatabaseCommit(hEvaluation);

			// the commit has transfered the streams, so now we can drop the tables
			for (i=0; i < sizeof(rgTableInfo)/sizeof(SpecialTable_t); i++)
			{

				if (!rgTableInfo[i].fPresent)
					continue;

				PMSIHANDLE hViewDrop;
				iResult = MSI::MsiDatabaseOpenViewW(hTempDB, rgTableInfo[i].szDrop, &hViewDrop);
				if (ERROR_SUCCESS != iResult)
				{
					if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
					DeleteTempFile(wzTempCUB);
					return HRESULT_FROM_WIN32(iResult);
				}
				if (ERROR_SUCCESS != (iResult = MSI::MsiViewExecute(hViewDrop, 0)))
				{
					if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
					DeleteTempFile(wzTempCUB);
					return HRESULT_FROM_WIN32(iResult);
				}			
				MsiViewClose(hViewDrop);
			}
		}

		// now merge the temp database back into the CUB file		
		iResult = MSI::MsiDatabaseMergeW(hEvaluation, hTempDB, L"MergeConflicts");
		MsiCloseHandle(hTempDB);
		DeleteTempFile(wzTempCUB);
		switch (iResult)
		{
		case ERROR_SUCCESS:
			break;
		case ERROR_DATATYPE_MISMATCH:
			// here is where schema conflicts can happen
			ResultMessage(ieError, L"MERGE", L"Fatal schema conflict between CUB file and database. Unable to perform evaluation.", NULL);
			if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
			return S_FALSE;
		case ERROR_FUNCTION_FAILED:
		{
			TRACE(_T("CEval::Evaluate - MergeConflicts reported.\n"));
			PMSIHANDLE hViewMergeConflicts = 0;
			iResult = MSI::MsiDatabaseOpenViewW(hEvaluation, L"SELECT `Table`, `NumRowMergeConflicts` FROM `MergeConflicts` WHERE `Table`<>'_Validation'", &hViewMergeConflicts);
			if (ERROR_SUCCESS != iResult)
			{
				if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
				return HRESULT_FROM_WIN32(iResult);
			}
			if (ERROR_SUCCESS != (iResult = MSI::MsiViewExecute(hViewMergeConflicts, 0)))
			{
				if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
				return HRESULT_FROM_WIN32(iResult);
			}

			PMSIHANDLE hRecMergeConflicts = 0;
			while (ERROR_SUCCESS == MSI::MsiViewFetch(hViewMergeConflicts, &hRecMergeConflicts))
			{
				WCHAR wzMsg[512] = {0};
				int cConflicts = MSI::MsiRecordGetInteger(hRecMergeConflicts, 2);
				ASSERT(cConflicts != MSI_NULL_INTEGER);
				WCHAR wzTable[72] = {0};
				DWORD cchTable = sizeof(wzTable)/sizeof(WCHAR);
				MSI::MsiRecordGetStringW(hRecMergeConflicts, 1, wzTable, &cchTable);
				swprintf(wzMsg, L"%d Row Merge Conflicts Reported In The %s Table", cConflicts, wzTable);
				ResultMessage(ieError, L"MERGE", wzMsg, NULL);
				iFunctionResult = S_FALSE;
			}
			break;
		}
		default:
			if (m_pfnStatus) (*m_pfnStatus)(ieStatusFail, NULL, m_pStatusContext);	
			return HRESULT_FROM_WIN32(iResult);
		}
	}

	// status message
	if (m_pfnStatus) (*m_pfnStatus)(ieStatusSummaryInfo, NULL, m_pStatusContext);

	// copy the summaryinfo stream.
	PMSIHANDLE hDBCopy;
	PMSIHANDLE hEvalCopy;
	PMSIHANDLE hRecordDB;
	PMSIHANDLE hRecordCUB;
	const WCHAR sqlSummInfoQuery[] = L"SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'";
	if ((ERROR_SUCCESS != MSI::MsiDatabaseOpenViewW(hEvaluation, sqlSummInfoQuery, &hEvalCopy)) ||
		(ERROR_SUCCESS != MSI::MsiDatabaseOpenViewW(m_hDatabase, sqlSummInfoQuery, &hDBCopy)) ||
		(ERROR_SUCCESS != MSI::MsiViewExecute(hDBCopy, 0)) ||
		(ERROR_SUCCESS != MSI::MsiViewExecute(hEvalCopy, 0)))
	{
		// could not open summaryinfo stream on one of the databases
		ResultMessage(ieWarning, L"MERGE", L"Unable to access Summary Information Stream. SummaryInfo validation results will not be valid.", NULL);
		iFunctionResult = S_FALSE;
	}
	else if (ERROR_SUCCESS != MSI::MsiViewFetch(hDBCopy, &hRecordDB))
	{
		ResultMessage(ieWarning, L"MERGE", L"Could not read DB Summary Information Stream. SummaryInfo validation results will not be valid.", NULL);
		iFunctionResult = S_FALSE;
	}
	else if (ERROR_SUCCESS != MSI::MsiViewFetch(hEvalCopy, &hRecordCUB))
	{
		ResultMessage(ieWarning, L"MERGE", L"Could not read CUB Summary Information Stream. SummaryInfo validation results will not be valid.", NULL);
		iFunctionResult = S_FALSE;
	}
	else if (ERROR_SUCCESS != MSI::MsiViewModify(hEvalCopy, MSIMODIFY_DELETE, hRecordCUB)) 
	{
		// could not copy summaryinfo stream.
		ResultMessage(ieWarning, L"MERGE", L"Could not drop CUB Summary Information Stream. SummaryInfo validation results will not be valid.", NULL);
		iFunctionResult = S_FALSE;
	}
	else if (ERROR_SUCCESS != MSI::MsiViewModify(hEvalCopy, MSIMODIFY_INSERT, hRecordDB)) 
	{
		// could not copy summaryinfo stream.
		ResultMessage(ieWarning, L"MERGE", L"Could not write DB Summary Information Stream. SummaryInfo validation results will not be valid.", NULL);
		iFunctionResult = S_FALSE;
	}

	// close all summaryinfo handles.
	MSI::MsiCloseHandle(hRecordDB);
	MSI::MsiCloseHandle(hRecordCUB);
	MSI::MsiViewClose(hEvalCopy);
	MSI::MsiViewClose(hDBCopy);
	MSI::MsiCloseHandle(hEvalCopy);
	MSI::MsiCloseHandle(hDBCopy);

	// initialize OLE for any VBScript ICEs
	W32::CoInitialize(0);

	// hold the Binary table because it will be accessed so much. Failure doesn't matter
	PMSIHANDLE hHoldView;
	MSI::MsiDatabaseOpenViewW(hEvaluation, L"ALTER TABLE `Binary` HOLD", &hHoldView);
	MSI::MsiViewExecute(hHoldView, 0);
	MSI::MsiViewClose(hHoldView);
	MSI::MsiCloseHandle(hHoldView);

	BOOL bUseSequence = FALSE;			// assume we won't use a sequence
	WCHAR wzSequence[MAX_TABLENAME];
	LPWSTR* wzICEs = NULL;			// array of ICEs to DoAction(s) on
	long lICECount = 0;				// count of ICEs to do

	// if there is a string
	if (wzRunEvaluations)
	{
		// if the first character is a sequence marker it's a sequence
		if (0 == wcsncmp(wzRunEvaluations, g_wzSequenceMarker, wcslen(g_wzSequenceMarker)))
		{
			bUseSequence = TRUE;
			wcscpy(wzSequence, wzRunEvaluations + wcslen(g_wzSequenceMarker));	// skip over the sequence marker
		}
		else	// actions one by one
		{
			bUseSequence = FALSE;

			// allocate a buffer (will not be released because m_wzICEs will point at it)
			long lLen = wcslen(wzRunEvaluations);
			LPWSTR wzBuffer = new WCHAR[lLen + 1];

			// copy the string to the buffer
			memcpy(wzBuffer, wzRunEvaluations, sizeof(WCHAR)*(lLen + 1));

			// set the count to one (because there is at least one string
			lICECount = 1;

			// now count the number of ':' markers are in the parameter
			LPWSTR pChar = wzBuffer;
			for (long i = 0; i < lLen; i++)
			{
				if (*pChar == L':')
					lICECount++;

				pChar++;	// move the pointer along
			}

			// allocate enough strings to point at the ":" separated ICEs
			wzICEs = new LPWSTR[lICECount];

			// loop through again putting NULLs in where the colon's used to be
			// and point the ICE array appropriately
			long lCount = 0;
			wzICEs[lCount++] = wzBuffer++;
			while (*wzBuffer != L'\0')
			{
				// if we found a colon, put a NULL in and point the next
				// ICE array at the next char
				if (*wzBuffer == L':')
				{
					// assert lCount < m_lCount
					*wzBuffer++ = L'\0';				// set colon NULL then increment
					// assert szBuffer != NULL
					wzICEs[lCount++] = wzBuffer;
				}

				wzBuffer++;	// increment through the buffer
			}

			ASSERT(lCount == lICECount)

			// status message
			if (m_pfnStatus) (*m_pfnStatus)(ieStatusStarting, reinterpret_cast<void *>(LongToPtr(lICECount)), m_pStatusContext);
		}
	}
	else	// nothing specified so use the default
	{
		// status message
		if (m_pfnStatus) (*m_pfnStatus)(ieStatusStarting, reinterpret_cast<void *>(1), m_pStatusContext);

		bUseSequence = TRUE;
		wcscpy(wzSequence, g_wzSequenceTable);
	}

	// engine started do the validations now
	if(bUseSequence)
	{
		ASSERT(0 == lICECount);		// should be zero

		// status message
		if (m_pfnStatus) (*m_pfnStatus)(ieStatusRunSequence, wzSequence, m_pStatusContext);

		// run the sequence through
		iResult = MsiSequenceW(hEngine, wzSequence, 0);
	}
	else	// do the ices one by one
	{
		UINT nActionResult = 0;	// result of MSIDoAction

		// loop through all ICEs
		for (long i = 0; i < lICECount; i++)
		{
			// status message
			if (m_pfnStatus) (*m_pfnStatus)(ieStatusRunICE, wzICEs[i], m_pStatusContext);

			// do the ICE action
			nActionResult = MsiDoActionW(hEngine, wzICEs[i]);

			// if the action was successful
			if (nActionResult == ERROR_FUNCTION_NOT_CALLED)	// ICE was not found (internal error)
			{
				ResultMessage(ieError, wzICEs[i], L"ICE was not found", NULL);
				iFunctionResult = S_FALSE;
			}
			else if (nActionResult != ERROR_SUCCESS) // failed for some other reason
			{
				iFunctionResult = S_FALSE;
				ResultMessage(ieError, wzICEs[i], L"ICE failed to execute successfully.", NULL);
			}
		}

		// free up memory
		delete [] wzICEs[0];
		delete [] wzICEs;
	}

	// status message
	if (m_pfnStatus) (*m_pfnStatus)(ieStatusShutdown, wzSequence, m_pStatusContext);

	// shutdown the engine now
	MsiCloseHandle(hEngine);
	
	// free the Binary table
	MSI::MsiDatabaseOpenViewW(hEvaluation, L"ALTER TABLE `Binary` FREE", &hHoldView);
	MSI::MsiViewExecute(hHoldView, 0);
	MSI::MsiViewClose(hHoldView);
	MSI::MsiCloseHandle(hHoldView);

	// close the temp database (have to so we can delete the file)
	::MsiCloseHandle(hEvaluation);

	// attempt to delete the temp file
	if (g_fWin9X)
		DeleteFileA(szTempFileName);
	else
		DeleteFileW(wzTempFileName);

	// uninitialize OLE
	W32::CoUninitialize();

	// status message
	if (m_pfnStatus) (*m_pfnStatus)(ieStatusSuccess, wzSequence, m_pStatusContext);
	return iFunctionResult;
}	// end of Validate

///////////////////////////////////////////////////////////
// GetResults
HRESULT CEval::GetResults(IEnumEvalResult** ppResults, ULONG* pcResults)
{
	// if there is no result enumerator
	if (!m_peResultEnumerator)
		return *ppResults = NULL, E_ABORT;

	// set the count and return the enumerator interface
	*pcResults = m_peResultEnumerator->GetCount();
	*ppResults = (IEnumEvalResult*)m_peResultEnumerator;
	m_peResultEnumerator->AddRef();	// addref it before returning it

	return S_OK;
}	// end of GetResults


/////////////////////////////////////////////////////////////////////
// private functions

///////////////////////////////////////////////////////////
// IsURL
BOOL CEval::IsURL(LPCWSTR szPath)
{
	ASSERT(szPath);

	BOOL bResult = FALSE;		// assume it's not a URL

	// if it starts with http:
	if (0 == wcsncmp(szPath, L"http", 4))
		bResult = TRUE;
	else if (0 == wcsncmp(szPath, L"ftp", 3))
		bResult = TRUE;
	else if (0 == wcsncmp(szPath, L"file", 4))
		bResult = TRUE;
	return bResult;
}	// end of IsURL

///////////////////////////////////////////////////////////
// MsiMessageHandler - external UI for MSI
int CEval::MsiMessageHandler(void *pContext, UINT iMessageType, LPCWSTR wzSrcMessage)
{
	// if the context is not specified
	if (!pContext)
		return -1;			// error

	// convert the context into this pointer
	CEval* pThis = static_cast<CEval*>(pContext);

	// check for null wzSrcMessage
	if (!wzSrcMessage)
		return 0; // not our message

	// make a copy of the message we are given, because it is const
	LPWSTR wzMessage = new WCHAR[wcslen(wzSrcMessage)+1];
	if (!wzMessage)
		return -1; // out of memory
	wcscpy(wzMessage, wzSrcMessage);

	// pointers into the message string based off of \t
	LPWSTR wzICE = NULL;
	UINT uiType = ieUnknown;			// assume unknown type
	LPWSTR wzDescription = NULL;
	LPWSTR wzLocation = NULL;

	// ignore the button specifications in the message
	INSTALLMESSAGE mt = (INSTALLMESSAGE)(0xFF000000&(UINT)iMessageType);

	if (INSTALLMESSAGE_USER == mt)
	{
		wzICE = wzMessage;
		LPWSTR wzType = NULL;	// used to determine error

		// if we can find a tab characer
		if (wcslen(wzICE) > 0)
		{
			wzType = wcschr(wzICE, L'\t');
			if (wzType)
			{
				// skip the tab null terminate wzICE
				*(wzType++) = L'\0';

				// determine what type of error this is
				switch (*wzType)
				{
				case L'1':
					uiType = ieError;
					break;
				case L'2':
					uiType = ieWarning;
					break;
				case L'3':
					uiType = ieInfo;
					break;
				default:
					uiType = ieUnknown;
				}
			}

			// if we can find a tab character
			if (wcslen(wzType) > 0)
			{
				wzDescription = wcschr(wzType, L'\t');
				if (wzDescription)
					// skip the tab and null terminate the type 
					*(wzDescription++) = L'\0';	

				// if we can find a tab characer
				if (wcslen(wzDescription) > 0)
				{
					wzLocation = wcschr(wzDescription, L'\t');
					if (wzLocation)
						// skip the tab and null terminate wzDescription
						*(wzLocation++) = L'\0';
				}
				else
				{
					wzICE = L"Unknown";
					uiType = ieUnknown;
					wzDescription = wzMessage;
				}
			}
			else
			{
				wzICE = L"Unknown";
				uiType = ieUnknown;
				wzDescription = wzMessage;
			}
		}
		else
		{
			wzICE = L"Unknown";
			uiType = ieUnknown;
			wzDescription = wzMessage;
		}
	}
	else if (INSTALLMESSAGE_WARNING == mt)
	{
		wzICE = L"Execution";
		uiType = ieWarning;
		wzDescription = wzMessage;
	}
	else if (INSTALLMESSAGE_ERROR == mt)
	{
		wzICE = L"Execution";
		uiType = ieError;
		wzDescription = wzMessage;
	}
	else // some other INSTALLMESSAGE
	{
		delete [] wzMessage;
		return 0; // we don't handle these
	}

	// store the result
	BOOL bResult;
	bResult = pThis->ResultMessage(uiType, wzICE, wzDescription, wzLocation);

	// if the user message handler returned false, set cancel to true
	pThis->m_bCancel = !bResult;

	// clean up wzMessage
	delete [] wzMessage;

	// cancel can also be set through the cancel method.
	return (pThis->m_bCancel) ? IDABORT : IDOK;
}	// end of MsiMessageHandler

///////////////////////////////////////////////////////////
// ResultMessage - add to enumerator and display if necessary
BOOL CEval::ResultMessage(UINT uiType, LPCWSTR wzICE, LPCWSTR wzDescription, LPCWSTR wzLocation)
{
	BOOL bResult = TRUE;		// assume everything is cool

	// if there is a user display
	if (m_pDisplayFunc)
		bResult = (*m_pDisplayFunc)(m_pContext, uiType, wzICE, wzDescription, wzLocation);

	// if there is an enumerator
	if (m_peResultEnumerator)
	{
		// create a new result and add the strings to it
		CEvalResult* pResult = new CEvalResult(uiType);
		pResult->AddString(wzICE);
		pResult->AddString(wzDescription);

		// set parse string to beginning of location
		LPCWSTR wzParse = wzLocation;

		if (wzParse)
		{
			// if we can find a tab character in the location string
			LPWSTR wzTab = wcschr(wzParse, L'\t');
			while (wzTab)
			{
				*wzTab = L'\0';				// null terminate szParse
				pResult->AddString(wzParse);

				wzParse = wzTab + 1;					// skip over the tab
				wzTab = wcschr(wzParse, L'\t');	// find the next tab
			}

			// if there is still something in parse
			if (wzParse)
				pResult->AddString(wzParse);
		}

		// now add the result to the enumerator
		m_peResultEnumerator->AddResult(pResult);
	}

	return bResult;
}	// end of ResultMessage

// retrieves a temp file name as a UNICODE string
bool CEval::GetTempFileName(WCHAR *wzResultName)
{
	if (g_fWin9X)
	{
		DWORD cchTempPath = MAX_PATH;
		char szTempPath[MAX_PATH];
		char szTempFilename[MAX_PATH];
		if (!W32::GetTempPathA(cchTempPath, szTempPath)) return false;
		if (!W32::GetTempFileNameA(szTempPath, "ICE", 0, szTempFilename)) return false;
		MultiByteToWideChar(CP_ACP, 0, szTempFilename, -1, wzResultName, MAX_PATH);
	}
	else
	{
		DWORD cchTempPath = MAX_PATH;
		WCHAR wzTempPath[MAX_PATH];
		if (!W32::GetTempPathW(cchTempPath, wzTempPath)) return false;
		if (!W32::GetTempFileNameW(wzTempPath, L"ICE", 0, wzResultName)) return false;
	}
	return true;
}

// sets a callback function which is used to give status messages back to the
// calling object;
HRESULT CEval::SetStatusCallback(const LPEVALCOMCALLBACK pfnCallback, void *pContext) 
{
	m_pfnStatus = pfnCallback;
	m_pStatusContext = pContext;
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\evalenum.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       evalenum.cpp
//
//--------------------------------------------------------------------------

// evalenum.cpp - Evaluate COM Object Component Result Enumerator Interface implemenation

#include "compdecl.h"
#include "evalenum.h"

#include "trace.h"	// add debug stuff

///////////////////////////////////////////////////////////
// constructor - component
CEvalResultEnumerator::CEvalResultEnumerator()
{
	// initial count
	m_cRef = 1;

	// set the position variable null
	m_pos = NULL;

	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor - component
CEvalResultEnumerator::~CEvalResultEnumerator()
{
	// deallocate the error list
	while (m_listResults.GetHeadPosition())
		delete m_listResults.RemoveHead();

	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor

///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT CEvalResultEnumerator::QueryInterface(const IID& iid, void** ppv)
{
	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IEnumEvalResult*>(this);
	else if (iid == IID_IEnumEvalResult)
		*ppv = static_cast<IEnumEvalResult*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CEvalResultEnumerator::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CEvalResultEnumerator::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release

/////////////////////////////////////////////////////////////////////////////
// IEnumEvalResult interface methods

///////////////////////////////////////////////////////////
// Next
HRESULT CEvalResultEnumerator::Next(ULONG cResults, IEvalResult** rgpResults, ULONG* pcResultsFetched)
{
	// set the number of results fetched to zero
	*pcResultsFetched = 0;

	// loop through count of results
	IEvalResult* pFetched = NULL;
	while (cResults > 0)
	{
		// if we're out of items quit looping
		if (!m_pos)
			return OLE_E_ENUM_NOMORE;

		// fetch the error clss and add it to the array to return
		pFetched = (IEvalResult*) m_listResults.GetNext(m_pos);
		ASSERT(pFetched);

		pFetched->AddRef();		// addref before sending off to la-la land		
		*(rgpResults + *pcResultsFetched) = pFetched;	// ???
			

		(*pcResultsFetched)++;	// increment the count fetched
		cResults--;					// decrement the count to loop
	}

	return S_OK;
}	// end of Next

///////////////////////////////////////////////////////////
// Skip
HRESULT CEvalResultEnumerator::Skip(ULONG cResults)
{
	// loop through the count
	while (cResults > 0)
	{
		// if we're out of items quit looping
		if (!m_pos)
			return OLE_E_ENUM_NOMORE;

		// increment the position (ignore the string returned)
		m_listResults.GetNext(m_pos);

		cResults--;	// decrement the count
	}

	return S_OK;
}	// end of Skip

///////////////////////////////////////////////////////////
// Reset
HRESULT CEvalResultEnumerator::Reset()
{
	// move the position back to the top of the list
	m_pos = m_listResults.GetHeadPosition();

	// return success
	return S_OK;
}	// end of Reset

///////////////////////////////////////////////////////////
// Clone
HRESULT CEvalResultEnumerator::Clone(IEnumEvalResult** ppEnum)
{
	return E_NOTIMPL;
}	// end of Clone


/////////////////////////////////////////////////////////////////////////////
// non-interface methods

///////////////////////////////////////////////////////////
// AddResult
UINT CEvalResultEnumerator::AddResult(CEvalResult* pResult)
{
	// add the result to the end of the results
	m_listResults.AddTail(pResult);

	// if the position is not set, set it to the head
	if (!m_pos)
		m_pos = m_listResults.GetHeadPosition();

	// return success
	return ERROR_SUCCESS;
}	// end of AddResult

///////////////////////////////////////////////////////////
// GetCount
UINT CEvalResultEnumerator::GetCount()
{
	// return number of errors
	return m_listResults.GetCount();
}	// end of GetCount
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\trace.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       trace.h
//
//--------------------------------------------------------------------------

#ifndef _TRACE_H_
#define _TRACE_H_


#if defined(DEBUG) || defined(_DEBUG)

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include "assert.h"


#define ERRMSG FormattedErrorMessage
#define ASSERT(x) assert(x);
void FormattedErrorMessage(HRESULT hr);

#else	// not DEBUG

#include <windows.h>

#define ERRMSG(x)
#define ASSERT(x)

#endif // DEBUG

void FormattedDebugStringA(LPCSTR szFormatter, ...);
void FormattedDebugStringW(LPCWSTR szFormatter, ...);

#if defined(UNICODE) || defined(_UNICODE)
#define TRACE FormattedDebugStringW
#else
#define TRACE FormattedDebugStringA
#endif

#define TRACEW FormattedDebugStringW
#define TRACEA FormattedDebugStringA

#endif // _TRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\factory.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       factory.cpp
//
//--------------------------------------------------------------------------

// factory.cpp - MSI Merge Module Tool Component ClassFactory implemenation

#include "factory.h"
#include "compdecl.h"
#include "iface.h"
#include "eval.h"

#include "trace.h"

///////////////////////////////////////////////////////////
// constructor - component
CFactory::CFactory()
{
	TRACE(_T("CFactory::constructor - called.\n"));

	// initial count
	m_cRef = 1;
}	// end of constructor


///////////////////////////////////////////////////////////
// destructor - component
CFactory::~CFactory()
{
	TRACE(_T("CFactory::destructor - called.\n"));
}	// end of destructor


///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT __stdcall CFactory::QueryInterface(const IID& iid, void** ppv)
{
	TRACE(_T("CFactory::QueryInterface - called, IID: %d.\n"), iid);

	// get class factory interface
	if (iid == IID_IUnknown || iid == IID_IClassFactory)
		*ppv = static_cast<IClassFactory*>(this);
	else	// tried to get a non-class factory interface
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface


///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG __stdcall CFactory::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef


///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG __stdcall CFactory::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


///////////////////////////////////////////////////////////
// CreateInstance - creates a component
HRESULT __stdcall CFactory::CreateInstance(IUnknown* punkOuter, const IID& iid, void** ppv)
{
	TRACE(_T("CFactory::CreateInstance - called, IID: %d.\n"), iid);

	// no aggregation
	if (punkOuter)
		return CLASS_E_NOAGGREGATION;

	// try to create the component
	CEval* pEval = new CEval;
	if (!pEval)
		return E_OUTOFMEMORY;

	// get the requested interface
	HRESULT hr = pEval->QueryInterface(iid, ppv);

	// release IUnknown
	pEval->Release();
	return hr;
}	// end of CreateInstance


///////////////////////////////////////////////////////////
// LockServer - locks or unlocks the server
HRESULT __stdcall CFactory::LockServer(BOOL bLock)
{
	// if we're to lock
	if (bLock)
		InterlockedIncrement(&g_cServerLocks);	// up the lock count
	else	// unlock
		InterlockedDecrement(&g_cServerLocks);	// down the lock count

	// if the locks are invalid
	if (g_cServerLocks < 0)
		return S_FALSE;			// show something is wrong

	// else return okay
	return S_OK;
}	// end of LockServer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\sources.inc ===
TARGETNAME=evalcom
!INCLUDE ..\..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=DYNLINK
TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\urlmon.lib \
	$(SDK_LIB_PATH)\wininet.lib 

USE_LIBCMT=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\evalcom.def

INCLUDES=$(SDK_INC_PATH);$(O);$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\evalcom.cpp \
	..\trace.cpp \
	..\factory.cpp \
	..\eval.cpp \
	..\evalres.cpp \
	..\evalenum.cpp \
	..\evalcom.rc \
	..\strlist.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\factory.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       factory.h
//
//--------------------------------------------------------------------------

// factory.h - MSI Evaluation ClassFactory declaration

#ifndef _EVALUATION_FACTORY_H_
#define _EVALUATION_FACTORY_H_

/////////////////////////////////////////////////////////////////////////////
// global variables
static long g_cServerLocks = 0;								// count of locks

#include "iface.h"
DEFINE_GUID(IID_IClassFactory,
	0x00001, 0, 0, 
	0xC0, 0, 0, 0, 0, 0, 0, 0x46);

///////////////////////////////////////////////////////////////////
// class factory
class CFactory : public IClassFactory
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv);
	virtual ULONG __stdcall AddRef();
	virtual ULONG __stdcall Release();

	// interface IClassFactory
	virtual HRESULT __stdcall CreateInstance(IUnknown* punkOuter, const IID& iid, void** ppv);
	virtual HRESULT __stdcall LockServer(BOOL bLock);
	
	// constructor/destructor
	CFactory();
	~CFactory();

private:
	long m_cRef;		// reference count
};

#endif	// _EVALUATION_FACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\trace.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       trace.cpp
//
//--------------------------------------------------------------------------

// this ensures that UNICODE and _UNICODE are always defined together for this
// object file
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#else
#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif
#endif
#include <tchar.h>
#include "trace.h"

#if defined(DEBUG) || defined(_DEBUG)

/////////////////////////////////////////////////////////////////////////////
// FormattedDebugStringA
void FormattedDebugStringA(LPCSTR szFormatter, ...) 
{ 
	char szBufDisplay[1000] = {0}; 

	va_list listDisplay; 
	va_start(listDisplay, szFormatter); 

	vsprintf(szBufDisplay, szFormatter, listDisplay); 
	::OutputDebugStringA(szBufDisplay); 
} 

/////////////////////////////////////////////////////////////////////////////
// FormattedDebugStringW
void FormattedDebugStringW(LPCWSTR wzFormatter, ...) 
{ 
	WCHAR wzBufDisplay[1000] = {0}; 

	va_list listDisplay; 
	va_start(listDisplay, wzFormatter); 

	vswprintf(wzBufDisplay, wzFormatter, listDisplay); 
	::OutputDebugStringW(wzBufDisplay); 
} 

/////////////////////////////////////////////////////////////////////////////
// FormattedErrorMessage
void FormattedErrorMessage(HRESULT hr)
{
	void* pMsgBuf;
	::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
							NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							(LPTSTR) &pMsgBuf,
							0, NULL);
	TRACE(_T(">>> System Error: %s\n"), (LPTSTR)pMsgBuf);
	LocalFree( pMsgBuf );
}

#else
void FormattedDebugStringA(LPCSTR szFormatter, ...) { };
void FormattedDebugStringW(LPCWSTR wzFormatter, ...) { };
#endif DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\list.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       list.h
//
//--------------------------------------------------------------------------

// list.h - defines and implements a linked list that stores items
//

#ifndef _LINKED_LIST_H_
#define _LINKED_LIST_H_

typedef void* POSITION;

/////////////////////////////////////////////////////////////////////////////
// CList

template <class T>
class CList
{
public:
	CList() : m_pHead(NULL), m_pTail(NULL), m_cCount(0) 
		{ }
	~CList()
		{	RemoveAll();	}

	POSITION AddTail(T pData);

	POSITION InsertBefore(POSITION posInsert, T pData);
	POSITION InsertAfter(POSITION posInsert, T pData);

	T RemoveHead();
	T RemoveTail();

	UINT GetCount();

	POSITION GetHeadPosition();
	T GetHead();
	T GetAt(POSITION pos);
	T GetNext(POSITION& rpos);
	T GetPrev(POSITION& rpos);

	void RemoveAll();

private:
	// embedded class
	class CNode
	{
	public:
		CNode(T pData, CNode* pPrev = NULL, CNode* pNext = NULL) : m_pData(pData), m_pPrev(pPrev), m_pNext(pNext) 
			{ }

		T m_pData;
		CNode* m_pPrev;
		CNode* m_pNext;
	};	// end of CNode

	CNode* m_pHead;
	CNode* m_pTail;

	UINT m_cCount;
};	// end of CList

template <class T>
POSITION CList<T>::AddTail(T pData)
{
	// if there is a tail
	if (m_pTail)
	{
		// create the new tail, then point at it
		m_pTail->m_pNext = new CNode(pData, m_pTail);
		m_pTail = m_pTail->m_pNext;
	}
	else	// there is no tail yet
		m_pTail = new CNode(pData);

	// if there is no head, point it at the tail
	if (!m_pHead)
		m_pHead = m_pTail;

	// increment the count
	m_cCount++;

	// return list node added as a void item
	return (POSITION)m_pTail;
}

template <class T>
POSITION CList<T>::InsertBefore(POSITION posInsert, T pData)
{
	// get the node and the node before to insert
	CNode* pNode = ((CNode*)posInsert);
	CNode* pPrev = pNode->m_pPrev;

	// create a node with the pointers wired up correctly
	pNode->m_pPrev = new CNode(pData, pPrev, pNode);

	// if there is a previous
	if (pPrev)
		pPrev->m_pNext = pNode->m_pPrev;
	else	// new head node
		m_pHead = pNode->m_pPrev;

	// increment the count
	m_cCount++;

	return (POSITION)pNode->m_pPrev;
}	// end of InsertBefore

template <class T>
POSITION CList<T>::InsertAfter(POSITION posInsert, T pData)
{
	// get the node and the node after to insert
	CNode* pNode = ((CNode*)posInsert);
	CNode* pNext = pNode->m_pNext;

	// create a node with the pointers wired up correctly
	pNode->m_pNext = new CNode(pData, pNode, pNext);

	// if there is a next
	if (pNext)
		pNext->m_pPrev = pNode->m_pNext;
	else	// new tail node
		m_pTail = pNode->m_pNext;

	// increment the count
	m_cCount++;

	return (POSITION)pNode->m_pNext;
}	// end of InsertAfter

template <class T>
T CList<T>::RemoveHead()
{
	T pData = NULL;	// assume no data will be returned

	// if there is a head
	if (m_pHead)
	{
		// get the data out of the node
		pData = m_pHead->m_pData;

		// climb down the list
		m_pHead = m_pHead->m_pNext;

		// if you are still in the list
		if (m_pHead)
		{
			// delete the top of the list
			delete m_pHead->m_pPrev;
			m_pHead->m_pPrev = NULL;
		}
		else	// deleting the last object
		{
			delete m_pTail;
			m_pTail = NULL;
		}

		m_cCount--;	// decrement the count
	}

	return pData;	// return how many left
}

template <class T>
T CList<T>::RemoveTail()
{
	T pData = NULL;	// assume no data will be returned

	// if there is a tail
	if (m_pTail)
	{
		// get the data out of the node
		pData = m_pTail->m_pData;

		// climb back up the list
		m_pTail = m_pTail->m_pPrev;

		// if you are still in the list
		if (m_pTail)
		{
			// delete the end of the list
			delete m_pTail->m_pNext;
			m_pTail->m_pNext = NULL;
		}
		else	// deleting the last object
		{
			delete m_pHead;
			m_pHead = NULL;
		}

		m_cCount--;	// decrement the count
	}

	return pData;	// return how many left
}

template <class T>
UINT CList<T>::GetCount()
{
	return m_cCount;	// return count of items
}

template <class T>
POSITION CList<T>::GetHeadPosition()
{
	// return list node as a void item
	return (POSITION)m_pHead;
}

template <class T>
T CList<T>::GetHead()
{
	// if there is no head bail
	if (!m_pHead)
		return NULL;

	// return head node data
	return m_pHead->m_pData;;
}

template <class T>
T CList<T>::GetAt(POSITION pos)
{
	// return data
	return ((CNode*)pos)->m_pData;
}

template <class T>
T CList<T>::GetNext(POSITION& rpos)
{
	// get the data to return
	T pData = ((CNode*)rpos)->m_pData;

	// increment the position
	rpos = (POSITION)((CNode*)rpos)->m_pNext;

	return pData;
}

template <class T>
T CList<T>::GetPrev(POSITION& rpos)
{
	// get the data to return
	T pData = ((CNode*)rpos)->m_pData;

	// decrement the position
	rpos = (POSITION)((CNode*)rpos)->m_pPrev;

	return pData;
}

template <class T>
void CList<T>::RemoveAll()
{
	// while there is a tail, kill it
	while (m_pTail)
		RemoveTail();
}

#endif	// _LINKED_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\strlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       strlist.cpp
//
//--------------------------------------------------------------------------

// strlist.cpp - String List Interface implemenation

#include "compdecl.h"
#include <initguid.h>
#include "strlist.h"

///////////////////////////////////////////////////////////
// constructor
CStringList::CStringList()
{
	// initial count
	m_cRef = 1;

	// null out the position
	m_pos = NULL;

	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor


///////////////////////////////////////////////////////////
// destructor
CStringList::~CStringList()
{
	// clean up the list
	while (GetHeadPosition())
		delete [] RemoveHead();

	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor


///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT CStringList::QueryInterface(const IID& iid, void** ppv)
{
	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IEnumString*>(this);
	else if (iid == IID_IEnumString)
		*ppv = static_cast<IEnumString*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface


///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CStringList::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef


///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CStringList::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release

/////////////////////////////////////////////////////////////////////////////
// IEnumString interface methods

///////////////////////////////////////////////////////////
// Next
HRESULT CStringList::Next(ULONG cStrings, LPOLESTR* pString, ULONG* pcStringsFetched)
{
	// set the strings fetched to zero
	*pcStringsFetched = 0;

	// loop through the count
	while (cStrings > 0)
	{
		// if we're out of items quit looping
		if (!m_pos)
			return OLE_E_ENUM_NOMORE;

		// copy over the string and increment the pos
		*(pString + *pcStringsFetched) = GetNext(m_pos);
			
		(*pcStringsFetched)++;	// increment the count copied
		cStrings--;				// decrement the count to loop
	}

	return ERROR_SUCCESS;
}	// end of Next

///////////////////////////////////////////////////////////
// Skip
HRESULT CStringList::Skip(ULONG cStrings)
{
	// loop through the count
	while (cStrings > 0)
	{
		// if we're out of items quit looping
		if (!m_pos)
			return OLE_E_ENUM_NOMORE;

		// increment the position (ignore the string returned)
		GetNext(m_pos);

		cStrings--;	// decrement the count
	}

	return ERROR_SUCCESS;
}	// end of Skip

///////////////////////////////////////////////////////////
// Reset
HRESULT CStringList::Reset()
{
	// move the position back to the top of the list
	m_pos = GetHeadPosition();

	// return success
	return ERROR_SUCCESS;
}	// end of Reset

///////////////////////////////////////////////////////////
// Clone
HRESULT CStringList::Clone(IEnumString** ppEnum)
{
	return E_NOTIMPL;
}	// end of Clone

///////////////////////////////////////////////////////////
// AddTail
POSITION CStringList::AddTail(LPOLESTR pData)
{
	POSITION pos = CList<LPOLESTR>::AddTail(pData);

	// if there is no position set it to the head
	if (!m_pos)
		m_pos = GetHeadPosition();

	return pos;
}	// end of AddTail

///////////////////////////////////////////////////////////
// InsertBefore
POSITION CStringList::InsertBefore(POSITION posInsert, LPOLESTR pData)
{
	POSITION pos = CList<LPOLESTR>::InsertBefore(posInsert, pData);

	// if there is no position set it to the head
	if (!m_pos)
		m_pos = GetHeadPosition();

	return pos;
}	// end of InsertBefore

///////////////////////////////////////////////////////////
// InsertAfter
POSITION CStringList::InsertAfter(POSITION posInsert, LPOLESTR pData)
{
	POSITION pos = CList<LPOLESTR>::InsertAfter(posInsert, pData);

	// if there is no position set it to the head
	if (!m_pos)
		m_pos = GetHeadPosition();

	return pos;
}	// end of InsertAfter

///////////////////////////////////////////////////////////
// RemoveHead
LPOLESTR CStringList::RemoveHead()
{
	// remove the head
	LPOLESTR psz = CList<LPOLESTR>::RemoveHead();

	// set the internal position to the new head
	m_pos = GetHeadPosition();

	return psz;
}	// end of RemoveHead

///////////////////////////////////////////////////////////
// RemoveTail
LPOLESTR CStringList::RemoveTail()
{
	// remove the tail
	LPOLESTR psz = CList<LPOLESTR>::RemoveTail();

	// set the internal position to the new head
	m_pos = GetHeadPosition();

	return psz;
}	// end of RemoveTail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\evalcom\strlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       strlist.h
//
//--------------------------------------------------------------------------

// strlist.h - String List Implementation declaration

#ifndef _STRING_LIST_H_
#define _STRING_LIST_H_

#include <objidl.h>	// IEnumString
#include "list.h"		// linked list

DEFINE_GUID(IID_IEnumString,
	0x00101, 0, 0, 
	0xC0, 0, 0, 0, 0, 0, 0, 0x46);

///////////////////////////////////////////////////////////////////
// CStringList
class CStringList : public IEnumString,
						  public CList<LPOLESTR>
{
public:
	// constructor/destructor
	CStringList();
	~CStringList();

	// IUnknown interface methods
	HRESULT __stdcall QueryInterface(const IID& iid, void** ppv);
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();

	// IEnumString interface methods
	HRESULT __stdcall Next(ULONG cErrors,					// count of errors to return
								  LPOLESTR * ppError,			// interface for errors
								  ULONG* pcErrorsFetched);		// number of errors returned
	HRESULT __stdcall Skip(ULONG cErrors);					// count of errors to skip
	HRESULT __stdcall Reset(void);
	HRESULT __stdcall Clone(IEnumString** ppEnum);		// enumerator to clone to

	// non-interface methods
	// wrappers around list methods
	POSITION AddTail(LPOLESTR pData);
	POSITION InsertBefore(POSITION posInsert, LPOLESTR pData);
	POSITION InsertAfter(POSITION posInsert, LPOLESTR pData);

	LPOLESTR RemoveHead();
	LPOLESTR RemoveTail();



private:
	long m_cRef;		// reference count
	POSITION m_pos;	// current position for enumerator
};	// end of CStringList

#endif	// _STRING_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\cubes\makefile.inc ===
Cubes:	$(BUILD_DIR)\darice.cub \
	$(BUILD_DIR)\logo.cub \
	$(BUILD_DIR)\XPlogo.cub \
	$(BUILD_DIR)\mergemod.cub

$(O)\common.cub: $(ICESRC)\CUB\*.idt
	msidb.exe -f$(ICESRC)\CUB -c -d$@ -i *.idt

$(BUILD_DIR)\darice.cub: $(O)\common.cub $(ICESRC)\full\*.idt
	msidb.exe -c -f$(ICESRC)\full -d$@ -i *.idt -m $(O)\common.cub
	msidb.exe -f$(SCHEMA_IDT) -i -d$@ property.idt

$(BUILD_DIR)\logo.cub: $(O)\common.cub $(ICESRC)\logo\*.idt 
	msidb.exe -f$(ICESRC)\logo -c -d$@ -i *.idt -m $(O)\common.cub
	msidb.exe -f$(SCHEMA_IDT) -i -d$@ property.idt

$(BUILD_DIR)\XPlogo.cub: $(O)\common.cub $(ICESRC)\XPlogo\*.idt 
	msidb.exe -f$(ICESRC)\XPlogo -c -d$@ -i *.idt -m $(O)\common.cub
	msidb.exe -f$(SCHEMA_IDT) -i -d$@ property.idt


$(BUILD_DIR)\mergemod.cub: $(ICESRC)\MMCUB\*.idt $(ICESRC)\CUB\_badregd.idt $(ICESRC)\CUB\_reserve.idt $(ICESRC)\CUB\_badprop.idt \
		$(ICESRC)\CUB\_validat.idt $(SCHEMA_IDT)\property.idt \
        $(ICESRC)\CUB\_action.idt
	msidb.exe -c -f$(ICESRC)\MMCUB -d$@ -i *.idt
	msidb.exe -f$(SCHEMA_IDT) -i -d$@ property.idt
	msidb.exe -f$(ICESRC)\CUB -c -d $(O)\mmcomm.cub -i _badregd.idt _reserve.idt _badprop.idt _validat.idt _action.idt
	msidb.exe -f$(ICESRC)\full -i -d$@ _schemad.idt -m $(O)\mmcomm.cub
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\modice.dll\sources.inc ===
TARGETNAME=modice
!INCLUDE ..\..\..\..\MsiMake.inc

TARGETTYPE=DYNLINK
TARGETLIBS= \
	$(BUILD_DIR)\msi.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1
USE_NATIVE_EH=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\modice.def
BINPLACE_PLACEFILE=..\..\placefil.txt

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\modice.cpp \
	..\modice.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\msiice.dll\msiice.cpp ===
//depot/private/msidev/admin/darwin/src/msitools/iceman/msiice.dll/msiice.cpp#2 - edit change 10700 (text)
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       msiice.cpp
//
//--------------------------------------------------------------------------

 
/*---------------------------------------------------------------------------------
headers, etc.
---------------------------------------------------------------------------------*/
#include <windows.h>  // included for both CPP and RC passes
#include <objbase.h>
#include <stdio.h>    // printf/wprintf
#include <stdlib.h>  // atoi
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "msidefs.h"  // must be in this directory or on INCLUDE path
#include "..\..\common\msiice.h"
#include "..\..\common\query.h"
#include "..\..\common\utilinc.cpp"

//!! Fix warnings and remove pragma
#pragma warning(disable : 4018) // signed/unsigned mismatch

const int g_iFirstICE = 1;
const struct ICEInfo_t g_ICEInfo[] = 
{
	// ICE01
	{
		TEXT("ICE01"),
		TEXT("Created 04/29/1998. Last Modified 08/17/1998."),
		TEXT("Simple ICE that doesn't test anything"),
		TEXT("ice01.html")
	},
	// ICE02
	{ 
		TEXT("ICE02"),
		TEXT("Created 05/18/1998. Last Modified 10/12/1998."),
		TEXT("ICE to test circular references in File and Component tables"),
		TEXT("ice02.html")
	},
	// ICE03
	{	
		TEXT("ICE03"),
		TEXT("Created 05/19/1998. Last Modified 10/03/2001."),
		TEXT("ICE to perform data validation and foreign key references"),
		TEXT("ice03.html")
	},
	// ICE04
	{
		TEXT("ICE04"),
		TEXT("Created 05/19/1998. Last Modified 09/24/1998."),
		TEXT("ICE to validate File table sequences according to Media table"),
		TEXT("ice04.html")
	},
	// ICE05
	{
		TEXT("ICE05"),
		TEXT("Created 05/20/1998. Last Modified 01/26/1999."),
		TEXT("ICE to validate that required data exists in certain tables."),
		TEXT("ice05.html")
	},
	// ICE06
	{
		TEXT("ICE06"),
		TEXT("Created 05/20/1998. Last Modified 02/18/1999."),
		TEXT("ICE that looks for missing columns in database tables"),
		TEXT("ice06.html")
	},
	// ICE07
	{
		TEXT("ICE07"),
		TEXT("Created 05/21/1998. Last Modified 02/18/1999."),
		TEXT("ICE that ensures that fonts are installed to the fonts folder. Only checked if you have a Font table"),
		TEXT("ice07.html")
	},
	// ICE08 -vbs
	{
		TEXT(""),
		TEXT(""),
		TEXT(""),
		TEXT("")
	},
	// ICE09 -vbs
	{
		TEXT(""),
		TEXT(""),
		TEXT(""),
		TEXT("")
	},
	// ICE10
	{
		TEXT("ICE10"),
		TEXT("Created 05/22/1998. Last Modified 10/02/2000."),
		TEXT("ICE that ensures that advertise states of feature childs and parents match"),
		TEXT("ice10.html")
	},
	// ICE11
	{
		TEXT("ICE11"),
		TEXT("Created 05/22/1998. Last Modified 08/17/1998."),
		TEXT("ICE that validates the Product Code of a nested install (advertised MSI) custom action type"),
		TEXT("ice11.html")
	},
	// ICE12
	{
		TEXT("ICE12"),
		TEXT("Created 05/29/1998. Last Modified 01/14/2000."),
		TEXT("ICE that validates the Property type custom actions"),
		TEXT("ice12.html")
	},
	// ICE13
	{
		TEXT("ICE13"),
		TEXT("Created 06/08/1998. Last Modified 08/17/1998."),
		TEXT("ICE that validates that no dialogs are listed in the *ExecuteSequence tables"),
		TEXT("ice13.html")
	},
	// ICE14
	{
		TEXT("ICE14"),
		TEXT("Created 06/08/1998. Last Modified 01/27/1999."),
		TEXT("ICE that ensures that Feature_Parents do not have the ifrsFavorParent attribute set"),
		TEXT("ice14.html")
	},
	// ICE15
	{
		TEXT("ICE15"),
		TEXT("Created 06/11/1998. Last Modified 01/05/1999."),
		TEXT("ICE that ensures that a circular reference exists between the Mime and Extension tables"),
		TEXT("ice15.html")
	},
	// ICE16
	{
		TEXT("ICE16"),
		TEXT("Created 06/11/1998. Last Modified 10/03/2001."),
		TEXT("ICE that ensures that the ProductName in the Property table is less than 64 characters"),
		TEXT("ice16.html")
	},
	// ICE17
	{
		TEXT("ICE17"),
		TEXT("Created 06/16/1998. Last Modified 05/15/1999."),
		TEXT("ICE that validates foreign key dependencies based upon control types in the Control table."),
		TEXT("ice17.html")
	},
	// ICE18
	{
		TEXT("ICE18"),
		TEXT("Created 06/18/1998. Last Modified 03/24/1999."),
		TEXT("ICE that validates the nulled KeyPath columns of the Component table."),
		TEXT("ice18.html")
	},
	// ICE19
	{
		TEXT("ICE19"),
		TEXT("Created 06/18/1998. Last Modified 01/21/1999."),
		TEXT("ICE that validates that ComponentIDs and KeyPaths for advertising."),
		TEXT("ice19.html")
	},
	// ICE20
	{
		TEXT("ICE20"),
		TEXT("Created 06/25/1998. Last Modified 10/04/1998."),
		TEXT("ICE that validates for Standard Dialogs if UI is authored."),
		TEXT("ice20.html")
	},
	// ICE21
	{
		TEXT("ICE21"),
		TEXT("Created 06/29/1998. Last Modified 03/02/1999."),
		TEXT("ICE that validates that all components reference a feature."),
		TEXT("ice21.html")
	},
	// ICE22
	{
		TEXT("ICE22"),
		TEXT("Created 06/29/1998. Last Modified 03/02/1999."),
		TEXT("ICE that validates that the feature and component referenced by a PublishedComponent actually map."),
		TEXT("ice22.html")
	},
	// ICE23
	{
		TEXT("ICE23"),
		TEXT("Created 07/02/1998. Last Modified 01/17/2000."),
		TEXT("ICE that validates the tab order of all dialogs."),
		TEXT("ice23.html")
	},
	// ICE24
	{
		TEXT("ICE24"),
		TEXT("Created 07/15/1998. Last Modified 02/01/1999."),
		TEXT("ICE that validates specific properties in the Property table."),
		TEXT("ice24.html")
	},
	// ICE25
	{
		TEXT("ICE25"),
		TEXT("Created 07/20/1998. Last Modified 08/31/1998."),
		TEXT("ICE that validates module dependencies/exclusions."),
		TEXT("ice25.html")
	},
	// ICE26
	{
		TEXT("ICE26"),
		TEXT("Created 08/13/1998. Last Modified 04/06/1999."),
		TEXT("ICE that validates required and prohibited actions in the Sequence tables."),
		TEXT("ice26.html")
	},
	// ICE27
	{
		TEXT("ICE27"),
		TEXT("Created 08/04/1998. Last Modified 04/22/1999."),
		TEXT("ICE that validates sequence table organization and sequence table dependencies."),
		TEXT("ice27.html")
	},
	// ICE28
	{
		TEXT("ICE28"),
		TEXT("Created 08/13/1998. Last Modified 10/27/1998."),
		TEXT("ICE that validates actions that can't be separated by ForceReboot."),
		TEXT("ice28.html")
	},
	// ICE29
	{
		TEXT("ICE29"),
		TEXT("Created 08/11/1998. Last Modified 10/27/1998."),
		TEXT("ICE that validates stream names."),
		TEXT("ice29.html")
	},
	// ICE30
	{
		TEXT("ICE30"),
		TEXT("Create 08/25/1998. Last Modified 06/26/2001."),
		TEXT("ICE that detects cross-component file collisions."),
		TEXT("ice30.html")
	},
	// ICE31
	{
		TEXT("ICE31"),
		TEXT("Created 07/24/1998. Last Modified 12/02/2000."),
		TEXT("ICE to verify that controls use valid text styles."),
		TEXT("ice31.html")
	},
	// ICE32
	{
		TEXT(""),
		TEXT(""),
		TEXT(""),
		TEXT("")
	},
	// ICE33
	{
		TEXT("ICE33"),
		TEXT("Created 09/01/1998. Last Modified 04/19/2001."),
		TEXT("ICE to verify that Registry entries do not duplicate or collide with registry tables."),
		TEXT("ice33.html")
	},
	// ICE34
	{
		TEXT("ICE34"),
		TEXT("Created 08/06/1998. Last Modified 10/27/1998."),
		TEXT("ICE to verify that all radio groups have a default."),
		TEXT("ice34.html")
	},
	// ICE35
	{
		TEXT("ICE35"),
		TEXT("Created 08/18/1998. Last Modified 10/17/2000."),
		TEXT("ICE that validates that compressed files are not set RFS, and ensures they have CABs."),
		TEXT("ice35.html")
	},
	// ICE36
	{
		TEXT("ICE36"),
		TEXT("Created 08/17/1998. Last Modified 01/17/2000."),
		TEXT("ICE that flags unused icons in the icon table, increasing performance."),
		TEXT("ice36.html")
	},
	// ICE37
	{
		TEXT("ICE37"),
		TEXT("Created 08/27/1998. Last Modified 09/25/1998."),
		TEXT("ICE that checks localized databases have a codepage."),
		TEXT("ice37.html")
	},
	// ICE38
	{
		TEXT("ICE38"),
		TEXT("Created 08/28/1998. Last Modified 01/17/2000."),
		TEXT("ICE that verifes that components in the user profile use HKCU reg entries as KeyPaths."),
		TEXT("ice38.html")
	},
	// ICE39
	{
		TEXT("ICE39"),
		TEXT("Created 09/03/1998. Last Modified 10/02/2000."),
		TEXT("ICE that validates summary information stream properties."),
		TEXT("ice39.html")
	},
	// ICE40
	{
		TEXT("ICE40"),
		TEXT("Created 09/07/1998. Last Modified 12/02/2000."),
		TEXT("ICE that checks various miscellaneous problems."),
		TEXT("ice40.html")
	},
	// ICE41
	{
		TEXT("ICE41"),
		TEXT("Created 09/08/1998. Last Modified 09/11/1998."),
		TEXT("ICE that verifes that Feature/Component references are valid in advertising tables."),
		TEXT("ice41.html")
	},
	// ICE42
	{
		TEXT("ICE42"),
		TEXT("Created 09/10/1998. Last Modified 07/21/1999."),
		TEXT("ICE that verifes arguments and context values in the Class Table."),
		TEXT("ice42.html")
	},
	// ICE43
	{
		TEXT("ICE43"),
		TEXT("Created 09/27/1998. Last Modified 01/17/2000."),
		TEXT("ICE that verifes non-advertised shortucts are in components with HKCU keypaths."),
		TEXT("ice43.html")
	},
	// ICE44
	{
		TEXT("ICE44"),
		TEXT("Created 09/28/1998. Last Modified 09/30/1998."),
		TEXT("ICE that verifes Dialog events refer to valid Dialog entries."),
		TEXT("ice44.html")
	},
	// ICE45
	{
		TEXT("ICE45"),
		TEXT("Created 10/01/1998. Last Modified 06/15/1999."),
		TEXT("ICE that verifes reserved bits are not set in attributes columns."),
		TEXT("ice45.html")
	},
	// ICE46
	{
		TEXT("ICE46"),
		TEXT("Created 10/14/1998. Last Modified 10/02/2000."),
		TEXT("ICE that checks for property usage where the property differs only by case from a defined property."),
		TEXT("ice46.html")
	},
	// ICE47
	{
		TEXT("ICE47"),
		TEXT("Created 10/20/1998. Last Modified 03/17/1999."),
		TEXT("ICE that checks for features with more than 800 components."),
		TEXT("ice47.html")
	},
	// ICE48
	{
		TEXT("ICE48"),
		TEXT("Created 10/26/1998. Last Modified 10/26/1998."),
		TEXT("ICE that checks for directories that are hardcoded to local drives."),
		TEXT("ice48.html")
	},
	// ICE49
	{
		TEXT("ICE49"),
		TEXT("Created 10/27/1998. Last Modified 10/27/1998."),
		TEXT("ICE that checks for non-REG_SZ default registry entries."),
		TEXT("ice49.html")
	},
	// ICE50
	{
		TEXT("ICE50"),
		TEXT("Created 10/27/1998. Last Modified 10/29/1998."),
		TEXT("ICE that verifies the icon extension matches the shortcut target extension."),
		TEXT("ice50.html")
	},
	// ICE51
	{
		TEXT("ICE51"),
		TEXT("Created 10/28/1998. Last Modified 10/28/1998."),
		TEXT("ICE to verify that only TTC/TTF fonts are missing titles."),
		TEXT("ice51.html")
	},
	// ICE52
	{
		TEXT("ICE52"),
		TEXT("Created 11/16/1998. Last Modified 11/16/1998."),
		TEXT("ICE to verify that APPSearch properties are public properties."),
		TEXT("ice52.html")
	},
	// ICE53
	{
		TEXT("ICE53"),
		TEXT("Created 11/19/1998. Last Modified 07/21/1999."),
		TEXT("ICE to verify that registry entries do not overwrite private installer data."),
		TEXT("ice53.html")
	},
	// ICE54
	{
		TEXT("ICE54"),
		TEXT("Created 12/07/1998. Last Modified 12/07/1998."),
		TEXT("ICE to check that Component KeyPaths are not companion files."),
		TEXT("ice54.html")
	},
	// ICE55
	{
		TEXT("ICE55"),
		TEXT("Created 12/14/1998. Last Modified 12/14/1998."),
		TEXT("ICE to check that LockPermission objects exist and have valid permissions."),
		TEXT("ice55.html")
	},
	// ICE56
	{
		TEXT("ICE56"),
		TEXT("Created 12/15/1998. Last Modified 03/29/1999."),
		TEXT("ICE to check that the Directory structure has a single, valid, root."),
		TEXT("ice56.html")
	},
	// ICE57
	{
		TEXT("ICE57"),
		TEXT("Created 02/11/1999. Last Modified 01/17/2000."),
		TEXT("Checks that components contain per-machine or per-user data, but not both."),
		TEXT("ice57.html")
	}
};
const int g_iNumICEs = sizeof(g_ICEInfo)/sizeof(struct ICEInfo_t);

////////////////////////////////////////////////////////////
// ErrorOut -- outputs the API error that occured
//
void APIErrorOut(MSIHANDLE hInstall, UINT iErr, const TCHAR* szIce, TCHAR* szApi)
{
	//NOTE: should not fail on displaying messages
	PMSIHANDLE hRecErr = ::MsiCreateRecord(3);
	::MsiRecordSetString(hRecErr, 0, szErrorOut);
	::MsiRecordSetString(hRecErr, 1, szIce);
	::MsiRecordSetString(hRecErr, 2, szApi);
	::MsiRecordSetInteger(hRecErr, 3, iErr);

	// post error
	if (!::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecErr))
		throw 0;

	// try and provide more useful error info
	PMSIHANDLE hRecLastErr = ::MsiGetLastErrorRecord();
	if (hRecLastErr)
	{ 
		if (::MsiRecordIsNull(hRecLastErr, 0))
			::MsiRecordSetString(hRecLastErr, 0, TEXT("Error [1]: [2]{, [3]}{, [4]}{, [5]}"));
		TCHAR rgchBuf[iSuperBuf];
		DWORD cchBuf = sizeof(rgchBuf)/sizeof(TCHAR);
		MsiFormatRecord(hInstall, hRecLastErr, rgchBuf, &cchBuf);
	
		TCHAR szError[iHugeBuf] = {0};
		_stprintf(szError, szLastError, szIce, rgchBuf);

		::MsiRecordClearData(hRecErr);
		::MsiRecordSetString(hRecErr, 0, szError);
		if (!::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecErr))
			throw 0;
	}
}

//////////////////////////////////////////////////////////////
// IsTablePersistent -- returns whether table is persistent
//  in database.
//
BOOL IsTablePersistent(BOOL fDisplayWarning, MSIHANDLE hInstall, MSIHANDLE hDatabase, const TCHAR* szTable, const TCHAR* szIce)
{
	BOOL fPersistent;
	MSICONDITION cond = ::MsiDatabaseIsTablePersistent(hDatabase, szTable);
	switch (cond)
	{
	case MSICONDITION_ERROR: // error
		{
			APIErrorOut(hInstall, UINT(MSICONDITION_ERROR), szIce, TEXT("MsiDatabaseIsTablePersistent_X"));
			fPersistent = FALSE;
			break;
		}
	case MSICONDITION_FALSE: //!! temporary, error??
		{
			APIErrorOut(hInstall, UINT(MSICONDITION_FALSE), szIce, TEXT("MsiDatabaseIsTablePersistent_X -- Table Marked as Temporary"));
			fPersistent = FALSE;
			break;
		}
	case MSICONDITION_NONE: // not found
		{
			fPersistent = FALSE;
			break;
		}
	case MSICONDITION_TRUE: // permanent
		{
			fPersistent = TRUE;
			break;
		}
	}

	if (!fDisplayWarning)
		return fPersistent; // nothing else to do

	if (!fPersistent) // display ICE warning
	{
		// prepare warning message
		TCHAR szMsg[iMaxBuf] = {0};
		_stprintf(szMsg, szIceWarning, szIce, szTable, szIce);

		// create a record for posting
		PMSIHANDLE hRec = ::MsiCreateRecord(1);
		
		// output
		::MsiRecordSetString(hRec, 0, szMsg);
		::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRec);
	}

	return fPersistent;
}

/////////////////////////////////////////////////////////////////////
// MyCharNext -- selectively calls WIN::CharNext
//
const TCHAR* MyCharNext(const TCHAR* sz)
{
#ifdef UNICODE
	return ++sz;
#else
	return ::CharNext(sz);
#endif // UNICODE
}

/////////////////////////////////////////////////////////////////////
// ValidateDependencies -- "global" function to validate dependencies.
//   Opens a view on the Origin table, and executes.  Opens a view
//   on the Dependent table.  Executes that view with the fetched
//   records from the Origin table.  This is to check that the
//   entry from the Origin exists in the Dependent table
//
// NOTE: This requires you to set up your queries correctly so the
//  Execute works.  You should also check for Table persistence of
//  the Origin table PRIOR to calling this function.  Dependent table
//  persistence is checked in this function (after we determine that
//  we need it)
//
// SQL SYNTAX: for sqlOrigin:  SELECT {key1 for Dep Table},{key2 for Dep Table},{key...},{Error Info col's} FROM {Origin}
//             for sqlDependent: SELECT {whatever} FROM {Dependent} WHERE {key1}=? AND {key2}=? {AND....}
//
// ERROR: must already have ICEXX\t1\tDesc\t%s%s\tTABLE\tCOLUMN\tKey1\tKey2 (etc.).  The %s%s are imp. for web help as
//  this function computes it automatically (using the defined base + actual file)
//
void ValidateDependencies(MSIHANDLE hInstall, MSIHANDLE hDatabase, TCHAR* szDependent, const TCHAR* sqlOrigin,
						  const TCHAR* sqlDependent, const TCHAR* szIceError, const TCHAR* szIce, const TCHAR* szHelp)
{
	// variables
	UINT iStat = ERROR_SUCCESS;

	// declare handles
	PMSIHANDLE hViewOrg = 0;
	PMSIHANDLE hViewDep = 0;
	PMSIHANDLE hRecOrg  = 0;
	PMSIHANDLE hRecDep  = 0;

	// open view on Origin table
	if (ERROR_SUCCESS != (iStat = ::MsiDatabaseOpenView(hDatabase, sqlOrigin, &hViewOrg)))
	{
		APIErrorOut(hInstall, iStat, szIce, TEXT("MsiDatabaseOpenView_1VD"));
		return;
	}
	// execute Origin table view
	if (ERROR_SUCCESS != (iStat = ::MsiViewExecute(hViewOrg, 0)))
	{
		APIErrorOut(hInstall, iStat, szIce, TEXT("MsiViewExecute_3VD"));
		return;
	}

	// does the Dependent table exist (doesn't matter if we don't have any entries of this type)
	BOOL fTableExists = FALSE;
	if (IsTablePersistent(FALSE, hInstall, hDatabase, szDependent, szIce))
		fTableExists = TRUE;
	
	// open view on Dependent table
	if (fTableExists && ERROR_SUCCESS != (iStat = ::MsiDatabaseOpenView(hDatabase, sqlDependent, &hViewDep)))
	{
		APIErrorOut(hInstall, iStat, szIce, TEXT("MsiDatabaseOpenView_2VD"));
		return;
	}

	
	// fetch all from Origin
	for (;;)
	{
		iStat = ::MsiViewFetch(hViewOrg, &hRecOrg);
		if (ERROR_NO_MORE_ITEMS == iStat)
			break; // no more

		if (!fTableExists)
		{
			// check for existence of dependent table
			// by this time, we are supposed to have listings in this table
			if (!IsTablePersistent(TRUE, hInstall, hDatabase, szDependent, szIce))
			{
				// ***********
				return;
			}
		}

		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, szIce, TEXT("MsiViewFetch_4VD"));
			return;
		}

		// execute Dependency table view with Origin table fetch
		if (ERROR_SUCCESS != (iStat = ::MsiViewExecute(hViewDep, hRecOrg)))
		{
			APIErrorOut(hInstall, iStat, szIce, TEXT("MsiViewExecute_5VD"));
			return;
		}

		// try to fetch
		iStat = ::MsiViewFetch(hViewDep, &hRecDep);
		if (ERROR_NO_MORE_ITEMS == iStat)
		{
			// error, Origin record not found in Dependency table
			TCHAR szError[iHugeBuf] = {0};
			_stprintf(szError, szIceError, szIceHelp, szHelp);

			// post error
			::MsiRecordSetString(hRecOrg, 0, szError);
			::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecOrg);
		}
		if (ERROR_NO_MORE_ITEMS != iStat && ERROR_SUCCESS != iStat)
		{
			// API error
			APIErrorOut(hInstall, iStat, szIce, TEXT("MsiViewFetch_6VD"));
			return;
		}

		// close dependent table view so can re-execute
		::MsiViewClose(hViewDep);
	}
}

////////////////////////////////////////////////////////////
// ICE01 -- simple ICE that doesn't test anything.  Outputs
// the time.
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR szIce01Return[]   = TEXT("ICE01\t3\tCalled at [1].");
const TCHAR szIce01Property[] = TEXT("Time");
const TCHAR szIce01NoTime[]   = TEXT("none");

ICE_FUNCTION_DECLARATION(01)
{
	// display generic info
	DisplayInfo(hInstall, 1);

	// time value to be sent on
	TCHAR szValue[iMaxBuf];
	DWORD cchValue = sizeof(szValue)/sizeof(TCHAR);

	// try to get the time of this call
	if (ERROR_SUCCESS != ::MsiGetProperty(hInstall, szIce01Property, szValue, &cchValue))
		_tcscpy(szValue, szIce01NoTime); // no time available

	// setup the record to be sent as a message
	PMSIHANDLE hRecTime = ::MsiCreateRecord(2);
	::MsiRecordSetString(hRecTime, 0, szIce01Return);
	::MsiRecordSetString(hRecTime, 1, szValue);

	// send the time
	::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecTime);

	// return success (ALWAYS)
	return ERROR_SUCCESS;
}
#endif

////////////////////////////////////////////////////////////
// ICE02 -- checks for circular references with the KeyPath
//  values of the Component table.  They must either
//  reference a File who references that same component
//  or reference a Registry Key who references that
//  same component.  This ensures that Darwin detects
//  the install state of the component using a file or
//  registry key that actually pertain to that component
//
const TCHAR sqlIce02Component[]     = TEXT("SELECT `KeyPath`, `Component`, `Attributes` FROM `Component` WHERE `KeyPath` is not null");
const TCHAR sqlIce02File[]          = TEXT("SELECT `File`,`Component_`, `Component_` FROM `File` WHERE `File`=?");
const TCHAR sqlIce02Registry[]      = TEXT("SELECT `Registry`, `Component_` FROM `Registry` WHERE `Registry`=?");
const TCHAR sqlIce02ODBC[]          = TEXT("SELECT `DataSource`, `Component_`  FROM `ODBCDataSource` WHERE `DataSource`=?");

ICE_ERROR(Ice02FileError, 2, ietError, "File: '[1]' cannot be the key file for Component: '[2]'.  The file belongs to Component: '%s'.","Component\tKeyPath\t[2]");
ICE_ERROR(Ice02ODBCError, 2, ietError, "ODBC Data Source: '[1]' cannot be the key file for Component: '[2]'. The DataSource belongs to Component: '%s'.","Component\tKeyPath\t[2]");
ICE_ERROR(Ice02RegError, 2, ietError, "Registry: '[1]' cannot be the key registry key for Component: '[2]'. The RegKey belongs to Component: '%s'","Component\tKeyPath\t[2]");
ICE_ERROR(Ice02RegFetchFailed, 2, ietError, "Registry key: '[1]' not found in Registry table.","Component\tKeyPath\t[2]");
ICE_ERROR(Ice02FileFetchFailed, 2, ietError, "File: '[1]' not found in File table.","Component\tKeyPath\t[2]");
ICE_ERROR(Ice02ODBCFetchFailed, 2, ietError, "ODBC Data Source: '[1]' not found in ODBCDataSource table","Component\tKeyPath\t[2]");
ICE_ERROR(Ice02MissingTable, 2, ietError, "Component '[2]' references %s '[1]' as KeyPath, but the %s table does not exist.","Component\tKeyPath\t[2]");

const int   iIce02RegSource         = msidbComponentAttributesRegistryKeyPath;
const int   iIce02ODBCSource        = msidbComponentAttributesODBCDataSource;

enum ikfAttributes
{
	ikfFile = 0,
	ikfReg  = 1,
	ikfODBC = 2,
};

bool  Ice02MatchKeyPath(MSIHANDLE hInstall, MSIHANDLE hDatabase, MSIHANDLE hRecComponent, ikfAttributes ikf);
bool  Ice02CheckReference(MSIHANDLE hInstall, MSIHANDLE hRecFetchFile, MSIHANDLE hRecFetchComponent, ikfAttributes ikf);


ICE_FUNCTION_DECLARATION(02)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// post generic info
	DisplayInfo(hInstall, 2);

	// obtain handle to database to validate
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 2, 1);
		return ERROR_SUCCESS;
	}

	// see if we can run by checking for the Component table to be existent
	// this way we don't bomb on an empty database
	//NOTE: will check later for File and Registry tables to be existent
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 2, TEXT("Component")))
		return ERROR_SUCCESS;

	// open view on component table
	PMSIHANDLE hViewComponent = 0;
	CQuery qComponent;
	ReturnIfFailed(2, 2, qComponent.OpenExecute(hDatabase, NULL, sqlIce02Component));

	// fetch records from component table
	PMSIHANDLE hRecFetchComponent = 0;
	while ((iStat = qComponent.Fetch(&hRecFetchComponent)) != ERROR_NO_MORE_ITEMS)
	{
		// check iStat for error
		if (iStat != ERROR_SUCCESS)
		{
			APIErrorOut(hInstall, 0, 2, 3);
			return ERROR_SUCCESS;
		}

		// attempt to match Component.KeyPath to Registry Key (if 3rd bit set) or File Key
		ikfAttributes ikf;
		int iAttrib = ::MsiRecordGetInteger(hRecFetchComponent, 3);
		if ((iAttrib & iIce02RegSource) == iIce02RegSource)
			ikf = ikfReg;
		else if ((iAttrib & iIce02ODBCSource) == iIce02ODBCSource)
			ikf = ikfODBC;
		else
			ikf = ikfFile;

		TCHAR szTable[32] = {0};
		switch (ikf)
		{
		case ikfFile:
			_stprintf(szTable, TEXT("File"));
			break;
		case ikfReg:
			_stprintf(szTable, TEXT("Registry"));
			break;
		case ikfODBC:
			_stprintf(szTable, TEXT("ODBCDataSource"));
			break;
		}

		if (!IsTablePersistent(FALSE, hInstall, hDatabase, 2, szTable))
		{
			ICEErrorOut(hInstall, hRecFetchComponent, Ice02MissingTable, szTable, szTable);
			continue;
		}

		if (!Ice02MatchKeyPath(hInstall, hDatabase, hRecFetchComponent, ikf))
			return ERROR_SUCCESS;
	}

	return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////
// Ice02MatchKeyPath -- Obtains file or registry record
//   that matches KeyPath of Component record
//
bool Ice02MatchKeyPath(MSIHANDLE hInstall, MSIHANDLE hDatabase, MSIHANDLE hRecFetchComponent, ikfAttributes ikf)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// open view on correct table
	CQuery qTable;

	const TCHAR* sql = NULL;
	const ErrorInfo_t *Err;
	switch (ikf)
	{
	case ikfFile:
		sql = sqlIce02File;
		Err = &Ice02FileFetchFailed;
		break;
	case ikfReg:
		sql = sqlIce02Registry;
		Err = &Ice02RegFetchFailed;
		break;
	case ikfODBC:
		sql = sqlIce02ODBC;
		Err = &Ice02ODBCFetchFailed;
		break;
	}
	
	// Grab specified record from File table
	ReturnIfFailed(2, 4, qTable.OpenExecute(hDatabase, hRecFetchComponent, sql));
	
	// fetch record -- ensured only one due to uniqueness of file/registry primary key
	PMSIHANDLE hRecFetchKey = 0;
	if (ERROR_SUCCESS != qTable.Fetch(&hRecFetchKey))
	{
		ICEErrorOut(hInstall, hRecFetchComponent, *Err);
		return true;
	}

	// check that File.Component_ = Component.Component or Registry.Component_ = Component.Component
	return Ice02CheckReference(hInstall, hRecFetchKey, hRecFetchComponent, ikf);
}

///////////////////////////////////////////////////////////////////////////
// Ice02CheckReference -- Validates that the *KeyFile* or *RegistryKey*
//   references the particular component that has this file or registry
//   key listed as its *key*
//
bool Ice02CheckReference(MSIHANDLE hInstall, MSIHANDLE hRecFetchKey, MSIHANDLE hRecFetchComponent, ikfAttributes ikf)
{
	const ErrorInfo_t *Err;
	switch (ikf)
	{
	case ikfFile:
		Err = &Ice02FileError;
		break;
	case ikfReg:
		Err = &Ice02RegError;
		break;
	case ikfODBC:
		Err = &Ice02ODBCError;
		break;
	}

	// status return
	UINT iStat = ERROR_SUCCESS;

	// get name of component from fetched component record
	// it is the second field in the fetched record
	TCHAR* pszComponent = NULL;
	ReturnIfFailed(2, 5, IceRecordGetString(hRecFetchComponent, 2, &pszComponent, NULL, NULL));

	// get name of component referenced by File.Component_ or Registry.Component_
	// it is the second field in the fetched record
	TCHAR* pszReferencedComponent = NULL;
	ReturnIfFailed(2, 6, IceRecordGetString(hRecFetchKey, 2, &pszReferencedComponent, NULL, NULL));

	// compare
	if (0 != _tcscmp(pszComponent, pszReferencedComponent))
	{
		ICEErrorOut(hInstall, hRecFetchComponent, *Err, pszReferencedComponent);
	}

	DELETE_IF_NOT_NULL(pszComponent);
	DELETE_IF_NOT_NULL(pszReferencedComponent);

	return true;
}

/////////////////////////////////////////////////////////
// ICE03 -- general data and foreign key validation
//
const TCHAR sqlIce03TableCatalog[]    = TEXT("SELECT `Name` FROM `_Tables`");
const TCHAR sqlIce03Table[]           = TEXT("SELECT * FROM `%s`");
const TCHAR sqlIce03Validation[]	  = TEXT("SELECT `Table` FROM `_Validation` WHERE (`Table`='%s' AND `Column`='%s')");
ICE_QUERY1(sqlIce03ColIndex, "SELECT `Number` FROM `_Columns` WHERE `Table` = '%s' AND `Name` = '%s'", Number);
ICE_QUERY2(sqlIce03FtrRef, "SELECT `Table`, `Column` FROM `_FtrRef` WHERE `Table` = '%s' AND `Column` = '%s'", Table, Column);

ICE_ERROR(Ice03NoError,	3, ietError, "No Error; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03DuplicateKey, 3, ietError, "Duplicate primary key; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03Required, 3, ietError, "Not a nullable column; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadLink, 3, ietError, "Not a valid foreign key; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03Overflow, 3, ietError, "Value exceeds MaxValue; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03Underflow, 3, ietError, "Value below MinValue; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03NotInSet, 3, ietError, "Value not a member of the set; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadVersion, 3, ietError, "Invalid version string. (Be sure a language is specified in Language column); Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadCase, 3, ietError, "All UPPER case required; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadGuid, 3, ietError, "Invalid GUID string (Be sure GUID is all UPPER case); Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadWildCard, 3, ietError, "Invalid filename/usage of wildcards; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadIdentifier, 3, ietError, "Invalid identifier; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadLanguage, 3, ietError, "Invalid Language Id; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadFilename, 3, ietError, "Invalid Filename; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadPath, 3, ietError, "Invalid full path; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadCondition, 3, ietError, "Bad conditional string; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadFormatted, 3, ietError, "Invalid format string; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadTemplate, 3, ietError, "Invalid template string; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadDefaultDir, 3, ietError, "Invalid DefaultDir string; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadRegPath, 3, ietError, "Invalid registry path; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadCustomSource, 3, ietError, "Bad CustomSource data; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadProperty, 3, ietError, "Invalid property string; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03MissingData, 3, ietError, "Missing data in _Validation table or old Database; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadCabinet, 3, ietError, "Bad cabinet syntax/name; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadCategory, 3, ietError, "_Validation table: Invalid category string; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadKeyTable, 3, ietError, "_Validation table: Data in KeyTAble column is incorrect; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadMaxMinValues, 3, ietError, "_Validation table: Value in MaxValue column < that in MinValue column; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadShortcut, 3, ietError, "Bad shortcut target; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03StringOverflow, 3, 2, "String overflow (greater than length permitted in column); Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03MissingEntry, 3, ietError, "Column is required by _Validation table; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03UndefinedError, 3, ietError, "Undefined error; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03BadLocalizeAttrib, 3, ietError, "Column cannot be localized; Table: [1], Column: [2], Key(s): [3]", "[1]\t[2]\t[5]");
ICE_ERROR(Ice03NoValTable, 3, ietError, "No _Validation table in database. unable to validate any data.","_Validation");

ICE_ERROR(Ice03ICEMissingData, 3, ietError, "Table: %s Column: %s Missing specifications in _Validation Table (or Old Database)","%s");

static UINT Ice03Validate(MSIHANDLE hInstall, MSIHANDLE hDatabase);
static const ErrorInfo_t*  Ice03MapErrorToICEError(MSIDBERROR eRet, BOOL& fSkipRest);

ICE_FUNCTION_DECLARATION(03)
{
	// display info
	DisplayInfo(hInstall, 3);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 3, 1);
		return ERROR_SUCCESS;
	}

	// do we have the _Validation table?
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 3, TEXT("_Validation")))
	{
		PMSIHANDLE hRecord = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecord, Ice03NoValTable);
		return ERROR_SUCCESS;
	}

	// validate database
	Ice03Validate(hInstall, hDatabase);

	return ERROR_SUCCESS;
}


////////////////////////////////////////////////////////////
// Ice03Validate -- validates the general data and foreign
//   keys of the tables in the database
//
UINT Ice03Validate(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// Are we validating a merge module?
	BOOL bIsMM = FALSE;
	if(IsTablePersistent(FALSE, hInstall, hDatabase, 3, TEXT("ModuleSignature")) && IsTablePersistent(FALSE, hInstall, hDatabase, 3, TEXT("_FtrRef")))
	{
		bIsMM = TRUE;
	}

	// declare handles
	CQuery qCatalog;
	PMSIHANDLE hRecCatalog = 0;
	CQuery qTable;
	PMSIHANDLE hRecTable = 0;

	// open view on table catalog in database
	ReturnIfFailed(3, 2, qCatalog.OpenExecute(hDatabase, 0, sqlIce03TableCatalog));

	// declare buffers for building queries
	TCHAR sql[iSuperBuf]       = {0};
	TCHAR* pszTableName = NULL;
	TCHAR* pszColumnName = NULL;
	DWORD cchTableName  = iMaxBuf;
	DWORD cchColumnName = iHugeBuf;
	DWORD cchBuf        = cchColumnName;
	
	// ready to loop through tables in catalog
	for (;;)
	{

		iStat = qCatalog.Fetch(&hRecCatalog);
		if (ERROR_NO_MORE_ITEMS == iStat)
			break; // no more rows in _Table catalog
		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 3, 3);
			DELETE_IF_NOT_NULL(pszTableName);
			return ERROR_SUCCESS;
		}
		
		// get name of next table to validate
		ReturnIfFailed(3, 4, IceRecordGetString(hRecCatalog, 1, &pszTableName, &cchTableName, NULL));

		// DO NOT validate temporary tables!!
		MSICONDITION ice = ::MsiDatabaseIsTablePersistent(hDatabase, pszTableName);
		if (ice == MSICONDITION_FALSE)
			continue; // skip temporary table

		// build SQL query and open view on database
		ReturnIfFailed(3, 5, qTable.OpenExecute(hDatabase, 0, sqlIce03Table, pszTableName));

		// check that each column has a validation entry
		PMSIHANDLE hColumnInfo;
		ReturnIfFailed(3, 6, qTable.GetColumnInfo(MSICOLINFO_NAMES, &hColumnInfo));
		int cColumns = ::MsiRecordGetFieldCount(hColumnInfo);
		
		CQuery qColumnVal;
		for (int i=1; i <= cColumns; i++) 
		{
			PMSIHANDLE hResult;
			ReturnIfFailed(3, 7, IceRecordGetString(hColumnInfo, i, &pszColumnName, &cchColumnName, NULL));

			if (ERROR_SUCCESS != qColumnVal.FetchOnce(hDatabase, 0, &hResult, 
				sqlIce03Validation, pszTableName, pszColumnName))
			{
				PMSIHANDLE hRecError = ::MsiCreateRecord(1);
				ICEErrorOut(hInstall, hRecError, Ice03ICEMissingData, pszTableName, pszColumnName, pszTableName);
			}
		}
		qColumnVal.Close();

		// variable to prevent repeated errors for same problematic table (duplicate MissingData errors)
		BOOL fSkipRest = FALSE;
		BOOL fMissing  = FALSE;

		// process current table
		for (;;)
		{
			iStat = qTable.Fetch(&hRecTable);
			if (ERROR_NO_MORE_ITEMS == iStat)
				break; // no more rows to fetch
	
			if (ERROR_SUCCESS != iStat)
			{
				APIErrorOut(hInstall, iStat, 3, 8);
				DELETE_IF_NOT_NULL(pszTableName);
				return ERROR_SUCCESS;
			}

			// call validate
			if (ERROR_SUCCESS != (iStat = qTable.Modify(MSIMODIFY_VALIDATE, hRecTable)))
			{
				// determine invalid data

				// reset (::GetError will write to cchBuf)
				cchBuf = cchColumnName;
				
				// do not print out every error for Missing data (first one will suffice)
				if (fMissing)
					fSkipRest = TRUE;

				// enumerate errors for row
				PMSIHANDLE hRecKeys=0; // primary key rec
				MSIDBERROR eReturn; // hold error type return value
				
				// ensure we have a pszColumnName buffer
				if (!pszColumnName)
				{
					pszColumnName = new TCHAR[iHugeBuf];
					cchColumnName = iHugeBuf;
					cchBuf = cchColumnName;
				}

				while ((eReturn = qTable.GetError(pszColumnName, cchBuf)) != MSIDBERROR_NOERROR)
				{
					if (eReturn == MSIDBERROR_MOREDATA)
					{
						// need to resize buffer
						if (pszColumnName)
							delete [] pszColumnName;
						pszColumnName = new TCHAR[++cchBuf];
						cchColumnName = cchBuf;
						if ((eReturn = qTable.GetError(pszColumnName, cchBuf)) == MSIDBERROR_NOERROR)
							break;
					}

					if (eReturn == MSIDBERROR_FUNCTIONERROR || eReturn == MSIDBERROR_MOREDATA
						|| eReturn == MSIDBERROR_INVALIDARG)
					{
						//!! should we display this??
						break; // not a *data validation* error
					}

					// Intercept MSIDBERROR_BADIDENTIFIER error returned for
					// Feature_ columns if this is a merge module. Because in
					// a merge module features can be represented by
					// null GUIDs until it is merged into a database.

					if(bIsMM && (eReturn == MSIDBERROR_BADIDENTIFIER || eReturn == MSIDBERROR_BADSHORTCUT))
					{
						UINT		iRet;
						CQuery		qFtrRef;
						PMSIHANDLE	hFtrRef;

						// Look up the table and column name in _FtrRef table.
						if((iRet = qFtrRef.FetchOnce(hDatabase, 0, &hFtrRef, sqlIce03FtrRef::szSQL, pszTableName, pszColumnName)) == ERROR_SUCCESS)
						{	
							// A potential replacement GUID in a column that
							// reference a feature in a merge module. If it's
							// a null GUID, don't display the error. As these
							// will be replace by feature names when merged
							// with a database.
							
							TCHAR*	pFeature = NULL;
							DWORD	dwFeature = iMaxBuf;
							DWORD	dwFeatureLen = 0;
							UINT	iFeature;
							LPCLSID pclsid = new CLSID;

							// What's the index of this column?

							CQuery	qIndex;
							MSIHANDLE	hColIndex;

							ReturnIfFailed(3, 9, qIndex.FetchOnce(hDatabase, 0, &hColIndex, sqlIce03ColIndex::szSQL, pszTableName, pszColumnName));
							iFeature = MsiRecordGetInteger(hColIndex, 1);

							ReturnIfFailed(3, 10, IceRecordGetString(hRecTable, iFeature, &pFeature, &dwFeature, &dwFeatureLen));

							if(_tcscmp(pFeature, TEXT("{00000000-0000-0000-0000-000000000000}")) == 0)
							{
								delete[] pFeature;
								continue;
							}
							delete[] pFeature;
						}
						else if(iRet != ERROR_NO_MORE_ITEMS)
						{
							APIErrorOut(hInstall, iRet, 3, __LINE__);
							return ERROR_SUCCESS;
						}
					}

					// decode error
					const ErrorInfo_t *ErrorInfo = Ice03MapErrorToICEError(eReturn, fMissing);
					
					// if MissingData && already printed first error, skip rest
					if (eReturn == MSIDBERROR_MISSINGDATA)
						continue;

					// determine number of primary keys
					ReturnIfFailed(3, 11, ::MsiDatabaseGetPrimaryKeys(hDatabase, pszTableName, &hRecKeys));

					unsigned int iNumFields = ::MsiRecordGetFieldCount(hRecKeys); // num fields = num primary keys

					// allocate record for error message (moniker + table + column + numPrimaryKeys)
					// message format: Invalid ~~ Table: [1] Col: [2] Moniker: [3] <tab> [table name = 4] <tab> [column name = 5] <tab> [key1 <tab>...
					PMSIHANDLE hRecError = ::MsiCreateRecord(5);
					if (0 == hRecError)
					{
						APIErrorOut(hInstall, 0, 3, 12);
						DELETE_IF_NOT_NULL(pszTableName);
						return ERROR_SUCCESS;
					}

					// fill in table, column, and primary keys
					::MsiRecordSetString(hRecError, 1, pszTableName);
					::MsiRecordSetString(hRecError, 2, pszColumnName);
					
					// start the moniker and template
					TCHAR szTemplate[iHugeBuf] = TEXT("[1]");
					DWORD cchTemplate = sizeof(szTemplate)/sizeof(TCHAR);
					TCHAR szMoniker[iHugeBuf] = TEXT("[1]");
					DWORD cchMoniker = sizeof(szMoniker)/sizeof(TCHAR);
					for (int i = 2; i <= iNumFields; i++) // cycle rest of primary keys
					{
						TCHAR szBuf[20] = TEXT("");

						// add key to moniker
						_stprintf(szBuf, TEXT(".[%d]"), i);
						_tcscat(szMoniker, szBuf);

						// add key to template
						_stprintf(szBuf, TEXT("\t[%d]"), i);
						_tcscat(szTemplate, szBuf);
					}

					// now format them into the moniker and template, and set into record
					// column 3 is the user-readable column id
					TCHAR *szTemp = NULL;
					DWORD cchTemp = 0;					
					::MsiRecordSetString(hRecTable, 0, szMoniker);
					::MsiFormatRecord(NULL, hRecTable, TEXT(""), &cchTemp);
					szTemp = new TCHAR[++cchTemp];
					::MsiFormatRecord(NULL, hRecTable, szTemp, &cchTemp);
					::MsiRecordSetString(hRecError, 3, szTemp);
					delete[] szTemp;

					// column 4 is not used anymore
					
					// column 5 is the machine-readable column id
					::MsiRecordSetString(hRecTable, 0, szTemplate);
					cchTemp = 0;
					::MsiFormatRecord(NULL, hRecTable, TEXT(""), &cchTemp);
					szTemp = new TCHAR[++cchTemp];
					::MsiFormatRecord(NULL, hRecTable, szTemp, &cchTemp);
					::MsiRecordSetString(hRecError, 5, szTemp);
					delete[] szTemp;

					// and display
					ICEErrorOut(hInstall, hRecError, *ErrorInfo);

					// reset
					cchBuf = cchColumnName;
				}
			}
		}
	}

	DELETE_IF_NOT_NULL(pszTableName);
	DELETE_IF_NOT_NULL(pszColumnName);

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////
// Ice03MapUINTToString -- maps the returned MSIDBERROR enum to the 
//   corresponding error string
//
const ErrorInfo_t* Ice03MapErrorToICEError(MSIDBERROR eRet, BOOL& fSkipRest)
{
	switch (eRet)
	{
	case MSIDBERROR_NOERROR:           return &Ice03NoError;
	case MSIDBERROR_DUPLICATEKEY:      return &Ice03DuplicateKey;
	case MSIDBERROR_REQUIRED:          return &Ice03Required;
	case MSIDBERROR_BADLINK:           return &Ice03BadLink;
	case MSIDBERROR_OVERFLOW:          return &Ice03Overflow;
	case MSIDBERROR_UNDERFLOW:         return &Ice03Underflow;
	case MSIDBERROR_NOTINSET:          return &Ice03NotInSet;
	case MSIDBERROR_BADVERSION:        return &Ice03BadVersion;
	case MSIDBERROR_BADCASE:           return &Ice03BadCase;
	case MSIDBERROR_BADGUID:           return &Ice03BadGuid;
	case MSIDBERROR_BADWILDCARD:       return &Ice03BadWildCard;
	case MSIDBERROR_BADIDENTIFIER:     return &Ice03BadIdentifier;
	case MSIDBERROR_BADLANGUAGE:       return &Ice03BadLanguage;
	case MSIDBERROR_BADFILENAME:       return &Ice03BadFilename;
	case MSIDBERROR_BADPATH:           return &Ice03BadPath;
	case MSIDBERROR_BADCONDITION:      return &Ice03BadCondition;
	case MSIDBERROR_BADFORMATTED:      return &Ice03BadFormatted;
	case MSIDBERROR_BADTEMPLATE:       return &Ice03BadTemplate;
	case MSIDBERROR_BADDEFAULTDIR:     return &Ice03BadDefaultDir;
	case MSIDBERROR_BADREGPATH:        return &Ice03BadRegPath;
	case MSIDBERROR_BADCUSTOMSOURCE:   return &Ice03BadCustomSource;
	case MSIDBERROR_BADPROPERTY:       return &Ice03BadProperty;
	case MSIDBERROR_MISSINGDATA:       fSkipRest = TRUE;
									   return &Ice03MissingData;      
	case MSIDBERROR_BADCATEGORY:       return &Ice03BadCategory;
	case MSIDBERROR_BADKEYTABLE:       return &Ice03BadKeyTable;
	case MSIDBERROR_BADMAXMINVALUES:   return &Ice03BadMaxMinValues;
	case MSIDBERROR_BADCABINET:        return &Ice03BadCabinet;
	case MSIDBERROR_BADSHORTCUT:       return &Ice03BadShortcut;
	case MSIDBERROR_STRINGOVERFLOW:    return &Ice03StringOverflow;
	case MSIDBERROR_BADLOCALIZEATTRIB: return &Ice03BadLocalizeAttrib;
	default:                           return &Ice03UndefinedError;
	}
}

////////////////////////////////////////////////////////////////////////
// ICE04 -- ICE to validate the sequences in the file table to ensure
//   they are not greater than what is permitted/authored in media
//   table
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR sqlIce04Media[] = TEXT("SELECT `LastSequence` FROM `Media` ORDER BY `LastSequence`");
const TCHAR sqlIce04File[]  = TEXT("SELECT `File`, `Sequence` FROM `File` WHERE `Sequence` > ?");
ICE_ERROR(Ice04Media, 4, ietInfo, "Max Sequence in Media Table is [1]", "");
ICE_ERROR(Ice04Error, 4, ietError, "File: [1], Sequence: [2] Greater Than Max Allowed by Media Table","File\tSequence\t[1]");

ICE_FUNCTION_DECLARATION(04)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// post information messages
	DisplayInfo(hInstall, 4);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// can we validate??
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 4, TEXT("Media")) ||
		!IsTablePersistent(FALSE, hInstall, hDatabase, 4, TEXT("File")))
		return ERROR_SUCCESS;

	// open view on Media table
	//!! Is ORDER BY worth performance hit??
	CQuery qMedia;
	ReturnIfFailed(04, 1, qMedia.OpenExecute(hDatabase, NULL, sqlIce04Media));

	// fetch until last one (ordered from low to high) to get highest sequence number allowed
	PMSIHANDLE hRecMedia = 0;
	int iLastSeq = 0;
	for (;;)
	{
		iStat = qMedia.Fetch(&hRecMedia);
		if (ERROR_SUCCESS != iStat && ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 4, 2);
			return ERROR_SUCCESS;
		}
		if (iStat != ERROR_SUCCESS)
			break; // done

		// get seq. number --> too bad have to do for every one
		iLastSeq = ::MsiRecordGetInteger(hRecMedia, 1);
	}

	// output highest seq number in Media table as info to user
	PMSIHANDLE hRecInfo = ::MsiCreateRecord(1);
	::MsiRecordSetInteger(hRecInfo, 1, iLastSeq); 
	ICEErrorOut(hInstall, hRecInfo, Ice04Media); 

	// open view on File table
	CQuery qFile;
	ReturnIfFailed(4, 3, qFile.OpenExecute(hDatabase, hRecInfo, sqlIce04File));

	// fetch all invalid (NULL set if none over LastSequence value)
	PMSIHANDLE hRecFile = 0;
	for (;;)
	{
		iStat = qFile.Fetch(&hRecFile);
		if (ERROR_NO_MORE_ITEMS != iStat && ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 4, 4);
			return ERROR_SUCCESS;
		}

		if (iStat != ERROR_SUCCESS)
			break; // done

		// output errors
		ICEErrorOut(hInstall, hRecFile, Ice04Error);
	}

	return ERROR_SUCCESS;
}
#endif

//////////////////////////////////////////////////////////////////////////
// ICE05 -- validates database tables contain certain *required* entries
//   as listed in the _Required table.
//   _Required table has the following columns and formats
//      Table -- primary key, name of table with a required entry
//      Value -- primary key, text (key1(;key2 etc)). Delimiter is ';'
//      KeyCount -- num primary keys, determines how parse value string
//      Description -- description of required entry
//   _Required table is inside of the darice.cub file for the basics.  If
//   your database requires other entries, they should also be listed in
//   your own personal copy of the _Required table.  These entries will
//   then be merged in and all should work.
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR sqlIce05Required[] = TEXT("SELECT `Table`, `Value`, `KeyCount` FROM `_Required` ORDER BY `Table`");
const int iColIce05Required_Table = 1;
const int iColIce05Required_Value = 2;

ICE_ERROR(Ice05MissingEntry, 5, ietError, "The entry: '[2]' is required in the '[1]' table.", "[1]");
ICE_ERROR(Ice05TableMissing, 5, ietError, "Table: '[1]' missing from database. All required entries are missing.","[1]");

ICE_FUNCTION_DECLARATION(05)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// post information messages
	DisplayInfo(hInstall, 5);
	
	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 5, 1);
		return ERROR_SUCCESS;
	}

	// declare handles
	CQuery qRequired;
	CQuery qTable;
	PMSIHANDLE hRecTableEx   = 0;
	PMSIHANDLE hRecRequired  = 0;
	PMSIHANDLE hRecTable     = 0;
	PMSIHANDLE hRecColInfo   = 0;

	// init status and run variables
	BOOL fTableExist = TRUE;

	// try to limit number times exec view on previous table
	TCHAR* pszPrevTable = NULL;
	TCHAR* pszTable = NULL;
	DWORD dwTable = iMaxBuf;
	TCHAR* pszValue = NULL;
	DWORD dwValue = iSuperBuf;
	
	if (!IsTablePersistent(false, hInstall, hDatabase, 5, TEXT("_Required")))
		return ERROR_SUCCESS;

	// begin processing _Required table
	ReturnIfFailed(5, 2, qRequired.OpenExecute(hDatabase, 0, sqlIce05Required));
	while (ERROR_NO_MORE_ITEMS != (iStat = qRequired.Fetch(&hRecRequired)))
	{
		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 5, 3);
			DELETE_IF_NOT_NULL(pszTable);
			DELETE_IF_NOT_NULL(pszValue);
			DELETE_IF_NOT_NULL(pszPrevTable);
			return ERROR_SUCCESS;
		}

		int cPrimaryKeys = ::MsiRecordGetInteger(hRecRequired, 3);
		
		// get name of table with required entries
		ReturnIfFailed(5, 4, IceRecordGetString(hRecRequired, iColIce05Required_Table, &pszTable, &dwTable, NULL));
		ReturnIfFailed(5, 5, IceRecordGetString(hRecRequired, iColIce05Required_Value, &pszValue, &dwValue, NULL));
		
		// set up execution record for table with required entries
		hRecTableEx = ::MsiCreateRecord(cPrimaryKeys);
		if (0 == hRecTableEx)
		{
			APIErrorOut(hInstall, iStat, 5, 6);
			DELETE_IF_NOT_NULL(pszTable);
			DELETE_IF_NOT_NULL(pszValue);
			DELETE_IF_NOT_NULL(pszPrevTable);
			return ERROR_SUCCESS;
		}

		// check if new table name with required entries (then we must change our query for new table)
		if (!pszPrevTable || _tcscmp(pszPrevTable, pszTable) != 0)
		{
			// init variables
			TCHAR sql[iSuperBuf]        = {0};                               // new SQL query to build
			PMSIHANDLE hRecPrimaryKeys  = 0;                                 // exec. record with primary keys
			TCHAR* pszKeyColName = NULL;                               // name of primary key column
			DWORD cchKeyColName = iMaxBuf;
			
			TCHAR szCol[iSuperBuf] = {0};                  // name of primary key columns, w/delimiter
			DWORD cchLen           = 0;

			// does this table exist?
			if (!IsTablePersistent(FALSE, hInstall, hDatabase, 5, pszTable))
			{
				fTableExist = FALSE;
				DELETE_IF_NOT_NULL(pszPrevTable);
				pszPrevTable = new TCHAR[_tcslen(pszTable) + 1];
				_tcscpy(pszPrevTable, pszTable);

				// error -- Since table is missing, all required entries will not be here
				ICEErrorOut(hInstall, hRecRequired, Ice05TableMissing);
				continue; // skip rest
			}

			// new table, need to open a new view.
			ReturnIfFailed(5, 7, ::MsiDatabaseGetPrimaryKeys(hDatabase, pszTable, &hRecPrimaryKeys));
			ReturnIfFailed(5, 8, IceRecordGetString(hRecPrimaryKeys, 1, &pszKeyColName, &cchKeyColName, NULL));

			if (::MsiRecordGetFieldCount(hRecPrimaryKeys) != cPrimaryKeys)
			{
				//!! ERROR - not match num primary keys; must be schema difference
				continue;
			}

			// build query of table to be checked
			int cchWritten, cchAddition;
			cchWritten = _stprintf(sql, TEXT("SELECT * FROM `%s` WHERE `%s`=?"), pszTable, pszKeyColName);
			cchAddition = cchWritten;
			_stprintf(szCol, TEXT("%s"), pszKeyColName);
			
			cchLen += cchWritten;
			for (int i = 2; i <= cPrimaryKeys; i++)
			{
				// add each primary key column to query
				ReturnIfFailed(5, 9, IceRecordGetString(hRecPrimaryKeys, i, &pszKeyColName, &cchKeyColName, NULL));

				cchWritten = _stprintf(sql + cchAddition, TEXT(" AND `%s`=?"), pszKeyColName);
				cchAddition = cchWritten;
				// add to szCol so can put in error record if error
				_stprintf(szCol + cchLen, TEXT(".%s"), pszKeyColName);

				cchLen += cchWritten;
			}
			DELETE_IF_NOT_NULL(pszKeyColName);

			// open view on table to validate
			ReturnIfFailed(5, 10, qTable.Open(hDatabase, sql));

			// get column info for that table so that can fill in execute record correctly
			ReturnIfFailed(5, 11, qTable.GetColumnInfo(MSICOLINFO_TYPES, &hRecColInfo));

			// copy table name into szPrevTable for future comparison
			DELETE_IF_NOT_NULL(pszPrevTable);
			pszPrevTable = new TCHAR[_tcslen(pszTable) + 1];
			_tcscpy(pszPrevTable, pszTable);
		}
		else if (!fTableExist)
			continue; // skip (already processed once that this table was missing)

		// variables
		TCHAR* pszKeyToken = NULL;
		TCHAR* pszTokenDelim = TEXT(";");
		TCHAR* pszType = NULL;
		DWORD cchType = iMaxBuf;
		int nDex = 0;
		for (int j = 1; j <= cPrimaryKeys; j++)
		{
			if (1 == j)
			{
				// establish token
				pszKeyToken = _tcstok(pszValue, pszTokenDelim);
			}
			else
				pszKeyToken = _tcstok(NULL, pszTokenDelim);

			// determine col type so know how to input into execution record
			ReturnIfFailed(5, 12, IceRecordGetString(hRecColInfo, j, &pszType, &cchType, NULL));

			if (pszType != 0 && (*pszType == TEXT('s') || *pszType == TEXT('S')))
				ReturnIfFailed(5, 13, ::MsiRecordSetString(hRecTableEx, j, pszKeyToken))
			else // integer primary key
				ReturnIfFailed(5, 14, ::MsiRecordSetInteger(hRecTableEx, j, _ttoi(pszKeyToken)));
			
			nDex = 0; // reset for next loop thru
		}
		DELETE_IF_NOT_NULL(pszType);

		// execute view and attempt to fetch required entry from table
		ReturnIfFailed(5, 15, qTable.Execute(hRecTableEx));

		iStat = qTable.Fetch(&hRecTable);
		if (iStat == ERROR_NO_MORE_ITEMS)
			// required value not in table
			ICEErrorOut(hInstall, hRecRequired, Ice05MissingEntry);
		else if (iStat != ERROR_SUCCESS)
		{
			APIErrorOut(hInstall, iStat, 5, 16);
			DELETE_IF_NOT_NULL(pszTable);
			DELETE_IF_NOT_NULL(pszValue);
			DELETE_IF_NOT_NULL(pszPrevTable);
			return ERROR_SUCCESS;
		}
	}

	DELETE_IF_NOT_NULL(pszTable);
	DELETE_IF_NOT_NULL(pszValue);
	DELETE_IF_NOT_NULL(pszPrevTable);
	
	return ERROR_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\msiice.dll\msiice3.cpp ===
/* msiice3.cpp - Darwin 1.1 ICE16-22 code  Copyright  1998-1999 Microsoft Corporation
____________________________________________________________________________*/

#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>  // included for both CPP and RC passes
#ifndef RC_INVOKED    // start of CPP source code
#include <stdio.h>    // printf/wprintf
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "msidefs.h"  // must be in this directory or on INCLUDE path
#include "..\..\common\msiice.h"
#include "..\..\common\query.h"

/////////////////////////////////////////////////////////////
// ICE16 -- ensures that the ProductName in the Property
//  table is less than 64 characters.  This also prevents
//  the following condition from occurring...
//  # When we set the registry key for DisplayName
//    in the Uninstall key for ARP, it will NOT show up
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR sqlIce16[] = TEXT("SELECT `Value` FROM `Property` WHERE `Property`='ProductName'");
ICE_ERROR(Ice16FoundError, 16, ietError, "ProductName property not found in Property table","Property");
ICE_ERROR(Ice16Error, 16, ietError, "ProductName: '[1]' is greater than %d characters in length. Current length: %d","Property\tValue\tProductName");
const int iMaxLenProductCode = 63;

ICE_FUNCTION_DECLARATION(16)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 16);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 16, 1);
		return ERROR_SUCCESS;
	}

	// do we have the property table?
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 16, TEXT("Property")))
		return ERROR_SUCCESS;

	// declare handles
	CQuery qProperty;
	PMSIHANDLE hRec = 0;
	
	// open view
	ReturnIfFailed(16, 2, qProperty.OpenExecute(hDatabase, 0, sqlIce16));

	// fetch the record
	iStat = qProperty.Fetch(&hRec);
	if (ERROR_NO_MORE_ITEMS == iStat)
	{
		// ProductName property not found
		PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecErr, Ice16FoundError);
		return ERROR_SUCCESS;
	}
	if (ERROR_SUCCESS != iStat)
	{
		APIErrorOut(hInstall, iStat, 16, 4);
		return ERROR_SUCCESS;
	}

	// get the string
	TCHAR szProduct[iMaxLenProductCode+1] = {0};
	DWORD cchProduct = sizeof(szProduct)/sizeof(TCHAR);
	if (ERROR_SUCCESS != (iStat = ::MsiRecordGetString(hRec, 1, szProduct, &cchProduct)) && iStat != ERROR_MORE_DATA)
	{
		APIErrorOut(hInstall, iStat, 16, 5);
		return ERROR_SUCCESS;
	}

	// ensure not > 63 char in length
	if (cchProduct > iMaxLenProductCode)
	{
		// error, > 63 char in length
		ICEErrorOut(hInstall, hRec, Ice16Error, iMaxLenProductCode, cchProduct);
		return ERROR_SUCCESS;
	}

	// return success
	return ERROR_SUCCESS;
}
#endif

/////////////////////////////////////////////////////////////////////////////////
// ICE17 -- validates foreign key dependencies based on certain control
//  types in the Control table
//
//   Bitmap --> must be found in Binary table (Control.Text) unless ImageHandle attribute is set
//   Icon   --> must be found in Binary table (Control.Text) unless ImageHandle attribute is set
//   PushButton --> must have an associated control event in ControlEvent table (Control.Dialog_, Control.Control)
//   RadioButtonGroup --> must be found in RadioButton table (Control.Property)
//   ComboBox --> must be found in ComboBox table (Control.Property)
//   ListBox --> must be found in ListBox table (Control.Property)
//   ListView --> must be found in ListView table (Control.Property)
//   CheckBox --> OPTIONAL, can be in CheckBox table (Control.Property)
//
//   +Pictures+
//   If Bitmap or Icon attribute is set (both can't be set at same time) AND ImageHandle attribute is not set,
//   then value in the TEXT column must be in the binary table
//

/* PushButton validation */
const TCHAR sqlIce17PushButton[] = TEXT("SELECT `Dialog_`, `Control`, `Attributes` FROM `Control` WHERE `Type`='PushButton'");
const TCHAR sqlIce17ControlEvent[] = TEXT("SELECT `Dialog_`, `Control_` FROM `ControlEvent` WHERE `Dialog_`=? AND `Control_`=?");
const TCHAR sqlIce17ControlCondEn[] = TEXT("SELECT `Dialog_`,`Control_` FROM `ControlCondition` WHERE `Dialog_`=? AND `Control_`=? AND `Action`= 'Enable'");
const TCHAR sqlIce17ControlCondShow[] = TEXT("SELECT `Dialog_`,`Control_` FROM `ControlCondition` WHERE `Dialog_`=? AND `Control_`=? AND `Action`= 'Show'");
ICE_ERROR(Ice17PBError, 17, ietError, "PushButton: '[2]' of Dialog: '[1]' does not have an event defined in the ControlEvent table. It is a 'Do Nothing' button.","Control\tControl\t[1]\t[2]");

/* Bitmap&Icon validation */
const TCHAR sqlIce17Bitmap[] = TEXT("SELECT `Text`, `Dialog_`, `Control`, `Attributes` FROM `Control` WHERE `Type`='Bitmap'");
const TCHAR sqlIce17Icon[] = TEXT("SELECT `Text`, `Dialog_`, `Control`, `Attributes` FROM `Control` WHERE `Type`='Icon'");
const TCHAR sqlIce17Binary[] = TEXT("SELECT `Name` FROM `Binary` WHERE `Name`=?");
const TCHAR sqlIce17Property[] = TEXT("SELECT `Value` FROM `Property` WHERE `Property`='%s'");
ICE_ERROR(Ice17BmpError, 17, ietError, "Bitmap: '[1]' for Control: '[3]' of Dialog: '[2]' not found in Binary table", "Control\tText\t[2]\t[3]");
ICE_ERROR(Ice17IconError, 17, ietError, "Icon: '[1]' for Control: '[3]' of Dialog: '[2]' not found in Binary table","Control\tText\t[2]\t[3]");
ICE_ERROR(Ice17NoDefault, 17, ietWarning, "Property %s in Text column for Control: '[3]' of Dialog: '[2]' not found in Property table, so no default value exists.","Control\tText\t[2]\t[3]");

/* RadioButtonGroup validation */
const TCHAR sqlIce17RBGroup[] = TEXT("SELECT `Property`, `Dialog_`, `Control`, `Attributes` FROM `Control` WHERE `Type`='RadioButtonGroup'");
const TCHAR sqlIce17RadioButton[] = TEXT("SELECT `Property` FROM `RadioButton` WHERE `Property`=?");
ICE_ERROR(Ice17RBGroupError, 17, ietWarning, "RadioButtonGroup: '[1]' for Control: '[3]' of Dialog: '[2]' not found in RadioButton table.","Control\tProperty\t[2]\t[3]");

/* ComboBox validation */
const TCHAR sqlIce17ComboBox[] = TEXT("SELECT `Property`, `Dialog_`, `Control`, `Attributes` FROM `Control` WHERE `Type`='ComboBox'");
const TCHAR sqlIce17ComboBoxTbl[] = TEXT("SELECT `Property` FROM `ComboBox` WHERE `Property`=?");
ICE_ERROR(Ice17CBError, 17, ietWarning, "ComboBox: '[1]' for Control: '[3]' of Dialog: '[2]' not found in ComboBox table.", "Control\tProperty\t[2]\t[3]");

/* ListBox validation */
const TCHAR sqlIce17ListBox[] = TEXT("SELECT `Property`, `Dialog_`, `Control`, `Attributes` FROM `Control` WHERE (`Type`='ListBox') AND (`Property` <> 'FileInUseProcess')");
const TCHAR sqlIce17ListBoxTbl[] = TEXT("SELECT `Property` FROM `ListBox` WHERE `Property`=?");
ICE_ERROR(Ice17LBError, 17, ietWarning, "ListBox: '[1]' for Control: '[3]' of Dialog: '[2]' not found in ListBox table.", "Control\tProperty\t[2]\t[3]");

/* ListView validation */
const TCHAR sqlIce17ListView[] = TEXT("SELECT `Property`, `Dialog_`, `Control`, `Attributes` FROM `Control` WHERE `Type`='ListView'");
const TCHAR sqlIce17ListViewTbl[] = TEXT("SELECT `Property` FROM `ListView` WHERE `Property`=?");
ICE_ERROR(Ice17LVError, 17, ietWarning, "ListView: '[1]' for Control: '[3]' of Dialog: '[2]' not found in ListView table.","Control\tProperty\t[2]\t[3]");

/* Specialized picture validations for RadioButtonGroup/RadioButtons, CheckBoxes, and PushButtons*/
const TCHAR sqlIce17Picture[] = TEXT("SELECT `Text`, `Dialog_`, `Control`, `Attributes` FROM `Control` WHERE `Type`='CheckBox' OR `Type`='PushButton'");
const TCHAR sqlIce17RBPicture[] = TEXT("SELECT `Text`, `Property`, `Order` FROM `RadioButton` WHERE `Property`=?");
ICE_ERROR(Ice17RBBmpPictError, 17, ietError, "Bitmap: '[1]' for RadioButton: '[2].[3]' not found in Binary table.", "RadioButton\tText\t[2]\t[3]");
ICE_ERROR(Ice17RBIconPictError, 17, ietError, "Icon: '[1]' for RadioButton: '[2].[3]' not found in Binary table.", "RadioButton\tText\t[2]\t[3]");
ICE_ERROR(Ice17BothPictAttribSet, 17, ietError, "Picture control: '[3]' of Dialog: '[2]' has both the Icon and Bitmap attributes set.", "Control\tAttributes\t[2]\t[3]");

/* Dependency validator function */
BOOL Ice17ValidateDependencies(MSIHANDLE hInstall, MSIHANDLE hDatabase, TCHAR* szDependent, const TCHAR* sqlOrigin, 
							   const TCHAR* sqlDependent, const ErrorInfo_t &Error, BOOL fPushButton,
							   BOOL fBinary);
BOOL Ice17ValidatePictures(MSIHANDLE hInstall, MSIHANDLE hDatabase);

ICE_FUNCTION_DECLARATION(17)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// Display info
	DisplayInfo(hInstall, 17);

	// Get database
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 17, 1);
		return ERROR_SUCCESS;
	}

	// is the control table here?, i.e. Db with UI??
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 17, TEXT("Control")))
		return ERROR_SUCCESS; // table not found

	// validate pushbuttons
	Ice17ValidateDependencies(hInstall, hDatabase, TEXT("ControlEvent"), sqlIce17PushButton, sqlIce17ControlEvent, Ice17PBError, TRUE, FALSE);
	// validate bitmaps
	Ice17ValidateDependencies(hInstall, hDatabase, TEXT("Binary"), sqlIce17Bitmap, sqlIce17Binary, Ice17BmpError, FALSE, TRUE);
	// validate icons
	Ice17ValidateDependencies(hInstall, hDatabase, TEXT("Binary"), sqlIce17Icon, sqlIce17Binary, Ice17IconError, FALSE, TRUE);
	// validate listboxes
	Ice17ValidateDependencies(hInstall, hDatabase, TEXT("ListBox"), sqlIce17ListBox, sqlIce17ListBoxTbl, Ice17LBError, FALSE, FALSE);
	// validate listviews
	Ice17ValidateDependencies(hInstall, hDatabase, TEXT("ListView"), sqlIce17ListView, sqlIce17ListViewTbl, Ice17LVError, FALSE, FALSE);
	// validate comboboxes
	Ice17ValidateDependencies(hInstall, hDatabase, TEXT("ComboBox"), sqlIce17ComboBox, sqlIce17ComboBoxTbl, Ice17CBError, FALSE, FALSE);
	// validate radiobuttongroups
	Ice17ValidateDependencies(hInstall, hDatabase, TEXT("RadioButton"), sqlIce17RBGroup, sqlIce17RadioButton, Ice17RBGroupError, FALSE, FALSE);

	// validate picture on pushbuttons, checkboxes, and radiobuttons
	Ice17ValidatePictures(hInstall, hDatabase);

	// return success
	return ERROR_SUCCESS;
}

BOOL Ice17CheckBinaryTable(MSIHANDLE hInstall, MSIHANDLE hDatabase, CQuery &qBinary, PMSIHANDLE hRecPict, PMSIHANDLE hRecSearch, const ErrorInfo_t &Error)
{
	ReturnIfFailed(17, 203, qBinary.Execute(hRecSearch));

	// attempt to fetch
	PMSIHANDLE hRecBinary;
	UINT iStat;
	if (ERROR_NO_MORE_ITEMS == (iStat = qBinary.Fetch(&hRecBinary)))
	{
		TCHAR *pchOpen = NULL;
		TCHAR *pchClose = NULL;
		TCHAR *pszProperty = NULL;
		DWORD dwProperty = 512;

		// check here for formatted text problems
		ReturnIfFailed(17, 204, IceRecordGetString(hRecPict, 1, &pszProperty, &dwProperty, NULL));

		if (NULL != (pchOpen = _tcschr(pszProperty, TEXT('['))) &&
			NULL != (pchClose = _tcschr(pchOpen+1, TEXT(']'))))
		{
			// if the property is not the entire value, we can't check.
			if ((pchOpen == pszProperty) && (*(pchClose+1) == TEXT('\0')))
			{
				*pchClose = TCHAR('\0');

				CQuery qProperty;
				// query property table for default value. If there is no default, don't check= 
				switch (iStat = qProperty.FetchOnce(hDatabase, 0, &hRecBinary, sqlIce17Property, pchOpen+1))
				{
				case ERROR_SUCCESS:
					break;
				case ERROR_NO_MORE_ITEMS:
					ICEErrorOut(hInstall, hRecPict, Ice17NoDefault, pchOpen+1);
					DELETE_IF_NOT_NULL(pszProperty);
					return TRUE;
				default:
					APIErrorOut(hInstall, iStat, 17, 204);
					DELETE_IF_NOT_NULL(pszProperty);
					return FALSE;
				}
				DELETE_IF_NOT_NULL(pszProperty);

				// if there is a default, check its value
				ReturnIfFailed(17, 204, qBinary.Execute(hRecBinary));
				if (ERROR_SUCCESS == qBinary.Fetch(&hRecBinary)) 
					return TRUE;
			}
			else
			{
				// property is not the entire value, don't check.
				DELETE_IF_NOT_NULL(pszProperty);
				return TRUE;
			}
		}
		DELETE_IF_NOT_NULL(pszProperty);

		// error, not found
		ICEErrorOut(hInstall, hRecPict, Error);
	}
	else if (ERROR_SUCCESS != iStat)
	{
		// api error
		APIErrorOut(hInstall, iStat, 17, 204);
		return FALSE;
	}
	return TRUE;
}

BOOL Ice17ValidateDependencies(MSIHANDLE hInstall, MSIHANDLE hDatabase, TCHAR* szDependent, const TCHAR* sqlOrigin, 
							   const TCHAR* sqlDependent, const ErrorInfo_t &Error, BOOL fPushButton,
							   BOOL fBinary)
{
	// variables
	UINT iStat = ERROR_SUCCESS;

	// declare handles
	CQuery qOrg;
	CQuery qDep;
	PMSIHANDLE hRecOrg  = 0;
	PMSIHANDLE hRecDep  = 0;

	// open view on Origin table
	ReturnIfFailed(17, 101, qOrg.OpenExecute(hDatabase, 0, sqlOrigin));

	// does the Dependent table exist (doesn't matter if we don't have any entries of this type)
	BOOL fTableExists = FALSE;
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 17, szDependent))
		fTableExists = TRUE;
	
	// open view on Dependent table
	if (fTableExists)
		ReturnIfFailed(17, 102, qDep.Open(hDatabase, sqlDependent));
	
	bool bControlCondition = IsTablePersistent(FALSE, hInstall, hDatabase, 17, TEXT("ControlCondition"));

	// fetch all from Origin
	for (;;)
	{
		iStat = qOrg.Fetch(&hRecOrg);
		if (ERROR_NO_MORE_ITEMS == iStat)
			break; // no more

		if (!fTableExists)
		{
			// check for existence of dependent table
			// by this time, we are supposed to have listings in this table
			if (!IsTablePersistent(TRUE, hInstall, hDatabase, 17, szDependent))
				return TRUE;
		}

		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 17, 103);
			return FALSE;
		}

		// if binary, ignore if imagehandle, otherwise check possibly formatte
		// if Bitmap or Icon do not set the ImageHandle attribute,
		// then picture is created at Run-time so it does not have to be in Binary table
		if (fBinary)
		{
			// get attributes from Control table
			int iAttrib = ::MsiRecordGetInteger(hRecOrg, 4);
			if (!(iAttrib & (int)(msidbControlAttributesImageHandle)))
				Ice17CheckBinaryTable(hInstall, hDatabase, qDep, hRecOrg, hRecOrg, Error);
			continue;
		}

		// execute Dependency table view with Origin table fetch
		ReturnIfFailed(17, 104, qDep.Execute(hRecOrg));

		// try to fetch
		iStat = qDep.Fetch(&hRecDep);
		if (ERROR_NO_MORE_ITEMS == iStat)
		{
			// could be an error...
			// NO error if ComboBox, ListBox, ListView, RadioButtonGroup have Indirect Attrib set
			// NO error if PushButton is disabled AND has no condition in ControlCondition table to set to Enable
			// NO error if PushButton is hidden AND has no condition in ControlCondition table to set to Show
			// NO error if Bitmap has ImageHandle attrib set
			// NO error if Icon has ImageHandle attrib set
			// NO error if object is dereferenced via formatted property value
			// WARNING if ComboBox, ListBox, ListView, RadioButtonGroup not listed in respective tables
			// Could be created dynamically

			BOOL fIgnore = FALSE; // whether to ignore error

			// if Indirect, then no error for ListBox, ListView, ComboBox, RadioButtonGroup
			if (!fPushButton)
			{
				// get attributes from Control table
				int iAttrib = ::MsiRecordGetInteger(hRecOrg, 4);
				if ((iAttrib & (int)(msidbControlAttributesIndirect)) == (int)(msidbControlAttributesIndirect))
					fIgnore = TRUE;
			}
			else // fPushButton
			{
				// see if disabled
				int iAttrib = ::MsiRecordGetInteger(hRecOrg, 3);
				if ((iAttrib & (int)(msidbControlAttributesEnabled)) == 0
					|| (iAttrib & (int)(msidbControlAttributesVisible)) == 0)
				{
					// control is disabled or hidden
					// Does not have to have an event PROVIDED not have a condition in ControlCondition table
					// which could set it to ENABLED or SHOW
					CQuery qCC;
					PMSIHANDLE hRecCC = 0;
					
					// Does ControlCondition table exist?
					if (bControlCondition)
						fIgnore = TRUE;
					else
					{
						// open view on ControlCondition table
						// see if there is an entry for this condition where Dialog_=Dialog_,Control_=Control_,Action=Enable
						ReturnIfFailed(17, 105, qCC.OpenExecute(hDatabase, hRecOrg, ((iAttrib & (int)(msidbControlAttributesEnabled)) == 0) ? sqlIce17ControlCondEn : sqlIce17ControlCondShow))
			
						// fetch...if NO_MORE, then we are okay to ignore
						iStat = qCC.Fetch(&hRecCC);
						if (ERROR_NO_MORE_ITEMS == iStat)
							fIgnore = TRUE;
						else if (ERROR_SUCCESS != iStat)
						{
							APIErrorOut(hInstall, iStat, 17, 106);
							return FALSE;
						}
					}
				}
			}
			// output error if really IS an ERROR
			if (!fIgnore)
				ICEErrorOut(hInstall, hRecOrg, Error);
		}
		if (ERROR_NO_MORE_ITEMS != iStat && ERROR_SUCCESS != iStat)
		{
			// API error
			APIErrorOut(hInstall, iStat, 17, 107);
			return FALSE;
		}
	}
	return TRUE;
}

BOOL Ice17ValidatePictures(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
	// status
	UINT iStat = ERROR_SUCCESS;

	// variables
	CQuery qPict;
	CQuery qBinary;
	CQuery qRB;
	PMSIHANDLE hRecPict = 0;
	PMSIHANDLE hRecBinary = 0;


	// open Binary view
	ReturnIfFailed(17, 202, qBinary.Open(hDatabase, sqlIce17Binary));

	for (int iTable = 0; iTable < 2; iTable++)
	{
		switch (iTable)
		{
		case 0:	
			ReturnIfFailed(17, 201, qPict.OpenExecute(hDatabase, 0, sqlIce17Picture));
			break;
		case 1:
			if (!IsTablePersistent(FALSE, hInstall, hDatabase, 17, TEXT("RadioButton")))
				continue;
			ReturnIfFailed(17, 206, qPict.OpenExecute(hDatabase, 0, sqlIce17RBGroup));
			ReturnIfFailed(17, 207, qRB.Open(hDatabase, sqlIce17RBPicture));
			break;
		default:
			APIErrorOut(hInstall, 9998, 17, 203);
			return FALSE;
		}

		while (ERROR_SUCCESS == (iStat = qPict.Fetch(&hRecPict)))
		{
			// check attributes.
			// can't have Bitmap and Icon attributes set at same time
			int iAttrib = ::MsiRecordGetInteger(hRecPict, 4);
			if ((iAttrib & (int)msidbControlAttributesBitmap) == (int)msidbControlAttributesBitmap 
				&& (iAttrib & (int)msidbControlAttributesIcon) == (int)msidbControlAttributesIcon)
			{
				// error, both attributes set
				ICEErrorOut(hInstall, hRecPict, Ice17BothPictAttribSet);
				continue;
			}

			// attempt to find in Binary table only if ImageHandle attribute is not set (which means dynamic at run-time)
			// and the Bitmap or Icon attributes are set
			if ((iAttrib & (int)msidbControlAttributesImageHandle) == 0
				&& ((iAttrib & (int)msidbControlAttributesBitmap) == (int)msidbControlAttributesBitmap
				|| (iAttrib & (int)msidbControlAttributesIcon) == (int)msidbControlAttributesIcon))
			{
				switch (iTable)
				{
				case 0:
					if (!Ice17CheckBinaryTable(hInstall, hDatabase, qBinary, hRecPict, hRecPict, 
						iAttrib & msidbControlAttributesBitmap ? Ice17BmpError : Ice17IconError))
						return ERROR_SUCCESS;
					break;
				case 1:
					{
					ReturnIfFailed(17, 208, qRB.Execute(hRecPict));
					PMSIHANDLE hRecRB;
					while (ERROR_SUCCESS == (iStat = qRB.Fetch(&hRecRB)))
						if (!Ice17CheckBinaryTable(hInstall, hDatabase, qBinary, hRecPict, hRecRB,
							iAttrib & msidbControlAttributesBitmap ? Ice17BmpError : Ice17IconError))
							return ERROR_SUCCESS;
					break;
					}
				default:
					APIErrorOut(hInstall, 9999, 17, 203);
					return FALSE;
				}
			}

		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 17, 205);
			return FALSE;
		}
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
// ICE18 -- validates that if your KeyPath column in the Component table is
//  NULL, then the Directory that would serve as its KeyPath is listed in
//  the CreateFolder table.  
//
//  NOTE:  You should never have a system directory in your CreateFolder table
//  NOTE:  You should never use a system directory as your KeyPath.  Instead,
//         use the Registry entry that would point to the system directory as the
//         KeyPath
//
const TCHAR sqlIce18File[] = TEXT("SELECT `File` FROM `File` WHERE `Component_`=?");
const TCHAR sqlIce18RemFile[] = TEXT("SELECT `FileKey` FROM `RemoveFile` WHERE `Component_`=? AND `DirProperty`=?");
const TCHAR sqlIce18DupFile[] = TEXT("SELECT `FileKey` FROM `DuplicateFile` WHERE `Component_`=? AND `DestFolder`=?");
const TCHAR sqlIce18MoveFile[] = TEXT("SELECT `FileKey` FROM `MoveFile` WHERE `Component_`=? AND `DestFolder`=?");
bool ComponentDirHasFileResources(MSIHANDLE hInstall, MSIHANDLE hDatabase, int iICE, MSIHANDLE hRecComp, 
								  CQuery &qFile, CQuery &qRemFile, CQuery &qDupFile, CQuery &qMoveFile)
{
	bool fFileTable = IsTablePersistent(TRUE, hInstall, hDatabase, iICE, TEXT("File"));
	bool fDupFileTable = IsTablePersistent(FALSE, hInstall, hDatabase, iICE, TEXT("DuplicateFile"));
	bool fRemFileTable = IsTablePersistent(FALSE, hInstall, hDatabase, iICE, TEXT("RemoveFile"));
	bool fMoveFileTable = IsTablePersistent(FALSE, hInstall, hDatabase, iICE, TEXT("MoveFile"));

	// open view on File table
	if (fFileTable && !qFile.IsOpen())
		ReturnIfFailed(iICE, 3, qFile.Open(hDatabase, sqlIce18File));
	// open view on DuplicateFile table (if possible)
	if (fDupFileTable && !qDupFile.IsOpen())
		ReturnIfFailed(iICE, 4, qDupFile.Open(hDatabase, sqlIce18DupFile));
	// open view on RemoveFile table (if possible)
	if (fRemFileTable && !qRemFile.IsOpen())
		ReturnIfFailed(iICE, 5, qRemFile.Open(hDatabase, sqlIce18RemFile));
	// open view on MoveFile table (if possible)
	if (fMoveFileTable && !qMoveFile.IsOpen())
		ReturnIfFailed(iICE, 6, qMoveFile.Open(hDatabase, sqlIce18MoveFile));

	PMSIHANDLE hRecFile;
	// see if there are files for this component in the File table
	if (fFileTable)
	{
		ReturnIfFailed(iICE, 9, qFile.Execute(hRecComp));
		if (ERROR_SUCCESS == qFile.Fetch(&hRecFile))
			return true;
	}
	// if necessary, try the RemoveFile table
	if (fRemFileTable)
	{
		ReturnIfFailed(iICE, 10, qRemFile.Execute(hRecComp));
		if (ERROR_SUCCESS == qRemFile.Fetch(&hRecFile))
			return true;
	}

	// try with DuplicateFile table (if exists)
	if (fDupFileTable)
	{
		ReturnIfFailed(iICE, 11, qDupFile.Execute(hRecComp));
		if (ERROR_SUCCESS == qDupFile.Fetch(&hRecFile))
			return true;
	}

	// try with DuplicateFile table (if exists)
	if (fMoveFileTable)
	{
		ReturnIfFailed(iICE, 12, qMoveFile.Execute(hRecComp));
		if (ERROR_SUCCESS == qMoveFile.Fetch(&hRecFile))
			return true;
	}
	return false;
}

const TCHAR sqlIce18Component[] = TEXT("SELECT `Component`, `Directory_` FROM `Component` WHERE `KeyPath` IS NULL");
const TCHAR sqlIce18ExemptRoot[] = TEXT("SELECT `Directory` FROM `Component`, `Directory` WHERE (`Component`.`Component`=?) AND (`Directory`.`Directory`=?) AND (`Component`.`Directory_`=`Directory`.`Directory`) AND ((`Directory`.`Directory_Parent` IS NULL) OR (`Directory_Parent`=`Directory`))");
const TCHAR sqlIce18CreateFolder[] = TEXT("SELECT `Directory_`,`Component_` FROM `CreateFolder` WHERE `Component_`=? AND `Directory_`=?");
ICE_ERROR(Ice18BadComponent, 18, ietError, "KeyPath for Component: '[1]' is Directory: '[2]'. The Directory/Component pair must be listed in the CreateFolders table.","Component\tDirectory_\t[1]");

ICE_FUNCTION_DECLARATION(18)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 18);

	// get database
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// do we have a component table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 18, TEXT("Component")))
		return ERROR_SUCCESS; // can't validate

	// declare handles
	CQuery qComp;
	CQuery qCreateFldr;
	PMSIHANDLE hRecComp = 0;
	PMSIHANDLE hRecCreateFldr = 0;

	// open view on component table
	ReturnIfFailed(18, 1, qComp.OpenExecute(hDatabase, 0, sqlIce18Component));

	// check for tables
	bool fTableExist = IsTablePersistent(FALSE, hInstall, hDatabase, 18, TEXT("CreateFolder"));
	bool fDirectoryTable = IsTablePersistent(FALSE, hInstall, hDatabase, 18, TEXT("Directory"));

	// open view on CreateFolder table
	if (fTableExist)
		ReturnIfFailed(18, 2, qCreateFldr.Open(hDatabase, sqlIce18CreateFolder));
	
	// other handles
	CQuery qFile;
	CQuery qDupFile;
	CQuery qRemFile;
	CQuery qMoveFile;
	CQuery qDir;
	PMSIHANDLE hRecFile = 0;

	// open view on Directory Table (if possible)
	if (fDirectoryTable)
		ReturnIfFailed(18, 7, qDir.Open(hDatabase, sqlIce18ExemptRoot));
	// fetch all
	while (ERROR_SUCCESS == (iStat = qComp.Fetch(&hRecComp)))
	{
		// exempt anything that is a root
		if (fDirectoryTable)
		{
			ReturnIfFailed(18, 8, qDir.Execute(hRecComp));
			if (ERROR_SUCCESS == qDir.Fetch(&hRecFile))
				continue;
		}

		// Need to only check for CreateFolder entry if no file resources are associated with
		// this directory
		if (!ComponentDirHasFileResources(hInstall, hDatabase, 18, hRecComp, qFile, qDupFile, qRemFile, qMoveFile))
		{
			// need to HAVE the CreateFolder table now
			if (!fTableExist)
			{
				ICEErrorOut(hInstall, hRecComp, Ice18BadComponent);
				continue;
			}

			// execute CreateFolder view
			ReturnIfFailed(18, 13, qCreateFldr.Execute(hRecComp));

			// attempt a fetch
			iStat = qCreateFldr.Fetch(&hRecCreateFldr);
			if (ERROR_NO_MORE_ITEMS == iStat)
			{
				ICEErrorOut(hInstall, hRecComp, Ice18BadComponent);
			}
			else if (ERROR_SUCCESS != iStat)
			{
				// API error
				APIErrorOut(hInstall, iStat, 18, 14);
				return ERROR_SUCCESS;
			}
		}
	}	
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 18, 15);
		return ERROR_SUCCESS;
	}

	// return success
	return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
// ICE19 -- validates ComponentId's and KeyPaths for Advertising.
//   Any advertised component must have a component Id
//   Any component for Class, Extension, and Typelib tables
//     must have a KeyPath that is a file
//   Any component for Shortcut table must have a KeyPath that is a file or
//     a directory
//	 PublishComponents can have no KeyPath, but its generally not a good 
//     idea.
//   KEYPATHS cannot be ODBCDataSources or Registry entries

// not shared with merge module subset
#ifndef MODSHAREDONLY
/* check for ComponentId */
const struct Ice19Info
{
	const TCHAR* szTable;
	const TCHAR* szSupportTable;
	const TCHAR* sqlExempt;		// run before anything else to select records to check. Select by setting temp column to 0 or 1.
	const TCHAR* sqlExempt2;	// run before anything else to select records to check. Select by setting temp column to 0 or 1.
	const TCHAR* sqlQueryBase;  // chunk of query before the WHERE
	struct ErrorInfo_t IDError;
	struct ErrorInfo_t KeyError;
} pAdvtTables[] =
{
	{
		TEXT("Class"),
		NULL,
		TEXT("UPDATE `Class` SET `_Ice19Exempt`=0"),
		NULL,
		TEXT("SELECT `Component`.`Attributes`, `Component`.`KeyPath`, `Component`.`Component`, `Class`.`CLSID`, `Class`.`Context` FROM `Class`,`Component` WHERE %s"),
		{ 19, ietError, TEXT("CLSID: '[4] with Context: '[5]' advertises component: '[3]'. This component cannot be advertised because it has no ComponentID."), TEXT("Class\tComponent_\t[4]\t[5]\t[3]") },
		{ 19, ietError, TEXT("CLSID: '[4] with Context: '[5]' advertises component: '[3]'. This component cannot be advertised because the KeyPath type disallows it."), TEXT("Class\tComponent_\t[4]\t[5]\t[3]") }
	},
	{
		TEXT("Extension"),
		NULL,
		TEXT("UPDATE `Extension` SET `_Ice19Exempt`=0"),
		NULL,
		TEXT("SELECT `Component`.`Attributes`, `Component`.`KeyPath`, `Component`.`Component`, `Extension`.`Extension` FROM `Extension`,`Component` WHERE %s"),
		{ 19, ietError, TEXT("Extension: '[4]' advertises component: '[3]'. This component cannot be advertised because it has no ComponentID."), TEXT("Extension\tComponent_\t[4]\t[3]") },
		{ 19, ietError, TEXT("Extension: '[4]' advertises component: '[3]'. This component cannot be advertised because the KeyPath type disallows it."), TEXT("Extension\tComponent_\t[4]\t[3]") }
	},
	{
		TEXT("PublishComponent"),
		NULL,
		TEXT("UPDATE `PublishComponent`, `Component` SET `PublishComponent`.`_Ice19Exempt`=1 WHERE (`Component`.`KeyPath` IS NOT NULL)"),
		NULL,
		TEXT("SELECT `Component`.`Attributes`, `Component`.`KeyPath`, `Component`.`Component`, `PublishComponent`.`ComponentId`, `PublishComponent`.`Qualifier` FROM `PublishComponent`,`Component` WHERE %s"),
		{19, ietError, TEXT("ComponentId: '[4]' with Qualifier: '[5]' publishes component: '[3]'. This component cannot be published because it has no ComponentID."), TEXT("PublishComponent\tComponent_\t[4]\t[5]") },
		{19, ietWarning, TEXT("ComponentId: '[4]' with Qualifier: '[5]' publishes component: '[3]'. It does not have a KeyPath. Using a directory keypath with qualified components could cause detection and repair problems."), TEXT("PublishComponent\tComponent_\t[4]\t[5]") }
	},
	{
		TEXT("Shortcut"),
		TEXT("Feature"),
		TEXT("UPDATE `Shortcut`, `Feature` SET `Shortcut`.`_Ice19Exempt`=0 WHERE `Shortcut`.`Target`=`Feature`.`Feature`"),
		TEXT("UPDATE `Shortcut`, `Component` SET `Shortcut`.`_Ice19Exempt`=1 WHERE (`Component`.`Component`=`Shortcut`.`Component_`) AND (`Component`.`KeyPath` IS NULL) AND (`_Ice19Exempt`=0)"),
		TEXT("SELECT `Component`.`Attributes`, `Component`.`KeyPath`, `Component`.`Component`, `Shortcut`.`Shortcut` FROM `Shortcut`,`Component` WHERE %s"),
		{19, ietError, TEXT("Shortcut: '[4]' advertises component: '[3]'. This component cannot be advertised because it has no ComponentID."), TEXT("Shortcut\tComponent_\t[4]") },
		{19, ietError, TEXT("Shortcut: '[4]' advertises component: '[3]'. This component cannot be advertised because the KeyPath type disallows it."), TEXT("Shortcut\tComponent_\t[4]") }
	}
};

// three possible check levels:
// 0: full check
// 1: componentID only
// 2: no check
const TCHAR sqlIce19CreateColumn[] = TEXT("ALTER TABLE `%s` ADD `_Ice19Exempt` SHORT TEMPORARY");
const TCHAR sqlIce19InitColumn[] = TEXT("UPDATE `%s` SET _Ice19Exempt=2");
const TCHAR sqlIce19BadKeyPath[] = TEXT("SELECT `Shortcut`,`Component_`,`Component`.`Attributes` FROM `Shortcut`,`Component` WHERE `Component_`=`Component` AND `KeyPath` IS NOT NULL");
const TCHAR sqlIce19Append1[] = TEXT("(`Component_`=`Component`.`Component`) AND (`Component`.`ComponentId` IS NULL) AND (`_Ice19Exempt`<>2)");
const TCHAR sqlIce19Append2[] = TEXT("(`Component_`=`Component`.`Component`) AND (`_Ice19Exempt`= 0)");

const int cAdvtTables = sizeof(pAdvtTables)/(sizeof(Ice19Info));
const int iIce19KeyPathInvalidMask = msidbComponentAttributesRegistryKeyPath | msidbComponentAttributesODBCDataSource;

ICE_FUNCTION_DECLARATION(19)
{
	// return status
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 19);

	// get database
	PMSIHANDLE  hDatabase = ::MsiGetActiveDatabase(hInstall);

	// Check for table existence
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 19, TEXT("Component")))
		return ERROR_SUCCESS;

	// loop thru all tables
	for (int i = 0; i < cAdvtTables; i++)
	{
		// handles
		CQuery qView;
		PMSIHANDLE hRec = 0;

		// Check for table existence
		if (!IsTablePersistent(FALSE, hInstall, hDatabase, 19, const_cast <TCHAR*>(pAdvtTables[i].szTable)))
			continue;

		// Check for support table existence
		if (pAdvtTables[i].szSupportTable &&
			!IsTablePersistent(FALSE, hInstall, hDatabase, 19, const_cast <TCHAR*>(pAdvtTables[i].szSupportTable)))
			continue;


		// create the marker column
		CQuery qCreate;
		ReturnIfFailed(19, 1, qCreate.OpenExecute(hDatabase, 0, sqlIce19CreateColumn, pAdvtTables[i].szTable));

		// init the marker column to 2.
		CQuery qInit;
		ReturnIfFailed(19, 2, qInit.OpenExecute(hDatabase, 0, sqlIce19InitColumn, pAdvtTables[i].szTable));

		// if there is an exemption query run that
		if (pAdvtTables[i].sqlExempt)
		{
			CQuery qExempt;
			ReturnIfFailed(19, 3, qExempt.OpenExecute(hDatabase, 0, pAdvtTables[i].sqlExempt));
		}
		if (pAdvtTables[i].sqlExempt2)
		{
			CQuery qExempt;
			ReturnIfFailed(19, 3, qExempt.OpenExecute(hDatabase, 0, pAdvtTables[i].sqlExempt2));
		}

		// now run the bad component query. Column 1 is dummy, other columns are table defined.
		// Looks for NULL ComponentId's Exempts anything marked 2.
		CQuery qBadComponent;
		ReturnIfFailed(19, 4, qBadComponent.OpenExecute(hDatabase, 0, pAdvtTables[i].sqlQueryBase, sqlIce19Append1));
		for (;;)
		{
			iStat = qBadComponent.Fetch(&hRec);
			if (ERROR_NO_MORE_ITEMS == iStat)
				break; // no more
			if (ERROR_SUCCESS != iStat)
			{
				APIErrorOut(hInstall, iStat, 19, 5);
				return ERROR_SUCCESS;
			}

			// ERROR -- bad component
			ICEErrorOut(hInstall, hRec, pAdvtTables[i].IDError);
		}

		// now run the attributes query. Return the attributes in column 1, keypath in 2, other columns are table 
		// defined exempt anything marked with a non-0 in the exempt column
		ReturnIfFailed(19, 6, qView.OpenExecute(hDatabase, 0, pAdvtTables[i].sqlQueryBase, sqlIce19Append2));

		// fetch all invalid
		for (;;)
		{
			iStat = qView.Fetch(&hRec);
			if (ERROR_NO_MORE_ITEMS == iStat)
				break; // no more
			if (ERROR_SUCCESS != iStat)
			{
				APIErrorOut(hInstall, iStat, 19, 6);
				return ERROR_SUCCESS;
			}

			// check for null keypath
			if (::MsiRecordIsNull(hRec, 2))
			{
				// error, null keypath
				ICEErrorOut(hInstall, hRec, pAdvtTables[i].KeyError);
				continue;
			}

			// We now have all non-null KeyPaths
			// MUST ensure they point to files
			if (::MsiRecordGetInteger(hRec, 1) & iIce19KeyPathInvalidMask)
			{
				// ERROR -- point to Registry or ODBCDataSource
				ICEErrorOut(hInstall, hRec, pAdvtTables[i].KeyError);
			}
		}
	}

	// return success
	return ERROR_SUCCESS;
}
#endif

/////////////////////////////////////////////////////////////////////////////////////
// ICE20 -- validates Standard Dialogs for specified requirements.  Only validates
//   if you have a Dialog table which means you have authored UI for your 
//   database package
//
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
//!! could possibly be changed to use IPROPNAME_LIMITUI
const TCHAR sqlIce20LimitUI[] = TEXT("SELECT `Property` FROM `Property` WHERE `Property`='LIMITUI'");
bool Ice20FindStandardDialogs(MSIHANDLE hInstall, MSIHANDLE hDatabase);

ICE_FUNCTION_DECLARATION(20)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 20);

	// get active database
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// do we have Property table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 20, TEXT("Property")))
		return ERROR_SUCCESS; // no Property table

	// handles
	CQuery qProperty;
	PMSIHANDLE hRecProperty = 0;
	BOOL fLimitUI = FALSE;

	// see if LIMITUI authored which means use only BASIC UI from INSTALLER
	ReturnIfFailed(20, 1, qProperty.OpenExecute(hDatabase, 0, sqlIce20LimitUI));
	if (ERROR_SUCCESS == qProperty.Fetch(&hRecProperty))
	{
		// LIMITUI property found
		fLimitUI = TRUE;
	}

	// check for UI authored by looking for Dialog table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 20, TEXT("Dialog")) || fLimitUI)
		return ERROR_SUCCESS; // no UI

	// UI authored, check for Dialogs listed in Dialog table
	Ice20FindStandardDialogs(hInstall, hDatabase);
	
	// return success
	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////////////////
// Ice20FindStandardDialogs -- looks for standard dialog and then calls corresponding
//   individual dialog validator
const TCHAR sqlIce20Dialog[] = TEXT("SELECT `Dialog` FROM `Dialog` WHERE `Dialog`=?");

ICE_ERROR(Ice20FindDlgErr, 20, ietError, "Standard Dialog: '[1]' not found in Dialog table","Dialog");
ICE_ERROR(Ice20ExitDlgsError, 20, ietError, "%s dialog/action not found in '%s' Sequence Table.","%s");

static enum isnExitDialogs
{
	isnPrevEnum   = -4,
	isnFatalError = -3, // required sequence number for FatalError dialog
	isnUserExit   = -2, // required sequence number for UserExit dialog
	isnExit       = -1, // required sequence number for Exit dialog
	isnNextEnum   =  0,
};	

struct ExitDialog
{
	TCHAR*         szDialog;
	isnExitDialogs isn;
};

const int iNumExitDialogs = isnNextEnum - (isnPrevEnum + 1);
static ExitDialog s_rgExitDialogs[] =  {
											TEXT("FatalError"), isnFatalError,
											TEXT("UserExit"),   isnUserExit,
											TEXT("Exit"),       isnExit
										};
const TCHAR sqlIce20AdminExitDlgs[] = TEXT("SELECT `Action` FROM AdminUISequence WHERE `Sequence`=?");
const TCHAR sqlIce20InstallExitDlgs[] = TEXT("SELECT `Action` FROM InstallUISequence WHERE `Sequence`=?");

// function pointer validators for individual dialogs
typedef bool (*FDialogValidate)(MSIHANDLE hInstall, MSIHANDLE hDatabase);
bool Ice20ValidateFilesInUse(MSIHANDLE hInstall, MSIHANDLE hDatabase);
bool Ice20ValidateError(MSIHANDLE hInstall, MSIHANDLE hDatabase);
bool Ice20ValidateCancel(MSIHANDLE hInstall, MSIHANDLE hDatabase);
//bool Ice20ValidateDiskCost(MSIHANDLE hInstall, MSIHANDLE hDatabase);

struct StandardDialog
{
	TCHAR* szDialog;          // name of dialog
	FDialogValidate FParam;   // validator function
};

static StandardDialog s_pDialogs[] =    { 
										TEXT("FilesInUse"), Ice20ValidateFilesInUse,
//										TEXT("Cancel"),     Ice20ValidateCancel,
//										TEXT("DiskCost"),   Ice20ValidateDiskCost,
										};

const int cDialogs = sizeof(s_pDialogs)/sizeof(StandardDialog);

bool Ice20FindStandardDialogs(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
	// status return 
	UINT iStat = ERROR_SUCCESS;

	// handles
	CQuery qDlg;
	PMSIHANDLE hRecDlg  = 0;
	PMSIHANDLE hRec = ::MsiCreateRecord(1); // for execution record

	ReturnIfFailed(20, 2, qDlg.Open(hDatabase, sqlIce20Dialog));

	for (int c = 0; c < cDialogs; c++)
	{
		::MsiRecordSetString(hRec, 1, s_pDialogs[c].szDialog);
		ReturnIfFailed(20, 3, qDlg.Execute(hRec));

		if (ERROR_SUCCESS == (iStat = qDlg.Fetch(&hRecDlg)))
			(*s_pDialogs[c].FParam)(hInstall, hDatabase); // validate dialog
		else
		{
			ICEErrorOut(hInstall, hRec, Ice20FindDlgErr);
		}
		
		qDlg.Close(); // so can re-execute
	}

	// ErrorDialog specified by property in Property table so must "hand-validate" it
	Ice20ValidateError(hInstall, hDatabase);

	//!! Exit, FatalError, UserExit Dialogs
	// Don't have to be dialogs.  Only have to have something in UISequence table with that action #
	// A different validator will make sure that it is listed in the Dialog table or is a CA.

	CQuery qAdminSeq;
	PMSIHANDLE hRecAdminSeq    = 0;
	CQuery qInstallSeq;
	PMSIHANDLE hRecInstallSeq  = 0;
	PMSIHANDLE hRecExec = ::MsiCreateRecord(1);

	bool bAdminTable = IsTablePersistent(false, hInstall, hDatabase, 20, TEXT("AdminUISequence"));
	bool bInstallTable = IsTablePersistent(false, hInstall, hDatabase, 20, TEXT("InstallUISequence"));

	if (!bInstallTable && !bAdminTable) 
		return true;

	// open view on InstallUISequence table
	if (bInstallTable)
		ReturnIfFailed(20, 4, qInstallSeq.Open(hDatabase, sqlIce20InstallExitDlgs));

	if (bAdminTable)
		ReturnIfFailed(20, 5, qAdminSeq.Open(hDatabase, sqlIce20AdminExitDlgs));
		

	for (int i = 0; i < iNumExitDialogs; i++)
	{
		if (bInstallTable)
		{
			// prepare for execution
			::MsiRecordSetInteger(hRecExec, 1, s_rgExitDialogs[i].isn);

			// validate InstallUISequence table
			ReturnIfFailed(20, 6, qInstallSeq.Execute(hRecExec));
			iStat = qInstallSeq.Fetch(&hRecInstallSeq);
			if (iStat != ERROR_SUCCESS)
			{
				if (ERROR_NO_MORE_ITEMS == iStat)
				{
					PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
					ICEErrorOut(hInstall, hRecErr, Ice20ExitDlgsError, s_rgExitDialogs[i].szDialog, TEXT("InstallUISequence"), TEXT("InstallUISequence"));
				}
				else
				{
					// api error
					APIErrorOut(hInstall, iStat, 20, 7);
					return false;
				}
			}
		}

		// validate AdminUISequence table
		if (bAdminTable)
		{
			ReturnIfFailed(20, 8, qAdminSeq.Execute(hRecExec));
			iStat = qAdminSeq.Fetch(&hRecAdminSeq);
			if (iStat != ERROR_SUCCESS)
			{
				if (ERROR_NO_MORE_ITEMS == iStat)
				{
					PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
					ICEErrorOut(hInstall, hRecErr, Ice20ExitDlgsError, s_rgExitDialogs[i].szDialog, TEXT("AdminUISequence"), TEXT("AdminUISequence"));
				}
				else
				{
					// api error
					APIErrorOut(hInstall, iStat, 20, 9);
					return false;
				}
			}
		}

		// close views for re-execute
		qInstallSeq.Close();
		qAdminSeq.Close();
	}
	return true;
}

//////////////////////////////////////////////////////////////////////
// FilesInUse Dialog -- must satisfy the following:
//  ++ Have a ListBox table
//  ++ Have a ListBox control with Property=FileInUseProcess
//  ++ Three pushbuttons
//  ++ One pushbutton with EndDialog event w/ Arg = Ignore
//  ++ One pushbutton with EndDialog event w/ Arg = Exit
//  ++ One pushbutton with EndDialog event w/ Arg = Retry
ICE_ERROR(Ice20VFIUDlgError1, 20, ietError, "ListBox table is required for the FilesInUse Dialog.","Dialog\tDialog\tFilesInUse");
ICE_ERROR(Ice20VFIUDlgError2, 20, ietError, "ListBox control with Property='FileInUseProcess' required for the FilesInUse Dialog.","Dialog\tDialog\tFilesInUse");
ICE_ERROR(Ice20VFIUDlgError3, 20, ietError, "Required PushButtons not found for the FilesInUseDialog.","Dialog\tDialog\tFilesInUse");
const TCHAR sqlIce20FIUListBox[]   = TEXT("SELECT `Control` FROM `Control` WHERE `Dialog_`='FilesInUse' AND `Type`='ListBox' AND `Property`='FileInUseProcess'");
const TCHAR sqlIce20FIUPushButton[] = TEXT("SELECT `ControlEvent`.`Argument` FROM `ControlEvent`, `Control` WHERE `Control`.`Dialog_`='FilesInUse' AND `ControlEvent`.`Dialog_`='FilesInUse' AND `Type`='PushButton' AND `Control_`=`Control` AND `ControlEvent`.`Event`='EndDialog'");

bool Ice20ValidateFilesInUse(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// check for ListBox table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 20, TEXT("ListBox")))
	{
		PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecErr, Ice20VFIUDlgError1);
	}

	// look for ListBox control
	CQuery qCtrl;
	PMSIHANDLE hRecCtrl = 0;
	ReturnIfFailed(20, 101, qCtrl.OpenExecute(hDatabase, 0, sqlIce20FIUListBox));
	if (ERROR_SUCCESS != (iStat = qCtrl.Fetch(&hRecCtrl)))
	{
		// ListBox control with Property='FileInUse' not found
		PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecErr, Ice20VFIUDlgError2);
	}
	qCtrl.Close();

	// look for PushButtons (3)
	BOOL fExit = FALSE;
	BOOL fRetry = FALSE;
	BOOL fIgnore = FALSE;
	CQuery qCtrlEvent;
	PMSIHANDLE hRecCtrlEvent = 0;

	// open view on ControlEvent table
	ReturnIfFailed(20, 102, qCtrlEvent.OpenExecute(hDatabase, 0, sqlIce20FIUPushButton));

	TCHAR* pszArgument = NULL;
	DWORD dwArgument = 512;
	for (;;)
	{
		// fetch all pushbuttons for the FilesInUse Dialog
		iStat = qCtrlEvent.Fetch(&hRecCtrlEvent);
		if (ERROR_NO_MORE_ITEMS == iStat)
			break; // no more

		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 20, 103);
			DELETE_IF_NOT_NULL(pszArgument);
			return false;
		}

		// found one, so check Argument
		ReturnIfFailed(20, 104, IceRecordGetString(hRecCtrlEvent, 1, &pszArgument, &dwArgument, NULL));

		// compare
		if (0 == _tcscmp(pszArgument, TEXT("Exit")))
			fExit = TRUE;
		else if (0 == _tcscmp(pszArgument, TEXT("Retry")))
			fRetry = TRUE;
		else if (0 == _tcscmp(pszArgument, TEXT("Ignore")))
			fIgnore = TRUE;
	}

	DELETE_IF_NOT_NULL(pszArgument);

	// check that all buttons covered
	if (!fExit || !fRetry || !fIgnore)
	{
		PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecErr, Ice20VFIUDlgError3);
	}
	return true;
}


//////////////////////////////////////////////////////////////////////
// Error Dialog -- must satisfy the following 
// ** Uses Dialog specified by ErrorDialog Property in Property table
// ++ Said specified Dialog must exist in Dialog table
// ++ Dialog must have ErrorDialog attribute
// ++ Must have static TEXT control named "ErrorText"
// ++ Above control must be referenced in Control_First column
// ++ If the ErrorIcon ctrl exists, it must be of Type Icon
// ++ Must have 7 pushbuttons
// ++ 7 pushbuttons must have EndDialog ControlEvents
// ++ 7 pushbuttons must satisfy one of the following arguments in
//    ControlEvent table --> ErrorAbort (w/ Name = "A"),
//                           ErrorCancel (w/ Name = "C"),
//                           ErrorIgnore (w/ Name = "I"),
//                           ErrorNo     (w/ Name = "N"),
//                           ErrorOk     (w/ Name = "O"),
//                           ErrorRetry  (w/ Name = "R"),
//                           ErrorYes    (w/ Name = "Y")
//
ICE_ERROR(Ice20ErrDlgError1, 20, ietError, "ErrorDialog Property not specified in Property table. Required property for determining the name of your ErrorDialog","Property");
ICE_ERROR(Ice20ErrDlgError2, 20, ietError, "Specified ErrorDialog: '[1]' not found in Dialog table (or its Control_First control is not 'ErrorText').","Property\tValue\tErrorDialog");
ICE_ERROR(Ice20ErrDlgError3, 20, ietError, "Specified ErrorDialog: '[1]' does not have ErrorDialog attribute set. Current attributes: %d.","Dialog\tDialog\t[1]");
ICE_ERROR(Ice20ErrDlgError4, 20, ietError, "PushButton for Error Argument '%s' not found for ErrorDialog: '[1]'","Dialog\tDialog\t[1]");
ICE_ERROR(Ice20ErrDlgError5, 20, ietError, "PushButton w/ Error Argument '%s' is not named correctly in ErrorDialog: '[1]'","Dialog\tDialog\t[1]");
ICE_ERROR(Ice20ErrDlgError6, 20, ietError, "The ErrorIcon control is specified, but it is not of type Icon; instead: '[1]'","Control\tType\t[2]\tErrorIcon");

struct ErrDlgArgs
{
	TCHAR* szArg;
	TCHAR* szName;
	BOOL   fFound;
	BOOL   fCorrectName;
};

static ErrDlgArgs s_pIce20ErrDlgArgs[] = {
									TEXT("ErrorAbort"), TEXT("A"), FALSE, TRUE,
									TEXT("ErrorCancel"),TEXT("C"), FALSE, TRUE,
									TEXT("ErrorIgnore"),TEXT("I"), FALSE, TRUE,
									TEXT("ErrorNo"),    TEXT("N"), FALSE, TRUE,
									TEXT("ErrorOk"),    TEXT("O"), FALSE, TRUE,
									TEXT("ErrorRetry"), TEXT("R"), FALSE, TRUE,
									TEXT("ErrorYes"),   TEXT("Y"), FALSE, TRUE
									};
const int cIce20ErrDlgArgs = sizeof(s_pIce20ErrDlgArgs)/sizeof(ErrDlgArgs);
const TCHAR sqlIce20ErrDlgProp[] = TEXT("SELECT `Value`,`Value` FROM `Property` WHERE `Property`='ErrorDialog'"); 
const TCHAR sqlIce20ErrDlg[] = TEXT("SELECT `Attributes` FROM `Dialog` WHERE `Dialog`=? AND `Control_First`='ErrorText'");
const TCHAR sqlIce20ErrorText[] = TEXT("SELECT `Control` FROM `Control` WHERE `Dialog_`=? AND `Control`='ErrorText' AND `Type`='Text'");
const TCHAR sqlIce20ErrDlgPushButton[] = TEXT("SELECT `ControlEvent`.`Argument`, `Control`.`Control` FROM `ControlEvent`, `Control` WHERE `Control`.`Dialog_`=? AND `ControlEvent`.`Dialog_`=? AND `Type`='PushButton' AND `Control_`=`Control` AND `ControlEvent`.`Event`='EndDialog'");
const TCHAR sqlIce20ErrDlgErrIcon[] = TEXT("SELECT `Type`, `Dialog_` FROM `Control` WHERE `Dialog_`=? AND `Control`='ErrorIcon'");

bool Ice20ValidateError(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// Now validate ErrorDialog which is based off of a property
	// do we have Property table??
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 20, TEXT("Property")))
	{
		PMSIHANDLE hRecord = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecord, Ice20ErrDlgError1);
		return true;
	}

	// get name of ErrorDialog from Property table
	CQuery qProperty;
	PMSIHANDLE hRecErrorDlgProp = 0;
	ReturnIfFailed(20, 201, qProperty.OpenExecute(hDatabase, 0, sqlIce20ErrDlgProp));

	// fetch name of ErrorDialog
	iStat = qProperty.Fetch(&hRecErrorDlgProp);
	if (ERROR_SUCCESS != iStat)
	{
		if (ERROR_NO_MORE_ITEMS == iStat)
		{
			// not found
			PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
			ICEErrorOut(hInstall, hRecErr, Ice20ErrDlgError1);
			return true;
		}
		else
		{
			APIErrorOut(hInstall, iStat, 20, 202);
			return false;
		}
	}

	// open view on Dialog Table for the ErrorDialog
	CQuery qDlg;
	PMSIHANDLE hRecErrDlg = 0;
	ReturnIfFailed(20, 203, qDlg.OpenExecute(hDatabase, hRecErrorDlgProp, sqlIce20ErrDlg));

	// attempt to fetch it
	iStat = qDlg.Fetch(&hRecErrDlg);
	if (ERROR_SUCCESS != iStat)
	{
		if (ERROR_NO_MORE_ITEMS == iStat)
		{
			ICEErrorOut(hInstall, hRecErrorDlgProp, Ice20ErrDlgError2);
			return true;
		}
		else
		{
			// api error
			APIErrorOut(hInstall, iStat, 20, 204);
			return false;
		}
	}
	// check for ErrorDialog attribute
	int iDlgAttributes = ::MsiRecordGetInteger(hRecErrDlg, 1);
	if ((iDlgAttributes & msidbDialogAttributesError) != msidbDialogAttributesError)
	{
		ICEErrorOut(hInstall, hRecErrorDlgProp, Ice20ErrDlgError3, iDlgAttributes);
	}
	
	// look for ErrorText control in control table
	CQuery qCtrl;
	PMSIHANDLE hRecCtrl = 0;
	ReturnIfFailed(20, 205, qCtrl.OpenExecute(hDatabase, hRecErrorDlgProp, sqlIce20ErrorText));
	iStat = qCtrl.Fetch(&hRecCtrl);
	if (ERROR_SUCCESS != iStat)
	{
		if (ERROR_NO_MORE_ITEMS == iStat)
		{
			// static text control not specified
			ICEErrorOut(hInstall, hRecErrorDlgProp, Ice20ErrDlgError4);
		}
		else
		{
			// api error
			APIErrorOut(hInstall, iStat, 20, 206);
			return false;
		}
	}

	// look for ErrorIcon control
	ReturnIfFailed(20, 207, qCtrl.OpenExecute(hDatabase, hRecErrorDlgProp, sqlIce20ErrDlgErrIcon));
	iStat = qCtrl.Fetch(&hRecCtrl);
	if (ERROR_SUCCESS == iStat)
	{
		// control found, check TYPE
		TCHAR* pszType = NULL;
		DWORD dwType = 512;
		
		ReturnIfFailed(20, 208, IceRecordGetString(hRecCtrl, 1, &pszType, &dwType, NULL));
		if (_tcscmp(TEXT("Icon"), pszType) != 0)
		{
			ICEErrorOut(hInstall, hRecCtrl, Ice20ErrDlgError6);
		}

		DELETE_IF_NOT_NULL(pszType);
	}


	// now have to validate the pushbuttons
	// fetch pushbuttons with EndDialog ControlEvents
	CQuery qPBCtrls;
	PMSIHANDLE hRecPBCtrls = 0;
	ReturnIfFailed(20, 209, qPBCtrls.OpenExecute(hDatabase, hRecErrorDlgProp, sqlIce20ErrDlgPushButton));

	TCHAR* pszArg = NULL;
	DWORD dwArg = 512;
	TCHAR* pszName = NULL;
	DWORD dwName = 512;

	for (;;)
	{
		iStat = qPBCtrls.Fetch(&hRecPBCtrls);
		if (ERROR_NO_MORE_ITEMS == iStat)
			break; // no more
		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 20, 210);
			DELETE_IF_NOT_NULL(pszArg);
			DELETE_IF_NOT_NULL(pszName);
			return false;
		}

		// get name of argument
		ReturnIfFailed(20, 211, IceRecordGetString(hRecPBCtrls, 1, &pszArg, &dwArg, NULL));

		// get name of pushbutton
		ReturnIfFailed(20, 212, IceRecordGetString(hRecPBCtrls, 2, &pszName, &dwName, NULL));

		// look for the argument in array
		for (int i = 0; i < cIce20ErrDlgArgs; i++)
		{
			if (_tcscmp(s_pIce20ErrDlgArgs[i].szArg, pszArg) == 0)
			{
				s_pIce20ErrDlgArgs[i].fFound = TRUE;
				if (_tcscmp(s_pIce20ErrDlgArgs[i].szName, pszName) != 0)
					s_pIce20ErrDlgArgs[i].fCorrectName = FALSE;
				break;
			}
		}
	}

	DELETE_IF_NOT_NULL(pszArg);
	DELETE_IF_NOT_NULL(pszName);

	// see if all PB args w/ correct names were covered
	for (int i = 0; i < cIce20ErrDlgArgs; i++)
	{
		if (!s_pIce20ErrDlgArgs[i].fFound)
		{
			ICEErrorOut(hInstall, hRecErrorDlgProp, Ice20ErrDlgError4, s_pIce20ErrDlgArgs[i].szArg);
		}
		else if (!s_pIce20ErrDlgArgs[i].fCorrectName)
		{
			// pushbutton named incorrectly
			ICEErrorOut(hInstall, hRecErrorDlgProp, Ice20ErrDlgError5, s_pIce20ErrDlgArgs[i].szArg);
		}
	}
	return true;
}

/////////////////////////////////////////////////////////////////////
// Cancel Dialog -- must satisfy the following
// ++ Must have a Text control
// ++ Must have 2 PushButtons with ControlEvents of EndDialog
// ++ The above 2 PushButtons must have one of the following args
//    == Return
//    == Exit
//
/*
const TCHAR szIce20CancelError1[] = TEXT("ICE20\t1\tRequired Text Control not found for Cancel Dialog\t%s%s\tDialog\tDialog\tCancel");
const TCHAR szIce20CancelError2[] = TEXT("ICE20\t1\tRequired pushbuttons not found for Cancel Dialog\t%s%s\tDialog\tDialog\tCancel");
const TCHAR sqlIce20CancelTextCtrl[] = TEXT("SELECT `Control` FROM `Control` WHERE `Dialog_`='Cancel' AND `Type`='Text'");
const TCHAR sqlIce20CancelPushButton[] = TEXT("SELECT `ControlEvent`.`Argument` FROM `ControlEvent`, `Control` WHERE `Control`.`Dialog_`='Cancel' AND `Type`='PushButton' AND `ControlEvent`.`Dialog_`=`Control`.`Dialog_` AND `Control_`=`Control` AND `ControlEvent`.`Event`='EndDialog'");

void Ice20ValidateCancel(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// look for text control
	PMSIHANDLE hViewTextCtrl = 0;
	PMSIHANDLE hRecTextCtrl = 0;
	if (ERROR_SUCCESS != (iStat = ::MsiDatabaseOpenView(hDatabase, sqlIce20CancelTextCtrl, &hViewTextCtrl)))
	{
		APIErrorOut(hInstall, iStat, szIce20, TEXT("MsiDatabaseOpenView_C1"));
		return;
	}
	if (ERROR_SUCCESS != (iStat = ::MsiViewExecute(hViewTextCtrl, 0)))
	{
		APIErrorOut(hInstall, iStat, szIce20, TEXT("MsiViewExecute_C2"));
		return;
	}
	iStat = ::MsiViewFetch(hViewTextCtrl, &hRecTextCtrl);
	if (ERROR_SUCCESS != iStat)
	{
		if (ERROR_NO_MORE_ITEMS == iStat)
		{
			// Missing text control
			TCHAR szError[iHugeBuf] = {0};
			_stprintf(szError, szIce20CancelError1, szIceHelp, szIce20Help);

			PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
			::MsiRecordSetString(hRecErr, 0, szError);
			::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecErr);
		}
		else
		{
			// api error
			APIErrorOut(hInstall, iStat, szIce20, TEXT("MsiViewFetch_C3"));
			return;
		}
	}

	// look for PushButtons
	PMSIHANDLE hViewPBCtrls = 0;
	PMSIHANDLE hRecPBCtrls = 0;
	BOOL fExit = FALSE;
	BOOL fReturn = FALSE;

	if (ERROR_SUCCESS != (iStat = ::MsiDatabaseOpenView(hDatabase, sqlIce20CancelPushButton, &hViewPBCtrls)))
	{
		APIErrorOut(hInstall, iStat, szIce20, TEXT("MsiDatabaseOpenView_C4"));
		return;
	}
	if (ERROR_SUCCESS != (iStat = ::MsiViewExecute(hViewPBCtrls, 0)))
	{
		APIErrorOut(hInstall, iStat, szIce20, TEXT("MsiViewExecute_C5"));
		return;
	}
	// fetch all PB's
	for (;;)
	{
		iStat = ::MsiViewFetch(hViewPBCtrls, &hRecPBCtrls);
		if (ERROR_NO_MORE_ITEMS == iStat)
			break; // no more
		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, szIce20, TEXT("MsiViewFetch_C6"));
			return;
		}
		// get argument
		TCHAR szArg[iMaxBuf] = {0};
		DWORD cchArg = sizeof(szArg)/sizeof(TCHAR);

		if (ERROR_SUCCESS != (iStat = ::MsiRecordGetString(hRecPBCtrls, 1, szArg, &cchArg)))
		{
			//!!buffer size
			APIErrorOut(hInstall, iStat, szIce20, TEXT("MsiRecordGetString_C7"));
			return;
		}
		if (_tcscmp(TEXT("Exit"), szArg) == 0)
			fExit = TRUE;
		else if (_tcscmp(TEXT("Return"), szArg) == 0)
			fReturn = TRUE;
	}

	// see if all PBs satisfied
	if (!fExit || !fReturn)
	{
		// missing PB's
		TCHAR szError[iHugeBuf] = {0};
		_stprintf(szError, szIce20CancelError2, szIceHelp, szIce20Help);

		PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
		::MsiRecordSetString(hRecErr, 0, szError);
		::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecErr);
	}
}
*/
////////////////////////////////////////////////////////////////////
// DiskCost Dialog -- must satisfy the following
// ++ Have a DiskCost control
//

/*ICE_ERROR(Ice20DiskCostError, 20, 1, "VolumeCostList control not found in DiskCost dialog.","Dialog\tDialog\tDiskCost");
const TCHAR szIce20DiskCostCtrl[] = TEXT("SELECT `Control` FROM `Control` WHERE `Dialog_`='DiskCost' AND `Type`='VolumeCostList'");

bool Ice20ValidateDiskCost(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	CQuery qCtrl;
	PMSIHANDLE hRecCtrl = 0;

	ReturnIfFailed(20, 401, qCtrl.OpenExecute(hDatabase, 0, szIce20DiskCostCtrl));
	iStat = qCtrl.Fetch(&hRecCtrl);
	if (iStat != ERROR_SUCCESS)
	{
		if (ERROR_NO_MORE_ITEMS == iStat)
		{
			// control not found
			PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
			ICEErrorOut(hInstall, hRecErr, Ice20DiskCostError);
		}
		else
		{
			// api error
			APIErrorOut(hInstall, iStat, 20, 402);
			return false;
		}
	}
	return true;
}
*/
#endif

////////////////////////////////////////////////////////////////
// ICE21 -- validates that all components in the Component table
//  map to a feature.  Utilizes the FeatureComponents table to
//  check the mapping.
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR sqlIce21Component[] = TEXT("SELECT `Component` FROM `Component`");
const TCHAR sqlIce21FeatureC[] = TEXT("SELECT `Feature_` FROM `FeatureComponents` WHERE `Component_`=?");
ICE_ERROR(Ice21Error, 21, ietError,  "Component: '[1]' does not belong to any Feature.","Component\tComponent\t[1]");

ICE_FUNCTION_DECLARATION(21)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 21);

	// get active database
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 21, 1);
		return ERROR_SUCCESS;
	}

	// look for the tables
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 21, TEXT("Component")))
		return ERROR_SUCCESS;

	bool bFeatureC = IsTablePersistent(FALSE, hInstall, hDatabase, 21, TEXT("FeatureComponents"));

	// declare handles
	CQuery qComp;
	CQuery qFeatureC;
	PMSIHANDLE hRecComp = 0;
	PMSIHANDLE hRecFeatureC = 0;

	// open view on Component table
	ReturnIfFailed(21, 2, qComp.OpenExecute(hDatabase, 0, sqlIce21Component));

	// open view on FeatureComponents table
	if (bFeatureC)
		ReturnIfFailed(21, 3, qFeatureC.Open(hDatabase, sqlIce21FeatureC));

	// fetch all components
	for (;;)
	{
		iStat = qComp.Fetch(&hRecComp);
		if (ERROR_NO_MORE_ITEMS == iStat)
			break; // no more
		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 21, 4);
			return ERROR_SUCCESS;
		}

		if (!bFeatureC)
		{
			ICEErrorOut(hInstall, hRecComp, Ice21Error);
			continue;
		}

		// look for component to map to a feature in FeatureComponent table
		ReturnIfFailed(21, 5,qFeatureC.Execute(hRecComp));
		
		iStat = qFeatureC.Fetch(&hRecFeatureC);
		if (ERROR_SUCCESS != iStat)
		{
			if (ERROR_NO_MORE_ITEMS == iStat)
			{
				ICEErrorOut(hInstall, hRecComp, Ice21Error);
			}
			else
			{
				APIErrorOut(hInstall, iStat, 21, 6);
				return ERROR_SUCCESS;
			}
		}
	}

	// return success
	return ERROR_SUCCESS;
}
#endif

//////////////////////////////////////////////////////////////////////////
// ICE22 -- validates that the Feature and Component referenced by an
//   entry in the PublishComponent table actually map, as stated in the
//   FeatureComponents table.
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR sqlIce22PublishC[] = TEXT("SELECT `Feature_`, `Component_`, `ComponentId`, `Qualifier` FROM `PublishComponent`");
const TCHAR sqlIce22FeatureC[] = TEXT("SELECT `Feature_`, `Component_` FROM `FeatureComponents` WHERE `Feature_`=? AND `Component_`=?");
ICE_ERROR(Ice22ErrorA, 22, ietError, "Feature-Component pair: '[1]'-'[2]' is not a valid mapping. This pair is referenced by PublishComponent: [3].[4].[2]", "PublishComponent\tComponent_\t[3]\t[4]\t[2]");
ICE_ERROR(Ice22NoTable, 22, ietError, "Feature-Component pair: '[1]'-'[2]' is referenced in the PublishComponent table: [3].[4].[2], but the FeatureComponents table does not exist.", "PublishComponent\tFeature_\t[3]\t[4]\t[2]");
ICE_FUNCTION_DECLARATION(22)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 22);

	// get active database
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 22, 1);
		return ERROR_SUCCESS;
	}

	// only validate if we have a PublishComponent table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 22, TEXT("PublishComponent")))
		return ERROR_SUCCESS;

	// make sure we have the FeatureComponents table
	bool bFeatureC = IsTablePersistent(FALSE, hInstall, hDatabase, 22, TEXT("FeatureComponents"));

	// declare handles
	CQuery qPublishC;
	CQuery qFeatureC;
	PMSIHANDLE hRecPublishC = 0;
	PMSIHANDLE hRecFeatureC = 0;

	// open view on PublishComponent table
	ReturnIfFailed(22, 2, qPublishC.OpenExecute(hDatabase, 0, sqlIce22PublishC));

	// open view on FeatureComponents table
	if (bFeatureC)
		ReturnIfFailed(22, 3, qFeatureC.Open(hDatabase, sqlIce22FeatureC));

	for (;;)
	{
		iStat = qPublishC.Fetch(&hRecPublishC);
		if (ERROR_NO_MORE_ITEMS == iStat)
			break; // no more
		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 22, 5);
			return ERROR_SUCCESS;
		}

		// if no FeatureComponents table, error.
		if (!bFeatureC)
		{
			ICEErrorOut(hInstall, hRecPublishC, Ice22NoTable);
			continue;
		}

		// execute on FeatureC
		ReturnIfFailed(22, 6, qFeatureC.Execute(hRecPublishC));

		// attempt to fetch
		iStat = qFeatureC.Fetch(&hRecFeatureC);
		if (ERROR_SUCCESS != iStat)
		{
			if (ERROR_NO_MORE_ITEMS == iStat)
			{
				// error, not map
				ICEErrorOut(hInstall, hRecPublishC, Ice22ErrorA);
			}
		}
	}

	// return success
	return ERROR_SUCCESS;
}
#endif

#else // RC_INVOKED, end of CPP source code, start of resource definitions
// resource definition go here
#endif // RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\modice.dll\modice.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       ModIce.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>  // included for both CPP and RC passes
#include <stdio.h>    // printf/wprintf
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "msidefs.h"  // must be in this directory or on INCLUDE path
#include "..\..\common\msiice.h"
#include "..\..\common\utilinc.cpp"
#include "..\..\common\query.h"
#include "fdi.h"


const int g_iFirstICE = 01;
const struct ICEInfo_t g_ICEInfo[] = 
{
	// ICEM01
	{
		TEXT("ICEM01"),
		TEXT("Created 08/30/1999. Last Modified 08/30/1999."),
		TEXT("Simple ICE that doesn't test anything"),
		TEXT("icetray.html")
	},
	// ICEM02
	{
		TEXT("ICEM02"),
		TEXT("Created 08/30/1999. Last Modified 08/30/1999."),
		TEXT("Verifies that all module dependencies and exclusions relate to the current module."),
		TEXT("icetray.html")
	},
	// ICEM03
	{
		TEXT("ICEM03"),
		TEXT("Created 08/30/1999. Last Modified 08/30/1999."),
		TEXT("Verifies that all Module*Sequence tables form a proper forest."),
		TEXT("icetray.html")
	},
	// ICEM04
	{
		TEXT("ICEM04"),
		TEXT("Created 10/05/1999. Last Modified 10/06/1999."),
		TEXT("Verifies that the module's required empty tables are indeed empty."),
		TEXT("icetray.html")
	},
	// ICEM05
	{
		TEXT("ICEM05"),
		TEXT("Created 09/01/1999. Last Modified 09/02/1999."),
		TEXT("Verifies that the Merge Module contains no stray components."),
		TEXT("icetray.html")
	},
	// ICEM06
	{
		TEXT("ICEM06"),
		TEXT("Created 09/03/1999. Last Modified 10/2/2000."),
		TEXT("Checks for invalid Feature references."),
		TEXT("icetray.html")
	},
	// ICEM07
	{
		TEXT("ICEM07"),
		TEXT("Created 09/05/1999. Last Modified 09/20/1999."),
		TEXT("Ensures that the order of files in the sequence table matches the order of files in the CAB."),
		TEXT("icetray.html")
	},
	// ICEM08
	{
		TEXT("ICEM08"),
		TEXT("Created 09/23/1999. Last Modified 09/23/1999."),
		TEXT("Ensures that a module does not exclude something that it depends upon."),
		TEXT("icetray.html")
	},
	// ICEM09
	{
		TEXT("ICEM09"),
		TEXT("Created 10/01/1999. Last Modified 10/09/1999."),
		TEXT("Verifies that the merge module safely handles predefined directories."),
		TEXT("icetray.html")
	},
	// ICEM10
	{
		TEXT("ICEM10"),
		TEXT("Created 10/19/1999. Last Modified 10/19/2000."),
		TEXT("Verifies that the merge module does not included disallowed properties."),
		TEXT("icetray.html")
	},
	// ICEM11
	{
		TEXT("ICEM11"),
		TEXT("Created 05/06/2000. Last Modified 05/06/2000."),
		TEXT("Verifies that a configurable merge module has a proper ModuleIgnoreTable."),
		TEXT("icetray.html")
	},
	// ICEM12
	{
		TEXT("ICEM12"),
		TEXT("Created 09/05/2000. Last Modified 09/11/2000."),
		TEXT("Verifies that in ModuleSequence tables, if the Action column is a standard action, the BaseAction and After columns are null."),
		TEXT("icetray.html")
	},
	// ICEM13
	{
		TEXT("ICEM13"),
		TEXT("Created 05/23/2001. Last Modified 05/23/2001."),
		TEXT("Verifies that Merge Module Database does not contain Policy Assembly."),
		TEXT("icetray.html")
	},
	// ICEM14
	{
		TEXT("ICEM14"),
		TEXT("Created 06/04/2001. Last Modified 06/04/2001."),
		TEXT("Verifies that the Value column of the ModuleSubstitution table is correct."),
		TEXT("icetray.html")
	}
};
const int g_iNumICEs = sizeof(g_ICEInfo)/sizeof(struct ICEInfo_t);


// ModuleSequence tables
static const TCHAR *rgszModuleTables[] = {
	TEXT("ModuleInstallExecuteSequence"),
	TEXT("ModuleInstallUISequence"),
	TEXT("ModuleAdminExecuteSequence"),
	TEXT("ModuleAdminUISequence"),
	TEXT("ModuleAdvtExecuteSequence"),
	TEXT("ModuleAdvtUISequence")
};
static const int cszModuleTables = sizeof(rgszModuleTables)/sizeof(TCHAR *);


///////////////////////////////////////////////////////////////////////
// ICE-M01, simple ICE that doesn't check anything
ICE_ERROR(IceM01Time, 01, ietInfo, "Called at: [Time]", "");

ICE_FUNCTION_DECLARATION(M01)
{
	// display generic info
	DisplayInfo(hInstall, 1);

	// time value to be sent on

	// setup the record to be sent as a message
	PMSIHANDLE hRecTime = ::MsiCreateRecord(1);
	ICEErrorOut(hInstall, hRecTime, IceM01Time);

	// return success (ALWAYS)
	return ERROR_SUCCESS;
}

static ErrorInfo_t IceMNotModule =
	{ 0, ietError, TEXT("This package has no ModuleSignature Table. It is not a Merge Module."),TEXT("ModuleSignature") };
	
BOOL IsPackageModule(MSIHANDLE hInstall, MSIHANDLE hDatabase, int iIce)
{
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 02, TEXT("ModuleSignature")))
	{
		PMSIHANDLE hRec = MsiCreateRecord(1);

		IceMNotModule.iICENum = iIce;
		// no module sig table, this is not a module.
		ICEErrorOut(hInstall, hRec, IceMNotModule);
		return FALSE;
	}
	return TRUE;
}

///////////////////////////////////////////////////////////////////////
// ICE-M02, Verifies that all module dependencies and exclusions relate to the current module.
static const TCHAR sqlIceM02Signature[] = TEXT("SELECT `ModuleID`, `Language`, `ModuleID`, `Language` FROM `ModuleSignature`");
static const TCHAR sqlIceM02BadDep[] = TEXT("SELECT `ModuleID`, `ModuleLanguage`, `RequiredID`, `RequiredLanguage` FROM `ModuleDependency` WHERE (`ModuleID`<>?) OR (`ModuleLanguage`<>?)");
static const TCHAR sqlIceM02SelfDep[] = TEXT("SELECT `ModuleID`, `ModuleLanguage`, `RequiredID`, `RequiredLanguage` FROM `ModuleDependency` WHERE (`RequiredID`=?) AND (`RequiredLanguage`=?) AND (`ModuleID`=?) AND (`ModuleLanguage`=?)");
static const TCHAR sqlIceM02BadEx[] = TEXT("SELECT `ModuleID`, `ModuleLanguage`, `ExcludedID`, `ExcludedLanguage` FROM `ModuleExclusion` WHERE `ModuleID`<>? OR `ModuleLanguage`<>?");
static const TCHAR sqlIceM02SelfEx[] = TEXT("SELECT `ModuleID`, `ModuleLanguage`, `ExcludedID`, `ExcludedLanguage` FROM `ModuleExclusion` WHERE (`ExcludedID`=?) AND (`ExcludedLanguage`=?) AND (`ModuleID`=?) AND (`ModuleLanguage`=?)");
ICE_ERROR(IceM02BadDep, 02, ietError, "The dependency [1].[2].[3].[4] in the ModuleDependency table creates a dependency for an unrelated module. A module can only define dependencies for itself.","ModuleDependency\tModuleID\t[1]\t[2]\t[3]\t[4]");
ICE_ERROR(IceM02SelfDep, 02, ietError, "This module is listed as depending on itself!","ModuleDependency\tModuleID\t[1]\t[2]\t[3]\t[4]");
ICE_ERROR(IceM02BadEx, 02, ietError, "The exclusion [1].[2].[3].[4] in the ModuleExclusion table creates an excluded module for an unrelated module. A module can only define exclusions for itself.","ModuleExclusion\tModuleID\t[1]\t[2]\t[3]\t[4]");
ICE_ERROR(IceM02SelfEx, 02, ietError, "This module excludes itself from the target database!","ModuleExclusion\tModuleID\t[1]\t[2]\t[3]\t[4]");

ICE_FUNCTION_DECLARATION(M02)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 02);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsPackageModule(hInstall, hDatabase, 02))
	{
		return ERROR_SUCCESS;
	}

	// fetch a record with the module signature information in it.
	PMSIHANDLE hSignature;
	CQuery qSignature;
	ReturnIfFailed(02, 1, qSignature.FetchOnce(hDatabase, 0, &hSignature, sqlIceM02Signature));
	
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 02, TEXT("ModuleDependency")))
	{
		CQuery qDep;
		PMSIHANDLE hBadDep;
		ReturnIfFailed(02, 2, qDep.OpenExecute(hDatabase, hSignature, sqlIceM02BadDep));
		while (ERROR_SUCCESS == (iStat = qDep.Fetch(&hBadDep)))
		{
			ICEErrorOut(hInstall, hBadDep, IceM02BadDep);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 02, 3);
		}
		
		qDep.Close();
		if (ERROR_SUCCESS == (iStat = qDep.FetchOnce(hDatabase, hSignature, &hBadDep, sqlIceM02SelfDep)))
			ICEErrorOut(hInstall, hBadDep, IceM02SelfDep);
		else if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 02, 4);
		}
			
	}

	if (IsTablePersistent(FALSE, hInstall, hDatabase, 02, TEXT("ModuleExclusion")))
	{
		CQuery qEx;
		PMSIHANDLE hBadEx;
		ReturnIfFailed(02, 5, qEx.OpenExecute(hDatabase, hSignature, sqlIceM02BadEx));
		while (ERROR_SUCCESS == (iStat = qEx.Fetch(&hBadEx)))
		{
			ICEErrorOut(hInstall, hBadEx, IceM02BadEx);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 02, 6);
		}
		
		qEx.Close();
		if (ERROR_SUCCESS == (iStat = qEx.FetchOnce(hDatabase, hSignature, &hBadEx, sqlIceM02SelfEx)))
			ICEErrorOut(hInstall, hBadEx, IceM02SelfEx);
		else if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 02, 7);
		}

	}

	return ERROR_SUCCESS;
};


///////////////////////////////////////////////////////////////////////
// ICE-M03, Verifies that the module sequence tables form a forest
static const TCHAR sqlIceM03CreateColumn[] = TEXT("ALTER TABLE `%s` ADD `_IceM03Mark` INT TEMPORARY");
static const TCHAR sqlIceM03MarkRoot[]     = TEXT("UPDATE `%s` SET `_IceM03Mark`=1 WHERE `BaseAction` IS NULL AND `Sequence` IS NOT NULL AND `After` IS NULL");
static const TCHAR sqlIceM03FetchMarked[]  = TEXT("SELECT `Action`, `_IceM03Mark` FROM `%s` WHERE `_IceM03Mark`=1");
static const int iColIceM03FetchMarked_Action = 1;
static const int iColIceM03FetchMarked_Mark = 2;
static const TCHAR sqlIceM03MarkChild[]    = TEXT("UPDATE `%s` SET `_IceM03Mark`=1 WHERE `BaseAction`=?");
static const TCHAR sqlIceM03FetchOrphan[]  = TEXT("SELECT `Action` FROM `%s` WHERE `_IceM03Mark`<>2");
ICE_ERROR(IceM03BadAction, 03, ietError, "The action '[1]' in the '%s' table is orphaned. It is not a valid base action and does not derive from a valid base action.","%s\tAction\t[1]");

ICE_FUNCTION_DECLARATION(M03)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 03);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsPackageModule(hInstall, hDatabase, 03))
	{
		return ERROR_SUCCESS;
	}

	for (int iTable=0; iTable < cszModuleTables; iTable++)
	{
		// need to check each of the 6 tables, even though AdvtUI is bogus
		if (IsTablePersistent(FALSE, hInstall, hDatabase, 03, rgszModuleTables[iTable]))
		{
			// create a marking column. No HOLD, just keep this query open. That way it
			// will be destroyed when it goes out of scope.
			CQuery qHold;
			ReturnIfFailed(03, 1, qHold.OpenExecute(hDatabase, 0, sqlIceM03CreateColumn, rgszModuleTables[iTable]));
		
			CQuery qRoot;
			if (ERROR_SUCCESS != (iStat = qRoot.OpenExecute(hDatabase, 0, sqlIceM03MarkRoot, rgszModuleTables[iTable])))
			{
				// if there was a problem marking the root, don't fail, just move on to the next table.
				APIErrorOut(hInstall, iStat, 03, 2);
				continue;
			}

			// repeatedly fetch everything that is marked, marking its children, until the entire forest
			// has been processed
			CQuery qFetchMarked;
			CQuery qMarkChild;
			ReturnIfFailed(03, 3, qFetchMarked.Open(hDatabase, sqlIceM03FetchMarked, rgszModuleTables[iTable]))
			ReturnIfFailed(03, 4, qMarkChild.Open(hDatabase, sqlIceM03MarkChild, rgszModuleTables[iTable]))
			int cMarked = 0;
			do 
			{
				cMarked = 0;
				PMSIHANDLE hMarkedRec;
				ReturnIfFailed(03, 6, qFetchMarked.Execute(0));
				while (ERROR_SUCCESS == (iStat = qFetchMarked.Fetch(&hMarkedRec)))
				{
					cMarked++;
					ReturnIfFailed(03, 7, qMarkChild.Execute(hMarkedRec));
					MsiRecordSetInteger(hMarkedRec, iColIceM03FetchMarked_Mark, 2);
					qFetchMarked.Modify(MSIMODIFY_UPDATE, hMarkedRec);
				}
				if (ERROR_NO_MORE_ITEMS != iStat)
				{
					APIErrorOut(hInstall, iStat, 03, 9);
				}
			} 
			while (cMarked);
				
			// now select anything not marked, it is orphaned.
			CQuery qFetchOrphan;
			ReturnIfFailed(03, 10, qFetchOrphan.OpenExecute(hDatabase, 0, sqlIceM03FetchOrphan, rgszModuleTables[iTable]));
			PMSIHANDLE hOrphan;
			while (ERROR_SUCCESS == (iStat = qFetchOrphan.Fetch(&hOrphan)))
			{
				ICEErrorOut(hInstall, hOrphan, IceM03BadAction, rgszModuleTables[iTable], rgszModuleTables[iTable]);
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 03, 11);
			}
		}
	}
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// ICE-M04, Verifies the existence of required and empty tables
struct M04Sequence_t
{
	TCHAR *szMMtable;
	TCHAR *szEmptyTable;
};

static const struct M04Sequence_t rgM04RequiredEmptySequence[] =
{
	{
		TEXT("ModuleInstallExecuteSequence"),
		TEXT("InstallExecuteSequence")
	},
	{
		TEXT("ModuleInstallUISequence"),
		TEXT("InstallUISequence")
	},
	{
		TEXT("ModuleAdvtExecuteSequence"),
		TEXT("AdvtExecuteSequence")
	},
	{
		TEXT("ModuleAdvtUISequence"),
		TEXT("AdvtUISequence")
	},
	{
		TEXT("ModuleAdminExecuteSequence"),
		TEXT("AdminExecuteSequence")
	},
	{
		TEXT("ModuleAdminUISequence"),
		TEXT("AdminUISequence")
	},
};
static const int cszM04Entries = sizeof(rgM04RequiredEmptySequence)/sizeof(M04Sequence_t);
ICE_QUERY2(qIceM04FeatureComponents, "SELECT `Feature_`,`Component_` FROM `FeatureComponents`", Feature_, Component_);
ICE_QUERY1(qIceM04Sequence, "SELECT `Action` FROM `%s`", Action);
ICE_ERROR(IceM04MissingFeatureC, 04, ietError, "An empty FeatureComponents table is required in a Merge Module.","FeatureComponents");
ICE_ERROR(IceM04NonEmptyFeatureC, 04, ietError, "Feature-Component '[1].[2]' found in the FeatureComponents table. The FeatureComponents table must be empty in a Merge Module.", "FeatureComponents\tFeature_\t[1]\t[2]");
ICE_ERROR(IceM04MissingSequence, 04, ietError, "The Merge Module contains the '%s' table. It must therefore have an empty '%s' table.", "%s");
ICE_ERROR(IceM04NonEmptySequence, 04, ietError, "Action '[1]' found in the %s table. This table must be empty in a Merge Module", "%s\tAction\t[1]");

ICE_FUNCTION_DECLARATION(M04)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 04);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsPackageModule(hInstall, hDatabase, 04))
	{
		return ERROR_SUCCESS;
	}

	// empty FeatureComponents table must exist
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 04, TEXT("FeatureComponents")))
	{
		// table is required
		PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecErr, IceM04MissingFeatureC);
	}
	else
	{
		// verify FeatureComponents table is indeed empty
		CQuery qFeatureC;
		ReturnIfFailed(04, 1, qFeatureC.OpenExecute(hDatabase, 0, qIceM04FeatureComponents::szSQL));
		PMSIHANDLE hRecFeatureC;
		while (ERROR_SUCCESS == (iStat = qFeatureC.Fetch(&hRecFeatureC)))
		{
			ICEErrorOut(hInstall, hRecFeatureC, IceM04NonEmptyFeatureC);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 04, 2);
	}

	// verify existence of empty *Sequence tables if corresponding MM *Sequence table exists
	CQuery qSequence;
	bool fSeqTableRequired;
	for (int i = 0; i < cszM04Entries; i++)
	{
		fSeqTableRequired = false;
		if (IsTablePersistent(FALSE, hInstall, hDatabase, 04, rgM04RequiredEmptySequence[i].szMMtable))
			fSeqTableRequired = true;
		if (IsTablePersistent(FALSE, hInstall, hDatabase, 04, rgM04RequiredEmptySequence[i].szEmptyTable))
		{
			// table must be empty if it exists in the Merge Module
			ReturnIfFailed(04, 3, qSequence.OpenExecute(hDatabase, 0, qIceM04Sequence::szSQL, rgM04RequiredEmptySequence[i].szEmptyTable));
			PMSIHANDLE hRecSeq;
			while (ERROR_SUCCESS == (iStat = qSequence.Fetch(&hRecSeq)))
			{
				ICEErrorOut(hInstall, hRecSeq, IceM04NonEmptySequence, rgM04RequiredEmptySequence[i].szEmptyTable, rgM04RequiredEmptySequence[i].szEmptyTable);
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
				APIErrorOut(hInstall, iStat, 04, 4);
		}
		else if (fSeqTableRequired)
		{
			// MM *Sequence table exists, therefore this *Sequence table must exist
			PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
			ICEErrorOut(hInstall, hRecErr, IceM04MissingSequence, rgM04RequiredEmptySequence[i].szMMtable, rgM04RequiredEmptySequence[i].szEmptyTable, rgM04RequiredEmptySequence[i].szEmptyTable);
		}
	}

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// ICE-M05, Verifies that there are no stray components
static const TCHAR sqlIceM05Signature[] = TEXT("SELECT `ModuleID`, `Language`, `ModuleID`, `Language` FROM `ModuleSignature`");
static const TCHAR sqlIceM05BadComp[] = TEXT("SELECT `Component`, `ModuleID`, `Language` FROM `ModuleComponents` WHERE (`ModuleID`<>?) OR (`Language`<>?)");
static const TCHAR sqlIceM05MatchComp[] = TEXT("SELECT `Component`.`Component` FROM `ModuleComponents`,`Component` WHERE `ModuleComponents`.`Component`=`Component`.`Component`");
static const TCHAR sqlIceM05CreateColumn[] = TEXT("ALTER TABLE `%s` ADD `_IceM05Mark` INT TEMPORARY");
static const TCHAR sqlIceM05MarkColumn[] = TEXT("UPDATE `%s` SET `_IceM05Mark`=1 WHERE `Component`=?");
static const TCHAR sqlIceM05StrayComp[] = TEXT("SELECT %s FROM `%s` WHERE `_IceM05Mark`<>1");
ICE_ERROR(IceM05BadComp, 05, ietError, "The component [1].[2].[3] in the ModuleComponents table does not belong to this Merge Module.","ModuleComponents\tComponent\t[1]\t[2]\t[3]");
ICE_ERROR(IceM05StrayComponent, 05, ietError, "The component [1] in the Component table is not listed in the ModuleComponents table.", "Component\tComponent\t[1]");
ICE_ERROR(IceM05StrayModuleComponent, 05, ietError, "The component [1].[2].[3] in the ModuleComponents table is not listed in the Component table.", "ModuleComponents\tComponent\t[1]\t[2]\t[3]");
ICE_ERROR(IceM05MissingModuleComponentsTable, 05, ietError, "The ModuleComponents table is missing. It is required in a Merge Module.", "ModuleComponents");
ICE_ERROR(IceM05MissingComponentTable, 05, ietError, "The Component table is missing. It is required in a Merge Module.", "Component");

ICE_FUNCTION_DECLARATION(M05)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 05);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsPackageModule(hInstall, hDatabase, 05))
	{
		return ERROR_SUCCESS;
	}

	// fetch a record with the module signature information in it.
	PMSIHANDLE hSignature;
	CQuery qSignature;
	ReturnIfFailed(05, 1, qSignature.FetchOnce(hDatabase, 0, &hSignature, sqlIceM05Signature));

	if (IsTablePersistent(false, hInstall, hDatabase, 05, TEXT("ModuleComponents")))
	{
		//CHECK 1: components in ModuleComponents table match signature of MergeModule
		CQuery qBadComp;
		PMSIHANDLE hBadComp;
		ReturnIfFailed(05, 2, qBadComp.OpenExecute(hDatabase, hSignature, sqlIceM05BadComp));
		while (ERROR_SUCCESS == (iStat = qBadComp.Fetch(&hBadComp)))
		{
			ICEErrorOut(hInstall, hBadComp, IceM05BadComp);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 05, 3);
		}
		qBadComp.Close();

		if (IsTablePersistent(false, hInstall, hDatabase, 05, TEXT("Component")))
		{
			// create marking columns
			CQuery qHoldModComp;
			ReturnIfFailed(05, 4, qHoldModComp.OpenExecute(hDatabase, 0, sqlIceM05CreateColumn, TEXT("ModuleComponents")));
			
			CQuery qHoldComp;
			ReturnIfFailed(05, 5, qHoldComp.OpenExecute(hDatabase, 0, sqlIceM05CreateColumn, TEXT("Component")));

			// mark all matching components
			CQuery qMatchComp;
			PMSIHANDLE hMatchComp;
			CQuery qMarkComp;
			CQuery qMarkModComp;
			ReturnIfFailed(05, 6, qMatchComp.OpenExecute(hDatabase, 0, sqlIceM05MatchComp));
			ReturnIfFailed(05, 7, qMarkComp.Open(hDatabase, sqlIceM05MarkColumn, TEXT("Component")));
			ReturnIfFailed(05, 8, qMarkModComp.Open(hDatabase, sqlIceM05MarkColumn, TEXT("ModuleComponents")));

			while (ERROR_SUCCESS == (iStat = qMatchComp.Fetch(&hMatchComp)))
			{
				// mark component in both ModuleComponents and Component tables
				ReturnIfFailed(05, 9, qMarkComp.Execute(hMatchComp));
				ReturnIfFailed(05, 10, qMarkModComp.Execute(hMatchComp));
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 05, 11);
			}
			qMatchComp.Close();

			CQuery qStrayComp;
			PMSIHANDLE hStrayComp;
			// CHECK 2: Find all components in Component table not listed in ModuleComponents table
			ReturnIfFailed(05, 12, qStrayComp.OpenExecute(hDatabase, 0, sqlIceM05StrayComp, TEXT("`Component`"), TEXT("Component")));
			while (ERROR_SUCCESS == (iStat = qStrayComp.Fetch(&hStrayComp)))
			{
				ICEErrorOut(hInstall, hStrayComp, IceM05StrayComponent);
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 05, 13);
			}

			// CHECK 3: Find all components in ModuleComponents table not listed in Component table
			ReturnIfFailed(05, 14, qStrayComp.OpenExecute(hDatabase, 0, sqlIceM05StrayComp, TEXT("`Component`,`ModuleID`,`Language`"), TEXT("ModuleComponents")));
			while (ERROR_SUCCESS == (iStat = qStrayComp.Fetch(&hStrayComp)))
			{
				ICEErrorOut(hInstall, hStrayComp, IceM05StrayModuleComponent);
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 05, 15);
			}
			
		}
		else
		{
			PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
			ICEErrorOut(hInstall, hRecErr, IceM05MissingComponentTable);
		}
	}
	else
	{
		PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecErr, IceM05MissingModuleComponentsTable);
	}

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// ICE-M06, Verifies that no foreign keys reference feature data.
ICE_QUERY2(qIceM06FetchTableColumn, "SELECT `Table`,`Column` FROM `_Validation` WHERE `KeyTable`='Feature' AND `KeyColumn`=1 AND `Table`<>'Feature' AND `Table`<>'FeatureComponents' AND `Table`<>'Shortcut'", Table, Column);
ICE_QUERY0(qIceM06FetchKeys,        "SELECT * FROM `%s` WHERE `%s`<>'{00000000-0000-0000-0000-000000000000}' AND `%s` IS NOT NULL");
ICE_QUERY2(qIceM06Shortcut,         "SELECT `Shortcut`, `Target` FROM `Shortcut` WHERE `Target`<>'{00000000-0000-0000-0000-000000000000}'", Shortcut, Target);

ICE_ERROR(IceM06Feature, 06, ietError, "The row %s in the %s table has a feature reference that is not a null GUID. Modules may not directly reference features.","%s\t%s\t%s");
ICE_ERROR(IceM06Shortcut, 06, ietError, "The target of shortcut [1] is not a property and not a null GUID. Modules may not directly reference features.","Shortcut\tTarget\t[1]");
ICE_ERROR(IceM06Validation, 06, ietWarning, "Column %s of table %s specified in the _Validation table does not exist.","_Validation\tColumn\t[1]");

ICE_FUNCTION_DECLARATION(M06)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 06);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsPackageModule(hInstall, hDatabase, 06))
	{
		return ERROR_SUCCESS;
	}

	// if there is a validation table, we can check some feature foreign keys
	if (IsTablePersistent(false, hInstall, hDatabase, 06, TEXT("_Validation")))
	{
		CQuery qFeatureRefTables;
		ReturnIfFailed(06, 1, qFeatureRefTables.OpenExecute(hDatabase, 0, qIceM06FetchTableColumn::szSQL));

		PMSIHANDLE hTableColumn;
		TCHAR *szTableName = NULL;
		DWORD cchTableName = 72;
		TCHAR *szColumnName = NULL;
		DWORD cchColumnName = 72;
		while (ERROR_SUCCESS == (iStat = qFeatureRefTables.Fetch(&hTableColumn)))
		{
			// get the table name
			ReturnIfFailed(06, 2, IceRecordGetString(hTableColumn, qIceM06FetchTableColumn::Table, &szTableName, &cchTableName, NULL));

			// make sure the table exists
			if (IsTablePersistent(false, hInstall, hDatabase, 06, szTableName))
			{
				// get the column name
				ReturnIfFailed(06, 3, IceRecordGetString(hTableColumn, qIceM06FetchTableColumn::Column, &szColumnName, &cchColumnName, NULL));
	
				// check all foreign keys in this table
				CQuery qGetKeyRefs;
				UINT iRetVal;

				iRetVal = qGetKeyRefs.OpenExecute(hDatabase, 0, qIceM06FetchKeys::szSQL, szTableName, szColumnName, szColumnName);
				if(iRetVal == ERROR_BAD_QUERY_SYNTAX)
				{
					ICEErrorOut(hInstall, hTableColumn, IceM06Validation, szColumnName, szTableName);
					continue;
				}
				else if(iRetVal != ERROR_SUCCESS)
				{
					ReturnIfFailed(06, 4, iRetVal);
				}
				
				// if there is any form of error, we need to set up the primary key tokens and then
				// give one error for each row
				PMSIHANDLE hBadRef;
				if (ERROR_SUCCESS == (iStat = qGetKeyRefs.Fetch(&hBadRef)))
				{
					TCHAR *szHuman;
					TCHAR *szToken;
					GeneratePrimaryKeys(06, hInstall, hDatabase, szTableName, &szHuman, &szToken);
					
					do
					{
						ICEErrorOut(hInstall, hBadRef, IceM06Feature, szHuman, szTableName, szTableName, szColumnName, szToken);
					} 
					while (ERROR_SUCCESS == (iStat = qGetKeyRefs.Fetch(&hBadRef)));
					
					delete[] szHuman;
					delete[] szToken;
				}
				if (ERROR_NO_MORE_ITEMS != iStat)
				{
					APIErrorOut(hInstall, iStat, 06, 5);
				}
			}
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 06, 6);
		}
	}

	// the shortcut table needs a little special handling, because the Target can either be a feature
	// or a property.
	if (IsTablePersistent(false, hInstall, hDatabase, 06, TEXT("Shortcut")))
	{
		CQuery qShortcutTable;
		TCHAR *szShortcut = 0;
		DWORD cchShortcut = 72;
		PMSIHANDLE hShortcutRec;
		ReturnIfFailed(06, 7, qShortcutTable.OpenExecute(hDatabase, 0, qIceM06Shortcut::szSQL))
		while (ERROR_SUCCESS == (iStat = qShortcutTable.Fetch(&hShortcutRec)))
		{
			ReturnIfFailed(06, 8, IceRecordGetString(hShortcutRec, qIceM06Shortcut::Target, &szShortcut, &cchShortcut, NULL));
			if (szShortcut[0] != TEXT('['))
			{
				ICEErrorOut(hInstall, hShortcutRec, IceM06Shortcut);
			}
		}
		delete[] szShortcut;
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 06, 9);
		}
	}
	return ERROR_SUCCESS;
}				

///////////////////////////////////////////////////////////////////////
// ICE-M07, Verifies that the file table order (by sequence) matches
// the CAB order
ICE_QUERY1(qIceM07Cab,"SELECT `Data` FROM `_Streams` WHERE `Name`='MergeModule.CABinet'", Data);
ICE_QUERY0(qIceM07TempColumn,"ALTER TABLE `File` ADD `_ICEM07CAB` INT TEMPORARY");
ICE_QUERY0(qIceM07Update,"UPDATE `File` SET `_ICEM07CAB`=%d WHERE `File`='%hs'");
ICE_QUERY3(qIceM07FileOrder,"SELECT `File`, `_ICEM07CAB`, `Sequence` FROM `File` ORDER BY `Sequence`", File, CABOrder, FileOrder);
ICE_QUERY0(qIceM07CountFile,"SELECT '' FROM `File`");

ICE_ERROR(IceM07SameFile, 07, ietError,   "The file '[1]' has the same sequence number as another file. File sequence numbers must track the order of files in the CAB.","File\tSequence\t[1]");
ICE_ERROR(IceM07BadOrder, 07, ietError,   "The file '[1]' appears to be out of sequence. It has position [2] in the CAB, but not when the file table is ordered by sequence number.","File\tSequence\t[1]");
ICE_ERROR(IceM07MissingFile, 07, ietError,   "The file '[1]' listed in the file table does not exist in the CAB.","File\tFile\t[1]");
ICE_ERROR(IceM07NoCAB,    07, ietWarning, "No embedded MergeModule.CABinet could be found.","File");

// the following must be outside function so callbacks can access it.
MSIHANDLE hIceM07CabRec[2] = {0,0};
MSIHANDLE hIceM07Database = 0;
UINT uiIceM07StreamPos[2] = {0,0};
UINT uiIceM07CabSequence = 0;

// These functions are callbacks for the FDI library.
void*               IceM07FDIAlloc(ULONG size);
void                IceM07FDIFree(void *mem);
INT_PTR  FAR DIAMONDAPI IceM07FDIOpen(char FAR *pszFile, int oflag, int pmode);
UINT FAR DIAMONDAPI IceM07FDIRead(INT_PTR hf, void FAR *pv, UINT cb);
UINT FAR DIAMONDAPI IceM07FDIWrite(INT_PTR hf, void FAR *pv, UINT cb);
int  FAR DIAMONDAPI IceM07FDIClose(INT_PTR hf);
long FAR DIAMONDAPI IceM07FDISeek(INT_PTR hf, long dist, int seektype);
INT_PTR                 IceM07ExtractFilesCallback(FDINOTIFICATIONTYPE iNotification, FDINOTIFICATION *pFDINotify);

// these are cabinet.dll function calls latebound later
HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc, PFNFREE  pfnfree, PFNOPEN  pfnopen, PFNREAD  pfnread,
                              PFNWRITE pfnwrite, PFNCLOSE pfnclose, PFNSEEK  pfnseek, int cpuType, PERF perf);
BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi);
BOOL FAR DIAMONDAPI FDICopy(HFDI hfdi, char *pszCabinet, char *pszCabPath, int flags, PFNFDINOTIFY pfnfdin,
                            PFNFDIDECRYPT pfnfdid, void *pvUser);

ICE_FUNCTION_DECLARATION(M07)
{
	UINT iStat = ERROR_NO_MORE_ITEMS;

	// display info
	DisplayInfo(hInstall, 07);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsPackageModule(hInstall, hDatabase, 07))
	{
		return ERROR_SUCCESS;
	}

	if (!IsTablePersistent(false, hInstall, hDatabase, 07, TEXT("File")))
		return ERROR_SUCCESS;

	CQuery qTempColumn;
	ReturnIfFailed(07, 1, qTempColumn.OpenExecute(hDatabase, 0, qIceM07TempColumn::szSQL));

	// check for stream
	{
		CQuery qCab;
		PMSIHANDLE hRec;
		iStat = qCab.FetchOnce(hDatabase, 0, &hRec, qIceM07Cab::szSQL);
	}
	if (ERROR_SUCCESS == iStat)
	{
		uiIceM07CabSequence = 1;
		// create a FDI context to do the decompression
		ERF ErrorInfo;

		HFDI hFDI = FDICreate(IceM07FDIAlloc, IceM07FDIFree, IceM07FDIOpen, IceM07FDIRead, IceM07FDIWrite, IceM07FDIClose, 
			IceM07FDISeek, cpuUNKNOWN, &ErrorInfo);		
		if (NULL == hFDI) 
		{
			APIErrorOut(hInstall, ERROR_FUNCTION_FAILED, 07, 2);
			return ERROR_SUCCESS;
		}

		// set up the handle used in the callbacks
		hIceM07Database = hDatabase;

		// iterate through files in cabinet, but don't extract any files. just grab the names
		BOOL fSuccess = FDICopy(hFDI, "MergeModule.CABinet", "", 0, IceM07ExtractFilesCallback, NULL, 0);
					
		// destroy the FDI context
		hIceM07Database = 0;
		FDIDestroy(hFDI);

		// ensure that the enumeration succeeded
		if (!fSuccess)
		{
			APIErrorOut(hInstall, ERROR_FUNCTION_FAILED, 07, 3);
			return ERROR_SUCCESS;
		}

		// get everything from the file table in order and compare the order of the cab sequence to 
		// the file sequence
		CQuery qFileOrder;
		ReturnIfFailed(07, 04, qFileOrder.OpenExecute(hDatabase, 0, qIceM07FileOrder::szSQL));
		int uiLastFileOrder = -1;
		int uiLastCABOrder = -1;
		PMSIHANDLE hFileRec;
		while (ERROR_SUCCESS == (iStat = qFileOrder.Fetch(&hFileRec)))
		{
			int uiThisFile = MsiRecordGetInteger(hFileRec, qIceM07FileOrder::FileOrder);
			int uiThisCAB = MsiRecordGetInteger(hFileRec, qIceM07FileOrder::CABOrder);

			if (uiThisFile == uiLastFileOrder)
			{
				ICEErrorOut(hInstall, hFileRec, IceM07SameFile);
			}
			else if (uiThisCAB == MSI_NULL_INTEGER)
			{
				ICEErrorOut(hInstall, hFileRec, IceM07MissingFile);
			}
			else if (uiThisCAB <= uiLastCABOrder)
			{
				ICEErrorOut(hInstall, hFileRec, IceM07BadOrder);
			}
			else
				uiLastCABOrder = uiThisCAB;

			uiLastFileOrder = uiThisFile;
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 07, 5);
		}
	}
	else if (ERROR_NO_MORE_ITEMS == iStat)
	{
		// if the file table is empty, there is no need for a CAB.
		PMSIHANDLE hRec;
		CQuery qCount;
		qCount.OpenExecute(hDatabase, 0, qIceM07CountFile::szSQL);
		iStat = qCount.FetchOnce(hDatabase, 0, &hRec, qIceM07CountFile::szSQL);
		if (ERROR_SUCCESS == iStat)
		{
			ICEErrorOut(hInstall, hRec, IceM07NoCAB);
		}
		else if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 07, 6);
		}
	}
	else if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 07, 7);
	}

	// the callback function has 
	return ERROR_SUCCESS;
}				

// These functions are callbacks for the FDI library.
void *IceM07FDIAlloc(ULONG size) { return static_cast<void *>(new unsigned char[size]); };
void IceM07FDIFree(void *mem) { delete[] mem; };
INT_PTR FAR DIAMONDAPI IceM07FDIOpen(char FAR *pszFile, int oflag, int pmode)
{
	// if FDI asks for some crazy mode (in low memory situation it could ask
	// for a scratch file) fail. 
	if (oflag != (/*_O_BINARY*/ 0x8000 | /*_O_RDONLY*/ 0x0000))
		return -1;

	// we should return the equivalent of a file handle. We forbid FDI from asking for any file except
	// the CAB, so we have a limited number of possible handles.
	int hHandle = hIceM07CabRec[0] ? 1 : 0;
	CQuery qCab;
	qCab.FetchOnce(hIceM07Database, 0, &hIceM07CabRec[hHandle], qIceM07Cab::szSQL);
	uiIceM07StreamPos[hHandle] = 0;
	return hHandle+1;
}

UINT FAR DIAMONDAPI IceM07FDIRead(INT_PTR hf, void FAR *pv, UINT cb)
{
	DWORD cbRead = cb;
	MsiRecordReadStream(hIceM07CabRec[hf-1], qIceM07Cab::Data, reinterpret_cast<char *>(pv), &cbRead); 
	uiIceM07StreamPos[hf-1] += cbRead;
	return cbRead;
}

UINT FAR DIAMONDAPI IceM07FDIWrite(INT_PTR hf, void FAR *pv, UINT cb) {	return -1; }
int FAR DIAMONDAPI IceM07FDIClose(INT_PTR hf) 
{	
	MsiCloseHandle(hIceM07CabRec[hf-1]); 
	hIceM07CabRec[hf-1] = 0; 
	return 0; 
}

long FAR DIAMONDAPI IceM07FDISeek(INT_PTR hf, long dist, int seektype)
{
	UINT uiNewPos = 0;
	switch (seektype)
	{
		case 0 /* SEEK_SET */ :
			uiNewPos = dist > 0 ? dist : 0;
			break;
		case 1 /* SEEK_CUR */ :
			if (-dist > uiIceM07StreamPos[hf-1])
				uiNewPos = 0;
			else
				uiNewPos = uiIceM07StreamPos[hf-1] + dist;		
			break;
		case 2 /* SEEK_END */ :
			// we are a read-only FDI system, seeking to the end is meaningless
			return 0;
			break;
		default :
			return -1;
	}

	if (uiNewPos < uiIceM07StreamPos[hf-1])
	{
		MsiCloseHandle(hIceM07CabRec[hf-1]);
		CQuery qCab;
		qCab.FetchOnce(hIceM07Database, 0, &hIceM07CabRec[hf-1], qIceM07Cab::szSQL);
		uiIceM07StreamPos[hf-1] = 0;
	}

	while (uiIceM07StreamPos[hf-1] < uiNewPos)
	{
		char rgchBuffer[4096];
		unsigned long cbRead = uiNewPos - uiIceM07StreamPos[hf-1];
		if (cbRead > sizeof(rgchBuffer))
			cbRead = sizeof(rgchBuffer);
		MsiRecordReadStream(hIceM07CabRec[hf-1], qIceM07Cab::Data, rgchBuffer, &cbRead);
		uiIceM07StreamPos[hf-1] += cbRead;
	}
	return uiIceM07StreamPos[hf-1];
}

// callback from FDI API
INT_PTR IceM07ExtractFilesCallback(FDINOTIFICATIONTYPE iNotification, FDINOTIFICATION *pFDINotify)
{
	switch(iNotification)
	{
		
	case fdintCOPY_FILE:
	{
		CQuery qUpdate;
		// note: filename provided by FDI is always ANSI
		qUpdate.OpenExecute(hIceM07Database, 0, qIceM07Update::szSQL, 
			uiIceM07CabSequence++, reinterpret_cast<LPCSTR>(pFDINotify->psz1));
		
		// return 0 to skip file
		return 0;
	}

	case fdintCLOSE_FILE_INFO:
	case fdintPARTIAL_FILE:
	case fdintNEXT_CABINET:
	case fdintENUMERATE:
	case fdintCABINET_INFO:
	default:
		// no action needed for these messages.
		break;
	};

	return 0;
}

static HINSTANCE hCabinetDll;   /* DLL module handle */

/* pointers to the functions in the DLL */

typedef HFDI (FAR DIAMONDAPI *PFNFDICREATE)(
        PFNALLOC            pfnalloc,
        PFNFREE             pfnfree,
        PFNOPEN             pfnopen,
        PFNREAD             pfnread,
        PFNWRITE            pfnwrite,
        PFNCLOSE            pfnclose,
        PFNSEEK             pfnseek,
        int                 cpuType,
        PERF                perf);
typedef BOOL (FAR DIAMONDAPI *PFNFDIISCABINET)(
        HFDI                hfdi,
        int                 hf,
        PFDICABINETINFO     pfdici);
typedef BOOL (FAR DIAMONDAPI *PFNFDICOPY)(
        HFDI                hfdi,
        char                *pszCabinet,
        char                *pszCabPath,
        int                 flags,
        PFNFDINOTIFY        pfnfdin,
        PFNFDIDECRYPT       pfnfdid,
        void                *pvUser);
typedef BOOL (FAR DIAMONDAPI *PFNFDIDESTROY)(
        HFDI                hfdi);
static PFNFDICREATE    pfnFDICreate;
static PFNFDIISCABINET pfnFDIIsCabinet;
static PFNFDICOPY      pfnFDICopy;
static PFNFDIDESTROY   pfnFDIDestroy;

HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf)
{
    HFDI hfdi;

    hCabinetDll = LoadLibraryA("CABINET"); // ensure work on win9X
    if (hCabinetDll == NULL)
    {
        return(NULL);
    }

    pfnFDICreate = reinterpret_cast<PFNFDICREATE>(GetProcAddress(hCabinetDll,"FDICreate"));
    pfnFDICopy = reinterpret_cast<PFNFDICOPY>(GetProcAddress(hCabinetDll,"FDICopy"));
    pfnFDIIsCabinet = reinterpret_cast<PFNFDIISCABINET>(GetProcAddress(hCabinetDll,"FDIIsCabinet"));
    pfnFDIDestroy = reinterpret_cast<PFNFDIDESTROY>(GetProcAddress(hCabinetDll,"FDIDestroy"));

    if ((pfnFDICreate == NULL) ||
        (pfnFDICopy == NULL) ||
        (pfnFDIIsCabinet == NULL) ||
        (pfnFDIDestroy == NULL))
    {
        FreeLibrary(hCabinetDll);

        return(NULL);
    }

    hfdi = pfnFDICreate(pfnalloc,pfnfree,
            pfnopen,pfnread,pfnwrite,pfnclose,pfnseek,cpuType,perf);
    if (hfdi == NULL)
    {
        FreeLibrary(hCabinetDll);
    }

    return(hfdi);
}

BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 int             hf,
                                 PFDICABINETINFO pfdici)
{
    if (pfnFDIIsCabinet == NULL)
    {
        return(FALSE);
    }

    return(pfnFDIIsCabinet(hfdi,hf,pfdici));
}

BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char         *pszCabinet,
                            char         *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void         *pvUser)
{
    if (pfnFDICopy == NULL)
    {
        return(FALSE);
    }

    return(pfnFDICopy(hfdi,pszCabinet,pszCabPath,flags,pfnfdin,pfnfdid,pvUser));
}

BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi)
{
    BOOL rc;

    if (pfnFDIDestroy == NULL)
    {
        return(FALSE);
    }

    rc = pfnFDIDestroy(hfdi);
    if (rc == TRUE)
    {
        FreeLibrary(hCabinetDll);
    }

    return(rc);
}

///////////////////////////////////////////////////////////////////////
// ICE-M08, Verifies that all module dependencies aren't excluded as well.
ICE_QUERY5(qIceM08GetDep, "SELECT `RequiredID`, `RequiredLanguage`, `RequiredVersion`, `ModuleID`,`ModuleLanguage` FROM `ModuleDependency`", RequiredID, RequiredLanguage, RequiredVersion, ModuleID, ModuleLanguage);
ICE_QUERY6(qIceM08GetEx,  "SELECT `ModuleID`, `ModuleLanguage`, `ExcludedID`, `ExcludedLanguage`, `ExcludedMinVersion`, `ExcludedMaxVersion` FROM `ModuleExclusion` WHERE (`ExcludedID`=?) AND (`ExcludedLanguage`=?)", ModuleID, ModuleLanguage, ExcludedID, ExcludedLanguage, ExcludedMinVersion, ExcludedMaxVersion);
ICE_ERROR(IceM08BadEx, 8, ietError, "This module requires module [1] ([2]v[3]) but also lists it as an exclusion.","ModuleDependency\tRequiredID\t[4]\t[5]\t[1]\t[2]");

// from tools\utils.cpp
extern int VersionCompare(LPCTSTR v1, LPCTSTR v2) ;

ICE_FUNCTION_DECLARATION(M08)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 8);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsPackageModule(hInstall, hDatabase, 8))
	{
		return ERROR_SUCCESS;
	}

	if (IsTablePersistent(FALSE, hInstall, hDatabase, 8, TEXT("ModuleDependency")) &&
		IsTablePersistent(FALSE, hInstall, hDatabase, 8, TEXT("ModuleExclusion")))
	{
		CQuery qDep;
		CQuery qEx;
		PMSIHANDLE hDep;
		PMSIHANDLE hEx;
		ReturnIfFailed(8, 1, qDep.OpenExecute(hDatabase, 0, qIceM08GetDep::szSQL));
		ReturnIfFailed(8, 2, qEx.Open(hDatabase, qIceM08GetEx::szSQL));

		DWORD cchDepVersion = 32;
		DWORD cchExVersion = 32;
		TCHAR *szDepVersion = new TCHAR[cchDepVersion];
		TCHAR *szExVersion = new TCHAR[cchExVersion];
		
		while (ERROR_SUCCESS == (iStat = qDep.Fetch(&hDep)))
		{
			bool bExcluded = false;
			ReturnIfFailed(8, 3, qEx.Execute(hDep));
			while (ERROR_SUCCESS == (iStat = qEx.Fetch(&hEx)))
			{
				// at this point everything matches between the dependency and the exclusion except
				// for the version information
				
				// if both of the excluded versions are null, nothing with this ID/lang combo is valid
				if (::MsiRecordIsNull(hEx, qIceM08GetEx::ExcludedMinVersion) &&
					::MsiRecordIsNull(hEx, qIceM08GetEx::ExcludedMaxVersion))
				{
					bExcluded = true;
					break;
				}

				// but if either one of the excluded versions is not null, it means some versions ARE valid, 
				// so if the required version is NULL, we don't have enough info to conclude anything.
				if (::MsiRecordIsNull(hDep, qIceM08GetDep::RequiredVersion))
				{
					continue;
				}

				// we'll need to do some version comparison, so extract the version
				// of the dependency
				ReturnIfFailed(8, 4, IceRecordGetString(hDep, qIceM08GetDep::RequiredVersion, &szDepVersion, &cchDepVersion, NULL));				

				// now check min version
				bool bExcludedMin = false;
				bool bExcludedMax = false;
				if (::MsiRecordIsNull(hEx, qIceM08GetEx::ExcludedMinVersion))
				{
					bExcludedMin = true;
				}
				else
				{
					ReturnIfFailed(8, 5, IceRecordGetString(hEx, qIceM08GetEx::ExcludedMinVersion, &szExVersion, &cchExVersion, NULL));

					if (VersionCompare(szExVersion, szDepVersion) != -1)
					{
						bExcludedMin = true;
					}
				} 
					
				// check max version
				if (::MsiRecordIsNull(hEx, qIceM08GetEx::ExcludedMaxVersion)) 
				{
					bExcludedMax = true;
				}
				else
				{
					ReturnIfFailed(8, 5, IceRecordGetString(hEx, qIceM08GetEx::ExcludedMaxVersion, &szExVersion, &cchExVersion, NULL));

					if (VersionCompare(szExVersion, szDepVersion) != 1)
					{
						bExcludedMax = true;
					}
				} 

				// if we satisfy both max and min restrictions on range for this exclusions, we are excluded
				if (bExcludedMin && bExcludedMax)
				{
					bExcluded = true;
					break;
				}
			}
			if (!bExcluded && ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 8, 6);
			}

			if (bExcluded)
				ICEErrorOut(hInstall, hDep, IceM08BadEx);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 8, 7);
		}
		
		delete[] szDepVersion;
		delete[] szExVersion;
	}

	return ERROR_SUCCESS;
};

///////////////////////////////////////////////////////////////////////
// ICE-M09, Verifies that the module safely handles all predefined directories
ICE_QUERY2(qIceM09GetDir, "SELECT `Directory_`, `Component` FROM `Component` WHERE `Directory_`=?", Directory, Component);
ICE_QUERY1(qIceM09GetCAByDir, "SELECT `Directory` FROM `Directory`", Directory);
ICE_QUERY3(qIceM09GetCA, "SELECT `Action`, `Source`, `Target` FROM `CustomAction` WHERE CustomAction`.`Type`=51 AND `Source`=?", Action, Source, Target);
ICE_QUERY2(qIceM09ModTable, "SELECT `Action`, `Sequence` FROM `%s` WHERE `Action`=?", Action, Sequence);

ICE_ERROR(IceM09PredefDir, 9, ietWarning, "The component '[2]' installs directly into the pre-defined directory '[1]'. It is recommended that merge modules alias all such directories to unique names.","Component\tDirectory_\t[2]");
ICE_ERROR(IceM09BadSeqNum, 9, ietWarning, "The '%s' table contains a type 51 action ([1]) for a pre-defined directory, but this action does not have sequence number '1'.","%s\tSequence\t[1]");
ICE_ERROR(IceM09WrongName, 9, ietWarning, "The 'CustomAction' table contains a type 51 action ([1]) for a pre-defined directory, but the name is not the same as the target directory. Many merge tools will generate duplicate actions.","CustomAction\tAction\t[1]");
ICE_ERROR(IceM09NoCATable, 9, ietError, "The 'Directory' table contains a pre-defined directory, but no CustomAction table. A custom action table is required, although it may be empty.","CustomAction");

ICE_FUNCTION_DECLARATION(M09)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 9);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsPackageModule(hInstall, hDatabase, 9))
	{
		return ERROR_SUCCESS;
	}

	// check that no components install to the predefined directory
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 9, TEXT("Component")))
	{
		CQuery qGetDir;
		PMSIHANDLE hDir;
		PMSIHANDLE hQueryArg = MsiCreateRecord(1);
		TCHAR *szDir = NULL;
		DWORD cchDir = 72; 
		int iDir = 0;
		ReturnIfFailed(9, 1, qGetDir.Open(hDatabase, qIceM09GetDir::szSQL));
		// loop through each possible predefined directory
		for (iDir=0; iDir < cDirProperties; iDir++)
		{
			MsiRecordSetString(hQueryArg, 1, rgDirProperties[iDir].tz);
			ReturnIfFailed(9, 2, qGetDir.Execute(hQueryArg));
			while (ERROR_SUCCESS == (iStat = qGetDir.Fetch(&hDir)))
			{
				// warning: Components in a module should not install directly to a
				// predefined directory.
				ICEErrorOut(hInstall, hDir, IceM09PredefDir);
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 9, 3);
			}
		}
	}

	// check that custom actions (if they exist) use the appropriate property definitions
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 9, TEXT("Directory")))
	{
		bool fHaveCATable = IsTablePersistent(FALSE, hInstall, hDatabase, 9, TEXT("CustomAction"));
		CQuery qGetCA;
		CQuery qGetCAByDir;
		PMSIHANDLE hDir;
		PMSIHANDLE hQueryArg = MsiCreateRecord(1);
		TCHAR *szCA = NULL;
		DWORD cchCALen = 72;
		DWORD cchCABuf = 72;
		ReturnIfFailed(9, 4, qGetCAByDir.OpenExecute(hDatabase, 0, qIceM09GetCAByDir::szSQL));
		if (fHaveCATable)
		{
			ReturnIfFailed(9, 5, qGetCA.Open(hDatabase, qIceM09GetCA::szSQL));
		}
		
		// loop through each possible directory that is a target of one or more CAs
		while (ERROR_SUCCESS == (iStat = qGetCAByDir.Fetch(&hDir)))
		{
			// index into the directory array providing the target of the current action
			int iDir = 0;
			bool fFound = false;
			
			// get directory and check that it is actually a directory we are concerned about
			ReturnIfFailed(9, 6, IceRecordGetString(hDir, qIceM09GetCAByDir::Directory, &szCA, &cchCABuf, &cchCALen));

			for (iDir=0; iDir < cDirProperties; iDir++)
			{
				if (cchCALen > rgDirProperties[iDir].cch &&
				    0==_tcsncmp(rgDirProperties[iDir].tz, szCA, rgDirProperties[iDir].cch))
				{
					fFound = true;
					break;
				}
			}
			
			if (fFound)
			{
				if (!fHaveCATable)
				{
					ICEErrorOut(hInstall, hDir, IceM09NoCATable);
				}
				else
				{
					// we know we have found a target directory, now the concern is if we have found
					// an action with an appropriate property value
					enum {eiNone, eiWrongName, eiAllOK } eiFound = eiNone;
					
					// if we are concerned with this target, execute the query to fetch all records that
					// target this dir (there could be more than one)
					ReturnIfFailed(9, 7, qGetCA.Execute(hDir));

					TCHAR *szSource = NULL;
					TCHAR *szBuf = NULL;
					DWORD cchBuf = 72;
					DWORD cchSourceBuf = 72;
					DWORD cchLen = 0;
					DWORD cchSourceLen = 0;
					MSIHANDLE hCA;
					PMSIHANDLE hBestCA;
					
					// loop through each action targeting this directory
					while (ERROR_SUCCESS == (iStat = qGetCA.Fetch(&hCA)))
					{
						// first check that we are setting it to [Property]. If this action sets it to something else,
						// we assume its not intended to do the aliasing for this directory, rather has some other 
						// function. In that case we don't consider this a match. Otherwise, we do.
						ReturnIfFailed(9, 9, IceRecordGetString(hCA, qIceM09GetCA::Source, &szSource, &cchSourceBuf, &cchSourceLen));
						ReturnIfFailed(9, 10, IceRecordGetString(hCA, qIceM09GetCA::Target, &szBuf, &cchBuf, &cchLen));
						if ((cchLen != rgDirProperties[iDir].cch+2) || 
							(0 != _tcsncmp(rgDirProperties[iDir].tz, &szBuf[1], rgDirProperties[iDir].cch)) || 
							(szBuf[0] != TEXT('[')) || 
							(szBuf[rgDirProperties[iDir].cch+1] != TEXT(']')))
						{
							// action is setting directory to something else, so this is not a match
							MsiCloseHandle(hCA);
							continue;
						}

						// we have matched the Sounce and Target columns. We better have the same name for
						// this action or it could be very confusing!
						eiFound = eiWrongName;

						// we'll need our best result after the loop is done
						hBestCA = hCA;
						
						// if the action name does not match the directory name, the merge tool will generate
						// duplicate actions. Thats not a good thing.
						ReturnIfFailed(9, 11, IceRecordGetString(hCA, qIceM09GetCA::Action, &szBuf, &cchBuf, &cchLen));
						if (cchLen == cchSourceLen && 0 == _tcscmp(szBuf, szSource))
						{
							eiFound = eiAllOK;
							break;
						}
					}
					if (szSource) 
						delete[] szSource;
					if (szBuf)
						delete[] szBuf;
					if (eiFound != eiAllOK && ERROR_NO_MORE_ITEMS != iStat)
					{
						APIErrorOut(hInstall, iStat, 9, 12);
					}

					if (eiFound == eiWrongName)
					{
						ICEErrorOut(hInstall, hBestCA, IceM09WrongName);
					}
					else if (eiFound == eiAllOK)
					{
						// if we did find a matching action, we can verify that it appears in the 
						// sequence tables at the appropriate point.
						for (int iModTable=0; iModTable < cszModuleTables; iModTable++)
						{
							CQuery qModTable;
							PMSIHANDLE hAction;
							if (!IsTablePersistent(FALSE, hInstall, hDatabase, 8, rgszModuleTables[iModTable]) ||
								(ERROR_SUCCESS != (iStat = qModTable.FetchOnce(hDatabase, hBestCA, &hAction, qIceM09ModTable::szSQL, rgszModuleTables[iModTable]))))
							{
								// if the action does not exist in the sequence table or the table is missing, the merge tool will
								// generate it on the fly, so this is not an error
								continue;
							}

							// but if it does exist, it should have sequence number 1.
							if (MsiRecordGetInteger(hAction, qIceM09ModTable::Sequence) != 1)
							{
								ICEErrorOut(hInstall, hAction, IceM09BadSeqNum, rgszModuleTables[iModTable], rgszModuleTables[iModTable]);
								continue;
							}
						}
					}
				}
			}
		}
		delete[] szCA; 
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 9, 13);
		}		
	}

	
	// check that custom actions (if they exist) are in the correct sequence location
	
	return ERROR_SUCCESS;
};

///////////////////////////////////////////////////////////////////////
// ICEM10, Verifies that the module does not contain certain properties
//		The specific properties are reserved for products.  Utilizes the
//      _Disallowed table for the "disallowed" property reference.
ICE_QUERY1(qIce10Disallow, "SELECT `Property`.`Property` FROM `Property`, `_Disallowed` WHERE `Property`.`Property`=`_Disallowed`.`Property`", Property);

ICE_ERROR(IceM10DisallowedProperty, 10, ietError, "The property '[1]' is not allowed in a Merge Module","Property\tProperty\t[1]");

ICE_FUNCTION_DECLARATION(M10)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 10);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsPackageModule(hInstall, hDatabase, 10))
	{
		return ERROR_SUCCESS;
	}

	// check that merge module does not contain "disallowed" properties
	// tables needed are Property, _Disallowed
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 10, TEXT("Property"))
		&& IsTablePersistent(FALSE, hInstall, hDatabase, 10, TEXT("_Disallowed")))
	{
		CQuery qDisallowed;
		PMSIHANDLE hRec;
		ReturnIfFailed(10, 1, qDisallowed.OpenExecute(hDatabase, 0, qIce10Disallow::szSQL));
		while (ERROR_SUCCESS == (iStat = qDisallowed.Fetch(&hRec)))
		{
			ICEErrorOut(hInstall, hRec, IceM10DisallowedProperty);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 10, 2);
	}

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// ICEM11, Verifies that a configurable merge module (one with a 
// ModuleConfiguration or ModuleSubstitution table) correctly lists
// those two tables in the ModuleIgnoreTable table.
ICE_QUERY1(qIce11IgnoreModCTable, "SELECT `Table` FROM `ModuleIgnoreTable` WHERE `Table`='ModuleConfiguration'", Table);
ICE_QUERY1(qIce11IgnoreModSTable, "SELECT `Table` FROM `ModuleIgnoreTable` WHERE `Table`='ModuleSubstitution'", Table);

ICE_ERROR(IceM11IgnoreTable, 11, ietError, "The module contains a ModuleConfiguration or ModuleSubstitution table. These tables must be listed in the ModuleIgnoreTable table.","ModuleIgnoreTable");

ICE_FUNCTION_DECLARATION(M11)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 11);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsPackageModule(hInstall, hDatabase, 11))
	{
		return ERROR_SUCCESS;
	}

    PMSIHANDLE hOutRec = MsiCreateRecord(1);

	// check if either ModuleConfiguration table exits
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 11, TEXT("ModuleConfiguration")))
    {
        if (!IsTablePersistent(FALSE, hInstall, hDatabase, 11, TEXT("ModuleIgnoreTable")))
        {
            ICEErrorOut(hInstall, hOutRec, IceM11IgnoreTable);
            return ERROR_SUCCESS;
        }

		PMSIHANDLE hRec;
		CQuery qDisallowed;
		if (ERROR_SUCCESS != (iStat = qDisallowed.FetchOnce(hDatabase, 0, &hRec, qIce11IgnoreModCTable::szSQL)))
        {
            if (ERROR_NO_MORE_ITEMS == iStat)
            {
			    ICEErrorOut(hInstall, hOutRec, IceM11IgnoreTable);
            }
            else
                APIErrorOut(hInstall, iStat, 11, 1);
            return ERROR_SUCCESS;
        }
    }

    // check if either ModuleConfiguration table exits
    if (IsTablePersistent(FALSE, hInstall, hDatabase, 11, TEXT("ModuleSubstitution")))
    {
        if (!IsTablePersistent(FALSE, hInstall, hDatabase, 11, TEXT("ModuleIgnoreTable")))
        {
            ICEErrorOut(hInstall, hOutRec, IceM11IgnoreTable);
            return ERROR_SUCCESS;
        }


		PMSIHANDLE hRec;
		CQuery qDisallowed;
		if (ERROR_SUCCESS != (iStat = qDisallowed.FetchOnce(hDatabase, 0, &hRec, qIce11IgnoreModSTable::szSQL)))
        {
            if (ERROR_NO_MORE_ITEMS == iStat)
            {
			    ICEErrorOut(hInstall, hOutRec, IceM11IgnoreTable);
            }
            else
                APIErrorOut(hInstall, iStat, 11, 1);
            return ERROR_SUCCESS;
        }
	}

	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// ICE-M12, Verifies that in ModuleSequence tables, if the Action
// column is standard action, the BaseAction and After columns are
// null.

// Add a tmp column to a ModuleSequence table to filter out the custom actions.
ICE_QUERY0(sqlIceM12AddMarker, "ALTER TABLE `%s` ADD `Marker` INTEGER TEMPORARY");
// Initialize the Marker column.
ICE_QUERY0(sqlIceM12InitMarker, "UPDATE `%s` SET `Marker` = 0");
// Set the Marker column.
ICE_QUERY0(sqlIceM12UpdateMarker, "UPDATE `%s` SET `Marker` = 1 WHERE `Action` = ?");
// Fetch all records that is a custom action or a dialog from the ModuleSequence tables.
ICE_QUERY4(sqlIceM12CA, "SELECT DISTINCT `%s`.`Action`, `%s`.`Sequence`, `%s`.`BaseAction`, `%s`.`After` FROM `%s`, `CustomAction`, `Dialog` WHERE `%s`.Action = `CustomAction`.Action OR `%s`.Action = `Dialog`.Dialog", Action, Sequence, BaseAction, After);
// Fetch all records that is a custom action from the ModuleSequence tables when there is no dialog table.
ICE_QUERY4(sqlIceM12CAnoDialog, "SELECT `%s`.`Action`, `%s`.`Sequence`, `%s`.`BaseAction`, `%s`.`After` FROM `%s`, `CustomAction` WHERE `%s`.Action = `CustomAction`.Action", Action, Sequence, BaseAction, After);
// Fetch all non-custom action records from the ModuleSequence tables base on
// a tmp column.
ICE_QUERY4(sqlIceM12SA, "SELECT `%s`.`Action`, `%s`.`Sequence`, `%s`.`BaseAction`, `%s`.`After` FROM `%s` WHERE `%s`.Marker = 0", Action, Sequence, BaseAction, After);
// If there's no CustomAction table, assume that all records from a
// ModuleSequence table are standard actions.
ICE_QUERY4(sqlIceM12SAnoCA, "SELECT `%s`.`Action`, `%s`.`Sequence`, `%s`.`BaseAction`, `%s`.`After` FROM `%s`", Action, Sequence, BaseAction, After);
// predefined errors
ICE_ERROR(IceM12SAError1, 12, ietError, "Standard actions should not use the BaseAction and After fields in Module Sequence tables. The standard action `[1]` has a values entered in the BaseAction or After fields of the %s table.", "%s\tAction\t[1]");
ICE_ERROR(IceM12SAError2, 12, ietError, "Standard actions must have a entry in the Sequence field of Module Sequence tables. The standard action `[1]` does not have a Sequence value in the %s table.", "%s\tAction\t[1]");
ICE_ERROR(IceM12CAError, 12, ietError, "Custom actions and dialogs should not leave the Sequence, BaseAction, and After fields of the Module Sequence tables all empty. The custom action `[1]` leaves the Sequence, BaseAction, and After fields empty in the %s table.", "%s\tAction\t[1]");
ICE_ERROR(IceM12CAWarning, 12, ietWarning, "Custom actions and dialogs should use the BaseAction and After fields and not use the Sequence field in the Module Sequence tables. The custom action `[1]` uses the Sequence field  and does not use the the BaseAction and After fields in the %s table.", "%s\tSequence\t[1]");
ICE_ERROR(IceM12AllActionError, 12, ietError, "An action can not use all of the Sequence, BaseAction and After fields. The action `[1]` in the %s table uses all of Sequence, BaseAction and After fields.", "%s\tAction\t[1]");
ICE_FUNCTION_DECLARATION(M12)
{
	UINT		iStat;
	CQuery		qSA, qCA;	// queries for standard actions and custom actions
	CQuery		qAddMarker, qInitMarker, qUpdateMarker;
	PMSIHANDLE	hRec;
	BOOL		bCATableExist = FALSE; // Does CustomAction table exist?
	BOOL		bDialogTableExist = FALSE; // Does the Dialog table exist?
	TCHAR*		pszAction = NULL;
	DWORD		dwAction = 72;
	PMSIHANDLE	hUpdateMarker = ::MsiCreateRecord(1);


	//
	// display info
	//

	DisplayInfo(hInstall, 12);

	//
	// get database handle
	//

	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	//
	// Make sure this is a merge module.
	//

	if (!IsPackageModule(hInstall, hDatabase, 12))
	{
		return ERROR_SUCCESS;
	}

	//
	// Does the CustomAction table exist? CustomAction table will always be
	// present through the validation process so bCATableExist will always
	// be TRUE.
	//

	if(IsTablePersistent(FALSE, hInstall, hDatabase, 12, TEXT("CustomAction")))
	{
		bCATableExist = TRUE;
	}

	//
	// Does the Dialog table exist?
	//
	
	if(IsTablePersistent(FALSE, hInstall, hDatabase, 12, TEXT("Dialog")))
	{
		bDialogTableExist = TRUE;
	}

	//
	// Validate every module sequence table in the database.
	//

	for(int i = 0; i < cszModuleTables; i++)
	{
		if(IsTablePersistent(FALSE, hInstall, hDatabase, 12, rgszModuleTables[i]))
		{
			//
			// Do custom actions first. If CustomAction table does not exist,
			// then assume there are no custom actions.
			//

			if(bCATableExist)
			{
				//
				// Set and initialize the temporary column in this
				// ModuleSequence table so that we can mark custom action
				// records and filter them out when we query for standard
				// action records.
				//

				ReturnIfFailed(12, 1, qAddMarker.OpenExecute(hDatabase, 0, sqlIceM12AddMarker::szSQL, rgszModuleTables[i]));
				ReturnIfFailed(12, 2, qInitMarker.OpenExecute(hDatabase, 0, sqlIceM12InitMarker::szSQL, rgszModuleTables[i]));
				ReturnIfFailed(12, 3, qUpdateMarker.Open(hDatabase, sqlIceM12UpdateMarker::szSQL, rgszModuleTables[i]));

				//
				// Fetch the custom action records from this table.
				//

				if(bDialogTableExist)
				{
					ReturnIfFailed(12, 4, qCA.OpenExecute(hDatabase,
														  0,
														  sqlIceM12CA::szSQL,
														  rgszModuleTables[i],
														  rgszModuleTables[i],
														  rgszModuleTables[i],
														  rgszModuleTables[i],
														  rgszModuleTables[i],
														  rgszModuleTables[i],
														  rgszModuleTables[i]));
				}
				else
				{
					ReturnIfFailed(12, 4, qCA.OpenExecute(hDatabase,
														  0,
														  sqlIceM12CAnoDialog::szSQL,
														  rgszModuleTables[i],
														  rgszModuleTables[i],
														  rgszModuleTables[i],
														  rgszModuleTables[i],
														  rgszModuleTables[i],
														  rgszModuleTables[i]));
				}

				while(ERROR_SUCCESS == (iStat = qCA.Fetch(&hRec)))
				{
					//
					// Get Action.
					//

					ReturnIfFailed(12, 5, IceRecordGetString(hRec, sqlIceM12CA::Action, &pszAction, &dwAction, NULL));
					
					//
					// Set the Marker.
					//

					::MsiRecordClearData(hUpdateMarker);
					::MsiRecordSetString(hUpdateMarker, 1, pszAction);
					ReturnIfFailed(12, 6, qUpdateMarker.Execute(hUpdateMarker));

					if(::MsiRecordIsNull(hRec, sqlIceM12CA::Sequence) == FALSE)
					{
						//
						// If a custom action has a sequence #, give a warning.
						//
						
						ICEErrorOut(hInstall, hRec, IceM12CAWarning, rgszModuleTables[i], rgszModuleTables[i]);

						//
						// If it has both sequence # and BaseAction/After values, give an error.
						//

						if(::MsiRecordIsNull(hRec, sqlIceM12CA::BaseAction) == FALSE || ::MsiRecordIsNull(hRec, sqlIceM12CA::After) == FALSE)
						{
							ICEErrorOut(hInstall, hRec, IceM12AllActionError, rgszModuleTables[i], rgszModuleTables[i]);
						}
					}
					else if(::MsiRecordIsNull(hRec, sqlIceM12CA::BaseAction) == TRUE || ::MsiRecordIsNull(hRec, sqlIceM12CA::After) == TRUE)
					{
						//
						// If a custom action doesn't have sequence #, nor does it
						// have BaseAction/After values, give an error.
						//

						ICEErrorOut(hInstall, hRec, IceM12CAError, rgszModuleTables[i], rgszModuleTables[i]);
					}
				}
				if(ERROR_NO_MORE_ITEMS != iStat)
				{
					APIErrorOut(hInstall, iStat, 12, 7);
				}

				DELETE_IF_NOT_NULL(pszAction);

				//
				// Close this query so we can reuse it for the next table.
				//

				ReturnIfFailed(12, 8, qCA.Close());
			}

			//
			// Now do standard actions.
			//

			if(bCATableExist)
			{
				ReturnIfFailed(12, 9, qSA.OpenExecute(hDatabase,
													  0,
													  sqlIceM12SA::szSQL,
													  rgszModuleTables[i],
													  rgszModuleTables[i],
													  rgszModuleTables[i],
													  rgszModuleTables[i],
													  rgszModuleTables[i],
													  rgszModuleTables[i]));
			}
			else
			{
				//
				// This code will not be executed because bCATableExist will
				// always be TRUE.

				ReturnIfFailed(12, 10, qSA.OpenExecute(hDatabase,
													   0,
													   sqlIceM12SAnoCA::szSQL,
													   rgszModuleTables[i],
													   rgszModuleTables[i],
													   rgszModuleTables[i],
													   rgszModuleTables[i],
													   rgszModuleTables[i]));
			}

			while(ERROR_SUCCESS == (iStat = qSA.Fetch(&hRec)))
			{
				//
				// If a standard action has BaseAction/After values then give
				// an error.
				//

				if(::MsiRecordIsNull(hRec, sqlIceM12CA::BaseAction) == FALSE ||
				   ::MsiRecordIsNull(hRec, sqlIceM12SA::After) == FALSE)
				{
					ICEErrorOut(hInstall, hRec, IceM12SAError1, rgszModuleTables[i], rgszModuleTables[i]);

					//
					// If an action has both BaseAction/After values and
					// sequence # then give an error.
					//

					if(::MsiRecordIsNull(hRec, sqlIceM12SA::Sequence) == FALSE)
					{
						ICEErrorOut(hInstall, hRec, IceM12AllActionError, rgszModuleTables[i], rgszModuleTables[i]);
					}
				}

				//
				// If a standard action doesn't have a sequence # then give an
				// error.
				//

				if(::MsiRecordIsNull(hRec, sqlIceM12SA::Sequence) == TRUE)
				{
					ICEErrorOut(hInstall, hRec, IceM12SAError2, rgszModuleTables[i], rgszModuleTables[i]);
				}
			}
			if(ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 12, 11);
			}

			//
			// Close this query so we can reuse it for the next table.
			//

			ReturnIfFailed(12, 12, qSA.Close());
		}
	}

	return ERROR_SUCCESS;
};


///////////////////////////////////////////////////////////////////////
// ICE-M13, Verifies that Merge Module Database does not contain 
// Policy Assemblies

// Fetch all records that contains Policy in the name in MsiAssemblyName table
ICE_QUERY2(sqlIceM13MsiAssemblyName, "SELECT `Component_`, `Value` FROM `MsiAssemblyName` WHERE `Name` = 'Name' OR `Name` = 'NAME' or `Name` = 'name'", Component_, Value);

// Error Messages
ICE_ERROR(IceM13PolicyAssembly, 13, ietWarning, "This entry Component_=`[1]` in MsiAssembly Table is a Policy/Configuration Assembly. A Publisher Policy/Configuration assembly should not be redistributed with a merge module. Policy/Configuration may impact other applications and should only be installed with products.", "MsiAssembly\tComponent_\t[1]");


#define POLICYSTR  TEXT("Policy")

ICE_FUNCTION_DECLARATION(M13)
{
	UINT		iStat;
	CQuery		qAssemblyName;	// queries for Name records in MsiAssemblyName
	PMSIHANDLE	hRec;
#define M13_BUFFSZ 256
	TCHAR*		pszStr = new TCHAR[M13_BUFFSZ];
	DWORD		dwStrSize = M13_BUFFSZ-1;


	//
	// display info
	//

	DisplayInfo(hInstall, 13);

	//
	// get database handle
	//

	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	//
	// Make sure this is a merge module.
	//

	if (!IsPackageModule(hInstall, hDatabase, 13))
	{
		goto Success;
	}

	//
	// Does both MsiAssembly & MsiAssemblyName exist.
	//

	if(	!IsTablePersistent(FALSE, hInstall, hDatabase, 13, TEXT("MsiAssembly"))
	||	!IsTablePersistent(FALSE, hInstall, hDatabase, 13, TEXT("MsiAssemblyName"))
	)
	{
		goto Success;
		
	}

	iStat = qAssemblyName.OpenExecute(hDatabase, 0, sqlIceM13MsiAssemblyName::szSQL);
	if(iStat)
	{
		APIErrorOut(hInstall, iStat, 13, __LINE__);
		goto Error;
	}

	while(ERROR_SUCCESS == (iStat = qAssemblyName.Fetch(&hRec)))
	{
		iStat = IceRecordGetString(hRec, sqlIceM13MsiAssemblyName::Value, &pszStr, &dwStrSize, NULL);
		if(iStat)
		{
			APIErrorOut(hInstall, iStat, 13, __LINE__);
			goto Error;
		}
	
		if(!_tcsnicmp(pszStr, POLICYSTR, ((sizeof(POLICYSTR)/sizeof(TCHAR))-1)))
		{
			ICEErrorOut(hInstall, hRec, IceM13PolicyAssembly);
		}
	}
					
	if(ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 13, 7);
		goto Error;
	}
Error:
Success:

	DELETE_IF_NOT_NULL(pszStr);

	return ERROR_SUCCESS;
};


///////////////////////////////////////////////////////////////////////
// ICEM14. Verifies that Value Column of ModuleSubstitution table is
// correct.

ICE_ERROR(IceM14MissingTable, 14, ietWarning, "ModuleSubstitution table exists but ModuleConfiguration table is missing.", "");
ICE_ERROR(IceM14MissingString, 14, ietError, "The replacement string in ModuleSubstitution.Value column in row [1].[2].[3] is not found in ModuleConfiguration table.", "ModuleSubstitution\tValue\t[1]\t[2]\t[3]");
ICE_ERROR(IceM14DisallowedConfig, 14, ietError, "In ModuleSubstitution table in row [1].[2].[3], a configurable item is indicated in the table '%s'. The table '%s' must not contain configurable items.", "ModuleSubstitution\tTable\t[1]\t[2]\t[3]");
ICE_ERROR(IceM14EmptyString, 14, ietError, "In ModuleSubstitution table in row [1].[2].[3], an empty replacement string is specified.", "ModuleSubstitution\tValue\t[1]\t[2]\t[3]");

ICE_QUERY4(sqlIceM14Value, "SELECT `Table`, `Row`, `Column`, `Value` FROM `ModuleSubstitution` WHERE `Value` is not null", Table, Row, Column, Value);
ICE_QUERY1(sqlIceM14Name, "SELECT `Name` FROM `ModuleConfiguration` WHERE `Name` = '%s'", Name);
ICE_QUERY4(sqlIceM14Table, "SELECT `Table`, `Row`, `Column`, `Value` FROM `ModuleSubstitution` WHERE `Table` = '%s'", Table, Row, Column, Value);

static const TCHAR* IceM14Tables[] =
{
	TEXT("ModuleSubstitution"),
	TEXT("ModuleConfiguration"),
	TEXT("ModuleExclusion"),
	TEXT("ModuleSignature")
};

void ValidateValue(MSIHANDLE hDatabase, MSIHANDLE hInstall, MSIHANDLE hValue, TCHAR* pValue)
{
	TCHAR*	pTmp = pValue;
	
	while(*pTmp != TEXT('\0'))
	{
		if(*pTmp == TEXT('['))
		{
			if(*(pTmp + 1) == TEXT('='))
			{
				TCHAR*	pEnd = pTmp + 2;
				TCHAR*	pSemiColon = NULL;

				// Found a "[=". Now look for the ending ']'.
				while(*pEnd != TEXT('\0') && *pEnd != TEXT(']'))
				{
					if(*pEnd == TEXT('\\'))
					{
						pEnd = pEnd + 2;
					}
					else
					{
						if(*pEnd == TEXT(';'))
						{
							pSemiColon = pEnd;
						}
						pEnd++;
					}
				}
				if(*pEnd == TEXT(']'))
				{
					if(pEnd == pTmp + 2)
					{
						ICEErrorOut(hInstall, hValue, IceM14EmptyString);
					}
					else
					{
						CQuery		qName;
						UINT		iStat;
						PMSIHANDLE	hName;
						TCHAR		szName[73];

						if(pSemiColon == NULL)
						{
							*pEnd = TEXT('\0');
						}
						else
						{
							*pSemiColon = TEXT('\0');
						}
						
						if((iStat = qName.FetchOnce(hDatabase, 0, &hName, sqlIceM14Name::szSQL, pTmp + 2)) == ERROR_NO_MORE_ITEMS)
						{
							// The replacement string is not in the ModuleConfiguration table.
							ICEErrorOut(hInstall, hValue, IceM14MissingString);
						}
						else if(iStat != ERROR_SUCCESS)
						{
							APIErrorOut(hInstall, iStat, 14, __LINE__);
						}

						if(pSemiColon == NULL)
						{
							*pEnd = TEXT(']');
						}
						else
						{
							*pSemiColon = TEXT(';');
						}
					}
				}

				// Advance pTmp to after the replacement string.
				if(pEnd != TEXT('\0'))
				{
					pTmp = pEnd + 1;
				}
				else
				{
					pTmp = pEnd;
				}
			}
			else if(*(pTmp + 1) == TEXT('\\'))
			{
				pTmp = pTmp + 2;
			}
			else
			{
				pTmp++;
			}
		}
		else if(*pTmp == TEXT('\\'))
		{
			pTmp = pTmp + 2;
		}
		else
		{
			pTmp++;
		}
	}
}

ICE_FUNCTION_DECLARATION(M14)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 14);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if(!IsPackageModule(hInstall, hDatabase, 14))
	{
		return ERROR_SUCCESS;
	}

	// Return success if no ModuleSubstitution table.
	if(!IsTablePersistent(false, hInstall, hDatabase, 14, TEXT("ModuleSubstitution")))
	{
		return ERROR_SUCCESS;
	}

	// Post warning if ModuleSubstitution table exists but ModuleConfiguration
	// table doesn't.
	if(!IsTablePersistent(false, hInstall, hDatabase, 14, TEXT("ModuleConfiguration")))
	{
		PMSIHANDLE hRecError = ::MsiCreateRecord(1);

		ICEErrorOut(hInstall, hRecError, IceM14MissingTable);
		return ERROR_SUCCESS;
	}

	// Validate that tables in IceM14Tables are not configurable.
	CQuery		qTable;
	PMSIHANDLE	hTable;

	for(int i = 0; i < sizeof(IceM14Tables) / sizeof(TCHAR*); i++)
	{
		ReturnIfFailed(14, __LINE__, qTable.OpenExecute(hDatabase, NULL, sqlIceM14Table::szSQL, IceM14Tables[i]));

		while((iStat = qTable.Fetch(&hTable)) == ERROR_SUCCESS)
		{
			ICEErrorOut(hInstall, hTable, IceM14DisallowedConfig, IceM14Tables[i], IceM14Tables[i]);
		}
		if(iStat != ERROR_NO_MORE_ITEMS)
		{
			APIErrorOut(hInstall, iStat, 14, __LINE__);
			return ERROR_SUCCESS;
		}
	}
	qTable.Close();

	// Validate Value column of ModuleSubstitution table.
	CQuery		qValue;
	PMSIHANDLE	hValue;

	ReturnIfFailed(14, __LINE__, qValue.OpenExecute(hDatabase, NULL, sqlIceM14Value::szSQL));

	TCHAR*	pValue = NULL;
	DWORD	dwBuffer = 0;

	while((iStat = qValue.Fetch(&hValue)) == ERROR_SUCCESS)
	{
		ReturnIfFailed(14, __LINE__, IceRecordGetString(hValue, sqlIceM14Value::Value, &pValue, &dwBuffer, NULL));

		ValidateValue(hDatabase, hInstall, hValue, pValue);
	}
	qValue.Close();
	if(pValue != NULL)
	{
		delete [] pValue;
	}
	if(iStat != ERROR_NO_MORE_ITEMS)
	{
		APIErrorOut(hInstall, iStat, 14, __LINE__);
		return ERROR_SUCCESS;
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\msiice.dll\msiice2.cpp ===
/* msiice2.cpp - Darwin  ICE06-15 code  Copyright  1998-1999 Microsoft Corporation
____________________________________________________________________________*/

#include <windows.h>  // included for both CPP and RC passes
#include <objbase.h>
#include <stdio.h>    // printf/wprintf
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "msidefs.h"  // must be in this directory or on INCLUDE path
#include "..\..\common\msiice.h"
#include "..\..\common\query.h"

//////////////////////////////////////////////////////////////
// sequence table listing
//
const TCHAR* pSeqTables[] = 
							{TEXT("AdvtExecuteSequence"), 
							 TEXT("AdvtUISequence"), 
							 TEXT("AdminExecuteSequence"), 
							 TEXT("AdminUISequence"),
							 TEXT("InstallExecuteSequence"), 
							 TEXT("InstallUISequence")};

const int cTables = sizeof(pSeqTables)/sizeof(TCHAR*);


/////////////////////////////////////////////////////////////
// ICE06 -- checks for missing columns.  If a column is
//   optional and not included in the database, then it
//   should not be listed in the _Validation table.  This
//   is the responsibility of some other tool or the author.
//
const TCHAR sqlIce06ColMissing[]      = TEXT("SELECT `Table`, `Number`, `Name`, `Type` FROM `_Columns` WHERE `Table`=? AND `Name`=?");
const TCHAR sqlIce06ValidationTable[] = TEXT("SELECT `Table`, `Column` FROM `_Validation`, `_Tables` WHERE `_Validation`.`Table` = `_Tables`.`Name`");
ICE_ERROR(Ice06Error, 6, 2, "Column: [2] of Table: [1] is not defined in database.","[1]");

ICE_FUNCTION_DECLARATION(06)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// post information messages
	DisplayInfo(hInstall, 6);
	
	// declare handles
	CQuery qValidation;
	CQuery qColCatalog;
	PMSIHANDLE hRecValidation    = 0;
	PMSIHANDLE hRecColCatalog    = 0;
	PMSIHANDLE hRecExec          = 0;

	// get database 
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	
	// open views on _Columns and Validation
	ReturnIfFailed(6, 1, qColCatalog.Open(hDatabase, sqlIce06ColMissing));
	ReturnIfFailed(6, 2, qValidation.OpenExecute(hDatabase, 0, sqlIce06ValidationTable));

	// create execution record for _Columns catalog
	hRecExec = ::MsiCreateRecord(2);
	
	while (ERROR_SUCCESS == (iStat = qValidation.Fetch(&hRecValidation)))
	{
		ReturnIfFailed(6, 3, qColCatalog.Execute(hRecValidation));

		iStat = qColCatalog.Fetch(&hRecColCatalog);
		if (iStat == ERROR_NO_MORE_ITEMS)
		{
			// ERROR -- missing from database
			ICEErrorOut(hInstall, hRecValidation, Ice06Error);
		}
		else if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 6, 4);
			return ERROR_SUCCESS;
		}

	}
	if (iStat != ERROR_NO_MORE_ITEMS)
	{
		APIErrorOut(hInstall, iStat, 6, 5);
		return ERROR_SUCCESS;
	}
	return ERROR_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////
// ICE07 -- ensures that fonts are installed to the fonts folder
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR sqlIce07[]     = TEXT("SELECT `Font`.`File_`, `Component`.`Directory_` FROM `File`, `Component`, `Font` WHERE `Font`.`File_`=`File`.`File` AND `File`.`Component_`=`Component`.`Component` AND `Component`.`Directory_` <> 'FontsFolder'");
ICE_ERROR(Ice07Error, 7, 2, "'[1]' is a Font and must be installed to the FontsFolder. Current Install Directory: '[2]'","Font\tFile_\t[1]");

ICE_FUNCTION_DECLARATION(07)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// post information messages
	DisplayInfo(hInstall, 7);

	// grab database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// only execute if database has a Font table, file table, and a component table.
	// note, this is not an *error* if this table is missing
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 7, TEXT("Font")) ||
		!IsTablePersistent(FALSE, hInstall, hDatabase, 7, TEXT("File")) ||
		!IsTablePersistent(FALSE, hInstall, hDatabase, 7, TEXT("Component")))
		return ERROR_SUCCESS;

	// declare handles
	CQuery qView;
	PMSIHANDLE hRecFetch = 0;

	// process query...any fetch is a font not installed to the FontsFolder.
	// note, process is get File_ from Font table, then get Component_ it maps to and get Directory_ from the Component
	ReturnIfFailed(7, 1, qView.OpenExecute(hDatabase, 0, sqlIce07));
	
	// begin to fetch invalid entries
	while (ERROR_SUCCESS == (iStat = qView.Fetch(&hRecFetch)))
	{
		ICEErrorOut(hInstall, hRecFetch, Ice07Error);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 7, 2);

	// return
	return ERROR_SUCCESS;
}
#endif

//////////////////////////////////////////////////////////////////////////
// ICE10 -- ensures that the advertise states for feature childs and 
//   corresponding feature parents match
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR sqlIce10Child[]  = TEXT("SELECT `Feature`, `Feature_Parent`, `Attributes` FROM `Feature` WHERE `Feature_Parent` is not null ORDER BY `Feature_Parent`");
const TCHAR sqlIce10Parent[] = TEXT("SELECT `Attributes` FROM `Feature` WHERE `Feature`=?"); 
const TCHAR szIce10Error1[]  = TEXT("ICE10\t1\tConflicting states.  One favors, one disallows advertise.  Child feature: [1] differs in advertise state from Parent: [2]\t%s%s\tFeature\tAttributes\t[1]");
const TCHAR szIce10Error2[]  = TEXT("ICE10\t1\tParent feature: [2] not found for child feature: [1]\t%s%s\tFeature\tFeature_Parent\t[1]");
const int iIce10AdvtMask     = msidbFeatureAttributesFavorAdvertise | msidbFeatureAttributesDisallowAdvertise;

ICE_FUNCTION_DECLARATION(10)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// post information messages
	DisplayInfo(hInstall, 10);
	
	// grab database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, szIce10, TEXT("MsiGetActiveDatabase_1"));
		return ERROR_SUCCESS;
	}

	// do we have a feature table?
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, TEXT("Feature"), szIce10))
		return ERROR_SUCCESS;

	// declare handles
	PMSIHANDLE hViewChild  = 0;
	PMSIHANDLE hViewParent = 0;
	PMSIHANDLE hRecChild   = 0;
	PMSIHANDLE hRecParent  = 0;
	PMSIHANDLE hRecExec    = 0;

	// open view on child features
	if (ERROR_SUCCESS != (iStat = ::MsiDatabaseOpenView(hDatabase, sqlIce10Child, &hViewChild)))
	{
		APIErrorOut(hInstall, iStat, szIce10, TEXT("MsiDatabaseOpenView_2"));
		return ERROR_SUCCESS;
	}
	if (ERROR_SUCCESS != (iStat = ::MsiViewExecute(hViewChild, 0)))
	{
		APIErrorOut(hInstall, iStat, szIce10, TEXT("MsiViewExecute_3"));
		return ERROR_SUCCESS;
	}

	// open view on parent features
	if (ERROR_SUCCESS != (iStat = ::MsiDatabaseOpenView(hDatabase, sqlIce10Parent, &hViewParent)))
	{
		APIErrorOut(hInstall, iStat, szIce10, TEXT("MsiDatabaseOpenView_4"));
		return ERROR_SUCCESS;
	}

	// set up execution record
	hRecExec = ::MsiCreateRecord(1);
	if (0 == hRecExec)
	{
		APIErrorOut(hInstall, 0, szIce10, TEXT("MsiCreateRecord_5"));
		return ERROR_SUCCESS;
	}

	// fetch all features w/ parents so we can compare advertise attribs
	//!! could make faster if order by feature_parent so not always re-executing
	TCHAR *pszParent = NULL;
	TCHAR *pszPrevious = NULL;
	DWORD dwParent = 512;

	BOOL fFirstTime = TRUE;
	int iParentAttrib = 0;
	int iChildAttrib = 0;
	for (;;)
	{
		iStat = ::MsiViewFetch(hViewChild, &hRecChild);
		if (ERROR_SUCCESS != iStat && ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, szIce10, TEXT("MsiViewFetch_6"));
			DELETE_IF_NOT_NULL(pszParent);
			DELETE_IF_NOT_NULL(pszPrevious);
			return ERROR_SUCCESS;
		}

		if (ERROR_NO_MORE_ITEMS == iStat)
			break;

		// now obtain feature's parent & save to limit number of times we have to execute the Feature_Parent view
		if (ERROR_SUCCESS != (iStat = IceRecordGetString(hRecChild, 2, &pszParent, &dwParent, NULL)))
		{
			APIErrorOut(hInstall, iStat, szIce10, TEXT("IceRecordGetString_7"));
			DELETE_IF_NOT_NULL(pszParent);
			DELETE_IF_NOT_NULL(pszPrevious);
			return ERROR_SUCCESS;
		}

		// if Feature_Parent has changed, close view and re-execute (& not first time thru loop)
		if (!pszPrevious || _tcscmp(pszPrevious, pszParent) != 0)
		{
			if (!fFirstTime)
			{
				if (ERROR_SUCCESS != (iStat = ::MsiViewClose(hViewParent)))
				{
					APIErrorOut(hInstall, iStat, szIce10, TEXT("MsiViewClose_8"));
					DELETE_IF_NOT_NULL(pszParent);
					DELETE_IF_NOT_NULL(pszPrevious);
					return ERROR_SUCCESS;
				}
			}
			
			// re-execute view
			if (ERROR_SUCCESS != (iStat = ::MsiRecordSetString(hRecExec, 1, pszParent)))
			{
				APIErrorOut(hInstall, iStat, szIce10, TEXT("MsiRecordSetString_9"));
				DELETE_IF_NOT_NULL(pszParent);
				DELETE_IF_NOT_NULL(pszPrevious);
				return ERROR_SUCCESS;
			}
			if (ERROR_SUCCESS != (iStat = ::MsiViewExecute(hViewParent, hRecExec)))
			{
				APIErrorOut(hInstall, iStat, szIce10, TEXT("MsiViewExecute_10"));
				DELETE_IF_NOT_NULL(pszParent);
				DELETE_IF_NOT_NULL(pszPrevious);
				return ERROR_SUCCESS;
			}
			// fetch record and store attributes value
			iStat = ::MsiViewFetch(hViewParent, &hRecParent);
			if (ERROR_SUCCESS != iStat && ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, szIce10, TEXT("MsiViewFetch_11"));
				DELETE_IF_NOT_NULL(pszParent);
				DELETE_IF_NOT_NULL(pszPrevious);
				return ERROR_SUCCESS;
			}
			if (iStat != ERROR_SUCCESS)
			{
				// Parent of feature not found in Feature table, ERROR
				TCHAR szError[iHugeBuf] = {0};
				_stprintf(szError, szIce10Error2, szIceHelp, szIce10Help);
				
				::MsiRecordSetString(hRecChild, 0, szError);
				::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecChild);
				continue;
			}

			// get attributes of parent
			iParentAttrib = ::MsiRecordGetInteger(hRecParent, 1);

			// copy to szPrevious
			DELETE_IF_NOT_NULL(pszPrevious);
			pszPrevious = new TCHAR[_tcslen(pszParent) + 1];
			_tcscpy(pszPrevious, pszParent);
		}

		// obtain attributes of child
		iChildAttrib = ::MsiRecordGetInteger(hRecChild, 3);

		//NOTE:  the possibility of both attributes (favor, disallow) checked for a particular 
		// feature is already validated in _Validation table (all possible allowable combinations
		// are listed in the set column

		// check to see if child and parent attributes match
		//NOTE:  one can be zero.  Only ERROR if one favors and one disallows
		if ((iParentAttrib & iIce10AdvtMask) != (iChildAttrib & iIce10AdvtMask))
		{
			// differ, make sure one not zero
			if (((iParentAttrib & iIce10AdvtMask) == 0) || ((iChildAttrib & iIce10AdvtMask) == 0))
				continue; // no error

			// per bug 146601, the parent disallow and child allow combination is valid
			if (iChildAttrib & msidbFeatureAttributesFavorAdvertise)
				continue; // no error

			// ERROR, one favors, one disallows
			TCHAR szError[iHugeBuf] = {0};
			_stprintf(szError, szIce10Error1, szIceHelp, szIce10Help);
			
			::MsiRecordSetString(hRecChild, 0, szError);
			::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecChild);
			continue;
		}
	}

	// Deallocate memory.
	DELETE_IF_NOT_NULL(pszParent);
	DELETE_IF_NOT_NULL(pszPrevious);

	// return
	return ERROR_SUCCESS;
}
#endif

//////////////////////////////////////////////////////////////////////////
// ICE11 -- checks that Nested Install custom actions have a valid GUID 
//   (MSI product code) in the Source column
//
const TCHAR sqlIce11[]         = TEXT("SELECT `Action`, `Source` FROM `CustomAction` WHERE `Type`=%d OR `Type`=%d OR `Type`=%d OR `Type`=%d");
const TCHAR sqlIce11Property[] = TEXT("SELECT `Value` FROM `Property` WHERE `Property`='ProductCode'");
const TCHAR szIce11Error1[]    = TEXT("ICE11\t1\tCustomAction: [1] is a nested install of an advertised MSI.  The 'Source' must contain a valid MSI product code.  Current: [2].\t%s%s\tCustomAction\tSource\t[1]");
const TCHAR szIce11Error2[]    = TEXT("ICE11\t1\t'ProductCode' property not found in Property Table.  Cannot compare nested install GUID.\t%s%s\tProperty");
const TCHAR szIce11Error3[]    = TEXT("ICE11\t1\tCustomAction: [1] is a nested install of an advertised MSI.  It duplicates the ProductCode of the base MSI package.  Current: [2].\t%s%s\tCustomAction\tSource\t[1]");
const TCHAR szIce11Error4[]    = TEXT("ICE11\t1\tCustomAction: [1] is a nested install of an advertised MSI.  The GUID must be all upper-case.  Current: [2].\t%s%s\tCustomAction\tSource\t[1]");

// use msidefs.h defines when NestedInstall stuff added
const int iIce11NestedGUIDMask = msidbCustomActionTypeInstall | msidbCustomActionTypeDirectory;
const int iIce11AsyncMask = iIce11NestedGUIDMask | msidbCustomActionTypeAsync;
const int iIce11IgnoreRetMask = iIce11NestedGUIDMask | msidbCustomActionTypeContinue;
const int iIce11AllMask = iIce11IgnoreRetMask | iIce11AsyncMask;

ICE_FUNCTION_DECLARATION(11)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// post information messages
	DisplayInfo(hInstall, 11);

	
	// grab database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, szIce11, TEXT("MsiGetActiveDatabase_1"));
		return ERROR_SUCCESS;
	}

	// handles
	PMSIHANDLE hView = 0;
	PMSIHANDLE hRec  = 0;

	// do we have a custom action table?
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, TEXT("CustomAction"), szIce11))
		return ERROR_SUCCESS;

	// open view
	TCHAR sql[iHugeBuf] = {0};
	_stprintf(sql, sqlIce11, iIce11NestedGUIDMask, iIce11AsyncMask, iIce11IgnoreRetMask, iIce11AllMask);
	
	if (ERROR_SUCCESS != (iStat = ::MsiDatabaseOpenView(hDatabase, sql, &hView)))
	{
		APIErrorOut(hInstall, iStat, szIce11, TEXT("MsiDatabaseOpenView_2"));
		return ERROR_SUCCESS;
	}

	if (ERROR_SUCCESS != (iStat = ::MsiViewExecute(hView, 0)))
	{
		APIErrorOut(hInstall, iStat, szIce11, TEXT("MsiViewExecute_3"));
		return ERROR_SUCCESS;
	}

	// ensure GUID does not duplicate the Product Code of this database
	// if does, ERROR - would lead to a recursive install of the same product (would be _very_ bad)
	// handles
	PMSIHANDLE hViewProp = 0;
	PMSIHANDLE hRecProp  = 0;
	BOOL fProductCode = TRUE;
	BOOL fPropertyTable = TRUE;

	// do we have a property table?
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, TEXT("Property"), szIce11))
		fPropertyTable = FALSE;

	// fetch all custom actions of type 39 or 167 (39 + 128 [async]) or  103 (39 + 64 [ignore ret]) or 192 (39 + [async] + [ignore ret])
	BOOL fFirstTime = TRUE;
	TCHAR* pszProductCode = NULL;
	DWORD dwProductCode = 512;
	for (;;)
	{
		iStat = ::MsiViewFetch(hView, &hRec);
		if (ERROR_SUCCESS != iStat && ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, szIce11, TEXT("MsiViewFetch_9"));
			DELETE_IF_NOT_NULL(pszProductCode);
			return ERROR_SUCCESS;
		}
		if (ERROR_NO_MORE_ITEMS == iStat)
			break;

		if (fFirstTime)
		{
			if (!fPropertyTable && !IsTablePersistent(FALSE, hInstall, hDatabase, TEXT("Property"), szIce11))
				DELETE_IF_NOT_NULL(pszProductCode);
				return ERROR_SUCCESS;

			// query Property table for ProductCode
			if (ERROR_SUCCESS != (iStat = ::MsiDatabaseOpenView(hDatabase, sqlIce11Property, &hViewProp)))
			{
				APIErrorOut(hInstall, iStat, szIce11, TEXT("MsiDatabaseOpenView_4"));
				DELETE_IF_NOT_NULL(pszProductCode);
				return ERROR_SUCCESS;
			}
			if (ERROR_SUCCESS != (iStat = ::MsiViewExecute(hViewProp, 0)))
			{
				APIErrorOut(hInstall, iStat, szIce11, TEXT("MsiViewExecute_5"));
				DELETE_IF_NOT_NULL(pszProductCode);
				return ERROR_SUCCESS;
			}

			PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
			if (0 == hRecErr)
			{
				APIErrorOut(hInstall, 0, szIce11, TEXT("MsiCreateRecord_6"));
				DELETE_IF_NOT_NULL(pszProductCode);
				return ERROR_SUCCESS;
			}

			// fetch record
			iStat = ::MsiViewFetch(hViewProp, &hRecProp);
			if (ERROR_SUCCESS != iStat)
			{
				if (ERROR_NO_MORE_ITEMS != iStat)
				{
					APIErrorOut(hInstall, iStat, szIce11, TEXT("MsiViewFetch_7"));
					DELETE_IF_NOT_NULL(pszProductCode);
					return ERROR_SUCCESS;
				}
				// ProductCode property not found
				TCHAR szError[iHugeBuf] = {0};
				_stprintf(szError, szIce11Error2, szIceHelp, szIce11Help);
					
				::MsiRecordSetString(hRecErr, 0, szError);
				::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRecErr);

				fProductCode = FALSE;
			}
			else
			{
				// grab the ProductCode GUID
				if (ERROR_SUCCESS != (iStat = IceRecordGetString(hRecProp, 1, &pszProductCode, &dwProductCode, NULL)))
				{
					//!!buffer size
					APIErrorOut(hInstall, iStat, szIce11, TEXT("IceRecordGetString_8"));
					DELETE_IF_NOT_NULL(pszProductCode);
					return ERROR_SUCCESS;
				}
			}
			fFirstTime = FALSE;
		}


		// grab 'source' which must be a valid MSI Product Code (GUID)
		//!! buffer size
		TCHAR* pszGUID = NULL;
		DWORD dwGUID = 512;
		DWORD cchGUID = 0;

		if (ERROR_SUCCESS != (iStat = IceRecordGetString(hRec, 2, &pszGUID, &dwGUID, &cchGUID)))
		{
			//!!buffer size
			APIErrorOut(hInstall, iStat, szIce11, TEXT("IceRecordGetString_10"));
			DELETE_IF_NOT_NULL(pszProductCode);
			return ERROR_SUCCESS;
		}

		// validate GUID
		LPCLSID pclsid = new CLSID;
#ifdef UNICODE
		HRESULT hres = ::IIDFromString(pszGUID, pclsid);
#else
		// convert to UNICODE string
		WCHAR wsz[iSuperBuf];
		DWORD cchwsz = sizeof(wsz)/sizeof(WCHAR);
		int iReturn = ::MultiByteToWideChar(CP_ACP, 0, pszGUID, cchGUID, wsz, cchwsz);
		HRESULT hres = ::IIDFromString(wsz, pclsid);
#endif
		if (pclsid)
			delete pclsid;
		if (hres != S_OK)
		{
			// invalid GUID
			TCHAR szError[iHugeBuf] = {0};
			_stprintf(szError, szIce11Error1, szIceHelp, szIce11Help);
			
			::MsiRecordSetString(hRec, 0, szError);
			::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRec);
			DELETE_IF_NOT_NULL(pszGUID);
			continue;
		}

		// compare the GUIDS
		if (fProductCode && _tcscmp(pszProductCode, pszGUID) == 0)
		{
			// they are the same, ERROR
			TCHAR szError[iHugeBuf] = {0};
			_stprintf(szError, szIce11Error3, szIceHelp, szIce11Help);
			
			::MsiRecordSetString(hRec, 0, szError);
			::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRec);
		}

		// GUID must be all UPPER-CASE
		TCHAR* pszUpper = new TCHAR[_tcslen(pszGUID) + 1];
		_tcscpy(pszUpper, pszGUID);
		::CharUpper(pszUpper);
		if (0 != _tcscmp(pszGUID, pszUpper))
		{
			// ERROR, GUID not all UPPER-CASE
			TCHAR szError[iHugeBuf] = {0};
			_stprintf(szError, szIce11Error4, szIceHelp, szIce11Help);
	
			::MsiRecordSetString(hRec, 0, szError);
			::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRec);
		}

		DELETE_IF_NOT_NULL(pszUpper);
		DELETE_IF_NOT_NULL(pszGUID);
	}

	DELETE_IF_NOT_NULL(pszProductCode);

	// return
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// ICE12 -- validates custom actions of Property types.  A brief 
//   description follows.
//   Directory Prop = Property set with formatted text.  Must be a foreign
//				      key to the Directory table.  As such, needs to appear
//                    in after CostFinalize since it requires usage of the
//                    Directory Manager which isn't set until then.
//   Any Prop/Directory = Property set with formatted text.  Must be a foreign
//                        key to the Property table.  Can set SOURCEDIR or
//                        something similar.  If it happens to be a property
//                        listed in the Directory table, then it must be before
//                        CostFinalize so it can set the directory before
//                        costing and be stored in the Directory Manager.  Else,
//                        can occur anywhere.
//   NOTE: Does not validate the formatted text entry
//
//   HOW VALIDATES:  
//      DirProp = All type 35 Source's must be in the Directory table!
//          Selects all of those custom actions from custom action
//          whose type is 35 and have a sequence number in a sequence
//          table that is lower than that of CostFinalize action (ERROR)
//      AnyProp = For those type 51's whose Source value is a foreign
//          key into the Directory table.  Selects all with a sequence
//          number greater than that of CostFinalize action (ERROR)

// not shared with merge module subset
#ifndef MODSHAREDONLY
// sql queries
ICE_QUERY3(qIce12Seq51, "SELECT `CustomAction`.`Action`,`Type`,`Sequence` FROM `CustomAction`,`Directory`,`%s` WHERE `CustomAction`.`Source`=`Directory`.`Directory` AND `CustomAction`.`Action`=`%s`.`Action` AND `%s`.`Sequence`>=%d",
		   Action, Type, Sequence);
ICE_QUERY3(qIce12Seq35, "SELECT `CustomAction`.`Action`,`Type`,`Sequence` FROM `CustomAction`,`Directory`,`%s` WHERE `CustomAction`.`Source`=`Directory`.`Directory` AND `CustomAction`.`Action`=`%s`.`Action` AND `%s`.`Sequence`<=%d",
		   Action, Type, Sequence);
ICE_QUERY3(qIce12Type35, "SELECT `Action`,`Source`,`Type` FROM `CustomAction`", Action, Source, Type);
ICE_QUERY1(qIce12Directory, "SELECT `Directory` FROM `Directory` WHERE `Directory`='%s'", Directory);
ICE_QUERY1(qIce12SeqFin, "SELECT `Sequence` FROM `%s` WHERE `Action`='CostFinalize'", Sequence);
ICE_QUERY2(qIce12Missing, "SELECT `CustomAction`.`Action`, `Type` FROM `CustomAction`,`%s` WHERE `CustomAction`.`Action`=`%s`.`Action`", Action, Type);

// errors
ICE_ERROR(Ice12Type51PosErr, 12, 1, "CustomAction: [1] is of type: [2] referring to a Directory. Therefore it must come before CostFinalize @ %d in Seq Table: %s. CA Seq#: [3]","%s\tSequence\t[1]");
ICE_ERROR(Ice12Type35PosErr, 12, 1, "CustomAction: [1] is of type: [2]. Therefore it must come after CostFinalize @ %d in Seq Table: %s. CA Seq#: [3]","%s\tSequence\t[1]");
ICE_ERROR(Ice12MissingErr, 12, 1, "CostFinalize missing from sequence table: '%s'.  CustomAction: [1] requires this action to be there.","%s");
ICE_ERROR(Ice12DirErr, 12, 1, "CustomAction: [1] is a Directory Property CA. It's directory (from Source column): '[2]' was not found in the Directory table.","CustomAction\tSource\t[1]");
ICE_ERROR(Ice12DirTableMissing, 12, 1, "You have Directory Property custom actions but no Directory table. All CA's of type 35 are foreign keys into the Directory table (from the source column)","CustomAction");

// other functions
BOOL Ice12ValidateTypePos(MSIHANDLE hInstall, MSIHANDLE hDatabase, BOOL fType35, BOOL fPrintedMissing);
BOOL Ice12ValidateType35(MSIHANDLE hInstall, MSIHANDLE hDatabase, bool fDirTable);

// custom action types
const int iIce12DirProp = msidbCustomActionTypeTextData | msidbCustomActionTypeDirectory;
const int iIce12AnyProp = msidbCustomActionTypeTextData | msidbCustomActionTypeProperty; // note property is directory+sourcefile


ICE_FUNCTION_DECLARATION(12)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 12);

	// grab database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 12, 1);
		return ERROR_SUCCESS;
	}

	// do we have a custom action table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 12, TEXT("CustomAction")))
		return ERROR_SUCCESS;

	// are we going to fail because we don't have a Directory table?
	bool fDirTable = IsTablePersistent(FALSE, hInstall, hDatabase, 12, TEXT("Directory"));

	// validate CA type Dir Property source's are in Directory table
	Ice12ValidateType35(hInstall, hDatabase, fDirTable);

	// validate CA type Dir Property position in the Sequence tables
	BOOL fPrintedMissing = FALSE;
	if (fDirTable) // we already found out that we are missing the Directory table...can't do any of the sql queries
	{
		fPrintedMissing = Ice12ValidateTypePos(hInstall, hDatabase, TRUE, fPrintedMissing);

		// validate CA type AnyProp - Directory position in the Sequence tables
		Ice12ValidateTypePos(hInstall, hDatabase, FALSE, fPrintedMissing);
	}

	// return
	return ERROR_SUCCESS;
}

//////////////////////////////////////////////////////////
// Ice12ValidateType35 -- all type 35 custom actions must
// reference the Directory table from their source column
//
BOOL Ice12ValidateType35(MSIHANDLE hInstall, MSIHANDLE hDatabase, bool fDirTable)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// declare handles
	PMSIHANDLE hRecCA = 0;
	PMSIHANDLE hRecDir = 0;

	// open view on custom action table
	CQuery qViewCA;
	ReturnIfFailed(12, 1, qViewCA.OpenExecute(hDatabase, 0, qIce12Type35::szSQL))

	// fetch all CAs of type 35
	for (;;)
	{
		iStat = qViewCA.Fetch(&hRecCA);
		if (ERROR_NO_MORE_ITEMS == iStat)
			break;
		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 12, 4);
			return FALSE;
		}

		// obtain type and see if it is Type35
		// type 35 = TextData + Source
		// ignore scheduling options
		int iType = ::MsiRecordGetInteger(hRecCA, qIce12Type35::Type);
		// remove scheduling and execution options
		iType &= 0x3F;
		if ((iType & 0x0F) != msidbCustomActionTypeTextData || (iType & 0xF0) != msidbCustomActionTypeDirectory)
			continue; // not type 35

		if (!fDirTable)
		{
			ICEErrorOut(hInstall, hRecCA, Ice12DirTableMissing);
			return FALSE;
		}

		// get directory name
		TCHAR* pszDir = NULL;
		DWORD dwDir = 512;
		ReturnIfFailed(12, 5, IceRecordGetString(hRecCA, qIce12Type35::Source, &pszDir, &dwDir, NULL));

		// open view
		CQuery qDir;
		ReturnIfFailed(12, 6, qDir.OpenExecute(hDatabase, 0, qIce12Directory::szSQL, pszDir));
		DELETE_IF_NOT_NULL(pszDir);

		// attempt to fetch that record
		iStat = qDir.Fetch(&hRecDir);
		if (ERROR_SUCCESS == iStat)
			continue; // valid
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 12, 7);
			return FALSE;
		}

		// record not found...error
		ICEErrorOut(hInstall, hRecCA, Ice12DirErr);
	}

	return TRUE;
}

//////////////////////////////////////////////////////////
// Ice12ValidateTypePos:  
//	If CustomAction.Source = Directory.Directory AND
//  custom action occurs before CostFinalize in the 
//  sequence table, then it must be type 51.  Else
//  it must be type 35.  Returns whether displayed
//  CAs from sequence tables where CostFinalize action
//  was not found to exist (This prevents duplicating
//  it on the second call to the function)
BOOL Ice12ValidateTypePos(MSIHANDLE hInstall, MSIHANDLE hDatabase, BOOL fType35, BOOL fPrintedMissing)
{
	// status return 
	UINT iStat = ERROR_SUCCESS;

	// flag
	BOOL fSeqExist = TRUE;
	BOOL fMissing = FALSE;

	// loop through all of the Sequence tables
	for (int i= 0; i < cTables; i++)
	{
		// CostFinalize sequence number
		int iSeqFin;

		// handle declarations
		PMSIHANDLE hRecSeq  = 0;
		PMSIHANDLE hRec     = 0;

		// is this sequence table in the database?
		if (!IsTablePersistent(FALSE, hInstall, hDatabase, 12, const_cast <TCHAR*>(pSeqTables[i])))
			continue; // go to next seq table

		// open the query on the particular Sequence table and obtain the sequence # of 'CostFinalize'
		CQuery qViewSeq;
		ReturnIfFailed(12, 101, qViewSeq.OpenExecute(hDatabase, 0, qIce12SeqFin::szSQL, pSeqTables[i]));

		// fetch value
		if (ERROR_NO_MORE_ITEMS == (iStat = qViewSeq.Fetch(&hRecSeq)))
		{
			fSeqExist = FALSE;
		}
		else if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 12, 11);
			return FALSE;
		}
		else
		{
			// get sequence number
			iSeqFin = ::MsiRecordGetInteger(hRecSeq, qIce12SeqFin::Sequence);
		}

		//!! If action not in Sequence table, then is it an error to have these custom actions in that table?
		//!! Assuming yes for now.  If not, then do we use sequence number from sibling sequence table?
		//!! What if that doesn't exist?
		if (!fSeqExist && !fPrintedMissing)
		{

			// if any type 35 or 51 CAs exist in this Sequence table then error.  CostFinalize not listed here
			CQuery qViewCA;
			ReturnIfFailed(12, 102, qViewCA.OpenExecute(hDatabase, 0, qIce12Missing::szSQL, pSeqTables[i], pSeqTables[i]));

			// fetch all invalid
			for (;;)
			{
				iStat = qViewCA.Fetch(&hRec);
				if (ERROR_NO_MORE_ITEMS == iStat)
					break;
				if (ERROR_SUCCESS != iStat)
				{
					APIErrorOut(hInstall, iStat, 12, 103);
					return TRUE; // it's going to fail again next time, go ahead and return TRUE
				}
				int iType = ::MsiRecordGetInteger(hRec, qIce12Missing::Type);
				// mask off scheduling and execution options
				iType &= 0x3F;
				// type 35 = TextData + SourceFile
				// type 51 = TextData + Property (property = directory + source)
				if ((iType & 0x0F) != msidbCustomActionTypeTextData)
					continue; // not type 35 or 51
				if ((iType & 0xF0) != msidbCustomActionTypeProperty && (iType & 0xF0) != msidbCustomActionTypeDirectory)
					continue; // not type 35 or 51

				// post error
				ICEErrorOut(hInstall, hRec, Ice12MissingErr, pSeqTables[i], pSeqTables[i]);
			}

			// set for return
			fMissing = TRUE;

			// reset
			fSeqExist = TRUE;

			// continue to next Seq table
			continue;
		}

		// open view on custom action table
		// fType35 = TRUE:  find type 35 CAs who are listed before CostFinalize in the Sequence tables
		// fType51 = FALSE: find type 51 CAs who are listed after CostFinalize in the Sequence tables
		CQuery qCA;
		ReturnIfFailed(12, 105, qCA.OpenExecute(hDatabase, 0, fType35 ? qIce12Seq35::szSQL : qIce12Seq51::szSQL,
			pSeqTables[i], pSeqTables[i], pSeqTables[i], iSeqFin));


		// fetch all invalid
		for (;;)
		{
			iStat = qCA.Fetch(&hRec);
			if (ERROR_NO_MORE_ITEMS == iStat)
				break;
			if (ERROR_SUCCESS != iStat)
			{
				APIErrorOut(hInstall, iStat, 12, 106);
				return FALSE;
			}
			int iTypeCol;
			if (fType35)
				iTypeCol = qIce12Seq35::Type;
			else // type 51
				iTypeCol = qIce12Seq51::Type;

			int iType = ::MsiRecordGetInteger(hRec, iTypeCol);
			if (fType35)
			{
				if ((iIce12DirProp != (iIce12DirProp & iType)) || (iIce12AnyProp == (iIce12AnyProp & iType)))
					continue; // not type 35
			}
			else // !fType35
			{
				if (iIce12AnyProp != (iIce12AnyProp & iType))
					continue; // not type 51 CA
			}

			// post error
			ICEErrorOut(hInstall, hRec, fType35 ? Ice12Type35PosErr : Ice12Type51PosErr, iSeqFin, 
				pSeqTables[i], pSeqTables[i]);
		}

		// reset
		fSeqExist = TRUE;
	}

	return fMissing;
}
#endif

//////////////////////////////////////////////////////////////////////////
// ICE13 -- validates that there are no dialogs listed in the 
//   *ExecuteSequence tables
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR* pExecSeqTables[] = {
								TEXT("AdminExecuteSequence"),
								TEXT("AdvtExecuteSequence"),
								TEXT("InstallExecuteSequence"),
};
const cExecSeqTables = sizeof(pExecSeqTables)/sizeof(TCHAR*);

const TCHAR sqlIce13Seq[] = TEXT("SELECT `Action` FROM `%s`, `Dialog` WHERE `%s`.`Action`=`Dialog`.`Dialog`");
const TCHAR szIce13Error[] = TEXT("ICE13\t1\tDialog '[1]' was found in the %s table.  Dialogs must be in the *UISequence tables.\t%s%s\t%s\tAction\t[1]");

ICE_FUNCTION_DECLARATION(13)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 13);

	// get database
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, szIce13, TEXT("MsiGetActiveDatabase_1"));
		return ERROR_SUCCESS;
	}

	if (!IsTablePersistent(FALSE, hInstall, hDatabase, TEXT("Dialog"), szIce13))
		return ERROR_SUCCESS; // we can't have any dialogs if there isn't a dialog table

	// loop through all *ExecuteSequence tables to find any instances where a dialog is listed
	for (int i = 0; i < cExecSeqTables; i++)
	{
		// is the table in the database?
		if (!IsTablePersistent(FALSE, hInstall, hDatabase, const_cast <TCHAR*>(pExecSeqTables[i]), szIce13))
			continue;

		// declare handles
		PMSIHANDLE hView = 0;
		PMSIHANDLE hRec = 0;
	
		// create query
		TCHAR sql[iMaxBuf] = {0};
		_stprintf(sql, sqlIce13Seq, pExecSeqTables[i], pExecSeqTables[i]);

		// open query
		if (ERROR_SUCCESS != (iStat = ::MsiDatabaseOpenView(hDatabase, sql, &hView)))
		{
			APIErrorOut(hInstall, iStat, szIce13, TEXT("MsiDatabaseOpenView_2"));
			return ERROR_SUCCESS;
		}
		// execute query
		if (ERROR_SUCCESS != (iStat = ::MsiViewExecute(hView, 0)))
		{
			APIErrorOut(hInstall, iStat, szIce13, TEXT("MsiViewExecute_3"));
			return ERROR_SUCCESS;
		}

		// any fetches are invalid
		for (;;)
		{
			iStat = ::MsiViewFetch(hView, &hRec);
			if (ERROR_NO_MORE_ITEMS == iStat)
				break; // no more

			if (ERROR_SUCCESS != iStat)
			{
				APIErrorOut(hInstall, iStat, szIce13, TEXT("MsiViewFetch_4"));
				return ERROR_SUCCESS;
			}

			// setup error
			TCHAR szError[iHugeBuf] = {0};
			_stprintf(szError, szIce13Error, pExecSeqTables[i], szIceHelp, szIce13Help, pExecSeqTables[i]);
			
			// output error
			::MsiRecordSetString(hRec, 0, szError);
			::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER), hRec);
		}

		// close view
		::MsiViewClose(hView);
	}

	// return success
	return ERROR_SUCCESS;
}
#endif

/////////////////////////////////////////////////////////////////
// ICE14 -- ensures that Feature Parents (those whose value
//   in the Feature_Parent column is null) do not have the 
//   ifrsFavorParent attribute set.  Also makes sure that
//   the Feature and Feature_Parent values do not match when
//   with the same record
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR sqlIce14FeatureChilds[] = TEXT("SELECT `Feature_Parent`, `Feature` FROM `Feature` WHERE `Feature_Parent` IS NOT NULL");
const TCHAR sqlIce14FeatureParent[] = TEXT("SELECT `Feature`, `Attributes` FROM `Feature` WHERE `Feature_Parent` IS NULL");

const int iFavorParent = (int)msidbFeatureAttributesFollowParent;

ICE_ERROR(Ice14Error, 14, 1, "Feature '[1]' is a root parent feature. Therefore it cannot have include ifrsFavorParent as an attribute.","Feature\tFeature\t[1]");
ICE_ERROR(Ice14MatchErr, 14, 1, "The entry for Feature_Parent is the same as the entry for Feature. Key: '[2]'.","Feature\tFeature_Parent\t[2]");
 
ICE_FUNCTION_DECLARATION(14)
{
	// status return 
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 14);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 14, 1);
		return ERROR_SUCCESS;
	}

	// do we have this table?
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 14, TEXT("Feature")))
		return ERROR_SUCCESS;

	// declare handles
	CQuery qChild;
	CQuery qParent;
	PMSIHANDLE hRecChild   = 0;
	PMSIHANDLE hRecParent  = 0;

	// open view
	ReturnIfFailed(14, 2, qChild.OpenExecute(hDatabase, 0, sqlIce14FeatureChilds));
	TCHAR* pszFeature = NULL;
	DWORD dwFeature = 512;
	TCHAR* pszParent = NULL;
	DWORD dwParent = 512;
	
	// validate feature versus feature_parent
	for (;;)
	{
		iStat = qChild.Fetch(&hRecChild);
		if (ERROR_NO_MORE_ITEMS == iStat)
			break; // no more

		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 14, 3);
			return ERROR_SUCCESS;
		}

		// get name of feature (so we can compare with parent)
		ReturnIfFailed(14, 4, IceRecordGetString(hRecChild, 2, &pszFeature, &dwFeature, NULL));

		// grab the name of the parent feature
		ReturnIfFailed(14, 5, IceRecordGetString(hRecChild, 1, &pszParent, &dwParent, NULL));
		
		// compare parent to feature 
		// if same for this record, then error
		if (0 == _tcsicmp(pszFeature, pszParent))
		{
			// output error
			ICEErrorOut(hInstall, hRecChild, Ice14MatchErr);
		}
	}

	DELETE_IF_NOT_NULL(pszFeature);
	DELETE_IF_NOT_NULL(pszParent);

	// validate feature_parent ROOT(s) for ifrsFavorParent bit set
	ReturnIfFailed(14, 6, qParent.OpenExecute(hDatabase, hRecChild, sqlIce14FeatureParent));

	for (;;)
	{
		// fetch the parent feature
		iStat = qParent.Fetch(&hRecParent);
		if (ERROR_NO_MORE_ITEMS == iStat)
			break; // no more

		if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 14,7);
			return ERROR_SUCCESS;
		}

		// get attributes
		int iAttrib = ::MsiRecordGetInteger(hRecParent, 2);
		if ((iAttrib & iFavorParent) == iFavorParent)
		{
			ICEErrorOut(hInstall, hRecParent, Ice14Error);
		}
	}

	// return success
	return ERROR_SUCCESS;
}
#endif

//////////////////////////////////////////////////////////////////
// ICE15 -- ensures that a circular reference exists between
// ICE 15 checks to be sure that every MIME type listed in the extension table correctly refers
// back to the extension that references it.
//  Notes on tables...
//   Mime Table has a foreign key to the Extension table (required)
//   Extension Table has a foreign key to the Mime table (not required)
//
const TCHAR sqlIce15Base[] = TEXT("SELECT `MIME`.`ContentType`, `MIME`.`Extension_` FROM `Extension`, `MIME` WHERE (`Extension`.`MIME_` = `MIME`.`ContentType`)");
const TCHAR sqlIce15Extension[] = TEXT("SELECT `Extension` FROM `Extension` WHERE (`MIME_` = ?) AND (`Extension`=?)");
const TCHAR sqlIce15MIME[] =      TEXT("SELECT `MIME_` FROM `Extension` WHERE (`MIME_` = ?) AND (`Extension`=?)");

const TCHAR sqlIce15MarkMIME[] = TEXT("UPDATE `MIME` SET `_ICE15`=1 WHERE (`Extension_`=?)");
const TCHAR sqlIce15MarkExtension[] = TEXT("UPDATE `Extension` SET `_ICE15`=1 WHERE (`MIME_`=?)");

const TCHAR sqlIce15CreateMIME[] = TEXT("ALTER TABLE `MIME` ADD `_ICE15` INTEGER TEMPORARY");
const TCHAR sqlIce15CreateExtension[] = TEXT ("ALTER TABLE `Extension` ADD `_ICE15` INTEGER TEMPORARY");

const TCHAR sqlIce15GetMIME[] = TEXT("SELECT `ContentType`, `Extension_` FROM `MIME` WHERE `_ICE15`<>1");
const TCHAR sqlIce15GetExtension[] = TEXT("SELECT `Extension`, `Component_`, `MIME_` FROM `Extension` WHERE (`MIME_` IS NOT NULL) AND (`_ICE15`<>1)");


ICE_ERROR(Ice15TblError, 15, 1, "Extension table is missing from database","MIME");
ICE_ERROR(Ice15MIMEError, 15, 1, "Extension '[2]' referenced by MIME '[1]' does not map to a MIME with a circular reference.","MIME\tExtension_\t[1]");
ICE_ERROR(Ice15ExtensionError, 15, 1, "MIME Type '[3]' referenced by extension '[1]'.'[2]' does not map to an extension with a circular reference.", "Extension\tMIME_\t[1]\t[2]");
ICE_FUNCTION_DECLARATION(15)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 15);

	// get database
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 15, 1);
		return ERROR_SUCCESS;
	}

	// do we have the MIME?
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 15, TEXT("MIME")))
		return ERROR_SUCCESS;

	// if we have the MIME table, then we must have Extension table!!
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 15, TEXT("Extension")))
	{
		// create an error record
		PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecErr, Ice15TblError);
		return ERROR_SUCCESS;
	}

	// create marking columns
	CQuery qCreateMIME;
	CQuery qCreateExtension;
	ReturnIfFailed(15, 2, qCreateMIME.OpenExecute(hDatabase, 0, sqlIce15CreateMIME));
	ReturnIfFailed(15, 3, qCreateExtension.OpenExecute(hDatabase, 0, sqlIce15CreateExtension));

	// declare handles
	CQuery qMIME;
	CQuery qExtension;
	CQuery qUpdateMIME;
	CQuery qUpdateExtension;
	CQuery qBase;
	PMSIHANDLE hBase = 0;
	PMSIHANDLE hRecExt = 0;
	PMSIHANDLE hRecMIME = 0;

	// open queries to fetch all circluar references and mark every entry in MIME and Extension
	// that references part of the circle as the foreign key.
	ReturnIfFailed(15, 4, qBase.OpenExecute(hDatabase, 0, sqlIce15Base));
	ReturnIfFailed(15, 5, qMIME.Open(hDatabase, sqlIce15MIME));
	ReturnIfFailed(15, 6, qExtension.Open(hDatabase, sqlIce15Extension));
	ReturnIfFailed(15, 7, qUpdateMIME.Open(hDatabase, sqlIce15MarkMIME));
	ReturnIfFailed(15, 8, qUpdateExtension.Open(hDatabase, sqlIce15MarkExtension));

	while (ERROR_SUCCESS == (iStat = qBase.Fetch(&hBase)))
	{
		ReturnIfFailed(15, 9, qMIME.Execute(hBase));
		ReturnIfFailed(15, 10, qExtension.Execute(hBase));
		// fetch from MIME and mark Extension
		while (ERROR_SUCCESS == (iStat = qMIME.Fetch(&hRecMIME)))
		{
			// mark Extension records.
			ReturnIfFailed(15, 11, qUpdateExtension.Execute(hRecMIME));
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 15, 12);
			return ERROR_SUCCESS;
		}

		// fetch from Extension and mark MIME
		while (ERROR_SUCCESS == (iStat = qExtension.Fetch(&hRecExt)))
		{
			// mark MIME records
			ReturnIfFailed(15, 13, qUpdateMIME.Execute(hRecExt));
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 15, 14);
			return ERROR_SUCCESS;
		}
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 15, 15);
		return ERROR_SUCCESS;
	}

	// now fetch everything not marked in either table and output an error saying that
	// it does not refer to a thing of the opposite type that has valid references.
	CQuery qBad;
	ReturnIfFailed(15, 16, qBad.OpenExecute(hDatabase, 0, sqlIce15GetMIME));
	while (ERROR_SUCCESS == (iStat = qBad.Fetch(&hRecMIME)))
	{
		ICEErrorOut(hInstall, hRecMIME, Ice15MIMEError);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 15, 17);

	ReturnIfFailed(15, 18, qBad.OpenExecute(hDatabase, 0, sqlIce15GetExtension));
	while (ERROR_SUCCESS == (iStat = qBad.Fetch(&hRecExt)))
	{
		// look for this record in the Extension table
		ICEErrorOut(hInstall, hRecExt, Ice15ExtensionError);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 15, 19);

	// temporary columns should go away when the views close
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\msiice.dll\msiice4.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       msiice4.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>  // included for both CPP and RC passes
#include <objbase.h>
#include <stdio.h>    // printf/wprintf
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include <time.h>	  // for the time() function to get seed for rand()
#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "msidefs.h"  // must be in this directory or on INCLUDE path
#include "..\..\common\msiice.h"
#include "..\..\common\dbutils.h"
#include "..\..\common\query.h"

//!! Fix warnings and remove pragma
#pragma warning(disable : 4018) // signed/unsigned mismatch

/////////////////////////////////////////////////////////////////////////////////
// ICE23 -- validates the integrity of tab orders in dialog boxes.
// Catches:
//		- dead end tab orders
//      - malformed loops
//      - dialogs whose tab order does not include the Control_First
//      - dialogs with bad Control_First entries
//      - bad references in tab orders
//      - no Control_First entry at all

const TCHAR sqlICE23a[] = TEXT("SELECT DISTINCT `Dialog`, `Control_First`  FROM `Dialog`");
const TCHAR sqlICE23b[] = TEXT("SELECT `Dialog_`, `Control` FROM `Control` WHERE ((`Dialog_`=?) AND (`Control_Next` IS NOT NULL))");
const TCHAR sqlICE23c[] = TEXT("SELECT `Dialog_`, `Control_Next` FROM `Control` WHERE ((`Dialog_`=?) AND (`Control`=?))");
const TCHAR sqlICE23d[] = TEXT("CREATE TABLE `%s` ( `Dialog` CHAR TEMPORARY, `Name` CHAR TEMPORARY PRIMARY KEY `Name`) HOLD");
const TCHAR sqlICE23e[] = TEXT("INSERT INTO `%s` ( `Dialog`, `Name` ) VALUES (? , ? ) TEMPORARY");
const TCHAR sqlICE23f[] = TEXT("ALTER TABLE `%s` FREE");

ICE_ERROR(Ice23NoDefault, 23, ietError, "Dialog [1] has no Control_First.","Dialog\tDialog\t[1]");
ICE_ERROR(Ice23BadDefault, 23, ietError, "Control_First of dialog [1] refers to nonexistant control [2]","Dialog\tControl_First\t[1]");
ICE_ERROR(Ice23NonLoop, 23, ietError, "Dialog [1] has dead-end tab order at control [2].","Control\tControl\t[1]\t[2]");
ICE_ERROR(Ice23InvalidNext, 23, ietError, "Control_Next of control [1].[2] links to unknown control.","Control\tControl_Next\t[1]\t[2]");
ICE_ERROR(Ice23Malformed, 23, ietError, "Dialog [1] has malformed tab order at control [2].","Control\tControl_Next\t[1]\t[2]");

bool Ice23ValidateDialog(MSIHANDLE hInstall, MSIHANDLE hDatabase, CQuery &hTemp, MSIHANDLE hDialogRec); 
void GenerateTmpTableName(TCHAR* tszTmpTableName);

ICE_FUNCTION_DECLARATION(23)
{
	// status return
	UINT	iStat = ERROR_SUCCESS;
	UINT	iDialogStat = ERROR_SUCCESS;
	TCHAR	tszTmpTableName[MAX_PATH];

	// display generic info
	DisplayInfo(hInstall, 23);
	
	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 23, 1);
		return ERROR_SUCCESS;
	}

	// do we have the Dialog table?
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 23, TEXT("Dialog")))
		return ERROR_SUCCESS;

	// do we have the Control table?
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 23, TEXT("Control")))
		return ERROR_SUCCESS;

	// declare handles for Dialog Query
	CQuery qDialog;
	PMSIHANDLE hDialogRec = 0;
	
	// open view for a query on all dialogs
	ReturnIfFailed(23, 2, qDialog.OpenExecute(hDatabase, NULL, sqlICE23a));

	// Get a temporary table name that does not collide with existing table
	// names.
	while(TRUE)
	{
		GenerateTmpTableName(tszTmpTableName);
		if(!IsTablePersistent(FALSE, hInstall, hDatabase, 23, tszTmpTableName))
		{
			break;
		}
	}

	// manage hold counts on the temporary table
	CManageTable MngVisitedControlTable(hDatabase, tszTmpTableName, /*fAlreadyLocked =*/ false); 

	// fetch records to loop over dialogs
	while (ERROR_SUCCESS == (iDialogStat = qDialog.Fetch(&hDialogRec))) {
		CQuery qCreate;
		CQuery qInsert;

		// create a table for the temporary storage.
		ReturnIfFailed(23, 4, qCreate.OpenExecute(hDatabase, NULL, sqlICE23d, tszTmpTableName));
		qCreate.Close();
		MngVisitedControlTable.AddLockCount();
		ReturnIfFailed(23, 5, qInsert.Open(hDatabase, sqlICE23e, tszTmpTableName));

		// now validate the dialog
		if (!Ice23ValidateDialog(hInstall, hDatabase, qInsert, hDialogRec))
		{
			// if there was an error, return success so other ICEs can run
			return ERROR_SUCCESS;
		};

		// free the temporary storage
		CQuery qCreate2;
		ReturnIfFailed(23, 6, qCreate2.OpenExecute(hDatabase, NULL, sqlICE23f, tszTmpTableName));
		qCreate2.Close();
		MngVisitedControlTable.RemoveLockCount();
		qInsert.Close();
	} // for each dialog

	if (ERROR_NO_MORE_ITEMS != iDialogStat)
	{
		// the loop ended due to an error
		APIErrorOut(hInstall, iDialogStat, 23, 7);
		return ERROR_SUCCESS;
	}

	// return success
	return ERROR_SUCCESS;
}


/* validates the tab order of a single dialog box. If there is an error, return false, otherwise true */

bool Ice23ValidateDialog(MSIHANDLE hInstall, MSIHANDLE hDatabase, CQuery &qTemp, MSIHANDLE hDialogRec) {

	// declare Control handles
	PMSIHANDLE hControlRec = 0;
	int iTabTotalCount = 0;
	UINT iStat = ERROR_SUCCESS;

	CQuery qControl;
	CQuery qTabFollow;

	// open view for a query on how many items in this dialog box have a tab order
	ReturnIfFailed(23, 8, qControl.OpenExecute(hDatabase, hDialogRec, sqlICE23b));

	// fetch records to count them up
	while (ERROR_SUCCESS == (iStat = qControl.Fetch(&hControlRec)))
	{
		iTabTotalCount++;
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		// the loop ended due to an error
		APIErrorOut(hInstall, iStat, 23, 9);
		return false;
	}

	// if there are items in the dialog box that have a tab order
	if (iTabTotalCount > 0) {

		// use three handles for each loop to keep track of where we were, are, and are going
		// the three integer values are manipulated to point to index into the array in different locations.
		// this avoids lots of mess when where we are becomes where we were.
		PMSIHANDLE hTabFollowRec[3] = {0, 0, 0};
		int Current = 0;
		int Next = 1;
		int Buffer = 2;

		// declare the loop counter
		int iTabLoopCount = 1;

		// if the dialog has a tab order but no first control, display an error
		if (::MsiRecordIsNull(hDialogRec, 2)) 
		{
			ICEErrorOut(hInstall, hDialogRec, Ice23NoDefault);
			return true;
		} 

		// declare strings to hold the first control name
		TCHAR* pszStartControlName = NULL;
		DWORD dwStartControlName = 512;
		DWORD cchStartControlName = 0;
		
		// create an initial state for the loop by creating a current control record
		// place the dialog name in a buffer temporarily
		ReturnIfFailed(23, 10, IceRecordGetString(hDialogRec, 1, &pszStartControlName, &dwStartControlName, &cchStartControlName));

		// also need to set it as the current control's dialog
		hTabFollowRec[Current] = ::MsiCreateRecord(2);
		ReturnIfFailed(23, 11, MsiRecordSetString(hTabFollowRec[Current], 1, pszStartControlName));

		// place the starting control name in a buffer to compare at end
		ReturnIfFailed(23, 12, IceRecordGetString(hDialogRec, 2, &pszStartControlName, &dwStartControlName, &cchStartControlName));
	
		// also need to set it as the current control
		ReturnIfFailed(23, 13, MsiRecordSetString(hTabFollowRec[Current], 2, pszStartControlName));

		// place the initial control name in the table of visited controls
		ReturnIfFailed(23, 14, qTemp.Execute(hTabFollowRec[Current]));

		// open view for a query to follow the tab order
		// execute the query to move to the first control.
		ReturnIfFailed(23, 15, qTabFollow.OpenExecute(hDatabase, hTabFollowRec[Current], sqlICE23c));

		// fetch record that matches the first control
		iStat = qTabFollow.Fetch(&(hTabFollowRec[Next]));
		if (iStat == ERROR_NO_MORE_ITEMS)
		{
			// error, dialog's Control_First points to non-existant control
			ICEErrorOut(hInstall, hTabFollowRec[Current], Ice23BadDefault);
			DELETE_IF_NOT_NULL(pszStartControlName);
			// continue with the next dialog
			return true;
		} 
		else if (iStat != ERROR_SUCCESS) 
		{
			// other error
			APIErrorOut(hInstall, iStat, 23, 16);
			DELETE_IF_NOT_NULL(pszStartControlName);
			return false;
		}
		
		// follow the tab links until we hit the starting point again or, as a safety measure, 
		// exceed the number of indexed controls in the dialog box by more than 1 (exceeding by 1 
		// is OK because of potential dead-end tab orders on the last leg)
		while (iTabLoopCount <= iTabTotalCount+1)
		{

			// check to see that the link is non-null
			if (::MsiRecordIsNull(hTabFollowRec[Next], 2)) 
			{
				ICEErrorOut(hInstall, hTabFollowRec[Current], Ice23NonLoop);
				DELETE_IF_NOT_NULL(pszStartControlName);
				return true;
			}	
			
			// if we have seen the control that we're looking for before, it might be an error
			if (ERROR_SUCCESS != qTemp.Execute(hTabFollowRec[Next])) {
				break;
			}
	
			// execute the query to move to the next control.
			ReturnIfFailed(23, 17, qTabFollow.Execute(hTabFollowRec[Next]));

			// fetch the next control record
			iStat = qTabFollow.Fetch(&(hTabFollowRec[Buffer]));
			if (iStat == ERROR_NO_MORE_ITEMS)
			{
				ICEErrorOut(hInstall, hTabFollowRec[Current], Ice23InvalidNext);
				DELETE_IF_NOT_NULL(pszStartControlName);
				return true;			
			} 
			else if (iStat != ERROR_SUCCESS) 
			{
				// other error
				APIErrorOut(hInstall, iStat, 23, 18);
				DELETE_IF_NOT_NULL(pszStartControlName);
				return false;
			}
		
			// query was successful, the next control is now the current control, the buffer now holds the next
			// control
			Current = Next;
			Next = Buffer;
			Buffer = (Buffer + 1) % 3;

			// increment the counter of controls followed
			iTabLoopCount++;
		} 

		// now check our results based on how many we hit
		if (iTabLoopCount != iTabTotalCount) {
			// error, doesn't get back to starting point
			ICEErrorOut(hInstall, hTabFollowRec[Current], Ice23Malformed);
			DELETE_IF_NOT_NULL(pszStartControlName);
			return true;
		}

		// declare some strings to hold final control name
		TCHAR* pszTestControlName = NULL;
		DWORD dwTestControlName = 512;
		DWORD cchTestControlName = 0;

		// if it took the right number of steps, just make sure we go back to the start
		// place the dialog name in a buffer temporarily
		ReturnIfFailed(23, 19, IceRecordGetString(hTabFollowRec[Next], 2, &pszTestControlName, &dwTestControlName, &cchTestControlName));
		
		// if we are not pointing back to the start control, it is a malformed loop
		if (_tcsncmp(pszTestControlName, pszStartControlName, cchStartControlName) != 0) 
		{
			ICEErrorOut(hInstall, hTabFollowRec[Current], Ice23Malformed);
			// error, doesn't get back to starting point
			DELETE_IF_NOT_NULL(pszStartControlName);
			DELETE_IF_NOT_NULL(pszTestControlName);
			return true;
		}

		DELETE_IF_NOT_NULL(pszStartControlName);
		DELETE_IF_NOT_NULL(pszTestControlName);
	} // if totalcount > 0
	
	return true;
}

//
// Generate a temporary table name in the form of "_VisitedControlxxxxx" where
// "xxxxx" is a random number seeded by current system time.
//

void GenerateTmpTableName(TCHAR* tszTmpTableName)
{
	int		i;	// The random number.

	//
	// Seed the random number generator with the current system time.
	//

	srand((unsigned)time(NULL));
	i = rand();

	_stprintf(tszTmpTableName, TEXT("_VisitedControl%d"), i);
}


//////////////////////////////////////////////////////////////////////////
// ICE24 -- validates specific properties in the property table
//  ProductCode -- GUID
//  ProductVersion -- Version
//  ProductLanguage -- LangId
//  UpgradeCode -- GUID

// not shared with merge module subset
#ifndef MODSHAREDONLY

typedef bool (*FPropertyValidate)(TCHAR*);
bool Ice24ValidateGUID(TCHAR* szProductCode);
bool Ice24ValidateProdVer(TCHAR* szVersion);
bool Ice24ValidateProdLang(TCHAR* szProductLang);

struct Ice24Property
{
	bool bRequired;
	TCHAR* sql;
	TCHAR* szProperty;
	FPropertyValidate FParam;
	ErrorInfo_t Error;
};

static Ice24Property s_rgProperty[] = 
{
	{
		true,
		TEXT("SELECT `Value` FROM `Property` WHERE `Property`='ProductCode'"), 
		TEXT("ProductCode"), 
		Ice24ValidateGUID,
		{  24, ietError, TEXT("ProductCode: '[1]' is an invalid Windows Installer GUID."), TEXT("Property\tValue\tProductCode") }
	},
	{
		true,
		TEXT("SELECT `Value` FROM `Property` WHERE `Property`='ProductVersion'"), 
		TEXT("ProductVersion"), 
		Ice24ValidateProdVer,
		{ 24, ietError, TEXT("ProductVersion: '[1]' is an invalid version string."),TEXT("Property\tValue\tProductVersion") }
	},
	{	
		true,
		TEXT("SELECT `Value` FROM `Property` WHERE `Property`='ProductLanguage'"), 
		TEXT("ProductLanguage"),
		Ice24ValidateProdLang,
		{ 24, ietError, TEXT("ProductLanguage: '[1]' is an invalid lang Id."), TEXT("Property\tValue\tProductLanguage") }
	},
	{	
		false,
		TEXT("SELECT `Value` FROM `Property` WHERE `Property`='UpgradeCode'"), 
		TEXT("UpgradeCode"),
		Ice24ValidateGUID,
		{  24, ietError, TEXT("UpgradeCode: '[1]' is an invalid Windows Installer GUID."), TEXT("Property\tValue\tUpgradeCode") }
	}
};
const int cIce24Functions = sizeof(s_rgProperty)/sizeof(Ice24Property);

ICE_ERROR(Ice24Error1, 24, ietError, "Property: '%s' not found in Property table.", "Property");
ICE_ERROR(Ice24NoTable, 24, ietError, "Property table does not exist. All required properties are missing.", "Property");
ICE_FUNCTION_DECLARATION(24)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 24);

	// get database
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// do we have the property table?
	// we can report the error here, since these are REQUIRED properties
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 24, TEXT("Property")))
	{
		PMSIHANDLE hRecord = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecord, Ice24NoTable);
		return ERROR_SUCCESS;
	}

	for (int i = 0; i < cIce24Functions; i++)
	{
		// handles
		CQuery qView;
		PMSIHANDLE hRec = 0;
	
		// open view
		ReturnIfFailed(25, 1, qView.OpenExecute(hDatabase, 0, s_rgProperty[i].sql));

		// fetch
		if (ERROR_SUCCESS != (iStat = qView.Fetch(&hRec)))
		{
			if (s_rgProperty[i].bRequired)
			{
				PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
				ICEErrorOut(hInstall, hRecErr, Ice24Error1, s_rgProperty[i].szProperty);
			}
			continue;
		}
		TCHAR* pszValue = NULL;
		DWORD dwValue = 512;
		
		ReturnIfFailed(24, 1, IceRecordGetString(hRec, 1, &pszValue, &dwValue, NULL));
		
		// validate value
		if (!(*s_rgProperty[i].FParam)(pszValue))
		{
			ICEErrorOut(hInstall, hRec, s_rgProperty[i].Error);
		}

		DELETE_IF_NOT_NULL(pszValue);

		// close view
		qView.Close();
	}
	
	return ERROR_SUCCESS;
}

bool Ice24ValidateGUID(TCHAR* szProductCode)
{
	// first make sure all UPPER-CASE GUID
	TCHAR szUpper[iMaxBuf] = {0};
	_tcscpy(szUpper, szProductCode);
	_tcsupr(szUpper);

	if (_tcscmp(szUpper, szProductCode) != 0)
		return false;

	// validate for a valid GUID
	LPCLSID pclsid = new CLSID;
#ifdef UNICODE
	HRESULT hres = ::IIDFromString(szProductCode, pclsid);
#else
	// convert to UNICODE string
	WCHAR wsz[iSuperBuf];
	DWORD cchProdCode = strlen(szProductCode)+1;
	DWORD cchwsz = sizeof(wsz)/sizeof(WCHAR);
	int iReturn = ::MultiByteToWideChar(CP_ACP, 0, szProductCode, cchProdCode, wsz, cchwsz);
	HRESULT hres = ::IIDFromString(wsz, pclsid);
#endif
	if (pclsid)
		delete pclsid;
	if (hres != S_OK)
		return false;
	return true;
}

bool Ice24ValidateProdVer(TCHAR* szVersion)
{
	const TCHAR* pchVersion = szVersion;
	TCHAR* szStopString = NULL;
	for (unsigned int ius = 0; ius < 4; ius++)
	{
		unsigned long ulVer = _tcstoul(pchVersion, &szStopString, 10);
		if (((ius == 0 || ius == 1) && ulVer > 255) || (ius == 2 && ulVer > 65535))
			return false; // invalid (field too great)
		if (*pchVersion == TEXT('.'))
			return false; // invalid (incorrect version string format)
		while (*pchVersion != 0 && *pchVersion != '.')
		{
			if (!_istdigit(*pchVersion))
				return false; // invalid (not a digit)
			pchVersion = MyCharNext(pchVersion);
		}
		if (*pchVersion == '.' && (*(pchVersion = MyCharNext(pchVersion)) == 0))
			return false; // invalid (trailing dot)
	}
	return true;
}

// Mask for Lang Ids
const int iLangInvalidMask = ~((15 << 10) + 0x3f);
bool Ice24ValidateProdLang(TCHAR* szProductLang)
{
	if (_ttoi(szProductLang) & iLangInvalidMask)
		return false;
	return true;
}
#endif

//////////////////////////////////////////////////////////////////////////
// ICE25 -- validates module exclusion/dependencies
//

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR sqlICE25a[] = TEXT("SELECT `RequiredID`, `RequiredLanguage`, `RequiredVersion`, `ModuleID`, `ModuleLanguage` FROM `ModuleDependency`");
const TCHAR sqlICE25b[] = TEXT("SELECT `ModuleID`, `Language`, `Version` FROM `ModuleSignature`");

ICE_ERROR(Ice25BadDepInfo, 25, ietError, "Bad dependency information. (fails basic validation).","ModuleDependency\tModuleID\t[4]\t[5]\t[1]\t[2]");
ICE_ERROR(Ice25FailDep, 25, ietWarning, "Possible dependency failure as we do not find [1]@[2] v[3] in ModuleSignature table","ModuleDependency\tModuleID\t[4]\t[5]\t[1]\t[2]");
ICE_ERROR(Ice25BadSig, 25, ietError, "Bad Signature Information in module [1], could not verify exclusions.","ModuleSignature\tModuleID\t[1]\t[2]\t[3]");
ICE_ERROR(Ice25FailExclusion, 25, ietError, "Module [1]@[2] v[3] is excluded.","ModuleSignature\tModuleID\t[1]\t[2]\t[3]");

ICE_FUNCTION_DECLARATION(25)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display generic info
	DisplayInfo(hInstall, 25);
	
	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 25, 1);
		return ERROR_SUCCESS;
	}

	// do we have the ModuleDependency table?
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 25, TEXT("ModuleDependency"))) {
		// yes, verify all ModuleDependencies
		
		// declare handles for quecy
		CQuery qDependency;
		PMSIHANDLE hDependencyRec = 0;
		
		// open view for a query on all dialogs
		ReturnIfFailed(25, 2, qDependency.OpenExecute(hDatabase, NULL, sqlICE25a));
	
		// validate this dependency
		for (;;)
		{
			iStat = qDependency.Fetch(&hDependencyRec);
			if (ERROR_NO_MORE_ITEMS == iStat)
				break; // no more

			switch (MsiDBUtils::CheckDependency(hDependencyRec, hDatabase)) 
			{
			case ERROR_SUCCESS: 
				continue;
			case ERROR_FUNCTION_FAILED: 
				// failed dependency check
				ICEErrorOut(hInstall, hDependencyRec, Ice25FailDep);
				continue;
			default:	
				ICEErrorOut(hInstall, hDependencyRec, Ice25BadDepInfo);
				continue;
			}
		}			
	}

	// now check exclusions
	// do we have the ModuleSignature table?
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 25, TEXT("ModuleSignature"))) {
		
		// declare handles for quecy
		CQuery qSignature;
		PMSIHANDLE hSignatureRec = 0;
		
		// open view for a query on all module signatures
		ReturnIfFailed(25, 3, qSignature.OpenExecute(hDatabase, NULL, sqlICE25b));
	
		// validate this exclusion
		for (;;)
		{
			iStat = qSignature.Fetch(&hSignatureRec);
			if (ERROR_NO_MORE_ITEMS == iStat)
				break; // no more

			switch (MsiDBUtils::CheckExclusion(hSignatureRec, hDatabase)) 
			{
			case ERROR_SUCCESS: 
				continue;
			case ERROR_FUNCTION_FAILED: 
				// failed exclusion check
				ICEErrorOut(hInstall, hSignatureRec, Ice25FailExclusion);
				continue;
			default:	
				// this module signature is bad
				ICEErrorOut(hInstall, hSignatureRec, Ice25BadSig);
				continue;
			}
		}			
	}

	return ERROR_SUCCESS;
}
#endif

//////////////////////////////////////////////////////////////
// ICE26 -- validates required and prohibited actions in the
//   sequence tables
//

// not shared with merge module subset
#ifndef MODSHAREDONLY

// Sequence table defines
const int istAdminUI  = 0x00000001;
const int istAdminExe = 0x00000002;
const int istAdvtUI   = 0x00000004;
const int istAdvtExe  = 0x00000008;
const int istInstUI   = 0x00000010;
const int istInstExe  = 0x00000020;

struct Seq26Table
{
	const TCHAR* szName;
	const TCHAR* szSQL;
	int iTable;
};
Seq26Table pIce26SeqTables[] =
{
	TEXT("AdminExecuteSequence"),   TEXT("SELECT `Action`, `Sequence` FROM `AdminExecuteSequence`"),    istAdminExe,
	TEXT("AdminUISequence"),        TEXT("SELECT `Action`, `Sequence` FROM `AdminUISequence`"),         istAdminUI,
	TEXT("AdvtExecuteSequence"),    TEXT("SELECT `Action`, `Sequence` FROM `AdvtExecuteSequence`"),     istAdvtExe,
	TEXT("AdvtUISequence"),         TEXT("SELECT `Action`, `Sequence` FROM `AdvtUISequence`"),          istAdvtUI,
	TEXT("InstallExecuteSequence"), TEXT("SELECT `Action`, `Sequence` FROM `InstallExecuteSequence`"),  istInstExe,
	TEXT("InstallUISequence"),      TEXT("SELECT `Action`, `Sequence` FROM `InstallUISequence`"),       istInstUI
};
const int cSeq26Tables = sizeof(pIce26SeqTables)/sizeof(Seq26Table);

const TCHAR sqlIce26Action[] = TEXT("SELECT `Prohibited`, `Required` FROM `_Action` WHERE `Action`=?");
const TCHAR sqlIce26TempCol[] = TEXT("ALTER TABLE `_Action` ADD `Marker` SHORT TEMPORARY");
const TCHAR sqlIce26Required[] = TEXT("SELECT `Required`, `Action` FROM `_Action` WHERE `Required`<>0 AND `Marker`=0");
const TCHAR sqlIce26Init[] = TEXT("UPDATE `_Action` SET `Marker`=0");
const TCHAR sqlIce26Update[] = TEXT("UPDATE `_Action` SET `Marker`=1 WHERE `Action`=?");

ICE_ERROR(Ice26AuthoringError, 26, ietWarning, "CUB file authoring error: Both prohibited and required set for a table %s for action [1]","");
ICE_ERROR(Ice26NoActionTable, 26, ietWarning, "CUB file authoring error. Missing action data. Sequnces may not be valid.","");
ICE_ERROR(Ice26RequiredError, 26, ietError, "Action: '[2]' is required in the %s Sequence table.","%s");
ICE_ERROR(Ice26ProhibitedError, 26, ietError, "Action: '[1]' is prohibited in the %s Sequence table.","%s\tAction\t[1]");

ICE_FUNCTION_DECLARATION(26)
{
	//status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 26);

	// get database
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// does _Action table exist??
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 26, TEXT("_Action")))
	{
		PMSIHANDLE hRecord = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecord, Ice26NoActionTable);
		return ERROR_SUCCESS; // not found
	}

	// create temporary column
	CQuery qCreateTemp;
	ReturnIfFailed(26, 1, qCreateTemp.OpenExecute(hDatabase, 0, sqlIce26TempCol));
	qCreateTemp.Close();

	// open view on _Action table
	CQuery qAction;
	PMSIHANDLE hRecAction = 0;
	ReturnIfFailed(26, 2, qAction.Open(hDatabase, sqlIce26Action));

	bool bLimitUI = false;
	if (IsTablePersistent(false, hInstall, hDatabase, 26, TEXT("Property")))
	{
		CQuery qLimitUI;
		PMSIHANDLE hRec;
		ReturnIfFailed(26, 3, qLimitUI.OpenExecute(hDatabase, 0, TEXT("SELECT `Value` FROM `Property` WHERE `Property`='LIMITUI' AND `Value` IS NOT NULL")));
		if (ERROR_SUCCESS == qLimitUI.Fetch(&hRec))
			bLimitUI = true;
	}

	// validate organization sequence tables
	for (int c = 0; c < cSeq26Tables; c++)
	{
		// does table exist??
		if (!IsTablePersistent(false, hInstall, hDatabase, 26, pIce26SeqTables[c].szName))
			continue; // skip

		if (bLimitUI && (pIce26SeqTables[c].iTable & (istAdminUI | istAdvtUI | istInstUI)))
			continue;

		// initialize marker column
		CQuery qMarker;
		ReturnIfFailed(26, 3, qMarker.OpenExecute(hDatabase, 0, sqlIce26Init));
		qMarker.Close();

		// open view for update of marker column
		CQuery qUpdate;
		ReturnIfFailed(26, 4, qUpdate.Open(hDatabase, sqlIce26Update));

		// open view on sequence table
		CQuery qSequence;

		PMSIHANDLE hRecSequence = 0;
		ReturnIfFailed(26, 5, qSequence.OpenExecute(hDatabase, 0, pIce26SeqTables[c].szSQL));

		// fetch all actions
		while (ERROR_SUCCESS == (iStat = qSequence.Fetch(&hRecSequence)))
		{
			// find its associated value in the _Action table
			ReturnIfFailed(26, 6, qAction.Execute(hRecSequence));
			if (ERROR_SUCCESS != (iStat = qAction.Fetch(&hRecAction)))
			{
				if (ERROR_NO_MORE_ITEMS == iStat)
				{
					// action not listed in _Action table
					// we're going to ignore here....ICE27 will catch if it's not a standard action
					// only potential issue is could we be missing an action in the _Action table
					continue;
				}
				else
				{
					// api error
					APIErrorOut(hInstall, iStat, 26, 7);
					return ERROR_SUCCESS;
				}
			}
			// get its prohibited and required values
			int iProhibited = ::MsiRecordGetInteger(hRecAction, 1);
			if (MSI_NULL_INTEGER == iProhibited || 0 > iProhibited)
			{
				APIErrorOut(hInstall, iStat, 26, 8);
				return ERROR_SUCCESS;
			}
			BOOL fProhibited = iProhibited & pIce26SeqTables[c].iTable;
			int iRequired = ::MsiRecordGetInteger(hRecAction, 2);
			if (MSI_NULL_INTEGER == iRequired || 0 > iRequired)
			{
				APIErrorOut(hInstall, iStat, 26, 9);
				return ERROR_SUCCESS;
			}
			BOOL fRequired = iRequired & pIce26SeqTables[c].iTable;
			if (fRequired && fProhibited)
			{
				// ERROR, both can't be set as these are mutually exclusive
				ICEErrorOut(hInstall, hRecSequence, Ice26AuthoringError, pIce26SeqTables[c].szName);
			}
			else if (fProhibited)
			{
				// ERROR, can't have this action in this table
				ICEErrorOut(hInstall, hRecSequence, Ice26ProhibitedError, 
					pIce26SeqTables[c].szName, pIce26SeqTables[c].szName);
			}

			// mark the marker column for this action
			ReturnIfFailed(26, 10, qUpdate.Execute(hRecSequence));
		}// for each action
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			// api error
			APIErrorOut(hInstall, iStat, 26, 11);
			return ERROR_SUCCESS;
		}

		// now check for Required actions that aren't there
		CQuery qRequired;
		PMSIHANDLE hRecRequired = 0;
		ReturnIfFailed(26, 12, qRequired.OpenExecute(hDatabase, 0, sqlIce26Required));

		// fetch all entries
		while (ERROR_SUCCESS == (iStat = qRequired.Fetch(&hRecRequired)))
		{
			// get required flag
			int iRequired = ::MsiRecordGetInteger(hRecRequired, 1);
			if (MSI_NULL_INTEGER == iRequired || 0 > iRequired)
			{
				APIErrorOut(hInstall, iStat, 26, 13);
				return ERROR_SUCCESS;
			}
			// compare with this table, if TRUE, then INVALID ('cause not marked)
			if (iRequired & pIce26SeqTables[c].iTable)
			{
				// ERROR, action is required in here
				ICEErrorOut(hInstall, hRecRequired, Ice26RequiredError, 
					pIce26SeqTables[c].szName, pIce26SeqTables[c].szName);
			}
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			// api error
			APIErrorOut(hInstall, iStat, 26, 14);
			return ERROR_SUCCESS;
		}
	}// for each sequence table

	return ERROR_SUCCESS;
}
#endif

/////////////////////////////////////////////////////////////
// ICE27 -- validates the organization of the sequence tables
//   as well as the order of actions (action dependencies)
//

// not shared with merge module subset
#ifndef MODSHAREDONLY

// Sequence tables
struct Seq27Table
{
	const TCHAR* szName;
	const TCHAR* szSQL;
};
Seq27Table pIce27SeqTables[] =
{
	TEXT("AdminExecuteSequence"),   TEXT("SELECT `Action`, `Sequence` FROM `AdminExecuteSequence` ORDER BY `Sequence`"),
	TEXT("AdminUISequence"),        TEXT("SELECT `Action`, `Sequence` FROM `AdminUISequence` ORDER BY `Sequence`"),
	TEXT("AdvtExecuteSequence"),    TEXT("SELECT `Action`, `Sequence` FROM `AdvtExecuteSequence` ORDER BY `Sequence`"),
	TEXT("AdvtUISequence"),         TEXT("SELECT `Action`, `Sequence` FROM `AdvtUISequence` ORDER BY `Sequence`"),
	TEXT("InstallExecuteSequence"), TEXT("SELECT `Action`, `Sequence` FROM `InstallExecuteSequence` ORDER BY `Sequence`"),
	TEXT("InstallUISequence"),      TEXT("SELECT `Action`, `Sequence` FROM `InstallUISequence` ORDER BY `Sequence`"),
};
const int cSeqTables = sizeof(pIce27SeqTables)/sizeof(Seq27Table);

// InstallSequence sectional constants
const int isfSearch    = 0x00000001L;
const int isfCosting   = 0x00000002L;
const int isfSelection = 0x00000004L;
const int isfExecution = 0x00000008L;
const int isfPostExec  = 0x00000010L;

// InstallSequence sectional devisors
const TCHAR szEndSearch[]      = TEXT("CostInitialize");  // end Search, begin Costing
const TCHAR szEndCosting[]     = TEXT("CostFinalize");    // end Costing, begin Selection
const TCHAR szEndSelection[]   = TEXT("InstallValidate"); // end Selection, begin Execution
const TCHAR szReset[]          = TEXT("InstallFinalize"); // change to PostExecution

// InstallSequence divisions
const TCHAR szSearch[]         = TEXT("Search");
const TCHAR szCosting[]        = TEXT("Costing");
const TCHAR szSelection[]      = TEXT("Selection");
const TCHAR szExecution[]      = TEXT("Execution");
const TCHAR szPostExec[]      = TEXT("PostExecution");

// Info messages
ICE_ERROR(Ice27SeqTableNotFound, 27, ietInfo, "%s table not found, skipping. . .", "");
ICE_ERROR(Ice27ValidateOrganization, 27, ietInfo, "%s TABLE: Validating organization. . .", "");
ICE_ERROR(Ice27ValidateDependency, 27, ietInfo, "%s TABLE: Validating sequence of actions and dependencies. . .", "");
ICE_ERROR(Ice27NoActionTable, 27, ietWarning, "CUB File Error. Unable to validate sequence table organization. Sequences may not be valid.", "");
ICE_ERROR(Ice27NoSequenceTable, 27, ietWarning, "CUB File Error. Unable to validate sequence dependencies. Sequences may not be valid.", "");

// functions
bool Ice27ValidateOrganizationSequence(MSIHANDLE hInstall, MSIHANDLE hDatabase, const TCHAR* szSeqTable, const TCHAR* sql);
bool Ice27ValidateSequenceDependency(MSIHANDLE hInstall, MSIHANDLE hDatabase, const TCHAR* szSeqTable, const TCHAR* sql);

ICE_FUNCTION_DECLARATION(27)
{
	// status return 
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 27);

	// get database
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	PMSIHANDLE hRecInfo = ::MsiCreateRecord(1);

	// do we have the _Sequence and _Action table? ... we should always have this table
	bool bSequence = IsTablePersistent(FALSE, hInstall, hDatabase, 27, TEXT("_Sequence"));
	bool bAction = IsTablePersistent(TRUE, hInstall, hDatabase, 27, TEXT("_Action"));
	if (!bSequence)
		ICEErrorOut(hInstall, hRecInfo, Ice27NoSequenceTable);
	if (!bAction)
		ICEErrorOut(hInstall, hRecInfo, Ice27NoActionTable);
	if (!bSequence && !bAction)
		return ERROR_SUCCESS;

	// validate organization sequence tables
	TCHAR szInfo[iMaxBuf] = {0};
	for (int c = 0; c < cSeqTables; c++)
	{
		if(MsiDatabaseIsTablePersistent(hDatabase,pIce27SeqTables[c].szName) == MSICONDITION_NONE)
		{
			ICEErrorOut(hInstall, hRecInfo, Ice27SeqTableNotFound, pIce27SeqTables[c].szName);
			continue;
		}
		ICEErrorOut(hInstall, hRecInfo, Ice27ValidateOrganization, pIce27SeqTables[c].szName);
		if (bAction)
			Ice27ValidateOrganizationSequence(hInstall, hDatabase, pIce27SeqTables[c].szName, pIce27SeqTables[c].szSQL);

		ICEErrorOut(hInstall, hRecInfo, Ice27ValidateDependency, pIce27SeqTables[c].szName);
		if (bSequence)
			Ice27ValidateSequenceDependency(hInstall, hDatabase, pIce27SeqTables[c].szName, pIce27SeqTables[c].szSQL);
	}

	// return success
	return ERROR_SUCCESS;
}

// sql queries
const TCHAR sqlIce27Organization[] = TEXT("SELECT `SectionFlag`, `Action` FROM `_Action` WHERE `Action`=?");
const TCHAR sqlIce27Dialog[] = TEXT("SELECT `Dialog` FROM `Dialog` WHERE `Dialog`= ?");
const TCHAR sqlIce27CustomAction[] = TEXT("SELECT `Action` FROM `CustomAction` WHERE `Action`=?");
// errors
ICE_ERROR(Ice27UnknownAction, 27, ietError, "Unknown action: '[1]' of %s table. Not a standard action and not found in CustomAction or Dialog tables", "%s\tAction\t[1]");
ICE_ERROR(Ice27InvalidSectionFlag, 27, ietWarning, "Cube file owner authoring error: Invalid Section Flag for '[2]' in _Action table.", "");
ICE_ERROR(Ice27OrganizationError, 27, ietError, "'[1]' Action in %s table in wrong place. Current: %s, Correct: %s", "%s\tSequence\t[1]");
ICE_ERROR(Ice27RequireScript, 27, ietError, "'[1]' Action in %s table can only be called when script operations exist to be executed","%s\tAction\t[1]");
ICE_ERROR(Ice27RequireExecute, 27, ietError, "InstallFinalize must be called in %s table as script operations exist to be executed.","%s");

bool Ice27ValidateOrganizationSequence(MSIHANDLE hInstall, MSIHANDLE hDatabase, const TCHAR* szTable, const TCHAR* sql)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// handles
	PMSIHANDLE hRecSequence      = 0;
	PMSIHANDLE hRecOrganization  = 0;
	PMSIHANDLE hRecDialog        = 0;
	PMSIHANDLE hRecCustomAction  = 0;

	// initialize section definition to Search
	int isf = isfSearch;

	// if script operations, must call InstallFinalize
	BOOL fRequireExecute = FALSE;
	CQuery qSequence;
	CQuery qOrganization;
	CQuery qDialog;
	CQuery qCustomAction;

	// open view on Sequence table
	ReturnIfFailed(27, 101, qSequence.OpenExecute(hDatabase, NULL, sql));

	// open view on Organization table for Validation
	ReturnIfFailed(27, 102, qOrganization.Open(hDatabase, sqlIce27Organization));

	// check for existence of Dialog and CustomAction tables
	BOOL fDialogTbl       = TRUE;
	BOOL fCustomActionTbl = TRUE;
	if (MsiDatabaseIsTablePersistent(hDatabase, TEXT("Dialog")) == MSICONDITION_NONE)
		fDialogTbl = FALSE;
	if (MsiDatabaseIsTablePersistent(hDatabase, TEXT("CustomAction")) == MSICONDITION_NONE)
		fCustomActionTbl = FALSE;

	// open view on Dialog table
	if (fDialogTbl)
		ReturnIfFailed(27, 103, qDialog.Open(hDatabase, sqlIce27Dialog));

	// open view on CustomAction table
	if (fCustomActionTbl)
		ReturnIfFailed(27, 104, qCustomAction.Open(hDatabase, sqlIce27CustomAction));

	// fetch all actions in Sequence table
	TCHAR* pszAction = NULL;
	DWORD dwAction = 512;
	while (ERROR_SUCCESS == (iStat = qSequence.Fetch(&hRecSequence)))
	{
		// get action
		ReturnIfFailed(27, 105, IceRecordGetString(hRecSequence, 1, &pszAction, &dwAction, NULL));

		// Determine if have to switch the current section state
		// Depends on a certain action defined as the boundary
		// This action is required in the Sequence table -- CostInitialize, CostFinalize, InstallValidate
		// InstallFinalize switches to PostExecution
		// InstallFinalize must be called if any execution operations exist
		if (_tcscmp(pszAction, szEndSearch) == 0)
			isf = isfCosting;
		else if (_tcscmp(pszAction, szEndCosting) == 0)
			isf = isfSelection;
		else if (_tcscmp(pszAction, szEndSelection) == 0)
			isf = isfExecution;
		else if (_tcscmp(pszAction, szReset) == 0)
		{
			if (fRequireExecute)
				fRequireExecute = FALSE;
			else
			{
				ICEErrorOut(hInstall, hRecSequence, Ice27RequireScript, szTable, szTable);
			}
			isf = isfPostExec; // post execution phase
		}

		// look for action in Organization table
		ReturnIfFailed(27, 106, qOrganization.Execute(hRecSequence));

		// attempt to fetch action's organization info
		if (ERROR_SUCCESS != (iStat = qOrganization.Fetch(&hRecOrganization)))
		{
			// init to not found
			BOOL fNotFound = TRUE; 

			// failed, see if "action" is a Dialog
			if (fDialogTbl)
			{
				ReturnIfFailed(27, 107, qDialog.Execute(hRecSequence));
				if (ERROR_SUCCESS == (iStat = qDialog.Fetch(&hRecDialog)))
				{
					fNotFound = FALSE;
				}
			}

			// failed, see if "action" is a CustomAction
			if (fNotFound && fCustomActionTbl)
			{
				ReturnIfFailed(27, 108, qCustomAction.Execute(hRecSequence));
				if (ERROR_SUCCESS == (iStat = qCustomAction.Fetch(&hRecCustomAction)))
				{
					fNotFound = FALSE;
				}
			}

			if (fNotFound)
			{
				ICEErrorOut(hInstall, hRecSequence, Ice27UnknownAction, szTable, szTable);
			}

		}
		else
		{
			// standard action, organization value found
			// obtain the section flag
			int iSectionFlag = ::MsiRecordGetInteger(hRecOrganization, 1);
			if (iSectionFlag == MSI_NULL_INTEGER)
			{
				APIErrorOut(hInstall, 0, 27, 109);
				continue;
			}

			// validate section flag
			if (iSectionFlag & ~(isfSearch|isfCosting|isfSelection|isfExecution|isfPostExec))
			{
				// invalid section flag -- can't error on table 'cause this is in cube file
				ICEErrorOut(hInstall, hRecOrganization, Ice27InvalidSectionFlag);

				continue;
			}

			// validate against current section
			if (iSectionFlag & isf)
			{
				if (iSectionFlag == isfExecution)
					fRequireExecute = TRUE;
			}
			else
			{
				// incorrect
				TCHAR szError[iHugeBuf] = {0};
				const TCHAR *szCurrent;
				switch (isf)
				{
				case isfSearch:    szCurrent = szSearch;    break;
				case isfCosting:   szCurrent = szCosting;   break;
				case isfSelection: szCurrent = szSelection; break;
				case isfExecution: szCurrent = szExecution; break;
				case isfPostExec:  szCurrent = szPostExec;  break;
				}
				// if isfAll, then never invalid
				TCHAR rgchCorrect[iMaxBuf] = {0};
				int cchWritten = 0;
				BOOL fOneWritten = 0;
				if (iSectionFlag & isfSearch)
				{
					cchWritten = _stprintf(rgchCorrect + cchWritten, _T("%s"), szSearch);
					fOneWritten = TRUE;
				}
				if (iSectionFlag & isfCosting)
				{
					cchWritten += _stprintf(rgchCorrect + cchWritten, fOneWritten ? _T(" OR %s") : _T("%s"),  szCosting);
					fOneWritten = TRUE;
				}
				if (iSectionFlag & isfSelection)
				{
					cchWritten += _stprintf(rgchCorrect + cchWritten, fOneWritten ? _T(" OR %s") : _T("%s"),  szSelection);
					fOneWritten = TRUE;
				}
				if (iSectionFlag & isfExecution)
				{
					cchWritten += _stprintf(rgchCorrect + cchWritten, fOneWritten ? _T(" OR %s") : _T("%s"),  szExecution);
					fOneWritten = TRUE;
				}
				if (iSectionFlag & isfPostExec)
					cchWritten += _stprintf(rgchCorrect + cchWritten, fOneWritten ? _T(" OR %s") : _T("%s"),  szPostExec);
				
				ICEErrorOut(hInstall, hRecSequence, Ice27OrganizationError, szTable, szCurrent, rgchCorrect, szTable);
				continue;
			}
		}
	}
	DELETE_IF_NOT_NULL(pszAction);
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		// api error
		APIErrorOut(hInstall, iStat, 27, 110);
		return false;
	}
	if (fRequireExecute)
	{
		PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
		// we forgot to execute the script operations
		ICEErrorOut(hInstall, hRecErr, Ice27RequireExecute, szTable, szTable);
	}

	// OK
	return true;
}

// sql queries
const TCHAR sqlSeqBeforeDependency[] = TEXT("SELECT `Dependent`, `Marker`, `Action` FROM `_Sequence` WHERE `Action`=? AND `Marker`<>0  AND `After`=0");
const TCHAR sqlSeqAfterDependency[]  = TEXT("SELECT `Dependent`, `Action` FROM `_Sequence` WHERE `Action`=? AND `Marker`=0 AND `After`=1 AND `Optional`=0"); 
const TCHAR sqlSeqDepTableAddCol[]   = TEXT("ALTER TABLE `_Sequence` ADD `Marker` SHORT TEMPORARY");
const TCHAR sqlSeqDepMarkerInit[]    = TEXT("UPDATE `_Sequence` SET `Marker`=0");
const TCHAR sqlSeqUpdateMarker[]     = TEXT("UPDATE `_Sequence` SET `Marker`=? WHERE `Dependent`=?");
const TCHAR sqlSeqInsert[]           = TEXT("SELECT `Action`, `Dependent`, `After`, `Optional` FROM `_Sequence`");
const TCHAR sqlSeqFindAfterOptional[]= TEXT("SELECT `Dependent`, `Action`, `After`, `Optional` FROM `_Sequence` WHERE `After`=1 AND `Optional`=1");

// errors
ICE_ERROR(Ice27BeforeError, 27, ietError, "Action: '[3]' in %s table must come before the '[1]' action. Current seq#: %d. Dependent seq#: [2].", "%s\tSequence\t[3]");
ICE_ERROR(Ice27AfterError, 27, ietError, "Action: '[2]' in %s table must come after the '[1]' action.","%s\tSequence\t[2]");
ICE_ERROR(Ice27NullSequenceNum, 27, ietError, "Action: '[1]' in %s table has an invalid sequence number.","%s\tSequence\t[1]");

bool Ice27ValidateSequenceDependency(MSIHANDLE hInstall, MSIHANDLE hDatabase, const TCHAR* szTable, const TCHAR* sql)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// handles
	CQuery qSequence;
	CQuery qSeqBeforeDep;
	CQuery qSeqAfterDep;
	CQuery qSeqUpdate;
	CQuery qSeqAddColumn;
	CQuery qSeqMarkerInit;
	PMSIHANDLE hRecSeqUpdateExecute = 0;
	PMSIHANDLE hRecQueryExecute     = 0;
	PMSIHANDLE hRecSequence         = 0;
	PMSIHANDLE hRecSeqBeforeDep     = 0;
	PMSIHANDLE hRecSeqAfterDep      = 0;

	// Set up the _Sequence table with the insert temporary of actions where After=1 and Optional=1
	// This is so that we can catch errors.  WE need to insert w/ Action=Dependent, Dependent=Action, After=0, and Optional=1
	CQuery qSeqInsert;
	CQuery qSeqFind;
	PMSIHANDLE hRecSeqFind    = 0;

	ReturnIfFailed(27, 201, qSeqFind.OpenExecute(hDatabase, NULL, sqlSeqFindAfterOptional));
	ReturnIfFailed(27, 202, qSeqInsert.OpenExecute(hDatabase, NULL, sqlSeqInsert));

	// fetch all of those actions
	while (ERROR_SUCCESS == (iStat = qSeqFind.Fetch(&hRecSeqFind)))
	{
		// set After from 1 to 0, leave optional as is
		::MsiRecordSetInteger(hRecSeqFind, 3, 0);

		// insert temporary (possible read only db)
		if (ERROR_SUCCESS != (iStat = qSeqInsert.Modify(MSIMODIFY_INSERT_TEMPORARY, hRecSeqFind)))
		{
			// if ERROR_FUNCTION_FAILED, we're okay....author already took care of this for us
			if (ERROR_FUNCTION_FAILED != iStat)
				APIErrorOut(hInstall, iStat, 27, 203);
		}
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 27, 204);
		return false;
	}
	qSeqFind.Close();
	qSeqInsert.Close();
	
	// Create the temporary marking column for the _Sequence table (this will store the sequence #s of the Dependent Actions)
	if (ERROR_SUCCESS != (iStat = qSeqAddColumn.OpenExecute(hDatabase, NULL, sqlSeqDepTableAddCol)))
	{
		// ignore if SQL query failure, means table already in memory with the Marker Column
		if (ERROR_BAD_QUERY_SYNTAX != iStat)
		{
			APIErrorOut(hInstall, iStat, 27, 205);
			return false;
		}
	}

	// Initialize the temporary marking column to zero
	// NO INSTALL SEQUENCE ACTIONS CAN HAVE A ZERO SEQUENCE # AS ZERO IS CONSIDERED "NULL"
	ReturnIfFailed(27, 206, qSeqMarkerInit.OpenExecute(hDatabase, NULL, sqlSeqDepMarkerInit));
	qSeqMarkerInit.Close();

	// Open view on Sequence table and order by the Sequence #
	ReturnIfFailed(27, 207, qSequence.OpenExecute(hDatabase, NULL, sql));

	// Open the two query views on _Sequence table for determining the validity of the actions
	// Create execution record
	ReturnIfFailed(27, 208, qSeqBeforeDep.Open(hDatabase, sqlSeqBeforeDependency));
	ReturnIfFailed(27, 209, qSeqAfterDep.Open(hDatabase, sqlSeqAfterDependency));

	// Open the update view on _Sequence table
	ReturnIfFailed(27, 210, qSeqUpdate.Open(hDatabase, sqlSeqUpdateMarker));


	// Start fetching actions from the Sequence table
	while (ERROR_SUCCESS == (iStat = qSequence.Fetch(&hRecSequence)))
	{
		int iSequence = ::MsiRecordGetInteger(hRecSequence, 2);
		
		// validate sequence number
		if (0 == iSequence || MSI_NULL_INTEGER == iSequence)
		{
			ICEErrorOut(hInstall, hRecSequence, Ice27NullSequenceNum, szTable, szTable);
			continue;
		}

		// execute Before & After dependency queries
		ReturnIfFailed(27, 212, qSeqBeforeDep.Execute(hRecSequence));
		ReturnIfFailed(27, 213, qSeqAfterDep.Execute(hRecSequence));
		
		// Fetch from _Sequence table on Before and After queries.  If resultant set, then ERROR
		// Following are the possibilities and whether permitted:
		//   Action After  Dependent Where Dependent Is Required And Temp Sequence Column Is Zero
		//       ERROR
		//   Action After  Dependent Where Dependent Is Required And Temp Sequence Column Is Greater Than Zero
		//       CORRECT
		//   Action After  Dependent Where Dependent Is Optional And Temp Sequence Column Is Zero
		//       CORRECT
		//   Action After  Dependent Where Dependent Is Optional And Temp Sequence Column Is Greater Than Zero
		//       CORRECT
		//   Action Before Dependent Where Dependent Is Optional Or Required And Temp Sequence Column Is Zero
		//       CORRECT
		//   Action Before Dependent Where Dependent Is Optional Or Requred And Temp Sequence Column Is Greater Than Zero
		//       ERROR

		// ** Only issue is when Action Is After Optional Dependent And Temp Sequence Column Is Zero because we
		// ** have no way of knowing whether the action will be later (in which case it would be invalid.  This is
		// ** ensured to be successful though by proper authoring of the _Sequence table and by this ICE which makes
		// ** the correct insertions.  If an Action comes after the Optional Dependent Action, then the _Sequence
		// ** table must also be authored with the Dependent Action listed as coming before that Action (so if we come
		// ** later, and find a result set, we flag this case).

		// If return is not equal to ERROR_NO_MORE_ITEMS, then ERROR and Output Action
		while (ERROR_NO_MORE_ITEMS != qSeqBeforeDep.Fetch(&hRecSeqBeforeDep))
		{
			int iDepSequenceNum = ::MsiRecordGetInteger(hRecSequence, 2);
			// hRecSequence
			ICEErrorOut(hInstall, hRecSeqBeforeDep, Ice27BeforeError, szTable, iDepSequenceNum, szTable);
		}

		while (ERROR_NO_MORE_ITEMS != qSeqAfterDep.Fetch(&hRecSeqAfterDep))
			ICEErrorOut(hInstall, hRecSeqAfterDep, Ice27AfterError, szTable, szTable);

		// Update _ActionDependency table temporary Sequence column (that we created) with the install sequence number
		// The Sequence column stores the sequence number of the Dependent Actions, so we are updating every
		// row where the action in the Dependent column equals the current action.  In the query view, we only
		// check to insure that this column is zero or greater than zero (so we don't care too much about the value),
		// but the value is helpful when reporting errors
		
		// prepare record for execution
		PMSIHANDLE hRecExeUpdate = ::MsiCreateRecord(2);
		TCHAR* pszAction = NULL;
		DWORD dwAction = 512;
		ReturnIfFailed(27, 214, IceRecordGetString(hRecSequence, 1, &pszAction, &dwAction, NULL));

		::MsiRecordSetInteger(hRecExeUpdate, 1, iSequence);
		::MsiRecordSetString(hRecExeUpdate, 2, pszAction);
		DELETE_IF_NOT_NULL(pszAction);
		ReturnIfFailed(27, 215, qSeqUpdate.Execute(hRecExeUpdate));

	}
	if (iStat != ERROR_NO_MORE_ITEMS)
	{
		APIErrorOut(hInstall, iStat, 27, 216);
		return false;
	}

	// succeed
	return true;
}
#endif

//////////////////////////////////////////////////////////////////////////
// ICE28 -- validates actions that can't be separated by ForceReboot
//

// not shared with merge module subset
#ifndef MODSHAREDONLY

struct Seq28Table
{
	const TCHAR* szName;
	const TCHAR* szSQL;
};
Seq28Table pIce28SeqTables[] =
{
	TEXT("AdminExecuteSequence"),   TEXT("SELECT `Action`, `Sequence` FROM `AdminExecuteSequence`"),
	TEXT("AdminUISequence"),        TEXT("SELECT `Action`, `Sequence` FROM `AdminUISequence`"),
	TEXT("AdvtExecuteSequence"),    TEXT("SELECT `Action`, `Sequence` FROM `AdvtExecuteSequence`"),
	TEXT("AdvtUISequence"),         TEXT("SELECT `Action`, `Sequence` FROM `AdvtUISequence`"),
	TEXT("InstallExecuteSequence"), TEXT("SELECT `Action`, `Sequence` FROM `InstallExecuteSequence`"),
	TEXT("InstallUISequence"),      TEXT("SELECT `Action`, `Sequence` FROM `InstallUISequence`"),
};
const int cSeq28Tables = sizeof(pIce28SeqTables)/sizeof(Seq28Table);

const TCHAR sqlIce28FindRange[] = TEXT("SELECT `Sequence` FROM `%s`, `_PlaceHolder` WHERE `%s`.`Action` = `_PlaceHolder`.`Action` AND `Set`=%d ORDER BY `%s`.`Sequence`");
const TCHAR sqlIce28NumSets[] = TEXT("SELECT `Set` FROM `_SetExclusion` ORDER BY `Set`");
const TCHAR sqlIce28AddColumn1[] = TEXT("ALTER TABLE `_SetExclusion` ADD `MinCol` SHORT TEMPORARY");
const TCHAR sqlIce28AddColumn2[] = TEXT("ALTER TABLE `_SetExclusion` ADD `MaxCol` SHORT TEMPORARY");
const TCHAR sqlIce28AddColumn3[] = TEXT("ALTER TABLE `_SetExclusion` ADD `Sequence` SHORT TEMPORARY");
const TCHAR sqlIce28InitColumns[] = TEXT("UPDATE `_SetExclusion` SET `MinCol`=0, `MaxCol`=0, `Sequence`=0");
const TCHAR sqlIce28UpdateColumns[] = TEXT("UPDATE `_SetExclusion` SET `MinCol`=%d, `MaxCol`=%d WHERE `Set`=%d");
const TCHAR sqlIce28FindAction[] = TEXT("SELECT `%s`.`Sequence`, `_SetExclusion`.`Action` FROM `%s`, `_SetExclusion` WHERE `%s`.`Action`=`_SetExclusion`.`Action`");
const TCHAR sqlIce28UpdateSequence[] = TEXT("UPDATE `_SetExclusion` SET `Sequence`=? WHERE `Action`=?");
const TCHAR sqlIce28Invalid[] = TEXT("SELECT `Action`, `Sequence`, `MinCol`, `MaxCol` FROM `_SetExclusion` WHERE `Sequence`<>0");
const int iColIce28Invalid_Action = 1;
const int iColIce28Invalid_Sequence = 2;
const int iColIce28Invalid_MinCol = 3;
const int iColIce28Invalid_MaxCol = 4;

ICE_ERROR(Ice28Error, 28, ietError, "Action: '[1]' of table %s is not permitted in the range [3] to [4] because it cannot separate a set of actions contained in this range.","%s\tSequence\t[1]");
ICE_ERROR(Ice28CUBError, 28, ietWarning,  "Cube file error. Unable to finish ICE28 validation.","");

ICE_FUNCTION_DECLARATION(28)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 28);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 28, 1);
		return ERROR_SUCCESS;
	}

	// are the _SetExlusion and _Placeholder tables there??
	if (!IsTablePersistent(FALSE,  hInstall, hDatabase, 28, TEXT("_SetExclusion")) ||
		!IsTablePersistent(FALSE, hInstall, hDatabase, 28, TEXT("_PlaceHolder")))
	{
		PMSIHANDLE hRecord = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecord, Ice28CUBError);
		return ERROR_SUCCESS;
	}

	// set up temporary columns
	PMSIHANDLE hViewAddColumn1 = 0;
	PMSIHANDLE hViewAddColumn2 = 0;
	PMSIHANDLE hViewAddColumn3 = 0;
	CQuery qAdd;
	ReturnIfFailed(28, 1, qAdd.OpenExecute(hDatabase, NULL, sqlIce28AddColumn1));
	qAdd.Close();
	CQuery qAdd2;
	ReturnIfFailed(28, 2, qAdd2.OpenExecute(hDatabase, NULL, sqlIce28AddColumn2));
	qAdd2.Close();
	CQuery qAdd3;
	ReturnIfFailed(28, 3, qAdd3.OpenExecute(hDatabase, NULL, sqlIce28AddColumn3));
	qAdd3.Close();

	// determine number of sets
	//!! this relies on correct authoring of this table in that the sets are in sequential order and increase by one only
	PMSIHANDLE hViewNumSets = 0;
	PMSIHANDLE hRecNumSets = 0;
	int iNumSets = 0;
	CQuery qNumSets;
	ReturnIfFailed(28, 4, qNumSets.OpenExecute(hDatabase, NULL, sqlIce28NumSets));
	while (ERROR_SUCCESS == (iStat = qNumSets.Fetch(&hRecNumSets)))
	{
		iNumSets++;
		if (::MsiRecordGetInteger(hRecNumSets, 1) != iNumSets)
		{
			// authoring error
			ICEErrorOut(hInstall, hRecNumSets, Ice28CUBError);
			return ERROR_SUCCESS;
		}
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 28, 5);
		return ERROR_SUCCESS;
	}
	qNumSets.Close();

	// for each set
	for (int i = 1; i <= iNumSets; i++)
	{
		// for each sequence table
		for (int c = 0; c < cSeq28Tables; c++)
		{
			// does table exist??
			if(::MsiDatabaseIsTablePersistent(hDatabase,pIce28SeqTables[c].szName) == MSICONDITION_NONE)
				continue; // skip

			// init temp columns in _SetExclusion table
			PMSIHANDLE hViewInit = 0;
			CQuery qInitColumns;

			ReturnIfFailed(28, 6, qInitColumns.OpenExecute(hDatabase, NULL, sqlIce28InitColumns));
			qInitColumns.Close();

			// find all actions references in _SetExclusion table and update Sequence column with their sequence numbers
			PMSIHANDLE hRecFindAction = 0;

			CQuery qFindAction;
			CQuery qUpdateSequence;
			ReturnIfFailed(28, 7, qFindAction.OpenExecute(hDatabase, NULL, sqlIce28FindAction, pIce28SeqTables[c].szName, pIce28SeqTables[c].szName, pIce28SeqTables[c].szName));
			ReturnIfFailed(28, 8, qUpdateSequence.Open(hDatabase, sqlIce28UpdateSequence));

			while (ERROR_SUCCESS == (iStat = qFindAction.Fetch(&hRecFindAction)))
			{
				// execute view to update
				ReturnIfFailed(28, 9, qUpdateSequence.Execute(hRecFindAction));
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 28, 10);
				return ERROR_SUCCESS;
			}

			// now we need to find the range
			PMSIHANDLE hRecFindRange = 0;
			int iMin = 0;
			int iMax = 0;
			CQuery qFindRange;
			ReturnIfFailed(28, 11, qFindRange.OpenExecute(hDatabase, NULL, sqlIce28FindRange, 
				pIce28SeqTables[c].szName, pIce28SeqTables[c].szName, i, pIce28SeqTables[c].szName));

			BOOL fFirst = TRUE;
			while (ERROR_SUCCESS == (iStat = qFindRange.Fetch(&hRecFindRange)))
			{
				int iSeq = ::MsiRecordGetInteger(hRecFindRange, 1);
				if (MSI_NULL_INTEGER == iSeq)
				{
					APIErrorOut(hInstall, iStat, 28, 12);
					return ERROR_SUCCESS;
				}
				if (fFirst)
				{
					iMin = iSeq;
					fFirst = FALSE;
				}
				iMax = iSeq; 
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 28, 13);
				return ERROR_SUCCESS;
			}

			// if both are zero, we don't need to continue as none of these actions in the set existed
			if (0 == iMin && 0 == iMax)
				continue;

			// update set with Min and Max
			CQuery qUpdate;
			ReturnIfFailed(28, 14, qUpdate.OpenExecute(hDatabase, NULL, sqlIce28UpdateColumns, iMin, iMax, i));
			qUpdate.Close();

			// find invalid
			CQuery qInvalid;
			PMSIHANDLE hRecInvalid = 0;
			ReturnIfFailed(28, 15, qInvalid.OpenExecute(hDatabase, NULL, sqlIce28Invalid));

			// must check resultant set
			while (ERROR_SUCCESS == (iStat = qInvalid.Fetch(&hRecInvalid)))
			{
				int iSequence = ::MsiRecordGetInteger(hRecInvalid, iColIce28Invalid_Sequence);
				int iMin = ::MsiRecordGetInteger(hRecInvalid, iColIce28Invalid_MinCol);
				int iMax = ::MsiRecordGetInteger(hRecInvalid, iColIce28Invalid_MaxCol);

				// compare sequence to RANGE
				if (iSequence >= iMin && iSequence <= iMax)
				{
					ICEErrorOut(hInstall, hRecInvalid, Ice28Error, pIce28SeqTables[c].szName, pIce28SeqTables[c].szName);
					// invalid, breaks up the set
				}
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 28, 16);
				return ERROR_SUCCESS;
			}
		}// for each sequence table
	}// for each set

	return ERROR_SUCCESS;
}
#endif



//////////////////////////////////////////////////////////////////////////
// ICE29 -- validates stream names.  Must be 31 chars or less due to
//   OLE limitations.  If JohnDelo's fix works, then we have up to 60
//   chars to use.
const TCHAR sqlIce29TablesCatalog[] = TEXT("SELECT `Name` FROM `_Tables`");
const TCHAR sqlIce29Table[]         = TEXT("SELECT * FROM `%s`");
const TCHAR sqlIce29CreateTempTable[] = TEXT("CREATE TABLE `_StreamVal` (`Stream` CHAR(65) NOT NULL TEMPORARY PRIMARY KEY `Stream`)");
const TCHAR sqlIce29Insert[]          = TEXT("INSERT INTO `_StreamVal` (`Stream`) VALUES ('%s') TEMPORARY");
ICE_ERROR(Ice29TableTooLong, 29, ietError, "'[1]' table is too long for OLE stream limitation.  Max Allowed is: %d.  Name length is: %d.","%s");
ICE_ERROR(Ice29NotUnique, 29, ietError, "The first %d characters for %s are not unique compared to other streams in the [1] table.","[1]\t%s\t%s");
ICE_ERROR(Ice29Absurdity, 29, ietError, "Your table [1] contains a stream name that is absurdly long. Cannot validate.","[1]");
ICE_ERROR(Ice29FoundTable, 29, ietInfo, "Stream Column Found In [1] Table","")
const int iMaxChar = 62;

ICE_FUNCTION_DECLARATION(29)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 29);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 29, 1);
		return ERROR_SUCCESS;
	}

	// create the temporary table for processing
	CQuery qTempTable;
	ReturnIfFailed(29, 2, qTempTable.OpenExecute(hDatabase, NULL, sqlIce29CreateTempTable));
	qTempTable.Close();

	// open view on _Tables catalog.  WE must find every table where there
	// is a stream column.  DARWIN limitation is max of one STREAM/OBJECT
	// column
	CQuery qCatalog;
	PMSIHANDLE hRecCatalog = 0;
	ReturnIfFailed(29, 3, qCatalog.OpenExecute(hDatabase, NULL, sqlIce29TablesCatalog));

	TCHAR* pszTable = NULL;
	DWORD dwTable = 512;
		
	// fetch every table
	while (ERROR_SUCCESS == qCatalog.Fetch(&hRecCatalog))
	{
		// get name of table
		ReturnIfFailed(29, 4, IceRecordGetString(hRecCatalog, 1, &pszTable, &dwTable, NULL));

		// initialize view on "TABLE"
		CQuery qTable;
		ReturnIfFailed(29, 5, qTable.OpenExecute(hDatabase, NULL, sqlIce29Table, pszTable));

		// get column data type info on "TABLE"
		// we want to find STREAM/OBJECT columns
		PMSIHANDLE hRecColInfo = 0;
		ReturnIfFailed(29, 6, qTable.GetColumnInfo(MSICOLINFO_TYPES, &hRecColInfo));

		// get field count so we can loop through the columns
		UINT cField = ::MsiRecordGetFieldCount(hRecColInfo);
		for (int i = 1; i <= cField; i++)
		{
			TCHAR szColType[32] = {0};
			DWORD cchColType = sizeof(szColType)/sizeof(TCHAR);
			ReturnIfFailed(29, 7, ::MsiRecordGetString(hRecColInfo, i, szColType, &cchColType));

			if ('v' == *szColType || 'V' == *szColType)
			{
				// we found a stream column, let's send an info message stating this
				ICEErrorOut(hInstall, hRecCatalog, Ice29FoundTable);

				// what is the name of this stream column?
				TCHAR* pszColumn = NULL;
				DWORD dwColumn = 512;
				PMSIHANDLE hRecColNames = 0;
				ReturnIfFailed(29, 8, qTable.GetColumnInfo(MSICOLINFO_NAMES, &hRecColNames));
				ReturnIfFailed(29, 9, IceRecordGetString(hRecColNames, i, &pszColumn, &dwColumn, NULL));
	
				// if size of table greater than iMaxChar, report error
				int iLen = 0;
				if ((iLen = _tcslen(pszTable)) > iMaxChar)
				{
					ICEErrorOut(hInstall, hRecCatalog, Ice29TableTooLong, pszTable);
					DELETE_IF_NOT_NULL(pszColumn);
					break; // bust outta loop
				}

				// get primary keys
				PMSIHANDLE hRecPrimaryKeys = 0;
				ReturnIfFailed(29, 10, ::MsiDatabaseGetPrimaryKeys(hDatabase, pszTable, &hRecPrimaryKeys));

				// create the query
				TCHAR sql[iSuperBuf] = {0};
				int cchWritten = _stprintf(sql, TEXT("SELECT "));
				UINT cPrimaryKeys = ::MsiRecordGetFieldCount(hRecPrimaryKeys);

				TCHAR* pszColName = NULL;
				DWORD dwColName = 512;
				for (int j = 1; j <= cPrimaryKeys; j++)
				{
					// get column name
					if (ERROR_SUCCESS != (iStat = IceRecordGetString(hRecPrimaryKeys, j, &pszColName, &dwColName, NULL)))
					{
						//!!buffer size
						APIErrorOut(hInstall, iStat, 29, 11);
						DELETE_IF_NOT_NULL(pszTable);
						DELETE_IF_NOT_NULL(pszColName);
						DELETE_IF_NOT_NULL(pszColumn);
						return ERROR_SUCCESS;
					}
					if (_tcslen(pszColName) + cchWritten +4 > sizeof(sql)/sizeof(TCHAR)) // assume worst case
					{
						APIErrorOut(hInstall, 0, 29, 12);
						DELETE_IF_NOT_NULL(pszTable);
						DELETE_IF_NOT_NULL(pszColName);
						DELETE_IF_NOT_NULL(pszColumn);
						return ERROR_SUCCESS;
					}
					if (j == 1)
						cchWritten += _stprintf(sql + cchWritten, TEXT("`%s`"), pszColName);
					else
						cchWritten += _stprintf(sql + cchWritten, TEXT(", `%s`"), pszColName); 
				}
				DELETE_IF_NOT_NULL(pszColName);

				// only non-null binary data
				if (cchWritten + _tcslen(TEXT(" FROM `%s` WHERE `%s` IS NOT NULL")) > sizeof(sql)/sizeof(TCHAR))
				{
					APIErrorOut(hInstall, 0, 29, 13);
					DELETE_IF_NOT_NULL(pszTable);
					DELETE_IF_NOT_NULL(pszColumn);
					return ERROR_SUCCESS;
				}
				_stprintf(sql + cchWritten, TEXT(" FROM `%s` WHERE `%s` IS NOT NULL"), pszTable, pszColumn);

				// open view on the table
				CQuery qTableKeys;
				PMSIHANDLE hRecTableKeys = 0;
				ReturnIfFailed(29, 11, qTableKeys.OpenExecute(hDatabase, NULL, sql));

				// fetch every row
				while (ERROR_SUCCESS == qTableKeys.Fetch(&hRecTableKeys))
				{
					// create stream name by concatenating table + key1 + key2...
					TCHAR szStream[1024] = {0};
					TCHAR szStreamSav[1024] = {0};
					TCHAR szRow[1024] = {0};
					int iTotalLen = iLen; // length of table
					cchWritten = _stprintf(szStream, TEXT("%s"), pszTable);
					int cchRow = 0;
					BOOL fError = FALSE;
					TCHAR* pszKey = NULL;
					DWORD dwKey = 512;

					for (j = 1; j <= cPrimaryKeys; j++)
					{
						// get key[j]
						ReturnIfFailed(29, 12, IceRecordGetString(hRecTableKeys, j, &pszKey, &dwKey, NULL));

						iTotalLen += _tcslen(pszKey) + 1; // separator + key
						if (iTotalLen > sizeof(szStream)/sizeof(TCHAR))
						{
							ICEErrorOut(hInstall, hRecCatalog, Ice29Absurdity);
							fError = TRUE;
							break;
						}
						if (fError)
						{
							DELETE_IF_NOT_NULL(pszKey);
							continue; // try next row
						}
						cchWritten += _stprintf(szStream + cchWritten, TEXT(".%s"), pszKey);
						cchRow += _stprintf(szRow + cchRow, j == 1 ? TEXT("%s") : TEXT("\t%s"), pszKey); // store for poss. error
					}// for each key

					DELETE_IF_NOT_NULL(pszKey);

					// we can only go up to iMaxChar, terminate there
					if (iTotalLen > iMaxChar)
					{
						_tcscpy(szStreamSav, szStream);
						szStream[iMaxChar+1] = '\0';
					}

					// attempt to insert value into TempTable

					CQuery qInsert;
					ReturnIfFailed(29, 13, qInsert.Open(hDatabase, sqlIce29Insert, szStream));
					if (ERROR_SUCCESS != qInsert.Execute(NULL))
					{
						// insert failed into temp table.
						// we are NOT UNIQUE
						ICEErrorOut(hInstall, hRecCatalog, Ice29NotUnique, iMaxChar, szStreamSav, pszColumn, szRow);
					}
				}// for each row

				DELETE_IF_NOT_NULL(pszColumn);;

				// since DARWIN only allows max of 1 stream column per table, we can stop
				break;
			}
		}// for each column
	}// for each table

	DELETE_IF_NOT_NULL(pszTable);

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\msiice.dll\sources.inc ===
TARGETNAME=msiice
!INCLUDE ..\..\..\..\MsiMake.inc

TARGETTYPE=DYNLINK
TARGETLIBS= \
	$(BUILD_DIR)\msi.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1
USE_NATIVE_EH=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\msiice.def
BINPLACE_PLACEFILE=..\..\placefil.txt


INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msiice.cpp \
	..\msiice2.cpp \
	..\msiice3.cpp \
	..\msiice4.cpp \
	..\msiice5.cpp \
	..\msiice6.cpp \
	..\msiice.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\msiice.dll\msiice6.cpp ===
/* msiice6.cpp - Darwin ICE40-57 code  Copyright  1998-1999 Microsoft Corporation
____________________________________________________________________________*/

#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>  // included for both CPP and RC passes
#ifndef RC_INVOKED    // start of CPP source code
#include <stdio.h>    // printf/wprintf
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "msidefs.h"  // must be in this directory or on INCLUDE path
#include "..\..\common\msiice.h"
#include "..\..\common\query.h"

//!! Fix warnings and remove pragma
#pragma warning(disable : 4018) // signed/unsigned mismatch

///////////////////////////////////////////////////////////////////////
// ICE40, checks for miscellaneous errors. 

// not shared with merge module subset
#ifndef MODSHAREDONLY
TCHAR sqlICE40a[] = TEXT("SELECT * FROM `Property` WHERE `Property`='REINSTALLMODE'");
TCHAR sqlICE40b[] = TEXT("SELECT * FROM `RemoveIniFile` WHERE (`Action`=4) AND (`Value` IS NULL)");

ICE_ERROR(ICE40HaveReinstallMode, 40, ietWarning, "REINSTALLMODE is defined in the Property table. This may cause difficulties.","Property\tProperty\tREINSTALLMODE");
ICE_ERROR(ICE40MissingErrorTable, 40, ietWarning, "Error Table is missing. Only numerical error messages will be generated.","Error");
ICE_ERROR(ICE40RemoveIniFileError, 40, ietError, "RemoveIniFile entry [1] must have a value, because the Action is \"Delete Tag\" (4).","RemoveIniFile\tRemoveIniFile\t[1]");
static const int iIce40ErrorTableRequiredMaxSchema = 100;

ICE_FUNCTION_DECLARATION(40)
{
	UINT iStat = ERROR_SUCCESS;
	PMSIHANDLE hErrorRecord = ::MsiCreateRecord(1);

	// display info
	DisplayInfo(hInstall, 40);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if property table, check for REINSTALLMODE
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 40, TEXT("Property")))
	{
		CQuery qProperty;
		PMSIHANDLE hRecord;
		ReturnIfFailed(40, 1, qProperty.OpenExecute(hDatabase, NULL, sqlICE40a));
		if (ERROR_SUCCESS == qProperty.Fetch(&hRecord))
			ICEErrorOut(hInstall, hRecord, ICE40HaveReinstallMode);
	};

	// check that we have an error table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 40, TEXT("Error")))
	{
		// Error table is only required for packages of schema 100 or less.
		// Starting with WI version 1.1 and greater, Error table became optional with use of msimsg.dll
		PMSIHANDLE hSummaryInfo = 0;
		if (IceGetSummaryInfo(hInstall, hDatabase, 40, &hSummaryInfo))
		{
			int iPackageSchema = 0;
			UINT iType = 0; 
			FILETIME ft;
			TCHAR szBuf[1];
			DWORD dwBuf = sizeof(szBuf)/sizeof(TCHAR);
			ReturnIfFailed(40, 4, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_PAGECOUNT, &iType, &iPackageSchema, &ft, szBuf, &dwBuf));
			if (iPackageSchema <= iIce40ErrorTableRequiredMaxSchema)
				ICEErrorOut(hInstall, hErrorRecord, ICE40MissingErrorTable);
		}
		else
			ICEErrorOut(hInstall, hErrorRecord, ICE40MissingErrorTable);
	}
	
	// check RemoveIniFile table
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 40, TEXT("RemoveIniFile")))
	{
		CQuery qBadEntries;
		PMSIHANDLE hBadEntryRec;
		ReturnIfFailed(40, 2, qBadEntries.OpenExecute(hDatabase, NULL, sqlICE40b));
		while (ERROR_SUCCESS == (iStat = qBadEntries.Fetch(&hBadEntryRec)))
			ICEErrorOut(hInstall, hBadEntryRec, ICE40RemoveIniFileError);
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 40, 3);
			return ERROR_SUCCESS;
		}
		qBadEntries.Close();
	}
	return ERROR_SUCCESS;
}
#endif

///////////////////////////////////////////////////////////////////////
// ICE41, checks that components listed in the advertising tables belong
// to the features listed in the advertising tables

// not shared with merge module subset
#ifndef MODSHAREDONLY
TCHAR sqlIce41GetExtension[] = TEXT("SELECT `Component_`, `Feature_`, `Extension` FROM `Extension`");
TCHAR sqlIce41GetClass[] = TEXT("SELECT `Component_`, `Feature_`, `CLSID`, `Context` FROM `Class`");
TCHAR sqlIce41GetFC[] = TEXT("SELECT * FROM `FeatureComponents` WHERE (`Component_`=?) AND (`Feature_`=?)");

ICE_ERROR(Ice41NoFeatureComponents, 41, ietError, "Class [3] references feature [2] and component [1], but the FeatureComponents table is missing, so no associaton exists.","Class\tCLSID\t[3]\t[4]\t[1]");
ICE_ERROR(Ice41NoLink, 41, ietError, "Class [3] references feature [2] and component [1], but the that Component is not associated with that Feature in the FeatureComponents table..","Class\tCLSID\t[3]\t[4]\t[1]");
ICE_ERROR(Ice41NoFeatureComponentsEx, 41, ietError, "Extension [3] references feature [2] and component [1], but the FeatureComponents table is missing, so no associaton exists.","Extension\tExtension\t[3]\t[1]");
ICE_ERROR(Ice41NoLinkEx, 41, ietError, "Extension [3] references feature [2] and component [1], but the that Component is not associated with that Feature in the FeatureComponents table..","Extension\tExtension\t[3]\t[1]");


ICE_FUNCTION_DECLARATION(41)
{
	UINT iStat = ERROR_SUCCESS;
	BOOL bHaveFeatureComponents;

	// display info
	DisplayInfo(hInstall, 41);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// check that we have a FeatureComponents table
	bHaveFeatureComponents = IsTablePersistent(FALSE, hInstall, hDatabase, 41, TEXT("FeatureComponents"));

	PMSIHANDLE hResult;
	PMSIHANDLE hFCRec;
	CQuery qFeatureComponents;
	if (bHaveFeatureComponents)
		ReturnIfFailed(41, 2, qFeatureComponents.Open(hDatabase, sqlIce41GetFC));

	// if no class table, OK
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 41, TEXT("Class")))
	{
		CQuery qClass;
		ReturnIfFailed(41, 1, qClass.OpenExecute(hDatabase, NULL, sqlIce41GetClass));
		
		while (ERROR_SUCCESS == (iStat = qClass.Fetch(&hResult)))
		{
			// for each class table entry, make sure there is an entry in
			// the FeatureComponents table.
			if (!bHaveFeatureComponents) 
			{
				ICEErrorOut(hInstall, hResult, Ice41NoFeatureComponents);
				continue;
			}

			ReturnIfFailed(41, 3, qFeatureComponents.Execute(hResult));
			if (ERROR_NO_MORE_ITEMS == (iStat = qFeatureComponents.Fetch(&hFCRec)))
				ICEErrorOut(hInstall, hResult, Ice41NoLink);
			else if (ERROR_SUCCESS != iStat)
			{
				APIErrorOut(hInstall, iStat, 41, 4);
				return ERROR_SUCCESS;
			}
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 41, 5);
			return ERROR_SUCCESS;
		}
		qClass.Close();
	}

	// now check extension table
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 41, TEXT("Extension")))
	{
		CQuery qExtension;
		ReturnIfFailed(41, 6, qExtension.OpenExecute(hDatabase, NULL, sqlIce41GetExtension));
		while (ERROR_SUCCESS == (iStat = qExtension.Fetch(&hResult)))
		{
			// for each class table entry, make sure there is an entry in
			// the FeatureComponents table.
			if (!bHaveFeatureComponents) 
			{
				ICEErrorOut(hInstall, hResult, Ice41NoFeatureComponentsEx);
				continue;
			}

			ReturnIfFailed(41, 7, qFeatureComponents.Execute(hResult));
			if (ERROR_NO_MORE_ITEMS == (iStat = qFeatureComponents.Fetch(&hFCRec)))
				ICEErrorOut(hInstall, hResult, Ice41NoLinkEx);
			else if (ERROR_SUCCESS != iStat)
			{
				APIErrorOut(hInstall, iStat, 41, 8);
				return ERROR_SUCCESS;
			}
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 41, 9);
			return ERROR_SUCCESS;
		}
		qExtension.Close();	
	}
	qFeatureComponents.Close();
	return ERROR_SUCCESS;
}
#endif

static const TCHAR sqlICE42GetInProcServers[] = TEXT("SELECT `Class`.`CLSID`,  `Class`.`Context`, `Component`.`Component`, `File`.`File`, `File`.`FileName` FROM `Class`, `Component`, `File` WHERE ((`Class`.`Context`='InProcServer') OR (`Class`.`Context`='InProcServer32')) AND (`Class`.`Component_`=`Component`.`Component`) AND (`Component`.`KeyPath`=`File`.`File`)");
static const int   iColICE42GetInProcServers_CLSID		= 1;
static const int   iColICE42GetInProcServers_Context	= 2;
static const int   iColICE42GetInProcServers_Component	= 3;
static const int   iColICE42GetInProcServers_File		= 4;
static const int   iColICE42GetInProcServers_FileName	= 5;

static const TCHAR sqlICE42GetBadServers[] = TEXT("SELECT `CLSID`, `Context`, `Component_`, `Argument`, `DefInprocHandler` FROM `Class` WHERE (`Context`<>'LocalServer') AND (`Context`<>'LocalServer32') AND ((`Argument` IS NOT NULL) OR (`DefInprocHandler` IS NOT NULL))");
static const int   iColICE42GetBadServers_CLSID				= 1;
static const int   iColICE42GetBadServers_Context			= 2;
static const int   iColICE42GetBadServers_Component			= 3;
static const int   iColICE42GetBadServers_Argument			= 4;
static const int   iColICE42GetBadServers_DefInprocHandler	= 5;

ICE_ERROR(Ice42BigFile, 42, ietWarning, "The Filename of component [3] (for CLSID [1]) is too long to validate.","File\tFileName\t[4]");
ICE_ERROR(Ice42Exe, 42, ietError, "CLSID [1] is an InProc server, but the implementing component [3] has an EXE ([5]) as its KeyFile.","Class\tContext\t[1]\t[2]\t[3]");
ICE_ERROR(Ice42BadArg, 42, ietError, "CLSID [1] in context [2] has an argument. Only LocalServer contexts can have arguments.","Class\tCLSID\t[1]\t[2]\t[3]");
ICE_ERROR(Ice42BadDefault, 42, ietError, "CLSID [1] in context [2] specifies a default InProc value. Only LocalServer contexts can have default InProc values.","Class\tCLSID\t[1]\t[2]\t[3]");

ICE_FUNCTION_DECLARATION(42)
{
	UINT iStat = ERROR_SUCCESS;
	TCHAR szFilename[512];
	unsigned long cchFilename = 512;

	// display info
	DisplayInfo(hInstall, 42);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// check that we have a FeatureComponents table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 42, TEXT("Class")))
		return ERROR_SUCCESS;

	CQuery qServers;
	PMSIHANDLE hServerRec;
	ReturnIfFailed(42, 1, qServers.OpenExecute(hDatabase, NULL, sqlICE42GetInProcServers));

	// This query retrieves the files that implement all InProcServer32 and InProcServer CLSIDs
	while (ERROR_SUCCESS == (iStat = qServers.Fetch(&hServerRec)))
	{
		unsigned long cchDummy = cchFilename;
		// now get the string, could be up to 255 long. We'll be nice and give it 512.
		iStat = ::MsiRecordGetString(hServerRec, iColICE42GetInProcServers_FileName, 
			szFilename, &cchDummy);
		switch (iStat) {
		case ERROR_MORE_DATA: 
			// naughty naughty, big filename.
			ICEErrorOut(hInstall, hServerRec, Ice42BigFile);
			continue;
		case ERROR_SUCCESS:
			// good.
			break;
		default:
			// bad
			APIErrorOut(hInstall, 2, 42, 2);
			continue;
		}
	
		// darwin gives us the length in cchDummy, so it makes comparing easy!
		if (cchDummy > 4) {
			if (_tcsnicmp(&szFilename[cchDummy-4], TEXT(".exe"), 4)==0)
			{
				ICEErrorOut(hInstall, hServerRec, Ice42Exe);
				continue;
			}

			// also have to check for SFN|LFN 
			TCHAR *pszBarLoc = _tcschr(szFilename, TEXT('|'));
			if ((pszBarLoc != NULL) && (pszBarLoc > szFilename+4))
				if (_tcsnicmp(pszBarLoc-4, TEXT(".exe"), 4)==0)
					ICEErrorOut(hInstall, hServerRec, Ice42Exe);
		}
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 42, 8);
		return ERROR_SUCCESS;
	}

	// next check for invalid server enttries (bad arguments are definproc)
	CQuery qBadArgs;
	PMSIHANDLE hBadArgRec;
	ReturnIfFailed(42, 9, qBadArgs.OpenExecute(hDatabase, NULL, sqlICE42GetBadServers));

	// retrieve bad server entries
	while (ERROR_SUCCESS == (iStat = qBadArgs.Fetch(&hBadArgRec)))
	{
		// if the argument is not null
		if (!::MsiRecordIsNull(hBadArgRec, iColICE42GetBadServers_Argument))
			ICEErrorOut(hInstall, hBadArgRec, Ice42BadArg);
		// if default is not null
		if (!::MsiRecordIsNull(hBadArgRec, iColICE42GetBadServers_DefInprocHandler))
			ICEErrorOut(hInstall, hBadArgRec, Ice42BadDefault);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 42, 10);
		return ERROR_SUCCESS;
	}
	qBadArgs.Close();

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// ICE 43. Verifies that non-advertised shortcuts have HKCU entries

// not shared with merge module subset
#ifndef MODSHAREDONLY
static const TCHAR sqlICE43CreateColumn[] = TEXT("ALTER TABLE `Shortcut` ADD `_ICE43Mark` SHORT TEMPORARY");
static const TCHAR sqlICE43InitColumn[] = TEXT("UPDATE `Shortcut` SET `_ICE43Mark`=0");
static const TCHAR sqlICE43MarkAdvertised[] = TEXT("UPDATE `Shortcut`,`Feature` SET `Shortcut`.`_ICE43Mark`=1 WHERE `Shortcut`.`Target`=`Feature`.`Feature`");
static const TCHAR sqlICE43MarkNonProfile[] = TEXT("UPDATE `Shortcut`,`Directory` SET `Shortcut`.`_ICE43Mark`=1 WHERE (`Shortcut`.`Directory_`=`Directory`.`Directory`) AND (`Directory`.`_Profile`<>2)");
static const TCHAR sqlICE43GetComponents[] = TEXT("SELECT DISTINCT `Component`.`KeyPath`, `Component`.`Component`, `Component`.`Attributes` FROM `Shortcut`,`Component` WHERE (`Shortcut`.`_ICE43Mark`<>1) AND (`Shortcut`.`Component_`=`Component`.`Component`)");
static const TCHAR sqlICE43FreeColumn[] = TEXT("ALTER TABLE `Directory` FREE");

ICE_ERROR(Ice43NonRegistry, 43, ietError, "Component [2] has non-advertised shortcuts. It should use a registry key under HKCU as its KeyPath, not a file.","Component\tAttributes\t[2]");
ICE_ERROR(Ice43NoRegTable, 43, ietError, "Component [2] has non-advertised shortcuts. It should use a registry key under HKCU as its KeyPath, but the Registry table is missing.","Component\tKeyPath\t[2]");
ICE_ERROR(Ice43NullPath, 43, ietError, "Component [2] has non-advertised shortcuts. It should use a registry key under HKCU as its KeyPath. The KeyPath is currently NULL.","Component\tComponent\t[2]");
ICE_ERROR(Ice43NonHKCU, 43, ietError, "Component [2] has non-advertised shortcuts. It's KeyPath registry key should fall under HKCU.","Registry\tRoot\t[1]");
ICE_ERROR(Ice43NoRegEntry, 43, ietError, "The KeyPath registry entry for component [2] does not exist.","Component\tKeyPath\t[2]");
ICE_ERROR(Ice43NotOwner, 43, ietError, "The Registry Entry [1] is set as the KeyPath for component [2], but that registry entry doesn't belong to [2].","Registry\tComponent_\t[1]");

ICE_FUNCTION_DECLARATION(43)
{
	// display info
	DisplayInfo(hInstall, 43);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// check for shortcut table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 43, TEXT("Shortcut")))
		return ERROR_SUCCESS;

	// check for component table.
	if (!IsTablePersistent(TRUE, hInstall, hDatabase, 43, TEXT("Component")))
		return ERROR_SUCCESS;

	// check for feature table. If not one, no shortcuts are advertised.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 43, TEXT("Feature")))
		return ERROR_SUCCESS;

	// create the column
	CQuery qColumn;
	ReturnIfFailed(43, 1, qColumn.OpenExecute(hDatabase, NULL, sqlICE43CreateColumn));

	// init the temporary column
	CQuery qInit;
	ReturnIfFailed(43, 2, qInit.OpenExecute(hDatabase, NULL, sqlICE43InitColumn));
	qInit.Close();

	// mark all shortcuts that are advertised, and thus DON'T need to be checked.
	CQuery qMark;
	ReturnIfFailed(43, 3, qMark.OpenExecute(hDatabase, NULL, sqlICE43MarkAdvertised));
	qMark.Close();

	// mark all shortcuts that are not created in the profile and thus DON'T need to be checked
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 43, TEXT("Directory")))
	{
		// manage Directory table hold count (received from MarkProfile)
		// extra free won't hurt us -- MarkProfile could fail after setting HOLD on Directory table
		CManageTable MngDirectoryTable(hDatabase, TEXT("Directory"), /*fAlreadyLocked = */true);
		// mark profile dirs
		MarkProfile(hInstall, hDatabase, 43);
		CQuery qMark;
		ReturnIfFailed(43, 4, qMark.OpenExecute(hDatabase, NULL, sqlICE43MarkNonProfile));
		qMark.OpenExecute(hDatabase, NULL, sqlICE43FreeColumn);
		MngDirectoryTable.RemoveLockCount();
	}

	// fetch and check all marked components
	CQuery qComponents;
	ReturnIfFailed(43, 6, qComponents.OpenExecute(hDatabase, NULL, sqlICE43GetComponents));
	CheckComponentIsHKCU(hInstall, hDatabase, 43, qComponents, &Ice43NonRegistry, &Ice43NullPath, 
		&Ice43NoRegTable, &Ice43NoRegEntry, &Ice43NotOwner, &Ice43NonHKCU, NULL);

	// done
	return ERROR_SUCCESS;
}
#endif

///////////////////////////////////////////////////////////////////////
// ICE 44. Checks for SpawnDialog or NewDialog actions that do not
// point to valid entries in the dialog table.
const TCHAR sqlIce44GetBadEvents[] = TEXT("SELECT `ControlEvent`.`Argument`,  `ControlEvent`.`Event`, `ControlEvent`.`Dialog_`, `ControlEvent`.`Control_`, `ControlEvent`.`Condition` FROM `ControlEvent` WHERE ((`ControlEvent`.`Event`='SpawnDialog') OR (`ControlEvent`.`Event`='NewDialog') OR (`ControlEvent`.`Event`='SpawnWaitDialog'))");
const int	iColIce44GetBadEvents_Argument	= 1;
const int	iColIce44GetBadEvents_Event		= 2;
const int	iColIce44GetBadEvents_Dialog	= 3;
const int	iColIce44GetBadEvents_Control	= 4;
const int	iColIce44GetBadEvents_Condition	= 5;

const TCHAR sqlIce44Dialog[] = TEXT("SELECT `Dialog` FROM `ControlEvent`, `Dialog` WHERE (`Dialog`=?)");
const TCHAR sqlIce44ControlEvent[] = TEXT("SELECT `Dialog_` FROM `ControlEvent`");
const int	iColIce44Dialog_Dialog = 1;

ICE_ERROR(Ice44Error, 44, ietError, "Control Event for Control '[3]'.'[4]' is of type [2], but its argument [1] is not a valid entry in the Dialog Table.","ControlEvent\tEvent\t[3]\t[4]\t[2]\t[1]\t[5]"); 
ICE_ERROR(Ice44NoDialogTable, 44, ietError, "Control Event table has entries, but the Dialog Table is missing.","ControlEvent"); 
ICE_ERROR(Ice44NullArgument, 44, ietError, "Control Event for Control '[3]'.'[4]' is of type [2], but the argument is Null. It must be a key into the dialog table.","ControlEvent\tEvent\t[3]\t[4]\t[2]\t[1]\t[5]"); 
ICE_FUNCTION_DECLARATION(44)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 44);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// check for controlevent table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 44, TEXT("ControlEvent")))
		return ERROR_SUCCESS;

	// check for dialog table
	bool bHaveDialog = IsTablePersistent(FALSE, hInstall, hDatabase, 44, TEXT("Dialog"));

	CQuery qControlEvent;
	PMSIHANDLE hRecCE = 0;
	iStat = qControlEvent.FetchOnce(hDatabase, NULL, &hRecCE, sqlIce44ControlEvent);
	if (iStat == ERROR_SUCCESS && !bHaveDialog)
	{
		hRecCE = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecCE, Ice44NoDialogTable);
		return ERROR_SUCCESS;
	}
	else if (iStat == ERROR_NO_MORE_ITEMS && !bHaveDialog)
		return ERROR_SUCCESS;
		

	CQuery qGetEvents;
	CQuery qDialog;
	ReturnIfFailed(44, 1, qGetEvents.OpenExecute(hDatabase, NULL, sqlIce44GetBadEvents));
	ReturnIfFailed(44, 2, qDialog.Open(hDatabase, sqlIce44Dialog));

	PMSIHANDLE hResult;
	PMSIHANDLE hUnusedRec;

	TCHAR szDialog[512];
	unsigned long cchDialog = 512;

	while (ERROR_SUCCESS == (iStat = qGetEvents.Fetch(&hResult)))
	{
		if (::MsiRecordIsNull(hResult, iColIce44GetBadEvents_Argument)) 
		{
			ICEErrorOut(hInstall, hResult, Ice44NullArgument);
			continue;
		}

		// now retrieve the string and check for '[]' pairs (property values which might
		// resolve to dialogs at runtime)
		cchDialog = 512;
		// schema allows 255 in this column. The ICE is nice and gives them 512.
		ReturnIfFailed(44, 3, ::MsiRecordGetString(hResult, iColIce44GetBadEvents_Argument, 
			szDialog, &cchDialog));
		TCHAR *pchLeftBracket;
		// look for a left bracket followed by a right bracket
		if ((pchLeftBracket = _tcschr(szDialog, _T('['))) &&
			(_tcschr(pchLeftBracket, _T(']'))))
			// found brackets, possible property. Skip this one.
			continue;

		// now check for an entry in the dialog table.
		ReturnIfFailed(44, 4, qDialog.Execute(hResult));
		switch (iStat = qDialog.Fetch(&hUnusedRec))
		{
		case ERROR_SUCCESS:
			// no error
			break;
		case ERROR_NO_MORE_ITEMS:
			ICEErrorOut(hInstall, hResult, Ice44Error);
			break;
		default:
			APIErrorOut(hInstall, iStat, 44, 4);
			return ERROR_SUCCESS;
		}
		qDialog.Close();
	}
	return ERROR_SUCCESS;
}

//////////////////////////////////////////////////////////////////////
// ICE 45. Verifies that reserved bits in the various attributes column
// are not set.

static const TCHAR sqlIce45GetRow[] = TEXT("SELECT * FROM `%s`%s%s");
ICE_ERROR(Ice45BitError, 45, ietError, "Row '%s' in table '%s' has bits set in the '%s' column that are reserved. They must be 0 to ensure compatability with future installer versions.","%s\t%s\t%s"); 
ICE_ERROR(Ice45BitWarning, 45, ietWarning, "Row '%s' in table '%s' has bits set in the '%s' column that are reserved. They should be 0 to ensure compatability with future installer versions.","%s\t%s\t%s"); 
ICE_ERROR(Ice45FutureWarning, 45, ietWarning, "Row '%s' in table '%s' has bits set in the '%s' column that are not used in the schema of the package, but are used in a later schema. Your package can run on systems where this attribute has no effect.","%s\t%s\t%s"); 

static const TCHAR sqlIce45GetColumn[] = TEXT("SELECT `Number` FROM `_Columns` WHERE `Table`=? AND `Name`=?");
static const int iColIce45GetColumn_Number = 1;

static const TCHAR sqlIce45PrivateTable[] = TEXT("SELECT `Table`, `Column`, `Condition`, `MinSchema`, `UsedBits`, `Error` FROM `_ReservedBits` WHERE (`MinSchema` IS NULL OR `MinSchema` <= %d) AND (`MaxSchema` >= %d OR `MaxSchema` IS NULL) ORDER BY `Table`, `Column`, `MinSchema`");
static const int iColIce45PrivateTable_Table = 1;
static const int iColIce45PrivateTable_Column = 2;
static const int iColIce45PrivateTable_Condition = 3;
static const int iColIce45PrivateTable_MinSchema = 4;
static const int iColIce45PrivateTable_UsedBits = 5;
static const int iColIce45PrivateTable_Error = 6;

static const TCHAR sqlIce45FutureSchema[] = TEXT("SELECT `UsedBits` FROM `_ReservedBits` WHERE `Table`=? AND `Column`=? AND `Condition`=? AND `MinSchema` > ?");

ICE_FUNCTION_DECLARATION(45)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 45);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// check to see if the evaluation system supports summaryinfo evaluation and get the schema version
	PMSIHANDLE hSummaryInfo = 0;
	
	int iSchema = 0;
	UINT iType = 0;
	FILETIME ft;
	TCHAR szBuf[1];
	DWORD dwBuf = sizeof(szBuf)/sizeof(TCHAR);
	if (!IceGetSummaryInfo(hInstall, hDatabase, 45, &hSummaryInfo))
		return ERROR_SUCCESS;
	ReturnIfFailed(45, 3, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_PAGECOUNT, &iType, &iSchema, &ft, szBuf, &dwBuf));

	// check that our private table exists
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 45, TEXT("_ReservedBits")))
		return ERROR_SUCCESS;

	CQuery qGetBits;
	ReturnIfFailed(45, 4, qGetBits.OpenExecute(hDatabase, 0, sqlIce45PrivateTable, iSchema, iSchema));

	CQuery qColumn;
	CQuery qFutureSchema;
	ReturnIfFailed(45, 5, qColumn.Open(hDatabase, sqlIce45GetColumn));
	ReturnIfFailed(45, 6, qFutureSchema.Open(hDatabase, sqlIce45FutureSchema));
	PMSIHANDLE hTable = 0;
	while (ERROR_SUCCESS == (iStat = qGetBits.Fetch(&hTable)))
	{
		// table names limited to 31 chars
		TCHAR szTable[64];
		TCHAR *szColumn = NULL;
		TCHAR *szHumanReadable = NULL;
		TCHAR *szTabDelimited = NULL;

		// see if the column in question exists, and if so, get the column number
		PMSIHANDLE hResult;
		ReturnIfFailed(45, 7, qColumn.Execute(hTable));
		switch (iStat = qColumn.Fetch(&hResult))
		{
		case ERROR_NO_MORE_ITEMS:
			continue;
		case ERROR_SUCCESS:
			break;
		default:
			APIErrorOut(hInstall, iStat, 45, 8);
			return ERROR_SUCCESS;
		}
		UINT iColumn = ::MsiRecordGetInteger(hResult, iColIce45GetColumn_Number);
						
		// get the table name
		DWORD cchTable = 64;
		ReturnIfFailed(45, 9, MsiRecordGetString(hTable, iColIce45PrivateTable_Table, szTable, &cchTable));

		// get the column name
		DWORD cchColumn = 50;
		ReturnIfFailed(45, 11, IceRecordGetString(hTable, iColIce45PrivateTable_Column, &szColumn, &cchColumn, NULL));
		
		// get this schema's attributes
		DWORD dwThisSchema = ~::MsiRecordGetInteger(hTable, iColIce45PrivateTable_UsedBits); 

		// get the attributes for future schemas.
		DWORD dwFutureSchema = dwThisSchema;
		if (::MsiRecordIsNull(hTable, iColIce45PrivateTable_MinSchema))
			::MsiRecordSetInteger(hTable, iColIce45PrivateTable_MinSchema, 0);

		ReturnIfFailed(45, 12, qFutureSchema.Execute(hTable))
		PMSIHANDLE hFutureSchema = 0;
		while (ERROR_SUCCESS == (iStat = qFutureSchema.Fetch(&hFutureSchema)))
		{
			dwFutureSchema &= ~::MsiRecordGetInteger(hFutureSchema, 1);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 45, 13);
		
		// run the query to get the attributes in each row. This involves getting the condition for this recordset
		CQuery qFile;
		PMSIHANDLE hFileRec;
		LPCTSTR szWhere = TEXT("");
		LPTSTR szWhereClause = NULL;
		if (!::MsiRecordIsNull(hTable, iColIce45PrivateTable_Condition))
		{
			szWhere = TEXT(" WHERE "); 
			ReturnIfFailed(45, 14, IceRecordGetString(hTable, iColIce45PrivateTable_Condition, &szWhereClause, NULL, NULL));
		}	
		ReturnIfFailed(45, 14, qFile.OpenExecute(hDatabase, NULL, sqlIce45GetRow, szTable, szWhere, szWhereClause ? szWhereClause : TEXT("")));
		if (szWhereClause)
		{
			delete[] szWhereClause;
			szWhereClause = NULL;
		}
		
		while (ERROR_SUCCESS == (iStat = qFile.Fetch(&hFileRec)))
		{
			// we use the ietInfo type to store row's state.
			// ietInfo means no problem, ietError or ietWarning mean what they say
			ietEnum ietRowStatus = ietInfo;
			
			if (::MsiRecordIsNull(hFileRec, iColumn))
				continue;
			DWORD iAttributes = ::MsiRecordGetInteger(hFileRec, iColumn);
			if (iAttributes & dwThisSchema)
			{
				// bit is reserved. See if some future schema knows about it. If so, warning only
				if (iAttributes & dwFutureSchema)
				{
					ietRowStatus = ietError;
				}
				else
					ietRowStatus = ietWarning;
			}

			if (ietInfo != ietRowStatus) 
			{
				if (!szHumanReadable)
					GeneratePrimaryKeys(45, hInstall, hDatabase, szTable, &szHumanReadable, &szTabDelimited);
				if (ietRowStatus == ietError)
				{
					// nobody knows about this bit, so its an error. But if the Error column of the column record is
					// null, its just a friendly warning.
					if (::MsiRecordIsNull(hTable, iColIce45PrivateTable_Error))
						ICEErrorOut(hInstall, hFileRec, Ice45BitWarning, szHumanReadable, szTable, szColumn, szTable, szColumn, szTabDelimited);
					else
						ICEErrorOut(hInstall, hFileRec, Ice45BitError, szHumanReadable, szTable, szColumn, szTable, szColumn, szTabDelimited);
				}
				else
					ICEErrorOut(hInstall, hFileRec, Ice45FutureWarning, szHumanReadable, szTable, szColumn, szTable, szColumn, szTabDelimited);				
			}
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 45, 15);

		if (szColumn) delete[] szColumn;
		if (szHumanReadable) delete[] szHumanReadable;
		if (szTabDelimited) delete[] szTabDelimited;
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 45, 16);
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// ICE46, checks for case-mismatches in properties between their 
// definitions in the property table (or system properties)
// and usage in conditions, directory tables, and formattedText.
class Ice46Hash
{
public:
	enum MatchResult { 
		matchFalse = 0,
		matchExact = 1,
		matchNoCase = 2
	};

	MatchResult Exists(const WCHAR *item) const;
	void Add(const WCHAR *item);

	Ice46Hash();
	~Ice46Hash();

private:
	struct bucket {
		WCHAR *data;
		bucket *next;
	};

	// private functions
	void Resize();
	int Hash(const WCHAR *item) const;
	void InternalAdd(bucket *pNewBucket);

	// data
	bucket **m_Table;
	int m_cItems;
	int m_iTableSize;
};

Ice46Hash::Ice46Hash() 
{
	m_iTableSize = 50;
	m_cItems = 0;
	m_Table = new bucket *[m_iTableSize];
	for (int i=0; i < m_iTableSize; m_Table[i++] = NULL) ;
}

Ice46Hash::~Ice46Hash()
{
	bucket *current;
	bucket *next; 
	for (int i=0; i < m_iTableSize; i++) 
	{
		current = m_Table[i];
		while (current)
		{
			next = current->next;
			delete current;
			current = next;
		}
	}
	delete [] m_Table;
}

Ice46Hash::MatchResult Ice46Hash::Exists(const WCHAR *item) const
{
	bool bMatchNoCase = false;
	int i = Hash(item);
	bucket *current = m_Table[i];
	while (current)
	{
		if (wcscmp(current->data, item) == 0) return matchExact;
		if (_wcsicmp(current->data, item) == 0) bMatchNoCase = true;
		current = current->next;
	}
	return bMatchNoCase ? matchNoCase : matchFalse;
}

void Ice46Hash::Add(const WCHAR *item) 
{
	WCHAR *temp = new WCHAR[wcslen(item)+1];
	wcscpy(temp, item);
	bucket *pNewBucket = new bucket;
	pNewBucket->next = NULL;
	pNewBucket->data = temp;
	InternalAdd(pNewBucket);
	if (m_cItems == m_iTableSize)
		Resize();
}

void Ice46Hash::InternalAdd(bucket *pNewBucket) 
{
	bucket **current = &m_Table[Hash(pNewBucket->data)];
	while (*current) current = &((*current)->next);
	*current = pNewBucket;
	m_cItems++;
}

void Ice46Hash::Resize()
{
	int i;
	bucket** pOldTable = m_Table;
	int iOldTableSize = m_iTableSize;
	m_iTableSize *= 2;
	m_Table = new bucket *[m_iTableSize];
	for (i = 0; i < m_iTableSize; i++)
		m_Table[i] = NULL;
	m_cItems = 0;

	bucket *current;
	bucket *temp;
	for (i=0; i < iOldTableSize; i++)
	{
		current = pOldTable[i];
		while (current)
		{
			temp = current->next;
			current->next = NULL;
			InternalAdd(current);
			current = temp;
		}
	}
	delete[] pOldTable;
}

int Ice46Hash::Hash(const WCHAR *item) const
{
	int hashval = 0;
	const WCHAR *current = item;
	while (*current) 
		hashval ^= towlower(*(current++));
	return hashval % m_iTableSize;
}

// query for defined properties
static const TCHAR sqlIce46Property[] = TEXT("SELECT `Property` FROM `Property`");
static const int	iColIce46Property_Property = 1;

// queries for various definition types.
// the order of columns in results is critical. Must be Table, Column
static const TCHAR sqlIce46FormattedTypes[] = TEXT("SELECT `Table`, `Column` FROM `_Validation` WHERE (`Category`='Formatted') OR (`Category`='Path') OR (`Category`='Paths') OR (`Category`='RegPath') OR (`Category`='Template')");
static const int	iColIce46FormattedTypes_Table = 1;
static const int	iColIce46FormattedTypes_Column = 2;

static const TCHAR sqlIce46ConditionType[] = TEXT("SELECT `Table`, `Column` FROM `_Validation` WHERE (`Category`='Condition')");
static const int	iColIce46ConditionType_Table = 1;
static const int	iColIce46ConditionType_Column = 2;

static const TCHAR sqlIce46ForeignKey[] = TEXT("SELECT `Table`, `Column` FROM `_Validation` WHERE (`KeyTable`='Property') AND (`KeyColumn`=1)");
static const int	iColIce46ForeignKey_Table = 1;
static const int	iColIce46ForeignKey_Column = 2;

static const TCHAR sqlIce46SpecialColumn[] = TEXT("SELECT `Table`, `Column` FROM `_Validation` WHERE (`Table`='Directory') AND (`Column`='Directory')");
static const int	iColIce46SpecialColumn_Table = 1;
static const int	iColIce46SpecialColumn_Column = 2;

ICE_ERROR(Ice46PropertyDefineCase, 46, ietWarning, "Property [1] defined in property table differs from another defined property only by case.", "Property\tProperty\t[1]")
ICE_ERROR(Ice46MissingValidation, 46, ietWarning, "Database is missing _Validation table. Could not completely check property names.", "_Validation");
ICE_ERROR(Ice46BadCase, 46, ietWarning, "Property '%ls' referenced in column '%s'.'%s' of row %s differs from a defined property by case only.", "%s\t%s\t%s"); 
ICE_ERROR(Ice46TableAccessError, 46, ietWarning, "Error retrieving values from column [2] in table [1]. Skipping Column.", "[1]"); 

typedef const WCHAR *(* Ice46ParseFunction)(WCHAR **);

const WCHAR *Ice46ParseFormatted(WCHAR **pwzState) 
{
	// parse the column data
	WCHAR *pwzLeft;
	WCHAR *pwzRight;
	while (**pwzState && (pwzLeft = wcschr(*pwzState, L'[')))
	{
		// get the right bracket
		pwzRight = wcschr(pwzLeft, L']');
		if (!pwzRight)
			break;

		// find the innermost set of brackets
		WCHAR *pwzNextLeft;
		while ((pwzNextLeft = wcschr(pwzLeft+1, L'[')) && (pwzNextLeft < pwzRight)) 
			pwzLeft = pwzNextLeft;

		// move the starting point to the character after the right bracket
		*pwzState = pwzRight+1;

		// check for any of the special delimiters. If found, move on to next left bracket
		pwzLeft++;
		if (wcschr(L"\\~#$!%1234567890", *pwzLeft))
			continue;

		// change the right bracket to a null. (Hey, its our memory...)
		*pwzRight = L'\0';
		return pwzLeft;
	}
	return NULL;
}

const WCHAR *Ice46ParseKey(WCHAR **pwzState) 
{
	// trivial column parse. Column must be an identifier.
	WCHAR *temp = *pwzState;
	*pwzState = NULL;
	return temp;
}

const WCHAR *Ice46ParseCondition(WCHAR **pwzState) 
{
	WCHAR *pwzCurrent;
	unsigned char rgbStartIdentifier[] = { 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7F, 0xFF, 0xFF, 0xE1, 0x7F, 0xFF, 0xFF, 0xE0 
	};
	unsigned char rgbContIdentifier[] = { 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0xC0,
		0x7F, 0xFF, 0xFF, 0xE1, 0x7F, 0xFF, 0xFF, 0xE0 
	};

	// start with the state position
	pwzCurrent = *pwzState;
	while (*pwzCurrent)
	{
		// scan forward looking for the beginning of an identifier (A-Z, a-z, _)
		// unicode chars, so high byte is 0 and low byte must have bit set in
		// bit array above
		if (((*pwzCurrent & 0xFF80) == 0) &&
			(rgbStartIdentifier[*pwzCurrent >> 3] & (0x80 >> (*pwzCurrent & 0x07))))
		{
			// first character of identifier?? Check that previous character
			// wasn't %, $, ?, &, !, " which flag keys into tables (or identifiers)
			if ((pwzCurrent == *pwzState) ||
				!wcschr(L"%$?&!\"", *(pwzCurrent-1)))
			{
				// not flagged, check for logical operators
				if (!_wcsnicmp(pwzCurrent, L"NOT", 3) ||
					!_wcsnicmp(pwzCurrent, L"AND", 3) ||
					!_wcsnicmp(pwzCurrent, L"EQV", 3) ||
					!_wcsnicmp(pwzCurrent, L"XOR", 3) ||
					!_wcsnicmp(pwzCurrent, L"IMP", 3)) 
					pwzCurrent += 3;
				else if	(!_wcsnicmp(pwzCurrent, L"OR", 2)) 
					pwzCurrent += 2;
				else
				{
					// woohoo! Its actually a property
					WCHAR *pwzEnd = pwzCurrent;
					// scan forward until we find something that is not
					// part of an identifier, or hit the end of the string
					while (*pwzEnd &&
						   ((*pwzEnd & 0xFF80) == 0) &&
							(rgbContIdentifier[*pwzEnd >> 3] & (0x80 >> (*pwzEnd & 0x07))))
							pwzEnd++;

					// state for next search is one after end location, unless end of string
					*pwzState = *pwzEnd ? pwzEnd+1 : pwzEnd;
					// set that location to null
					*pwzEnd = L'\0';
					return pwzCurrent;
				}
			}
			else
			{
				// previous character flagged this as not a property
				// move forward to the end of the identifier
				while (*pwzCurrent &&
					   ((*pwzCurrent & 0xFF80) == 0) &&
						(rgbContIdentifier[*pwzCurrent >> 3] & (0x80 >> (*pwzCurrent & 0x07))))
						pwzCurrent++;
			}
		}
		else
			// some non-identifier character
			pwzCurrent++;
	}
	return NULL;
}

bool Ice46CheckColumn(MSIHANDLE hInstall, MSIHANDLE hDatabase, Ice46Hash &HashTable, CQuery &qValidation, Ice46ParseFunction pfParse)
{
	PMSIHANDLE hResultRec;
	TCHAR *szQuery = new TCHAR[255];
	DWORD cchQuery = (szQuery ? 255 : 0);
	WCHAR *wzData = new WCHAR[255];
	DWORD cchData = (wzData ? 255 : 0);
	UINT iStat;

	CDeleteOnExit q1((LPTSTR *)&szQuery);
	CDeleteOnExit q2((LPTSTR *)&wzData);

	// check all formatted text
	while (ERROR_SUCCESS == (iStat = qValidation.Fetch(&hResultRec)))
	{
		PMSIHANDLE hKeyRec;
		PMSIHANDLE hDataRec;
		int cPrimaryKeys;
		TCHAR szTableName[255];
		TCHAR szColumnName[255];
		DWORD cchTableName = 255;
		DWORD cchColumnName = 255;

		// retrieve the table name from the record
		ReturnIfFailed(46, 4, ::MsiRecordGetString(hResultRec, 1, szTableName, &cchTableName));
		ReturnIfFailed(46, 5, ::MsiRecordGetString(hResultRec, 2, szColumnName, &cchColumnName));
	
		// check to see if the table exists
		if (!IsTablePersistent(FALSE, hInstall, hDatabase, 46, szTableName))
			continue;

		// get the primary keys and form a query for the column names.
		::MsiDatabaseGetPrimaryKeys(hDatabase, szTableName, &hKeyRec);
		cPrimaryKeys = ::MsiRecordGetFieldCount(hKeyRec);

		// build up the columns for the SQL query in Template.
		TCHAR szTemplate[255] = TEXT("");
		_tcscpy(szTemplate, TEXT("`[1]`"));
		TCHAR szTemp[10];
		for (int i=2; i <= cPrimaryKeys; i++)
		{
			_stprintf(szTemp, TEXT(", `[%d]`"), i);
			_tcscat(szTemplate, szTemp);
		}

		// use the formatrecord API to fill in all of the data values in the SQL query.
		::MsiRecordSetString(hKeyRec, 0, szTemplate);
		if (ERROR_MORE_DATA == ::MsiFormatRecord(hInstall, hKeyRec, szQuery, &cchQuery)) {
			delete [] szQuery;
			szQuery = new TCHAR[++cchQuery];
			ReturnIfFailed(46, 6, ::MsiFormatRecord(hInstall, hKeyRec, szQuery, &cchQuery));
		}

		// retrieve the records if error, move on to the next table
		CQuery qData;
		if (ERROR_SUCCESS != qData.OpenExecute(hDatabase, 0, TEXT("SELECT `%s`, %s FROM `%s` WHERE `%s` IS NOT NULL"), 
								szColumnName, szQuery, szTableName, szColumnName))
		{
			ICEErrorOut(hInstall, hResultRec, Ice46TableAccessError);
			continue;
		}

		while (ERROR_SUCCESS == (iStat = qData.Fetch(&hDataRec)))
		{
			// retrieve the string
			if (ERROR_MORE_DATA == (iStat = ::MsiRecordGetStringW(hDataRec, 1, wzData, &cchData)))
			{
				delete [] wzData;
				wzData = new WCHAR[++cchData];
				iStat = ::MsiRecordGetStringW(hDataRec, 1, wzData, &cchData);
			}
			if (ERROR_SUCCESS != iStat)
			{
				APIErrorOut(hInstall, iStat, 46, 7);
				return ERROR_SUCCESS;
			}

			WCHAR *pwzState = wzData;
			const WCHAR *pwzToken = NULL;
			while (pwzToken = pfParse(&pwzState))
			{
				// check the property now pointed to by pszLeft
				if (HashTable.Exists(pwzToken) == Ice46Hash::matchNoCase)
				{
					// egads!! Error. Have to build the error string
					TCHAR szRowName[255] = TEXT("");
					TCHAR szKeys[255] = TEXT("");

					// build up the columns for the user-readable string in szRowName
					// and the tab-delimited string in szKeys.
					_tcscpy(szRowName, TEXT("'[2]'"));
					_tcscpy(szKeys, TEXT("[2]"));
					TCHAR szTemp[10];
					for (int i=2; i <= cPrimaryKeys; i++)
					{
						_stprintf(szTemp, TEXT(".'[%d]'"), i+1);
						_tcscat(szRowName, szTemp);
						_stprintf(szTemp, TEXT("\t[%d]"), i+1);
						_tcscat(szKeys, szTemp);
					}

					ICEErrorOut(hInstall, hDataRec, Ice46BadCase, pwzToken, szTableName, szColumnName, szRowName, 
						szTableName, szColumnName, szKeys);
				}
			}
		}
	}
	return true;
}

ICE_FUNCTION_DECLARATION(46)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 46);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// create the hash table
	Ice46Hash HashTable;

	// hash in the system properties
	for (int i=0; i < cwzSystemProperties; i++)
		HashTable.Add(rgwzSystemProperties[i]);

	// hash in everything from the property table, checking for bad case
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 46, TEXT("Property")))
	{
		CQuery qProperty;
		PMSIHANDLE hPropertyRec;
		WCHAR wzNew[255];
		DWORD cchNew;
		ReturnIfFailed(46, 1, qProperty.OpenExecute(hDatabase, NULL, sqlIce46Property));
		while (ERROR_SUCCESS == (iStat = qProperty.Fetch(&hPropertyRec)))
		{
			cchNew = 255;
			ReturnIfFailed(46, 2, ::MsiRecordGetStringW(hPropertyRec, iColIce46Property_Property, wzNew, &cchNew));
			switch (HashTable.Exists(wzNew))
			{
			case Ice46Hash::matchExact:
				break;
			case Ice46Hash::matchNoCase:
				ICEErrorOut(hInstall, hPropertyRec, Ice46PropertyDefineCase);
				// fall through. Even though the case is off from a system property
				// we still want to add it because we are 
			case Ice46Hash::matchFalse:
				HashTable.Add(wzNew);
				break;
			}
		}
	}

	if (IsTablePersistent(FALSE, hInstall, hDatabase, 46, TEXT("_Validation")))
	{
		// check everything that references the property table as key column
		CQuery qValidation;
		ReturnIfFailed(46, 3, qValidation.OpenExecute(hDatabase, 0, sqlIce46ForeignKey));
		Ice46CheckColumn(hInstall, hDatabase, HashTable, qValidation, Ice46ParseKey);
		qValidation.Close();

		// check all formatted text
		ReturnIfFailed(46, 4, qValidation.OpenExecute(hDatabase, 0, sqlIce46FormattedTypes));
		Ice46CheckColumn(hInstall, hDatabase, HashTable, qValidation, Ice46ParseFormatted);
		qValidation.Close();

		// check all conditions
		ReturnIfFailed(46, 5, qValidation.OpenExecute(hDatabase, 0, sqlIce46ConditionType));
		Ice46CheckColumn(hInstall, hDatabase, HashTable, qValidation, Ice46ParseCondition);
		qValidation.Close();

		// check special table types (i.e. DefaultDir)
		ReturnIfFailed(46, 3, qValidation.OpenExecute(hDatabase, 0, sqlIce46SpecialColumn));
		Ice46CheckColumn(hInstall, hDatabase, HashTable, qValidation, Ice46ParseKey);
		qValidation.Close();
	}
	else
	{
		PMSIHANDLE hRec = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRec, Ice46MissingValidation);
	}

	// check the directory table

	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// ICE47, checks for features that have more than 1600 components.

// not shared with merge module subset
#ifndef MODSHAREDONLY
static const TCHAR sqlIce47Features[] = TEXT("SELECT `Feature` FROM `Feature`");
static const int iColIce47Feature_Feature = 1;

static const TCHAR sqlIce47Components[] = TEXT ("SELECT `Component_` FROM `FeatureComponents` WHERE `Feature_`=?");
static const int iColIce47Components_Component = 1;

ICE_ERROR(Ice47TooManyComponents, 47, ietWarning, "Feature '[1]' has %u components. This could cause problems on Win9X systems. You should try to have fewer than %u components per feature.","Feature\tFeature\t[1]");
static const int iIce56MaxComponents = 817;

ICE_FUNCTION_DECLARATION(47)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 47);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if ((!IsTablePersistent(FALSE, hInstall, hDatabase, 47, TEXT("Feature"))) ||
		(!IsTablePersistent(FALSE, hInstall, hDatabase, 47, TEXT("FeatureComponents"))))
		return ERROR_SUCCESS;

	CQuery qFeature;
	CQuery qComponent;
	unsigned int cComponents;
	PMSIHANDLE hFeatureRec;
	PMSIHANDLE hComponentRec;
	ReturnIfFailed(47, 1, qFeature.OpenExecute(hDatabase, 0, sqlIce47Features));
	ReturnIfFailed(47, 2, qComponent.Open(hDatabase, sqlIce47Components));

	// loop through every feature
	while (ERROR_SUCCESS == (iStat = qFeature.Fetch(&hFeatureRec)))
	{
		cComponents=0;
		ReturnIfFailed(47, 3, qComponent.Execute(hFeatureRec));
		// count up number of components
		while (ERROR_SUCCESS == qComponent.Fetch(&hComponentRec))
			cComponents++;
		if (cComponents >= iIce56MaxComponents)
			ICEErrorOut(hInstall, hFeatureRec, Ice47TooManyComponents, cComponents, iIce56MaxComponents);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 47, 4);

	return ERROR_SUCCESS;
};
#endif

///////////////////////////////////////////////////////////////////////
// ICE48 - checks for hardcoded, non-UNC, non-URL paths in the 
// directory table
static const TCHAR sqlIce48Directory[] = TEXT("SELECT `Directory`.`Directory`, `Property`.`Value` FROM `Directory`, `Property` WHERE (`Directory`.`Directory`=`Property`.`Property`)");
static const int iColIce48Directory_Directory = 1;
static const int iColIce48Directory_Value = 2;

ICE_ERROR(Ice48HardcodedLocal, 48, ietWarning, "Directory '[1]' appears to be hardcoded in the property table to a local drive.", "Directory\tDirectory\t[1]");
ICE_ERROR(Ice48Hardcoded, 48, ietWarning, "Directory '[1]' appears to be hardcoded in the property table.", "Directory\tDirectory\t[1]");

ICE_FUNCTION_DECLARATION(48)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 48);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// check for the two tables
	if ((!IsTablePersistent(FALSE, hInstall, hDatabase, 48, TEXT("Property"))) ||
		(!IsTablePersistent(FALSE, hInstall, hDatabase, 48, TEXT("Directory"))))
		return ERROR_SUCCESS;

	// query for all directories that are hardcoded to the property table
	CQuery qDirectory;
	ReturnIfFailed(48, 1, qDirectory.OpenExecute(hDatabase, 0, sqlIce48Directory));

	//retrieve all directories and check for hardcoded drive
	PMSIHANDLE hDirRec;
	TCHAR *szValue;
	unsigned long cchValue = 255;
	unsigned long cchValueSize = 255;
	szValue = new TCHAR[255];

	while (ERROR_SUCCESS == (iStat = qDirectory.Fetch(&hDirRec)))
	{
		// retrieve the string from the record
		cchValue = cchValueSize;
		UINT iStat = ::MsiRecordGetString(hDirRec, iColIce48Directory_Value, szValue, &cchValue);
		if (iStat == ERROR_MORE_DATA)
		{
			delete[] szValue;
			szValue = new TCHAR[++cchValue];
			cchValueSize = cchValue;
			iStat = ::MsiRecordGetString(hDirRec, iColIce48Directory_Value, szValue, &cchValue);
		}
		ReturnIfFailed(47, 2, iStat);

		// parse the string
		if ((_istalpha(szValue[0])) &&
			(_tcsnicmp(szValue, TEXT(":\\"), 2)))
			ICEErrorOut(hInstall, hDirRec, Ice48HardcodedLocal);
		else
			ICEErrorOut(hInstall, hDirRec, Ice48Hardcoded);
	}
	delete[] szValue;

	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 48, 3);
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// ICE49 - checks for default values that are DWORD (bad for Win9X)
static const TCHAR sqlIce49Registry[] = TEXT("SELECT `Registry`, `Value` FROM `Registry` WHERE (`Name` IS NULL) AND (`Value` IS NOT NULL)");
static const int iColIce49Registry_Registry = 1;
static const int iColIce49Registry_Value = 2;

ICE_ERROR(Ice49BadDefault, 49, ietWarning, "Reg Entry '[1]' is not of type REG_SZ. Default types must be REG_SZ on Win95 Systems. Make sure the component is conditionalized to never be installed on Win95 machines.", "Registry\tValue\t[1]");

ICE_FUNCTION_DECLARATION(49)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 49);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// check for the table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 49, TEXT("Registry")))
		return ERROR_SUCCESS;

	// query for all registry entries with null names and non-null values.
	CQuery qRegistry;
	ReturnIfFailed(48, 1, qRegistry.OpenExecute(hDatabase, 0, sqlIce49Registry));

	//retrieve all directories and check for hardcoded drive
	PMSIHANDLE hDirRec;
	TCHAR *szValue;
	unsigned long cchValue = 255;
	unsigned long cchValueSize = 255;
	szValue = new TCHAR[255];

	while (ERROR_SUCCESS == (iStat = qRegistry.Fetch(&hDirRec)))
	{
		// retrieve the string from the record
		cchValue = cchValueSize;
		UINT iStat = ::MsiRecordGetString(hDirRec, iColIce49Registry_Value, szValue, &cchValue);
		if (iStat == ERROR_MORE_DATA)
		{
			delete[] szValue;
			szValue = new TCHAR[++cchValue];
			cchValueSize = cchValue;
			iStat = ::MsiRecordGetString(hDirRec, iColIce49Registry_Value, szValue, &cchValue);
		}
		ReturnIfFailed(47, 2, iStat);

		// parse the string
		if (((szValue[0] == TEXT('#')) &&
			 (szValue[1] != TEXT('#'))) ||
			(_tcsstr(szValue, TEXT("[~]"))))
			ICEErrorOut(hInstall, hDirRec, Ice49BadDefault);
	}
	delete[] szValue;

	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 49, 3);
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// ICE50 - checks for matching extension in shortcut/icon

// not shared with merge module subset
#ifndef MODSHAREDONLY
static const TCHAR sqlIce50Shortcut[] = TEXT("SELECT `Shortcut`.`Component_`, `Shortcut`.`Icon_`, `Shortcut`.`Shortcut` FROM `Shortcut`, `Feature` WHERE (`Shortcut`.`Target`=`Feature`.`Feature`) AND (`Shortcut`.`Icon_` IS NOT NULL)");
static const int iColIce50Shortcut_Component = 1;
static const int iColIce50Shortcut_Icon = 2;
static const int iColIce50Shortcut_Shortcut = 3;

static const TCHAR sqlIce50Component[] = TEXT("SELECT `KeyPath`, `Component` FROM `Component` WHERE (`Component`=?)");
static const int iColIce50Component_KeyPath = 1;
static const int iColIce50Component_Component = 2;

static const TCHAR sqlIce50File[] = TEXT("SELECT `FileName` FROM `File` WHERE (`File`=?)");
static const int iColIce50File_FileName = 1;

ICE_ERROR(Ice50NullKeyPath, 50, ietError, "Component '[2]' has an advertised shortcut, but a null KeyPath.", "Component\tComponent\t[2]");
ICE_ERROR(Ice50BadKeyPath, 50, ietError, "Component '[2]' has an advertised shortcut, but the KeyPath cannot be found.", "Component\tComponent\t[2]");
ICE_ERROR(Ice50Mismatched, 50, ietError, "The extension of Icon '[2]' for Shortcut '[3]' does not match the extension of the Key File for component '[1]'.", "Shortcut\tIcon_\t[3]");
ICE_ERROR(Ice50IconDisplay, 50, ietWarning, "The extension of Icon '[2]' for Shortcut '[3]' is not \"exe\" or \"ico\". The Icon will not be displayed correctly.", "Shortcut\tIcon_\t[3]");
ICE_ERROR(Ice50MissingComponent, 50, ietError, "The shortcut '[3]' does not refer to a valid component.", "Shortcut\tComponent_\t[3]");

ICE_FUNCTION_DECLARATION(50)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 50);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// no shortcut or feature table means no advertised shortcuts
	if ((!IsTablePersistent(FALSE, hInstall, hDatabase, 50, TEXT("Shortcut"))) ||
		(!IsTablePersistent(FALSE, hInstall, hDatabase, 50, TEXT("Feature"))))
		return ERROR_SUCCESS;

	// no icon table means no icons, so they obviously can't be misnamed
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 50, TEXT("Icon")))
		return ERROR_SUCCESS;

	// no component or no file means it can't possibly be mismatched.
	if ((!IsTablePersistent(FALSE, hInstall, hDatabase, 50, TEXT("Component"))) ||
		(!IsTablePersistent(FALSE, hInstall, hDatabase, 50, TEXT("File"))))
		return ERROR_SUCCESS;

	// prepare the three queries
	CQuery qIcon;
	CQuery qComponent;
	CQuery qFile;
	PMSIHANDLE hComponent;
	PMSIHANDLE hShortcut;
	PMSIHANDLE hFile;
	ReturnIfFailed(50, 1, qIcon.OpenExecute(hDatabase, 0, sqlIce50Shortcut));
	ReturnIfFailed(50, 2, qComponent.Open(hDatabase, sqlIce50Component));
	ReturnIfFailed(50, 3, qFile.Open(hDatabase, sqlIce50File));
	
	// retrieve all the advertised shortcuts
	while (ERROR_SUCCESS == (iStat = qIcon.Fetch(&hShortcut)))
	{
		// get the component from the shortcut
		ReturnIfFailed(50, 4, qComponent.Execute(hShortcut));
		iStat = qComponent.Fetch(&hComponent);
		switch (iStat) {
		case ERROR_NO_MORE_ITEMS:
			ICEErrorOut(hInstall, hShortcut, Ice50MissingComponent);
			continue;
		case ERROR_SUCCESS:
			break;
		default:
			APIErrorOut(hInstall, iStat, 50, 5);
			continue;
		}

		// if the keypath is null, that's bad.
		if (::MsiRecordIsNull(hComponent, iColIce50Component_KeyPath))
		{
			ICEErrorOut(hInstall, hComponent, Ice50NullKeyPath);
			continue;
		}

		// find the keyfile name
		ReturnIfFailed(50, 6, qFile.Execute(hComponent));
		iStat = qFile.Fetch(&hFile);
		switch (iStat) {
		case ERROR_NO_MORE_ITEMS:
			ICEErrorOut(hInstall, hComponent, Ice50BadKeyPath);
			continue;
		case ERROR_SUCCESS:
			break;
		default:
			APIErrorOut(hInstall, iStat, 50, 7);
			continue;
		}

		// retrieve the filename
		TCHAR szFilename[512];
		unsigned long cchFilename = 512;
		ReturnIfFailed(50, 8, ::MsiRecordGetString(hFile, iColIce50File_FileName, szFilename, &cchFilename));

		// parse the filename for an extension
		TCHAR *szFileExtension = _tcsrchr(szFilename, TEXT('.'));
		if (szFileExtension) szFileExtension++;

		// now get the icon name from the shortcut
		TCHAR szIcon[512];
		unsigned long cchIcon = 512;
		ReturnIfFailed(50, 9, ::MsiRecordGetString(hShortcut, iColIce50Shortcut_Icon, szIcon, &cchIcon));

		// parse the name for an extension
		TCHAR *szIconExtension = _tcsrchr(szIcon, TEXT('.'));
		if (szIconExtension) szIconExtension++;


		// OK if Icon extension is exe 
		if (szIconExtension && (_tcsicmp(szIconExtension, TEXT("exe")) == 0))
			continue;

		// OK if Icon extension is ico
		if (szIconExtension && (_tcsicmp(szIconExtension, TEXT("ico")) == 0))
			continue;

		// if its not EXE or ICO, some shell's won't display it correctly
		ICEErrorOut(hInstall, hShortcut, Ice50IconDisplay);

		// if both extensions are null, we're ok
		if ((!szIconExtension || !*szIconExtension) &&
			(!szFileExtension || !*szFileExtension))
			continue;

		// if both are not null and they are the same
		if (szIconExtension && szFileExtension &&
			!_tcsicmp(szIconExtension, szFileExtension))
			continue;

		ICEErrorOut(hInstall, hShortcut, Ice50Mismatched);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 50, 10);
	return ERROR_SUCCESS;
}
#endif

///////////////////////////////////////////////////////////////////////
// ICE51 - checks for font titles for all except TTC, TTF fonts.

static const TCHAR sqlIce51Font[] = TEXT("SELECT `File_`, `FontTitle` FROM `Font`");
static const int iColIce51Font_File = 1;
static const int iColIce51Font_FontTitle = 2;

static const TCHAR sqlIce51File[] = TEXT("SELECT `FileName` FROM `File` WHERE (`File`=?)");
static const int iColIce51File_FileName = 1;

ICE_ERROR(Ice51BadKey, 51, ietError, "Font '[1]' does not refer to a file in the File table.", "Font\tFile_\t[1]");
ICE_ERROR(Ice51TrueTypeWithTitle, 51, ietWarning, "Font '[1]' is a TTC\\TTF font, but also has a title.", "Font\tFile_\t[1]");
ICE_ERROR(Ice51NullTitle, 51, ietError, "Font '[1]' does not have a title. Only TTC\\TTF fonts do not need titles.", "Font\tFile_\t[1]");

ICE_FUNCTION_DECLARATION(51)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 51);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// no font table, we're ok. If no file table, we're OK.
	if ((!IsTablePersistent(FALSE, hInstall, hDatabase, 51, TEXT("Font"))) ||
		(!IsTablePersistent(FALSE, hInstall, hDatabase, 51, TEXT("File"))))
		return ERROR_SUCCESS;

	// select everything from the font table
	CQuery qFont;
	CQuery qFile;
	PMSIHANDLE hFont;
	PMSIHANDLE hFile;
	ReturnIfFailed(51, 1, qFont.OpenExecute(hDatabase, 0, sqlIce51Font));
	ReturnIfFailed(51, 2, qFile.Open(hDatabase, sqlIce51File));

	// retrieve all the fonts
	while (ERROR_SUCCESS == (iStat = qFont.Fetch(&hFont)))
	{
		// get the filename from the file table
		ReturnIfFailed(51, 3, qFile.Execute(hFont));
		iStat = qFile.Fetch(&hFile);
		switch (iStat) {
		case ERROR_NO_MORE_ITEMS:
			ICEErrorOut(hInstall, hFont, Ice51BadKey);
			continue;
		case ERROR_SUCCESS:
			break;
		default:
			APIErrorOut(hInstall, iStat, 51, 4);
			continue;
		}

		// retrieve the filename
		TCHAR szFilename[512];
		unsigned long cchFilename = 512;
		ReturnIfFailed(51, 5, ::MsiRecordGetString(hFile, iColIce51File_FileName, szFilename, &cchFilename));

		// parse the filename for an extension
		TCHAR *szFileExtension = _tcsrchr(szFilename, TEXT('.'));
		if (szFileExtension) szFileExtension++;

		// if the font is TTF or TTC
		if (szFileExtension && ((_tcsicmp(szFileExtension, TEXT("TTC")) == 0) ||
			(_tcsicmp(szFileExtension, TEXT("TTF")) == 0)))
		{
			// the title should be null
			if (!::MsiRecordIsNull(hFont, iColIce51Font_FontTitle))
				ICEErrorOut(hInstall, hFont, Ice51TrueTypeWithTitle);
		}
		else
		{
			// the title must NOT be null.
			if (::MsiRecordIsNull(hFont, iColIce51Font_FontTitle))
				ICEErrorOut(hInstall, hFont, Ice51NullTitle);
		}
	}

	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 51, 6);
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// ICE52 - checks that all properties in AppSearch/CCCPSearch are public.

static const TCHAR sqlIce52AppSearch[] = TEXT("SELECT `Property`, `Signature_` FROM `AppSearch`");
static const int iColIce52AppSearch_Property = 1;
static const int iColIce52AppSearch_Signature = 2;

ICE_ERROR(Ice52NonPublic, 52, ietWarning, "Property '[1]' in AppSearch row '[1]'.'[2]' is not public. It should be all uppercase.", "AppSearch\tProperty\t[1]\t[2]");

ICE_FUNCTION_DECLARATION(52)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 52);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if there is an AppSearch table
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 52, TEXT("AppSearch")))
	{
		// retrieve all items
		CQuery qAppSearch;
		ReturnIfFailed(52, 1, qAppSearch.OpenExecute(hDatabase, 0, sqlIce52AppSearch));

		// retrieve all the properties
		PMSIHANDLE hProperty;
		while (ERROR_SUCCESS == (iStat = qAppSearch.Fetch(&hProperty)))
		{
			// retrieve the property, should be limited to 72 chars by schema
			TCHAR szProperty[128];
			unsigned long cchProperty = 128;
			ReturnIfFailed(52, 2, ::MsiRecordGetString(hProperty, iColIce52AppSearch_Property, 
				szProperty, &cchProperty));

			// search for lowercase characters
			for (int i=0; i < cchProperty; i++) 
				if (_istlower(szProperty[i]))
				{
					ICEErrorOut(hInstall, hProperty, Ice52NonPublic);
					break;
				}
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 52, 3);
	}

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// ICE53 - checks for darwin config settings in the registry table

static const TCHAR sqlIce53Registry[] = TEXT("SELECT `Registry`, `Key` FROM `Registry` WHERE (`Root`=?)");
static const int iColIce53Registry_Registry = 1;

static const TCHAR sqlIce53Property[] =  TEXT("SELECT `Property`,`Value` FROM `Property`");
static const int iColIce53Property_Property = 1;
static const int iColIce53Property_Value = 2;

ICE_ERROR(Ice53DarwinData, 53, ietError, "Registry Key '[1]' writes Darwin internal or policy information.", "Registry\tRegistry\t[1]");


const int cRoot = 4;
const int cSearch = 6;
const TCHAR * rgszIce53Search[cRoot][cSearch] = 
{
	{ // -1 key root
		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Products"),
		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components"),
		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\DriveMapping"),
		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Folders"),
		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Rollback"),
		TEXT("Software\\Policies\\Microsoft\\Windows\\Installer")
	},
	{ // 0 key root
		TEXT("Installer\\Products"),
		TEXT("Installer\\Features"),
		TEXT("Installer\\Components"),
		NULL,
		NULL,
		NULL
	},
	{ // 1 key root
		TEXT("Software\\Policies\\Microsoft\\Windows\\Installer"),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
	},
	{ // 2 key root
		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Products"),
		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components"),
		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\DriveMapping"),
		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Folders"),
		TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Rollback"),
		TEXT("Software\\Policies\\Microsoft\\Windows\\Installer")
	}
};


ICE_FUNCTION_DECLARATION(53)
{
	UINT iStat;
	TCHAR *szTemplate = new TCHAR[100];
	DWORD cchTemplate = 100;

	// display info
	DisplayInfo(hInstall, 53);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if there is a Registry table
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 53, TEXT("Registry")))
	{
		// we'd like to use MsiFormatRecord to expand any property values, but
		// the property table has not been processed because the CUB file
		// is what actually is used to init the engine. To work around this, we manually
		// run through the property table and set all of the properties
		if (IsTablePersistent(FALSE, hInstall, hDatabase, 53, TEXT("Property")))
		{
			CQuery qProperty;
			PMSIHANDLE hProperty;
			qProperty.OpenExecute(hDatabase, 0, sqlIce53Property);
			while (ERROR_SUCCESS == qProperty.Fetch(&hProperty))
			{
				DWORD cchName = 128;
				DWORD cchValue = 255;
				TCHAR szName[128];
				TCHAR szValue[255];
				::MsiRecordGetString(hProperty, iColIce53Property_Property, szName, &cchName);
				::MsiRecordGetString(hProperty, iColIce53Property_Value, szValue, &cchValue);
				::MsiSetProperty(hInstall, szName, szValue);
			}
		}

		// create a search record
		CQuery qRegistry;
		PMSIHANDLE hSearch = ::MsiCreateRecord(1);

		// retrieve all registry entries that match the darwin data
		ReturnIfFailed(52, 1, qRegistry.Open(hDatabase, sqlIce53Registry));

		for (int iRoot=0; iRoot < cRoot; iRoot++) 
		{
			// set the registry data
			ReturnIfFailed(53, 2, ::MsiRecordSetInteger(hSearch, 1, iRoot-1));
					
			// execute the query
			ReturnIfFailed(53, 3, qRegistry.Execute(hSearch));

			// retrieve all the possible bad values
			PMSIHANDLE hRegistry;
			PMSIHANDLE hDummy = ::MsiCreateRecord(1);
			while (ERROR_SUCCESS == (iStat = qRegistry.Fetch(&hRegistry)))
			{
				// pull the key name
				DWORD cchDummy = cchTemplate;
				if (ERROR_SUCCESS != (iStat = IceRecordGetString(hRegistry, 2, &szTemplate, &cchTemplate, &cchDummy)))
				{
					APIErrorOut(hInstall, iStat, 53, 4);
					continue;
				}

				// stick this into a temporary record, then format it. This will 
				// resolve any properties that people use to try 
				// and set the registry paths at runtime
				cchDummy = cchTemplate;
				::MsiRecordSetString(hDummy, 0, szTemplate);
				if (ERROR_SUCCESS != (iStat = ::MsiFormatRecord(hInstall, hDummy, szTemplate, &cchDummy)))
				{
					if (ERROR_MORE_DATA == iStat)
					{
						// need more buffer
						delete[] szTemplate;
						cchTemplate = (cchDummy += 4);
						szTemplate = new TCHAR[cchDummy];
						iStat =  ::MsiFormatRecord(hInstall, hDummy, szTemplate, &cchDummy);
					}
					if (ERROR_SUCCESS != iStat)
					{
						APIErrorOut(hInstall, iStat, 53, 5);
						continue;
					}
				}

				// if it begins with the string, give an error
				for (int iSearch=0; iSearch < cSearch; iSearch++)
					if (rgszIce53Search[iRoot][iSearch] &&
						(_tcsncmp(szTemplate, rgszIce53Search[iRoot][iSearch], _tcslen(rgszIce53Search[iRoot][iSearch])) == 0))
						ICEErrorOut(hInstall, hRegistry, Ice53DarwinData);
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
				APIErrorOut(hInstall, iStat, 53, 6);
		}
		delete[] szTemplate;
	}


	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// ICE54
// This ICE checks that files which are used as KeyPaths of components do
// not derive their version from another file via the companion file 
// mechanism. If a companion file is used as the KeyPath, version checking
// and determining when to install a component can get really goofy.

static const TCHAR sqlIce54KeyFile[] =  TEXT("SELECT `File`.`Version`, `File`.`File`, `Component`.`Attributes`, `Component`.`Component` FROM `Component`,`File` WHERE (`Component`.`KeyPath`=`File`.`File`)");
static const int iColIce54KeyFile_Version = 1;
static const int iColIce54KeyFile_File = 2;
static const int iColIce54KeyFile_Attributes = 3;
static const int iColIce54KeyFile_Component = 4;

static const TCHAR sqlIce54Companion[] =  TEXT("SELECT `File` FROM `File` WHERE (`File`=?)");
static const int iColIce54Companion_File = 1;

ICE_ERROR(Ice54CompanionError, 54, ietWarning, "Component '[4]' uses file '[2]' as its KeyPath, but the file's version is provided by the file '[1]'.", "Component\tKeyPath\t[4]");

ICE_FUNCTION_DECLARATION(54)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 54);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if there is a Component Table and a File table, we have something to check
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 54, TEXT("Component")) &&
		IsTablePersistent(FALSE, hInstall, hDatabase, 54, TEXT("File")))
	{
		// we want to retrieve every component where the KeyFile of the component is non-null, 
		// and is a valid key into the file table
		CQuery qKeyFile;
		PMSIHANDLE hKeyFile;

		CQuery qCompanion;
		PMSIHANDLE hCompanion;

		ReturnIfFailed(54, 1, qKeyFile.OpenExecute(hDatabase, 0, sqlIce54KeyFile));
		ReturnIfFailed(54, 2, qCompanion.Open(hDatabase, sqlIce54Companion));

		while (ERROR_SUCCESS == (iStat = qKeyFile.Fetch(&hKeyFile)))
		{
			// then check the attributes to make sure this is a file keyfile
			if (::MsiRecordGetInteger(hKeyFile, iColIce54KeyFile_Attributes) & 
				(msidbComponentAttributesRegistryKeyPath ||	msidbComponentAttributesODBCDataSource))
			{
				// the keypath is actually a registry entry or ODBC entry
				continue;
			}

			// then query the file table for the files version as a primary key
			ReturnIfFailed(54, 3, qCompanion.Execute(hKeyFile));
			if (ERROR_SUCCESS == (iStat = qCompanion.Fetch(&hCompanion)))
			{
				// if it succeeds, the keyfile of the component is a companion file, and this is not allowed.
				ICEErrorOut(hInstall, hKeyFile, Ice54CompanionError);
			} 
			else if (ERROR_NO_MORE_ITEMS != iStat)
				APIErrorOut(hInstall, iStat, 54, 4);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 54, 5);
	}
	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// ICE55
// Verifies that everything in the LockPermissions table has a non-null
// permissions value and references a valid item in the table/column
// entries

static const TCHAR sqlIce55LockPerm[] =  TEXT("SELECT `LockObject`, `Table`, `Domain`, `User`, `Permission` FROM `LockPermissions`");
static const int iColIce55LockPerm_LockObject = 1;
static const int iColIce55LockPerm_Table = 2;
static const int iColIce55LockPerm_Domain = 3;
static const int iColIce55LockPerm_User = 4;
static const int iColIce55LockPerm_Permission = 5;

static const TCHAR sqlIce55Column[] =  TEXT("SELECT `Name` FROM `_Columns` WHERE `Table`='%s' AND `Number`=1");
static const int iColIce55Column_Name = 1;

static const TCHAR sqlIce55Object[] =  TEXT("SELECT `%s` FROM `%s` WHERE `%s`=?");
static const int iColIce55Object_Object = 1;

ICE_ERROR(Ice55NullPerm, 55, ietError, "LockObject '[1]'.'[2]'.'[3]'.'[4]' in the LockPermissions table has a null Permission value.", "LockPermissions\tLockObject\t[1]\t[2]\t[3]\t[4]");
ICE_ERROR(Ice55MissingObject, 55, ietError, "Could not find item '[1]' in table '[2]' which is referenced in the LockPermissions table.", "LockPermissions\tLockObject\t[1]\t[2]\t[3]\t[4]");

ICE_FUNCTION_DECLARATION(55)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 55);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if there is a LockPermissions Table
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 55, TEXT("LockPermissions")))
	{
		CQuery qLockPerm;
		CQuery qObject;
		CQuery qColumn;
		PMSIHANDLE hLockPerm;
		PMSIHANDLE hColumn;
		PMSIHANDLE hObject;

		// init queries
		ReturnIfFailed(55, 1, qLockPerm.OpenExecute(hDatabase, 0, sqlIce55LockPerm));

		// fetch all directories with null KeyPaths
		while (ERROR_SUCCESS == (iStat = qLockPerm.Fetch(&hLockPerm)))
		{
			TCHAR szTable[255];
			TCHAR szColumn[255];
			DWORD cchTable = 255;
			DWORD cchColumn = 255;

			// check if the permissions column is null
			if (::MsiRecordIsNull(hLockPerm, iColIce55LockPerm_Permission))
				ICEErrorOut(hInstall, hLockPerm, Ice55NullPerm);

			// get the column name of the first column in the referenced table
			ReturnIfFailed(55, 2, ::MsiRecordGetString(hLockPerm, iColIce55LockPerm_Table, szTable, &cchTable));

			// check that the table exists
			if (!IsTablePersistent(FALSE, hInstall, hDatabase, 55, szTable))
			{
				ICEErrorOut(hInstall, hLockPerm, Ice55MissingObject);
				continue;
			}

			ReturnIfFailed(55, 3, qColumn.FetchOnce(hDatabase, 0, &hColumn, sqlIce55Column, szTable));
			ReturnIfFailed(55, 4, ::MsiRecordGetString(hColumn, iColIce55Column_Name, szColumn, &cchColumn));

			// execute the query to find the object
			ReturnIfFailed(55, 5, qObject.OpenExecute(hDatabase, hLockPerm, sqlIce55Object, szColumn, szTable, szColumn));
			switch (iStat = qObject.Fetch(&hObject))
			{
			case ERROR_NO_MORE_ITEMS:
				ICEErrorOut(hInstall, hLockPerm, Ice55MissingObject);
				break;
			case ERROR_SUCCESS:
				break;
			default:
				APIErrorOut(hInstall, iStat, 55, 6);
			}
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 55, 7);
	}
	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// ICE56
// Verifies that there is only one root of the directory structure, and that
// it is TARGETDIR, SourceDir. If this is NOT true, Admin images will
// not be copied to the admin install point correctly.

// not shared with merge module subset
#ifndef MODSHAREDONLY
static const TCHAR sqlIce56CreateCol[] = TEXT("ALTER TABLE `Directory` ADD `_Child` INTEGER TEMPORARY");
static const TCHAR sqlIce56ResetCol[]  = TEXT("UPDATE `Directory` SET `_Child`=0");

static const TCHAR sqlIce56Directory[] = TEXT("SELECT `Directory`, `DefaultDir` FROM `Directory` WHERE (`Directory_Parent` IS NULL) OR (`Directory_Parent`=`Directory`)");
static const int iColIce56Directory_Directory = 1;
static const int iColIce56Directory_DefaultDir = 2;

static const TCHAR sqlIce56FilesInDirectory[] =  TEXT("SELECT `File` FROM `Component`,`File`,`Directory` WHERE (`Component`.`Directory_`=`Directory`.`Directory`) AND (`File`.`Component_`=`Component`.`Component`) AND (`Directory`.`_Child`=2)");

ICE_ERROR(Ice56BadRoot, 56, ietError, "Directory '[1]' is an invalid root directory. It or one of its children contains files. Only TARGETDIR or its children can have files.", "Directory\tDirectory\t[1]");
ICE_ERROR(Ice56BadTargetDir, 56, ietError, "Directory 'TARGETDIR' has a bad DefaultDir value. It should be 'SourceDir'", "Directory\tDirectory\tTARGETDIR");

ICE_FUNCTION_DECLARATION(56)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 56);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if there is a Directory Table, we can validate
	// if there is no file table or component table, no files could be sourced in
	// these directories, so no error
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 56, TEXT("Directory")) &&
		IsTablePersistent(FALSE, hInstall, hDatabase, 56, TEXT("File")) &&
		IsTablePersistent(FALSE, hInstall, hDatabase, 56, TEXT("Component")))
	{
		CQuery qDirectory;
		CQuery qFile;
			CQuery qColumn;
		PMSIHANDLE hDirectory;

		// create the temporary column. 
		ReturnIfFailed(56, 1, qColumn.OpenExecute(hDatabase, 0, sqlIce56CreateCol));

		// init queries
		ReturnIfFailed(56, 2, qDirectory.OpenExecute(hDatabase, 0, sqlIce56Directory));
		ReturnIfFailed(56, 3, qFile.Open(hDatabase, sqlIce56FilesInDirectory));

		// fetch all directories that are roots
		while (ERROR_SUCCESS == (iStat = qDirectory.Fetch(&hDirectory)))
		{
			// reset the mark column so we don't duplicate messages already
			// displayed in previous pass
			ReturnIfFailed(56, 4, qColumn.OpenExecute(hDatabase, 0, sqlIce56ResetCol));

			// mark all children of this directory
			MarkChildDirs(hInstall, hDatabase, 56, hDirectory, TEXT("_Child"), 1, 2);
		
			// if there are no files in this directory it is exempt from the check
			PMSIHANDLE hFileRec;
			ReturnIfFailed(56, 5, qFile.Execute(hDirectory));
			if (ERROR_SUCCESS == qFile.Fetch(&hFileRec))
			{
				TCHAR szBuffer[10];
				DWORD cchBuffer = 10;
				bool bError = false;

				// pull the key out to see if it is TargetDir
				// we set cchBuffer to 10. If the string retrieval comes back with ERROR_MORE_DATA,
				// we know it is not TARGETDIR
				cchBuffer = 10;
				switch (iStat = ::MsiRecordGetString(hDirectory, iColIce56Directory_Directory, szBuffer, &cchBuffer))
				{
				case ERROR_MORE_DATA:
					// <> TARGETDIR
					bError = true;
					break;
				case ERROR_SUCCESS:
					// check to see if it is actually TARGETDIR
					if (_tcscmp(TEXT("TARGETDIR"), szBuffer) == 0)
					{
						// next check if DefaultDir is SourceDir or SOURCEDIR
						// by same logic. If its too long, it fails.
						cchBuffer = 10;
						iStat = ::MsiRecordGetString(hDirectory, iColIce56Directory_DefaultDir, szBuffer, &cchBuffer);
						if ((ERROR_MORE_DATA == iStat) ||
							((ERROR_SUCCESS == iStat) &&
							 (0 != _tcscmp(TEXT("SourceDir"), szBuffer)) &&
							 (0 != _tcscmp(TEXT("SOURCEDIR"), szBuffer))))
						{
							ICEErrorOut(hInstall, hDirectory, Ice56BadTargetDir);
							continue;
						}
						else if ((ERROR_SUCCESS != iStat) && (ERROR_MORE_DATA != iStat))
							APIErrorOut(hInstall, iStat, 56, 6);
					}
					else
						// not TARGETDIR
						bError = true;
						break;
				default:
					APIErrorOut(hInstall, iStat, 56, 7);
				}

				if (bError) 
					ICEErrorOut(hInstall, hDirectory, Ice56BadRoot);
			}
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 56, 8);
	}
	return ERROR_SUCCESS;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// ICE57
// Checks that per-machine and per-user data are not mixed in a compenent.
// This is done by checking for components that have
// 1) either HKCU entries, files in the profile, or shortcuts in the profile  
// AND 2) a keypath to a per-machine file or non-HKCU reg key
// also checks for problems with -1 reg keys
// we create four temporary columns. _ICE57User is set if any per-user resources
// exist in the component. _ICE57Machine is set if any per-machine resources exist
// in the component. _ICE57AllUsers is set if any -1 root reg keys exist in the 
// component, and _ICE57KeyPath is set to 1, 2, or 3 if the keypath is per-user, 
// per-machine, or varies (respectively).

// not shared with merge module subset
#ifndef MODSHAREDONLY
static const TCHAR sqlIce57TempColumnU[] =  TEXT("ALTER TABLE `Component` ADD `_ICE57User` INT TEMPORARY");
static const TCHAR sqlIce57TempColumnM[] =  TEXT("ALTER TABLE `Component` ADD `_ICE57Machine` INT TEMPORARY");
static const TCHAR sqlIce57TempColumnA[] =  TEXT("ALTER TABLE `Component` ADD `_ICE57AllUsers` INT TEMPORARY");
static const TCHAR sqlIce57TempColumnS[] =  TEXT("ALTER TABLE `Shortcut` ADD `_ICE57Mark` INT TEMPORARY");
static const TCHAR sqlIce57TempColumnK[] =  TEXT("ALTER TABLE `Component` ADD `_ICE57KeyPath` INT TEMPORARY");

static const TCHAR sqlIce57MarkAdvtShortcut[] =  TEXT("UPDATE `Shortcut`, `Feature` SET `Shortcut`.`_ICE57Mark`=1 WHERE (`Feature`.`Feature`=`Shortcut`.`Target`)");
static const TCHAR sqlIce57MarkAFromRegistry[] =  TEXT("UPDATE `Component`, `Registry` SET `Component`.`_ICE57AllUsers`=1 WHERE (`Registry`.`Component_`=`Component`.`Component`) AND (`Registry`.`Root`=-1)");
static const TCHAR sqlIce57MarkUFromRegistry[] =  TEXT("UPDATE `Component`, `Registry` SET `Component`.`_ICE57User`=1 WHERE (`Registry`.`Component_`=`Component`.`Component`) AND (`Registry`.`Root`=1)");
static const TCHAR sqlIce57MarkUFromFile[] =  TEXT("UPDATE `Component`, `File`, `Directory` SET `Component`.`_ICE57User`=1 WHERE (`File`.`Component_`=`Component`.`Component`) AND (`Component`.`Directory_`=`Directory`.`Directory`) AND (`Directory`.`_Profile`=2)");
static const TCHAR sqlIce57MarkUDirKeyPath[] =  TEXT("UPDATE `Component`, `Directory` SET `Component`.`_ICE57User`=1, `Component`.`_ICE57KeyPath`=1 WHERE (`Component`.`Directory_`=`Directory`.`Directory`) AND (`Directory`.`_Profile`=2) AND (`Component`.`KeyPath` IS NULL)");
static const TCHAR sqlIce57MarkUFromShortcut[] =  TEXT("UPDATE `Component`, `Shortcut`, `Directory` SET `Component`.`_ICE57User`=1 WHERE (`Component`.`Component`=`Shortcut`.`Component_`) AND (`Shortcut`.`Directory_`=`Directory`.`Directory`) AND (`Directory`.`_Profile`=2) AND (`Shortcut`.`_ICE57Mark`<>1)");
static const TCHAR sqlIce57MarkMFromRegistry[] =  TEXT("UPDATE `Component`, `Registry` SET `Component`.`_ICE57Machine`=1 WHERE (`Registry`.`Component_`=`Component`.`Component`) AND (`Registry`.`Root`<>1)");
static const TCHAR sqlIce57MarkMFromFile[] =  TEXT("UPDATE `Component`, `File`, `Directory` SET `Component`.`_ICE57Machine`=1 WHERE (`File`.`Component_`=`Component`.`Component`) AND (`Component`.`Directory_`=`Directory`.`Directory`) AND (`Directory`.`_Profile`<>2)");
static const TCHAR sqlIce57MarkMDirKeyPath[] =  TEXT("UPDATE `Component`, `Directory` SET `Component`.`_ICE57Machine`=1, `Component`.`_ICE57KeyPath`=2 WHERE (`Component`.`Directory_`=`Directory`.`Directory`) AND (`Directory`.`_Profile`<>2) AND (`Component`.`KeyPath` IS NULL)");
static const TCHAR sqlIce57MarkMFromShortcut[] =  TEXT("UPDATE `Component`, `Shortcut`, `Directory` SET `Component`.`_ICE57Machine`=1 WHERE (`Component`.`Component`=`Shortcut`.`Component_`) AND (`Shortcut`.`Directory_`=`Directory`.`Directory`) AND (`Directory`.`_Profile`<>2) AND (`Shortcut`.`_ICE57Mark`<>1)");

static const TCHAR sqlIce57MarkRegKeyPath[] = TEXT("SELECT `Component`.`Attributes`, `Component`.`_ICE57KeyPath`, `Registry`.`Root` FROM `Component`, `Registry` WHERE (`Component`.`KeyPath`=`Registry`.`Registry`)");
static const int iColIce57MarkRegKeyPath_Attributes =1;
static const int iColIce57MarkRegKeyPath_ICE57KeyPath =2;
static const int iColIce57MarkRegKeyPath_Root =3;

static const TCHAR sqlIce57MarkFileKeyPath[] = TEXT("SELECT `Component`.`Attributes`, `Component`.`_ICE57KeyPath`, `Directory`.`_Profile` FROM `Component`, `File`, `Directory` WHERE (`Component`.`KeyPath`=`File`.`File`) AND (`Component`.`Directory_`=`Directory`.`Directory`)");
static const int iColIce57MarkFileKeyPath_Attributes =1;
static const int iColIce57MarkFileKeyPath_ICE57KeyPath =2;
static const int iColIce57MarkFileKeyPath_Profile =3;

static const TCHAR sqlIce57Component[] =  TEXT("SELECT `Component`.`KeyPath`, `Component`.`Component`, `Component`.`Attributes` FROM `Component` WHERE (`_ICE57User`=1) AND (`_ICE57Machine`=1) AND (`_ICE57KeyPath`<>3)");
static const int iColIce57Component_Component = 1;
static const int iColIce57Component_Attributes = 2;

static const TCHAR sqlIce57AllUsersMachine[] =  TEXT("SELECT `Component` FROM `Component` WHERE `_ICE57AllUsers`=1 AND `_ICE57KeyPath`=2");
static const TCHAR sqlIce57AllUsersUser[] =  TEXT("SELECT `Component` FROM `Component` WHERE `_ICE57User`=1 AND `_ICE57KeyPath`=3");

ICE_ERROR(Ice57BadComponent, 57, ietError, "Component '[2]' has both per-user and per-machine data with a per-machine KeyPath.", "Component\tComponent\t[2]");
ICE_ERROR(Ice57WarnComponent, 57, ietWarning, "Component '[2]' has both per-user and per-machine data with an HKCU Registry KeyPath.", "Component\tComponent\t[2]");
ICE_ERROR(Ice57AllUsersMachine, 57, ietWarning, "Component '[1]' has a registry entry that can be either per-user or per-machine and a per-machine KeyPath.", "Component\tComponent\t[1]");
ICE_ERROR(Ice57AllUsersUser, 57, ietError, "Component '[1]' has both per-user data and a keypath that can be either per-user or per-machine.", "Component\tComponent\t[1]");

ICE_FUNCTION_DECLARATION(57)
{
	// display info
	DisplayInfo(hInstall, 57);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if no component table, none of them are bad.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 57, TEXT("Component")))
		return ERROR_SUCCESS;

	// create temporary column _ICE57User and _ICE57Machine in the component table
	CQuery qColumn1;
	ReturnIfFailed(57, 1, qColumn1.OpenExecute(hDatabase, 0, sqlIce57TempColumnU));
	CQuery qColumn2;
	ReturnIfFailed(57, 2, qColumn2.OpenExecute(hDatabase, 0, sqlIce57TempColumnM));
	CQuery qColumn3;
	ReturnIfFailed(57, 3, qColumn3.OpenExecute(hDatabase, 0, sqlIce57TempColumnA));
	CQuery qColumn4;
	ReturnIfFailed(57, 4, qColumn4.OpenExecute(hDatabase, 0, sqlIce57TempColumnK));

	bool bDirectory = IsTablePersistent(FALSE, hInstall, hDatabase, 57, TEXT("Directory"));
	bool bRegistry  = IsTablePersistent(FALSE, hInstall, hDatabase, 57, TEXT("Registry"));
	bool bFile		= IsTablePersistent(FALSE, hInstall, hDatabase, 57, TEXT("File"));
	bool bFeature	= IsTablePersistent(FALSE, hInstall, hDatabase, 57, TEXT("Feature"));

	// mark the component table for all components containing HKCU or HKLM reg entries
	if (bRegistry)
	{
		CQuery qMarkFromRegistry;
		ReturnIfFailed(57, 5, qMarkFromRegistry.OpenExecute(hDatabase, 0, sqlIce57MarkUFromRegistry));
		ReturnIfFailed(57, 6, qMarkFromRegistry.OpenExecute(hDatabase, 0, sqlIce57MarkMFromRegistry));

		// also mark the -1 column with a 1 for -1 entry thats not a KeyPath.
		ReturnIfFailed(57, 7, qMarkFromRegistry.OpenExecute(hDatabase, 0, sqlIce57MarkAFromRegistry));

		// also mark the keypath as user (1), machine (2) or AllUsers (3) if registry keypath
		PMSIHANDLE hRegRec;
		ReturnIfFailed(57, 8, qMarkFromRegistry.OpenExecute(hDatabase, 0, sqlIce57MarkRegKeyPath));
		UINT iStat;
		while (ERROR_SUCCESS == (iStat = qMarkFromRegistry.Fetch(&hRegRec)))
		{
			// if reg keypath, mark it
			if (::MsiRecordGetInteger(hRegRec, iColIce57MarkRegKeyPath_Attributes) & msidbComponentAttributesRegistryKeyPath)
			{
				switch (::MsiRecordGetInteger(hRegRec, iColIce57MarkRegKeyPath_Root))
				{
				case 1:
					::MsiRecordSetInteger(hRegRec, iColIce57MarkRegKeyPath_ICE57KeyPath, 1);
					break;
				case -1:
					::MsiRecordSetInteger(hRegRec, iColIce57MarkRegKeyPath_ICE57KeyPath, 3);
					break;
				default:
					::MsiRecordSetInteger(hRegRec, iColIce57MarkRegKeyPath_ICE57KeyPath, 2);
					break;
				}
			}
			ReturnIfFailed(57, 10, qMarkFromRegistry.Modify(MSIMODIFY_UPDATE, hRegRec));
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 57, 9);
			return ERROR_SUCCESS;
		}
	}

	if (bDirectory)
	{
		// manage Directory table hold counts (receives 1 from MarkProfile)
		// MarkProfile could fail after having set HOLD count, this helps us
		CManageTable MngDirectoryTable(hDatabase, TEXT("Directory"), /*fAlreadyLocked = */true);

		// first mark all directories in the profile. (Directory._Profile = 2)
		// Directory table will have a lock count +1 after this call
		MarkProfile(hInstall, hDatabase, 57);

		// mark the component table for all components. If it doesn't have any files, 
		// it is not a profile component unless the KeyPath is the directory itself,
		CQuery qMarkDirKeyPath;
		ReturnIfFailed(57, 11, qMarkDirKeyPath.OpenExecute(hDatabase, 0, sqlIce57MarkUDirKeyPath));
		ReturnIfFailed(57, 12, qMarkDirKeyPath.OpenExecute(hDatabase, 0, sqlIce57MarkMDirKeyPath));

		if (bFile)
		{
			CQuery qMarkFromFile;
			ReturnIfFailed(57, 13, qMarkFromFile.OpenExecute(hDatabase, 0, sqlIce57MarkUFromFile));
			ReturnIfFailed(57, 14, qMarkFromFile.OpenExecute(hDatabase, 0, sqlIce57MarkMFromFile));

			PMSIHANDLE hFileRec;
			ReturnIfFailed(57, 15, qMarkFromFile.OpenExecute(hDatabase, 0, sqlIce57MarkFileKeyPath));
			UINT iStat;
			while (ERROR_SUCCESS == (iStat = qMarkFromFile.Fetch(&hFileRec)))
			{
				// if file keypath (not reg or ODBC), mark it
				int iAttributes = ::MsiRecordGetInteger(hFileRec, iColIce57MarkFileKeyPath_Attributes) ;
				if (!(iAttributes & msidbComponentAttributesRegistryKeyPath) &&
					!(iAttributes & msidbComponentAttributesODBCDataSource))
				{
					if (::MsiRecordGetInteger(hFileRec, iColIce57MarkFileKeyPath_Profile) == 2)
						::MsiRecordSetInteger(hFileRec, iColIce57MarkFileKeyPath_ICE57KeyPath, 1);
					else
						::MsiRecordSetInteger(hFileRec, iColIce57MarkFileKeyPath_ICE57KeyPath, 2);
					ReturnIfFailed(57, 16, qMarkFromFile.Modify(MSIMODIFY_UPDATE, hFileRec));
				}
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 57, 17);
				return ERROR_SUCCESS;
			}
		}

		// mark the component table for all shortcuts in the profile
		if (IsTablePersistent(FALSE, hInstall, hDatabase, 57, TEXT("Shortcut")))
		{
			// create a temp column in the shortcut table
			CQuery qColumn;
			ReturnIfFailed(57, 18, qColumn.OpenExecute(hDatabase, 0, sqlIce57TempColumnS));
			if (bFeature)
			{
				CQuery qMarkAdvt;
				ReturnIfFailed(57, 19, qMarkAdvt.OpenExecute(hDatabase, 0, sqlIce57MarkAdvtShortcut));
			}

			CQuery qMarkFromShortcut;
			ReturnIfFailed(57, 20, qMarkFromShortcut.OpenExecute(hDatabase, 0, sqlIce57MarkUFromShortcut));
			ReturnIfFailed(57, 21, qMarkFromShortcut.OpenExecute(hDatabase, 0, sqlIce57MarkMFromShortcut));
		}

		CQuery qFree;
		qFree.OpenExecute(hDatabase, 0, TEXT("ALTER TABLE `Directory` FREE"));
		MngDirectoryTable.RemoveLockCount();
	}

	// All components are marked with per-user and per-machine data flags. Anything marked
	// with both is an error unless HKCU KeyPath, in which case it is a warning.
	PMSIHANDLE hRecResult;
	CQuery qComponent;

	// use the helper function to check that the components are HKCU entries.
	// If the referenced reg key is missing, bogus, or the table is gone, no message.
	// if HKCU (success) give warning, otherwise error.
	ReturnIfFailed(57, 22, qComponent.OpenExecute(hDatabase, 0, sqlIce57Component));
	CheckComponentIsHKCU(hInstall, hDatabase, 57, qComponent, &Ice57BadComponent,
		&Ice57BadComponent, NULL, NULL, NULL, &Ice57BadComponent, &Ice57WarnComponent);

	// check all components with -1 data and per machine keypath
	ReturnIfFailed(57, 23, qComponent.OpenExecute(hDatabase, 0, sqlIce57AllUsersMachine));
	PMSIHANDLE hErrRec;
	UINT iStat;
	while (ERROR_SUCCESS == (iStat = qComponent.Fetch(&hErrRec)))
	{
		ICEErrorOut(hInstall, hErrRec, Ice57AllUsersMachine);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 57, 24);

	// check all components with -1 keypath and user resourcen
	ReturnIfFailed(57, 25, qComponent.OpenExecute(hDatabase, 0, sqlIce57AllUsersUser));
	while (ERROR_SUCCESS == (iStat = qComponent.Fetch(&hErrRec)))
	{
		ICEErrorOut(hInstall, hErrRec, Ice57AllUsersUser);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 57, 26);

	return ERROR_SUCCESS;
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\msiice.dll\msiice5.cpp ===
/* msiice5.cpp - Darwin ICE30-39 code  Copyright  1998-1999 Microsoft Corporation
____________________________________________________________________________*/

#include <windows.h>  // included for both CPP and RC passes
#include <wtypes.h>   // needed for VT_FILETIME
#include <stdio.h>    // printf/wprintf
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "msidefs.h"  // must be in this directory or on INCLUDE path
#include "..\..\common\msiice.h"
#include "..\..\common\query.h"

//!! Fix warnings and remove pragmas
#pragma warning(disable : 4018) // signed/unsigned mismatch
#pragma warning(disable : 4242) // conversion from int to unsigned short

///////////////////////////////////////////////////////////////////////
// ICE30, checks to see that files from different components don't 
// collide. 


// we have an SFN and LFN table which hold the paths and filenames for each file
static const TCHAR sqlICE30CreateSFNTable[] = TEXT("CREATE TABLE `_ICE30SFNTable` ")
												    TEXT("(`IFileName` CHAR NOT NULL TEMPORARY, ")
													TEXT("`Path` CHAR NOT NULL TEMPORARY, ")
													TEXT("`Files` CHAR NOT NULL TEMPORARY, ")
													TEXT("`FileName` CHAR NOT NULL TEMPORARY ")
													TEXT("PRIMARY KEY `IFileName`, `Path`) HOLD");
static const TCHAR sqlICE30CreateLFNTable[] = TEXT("CREATE TABLE `_ICE30LFNTable` ")
												    TEXT("(`IFileName` CHAR NOT NULL TEMPORARY, ")
													TEXT("`Path` CHAR NOT NULL TEMPORARY, ")
													TEXT("`Files` CHAR NOT NULL TEMPORARY, ")
												    TEXT("`FileName` CHAR NOT NULL TEMPORARY ")
													TEXT("PRIMARY KEY `IFileName`, `Path`) HOLD");


// reason we return parent twice is that next time we run this query, it will fail if the entry is a 
// self-referencing root
ICE_QUERY5(qICE30DirWalk, "SELECT `Directory_Parent`, `Directory`, `DefaultDir`, `_ICE30SFN`, `_ICE30LFN` FROM `Directory` WHERE `Directory`.`Directory`=? AND `Directory_Parent`<>?", Parent, Directory, DefaultDir, SFN, LFN);

// retrieve all components for dir walk. Use `Attributes` as dummy initial value. Because it is an integer
// and Identifiers never start with digits, we are guaranteed not to match the first time through the
// directory query.
ICE_QUERY4(qICE30ComponentDirs, "SELECT `Directory_`, `Attributes`, `Condition`, `Component` FROM `Component`", Directory, Attributes, Condition, Component);

// alter the Dir Table
static const TCHAR sqlICE30AlterDirTable1[] = TEXT("ALTER TABLE `Directory` ADD `_ICE30SFN` CHAR TEMPORARY HOLD");
static const TCHAR sqlICE30AlterDirTable2[] = TEXT("ALTER TABLE `Directory` ADD `_ICE30LFN` CHAR TEMPORARY HOLD");

// alter the File Table
static const TCHAR sqlICE30AlterFileTable1[] = TEXT("ALTER TABLE `File` ADD `_ICE30SFN` CHAR TEMPORARY HOLD");
static const TCHAR sqlICE30AlterFileTable2[] = TEXT("ALTER TABLE `File` ADD `_ICE30LFN` CHAR TEMPORARY HOLD");
static const TCHAR sqlICE30AlterFileTable3[] = TEXT("ALTER TABLE `File` ADD `_ICE30Condition` CHAR TEMPORARY HOLD");
static const TCHAR sqlICE30AlterFileTable4[] = TEXT("ALTER TABLE `File` ADD `_ICE30SFNM` CHAR TEMPORARY HOLD");
static const TCHAR sqlICE30AlterFileTable5[] = TEXT("ALTER TABLE `File` ADD `_ICE30LFNM` CHAR TEMPORARY HOLD");
//static const TCHAR sqlICE30UpdateFile[] = TEXT("SELECT  `_ICE30SFNM`, `_ICE30LFNM`, `_ICE30Condition` FROM `File1` WHERE (`Component_`=?)");

ICE_QUERY6(qICE30UpdateFile, "UPDATE `File` SET `_ICE30SFNM`=?, `_ICE30LFNM`=?, `_ICE30Condition`=?, `_ICE30SFN`=?, `_ICE30LFN`=? WHERE (`Component_`=?)", PathShortM, PathLongM, Condition, PathShort, PathLong, Component);

// query the file tables. Need the 4th column to handle the mixed-case filename
ICE_QUERY4(qICE30FileSFN, "SELECT `FileName`, `_ICE30SFN`, `File`, `File` FROM `File`", IFilename, SFN, File, Filename);
ICE_QUERY4(qICE30FileLFN, "SELECT `FileName`, `_ICE30LFN`, `File`, `File` FROM `File` WHERE (`FileName`=?) AND (`_ICE30SFN`=?) AND (`File`=?)", IFilename, LFN, File, Filename);

// insert into the private tables
static const TCHAR sqlICE30InsertSFN[] = TEXT("SELECT * FROM `_ICE30SFNTable`");
static const TCHAR sqlICE30InsertLFN[] = TEXT("SELECT * FROM `_ICE30LFNTable`");

// query private tables
static const TCHAR sqlICE30QueryPrivateSFN[] = TEXT("SELECT `Files`, `Path` FROM `_ICE30SFNTable` WHERE (`IFileName`=?) AND (`Path`=?)");
static const TCHAR sqlICE30QueryPrivateLFN[] = TEXT("SELECT `Files`, `Path` FROM `_ICE30LFNTable` WHERE (`IFileName`=?) AND (`Path`=?)");
static const int iColICE30QueryPrivateXFN_Files = 1;

// queries the property table for any directories that 
static const TCHAR sqlICE30GetProperty[] = TEXT("SELECT `Property`.`Value`, `Property`.`Value`, `Directory`.`Directory` FROM `Property`, `Directory` WHERE `Property`.`Property`=`Directory`.`Directory`");
static const TCHAR iColICE30GetProperty_SFN = 1;
static const TCHAR iColICE30GetProperty_LFN = 2;
static const TCHAR iColICE30GetProperty_Directory = 3;

// query the InstallExecuteSequence table in order to get type 51 custom actions at the beginning of the table
ICE_QUERY2(sqlICE30GetAction, "SELECT `Action`, `Condition` FROM `InstallExecuteSequence` ORDER BY `Sequence`", Action, Condition);

// query the CustomAction table to get the Target and the Source
ICE_QUERY4(sqlICE30GetTargetSource, "SELECT `CustomAction`.`Target`, `CustomAction`.`Target`, `CustomAction`.`Source` , `CustomAction`.`Type` FROM `CustomAction` WHERE `CustomAction`.`Action` = ?", Target1, Target2, Source, Type);

// walk through the directory table for directories of the form "<standard folders>.<GUID>"
ICE_QUERY3(sqlICE30Directory, "SELECT `_ICE30SFN`, `_ICE30LFN`, `Directory` FROM `Directory`", _ICE30SFN, _ICE30LFN, Directory);

// sets a directory from the property or CA table
static const TCHAR sqlICE30SetDir[] = TEXT("UPDATE `Directory` SET `_ICE30SFN`=?, `_ICE30LFN`=? WHERE `Directory`=?");

// retrieve everything needed to output a message. By adding the condition of the component to 
// the file table, we avoid having to do a join between File and Component every time we want to 
// execute this query
ICE_QUERY7(qICE30GetFileInfo, "SELECT `File`, `Component_`, `FileName`, `_ICE30Condition`, `_ICE30SFNM`, `_ICE30LFNM`, `_ICE30Condition` FROM `File` WHERE `File`=?", File, Component, FileName, Condition, SFNM, LFNM, Condition2)

ICE_ERROR(ICE30LNoCond1, 30, ietError, "The target file '[3]' is installed in '[6]' by two different components on an LFN system: '[2]' and '[7]'. This breaks component reference counting.", "File\tFile\t[4]");
ICE_ERROR(ICE30LNoCond2, 30, ietError, "The target file '[3]' is installed in '[6]' by two different components on an LFN system: '[2]' and '[7]'. This breaks component reference counting.", "File\tFile\t[1]");
ICE_ERROR(ICE30LOneCond1, 30, ietError, "Installation of a conditionalized component would cause the target file '[3]' to be installed in '[6]' by two different components on an LFN system: '[2]' and '[7]'. This would break component reference counting.", "File\tFile\t[4]");
ICE_ERROR(ICE30LOneCond2, 30, ietError, "Installation of a conditionalized component would cause the target file '[3]' to be installed in '[6]' by two different components on an LFN system: '[2]' and '[7]'. This would break component reference counting.", "File\tFile\t[1]");
ICE_ERROR(ICE30LBothCond1, 30, ietWarning, "The target file '[3]' might be installed in '[6]' by two different conditionalized components on an LFN system: '[2]' and '[7]'. If the conditions are not mutually exclusive, this will break the component reference counting system.", "File\tFile\t[4]");
ICE_ERROR(ICE30LBothCond2, 30, ietWarning, "The target file '[3]' might be installed in '[6]' by two different conditionalized components on an LFN system: '[2]' and '[7]'. If the conditions are not mutually exclusive, this will break the component reference counting system.", "File\tFile\t[1]");
ICE_ERROR(ICE30SNoCond1, 30, ietError, "The target file '[3]' is installed in '[5]' by two different components on an SFN system: '[2]' and '[7]'. This breaks component reference counting.", "File\tFile\t[4]");
ICE_ERROR(ICE30SNoCond2, 30, ietError, "The target file '[3]' is installed in '[5]' by two different components on an SFN system: '[2]' and '[7]'. This breaks component reference counting.", "File\tFile\t[1]");
ICE_ERROR(ICE30SOneCond1, 30, ietError, "Installation of a conditionalized component would cause the target file '[3]' to be installed in '[6]' by two different components on an SFN system: '[2]' and '[7]'. This would break component reference counting.", "File\tFile\t[4]");
ICE_ERROR(ICE30SOneCond2, 30, ietError, "Installation of a conditionalized component would cause the target file '[3]' to be installed in '[6]' by two different components on an SFN system: '[2]' and '[7]'. This would break component reference counting.", "File\tFile\t[1]");
ICE_ERROR(ICE30SBothCond1, 30, ietWarning, "The target file '[3]' might be installed in '[5]' by two different conditionalized components on an SFN system: '[2]' and '[7]'. If the conditions are not mutually exclusive, this will break the component reference counting system.", "File\tFile\t[4]");
ICE_ERROR(ICE30SBothCond2, 30, ietWarning, "The target file '[3]' might be installed in '[5]' by two different conditionalized components on an SFN system: '[2]' and '[7]'. If the conditions are not mutually exclusive, this will break the component reference counting system.", "File\tFile\t[1]");
ICE_ERROR(ICE30BadFilename, 30, ietError, "The target file '[1]' could not be retrieved from the database to be validated. It may be too long.", "File\tFile\t[3]");
ICE_ERROR(ICE30LSameComponent1, 30, ietError, "Installation of component '[2]' would cause the target file '[3]' to be installed twice in '[6]' on an LFN system. This will break the component reference counting system.", "File\tFile\t[4]");
ICE_ERROR(ICE30LSameComponent2, 30, ietError, "Installation of component '[2]' would cause the target file '[3]' to be installed twice in '[6]' on an LFN system. This will break the component reference counting system.", "File\tFile\t[1]");
ICE_ERROR(ICE30SSameComponent1, 30, ietError, "Installation of component '[2]' would cause the target file '[3]' to be installed twice in '[5]' on an SFN system. This will break the component reference counting system.", "File\tFile\t[4]");
ICE_ERROR(ICE30SSameComponent2, 30, ietError, "Installation of component '[2]' would cause the target file '[3]' to be installed twice in '[5]' on an SFN system. This will break the component reference counting system.", "File\tFile\t[1]");

ICE_ERROR(ICE30ComponentProgress, 30, ietInfo, "Resolving Component Paths...","");
ICE_ERROR(ICE30FileProgress, 30, ietInfo, "Checking for colliding files...","");


bool ICE30ResolveTargetPath(MSIHANDLE hInstall, MSIHANDLE hDatabase, MSIHANDLE hParent, TCHAR **pszLong, unsigned long &cchLong, 
							TCHAR **pszShort, unsigned long &cchShort)
{
	CQuery qDir;
	UINT iStat;
	UINT iResult;

	if (ERROR_SUCCESS != (iStat = qDir.Open(hDatabase, qICE30DirWalk::szSQL)))
	{
		APIErrorOut(hInstall, iStat, 30, 100);
		return false;
	}

	// if nobody has allocated any memory, do so
	if ((*pszLong == NULL) || (cchLong == 0))
	{
		*pszLong = new TCHAR[MAX_PATH];
		**pszLong = _T('\0');
		cchLong = MAX_PATH;
	}
	if ((*pszShort == NULL) || (cchShort == 0))
	{
		*pszShort = new TCHAR[MAX_PATH];
		**pszShort = _T('\0');
		cchShort = MAX_PATH;
	}

	// fetch the directory we are looking for
	PMSIHANDLE hDirectory;		 
	if (ERROR_SUCCESS != (iStat = qDir.Execute(hParent))) {
		APIErrorOut(hInstall, iStat, 30, 101);
		return false;
	}
	iStat = qDir.Fetch(&hDirectory);
	switch (iStat) 
	{ 
	case ERROR_SUCCESS:
		// found directory
		break;
	case ERROR_NO_MORE_ITEMS:
		// query failed. We must have hit the root already
		return true;
	default:
		// bad news
		APIErrorOut(hInstall, iStat, 30, 102);
		return false;
	}

	// if it has not already been resolved, resolve it
	if (::MsiRecordIsNull(hDirectory, 4)) 
	{

		// resolve our parent directory. If our parent is null or a self-referencing root, this will simply
		// return true and we can keep going
		if (!ICE30ResolveTargetPath(hInstall, hDatabase, hDirectory, pszLong, cchLong, pszShort, cchShort))
			return false;

		// now tack on our path to whatever our parent had
		TCHAR *pszBuffer = NULL;
		DWORD dwBuffer = 512;
		
		// get the directory name from the record
		UINT iResult = IceRecordGetString(hDirectory, 3, &pszBuffer, &dwBuffer, NULL);
		if (ERROR_SUCCESS != iResult)
		{
			// couldn't get string. Not good
			return false;
		}	

		// search for the divider between Target and Source
		TCHAR *szTargetDivider = _tcschr(pszBuffer, _T(':'));
		if (szTargetDivider) 
			*szTargetDivider = _T('\0');

		// search for the divider between SFN and LFN
		TCHAR *szDivider = _tcschr(pszBuffer, _T('|'));
		if (szDivider)
			*szDivider = _T('\0');

		// if there is nothing there, we are completely hosed
		int len = _tcslen(pszBuffer);
		if (len == 0) {
			DELETE_IF_NOT_NULL(pszBuffer);
			return false;
		}

		// check to see if we are treading water
		if (_tcscmp(pszBuffer, _T(".")) != 0) 
		{
			// we contribute to the path
			if (_tcslen(*pszShort) + len >= cchShort-2)
			{
				// not enough memory to hold the path
				TCHAR *temp = new TCHAR[cchShort+MAX_PATH];
				_tcscpy(temp, *pszShort);
				delete[] *pszShort;
				*pszShort = temp;
				cchShort += MAX_PATH;
			}

			// tack our contirbution on to the end
			_tcscat(*pszShort, pszBuffer);
			_tcscat(*pszShort, _T("\\"));
		}

		// if we found an LFN, process it
		if (szDivider) 
		{
			szDivider = _tcsinc(szDivider);
		} 
		else
			szDivider = pszBuffer;

		// otherwise use the SFN for it as well
		len = _tcslen(szDivider);
		if (len != 0) 
		{
			// check for no contribution
			if (_tcscmp(szDivider, _T(".")) != 0) 
			{
				// we contribute to the path
				if (_tcslen(*pszLong) + len >= cchLong-2)
				{
					// not enough memory to hold the path
					TCHAR *temp = new TCHAR[cchLong+MAX_PATH];
					_tcscpy(temp, *pszLong);
					delete[] *pszLong;
					*pszLong = temp;
					cchLong += MAX_PATH;
				}

				// tack our contirbution on to the end
				_tcscat(*pszLong, szDivider);
				_tcscat(*pszLong, _T("\\"));
			}
		}

		::MsiRecordSetString(hDirectory, 4, *pszShort);
		::MsiRecordSetString(hDirectory, 5, *pszLong);
		qDir.Modify(MSIMODIFY_UPDATE, hDirectory);

		DELETE_IF_NOT_NULL(pszBuffer);

		return true;
	}

	// this directory has already been resolved, so we just need to
	// retrieve what is already in there
	iResult = IceRecordGetString(hDirectory, 4, pszShort, NULL, &cchShort);
	if (ERROR_SUCCESS != iResult)
		return false;

	iResult = IceRecordGetString(hDirectory, 5, pszLong, NULL, &cchLong);
	if (ERROR_SUCCESS != iResult)
		return false;

	// and we're good to go
	return true;
}

/////////////////////////////////////////////////////////////////////////////
// the file entry already exists in the table. Output the error messages
bool ICE30Collision(MSIHANDLE hInstall, MSIHANDLE hDatabase, CQuery &qExisting, MSIHANDLE hFileRec, bool bLFN)
{
	int iCondition = 0;
	int iStartCondition = 0;
	CQuery qGetInfo;
	PMSIHANDLE hExecRec = ::MsiCreateRecord(1);
	PMSIHANDLE hResultRec = 0;

	// get the record out that existed. If it doesn't exist, there was some problem resolving
	// the directory. (most likely a bad foreign key somewhere...), so unable to check.
	PMSIHANDLE hExistingRec;
	ReturnIfFailed(30, 200, qExisting.Execute(hFileRec));

	UINT iStat;
	switch (iStat = qExisting.Fetch(&hExistingRec))
	{
	case ERROR_SUCCESS: break;
	case ERROR_NO_MORE_ITEMS: return true;
	default:
		APIErrorOut(hInstall, iStat, 30, 201);
		return false;
	}

	// pull this file key into a string buffer
	TCHAR* pszFileKey = NULL;
	DWORD cchFileKey = 0;
	ReturnIfFailed(30, 202, IceRecordGetString(hFileRec, qICE30FileSFN::File, &pszFileKey, NULL, &cchFileKey));

	// get the condition value for and component the current file
	::MsiRecordSetString(hExecRec, 1, pszFileKey);
	ReturnIfFailed(30, 203, qGetInfo.FetchOnce(hDatabase, hExecRec, &hResultRec, qICE30GetFileInfo::szSQL));
	iStartCondition = ::MsiRecordIsNull(hResultRec, qICE30GetFileInfo::Condition) ? 0 : 1;

	// pull this component key into a string buffer
	TCHAR* pszComponent = NULL;
	DWORD cchComponent = 0;
	ReturnIfFailed(30, 204, IceRecordGetString(hResultRec,  qICE30GetFileInfo::Component, &pszComponent, NULL, &cchComponent));

	// Buffer to hold the component of existing file records. This is used to
	// compare if two files with the same names and paths are being installed
	// by the same components.
	TCHAR* pszComponentExist = NULL;
	DWORD dwComponentExist = iMaxBuf;

	// get the list of file keys. Reserve enough space for us to tack on the current 
	// file key to the end and update the record
	TCHAR *pszBuffer = new TCHAR[255];
	DWORD cchBuffer = 255-cchFileKey-2;
	UINT iResult = ::MsiRecordGetString(hExistingRec, iColICE30QueryPrivateXFN_Files, pszBuffer, &cchBuffer);
	if (iResult == ERROR_MORE_DATA) {
		delete[] pszBuffer;
		cchBuffer+= cchFileKey+2;
		pszBuffer = new TCHAR[cchBuffer];
		iResult = ::MsiRecordGetString(hExistingRec, iColICE30QueryPrivateXFN_Files, pszBuffer, &cchBuffer);
	}

	// loop through every file key in the "Files" column of the record
	TCHAR *szCurFileKey = pszBuffer;
	while (szCurFileKey)
	{
		// turn the first list entry into a seperate string
		TCHAR *szSemiColon = _tcschr(szCurFileKey, TEXT(';'));
		if (szSemiColon) *szSemiColon = TEXT('\0');

		// retrieve the file, component, filename, condition, and path of this file
		::MsiRecordSetString(hExecRec, 1, szCurFileKey);
		ReturnIfFailed(30, 205, qGetInfo.Execute(hExecRec));
		ReturnIfFailed(30, 206, qGetInfo.Fetch(&hResultRec));

		// add the condition count
		iCondition = iStartCondition + (::MsiRecordIsNull(hResultRec, qICE30GetFileInfo::Condition) ? 0 : 1);

		// set the other file key and component into the condition location
		::MsiRecordSetString(hResultRec, qICE30GetFileInfo::Condition, pszFileKey);
		::MsiRecordSetString(hResultRec, qICE30GetFileInfo::Condition2, pszComponent);

		// Get the component for the file in the XFN table..
		ReturnIfFailed(20, 207, IceRecordGetString(hResultRec, qICE30GetFileInfo::Component, &pszComponentExist, &dwComponentExist, NULL));

		// Compare if the two files are installed by the same component. If
		// yes, report error.

		if(_tcscmp(pszComponent, pszComponentExist) == 0)
		{
			ICEErrorOut(hInstall, hResultRec, bLFN ? ICE30LSameComponent1 : ICE30SSameComponent1);
			ICEErrorOut(hInstall, hResultRec, bLFN ? ICE30LSameComponent2 : ICE30SSameComponent2);
		}
		else
		{
			// output the message based on the condition count and LFN value
			switch (iCondition) 
			{
			case 0: 
				ICEErrorOut(hInstall, hResultRec, bLFN ? ICE30LNoCond1 : ICE30SNoCond1); 
				ICEErrorOut(hInstall, hResultRec, bLFN ? ICE30LNoCond2 : ICE30SNoCond2); 
				break;
			case 1: 
				ICEErrorOut(hInstall, hResultRec, bLFN ? ICE30LOneCond1 : ICE30SOneCond1); 
				ICEErrorOut(hInstall, hResultRec, bLFN ? ICE30LOneCond2 : ICE30SOneCond2); 
				break;
			case 2: 
				ICEErrorOut(hInstall, hResultRec, bLFN ? ICE30LBothCond1 : ICE30SBothCond1); 
				ICEErrorOut(hInstall, hResultRec, bLFN ? ICE30LBothCond2 : ICE30SBothCond2); 
				break;
			default: // should never happen
				APIErrorOut(hInstall, 0, 30, 208);
				return false;
			}
		}

		// restore the semicolon and move forward
		if (szSemiColon) *(szSemiColon++) = TEXT(';');
		szCurFileKey = szSemiColon;
	}

	// now update the record to add this file key to the end
	_tcscat(pszBuffer, TEXT(";"));
	_tcscat(pszBuffer, pszFileKey);
	::MsiRecordSetString(hExistingRec, iColICE30QueryPrivateXFN_Files, pszBuffer);
	qExisting.Modify(MSIMODIFY_UPDATE, hExistingRec);

	// cleanup
	DELETE_IF_NOT_NULL(pszFileKey);
	DELETE_IF_NOT_NULL(pszBuffer);
	DELETE_IF_NOT_NULL(pszComponent);

	return true;
}

///////////////////////////////////////////////////////////////////////
// ICE30 - checks for colliding files
ICE_FUNCTION_DECLARATION(30)
{
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display generic info
	DisplayInfo(hInstall, 30);
	
	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 30, 1);
		return ERROR_SUCCESS;
	}

	// do we have the File table? If not, obviously no colliding files
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 30, TEXT("File")))
		return ERROR_SUCCESS;
	// do we have the Component table? If not, trouble, files must have a component reference,
	// but thats not this ICEs problem.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 30, TEXT("Component")) ||
		!IsTablePersistent(FALSE, hInstall, hDatabase, 30, TEXT("Directory")))
		return ERROR_SUCCESS;

	// create a temporary table to hold information
	CQuery qCreate;

	// manage the Directory and File and created table(s) hold counts
	CManageTable MngDirectoryTable(hDatabase, TEXT("Directory"), /*fAlreadyLocked = */false);
	CManageTable MngFileTable(hDatabase, TEXT("File"), /*fAlreadyLocked = */false);
	CManageTable MngIce30SFNTable(hDatabase, TEXT("_ICE30SFNTable"), /*fAlreadyLocked = */false);
	CManageTable MngIce30LFNTable(hDatabase, TEXT("_ICE30LFNTable"), /*fAlreadyLocked = */false);

	// create columns in the dir table
	ReturnIfFailed(30, 2, qCreate.OpenExecute(hDatabase, NULL, sqlICE30AlterDirTable1));
	qCreate.Close();
	MngDirectoryTable.AddLockCount();

	ReturnIfFailed(30, 3, qCreate.OpenExecute(hDatabase, NULL, sqlICE30AlterDirTable2));
	qCreate.Close();
	MngDirectoryTable.AddLockCount();

	// create columns in the file table
	ReturnIfFailed(30, 4, qCreate.OpenExecute(hDatabase, NULL, sqlICE30AlterFileTable1));
	qCreate.Close();
	MngFileTable.AddLockCount();

	ReturnIfFailed(30, 5, qCreate.OpenExecute(hDatabase, NULL, sqlICE30AlterFileTable2));
	qCreate.Close();
	MngFileTable.AddLockCount();

	ReturnIfFailed(30, 6, qCreate.OpenExecute(hDatabase, NULL, sqlICE30AlterFileTable3));
	qCreate.Close();
	MngFileTable.AddLockCount();

	ReturnIfFailed(30, 7, qCreate.OpenExecute(hDatabase, NULL, sqlICE30AlterFileTable4));
	qCreate.Close();
	MngFileTable.AddLockCount();

	ReturnIfFailed(30, 8, qCreate.OpenExecute(hDatabase, NULL, sqlICE30AlterFileTable5));
	qCreate.Close();
	MngFileTable.AddLockCount();

	// create the temporary tables
	ReturnIfFailed(30, 9, qCreate.OpenExecute(hDatabase, NULL, sqlICE30CreateSFNTable));
	qCreate.Close();
	MngIce30SFNTable.AddLockCount();
	
	ReturnIfFailed(30, 10, qCreate.OpenExecute(hDatabase, NULL, sqlICE30CreateLFNTable));
	qCreate.Close();
	MngIce30LFNTable.AddLockCount();

	////
	// fully resolve all of the directory paths and insert values into file table
	PMSIHANDLE hProgress = ::MsiCreateRecord(1);
	ICEErrorOut(hInstall, hProgress, ICE30ComponentProgress);

	// check the property table for directory definitions
	CQuery qSetDir;
	qSetDir.Open(hDatabase, sqlICE30SetDir);
	PMSIHANDLE hDirRec;
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 30, TEXT("Property")))
	{
		CQuery qProperty;
		qProperty.OpenExecute(hDatabase, 0, sqlICE30GetProperty);
		while (ERROR_SUCCESS == (iStat = qProperty.Fetch(&hDirRec)))
			qSetDir.Execute(hDirRec);
		if (ERROR_NO_MORE_ITEMS != iStat)
		{ 
			APIErrorOut(hInstall, 0, 30, 11);
			return ERROR_SUCCESS;
		}
	}
	
	// When a MSM is merged with a database, sometimes custom actions of type
	// 51 is generated by Darwin and placed at the beginning of a sequence
	// table to set directory properties. We should check for these properties
	// as well.
	if(IsTablePersistent(FALSE, hInstall, hDatabase, 30, TEXT("ModuleSignature")))
	{
		// This is a merge module. Type 51 custom action is not required. Go
		// through the Directory table and look for directories of the form
		// "<Standard Folder>.<GUID>", set "[Stander Folder]" in the temporary
		// columns.
		CQuery		qDirectory;
		PMSIHANDLE	hDirectory;
		TCHAR*	pDirectory = new TCHAR[73];
		DWORD	dwDirectory = 73;

		if(!pDirectory)
		{
			APIErrorOut(hInstall, GetLastError(), 30, __LINE__);
			return ERROR_SUCCESS;
		}

		ReturnIfFailed(30, __LINE__, qDirectory.OpenExecute(hDatabase, 0, sqlICE30Directory::szSQL));
		while((iStat = qDirectory.Fetch(&hDirectory)) == ERROR_SUCCESS)
		{
			if((iStat = IceRecordGetString(hDirectory, sqlICE30Directory::Directory, &pDirectory, &dwDirectory, NULL)) != ERROR_SUCCESS)
			{
				APIErrorOut(hInstall, iStat, 30, __LINE__);
				delete []pDirectory;
				return ERROR_SUCCESS;
			}

			for(int i = 1; i < cDirProperties; i++)
			{
				if(_tcsncmp(pDirectory, rgDirProperties[i].tz, rgDirProperties[i].cch) == 0 && *(pDirectory + rgDirProperties[i].cch) == TEXT('.'))
				{
					// This is a standard folder. Set the temporary columns.
					TCHAR		szTmp[73];	// '[]' and null terminator.

					wsprintf(szTmp, TEXT("[%s]"), rgDirProperties[i].tz);
					if((iStat = ::MsiRecordSetString(hDirectory, sqlICE30Directory::_ICE30SFN, szTmp)) != ERROR_SUCCESS)
					{
						APIErrorOut(hInstall, iStat, 30, __LINE__);
						delete [] pDirectory;
						return ERROR_SUCCESS;
					}
					if((iStat = ::MsiRecordSetString(hDirectory, sqlICE30Directory::_ICE30LFN, szTmp)) != ERROR_SUCCESS)
					{
						APIErrorOut(hInstall, iStat, 30, __LINE__);
						delete [] pDirectory;
						return ERROR_SUCCESS;
					}
					qSetDir.Execute(hDirectory);
					break;
				}
			}
		}
		delete [] pDirectory;
		qDirectory.Close();
		if(iStat != ERROR_NO_MORE_ITEMS)
		{
			APIErrorOut(hInstall, iStat, 30, __LINE__);
			return ERROR_SUCCESS;
		}
	}
	else if(IsTablePersistent(FALSE, hInstall, hDatabase, 30, TEXT("InstallExecuteSequence")) &&
			IsTablePersistent(FALSE, hInstall, hDatabase, 30, TEXT("CustomAction")))
	{
		CQuery		qSequence;
		PMSIHANDLE	hSequence;

		ReturnIfFailed(30, 1001, qSequence.OpenExecute(hDatabase, 0, sqlICE30GetAction::szSQL));
		
		while((iStat = qSequence.Fetch(&hSequence)) == ERROR_SUCCESS)
		{
			// The actions we got from the InstallExecuteSequence table are
			// ordered by their sequence #s. The actions that we are interested
			// in are:
			// 1. At the beginning of the table
			// 2. Conditionless
			// 3. Of type 51
			if(::MsiRecordIsNull(hSequence, sqlICE30GetAction::Condition))
			{
				UINT		iStat2;
				CQuery		qCA;
				PMSIHANDLE	hCARec;

				if((iStat2 = qCA.FetchOnce(hDatabase, hSequence, &hCARec, sqlICE30GetTargetSource::szSQL)) == ERROR_SUCCESS)
				{
					int		iType;

					iType = ::MsiRecordGetInteger(hCARec, sqlICE30GetTargetSource::Type);
					iType &= 0x3F;
					if((iType & 0x0F) != msidbCustomActionTypeTextData || (iType & 0xF0) != msidbCustomActionTypeProperty)
					{
						// Not type 51 custom action. Stop looking further
						// because if there are any Darwin generated type
						// 51 custom actions they should be at the beginning
						// of the sequence table.
						break;
					}

					qSetDir.Execute(hCARec);
				}
				else if(iStat2 == ERROR_NO_MORE_ITEMS)
				{
					// We did not find this custom action or it's not type 51.
					// No more Darwin generated custom action of type 51, stop
					// looking for them.
					break;
				}
				else
				{
					// Some kind of error had occured.
					APIErrorOut(hInstall, 0, 30, 1004);
					qSequence.Close();
					return ERROR_SUCCESS;
				}
			}
			else
			{
				// We encountered an action that's not conditionless. This is
				// the end of the Darwin generated type 51 custom action. Stop
				// searching for them.
				break;
			}
		}
		if(iStat != ERROR_NO_MORE_ITEMS && iStat != ERROR_SUCCESS)
		{ 
			APIErrorOut(hInstall, 0, 30, 1000);
			qSequence.Close();
			return ERROR_SUCCESS;
		}
	}

	// also check Darwin properties
	hDirRec = ::MsiCreateRecord(3);
	for (int i=0; i < cwzSystemProperties; i++)
	{
		TCHAR szBuffer[63];
		_stprintf(szBuffer, TEXT("[%ls]\\"), rgwzSystemProperties[i]);
		MsiRecordSetString(hDirRec, 1, szBuffer);
		MsiRecordSetString(hDirRec, 2, szBuffer);
		MsiRecordSetStringW(hDirRec, 3, rgwzSystemProperties[i]);
		qSetDir.Execute(hDirRec);
	};

	TCHAR *szComponent = NULL;
	DWORD cchComponent = 0;

	PMSIHANDLE hComponentRec;
	CQuery qComponents;
	ReturnIfFailed(30, 9, qComponents.OpenExecute(hDatabase, NULL, qICE30ComponentDirs::szSQL));
	while (ERROR_SUCCESS == (iStat = qComponents.Fetch(&hComponentRec))) 
	{
		// get the complete absolute path to this component
		TCHAR *szPathShort = NULL;
		TCHAR *szPathLong = NULL;
		unsigned long cchShort;
		unsigned long cchLong;
		
		// get the fully expanded path to the component
		if (ICE30ResolveTargetPath(hInstall, hDatabase, hComponentRec, &szPathLong, cchLong, &szPathShort, cchShort))
		{
			PMSIHANDLE hFileRec = MsiCreateRecord(6);
			MsiRecordSetString(hFileRec, qICE30UpdateFile::PathShortM, szPathShort);
			MsiRecordSetString(hFileRec, qICE30UpdateFile::PathLongM, szPathLong);
			MsiRecordSetString(hFileRec, qICE30UpdateFile::Condition, ::MsiRecordIsNull(hComponentRec, qICE30ComponentDirs::Condition) ? TEXT("") : TEXT("1"));
			
			// now make uppercase versions of the path
			TCHAR *pchToUpper = NULL;
			for (pchToUpper=szPathShort; *pchToUpper && *pchToUpper != TEXT('|') ; pchToUpper++)
#ifdef UNICODE
				*pchToUpper = towupper(*pchToUpper);
#else
				*pchToUpper = toupper(*pchToUpper);
#endif
			for (pchToUpper=szPathLong; *pchToUpper && *pchToUpper != TEXT('|') ; pchToUpper++)
#ifdef UNICODE
				*pchToUpper = towupper(*pchToUpper);
#else
				*pchToUpper = toupper(*pchToUpper);
#endif
			MsiRecordSetString(hFileRec, qICE30UpdateFile::PathShort, szPathShort);
			MsiRecordSetString(hFileRec, qICE30UpdateFile::PathLong, szPathLong);

			ReturnIfFailed(30, 24, IceRecordGetString(hComponentRec, qICE30ComponentDirs::Component, &szComponent, &cchComponent, NULL));
			MsiRecordSetString(hFileRec, qICE30UpdateFile::Component, szComponent);

			// update the File table entries
			CQuery qFileUpdate;
			ReturnIfFailed(30, 13, qFileUpdate.OpenExecute(hDatabase, hFileRec, qICE30UpdateFile::szSQL));
		}

		// we are responsible for cleaning up after ResolveTargetPath
		delete[] szPathLong;
		delete[] szPathShort;
	}
	qComponents.Close();

	if (szComponent)
	{
		delete[] szComponent;
		szComponent = NULL;
	}

	// make sure we left the loop because we ran out of components
	if (ERROR_NO_MORE_ITEMS != iStat)
	{ 
		APIErrorOut(hInstall, 0, 30, 15);
		return ERROR_SUCCESS;
	}

	// SFN/LFN tables are Filename(key, all upper) Directory(key, all upper) File(s) OriginalFile
	// pull each file from the file table and stick it in the SFN and LFN table by filename and directory. If
	// it already exists, its a conflict
	CQuery qFileSFN;
	CQuery qFileLFN;
	CQuery qInsertSFN;
	CQuery qInsertLFN;
	CQuery qFindSFN;
	CQuery qFindLFN;
	PMSIHANDLE hFileSFN;
	PMSIHANDLE hFileLFN;
	PMSIHANDLE hExisting;

	ReturnIfFailed(30, 16, qFileSFN.OpenExecute(hDatabase, 0, qICE30FileSFN::szSQL));
	ReturnIfFailed(30, 17, qFileLFN.Open(hDatabase, qICE30FileLFN::szSQL));
	ReturnIfFailed(30, 18, qInsertSFN.OpenExecute(hDatabase, 0, sqlICE30InsertSFN));
	ReturnIfFailed(30, 19, qInsertLFN.OpenExecute(hDatabase, 0, sqlICE30InsertLFN));
	ReturnIfFailed(30, 20, qFindSFN.Open(hDatabase, sqlICE30QueryPrivateSFN));
	ReturnIfFailed(30, 21, qFindLFN.Open(hDatabase, sqlICE30QueryPrivateLFN));

	ICEErrorOut(hInstall, hProgress, ICE30FileProgress);

	TCHAR* pszFile = NULL;
	DWORD dwFile = 512;
	while (ERROR_SUCCESS == (iStat = qFileSFN.Fetch(&hFileSFN))) 
	{
		// get the LFN path. It must exist because its the same record as the SFN, just a different order
		ReturnIfFailed(30, 22, qFileLFN.Execute(hFileSFN));
		ReturnIfFailed(30, 23, qFileLFN.Fetch(&hFileLFN));

		// get the complete absolute path to this component
		TCHAR *szFilenameShort = NULL;
		TCHAR *szFilenameLong = NULL;
		TCHAR *pchToUpper = NULL;

		// retrieve the filename
		if (ERROR_SUCCESS != IceRecordGetString(hFileSFN, qICE30FileSFN::IFilename, &pszFile, &dwFile, NULL))
		{
			ICEErrorOut(hInstall, hFileSFN, ICE30BadFilename);
			continue;
		}

		// split the filename
		szFilenameShort = pszFile;
		szFilenameLong = _tcschr(pszFile, _T('|'));
		if (szFilenameLong)
			*(szFilenameLong++) = _T('\0');
		else
			szFilenameLong = szFilenameShort;

		// insert the SFN in both mixed case and all upper case
		::MsiRecordSetString(hFileSFN, qICE30FileSFN::Filename, szFilenameShort);
		::MsiRecordSetString(hFileLFN, qICE30FileLFN::Filename, szFilenameLong);

		for (pchToUpper=szFilenameShort; *pchToUpper && *pchToUpper != TEXT('|') ; pchToUpper++)
#ifdef UNICODE
			*pchToUpper = towupper(*pchToUpper);
#else
			*pchToUpper = toupper(*pchToUpper);
#endif
		::MsiRecordSetString(hFileSFN, qICE30FileSFN::IFilename, szFilenameShort);

		if (ERROR_SUCCESS != qInsertSFN.Modify(MSIMODIFY_INSERT, hFileSFN))
		{
			// output the messages
			ICE30Collision(hInstall, hDatabase, qFindSFN, hFileSFN, false /* SFN */);
		}

		for (pchToUpper=szFilenameLong; *pchToUpper; pchToUpper++)
#ifdef UNICODE
			*pchToUpper = towupper(*pchToUpper);
#else
			*pchToUpper = toupper(*pchToUpper);
#endif
		::MsiRecordSetString(hFileLFN, qICE30FileLFN::IFilename, szFilenameLong);
		if (ERROR_SUCCESS != qInsertLFN.Modify(MSIMODIFY_INSERT, hFileLFN))
		{
			// output the messages
			ICE30Collision(hInstall, hDatabase, qFindLFN, hFileLFN, true /* LFN */);
		}
	}

	DELETE_IF_NOT_NULL(pszFile);

	return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
// ICE31. Checks for missing text styles

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR sqlICE31a[] = TEXT("SELECT `Text`, `Dialog_`, `Control` FROM `Control` WHERE `Text` IS NOT NULL AND `Type`<>'ScrollableText'");
const TCHAR sqlICE31b[] = TEXT("SELECT `TextStyle`.`TextStyle` FROM `TextStyle` WHERE `TextStyle`.`TextStyle` = ?");
const TCHAR sqlICE31c[] = TEXT("SELECT `Value` FROM `Property` WHERE `Property`='DefaultUIFont'");
ICE_QUERY1(qIce31LimitUI, "SELECT `Value` FROM `Property` WHERE `Property` ='LIMITUI'", Value);

ICE_ERROR(Ice31MissingStyle, 31, ietError, "Control [2].[3] uses undefined TextStyle [1].","Control\tText\t[2]\t[3]");
ICE_ERROR(Ice31MissingClose, 31, ietError, "Control [2].[3] is missing closing brace in text style.","Control\tText\t[2]\t[3]");
ICE_ERROR(Ice31OverStyle, 31, ietError, "Control [2].[3] specifies a text style that is too long to be valid.","Control\tText\t[2]\t[3]");
ICE_ERROR(Ice31TextWarning, 31, ietWarning, "Text Style tag in [2].[3] has no effect. Do you really want it to appear as text?","Control\tText\t[2]\t[3]");
ICE_ERROR(Ice31NoStyleTable, 31, ietError, "Control [2].[3] uses text style [1], but the TextStyle table does not exist.","Control\tText\t[2]\t[3]");
ICE_ERROR(Ice31NoDefault, 31, ietError, "The 'DefaultUIFont' Property must be set to a valid TextStyle in the Property table.","Property");
ICE_ERROR(Ice31BadDefault, 31, ietError, "The 'DefaultUIFont' Property does not refer to a valid TextStyle defined in the TextStyle table.","Property\tDefaultUIFont");

ICE_FUNCTION_DECLARATION(31)
{
	bool bHaveStyleTable = false;
	
	// status return
	UINT iStat = ERROR_SUCCESS;

	// display generic info
	DisplayInfo(hInstall, 31);
	
	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 31, 1);
		return ERROR_SUCCESS;
	}

	// do we have the Control table? If not, obviously no bad text styles
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 31, TEXT("Control")))
		return ERROR_SUCCESS;

	// do we have the LIMITUI property set?  If yes, obviously no bad text styles since we'll always run in Basic UI
	CQuery qLimitUI;
	PMSIHANDLE hLimitUIRec = 0;
	if (ERROR_SUCCESS == qLimitUI.FetchOnce(hDatabase, 0, &hLimitUIRec, qIce31LimitUI::szSQL))
		return ERROR_SUCCESS; // no authored UI will be used

	// do we have the Style table?
	bHaveStyleTable = (1 == IsTablePersistent(FALSE, hInstall, hDatabase, 31, TEXT("TextStyle")));

	// declare handles for Control Query
	CQuery qControl;
	PMSIHANDLE hControlRec = 0;
	
	// open view for a query on all controls
	ReturnIfFailed(31, 2, qControl.OpenExecute(hDatabase, 0, sqlICE31a));
		
	// declare handles for TextStyle Query
	CQuery qTextStyle;
	PMSIHANDLE hTextRec = 0;

	if (bHaveStyleTable) {
		// open view for a query on all text styles
		ReturnIfFailed(31, 3, qTextStyle.Open(hDatabase, sqlICE31b));
	}

	// check for the DefaultUIFont property
	CQuery qProperty;
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 31, TEXT("Property")) ||
		(ERROR_SUCCESS != qProperty.FetchOnce(hDatabase, 0, &hControlRec, sqlICE31c)))
	{
		PMSIHANDLE hErrorRec = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hErrorRec, Ice31NoDefault);
	} 
	else
	{
		ReturnIfFailed(31, 4, qTextStyle.Execute(hControlRec));
		switch (iStat = qTextStyle.Fetch(&hTextRec))
		{
		case ERROR_SUCCESS:
			break;
		case ERROR_NO_MORE_ITEMS:
			ICEErrorOut(hInstall, hControlRec, Ice31BadDefault);
			break;
		default:
			APIErrorOut(hInstall, iStat, 31, 5);
			break;
		}
	}

	// declare some strings to hold final control name
	// reuse as much as possible
	DWORD cchRecordText;
	TCHAR *pszRecordText = new TCHAR[iMaxBuf];
	DWORD dwRecordText = iMaxBuf;
	
	// fetch records to loop over every control
	while (ERROR_SUCCESS == (iStat = qControl.Fetch(&hControlRec))) 
	{
		bool bValidStyle = false;
		
	
		// get the string to parse the style name, 
		while (1) {
			iStat =IceRecordGetString(hControlRec, 1, &pszRecordText, &dwRecordText, &cchRecordText);
			if (iStat == ERROR_SUCCESS) break;
			
			// default error
			APIErrorOut(hInstall, iStat, 31, 6);
			DELETE_IF_NOT_NULL(pszRecordText);
			return ERROR_SUCCESS;
		}

		TCHAR szStyleName[iMaxBuf];
		TCHAR *pchBrace = pszRecordText;
		DWORD cchStyleName = sizeof(szStyleName)/sizeof(TCHAR);

		// if the text is prefixed with a style
		for (int i=0; i < 2; i++)
		{
			bValidStyle = false;

			if ((_tcsncmp(pchBrace, _T("{\\"),2) == 0) ||
				(_tcsncmp(pchBrace, _T("{&"),2) == 0))
			{
				TCHAR *pszStyleStart = _tcsinc(_tcsinc(pchBrace));
				pchBrace = _tcschr(pchBrace, _T('}'));
			
				// if pchBrace is null, the text string is invalid
				if (pchBrace == NULL) 
				{
					ICEErrorOut(hInstall, hControlRec, Ice31MissingClose);
					// move on to the next string
					break;
				} 

				// copy the style name over to the new buffer
				size_t iNumChars = pchBrace-pszStyleStart;
				
				// if iNumChars > 72, the text style is invalid
				if (iNumChars > 72)
				{
					ICEErrorOut(hInstall, hControlRec, Ice31OverStyle);
					continue;
				} 
			
				// tack a null char on to the end
				_tcsncpy(szStyleName, pszStyleStart, iNumChars);
				szStyleName[iNumChars] = _T('\0');
				pchBrace = _tcsinc(pchBrace);

				// hooray, we have a text style
				bValidStyle = true;
			}
			
			if (bValidStyle) {
					
				// set the string back into the record
				ReturnIfFailed(31, 7, ::MsiRecordSetString(hControlRec, 1, szStyleName));

				// no style table, so automagic error
				if (!bHaveStyleTable)
				{
					// warning, possibly goofy text string
					ICEErrorOut(hInstall, hControlRec, Ice31NoStyleTable);
					continue;
				}
					
				// execute
				ReturnIfFailed(31, 8, qTextStyle.Execute(hControlRec));
		
				// fetch records to loop over every control
				UINT iFetchStat = qTextStyle.Fetch(&hTextRec);

				// close the view right away so we can reexecute the query later
				ReturnIfFailed(31, 9, qTextStyle.Close());
				switch (iFetchStat) {
				case ERROR_SUCCESS : continue;
				case ERROR_NO_MORE_ITEMS : 
				{
					// error, style not found
					ICEErrorOut(hInstall, hControlRec, Ice31MissingStyle);
					continue;
				}
				default:
					APIErrorOut(hInstall, iFetchStat, 31, 10);
					DELETE_IF_NOT_NULL(pszRecordText);
					break;
				}
			} 
		}

		// to be nice, throw a warning if they are doing something questionable
		if ((_tcsstr(pchBrace, _T("{\\")) != NULL) ||
			(_tcsstr(pchBrace, _T("{&")) != NULL)) 
		{
			// warning, possibly goofy text string
			ICEErrorOut(hInstall, hControlRec, Ice31TextWarning);
		}
	} // for each control

	// clean up
	DELETE_IF_NOT_NULL(pszRecordText);

	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		// the loop ended due to an error
		APIErrorOut(hInstall, iStat, 31, 11);
	}

	// return success
	return ERROR_SUCCESS;
}
#endif

////
// retrieve the error from the BadRegData record
DWORD Ice33GetError(MSIHANDLE hInstall, MSIHANDLE hBadDataRec, LPTSTR *szError, unsigned long &cchError) 
{
	UINT iStat;

	// template matched, parsed items matched, value matched, name implicitly matched
	// due to query, so we have an ERROR. Get the error string from the data record
	unsigned long cchDummy = cchError;
	if (ERROR_SUCCESS != (iStat = IceRecordGetString(hBadDataRec, 6, szError, NULL, &cchDummy)))
	{
		APIErrorOut(hInstall, iStat, 33, 11);
		cchError = cchDummy;
		return ERROR_FUNCTION_FAILED;
	}

	cchError = cchDummy;

	return ERROR_SUCCESS;
}

const static int iValTypeExact  = 0x02;
const static int iValTypeOptional = 0x01;	

bool Ice33ExpandTemplate(LPCTSTR szPrefix, LPTSTR *szTemplate, unsigned long &length, 
						 LPTSTR *szWorkArea, unsigned long &worklength)
{
	// run through the string, replacing %S, %G, %P, and %I with %s, and creating appropriate
	// templates
	static LPCTSTR szIntTemplate = TEXT("%*255[0-9]");
	static LPCTSTR szPathTemplate = TEXT("%*1024[^\001]");
	static LPCTSTR szGUIDTemplate = TEXT("{%*1x%*1x%*1x%*1x%*1x%*1x%*1x%*1x-%*1x%*1x%*1x%*1x-%*1x%*1x%*1x%*1x-%*1x%*1x%*1x%*1x-%*1x%*1x%*1x%*1x%*1x%*1x%*1x%*1x%*1x%*1x%*1x%*1x}");
	static LPCTSTR szStringTemplate = TEXT("%*255[^\\/\001]");

	const TCHAR * (rgszParams[4]);
	int iCurParam = 0;
	TCHAR *curchar = *szTemplate;
	bool bPercent = false;
	int iTemplateLength = _tcslen(*szTemplate);

	// calculate the minimum length (based on the prefix) 
	// and then add 4 for the success marker and null character.
	unsigned lLengthNeeded = iTemplateLength + _tcslen(szPrefix);
	lLengthNeeded += 4; 

	while (*curchar != TEXT('\0'))
	{
		if (*curchar == TEXT('%')) {
			bPercent = !bPercent; 
		} else if (bPercent) {
			switch (*curchar)
			{
			case TEXT('S') : 
				rgszParams[iCurParam++] = szStringTemplate;
				lLengthNeeded += _tcslen(szStringTemplate);
				*curchar = TEXT('s');
				break;
			case TEXT('P') : 
				rgszParams[iCurParam++] = szPathTemplate;
				lLengthNeeded += _tcslen(szPathTemplate);
				*curchar = TEXT('s');
				break;
			case TEXT('G') :
				rgszParams[iCurParam++] = szGUIDTemplate;
				lLengthNeeded += _tcslen(szGUIDTemplate);
				*curchar = TEXT('s');
				break;
			case TEXT('I') :
				rgszParams[iCurParam++] = szIntTemplate;
				lLengthNeeded += _tcslen(szIntTemplate);
				*curchar = TEXT('s');
				break;
			default :
				; // nothing
			}
			bPercent = !bPercent; 
		}
		curchar++;
	}

	// copy the current template into the work area
	if (worklength < iTemplateLength+1) {
		delete[] *szWorkArea;
		worklength = iTemplateLength+1;
		*szWorkArea = new TCHAR[worklength];
	}
	_tcsncpy(*szWorkArea, *szTemplate, iTemplateLength+1);

	// if we need more space in our output area, make some
	if (lLengthNeeded > length-1) {
		delete[] *szTemplate;
		length = lLengthNeeded+1;
		*szTemplate = new TCHAR[length];
	}

	// copy the prefix to the new template
	_tcscpy(*szTemplate, szPrefix);
	TCHAR *szFormatDest = *szTemplate + _tcslen(szPrefix);

	// modify the template
#ifdef UNICODE
	swprintf(szFormatDest, *szWorkArea, rgszParams[0], rgszParams[1], rgszParams[2], rgszParams[3]);
#else
	sprintf(szFormatDest, *szWorkArea, rgszParams[0], rgszParams[1], rgszParams[2], rgszParams[3]);
#endif
	// we need to cat our "success" marker on the end. If it is converted correctly,
	// everything else matched.
	_tcscat(*szTemplate, TEXT("\001%c"));

	return true;
}

///////////////////////////////////////////////////////////////////////
// Checks the reg key of the given registry record against the sscanf 
// template provided in szTemplate. Will grow szRegKey if needed. 
// return true if the key matches the template.
bool Ice33CheckRegKey(MSIHANDLE hInstall, MSIHANDLE hRegistryRec, 
					  LPCTSTR szTemplate, LPTSTR *szRegKey, unsigned long &cchRegKey)
{
	UINT iStat;

	// pull the reg key out, need space for the success marker at the end.
	// For this reason do not use IceRecordGetString because it deallocates
	// and reallocates buffers.
	unsigned long cchDummy = cchRegKey-4;
	if (ERROR_SUCCESS != (iStat = ::MsiRecordGetString(hRegistryRec, 3, *szRegKey, &cchDummy)))
	{
		if (ERROR_MORE_DATA == iStat)
		{
			// need more buffer
			delete[] *szRegKey;
			cchRegKey = (cchDummy += 4);
			*szRegKey = new TCHAR[cchDummy];
			iStat = ::MsiRecordGetString(hRegistryRec, 3, *szRegKey, &cchDummy);
		}
		if (ERROR_SUCCESS != iStat)
		{
			// return false so that no more checks will be done on this key.
			APIErrorOut(hInstall, iStat, 33, 8);
			return false;
		}
	}

	// tack the success marker on the end. If this is parsed correctly, everything
	// else was too.
	_tcscat(*szRegKey, TEXT("\001Y"));

	// compare the Reg Key against the template. If successful, this
	// will place the character 'Y' in cSucceed and return 1

	int cItemsRead;
	TCHAR cSucceed;
#ifdef _UNICODE
	cItemsRead = swscanf(*szRegKey, szTemplate, &cSucceed);
#else
	cItemsRead = sscanf(*szRegKey, szTemplate, &cSucceed);
#endif
	if ((cItemsRead == 0) || (cSucceed != TEXT('Y')))
		return false;

	// match
	return true;
}


const static TCHAR sqlIce33Extension[] = TEXT("SELECT `ProgId_`, `Extension` FROM `Extension` WHERE (`ProgId_` IS NOT NULL)");
const static TCHAR sqlIce33ProgId[] = TEXT("SELECT `ProgId` FROM `ProgId` WHERE ((`ProgId` = ?) AND (`ProgId_Parent` IS NULL) AND (`Class_` IS NULL))");
const static TCHAR sqlIce33Verb[] = TEXT("SELECT `Verb` FROM `Verb` WHERE ((`Extension_` <> ?) AND (`Extension_` = ?))");
const static TCHAR sqlIce33SetRegistry[] = TEXT("UPDATE `Registry` SET `_Ice33Match` = 1 WHERE ((`Root` = 0) AND (`Key` = ?))");

DWORD CheckForOrphanedExtensions(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
	CQuery 	qExt;
	CQuery	qTmp;

	PMSIHANDLE	hExt = NULL;
	PMSIHANDLE	hTmp = NULL;

	UINT iStat;

	if	(!IsTablePersistent(FALSE, hInstall, hDatabase, 31, TEXT("Registry")) ||
		!IsTablePersistent(FALSE, hInstall, hDatabase, 31, TEXT("ProgId")) ||
		!IsTablePersistent(FALSE, hInstall, hDatabase, 31, TEXT("Verb")) ||
		!IsTablePersistent(FALSE, hInstall, hDatabase, 31, TEXT("Extension")))
		{
			goto Exit;		// Nothing to check
		}

		iStat = qExt.OpenExecute(hDatabase, NULL, sqlIce33Extension);
		if(iStat)
		{
			APIErrorOut(hInstall, iStat, 33, __LINE__);
			goto Exit;	
		}
		while (ERROR_SUCCESS == (iStat = qExt.Fetch(&hExt)))
		{
			iStat = qTmp.FetchOnce(hDatabase, hExt, &hTmp, sqlIce33ProgId);
			if(iStat)
			{
				if(iStat == ERROR_NO_MORE_ITEMS) 
				{
					continue;		// Next extension
				}
				APIErrorOut(hInstall, iStat, 33, __LINE__);
				goto Exit;
			}

			qTmp.Close();
			iStat = qTmp.FetchOnce(hDatabase, hExt, &hTmp, sqlIce33Verb);

			if(iStat == ERROR_NO_MORE_ITEMS) 
			{
				qTmp.Close();
				iStat = qTmp.OpenExecute(hDatabase, hExt, sqlIce33SetRegistry);
				qTmp.Close();
			}
			else if(iStat) 
			{
				APIErrorOut(hInstall, iStat, 33, __LINE__);
				goto Exit;
			}
		}
Exit:
	
	return ERROR_SUCCESS;
		
}


const static TCHAR sqlIce33AddColumn[] = TEXT("ALTER TABLE `Registry` ADD `_Ice33Match` INT TEMPORARY HOLD");
const static TCHAR sqlIce33InitColumn[] = TEXT("UPDATE `Registry` SET `_Ice33Match` = 0");
const static TCHAR sqlIce33Free[] = TEXT("ALTER TABLE `Registry` FREE");
const static TCHAR sqlIce33BadReg[] = TEXT("SELECT `ValueType`, `Name`, `Value`, `ValueType`, `Key`, `Error` FROM `_BadRegData`");
const static TCHAR sqlIce33SpecialFlags[] = TEXT("SELECT `Registry`, `Root`, `Key`, `Name`, `Value`, `Component_` FROM `Registry` WHERE (`_Ice33Match`<>1) AND (`Root`=?) AND ((`Name`='+') OR (`Name`='-') OR (`Name`='*')) AND (`Value` IS NULL)");

const static LPCTSTR sqlIce33Registry[] = {
	TEXT("SELECT `Registry`, `Root`, `Key`, `Name`, `Value`, `Component_` FROM `Registry` WHERE (`_Ice33Match`<>1) AND (`Root`=?) AND (`Name`=?)"),
	TEXT("SELECT `Registry`, `Root`, `Key`, `Name`, `Value`, `Component_` FROM `Registry` WHERE (`_Ice33Match`<>1) AND (`Root`=?) AND (`Name`=?) AND ((`Value` = ?) OR (`Value` IS NULL))"),
	TEXT("SELECT `Registry`, `Root`, `Key`, `Name`, `Value`, `Component_` FROM `Registry` WHERE (`_Ice33Match`<>1) AND (`Root`=?) AND (`Name`=?) AND (`Value` IS NOT NULL)"),
	TEXT("SELECT `Registry`, `Root`, `Key`, `Name`, `Value`, `Component_` FROM `Registry` WHERE (`_Ice33Match`<>1) AND (`Root`=?) AND (`Name`=?) AND (`Value` = ?)"),
	TEXT("SELECT `Registry`, `Root`, `Key`, `Name`, `Value`, `Component_` FROM `Registry` WHERE (`_Ice33Match`<>1) AND (`Root`=?) AND (`Name`=?) AND (`Value` IS NULL)")
};
/* Bug 146217
For each entry in the Extension table:
	If Extension.ProgId_ <> NULL then
		Query ProgId table for primary key referenced in Extension.ProgId_ (there can only be one)
		if ProgId.ProgId_Parent = NULL  and  ProgId.Class_ = NULL then
			Query Verb table for a record where Verb.Extension_ = the current Extension in question
			If Record is not found in Verb table then
				DO NOT flag entries in the Registry table as errors if they match the query:
				SELECT * FROM `Registry` WHERE `Root`=0 AND `Key`='<Extension.ProgId_>'
			end if
		end if
	end if
next

For the registry keys that are selected to be correct, based on the logic above, set the _Ice33Match = 1.
*/

// the error wrapper for ICE33. The user readable strings are all completely user defined.
ICE_ERROR(Ice33Error, 33, ietWarning, "%s", "Registry\tRegistry\t[1]");
ICE_ERROR(Ice33BadCube, 33, ietWarning, "CUB authoring error. Unable to complete all evaluations.", "Registry\tRegistry\t[1]");

///////////////////////////////////////////////////////////////////////
// ICE33 is the mega-registry check ICE. It goes through the registry 
// table and checks for any keys that are already created (and thus 
// will be mangled by) the Class, Extension, ProgID, etc, etc tables.
ICE_FUNCTION_DECLARATION(33)
{
	static LPCTSTR szNoPrefix = TEXT("");
	static LPCTSTR szClassPrefix = TEXT("Software\\Classes\\");

	UINT iStat;
	bool bSpecialFlags;
	
    // display generic info
	DisplayInfo(hInstall, 33);
	
	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 33, 1);
		return ERROR_SUCCESS;
	}

	// declare queries
	CQuery rgqRegQueries[sizeof(sqlIce33Registry)/sizeof(LPCTSTR)];
	CQuery qBadRegData;
	CQuery qSpecial;

	// check that we have a registry table. If not, all is well
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 33, TEXT("Registry")))
		return ERROR_SUCCESS;

	// we need to have our private registry table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 33, TEXT("_BadRegData")))
	{
		PMSIHANDLE hRecord = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecord, Ice33BadCube);
		return ERROR_SUCCESS;
	}

	// everything should be at least 5 long to start, because we will need the space to
	// tack on various flags and parsing items. So we subtract the length we need from 
	// the length we provide MsiRecordGetString(). Since its an unsigned long, me 
	// must ensure that it will never be < 0, because that means 4 billion, and we'll
	// write all over memory because we think we have the space.
	TCHAR *szValue = new TCHAR[5];
	TCHAR *szRegKey = new TCHAR[5];
	TCHAR *szTemplate = new TCHAR[5];
	TCHAR *szValTemplate = new TCHAR[5];
	TCHAR *szError = new TCHAR[5];
	TCHAR *szWorkArea = new TCHAR[5];
	unsigned long cchValue = 5;
	unsigned long cchRegKey = 5;
	unsigned long cchTemplate = 5;
	unsigned long cchValTemplate = 5;
	unsigned long cchError = 5;
	unsigned long cchWorkArea = 5;

	// create the column
	CQuery qCreate;
	ReturnIfFailed(33, 1, qCreate.OpenExecute(hDatabase, NULL, sqlIce33AddColumn));

	// manage the Registry table hold counts
	CManageTable MngRegistryTable(hDatabase, TEXT("Registry"), /*fAlreadyLocked = */true);

	CQuery qInit;
	ReturnIfFailed(33, 2, qInit.OpenExecute(hDatabase, NULL, sqlIce33InitColumn));

	CheckForOrphanedExtensions(hInstall, hDatabase);

	// open all of the queries
	PMSIHANDLE hBadDataRec = ::MsiCreateRecord(1);
	ReturnIfFailed(33, 2, qBadRegData.Open(hDatabase, sqlIce33BadReg));
	ReturnIfFailed(33, 3, qSpecial.Open(hDatabase, sqlIce33SpecialFlags));
	for (int i=4; i < sizeof(rgqRegQueries)/sizeof(CQuery)+4; i++)
		ReturnIfFailed(33, i, rgqRegQueries[i-4].Open(hDatabase, sqlIce33Registry[i-4]));

	// run the queries 3 times, for roots 0, 1, and 2.
	for (int iRoot=0; iRoot < 3; iRoot++) 
	{

		qBadRegData.Execute(NULL);
		while (ERROR_SUCCESS == (iStat = qBadRegData.Fetch(&hBadDataRec)))
		{
			bool bCheckValTemplate = false;
			bool bHaveError = false; 
			CQuery *regQuery;
			UINT iQuery;

			// get the value type we are looking for
			long iValType = ::MsiRecordGetInteger(hBadDataRec, 4);
			switch (iValType) 
			{
			case MSI_NULL_INTEGER:
				// defaults to non-exact non-optional
				iValType = 0;	// fall through
			case 0:
				// non-optional parse, but if null, query only null
				if (::MsiRecordIsNull(hBadDataRec, 3))
				{
					iQuery = 4;
					iValType = 2; 
				} 
				else
					iQuery = 2;
				break;
			case 1: 
				// optional, not exact
				iQuery = 0;
				break;
			case 2:
				// exact, not optional
				iQuery = ::MsiRecordIsNull(hBadDataRec, 3) ? 3 : 3;
				break;
			case 3:
				// optional, but exact if there
				iQuery = 1;
				break;
			default:
				ICEErrorOut(hInstall, hBadDataRec, Ice33BadCube);
				continue;
			}

			// if the name column is null, it means a default value. We also check for
			// cases where Value is null and Name is one of the special cases.
			// to do this, we just add 5 to the query index. The queries after 5
			// OR those special cases in to the query results.
			if (::MsiRecordIsNull(hBadDataRec, 2))
				bSpecialFlags = true;
			else
				bSpecialFlags = false;
			
			// now set the query
			regQuery = &rgqRegQueries[iQuery];

			// set the root value to limit the queries to valid items
			::MsiRecordSetInteger(hBadDataRec, 1, iRoot);

			// pull the reg key template
			unsigned long cchDummy = cchTemplate-4;
			if (ERROR_SUCCESS != (iStat = ::MsiRecordGetString(hBadDataRec, 5, szTemplate, &cchDummy)))
			{
				if (ERROR_MORE_DATA == iStat)
				{
					// need more buffer
					delete[] szTemplate;
					cchTemplate = (cchDummy += 4);
					szTemplate = new TCHAR[cchDummy];
					iStat = ::MsiRecordGetString(hBadDataRec, 5, szTemplate, &cchDummy);
				}
				if (ERROR_SUCCESS != iStat)
				{
					APIErrorOut(hInstall, iStat, 33, 7);
					continue;
				}
			}

			// expand the template
			TCHAR const *szPrefix = NULL;
			if (iRoot == 0)
				szPrefix = szNoPrefix;
			else
				szPrefix = szClassPrefix;
			Ice33ExpandTemplate(szPrefix, &szTemplate, cchTemplate, &szWorkArea, cchWorkArea);			

			// assume we don't have to check the value template.
			bCheckValTemplate = false;
			if (!(iValType & iValTypeExact))
			{
				// we might have to check. Pull the value template.
				unsigned long cchDummy = cchValTemplate-4;
				if (ERROR_SUCCESS != (iStat = ::MsiRecordGetString(hBadDataRec, 3, szValTemplate, &cchDummy)))
				{
					if (ERROR_MORE_DATA == iStat)
					{
						// need more buffer
						delete[] szValTemplate;
						cchValTemplate = (cchDummy += 4);
						szValTemplate = new TCHAR[cchDummy];
						iStat = ::MsiRecordGetString(hBadDataRec, 3, szValTemplate, &cchDummy);
					}
					if (ERROR_SUCCESS != iStat)
					{
						APIErrorOut(hInstall, iStat, 33, 10);
						continue;
					}
				}

				// if our template is %P, we want a path, which we define as anything, so
				// no need to check at all.
				if (_tcsnicmp(szValTemplate, _T("%P"), 3) != 0) 
				{
					// expand the template, we have to check.
					Ice33ExpandTemplate(szNoPrefix, &szValTemplate, cchValTemplate, &szWorkArea, cchWorkArea);
					bCheckValTemplate = true;
				}
			}

			// now look for potentially naughty reg entries
			ReturnIfFailed(33, 6, regQuery->Execute(hBadDataRec));

			PMSIHANDLE hRegistryRec;
			while (ERROR_SUCCESS == (iStat = regQuery->Fetch(&hRegistryRec)))
			{
				// check the registry key against the template
				if (!Ice33CheckRegKey(hInstall, hRegistryRec, szTemplate, &szRegKey, cchRegKey))
					continue;

				// if we have to check the value template
				if (bCheckValTemplate) 
				{
					// if the value is optional and we have a null, we can move on alse
					if (!((iValType & iValTypeOptional) && ::MsiRecordIsNull(hRegistryRec, 5)))
					{
						// check value. Don't worry about NULL, that will be eliminated through the query.
						// so pull the value string out of the retrieved registry record
						cchDummy = cchValue-3;
						if (ERROR_SUCCESS != (iStat = ::MsiRecordGetString(hRegistryRec, 5, szValue, &cchDummy)))
						{
							if (ERROR_MORE_DATA == iStat)
							{
								// need more buffer
								delete[] szValue;
								cchValue = (cchDummy +=3);
								szValue = new TCHAR[cchDummy];
								iStat = ::MsiRecordGetString(hRegistryRec, 5, szValue, &cchDummy);
							}
							if (ERROR_SUCCESS != iStat)
							{
								APIErrorOut(hInstall, iStat, 33, 9);
								continue;
							}
						}

						// tack the success marker on the end. If this is parsed correctly, everything
						// else was too.
						_tcscat(szValue, TEXT("\001Y"));
						
						// do a similar sscanf job
						int cItemsRead;
						TCHAR cSucceed;
#ifdef _UNICODE
						cItemsRead = swscanf(szValue, szValTemplate, &cSucceed);
#else
						cItemsRead = sscanf(szValue, szValTemplate, &cSucceed);
#endif
				
						// cItemsRead MUST be 1
						if ((cItemsRead != 1)  && (cSucceed == TEXT('Y')))
							continue;
					}
				}

				// get the error message and post it
				if (!bHaveError) 
				{
					ReturnIfFailed(33, 12, Ice33GetError(hInstall, hBadDataRec, &szError, cchError));
					bHaveError = true;
				}

				// update the record so that the matched flag is "1", keeping this
				// record from being checked by any other queries
				MsiRecordSetInteger(hRegistryRec, 7, 1);
				regQuery->Modify(MSIMODIFY_UPDATE, hRegistryRec);

				// and finally post it as an error
				ICEErrorOut(hInstall, hRegistryRec, Ice33Error, szError);
			}

			// no more items in registry matched our query. Make sure this is why we quit
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 33, 12);
				return ERROR_SUCCESS;
			}

			if (bSpecialFlags)
			{
				// if we accept special flags in this template, check those
				ReturnIfFailed(33, 13, qSpecial.Execute(hBadDataRec));
				while (ERROR_SUCCESS == (iStat = qSpecial.Fetch(&hRegistryRec)))
				{
					// check the registry key against the template
					if (!Ice33CheckRegKey(hInstall, hRegistryRec, szTemplate, &szRegKey, cchRegKey))
						continue;

					// update the record so that the matched flag is "1", keeping this
					// record from being checked by any other queries
					MsiRecordSetInteger(hRegistryRec, 7, 1);
					qSpecial.Modify(MSIMODIFY_UPDATE, hRegistryRec);

					// get the error message and post it
					if (!bHaveError) 
					{
						ReturnIfFailed(27, 12, Ice33GetError(hInstall, hBadDataRec, &szError, cchError));
						bHaveError = true;
					}

					ICEErrorOut(hInstall, hRegistryRec, Ice33Error, szError);
				}
				// no more items in registry matched our query. Make sure this is why we quit
				if (ERROR_NO_MORE_ITEMS != iStat)
				{
					APIErrorOut(hInstall, iStat, 33, 13);
					return ERROR_SUCCESS;
				}
			}
		}
		// no more items in registry template table
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 33, 14);
			return ERROR_SUCCESS;
		}
	}

	delete[] szError;
	delete[] szTemplate;
	delete[] szValTemplate;
	delete[] szValue;
	delete[] szRegKey;
	delete[] szWorkArea;

	for (i=0; i < sizeof(rgqRegQueries)/sizeof(CQuery); i++) 
		rgqRegQueries[i].Close();
	qBadRegData.Close();

	CQuery qFree;
	ReturnIfFailed(33, 1, qFree.OpenExecute(hDatabase, NULL, sqlIce33Free));
	MngRegistryTable.RemoveLockCount();

	return ERROR_SUCCESS;
}








///////////////////////////////////////////////////////////////////////
// ICE34
// validates that every radiobutton group has a default set in the 
// property table

const TCHAR sqlICE34a[] = TEXT("SELECT `Property`, `Dialog_`, `Control`, `Attributes` FROM `Control` WHERE `Type`='RadioButtonGroup'");
const TCHAR sqlICE34b[] = TEXT("SELECT `Value`,`Property`.`Property`, `Value` FROM `Property` WHERE `Property` = ?");
const TCHAR sqlICE34c[] = TEXT("SELECT `Order` FROM `RadioButton` WHERE `Value` = ? AND `Property` = ? ");

ICE_ERROR(Ice34MissingRadioButton, 34, ietError, "You must have a RadioButton table because [2].[3] is a RadioButtonGroup control.","Control\tType\t[2]\t[3]");
ICE_ERROR(Ice34MissingProperty, 34, ietError, "Property [1] (of RadioButtonGroup control [2].[3]) is not defined in the Property Table.","Control\tProperty\t[2]\t[3]");
ICE_ERROR(Ice34NoProperty, 34, ietError, "Control [2].[3] must have a property because it is of type RadioButtonGroup.","Control\tControl\t[2]\t[3]");
ICE_ERROR(Ice34NullProperty, 34, ietError, "Property [1] cannot be null, because it belongs to a RadioButton Group.","Control\tProperty\t[2]\t[3]");
ICE_ERROR(Ice34MissingPropertyTable, 34, ietError, "The Property table is missing. RadioButtonGroup control [2].[3] must have a default value defined for property [1].","Control\tProperty\t[2]\t[3]");
ICE_ERROR(Ice34InvalidValue, 34, ietError, "[1] is not a valid default value for the RadioButtonGroup using property [2]. The value must be listed as an option in the RadioButtonGroup table.","Property\tValue\t[2]");
ICE_ERROR(Ice34InvalidValueIndirect, 34, ietError, "[1] is not a valid default value for the property [2]. The property is an indirect RadioButtonGroup property of control [3].","Property\tValue\t[2]");
ICE_ERROR(Ice34NullPropertyIndirect1, 34, ietError, "Property [1] cannot be null. It must point to another property because RadioButtonGroup control [2].[3] is indirect.","Property\tProperty\t[1]");
ICE_ERROR(Ice34NullPropertyIndirect2, 34, ietError, "Property [1] cannot be null because it is an indirect property of the RadioButtonGroup control [2].[3].","Property\tProperty\t[1]");
ICE_ERROR(Ice34MissingPropertyIndirect, 34, ietError, "Property [4] must be defined because it is an indirect property of a RadioButtonGroup control [2].[3].","Property\tValue\t[1]");

ICE_FUNCTION_DECLARATION(34)
{

	CQuery qControl;
	CQuery qProperty;
	CQuery qRadioButton;

	PMSIHANDLE hControlRec;
	PMSIHANDLE hPropertyRec;
	PMSIHANDLE hRadioButtonRec;

	UINT iStat;
	bool bHavePropertyTable, bHaveRadioTable;
	bool bIndirect;
	TCHAR* pszIndirectName = NULL;
	DWORD dwIndirectName = 512;
	
	// display generic info
	DisplayInfo(hInstall, 34);
	
	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	if (0 == hDatabase)
	{
		APIErrorOut(hInstall, 0, 34, 1);
		return ERROR_SUCCESS;
	}

	// do we have the Control table?
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 34, TEXT("Control")))
		return ERROR_SUCCESS;

	// do we have the Property table?
	bHavePropertyTable = (1 == IsTablePersistent(FALSE, hInstall, hDatabase, 34, TEXT("Property")));

	// do we have the RadioButton table?
	bHaveRadioTable = (1 == IsTablePersistent(FALSE, hInstall, hDatabase, 34, TEXT("RadioButton")));

	// open view for a query on all controls
	ReturnIfFailed(34, 2, qControl.OpenExecute(hDatabase, 0, sqlICE34a));

	// open view for a query on the property table
	if (bHavePropertyTable) {
		ReturnIfFailed(34, 4, qProperty.Open(hDatabase, sqlICE34b));
	}

	// open view for a query on the property table
	if (bHaveRadioTable) {
		ReturnIfFailed(34, 5, qRadioButton.Open(hDatabase, sqlICE34c));
	}

	// as long as there are radiobutton groups, check them
	while (ERROR_SUCCESS == (iStat = qControl.Fetch(&hControlRec)))
	{
		// if we don't have a property table, give an error
		if (!bHavePropertyTable)
			ICEErrorOut(hInstall, hControlRec, Ice34MissingPropertyTable);

		// if we don't have a radio button table, we can abort right now
		if (!bHaveRadioTable)
			ICEErrorOut(hInstall, hControlRec, Ice34MissingRadioButton);

		// if either table is missing, move on
		if (!bHaveRadioTable || !bHavePropertyTable) 
			continue;

		// now check for a null property
		if (::MsiRecordIsNull(hControlRec, 1))
		{
			ICEErrorOut(hInstall, hControlRec, Ice34NoProperty);
			continue;
		}
		
		// now look for the property
		ReturnIfFailed(34, 6, qProperty.Execute(hControlRec)); 

		iStat = qProperty.Fetch(&hPropertyRec);

		// close the view so we can re-execute later
		ReturnIfFailed(34, 7, qProperty.Close());

		// now check the results of the property query
		switch (iStat)
		{
		case ERROR_NO_MORE_ITEMS:
		{
			// error, property not found
			ICEErrorOut(hInstall, hControlRec, Ice34MissingProperty);
			continue;
		}
		case ERROR_SUCCESS:
			// we're OK, property found
			break;
		default:
			APIErrorOut(hInstall, iStat, 34, 8);
			DELETE_IF_NOT_NULL(pszIndirectName);
			return ERROR_SUCCESS;
		}

		// check to see if the control is indirect. This changes our error message if the
		// property is somehow null
		DWORD lAttributes = ::MsiRecordGetInteger(hControlRec, 4);
		bIndirect = (0 != (lAttributes & 0x08));
		
		// now check for a null property
		if (::MsiRecordIsNull(hPropertyRec, 1))
		{
			if (bIndirect)
				ICEErrorOut(hInstall, hControlRec, Ice34NullPropertyIndirect1);
			else
				ICEErrorOut(hInstall, hControlRec, Ice34NullProperty);
			continue;
		}

		// We have a non-null property. If the control is indirect, we need to "dereference"
		// the property before we can look in the radiobutton table.

		// if indirect control
		if (bIndirect) {
			// save the existing property name for error messages
			IceRecordGetString(hPropertyRec, 1, &pszIndirectName, &dwIndirectName, NULL);

			// look for the property, using the value of the current property as the name
			ReturnIfFailed(34, 9, qProperty.Execute(hPropertyRec));
			iStat = qProperty.Fetch(&hPropertyRec);
			ReturnIfFailed(34, 10, qProperty.Close());

			// now check the results of the property query
			switch (iStat)
			{
			case ERROR_NO_MORE_ITEMS:
			{
				::MsiRecordSetString(hControlRec, 4, pszIndirectName);
				// error, property not found
				ICEErrorOut(hInstall, hControlRec, Ice34MissingPropertyIndirect);
				continue;
			}
			case ERROR_SUCCESS:
				// we're OK, property found
				break;
			default:
				APIErrorOut(hInstall, iStat, 34, 11);
				DELETE_IF_NOT_NULL(pszIndirectName);
				return ERROR_SUCCESS;
			}

			// now check for a null property
			if (::MsiRecordIsNull(hPropertyRec, 2))
			{
				ICEErrorOut(hInstall, hControlRec, Ice34NullPropertyIndirect2);
				continue;
			}
		}
	
		// now we can look for the property in the radiobutton table
		ReturnIfFailed(34, 12, qRadioButton.Execute(hPropertyRec));
		iStat = qRadioButton.Fetch(&hRadioButtonRec);
		ReturnIfFailed(34, 13, qRadioButton.Close());

		// now check the results of the property query
		switch (iStat)
		{
		case ERROR_NO_MORE_ITEMS:
		{
			// error, property not found
			TCHAR szError[iHugeBuf] = {0};
			TCHAR szControl[iHugeBuf] = {0};
			unsigned long cchControl = sizeof(szControl)/sizeof(TCHAR);
			if (bIndirect) 
			{
				::MsiRecordSetString(hControlRec, 0, _T("[2].[3] (via property [1])"));
				::MsiFormatRecord(hInstall, hControlRec, szControl, &cchControl);
				::MsiRecordSetString(hPropertyRec, 3, szControl);
				ICEErrorOut(hInstall, hPropertyRec, Ice34InvalidValueIndirect);
			}
			else			
				ICEErrorOut(hInstall, hPropertyRec, Ice34InvalidValue);
			continue;
		}
		case ERROR_SUCCESS:
			// we're OK, property value is OK
			continue;
		default:
			APIErrorOut(hInstall, iStat, 34, 14);
			DELETE_IF_NOT_NULL(pszIndirectName);
			return ERROR_SUCCESS;
		}
	}

	DELETE_IF_NOT_NULL(pszIndirectName);

	return ERROR_SUCCESS;
}


CDeleteOnExit::CDeleteOnExit(LPTSTR *ptr)
{
	m_pPtr=ptr;
}

CDeleteOnExit::~CDeleteOnExit()
{
	if(m_pPtr && *m_pPtr) 
				delete[] *m_pPtr;
}

///////////////////////////////////////////////////////////////////////
// ICE35 -- validates that compressed files are not set RFS (run from
//   source)
//

const TCHAR sqlICE35CreateCol[] = TEXT("ALTER TABLE `File` ADD `_ICE35Mark` INTEGER TEMPORARY");
const TCHAR sqlICE35Media[] = TEXT("SELECT `Media`.`LastSequence`, `Media`.`Cabinet` FROM `Media` ORDER BY `LastSequence`");
const TCHAR sqlICE35MarkFile[] = TEXT("SELECT `File`.`Attributes`, `File`.`_ICE35Mark` FROM `File` WHERE (`File`.`Sequence` <= ?) AND (`File`.`Sequence` > ?)");
const int iColICE35MarkFile_Attributes = 1;
const int iColICE35MarkFile_Mark = 2;

const TCHAR sqlICE35Cabinet[] = TEXT("SELECT DISTINCT `Component`.`Attributes`, `Component`.`Component`, `Component`.`Component` FROM `Component`,`File` WHERE (`File`.`Sequence` <= ?) AND (`File`.`Sequence` > ?) AND (`Component`.`Component` = `File`.`Component_`) AND (`File`.`_ICE35Mark`=2)");

const TCHAR sqlICE35GetFiles[] = TEXT("SELECT `File`, `Attributes` FROM `File` WHERE (`_ICE35Mark`<>1) AND (`_ICE35Mark`<>2)");
const int iColICE35GetFiles_File = 1;
const int iColICE35GetFiles_Attributes = 2;
const int iSchema150 = 150;

ICE_ERROR(ICE35RFSOnly,  35, ietError, "Component [2] cannot be Run From Source only, because a member file is compressed in [3].", "Component\tAttributes\t[2]");
ICE_ERROR(ICE35InvalidBits, 35, ietError, "Component [2] has invalid Attribute bits (RFS property).","Component\tAttributes\t[2]");
ICE_ERROR(ICE35NoCAB, 35, ietError, "File [1] is marked compressed, but does not have a CAB specified in the Media table entry for its sequence number.", "File\tFile\t[1]");
ICE_ERROR(ICE35SummaryUnsupported, 35, ietWarning, "Your validation engine does not support SummaryInfo validation. ICE35 will not be able to check files that are not explicitly marked compressed.", "");

// an ICE39 (summaryinfo validation) function that we call to get the property	
UINT GetSummaryInfoPropertyString(MSIHANDLE hSummaryInfo, UINT uiProperty, UINT &puiDataType, LPTSTR *szValueBuf, DWORD &cchValueBuf);

ICE_FUNCTION_DECLARATION(35)
{
	//status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 35);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if there is no component table, no components are configured wrong, so OK
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 35, TEXT("Component")))
		return ERROR_SUCCESS;

	// if there is no file table, we are also OK, because it could be that
	// no components have files
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 35, TEXT("File")))
		return ERROR_SUCCESS;

	// media table could also be missing if no componentns have files.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 35, TEXT("Media")))
		return ERROR_SUCCESS;

	UINT iType;
	int iValue;
	PMSIHANDLE hSummaryInfo;
	unsigned long cchString = MAX_PATH;
	TCHAR *szString = new TCHAR[cchString];
	bool bSourceTypeCompressed = false;
	bool bAtLeastSchema150 = false;
	CDeleteOnExit t1(&szString);

	ReturnIfFailed(39, 1, ::MsiGetSummaryInformation(hDatabase, NULL, 0, &hSummaryInfo));

	// check to see if the evaluation system supports summaryinfo evaluation.
	ReturnIfFailed(39, 4, GetSummaryInfoPropertyString(hSummaryInfo, PID_SUBJECT, iType, &szString, cchString));
	if (VT_LPSTR == iType) 
	{
		if (_tcsncmp(szString, _T("Internal Consistency Evaluators"), 31) == 0)
		{
			PMSIHANDLE hErrorRec = ::MsiCreateRecord(1);
			ICEErrorOut(hInstall, hErrorRec, ICE35SummaryUnsupported);
			return ERROR_SUCCESS;
		}
		else
		{
			// it does. Get the source image type.
			FILETIME ft;
			ReturnIfFailed(35, 16, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_WORDCOUNT, &iType, &iValue, &ft, szString, &cchString));
			if (iValue & msidbSumInfoSourceTypeCompressed)
				bSourceTypeCompressed = true;
			ReturnIfFailed(35, 17, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_PAGECOUNT, &iType, &iValue, &ft, szString, &cchString));
			if (iValue >= iSchema150)
				bAtLeastSchema150 = true;
		}
	}

	// create temporary file column
	CQuery qColumn;
	ReturnIfFailed(35, 1, qColumn.OpenExecute(hDatabase, 0, sqlICE35CreateCol));

	// look for everything in the Media table
	CQuery qMedia;
	PMSIHANDLE hMediaRec;
	ReturnIfFailed(35, 2, qMedia.OpenExecute(hDatabase, 0, sqlICE35Media));

	// open the view for component query
	CQuery qComponent;
	PMSIHANDLE hComponentRec;
	ReturnIfFailed(35, 3, qComponent.Open(hDatabase, sqlICE35Cabinet));

	// open the view for file check
	CQuery qFileMark;
	ReturnIfFailed(35, 4, qFileMark.Open(hDatabase, sqlICE35MarkFile));

	TCHAR* pszCAB = NULL;
	DWORD dwCAB = 512;
	PMSIHANDLE hFileRec;
	int iPrevLastSeq = 0;
	while (ERROR_SUCCESS == (iStat = qMedia.Fetch(&hMediaRec))) 
	{
		// get the sequence number
		int iSequence = ::MsiRecordGetInteger(hMediaRec, 1);

		// if this media entry uses a cabinet
		if (!::MsiRecordIsNull(hMediaRec, 2))
		{
			// pull the CAB name
			IceRecordGetString(hMediaRec, 2, &pszCAB, &dwCAB, NULL);


			// fetch all files in this sequence range
			::MsiRecordSetInteger(hMediaRec, 2, iPrevLastSeq);
			ReturnIfFailed(35, 5, qFileMark.Execute(hMediaRec));
			while (ERROR_SUCCESS == (iStat = qFileMark.Fetch(&hFileRec)))
			{
				// get the attributes
				DWORD iAttributes = ::MsiRecordGetInteger(hFileRec, iColICE35MarkFile_Attributes);
				if ((iAttributes & msidbFileAttributesCompressed) ||
					(bSourceTypeCompressed & !(iAttributes & msidbFileAttributesNoncompressed)))
					// compressed, mark with 2
					::MsiRecordSetInteger(hFileRec, iColICE35MarkFile_Mark, 2);
				else
					// uncompressed, mark it with 1
					::MsiRecordSetInteger(hFileRec, iColICE35MarkFile_Mark, 1);
				// update the record
				ReturnIfFailed(35, 6, qFileMark.Modify(MSIMODIFY_UPDATE, hFileRec));
			}

			// query for all components using files in this media sequence range
			// that are marked with a "2"
			ReturnIfFailed(35, 4, qComponent.Execute(hMediaRec));

			// for every record we get, output an error if attributes are bad
			while (ERROR_SUCCESS == (iStat = qComponent.Fetch(&hComponentRec)))
			{
				// check to see if this component allows RFS
				DWORD iAttributes = ::MsiRecordGetInteger(hComponentRec, 1);
				::MsiRecordSetString(hComponentRec, 3, pszCAB);

				// the lower two bits are RFS flags. 0 means local only, which is what we want
				switch (iAttributes & 0x03)
				{
				case 0: break; // OK
				case 1: // source only. BAD!
					if (!bAtLeastSchema150) // no longer required starting with schema 150
						ICEErrorOut(hInstall, hComponentRec, ICE35RFSOnly);
					break;
				case 2: // either OK.
					break;
				default:
					ICEErrorOut(hInstall, hComponentRec, ICE35InvalidBits);
					break;
				}
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 35, 5);
				return ERROR_SUCCESS;
			}
		}

		iPrevLastSeq = iSequence;
	}

	DELETE_IF_NOT_NULL(pszCAB);

	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 35, 5);
		return ERROR_SUCCESS;
	}

	// now retrieve any files that are not marked and check their attributes
	CQuery qGetFiles;
	ReturnIfFailed(35, 7, qGetFiles.OpenExecute(hDatabase, 0, sqlICE35GetFiles));

	while (ERROR_SUCCESS == (iStat = qGetFiles.Fetch(&hFileRec))) 
	{
		// check to see if this file is compressed, either explicitly or through summaryinfo
		DWORD iAttributes = ::MsiRecordGetInteger(hFileRec, iColICE35GetFiles_Attributes);
		if ((iAttributes & msidbFileAttributesCompressed) ||
			(bSourceTypeCompressed & !(iAttributes & msidbFileAttributesNoncompressed)))
			ICEErrorOut(hInstall, hFileRec, ICE35NoCAB);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 35, 5);
		return ERROR_SUCCESS;
	}
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// ICE36 -- validates that all icons are used.

// foreign tables
struct Ice36FKTables
{
	const TCHAR* szName;
	const TCHAR* szSQL;
};

const int iICE36Tables = 4;
Ice36FKTables pICE36Tables[iICE36Tables] = {
	{ _T("Class"),    _T("UPDATE `Icon`, `Class` SET `Icon`.`Used`=1 WHERE `Icon`.`Name`=`Class`.`Icon_`") },
	{ _T("Shortcut"), _T("UPDATE `Icon`,`Shortcut` SET `Icon`.`Used`=1 WHERE `Icon`.`Name`=`Shortcut`.`Icon_`") },
	{ _T("ProgId"),   _T("UPDATE `Icon`,`ProgId` SET `Icon`.`Used`=1 WHERE `Icon`.`Name`=`ProgId`.`Icon_`") },
	{ _T("Property"),   _T("UPDATE `Icon`,`Property` SET `Icon`.`Used`=1 WHERE (`Property`.`Property`='ARPPRODUCTICON' AND `Icon`.`Name`=`Property`.`Value`)") }
};

const TCHAR sqlICE36CreateColumn[] = _T("ALTER TABLE `Icon` ADD `Used` SHORT TEMPORARY HOLD");
const TCHAR sqlICE36InitColumn[] = _T("UPDATE `Icon` SET `Icon`.`Used`=0");
const TCHAR sqlICE36GetUnused[] = _T("SELECT `Icon`.`Name` FROM `Icon` WHERE `Icon`.`Used` = 0");
const TCHAR sqlICE36FreeTable[] = _T("ALTER TABLE `Icon` FREE");

ICE_ERROR(ICE36NotUsed, 36, ietWarning, "Icon Bloat. Icon [1] is not used in the Class, Shortcut, or ProgID table and also not used for ARPPRODUCTICON property.","Icon\tName\t[1]")

ICE_FUNCTION_DECLARATION(36)
{
	//status return
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 36);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// make sure we have an icon table to work with. If not, there are obviously 
	// no extra icons.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 36, TEXT("Icon")))
		return ERROR_SUCCESS;

	// create a temporary column in the Icon table as a marker
	CQuery qCreate;
	PMSIHANDLE hCreateView;
	ReturnIfFailed(36, 1, qCreate.OpenExecute(hDatabase, 0, sqlICE36CreateColumn));
	qCreate.Close();

	// manage hold count on Icon table
	CManageTable MngIconTable(hDatabase, TEXT("Icon"), /*fAlreadyLocked = */true);

	// and init that column
	CQuery qInit;
	ReturnIfFailed(36, 2, qInit.OpenExecute(hDatabase, 0, sqlICE36InitColumn));
	qInit.Close();

	// now check each of the possible keys into this table and mark everything that is found
	for (int i=0; i < iICE36Tables; i++)
	{

		// make sure we have an a table. If not, skip it
		if (!IsTablePersistent(FALSE, hInstall, hDatabase, 36, pICE36Tables[i].szName))
			continue;

		// create a view to do the modify
		CQuery qModify;
		ReturnIfFailed(36, 3, qModify.OpenExecute(hDatabase, 0, pICE36Tables[i].szSQL));
		qModify.Close();
	}

	CQuery qIcon;
	PMSIHANDLE hIconRec;

	// now retrieve anything that isn't marked and give an error for each
	ReturnIfFailed(36, 4, qIcon.OpenExecute(hDatabase, 0, sqlICE36GetUnused));

	// get all items
	while (ERROR_SUCCESS == (iStat = qIcon.Fetch(&hIconRec)))
		ICEErrorOut(hInstall, hIconRec, ICE36NotUsed);

	// make sure that we stopped because there were no more items
	if (iStat != ERROR_NO_MORE_ITEMS)
	{
		APIErrorOut(hInstall, iStat, 36, 5);
		return ERROR_SUCCESS;
	}

	// create a view to do the modify
	CQuery qFree;
	ReturnIfFailed(36, 6, qFree.OpenExecute(hDatabase, 0, sqlICE36FreeTable));
	MngIconTable.RemoveLockCount();
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Helper function to determine if a component falls under HKCU
// iICE is the ICE number
// qFetch is an opened query that returns every component we should check
// the errors are provided by the ICE and are displayed in the error cases
// or success case. Any can be NULL to disable that error.
static const TCHAR sqlHKCUGetRegistry[] = TEXT("SELECT `Registry` FROM `Registry` WHERE (`Registry`=?)");
static const TCHAR sqlHKCUGetRegistryOwned[] = TEXT("SELECT `Registry`, `Root` FROM `Registry` WHERE (`Registry`=?) AND (`Component_`=?)");

bool CheckComponentIsHKCU(MSIHANDLE hInstall, MSIHANDLE hDatabase, int iICE, 
						  CQuery &qFetch, 
					 const ErrorInfo_t *NonRegistry, const ErrorInfo_t *NullPath, 
					 const ErrorInfo_t *NoRegTable, const ErrorInfo_t *NoRegEntry,
					 const ErrorInfo_t *NotOwner, const ErrorInfo_t *NonHKCU,
					 const ErrorInfo_t *IsHKCU)
{
	UINT iStat;
	PMSIHANDLE hMarkedRec;
	BOOL bHaveRegistry;

	// figure out if we have a registry table or not.
	bHaveRegistry  = IsTablePersistent(FALSE, hInstall, hDatabase, 38, TEXT("Registry"));

	// init the registry queries
	CQuery qRegistry;
	CQuery qRegistryOwned;
	if (bHaveRegistry)
	{
		ReturnIfFailed(38, 8, qRegistry.Open(hDatabase, sqlHKCUGetRegistry));
		ReturnIfFailed(38, 9, qRegistryOwned.Open(hDatabase, sqlHKCUGetRegistryOwned));
	}

	while (ERROR_SUCCESS == (iStat = qFetch.Fetch(&hMarkedRec)))
	{
		// get the attributes
		unsigned int iAttributes = ::MsiRecordGetInteger(hMarkedRec, 3);
		if (!(iAttributes & 0x04))
		{
			// not set to registry
			if (NonRegistry) 
				ICEErrorOut(hInstall, hMarkedRec, *NonRegistry);
			continue;
		}

		// if it was null, thats even worse
		if (::MsiRecordIsNull(hMarkedRec, 1))
		{
			if (NullPath) 
				ICEErrorOut(hInstall, hMarkedRec, *NullPath);
			continue;
		}

		// if we don't have a registry table, this is a definite error
		if (!bHaveRegistry)
		{
			if (NoRegTable) 
				ICEErrorOut(hInstall, hMarkedRec, *NoRegTable);
			continue;
		}

		// it was set to registry, now make sure that the registry entry belongs to us
		// and is under HKCU
		ReturnIfFailed(38, 11, qRegistry.Execute(hMarkedRec));
		PMSIHANDLE hRegistry;
		if (ERROR_SUCCESS != (iStat = qRegistry.Fetch(&hRegistry))) {
			// registry key doesn't exist
			if (NoRegEntry) 
				ICEErrorOut(hInstall, hMarkedRec, *NoRegEntry);
			continue;
		}

		// check that it actually belongs to us
		ReturnIfFailed(38, 12, qRegistryOwned.Execute(hMarkedRec));
		iStat = qRegistryOwned.Fetch(&hRegistry);
		switch (iStat)
		{
		case ERROR_SUCCESS: break;
		case ERROR_NO_MORE_ITEMS:
			// registry key exists, but doesn't belong to this component
			if (NotOwner) 
				ICEErrorOut(hInstall, hMarkedRec, *NotOwner);
			continue;
		default:
			APIErrorOut(hInstall, iStat, 38, 13);
			return ERROR_SUCCESS;
		}

		// reg key exists and belongs to us, check that it lies under HKCU
		iAttributes = ::MsiRecordGetInteger(hRegistry, 2);
		// iAttributes can be either 1 or -1 for HKCU
		if ((iAttributes != 1) && (iAttributes != -1))
		{
			if (NonHKCU) 
				ICEErrorOut(hInstall, hMarkedRec, *NonHKCU);
			continue;
		}

		// this component is happy
		if (IsHKCU)
			ICEErrorOut(hInstall, hMarkedRec, *IsHKCU);
	}
	return true;
}

///////////////////////////////////////////////////////////////////////
// ICE38 -- validates that profile components don't have a file as 
// the KeyPath, and checks that the registry key is valid.
static const TCHAR sqlICE38GetComponents[] = TEXT("SELECT `Component`.`KeyPath`, `Component`.`Component`, `Component`.`Attributes` FROM `Directory`,`Component` WHERE (`Component`.`Directory_`=`Directory`.`Directory`) AND (`Directory`.`_Profile`=2)");
static const TCHAR sqlICE38Free[] = TEXT("ALTER TABLE `Directory` FREE");

ICE_ERROR(ICE38NonRegistry, 38, ietError, "Component [2] installs to user profile. It must use a registry key under HKCU as its KeyPath, not a file.","Component\tAttributes\t[2]");
ICE_ERROR(ICE38NoRegTable, 38, ietError, "Component [2] installs to user profile. It must use a registry key under HKCU as its KeyPath, but the Registry table is missing.","Component\tKeyPath\t[2]");
ICE_ERROR(ICE38NullPath, 38, ietError, "Component [2] installs to user profile. It must use a registry key under HKCU as its KeyPath. The KeyPath is currently NULL.","Component\tComponent\t[2]");
ICE_ERROR(ICE38NonHKCU, 38, ietError, "Component [2] installs to user profile. It's KeyPath registry key must fall under HKCU.","Registry\tRoot\t[1]");
ICE_ERROR(ICE38NoRegEntry, 38, ietError, "The KeyPath registry entry for component [2] does not exist.","Component\tKeyPath\t[2]");
ICE_ERROR(ICE38RegNotOwner, 38, ietError, "The Registry Entry [1] is set as the KeyPath for component [2], but that registry entry doesn't belong to [2].","Registry\tComponent_\t[1]");
ICE_FUNCTION_DECLARATION(38)
{
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 38);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if no component table, no problem
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 38, TEXT("Component")))
		return ERROR_SUCCESS;

	// if no directory table, problem
	if (!IsTablePersistent(TRUE, hInstall, hDatabase, 38, TEXT("Directory")))
		return ERROR_SUCCESS;

	// manage Directory table hold count (received from MarkProfile)
	// extra free won't hurt us -- MarkProfile could fail after setting HOLD on Directory table
	CManageTable MngDirectoryTable(hDatabase, TEXT("Directory"), /*fAlreadyLocked = */true);

	// mark every directory in the profile in Directory._Profile
	if (!MarkProfile(hInstall, hDatabase, 38))
		return ERROR_SUCCESS;
	
	// now get every component that falls in a marked directory
	CQuery qComponent;

	ReturnIfFailed(38, 10, qComponent.OpenExecute(hDatabase, NULL, sqlICE38GetComponents));
	CheckComponentIsHKCU(hInstall, hDatabase, 38, qComponent, &ICE38NonRegistry, &ICE38NullPath,
		&ICE38NoRegTable, &ICE38NoRegEntry, &ICE38RegNotOwner, &ICE38NonHKCU, NULL);

	// release directory table
	qComponent.OpenExecute(hDatabase, NULL, sqlICE38Free);
	MngDirectoryTable.RemoveLockCount();
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// ICE39, validates Summary Info Stream
enum eMode_t 
{
	modeUnknown = 0,
	modeModule = 1,
	modeDatabase = 2,
	modeTransform = 3,
	modePatch = 4
};

ICE_ERROR(Ice39BadTemplate, 39, ietError, "PID_TEMPLATE value in Summary Information Stream is not valid. It must be of the form \"Platform,Platform,...;LangID,LangID,...\".","_SummaryInfo\t7");
ICE_ERROR(Ice39BadTemplateArchitecture, 39, ietError, "PID_TEMPLATE value in Summary Information Stream is not valid. Mixed architecture packages with Intel64 are not allowed.\".","_SummaryInfo\t7");
ICE_ERROR(Ice39BadTemplatePatch, 39, ietError, "PID_TEMPLATE value in Summary Information Stream is not valid for a Patch. It must be a semicolon delimited list of product codes.\".","_SummaryInfo\t7");
ICE_ERROR(Ice39NullTemplate, 39, ietError, "PID_TEMPLATE value in Summary Information Stream is not valid. It can only be NULL in Transforms.\".","_SummaryInfo\t7");
ICE_ERROR(Ice39BadTransformLanguage, 39, ietError, "PID_TEMPLATE value in Summary Information Stream is not valid for a Transform. It can only specify one language.\".","_SummaryInfo\t7");
ICE_ERROR(Ice39BadTitle, 39, ietError, "Could not recognize PID_TITLE value in Summary Information Stream as a identifying a valid package type. Unable to continue SummaryInfo validation.","_SummaryInfo\t2");
ICE_ERROR(Ice39BadLastPrinted, 39, ietWarning, "PID_LASTPRINTED value in Summary Information Stream is not valid. The time must be equal to or later than the create time.","_SummaryInfo\t11");
ICE_ERROR(Ice39BadLastSave, 39, ietWarning, "PID_LASTSAVE_DTM value in Summary Information Stream is not valid. The time must be equal to or later than the create time.","_SummaryInfo\t12");
ICE_ERROR(Ice39BadWordCountPatch, 39, ietError, "PID_WORDCOUNT value in Summary Information Stream is not valid. 1 is the only supported value for a patch.","_SummaryInfo\t15");
ICE_ERROR(Ice39BadWordCountDatabase, 39, ietError, "PID_WORDCOUNT value in Summary Information Stream is not valid. Source image flags must be 0, 1, 2, or 3.","_SummaryInfo\t15");
ICE_ERROR(Ice39BadSecurity, 39, ietError, "PID_SECURITY value in Summary Information Stream is not valid. Must be 0, 1, or 2.","_SummaryInfo\t19");
ICE_ERROR(Ice39BadType, 39, ietError, "Bad Type in Summary Information Stream for %s.","_SummaryInfo\t%d");
ICE_ERROR(Ice39BadRevNumberTransform, 39, ietError, "PID_REVNUMBER value in Summary Information Stream is not valid. Format for Transforms is \"<GUID> <Version>;<GUID> <Version>;<GUID>\".","_SummaryInfo\t9");
ICE_ERROR(Ice39BadRevNumberPatch, 39, ietError, "PID_REVNUMBER value in Summary Information Stream is not valid. Format for Transforms is \"<GUID><GUID>...\".","_SummaryInfo\t9");
ICE_ERROR(Ice39BadRevNumberDatabase, 39, ietError, "PID_REVNUMBER value in Summary Information Stream is not valid. Format for Databases is \"<GUID>\".","_SummaryInfo\t9");
ICE_ERROR(Ice39BadRevNumberModule, 39, ietError, "PID_REVNUMBER value in Summary Information Stream is not valid. Format for Merge Modules is \"<GUID>\".","_SummaryInfo\t9");
ICE_ERROR(Ice39BadRevNumber, 39, ietError, "PID_REVNUMBER value in Summary Information Stream is not valid. Valid format depends on the type of package, see the docs.","_SummaryInfo\t9");
ICE_ERROR(Ice39BadTransformFlags, 39, ietError, "PID_LASTPRINTED value in Summary Information Stream is not valid. Only Databases can have a value.","_SummaryInfo\t11"); 
ICE_ERROR(Ice39CompressedWarning, 39, ietWarning, "The File '[1]' is explicitly marked compressed, but the Summary Information Stream already specifies that the whole install is compressed. This might not be the behavior you want.","File\tAttributes\t[1]"); 
ICE_ERROR(Ice39Unsupported, 39, ietWarning, "Your validation engine does not support SummaryInfo validation. Skipping ICE39.", ""); 
ICE_ERROR(Ice39AdminImage, 39, ietWarning, "'Admin Image' flag set in SummaryInfo stream. Should be set only for Admin packages.", "SummaryInfo\t15"); 

const TCHAR sqlIce39File[] = TEXT("SELECT `File`, `Attributes` FROM `File` WHERE (`Attributes` > 8192)");

static const TCHAR *rgszPID[] = {
	TEXT(""), // unused, no PID 0
	TEXT("PID_CODEPAGE"),
	TEXT("PID_TITLE"), 
	TEXT("PID_SUBJECT"),
	TEXT("PID_AUTHOR"),
	TEXT("PID_KEYWORDS"), 
	TEXT("PID_COMMENTS"), 
	TEXT("PID_TEMPLATE"), 
	TEXT("PID_LASTAUTHOR"), 
	TEXT("PID_REVNUMBER"), 
	TEXT(""), // unused, no PID 10
	TEXT("PID_LASTPRINTED"),
	TEXT("PID_CREATE_DTM"), 
	TEXT("PID_LASTSAVE_DTM"),
	TEXT("PID_PAGECOUNT"),
	TEXT("PID_WORDCOUNT"),
	TEXT("PID_CHARCOUNT"), 
	TEXT(""), // unused, no PID 17
	TEXT("PID_APPNAME"), 
	TEXT("PID_SECURITY")
};

bool Ice39CheckVersion(LPCTSTR *pszCurrent) 
{
	for (int i=0; i < 4; i++)
	{
		// handle up to 4 digits, return if hit space
		// break if hit .
		for (int digits=0; digits < 4; digits++)
		{
			if (_istdigit(**pszCurrent))
				(*pszCurrent)++;
			else if (_istspace(**pszCurrent))
			{
				(*pszCurrent)++;
				return true;
			}
			if (**pszCurrent == TEXT('.'))
				break;
			return false;
		}
		// parsed digits, now either space, '.' or bad char
		if (_istspace(**pszCurrent))
		{
			(*pszCurrent)++;
			return true;
		}

		// or hit '.', move on
		if (**pszCurrent == TEXT('.'))
		{
			(*pszCurrent)++;
			continue;
		}

		// otherwise bad
		return false;
	}

	// four chunks of digits, make sure space at the end.
	if (_istspace(**pszCurrent))
	{
		(*pszCurrent)++;
		return true;
	}

	// otherwise error
	return false;
};

bool Ice39CheckGuid(LPCTSTR *pszCurrent) 
{
	const char digits[5] = {8, 4, 4, 4, 12};
	// check for {
	if (**pszCurrent != TEXT('{'))
		return false;
	(*pszCurrent)++;

	int blocknum;

	for (blocknum = 0; blocknum < 5; blocknum++) 
	{
		// now check for UPPERCASE hex digits
		for (int i=0; i < digits[blocknum]; i++, (*pszCurrent)++)
		{
			if (!(_istdigit(**pszCurrent) || 
				 ((**pszCurrent >= TEXT('A')) && (**pszCurrent <= TEXT('F')))))
				return false;
		}

		// check for dash
		if (**pszCurrent != TEXT('-'))
			break;
		(*pszCurrent)++;
	}

	// now check that we got all blocks
	if (blocknum != 4) return false;
	
	// check for closing brace
	if (**pszCurrent != TEXT('}'))
		return false;
	(*pszCurrent)++;
	return true;
}

// Valid Formats for Revision Number:
// database: GUID
// mergemodule: GUID
// transform: GUID version;GUID version;GUID
// patch: GUIDGUIDGUID.... (no delims)
bool Ice39ValidateRevNumber(MSIHANDLE hInstall, const TCHAR * const szString, const enum eMode_t eMode) {

	LPCTSTR currentChar = szString;
	PMSIHANDLE hErrorRec = ::MsiCreateRecord(1);
	MsiRecordSetInteger(hErrorRec, 1, 5);

	switch (eMode) {
	case modeDatabase:
	case modeModule:
		// check for guid
		if (!Ice39CheckGuid(&currentChar)) break;
		if (*currentChar != TEXT('\0')) break;
		return true;

	case modeTransform:
		if (!Ice39CheckGuid(&currentChar)) break;

		// eat white space
		do { if (*currentChar == TEXT('\0')) break; } while (_istspace(*currentChar++));
		if (!Ice39CheckVersion( &currentChar)) break;

		// eat white space, then semicolon
		do { if (*currentChar == TEXT('\0')) break; } while (_istspace(*currentChar++));
		if (*currentChar != TEXT(';')) break;

		// eat white space, then guid
		do { if (*currentChar == TEXT('\0')) break; } while (_istspace(*currentChar++));
		if (!Ice39CheckGuid( &currentChar)) break;

		// must be version
		do { if (*currentChar == TEXT('\0')) break; } while (_istspace(*currentChar++));
		if (!Ice39CheckVersion( &currentChar)) break;

		// must be semicolon
		do { if (*currentChar == TEXT('\0')) break; } while (_istspace(*currentChar++));
		if (*currentChar != TEXT(';')) break;
		// eat white space
		do { if (*currentChar == TEXT('\0')) break; } while (_istspace(*currentChar++));
		if (!Ice39CheckGuid( &currentChar)) break;

		// eat white space
		do { if (*currentChar == TEXT('\0')) break; } while (_istspace(*currentChar++));
		return true;

	case modePatch:
		while (Ice39CheckGuid( &currentChar))
			;
		if (*currentChar != TEXT('\0')) break;
		return true;
	}

	switch (eMode)
	{
	case modePatch:
		ICEErrorOut(hInstall, hErrorRec, Ice39BadRevNumberPatch);
		break;
	case modeTransform:
		ICEErrorOut(hInstall, hErrorRec, Ice39BadRevNumberTransform);
		break;
	case modeDatabase:
		ICEErrorOut(hInstall, hErrorRec, Ice39BadRevNumberDatabase);
		break;
	case modeModule:
		ICEErrorOut(hInstall, hErrorRec, Ice39BadRevNumberModule);
		break;
	}
	return true;
}

bool Ice39ValidateTemplate(MSIHANDLE hInstall, TCHAR *szString, const enum eMode_t eMode) {

	const TCHAR *szCurrent = szString;
	bool fPlatform = false;
	bool fIntel64  = false;
	switch (eMode)
	{
	case modePatch:
		// patch contains just guid;guid;guid....
		do {
			if (!Ice39CheckGuid(&szCurrent))
			{
				PMSIHANDLE hErrorRec = ::MsiCreateRecord(1);
				ICEErrorOut(hInstall, hErrorRec, Ice39BadTemplatePatch);
				break;
			}
		} while (*szCurrent == TEXT(';'));
		break;
	case modeDatabase:
	case modeTransform:
	case modeModule:
		// check platform values
		while (1)
		{
			if ((_tcsncmp(szCurrent, TEXT("Intel"), 5) == 0) ||
				(_tcsncmp(szCurrent, TEXT("Alpha"), 5) == 0) ||
				(_tcsncmp(szCurrent, TEXT("Intel64"), 7) == 0))
			{
				if (_tcsncmp(szCurrent, TEXT("Intel64"), 7) == 0)
				{
					fIntel64 = true;
					if (fPlatform)
					{
						PMSIHANDLE hErrorRec = ::MsiCreateRecord(1);
						ICEErrorOut(hInstall, hErrorRec, Ice39BadTemplateArchitecture);
					}
					szCurrent += 7;
				}
				else
				{
					if (fIntel64)
					{
						PMSIHANDLE hErrorRec = ::MsiCreateRecord(1);
						ICEErrorOut(hInstall, hErrorRec, Ice39BadTemplateArchitecture);
					}
					szCurrent += 5;
				}
				fPlatform = true;
				if (*szCurrent == TEXT(','))
				{
					szCurrent++;
					continue;
				}
			}
			if (*szCurrent != TEXT(';')) 
			{
				PMSIHANDLE hErrorRec = ::MsiCreateRecord(1);
				ICEErrorOut(hInstall, hErrorRec, Ice39BadTemplate);
			}
			szCurrent++;
			break;
		}

		// check language values
		while (1)
		{
			if ((*szCurrent >= TEXT('0')) && (*szCurrent <= TEXT('9')))
			{
				szCurrent++;
				continue;
			}
			if (*szCurrent == TEXT(','))
			{
				if (eMode == modeTransform)
				{
					PMSIHANDLE hErrorRec = ::MsiCreateRecord(1);
					ICEErrorOut(hInstall, hErrorRec, Ice39BadTransformLanguage);
					break;
				} 
				else
				{
					szCurrent++;
					continue;
				}
			}
			break;
		}
	default:
		break;
	}
	if (*szCurrent != TEXT('\0'))
	{
		PMSIHANDLE hErrorRec = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hErrorRec, Ice39BadTemplate);
	}
	return true;
}

///////////////////////////////////////////////////////////////////////
// ICE39 -- validates summary info properties
ICE_FUNCTION_DECLARATION(39)
{
	eMode_t eMode;
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 39);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// dummy handle used for error output
	PMSIHANDLE hErrorRec = ::MsiCreateRecord(1);

	UINT iType;
	int iValue;
	PMSIHANDLE hSummaryInfo;
	FILETIME timeFirst;
	FILETIME timeSecond;
	unsigned long cchString = MAX_PATH;
	TCHAR *szString = new TCHAR[cchString];
	CDeleteOnExit t1(&szString);

	ReturnIfFailed(39, 1, ::MsiGetSummaryInformation(hDatabase, NULL, 0, &hSummaryInfo));

	// check to see if the evaluation system supports summaryinfo evaluation.
	ReturnIfFailed(39, 4, GetSummaryInfoPropertyString(hSummaryInfo, PID_SUBJECT, iType, &szString, cchString));
	if (VT_LPSTR == iType) 
	{
		if (_tcsncmp(szString, _T("Internal Consistency Evaluators"), 31) == 0)
		{
			ICEErrorOut(hInstall, hErrorRec, Ice39Unsupported);
			return ERROR_SUCCESS;
		}
	}	

	// codepage, just check that it is an integer
	ReturnIfFailed(39, 2, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_CODEPAGE, &iType, &iValue, &timeFirst, szString, &cchString));
	if ((iType != VT_EMPTY) && (iType != VT_I2))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_CODEPAGE], PID_CODEPAGE);
	
	// title must be "Merge Module", "Installation Database", "Patch" or "Transform"
	ReturnIfFailed(39, 3, GetSummaryInfoPropertyString(hSummaryInfo, PID_TITLE, iType, &szString, cchString));
	if (iType != VT_LPSTR)
	{
		ICEErrorOut(hInstall, hErrorRec, Ice39BadTitle);
		return ERROR_SUCCESS;
	}
	else if (_tcsncmp(szString, _T("Merge Module"), 12) == 0)
		eMode = modeModule;
	else if (_tcsncmp(szString, _T("Transform"), 9) == 0)
		eMode = modeTransform;
	else if (_tcsncmp(szString, _T("Patch"), 9) == 0)
		eMode = modePatch;
	else 
	{
		eMode = modeDatabase;
//		ICEErrorOut(hInstall, hErrorRec, Ice39BadTitle);
//		return ERROR_SUCCESS;
	}

	// subject make sure its a string
	ReturnIfFailed(39, 4, GetSummaryInfoPropertyString(hSummaryInfo, PID_SUBJECT, iType, &szString, cchString));
	CQuery qProperty;
	if ((iType != VT_EMPTY) && (iType != VT_LPSTR))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_SUBJECT], PID_SUBJECT);

	// author, just make sure its a string and equal to Manufacturer
	ReturnIfFailed(39, 5, GetSummaryInfoPropertyString(hSummaryInfo, PID_AUTHOR, iType, &szString, cchString));
	if ((iType != VT_EMPTY) && (iType != VT_LPSTR))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_AUTHOR], PID_AUTHOR);

	// keywords, just make sure its a string
	ReturnIfFailed(39, 6, GetSummaryInfoPropertyString(hSummaryInfo, PID_KEYWORDS, iType, &szString, cchString));
	if ((iType != VT_EMPTY) && (iType != VT_LPSTR))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_KEYWORDS], PID_KEYWORDS);

	// comments, just make sure its a string
	ReturnIfFailed(39, 7, GetSummaryInfoPropertyString(hSummaryInfo, PID_COMMENTS, iType, &szString, cchString));
	if ((iType != VT_EMPTY) && (iType != VT_LPSTR))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_COMMENTS], PID_COMMENTS);

	// template can be empty, null, or it can be platform,platform,...;lang,lang,...
	// depending on DB type.
	ReturnIfFailed(39, 8, GetSummaryInfoPropertyString(hSummaryInfo, PID_TEMPLATE, iType, &szString, cchString));
	if (iType != VT_LPSTR)
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_TEMPLATE], PID_TEMPLATE);
	else 
	{
		// can only be null in transform
		if ((*szString == TEXT('\0') && (eMode != modeTransform)))
			ICEErrorOut(hInstall, hErrorRec, Ice39NullTemplate);
		else
		{
			if (!Ice39ValidateTemplate(hInstall, szString, eMode))
				return ERROR_SUCCESS;
		}
	}

	// last author
	// for a databose, who cares
	// for a transform its another platform;lang thing.
	// for a patch its semicolon delimited identifiers, so we'll say who cares
	ReturnIfFailed(39, 9, GetSummaryInfoPropertyString(hSummaryInfo, PID_LASTAUTHOR, iType, &szString, cchString));
	switch (eMode) {
	case modeDatabase:
	case modePatch:
		if ((iType != VT_EMPTY) && (iType != VT_LPSTR))
			ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_LASTAUTHOR], PID_LASTAUTHOR);
		break;
	case modeTransform:
		if ((iType != VT_EMPTY) && (iType != VT_LPSTR))
			ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_LASTAUTHOR], PID_LASTAUTHOR);
		if (!Ice39ValidateTemplate(hInstall, szString, eMode))
			return ERROR_SUCCESS;
		break;
	}

	// revisionnumber, complicated, so pass to function
	ReturnIfFailed(39, 10, GetSummaryInfoPropertyString(hSummaryInfo, PID_REVNUMBER, iType, &szString, cchString));
	if (iType != VT_LPSTR)
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_REVNUMBER], PID_REVNUMBER);
	if (!Ice39ValidateRevNumber(hInstall, szString, eMode))
		return ERROR_SUCCESS;

	// create date and times. Validate that LastSave is null or >= Create
	ReturnIfFailed(39, 12, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_CREATE_DTM, &iType, &iValue, &timeFirst, szString, &cchString));
	if (iType == VT_FILETIME) 
	{
		ReturnIfFailed(39, 13, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_LASTSAVE_DTM, &iType, &iValue, &timeSecond, szString, &cchString));
		if (iType != VT_EMPTY)
		{
			if (iType != VT_FILETIME)
				ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_LASTSAVE_DTM], PID_LASTSAVE_DTM);
			else if (CompareFileTime(&timeFirst, &timeSecond) == 1)
				ICEErrorOut(hInstall, hErrorRec, Ice39BadLastSave);
		}

		// last printed should also be >= CreateTime
		ReturnIfFailed(39, 14, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_LASTPRINTED, &iType, &iValue, &timeSecond, szString, &cchString));
		if ((eMode == modeDatabase) && (iType != VT_EMPTY))
		{
			if (iType != VT_FILETIME)
				ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_LASTPRINTED], PID_LASTPRINTED);
			else if (CompareFileTime(&timeFirst, &timeSecond) == 1)
				ICEErrorOut(hInstall, hErrorRec, Ice39BadLastPrinted);
		}
	}
	else if (iType != VT_EMPTY)
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_CREATE_DTM], PID_CREATE_DTM);
		
	// page count, might be null in patch packages, otherwise I4 is all we can check (or can we check version maybe)
	ReturnIfFailed(39, 15, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_PAGECOUNT, &iType, &iValue, &timeFirst, szString, &cchString));
	if ((eMode != modePatch) && (iType != VT_I4))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_PAGECOUNT], PID_PAGECOUNT);

	// word count 
	// transform is null.
	// database is source image flags, 0-3 (bit field)
	// patch must be '1'
	// admin image bit (3) set 
	ReturnIfFailed(39, 16, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_WORDCOUNT, &iType, &iValue, &timeFirst, szString, &cchString));
	if ((eMode != modeTransform) && (iType != VT_I4))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_WORDCOUNT], PID_WORDCOUNT);
	else if (eMode == modeDatabase)
	{
		if (iValue & 0xFFF8)
			ICEErrorOut(hInstall, hErrorRec, Ice39BadWordCountDatabase);
		else 
		{
			if (iValue & msidbSumInfoSourceTypeCompressed)
			{
				// open a query on the file table if it exists
				if (::MsiDatabaseIsTablePersistent(hDatabase, _T("File")))
				{	
					CQuery qFile;
					PMSIHANDLE hFileRec;
					ReturnIfFailed(39, 17, qFile.OpenExecute(hDatabase, 0, sqlIce39File));
					while (ERROR_SUCCESS == qFile.Fetch(&hFileRec))
					{
						// check for files marked with the default value
						if (::MsiRecordGetInteger(hFileRec, 2) & msidbFileAttributesCompressed)
							ICEErrorOut(hInstall, hFileRec, Ice39CompressedWarning);
					}
					qFile.Close();
				}
			}
			if (iValue & msidbSumInfoSourceTypeAdminImage)
				ICEErrorOut(hInstall, hErrorRec, Ice39AdminImage);
		}
	}
	else if ((eMode == modePatch) && (iValue != 1))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadWordCountPatch);

	// CharCount - Transform validation flags. Null except in Transform.
	ReturnIfFailed(39, 17, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_CHARCOUNT, &iType, &iValue, &timeFirst, szString, &cchString));
	if ((eMode == modeTransform) && (iType != VT_I4))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_CHARCOUNT], PID_CHARCOUNT);
	else if ((eMode == modeTransform) && (iValue & 0xF000FFC0))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadTransformFlags);

	// AppName value, all we can do is verify that its a string.
	ReturnIfFailed(39, 18, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_APPNAME, &iType, &iValue, &timeFirst, szString, &cchString));
	if ((iType != VT_LPSTR) && (iType != VT_EMPTY))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_APPNAME], PID_APPNAME);

	// Security value
	ReturnIfFailed(39, 19, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_SECURITY, &iType, &iValue, &timeFirst, szString, &cchString));
	if ((iType != VT_EMPTY) && (iType != VT_I4))
		ICEErrorOut(hInstall, hErrorRec, Ice39BadType, rgszPID[PID_SECURITY], PID_SECURITY);
		
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\msiice15.dll\sources.inc ===
TARGETNAME=msiice15
!INCLUDE ..\..\..\..\MsiMake.inc

TARGETTYPE=DYNLINK
TARGETLIBS= \
	$(BUILD_DIR)\msi.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \

C_DEFINES=$(C_DEFINES)
USE_LIBCMT=1
USE_NATIVE_EH=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\msiice15.def
BINPLACE_PLACEFILE=..\..\placefil.txt

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msiice15.cpp \
	..\msiice15.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\shrice.dll\shrice.cpp ===
#include "..\msiice.dll\msiice.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\msiice11.dll\sources.inc ===
TARGETNAME=msiice11
!INCLUDE ..\..\..\..\MsiMake.inc

TARGETTYPE=DYNLINK
TARGETLIBS= \
	$(BUILD_DIR)\msi.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \

C_DEFINES=$(C_DEFINES)
USE_LIBCMT=1
USE_NATIVE_EH=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\msiice11.def
BINPLACE_PLACEFILE=..\..\placefil.txt

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msiice11.cpp \
	..\msiice11.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\shrice.dll\shricinc.cpp ===
#include "..\msiice.dll\msiice2.cpp"
#include "..\msiice.dll\msiice3.cpp"
#include "..\msiice.dll\msiice4.cpp"
#include "..\msiice.dll\msiice5.cpp"
#include "..\msiice.dll\msiice6.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\msiice15.dll\msiice15.cpp ===
//--------------------------------------------------------------------------
//
//	Microsoft Windows
//
//	Copyright (C) Microsoft Corporation, 2000
// 
//	File:		msiice15.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>	// included for both CPP and RC passes
#include <stdio.h>	// printf/wprintf
#include <tchar.h>	// define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "msidefs.h"	// must be in this directory or on INCLUDE path
#include "..\..\common\msiice.h"
#include "..\..\common\query.h"
#include "..\..\common\utilinc.cpp"


const int g_iFirstICE = 78;
const struct ICEInfo_t g_ICEInfo[] = 
{
	// ICE78
	{
		TEXT("ICE78"),
		TEXT("Created 8/29/2000. Last Modified 8/29/2000."),
		TEXT("Verifies that AdvtUISequence table either does not exist or is empty."),
		TEXT("ice78.html")
	},
	// ICE79
	{
		TEXT("ICE79"),
		TEXT("Created 10/24/2000. Last Modified 05/22/2001."),
		TEXT("Verifies that references to component and feature in conditions are valid."),
		TEXT("ice79.html")
	},
	// ICE80
	{
		TEXT("ICE80"),
		TEXT("Created 01/17/2001. Last Modified 06/26/2001."),
		TEXT("Verifies that various Template Summary Properties are correct."),
		TEXT("ice80.html")
	},
	// ICE81
	{
		TEXT("ICE81"),
		TEXT("Created 04/04/2001. Last Modified 04/04/2001."),
		TEXT("MsiDigitalCertificate table and MsiDigitalSignature table Validator."),
		TEXT("ice81.html")
    },
	// ICE82
	{
		TEXT("ICE82"),
		TEXT("Created 04/10/2001. Last Modified 04/10/2001."),
		TEXT("InstallExecuteSequence validator and warns if the executeSequence tables found to use a sequence number more than once.`"),
		TEXT("ice82.html")
	},
	// ICE83
	{
		TEXT("ICE83"),
		TEXT("Created 04/10/2001. Last Modified 04/10/2001."),
		TEXT("MsiAssembly table and MsiAssemblyName table validator."),
		TEXT("ice83.html")
	},
	// ICE84
	{
		TEXT("ICE84"),
		TEXT("Created 05/04/2001. Last Modified 05/04/2001."),
		TEXT("Verify that all required actions in sequence tables are condition-less."),
		TEXT("ice84.html")
	},
	// ICE85
	{
		TEXT("ICE85"),
		TEXT("Created 05/14/2001. Last Modified 05/14/2001."),
		TEXT("Verify that the SourceName column of MoveFile table is a valid LFN WildCardFilename."),
		TEXT("ice85.html")
	},
	// ICE86
	{
		TEXT("ICE86"),
		TEXT("Created 05/18/2001. Last Modified 05/22/2001."),
		TEXT("Post warning for the use of AdminUser instead of Privileged property in conditions."),
		TEXT("ice86.html")
	},
	// ICE87
	{
		TEXT("ICE87"),
		TEXT("Created 05/29/2001. Last Modified 05/29/2001."),
		TEXT("Verifies that some properties that shouldn't be authored into the Property table are not."),
		TEXT("ice87.html")
	},
	// ICE88
	{
		TEXT("ICE88"),
		TEXT("Created 05/29/2001. Last Modified 05/29/2001."),
		TEXT("Verifies that some properties that shouldn't be authored into the Property table are not."),
		TEXT("ice88.html")
	},
	// ICE89
	{
		TEXT("ICE89"),
		TEXT("Created 06/06/2001. Last Modified 06/06/2001."),
		TEXT("Verifies that the Progid_Parent column in ProgId table is a valid foreign key into the ProgId column."),
		TEXT("ice89.html")
	},
	// ICE90
	{
		TEXT("ICE90"),
		TEXT("Created 06/08/2001. Last Modified 06/08/2001."),
		TEXT("Warns user of cases where a shortcut's directory is a public property (ALL CAPS) that is under a profile directory. This results in a problem if the value of the ALLUSERS property changes in the UI sequence."),
		TEXT("ice90.html")
	},
	// ICE91
	{
		TEXT("ICE91"),
		TEXT("Created 06/11/2001. Last Modified 06/11/2001."),
		TEXT("Warns user of cases where a file (or INI entry, shortcut) is explicitly installed into a per-user profile directory that doesn't vary based on the ALLUSERS value. These files will not be copied into each user's profile."),
		TEXT("ice91.html")
	},
	// ICE92
	{
		TEXT("ICE92"),
		TEXT("Created 06/12/2001. Last Modified 06/12/2001."),
		TEXT("Verifies that a GUID-less component is not marked permanent."),
		TEXT("ice92.html")
	},
	// ICE93
	{
		TEXT("ICE93"),
		TEXT("Created 06/13/2001. Last Modified 06/13/2001."),
		TEXT("Verifies that a custom action doesn't use the same name as a standard action."),
		TEXT("ice93.html")
	},
	// ICE94
	{
		TEXT("ICE94"),
		TEXT("Created 06/18/2001. Last Modified 06/18/2001."),
		TEXT("Verifies that there are no non-advertised shortcuts to assembly files in the global assembly cache."),
		TEXT("ice94.html")
	},
	// ICE95
	{
		TEXT("ICE95"),
		TEXT("Created 06/19/2001. Last Modified 06/19/2001."),
		TEXT("Verifies that Billboard control items fit into all the Billboards."),
		TEXT("ice95.html")
	},
	// ICE96
	{
		TEXT("ICE96"),
		TEXT("Created 07/20/2001. Last Modified 07/20/2001."),
		TEXT("Verifies that PublishFeatures and PublishProduct actions are authored in AdvtExecuteSequence table."),
		TEXT("ice96.html")
	},
    	// ICE97
	{
		TEXT("ICE97"),
		TEXT("Created 09/26/2002. Last Modified 09/26/2002."),
		TEXT("Verifies that 2 components does not isolate a shared component to the same directory"),
		TEXT("ice97.html")
	}

};
const int g_iNumICEs = sizeof(g_ICEInfo)/sizeof(struct ICEInfo_t);


//
// Enumerator for all conditions in a database (.msi or .msm files).
//

typedef enum
{
	CONDITION_ENUMERATOR_NONE,
	CONDITION_ENUMERATOR_PROPERTY,
	CONDITION_ENUMERATOR_COMPONENT,
	CONDITION_ENUMERATOR_FEATURE
} CONDITION_ENUMERATOR_SYMBOLTYPE;

const WCHAR* ParseCondition(WCHAR** pState, CONDITION_ENUMERATOR_SYMBOLTYPE& Type)
{
	WCHAR*	pCurrent;
	unsigned char rgbStartIdentifier[] = { 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7F, 0xFF, 0xFF, 0xE1, 0x7F, 0xFF, 0xFF, 0xE0 
	};
	unsigned char rgbContIdentifier[] = { 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0xC0,
		0x7F, 0xFF, 0xFF, 0xE1, 0x7F, 0xFF, 0xFF, 0xE0 
	};


	Type = CONDITION_ENUMERATOR_NONE;

	// start with the state position
	pCurrent = *pState;
	while(*pCurrent)
	{
		// scan forward looking for the beginning of an identifier (A-Z, a-z, _)
		// unicode chars, so high byte is 0 and low byte must have bit set in
		// bit array above
		if(((*pCurrent & 0xFF80) == 0) &&
			(rgbStartIdentifier[*pCurrent >> 3] & (0x80 >> (*pCurrent & 0x07))))
		{
			// first character of identifier: Check what the previous character
			// is.
			if(pCurrent != *pState && wcschr(L"$?", *(pCurrent-1)))
			{
				// Component found.
				Type = CONDITION_ENUMERATOR_COMPONENT;

				WCHAR*	pEnd = pCurrent;
				
				// scan forward until we find something that is not
				// part of an identifier, or hit the end of the string
				while(*pEnd &&
					  ((*pEnd & 0xFF80) == 0) &&
					  (rgbContIdentifier[*pEnd >> 3] & (0x80 >> (*pEnd & 0x07))))
				{
					pEnd++;
				}

				// state for next search is one after end location, unless end of string
				*pState = *pEnd ? pEnd+1 : pEnd;
				// set that location to null
				*pEnd = L'\0';
				return pCurrent;
			}
			else if(pCurrent != *pState && wcschr(L"&!", *(pCurrent - 1)))
			{
				// Feature found.
				Type = CONDITION_ENUMERATOR_FEATURE;

				WCHAR*	pEnd = pCurrent;
				
				// scan forward until we find something that is not
				// part of an identifier, or hit the end of the string
				while(*pEnd &&
					  ((*pEnd & 0xFF80) == 0) &&
					  (rgbContIdentifier[*pEnd >> 3] & (0x80 >> (*pEnd & 0x07))))
				{
					pEnd++;
				}

				// state for next search is one after end location, unless end of string
				*pState = *pEnd ? pEnd+1 : pEnd;
				// set that location to null
				*pEnd = L'\0';
				return pCurrent;
			}
			else if((pCurrent != *pState) && (*(pCurrent - 1) == L'%'))
			{
				// Environment variable, move forward to the end of the identifier.
				while (*pCurrent &&
					   ((*pCurrent & 0xFF80) == 0) &&
						(rgbContIdentifier[*pCurrent >> 3] & (0x80 >> (*pCurrent & 0x07))))
				{
					pCurrent++;
				}
			}
			else if((pCurrent != *pState) && (*(pCurrent - 1) == L'"'))
			{
				// Double quoted strings. Move forward to the next '"'.
				while(*pCurrent && *pCurrent != L'"')
				{
					pCurrent++;
				}

				// Skip the ending '"'.
				if(*pCurrent)
				{
					pCurrent++;
				}
			}
			else
			{
				// Check for logical operators.
				if(!_wcsnicmp(pCurrent, L"NOT", 3) ||
				   !_wcsnicmp(pCurrent, L"AND", 3) ||
				   !_wcsnicmp(pCurrent, L"EQV", 3) ||
				   !_wcsnicmp(pCurrent, L"XOR", 3) ||
				   !_wcsnicmp(pCurrent, L"IMP", 3))
				{
				   pCurrent += 3;
				}
				else if(!_wcsnicmp(pCurrent, L"OR", 2)) 
				{
					pCurrent += 2;
				}
				else
				{
					// Woohoo! Its actually a property.
					Type = CONDITION_ENUMERATOR_PROPERTY;

					WCHAR *pEnd = pCurrent;
					
					// scan forward until we find something that is not
					// part of an identifier, or hit the end of the string
					while(*pEnd &&
						  ((*pEnd & 0xFF80) == 0) &&
						  (rgbContIdentifier[*pEnd >> 3] & (0x80 >> (*pEnd & 0x07))))
					{
						pEnd++;
					}

					// state for next search is one after end location, unless end of string
					*pState = *pEnd ? pEnd+1 : pEnd;
					// set that location to null
					*pEnd = L'\0';
					return pCurrent;
				}
			}
		}
		else
		{
			// some non-identifier character
			pCurrent++;
		}
	}

	return NULL;
}

typedef enum
{
	CONDITION_ERR_SUCCESS = ERROR_SUCCESS,
	CONDITION_ERR_TABLE_ACCESS,
	CONDITION_ERR_FETCH_DATA
} CONDITION_ERR_ENUM;

typedef DWORD (*CheckFunc)(MSIHANDLE, MSIHANDLE, MSIHANDLE, CONDITION_ENUMERATOR_SYMBOLTYPE, DWORD cPrimaryKeys, const WCHAR*, const TCHAR*, const TCHAR*);
typedef DWORD (*ErrorFunc)(MSIHANDLE, CONDITION_ERR_ENUM, MSIHANDLE);

ICE_QUERY2(sqlConditionType, "SELECT `Table`, `Column` FROM `_Validation` WHERE (`Category`='Condition')", Table, Column);

DWORD ConditionEnumerator(MSIHANDLE hInstall, MSIHANDLE hDatabase, DWORD dwIce, CheckFunc pCheckFunc, ErrorFunc pErrFunc)
{
	CQuery		qValidation;
	PMSIHANDLE	hResultRec;
	TCHAR*		pQuery = new TCHAR[255];
	OUT_OF_MEMORY_RETURN(dwIce, pQuery);
	DWORD		cQuery = 255;
	WCHAR*		pData = new WCHAR[255];
	OUT_OF_MEMORY_RETURN(dwIce, pData);
	DWORD		cData = 255;
	UINT		iStat;

	ReturnIfFailed(dwIce, 1000, qValidation.OpenExecute(hDatabase, 0, sqlConditionType::szSQL));
		
	// Enumerate all columns of type condition
	while(ERROR_SUCCESS == (iStat = qValidation.Fetch(&hResultRec)))
	{
		PMSIHANDLE	hKeyRec;
		PMSIHANDLE	hDataRec;
		DWORD		cPrimaryKeys;
		TCHAR		szTableName[255];
		TCHAR		szColumnName[255];
		DWORD		cTableName = 255;
		DWORD		cColumnName = 255;
		
		// Retrieve the table and the column name from the record.
		ReturnIfFailed(dwIce, 1001, ::MsiRecordGetString(hResultRec, 1, szTableName, &cTableName));
		ReturnIfFailed(dwIce, 1002, ::MsiRecordGetString(hResultRec, 2, szColumnName, &cColumnName));
	
		// Check to see if this table exists.
		if(!IsTablePersistent(FALSE, hInstall, hDatabase, dwIce, szTableName))
		{
			continue;
		}

		// Get the primary keys and form a query for the column names.
		::MsiDatabaseGetPrimaryKeys(hDatabase, szTableName, &hKeyRec);
		cPrimaryKeys = ::MsiRecordGetFieldCount(hKeyRec);

		// Build up the columns for the SQL query in Template.
		TCHAR szTemplate[255] = TEXT("");
		_tcscpy(szTemplate, TEXT("`[1]`"));
		TCHAR szTemp[10];
		for(int i=2; i <= cPrimaryKeys; i++)
		{
			_stprintf(szTemp, TEXT(", `[%d]`"), i);
			_tcscat(szTemplate, szTemp);
		}

		// use the formatrecord API to fill in all of the data values in the SQL query.
		::MsiRecordSetString(hKeyRec, 0, szTemplate);
		if(ERROR_MORE_DATA == ::MsiFormatRecord(hInstall, hKeyRec, pQuery, &cQuery)) {
			delete [] pQuery;
			pQuery = new TCHAR[++cQuery];
			OUT_OF_MEMORY_RETURN(dwIce, pQuery);
			ReturnIfFailed(dwIce, 1003, ::MsiFormatRecord(hInstall, hKeyRec, pQuery, &cQuery));
		}

		// retrieve the records. if error, move on to the next table
		CQuery qData;
		if(ERROR_SUCCESS != qData.OpenExecute(hDatabase,
											  0,
											  TEXT("SELECT `%s`, %s FROM `%s` WHERE `%s` IS NOT NULL"),
											  szColumnName,
											  pQuery,
											  szTableName,
											  szColumnName))
		{
			pErrFunc(hInstall, CONDITION_ERR_TABLE_ACCESS, hResultRec);
			continue;
		}

		while(ERROR_SUCCESS == (iStat = qData.Fetch(&hDataRec)))
		{
			// retrieve the string
			if(ERROR_MORE_DATA == (iStat = ::MsiRecordGetStringW(hDataRec, 1, pData, &cData)))
			{
				delete [] pData;
				pData = new WCHAR[++cData];
				OUT_OF_MEMORY_RETURN(dwIce, pData);
				iStat = ::MsiRecordGetStringW(hDataRec, 1, pData, &cData);
			}
			if(ERROR_SUCCESS != iStat)
			{
				APIErrorOut(hInstall, iStat, dwIce, 1005);
				return ERROR_SUCCESS;
			}

			WCHAR*	pState = pData;
			const WCHAR*	pToken = NULL;
			CONDITION_ENUMERATOR_SYMBOLTYPE	iType;
			while(pToken = ParseCondition(&pState, iType))
			{
				pCheckFunc(hInstall, hDatabase, hDataRec, iType, cPrimaryKeys, pToken, szTableName, szColumnName);
			}
		}
		if(iStat != ERROR_NO_MORE_ITEMS)
		{
			pErrFunc(hInstall, CONDITION_ERR_FETCH_DATA, hResultRec);
			continue;
		}
	}

	qValidation.Close();

	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
//	ICE78 -- Verifies that AdvtUISequence table either does not exist or
//			is empty.

// not shared with merge module subset
#ifndef MODSHAREDONLY
ICE_QUERY1(qIce78AdvtUISequence, "SELECT `AdvtUISequence`.`Action` FROM `AdvtUISequence`", Action);
ICE_ERROR(Ice78AdvtUISequenceNotEmpty, 78, ietError, "Action '[1]' found in AdvtUISequence table. No UI is allowed during advertising. Therefore AdvtUISequence table must be empty or not present.", "AdvtUISequence\tAction\t[1]");

ICE_FUNCTION_DECLARATION(78)
{
	UINT	iStat;
	

	// display info
	DisplayInfo(hInstall, 78);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// Return success if do not have AdvtUISequence table.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 78, TEXT("AdvtUISequence")))
		return ERROR_SUCCESS;

	CQuery qAdvt;
	ReturnIfFailed(78, 1, qAdvt.OpenExecute(hDatabase, 0, qIce78AdvtUISequence::szSQL));
	PMSIHANDLE hRecAction;
	
	while(ERROR_SUCCESS == (iStat = qAdvt.Fetch(&hRecAction)))
	{
		ICEErrorOut(hInstall, hRecAction, Ice78AdvtUISequenceNotEmpty);
	}
	if(ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 78, 2);
	}

	return ERROR_SUCCESS;
}
#endif

///////////////////////////////////////////////////////////////////////////////
// ICE79 -- Verifies that references to component and feature in conditions
//			are valid. This could be an addition to ICE46, but since ICE46 is
//			a logo validator, we have to create a new ICE. A part of the code
//			from ICE46 is reused here.

// Not shared with merge module
#ifndef MODSHAREDONLY

// Query for a component in the Component table.
ICE_QUERY0(Ice79ValidComponent, "SELECT `Component` FROM `Component` WHERE `Component` = '%s'");
// Query for a feature in the Feature table.
ICE_QUERY0(Ice79ValidFeature, "SELECT `Feature` FROM `Feature` WHERE `Feature` = '%s'");

// Warning: Validation table is missing.
ICE_ERROR(Ice79MissingValidation, 79, ietWarning, "Database is missing _Validation table. Could not completely check property names.", "_Validation");
// Warning: Feature or Component table is missing.
ICE_ERROR(Ice79MissingComponentTable, 79, ietWarning, "Component table must exist for this ICE to work and it is missing.", "");
ICE_ERROR(Ice79MissingFeatureTable, 79, ietWarning, "Feature table must exist for this ICE to work and it is missing.", "");
// Warning: Can not access a table.
ICE_ERROR(Ice79TableAccessError, 79, ietWarning, "Error retrieving values from column [2] in table [1]. Skipping Column.", "[1]"); 
// Warning: Can not fetch data from a table.
ICE_ERROR(Ice79TableFetchData, 79, ietWarning, "Error retrieving data from table [1]. Skipping table.", "[1]"); 
// Error: Invalid component reference in a condition.
ICE_ERROR(Ice79InvalidComponent, 79, ietError, "Component '%ls' referenced in column '%s'.'%s' of row %s is invalid.", "%s\t%s\t%s"); 
// Error: Invalid feature reference in a condition.
ICE_ERROR(Ice79InvalidFeature, 79, ietError, "Feature '%ls' referenced in column '%s'.'%s' of row %s is invalid.", "%s\t%s\t%s"); 

// These 2 variables keep track of whether or not we have checked the
// persistency of Component and Feature table. If their values are 0,
// they haven't been initialized. If 1, they have been initialized and the
// table does exist. 2 means that they have been initialized and the table
// does not exist.
static int dwComponentTable = 0;
static int dwFeatureTable = 0;

// Function to check for validity of components and features.
DWORD Ice79Check(MSIHANDLE hInstall, MSIHANDLE hDatabase, MSIHANDLE hDataRec, CONDITION_ENUMERATOR_SYMBOLTYPE Type, DWORD cPrimaryKeys, const WCHAR* pSymbol, const TCHAR* pTableName, const TCHAR* pColumnName)
{
	if(Type == CONDITION_ENUMERATOR_COMPONENT)
	{
		// Check for invalid component.
		CQuery		qComponent;
		UINT		iErr;
		PMSIHANDLE	hComponent;

		if(dwComponentTable == 0)
		{
			dwComponentTable = 1;
			
			// If missing Component table then can not validate.
			if(!IsTablePersistent(FALSE, hInstall, hDatabase, 79, TEXT("Component")))
			{
				dwComponentTable = 2;
				PMSIHANDLE hRec = ::MsiCreateRecord(1);
				ICEErrorOut(hInstall, hRec, Ice79MissingComponentTable);
				return ERROR_SUCCESS;
			}
		}
		else if(dwComponentTable == 2)
		{
			return ERROR_SUCCESS;
		}

		if((iErr = qComponent.FetchOnce(hDatabase, 0, &hComponent, Ice79ValidComponent::szSQL, pSymbol)) == ERROR_NO_MORE_ITEMS)
		{
			// Not valid Component.
			TCHAR szRowName[255] = TEXT("");
			TCHAR szKeys[255] = TEXT("");

			// build up the columns for the user-readable string in szRowName
			// and the tab-delimited string in szKeys.
			_tcscpy(szRowName, TEXT("'[2]'"));
			_tcscpy(szKeys, TEXT("[2]"));
			TCHAR szTemp[10];
			for (int i=2; i <= cPrimaryKeys; i++)
			{
				_stprintf(szTemp, TEXT(".'[%d]'"), i+1);
				_tcscat(szRowName, szTemp);
				_stprintf(szTemp, TEXT("\t[%d]"), i+1);
				_tcscat(szKeys, szTemp);
			}
			ICEErrorOut(hInstall, hDataRec, Ice79InvalidComponent, pSymbol, pTableName, pColumnName, szRowName,
				pTableName, pColumnName, szKeys);
		}
		else if(iErr != ERROR_SUCCESS)
		{
			APIErrorOut(hInstall, iErr, 79, 1);
		}
		qComponent.Close();
	}
	else if(Type == CONDITION_ENUMERATOR_FEATURE)
	{
		// Check for invalid feature.
		CQuery		qFeature;
		UINT		iErr;
		PMSIHANDLE	hFeature;

		if(dwFeatureTable == 0)
		{
			dwFeatureTable = 1;
			
			// If missing Feature table then can not validate.
			if(!IsTablePersistent(FALSE, hInstall, hDatabase, 79, TEXT("Feature")))
			{
				dwFeatureTable = 2;
				PMSIHANDLE hRec = ::MsiCreateRecord(1);
				ICEErrorOut(hInstall, hRec, Ice79MissingFeatureTable);
				return ERROR_SUCCESS;
			}
		}
		else if(dwFeatureTable == 2)
		{
			return ERROR_SUCCESS;
		}

		if((iErr = qFeature.FetchOnce(hDatabase, 0, &hFeature, Ice79ValidFeature::szSQL, pSymbol)) == ERROR_NO_MORE_ITEMS)
		{
			// Invalid feature.
			TCHAR szRowName[255] = TEXT("");
			TCHAR szKeys[255] = TEXT("");

			// build up the columns for the user-readable string in szRowName
			// and the tab-delimited string in szKeys.
			_tcscpy(szRowName, TEXT("'[2]'"));
			_tcscpy(szKeys, TEXT("[2]"));
			TCHAR szTemp[10];
			for (int i=2; i <= cPrimaryKeys; i++)
			{
				_stprintf(szTemp, TEXT(".'[%d]'"), i+1);
				_tcscat(szRowName, szTemp);
				_stprintf(szTemp, TEXT("\t[%d]"), i+1);
				_tcscat(szKeys, szTemp);
			}

			ICEErrorOut(hInstall, hDataRec, Ice79InvalidFeature, pSymbol, pTableName, pColumnName, szRowName,
				pTableName, pColumnName, szKeys);
		}
		else if(iErr != ERROR_SUCCESS)
		{
			APIErrorOut(hInstall, iErr, 79, 2);
		}
		qFeature.Close();
	}

	return ERROR_SUCCESS;
}

DWORD Ice79Err(MSIHANDLE hInstall, CONDITION_ERR_ENUM Type, MSIHANDLE hRec)
{
	switch(Type)
	{
	case CONDITION_ERR_TABLE_ACCESS:

		ICEErrorOut(hInstall, hRec, Ice79TableAccessError);
		break;

	case CONDITION_ERR_FETCH_DATA:

		ICEErrorOut(hInstall, hRec, Ice79TableFetchData);
		break;

	default:
		break;
	};

	return ERROR_SUCCESS;
}

ICE_FUNCTION_DECLARATION(79)
{
	UINT iStat;


	// display info
	DisplayInfo(hInstall, 79);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// Find all condition columns in the _Validation table.
	if(IsTablePersistent(FALSE, hInstall, hDatabase, 79, TEXT("_Validation")))
	{
		ConditionEnumerator(hInstall, hDatabase, 79, Ice79Check, Ice79Err);
	}
	else
	{
		PMSIHANDLE hRec = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRec, Ice79MissingValidation);
	}

	return ERROR_SUCCESS;
}

#endif


///////////////////////////////////////////////////////////////////////////////
// ICE80 -- Verifies that Template Summary Property correctly contains Intel64
//			or Intel according to the presence of 64 bit components,
//			custom action scripts, Properties & RegLocator entries.
//			Also verifies that the 64bit components uses only 64bit entries 
//			for both directories and environment values in Environment table, 
//			Registry table & Shortcuts table.
//			Also verifies that the language ID specified by the ProductLanguage
//			property is contained in the Template Summary Property stream.
//			

// Not shared with merge module
#ifndef MODSHAREDONLY

UINT GetSummaryInfoPropertyString(MSIHANDLE hSummaryInfo, UINT uiProperty, UINT &puiDataType, LPTSTR *szValueBuf, DWORD &cchValueBuf);

// Query for all components.
ICE_QUERY3(sqlIce80Components, "SELECT `Component`, `Attributes`, `Directory_` FROM `Component`", Component, Attributes, Directory_);
// Query for all custom actions.
ICE_QUERY2(sqlIce80CAs, "SELECT `Action`, `Type` FROM `CustomAction`", Action, Type);
ICE_QUERY1(sqlIce80Property, "SELECT `Property` FROM `Property` WHERE `Property` = 'System64Folder' OR `Property` = 'ProgramFiles64Folder' OR `Property` = 'CommonFiles64Folder'", Property);
ICE_QUERY1(sqlIce80RegLocator, "SELECT `Signature_` FROM `RegLocator` WHERE `Type` >= %d", Signature);
ICE_QUERY1(sqlIce80Directory, "SELECT `Directory_Parent` FROM `Directory` WHERE `Directory` = '%s'", Directory_Parent);
ICE_QUERY2(sqlIce80Environment, "SELECT `Value`, `Environment` FROM `Environment` WHERE `Component_` = '%s'", Value, Environment);
ICE_QUERY2(sqlIce80Registry, "SELECT `Value`, `Registry` FROM `Registry` WHERE `Component_` = '%s'", Value, Registry);
ICE_QUERY2(sqlIce80Shortcut, "SELECT `Arguments`, `Shortcut` FROM `Shortcut` WHERE `Component_` = '%s'", Arguments, Shortcut);
ICE_QUERY2(sqlIce80ProductLanguage, "SELECT `Property`, `Value` FROM `Property` WHERE `Property` = 'ProductLanguage'", Property, Value);

// Error
ICE_ERROR(Ice8064bitComponent, 80, ietError, "This package contains 64 bit component '[1]' but the Template Summary Property does not contain Intel64.", "Component\tAttributes\t[1]");
ICE_ERROR(Ice8064bitCAScript, 80, ietError, "This package contains 64 bit custom action script '[1]' but the Template Summary Property does not contain Intel64.", "CustomAction\tAction\t[1]");
ICE_ERROR(Ice80BadSummaryProperty, 80, ietError, "Bad value in Summary Information Stream for %s.","_SummaryInfo\t%d");
ICE_ERROR(Ice80WrongSchema, 80, ietError, "This package is marked with Intel64 but it has a schema less than 150.", "_SummaryInfo\t%d");
ICE_ERROR(Ice8032BitPkgUsing64BitProp, 80, ietWarning, "This 32Bit Package is using 64 bit property [1]", "Property\tProperty\t[1]");
ICE_ERROR(Ice8032BitPkgUsing64BitLocator, 80, ietWarning, "This 32Bit Package is using 64 bit Locator Type in RegLocator table entry [1]", "RegLocator\tType\t[1]");
ICE_ERROR(Ice80Wrong32BitDirectory, 80, ietError, "This 64BitComponent [1] uses 32BitDirectory [3]", "Component\tDirectory_\t[1]");
ICE_ERROR(Ice80Wrong64BitDirectory, 80, ietError, "This 32BitComponent [1] uses 64BitDirectory [3]", "Component\tDirectory_\t[1]");
ICE_ERROR(Ice80ProductLanguage, 80, ietError, "The 'ProductLanguage' property in the Property table has a value of '[2]', which is not contained in the Template Summary Property stream.", "Property\tValue\t[1]");

typedef enum 
{
	DIRTYPE_NONE,
	DIRTYPE_32BIT,
	DIRTYPE_64BIT
} DIRTYPE;


// Please keep the environment entries in all CAPs since the comparison is
// case insensitive, the string to be compared is converted to uppercase before 
// checking.
static const	TCHAR *WrongEnvFor32BitComp[] = 
{
	TEXT("[%PROGRAMFILES]"),
	TEXT("[%COMMONPROGRAMFILES]"),
	TEXT("[%WINDIR]\\SYSTEM32"),
	TEXT("[%WINROOT]\\SYSTEM32"),
	TEXT("[%SYSTEMROOT]\\SYSTEM32")
};

static const TCHAR *WrongEnvFor64BitComp[] = 
{
	TEXT("[%PROGRAMFILES(X86)]"),
	TEXT("[%COMMONPROGRAMFILES(X86)]"),
	TEXT("[%WINDIR]\\SYSWOW64"),
	TEXT("[%WINROOT]\\SYSWOW64"),
	TEXT("[%SYSTEMROOT]\\SYSWOW64")
};

static const TCHAR *WrongEnvFor32BitCompIn32BitPkg[] = 
{
	TEXT("[%PROGRAMFILES(X86)]"),
	TEXT("[%COMMONPROGRAMFILES(X86)]"),
	TEXT("[%WINDIR]\\SYSWOW64"),
	TEXT("[%WINROOT]\\SYSWOW64"),
	TEXT("[%SYSTEMROOT]\\SYSWOW64")
};

// Properties - Case sensitive
static const	TCHAR *WrongPropFor32BitComp[] = 
{
	TEXT("[ProgramFiles64Folder]"),
	TEXT("[CommonFiles64Folder]"),
	TEXT("[System64Folder]"),
};

static const	TCHAR *WrongPropFor64BitComp[] = 
{
	TEXT("[ProgramFilesFolder]"),
	TEXT("[CommonFilesFolder]"),
	TEXT("[SystemFolder]"),
};

typedef enum 
{
	CHKENVIRONMENT = 0,
	CHKPROPERTY,
	CHK32BITPKGENV,
	MAX_CRIT
} CHKCRIT;

typedef struct _TABLEINFO
{
	TCHAR*		szTableName;
	BOOL		fTableExist;
	BOOL		fCaseSensitive;
	TCHAR*		szSql;
	UINT		col;		// Column to the string to be checked
	TCHAR		*szLocation;
	TCHAR		*szErrMsgFor32BitComp;
	TCHAR		*szErrMsgFor64BitComp;
	TCHAR		**szListFor32BitComp;
	TCHAR		**szListFor64BitComp;
	DWORD		dwListEntries;
} TABLEINFO;

static TABLEINFO EnvTableInfo[] =
{
	{
		TEXT("Environment"), 
		FALSE,
		FALSE,
		(TCHAR *)sqlIce80Environment::szSQL, 
		sqlIce80Environment::Value, 
		TEXT("Environment\tValue\t[2]"),
		TEXT("This Environment [2] entry uses 64BitEnvironment Value [1] in Environment table for a 32BitComponent "),
		TEXT("This Environment [2] entry uses 32BitEnvironment Value [1] in Environment table for a 64bit component"), 
		(TCHAR **)WrongEnvFor32BitComp,
		(TCHAR **)WrongEnvFor64BitComp,
		(sizeof(WrongEnvFor64BitComp)/sizeof(TCHAR *))
	},
	{	
		TEXT("Registry"), 
		FALSE,
		FALSE,
		(TCHAR *)sqlIce80Registry::szSQL, 
		sqlIce80Registry::Value, 
		TEXT("Registry\tValue\t[2]"),
		TEXT("This Registry [2] entry uses 64BitEnvironment Value [1] in Registry table for a 32BitComponent "),
		TEXT("This Registry [2] entry uses 32BitEnvironment Value [1] in Registry table for a 64BitComponent "),
		(TCHAR **)WrongEnvFor32BitComp,
		(TCHAR **)WrongEnvFor64BitComp,
		sizeof(WrongEnvFor64BitComp)/sizeof(TCHAR *)
	},
	{	
		TEXT("Shortcut"), 
		FALSE,
		FALSE,
		(TCHAR *)sqlIce80Shortcut::szSQL, 
		sqlIce80Shortcut::Arguments, 
		TEXT("Shortcut\tArguments\t[2]"),
		TEXT("This Shortcuts [2] entry uses 64BitEnvironment Value [1] in Shortcut table - Arguments column for a 32BitComponent "),
		TEXT("This Shortcuts [2] entry uses 32BitEnvironment Value [1] in Shortcut table - Arguments column for a 64BitComponent "),
		(TCHAR **)WrongEnvFor32BitComp,
		(TCHAR **)WrongEnvFor64BitComp,
		sizeof(WrongEnvFor64BitComp)/sizeof(TCHAR *)
	},
	{	
		NULL, 
		FALSE,
		FALSE,
		NULL, 
		0, 
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		0
	}
};

static TABLEINFO PropTableInfo[] =
{
	{
		TEXT("Environment"), 
		FALSE,
		TRUE,
		(TCHAR *)sqlIce80Environment::szSQL, 
		sqlIce80Environment::Value, 
		TEXT("Environment\tValue\t[2]"),
		TEXT("This Environment [2] entry uses 64Bit Propery Value [1] in Environment table for a 32BitComponent "),
		TEXT("This Environment [2] entry uses 32BitProperty Value [1] in Environment table for a 64bit component"),
		(TCHAR **)WrongPropFor32BitComp,
		(TCHAR **)WrongPropFor64BitComp,
		(sizeof(WrongPropFor64BitComp)/sizeof(TCHAR *))
	},
	{	
		TEXT("Registry"), 
		FALSE,
		TRUE,
		(TCHAR *)sqlIce80Registry::szSQL, 
		sqlIce80Registry::Value, 
		TEXT("Registry\tValue\t[2]"),
		TEXT("This Registry [2] entry uses 64Bit Property Value [1] in Registry table for a 32BitComponent "),
		TEXT("This Registry [2] entry uses 32Bit Property Value [1] in Registry table for a 64BitComponent "),
		(TCHAR **)WrongPropFor32BitComp,
		(TCHAR **)WrongPropFor64BitComp,
		(sizeof(WrongPropFor64BitComp)/sizeof(TCHAR *))
	},
	{	
		TEXT("Shortcut"), 
		FALSE,
		TRUE,
		(TCHAR *)sqlIce80Shortcut::szSQL, 
		sqlIce80Shortcut::Arguments, 
		TEXT("Shortcut\tArguments\t[2]"),
		TEXT("This Shortcuts [2] entry uses 64Bit Property Value [1] in Shortcut table - Arguments column for a 32BitComponent "),
		TEXT("This Shortcuts [2] entry uses 32Bit Property Value [1] in Shortcut table - Arguments column for a 64BitComponent "),
		(TCHAR **)WrongPropFor32BitComp,
		(TCHAR **)WrongPropFor64BitComp,
		(sizeof(WrongPropFor64BitComp)/sizeof(TCHAR *))
	},
	{	
		NULL, 
		FALSE,
		FALSE,
		NULL, 
		0, 
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		0
	}
};

static TABLEINFO EnvTableInfoFor32BitPkg[] =
{
	{
		TEXT("Environment"), 
		FALSE,
		FALSE,
		(TCHAR *)sqlIce80Environment::szSQL, 
		sqlIce80Environment::Value, 
		TEXT("Environment\tValue\t[2]"),
		TEXT("This Environment [2] entry uses Environment Value [1] reserved for 64Bit system in the Environment table for a 32BitComponent "),
		NULL, 
		(TCHAR **)WrongEnvFor32BitCompIn32BitPkg,
		NULL,
		(sizeof(WrongEnvFor32BitCompIn32BitPkg)/sizeof(TCHAR *))
	},
	{	
		TEXT("Registry"), 
		FALSE,
		FALSE,
		(TCHAR *)sqlIce80Registry::szSQL, 
		sqlIce80Registry::Value, 
		TEXT("Registry\tValue\t[2]"),
		TEXT("This Registry [2] entry uses 64BitEnvironment Value [1] in Registry table for a 32BitComponent "),
		NULL,
		(TCHAR **)WrongEnvFor32BitCompIn32BitPkg,
		NULL,
		(sizeof(WrongEnvFor32BitCompIn32BitPkg)/sizeof(TCHAR *))
	},
	{	
		TEXT("Shortcut"), 
		FALSE,
		FALSE,
		(TCHAR *)sqlIce80Shortcut::szSQL, 
		sqlIce80Shortcut::Arguments, 
		TEXT("Shortcut\tArguments\t[2]"),
		TEXT("This Shortcuts [2] entry uses 64BitEnvironment Value [1] in Shortcut table - Arguments column for a 32BitComponent "),
		NULL,
		(TCHAR **)WrongEnvFor32BitCompIn32BitPkg,
		NULL,
		(sizeof(WrongEnvFor32BitCompIn32BitPkg)/sizeof(TCHAR *))
	},
	{	
		NULL, 
		FALSE,
		FALSE,
		NULL, 
		0, 
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		0
	}
};

// Utility for ICE80
UINT CheckCriteria(MSIHANDLE hInstall, MSIHANDLE hDatabase, 
						TCHAR *pszComponent, CHKCRIT crit, BOOL fComp64Bit)
{
	
	TCHAR*	pszStr = new TCHAR[MAX_PATH];
	OUT_OF_MEMORY_RETURN(80, pszStr);
	UINT	iStat = ERROR_SUCCESS;

	DWORD		dwSize = MAX_PATH-2;
	PMSIHANDLE	hRec = NULL;
	CQuery		query;
	UINT		i, j;
	ErrorInfo_t err = {80, ietWarning, NULL, NULL};
	TABLEINFO	*ctTableInfo = EnvTableInfo;

	switch(crit)
	{
		case CHKPROPERTY:
		{
			err.iType = ietError;
			ctTableInfo = PropTableInfo;
			break;
		}
		case CHK32BITPKGENV:
		{
			ctTableInfo = EnvTableInfoFor32BitPkg;
			if(fComp64Bit)
			{
				goto Exit;
			}
			break;
		}
		default:
			break;
	}
	
	for(j=0; ctTableInfo[j].szTableName; j++)
	{
		if(ctTableInfo[j].fTableExist == FALSE)
		{
			continue;		// Go for next entry
		}
		err.szLocation = ctTableInfo[j].szLocation; 
		query.Close();
		iStat = query.OpenExecute(hDatabase, 0, ctTableInfo[j].szSql, pszComponent);
		if(iStat)
		{
			APIErrorOut(hInstall, iStat, 80, __LINE__);
			goto Exit;
		}
		while(ERROR_SUCCESS == (iStat = query.Fetch(&hRec)))
		{
			iStat = IceRecordGetString(hRec, ctTableInfo[j].col, 
											&pszStr, &dwSize, NULL);
			if(iStat != ERROR_SUCCESS)			
			{
				APIErrorOut(hInstall, iStat, 80, __LINE__);
				goto Exit;
			}
	
			if(!*pszStr)
				continue;		// null string
		
			if(!ctTableInfo[j].fCaseSensitive)
			{
				pszStr = _tcsupr(pszStr);
			}

			if(!fComp64Bit)		// 32 bit component
			{
				for(i=0; i<ctTableInfo[j].dwListEntries; i++)
				{
					if(_tcsstr(pszStr, ctTableInfo[j].szListFor32BitComp[i]))
					{
						err.szMessage = 
								ctTableInfo[j].szErrMsgFor32BitComp; 
						ICEErrorOut(hInstall, hRec, err);
						break;
					}
			} 
			} 
			else					// 64bit component
			{
				for(i=0; i<ctTableInfo[j].dwListEntries; i++)
				{
					if(_tcsstr(pszStr, ctTableInfo[j].szListFor64BitComp[i]))
					{
						err.szMessage = 
								ctTableInfo[j].szErrMsgFor64BitComp; 
						ICEErrorOut(hInstall, hRec, err);
						break;
					}
				} 
			} 
		}
		if(iStat != ERROR_NO_MORE_ITEMS)			
		{
			APIErrorOut(hInstall, iStat, 80, __LINE__);
			goto Exit;
		}
	}
	iStat = ERROR_SUCCESS;

Exit:
	DELETE_IF_NOT_NULL(pszStr);
	return iStat;
}

UINT CheckTargetPath(MSIHANDLE hInstall, MSIHANDLE hDatabase, 
								TCHAR **ppszStr, DWORD *pdwSize, 
								DIRTYPE *pdirType)
{
	UINT	iStat = ERROR_SUCCESS;

	PMSIHANDLE	hRec = NULL;
	CQuery		query;
	
	
	if(!pdirType)
	{
		goto Exit;			// Can't return the result, so why bother ?
	}
	
	*pdirType = DIRTYPE_NONE;	

	if(		!_tcscmp((*ppszStr), TEXT("ProgramFiles64Folder")) 
		||	!_tcscmp((*ppszStr), TEXT("CommonFiles64Folder"))
		||	!_tcscmp((*ppszStr), TEXT("System64Folder")) 
	)
	{
		*pdirType = DIRTYPE_64BIT;
	}
	else if(!_tcscmp((*ppszStr), TEXT("ProgramFilesFolder")) 
		||	!_tcscmp((*ppszStr), TEXT("CommonFilesFolder"))
		||	!_tcscmp((*ppszStr), TEXT("SystemFolder")) 
	)
	{
		*pdirType = DIRTYPE_32BIT;
	}
	else	// none of the special props
	{		// go down in the Directory table recursively.
		iStat = query.FetchOnce(hDatabase, NULL, &hRec, 
										sqlIce80Directory::szSQL, (*ppszStr));
		if(iStat == ERROR_SUCCESS)
		{
			iStat = IceRecordGetString(hRec, 
						sqlIce80Directory::Directory_Parent,
						ppszStr,	pdwSize, NULL);
			if(iStat)
				{
				APIErrorOut(hInstall, iStat, 80, __LINE__);
				goto Exit;
				}
			iStat = CheckTargetPath(hInstall, hDatabase, 
										ppszStr, pdwSize, pdirType);
			if(iStat)
				{
				APIErrorOut(hInstall, iStat, 80, __LINE__);
				goto Exit;
				}
		}
		else if(iStat == ERROR_NO_MORE_ITEMS)
		{
			iStat = ERROR_SUCCESS;
		}
		else
		{
			APIErrorOut(hInstall, iStat, 80, __LINE__);
			goto Exit;
		}
	}
	
Exit:
	return iStat;
}


ICE_FUNCTION_DECLARATION(80)
{
	TCHAR*		pTemplate = new TCHAR[MAX_PATH];
	OUT_OF_MEMORY_RETURN(80, pTemplate);
	TCHAR*		pszStr = new TCHAR[MAX_PATH];

	UINT		iStat = ERROR_SUCCESS;		// Return code.
	PMSIHANDLE	hSummaryInfo;
	UINT		iType;
	int			iValue;
	FILETIME	ft;
	DWORD		dwTemplate = MAX_PATH-1;
	DWORD		cchSizeStr = MAX_PATH-1;
	CQuery		query;
	CQuery		queryComponentDir;
	PMSIHANDLE	hRec;
	BOOL		bIntel64 = FALSE;
	DIRTYPE		dirType = DIRTYPE_NONE;
	DWORD		dwIntel64Len = _tcslen(IPROPNAME_INTEL64);
	PMSIHANDLE	hErrorRec = ::MsiCreateRecord(1);	// dummy for error out.
	BOOL		bNoComponentTable = FALSE;
	BOOL		bNoCATable = FALSE;
	BOOL		bNoPropertyTable = FALSE;
	BOOL		bNoRegLocatorTable = FALSE;
	BOOL		bNoDirectoryTable = FALSE;

	
	// display info
	DisplayInfo(hInstall, 80);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// Check out of memory.
	if(!pTemplate)
	{
		APIErrorOut(hInstall, ERROR_NOT_ENOUGH_MEMORY, 80, 1);
		goto Exit;
	}

	// if there is no component table or CustomAction table, return.
	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 80, TEXT("Component")))
	{
		bNoComponentTable = TRUE;
	}
	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 80, TEXT("CustomAction")))
	{
		bNoCATable = TRUE;
	}
	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 80, TEXT("Property")))
	{
		bNoPropertyTable = TRUE;
	}
	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 80, TEXT("RegLocator")))
	{
		bNoRegLocatorTable = TRUE;
	}
	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 80, TEXT("Directory")))
	{
		bNoDirectoryTable = TRUE;
	}
	for(iValue=0; EnvTableInfo[iValue].szTableName; iValue++)
	{
		EnvTableInfo[iValue].fTableExist = IsTablePersistent(FALSE, hInstall, 
							hDatabase, 80,  EnvTableInfo[iValue].szTableName);
	}
	for(iValue=0; PropTableInfo[iValue].szTableName; iValue++)
	{
		PropTableInfo[iValue].fTableExist = IsTablePersistent(FALSE, hInstall, 
							hDatabase, 80,  PropTableInfo[iValue].szTableName);
	}
	for(iValue=0; EnvTableInfoFor32BitPkg[iValue].szTableName; iValue++)
	{
		EnvTableInfoFor32BitPkg[iValue].fTableExist = IsTablePersistent(
						FALSE, hInstall, hDatabase, 80,  
						EnvTableInfoFor32BitPkg[iValue].szTableName);
	}
	if(bNoComponentTable && bNoCATable && bNoPropertyTable && 
												bNoRegLocatorTable)
	{
		goto Exit;
	}
	
	// Get the Template Summary Property.
	iStat = ::MsiGetSummaryInformation(hDatabase, NULL, 0, &hSummaryInfo);
	if(iStat)
		{
		APIErrorOut(hInstall, iStat, 80, __LINE__);
		goto Exit;
		}

	iStat = GetSummaryInfoPropertyString(hSummaryInfo, PID_TEMPLATE, iType, &pTemplate, dwTemplate);
	if(iStat)
	{
		APIErrorOut(hInstall, iStat, 80, __LINE__);
		goto Exit;
	}

	if(iType != VT_LPSTR || *pTemplate == TEXT('\0'))
	{
		ICEErrorOut(hInstall, hErrorRec, Ice80BadSummaryProperty, TEXT("PID_TEMPLATE"), PID_TEMPLATE);
		goto Exit;
	}

	// Is this a 64 bit package according to it's summary info stream?
	if(dwTemplate >= dwIntel64Len)
	{
		if(_tcsncmp(pTemplate, IPROPNAME_INTEL64, dwIntel64Len) == 0)
		{
			bIntel64 = TRUE;
		}
	}
	
	// If this is a 64 bit package, make sure it has a schema greater than or
	// equal to 150.
	dwTemplate = 0;
	iStat = ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_PAGECOUNT, &iType, &iValue, &ft, TEXT(""), &dwTemplate);
	if(iStat)
	{
		APIErrorOut(hInstall, iStat, 80, __LINE__);
		goto Exit;
	}
	if(iType != VT_I4)
	{
		ICEErrorOut(hInstall, hErrorRec, Ice80BadSummaryProperty, TEXT("PID_PAGECOUNT"), PID_PAGECOUNT);
		goto Exit;
	}
	if(bIntel64 && iValue < 150)
	{
		ICEErrorOut(hInstall, hErrorRec, Ice80WrongSchema, PID_PAGECOUNT);
	}

	// Check all the components.
	if(bNoComponentTable == FALSE)
	{
		iStat = query.OpenExecute(hDatabase, NULL, sqlIce80Components::szSQL);
		if(iStat)
		{
			APIErrorOut(hInstall, iStat, 80, __LINE__);
			goto Exit;
		}
		while(ERROR_SUCCESS == (iStat = query.Fetch(&hRec)))
		{
			UINT	iAttr = ::MsiRecordGetInteger(hRec, sqlIce80Components::Attributes);

			iStat = IceRecordGetString(hRec,	sqlIce80Components::Directory_,
						&pszStr,	&cchSizeStr, NULL);
			if(iStat != ERROR_SUCCESS)			
			{
				APIErrorOut(hInstall, iStat, 80, __LINE__);
				goto Exit;
			}
			if(bNoDirectoryTable == FALSE)
			{
				iStat = CheckTargetPath(hInstall, hDatabase, &pszStr, &cchSizeStr, &dirType);
				if(iStat != ERROR_SUCCESS)			
				{
					APIErrorOut(hInstall, iStat, 80, __LINE__);
					goto Exit;
				}
			}

			if(iAttr & msidbComponentAttributes64bit)
			{
				if(bIntel64 == FALSE)
				{
					// Not a 64 bit package
					ICEErrorOut(hInstall, hRec, Ice8064bitComponent);
				}
				if(dirType == DIRTYPE_32BIT)	// Incompatible
				{
					ICEErrorOut(hInstall, hRec, Ice80Wrong32BitDirectory);
				}
			}
			else
			{
				if(dirType == DIRTYPE_64BIT)	// Incompatible
				{
					ICEErrorOut(hInstall, hRec, Ice80Wrong64BitDirectory);
				}
			} 

			iStat = IceRecordGetString(hRec,	sqlIce80Components::Component,
						&pszStr,	&cchSizeStr, NULL);
			if(iStat != ERROR_SUCCESS)			
			{
				APIErrorOut(hInstall, iStat, 80, __LINE__);
				goto Exit;
			}

			if(bIntel64)	// Check Env values for 64bit package
			{
				iStat = CheckCriteria(hInstall, hDatabase, pszStr, 
								CHKENVIRONMENT, 
								(iAttr & msidbComponentAttributes64bit));
				if(iStat != ERROR_SUCCESS)			
				{
					APIErrorOut(hInstall, iStat, 80, __LINE__);
					goto Exit;
				}
			}
			else	// 32 Bit Pkg
			{
				iStat = CheckCriteria(hInstall, hDatabase, pszStr, 
												CHK32BITPKGENV, FALSE);
				if(iStat != ERROR_SUCCESS)			
				{
					APIErrorOut(hInstall, iStat, 80, __LINE__);
					goto Exit;
				}
			}
			iStat = CheckCriteria(hInstall, hDatabase, pszStr, 
								CHKPROPERTY, 
								(iAttr & msidbComponentAttributes64bit));
			if(iStat != ERROR_SUCCESS)			
			{
				APIErrorOut(hInstall, iStat, 80, __LINE__);
				goto Exit;
			}

		}
		query.Close();
		
		// Make sure that we stopped because there were no more items
		if (iStat != ERROR_NO_MORE_ITEMS)
		{
			APIErrorOut(hInstall, iStat, 80, __LINE__);
			goto Exit;
		}
	
	}


	// Check all the custom actions.
	if(bNoCATable == FALSE)
	{
		iStat = query.OpenExecute(hDatabase, NULL, sqlIce80CAs::szSQL);
		if(iStat)
		{
			APIErrorOut(hInstall, iStat, 80, __LINE__);
			goto Exit;
		} 
		while(ERROR_SUCCESS == (iStat = query.Fetch(&hRec)))
		{
			UINT	iCAType = ::MsiRecordGetInteger(hRec, sqlIce80CAs::Type);

			if(iCAType & msidbCustomActionType64BitScript)
			{
				if(bIntel64 == FALSE)
				{
					// Not a 64 bit package.
					ICEErrorOut(hInstall, hRec, Ice8064bitCAScript);
				}
			}
		}
		query.Close();
		
		// Make sure that we stopped because there were no more items
		if (iStat != ERROR_NO_MORE_ITEMS)
		{
			APIErrorOut(hInstall, iStat, 80, __LINE__);
			goto Exit;
		}
	}

	// Check all the Properties.
	if((bIntel64 == FALSE) && (bNoPropertyTable == FALSE))
	{
		iStat = query.OpenExecute(hDatabase, NULL, sqlIce80Property::szSQL);
		if(iStat)
		{
			APIErrorOut(hInstall, iStat, 80, __LINE__);
			goto Exit;
		}
		while(ERROR_SUCCESS == (iStat = query.Fetch(&hRec)))
		{
			ICEErrorOut(hInstall, hRec, Ice8032BitPkgUsing64BitProp);
		}
		query.Close();
		
		// Make sure that we stopped because there were no more items
		if (iStat != ERROR_NO_MORE_ITEMS)
		{
			APIErrorOut(hInstall, iStat, 80, __LINE__);
			goto Exit;
		}
	}

	// Check that the language specified by property ProductLanguage is listed
	// in the template summary stream.
	if(bNoPropertyTable == FALSE)
	{
		TCHAR*	pTmp = _tcschr(pTemplate, TEXT(';'));
		if(pTmp == NULL)
		{
			ICEErrorOut(hInstall, hErrorRec, Ice80BadSummaryProperty, TEXT("PID_TEMPLATE"), PID_TEMPLATE);
		}
		else
		{			
			if((iStat = query.FetchOnce(hDatabase, NULL, &hRec, sqlIce80ProductLanguage::szSQL)) != ERROR_SUCCESS)
			{
				APIErrorOut(hInstall, iStat, 80, __LINE__);
				goto Exit;
			}
			TCHAR*	pLanguage = new TCHAR[50];
			OUT_OF_MEMORY_RETURN(80, pLanguage);
			DWORD	dwLanguage = 50;

			if((iStat = IceRecordGetString(hRec, sqlIce80ProductLanguage::Value, &pLanguage, &dwLanguage, NULL)) != ERROR_SUCCESS)
			{
				APIErrorOut(hInstall, iStat, 80, __LINE__);
				goto Exit;
			}
			
			TCHAR* pTmp2 = pTmp;

            if((pTmp = _tcsstr(pTmp, pLanguage)) == NULL ||
			   ((*(pTmp -1) != TEXT(';')) && (*(pTmp - 1) != TEXT(','))) ||
			   ((*(pTmp + _tcslen(pLanguage)) != TEXT(',')) && (*(pTmp + _tcslen(pLanguage)) != TEXT('\0'))))
			{
				if(!(*(pTmp2 + 1) == '\0' || 
					 ((pTmp2 = _tcsstr(pTmp2, TEXT("0"))) != NULL && *(pTmp2 - 1) == TEXT(';') && *(pTmp2 + 1) == TEXT('\0'))))
                    ICEErrorOut(hInstall, hRec, Ice80ProductLanguage);
			}
			delete [] pLanguage;
		}
	}

	// Check all the RegLocator entries where Type >=	msidbLocatorType64Bit
	if((bIntel64 == FALSE) && (bNoRegLocatorTable == FALSE))
	{
		iStat = query.OpenExecute(hDatabase, NULL, sqlIce80RegLocator::szSQL, msidbLocatorType64bit);
		if(iStat)
		{
			APIErrorOut(hInstall, iStat, 80, __LINE__);
			goto Exit;
		}
		while(ERROR_SUCCESS == (iStat = query.Fetch(&hRec)))
		{
			ICEErrorOut(hInstall, hRec, Ice8032BitPkgUsing64BitLocator);
		}
		query.Close();
		
		// Make sure that we stopped because there were no more items
		if (iStat != ERROR_NO_MORE_ITEMS)
		{
			APIErrorOut(hInstall, iStat, 80, __LINE__);
			goto Exit;
		}
	}
Exit:

	if(pTemplate)
	{
		delete []pTemplate;
	}
	DELETE_IF_NOT_NULL(pszStr);
	return ERROR_SUCCESS;
}


#endif // MODSHAREDONLY

///////////////////////////////////////////////////////////////////////////////
//	ICE81 --	
//			A. To generate warnings on orphaned Digital Certificates
//
//			B. To generate errors when the signed object's entry is either 
//				missing or the cabinet col of the signed object's entry 
//				(in media table) has pound sign ('#') as prefix 
//				in the value.
//
//				The logic below is not in data centric style.
//				The BEST way could be to create a table similar to _validat
//				and the difference here can be that neither the source nor
//				the destination column has to be Primary key/Foreign key
//				And this routine will scan the destination table for atleast
//				one record containing the same value as in source col of a 
//				row in source table 
//
//				For scanning orphaned certs, the entries can be
//				SourceTable	=	MsiDigitalCertificate
//				SourceCol	=	DigitalCertificate
//				DestinationTable	=	MsiDigitalSignature
//				DestinationCol	=	3 (DigitalCertificate)
//				ErrorType	=	ietWarning
//			
//				We can even add qualifiers col to explain how the data has
//				tobe analysed.
//			
//				DataAssess		= Same as source entry OR
//								Prefix should be as specfied in Value col OR
//								Suffix should be as specfied in Value col OR
//								should be as specfied in Value col	OR
//								sub-string should be as specfied in Value col 
//				Value			= *	- Take the value in source col
//								= prefix/suffix/complete val/sub-string val
//									
// 
// 
//
//	Author :	RenukaM
//
// not shared with merge module subset

#ifndef MODSHAREDONLY

#define MyIceN 81

void Ice81_OrphanCertificates(MSIHANDLE hInstall, MSIHANDLE hDatabase, BOOL fSignTableExist);
void Ice81_ValidateDigitalSignature(MSIHANDLE hInstall, MSIHANDLE hDatabase);

ICE_FUNCTION_DECLARATION(81)
{
	PMSIHANDLE	hDatabase = 0;

	// display info
	DisplayInfo(hInstall, 81);

					// hInstall is passed in as arg - see 
					// ICE_FUNCTIO_DECLARATION's definition
	hDatabase =::MsiGetActiveDatabase(hInstall);

	if(0 != hDatabase)
		{
		BOOL fSignTable = IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
									TEXT("MsiDigitalSignature"));
		Ice81_OrphanCertificates(hInstall, hDatabase, fSignTable);
		if(fSignTable)
			Ice81_ValidateDigitalSignature(hInstall, hDatabase);
		}
	else
		{
		APIErrorOut(hInstall, 0, MyIceN, 1);
		}
	
	return ERROR_SUCCESS;
}

//Queries

const TCHAR sqlIce81ADigitalCert[] = TEXT("SELECT `DigitalCertificate` FROM `MsiDigitalCertificate`");

const TCHAR sqlIce81ADigitalSign[] = TEXT("SELECT `DigitalCertificate_` FROM `MsiDigitalSignature` WHERE (`DigitalCertificate_` = ?)");


// ErrorInfo

ICE_ERROR(Ice81AAllCertificatesAreOrphaned, MyIceN, ietWarning, "MsiDigitalSignature Table does not reference any of the records in MsiDigitalCertificate table.", "MsiDigitalCertificate\tDigitalCertificate");

ICE_ERROR(Ice81AOrphanedCertificate, MyIceN, ietWarning, "No reference to the Digital Certificate [1] could be found in MsiDigitalSignature table.", "MsiDigitalCertificate\tDigitalCertificate\t[1]");


#define ICE_REPORT_ERROR_NO_ARG(IceNMsg) \
	{ \
	PMSIHANDLE hRecError = MsiCreateRecord(1);	\
	ICEErrorOut(hInstall, hRecError, IceNMsg);	\
	}

#define RETURN_SUCCESS goto Success
#define RETURN_FAIL goto Error

#define IF_API_ERROR_REPORT_AND_RETURN(iStat) \
	{	\
	if(ERROR_SUCCESS != iStat )	\
		{	\
		API_ERROR_REPORT_AND_RETURN(iStat);	\
		}	\
	}

#define API_ERROR_REPORT_AND_RETURN(iStat) \
	{	\
	APIErrorOut(hInstall, iStat, MyIceN, __LINE__);	\
	RETURN_FAIL;	\
	}

void Ice81_OrphanCertificates(MSIHANDLE hInstall, MSIHANDLE hDatabase, BOOL fSignTableExist)
{
	UINT		iRet = ERROR_SUCCESS;

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
									TEXT("MsiDigitalCertificate")))
		{
		RETURN_SUCCESS;		// Nothing to check
		}

	{
	CQuery		qCertTable;
	CQuery		qSignTable;
	PMSIHANDLE	hCertRec = 0; 
	PMSIHANDLE	hSignRec = 0; 
	

	if(fSignTableExist)
		{
		iRet = qSignTable.Open(hDatabase, sqlIce81ADigitalSign);
		IF_API_ERROR_REPORT_AND_RETURN(iRet);
		}
 
	iRet = qCertTable.OpenExecute(hDatabase, 0, sqlIce81ADigitalCert);
	IF_API_ERROR_REPORT_AND_RETURN(iRet);
 
	for(;;)
		{
		iRet = qCertTable.Fetch(&hCertRec);

		if(ERROR_NO_MORE_ITEMS == iRet)
			{
			RETURN_SUCCESS;		// we are done
			}

		IF_API_ERROR_REPORT_AND_RETURN(iRet);

		if(!fSignTableExist) 
			{
			ICE_REPORT_ERROR_NO_ARG(Ice81AAllCertificatesAreOrphaned);
			RETURN_SUCCESS;
			}

		iRet = qSignTable.Execute(hCertRec);
		IF_API_ERROR_REPORT_AND_RETURN(iRet);

		iRet = qSignTable.Fetch(&hSignRec); 

		if(ERROR_SUCCESS != iRet)
			{
			if(ERROR_NO_MORE_ITEMS == iRet)
				ICEErrorOut(hInstall, hCertRec, Ice81AOrphanedCertificate);
			else
				API_ERROR_REPORT_AND_RETURN(iRet); 
			}
		}
	}
Success:
Error:
		return;
}


//Queries

const TCHAR sqlIce81BDigitalSignature[] = TEXT("SELECT `Table`, `SignObject` FROM `MsiDigitalSignature`");

const TCHAR sqlIce81BGetMediaCabinet[] = TEXT("SELECT `DiskId`, `Cabinet` FROM `Media` WHERE (`DiskId` = %s)");


// ErrorInfo
ICE_ERROR(Ice81BAllSignedObjectsMissing, MyIceN, ietError, "Media Table does not exist. Hence all the entries in MsiDigitalSignature are incorrect", "MsiDigitalSignature\tSignObject");

ICE_ERROR(Ice81BMissingSignedObject, MyIceN, ietError, "Missing signed object [2] in Media Table", "MsiDigitalSignature\tSignObject\t[1]\t[2]");

ICE_ERROR(Ice81BNoPrefixInCabinet, MyIceN, ietError, "The entry in table [1] with key [2] is signed. Hence the cabinet should point to an object outside the package (the value of Cabinet should NOT be prefixed with #)", "MsiDigitalSignature\tSignObject\t[1]\t[2]");

ICE_ERROR(Ice81BNULLSignObject, MyIceN, ietError, "Internal Error: IceGetString returned NULL pointer for SignObject", "MsiDigitalSignature\tSignObject\t[1]\t[2]");

void Ice81_ValidateDigitalSignature(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
// Pointers to delete - All variables in this section MUST be initialized
	TCHAR	*pszSignObj = NULL;
	TCHAR	*pszCabinet = NULL;
	

// Either simple or too good variables that we need not bother
	UINT		iRet = ERROR_SUCCESS;
	BOOL		fMediaTableExist = TRUE;


	if(!IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
									TEXT("Media")))
		{
		fMediaTableExist = FALSE;
		}

	{
	CQuery		qSignTable;
	CQuery		qMediaTable;
	PMSIHANDLE	hMediaRec = 0; 
	PMSIHANDLE	hSignRec = 0; 
	DWORD		cchSizeSignObj = 0;
	DWORD		cchSizeCabinet = 0;

	iRet = qSignTable.OpenExecute(hDatabase, 0, sqlIce81BDigitalSignature);
	IF_API_ERROR_REPORT_AND_RETURN(iRet);
 
	for(;;)
		{
		iRet = qSignTable.Fetch(&hSignRec);

		if(ERROR_NO_MORE_ITEMS == iRet)
			{
			RETURN_SUCCESS;		// we are done
			}

		IF_API_ERROR_REPORT_AND_RETURN(iRet);

		if(!fMediaTableExist) 
			{
			ICE_REPORT_ERROR_NO_ARG(Ice81BAllSignedObjectsMissing);
			RETURN_SUCCESS;
			}

		iRet = IceRecordGetString(hSignRec, 2, &pszSignObj, 
							&cchSizeSignObj, NULL);
		IF_API_ERROR_REPORT_AND_RETURN(iRet);

		if(!pszSignObj)
			{
			ICEErrorOut(hInstall, hSignRec, Ice81BNULLSignObject);
			RETURN_FAIL;
			}

		iRet = qMediaTable.FetchOnce(hDatabase, 0, &hMediaRec, 
							sqlIce81BGetMediaCabinet, pszSignObj);

		if(ERROR_SUCCESS != iRet)
			{
			if(ERROR_NO_MORE_ITEMS == iRet)
				ICEErrorOut(hInstall, hSignRec, Ice81BMissingSignedObject);
			else
				API_ERROR_REPORT_AND_RETURN(iRet); 
			}
		else
			{
					// Cabinet should NOT contain # as prefix
			iRet = IceRecordGetString(hMediaRec, 2, &pszCabinet, 
							&cchSizeCabinet, NULL);

			IF_API_ERROR_REPORT_AND_RETURN(iRet);
		
			if(!pszCabinet || (*pszCabinet == TCHAR(0)) || (*pszCabinet == TCHAR('#')))
				{
				ICEErrorOut(hInstall, hSignRec, Ice81BNoPrefixInCabinet);
				}
			
			}
		}
	}
Success:
Error:

		DELETE_IF_NOT_NULL(pszSignObj);
		DELETE_IF_NOT_NULL(pszCabinet);
		
	
		return;
}

#endif // MODSHAREDONLY



///////////////////////////////////////////////////////////////////////////////
// ICE82 -- Verifies that the InstallExecuteSequence has, either all the 
//			following four actions or none.
//			1) RegisterProduct
//			2) RegisterUser
//			3) PublishProduct
//			4) PublishFeatures
//
//
//			Also verifies that a sequence number is not used more than once
//			in the same table for the following tables
//
//			InstallExecuteSequence
//			InstallUISequence
//			AdminExecuteSequence
//			AdminUISequence
//			AdvtExecuteSequence
//			AdvtUISequence
//

// Not shared with merge module
#ifndef MODSHAREDONLY

#undef MyIceN
#define MyIceN 82

void Ice82_InstallAction(MSIHANDLE hInstall, MSIHANDLE hDatabase);
void Ice82_CheckDuplicateFilesAction(MSIHANDLE hInstall, MSIHANDLE hDatabase);
void Ice82_CheckSequence(MSIHANDLE hInstall, MSIHANDLE hDatabase);

ICE_FUNCTION_DECLARATION(82)
{
	PMSIHANDLE	hDatabase = 0;

	// display info
	DisplayInfo(hInstall, 82);

					// hInstall is passed in as arg - see 
					// ICE_FUNCTIO_DECLARATION's definition
	hDatabase =::MsiGetActiveDatabase(hInstall);

	if(0 != hDatabase)
		{
		Ice82_InstallAction(hInstall, hDatabase);
		Ice82_CheckDuplicateFilesAction(hInstall, hDatabase);
		Ice82_CheckSequence(hInstall, hDatabase);
		}
	else
		{
		APIErrorOut(hInstall, 0, MyIceN, 1);
		}
	
	return ERROR_SUCCESS;
}


// Query for all Actions.
ICE_QUERY1(qIce82Action, "SELECT `Action` FROM `InstallExecuteSequence` WHERE `Action` = 'PublishFeatures' OR `Action` = 'RegisterProduct' OR `Action` = 'PublishProduct' OR `Action` = 'RegisterUser'", Action);

// Error
ICE_ERROR(Ice82MissingGroup, 82, ietWarning, "The InstallExecuteSequence table does not contain the set of actions (PublishFeatures, PublishProduct, RegisterProduct, RegisterUser).", "InstallExecuteSequence");
ICE_ERROR(Ice82NonCompliance, 82, ietError, "The InstallExecuteSequence contains [1] which makes this list (Publish Features, PublishProduct, RegisterProduct, RegisterUser) partial. Should either contain all of the 4 actions mentioned in the list or none of them.", "InstallExecuteSequence\tAction\t[1]");
ICE_ERROR(Ice82NULLAction, MyIceN, ietError, "Internal Error: IceGetString returned NULL pointer for Action field", "InstallExecuteSequence\tAction\t[1]");


void Ice82_InstallAction(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
	// Pointers to DELETE
	TCHAR	*pszAction = NULL;

	// 
// The MAX_ACTIONS can go between 1 - 32, since iMask is an int 
#define MAX_ACTIONS 4

	TCHAR *ActionList[MAX_ACTIONS] =	{	
										TEXT("PublishFeatures"),
										TEXT("PublishProduct"),
										TEXT("RegisterProduct"),
										TEXT("RegisterUser")
									};

	UINT		i, j, iMask=0;
	BOOL		fFetch;
	DWORD		cchSizeAction = 0;
	CQuery		qActionTable;
	PMSIHANDLE	hActionRec = 0; 
	UINT		iRet = ERROR_SUCCESS;

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
									TEXT("InstallExecuteSequence")))
		{
		goto Done;
		}

	iRet = qActionTable.OpenExecute(hDatabase, 0, qIce82Action::szSQL);
	IF_API_ERROR_REPORT_AND_RETURN(iRet);
 
	for(;;)
		{
		iRet = qActionTable.Fetch(&hActionRec);

		if(ERROR_NO_MORE_ITEMS == iRet)
			{
			RETURN_SUCCESS;		// we are done
			}

		IF_API_ERROR_REPORT_AND_RETURN(iRet);

		iRet = IceRecordGetString(hActionRec, qIce82Action::Action, &pszAction, 
							&cchSizeAction, NULL);
		IF_API_ERROR_REPORT_AND_RETURN(iRet);

		if(!pszAction)
			{
			ICEErrorOut(hInstall, hActionRec, Ice82NULLAction);
			RETURN_FAIL;
			}
		
		for(j=1,i=0; i<MAX_ACTIONS; i++,j<<=1)
			{
			if(iMask & j)
				continue;		// This list entry is already found.

			if(!_tcscmp(ActionList[i], pszAction))
				{
				iMask |= j;
				break;			// Found match hence break (ActionList has
								// unique entries).
				}
			}
		
		if(iMask == (1 << MAX_ACTIONS) - 1)
			{
			break;			// All entries are found.
			}

		}
Success:
		if(iMask != (1 << MAX_ACTIONS)-1)
			{
			PMSIHANDLE hRecError = MsiCreateRecord(1); 
			if(!iMask)		// Not a single entry is found
				{
				ICEErrorOut(hInstall, hRecError, Ice82MissingGroup);	
				}
			else			// one or more but not all entries are found.
				{
				for(j=1,i=0; i<MAX_ACTIONS; i++,j<<=1)
					{
					if(iMask & j)
						{
						MsiRecordSetString(hRecError, 1, ActionList[i]);
						ICEErrorOut(hInstall, hRecError, Ice82NonCompliance);	
						}
					}
				}
	
			}
Done:
Error:
	DELETE_IF_NOT_NULL(pszAction);
		
	return;
}


// Query for any entry in DuplicateFile table
ICE_QUERY1(qIce82DuplicateFileTable, "SELECT `FileKey` FROM `DuplicateFile`", Action);

// Query for PatchFiles action in InstallExecute Sequence
ICE_QUERY1(qIce82PatchFilesAction, "SELECT `Sequence` FROM `InstallExecuteSequence` WHERE (`Action` = 'PatchFiles')", Sequence);

// Query for DuplicateFiles action in InstallExecute Sequence
ICE_QUERY1(qIce82DuplicateFilesAction, "SELECT `Action` FROM `InstallExecuteSequence` WHERE (`Action` = 'DuplicateFiles' AND `Sequence` <= ?)", Action);

// Error
ICE_ERROR(Ice82DuplicateFiles, 82, ietWarning, "The sequence of DuplicateFiles Action is not greater than the Sequence of PatchFiles Action in the InstallExecuteSequence table.", "InstallExecuteSequence\tSequence\t[1]");

void Ice82_CheckDuplicateFilesAction(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
	CQuery		qDupl;
	CQuery		qPatch;
	PMSIHANDLE	hRecDupl;
	PMSIHANDLE	hRecPatch;
	UINT		iRet = ERROR_SUCCESS;

	if(		!IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
									TEXT("DuplicateFile"))
		||	!IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
									TEXT("InstallExecuteSequence"))
	)
		{
		goto Success;
		}

	iRet = qDupl.FetchOnce(hDatabase, 0, &hRecDupl, qIce82DuplicateFileTable::szSQL);
	if(iRet)
	{
		if(ERROR_NO_MORE_ITEMS == iRet)
			{
			RETURN_SUCCESS;		// we are done
			}

		IF_API_ERROR_REPORT_AND_RETURN(iRet);
	}		


	// DuplicatFile table has atleast one record.

	iRet = qPatch.FetchOnce(hDatabase, 0, &hRecPatch, qIce82PatchFilesAction::szSQL);
	if(iRet)
	{
		if(ERROR_NO_MORE_ITEMS == iRet)
			{
			RETURN_SUCCESS;		// we are done
			}

		IF_API_ERROR_REPORT_AND_RETURN(iRet);
	}		

	// PatchFiles Action is present in InstallExecuteSequence table
	qDupl.Close();
	iRet = qDupl.FetchOnce(hDatabase, hRecPatch, &hRecDupl, qIce82DuplicateFilesAction::szSQL);
	if(iRet)
	{
		if(ERROR_NO_MORE_ITEMS == iRet)
			{
			RETURN_SUCCESS;		// we are done
			}

		IF_API_ERROR_REPORT_AND_RETURN(iRet);
	}		
	ICEErrorOut(hInstall, hRecDupl, Ice82DuplicateFiles);	
Success:
Error:
	return;

}

// Add temporary column
const static TCHAR sqlIce82AddColumn[] = TEXT("ALTER TABLE `%s` ADD `_Ice82Checked` INT TEMPORARY");
const static TCHAR sqlIce82InitColumn[] = TEXT("UPDATE `%s` SET `_Ice82Checked` = 0");
const static TCHAR sqlIce33SetColumn[] = TEXT("UPDATE `%s` SET `_Ice82Checked` = 1 WHERE ((`Sequence` = ?) AND (`Action` = ?))");

// Query for any entry in DuplicateFile table
ICE_QUERY2(qIce82SequenceQuery, "SELECT `Sequence`, `Action` FROM `%s`", Sequence, Action);
ICE_QUERY2(qIce82DuplicateQuery,"SELECT `Sequence`, `Action` FROM `%s` WHERE `_Ice82Checked` <> 1 AND `Sequence` = ?", Sequence, Action);

// Error
const static TCHAR szIce82SequenceErrMsg[] = TEXT("This action [2] has duplicate sequence number [1] in the table %s");
const static TCHAR szIce82SequenceErrLocation[] =  TEXT("%s\tSequence\t[2]");


const static TCHAR *SequenceTables[] = 
{
	TEXT("InstallExecuteSequence"),
	TEXT("InstallUISequence"),
	TEXT("AdminExecuteSequence"),
	TEXT("AdminUISequence"),
	TEXT("AdvtExecuteSequence"),
	TEXT("AdvtUISequence")
};

void Ice82_CheckSequence(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
	UINT		iRet = ERROR_SUCCESS;

	UINT		iTables = sizeof(SequenceTables)/sizeof(TCHAR *);
	UINT		i;
	BOOL		fError;

//	Be little stingy on the size. The calculation below assumes a table name 
//  to be less than 40 characters. If it exceeds, nothing fails except that 
//  the message will get truncated
	TCHAR		szMessage[(sizeof(szIce82SequenceErrMsg)/sizeof(TCHAR))+40];
	TCHAR		szLocation[(sizeof(szIce82SequenceErrLocation)/sizeof(TCHAR))+40];
	ErrorInfo_t Ice82DuplicateSequence;

	Ice82DuplicateSequence.iICENum = MyIceN;
	Ice82DuplicateSequence.szMessage = szMessage;
	Ice82DuplicateSequence.szLocation = szLocation;
	szMessage[0] = 0;
	szLocation[0] = 0;

	for(i=0; i<iTables; i++)
	{
		fError = FALSE;
		if(!IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
								SequenceTables[i]))
		{
			continue;
		}

		// create the column
		CQuery qCreate;
		iRet = qCreate.OpenExecute(hDatabase, NULL, sqlIce82AddColumn, SequenceTables[i]);
		IF_API_ERROR_REPORT_AND_RETURN(iRet);
			
		CQuery qInit;
		iRet = qInit.OpenExecute(hDatabase, NULL, sqlIce82InitColumn, SequenceTables[i]);
		IF_API_ERROR_REPORT_AND_RETURN(iRet);
			
		CQuery		qSequence;
		iRet = qSequence.OpenExecute(hDatabase, 0, qIce82SequenceQuery::szSQL, SequenceTables[i]);
		IF_API_ERROR_REPORT_AND_RETURN(iRet);

		PMSIHANDLE	hRecSequence;
		while(ERROR_SUCCESS == (iRet = qSequence.Fetch(&hRecSequence)))
		{
			{
				INT iSequence = ::MsiRecordGetInteger(hRecSequence, 
											qIce82SequenceQuery::Sequence);
				if(!iSequence)
				{
					continue;		// Do not care about Sequence = 0
				}
				Ice82DuplicateSequence.iType =
								(iSequence > 0) ? ietWarning : ietError;
			}
				
			CQuery qTmp;
			iRet = qTmp.OpenExecute(hDatabase, hRecSequence, sqlIce33SetColumn, SequenceTables[i]);

			CQuery qDupl;
			iRet = qDupl.OpenExecute(hDatabase, hRecSequence, qIce82DuplicateQuery::szSQL, SequenceTables[i]);
			IF_API_ERROR_REPORT_AND_RETURN(iRet);
	
			PMSIHANDLE	hRecDuplicate;
			while(ERROR_SUCCESS == (iRet = qDupl.Fetch(&hRecDuplicate)))
			{
				if(!fError)
				{
					_sntprintf(szMessage, 
								((sizeof(szMessage)/sizeof(TCHAR))-1),  
								szIce82SequenceErrMsg, SequenceTables[i]);
					_sntprintf(szLocation, 
								((sizeof(szLocation)/sizeof(TCHAR))-1),  
								szIce82SequenceErrLocation, SequenceTables[i]);
					szMessage[(sizeof(szMessage)/sizeof(TCHAR))-1] = 0;
					szLocation[(sizeof(szLocation)/sizeof(TCHAR))-1] = 0;
					fError = TRUE;
				}
				ICEErrorOut(hInstall, hRecDuplicate, Ice82DuplicateSequence);	
				qTmp.Close();
				iRet = qTmp.OpenExecute(hDatabase, hRecDuplicate, sqlIce33SetColumn, SequenceTables[i]);
			}
			if(iRet != ERROR_NO_MORE_ITEMS)
			{
				API_ERROR_REPORT_AND_RETURN(iRet);
			}
		}
		if(iRet != ERROR_NO_MORE_ITEMS)
		{
			API_ERROR_REPORT_AND_RETURN(iRet);
		}
	}	
Error:
	return;
}
			
	

#endif // MODSHAREDONLY

///////////////////////////////////////////////////////////////////////////////
// ICE83 -- Validator for MsiAssembly & MsiAssemblyName.
//			Does the following.
//
//			1)	Ensure that for SX Assembly, the Keypath is not it's 
//				manifest file.
//			2)	If there are record(s) in MsiAssembly or MsiAssemblyName
//				table, then ensure that the Action table has either
//				MsiPublishAssemblies or MsiUnpublishAssemblies action.

// Not shared with merge module
#ifndef MODSHAREDONLY

#undef MyIceN
#define MyIceN 83

void Ice83_AssemblyTableCheck(MSIHANDLE hInstall, MSIHANDLE hDatabase);
void Ice83_AssemblyPublishAction(MSIHANDLE hInstall, MSIHANDLE hDatabase);

ICE_FUNCTION_DECLARATION(83)
{
	PMSIHANDLE	hDatabase = 0;

	// display info
	DisplayInfo(hInstall, 83);

					// hInstall is passed in as arg - see 
					// ICE_FUNCTIO_DECLARATION's definition
	hDatabase =::MsiGetActiveDatabase(hInstall);

	if(0 != hDatabase)
		{
		Ice83_AssemblyTableCheck(hInstall, hDatabase);
		Ice83_AssemblyPublishAction(hInstall, hDatabase);
		}
	else
		{
		APIErrorOut(hInstall, 0, MyIceN, 1);
		}
	
	return ERROR_SUCCESS;
}


// Query for all wrong assemblies.
ICE_QUERY1(qIce83AssemblyManifest, "SELECT `MsiAssembly`.`Component_` FROM `MsiAssembly`, `Component` WHERE (`MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Attributes` = 1 AND `MsiAssembly`.`File_Application` = NULL AND `MsiAssembly`.`File_Manifest` = `Component`.`KeyPath`)", Component_);

ICE_QUERY2(qIce83AssemblyAttributes, "SELECT `Component`.`Attributes`, `Component`.`Component` FROM `MsiAssembly`, `Component` WHERE (`MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`File_Application` = NULL)", Attributes, Component);

// Error messages
ICE_ERROR(Ice83WrongKeyPath, 83, ietWarning, "The keypath for Global Win32 SXS Assembly (Component_=[1]) SHOULD NOT be it's manifest file for assemblies other than Win32 Policy assemblies", "Component\tKeyPath\t[1]");
ICE_ERROR(Ice83RunFromSource, 83, ietError, "This Component [2] is an Assembly. Hence cannot run from source.", "Component\tAttributes\t[2]");

void Ice83_AssemblyTableCheck(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
		
	CQuery		qAssemblyTable;
	PMSIHANDLE	hAssemblyRec = 0; 
	UINT		iRet = ERROR_SUCCESS;

	if(		!IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
									TEXT("MsiAssembly"))
		||	!IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
									TEXT("Component"))
	)
	{
		RETURN_SUCCESS;
	}

	iRet = qAssemblyTable.OpenExecute(hDatabase, 0, qIce83AssemblyManifest::szSQL);
	IF_API_ERROR_REPORT_AND_RETURN(iRet);
 
	for(;;)
	{
		iRet = qAssemblyTable.Fetch(&hAssemblyRec);

		if(ERROR_NO_MORE_ITEMS == iRet)
		{
			break;
		}

		IF_API_ERROR_REPORT_AND_RETURN(iRet);

		ICEErrorOut(hInstall, hAssemblyRec, Ice83WrongKeyPath);
	}

	qAssemblyTable.Close();
	iRet = qAssemblyTable.OpenExecute(hDatabase, 0, qIce83AssemblyAttributes::szSQL);
	IF_API_ERROR_REPORT_AND_RETURN(iRet);
 
	for(;;)
	{
		iRet = qAssemblyTable.Fetch(&hAssemblyRec);

		if(ERROR_NO_MORE_ITEMS == iRet)
		{
			break;
		}

		IF_API_ERROR_REPORT_AND_RETURN(iRet);

		// If Run From Source is enabled report
		if(MsiRecordGetInteger(hAssemblyRec, 
					qIce83AssemblyAttributes::Attributes) 
			& (msidbComponentAttributesSourceOnly | msidbComponentAttributesOptional))
		{
			ICEErrorOut(hInstall, hAssemblyRec, Ice83RunFromSource);
		}
	}

Success:
Error:
	return;
}

// Query for any assembly
	
ICE_QUERY1(qIce83AnyAssembly, "SELECT `Component_` FROM `MsiAssembly`", Component);
ICE_QUERY1(qIce83PublishAction, "SELECT `Action` FROM `InstallExecuteSequence` WHERE `Action` = 'MsiPublishAssemblies' OR `Action` = 'MsiUnpublishAssemblies'", Action);
ICE_QUERY1(qIce83PublishAdvtAction, "SELECT `Action` FROM `AdvtExecuteSequence` WHERE `Action` = 'MsiPublishAssemblies'", Action);
ICE_QUERY1(qIce83UnPublishAdvtAction, "SELECT `Action` FROM `AdvtExecuteSequence` WHERE `Action` = 'MsiUnpublishAssemblies'", Action);

// Error messages
ICE_ERROR(Ice83MissingPublishAction, 83, ietError, "Both MsiPublishAssemblies AND MsiUnpublishAssemblies actions MUST be present in InstallExecuteSequence table.", "InstallExecuteSequence");
ICE_ERROR(Ice83MissingPublishAdvtAction, 83, ietError, "The MsiPublishAssemblies action MUST be present in AdvtExecuteSequence table.", "AdvtExecuteSequence");
ICE_ERROR(Ice83NotMissingUnPublishAdvtAction, 83, ietWarning, "The MsiUnpublishAssemblies action SHOULD not be present in AdvtExecuteSequence table, since it does nothing.", "AdvtExecuteSequence");

void Ice83_AssemblyPublishAction(MSIHANDLE hInstall, MSIHANDLE hDatabase)
{
		
	UINT		iRet = ERROR_SUCCESS;

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
									TEXT("MsiAssembly")))
		{
		RETURN_SUCCESS;		// Nothing to validate
		}


	{
	CQuery		qAssemblyTable;
	PMSIHANDLE	hAssemblyRec = 0; 

	iRet = qAssemblyTable.OpenExecute(hDatabase, 0, qIce83AnyAssembly::szSQL);
	IF_API_ERROR_REPORT_AND_RETURN(iRet);

	iRet = qAssemblyTable.Fetch(&hAssemblyRec);

	if(iRet == ERROR_NO_MORE_ITEMS)
		{
		RETURN_SUCCESS;			// Done
		} 
	IF_API_ERROR_REPORT_AND_RETURN(iRet);
	}
	
	// An entry is found in either MsiAssembly table
	if(	IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
									TEXT("InstallExecuteSequence")))
	{
		CQuery		qActionTable;
		PMSIHANDLE	hActionRec = 0; 
	
		iRet = qActionTable.OpenExecute(hDatabase, 0, qIce83PublishAction::szSQL);
		IF_API_ERROR_REPORT_AND_RETURN(iRet);

		for(UINT i=0; ((i < 2) && !iRet); i++)
			{
			iRet = qActionTable.Fetch(&hActionRec);
			}

		if(iRet)
		{
			if(iRet != ERROR_NO_MORE_ITEMS)
			{
				API_ERROR_REPORT_AND_RETURN(iRet);
			}
			else
			{
				PMSIHANDLE hRecError = MsiCreateRecord(1); 
				ICEErrorOut(hInstall, hRecError, Ice83MissingPublishAction);
			}
		}

	}


	// An entry is found in either MsiAssembly table
	if(	IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, 
									TEXT("AdvtExecuteSequence")))
	{
		CQuery		qActionTable;
		PMSIHANDLE	hActionRec = 0; 
	
		iRet = qActionTable.FetchOnce(hDatabase, 0, &hActionRec, 
											qIce83PublishAdvtAction::szSQL);
		if(iRet)
		{
			if(iRet != ERROR_NO_MORE_ITEMS)
			{
				API_ERROR_REPORT_AND_RETURN(iRet);
			}
			else
			{
				PMSIHANDLE hRecError = MsiCreateRecord(1); 
				ICEErrorOut(hInstall, hRecError, Ice83MissingPublishAdvtAction);
			}
		}

		qActionTable.Close();
	
		iRet = qActionTable.FetchOnce(hDatabase, 0, &hActionRec, 
											qIce83UnPublishAdvtAction::szSQL);
		if(iRet)
		{
			if(iRet != ERROR_NO_MORE_ITEMS)
			{
				API_ERROR_REPORT_AND_RETURN(iRet);
			}
		}
		else		// Fetched a record
		{
			PMSIHANDLE hRecError = MsiCreateRecord(1); 
			ICEErrorOut(hInstall, hRecError, Ice83NotMissingUnPublishAdvtAction);
		}
	}

Success:
Error:
	return;
}

#endif // MODSHAREDONLY


///////////////////////////////////////////////////////////////////////////////
// ICE84 -- Verifies that reqired actions in sequence tables are conditionless.

// not shared with merge module subset
#ifndef MODSHAREDONLY

// Tables in which some or all of the actions in table _Reqact is required.
const TCHAR* Tables[] =
{
	TEXT("AdvtExecuteSequence"),
	TEXT("AdminExecuteSequence"),
	TEXT("InstallExecuteSequence")
};
const DWORD cTables = sizeof(Tables) / sizeof(TCHAR*);

ICE_QUERY2(qIce84Actions, "SELECT `%s`.`Action`, `Condition` FROM `%s`, `_Reqact` WHERE `%s`.`Action` = `_Reqact`.`Action` AND `Condition` is not null", Action, Condition);

ICE_ERROR(Ice84NoReqactTable, 84, ietWarning, "CUB file authoring error. Missing required actions data.","");
ICE_ERROR(Ice84RequiredActionConditioned, 84, ietWarning, "Action '[1]' found in %s table is a required action with a condition.", "%s\tAction\t[1]");

ICE_FUNCTION_DECLARATION(84)
{
	UINT		iStat;
	CQuery		qSequence;
	PMSIHANDLE	hRecAction;
	

	// display info
	DisplayInfo(hInstall, 84);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// Does _Reqact table exist?
	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 84, TEXT("_Reqact")))
	{
		PMSIHANDLE hRecord = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecord, Ice84NoReqactTable);
		return ERROR_SUCCESS;
	}
	
	// Loop through all the sequence tables.
	for(int i = 0; i < cTables; i++)
	{
		// Does this sequence table exist?
		if(!IsTablePersistent(FALSE, hInstall, hDatabase, 84, Tables[i]))
		{
			continue;
		}
	
		// Query for all actions and their conditions.
		ReturnIfFailed(84, 1, qSequence.OpenExecute(hDatabase, 0, qIce84Actions::szSQL, Tables[i], Tables[i], Tables[i]));

		while((iStat = qSequence.Fetch(&hRecAction)) == ERROR_SUCCESS)
		{
			// This is a required action and it's conditioned.
			ICEErrorOut(hInstall, hRecAction, Ice84RequiredActionConditioned, Tables[i], Tables[i]);

		}
		if(ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 84, 2);
		}

		// Close the query.
		qSequence.Close();
	}

	return ERROR_SUCCESS;
}

#endif // MODSHAREDONLY


///////////////////////////////////////////////////////////////////////////////
// ICE85 -- Verify that the SourceName column of MoveFile table is a valid LFN
// WildCardFilename.

// Shared with merge module subset

// Function to verify a LFN wildcard file name.

const DWORD cMaxReservedWords = 3;
const DWORD cMinReservedWords = 3;
const DWORD cReservedWords = 3;
const TCHAR* const ReservedWords[cReservedWords] = {TEXT("AUX"), TEXT("CON"), TEXT("PRN")};
const DWORD LFNValidChar[4] =
{
	0x00000000, // disallows characters -- ^X, ^Z, etc.
	0x2bff7bfb, // disallows " * / : < > ?
	0xefffffff, // disallows backslash
	0x6fffffff  // disallows | and ASCII code 127 (Ctrl + BKSP)
};
const int cMaxLFN = 255;
const int iValidChar = 127; // any char with ASCII code > 127 is valid in a filename

BOOL CheckWildcardFilename(const TCHAR* pFileName)
{
	DWORD	cFileName = _tcslen(pFileName);
		
	//check reserved words
	if(cFileName <= cMaxReservedWords && cFileName >= cMinReservedWords)
	{
		for (int i = 0; i < cReservedWords; i++)
		{
			if (!_tcscmp(pFileName, ReservedWords[i]))
				return FALSE;
		}
	}

	//check invalid characters
	const	TCHAR* pTmp = pFileName;
	BOOL	fNonPeriodChar = FALSE;
	int		cPeriod = 0;
	int		cWildCardCount = 0;

	do
	{
		// wildcards: For validation, ? must be a character, even if it is right before
		// the period in a SFN. We still allow for * to be 0
		if(*pTmp == TEXT('*'))
		{
			// keep track of how many *'s we see.
			cWildCardCount++;
		}
		else if(*pTmp == TEXT('?'))
		{
			// eat char
		}
		else if(((int)(*pTmp)) < iValidChar && !(LFNValidChar[((int)(*pTmp)) / (sizeof(int)*8)] & (1 << (((int)(*pTmp)) % (sizeof(int)*8)))))
		{
			// Check for valid char
			// NOTE:  division finds location in rgiValidChar array and modulus finds particular bit.
			return FALSE;
		}
		
		// Can't be all periods
		if(!fNonPeriodChar && *pTmp != '.')
		{
			fNonPeriodChar = TRUE;
		}

		pTmp++;
	}
	while(*pTmp != TEXT('\0'));
	
	if(!fNonPeriodChar)
	{
		return FALSE;
	}

	// check for length limits
	if(cFileName - cWildCardCount > cMaxLFN)
	{
		return FALSE;
	}

	return TRUE;
}

ICE_QUERY2(qIce85SourceName, "SELECT `FileKey`, `SourceName` FROM `MoveFile` WHERE `SourceName` is not null", FileKey, SourceName);

ICE_ERROR(Ice85BadName, 85, ietError, "SourceName '[2]' found in the MoveFile table is of bad format. It has to be a valid long file name", "MoveFile\tSourceName\t[1]");

ICE_FUNCTION_DECLARATION(85)
{
	UINT		iStat;
	CQuery		qSourceName;
	PMSIHANDLE	hSourceName;
	TCHAR*		pSourceName = NULL;
	DWORD		cSourceName = 0;
		

	// display info
	DisplayInfo(hInstall, 85);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// Does MoveFile table exist?
	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 85, TEXT("MoveFile")))
	{
		return ERROR_SUCCESS;
	}
	
	// Fetch SourceName column.
	ReturnIfFailed(85, 1, qSourceName.OpenExecute(hDatabase, 0, qIce85SourceName::szSQL));

	while((iStat = qSourceName.Fetch(&hSourceName)) == ERROR_SUCCESS)
	{
		ReturnIfFailed(85, 2, IceRecordGetString(hSourceName, qIce85SourceName::SourceName, &pSourceName, &cSourceName, NULL));
		if(CheckWildcardFilename(pSourceName) == FALSE)
		{
			ICEErrorOut(hInstall, hSourceName, Ice85BadName);
		}
	}
	if(ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 85, 3);
	}

	// Close the query.
	qSourceName.Close();

	// Clean up allocated string.
	if(pSourceName)
	{
		delete [] pSourceName;
	}

	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
// ICE86 -- Post warning for the use of AdminUser instead of Privileged
//			property in conditions.

// Shared with merge module

// Warning: Validation table is missing.
ICE_ERROR(Ice86MissingValidation, 86, ietWarning, "Database is missing _Validation table. Could not completely check property names.", "_Validation");
// Warning: Can not access a table.
ICE_ERROR(Ice86TableAccessError, 86, ietWarning, "Error retrieving values from column [2] in table [1]. Skipping Column.", "[1]"); 
// Warning: Can not fetch data from a table.
ICE_ERROR(Ice86TableFetchData, 86, ietWarning, "Error retrieving data from table [1]. Skipping table.", "[1]"); 
// Warning: Use of AdminUser instead of Privileged property in conditions.
ICE_ERROR(Ice86AdminUser, 86, ietWarning, "Property `%s` found in column `%s`.`%s` in row %s. `Privileged` property is often more appropriate.", "%s\t%s\t%s");

// Function to check for validity of components and features.
DWORD Ice86Check(MSIHANDLE hInstall, MSIHANDLE, MSIHANDLE hDataRec, CONDITION_ENUMERATOR_SYMBOLTYPE Type, DWORD cPrimaryKeys, const WCHAR* pSymbol, const TCHAR* pTableName, const TCHAR* pColumnName)
{
	if(Type == CONDITION_ENUMERATOR_PROPERTY)
	{
		if(wcscmp(pSymbol, L"AdminUser") == 0)
		{
			TCHAR szRowName[255] = TEXT("");
			TCHAR szKeys[255] = TEXT("");

			// build up the columns for the user-readable string in szRowName
			// and the tab-delimited string in szKeys.
			_tcscpy(szRowName, TEXT("'[2]'"));
			_tcscpy(szKeys, TEXT("[2]"));
			TCHAR szTemp[10];
			for (int i=2; i <= cPrimaryKeys; i++)
			{
				_stprintf(szTemp, TEXT(".'[%d]'"), i+1);
				_tcscat(szRowName, szTemp);
				_stprintf(szTemp, TEXT("\t[%d]"), i+1);
				_tcscat(szKeys, szTemp);
			}
			
			ICEErrorOut(hInstall, hDataRec, Ice86AdminUser, pSymbol, pTableName, pColumnName, szRowName, pTableName, pColumnName, szKeys);
		}
	}
	
	return ERROR_SUCCESS;
}

DWORD Ice86Err(MSIHANDLE hInstall, CONDITION_ERR_ENUM Type, MSIHANDLE hRec)
{
	switch(Type)
	{
	case CONDITION_ERR_TABLE_ACCESS:

		ICEErrorOut(hInstall, hRec, Ice86TableAccessError);
		break;

	case CONDITION_ERR_FETCH_DATA:

		ICEErrorOut(hInstall, hRec, Ice86TableFetchData);
		break;

	default:
		break;
	};

	return ERROR_SUCCESS;
}

ICE_FUNCTION_DECLARATION(86)
{
	UINT iStat;


	// display info
	DisplayInfo(hInstall, 86);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// Find all condition columns in the _Validation table.
	if(IsTablePersistent(FALSE, hInstall, hDatabase, 86, TEXT("_Validation")))
	{
		ConditionEnumerator(hInstall, hDatabase, 86, Ice86Check, Ice86Err);
	}
	else
	{
		PMSIHANDLE hRec = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRec, Ice86MissingValidation);
	}

    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// ICE87 -- Verifies that some properties that shouldn't be authored
//			into the Property table are not.

// Shared with merge module.

ICE_QUERY1(qIce87BadProperties, "SELECT `Property`.`Property` FROM `Property`, `_BadProperties` WHERE `Property`.`Property`=`_BadProperties`.`Property`", Property);

ICE_ERROR(Ice87BadProperty, 87, ietWarning, "The property '[1]' shouldn't be authored into the Property table. Doing so might cause the product to not be uninstalled correctly.","Property\tProperty\t[1]");

ICE_FUNCTION_DECLARATION(87)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 87);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (IsTablePersistent(FALSE, hInstall, hDatabase, 87, TEXT("Property"))
		&& IsTablePersistent(FALSE, hInstall, hDatabase, 87, TEXT("_BadProperties")))
	{
		CQuery qBadProp;
		PMSIHANDLE hRec;
		ReturnIfFailed(10, 1, qBadProp.OpenExecute(hDatabase, 0, qIce87BadProperties::szSQL));
		while (ERROR_SUCCESS == (iStat = qBadProp.Fetch(&hRec)))
		{
			ICEErrorOut(hInstall, hRec, Ice87BadProperty);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 87, 2);
		}
	}

	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
// ICE88 -- Validator for DirProperty column of IniFile Table
//
//			For each entry in IniFile table, validate the value in 
//			DirProperty column, scan for the value in the following tables 
//			and also scan against the known list of properties set by the 
//			installer. Raises Warning, if the value could not be found.
//
//			1) Directory Table
//			2) AppSearch Table
//			3) Property Table
//			4) CustomAction Table where Action Type = 51
//			5) Known list of properties
//
// Not shared with merge module
#ifndef MODSHAREDONLY

#undef MyIceN
#define MyIceN 88

// Query for all INIFile Entries.
ICE_QUERY3(qIce88IniFile, "SELECT `DirProperty`, `Component_`, `IniFile` FROM `IniFile`", DirProperty, Component_, IniFile);

// Query for matching Componenent entry.
ICE_QUERY1(qIce88Component, "SELECT `Attributes` FROM `Component` WHERE (`Component` <> ? AND `Component` = ?)", Attributes);

// Scan Directory Table
ICE_QUERY1(qIce88Directory, "SELECT `Directory` FROM `Directory` WHERE `Directory` = ?", Directory);

// Scan Property Table
ICE_QUERY1(qIce88Property, "SELECT `Property` FROM `Property` WHERE `Property` = ?", Property);

// Scan AppSearch Table
ICE_QUERY1(qIce88AppSearch, "SELECT `Property` FROM `AppSearch` WHERE `Property` = ?", Property);

// Scan CustomAction Table
ICE_QUERY1(qIce88CA, "SELECT `Source` FROM `CustomAction` WHERE `Type` = 51 AND `Source` = ?", Source);

typedef struct _SQLINFO
{
	TCHAR *szTableName;
	TCHAR *szSQL;
} SQLINFO;

static const SQLINFO ListSqlInfo[] = 
{
	{TEXT("Directory"), (TCHAR *)qIce88Directory::szSQL},
	{TEXT("Property"), (TCHAR *)qIce88Property::szSQL},
	{TEXT("AppSearch"), (TCHAR *)qIce88AppSearch::szSQL},
	{TEXT("CustomAction"), (TCHAR *)qIce88CA::szSQL}
};

#define ICE88_SQL_QUERIES_CNT (sizeof(ListSqlInfo)/sizeof(SQLINFO))

// Properties - Case sensitive
static const	TCHAR *PropFor64BitComp[] = 
{
	TEXT("[ProgramFiles64Folder]"),
	TEXT("[CommonFiles64Folder]"),
	TEXT("[System64Folder]")
};

static const	TCHAR *PropFor32BitComp[] = 
{
	TEXT("[ProgramFilesFolder]"),
	TEXT("[CommonFilesFolder]"),
	TEXT("[SystemFolder]")
};


// Error messages
ICE_ERROR(Ice88MissingDirProperty, 88, ietWarning, "In the IniFile table entry (IniFile=) [3] the DirProperty=[1] is not found in Directory/Property/AppSearch/CA-Type51 tables and it is not one of the installer properties", "IniFile\tDirProperty\t[3]");


ICE_FUNCTION_DECLARATION(88)
{
	TCHAR*		pszStr = new TCHAR[MAX_PATH];
	PMSIHANDLE	hDatabase = 0;

	CQuery		qIni;
	CQuery		qScan;

	PMSIHANDLE	hIniRec = NULL;
	PMSIHANDLE	hScanRec = NULL;

	UINT 	iStat = ERROR_SUCCESS;
	UINT 	i, iSize;
	DWORD	dwSize = MAX_PATH-1;

	TCHAR 	**szList;

	// display info
	DisplayInfo(hInstall, MyIceN);

					// hInstall is passed in as arg - see 
					// ICE_FUNCTIO_DECLARATION's definition
	hDatabase =::MsiGetActiveDatabase(hInstall);

	if(0 == hDatabase)
    {
		APIErrorOut(hInstall, 0, MyIceN, __LINE__);
		goto Exit;
    }
	
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, MyIceN, TEXT("IniFile")))
	{
		goto Exit;
	}

	if((iStat = qIni.OpenExecute(hDatabase, 0, 	qIce88IniFile::szSQL)) 
														!= ERROR_SUCCESS)
	{
		APIErrorOut(hInstall, iStat, MyIceN, __LINE__);
		goto Exit;
	}

	while (ERROR_SUCCESS == (iStat = qIni.Fetch(&hIniRec)))
	{
		for(i=0; i<ICE88_SQL_QUERIES_CNT; i++)
		{
			if (!IsTablePersistent(FALSE, hInstall, hDatabase, 10, 
											ListSqlInfo[i].szTableName))
			{
				continue;
			}

			qScan.Close();
			iStat = qScan.FetchOnce(hDatabase, hIniRec, &hScanRec, 
														ListSqlInfo[i].szSQL);
			if(iStat == ERROR_SUCCESS)
			{
				break;			// Found the entry
			} 
			else if(iStat != ERROR_NO_MORE_ITEMS)
			{
				APIErrorOut(hInstall, iStat, MyIceN, __LINE__);
				goto Exit;
			}
		}
		if(i == ICE88_SQL_QUERIES_CNT)
		{			// Not found
			qScan.Close();
			iStat = qScan.FetchOnce(hDatabase, hIniRec, &hScanRec, 
														qIce88Component::szSQL);
			if(iStat != ERROR_SUCCESS)
			{
				if(iStat != ERROR_NO_MORE_ITEMS)
				{
					APIErrorOut(hInstall, iStat, MyIceN, __LINE__);
					goto Exit;
				}
				else
				{
					continue; // Component do not exist
				}
			}
			if(MsiRecordGetInteger(hScanRec, qIce88Component::Attributes) &
					msidbComponentAttributes64bit)	
			{
				szList = (TCHAR **)PropFor64BitComp;
				iSize = sizeof(PropFor64BitComp)/sizeof(TCHAR *);
			}
			else
			{
				szList = (TCHAR **)PropFor32BitComp;
				iSize = sizeof(PropFor32BitComp)/sizeof(TCHAR *);
			}
		
			iStat = IceRecordGetString(hIniRec, qIce88IniFile::DirProperty, 
													&pszStr, &dwSize, NULL);
			
			if(iStat != ERROR_SUCCESS)
			{
				APIErrorOut(hInstall, iStat, MyIceN, __LINE__);
				goto Exit;
			}

			if(pszStr && *pszStr)
			{
				for(i=0; i<iSize; i++)
				{
					if(!_tcscmp(szList[i], pszStr))
					{
						break;
					}
				}
			}
			else
			{
				i = iSize;
			}

			if(i == iSize)
			{
				ICEErrorOut(hInstall, hIniRec, Ice88MissingDirProperty);
			}
		}	
	}
	

Exit:
	DELETE_IF_NOT_NULL(pszStr);
	return ERROR_SUCCESS;
}

#endif


///////////////////////////////////////////////////////////////////////////////
// ICE89 -- Verifies that the Progid_Parent column in ProgId table is a valid
//			foreign keys into the ProgId column.
//
// Shared with merge module.
//

ICE_ERROR(Ice89BadProgIdParent, 89, ietError, "The ProgId_Parent '[1]' in the ProgId table is not a valid ProgId.","ProgId\tProgId_Parent\t[2]");

ICE_QUERY1(qIce89ProgId, "SELECT `ProgId` FROM `ProgId` WHERE `ProgId` = ?", ProgId);
ICE_QUERY2(qIce89ProgIdParent, "SELECT `ProgId_Parent`, `ProgId` FROM `ProgId` WHERE `ProgId_Parent` is not null", ProgId_Parent, ProgId);

ICE_FUNCTION_DECLARATION(89)
{
	UINT		iStat;
	PMSIHANDLE	hDatabase;
	
	// display info
	DisplayInfo(hInstall, 89);

	hDatabase =::MsiGetActiveDatabase(hInstall);

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 89, TEXT("ProgId")))
	{
		return ERROR_SUCCESS;
	}

	CQuery		qProgId;
	CQuery		qProgIdParent;
	PMSIHANDLE	hProgId;
	PMSIHANDLE	hProgIdParent;

	ReturnIfFailed(89, __LINE__, qProgIdParent.OpenExecute(hDatabase, NULL, qIce89ProgIdParent::szSQL));

	ReturnIfFailed(89, __LINE__, qProgId.Open(hDatabase, qIce89ProgId::szSQL));

	while((iStat = qProgIdParent.Fetch(&hProgIdParent)) == ERROR_SUCCESS)
	{
		ReturnIfFailed(89, __LINE__, qProgId.Execute(hProgIdParent));

		iStat = qProgId.Fetch(&hProgId);
		if(iStat == ERROR_NO_MORE_ITEMS)
		{
			ICEErrorOut(hInstall, hProgIdParent, Ice89BadProgIdParent);
		}
		else if(iStat != ERROR_SUCCESS)
		{
			APIErrorOut(hInstall, iStat, 89, __LINE__);
			qProgIdParent.Close();
			qProgId.Close();
			return ERROR_SUCCESS;
		}
	}
	if(iStat != ERROR_NO_MORE_ITEMS)
	{
		APIErrorOut(hInstall, iStat, 89, __LINE__);
	}

	qProgIdParent.Close();
	qProgId.Close();
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
// ICE90 -- Warns user of cases where a shortcut's directory is a public
//			property (ALL CAPS) that is under a profile directory. This results
//			in a problem if the value of the ALLUSERS property changes in the
//			UI sequence.
//
// Not shared with merge module.
//
#ifndef MODSHAREDONLY

ICE_ERROR(Ice90Shortcut, 90, ietWarning, "The shortcut '[1]' has a directory that is a public property (ALL CAPS) and is under user profile directory. This results in a problem if the value of the ALLUSERS property changes in the UI sequence.","Shortcut\tDirectory_\t[1]");

// This query find all shortcuts under a profile directory and has a directory property.
ICE_QUERY2(qIce90Shortcut, "SELECT `Shortcut`, `Directory_` FROM `Shortcut`, `Directory` WHERE `Directory_` = `Directory` AND `_Profile` = 2", Shortcut, Directory_);

ICE_FUNCTION_DECLARATION(90)
{
	UINT		iStat;
	PMSIHANDLE	hDatabase;
	
	// display info
	DisplayInfo(hInstall, 90);

	hDatabase =::MsiGetActiveDatabase(hInstall);

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 90, TEXT("Shortcut")) ||
	   !IsTablePersistent(FALSE, hInstall, hDatabase, 90, TEXT("Directory")))
	{
		return ERROR_SUCCESS;
	}

	CManageTable MngDirectoryTable(hDatabase, TEXT("Directory"), /*fAlreadyLocked = */true);
	// Mark profile directories.
	if(true != MarkProfile(hInstall, hDatabase, 90))
	{
		return ERROR_SUCCESS;
	}

	// If a shortcut has a directory that is a public property, and is under
	// the user's profile directory, then it's a warning.

	CQuery		qShortcut;
	PMSIHANDLE	hShortcut;
	TCHAR*		pProperty = new TCHAR[73];
	DWORD		dwProperty = 73;
	TCHAR*		pTmp = NULL;

	ReturnIfFailed(90, __LINE__, qShortcut.OpenExecute(hDatabase, NULL, qIce90Shortcut::szSQL));

	while((iStat = qShortcut.Fetch(&hShortcut)) == ERROR_SUCCESS)
	{
		BOOL	bError = TRUE;

		// Check to see if this is a public property directory.
		ReturnIfFailed(90, __LINE__, IceRecordGetString(hShortcut, 2, &pProperty, &dwProperty, NULL));

		// Search for lowercase characters.
		pTmp = pProperty;
		while(*pTmp != TEXT('\0'))
		{
			if(_istlower(*pTmp))
			{
				bError = FALSE;
				break;
			}
			pTmp++;
		}

		if(bError == TRUE)
		{
			ICEErrorOut(hInstall, hShortcut, Ice90Shortcut);
		}
	}
	qShortcut.Close();
	if(iStat != ERROR_NO_MORE_ITEMS)
	{
		APIErrorOut(hInstall, iStat, 90, __LINE__);
	}

	delete [] pProperty;
	return ERROR_SUCCESS;
}

#endif // MODSHAREDONLY


///////////////////////////////////////////////////////////////////////////////
// ICE91 -- Warns user of cases where a file (or INI entry, shortcut) is
//			explicitly installed into a per-user profile directory that doesn't
//			vary based on the ALLUSERS value. These files will not be copied
//			into each user's profile.
//
// Not shared with merge module.
//
#ifndef MODSHAREDONLY

ICE_ERROR(Ice91File, 91, ietWarning, "The file '[1]' will be installed to the per user directory '[2]' that doesn't vary based on ALLUSERS value. This file won't be copied to each user's profile even if a per machine installation is desired.","File\tFile\t[1]");
ICE_ERROR(Ice91IniFile, 91, ietWarning, "The IniFile '[1]' will be installed to the per user directory '[2]' that doesn't vary based on ALLUSERS value. This file won't be copied to each user's profile even if a per machine installation is desired.","IniFile\tIniFile\t[1]");
ICE_ERROR(Ice91Shortcut, 91, ietWarning, "The shortcut '[1]' will be installed to the per user directory '[2]' that doesn't vary based on ALLUSERS value. This file won't be copied to each user's profile even if a per machine installation is desired.","Shortcut\tShortcut\t[1]");

// Find files under profile directories.
ICE_QUERY1(qIce91File, "SELECT `File`.`File`, `Directory`.`Directory` FROM `File`, `Component`, `Directory` WHERE `File`.`Component_` = `Component`.`Component` AND `Component`.`Directory_` = `Directory`.`Directory` AND `Directory`.`_Profile` = 2", File);
ICE_QUERY1(qIce91IniFile, "SELECT `IniFile`.`IniFile`, `Directory`.`Directory` FROM `IniFile`, `Directory` WHERE `IniFile`.`DirProperty` = `Directory`.`Directory` AND `Directory`.`_Profile` = 2", IniFile);
ICE_QUERY1(qIce91Shortcut, "SELECT `Shortcut`.`Shortcut`, `Directory`.`Directory` FROM `Shortcut`, `Directory` WHERE `Shortcut`.`Directory_` = `Directory`.`Directory` AND `Directory`.`_Profile` = 2", Shortcut);

ICE_FUNCTION_DECLARATION(91)
{
	UINT		iStat;
	PMSIHANDLE	hDatabase;
	
	// display info
	DisplayInfo(hInstall, 91);

	hDatabase =::MsiGetActiveDatabase(hInstall);

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 91, TEXT("Directory")))
	{
		return ERROR_SUCCESS;
	}

	CManageTable MngDirectoryTable(hDatabase, TEXT("Directory"), /*fAlreadyLocked = */true);
	// Mark profile directories.
	if(true != MarkProfile(hInstall, hDatabase, 91, false, false, true))
	{
		return ERROR_SUCCESS;
	}

	if(IsTablePersistent(FALSE, hInstall, hDatabase, 91, TEXT("File")))
	{
		if(IsTablePersistent(FALSE, hInstall, hDatabase, 91, TEXT("Component")))
		{
			CQuery		qFile;
			PMSIHANDLE	hFile;

			ReturnIfFailed(91, __LINE__, qFile.OpenExecute(hDatabase, NULL, qIce91File::szSQL));

			while((iStat = qFile.Fetch(&hFile)) == ERROR_SUCCESS)
			{
				ICEErrorOut(hInstall, hFile, Ice91File);
			}
			qFile.Close();
			if(iStat != ERROR_NO_MORE_ITEMS)
			{
				APIErrorOut(hInstall, iStat, 91, __LINE__);
				return ERROR_SUCCESS;
			}
		}
	}

	if(IsTablePersistent(FALSE, hInstall, hDatabase, 90, TEXT("IniFile")))
	{
		CQuery		qIniFile;
		PMSIHANDLE	hIniFile;

		ReturnIfFailed(91, __LINE__, qIniFile.OpenExecute(hDatabase, NULL, qIce91IniFile::szSQL));

		while((iStat = qIniFile.Fetch(&hIniFile)) == ERROR_SUCCESS)
		{
			ICEErrorOut(hInstall, hIniFile, Ice91IniFile);
		}
		qIniFile.Close();
		if(iStat != ERROR_NO_MORE_ITEMS)
		{
			APIErrorOut(hInstall, iStat, 91, __LINE__);
			return ERROR_SUCCESS;
		}
	}

	if(IsTablePersistent(FALSE, hInstall, hDatabase, 90, TEXT("Shortcut")))
	{
		CQuery		qShortcut;
		PMSIHANDLE	hShortcut;

		ReturnIfFailed(91, __LINE__, qShortcut.OpenExecute(hDatabase, NULL, qIce91Shortcut::szSQL));

		while((iStat = qShortcut.Fetch(&hShortcut)) == ERROR_SUCCESS)
		{
			ICEErrorOut(hInstall, hShortcut, Ice91Shortcut);
		}
		qShortcut.Close();
		if(iStat != ERROR_NO_MORE_ITEMS)
		{
			APIErrorOut(hInstall, iStat, 91, __LINE__);
			return ERROR_SUCCESS;
		}
	}

	return ERROR_SUCCESS;
}

#endif // MODSHAREDONLY


///////////////////////////////////////////////////////////////////////////////
// ICE92 -- Verifies that GUID-less components are not marked permanent.
//
// Shared with merge module.
//

ICE_ERROR(Ice92Component, 92, ietError, "The Component '[1]' has no ComponentId and is marked as permanent.","Component\tComponent\t[1]");

// Find Components with no ComponentIds.
ICE_QUERY2(qIce92Component, "SELECT `Component`, `Attributes` FROM `Component` WHERE `ComponentId` is null", Component, Attributes);

ICE_FUNCTION_DECLARATION(92)
{
	UINT		iStat;
	PMSIHANDLE	hDatabase;
	
	// display info
	DisplayInfo(hInstall, 92);

	hDatabase =::MsiGetActiveDatabase(hInstall);

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 92, TEXT("Component")))
	{
		return ERROR_SUCCESS;
	}

	// Get all the components with no GUIDs.
	CQuery		qComponent;
	PMSIHANDLE	hComponent;

	ReturnIfFailed(92, __LINE__, qComponent.OpenExecute(hDatabase, NULL, qIce92Component::szSQL));
	while((iStat = qComponent.Fetch(&hComponent)) == ERROR_SUCCESS)
	{
		int	iAttributes = MsiRecordGetInteger(hComponent, qIce92Component::Attributes);

		if(iAttributes & msidbComponentAttributesPermanent)
		{
			ICEErrorOut(hInstall, hComponent, Ice92Component);
		}
	}
	qComponent.Close();
	if(iStat != ERROR_NO_MORE_ITEMS)
	{
		APIErrorOut(hInstall, iStat, 92, __LINE__);
	}

	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
// ICE93 -- Verifies that a custom action doesn't use the same name as a
//			standard action.
//
// Shared with merge module.
//

ICE_ERROR(Ice93Action, 93, ietWarning, "The Custom action '[1]' uses the same name as a standard action.","CustomAction\tAction\t[1]");

// Find custom actions with standard action names in the CustomAction table.
ICE_QUERY1(qIce93Action, "SELECT `CustomAction`.`Action` FROM `CustomAction`, `_Action` WHERE `CustomAction`.`Action` = `_Action`.`Action`", Action);

ICE_FUNCTION_DECLARATION(93)
{
	UINT		iStat;
	PMSIHANDLE	hDatabase;
	
	// display info
	DisplayInfo(hInstall, 93);

	hDatabase =::MsiGetActiveDatabase(hInstall);

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 93, TEXT("CustomAction")) ||
	   !IsTablePersistent(FALSE, hInstall, hDatabase, 93, TEXT("_Action")))
	{
		return ERROR_SUCCESS;
	}

	// Get custom actions with standard action names.
	CQuery		qAction;
	PMSIHANDLE	hAction;

	ReturnIfFailed(93, __LINE__, qAction.OpenExecute(hDatabase, NULL, qIce93Action::szSQL));
	while((iStat = qAction.Fetch(&hAction)) == ERROR_SUCCESS)
	{
		ICEErrorOut(hInstall, hAction, Ice93Action);
	}
	qAction.Close();
	if(iStat != ERROR_NO_MORE_ITEMS)
	{
		APIErrorOut(hInstall, iStat, 93, __LINE__);
	}

	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
// ICE94 -- Verifies that there are no non-advertised shortcuts to assembly
//			files in the global assembly cache.
//
// Shared with merge module.
//

ICE_ERROR(Ice94Shortcut, 94, ietWarning, "The non-advertised shortcut '[2]' points to an assembly file in the global assembly cache.","Shortcut\tShortcut\t[2]");

ICE_QUERY2(qIce94GlobalAssemblyShortcut, "SELECT `Shortcut`.`Target`, `Shortcut`.`Shortcut` FROM `Shortcut`, `MsiAssembly` WHERE `Shortcut`.`Component_` = `MsiAssembly`.`Component_` AND `MsiAssembly`.`File_Application` is null", Shortcut, Target);
ICE_QUERY1(qIce94Feature, "SELECT `Feature` FROM `Feature` WHERE `Feature` = ?", Feature);

ICE_FUNCTION_DECLARATION(94)
{
	UINT		iStat;
	PMSIHANDLE	hDatabase;
	
	// display info
	DisplayInfo(hInstall, 94);

	hDatabase =::MsiGetActiveDatabase(hInstall);

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 94, TEXT("Shortcut")) ||
	   !IsTablePersistent(FALSE, hInstall, hDatabase, 94, TEXT("Feature")) ||
	   !IsTablePersistent(FALSE, hInstall, hDatabase, 94, TEXT("MsiAssembly")))
	{
		return ERROR_SUCCESS;
	}

	CQuery		qShortcut;
	PMSIHANDLE	hShortcut;
	CQuery		qFeature;
	PMSIHANDLE	hFeature;

	ReturnIfFailed(94, __LINE__, qShortcut.OpenExecute(hDatabase, NULL, qIce94GlobalAssemblyShortcut::szSQL));
	ReturnIfFailed(94, __LINE__, qFeature.Open(hDatabase, qIce94Feature::szSQL));
	while((iStat = qShortcut.Fetch(&hShortcut)) == ERROR_SUCCESS)
	{
		ReturnIfFailed(94, __LINE__, qFeature.Execute(hShortcut));
		if((iStat = qFeature.Fetch(&hFeature)) == ERROR_NO_MORE_ITEMS)
		{
			// This is a non-advertised shortcut pointing to a global assembly file. Post warning.
			ICEErrorOut(hInstall, hShortcut, Ice94Shortcut);
		}
		else if(iStat != ERROR_SUCCESS)
		{
			APIErrorOut(hInstall, iStat, 94, __LINE__);
			qShortcut.Close();
			qFeature.Close();
			return ERROR_SUCCESS;
		}
	}
	if(iStat != ERROR_NO_MORE_ITEMS)
	{
		APIErrorOut(hInstall, iStat, 94, __LINE__);
	}

	qShortcut.Close();
	qFeature.Close();
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
// ICE95 -- Verifies that Billboard control items fit into all the Billboards.
//
// Shared with merge module.
//

ICE_ERROR(Ice95X, 95, ietWarning, "The BBControl item '[1].[2]' in the BBControl table does not fit in all the billboard controls in the Control table. The X coordinate exceeds the boundary of the minimum billboard control width %s","BBControl\tX\t[1]\t[2]");
ICE_ERROR(Ice95Y, 95, ietWarning, "The BBControl item '[1].[2]' in the BBControl table does not fit in all the billboard controls in the Control table. The Y coordinate exceeds the boundary of the minimum billboard control height %s","BBControl\tY\t[1]\t[2]");
ICE_ERROR(Ice95Width, 95, ietWarning, "The BBControl item '[1].[2]' in the BBControl table does not fit in all the billboard controls in the Control table. The X coordinate and the width combined together exceeds the minimum billboard control width %s","BBControl\tWidth\t[1]\t[2]");
ICE_ERROR(Ice95Height, 95, ietWarning, "The BBControl item '[1].[2]' in the BBControl table does not fit in all the billboard controls in the Control table. The Y coordinate and the height combined together exceeds the minimum billboard control height %s","BBControl\tHeight\t[1]\t[2]");

ICE_QUERY2(qIce95MinBillboard, "SELECT `Width`, `Height` FROM `Control` WHERE `Type` = 'Billboard' ORDER BY `Width`", Width, Height);
ICE_QUERY6(qIce95BBControl, "SELECT `Billboard_`, `BBControl`, `X`, `Y`, `Width`, `Height` FROM `BBControl`", Billboard_, BBControl, X, Y, Width, Height);

ICE_FUNCTION_DECLARATION(95)
{
	UINT		iStat;
	PMSIHANDLE	hDatabase;
	
	// display info
	DisplayInfo(hInstall, 95);

	hDatabase =::MsiGetActiveDatabase(hInstall);

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 95, TEXT("BBControl")) ||
	   !IsTablePersistent(FALSE, hInstall, hDatabase, 95, TEXT("Control")))
	{
		return ERROR_SUCCESS;
	}

	CQuery		qMinBillboard;
	PMSIHANDLE	hMinBillboard;
	CQuery		qBBControl;
	PMSIHANDLE	hBBControl;
	DWORD		dwMinWidth = 0;
	DWORD		dwMinHeight = 0;
	DWORD		dwHeight = 0;
	BOOL		bMin = TRUE;
	TCHAR		szWidth[50];
	TCHAR		szHeight[50];
	
	// Find the minimum height and width of all the Billboard controls.
	ReturnIfFailed(95, __LINE__, qMinBillboard.OpenExecute(hDatabase, NULL, qIce95MinBillboard::szSQL));
	while((iStat = qMinBillboard.Fetch(&hMinBillboard)) == ERROR_SUCCESS)
	{
		if(bMin == TRUE)
		{
			dwMinWidth = ::MsiRecordGetInteger(hMinBillboard, qIce95MinBillboard::Width);
			if(MSI_NULL_INTEGER == dwMinWidth)
			{
				APIErrorOut(hInstall, iStat, 95, __LINE__);
				qMinBillboard.Close();
				return ERROR_SUCCESS;
			}
			bMin = FALSE;
		}
		dwHeight = ::MsiRecordGetInteger(hMinBillboard, qIce95MinBillboard::Height);
		if(MSI_NULL_INTEGER == dwHeight)
		{
			APIErrorOut(hInstall, iStat, 95, __LINE__);
			qMinBillboard.Close();
			return ERROR_SUCCESS;
		}
		if(dwMinHeight == 0 || dwHeight < dwMinHeight)
		{
			dwMinHeight = dwHeight;
		}
	}
	qMinBillboard.Close();
	if(iStat != ERROR_NO_MORE_ITEMS)
	{
		APIErrorOut(hInstall, iStat, 95, __LINE__);
		return ERROR_SUCCESS;
	}

	_stprintf(szWidth, TEXT("%d"), dwMinWidth);
	_stprintf(szHeight, TEXT("%d"), dwMinHeight);

	// Compare each BBControl items with the minimum hight and width of a
	// billboard control. Only items that will fit into this virtual
	// billboard of minimum height and width will fit into all of the
	// billboard controls.
	ReturnIfFailed(95, __LINE__, qBBControl.OpenExecute(hDatabase, NULL, qIce95BBControl::szSQL));
	while((iStat = qBBControl.Fetch(&hBBControl)) == ERROR_SUCCESS)
	{
		DWORD	dwX = 0;
		DWORD	dwY = 0;
		DWORD	dwNum = 0;
		BOOL	bXError = FALSE;
		BOOL	bYError = FALSE;

		dwX = ::MsiRecordGetInteger(hBBControl, qIce95BBControl::X);
		if(MSI_NULL_INTEGER == dwX)
		{
			APIErrorOut(hInstall, iStat, 95, __LINE__);
			qBBControl.Close();
			return ERROR_SUCCESS;
		}
		if(dwX > dwMinWidth)
		{
			ICEErrorOut(hInstall, hBBControl, Ice95X, szWidth);
			bXError = TRUE;
		}

		dwY = ::MsiRecordGetInteger(hBBControl, qIce95BBControl::Y);
		if(MSI_NULL_INTEGER == dwY)
		{
			APIErrorOut(hInstall, iStat, 95, __LINE__);
			qBBControl.Close();
			return ERROR_SUCCESS;
		}
		if(dwY > dwMinHeight)
		{
			ICEErrorOut(hInstall, hBBControl, Ice95Y, szHeight);
			bYError = TRUE;
		}

		if(bXError == FALSE)
		{
			dwNum = ::MsiRecordGetInteger(hBBControl, qIce95BBControl::Width);
			if(MSI_NULL_INTEGER == dwNum)
			{
				APIErrorOut(hInstall, iStat, 95, __LINE__);
				qBBControl.Close();
				return ERROR_SUCCESS;
			}
			if(dwNum + dwX > dwMinWidth)
			{
				ICEErrorOut(hInstall, hBBControl, Ice95Width, szWidth);
			}
		}

		if(bYError == FALSE)
		{
			dwNum = ::MsiRecordGetInteger(hBBControl, qIce95BBControl::Height);
			if(MSI_NULL_INTEGER == dwNum)
			{
				APIErrorOut(hInstall, iStat, 95, __LINE__);
				qBBControl.Close();
				return ERROR_SUCCESS;
			}
			if(dwNum + dwY > dwMinHeight)
			{
				ICEErrorOut(hInstall, hBBControl, Ice95Height, szHeight);
			}
		}
	}
	qBBControl.Close();
	if(iStat != ERROR_NO_MORE_ITEMS)
	{
		APIErrorOut(hInstall, iStat, 95, __LINE__);
		return ERROR_SUCCESS;
	}

	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
// ICE96 -- Verifies that PublishFeatures and PublishProduct actions are
//			authored into the AdvtExecuteSequence table.
//
// Not shared with merge module.
//
#ifndef MODSHAREDONLY

ICE_ERROR(Ice96MissingFeaturesAction, 96, ietWarning, "The PublishFeatures action is required in the AdvtExecuteSequence table.","AdvtExecuteSequence");
ICE_ERROR(Ice96MissingProductAction, 96, ietWarning, "The PublishProduct action is required in the AdvtExecuteSequence table.","AdvtExecuteSequence");

ICE_QUERY1(qIce96FeaturesAction, "SELECT `Action` FROM `AdvtExecuteSequence` WHERE `Action` = 'PublishFeatures'", Action);
ICE_QUERY1(qIce96ProductAction, "SELECT `Action` FROM `AdvtExecuteSequence` WHERE `Action` = 'PublishProduct'", Action);

ICE_FUNCTION_DECLARATION(96)
{
	UINT		iStat;
	PMSIHANDLE	hDatabase;
	
	// display info
	DisplayInfo(hInstall, 96);

    hDatabase =::MsiGetActiveDatabase(hInstall);

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 94, TEXT("AdvtExecuteSequence")))
	{
		return ERROR_SUCCESS;
	}

	CQuery		qAction;
	PMSIHANDLE	hAction;
	PMSIHANDLE	hErr = ::MsiCreateRecord(1);

	iStat = qAction.FetchOnce(hDatabase, NULL, &hAction, qIce96FeaturesAction::szSQL);
	if(iStat == ERROR_NO_MORE_ITEMS)
	{
		ICEErrorOut(hInstall, hErr, Ice96MissingFeaturesAction);
	}
	else if(iStat != ERROR_SUCCESS)
	{
		APIErrorOut(hInstall, iStat, 96, __LINE__);
	}

	iStat = qAction.FetchOnce(hDatabase, NULL, &hAction, qIce96ProductAction::szSQL);
	if(iStat == ERROR_NO_MORE_ITEMS)
	{
		ICEErrorOut(hInstall, hErr, Ice96MissingProductAction);
	}
	else if(iStat != ERROR_SUCCESS)
	{
		APIErrorOut(hInstall, iStat, 96, __LINE__);
	}

	return ERROR_SUCCESS;
}

#endif // MODSHAREDONLY


///////////////////////////////////////////////////////////////////////////////
// ICE97 -- Verifies that more than one component that isolates the same 
//			shared component does not install into the same directory
//
// Not shared with merge module.
//
#ifndef MODSHAREDONLY

ICE_ERROR(Ice97SameDirtectory, 97, ietError, "This component [1] installs the Shared component into the same directory [2] as another. Will break component rules if both (or more) gets seleced for install.","IsolatedComponent\tComponent_Application\t%s\t[1]");

ICE_QUERY1(qIce97ComponentShared, "SELECT DISTINCT `Component_Shared` FROM `IsolatedComponent`", Component_Shared);
ICE_QUERY1(qIce97ComponentDirectory, "SELECT DISTINCT `Component`.`Directory_` FROM `Component`,`IsolatedComponent` WHERE `IsolatedComponent`.`Component_Shared` = ? AND `IsolatedComponent`.`Component_Application` = `Component`.`Component`", Directory_);
ICE_QUERY2(qIce97ComponentCulprit, "SELECT `Component`.`Component`, `Component`.`Directory_` FROM `Component`,`IsolatedComponent` WHERE `IsolatedComponent`.`Component_Shared` = ? AND `IsolatedComponent`.`Component_Application` = `Component`.`Component` AND `Component`.`Directory_` = '%s'", Component, Directory_);

ICE_FUNCTION_DECLARATION(97)
{
    TCHAR*  pszStr = new TCHAR[MAX_PATH];
    OUT_OF_MEMORY_RETURN(97, pszStr);
	UINT		iStat;
	PMSIHANDLE	hDatabase;
	
    // display info
	DisplayInfo(hInstall, 97);
    
    hDatabase =::MsiGetActiveDatabase(hInstall);

	if(!IsTablePersistent(FALSE, hInstall, hDatabase, 97, TEXT("IsolatedComponent")))
	{
		return ERROR_SUCCESS;
	}
	
	CQuery qComponentShared;

	ReturnIfFailed(97, __LINE__, qComponentShared.OpenExecute(hDatabase, 0,  qIce97ComponentShared::szSQL));

    PMSIHANDLE hRecComponentShared = NULL;
	while(ERROR_SUCCESS == (iStat = qComponentShared.Fetch(&hRecComponentShared)))
	{
		CQuery qComponentDirectory;
		ReturnIfFailed(97, __LINE__, qComponentDirectory.OpenExecute(hDatabase, hRecComponentShared,  qIce97ComponentDirectory::szSQL));
        
		PMSIHANDLE hRecDirectory = NULL;
		while(ERROR_SUCCESS == (iStat = qComponentDirectory.Fetch(&hRecDirectory)))
		{
			DWORD dwSize = MAX_PATH-2;
			UINT iStat = IceRecordGetString(hRecDirectory, 
				qIce97ComponentDirectory::Directory_, &pszStr, &dwSize, NULL);
			if(iStat != ERROR_SUCCESS)
			{
				APIErrorOut(hInstall, ERROR_FUNCTION_FAILED, 97, __LINE__);
                return ERROR_FUNCTION_FAILED;
			}	

			CQuery qComponentCulprit;
			ReturnIfFailed(97, __LINE__, qComponentCulprit.OpenExecute(hDatabase, hRecComponentShared,  qIce97ComponentCulprit::szSQL, pszStr));
            
			long il = 0;
			PMSIHANDLE hRec = NULL;
			while(ERROR_SUCCESS == (iStat = qComponentCulprit.Fetch(&hRec)))
			{
				if(++il > 1)	// Found more than one row of the same directory
					break;
			}

			if(il == 1)
			{
				continue; // no duplicates found
			}
			if(!il)
			{
				APIErrorOut(hInstall, ERROR_FUNCTION_FAILED, 97, __LINE__);
                continue;
			}
	
			CQuery qCulprit;
			ReturnIfFailed(97, __LINE__, qCulprit.OpenExecute(hDatabase, hRecComponentShared,  qIce97ComponentCulprit::szSQL, pszStr));
            
			PMSIHANDLE hRecCulprit = NULL;
			// Found one duplicate
			dwSize = MAX_PATH-2;
			iStat = IceRecordGetString(hRecComponentShared, 
				qIce97ComponentShared::Component_Shared, &pszStr, &dwSize, NULL);
			if(iStat != ERROR_SUCCESS)
			{
				APIErrorOut(hInstall, ERROR_FUNCTION_FAILED, 97, __LINE__);
                return ERROR_FUNCTION_FAILED;
			}	

			while(ERROR_SUCCESS == (iStat = qCulprit.Fetch(&hRecCulprit)))
			{
				ICEErrorOut(hInstall, hRecCulprit, Ice97SameDirtectory, pszStr);
            }
		}
	}

	return ERROR_SUCCESS;
}

#endif // MODSHAREDONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\msiice11.dll\msiice11.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
// 
//  File:       MsiICE11.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>  // included for both CPP and RC passes
#include <stdio.h>    // printf/wprintf
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "msidefs.h"  // must be in this directory or on INCLUDE path
#include "..\..\common\msiice.h"
#include "..\..\common\query.h"
#include "..\..\common\utilinc.cpp"


const int g_iFirstICE = 58;
const struct ICEInfo_t g_ICEInfo[] = 
{
	// ICE58
	{
		TEXT("ICE58"),
		TEXT("Created 04/08/1999. Last Modified 12/02/2000."),
		TEXT("ICE to ensure that you have fewer than 80 entries in the Media table."),
		TEXT("ice58.html")
	},
	// ICE59
	{ 
		TEXT("ICE59"),
		TEXT("Created 04/08/1999. Last Modified 04/08/1999."),
		TEXT("ICE to ensure that advertised shortcut targets install the component of the shortcut."),
		TEXT("ice59.html")
	},
	// ICE60
	{ 
		TEXT("ICE60"),
		TEXT("Created 04/13/1999. Last Modified 10/26/2000."),
		TEXT("Verifies that files in the file table which are not fonts have a valid version/language."),
		TEXT("ice60.html")
	},
	{
		TEXT(""),
		TEXT(""),
		TEXT(""),
		TEXT(""),
	},
	{
		TEXT("ICE62"),
		TEXT("Created 06/03/1999. Last Modified 06/21/1999."),
		TEXT("Performs a wide variety of IsolatedComponent checks."),
		TEXT("ice62.html"),
	},
	{
		TEXT("ICE63"),
		TEXT("Created 06/04/1999. Last Modified 07/21/1999."),
		TEXT("Validates sequence restrictions on RemoveExistingProducts"),
		TEXT("ice63.html"),
	},
	{
		TEXT("ICE64"),
		TEXT("Created 06/07/1999. Last Modified 01/17/2000."),
		TEXT("Checks that Profile directories are listed in the RemoveFile table."),
		TEXT("ice64.html"),
	},
	{
		TEXT("ICE65"),
		TEXT("Created 06/11/1999. Last Modified 06/21/1999."),
		TEXT("Checks that the Environment table does not have invalid prefix or append values."),
		TEXT("ice65.html"),
	},
	{
		TEXT("ICE66"),
		TEXT("Created 06/14/1999. Last Modified 10/05/2000."),
		TEXT("Determines the appropriate schema for the package and ensures that the marked schema is valid."),
		TEXT("ice66.html"),
	},
	{
		TEXT("ICE67"),
		TEXT("Created 06/17/1999. Last Modified 06/21/1999."),
		TEXT("Validates that shortcuts are installed by the component of their target."),
		TEXT("ice67.html"),
	},
	{
		TEXT("ICE68"),
		TEXT("Created 06/22/1999. Last Modified 04/19/2001."),
		TEXT("Checks that all custom actions are of a valid type."),
		TEXT("ice68.html"),
	},
	{
		TEXT("ICE69"),
		TEXT("Created 06/22/1999. Last Modified 02/02/2001."),
		TEXT("Checks for possible cross-component references with [$component] and [#filekey] literals in formatted string that could result in error"),
		TEXT("ice69.html"),
	},
	{
		TEXT("ICE70"),
		TEXT("Created 07/14/1999. Last Modified 07/21/1999."),
		TEXT("Checks that the characters following a # in a registry value are numeric"),
		TEXT("ice70.html"),
	},
	{
		TEXT("ICE71"),
		TEXT("Created 08/02/1999. Last Modified 08/02/1999."),
		TEXT("Verifies that the first media table entry starts with 1"),
		TEXT("ice71.html"),
	},
	{
		TEXT("ICE72"),
		TEXT("Created 10/11/1999. Last Modified 10/11/1999."),
		TEXT("Verifies that only built-in custom actions are used in the AdvtExecuteSequence table"),
		TEXT("ice72.html"),
	},
	{
		TEXT("ICE73"),
		TEXT("Created 10/28/1999. Last Modified 10/29/1999."),
		TEXT("Verifies that the package does not reuse package and product codes of Windows Installer SDK packages"),
		TEXT("ice73.html")
	},
	// ICE74
	{
		TEXT("ICE74"),
		TEXT("Created 01/14/2000. Last Modified 01/14/2000."),
		TEXT("ICE to ensure that the FASTOEM property does not exist in the database."),
		TEXT("ice74.html")
	},
	// ICE75
	{
		TEXT("ICE75"),
		TEXT("Created 02/08/2000. Last Modified 02/08/2000."),
		TEXT("ICE to ensure that custom actions whose source is an installed file are sequenced after CostFinalize."),
		TEXT("ice75.html")
	},
	// ICE76
	{
		TEXT("ICE76"),
		TEXT("Created 02/25/2000. Last modified 04/11/2000."),
		TEXT("ICE to ensure that files associated with SFP catalogs are not in the BindImage table."),
		TEXT("ice76.html")
	},
	// ICE77
	{
		TEXT("ICE77"),
		TEXT("Created 07/05/2000. Last modified 07/05/2000."),
		TEXT("ICE to ensure that inscript custom actions are scheduled between InstallInitialize and InstallFinalize."),
		TEXT("ice77.html")
	}
};
const int g_iNumICEs = sizeof(g_ICEInfo)/sizeof(struct ICEInfo_t);


///////////////////////////////////////////////////////////////////////
// ICE58, checks for too many media table entries.

// not shared with merge module subset
#ifndef MODSHAREDONLY
static const TCHAR sqlIce58Media[] = TEXT("SELECT * FROM `Media`");
ICE_ERROR(Ice58TooManyMedia, 58, ietWarning, "This package has %u media entries. Packages are limited to %u entries in the media table, unless using Windows Installer version 2.0 or greater.","Media");
static const int iIce58MaxMedia = 80;
static const int iIce58UnlimitedMediaMinSchema = 150;

ICE_FUNCTION_DECLARATION(58)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 58);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 58, TEXT("Media")))
		return ERROR_SUCCESS;

	// if package only supports schema 150 or greater, we can skip validation since Windows Installer versions 2.0 and greater
	// support more than 80 media entries
	PMSIHANDLE hSummaryInfo=0;
	if (IceGetSummaryInfo(hInstall, hDatabase, 58, &hSummaryInfo))
	{
		int iPackageSchema = 0;
		UINT iType = 0; 
		FILETIME ft;
		TCHAR szBuf[1];
		DWORD dwBuf = sizeof(szBuf)/sizeof(TCHAR);
		ReturnIfFailed(58, 3, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_PAGECOUNT, &iType, &iPackageSchema, &ft, szBuf, &dwBuf));
		if (iPackageSchema >= iIce58UnlimitedMediaMinSchema)
			return ERROR_SUCCESS; // package can only be installed on WI version 2.0 or greater
	}

	CQuery qMedia;
	unsigned int cMedia = 0;
	PMSIHANDLE hMediaRec;
	ReturnIfFailed(58, 1, qMedia.OpenExecute(hDatabase, 0, sqlIce58Media));
	
	// count media entries
	while (ERROR_SUCCESS == (iStat = qMedia.Fetch(&hMediaRec)))
		cMedia++;
	if (cMedia > iIce58MaxMedia)
	{
		PMSIHANDLE hRec = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRec, Ice58TooManyMedia, cMedia, iIce58MaxMedia);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 58, 2);

	return ERROR_SUCCESS;
};
#endif

///////////////////////////////////////////////////////////////////////
// ICE59, checks that advertised shortcuts correctly map their 
// component to the feature containing the target

// not shared with merge module subset
#ifndef MODSHAREDONLY
static const TCHAR sqlIce59Shortcut[] = TEXT("SELECT `Shortcut`.`Target`,`Shortcut`.`Component_`,`Shortcut`.`Shortcut` FROM `Shortcut`,`Feature` WHERE (`Shortcut`.`Target`=`Feature`.`Feature`)");
static const TCHAR sqlIce59FeatureComponents[] = TEXT("SELECT * FROM `FeatureComponents` WHERE `Feature_`=? AND `Component_`=?");
ICE_ERROR(Ice59BadMapping, 59, ietError, "The shortcut [3] activates component [2] and advertises feature [1], but there is no mapping between [1] and [2] in the FeatureComponents table.","Shortcut\tShortcut\t[3]");
ICE_ERROR(Ice59NoFeatureC, 59, ietError, "The shortcut [3] activates component [2] and advertises feature [1]. You should have a FeatureComponents table with a row associating [1] and [2].","Shortcut\tShortcut\t[3]");

ICE_FUNCTION_DECLARATION(59)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 59);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if no shortcut table, no possible errors. If no Feature table, no advertised 
	// shortcuts, so no possible errors
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 59, TEXT("Shortcut")) ||
		!IsTablePersistent(FALSE, hInstall, hDatabase, 59, TEXT("Feature")))
		return ERROR_SUCCESS;

	bool bFeatureComponents = IsTablePersistent(FALSE, hInstall, hDatabase, 58, TEXT("FeatureComponents"));

	CQuery qShortcut;
	CQuery qFeatureC;
	PMSIHANDLE hShortcut;
	PMSIHANDLE hFeatureC;
	ReturnIfFailed(59, 1, qShortcut.OpenExecute(hDatabase, 0, sqlIce59Shortcut));
	if (bFeatureComponents)
		ReturnIfFailed(59, 2, qFeatureC.Open(hDatabase, sqlIce59FeatureComponents));
	
	// check every advertised shortcut
	while (ERROR_SUCCESS == (iStat = qShortcut.Fetch(&hShortcut)))
	{
		// Check the FeatureComponents table for the mapping. It should exist.
		if (bFeatureComponents)
		{
			ReturnIfFailed(59,3, qFeatureC.Execute(hShortcut));
			iStat = qFeatureC.Fetch(&hFeatureC);
			switch (iStat)
			{
			case ERROR_NO_MORE_ITEMS:
				ICEErrorOut(hInstall, hShortcut, Ice59BadMapping);
				break;
			case ERROR_SUCCESS:
				break;
			default:
				APIErrorOut(hInstall, iStat, 59, 4);
			}
		}
		else
			ICEErrorOut(hInstall, hShortcut, Ice59NoFeatureC);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 59, 5);

	return ERROR_SUCCESS;
};
#endif

///////////////////////////////////////////////////////////////////////
// ICE60, checks that any versions in the file table have languages.
// (more accurrately, that anything without a language is a companion
// file reference or a font.)
static const TCHAR sqlIce60File[] = TEXT("SELECT `Version`, `File` FROM `File` WHERE `Language` IS NULL AND `Version` IS NOT NULL");
static const TCHAR sqlIce60Companion[] = TEXT("SELECT `File` FROM `File` WHERE `File`=?");
static const TCHAR sqlIce60Font[] = TEXT("SELECT `File_` FROM `Font` WHERE `File_`=? OR `File_`=?");

// Query for all Font files with non-null language column.
ICE_QUERY1(sqlIce60BadFont, "SELECT `File` FROM `Font`, `File` WHERE `Font`.`File_` = `File`.`File` AND `Language` IS NOT NULL", File);

// Query for all MsiFileHash entries that are versioned
ICE_QUERY1(sqlIce60VersionedAndHashed, "SELECT `Version`, `File` FROM `File`, `MsiFileHash` WHERE `MsiFileHash`.`File_` = `File`.`File` AND `Version` IS NOT NULL", File);

ICE_ERROR(Ice60NeedLanguage, 60, ietWarning, "The file [2] is not a Font, and its version is not a companion file reference. It should have a language specified in the Language column.","File\tVersion\t[2]");
// Font files can not have language.
ICE_ERROR(Ice60BadFont, 60, ietWarning, "The file [1] is a font, its language should be null.","File\tLanguage\t[1]");
ICE_ERROR(Ice60VersionedAndHashed, 60, ietError, "The file [1] is Versioned. It cannot be hashed","MsiFileHash\tFile_\t[1]");

ICE_FUNCTION_DECLARATION(60)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 60);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 60, TEXT("File")))
		return ERROR_SUCCESS;
	bool bFont = IsTablePersistent(FALSE, hInstall, hDatabase, 60, TEXT("Font"));

	CQuery qFont;
	CQuery qFile;
	CQuery qCompanion;

	PMSIHANDLE hFile;
	PMSIHANDLE hCompanion;
	ReturnIfFailed(60, 1, qFile.OpenExecute(hDatabase, 0, sqlIce60File));
	ReturnIfFailed(60, 2, qCompanion.Open(hDatabase, sqlIce60Companion));
	if (bFont)
		ReturnIfFailed(60, 3, qFont.Open(hDatabase, sqlIce60Font));

	// fetch all files with null languages
	while (ERROR_SUCCESS == (iStat = qFile.Fetch(&hFile)))
	{
		// check if the file is a companion reference
		PMSIHANDLE hNotUsed;
		ReturnIfFailed(60, 4, qCompanion.Execute(hFile));
		switch (iStat = qCompanion.Fetch(&hNotUsed)) 
		{
		case ERROR_NO_MORE_ITEMS:
			// not a companion file, keep checking
			break;
		case ERROR_SUCCESS:
			// is a companion file, move on.
			continue;
		default:
			APIErrorOut(hInstall, iStat, 60, 5);
			return ERROR_SUCCESS;
		}

		// fonts are exempt, so check the font table
		if (bFont)
		{
			// this is a bit repetitive because we check the first two columns against
			// the font table, but we already know the file is not a companion
			// reference, so the first column will never be true (unless the 
			// font table is messed up.) But it keeps us from playing games
			// with the record to get the query params in the right order.
			ReturnIfFailed(60, 6, qFont.Execute(hFile));
			switch (iStat = qFont.Fetch(&hNotUsed)) 
			{
			case ERROR_NO_MORE_ITEMS:
				// not a font, keep checking
				break;
			case ERROR_SUCCESS:
				// is a font, so exempt from the check
				continue;
			default:
				APIErrorOut(hInstall, iStat, 60, 7);
				return ERROR_SUCCESS;
			}
		}

		// not a companion reference and not a font. We should have a language
		// in this row.
		ICEErrorOut(hInstall, hFile, Ice60NeedLanguage);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
    {
		APIErrorOut(hInstall, iStat, 60, 8);
        return ERROR_SUCCESS;
    }

	if(bFont)
	{
		// Font table exists. Give warnings to font files with Languages.
		CQuery		qBadFont;
		PMSIHANDLE	hBadFontFile;

		qBadFont.OpenExecute(hDatabase, 0, sqlIce60BadFont::szSQL);
		while((iStat = qBadFont.Fetch(&hBadFontFile)) == ERROR_SUCCESS)
		{
			ICEErrorOut(hInstall, hBadFontFile, Ice60BadFont);
		}
		qBadFont.Close();
		if(iStat != ERROR_NO_MORE_ITEMS)
		{
			APIErrorOut(hInstall, iStat, 60, 9);
            return ERROR_SUCCESS;
		}
	}

    if(IsTablePersistent(FALSE, hInstall, hDatabase, 60, TEXT("MsiFileHash")))
    {
        qFile.Close();
		qFile.OpenExecute(hDatabase, 0, sqlIce60VersionedAndHashed::szSQL);
		PMSIHANDLE hNotUsed;
		qCompanion.Close();
		ReturnIfFailed(60, 7, qCompanion.Open(hDatabase, sqlIce60Companion));
		while((iStat = qFile.Fetch(&hFile)) == ERROR_SUCCESS)
		{
            ReturnIfFailed(60, 8, qCompanion.Execute(hFile));
			if(qCompanion.Fetch(&hNotUsed) != ERROR_SUCCESS)
				ICEErrorOut(hInstall, hFile, Ice60VersionedAndHashed);
		}
		qFile.Close();
		qCompanion.Close();
		if(iStat != ERROR_NO_MORE_ITEMS)
		{
			APIErrorOut(hInstall, iStat, 60, 9);
            return ERROR_SUCCESS;
		}
        
    }
	return ERROR_SUCCESS;
};

///////////////////////////////////////////////////////////////////////
// ICE61 VBScript ICE, checks upgrade table

///////////////////////////////////////////////////////////////////////
// ICE62, checks for a wide variety of problems with Fusion tables.

// not shared with merge module subset
#ifndef MODSHAREDONLY

ICE_ERROR(Ice62BadKeyPath, 62, ietError, "The component '[1]' is listed as an isolated application component in the IsolatedComponent table, but the key path is not a file.", "IsolatedComponent\tComponent_Application\t[3]\t[1]");
ICE_ERROR(Ice62NoSharedDll, 62, ietError, "The component '[1]' is listed as an isolated shared component in the IsolatedComponent table, but is not marked with the SharedDllRefCount component attribute.", "IsolatedComponent\tComponent_Shared\t[1]\t[3]");
ICE_ERROR(Ice62BadFeatureMapping, 62, ietError, "The isolated shared component '[2]' is not installed by the same feature as (or a parent feature of) its isolated application component '[3]' (which is installed by feature '[1]').", "IsolatedComponent\tComponent_Shared\t[2]\t[3]");
ICE_ERROR(Ice62SharedCondition, 62, ietWarning, "The isolated shared component '[1]' (referenced in the IsolatedComponent table) is conditionalized. Isolated shared component conditions should never change from TRUE to FALSE after the first install of the product.", "Component\tCondition\t[1]");
ICE_ERROR(Ice62Multiple, 62, ietWarning, "The isolated shared component '[1]' is shared by multiple applications (including '[2]') that are installed to the directory `[3]'.", "IsolatedComponent\tComponent_Shared\t[1]\t[2]");

// checks for bad attributes in either shared or application component
static const TCHAR sqlIce62SharedComponentAttributes[] = TEXT("SELECT `Component`.`Component`, `Component`.`Attributes`, `IsolatedComponent`.`Component_Application` FROM `Component`, `IsolatedComponent` WHERE `Component`.`Component`=`IsolatedComponent`.`Component_Shared`");
static const TCHAR sqlIce62AppComponentAttributes[] = TEXT("SELECT `Component`.`Component`, `Component`.`Attributes`, `IsolatedComponent`.`Component_Shared` FROM `Component`, `IsolatedComponent` WHERE `Component`.`Component`=`IsolatedComponent`.`Component_Application`");
static const int iColIce62ComponentAttributes_Component  = 1;
static const int iColIce62ComponentAttributes_Attributes = 2;

// queries for feature-parent checks
static const TCHAR sqlIce62AppFeature[] = TEXT("SELECT `FeatureComponents`.`Feature_`, `Component_Shared`, `Component_Application` FROM `FeatureComponents`, `IsolatedComponent` WHERE `Component_Application`=`FeatureComponents`.`Component_`");
static const int iColIce62AppFeature_Feature  = 1;
static const int iColIce62AppFeature_Component = 2;

static const TCHAR sqlIce62SharedFeatureC[] = TEXT("SELECT `Feature_` FROM `FeatureComponents` WHERE `Feature_`=? AND `Component_`=?");
static const int iColIce62SharedFeatureC_Feature  = 1;

static const TCHAR sqlIce62FeatureParent[] = TEXT("SELECT `Feature_Parent` FROM `Feature` WHERE `Feature`=?");
static const int iColIce62FeatureParent_Feature  = 1;

// checks for non-null conditions
static const TCHAR sqlIce62Conditions[] = TEXT("SELECT `Component` FROM `IsolatedComponent`, `Component` WHERE `Component_Shared`=`Component` AND `Component`.`Condition` IS NOT NULL");

// checks for multiple applications sharing a component in the same place
static const TCHAR sqlIce62DirComps[] = TEXT("SELECT `Component_Shared`, `Component`.`Directory_`, `Component_Application` FROM `IsolatedComponent`, `Component` WHERE `Component_Application`=`Component`");
static const TCHAR sqlIce62SameDirComps[] = TEXT("SELECT `Component_Shared`, `Component_Application`, `Component`.`Directory_` FROM `IsolatedComponent`, `Component` WHERE `Component_Shared`=`Component` AND `Component_Shared`=? AND `Component`.`Directory_`=? AND `Component_Application`<>?");

ICE_FUNCTION_DECLARATION(62)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 62);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	
	// if theres no IsolatedComponents table, there's nothing to check
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 62, TEXT("IsolatedComponent")))
		return ERROR_SUCCESS;

	// if theres no component table, there's nothing to check either. If there's data
	// in the IsolatedComponents table, it will be flagged as bad foreign key by ICE03
	// so its not required that we check that here.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 62, TEXT("Component")))
		return ERROR_SUCCESS;

	// first check the attributes of every component that is an isolated application component
	// these must marked as file keypaths, not registry or ODBC. Note that we don't actually
	// care if the key to the file table is valid. Again, that is not a fusion specific error 
	// and will be checked by some other ICE (03 again).
	CQuery qAppComponent;
	PMSIHANDLE hComponent = 0;
	ReturnIfFailed(62, 1, qAppComponent.OpenExecute(hDatabase, 0, sqlIce62AppComponentAttributes));
	while (ERROR_SUCCESS == (iStat = qAppComponent.Fetch(&hComponent)))
	{
		DWORD dwAttributes = ::MsiRecordGetInteger(hComponent, iColIce62ComponentAttributes_Attributes);
		if (dwAttributes & (msidbComponentAttributesRegistryKeyPath | msidbComponentAttributesODBCDataSource))
			ICEErrorOut(hInstall, hComponent, Ice62BadKeyPath);

	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 62, 2);
		return ERROR_SUCCESS;
	}
		
	// next check the attributes of every component that is a a shared isolated component
	// these must marked as ShaerdDllRefCount
	CQuery qSharedComponent;
	ReturnIfFailed(62, 3, qSharedComponent.OpenExecute(hDatabase, 0, sqlIce62SharedComponentAttributes));
	while (ERROR_SUCCESS == (iStat = qSharedComponent.Fetch(&hComponent)))
	{
		DWORD dwAttributes = ::MsiRecordGetInteger(hComponent, iColIce62ComponentAttributes_Attributes);
		if (!(dwAttributes & msidbComponentAttributesSharedDllRefCount))
			ICEErrorOut(hInstall, hComponent, Ice62NoSharedDll);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 62, 4);
		return ERROR_SUCCESS;
	}

	// next check the feature relationship for each shared/app mapping. The shared 
	// component must be in the same feature as, or a parent feature of, the app.

	// if we don't have a feature or feature components table, we can't do this check.
	// Some other ICE checks that every component belongs to a feature, thats not our
	// job. (its ICE21s) 
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 62, TEXT("Feature")) &&
		IsTablePersistent(FALSE, hInstall, hDatabase, 62, TEXT("FeatureComponents")))
	{
		// retrieve the app component and its feature. If the row doesn't exist, it means
		// the feature doesn't map to a component. Thats not our job.
		CQuery qAppFeature;
		CQuery qSharedFeatureC;
		CQuery qFeatureParent;
		PMSIHANDLE hIsoComponent;
		ReturnIfFailed(62, 5, qAppFeature.OpenExecute(hDatabase, 0, sqlIce62AppFeature));
		ReturnIfFailed(62, 6, qSharedFeatureC.Open(hDatabase, sqlIce62SharedFeatureC));
		ReturnIfFailed(62, 7, qFeatureParent.Open(hDatabase, sqlIce62FeatureParent));
		while (ERROR_SUCCESS == (iStat = qAppFeature.Fetch(&hIsoComponent)))
		{	
			// we're going to need the component record undamaged in order to give a 
			// useful error message, so make a copy of the Feature and SharedC part
			// to use as a work-record in the queries
			PMSIHANDLE hComponent = ::MsiCreateRecord(2);
			{
			TCHAR *szTemp = NULL;
			DWORD cchTemp = 0;
			ReturnIfFailed(62, 8, IceRecordGetString(hIsoComponent, iColIce62AppFeature_Feature, &szTemp, &cchTemp, NULL));
			MsiRecordSetString(hComponent, iColIce62AppFeature_Feature, szTemp);
			ReturnIfFailed(62, 9, IceRecordGetString(hIsoComponent, iColIce62AppFeature_Component, &szTemp, &cchTemp, NULL));
			MsiRecordSetString(hComponent, iColIce62AppFeature_Component, szTemp);
			delete[] szTemp, szTemp=NULL;
			}
			
			bool fFound = false;
			bool fError = false;
			do 
			{
				// in the hAppFeature record is Feature, SharedComponent. See if that mapping is 
				// in the FeatureComponents table.
				PMSIHANDLE hNewComponent;
				ReturnIfFailed(62,10, qSharedFeatureC.Execute(hComponent));
				switch (iStat = qSharedFeatureC.Fetch(&hNewComponent))
				{
				case ERROR_SUCCESS:
					// found the feature component mapping we were looking for.
					fFound = true;
					break;
				case ERROR_NO_MORE_ITEMS:
					// didn't find it. Move on to the parent feature below
					break;
				default:
					APIErrorOut(hInstall, iStat, 62, 11);
					return ERROR_SUCCESS;
				}
				
				if (!fFound)
				{
					// no luck. Get the parent of this feature and the shared component, and put it 
					// back in the same record.
					PMSIHANDLE hParentFeature;
					ReturnIfFailed(62, 12, qFeatureParent.Execute(hComponent));
					switch (iStat = qFeatureParent.Fetch(&hParentFeature))
					{
					case ERROR_SUCCESS:
					{
						// found the parent feature. Thats good, but bad for us because 
						// now we have to move strings around to set up for the next
						// query of the FeatureComponents table
						TCHAR *szParentFeature = NULL;
						ReturnIfFailed(62, 13, IceRecordGetString(hParentFeature, iColIce62FeatureParent_Feature,
							&szParentFeature, NULL, NULL));
						ReturnIfFailed(62, 14, MsiRecordSetString(hComponent, 1, szParentFeature));
						delete[] szParentFeature, szParentFeature=NULL;
						break;
					}
					case ERROR_NO_MORE_ITEMS:
						// no entry for the feature at all. Thats not good. Its an error
						fError=true;
						break;
					default:
						APIErrorOut(hInstall, iStat, 62, 15);
						return ERROR_SUCCESS;
					}
				}
					
				// if no parent, no further features to check.
			} while (!fFound && !fError && !::MsiRecordIsNull(hComponent, iColIce62FeatureParent_Feature));

			// no match for this entry
			if (!fFound)
				ICEErrorOut(hInstall, hIsoComponent, Ice62BadFeatureMapping);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 62, 16);
			return ERROR_SUCCESS;
		}
	}

	if (IsTablePersistent(FALSE, hInstall, hDatabase, 62, TEXT("Component")))
	{
		// check if any shared components have conditions. If they do, give a arning
		// that they can't change from TRUE to FALSE during the lifetime of a single install
		CQuery qCondition;
		PMSIHANDLE hComponent;
		ReturnIfFailed(62, 17, qCondition.OpenExecute(hDatabase, 0, sqlIce62Conditions));
		while (ERROR_SUCCESS == (iStat = qCondition.Fetch(&hComponent)))
		{
			ICEErrorOut(hInstall, hComponent, Ice62SharedCondition);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 62, 18);
			return ERROR_SUCCESS;
		}

		// check for shared components isolated in the same directory with multiple applications.
		CQuery qSameDirComp;
		CQuery qDirComp;
		ReturnIfFailed(62, 19, qSameDirComp.Open(hDatabase,sqlIce62SameDirComps));
		ReturnIfFailed(62, 20, qDirComp.OpenExecute(hDatabase, 0, sqlIce62DirComps));
		PMSIHANDLE hApp;
		while (ERROR_SUCCESS == (iStat = qDirComp.Fetch(&hApp)))
		{
			ReturnIfFailed(62, 21, qSameDirComp.Execute(hApp));
			while (ERROR_SUCCESS == (iStat = qSameDirComp.Fetch(&hComponent)))
			{
				ICEErrorOut(hInstall, hComponent, Ice62Multiple);
			}
			if (ERROR_NO_MORE_ITEMS != iStat)
			{
				APIErrorOut(hInstall, iStat, 62, 22);
				return ERROR_SUCCESS;
			}		
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 62, 23);
			return ERROR_SUCCESS;
		}
		
	}

	// check for multiple applications in the same directory that have the same shared component
	
	return ERROR_SUCCESS;
}
#endif


///////////////////////////////////////////////////////////////////////
// ICE63 Checks sequencing of RemoveExistingProducts

// not shared with merge module subset
#ifndef MODSHAREDONLY
static const TCHAR sqlIce63GetIISeqNum[] = TEXT("SELECT `Sequence` FROM `InstallExecuteSequence` WHERE `Action`='InstallInitialize'");
static const TCHAR sqlIce63GetIVSeqNum[] = TEXT("SELECT `Sequence` FROM `InstallExecuteSequence` WHERE `Action`='InstallValidate'");
static const TCHAR sqlIce63GetIESeqNum[] = TEXT("SELECT `Sequence` FROM `InstallExecuteSequence` WHERE `Action`='InstallExecute'");
static const TCHAR sqlIce63GetIEASeqNum[] =TEXT("SELECT `Sequence` FROM `InstallExecuteSequence` WHERE `Action`='InstallExecuteAgain'");
static const TCHAR sqlIce63GetIFSeqNum[] = TEXT("SELECT `Sequence` FROM `InstallExecuteSequence` WHERE `Action`='InstallFinalize'");
static const TCHAR sqlIce63GetREPSeqNum[] = TEXT("SELECT `Sequence` FROM `InstallExecuteSequence` WHERE `Action`='RemoveExistingProducts'");
static const int iColIce63GetIXSeqNum_Sequence = 1;

static const TCHAR sqlIce63GetActionsBetweenIEandREP[] = TEXT("SELECT `Action`, `Sequence` FROM `InstallExecuteSequence` WHERE (`Sequence`>=?) AND (`Sequence`<=?) AND (`Action` <> 'InstallExecute') AND (`Action` <> 'RemoveExistingProducts') AND (`Action` <> 'InstallExecuteAgain') ORDER BY `Sequence`");
static const TCHAR sqlIce63GetActionsBetweenIIandREP[] = TEXT("SELECT `Action`, `Sequence` FROM `InstallExecuteSequence` WHERE (`Sequence`>=?) AND (`Sequence`<=?) AND (`Action` <> 'RemoveExistingProducts') AND (`Action` <> 'InstallInitialize') ORDER BY `Sequence`");

ICE_ERROR(Ice63BetweenIEandIF, 63, ietWarning, "Some action falls between InstallExecute(Again) and RemoveExistingProducts (before InstallFinalize).", "InstallExecuteSequence\tAction\tRemoveExistingProducts"); 
ICE_ERROR(Ice63NotAfterII, 63, ietWarning, "Some action falls between InstallInitialize and RemoveExistingProducts.", "InstallExecuteSequence\tAction\tRemoveExistingProducts"); 
ICE_ERROR(Ice63BadPlacement, 63, ietError, "RemoveExistingProducts action is in an invalid location.", "InstallExecuteSequence\tAction\tRemoveExistingProducts"); 

ICE_FUNCTION_DECLARATION(63)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 63);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	
	// if theres no IES table, there's nothing to check, as REP can only be
	// in the IES table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 63, TEXT("InstallExecuteSequence")))
		return ERROR_SUCCESS;

	// retrieve REP Sequence number
	CQuery qGetSeqNum;
	PMSIHANDLE hResult;
	UINT uiREPSeq = 0;
	switch (iStat = qGetSeqNum.FetchOnce(hDatabase, 0, &hResult, sqlIce63GetREPSeqNum))
	{
	case ERROR_NO_MORE_ITEMS:
		// if no REP action, nothing to check
		return ERROR_SUCCESS; 
	case ERROR_SUCCESS:
		uiREPSeq = ::MsiRecordGetInteger(hResult, iColIce63GetIXSeqNum_Sequence);
		break;
	default:
		APIErrorOut(hInstall, iStat, 63, 1);	
		return ERROR_SUCCESS;
	}
		
	////
	// first check is betwen InstallValidate and InstallInitialize. This is an OK spot.

	// we need the sequence numbers for InstallInitialize and InstallValidate
	UINT uiIVSeq = 0;
	UINT uiIISeq = 0;
	bool fCheckIVtoII = true;
	bool fCheckII = true;
	iStat = qGetSeqNum.FetchOnce(hDatabase, 0, &hResult, sqlIce63GetIISeqNum);
	if (iStat == ERROR_NO_MORE_ITEMS)
	{
		fCheckIVtoII = false;
		fCheckII = false;
	}
	else if (iStat == ERROR_SUCCESS)
		uiIISeq = ::MsiRecordGetInteger(hResult, iColIce63GetIXSeqNum_Sequence);
	else
	{
		APIErrorOut(hInstall, iStat, 63, 2);	
		return ERROR_SUCCESS;
	}

	iStat = qGetSeqNum.FetchOnce(hDatabase, 0, &hResult, sqlIce63GetIVSeqNum);
	if (iStat == ERROR_NO_MORE_ITEMS)
		fCheckIVtoII = false;
	else if (iStat == ERROR_SUCCESS)
		uiIVSeq = ::MsiRecordGetInteger(hResult, iColIce63GetIXSeqNum_Sequence);
	else
	{
		APIErrorOut(hInstall, iStat, 63, 3);	
		return ERROR_SUCCESS;
	}

	// if it falls in the range InstallValidate to InstallInitalize, thats good.
	if (fCheckIVtoII && uiREPSeq > uiIVSeq && uiREPSeq < uiIISeq)
		return ERROR_SUCCESS;

	////
	// second check is after InstallFinalize. This is an OK spot.
	bool fCheckIF = true;
	UINT uiIFSeq = 0;
	iStat = qGetSeqNum.FetchOnce(hDatabase, 0, &hResult, sqlIce63GetIFSeqNum);
	if (iStat == ERROR_NO_MORE_ITEMS)
		fCheckIF = false;
	else if (iStat == ERROR_SUCCESS)
		uiIFSeq = ::MsiRecordGetInteger(hResult, iColIce63GetIXSeqNum_Sequence);
	else
	{
		APIErrorOut(hInstall, iStat, 63, 4);	
		return ERROR_SUCCESS;
	}

	// if it falls after InstallFinalize, thats good.
	if (fCheckIF && uiREPSeq > uiIFSeq)
		return ERROR_SUCCESS;
	
	////
	// third check is that it is after InstallExecute (or InstallExecuteAgain)
	// and before InstallFinalize. This is a warning.
	bool fCheckIE = false;
	UINT uiIESeq = 0;
	iStat = qGetSeqNum.FetchOnce(hDatabase, 0, &hResult, sqlIce63GetIESeqNum);
	if (iStat == ERROR_NO_MORE_ITEMS)
	{
		// no action, because IEA might exist.
	}
	else if (iStat == ERROR_SUCCESS)
	{
		fCheckIE = true;	
		uiIESeq = ::MsiRecordGetInteger(hResult, iColIce63GetIXSeqNum_Sequence);
	}
	else
	{
		APIErrorOut(hInstall, iStat, 63, 5);	
		return ERROR_SUCCESS;
	}

	// get sequence number for InstallExecuteAgain
	UINT uiIEASeq = 0;
	iStat = qGetSeqNum.FetchOnce(hDatabase, 0, &hResult, sqlIce63GetIEASeqNum);
	if (iStat == ERROR_NO_MORE_ITEMS)
	{
		// no action, because IE might exist.
	}
	else if (iStat == ERROR_SUCCESS)
	{
		uiIEASeq = ::MsiRecordGetInteger(hResult, iColIce63GetIXSeqNum_Sequence);
		fCheckIE = true;	
	}
	else
	{
		APIErrorOut(hInstall, iStat, 63, 6);
		return ERROR_SUCCESS;
	}

	// if it falls in the range, we need to check for other actions in this range
	if (fCheckIE)
	{	
		UINT uiSmaller = ((uiIESeq == 0) || ((uiIEASeq != 0) && (uiIEASeq < uiIESeq))) ? uiIEASeq : uiIESeq;
		UINT uiLarger =  ((uiIESeq == 0) || ((uiIEASeq != 0) && (uiIEASeq > uiIESeq))) ? uiIEASeq : uiIESeq;
		UINT uiRangeStart = 0;
		
		if (uiLarger < uiREPSeq && uiREPSeq < uiIFSeq)
		{
			// it falls in the smaller range.
			uiRangeStart = uiLarger;
		}
		else if (uiSmaller < uiREPSeq && uiREPSeq < uiIFSeq)
		{
			// it falls in the larger range
			uiRangeStart = uiSmaller;
		}
		// else
			// it doesn't fall in either range

		// if it fell in any range
		if (uiRangeStart != 0)
		{
			PMSIHANDLE hExecRec = ::MsiCreateRecord(2);
			MsiRecordSetInteger(hExecRec, 1, uiRangeStart);
			MsiRecordSetInteger(hExecRec, 2, uiREPSeq);	
			CQuery qRange;
			iStat = qRange.FetchOnce(hDatabase, hExecRec, &hResult, sqlIce63GetActionsBetweenIEandREP);
			switch (iStat)
			{
			case ERROR_SUCCESS:
				// some other action interefered, thats a warning
				ICEErrorOut(hInstall, hResult, Ice63BetweenIEandIF);
				break;
			case ERROR_NO_MORE_ITEMS:
				// no action is between IE[A] and REP. Good placement.
				break;
			default:
				APIErrorOut(hInstall, iStat, 63, 7);
				break;
			}
			return ERROR_SUCCESS;
		}
	}

	////
	// the last possible location is immediately after InstallInitailize
	if (fCheckII && uiREPSeq > uiIISeq)
	{
		PMSIHANDLE hExecRec = ::MsiCreateRecord(2);
		MsiRecordSetInteger(hExecRec, 1, uiIISeq);
		MsiRecordSetInteger(hExecRec, 2, uiREPSeq);	
		CQuery qRange;
		iStat = qRange.FetchOnce(hDatabase, hExecRec, &hResult, sqlIce63GetActionsBetweenIIandREP);
		switch (iStat)
		{
		case ERROR_SUCCESS:
			// some other action interefered, thats a warning
			ICEErrorOut(hInstall, hResult, Ice63NotAfterII);
			break;
		case ERROR_NO_MORE_ITEMS:
			// no action is between IE[A] and REP. Good placement.
			break;
		default:
			APIErrorOut(hInstall, iStat, 63, 8);
			break;
		}
		return ERROR_SUCCESS;	
	}

	// it didn't pop up anywhere good, so its an error.
	ICEErrorOut(hInstall, hResult, Ice63BadPlacement);
	
	return ERROR_SUCCESS;
}
#endif

///////////////////////////////////////////////////////////////////////
// ICE64 Verifies that new profile dirs won't be left behind
// during an uninstall for a roaming user.

// not shared with merge module subset
#ifndef MODSHAREDONLY
const TCHAR sqlIce64Profile[] = TEXT("SELECT `Directory` FROM `Directory` WHERE `_Profile`=2");
const TCHAR sqlIce64RemoveFile[] = TEXT("SELECT `FileKey` FROM `RemoveFile` WHERE `DirProperty`=? AND `FileName` IS NULL");
const TCHAR sqlIce64FreeDir[] = TEXT("ALTER TABLE `Directory` FREE");

ICE_ERROR(Ice64BadDir, 64, ietError, "The directory [1] is in the user profile but is not listed in the RemoveFile table.", "Directory\tDirectory\t[1]");

ICE_FUNCTION_DECLARATION(64)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 64);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if theres no directory table, nothing to check.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 64, TEXT("Directory")))
		return ERROR_SUCCESS;

	// MarkProfile adds a HOLD count to the Directory table.  We want to make sure this HOLD count
	// is freed when the ICE exits (whether at the end, or due to Internal ICE Failure)
	CManageTable MngDirectoryTable(hDatabase, TEXT("Directory"), /*fAlreadyLocked = */true);

	// mark every directory that is in the profile
	if (!MarkProfile(hInstall, hDatabase, 64, true, true))
		return ERROR_SUCCESS;

	// without a RemoveFile table, output an error for every profile dir.
	bool fRemoveFile = IsTablePersistent(FALSE, hInstall, hDatabase, 64, TEXT("RemoveFile"));

	CQuery qProfileDir;
	CQuery qRemoveFile;
	PMSIHANDLE hDirRec = 0;
	PMSIHANDLE hRemFile = 0;
	ReturnIfFailed(64, 1, qProfileDir.OpenExecute(hDatabase, 0, sqlIce64Profile));
	if (fRemoveFile)
		ReturnIfFailed(64, 2, qRemoveFile.Open(hDatabase, sqlIce64RemoveFile));
		
	// query for every marked profile directory
	while (ERROR_SUCCESS == (iStat = qProfileDir.Fetch(&hDirRec)))
	{
		if (fRemoveFile)
		{
			// and see if it is in the RemoveFile table
			ReturnIfFailed(64, 3, qRemoveFile.Execute(hDirRec));
			iStat = qRemoveFile.Fetch(&hRemFile);
			switch (iStat)
			{
			case ERROR_SUCCESS:
				break;
			case ERROR_NO_MORE_ITEMS:
				ICEErrorOut(hInstall, hDirRec, Ice64BadDir);
				break;
			default:
				APIErrorOut(hInstall, iStat, 64, 4);
				return ERROR_SUCCESS;
			}
		}
		else
			ICEErrorOut(hInstall, hDirRec, Ice64BadDir);
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 62, 4);
		return ERROR_SUCCESS;
	}

	// free the dir table (held by MarkProfile)
	CQuery qFree;
	qFree.OpenExecute(hDatabase, 0, sqlIce64FreeDir);
	MngDirectoryTable.RemoveLockCount();
	return ERROR_SUCCESS;
}
#endif

///////////////////////////////////////////////////////////////////////
// ICE65 Verifies that the Environment.Value field doesn't have
// separator values in the wrong place.

static const TCHAR sqlIce65Environment[] = TEXT("SELECT `Value`, `Environment` FROM `Environment`");
static const int iColIce65Environment_Value = 1;
static const int iColIce65Environment_Environment = 2;

ICE_ERROR(Ice65BadValue, 65, ietError, "The environment variable '[2]' has a separator beginning or ending its value.", "Environment\tValue\t[2]");
ICE_ERROR(Ice65EmbeddedNull,65, ietError, "The environment variable '[2]' has an embedded NULL character.", "Environment\tValue\t[2]");
ICE_ERROR(Ice65AlNumSep, 65, ietWarning, "The environment variable '[2]' has an alphanumeric separator", "Environment\tValue\t[2]");

ICE_FUNCTION_DECLARATION(65)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 65);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if theres no directory table, nothing to check.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 65, TEXT("Environment")))
		return ERROR_SUCCESS;

	CQuery qEnvironment;
	ReturnIfFailed(64, 1, qEnvironment.OpenExecute(hDatabase, 0, sqlIce65Environment));
	PMSIHANDLE hEnvRec;
	TCHAR *szString = NULL;
	DWORD cchString = 0;
	while (ERROR_SUCCESS == (iStat = qEnvironment.Fetch(&hEnvRec)))
	{
		// need to pull out the string
		DWORD iStringLen = 0;
		ReturnIfFailed(65, 2, IceRecordGetString(hEnvRec, iColIce65Environment_Value, &szString, &cchString, &iStringLen));

		// if the string is less than 3 chars our string ops
		// may misbehave, but we can't fail the ICE anyway
		if (iStringLen <= 3)
			continue;
			
		// check the beginning of the string for [~];
		if (_tcsncmp(szString, TEXT("[~]"), 3) == 0)
		{
			// the next char (can't be DBCS) is the separator
			TCHAR chSepChar = szString[3];

			// warning if the sepchar is alphanumeric (in english locale)
			if ((chSepChar >= TEXT('0') && chSepChar <= TEXT('9')) ||
				(chSepChar >= TEXT('a') && chSepChar <= TEXT('z')) ||
				(chSepChar >= TEXT('A') && chSepChar <= TEXT('Z')))
				ICEErrorOut(hInstall, hEnvRec, Ice65AlNumSep);
				
			// if this is true, the last char can't be a separator
			TCHAR *szCur = &szString[iStringLen];
			szCur = CharPrev(szString, szCur);
			if (*szCur == chSepChar)
				ICEErrorOut(hInstall, hEnvRec, Ice65BadValue);				
		}
		else
		{
			TCHAR *szCur = &szString[iStringLen];
			for (int i=0; i < 3; i++)
				szCur = CharPrev(szString, szCur);
			if (_tcscmp(szCur, TEXT("[~]")) == 0)
			{
				TCHAR chSepChar = *CharPrev(szString, szCur);			

				// warning if the sepchar is alphanumeric
			if ((chSepChar >= TEXT('0') && chSepChar <= TEXT('9')) ||
				(chSepChar >= TEXT('a') && chSepChar <= TEXT('z')) ||
				(chSepChar >= TEXT('A') && chSepChar <= TEXT('Z')))
					ICEErrorOut(hInstall, hEnvRec, Ice65AlNumSep);
					
				if (szString[0] == chSepChar)
					ICEErrorOut(hInstall, hEnvRec, Ice65BadValue);				
			}
			else 
			{
				// the string doesn't start or end in [~]. If [~] appears
				// anywhere in the string, its a problem
				if (_tcsstr(szString, TEXT("[~]")))
				{
					ICEErrorOut(hInstall, hEnvRec, Ice65EmbeddedNull);
				}
			}
		}
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 65, 3);
		return ERROR_SUCCESS;
	}
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// ICE66 Uses the set of tables in the database to determine the
// appropriate schema for the package

static const TCHAR sqlIce66AllColumns[] = TEXT("SELECT `Table`, `Name` FROM `_Columns`");
static const TCHAR sqlIce66Columns[] = TEXT("SELECT `Table`,`Name` FROM `_Columns` WHERE `Table`=? AND `Name`=?");
static const TCHAR sqlIce66MaxSchema[] = TEXT("SELECT `Table`,`Column` FROM `_SchemaData` WHERE `MaxSchema` < ?");
static const TCHAR sqlIce66DataTable[] = TEXT("SELECT `MinSchema`, `MaxSchema` FROM `_SchemaData` WHERE `Table`=? AND `Column`=?");
static const TCHAR sqlIce66MinSchema[] = TEXT("SELECT DISTINCT `Table`, `Column`, `InstallerVersion` FROM `_SchemaData` WHERE `MinSchema` > ?");
static const int iColIce66DataTable_MinSchema = 1;
static const int iColIce66DataTable_MaxSchema = 2;

ICE_ERROR(Ice66LowSchema, 66, ietWarning, "Complete functionality of the [1] table is only available with Windows Installer version %s. Your schema is %d.", "[1]");
ICE_ERROR(Ice66HighSchema, 66, ietWarning, "Column [2] of table [1] is obsolete with respect to your current schema marked as schema %d.", "[1]");
ICE_ERROR(Ice66Impossible, 66, ietWarning, "It will not be possible to have a single schema that supports all of the tables in the database.", "_SummaryInfo\t14");
ICE_ERROR(Ice66NoSummaryInfo, 66, ietWarning, "Based on the tables and columns in your database, it should be marked with a schema between %d and %d, but the validation system was unable to check this automatically.", "_SummaryInfo\t14");

ICE_FUNCTION_DECLARATION(66)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 66);
	
	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if theres no CUB table, nothing to check.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 66, TEXT("_SchemaData")))
		return ERROR_SUCCESS;

	// get the summary info stream, check the schema, otherwise give a manual warning.
	PMSIHANDLE hSummaryInfo;
	if (!IceGetSummaryInfo(hInstall, hDatabase, 66, &hSummaryInfo))
	{
		// no summary info available.  Try and calcuate what schema they should have to work
		PMSIHANDLE hRecord = ::MsiCreateRecord(1);
		int iMinSchema = 30;
		int iMaxSchema = 110;
		CQuery qDBColumns;
		CQuery qData;
		PMSIHANDLE hColumnRec;
		ReturnIfFailed(66, 1, qDBColumns.OpenExecute(hDatabase, 0, sqlIce66AllColumns));
		ReturnIfFailed(66, 2, qData.Open(hDatabase, sqlIce66DataTable));
		while (ERROR_SUCCESS == (iStat = qDBColumns.Fetch(&hColumnRec)))
		{
			ReturnIfFailed(66, 3, qData.Execute(hColumnRec));
			PMSIHANDLE hResult;
			switch (iStat = qData.Fetch(&hResult))
			{
			case ERROR_NO_MORE_ITEMS:
				// column does not exist in our schema data table. This
				// means it is a custom user column, so does not affect 
				// the required schema
				break;
			case ERROR_SUCCESS:
			{
				// table exists, meaning it is in at least one schema
				if (!::MsiRecordIsNull(hResult, iColIce66DataTable_MinSchema))
				{
					int iCurMin = ::MsiRecordGetInteger(hResult, iColIce66DataTable_MinSchema);
					if (iMinSchema < iCurMin)
						iMinSchema = iCurMin;
				}
				if (!::MsiRecordIsNull(hResult, iColIce66DataTable_MaxSchema))
				{
					int iCurMax = ::MsiRecordGetInteger(hResult, iColIce66DataTable_MaxSchema);
					if (iMaxSchema > iCurMax)
						iMaxSchema = iCurMax;
				}

				if (iMinSchema > iMaxSchema)
				{
					ICEErrorOut(hInstall, hColumnRec, Ice66Impossible);
					return ERROR_SUCCESS;
				}
				
				break;
			}
			default:
				APIErrorOut(hInstall, iStat, 66, 4);
				return ERROR_SUCCESS;
			}
		}			
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 66, 5);
		}

		ICEErrorOut(hInstall, hRecord, Ice66NoSummaryInfo, iMinSchema, iMaxSchema);
	}
	else
	{
		// they have summary information
		// report any loss of functionality based on their current schema if package not installed on 1.1 Darwin
		int iSchema = 0;
		UINT iType = 0; 
		FILETIME ft;
		TCHAR szBuf[1];
		DWORD dwBuf = sizeof(szBuf)/sizeof(TCHAR);
		ReturnIfFailed(66, 6, ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_PAGECOUNT, &iType, &iSchema, &ft, szBuf, &dwBuf));
		
		// Minimum schema query -- report warnings for each table where potential exists for loss of functionality if
		// not installed with proper version of Darwin
		
		// create record for schema
		PMSIHANDLE hRecSchema = ::MsiCreateRecord(1);
		::MsiRecordSetInteger(hRecSchema, 1, iSchema);

		// open view
		CQuery qSchema;
		TCHAR* szPrevTable = NULL;
		int iMinReqSchema = 100;
		ReturnIfFailed(66, 7, qSchema.OpenExecute(hDatabase, hRecSchema, sqlIce66MinSchema));
		PMSIHANDLE hTableRec;
		while (ERROR_SUCCESS == (iStat = qSchema.Fetch(&hTableRec)))
		{
			// see if table exists in database
			TCHAR* szInstallerVersion = NULL;
			DWORD cchInstallerVersion = 0;
			ReturnIfFailed(66, 20, IceRecordGetString(hTableRec, 3, &szInstallerVersion, &cchInstallerVersion, NULL));
			iMinReqSchema = ::MsiRecordGetInteger(hTableRec, 3);
			DWORD cchTable = 0;
			::MsiRecordGetString(hTableRec, 1, TEXT(""), &cchTable);
			TCHAR* szTable = new TCHAR[++cchTable];
			ReturnIfFailed(66, 8, ::MsiRecordGetString(hTableRec, 1, szTable, &cchTable));
			MSICONDITION eStatus = ::MsiDatabaseIsTablePersistent(hDatabase, szTable);
			if (eStatus == MSICONDITION_ERROR)
				APIErrorOut(hInstall, eStatus, 66, 9);
			if (eStatus == MSICONDITION_NONE)
				continue; // table not exist so ignore
			else
			{
				PMSIHANDLE hRec = 0;
				CQuery qColumnsCheck;
				ReturnIfFailed(66, 12, qColumnsCheck.OpenExecute(hDatabase, hTableRec, sqlIce66Columns));
				iStat = qColumnsCheck.Fetch(&hRec);
				switch (iStat)
				{
				case ERROR_SUCCESS:
					{
						// table.column exists in database and db schema < that allowed for table.col
						if (!szPrevTable || 0 != _tcscmp(szPrevTable, szTable))
						{
							ICEErrorOut(hInstall, hRec, Ice66LowSchema, szInstallerVersion, iSchema);
							if (szPrevTable)
								delete [] szPrevTable;
							szPrevTable = new TCHAR[++cchTable];
							_tcscpy(szPrevTable, szTable); // 1 error per table
						}
						break;
					}
				case ERROR_NO_MORE_ITEMS:
						break;
				default: // error
					{
						APIErrorOut(hInstall, iStat, 66, 14);
						break;
					}
				}

			}
			if (szTable)
				delete [] szTable;
			if (szInstallerVersion)
				delete [] szInstallerVersion;
		}
		if (szPrevTable)
			delete [] szPrevTable;
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			APIErrorOut(hInstall, iStat, 66, 10);
		}


		
		// Maximum schema query -- report warnings for each table.column where newer versions of Darwin aren't listed as
		// supporting.  NOTE: this should never happen with true backwards compatibility
		CQuery qColumns;
		ReturnIfFailed(66, 11, qSchema.OpenExecute(hDatabase, hRecSchema, sqlIce66MaxSchema));
		PMSIHANDLE hTableColRec = 0;
		while (ERROR_SUCCESS == (iStat = qSchema.Fetch(&hTableColRec)))
		{
			// see if table exists in database
			PMSIHANDLE hRec = 0;
			ReturnIfFailed(66, 12, qColumns.OpenExecute(hDatabase, hTableColRec, sqlIce66Columns));
			iStat = qColumns.Fetch(&hRec);
			switch (iStat)
			{
			case ERROR_SUCCESS:
				{
					// table.column exists in database and db schema > that allowed for table.col
					ICEErrorOut(hInstall, hRec, Ice66HighSchema, iSchema);
					break;
				}
			case ERROR_NO_MORE_ITEMS:
					break;
			default: // error
				{
					APIErrorOut(hInstall, iStat, 66, 13);
					break;
				}
			}
		}
	}



	return ERROR_SUCCESS;	
}

///////////////////////////////////////////////////////////////////////
// ICE67 Verifies that shortcuts are installed by the target component 
// of the shortcut

// not shared with merge module subset
#ifndef MODSHAREDONLY
static const TCHAR sqlIce67GetShortcuts[] = TEXT("SELECT `Target`, `Component_`, `Shortcut`, `Component`.`Attributes` FROM `Shortcut`, `Component` WHERE `Shortcut`.`Component_`=`Component`.`Component`");
static const int iColIce67GetShortcut_Target = 1;
static const int iColIce67GetShortcut_Component = 2;
static const int iColIce67GetShortcut_Attributes = 3;

static const TCHAR sqlIce67IsAdvertised[] = TEXT("SELECT `Feature` FROM `Feature` WHERE `Feature`=?");

static const TCHAR sqlIce67FileComponent[] = TEXT("SELECT `Component_`, `Component`.Attributes` FROM `File`, `Component` WHERE `File`=? AND `Component_`=`Component`.`Component`");
static const int iColIce67FileComponent_Component = 1;
static const int iColIce67FileComponent_Attributes = 2;

ICE_ERROR(Ice67OptionalComponent, 67, ietWarning, "The shortcut '[3]' is a non-advertised shortcut with a file target. The shortcut and target are installed by different components, and the target component can run locally or from source.", "Shortcut\tTarget\t[3]");
ICE_ERROR(Ice67NoFileTable, 67, ietWarning, "The shortcut '[3]' is a non-advertised shortcut with a file target, but the File table does not exist.", "Shortcut\tTarget\t[3]");
ICE_ERROR(Ice67BadKey, 67, ietError, "The shortcut '[3]' is a non-advertised shortcut with a file target, but the target file does not exist.", "Shortcut\tTarget\t[3]");


ICE_FUNCTION_DECLARATION(67)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 67);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if theres no shortuct table or component table, nothing to check.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 67, TEXT("Shortcut")) ||
		!IsTablePersistent(FALSE, hInstall, hDatabase, 67, TEXT("Component")))
		return ERROR_SUCCESS;

	bool fFeatureTable = IsTablePersistent(FALSE, hInstall, hDatabase, 67, TEXT("Feature"));
	bool fFileTable = IsTablePersistent(FALSE, hInstall, hDatabase, 67, TEXT("File"));

	// open the file and feature queries used inside the loop.
	CQuery qFeature;
	CQuery qFile;
	if (fFeatureTable) 
		ReturnIfFailed(67, 1, qFeature.Open(hDatabase, sqlIce67IsAdvertised));
	if (fFileTable)
		ReturnIfFailed(67, 2, qFile.Open(hDatabase, sqlIce67FileComponent));
	
	// check every shortcut
	CQuery qShortcut;
	ReturnIfFailed(67, 3, qShortcut.OpenExecute(hDatabase, 0, sqlIce67GetShortcuts));
	PMSIHANDLE hShortcut;
	TCHAR *szString = NULL;
	DWORD cchString = 0;

	// string buffers used to compare components
	TCHAR *szTarget = NULL;
	TCHAR *szShortcut = NULL;
	DWORD cchTarget = 0;
	DWORD cchShortcut = 0;

	while (ERROR_SUCCESS == (iStat = qShortcut.Fetch(&hShortcut)))
	{
		// see if this is an advertised shortuct
		if (fFeatureTable)
		{
			PMSIHANDLE hTemp;
			ReturnIfFailed(67, 4, qFeature.Execute(hShortcut));
			switch (iStat = qFeature.Fetch(&hTemp))
			{
			case ERROR_SUCCESS:
				// this is an advertised shortcut
				continue;
			case ERROR_NO_MORE_ITEMS:
				// this is not advertised, so we much validate
				break;
			default:
				APIErrorOut(hInstall, iStat, 67, 5);
				return ERROR_SUCCESS;
			}
		}
		
		// now get the target string
		ReturnIfFailed(67, 6, IceRecordGetString(hShortcut, iColIce67GetShortcut_Target, &szString, &cchString, NULL));

		// see if the target string is of the form [#FileKey]
		if (0 == _tcsncmp(szString, TEXT("[#"), 2) ||
			0 == _tcsncmp(szString, TEXT("[!"), 2))
		{
			// ensure the last char is a ']'
			TCHAR *pchEnd = szString + _tcslen(szString)-1;
			if (*pchEnd == TEXT(']'))
			{
				*pchEnd = '\0';
				TCHAR *szFileKey = szString + 2;

				// make sure that theres not another open bracket in the filename. If so, its a nested
				// property, and we can't validate it easily.
				if (_tcschr(szFileKey, TEXT('[')))
					continue;

				// if there is a file table, we need to check the component that installs the file
				// if not, it a bad foreign key
				if (fFileTable)
				{
					ReturnIfFailed(67, 7, MsiRecordSetString(hShortcut, iColIce67GetShortcut_Target, szFileKey));
					ReturnIfFailed(67, 8, qFile.Execute(hShortcut))

					PMSIHANDLE hTemp;
					switch (iStat = qFile.Fetch(&hTemp))
					{
					case ERROR_SUCCESS:
					{
						// this is valid key reference. Check if the components are the same.
						ReturnIfFailed(67, 9, IceRecordGetString(hTemp, iColIce67FileComponent_Component, &szTarget, &cchTarget, NULL));
						ReturnIfFailed(67, 10, IceRecordGetString(hShortcut, iColIce67GetShortcut_Component, &szShortcut, &cchShortcut, NULL));
						if (_tcscmp(szTarget, szShortcut) != 0)
						{
							// components are not the same, check the attributes of target
							if (MsiRecordGetInteger(hTemp, iColIce67FileComponent_Attributes) & msidbComponentAttributesOptional)
							{
								// target is optional. Warning
								ICEErrorOut(hInstall, hShortcut, Ice67OptionalComponent);
							}
						}		
						continue;
					}
					case ERROR_NO_MORE_ITEMS:
						// no mapping between the file and the shortcut component could be found
						// the foreign key is invalid
						ICEErrorOut(hInstall, hShortcut, Ice67BadKey);
						break;
					default:
						APIErrorOut(hInstall, iStat, 67, 11);
						return ERROR_SUCCESS;
					}
				}
				else
				{
					ICEErrorOut(hInstall, hShortcut, Ice67NoFileTable);
				}
			}
		}
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 67, 12);
		return ERROR_SUCCESS;
	}

	if (szTarget)
		delete[] szTarget;
	if (szShortcut)
		delete[] szShortcut;
	return ERROR_SUCCESS;
}
#endif

///////////////////////////////////////////////////////////////////////
// ICE68 Checks for invalid custom action types and attributes
static const TCHAR sqlIce68CustomAction[] = TEXT("SELECT `Type`,`Action` FROM `CustomAction`");
static const int iColIce68CustomAction_Type = 1;
static const int iColIce68CustomAction_Action = 2;

ICE_ERROR(Ice68BadType, 68, ietError, "Invalid custom action type for action '[2]'.", "CustomAction\tType\t[2]");

ICE_ERROR(Ice68BadSummaryProperty, 68, ietError, "Bad value in Summary Information Stream for %s.","_SummaryInfo\t%d");
ICE_ERROR(Ice68WrongSchema, 68, ietWarning, "This package has elevated commit in CustomAction table (Action=[2]) but it has a schema less than 150.", "CustomAction\tType\t[2]");

ICE_ERROR(Ice68InvalidElevateFlag, 68, ietWarning, "Even though custom action '[2]' is marked to be elevated (with attribute msidbCustomActionTypeNoImpersonate), it will not be run with elevated privileges because it's not deferred (with attribute msidbCustomActionTypeInScript).", "CustomAction\tType\t[2]");

ICE_ERROR(Ice68InvalidTSAware, 68, ietError, "TSAware flag (msidbCustomActionTypeTSAware) set for CustomAction '[2]'. Flag is only available for deferred, impersonated custom actions", "CustomAction\tType\t[2]");


UINT GetSchema(MSIHANDLE hDatabase, DWORD *pdwSchema, UINT *piType);

ICE_FUNCTION_DECLARATION(68)
{
	UINT iStat;
    DWORD   dwSchema = 0;

	// display info
	DisplayInfo(hInstall, 68);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// if theres no customaction table, nothing to check.
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 67, TEXT("CustomAction")))
		return ERROR_SUCCESS;

	// get the attributes of every custom action
	CQuery qCA;
	PMSIHANDLE hCA;
	ReturnIfFailed(68, 1, qCA.OpenExecute(hDatabase, 0, sqlIce68CustomAction));
	while (ERROR_SUCCESS == (iStat = qCA.Fetch(&hCA)))
	{
		DWORD dwAttributes = MsiRecordGetInteger(hCA, iColIce68CustomAction_Type);

		if(dwAttributes & msidbCustomActionTypeNoImpersonate)
		{
			if(!(dwAttributes & msidbCustomActionTypeInScript))
			{
				ICEErrorOut(hInstall, hCA, Ice68InvalidElevateFlag);
			}
		}

		if(dwAttributes & msidbCustomActionTypeTSAware)
		{
			if(	!(dwAttributes & msidbCustomActionTypeInScript) ||
				(dwAttributes & msidbCustomActionTypeNoImpersonate))
			{
				ICEErrorOut(hInstall, hCA, Ice68InvalidTSAware);
			}
			
		}
#define ELEVATED_COMMIT \
    (msidbCustomActionTypeNoImpersonate | msidbCustomActionTypeCommit) 

        if((dwAttributes & ELEVATED_COMMIT) == ELEVATED_COMMIT)
        {   
            if(!dwSchema)
            {
                UINT		iSchemaType;
                ReturnIfFailed(68, 2, GetSchema(hDatabase, &dwSchema, &iSchemaType));
                if(iSchemaType != VT_I4)
                {
                    PMSIHANDLE	hErrorRec = ::MsiCreateRecord(1);	// dummy for error out.
                    ICEErrorOut(hInstall, hErrorRec, Ice68BadSummaryProperty, TEXT("PID_PAGECOUNT"), PID_PAGECOUNT);
                }
            }
            if(dwSchema < 150)
            {
				ICEErrorOut(hInstall, hCA, Ice68WrongSchema, PID_PAGECOUNT);
            }
        }
		// first three bits are the action type. They are not part of the attributes
		// checked, but are used to determine what attributes are valid.
		DWORD iType = dwAttributes & 0x07;
		dwAttributes &= ~0x07;

		// Two new options are added for Darwin 2.0: msidbCustomActionType64BitScript
		// is only valid for scripts. msidbCustomActionTypeHideTarget is valid for all
		// types.
		switch (iType)
		{
		case msidbCustomActionTypeDll:   // fallthrough
		case msidbCustomActionTypeExe:   // fallthrough
		case msidbCustomActionTypeJScript: // fallthrough
		case msidbCustomActionTypeVBScript: 
		{
			// for these four cases, all other bits are valid. msidefs.h doesn't provide us a mask for all
			// bits.
			DWORD dwValidAttr = 0x00002FF7;

			if(iType == msidbCustomActionTypeJScript || iType == msidbCustomActionTypeVBScript)
			{
				// For these two types, msidbCustomActionType64BitScript is also valid.
				dwValidAttr |= msidbCustomActionType64BitScript;
			}
			if(dwAttributes & msidbCustomActionTypeInScript)
			{
				// Make TSAware, InScript custom actions valid
				dwValidAttr |= msidbCustomActionTypeTSAware;
			}
			if (dwAttributes & ~dwValidAttr)
				ICEErrorOut(hInstall, hCA, Ice68BadType);
			break;
		}
		case msidbCustomActionTypeTextData:
		{	
			// for text type, must have one of these types (only two bits though)
			DWORD dwValidAttr = (msidbCustomActionTypeSourceFile | msidbCustomActionTypeDirectory | msidbCustomActionTypeProperty);			
			if (!(dwAttributes & dwValidAttr))
				ICEErrorOut(hInstall, hCA, Ice68BadType);
			else
			{
				// only other valid bits are the "pass" flags (execution scheduling options, but not InScript)
				dwValidAttr |= (msidbCustomActionTypeFirstSequence | msidbCustomActionTypeOncePerProcess | msidbCustomActionTypeClientRepeat | msidbCustomActionTypeHideTarget);
				if (dwAttributes & ~dwValidAttr)
					ICEErrorOut(hInstall, hCA, Ice68BadType);
			}
			break;
		}
		case msidbCustomActionTypeInstall:
		{
			// nested installs can have none or either of the two bits set, but not both.
			int dwValidAttr = (msidbCustomActionTypeSourceFile | msidbCustomActionTypeDirectory);
			if ((dwValidAttr & dwAttributes) == dwValidAttr)
				ICEErrorOut(hInstall, hCA, Ice68BadType);
			else
			{
				// nested installs cannot have execution scheduling options (pass flags)
				// nested installs cannot be async
				dwValidAttr |= msidbCustomActionTypeContinue | msidbCustomActionTypeHideTarget;
				if (dwAttributes & ~dwValidAttr)
					ICEErrorOut(hInstall, hCA, Ice68BadType);
			}
			break;
		}
		default:
			ICEErrorOut(hInstall, hCA, Ice68BadType);
			break;
		}
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		APIErrorOut(hInstall, iStat, 68, 2);
		return ERROR_SUCCESS;
	}
	return ERROR_SUCCESS;
}
	
UINT GetSchema(MSIHANDLE hDatabase, DWORD *pdwSchema, UINT *piType)
{
    PMSIHANDLE	hSummaryInfo = 0;
    int			iValue;
    FILETIME	ft;
    DWORD		dwTemplate = 0;
    UINT        iType;
    UINT        iRet = ERROR_SUCCESS;

    // Check Arguments

    if(!pdwSchema)
        return 0;

    *pdwSchema = 0;

    if(!hDatabase)
        return 0;

    if(!piType)
    {
        piType = &iType;
    }

    // Get the Template Summary Property.
    if(!(iRet = ::MsiGetSummaryInformation(hDatabase, NULL, 0, &hSummaryInfo)))
    {
        if(hSummaryInfo)
        {
            iRet = ::MsiSummaryInfoGetProperty(hSummaryInfo, PID_PAGECOUNT, piType, &iValue, &ft, TEXT(""), &dwTemplate);
            if(!iRet)
            {
                if(*piType == VT_I4)
                {
                    *pdwSchema = iValue;
                }
            }
        }
    }
    return iRet;
}
    

///////////////////////////////////////////////////////////////////////
// ICE69 Checks for cross-component references errors

// not shared with merge module subset
#ifndef MODSHAREDONLY
ICE_QUERY0(sqlIce69GetComponents, "SELECT * FROM %s");
ICE_QUERY0(sqlIce69GetColumnNumber, "SELECT `Number` FROM `_Columns` WHERE `Table`=? AND `Name`=?");
ICE_QUERY0(sqlIce69GetComponentNumber, "SELECT `Number` FROM `_Columns` WHERE `Table`=? AND `Name`='Component_'");
ICE_QUERY0(sqlIce69GetColumns, "SELECT `Table`,`Column` FROM `_Validation` WHERE `Table`=? AND (`Category`='Formatted' OR `Category`='RegPath' OR `Category`='Shortcut')");
ICE_QUERY0(sqlIce69Verb, "SELECT `Extension_`, `Verb`, `Command`, `Argument` FROM `Verb`");
ICE_QUERY0(sqlIce69Extension, "SELECT `Component_` FROM `Extension` WHERE `Extension`=? AND `Component_`='%s'");
ICE_QUERY0(sqlIce69AppId, "SELECT `AppId`, `RemoteServerName` FROM `AppId`");
ICE_QUERY0(sqlIce69Class, "SELECT `Component_` FROM `Class` WHERE `AppId_`=? AND `Component_`='%s'");
ICE_QUERY0(sqlIce69FileComponent, "SELECT `Component_` FROM `File` WHERE `File` = '%s'");

static const TCHAR* pIce69Tables[] = { TEXT("Shortcut"), TEXT("IniFile"), TEXT("Registry"), TEXT("RemoveIniFile"), TEXT("RemoveRegistry"),
										TEXT("ServiceControl"), TEXT("ServiceInstall"), TEXT("Environment"), TEXT("Class") };
const int iIce69NumTables = sizeof(pIce69Tables)/sizeof(TCHAR*);

static enum ixrIce69Validator
{
	ixrVerb_Cmd = 1,
	ixrVerb_Arg = 2,
	ixrAppId_Rem = 3,
};

static void Ice69ParseFormatString(const TCHAR* sql, const TCHAR* szFormat, MSIHANDLE hRecVerb, MSIHANDLE hDatabase, ixrIce69Validator ixr, MSIHANDLE hInstall);
ICE_ERROR(Ice69XComponentRefWarning, 69, ietWarning, "Mismatched component reference. Entry '%s' of the %s table belongs to component '%s'. However, the formatted string in column '%s' references component '%s'. Components are in the same feature.", "%s\t%s\t%s");
ICE_ERROR(Ice69XComponentRefWarningFile, 69, ietWarning, "Mismatched component reference. Entry '%s' of the %s table belongs to component '%s'. However, the formatted string in column '%s' references file '%s' which belongs to component '%s'. Components are in the same feature.", "%s\t%s\t%s");
ICE_ERROR(Ice69XComponentRefError, 69, ietError, "Mismatched component reference. Entry '%s' of the %s table belongs to component '%s'. However, the formatted string in column '%s' references component '%s'. Components belong to different features", "%s\t%s\t%s");
ICE_ERROR(Ice69XComponentRefErrorFile, 69, ietError, "Mismatched component reference. Entry '%s' of the %s table belongs to component '%s'. However, the formatted string in column '%s' references file '%s' which belongs to component '%s'. Components belong to different features", "%s\t%s\t%s");
ICE_ERROR(Ice69VerbXComponentRef, 69, ietWarning, "Mismatched component reference. Component '%s' in formatted string for column '%s' of the Verb table (entry [1].[2]) does not match any component with extension '[1]' in the Extension table." , "Verb\t%s\t[1]\t[2]");
ICE_ERROR(Ice69VerbXComponentRefFile, 69, ietWarning, "Mismatched component reference. Component '%s' to which file '%s' belongs in formatted string for column '%s' of the Verb table (entry [1].[2]) does not match any component with extension '[1]' in the Extension table." , "Verb\t%s\t[1]\t[2]");
ICE_ERROR(Ice69AppIdXComponentRef, 69, ietWarning, "Mismatched component reference. Component '%s' in formatted string for the 'RemoteServerName' column of the AppId table (entry [1]) does not match any component with appId '[1]' in the Class table.", "AppId\tRemoteServerName\t[1]");
ICE_ERROR(Ice69AppIdXComponentRefFile, 69, ietWarning, "Mismatched component reference. Component '%s' to which file '%s' belongs in formatted string for the 'RemoteServerName' column of the AppId table (entry [1]) does not match any component with appId '[1]' in the Class table.", "AppId\tRemoteServerName\t[1]");
ICE_ERROR(Ice69MissingFileEntry, 69, ietError, "'%s' references invalid file.", "%s\t%s\t%s");
ICE_FUNCTION_DECLARATION(69)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 69);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// ensure _Validation table exists as we use it for finding columns with Category="Formatted"
	if (!IsTablePersistent(TRUE, hInstall, hDatabase, 69, TEXT("_Validation")))
		return ERROR_SUCCESS; // exit

	// cycle through all tables with potential for cross-component referencing
	// create record for table names
	PMSIHANDLE hRec = ::MsiCreateRecord(1);


	for (int iTable = 0; iTable < iIce69NumTables; iTable++)
	{
		// see if table is persistent
		if (!IsTablePersistent(FALSE, hInstall, hDatabase, 69, pIce69Tables[iTable]))
			continue; // to next table

		// make sure Component table is available
		if (iTable == 0 && !IsTablePersistent(FALSE, hInstall, hDatabase, 69, TEXT("Component")))
			return ERROR_SUCCESS; // exit

		// make sure FeatureComponents table is available
		if (iTable == 0 && !IsTablePersistent(FALSE, hInstall, hDatabase, 69, TEXT("FeatureComponents")))
			return ERROR_SUCCESS; // exit

		// set up execution record containing table name
		ReturnIfFailed(69, 1, MsiRecordSetString(hRec, 1, pIce69Tables[iTable]));

		// determine where Component_ column is
		CQuery qComponent;
		PMSIHANDLE hComponentOrder;
		ReturnIfFailed(69, 2, qComponent.FetchOnce(hDatabase, hRec, &hComponentOrder, sqlIce69GetComponentNumber::szSQL));
		int iComponentCol = MsiRecordGetInteger(hComponentOrder, 1);
		if (iComponentCol == MSI_NULL_INTEGER || iComponentCol < 1)
		{
			APIErrorOut(hInstall, iComponentCol, 69, 3); // invalid column number
			continue; // bad error
		}

		// mark formatted columns
		DWORD dwColumns = 0;

		// open the _Validation table query
		CQuery qValidation;
		PMSIHANDLE hResult;
		iStat = qValidation.FetchOnce(hDatabase, hRec, &hResult, sqlIce69GetColumns::szSQL);
		while (iStat != ERROR_NO_MORE_ITEMS)
		{
			// make sure we didn't fail
			if (iStat != ERROR_SUCCESS)
			{
				APIErrorOut(hInstall, iStat, 69, 4);
				return ERROR_SUCCESS;
			}
			else
			{
				// execute query on Columns catalog (_Columns) to obtain the number of the column (order)
				CQuery qColumnsCatalog;
				PMSIHANDLE hColOrder;
				ReturnIfFailed(69, 5, qColumnsCatalog.FetchOnce(hDatabase, hResult, &hColOrder, sqlIce69GetColumnNumber::szSQL));

				// obtain column number
				int iCol = MsiRecordGetInteger(hColOrder, 1);
				if (iCol == MSI_NULL_INTEGER || iCol < 1)
				{
					APIErrorOut(hInstall, iCol, 69, 6); // invalid column number
					continue; // bad error
				}

				// mark column in DWORD
				dwColumns |= (1 << (iCol - 1) );
			}

			// fetch next
			iStat = qValidation.Fetch(&hResult);
		}

		// validate entries in table
		CQuery qTable;
		PMSIHANDLE hRecComponents;
		// buffers
		TCHAR *szComponent = NULL;
		DWORD cchComponent = 0;
		TCHAR *szFormatted = NULL;
		DWORD cchFormatted = 0;

		iStat = qTable.FetchOnce(hDatabase, 0, &hRecComponents, sqlIce69GetComponents::szSQL, pIce69Tables[iTable]);
		while (iStat != ERROR_NO_MORE_ITEMS)
		{
			// ensure no fail
			if (iStat != ERROR_SUCCESS)
			{
				APIErrorOut(hInstall, iStat, 69, 7);
				break;
			}
			else
			{

				// now get the component string
				ReturnIfFailed(69, 8, IceRecordGetString(hRecComponents, iComponentCol, &szComponent, &cchComponent, NULL));
				
				// other buffers
				// for each "Formatted" column, do a compare and warn if different
				for (int j = 32; j > 0; j--)
				{
					if (dwColumns & (1 << (j-1)))
					{
						// column is a "formatted" column; obtain string
						ReturnIfFailed(69, 9, IceRecordGetString(hRecComponents, j, &szFormatted, &cchFormatted, NULL));
						// parse string looking for [$component] syntax
						if (szFormatted == NULL || *szFormatted == '\0')
							continue; // nothing to look at
											
						TCHAR* pch = _tcschr(szFormatted, TEXT('['));
						while (pch != NULL)
						{
							// see if pch is of the form [$componentkey]
							if (0 == _tcsncmp(pch, TEXT("[$"), 2))
							{
								pch = _tcsinc(pch); // for '['
								pch = _tcsinc(pch); // for '$'
								if (pch != NULL)
								{
									TCHAR* pch2 = _tcschr(pch, TEXT(']'));
									if (pch2 != NULL)
									{
										*pch2 = TEXT('\0'); // null terminate in place

										// make sure there is not another '[' within since we can't validate that easily
										if (!_tcschr(pch, TEXT('[')) && 0 != _tcscmp(szComponent, pch))
										{
											// ERROR mismatched components

											// determine whether error or warning (warning if same feature, but diff comp)
											bool fSameFeature;
											if (ERROR_SUCCESS != ComponentsInSameFeature(hInstall, hDatabase, 69, szComponent, pch, &fSameFeature))
												return ERROR_SUCCESS; // abort
											TCHAR* szHumanReadable = NULL;
											TCHAR* szTabDelimited =  NULL;
											GeneratePrimaryKeys(69, hInstall, hDatabase, pIce69Tables[iTable], &szHumanReadable, &szTabDelimited);
											PMSIHANDLE hColNames = 0;
											ReturnIfFailed(69, 10, qTable.GetColumnInfo(MSICOLINFO_NAMES, &hColNames));
											TCHAR* szColName = 0;
											DWORD cchColName = 0;
											ReturnIfFailed(69, 11, IceRecordGetString(hColNames, j, &szColName, &cchColName, NULL)); 
											ICEErrorOut(hInstall, hRecComponents, fSameFeature ? Ice69XComponentRefWarning : Ice69XComponentRefError, szHumanReadable, pIce69Tables[iTable], szComponent, szColName, pch, pIce69Tables[iTable], szColName, szTabDelimited);
											if (szTabDelimited)
												delete [] szTabDelimited;
											if (szColName)
												delete [] szColName;
											if (szHumanReadable)
												delete [] szHumanReadable;
										}
									}
									pch = _tcsinc(pch2); // for '\0' that we created
								}
							}
							// see if pch is of the form [#filekey]
							else if(0 == _tcsncmp(pch, TEXT("[#"), 2))
							{
								pch = _tcsinc(pch); // for '['
								pch = _tcsinc(pch); // for '#'
								if (pch != NULL)
								{
									TCHAR* pch2 = _tcschr(pch, TEXT(']'));
									if (pch2 != NULL)
									{
										*pch2 = TEXT('\0'); // null terminate in place

										TCHAR*		pFileKeyComponent = NULL;
										DWORD		dwFileKeyComponent = 0;
										BOOL		bError = FALSE;		// Tell later code not to continue.

										// make sure there is not another '[' within since we can't validate that easily
										// Get the component this file belongs to.
										if (!_tcschr(pch, TEXT('[')))
										{
											CQuery		qComponent;
											PMSIHANDLE	hComponent;
											
											iStat = qComponent.FetchOnce(hDatabase, NULL, &hComponent, sqlIce69FileComponent::szSQL, pch);
											if(iStat != ERROR_SUCCESS)
											{
												if(iStat == ERROR_NO_MORE_ITEMS)
												{
													TCHAR*		szHumanReadable = NULL;
													TCHAR*		szTabDelimited =  NULL;
													PMSIHANDLE	hColNames = 0;
													TCHAR*		szColName = 0;
													DWORD		cchColName = 0;
													
													// Didn't find an entry for this file, error.
													GeneratePrimaryKeys(69, hInstall, hDatabase, pIce69Tables[iTable], &szHumanReadable, &szTabDelimited);
													ReturnIfFailed(69, 12, qTable.GetColumnInfo(MSICOLINFO_NAMES, &hColNames));
													ReturnIfFailed(69, 13, IceRecordGetString(hColNames, j, &szColName, &cchColName, NULL)); 
													ICEErrorOut(hInstall, hRecComponents, Ice69MissingFileEntry, pch, pIce69Tables[iTable], szColName, szTabDelimited);
													bError = TRUE;
													if(szTabDelimited)
													{
														delete [] szTabDelimited;
													}
													if(szColName)
													{
														delete [] szColName;
													}
													if(szHumanReadable)
													{
														delete [] szHumanReadable;
													}
												}
												else
												{
													APIErrorOut(hInstall, iStat, 69, 14);
													return ERROR_SUCCESS;
												}
											}
											else
											{
												ReturnIfFailed(69, 15, IceRecordGetString(hComponent, 1, &pFileKeyComponent, &dwFileKeyComponent, NULL));
											}
										}
										if(bError == FALSE && 0 != _tcscmp(szComponent, pFileKeyComponent))
										{
											// ERROR mismatched components

											// determine whether error or warning (warning if same feature, but diff comp)
											bool fSameFeature;
											if (ERROR_SUCCESS != ComponentsInSameFeature(hInstall, hDatabase, 69, szComponent, pFileKeyComponent, &fSameFeature))
												return ERROR_SUCCESS; // abort
											TCHAR* szHumanReadable = NULL;
											TCHAR* szTabDelimited =  NULL;
											GeneratePrimaryKeys(69, hInstall, hDatabase, pIce69Tables[iTable], &szHumanReadable, &szTabDelimited);
											PMSIHANDLE hColNames = 0;
											ReturnIfFailed(69, 16, qTable.GetColumnInfo(MSICOLINFO_NAMES, &hColNames));
											TCHAR* szColName = 0;
											DWORD cchColName = 0;
											ReturnIfFailed(69, 17, IceRecordGetString(hColNames, j, &szColName, &cchColName, NULL)); 
											ICEErrorOut(hInstall, hRecComponents, fSameFeature ? Ice69XComponentRefWarningFile : Ice69XComponentRefErrorFile, szHumanReadable, pIce69Tables[iTable], szComponent, szColName, pch, pFileKeyComponent, pIce69Tables[iTable], szColName, szTabDelimited);
											if (szTabDelimited)
												delete [] szTabDelimited;
											if (szColName)
												delete [] szColName;
											if (szHumanReadable)
												delete [] szHumanReadable;
										}
										if(pFileKeyComponent)
										{
											delete [] pFileKeyComponent;
										}
									}
									pch = _tcsinc(pch2); // for '\0' that we created
								}
							}
							else
								pch = _tcsinc(pch); // for '[' that wasn't "[$....]"
							pch = _tcschr(pch, TEXT('[')); // look for next
						}
					}
				}
			}

			// fetch next
			iStat = qTable.Fetch(&hRecComponents);
		}
		if (szFormatted)
		{
			delete [] szFormatted;
			cchFormatted = 0;
		}
		if (szComponent)
		{
			delete [] szComponent;
			cchComponent = 0;
		}
	}

	// validate Verb table (which is roundabout with Extension table for finding the reference)
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 69, TEXT("Verb")))
	{
		CQuery qVerb;
		PMSIHANDLE hVerb;
		TCHAR* szArgument = 0;
		DWORD cchArgument = 0;
		TCHAR* szCommand = 0;
		DWORD cchCommand = 0;
		iStat = qVerb.FetchOnce(hDatabase, 0, &hVerb, sqlIce69Verb::szSQL);
		while (iStat != ERROR_NO_MORE_ITEMS)
		{
			// ensure no fail
			if (iStat != ERROR_SUCCESS)
			{
				APIErrorOut(hInstall, iStat, 69, 18);
				break;
			}
			else
			{
				// retrieve component name and formatted string
				ReturnIfFailed(69, 19, IceRecordGetString(hVerb, 3, &szCommand, &cchCommand, NULL));
				Ice69ParseFormatString(sqlIce69Extension::szSQL, szCommand, hVerb, hDatabase, ixrVerb_Cmd, hInstall);
				ReturnIfFailed(69, 20, IceRecordGetString(hVerb, 4, &szArgument, &cchArgument, NULL));
				Ice69ParseFormatString(sqlIce69Extension::szSQL, szArgument, hVerb, hDatabase, ixrVerb_Arg, hInstall);
			}
			iStat = qVerb.Fetch(&hVerb);
		}
		if (szCommand)
			delete [] szCommand;
		if (szArgument)
			delete [] szArgument;
	}
	// validate AppId table (which is roundabout with Class table for finding the reference)
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 69, TEXT("AppId")))
	{
		CQuery qAppId;
		PMSIHANDLE hAppId;
		TCHAR* szRemoteServerName = 0;
		DWORD cchRemoteServerName = 0;
		iStat = qAppId.FetchOnce(hDatabase, 0, &hAppId, sqlIce69AppId::szSQL);
		while (iStat != ERROR_NO_MORE_ITEMS)
		{
			// ensure no fail
			if (iStat != ERROR_SUCCESS)
			{
				APIErrorOut(hInstall, iStat, 69, 21);
				break;
			}
			else
			{
				// retrieve component name and formatted string
				ReturnIfFailed(69, 22, IceRecordGetString(hAppId, 2, &szRemoteServerName, &cchRemoteServerName, NULL));
				Ice69ParseFormatString(sqlIce69Class::szSQL, szRemoteServerName, hAppId, hDatabase, ixrAppId_Rem, hInstall);
			}
			iStat = qAppId.Fetch(&hAppId);
		}
		if (szRemoteServerName)
			delete [] szRemoteServerName;
	}
	return ERROR_SUCCESS;
}

void Ice69ParseFormatString(const TCHAR* szQuery, const TCHAR* szFormatted, MSIHANDLE hRec, MSIHANDLE hDatabase, ixrIce69Validator ixr, MSIHANDLE hInstall)
{
	// query
	CQuery qTable;
	UINT iStat;

	if (szFormatted == NULL || *szFormatted == '\0')
		return; // nothing to look at
											
	TCHAR* pch = _tcschr(szFormatted, TEXT('['));
	while (pch != NULL)
	{
		// see if pch is of the form [$componentkey]
		if (0 == _tcsncmp(pch, TEXT("[$"), 2))
		{
			pch = _tcsinc(pch); // for '['
			pch = _tcsinc(pch); // for '$'
			if (pch != NULL)
			{
				TCHAR* pch2 = _tcschr(pch, TEXT(']'));
				if (pch2 != NULL)
				{
					*pch2 = TEXT('\0'); // null terminate in place
					// make sure there is not another '[' within since we can't validate that easily
					if (!_tcschr(pch, TEXT('[')))
					{
						// open query on extension to look for reference
						PMSIHANDLE hRecRef = 0;
						iStat = qTable.FetchOnce(hDatabase, hRec, &hRecRef, szQuery, pch);
						switch (iStat)
						{
						case ERROR_SUCCESS:
								break; // we're good
						case ERROR_NO_MORE_ITEMS:
							{
								// ERROR
								if (ixr == ixrVerb_Cmd)
									ICEErrorOut(hInstall, hRec, Ice69VerbXComponentRef, pch, TEXT("Command"), TEXT("Command"));
								else if (ixr == ixrVerb_Arg)
									ICEErrorOut(hInstall, hRec, Ice69VerbXComponentRef, pch, TEXT("Argument"), TEXT("Argument"));
								else // ixr == ixrAppId_Rem
									ICEErrorOut(hInstall, hRec, Ice69AppIdXComponentRef, pch);
								break;
							}
						default:
							{
								// api error
								APIErrorOut(hInstall, iStat, 69, 23);
								break;
							}
						}
					}
				}
				pch = _tcsinc(pch2); // for '\0' that we created
			}
		}
		// see if pch is of the form [#filekey]
		if (0 == _tcsncmp(pch, TEXT("[#"), 2))
		{
			pch = _tcsinc(pch); // for '['
			pch = _tcsinc(pch); // for '$'
			if (pch != NULL)
			{
				TCHAR* pch2 = _tcschr(pch, TEXT(']'));
				if (pch2 != NULL)
				{
					*pch2 = TEXT('\0'); // null terminate in place
					
					TCHAR*		pFileKeyComponent = NULL;
					DWORD		dwFileKeyComponent = 0;
					
					// make sure there is not another '[' within since we can't validate that easily
					// Get the component this file belongs to.
					if (!_tcschr(pch, TEXT('[')))
					{
						CQuery		qComponent;
						PMSIHANDLE	hComponent;
						
						iStat = qComponent.FetchOnce(hDatabase, NULL, &hComponent, sqlIce69FileComponent::szSQL, pch);
						if(iStat == ERROR_SUCCESS)
						{
							iStat = IceRecordGetString(hComponent, 1, &pFileKeyComponent, &dwFileKeyComponent, NULL);
							if(iStat == ERROR_SUCCESS)
							{
								// open query on extension to look for reference
								PMSIHANDLE hRecRef = 0;
								iStat = qTable.FetchOnce(hDatabase, hRec, &hRecRef, szQuery, pFileKeyComponent);
								switch (iStat)
								{
								case ERROR_SUCCESS:
										break; // we're good
								case ERROR_NO_MORE_ITEMS:
									{
										// ERROR
										if (ixr == ixrVerb_Cmd)
											ICEErrorOut(hInstall, hRec, Ice69VerbXComponentRefFile, pFileKeyComponent, pch, TEXT("Command"), TEXT("Command"));
										else if (ixr == ixrVerb_Arg)
											ICEErrorOut(hInstall, hRec, Ice69VerbXComponentRefFile, pFileKeyComponent, pch, TEXT("Argument"), TEXT("Argument"));
										else // ixr == ixrAppId_Rem
											ICEErrorOut(hInstall, hRec, Ice69AppIdXComponentRefFile, pFileKeyComponent, pch);
										break;
									}
								default:
									{
										// api error
										APIErrorOut(hInstall, iStat, 69, 24);
										break;
									}
								}
								if(pFileKeyComponent)
								{
									delete [] pFileKeyComponent;
								}
							}
						}
						else if(iStat == ERROR_NO_MORE_ITEMS)
						{
							if(ixr == ixrVerb_Cmd)
							{
								ICEErrorOut(hInstall, hRec, Ice69MissingFileEntry, pch, TEXT("Command"), TEXT("Command"));
							}
							else if(ixr == ixrVerb_Arg)
							{
								ICEErrorOut(hInstall, hRec, Ice69MissingFileEntry, pch, TEXT("Argument"), TEXT("Argument"));
							}
							else // ixr == ixrAppId_Rem
							{
								ICEErrorOut(hInstall, hRec, Ice69MissingFileEntry, pch);
							}
						}
						else
						{
							APIErrorOut(hInstall, iStat, 69, 25);
						}
					}
				}
				pch = _tcsinc(pch2); // for '\0' that we created
			}
		}
		else
			pch = _tcsinc(pch); // for '[' without [$
		pch = _tcschr(pch, TEXT('['));
	}
}
#endif

////////////////////////////////////////////////////////////////////////
//  ICE70 -- verifys that chars following a # in a registry value are
//           numeric. ##str, #%unexpStr are valid
//           also validates #int, #xhex, #Xhex
//           if properties are there, can't validate well
//			 #[prop1][prop2] is valid
//           property must be up front
//           actual property syntax (proper open/close brackets) are
//           validated in different ice
static const TCHAR sqlIce70Registry[] = TEXT("SELECT `Registry`,`Value` FROM `Registry` WHERE `Value` IS NOT NULL");

ICE_ERROR(Ice70InvalidNumericValue, 70, ietError, "The value '[2]' is an invalid numeric value for registry entry [1].  If you meant to use a string, then the string value entry must be preceded by ## not #.", "Registry\tValue\t[1]");
ICE_ERROR(Ice70InvalidHexValue, 70, ietError, "The value '[2]' is an invalid hexadecimal value for registry entry [1].", "Registry\tValue\t[1]");

ICE_FUNCTION_DECLARATION(70)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 70);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	CQuery qRegistry;
	PMSIHANDLE hRecRegistry;

	// do not process if do not have Registry table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 69, TEXT("Registry")))
		return ERROR_SUCCESS;
	ReturnIfFailed(70, 1, qRegistry.OpenExecute(hDatabase, 0, sqlIce70Registry));

	// process registry table
	TCHAR* szRegValue = NULL;
	DWORD cchRegValue = 0;
	while (ERROR_SUCCESS == (iStat = qRegistry.Fetch(&hRecRegistry)))
	{
		ReturnIfFailed(70, 2, IceRecordGetString(hRecRegistry, 2, &szRegValue, &cchRegValue, NULL));
		TCHAR* pch = szRegValue;
		if (pch == NULL)
		{
			APIErrorOut(hInstall, 0, 70, 3); // we should not get any null values based on query
			continue;
		}
		BOOL fProperty = FALSE;
		BOOL fHex = FALSE;
		if (*pch++ == '#')
		{
			switch (*pch)
			{
			case '#': // ##str syntax, string, skip
					break;
			case '%': // #%str syntax, unexpanded string, skip
					break;
			case '[':
				{
					// #[property] syntax or some such, we can't evaluate
					// we could warn of need for numeric data, but if [property] evaluates to #str,
					// then we have ##str and that's valid.  properties just cannot be reliably
					// evaluated at validation runtime
					// we do not look for trailing ']'

					// we can say [#filekey], [$compkey], and [!filekey] are invalid
					if (*(++pch) == '#' || *pch == '$' || *pch == '!')
						ICEErrorOut(hInstall, hRecRegistry, Ice70InvalidNumericValue);

					// make sure property syntax correct.  NOTE: we only care about the 1st property
					// i.e. '#[myproperty' is invalid, but '#[myprop] [prop' is valid.
					fProperty = TRUE;
					while (*pch != 0)
					{
						if (*pch == ']')
						{
							fProperty = FALSE;
							break;
						}
						pch = _tcsinc(pch);
					}
					if (fProperty)
					{
						// no closing brace
						ICEErrorOut(hInstall, hRecRegistry, Ice70InvalidNumericValue);
					}
					break;
				}
			case '\0':
				{
					// empty str
					ICEErrorOut(hInstall, hRecRegistry, Ice70InvalidNumericValue);
					break;
				}
			case 'x':
			case 'X': 
				{
					// #xhex syntax, hexadecimal value
					fHex = TRUE;
					pch++;
					// fall through
				}
			default:
				{
					// #int syntax
					if (!fHex && (*pch == '+' || *pch == '-'))
							pch++; // for add or subtract
					while (*pch != 0)
					{
						if (*pch == '[')
						{
							pch++;
							if (*pch == '#' || *pch == '!' || *pch == '$')
							{
								// invalid -- must become numeric properties
								if (fHex)
									ICEErrorOut(hInstall, hRecRegistry, Ice70InvalidHexValue);
								else
									ICEErrorOut(hInstall, hRecRegistry, Ice70InvalidNumericValue);
							}
							fProperty = TRUE;
							pch++;
						}
						else if (fProperty && *pch == ']')
						{
							fProperty = FALSE;
							pch++;
						}
						else if (*pch >= '0' && *pch <= '9')
						{
							// valid
							pch++;
						}
						else if (fHex && ((*pch >= 'a' && *pch <= 'f') || (*pch >= 'A' && *pch <= 'F')))
						{
							// valid
							pch++;
						}
						else if (!fProperty)
						{
							// invalid
							if (fHex)
								ICEErrorOut(hInstall, hRecRegistry, Ice70InvalidHexValue);
							else
								ICEErrorOut(hInstall, hRecRegistry, Ice70InvalidNumericValue);
							break;
						}
						else // fProperty
							pch = _tcsinc(pch);
					}
					if (fProperty)
					{
						// invalid -- never closed property braces
						if (fHex)
							ICEErrorOut(hInstall, hRecRegistry, Ice70InvalidHexValue);
						else
							ICEErrorOut(hInstall, hRecRegistry, Ice70InvalidNumericValue);
					}
					break;
				}
			}
		}

	}
	if (iStat != ERROR_NO_MORE_ITEMS)
		APIErrorOut(hInstall, iStat, 70, 4);
	if (szRegValue)
		delete [] szRegValue;

	return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//  ICE71 -- verifies that the first media table entry starts with 1
//     This is needed since we assume the package is located at Disk 1
//     for SourceList

// not shared with merge module subset
#ifndef MODSHAREDONLY
static const TCHAR sqlIce71Media[] = TEXT("SELECT `DiskId` FROM `Media` ORDER BY `DiskId`");

ICE_ERROR(Ice71NoMedia, 71, ietWarning, "The Media table has no entries.", "Media");
ICE_ERROR(Ice71MissingFirstMediaEntry, 71, ietError, "The Media table requires an entry with DiskId=1. First DiskId is '[1]'.", "Media\tDiskId\t[1]");

ICE_FUNCTION_DECLARATION(71)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 71);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// do not process if do not have Media table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 71, TEXT("Media")))
		return ERROR_SUCCESS;

	CQuery qMedia;
	PMSIHANDLE hRec = 0;
	int iDiskId = 0;
	iStat = qMedia.FetchOnce(hDatabase, 0, &hRec, sqlIce71Media);
	switch (iStat)
	{
	case ERROR_SUCCESS: // media entries
		iDiskId = MsiRecordGetInteger(hRec, 1);
		if (iDiskId != 1) // no entry w/ 1
			ICEErrorOut(hInstall, hRec, Ice71MissingFirstMediaEntry); 
		break;
	case ERROR_NO_MORE_ITEMS: // no media entries
		// generate a valid record
		hRec = MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRec, Ice71NoMedia);
		break;
	default: // api error
		APIErrorOut(hInstall, iStat, 71, 2); 
		break;
	}


	return ERROR_SUCCESS;
}
#endif

////////////////////////////////////////////////////////////////////////
//  ICE72 -- verifies that non-built in Custom Actions are not used in
//      the AdvtExecuteSequence table.  This means that only type 19, 
//      type 51 and type 35 custom actions are allowed

// not shared with merge module subset
#ifndef MODSHAREDONLY
ICE_QUERY2(qIce72CustomAction, "SELECT `AdvtExecuteSequence`.`Action`, `CustomAction`.`Type` FROM `AdvtExecuteSequence`, `CustomAction` WHERE `AdvtExecuteSequence`.`Action`=`CustomAction`.`Action`", Action, Type);
ICE_ERROR(Ice72InvalidCustomAction, 72, ietError, "Custom Action '[1]' in the AdvtExecuteSequence is not allowed. Only built-in custom actions are allowed.", "AdvtExecuteSequence\tAction\t[1]");
const int iIce72Type35 = msidbCustomActionTypeTextData | msidbCustomActionTypeDirectory;
const int iIce72Type51 = msidbCustomActionTypeTextData | msidbCustomActionTypeProperty;
const int iIce72Type19 = msidbCustomActionTypeTextData | msidbCustomActionTypeSourceFile;

ICE_FUNCTION_DECLARATION(72)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 72);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// do not process if do not have AdvtExecuteSequence table
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 72, TEXT("AdvtExecuteSequence")))
		return ERROR_SUCCESS;

	// do not process if do not have CustomAction table
	//FUTURE: CustomAction table is always present via validation process
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 72, TEXT("CustomAction")))
		return ERROR_SUCCESS;

	CQuery qAdvt;
	ReturnIfFailed(72, 1, qAdvt.OpenExecute(hDatabase, 0, qIce72CustomAction::szSQL));
	PMSIHANDLE hRecAction;
	while (ERROR_SUCCESS == (iStat = qAdvt.Fetch(&hRecAction)))
	{
		int iType = ::MsiRecordGetInteger(hRecAction, qIce72CustomAction::Type);
		// only type 19, type 51 and type 35 are allowed
		if (iIce72Type51 != (iType & iIce72Type51) && iIce72Type35 != (iType & iIce72Type35)
			&& iIce72Type19 != (iType & iIce72Type19))
		{
			ICEErrorOut(hInstall, hRecAction, Ice72InvalidCustomAction);
		}
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 72, 2);
	return ERROR_SUCCESS;
}
#endif

////////////////////////////////////////////////////////////////////////
//  ICE73 -- verifies that the package does not reuse product and 
//           package codes of the sample packages provided in the
//           Windows Installer SDK
//
//   NOTE: does not verify that the GUID is valid
// not shared with merge module subset
#ifndef MODSHAREDONLY
ICE_QUERY1(qIce73ProductCode, "SELECT `Value` FROM `Property` WHERE `Property`='ProductCode'", Value);
ICE_QUERY1(qIce73UpgradeCode, "SELECT `Value` FROM `Property` WHERE `Property`='UpgradeCode'", Value);
ICE_ERROR(Ice73ReusedProductCode, 73, ietWarning, "This package reuses the '[1]' ProductCode of %s Windows Installer SDK package.", "Property\tValue\tProductCode");
ICE_ERROR(Ice73ReusedUpgradeCode, 73, ietWarning, "This package reuses the '[1]' UpgradeCode of %s Windows Installer SDK package.", "Property\tValue\tUpgradeCode");
ICE_ERROR(Ice73ReusedPackageCode, 73, ietWarning, "This package reuses the '%s' Package Code of %s Windows Installer SDK package.", "_SummaryInfo\t9");
ICE_ERROR(Ice73MissingPackageCode, 73, ietError, "This package is missing the Package Code property in the Summary Information Stream.", "_SummaryInfo");
ICE_ERROR(Ice73MissingProductCode, 73, ietError, "This package is missing the ProductCode property in the Property table.", "Property");
ICE_ERROR(Ice73MissingPropertyTable, 73, ietError, "This package is missing the Property table. It's required for the ProductCode property.", "Property");
ICE_ERROR(Ice73InvalidPackageCode, 73, ietError, "The package code in the Summary Information Stream Revision property is invalid.", "_SummaryInfo\t9");

struct ICE_GUID {
	TCHAR* szPackageCode;
	TCHAR* szProductCode;
    TCHAR* szUpgradeCode;
	TCHAR* szMsiName;
};

// this is for the GUIDs from the 1.0 SDK and 1.0 SDK refresh 
const struct ICE_GUID rgIce73GUIDList[] = 
{
	{
		TEXT("{000C1101-0000-0000-C000-000000000047}"),// szPackageCode
		TEXT("{9BBF15D0-1985-11D1-9A9D-006097C4E489}"),// szProductCode
		0,                                             // szUpgradeCode
		TEXT(" the msispy.msi 1.0")                    // szMsiName
	},
	{
		TEXT("{80F7E030-A751-11D2-A7D4-006097C99860}"),// szPackageCode
		TEXT("{80F7E030-A751-11D2-A7D4-006097C99860}"),// szProductCode
		TEXT("{1AA03E10-2B19-11D2-B2EA-006097C99860}"),// szUpgradeCode
		TEXT(" the orca.msi 1.0")                      // szMsiName
	},
	{
		TEXT("{0CD9A0A0-DDFD-11D1-A851-006097ABDE17}"),// szPackageCode
		TEXT("{0CD9A0A0-DDFD-11D1-A851-006097ABDE17}"),// szProductCode
		TEXT("{AD2A58F2-E645-11D2-88C7-00A0C981B015}"),// szUpgradeCode
		TEXT("the msival2.msi 1.0")                    // szMsiName
	}
};
const int cIce73GUIDItems = sizeof(rgIce73GUIDList)/sizeof(struct ICE_GUID);

// subsequent GUIDs are from the following range:
//{8FC70000-88A0-4b41-82B8-8905D4AA904C}
//     ^^^^
//{8FC7    -88A0-4B41-82B8-8905D4AA904C}

const TCHAR szIce73SDKRangeBeg[] = TEXT("{8FC7");
const TCHAR szIce73SDKRangeEnd[] = TEXT("-88A0-4B41-82B8-8905D4AA904C}");
const TCHAR szIce73SDKRangeMid[] = TEXT("****");
const int iIce73StartRangeEnd = 9; // Range End starts at pos 9 of GUID
const int iIce73BegRangeLen = 5;
const int iIce73EndRangeLen = 29;

ICE_FUNCTION_DECLARATION(73)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 73);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// verify package code does not match our package codes
	PMSIHANDLE hSummaryInfo = 0;
	if (IceGetSummaryInfo(hInstall, hDatabase, 73, &hSummaryInfo))
	{
		UINT uiDataType = VT_EMPTY;
		TCHAR* szPackageCode = NULL;
		DWORD cchPackageCode= 0;
		ReturnIfFailed(73, 1, GetSummaryInfoPropertyString(hSummaryInfo, PID_REVNUMBER, uiDataType, &szPackageCode, cchPackageCode));
		if (uiDataType == VT_LPSTR)
		{
			// process package code
			for (int i = 0; i < cIce73GUIDItems; i++)
			{
				if (0 == _tcsicmp(szPackageCode, rgIce73GUIDList[i].szPackageCode))
				{
					PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
					ICEErrorOut(hInstall, hRecErr, Ice73ReusedPackageCode, rgIce73GUIDList[i].szPackageCode, rgIce73GUIDList[i].szMsiName);
					break;
				}
			}
			if (0 == _tcsncicmp(szIce73SDKRangeBeg, szPackageCode, iIce73BegRangeLen)
				&& 0 == _tcsncicmp(szIce73SDKRangeEnd, szPackageCode+iIce73StartRangeEnd, iIce73EndRangeLen))
			{
				PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
				TCHAR szPkgCode[40];
				wsprintf(szPkgCode, TEXT("%s%s%s"), szIce73SDKRangeBeg, szIce73SDKRangeMid, szIce73SDKRangeEnd);
				ICEErrorOut(hInstall, hRecErr, Ice73ReusedPackageCode, szPkgCode, TEXT("a 1.1"));
			}
		}
		else if (uiDataType == VT_EMPTY)
		{
			// package code is missing
			PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
			ICEErrorOut(hInstall, hRecErr, Ice73MissingPackageCode);
		}
		else
		{
			// non string data
			APIErrorOut(hInstall, 0, 73, 2);
		}
		if (szPackageCode)
			delete [] szPackageCode;
	}

	if (IsTablePersistent(FALSE, hInstall, hDatabase, 73, TEXT("Property")))
	{
		// verify product code does not match our product codes
		CQuery qProductCode;
		PMSIHANDLE hRec = 0;
		if (ERROR_NO_MORE_ITEMS == (iStat = qProductCode.FetchOnce(hDatabase, 0, &hRec, qIce73ProductCode::szSQL)))
		{
			// product code property is missing
			PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
			ICEErrorOut(hInstall, hRecErr, Ice73MissingProductCode);
		}
		else if (ERROR_SUCCESS != iStat)
		{
			PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
			ICEErrorOut(hInstall, hRecErr, Ice73InvalidPackageCode);
		}
		else
		{
			// process product code
			TCHAR* szProductCode = NULL;
			DWORD cchProductCode = 0;
			ReturnIfFailed(73, 4, IceRecordGetString(hRec, qIce73ProductCode::Value, &szProductCode, &cchProductCode, NULL));
			for (int i = 0; i < cIce73GUIDItems; i++)
			{
				if (0 == _tcsicmp(szProductCode, rgIce73GUIDList[i].szProductCode))
				{
					ICEErrorOut(hInstall, hRec, Ice73ReusedProductCode, rgIce73GUIDList[i].szMsiName);
					break;
				}
			}
			if (0 == _tcsncicmp(szIce73SDKRangeBeg, szProductCode, iIce73BegRangeLen)
				&& 0 == _tcsncicmp(szIce73SDKRangeEnd, szProductCode+iIce73StartRangeEnd, iIce73EndRangeLen))
			{
				PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
				TCHAR szProdCode[40];
				wsprintf(szProdCode, TEXT("%s%s%s"), szIce73SDKRangeBeg, szIce73SDKRangeMid, szIce73SDKRangeEnd);
				::MsiRecordSetString(hRecErr, 1, szProdCode);
				ICEErrorOut(hInstall, hRecErr, Ice73ReusedProductCode, TEXT("a 1.1"));
			}
			if (szProductCode)
				delete [] szProductCode;
		}

		// verify upgradecode does not match our upgrade codes
		CQuery qUpgradeCode;
		if (ERROR_NO_MORE_ITEMS == (iStat = qUpgradeCode.FetchOnce(hDatabase, 0, &hRec, qIce73UpgradeCode::szSQL)))
		{
			// upgrade code property is missing -- this is OK
		}
		else if (ERROR_SUCCESS != iStat)
		{
			APIErrorOut(hInstall, iStat, 73, 5);
		}
		else
		{
			// process upgrade code
			TCHAR* szUpgradeCode = NULL;
			DWORD cchUpgradeCode = 0;
			ReturnIfFailed(73, 6, IceRecordGetString(hRec, qIce73UpgradeCode::Value, &szUpgradeCode, &cchUpgradeCode, NULL));
			for (int i = 0; i < cIce73GUIDItems; i++)
			{
				if (rgIce73GUIDList[i].szUpgradeCode && 0 == _tcsicmp(szUpgradeCode, rgIce73GUIDList[i].szUpgradeCode))
				{
					ICEErrorOut(hInstall, hRec, Ice73ReusedUpgradeCode, rgIce73GUIDList[i].szMsiName);
					break;
				}
			}
			if (0 == _tcsncicmp(szIce73SDKRangeBeg, szUpgradeCode, iIce73BegRangeLen)
				&& 0 == _tcsncicmp(szIce73SDKRangeEnd, szUpgradeCode+iIce73StartRangeEnd, iIce73EndRangeLen))
			{
				PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
				TCHAR szUpCode[40];
				wsprintf(szUpCode, TEXT("%s%s%s"), szIce73SDKRangeBeg, szIce73SDKRangeMid, szIce73SDKRangeEnd);
				::MsiRecordSetString(hRecErr, 1, szUpCode);
				ICEErrorOut(hInstall, hRecErr, Ice73ReusedUpgradeCode, TEXT("a 1.1"));
			}

			if (szUpgradeCode)
				delete [] szUpgradeCode;
		}
	}
	else
	{
		// property table missing
		PMSIHANDLE hRecErr = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hRecErr, Ice73MissingPropertyTable);
	}

	return ERROR_SUCCESS;
}

#endif


///////////////////////////////////////////////////////////////////////
// ICE74 -- FASTOEM property is not permitted in the MSI Property table
//			It must be authored on the commandline instead of in the
//			package. UpgradeCode should be in the Property table for
//			databases (not for merge modules). A warning is reported if
//			it's not.
//          
//  -- shared with merge module subset

ICE_QUERY1(qIce74FASTOEM, "SELECT `Property` FROM `Property` WHERE `Property`='FASTOEM'", Property);
ICE_QUERY2(qIce74UpgradeCode, "SELECT `Property`, `Value` FROM `Property` WHERE `Property`='UpgradeCode' AND `Value` is not null", Property, Value);
ICE_ERROR(Ice74FASTOEMDisallowed, 74, ietError, "The FASTOEM property cannot be authored in the Property table.","Property\tProperty\tFASTOEM");
ICE_ERROR(Ice74UpgradeCodeNotExist, 74, ietWarning, "The UpgradeCode property is not authored in the Property table. It is strongly recommended that authors of installation packages specify an UpgradeCode for their application.", "Property");
ICE_ERROR(Ice74UpgradeCodeNotValid, 74, ietError, "'[2]' is not a valid UpgradeCode.", "Property\tValue\t[1]");

ICE_FUNCTION_DECLARATION(74)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 74);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// skip validation if Property table not persistent
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 74, TEXT("Property")))
		return ERROR_SUCCESS;

	// query for FASTOEM property, error if exists
	CQuery qQuery;
	PMSIHANDLE hRec;
	if (ERROR_SUCCESS == (iStat = qQuery.FetchOnce(hDatabase, 0, &hRec, qIce74FASTOEM::szSQL)))
		ICEErrorOut(hInstall, hRec, Ice74FASTOEMDisallowed);
	else if (ERROR_NO_MORE_ITEMS != iStat)
		APIErrorOut(hInstall, iStat, 74, 1);

	// If this is not a merge module, check to see if UpgradeCode property exists.
	if(IsTablePersistent(FALSE, hInstall, hDatabase, 74, TEXT("ModuleSignature")))
	{
		return ERROR_SUCCESS;
	}
	if(ERROR_NO_MORE_ITEMS == (iStat = qQuery.FetchOnce(hDatabase, 0, &hRec, qIce74UpgradeCode::szSQL)))
	{
		PMSIHANDLE	hErrorRec = ::MsiCreateRecord(1);
		ICEErrorOut(hInstall, hErrorRec, Ice74UpgradeCodeNotExist);
	}
	else if(ERROR_SUCCESS != iStat)
	{
		APIErrorOut(hInstall, iStat, 74, __LINE__);
	}
	else	// Check for null guid.
	{
		TCHAR*	pValue = NULL;
		DWORD	dwValue = 0;

		ReturnIfFailed(74, __LINE__, IceRecordGetString(hRec, qIce74UpgradeCode::Value, &pValue, &dwValue, NULL));
		if(_tcscmp(pValue, TEXT("{00000000-0000-0000-0000-000000000000}")) == 0)
		{
			ICEErrorOut(hInstall, hRec, Ice74UpgradeCodeNotValid);
		}
	}

	return ERROR_SUCCESS;
};

////////////////////////////////////////////////////////////////////////
//  ICE75 -- validates that custom actions whose source is an installed
//           file are sequenced after CostFinalize (so Directory Mngr
//           is initialized).
//  
//	Types 17 (DLL), 18 (EXE), 21 (JSCRIPT), and 22 (VBSCRIPT)
//

// not shared with merge module subset
#ifndef MODSHAREDONLY

ICE_QUERY3(qIce75SequencedCustomActions, "SELECT `CustomAction`.`Action`, `Type`, `Sequence` FROM `CustomAction`, `%s` WHERE `%s`.`Action`=`CustomAction`.`Action`", Action, Type, Sequence);
ICE_QUERY1(qIce75CostFinalize, "SELECT `Sequence` FROM `%s` WHERE `Action`='CostFinalize'", Sequence);
ICE_ERROR(Ice75CostFinalizeRequired, 75, ietError, "CostFinalize is missing from '%s'. [1] is a custom action whose source is an installed file. It must be sequenced after the CostFinalize action", "%s\tSequence\t[1]");
ICE_ERROR(Ice75InvalidCustomAction, 75, ietError, "[1] is a custom action whose source is an installed file.  It must be sequenced after the CostFinalize action in the %s Sequence table", "%s\tSequence\t[1]");

const int iICE75SourceMask = msidbCustomActionTypeBinaryData | msidbCustomActionTypeSourceFile | msidbCustomActionTypeDirectory
								| msidbCustomActionTypeProperty;
const int iICE75Type19Mask = msidbCustomActionTypeSourceFile | msidbCustomActionTypeTextData;

static const TCHAR *rgICE75SeqTables[] =
{
	TEXT("AdminUISequence"),
	TEXT("AdminExecuteSequence"),
	TEXT("AdvtUISequence"),
//	TEXT("AdvtExecuteSequence"), -- type 17,18,21,22 custom actions not allowed in this table, caught by ICE72
	TEXT("InstallUISequence"),
	TEXT("InstallExecuteSequence")
};
static const int cICE75SeqTables = sizeof(rgICE75SeqTables)/sizeof(TCHAR*);

ICE_FUNCTION_DECLARATION(75)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 75);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// do not process if do not have CustomAction table
	//FUTURE: CustomAction table is always present via validation process
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 75, TEXT("CustomAction")))
		return ERROR_SUCCESS;

	PMSIHANDLE hRecCostFinalize = 0;
	PMSIHANDLE hRecCustomAction = 0;
	
	bool fCostFinalize = true;
	int iCostFinalizeSeq = 0;
	
	CQuery qCostFinalize;
	CQuery qCustomAction;
	
	// for each sequence table
	for (int i = 0; i < cICE75SeqTables; i++)
	{
		// skip if table doesn't exist
		if (!IsTablePersistent(FALSE, hInstall, hDatabase, 75, rgICE75SeqTables[i]))
			continue;

		// initialize
		fCostFinalize = true;

		// find sequence number of CostFinalize action
		iStat = qCostFinalize.FetchOnce(hDatabase, 0, &hRecCostFinalize, qIce75CostFinalize::szSQL, rgICE75SeqTables[i]);
		switch (iStat)
		{
		case ERROR_NO_MORE_ITEMS: // CostFinalize action not present
			fCostFinalize = false;
			break;
		case ERROR_SUCCESS: // CostFinalize action present
			iCostFinalizeSeq = ::MsiRecordGetInteger(hRecCostFinalize, qIce75CostFinalize::Sequence);
			break;
		default: // API error
			fCostFinalize = false;
			APIErrorOut(hInstall, iStat, 75, 1);
			break;
		}

		// fetch all custom actions in the sequence table
		ReturnIfFailed(75, 2, qCustomAction.OpenExecute(hDatabase, 0, qIce75SequencedCustomActions::szSQL, rgICE75SeqTables[i], rgICE75SeqTables[i]));
		while (ERROR_SUCCESS == (iStat = qCustomAction.Fetch(&hRecCustomAction)))
		{
			// obtain CA type info
			int iType = ::MsiRecordGetInteger(hRecCustomAction, qIce75SequencedCustomActions::Type);

			// only validate if "SOURCE type custom action". Custom action
			// type 19 is a special case here. It happens to share a bit with
			// msidbCustomActionTypeSourceFile, but it doesn't have any
			// source.
			if (((iType & iICE75Type19Mask) == (msidbCustomActionTypeSourceFile | msidbCustomActionTypeTextData)) ||
				(msidbCustomActionTypeSourceFile != (iType & iICE75SourceMask)))
				continue; // not a SOURCE custom action

			// get CA's sequence number
			int iCASeq = ::MsiRecordGetInteger(hRecCustomAction, qIce75SequencedCustomActions::Sequence);
			
			// error if custom action sequenced before CostFinalize (equal counts as invalid)
			// or if CostFinalize action is missing
			if (!fCostFinalize)
				ICEErrorOut(hInstall, hRecCustomAction, Ice75CostFinalizeRequired, rgICE75SeqTables[i], rgICE75SeqTables[i]);
			else if (iCASeq <= iCostFinalizeSeq)
				ICEErrorOut(hInstall, hRecCustomAction, Ice75InvalidCustomAction, rgICE75SeqTables[i], rgICE75SeqTables[i]);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 75, 3);
	}
	return ERROR_SUCCESS;
}
#endif // MODSHAREDONLY

//////////////////////////////////////////////////////////////////////////
// ICE76 -- Files that reference SFP catalogs cannot be in the BindImage
//          table
//
//          Files that reference SFP catalogs must be in permanent and Local Only
//          Components.
//          
//  -- shared with merge module subset

ICE_QUERY1(qIce76BindImage, "SELECT `BindImage`.`File_` FROM `BindImage`,`FileSFPCatalog` WHERE `BindImage`.`File_`=`FileSFPCatalog`.`File_`", File );
ICE_ERROR(Ice76BindImageDisallowed, 76, ietError, "File '[1]' references a SFP catalog.  Therefore it cannot be in the BindImage table.","BindImage\tFile_\t[1]");

ICE_QUERY2(qIce76SFPComponentAttributes, "SELECT `Component`.`Component`,`Component`.`Attributes` FROM `File`,`Component`,`FileSFPCatalog` WHERE `File`.`File`=`FileSFPCatalog`.`File_` AND `File`.`Component_` = `Component`.`Component`", File, Attributes);
ICE_ERROR(Ice76SFPLocalAndPermanentRequired, 76, ietError, "Component '[1]' contains files referenced by SFP Catalogs.  The component must be local only and permanent.","Component\tComponent\t[1]");

ICE_FUNCTION_DECLARATION(76)
{
	UINT iStat;

	// display info
	DisplayInfo(hInstall, 76);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// skip validation if BindImage or FileSFPCatalog tables not persistent
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 76, TEXT("BindImage"))
		&& IsTablePersistent(FALSE, hInstall, hDatabase, 76, TEXT("FileSFPCatalog")))
	{
		// Any successful fetch is an error as any file that references a SFP catalog cannot be binded
		CQuery qBindImage;
		PMSIHANDLE hRecFile=0;
		ReturnIfFailed(76, 1, qBindImage.OpenExecute(hDatabase, 0, qIce76BindImage::szSQL));
		while (ERROR_SUCCESS == (iStat = qBindImage.Fetch(&hRecFile)))
			ICEErrorOut(hInstall, hRecFile, Ice76BindImageDisallowed);
		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 76, 2);
	}

	// skip attribute verification if File, Component, or FileSFPCatalog tables not persistent
	if (IsTablePersistent(FALSE, hInstall, hDatabase, 76, TEXT("File"))
		&& IsTablePersistent(FALSE, hInstall, hDatabase, 76, TEXT("Component"))
		&& IsTablePersistent(FALSE, hInstall, hDatabase, 76, TEXT("FileSFPCatalog")))
	{
		CQuery qSFPAttributes;
		PMSIHANDLE hRecComponent=0;
		ReturnIfFailed(76, 3, qSFPAttributes.OpenExecute(hDatabase, 0, qIce76SFPComponentAttributes::szSQL));

		TCHAR *pszLastComponent = NULL, *pszCurrentComponent = NULL;
		DWORD cchLastComponent = 0, cchCurrentComponent = 0;

		while (ERROR_SUCCESS == (iStat = qSFPAttributes.Fetch(&hRecComponent)))
		{
			// check attributes, and error if both local only and permanent are not set.

			int iAttributes = MsiRecordGetInteger(hRecComponent, qIce76SFPComponentAttributes::Attributes);
			ReturnIfFailed(76, 4, IceRecordGetString(hRecComponent, qIce76SFPComponentAttributes::File, &pszCurrentComponent, &cchCurrentComponent, NULL));
			
			// only spit out each error once for each component
			if (!pszLastComponent || (0 != _tcscmp(pszLastComponent, pszCurrentComponent))) 
			{
				if	(	(MSI_NULL_INTEGER == iAttributes) ||
						(msidbComponentAttributesSourceOnly & iAttributes) ||
						(msidbComponentAttributesOptional & iAttributes) ||
						!(msidbComponentAttributesPermanent & iAttributes)
					)
				{
					ICEErrorOut(hInstall, hRecComponent, Ice76SFPLocalAndPermanentRequired);

					if (pszLastComponent)
					{
						delete [] pszLastComponent;
					}
					pszLastComponent = pszCurrentComponent;
					cchLastComponent = cchCurrentComponent;
				}
			}
		}

		if (pszLastComponent && (pszLastComponent != pszCurrentComponent))
		{
			delete [] pszLastComponent, cchLastComponent = 0;
		}
		if (pszCurrentComponent)
		{
			delete [] pszCurrentComponent, cchCurrentComponent = 0;
		}

		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 76, 5);
	}

	return ERROR_SUCCESS;
};

////////////////////////////////////////////////////////////////////////
//  ICE77 -- validates that in-script custom actions are sequenced 
//			 in between InstallInitialize and InstallFinalize
//  
// -- not shared with merge module subset
#ifndef MODSHAREDONLY

ICE_QUERY3(qIce77SequencedCustomActions, "SELECT `CustomAction`.`Action`, `Type`, `Sequence` FROM `CustomAction`, `%s` WHERE `%s`.`Action`=`CustomAction`.`Action`", Action, Type, Sequence);
ICE_QUERY1(qIce77InstallInitialize, "SELECT `Sequence` FROM `%s` WHERE `Action`='InstallInitialize'", Sequence);
ICE_QUERY1(qIce77InstallFinalize, "SELECT `Sequence` FROM `%s` WHERE `Action`='InstallFinalize'", Sequence);
ICE_ERROR(Ice77InstallInitializeRequired, 77, ietError, "InstallInitialize is missing from '%s'. [1] is a in-script custom action. It must be sequenced after the InstallInitialize action", "%s\tSequence\t[1]");
ICE_ERROR(Ice77InstallFinalizeRequired, 77, ietError, "InstallFinalize is missing from '%s'. [1] is a in-script custom action. It must be sequenced before the InstallFinalize action", "%s\tSequence\t[1]");
ICE_ERROR(Ice77InvalidCustomAction, 77, ietError, "[1] is a in-script custom action.  It must be sequenced in between the InstallInitialize action and the InstallFinalize action in the %s table", "%s\tSequence\t[1]");

static const TCHAR *rgICE77SeqTables[] =
{
	TEXT("AdminExecuteSequence"),
	TEXT("InstallExecuteSequence")
};

static const int cICE77SeqTables = sizeof(rgICE77SeqTables)/sizeof(TCHAR*);

ICE_FUNCTION_DECLARATION(77)
{
	UINT iStat = ERROR_SUCCESS;

	// display info
	DisplayInfo(hInstall, 77);

	// get database handle
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);

	// do not process if do not have CustomAction table
	//FUTURE: CustomAction table is always present via validation process
	if (!IsTablePersistent(FALSE, hInstall, hDatabase, 77, TEXT("CustomAction")))
		return ERROR_SUCCESS;

	PMSIHANDLE hRecInstallInitialize = 0;
	PMSIHANDLE hRecInstallFinalize = 0;
	PMSIHANDLE hRecCustomAction = 0;
	
	bool fInstallInitialize = true;	
	bool fInstallFinalize = true;

	
	int iInstallInitializeSeq = 0;
	int iInstallFinalizeSeq = 0;

	CQuery qInstallInitialize;
	CQuery qInstallFinalize;
	CQuery qCustomAction;
	
	// for each sequence table
	for (int i = 0; i < cICE77SeqTables; i++)
	{
		// skip if table doesn't exist
		if (!IsTablePersistent(FALSE, hInstall, hDatabase, 77, rgICE77SeqTables[i]))
			continue;

		// initialize
		fInstallInitialize = true;
		fInstallFinalize = true;

		// find sequence number of InstallInitialize action
		iStat = qInstallInitialize.FetchOnce(hDatabase, 0, &hRecInstallInitialize, qIce77InstallInitialize::szSQL, rgICE77SeqTables[i]);

		switch (iStat)
		{
		case ERROR_NO_MORE_ITEMS: // InstallInitialize action not present
			fInstallInitialize = false;
			break;
		case ERROR_SUCCESS: // CostFinalize action present
			iInstallInitializeSeq = ::MsiRecordGetInteger(hRecInstallInitialize, qIce77InstallInitialize::Sequence);
			break;
		default: // API error
			fInstallInitialize = false;
			APIErrorOut(hInstall, iStat, 77, 1);
			break;
		}


		// find sequence number of InstallFinalize action
		iStat = qInstallFinalize.FetchOnce(hDatabase, 0, &hRecInstallFinalize, qIce77InstallFinalize::szSQL, rgICE77SeqTables[i]);

		switch (iStat)
		{
		case ERROR_NO_MORE_ITEMS: // CostFinalize action not present
			fInstallFinalize = false;
			break;
		case ERROR_SUCCESS: // CostFinalize action present
			iInstallFinalizeSeq = ::MsiRecordGetInteger(hRecInstallFinalize, qIce77InstallFinalize::Sequence);
			break;
		default: // API error
			fInstallFinalize = false;
			APIErrorOut(hInstall, iStat, 77, 2);
			break;
		}

		// fetch all custom actions in the sequence table
		ReturnIfFailed(77, 3, qCustomAction.OpenExecute(hDatabase, 0, qIce77SequencedCustomActions::szSQL, rgICE77SeqTables[i], rgICE77SeqTables[i]));
		while (ERROR_SUCCESS == (iStat = qCustomAction.Fetch(&hRecCustomAction)))
		{
			// obtain CA type info
			int iType = ::MsiRecordGetInteger(hRecCustomAction, qIce77SequencedCustomActions::Type);

			// only validate if this is a in-script CA
			if (msidbCustomActionTypeInScript != (iType & msidbCustomActionTypeInScript))
				continue; // not a in-script CA

			// get CA's sequence number
			int iCASeq = ::MsiRecordGetInteger(hRecCustomAction, qIce77SequencedCustomActions::Sequence);
			
			// error if custom action sequenced before InstallInitialize or after InstallFinalize(equal counts as invalid)
			// or if InstallInitialize or InstallFinalize action is missing

			if ( (!fInstallInitialize) || (!fInstallFinalize) )
			{
				if (!fInstallInitialize)
					ICEErrorOut(hInstall, hRecCustomAction, Ice77InstallInitializeRequired, rgICE77SeqTables[i], rgICE77SeqTables[i]);
				if (!fInstallFinalize)
					ICEErrorOut(hInstall, hRecCustomAction, Ice77InstallFinalizeRequired, rgICE77SeqTables[i], rgICE77SeqTables[i]);
			}
			else if ( (iCASeq <= iInstallInitializeSeq) ||  (iCASeq >= iInstallFinalizeSeq) )
				ICEErrorOut(hInstall, hRecCustomAction, Ice77InvalidCustomAction, rgICE77SeqTables[i], rgICE77SeqTables[i]);
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
			APIErrorOut(hInstall, iStat, 77, 4);
	}
	return ERROR_SUCCESS;
}
#endif // MODSHAREDONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\shrice.dll\sources.inc ===
TARGETNAME=shrice
!INCLUDE ..\..\..\..\MsiMake.inc

TARGETTYPE=DYNLINK
TARGETLIBS= \
	$(BUILD_DIR)\msi.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \

C_DEFINES=$(C_DEFINES) -DMODSHAREDONLY
USE_LIBCMT=1
USE_NATIVE_EH=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\shrice.def
BINPLACE_PLACEFILE=..\..\placefil.txt

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\shrice.cpp \
	..\shricInc.cpp \
	..\shrice.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\shrice11.dll\shrice11.cpp ===
#include "..\msiice11.dll\msiice11.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\shrice11.dll\sources.inc ===
TARGETNAME=shrice11
!INCLUDE ..\..\..\..\MsiMake.inc

TARGETTYPE=DYNLINK
TARGETLIBS= \
	$(BUILD_DIR)\msi.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \

C_DEFINES=$(C_DEFINES) -DMODSHAREDONLY
USE_MSVCRT=1
USE_NATIVE_EH=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\shrice11.def
BINPLACE_PLACEFILE=..\..\placefil.txt

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\shrice11.cpp \
	..\shrice11.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\shrice15.dll\shrice15.cpp ===
#include "..\msiice15.dll\msiice15.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\iceman\shrice15.dll\sources.inc ===
TARGETNAME=shrice15
!INCLUDE ..\..\..\..\MsiMake.inc

TARGETTYPE=DYNLINK
TARGETLIBS= \
	$(BUILD_DIR)\msi.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \

C_DEFINES=$(C_DEFINES) -DMODSHAREDONLY
USE_MSVCRT=1
USE_NATIVE_EH=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\shrice15.def
BINPLACE_PLACEFILE=..\..\placefil.txt

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\shrice15.cpp \
	..\shrice15.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\globals.h ===
/////////////////////////////////////////////////////////////////////////////
// dep.cpp
//		Implements IMsmDependency interface
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#ifndef _GLOBALS_H
#define _GLOBALS_H

#include <windows.h>
#include <oaidl.h>

HRESULT LoadTypeLibFromInstance(ITypeLib** pTypeLib); 
extern long g_cComponents;
extern HINSTANCE g_hInstance;
extern bool g_fWin9X;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\make.inc ===
MERGEMOD_H: $(BUILD_COMMONDIR)\Mergemod.h

$(BUILD_COMMONDIR)\Mergemod.h: $(INC_DIR)\Mergemod.w
	wcshdr.exe < $(INC_DIR)\Mergemod.w > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\localerr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       localerr.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// localerr.h
//		Implements Local Error exception object
// 

#ifndef _LOCAL_ERROR_H_
#define _LOCAL_ERROR_H_

#include "merge.h"

/////////////////////////////////////////////////////////////////////////////
// CLocalError

class CLocalError 
{
public:
	CLocalError(UINT iError, LPCWSTR wzLog) : m_iError(iError)
	{
		wcscpy(m_wzLog, wzLog);
	}
	
	UINT Log(HANDLE hFileLog, LPCWSTR szPrefix = NULL);

	UINT GetError()
	{	return m_iError;	};

	// data
private:
	const UINT m_iError;
	WCHAR m_wzLog[528];
};

UINT CLocalError::Log(HANDLE hFileLog, LPCWSTR wzPrefix /*= NULL*/)
{
	// if the log file is not open
	if (INVALID_HANDLE_VALUE == hFileLog)
		return ERROR_FUNCTION_FAILED;	// bail no file to write to

	WCHAR wzError[50];	// holds one of the below errors

	// display the correct error message
	switch (m_iError)
	{
	case ERROR_INVALID_HANDLE:
		wcscpy(wzError, L"passed an invalid handle.\r\n");
		break;
	case ERROR_BAD_QUERY_SYNTAX:
		wcscpy(wzError, L"passed a bad SQL syntax.\r\n");
		break;
	case ERROR_FUNCTION_FAILED:
		wcscpy(wzError, L"function failed.\r\n");
		break;
	case ERROR_INVALID_HANDLE_STATE:
		wcscpy(wzError, L"handle in invalid state.\r\n");
		break;
	case ERROR_NO_MORE_ITEMS:
		wcscpy(wzError, L"no more items.\r\n");
		break;
	case ERROR_INVALID_PARAMETER:
		wcscpy(wzError, L"passed an invalid parameter.\r\n");
		break;
	case ERROR_MORE_DATA:
		wcscpy(wzError, L"more buffer space required to hold data.\r\n");
		break;
	default:	// unknown error
		wcscpy(wzError, L"unknown error.\r\n");
	}

	// buffer to log
	WCHAR wzLogBuffer[528] = {0};
	DWORD cchBuffer = 0;

	// if there is a prefix
	if (wzPrefix)
		swprintf(wzLogBuffer, L"%ls%ls\r\n\tReason: %ls\r\n", wzPrefix, m_wzLog, wzError);
	else
		swprintf(wzLogBuffer, L">>> Fatal %ls\r\n\tReason: %ls\r\n", m_wzLog, wzError);

	// get length of bugger
	cchBuffer = wcslen(wzLogBuffer);

	// return if write worked
	size_t cchDiscard = 1025;
    char szLogBuffer[1025];
	WideToAnsi(wzLogBuffer, szLogBuffer, &cchDiscard);
    unsigned long cchBytesWritten = 0;
	BOOL bResult = WriteFile(hFileLog, szLogBuffer, cchBuffer, &cchBytesWritten, NULL);

	return bResult ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
}

#endif // _LOCAL_ERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\enum.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       enum.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// enum.h
//		Declares IEnumTemplate interface
// 

#ifndef __TEMPLATE_ENUM_VARIANT__
#define __TEMPLATE_ENUM_VARIANT__

#include "..\common\list.h"
#include "..\common\trace.h"

#pragma warning(disable: 4786)

// Tclass - the dispinterface implementation
// Tdisp - the dispinterface enumerated
// Tenum - the non-Variant enumeration type storing the interface
template <class Tclass, class Tdisp, class Tenum>
class CEnumTemplate : public IEnumVARIANT,
							 public Tenum
{
public:
	CEnumTemplate(const IID& riid);
	CEnumTemplate(const IID& riid, const POSITION& pos, CList<Tclass>* plistData);
	CEnumTemplate(const CEnumTemplate<Tclass,Tdisp,Tenum>& reTemplate);
	~CEnumTemplate();

	// IUnknown interface
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID& iid, void** ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// Common IEnumVARIANT & IEnum* interfaces
	HRESULT STDMETHODCALLTYPE Skip(ULONG cItem);
	HRESULT STDMETHODCALLTYPE Reset();

	// IEnumVARIANT interface
	HRESULT STDMETHODCALLTYPE Next(ULONG cItem, VARIANT* rgvarRet, ULONG* cItemRet);
	HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT** ppiRet);

	// IEnum* interface
	HRESULT STDMETHODCALLTYPE Next(ULONG cItem, Tdisp* rgvarRet, ULONG* cItemRet);
	HRESULT STDMETHODCALLTYPE Clone(Tenum** ppiRet);

	// non-interface methods
	POSITION AddTail(Tclass pData);
	UINT GetCount();

private:
	long m_cRef;
	IID m_iid;

	POSITION m_pos;
	CList<Tclass> m_listData;
};

///////////////////////////////////////////////////////////
// constructor	
template <class Tclass, class Tdisp, class Tenum>
CEnumTemplate<Tclass,Tdisp,Tenum>::CEnumTemplate(const IID& riid)
{
	// initial count
	m_cRef = 1;

	// set iid and null position
	m_iid = riid;
	m_pos = NULL;

	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor

///////////////////////////////////////////////////////////
// constructor	- 2
template <class Tclass, class Tdisp, class Tenum>
CEnumTemplate<Tclass,Tdisp,Tenum>::CEnumTemplate(const IID& riid, const POSITION& pos, CList<Tclass>* plistData)
{
	// initial count
	m_cRef = 1;

	// up the component count
	InterlockedIncrement(&g_cComponents);

	// copy over all the data
	Tclass pItem;
	m_pos = plistData->GetHeadPosition();
	while (m_pos)
	{
		// get the item
		pItem = plistData->GetNext(m_pos);
		pItem->AddRef();	// up the count on the item

		m_listData.AddTail(pItem);	// add the addreffed item to this list
	}

	// copy over other data
	m_iid = riid;
	m_pos = pos;
}	// end of constructor - 2

///////////////////////////////////////////////////////////
// copy constructor	
template <class Tclass, class Tdisp, class Tenum>
CEnumTemplate<Tclass,Tdisp,Tenum>::CEnumTemplate(const CEnumTemplate<Tclass,Tdisp,Tenum>& reTemplate)
{
	// initial count
	m_cRef = 1;

	// up the component count
	InterlockedIncrement(&g_cComponents);

	// copy over all the data
	Tclass pItem;
	m_pos = reTemplate.m_listData.GetHeadPosition();
	while (m_pos)
	{
		// get the item
		pItem = reTemplate.m_listData.GetNext(m_pos);
		pItem->AddRef();	// up the count on the item

		m_listData.AddTail(pItem);	// add the addreffed item to this list
	}

	// copy over other data
	m_iid = reTemplate.m_iid;
	m_pos = reTemplate.m_pos;	// start at the same position in the enumerator
}	// end of copy constructor

///////////////////////////////////////////////////////////
// destructor
template <class Tclass, class Tdisp, class Tenum>
CEnumTemplate<Tclass,Tdisp,Tenum>::~CEnumTemplate()
{
	POSITION pos = m_listData.GetHeadPosition();
	while (pos)
		m_listData.GetNext(pos)->Release();

	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor

///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
template <class Tclass, class Tdisp, class Tenum>
HRESULT CEnumTemplate<Tclass,Tdisp,Tenum>::QueryInterface(const IID& iid, void** ppv)
{
	TRACEA("CEnumTemplate::QueryInterface - called, IID: %d\n", iid);

	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<Tenum*>(this);
	else if (iid == IID_IEnumVARIANT)
		*ppv = static_cast<IEnumVARIANT *>(this);
	else if (iid == m_iid)
		*ppv = static_cast<Tenum*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
template <class Tclass, class Tdisp, class Tenum>
ULONG CEnumTemplate<Tclass,Tdisp,Tenum>::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
template <class Tclass, class Tdisp, class Tenum>
ULONG CEnumTemplate<Tclass,Tdisp,Tenum>::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// Common IEnumVARIANT & IEnum* interfaces

///////////////////////////////////////////////////////////
// Skip
template <class Tclass, class Tdisp, class Tenum>
HRESULT CEnumTemplate<Tclass,Tdisp,Tenum>::Skip(ULONG cItem)
{
	// loop through the count
	while (cItem > 0)
	{
		// if we're out of items quit looping
		if (!m_pos)
			return S_FALSE;

		// increment the position (ignore the data returned)
		m_listData.GetNext(m_pos);

		cItem--;	// decrement the count
	}

	return S_OK;
}	// end of Skip

///////////////////////////////////////////////////////////
// Reset
template <class Tclass, class Tdisp, class Tenum>
HRESULT CEnumTemplate<Tclass,Tdisp,Tenum>::Reset()
{
	// move the position back to the top of the list
	m_pos = m_listData.GetHeadPosition();

	return S_OK;
}	// end of Reset


/////////////////////////////////////////////////////////////////////////////
// IEnumVARIANT interfaces

///////////////////////////////////////////////////////////
// Next
template <class Tclass, class Tdisp, class Tenum>
HRESULT CEnumTemplate<Tclass,Tdisp,Tenum>::Next(ULONG cItem, VARIANT* rgvarRet, ULONG* cItemRet)
{
	// error check
	if (!rgvarRet)
		return E_INVALIDARG;

	// count of items fetched
	ULONG cFetched = 0;
	
	// loop through the count
	IDispatch* pdispEnum;			// pull out the data as an IDispatch
	while (cItem > 0)
	{
		// if we're out of items quit looping
		if (!m_pos)
		{
			// if we need to return how many items are fetched
			if (cItemRet)
				*cItemRet = cFetched;

			return S_FALSE;
		}

		// get the IDispatch interface and increment the position
		pdispEnum = m_listData.GetNext(m_pos);

		// initialize the variant
		::VariantInit((rgvarRet + cFetched));

		// copy over the IDispatch
		(rgvarRet + cFetched)->vt = VT_DISPATCH;
		(rgvarRet + cFetched)->pdispVal = static_cast<IDispatch *>(pdispEnum);
		pdispEnum->AddRef();			// addref the IDispatch copy
			
		cFetched++;		// increment the count copied
		cItem--;			// decrement the count to loop
	}

	// if we need to return how many items are fetched
	if (cItemRet)
		*cItemRet = cFetched;

	return S_OK;
}	// end of Next

///////////////////////////////////////////////////////////
// Clone
template <class Tclass, class Tdisp, class Tenum>
HRESULT CEnumTemplate<Tclass,Tdisp,Tenum>::Clone(IEnumVARIANT** ppiRet)
{
	//error check
	if (!ppiRet)
		return E_INVALIDARG;

	*ppiRet = NULL;

	// create a new enumerator
	CEnumTemplate<Tclass,Tdisp,Tenum>* pEnum = new CEnumTemplate<Tclass,Tdisp,Tenum>(m_iid, m_pos, &m_listData);

	if (!pEnum)
		return E_OUTOFMEMORY;

	// assing the new enumerator to return value
	*ppiRet = dynamic_cast<IEnumVARIANT*>(pEnum);

	return S_OK;
}	// end of Clone;


/////////////////////////////////////////////////////////////////////////////
// IEnum* interfaces

///////////////////////////////////////////////////////////
// Next
template <class Tclass, class Tdisp, class Tenum>
HRESULT CEnumTemplate<Tclass,Tdisp,Tenum>::Next(ULONG cItem, Tdisp* rgvarRet, ULONG* cItemRet)
{
	// error check
	if (!rgvarRet)
		return E_INVALIDARG;

	// count of items fetched
	ULONG cFetched = 0;
	
	*rgvarRet = NULL;		// null out the passed in variable

	// loop through the count
	while (cItem > 0)
	{
		// if we're out of items quit looping
		if (!m_pos)
		{
			// if we need to return how many items are fetched
			if (cItemRet)
				*cItemRet = cFetched;

			return S_FALSE;
		}

		// copy over the item and increment the pos
		*(rgvarRet + cFetched) = m_listData.GetNext(m_pos);
		(*(rgvarRet + cFetched))->AddRef();			// addref the copy
			
		cFetched++;		// increment the count copied
		cItem--;			// decrement the count to loop
	}

	// if we need to return how many items are fetched
	if (cItemRet)
		*cItemRet = cFetched;

	return S_OK;
}	// end of Next

///////////////////////////////////////////////////////////
// Clone
template <class Tclass, class Tdisp, class Tenum>
HRESULT CEnumTemplate<Tclass,Tdisp,Tenum>::Clone(Tenum** ppiRet)
{
	//error check
	if (!ppiRet)
		return E_INVALIDARG;

	*ppiRet = NULL;

	// create a new enumerator
	CEnumTemplate<Tclass,Tdisp,Tenum>* pEnum = new CEnumTemplate<Tclass,Tdisp,Tenum>(m_iid, m_pos, &m_listData);

	if (!pEnum)
		return E_OUTOFMEMORY;

	// assing the new enumerator to return value
	*ppiRet = pEnum;

	return S_OK;
}	// end of Clone;

/////////////////////////////////////////////////////////////////////////////
// non-interface methods

///////////////////////////////////////////////////////////
// AddTail
template <class Tclass, class Tdisp, class Tenum>
POSITION CEnumTemplate<Tclass,Tdisp,Tenum>::AddTail(Tclass pData)
{
	POSITION pos = m_listData.AddTail(pData);

	// if there is no current position put it at the head
	if (!m_pos)
		m_pos = m_listData.GetHeadPosition();

	return pos;	// return the added position
}	// end of AddTail

///////////////////////////////////////////////////////////
// GetCount
template <class Tclass, class Tdisp, class Tenum>
UINT CEnumTemplate<Tclass,Tdisp,Tenum>::GetCount()
{
	return m_listData.GetCount();
}	// end of GetCount



// TObjImpl   - class implementing the base object
// TCollIface - interface of the collection
// TObjIface  - interface of the base object
// TEnumIFace - interface of the enumerator
// TCollIID   - IID of the collection interface
// TObjIID    - IID of the base object interface
// TEnumIID   - IID of the enumerator interface
template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
class CCollectionTemplate : public TCollIface
{
public:
	CCollectionTemplate();
	~CCollectionTemplate();

	// IUnknown interface
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID& iid, void** ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDispatch methods
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT* pctInfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTI);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
														 LCID lcid, DISPID* rgDispID);
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
											   DISPPARAMS* pDispParams, VARIANT* pVarResult,
												EXCEPINFO* pExcepInfo, UINT* puArgErr);
	HRESULT STDMETHODCALLTYPE InitTypeInfo();

	// collection interface
	HRESULT STDMETHODCALLTYPE get_Item(long lItem, TObjIface** Return);
	HRESULT STDMETHODCALLTYPE get_Count(long* Count);
	HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown** NewEnum);

	// non-interface methods
	bool Add(TObjImpl* perrAdd);

private:
	long m_cRef;
	ITypeInfo* m_pTypeInfo;

	// enumeration of error interfaces
	CEnumTemplate<TObjImpl*, TObjIface*, TEnumIface>* m_pEnum;
};



///////////////////////////////////////////////////////////
// constructor	
template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::CCollectionTemplate()
{
	// initial count
	m_cRef = 1;

	//create error enumerator
	m_pEnum = new CEnumTemplate<TObjImpl*, TObjIface*, TEnumIface>(*TEnumIID);

	// no type info yet
	m_pTypeInfo = NULL;

	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::~CCollectionTemplate()
{
	// release the type info
	if (m_pTypeInfo)
		m_pTypeInfo->Release();

	if (m_pEnum)
		m_pEnum->Release();

	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor

///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
HRESULT CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::QueryInterface(const IID& iid, void** ppv)
{
	TRACEA("CollectionTemplate::QueryInterface - called, IID: %d\n", iid);

	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<TCollIface*>(this);
	else if (iid == IID_IDispatch)
		*ppv = static_cast<TCollIface*>(this);
	else if (iid == *TCollIID)
		*ppv = static_cast<TCollIface*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
ULONG CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
ULONG CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// IDispatch interface
template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
HRESULT CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::GetTypeInfoCount(UINT* pctInfo)
{
	if(NULL == pctInfo)
		return E_INVALIDARG;

	*pctInfo = 1;	// only one type info supported by this dispatch

	return S_OK;
}

template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
HRESULT CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::GetTypeInfo(UINT iTInfo, LCID /* lcid */, ITypeInfo** ppTypeInfo)
{
	if (0 != iTInfo)
		return DISP_E_BADINDEX;

	if (NULL == ppTypeInfo)
		return E_INVALIDARG;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	*ppTypeInfo = m_pTypeInfo;
	m_pTypeInfo->AddRef();

	return S_OK;
}

template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
HRESULT CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
						 LCID lcid, DISPID* rgDispID)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID);
}

template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
HRESULT CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
				  DISPPARAMS* pDispParams, VARIANT* pVarResult,
				  EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr = S_OK;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->Invoke((IDispatch*)this, dispIdMember, wFlags, pDispParams, pVarResult,
										pExcepInfo, puArgErr);
}

template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
HRESULT CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::InitTypeInfo()
{
	HRESULT hr = S_OK;
	ITypeLib* pTypeLib = NULL;

	// if there is no info loaded
	if (NULL == m_pTypeInfo)
	{
		// try to load the Type Library into memory. For SXS support, do not load from registry, rather
		// from launched instance
		hr = LoadTypeLibFromInstance(&pTypeLib);
		if (FAILED(hr))
		{
			TRACEA("CCollection::InitTypeInfo - failed to load TypeLib[0x%x]\n", LIBID_MsmMergeTypeLib);
			return hr;
		}

		// try to get the Type Info for this Interface
		hr = pTypeLib->GetTypeInfoOfGuid(*TCollIID, &m_pTypeInfo);
		if (FAILED(hr))
		{
			TRACEA("CCollection::InitTypeInfo - failed to get inteface[0x%x] from TypeLib[0x%x]\n", *TCollIID, LIBID_MsmMergeTypeLib);

			// no type info was loaded
			m_pTypeInfo = NULL;
		}

		pTypeLib->Release();
	}

	return hr;
}


///////////////////////////////////////////////////////////
// Item
template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
HRESULT CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::get_Item(long lItem, TObjIface** Return)
{
	// error check
	if (!Return)
		return E_INVALIDARG;

	HRESULT hr;

	// set the return null
	*Return = NULL;

	//if the item is too small
	if (lItem < 1)
		return E_INVALIDARG;

	hr = m_pEnum->Reset();		// go back to the top
	// if we need to skip any items
	if (lItem > 1)
	{
		hr = m_pEnum->Skip(lItem - 1);	// skip to the Item
		if (FAILED(hr))
			return E_INVALIDARG;	// failed to find item
	}

	hr = m_pEnum->Next(1, Return, NULL);
	if (FAILED(hr))
	{
		TRACEA("CCollection::Item - Failed to get error from enumerator.\r\n");
		return E_INVALIDARG;
	}

	return hr;
}	// end of Item

///////////////////////////////////////////////////////////
// Count
template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
HRESULT CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::get_Count(long* Count)
{
	// error check
	if (!Count)
		return E_INVALIDARG;

	// get the count in the enumerator
	*Count = m_pEnum->GetCount();

	return S_OK;
}	// end of Count

///////////////////////////////////////////////////////////
// _NewEnum
template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
HRESULT CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::get__NewEnum(IUnknown** NewEnum)
{
	// error check
	if (!NewEnum)
		return E_INVALIDARG;

	HRESULT hr;

	// blank out the passed in variable
	*NewEnum = NULL;

	// return the enumerator as an IUnknown
	IEnumVARIANT* pEnumVARIANT;
	hr = m_pEnum->Clone(&pEnumVARIANT);

	if (SUCCEEDED(hr))
	{
		pEnumVARIANT->Reset();
		*NewEnum = pEnumVARIANT;
	}

	return hr;
}	// end of _NewEnum


/////////////////////////////////////////////////////////////////////////////
// non-interface methods
template <class TObjImpl, class TCollIface, class TObjIface, class TEnumIface, const IID* TCollIID, const IID* TObjIID, const IID* TEnumIID>
bool CCollectionTemplate<TObjImpl, TCollIface, TObjIface, TEnumIface, TCollIID, TObjIID, TEnumIID>::Add(TObjImpl* perrAdd)
{
	ASSERT(perrAdd);
	// add the error to the end of the list
	return (NULL != m_pEnum->AddTail(perrAdd));
}	// end of Add

#endif // __TEMPLATE_ENUM_VARIANT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\merge.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       merge.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// merge.cpp
//		Implements IMsmMerge and IMsmMerge2 interface
// 
#include "globals.h"

#include "merge.h"
#include "msidefs.h"

#include "..\common\trace.h"
#include "..\common\varutil.h"
#include "..\common\query.h"
#include "..\common\dbutils.h"
#include "..\common\utils.h"

#include "localerr.h"

#include <sys\stat.h>

#include "mmerror.h"
#include "mmdep.h"
#include "mmcfgitm.h"

#include "fdi.h"
#include "seqact.h"

// number of bytes to read/write from stream/file while extracting
const ULONG g_ulStreamBufSize = 4096;

///////////////////////////////////////////////////////////
// global strings

const LPWSTR g_wzFeatureReplacement =		L"{00000000-0000-0000-0000-000000000000}"; 
const UINT   g_cchFeatureReplacement =		39;

const LPWSTR g_wzCabinetStream =			L"MergeModule.Cabinet"; 
const LPWSTR g_wzLanguagePrefix =			L"MergeModule.Lang"; 
const UINT	 g_cchLanguagePrefix =			25;		// 8 added for numeric language value

const LPWSTR g_wzModuleSignatureTable =		L"ModuleSignature";
const LPWSTR g_wzModuleDependencyTable =	L"ModuleDependency";
const LPWSTR g_wzModuleExclusionTable =		L"ModuleExclusion";
const LPWSTR g_wzModuleIgnoreTable =		L"ModuleIgnoreTable";
const LPWSTR g_wzFeatureComponentsTable =	L"FeatureComponents";
const LPWSTR g_wzFileTable =				L"File"; 
const LPWSTR g_wzModuleConfigurationTable =	L"ModuleConfiguration"; 
const LPWSTR g_wzModuleSubstitutionTable =  L"ModuleSubstitution"; 


const LPWSTR g_rgwzModuleSequenceTables[] = { 
	L"ModuleAdminUISequence",
	L"ModuleAdminExecuteSequence",
	L"ModuleAdvtUISequence",
	L"ModuleAdvtExecuteSequence",
	L"ModuleInstallUISequence",
	L"ModuleInstallExecuteSequence"
};
const UINT g_cwzSequenceTables = sizeof(g_rgwzModuleSequenceTables)/sizeof(LPWSTR);

///////////////////////////////////////////////////////////
// SQL statements
// ***** Effeciency: all of these should be escaped.
LPCTSTR g_sqlExecuteConnect[] = { TEXT("SELECT `Component`.`Component` FROM `Component`"),
								 TEXT("INSERT INTO `FeatureComponents` (`Feature_`, `Component_`) VALUES (?, ?)")
							};

LPCTSTR g_sqlExecuteMerge = TEXT("SELECT `_Tables`.`Name` FROM `_Tables`");

LPCTSTR g_sqlCreateMergeIgnore = TEXT("CREATE TABLE `__MergeIgnore` (`Name` CHAR NOT NULL TEMPORARY, `Log` INTEGER TEMPORARY PRIMARY KEY `Name`)");
LPCTSTR g_sqlInsertMergeIgnore = TEXT("SELECT `Name`, `Log` FROM `__MergeIgnore`");
LPCTSTR g_sqlQueryMergeIgnore = TEXT("SELECT `Name`, `Log` FROM `__MergeIgnore` WHERE `Name`=?");
LPCWSTR g_rgwzIgnoreTables[] = {
	g_wzDirectoryTable,
	g_wzFeatureComponentsTable,
	g_wzModuleIgnoreTable,
	g_wzModuleSignatureTable,
	g_wzFileTable,
	g_rgwzModuleSequenceTables[0],
	g_rgwzModuleSequenceTables[1],
	g_rgwzModuleSequenceTables[2],
	g_rgwzModuleSequenceTables[3],
	g_rgwzModuleSequenceTables[4],
	g_rgwzModuleSequenceTables[5],
	g_rgwzMSISequenceTables[0],
	g_rgwzMSISequenceTables[1],
	g_rgwzMSISequenceTables[1],
	g_rgwzMSISequenceTables[3],
	g_rgwzMSISequenceTables[4],
	g_rgwzMSISequenceTables[5],
	g_wzModuleConfigurationTable,
	g_wzModuleSubstitutionTable,
	L"__MergeIgnore",
	L"__ModuleConfig",
	L"__MergeSubstitute"
};
const UINT g_cwzIgnoreTables = sizeof(g_rgwzIgnoreTables)/sizeof(LPWSTR);
					
LPCTSTR g_sqlSetHighestFileSequence[] = { TEXT("SELECT `Sequence` FROM `File`")
												};

LPCTSTR g_sqlMergeFileTable[] = {	TEXT("SELECT `File`,`Component_`,`FileName`,`FileSize`,`Version`,`Language`,`Attributes`,`Sequence` FROM `File`")
										};

LPCTSTR g_sqlTableExists[] = { TEXT("SELECT _Tables.Name FROM `_Tables` WHERE _Tables.Name=?")
										};


LPCTSTR g_sqlExclusion[] = { TEXT("SELECT `ModuleID`, `Language`, `Version` FROM `ModuleSignature`") };

LPCTSTR g_sqlDependency[] = { TEXT("SELECT `RequiredID`,`RequiredLanguage`,`RequiredVersion` FROM `ModuleDependency`"),
										TEXT("SELECT `ModuleID`,`Language`,`Version` FROM `ModuleSignature` WHERE `ModuleID`=?")
									};

LPCTSTR g_sqlExtractFiles[] = {	TEXT("SELECT File.File, Directory.Directory_Parent, Directory.DefaultDir, File.FileName FROM `File`, `Component`, `Directory` WHERE Component.Component=File.Component_ AND Component.Directory_=Directory.Directory"),
											TEXT("SELECT Directory.Directory_Parent, Directory.DefaultDir FROM `Directory` WHERE Directory.Directory=?")
										};

LPCTSTR g_sqlExtractFilePath[] = {	TEXT("SELECT File.File, Directory.Directory_Parent, Directory.DefaultDir, File.FileName FROM `File`, `Component`, `Directory` WHERE Component.Component=File.Component_ AND Component.Directory_=Directory.Directory AND File.Filename=%s"),
												TEXT("SELECT Directory.Directory_Parent, Directory.DefaultDir FROM `Directory` WHERE Directory.Directory=?") };

LPCTSTR g_sqlAllFiles = TEXT("SELECT `File`.`File` FROM `File`");

LPCTSTR g_sqlMoveIgnoreTable = TEXT("SELECT `Table`, 1 FROM `ModuleIgnoreTable`");

///////////////////////////////////////////////////////////
// constructor	
CMsmMerge::CMsmMerge(bool fExVersion)
{
	m_fExVersion = fExVersion;
	
	// initial count
	m_cRef = 1;

	// no type info yet
	m_pTypeInfo = NULL;

	// invalidate the handles
	m_hDatabase = NULL;
	m_hModule = NULL;
	m_hFileLog = INVALID_HANDLE_VALUE;

	// assume we will own the database on open
	m_bOwnDatabase = TRUE;

	// set the highest sequence to zero
	m_lHighestFileSequence = 0;

	// null out the base path
	m_pwzBasePath = NULL;
	m_fUseLFNExtract = false;
	m_fUseDBForPath = -1;

	// null out the enumerators
	m_pErrors = NULL;
	m_pDependencies = NULL;

	// get the string buffer
	m_wzBuffer = NULL;
	m_cchBuffer = 0;

	// module substitution disabled by default
	m_fModuleConfigurationEnabled = false;
	m_pqGetItemValue = NULL;
	m_piConfig = NULL;
	m_iIntDispId = -1;
	m_iTxtDispId = -1;

	// file lists that have limited lifetimes
	m_plstExtractedFiles = NULL;
	m_plstMergedFiles = NULL;
	
	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
CMsmMerge::~CMsmMerge()
{
	if (m_pTypeInfo)
		m_pTypeInfo->Release();

	// if we own the database close it now
	if (m_bOwnDatabase && m_hDatabase)
	{
		FormattedLog(L"> Warning:: MSI Database was not appropriately closed before exit.\r\n");
		CloseDatabase(FALSE);
	}

	// close everything
	if (m_hModule)
	{
		FormattedLog(L"> Warning:: Merge Module was not appropriately closed before exit.\r\n");
		CloseModule();
	}

	if (INVALID_HANDLE_VALUE != m_hFileLog)
	{
		FormattedLog(L"> Warning:: Log file was not appropriately closed before exit.\r\n");
		CloseLog();	// just close the log file
	}

	ASSERT(NULL == m_pwzBasePath);	// this should be null before the end of ExtractFiles

	// release any left over collections
	if (m_pErrors)
		m_pErrors->Release();

	if (m_pDependencies)
		m_pDependencies->Release();

	// clean up the temporary buffer
	if (m_wzBuffer)
		delete m_wzBuffer;

	if (m_pqGetItemValue)
		delete m_pqGetItemValue;

	// clean up merged file list
	if (m_plstMergedFiles)
		m_plstMergedFiles->Release();

	// clean up extracted file list
	if (m_plstExtractedFiles)
		m_plstExtractedFiles->Release();

	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor

///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT CMsmMerge::QueryInterface(const IID& iid, void** ppv)
{
	TRACEA("CMsmMerge::QueryInterface - called, IID: %d\n", iid);

	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IMsmMerge*>(this);
	else if (iid == IID_IDispatch)
		*ppv = static_cast<IMsmMerge*>(this);
	else if (iid == IID_IMsmMerge)
		*ppv = static_cast<IMsmMerge*>(this);
	else if (m_fExVersion && iid == IID_IMsmMerge2)
		*ppv = static_cast<IMsmMerge2*>(this);
	else if (!m_fExVersion && iid == IID_IMsmGetFiles)
		*ppv = static_cast<IMsmGetFiles*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CMsmMerge::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CMsmMerge::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// IDispatch interface

HRESULT CMsmMerge::GetTypeInfoCount(UINT* pctInfo)
{
	if(NULL == pctInfo)
		return E_INVALIDARG;

	*pctInfo = 1;	// only one type info supported by this dispatch

	return S_OK;
}

HRESULT CMsmMerge::GetTypeInfo(UINT iTInfo, LCID /* lcid */, ITypeInfo** ppTypeInfo)
{
	if (0 != iTInfo)
		return DISP_E_BADINDEX;

	if (NULL == ppTypeInfo)
		return E_INVALIDARG;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	*ppTypeInfo = m_pTypeInfo;
	m_pTypeInfo->AddRef();

	return S_OK;
}

HRESULT CMsmMerge::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
						 LCID lcid, DISPID* rgDispID)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID);
}

HRESULT CMsmMerge::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
				  DISPPARAMS* pDispParams, VARIANT* pVarResult,
				  EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr = S_OK;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->Invoke(static_cast<IMsmMerge2 *>(this), dispIdMember, wFlags, pDispParams, pVarResult,
										pExcepInfo, puArgErr);
}

HRESULT CMsmMerge::InitTypeInfo()
{
	HRESULT hr = S_OK;
	ITypeLib* pTypeLib = NULL;

	// if there is no info loaded
	if (NULL == m_pTypeInfo)
	{
		// try to load the Type Library into memory. For SXS support, do not load from registry, rather
		// from launched instance
		hr = LoadTypeLibFromInstance(&pTypeLib);
		if (FAILED(hr))
		{
			TRACEA("CMsmMerge::InitTypeInfo - failed to load TypeLib[0x%x]\n", LIBID_MsmMergeTypeLib);
			return hr;
		}

		// try to get the Type Info for this Interface
		hr = pTypeLib->GetTypeInfoOfGuid(m_fExVersion ? IID_IMsmMerge2 : IID_IMsmMerge, &m_pTypeInfo);
		if (FAILED(hr))
		{
			TRACEA("CMsmMerge::InitTypeInfo - failed to get inteface[0x%x] from TypeLib[0x%x]\n", IID_IMsmMerge, LIBID_MsmMergeTypeLib);

			// no type info was loaded
			m_pTypeInfo = NULL;
		}

		pTypeLib->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IMsmMerge interface

///////////////////////////////////////////////////////////
// OpenDatabase
HRESULT CMsmMerge::OpenDatabase(const BSTR Path)
{
	// if there already is a database open bail
	if (m_hDatabase)
		return HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES);

	UINT iResult = ERROR_SUCCESS;	// assume everything will be okay

	// if a handle was passed in (starts with #)
	if (L'#' == *Path)
	{
		m_bOwnDatabase = FALSE;	// database was not opened by the COM Object

		// convert string to valid handle
		LPWSTR wzParse = Path + 1;
		int ch;
		while ((ch = *wzParse) != 0)
		{
			// if the character is not a number (thus not part of the address of the handle)
			if (ch < L'0' || ch > L'9')
			{
				m_hDatabase = NULL;					// null out the handle
				iResult = ERROR_INVALID_HANDLE;	// invalid handle
				break;									// quit trying to make this work
			}
			m_hDatabase = m_hDatabase * 10 + (ch - L'0');
			wzParse++;
		}

		// if open is okay
		if (ERROR_SUCCESS == iResult)
			FormattedLog(L"Opened MSI Database from handle %ls\r\n", Path);

		else	// failed to open database
			FormattedLog(L">> Error: Failed to open MSI Database with handle %ls\r\n", Path);
	}
	else	// open the database read/write by the string name
	{
		m_bOwnDatabase = TRUE;	// database was opened by the COM Object

		iResult = ::MsiOpenDatabaseW(Path, reinterpret_cast<LPCWSTR>(MSIDBOPEN_TRANSACT), &m_hDatabase);
		if (ERROR_SUCCESS == iResult)
		{
			FormattedLog(L"Opened MSI Database: %ls\r\n", Path);
		}
		else
		{
			FormattedLog(L">> Error: Failed to open MSI Database: %ls\r\n", Path);		
		}
	}

	// if open is successful
	if (ERROR_SUCCESS == iResult)
	{
		// if the highest file sequence is
		if (ERROR_SUCCESS != (iResult = SetHighestFileSequence()))
		{
			FormattedLog(L">> Error: Failed to get File Table's highest sequence [high sequence = %d].\r\n", m_lHighestFileSequence);
		}
	}

	// return if open was successful
	return HRESULT_FROM_WIN32(iResult);
}	// end of OpenDatabase

///////////////////////////////////////////////////////////
// OpenModule
HRESULT CMsmMerge::OpenModule(const BSTR Path, short Language)
{
	// if there already is a module open bail
	if (m_hModule)
		return HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES);

	// open the module read only
	UINT iResult;
	iResult = ::MsiOpenDatabaseW(Path, reinterpret_cast<LPCWSTR>(MSIDBOPEN_READONLY), &m_hModule);

	// if open is successful
	if (ERROR_SUCCESS == iResult)
	{
		// check to make sure the module signature table exists
		if (MsiDBUtils::TableExistsW(g_wzModuleSignatureTable, m_hModule))
		{
			// soter filename
			wcsncpy(m_wzModuleFilename, Path, MAX_PATH - 1);
			m_wzModuleFilename[MAX_PATH - 1] = L'\0';

			FormattedLog(L"Opened Merge Module: %ls\r\n", Path);

			// get the module's default language
			short nModuleLanguage;
			iResult = ModuleLanguage(nModuleLanguage);

			if (ERROR_SUCCESS == iResult)
			{
				// for the merge to succeed, the module language must satisfy the requirements and be LESS
				// restrictive than the database.
				if (!StrictLangSatisfy(Language, nModuleLanguage))
				{
					// module language doesn't work. Try transforming
					short nNewLanguage;
					iResult = ERROR_FUNCTION_FAILED;

					// Step1: if the desired language specifies an exact language, try it
					if (SUBLANGID(Language) != 0)
					{
						nNewLanguage = Language;
						FormattedLog(L"Transforming Merge Module from language %d to %d.\r\n", nModuleLanguage, nNewLanguage);
						
						// apply the transform from the database itself
						WCHAR wzLangTransform[g_cchLanguagePrefix];
						swprintf(wzLangTransform, L":%ls%d", g_wzLanguagePrefix, Language);

						// apply the transform and ignore any errors
						iResult = ::MsiDatabaseApplyTransformW(m_hModule, wzLangTransform, 0x1F);
					}

					// Step2: if failed above or desired language is a group, try to transform to group
					if ((ERROR_SUCCESS != iResult) && (PRIMARYLANGID(Language) != 0))
					{
						nNewLanguage = PRIMARYLANGID(Language);
						FormattedLog(L"Transforming Merge Module from language %d to group %d.\r\n", nModuleLanguage, nNewLanguage);
						
						// apply the transform from the database itself
						WCHAR wzLangTransform[g_cchLanguagePrefix];
						swprintf(wzLangTransform, L":%ls%d", g_wzLanguagePrefix, PRIMARYLANGID(Language));

						// apply the transform and ignore any errors
						iResult = ::MsiDatabaseApplyTransformW(m_hModule, wzLangTransform, 0x1F);
					}

					// Step3: if failed above or desired language is neutral, try to transform to neutral
					if (ERROR_SUCCESS != iResult)
					{
						nNewLanguage = 0;
						FormattedLog(L"Transforming Merge Module from language %d to language neutral.\r\n", nModuleLanguage);
						
						// apply the transform from the database itself
						WCHAR wzLangTransform[g_cchLanguagePrefix];
						swprintf(wzLangTransform, L":%ls%d", g_wzLanguagePrefix, 0);

						// apply the transform and ignore any errors
						iResult = ::MsiDatabaseApplyTransformW(m_hModule, wzLangTransform, 0x1F);
					}

					if (ERROR_SUCCESS == iResult)
					{
						ModuleLanguage(nModuleLanguage);
						FormattedLog(L"Merge Module is now language: %d\r\n", nNewLanguage);
						return ERROR_SUCCESS;
					}
					else if (ERROR_OPEN_FAILED == iResult)
					{
						FormattedLog(L">> Error: Failed to locate transform for any language that would satisfy %d\r\n", Language);

						// clear out any old errors and create a new enumerator to hold new ones
						ClearErrors();
						m_pErrors = new CMsmErrors;
						if (!m_pErrors) return E_OUTOFMEMORY;

						// create language error
						CMsmError *pErr = new CMsmError(msmErrorLanguageUnsupported, NULL, Language);
						if (!pErr) return E_OUTOFMEMORY;
						m_pErrors->Add(pErr);
					}
					else	// some really bad error
					{
						FormattedLog(L">> Error: Failed to apply transform for language: %d\r\n", nNewLanguage);

						// clear out any old errors and create a new enumerator to hold new ones
						ClearErrors();
						m_pErrors = new CMsmErrors;
						if (!m_pErrors) return E_OUTOFMEMORY;

						// create a transform error
						CMsmError *pErr = new CMsmError(msmErrorLanguageFailed, NULL, nNewLanguage);
						if (!pErr) return E_OUTOFMEMORY;
						m_pErrors->Add(pErr);
					}

					// could not get a valid language
					::MsiCloseHandle(m_hModule);
					m_hModule = 0;
					return HRESULT_FROM_WIN32(ERROR_INSTALL_LANGUAGE_UNSUPPORTED);
				}
				
			}
		}
		else	// this is not a Merge Module
		{
			// close the module and log the error
			FormattedLog(L">> Error: File %ls is not a Merge Module.\r\n   The file is lacking the required MergeSignature Table.\r\n", Path);			
			::MsiCloseHandle(m_hModule);
			m_hModule = 0;
			return E_ABORT;	// abort open
		}
	}
	else	// failed to open module
	{
		::MsiCloseHandle(m_hModule);
		m_hModule = 0;
		FormattedLog(L">> Error: Failed to open Merge Module: %ls\r\n", Path);
	}
	// return status of open
	return  HRESULT_FROM_WIN32(iResult);
}	// end of OpenModule

///////////////////////////////////////////////////////////
// CloseDatabase
HRESULT CMsmMerge::CloseDatabase(VARIANT_BOOL Commit)
{
	UINT iResult = ERROR_SUCCESS;		// assume everything is okay
	HRESULT hResult = S_OK;

	// if there is an open database
	if (m_hDatabase)
	{
		// if we are to commit
		if (VARIANT_FALSE != Commit)
		{			
			// try to commit database
			iResult = ::MsiDatabaseCommit(m_hDatabase);

			// if succeeded in committing database
			if (ERROR_SUCCESS == iResult)
				FormattedLog(L"Committed changes to MSI Database.\r\n");
			else
			{
				FormattedLog(L">> Error: Failed to save changes to MSI Database.\r\n");
				hResult = HRESULT_FROM_WIN32(STG_E_CANTSAVE);
			}
		}
		else	// not committing changes
			FormattedLog(L"> Warning: Changes were not saved to MSI Database.\r\n");


		// now try to close the database
		if (m_bOwnDatabase)
		{
			iResult = ::MsiCloseHandle(m_hDatabase);

			// if succeeded
			if (ERROR_SUCCESS == iResult)
			{
				FormattedLog(L"Closed MSI Database.\r\n");
				m_hDatabase = NULL;
			}
			else	// failed to close database
			{
				FormattedLog(L">> Error: Failed to close MSI Database.\r\n");
				hResult = E_FAIL;
			}
		}
		else
			m_hDatabase = NULL;
	}
	else
		return S_FALSE;

	// if there are any dependencies release them
	if (m_pDependencies)
	{
		m_pDependencies->Release();
		m_pDependencies = NULL;
	}

	// set the highest sequence back to zero
	m_lHighestFileSequence = 0;

	return !iResult ? S_OK : hResult;
}	// end of CloseDatabase

///////////////////////////////////////////////////////////
// CloseModule
HRESULT CMsmMerge::CloseModule(void)
{
	UINT iResult = ERROR_SUCCESS;

	// if there is an open module
	if (m_hModule)
	{
		// close the module
		iResult = ::MsiCloseHandle(m_hModule);
		
		// if succeed in closing module
		if (ERROR_SUCCESS == iResult)
		{
			FormattedLog(L"Closed Merge Module.\r\n");
			m_hModule = NULL;
		}
		else	// failed to close the module
		{
			FormattedLog(L">> Error: Failed to close Merge Module.\r\n");
		}
	}
	else
		return S_FALSE;

	// clean out the module filename
	wcscpy(m_wzModuleFilename, L"");
	return iResult ? E_FAIL : S_OK;
}	// end of CloseModule

///////////////////////////////////////////////////////////
// OpenLog
HRESULT CMsmMerge::OpenLog(BSTR Path)
{
	// if there already is a log file open
	if (INVALID_HANDLE_VALUE != m_hFileLog)
		return HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES);

	// open the file or create it if it doesn't exist
	if (g_fWin9X)
	{
		char szPath[MAX_PATH];
		size_t cchPath = MAX_PATH;
		WideToAnsi(Path, szPath, &cchPath);
		m_hFileLog = ::CreateFileA(szPath, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	}
	else
	{
		m_hFileLog = ::CreateFileW(Path, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	}

	// if the file is open
	if (INVALID_HANDLE_VALUE != m_hFileLog)
		::SetFilePointer(m_hFileLog, 0, 0, FILE_END);	// move the file pointer to the end

	// return if open worked
	return (INVALID_HANDLE_VALUE != m_hFileLog) ? S_OK : HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
}	// end of OpenLog

///////////////////////////////////////////////////////////
// CloseLog
HRESULT CMsmMerge::CloseLog(void)
{
	// if the log file is open
	if (INVALID_HANDLE_VALUE != m_hFileLog)
	{
		// end logging
		BOOL bResult = ::CloseHandle(m_hFileLog);
		m_hFileLog = INVALID_HANDLE_VALUE;	// reset the handle invalid
		return bResult ? S_OK : E_FAIL;
	}
	else
		return S_FALSE;
}	// end of CloseLog

///////////////////////////////////////////////////////////
// Log
HRESULT CMsmMerge::Log(BSTR Message)
{
	// if the log file is not open
	if (INVALID_HANDLE_VALUE == m_hFileLog)
		return S_FALSE;	// bail everything's okay

	return FormattedLog(L"%ls\r\n", Message);
}	// end of Log

///////////////////////////////////////////////////////////
// Errors
HRESULT CMsmMerge::get_Errors(IMsmErrors** Errors)
{
	// error check
	if (!Errors)
		return E_INVALIDARG;

	*Errors = NULL;

	// if there are some errors
	if (m_pErrors)
	{
		*Errors = (IMsmErrors*)m_pErrors;
		m_pErrors->AddRef();	// addref it before returning it
	}
	else	// no errors return empty enumerator
	{
		*Errors = new CMsmErrors;
		if (!*Errors)
			return E_OUTOFMEMORY;
	}

	return S_OK;
}	// end of Errors

///////////////////////////////////////////////////////////
// Dependencies
HRESULT CMsmMerge::get_Dependencies(IMsmDependencies** Dependencies)
{
	if (!Dependencies)
		return E_INVALIDARG;

	*Dependencies = NULL;
	// if the database isn't open bail
	if (NULL == m_hDatabase)
		return E_UNEXPECTED;				// !!! Right thing to return?

	// get the dependency enumerator
	UINT iResult;
	if (ERROR_SUCCESS != (iResult = CheckDependencies()))
		return E_UNEXPECTED;

	// return the enumerator interface
	*Dependencies = (IMsmDependencies*)m_pDependencies;
	m_pDependencies->AddRef();	// addref it before returning it

	return S_OK;
}	// end of Dependencies


UINT CMsmMerge::CheckSummaryInfoPlatform(bool &fAllow)
{
	PMSIHANDLE hSummary;

	// by default, all merging is allowed.
	fAllow = true;

	if (ERROR_SUCCESS == MsiGetSummaryInformation(m_hModule, NULL, 0, &hSummary))
	{
		int iValue = 0;
		FILETIME ftValue;
		DWORD uiResult = ERROR_SUCCESS;
		DWORD cchValue = 255;
		UINT uiDataType = 0;
		WCHAR *wzValue = new WCHAR[255];
		if (!wzValue)
			return E_OUTOFMEMORY;
		uiResult = MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, &uiDataType, &iValue, &ftValue, wzValue, &cchValue);
		if (uiResult == ERROR_MORE_DATA)
		{
			delete[] wzValue;
			wzValue = new WCHAR[++cchValue];
			if (!wzValue)
				return E_OUTOFMEMORY;
			uiResult = MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, &uiDataType, &iValue, &ftValue, wzValue, &cchValue);
		}

		if (ERROR_SUCCESS == uiResult && uiDataType == VT_LPSTR)
		{
			// found a summaryinfo template property, search for Intel64. Not allowed to have both Intel and Intel64, so just
			// check for Intel64. (ignore possibility of "Alpha,Intel64", not supported)
			if (0 == wcsncmp(wzValue, L"Intel64", (sizeof(L"Intel64")/sizeof(WCHAR))-1))
			{
				PMSIHANDLE hDatabaseSummary;
														
				// 64bit module. Check that the database is also 64bit
				if (ERROR_SUCCESS == MsiGetSummaryInformation(m_hDatabase, NULL, 0, &hDatabaseSummary))
				{
					cchValue = 255;
					uiResult = MsiSummaryInfoGetProperty(hDatabaseSummary, PID_TEMPLATE, &uiDataType, &iValue, &ftValue, wzValue, &cchValue);
					if (uiResult == ERROR_MORE_DATA)
					{
						delete[] wzValue;
						wzValue = new WCHAR[++cchValue];
						if (!wzValue)
							return E_OUTOFMEMORY;
						uiResult = MsiSummaryInfoGetProperty(hDatabaseSummary, PID_TEMPLATE, &uiDataType, &iValue, &ftValue, wzValue, &cchValue);
					}

					if (ERROR_SUCCESS == uiResult && uiDataType == VT_LPSTR)
					{
						// 64bit module, and the database has a valid SummaryInfo stream, so now the default is failure.
						fAllow = false;

						// found a summaryinfo template property, search for Intel64. Not allowed to have both Intel and Intel64, so just
						// check for Intel64. (ignore possibility of "Alpha,Intel64", not supported)
						if (0 == wcsncmp(wzValue, L"Intel64", (sizeof(L"Intel64")/sizeof(WCHAR))-1))
						{
							// 64bit package and 64bit module, OK
							fAllow = true;
						}
					}
				}
			}
		}
		else
		{
			// the MSM spec was ambiguous about whether the template proprety was required. If there is an error
			// reading from it, assume a 32bit module and continue
		}
		delete[] wzValue;
	}
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////
// Merge and MergeEx
HRESULT CMsmMerge::MergeEx(const BSTR Feature, const BSTR RedirectDir, IUnknown* pConfiguration)
{
	if (!m_hModule || !m_hDatabase)
		return E_FAIL;

	// first try the vtable interface, then the dispatch interface
	m_fModuleConfigurationEnabled = (pConfiguration != NULL);
	m_piConfig = NULL;
	m_piConfigDispatch = NULL;
	if (m_fModuleConfigurationEnabled)
	{
		if (S_OK != pConfiguration->QueryInterface(IID_IMsmConfigureModule, reinterpret_cast<void**>(&m_piConfig)))
		{
			if (S_OK != pConfiguration->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(&m_piConfigDispatch)))
			{
				return E_INVALIDARG;
			}
			else
			{
				// need to call GetIdsOfNames to get dispatch Ids
				m_iTxtDispId = -1;
				m_iIntDispId = -1;
				WCHAR* wzNameText = L"ProvideTextData";
				m_piConfigDispatch->GetIDsOfNames(IID_NULL, &wzNameText, 1, 0, &m_iTxtDispId);
				WCHAR* wzNameInt = L"ProvideIntegerData";
				m_piConfigDispatch->GetIDsOfNames(IID_NULL, &wzNameInt, 1, 0, &m_iIntDispId);
				
				// if this is implemented in VB as a class with "implements IMsmConfigureModule"
				// the names might be decorated with the interface name. Try that.
				if (m_iTxtDispId == -1)
				{
					WCHAR* wzVBNameText = L"IMsmConfigureModule_ProvideTextData";
					m_piConfigDispatch->GetIDsOfNames(IID_NULL, &wzVBNameText, 1, 0, &m_iTxtDispId);
				}
				if (m_iIntDispId == -1)
				{
					WCHAR* wzVBNameInt = L"IMsmConfigureModule_ProvideIntegerData";
					m_piConfigDispatch->GetIDsOfNames(IID_NULL, &wzVBNameInt, 1, 0, &m_iIntDispId);
				}
				
			}
		}
	}
		
	HRESULT hRes = Merge(Feature, RedirectDir);

	// reset object state
	if (m_piConfigDispatch)
	{
		m_piConfigDispatch->Release();
		m_piConfigDispatch = NULL;
	}
	if (m_piConfig)
	{
		m_piConfig->Release();
		m_piConfig = NULL;
	}
	m_fModuleConfigurationEnabled = false;
	
	return hRes;
}

HRESULT CMsmMerge::Merge(BSTR Feature, BSTR RedirectDir)
{
	// generic return result
	UINT iResult = S_FALSE;		// assume that the merge will fail.

	if (!m_hModule || !m_hDatabase)
		return E_FAIL;

	// clear out any old errors and create a new enumerator to hold new ones
	ClearErrors();
	m_pErrors = new CMsmErrors;
	if (!m_pErrors) return E_OUTOFMEMORY;

	// if the exclusions pass
	if (ERROR_SUCCESS == CheckExclusionTable())
	{
		bool f64BitOK;
		if (ERROR_SUCCESS != (iResult = CheckSummaryInfoPlatform(f64BitOK)))
		{
			return iResult;
		}

		if (!f64BitOK)
		{
			FormattedLog(L">> Error: Merging 64bit module into 32bit database.\r\n");
			if (m_pErrors)
			{
				CMsmError *pErr = new CMsmError(msmErrorPlatformMismatch, NULL, -1);
				if (!pErr) 
					return E_OUTOFMEMORY;
				m_pErrors->Add(pErr);
			}
			return E_FAIL;
		}

		// try to connect and merge component
		try
		{
			// execute the merge
			iResult = ExecuteMerge(Feature, RedirectDir);

			// if the merge was successful and we were provided a feature
			if (ERROR_SUCCESS == iResult)
				iResult = ExecuteConnect(Feature);	// execute the connect
		}
		catch (CLocalError errLocal)
		{
			iResult = errLocal.GetError();			// get the error
			errLocal.Log(m_hFileLog);					// log the error
		}
		catch (UINT ui)
		{
			// if E_FAIL was thrown, do not log.
			if (ui != E_FAIL)
				FormattedLog(L">>> Fatal Error: Internal Error %d during merge.\r\n", ui);
			return E_FAIL;
		}
		catch (...)
		{
			FormattedLog(L">>> Fatal Error: Unhandled exception during merge.\r\n");
			return E_FAIL;
		}
	}
	else		// log the exclusion error
	{
		FormattedLog(L">> Error: Merge Module `%ls` is excluded by another Merge Module.\r\n", m_wzModuleFilename);
	}

	// return the result of the merge
	if (iResult != ERROR_SUCCESS)
		return S_FALSE;
	return S_OK;
}	// end of Merge

///////////////////////////////////////////////////////////
// Connect
HRESULT CMsmMerge::Connect(BSTR Feature)
{
	if (!Feature || (0 == ::wcslen(Feature)))
		return E_INVALIDARG;

	// execute the connection
	UINT iResult = ExecuteConnect(Feature);

	return iResult ? E_FAIL : S_OK;	// return result
}	// end of Connect

///////////////////////////////////////////////////////////
// ExtractCAB
HRESULT CMsmMerge::ExtractCAB(const BSTR Path)
{
	return ExtractCABCore(Path);
}

HRESULT CMsmMerge::ExtractCABCore(const WCHAR* Path)
{
	char szPath[MAX_PATH];
	WCHAR wzPath[MAX_PATH];

	// if no path is specified
	if (!Path)
		return E_INVALIDARG;
	size_t cchPath = ::wcslen(Path);
	if ( cchPath > 255 )
		return E_INVALIDARG;

	HRESULT hResult = E_FAIL;			// generic return result

	FormattedLog(L"Extracting MergeModule CAB to %ls.\r\n", Path);
	
	// Query the streams table
	CQuery qStreams;
	PMSIHANDLE hCABStream;
	if (ERROR_SUCCESS != (hResult = qStreams.OpenExecute(m_hModule, NULL, 
		TEXT("SELECT `Data` FROM `_Streams` WHERE `Name`='MergeModule.CABinet'"))))
	{
		FormattedLog(L">> Error: Couldn't find streams in Merge Module [%ls].\r\n", m_wzModuleFilename);
		return E_FAIL;
	}

	// try to get the stream. It may not exist.
	hResult = qStreams.Fetch(&hCABStream);
	switch (hResult)
	{
	case ERROR_SUCCESS: break;
	case ERROR_NO_MORE_ITEMS:
		FormattedLog(L"> Warning: No Embedded CAB in Merge Module [%ls]. This could be OK, or it could signify a problem with your module.\r\n", m_wzModuleFilename);
		return S_FALSE;
	default:
		FormattedLog(L">> Error: Couldn't access streams in Merge Module [%ls].\r\n", m_wzModuleFilename);
		return E_FAIL;
	}

	char *pchBackSlash = NULL;
	WCHAR *pwchBackSlash = NULL;
	if (g_fWin9X) 
	{
		// Make an ANSI version of the path (maybe DBCS)
		size_t cchAnsiPath = MAX_PATH;
		WideToAnsi(Path, szPath, &cchAnsiPath);

		// DBCS means we can't just go searching for the slash in the ANSI string.
		// instead, search the wide version, then advance in the ANSI version that many characters
		pwchBackSlash = wcsrchr(Path, L'\\');
		if (pwchBackSlash)
		{
			pchBackSlash = szPath;
			for (int i=0; i != pwchBackSlash-Path; i++) 
				pchBackSlash = CharNextExA(CP_ACP, pchBackSlash, 0);
			*pchBackSlash = '\0';
		}
	}
	else
	{
		wcsncpy(wzPath, Path, 255);
		pwchBackSlash = wcsrchr(wzPath, L'\\');
		if (pwchBackSlash) *pwchBackSlash = L'\0';
	}

	// create the path if it doesn't exist
	DWORD lDirResult = g_fWin9X ? ::GetFileAttributesA(szPath) : ::GetFileAttributesW(wzPath); 
	
	if (lDirResult == 0xFFFFFFFF)
	{
		if (!(g_fWin9X ? CreatePathA(szPath) : CreatePathW(wzPath))) 
		{
			FormattedLog(L">> Error: Failed to create Directory: %ls.\r\n", wzPath);
			if (m_pErrors)
			{
				CMsmError *pErr = new CMsmError(msmErrorDirCreate, wzPath, -1);
				if (!pErr) return E_OUTOFMEMORY;
				m_pErrors->Add(pErr);
			}
			return HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
		}
	}
	else if ((lDirResult & FILE_ATTRIBUTE_DIRECTORY) == 0) 
	{
		// exists, but not a directory...fail
		FormattedLog(L">> Error: Failed to create Directory: %ls.\r\n", wzPath);
		if (m_pErrors)
		{
			CMsmError *pErr = new CMsmError(msmErrorDirCreate, wzPath, -1);
			if (!pErr) return E_OUTOFMEMORY;
			m_pErrors->Add(pErr);
		}
		return HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
	}

	// try to create extract file (will not overwrite files)
	HANDLE hCabinetFile = INVALID_HANDLE_VALUE;
	if (g_fWin9X) 
	{
		// the path creation check turned the filename into a path by turning the '\'
		// into a '\0'. Change it back to re-attach the filename
		*pchBackSlash = '\\';
		hCabinetFile = ::CreateFileA(szPath, GENERIC_WRITE, 0, (LPSECURITY_ATTRIBUTES)0, 
												 CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)0);
	}
	else 
		hCabinetFile = ::CreateFileW(Path, GENERIC_WRITE, 0, (LPSECURITY_ATTRIBUTES)0, 
												 CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)0);

	// if failed to create file
	if (hCabinetFile == INVALID_HANDLE_VALUE)
	{
		FormattedLog(L">> Error: Failed to create CABinet file [%ls].\r\n", Path);		
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);	// ??? Right error code?
	}

	// create a buffer of 10K
	char *pBuffer = new char[10240]; 
	if (!pBuffer) return E_OUTOFMEMORY;
	unsigned long cbRead;
	unsigned int cbTotal = 0;

	// loop while there is still data to be read from stream
	do {
		cbRead = 10240;
		// try to read data from stream
		hResult = MsiRecordReadStream(hCABStream, 1, pBuffer, &cbRead);
		if (FAILED(hResult))
		{
			::CloseHandle(hCabinetFile);

			FormattedLog(L">> Error: Failed to read stream in Merge Module [%ls].\r\n", m_wzModuleFilename);

			delete[] pBuffer;
			return E_FAIL;
		}

		if (cbRead != 0) {
			// write data to file
			unsigned long cbWritten;
			if (!::WriteFile(hCabinetFile, pBuffer, cbRead, &cbWritten, (LPOVERLAPPED)0))
			{
				::CloseHandle(hCabinetFile);

				FormattedLog(L">> Error: Failed to write to CABinet file [%ls].\r\n", Path);
				delete[] pBuffer;
				return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);		// !!! Right error code?
			}

			// if didn't write all we read
			if (cbWritten != cbRead)
			{
				::CloseHandle(hCabinetFile);

				FormattedLog(L">> Error: Failed to write all bytes to CABinet file [%ls].\r\n", Path);

				delete[] pBuffer;
				return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);		// !!! Right error code?
			}
		}

		// update the total
		cbTotal += cbRead;	
	} while (cbRead > 0);

	delete[] pBuffer;

	// if we read nothing
	if (cbTotal == 0)
	{
		FormattedLog(L">> Error: Failed to read stream in Merge Module [%ls].\r\n", m_wzModuleFilename);
		return hResult;
	}

	// close the extract file
	::CloseHandle(hCabinetFile);
	FormattedLog(L"%ls extracted successfully.\r\n", Path);				

	return S_OK;
}	// end of ExtractCABCore


///////////////////////////////////////////////////////////
// ExtractFiles
HRESULT CMsmMerge::ExtractFiles(BSTR Path)
{
	m_fUseDBForPath = -1;
	return ExtractFilesCore(Path, VARIANT_FALSE, NULL);
}

HRESULT CMsmMerge::ExtractFilesEx(const BSTR Path, VARIANT_BOOL fLFN, IMsmStrings **FilePaths)
{
	m_fUseDBForPath = FALSE;
	return ExtractFilesCore(Path, fLFN, FilePaths);
}

HRESULT CMsmMerge::CreateSourceImage(const BSTR Path, VARIANT_BOOL fLFN, IMsmStrings **FilePaths)
{
	m_fUseDBForPath = TRUE;
	return ExtractFilesCore(Path, fLFN, FilePaths);
}

HRESULT CMsmMerge::ExtractFilesCore(const BSTR Path, VARIANT_BOOL fLFN, IMsmStrings **FilePaths)
{
	// if no base path is specified
	if (!Path)
		return E_INVALIDARG;

	size_t cchPath = ::wcslen(Path);

	if ((0 == cchPath) || (cchPath > MAX_PATH))
		return E_INVALIDARG;

	WCHAR wzPath[MAX_PATH];
	char szPath[MAX_PATH];

	// if a list of files is requested, create an object
	if (FilePaths)
	{
		if (m_plstExtractedFiles)
			m_plstExtractedFiles->Release();
			
		m_plstExtractedFiles = new CMsmStrings;
		if (!m_plstExtractedFiles)
			return E_OUTOFMEMORY;
	}

	// neaten path and make an ANSI version for the system calls
	wcscpy(wzPath, Path);
	if (wzPath[cchPath-1] == L'\\')
		wzPath[cchPath-1] = L'\0';
	size_t cchLen = MAX_PATH;
	WideToAnsi(wzPath, szPath, &cchLen);

	// if the path does not exist, create it
	DWORD lDirResult = g_fWin9X ? ::GetFileAttributesA(szPath) : ::GetFileAttributesW(wzPath); 
	
	if (lDirResult == 0xFFFFFFFF)
	{
		if (!(g_fWin9X ? CreatePathA(szPath) : CreatePathW(wzPath))) 
		{
			FormattedLog(L">> Error: Failed to extract files to path: %ls.\r\n", wzPath);

			// create directory error
			if (m_pErrors)
			{
				CMsmError *pErr = new CMsmError(msmErrorDirCreate, wzPath, -1);
				if (!pErr) return E_OUTOFMEMORY;
				m_pErrors->Add(pErr);
			}

			return HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
		}
	}
	else if ((lDirResult & FILE_ATTRIBUTE_DIRECTORY) == 0) 
	{
		// exists, but not a directory...fail
		FormattedLog(L">> Error: Failed to extract files to path: %ls.\r\n", wzPath);
		if (m_pErrors)
		{
			CMsmError *pErr = new CMsmError(msmErrorDirCreate, wzPath, -1);
			if (!pErr) return E_OUTOFMEMORY;
			m_pErrors->Add(pErr);
		}
		return HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
	}

	// create a temp filename for the Merge Module Cabinet
	// we will need both ANSI and Unicode versions of the path. We create the BSTR
	// from the Unicode version, and the CAB code needs the ANSI version.
	UINT iTempResult;
	WCHAR wzTempFilename[MAX_PATH];
	char szTempFilename[MAX_PATH];

	if (g_fWin9X) 
	{
		// Win9X ONLY
		iTempResult = ::GetTempFileNameA(szPath, "MMC", 0, szTempFilename);
		size_t cchTempFileName = MAX_PATH;
		AnsiToWide(szTempFilename, wzTempFilename, &cchTempFileName);
	}
	else
	{
		// Unicode system only 
		iTempResult = ::GetTempFileNameW(wzPath, L"MMC", 0, wzTempFilename);
		size_t cchTempFileName = MAX_PATH;
		WideToAnsi(wzTempFilename, szTempFilename, &cchTempFileName);
	}

	// if failed to get a temp file path
	if (0 == iTempResult)
	{
		FormattedLog(L">> Error: Failed to create a temporary file to extract files in path: %ls.\r\n", wzPath);
		return E_FAIL;
	}

	// extract cab to temp file by calling ExtractCAB. We can use a LPCWSTR instead
	// of a BSTR.
	HRESULT hResult;
	hResult = ExtractCABCore(wzTempFilename);

	// if failed to extract CABinet file
	// note explicit check of S_OK. S_FALSE means no embedded CAB.
	if (S_OK == hResult)
	{
		// m_pwzBasePath should be null before the end of ExtractFiles
		ASSERT(NULL == m_pwzBasePath);	

		// store base path in temp member variable
		m_pwzBasePath = wzPath;
		m_fUseLFNExtract = fLFN ? true : false;

		// create a FDI instance
		HFDI hFDI;
		ERF ErrorInfo;
		hFDI = FDICreate(FDIAlloc, FDIFree, FDIOpen, FDIRead, FDIWrite, FDIClose, FDISeek, cpuUNKNOWN, &ErrorInfo);
		if (NULL != hFDI) 
		{
			// verify that the file is a cabinet
			FDICABINETINFO CabInfo;
			HANDLE hCabinet = CreateFileA(szTempFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0L, NULL);
			if (INVALID_HANDLE_VALUE != hCabinet)
			{
				if (FDIIsCabinet(hFDI, reinterpret_cast<INT_PTR>(hCabinet), &CabInfo)) 
				{
					// close the CAB file
					::CloseHandle(hCabinet);

					// need to extract the filename from the path for use in the API. If the passed-in path
					// has any relative segments ("." or ".."), the path may have been canonicalized by
					// GetTempFileName (especially if on Win9X). Also need to verify that the path is terminated
					// with a trailing backslash. Search for the last backslash in the string
					// and point the filename pointer at the next character. If there are no backslashes,
					// use the entire path as the filename.
					char* pchFileName = szTempFilename;
					char* pchTemp = szTempFilename;
					for (; pchTemp && *pchTemp != '\0'; pchTemp = CharNextExA(CP_ACP, pchTemp, 0))
					{
						if (*pchTemp == '\\')
							pchFileName = CharNextExA(CP_ACP, pchTemp, 0);
					}

					// allocate a new buffer for the filename, ensure its null terminated and place the filename there
					char rgchFileName[MAX_PATH] = "";
					if (!pchFileName)
						pchFileName = szTempFilename;
					size_t iBytesToCopy = pchTemp-pchFileName+1;
					if (iBytesToCopy > MAX_PATH)
						return E_FAIL;
					memcpy(rgchFileName, pchFileName, iBytesToCopy); 

					// need to save char that will be replaced by the null to
					// put it back later for file deletion
					char oldCh = *pchFileName; 
					*pchFileName = 0;

					// iterate through files in cabinet extracting them to the callback function
					hResult = FDICopy(hFDI, rgchFileName, szTempFilename, 0, ExtractFilesCallback, NULL, this) ? S_OK : E_FAIL;
					*pchFileName = oldCh;
					if (FAILED(hResult))
						FormattedLog(L">> Error: Failed to extract all files from CAB '%ls'.\r\n", wzTempFilename);
				}
				else
				{
					// close CAB file
					::CloseHandle(hCabinet);
					FormattedLog(L">> Error: Embedded CAB '%ls' is not a valid CAB File.\r\n", wzTempFilename);
				}
			}
			else
				FormattedLog(L">> Error: Failed to open temporary file '%ls'.\r\n", wzTempFilename);

			// destroy the FDI context
			FDIDestroy(hFDI);
		}
		else
			FormattedLog(L">> Error: Failed to create CAB Decompression object.\r\n");
	}
	else
		FormattedLog(L">> Error: Failed to extract files to path: %ls.\r\n", wzPath);

	// cleanup by deleting the cabinet file.
	if ((g_fWin9X && !::DeleteFileA(szTempFilename)) ||
		(!g_fWin9X && !::DeleteFileW(wzTempFilename)))
	FormattedLog(L"> Warning: Failed to remove temporary file: %ls\r\n", wzTempFilename);

	// null out stored base path
	m_pwzBasePath = NULL;

	// if the caller wants a list of file paths, pass the list pointer back to them.
	if (FilePaths)
	{
		*FilePaths = static_cast<IMsmStrings*>(m_plstExtractedFiles);

		// transfer our single refcount to the caller
		m_plstExtractedFiles = NULL;
	}	

	return hResult;
}	// end of ExtractFiles


/////////////////////////////////////////////////////////////////////////////
// non-interface methods

eColumnType CMsmMerge::ColumnTypeCharToEnum(WCHAR chType) const
{
	switch (chType)
	{
	case 'L':
	case 'l':
	case 'S':
	case 's':
	case 'G':
	case 'g':
		return ectString;
	case 'i':
	case 'I':
	case 'j':
	case 'J':
		return ectInteger;
	case 'V':
	case 'v':
		return ectBinary;
	default:
		return ectUnknown;
	}
}

// determine the column number (index) of a NON-TEMPORARY column in a table.
UINT CMsmMerge::GetColumnNumber(MSIHANDLE hDB, const WCHAR* wzTable, const WCHAR* wzColumn, int &iOutputColumn) const
{
	PMSIHANDLE hRes;
	PMSIHANDLE hRec = MsiCreateRecord(2);
	if (!hRec)
		return ERROR_FUNCTION_FAILED;

	MsiRecordSetStringW(hRec, 1, wzTable);
	MsiRecordSetStringW(hRec, 2, wzColumn);

	CQuery qDatabaseColumn;
	if (ERROR_SUCCESS != qDatabaseColumn.FetchOnce(hDB, hRec, &hRes, TEXT("SELECT `Number` FROM `_Columns` WHERE `Table`=? AND `Name`=?")))
		return ERROR_FUNCTION_FAILED;
	
	iOutputColumn = MsiRecordGetInteger(hRes, 1);
	return ERROR_SUCCESS;
}

// determine the number (index) of a column in an query
UINT CMsmMerge::GetColumnNumber(CQuery& qQuery, const WCHAR* wzColumn, int &iOutputColumn) const
{
	PMSIHANDLE hColumnNames;
	if (ERROR_SUCCESS != qQuery.GetColumnInfo(MSICOLINFO_NAMES, &hColumnNames))
		return ERROR_FUNCTION_FAILED;

	int iColumns = MsiRecordGetFieldCount(hColumnNames);

	DWORD cchBuffer = 72;
	WCHAR* wzName = NULL;
	for (int iColumn=1; iColumn <= iColumns; iColumn++)
	{
		if (ERROR_SUCCESS != RecordGetString(hColumnNames, iColumn, &wzName, &cchBuffer))
		{
			if (wzName)
				delete[] wzName;
			return ERROR_FUNCTION_FAILED;
		}

		if (0 == wcscmp(wzName, wzColumn))
		{
			iOutputColumn = iColumn;
			delete[] wzName;
			return ERROR_SUCCESS;
		}
	}
	if (wzName)
		delete[] wzName;
	return ERROR_FUNCTION_FAILED;
}

///////////////////////////////////////////////////////////
// SetHighestFileSequence
// Pre:	database handle is open
// Pos:	m_lHighestFileSequence is set to the higest sequence in the database's File table
UINT CMsmMerge::SetHighestFileSequence()
{
	UINT iResult = ERROR_SUCCESS;	// assume everything will be okay in the end

	ULONG lSequence;						// current rows sequence number
	m_lHighestFileSequence = 0;		// set the highest sequence back to zero

	// if the file table does not exists the highest sequence is zero, bail
	if (!MsiDBUtils::TableExistsW(L"File", m_hDatabase))
		return ERROR_SUCCESS;

	// try to get the rows in the database's File Table
	try
	{
		// get the File Table in the database
		CQuery queryDatabase;
		CheckError(queryDatabase.OpenExecute(m_hDatabase, NULL, g_sqlSetHighestFileSequence[0]), 
					  L">> Error: Failed to open view on MSI Database's File Table.\r\n");

		// start fetching
		PMSIHANDLE hRecDatabaseFile;
		while (ERROR_SUCCESS == queryDatabase.Fetch(&hRecDatabaseFile))
		{
			// get the sequence number of this record
			lSequence = ::MsiRecordGetInteger(hRecDatabaseFile, 1);

			// if this sequence is higher, bump the highest sequence
			if (lSequence > m_lHighestFileSequence)
				m_lHighestFileSequence = lSequence;
		}
	}
	catch (CLocalError errLocal)
	{
		errLocal.Log(m_hFileLog);	// log the error
		iResult = errLocal.GetError();
	}

	return iResult;
}

///////////////////////////////////////////////////////////
// CheckExclusionTable
// Pre:	database handle is open
//			module handle is open
// Pos:	module check to see if it can coexist with other modules in database
UINT CMsmMerge::CheckExclusionTable()
{ 
	UINT iResult = ERROR_SUCCESS;

	// database can exclude the module
	if (!MsiDBUtils::TableExistsW(g_wzModuleSignatureTable, m_hModule))
		return ERROR_SUCCESS;	// no signature table no merge modules in yet

	// if there is a ModuleExclusion Table then there may be exclusions
	if (MsiDBUtils::TableExistsW(g_wzModuleExclusionTable, m_hDatabase))
	{
		try 
		{
			// get module's signature
			PMSIHANDLE hRecModule;
			CQuery queryModule;
			CheckError(queryModule.OpenExecute(m_hModule, NULL, g_sqlExclusion[0]), 
						  L">> Error: Failed to get Merge Module's signature.\r\n");

			while (ERROR_SUCCESS == queryModule.Fetch(&hRecModule))
			{
				if (ERROR_FUNCTION_FAILED == MsiDBUtils::CheckExclusion(hRecModule, m_hDatabase))
				{
					// set that we have errors
					iResult = ERROR_FUNCTION_FAILED;			

					// create a new error item and add it to the error list
					if (m_pErrors)
					{
						CMsmError *pErr = new CMsmError(msmErrorExclusion, NULL, -1);
						m_pErrors->Add(pErr);	
			
						// add the excluded module 
						WCHAR szID[256];
						DWORD cchID = 256;
						CheckError(::MsiRecordGetStringW(hRecModule, 1, szID, &cchID), 
									  L">> Error: .");	
						pErr->AddModuleError(szID);								// add the conflicting moduleID
						cchID = 256;
						CheckError(::MsiRecordGetStringW(hRecModule, 2, szID, &cchID), 
									  L">> Error: .");	
						pErr->AddModuleError(szID);								// add the language
						cchID = 256;
						CheckError(::MsiRecordGetStringW(hRecModule, 3, szID, &cchID), 
									  L">> Error: .");	
						pErr->AddModuleError(szID);								// add the version
					}
				}
			} 
		}
		catch (CLocalError errLocal)
		{
			errLocal.Log(m_hFileLog);	// log the error
			iResult = errLocal.GetError();
		}
	}

	////
	// module can also exclude one or more things in the database
	if (!MsiDBUtils::TableExistsW(g_wzModuleSignatureTable, m_hDatabase))
		return ERROR_SUCCESS;	// no signature table no merge modules in yet

	// if there is a ModuleExclusion Table then there may be exclusions
	if (MsiDBUtils::TableExistsW(g_wzModuleExclusionTable, m_hModule))
	{
		try {
			// get each signature from the database
			PMSIHANDLE hRecSignature;
			CQuery queryDatabase;
			CheckError(queryDatabase.OpenExecute(m_hDatabase, NULL, g_sqlExclusion[0]), 
						  L">> Error: Failed to get signatures from database.\r\n");

			while (ERROR_SUCCESS == queryDatabase.Fetch(&hRecSignature))
			{
				if (ERROR_FUNCTION_FAILED == MsiDBUtils::CheckExclusion(hRecSignature, m_hModule))
				{
					// set that we have errors
					iResult = ERROR_FUNCTION_FAILED;			

					// create a new error item and add it to the error list
					if (m_pErrors)
					{
						CMsmError *pErr = new CMsmError(msmErrorExclusion, NULL, -1);
						if (!pErr) return E_OUTOFMEMORY;
						m_pErrors->Add(pErr);	
				
						// get the name of the row merging
						WCHAR szID[256];
						DWORD cchID = 256;
						CheckError(::MsiRecordGetStringW(hRecSignature, 1, szID, &cchID), 
									  L">> Error: .");	
						pErr->AddDatabaseError(szID);								// add the conflicting moduleID
						cchID = 256;
						CheckError(::MsiRecordGetStringW(hRecSignature, 2, szID, &cchID), 
									  L">> Error: .");	
						pErr->AddDatabaseError(szID);								// add the language
						cchID = 256;
						CheckError(::MsiRecordGetStringW(hRecSignature, 3, szID, &cchID), 
									  L">> Error: .");	
						pErr->AddDatabaseError(szID);								// add the version			
					}
				}
			}
		}
		catch (CLocalError errLocal)
		{
			errLocal.Log(m_hFileLog);	// log the error
			iResult = errLocal.GetError();
		}
	}

	return iResult;
}	// end of CheckExclusionTable

///////////////////////////////////////////////////////////
// CheckDependencies
// Pre:	module handle is open
// Pos:	dependency enumerator filled
UINT CMsmMerge::CheckDependencies()
{
	UINT iResult = ERROR_SUCCESS;	// assume everything will be okay

	// if there are any old dependencies release them
	if (m_pDependencies)
	{
		m_pDependencies->Release();
		m_pDependencies = NULL;
	}

	// create a new empty dependency enumerator
	m_pDependencies = new CMsmDependencies;
	if (!m_pDependencies) return E_OUTOFMEMORY;

	// if there is no ModuleDependency Table then there can be no dependencies
	// and if there is no ModuleSignature Table then there can be no dependencies
	if (MsiDBUtils::TableExistsW(g_wzModuleDependencyTable, m_hDatabase) &&
		 MsiDBUtils::TableExistsW(g_wzModuleSignatureTable, m_hDatabase))
	{
		try
		{
			// do check of M&M Dependency table
			CQuery queryDependency;
			CheckError(queryDependency.OpenExecute(m_hDatabase, NULL, g_sqlDependency[0]), 
						  L">> Error: Failed to open view on Database's ModuleDependency Table.\r\n");

			// variables to get data from dependency record
			WCHAR szReqID[256];
			short nReqLanguage;
			WCHAR szReqVersion[256];
			DWORD cchReqID = 256;
			DWORD cchReqVersion = 256;

			// loop through dependencies
			PMSIHANDLE hRecDependency;
			while (ERROR_SUCCESS == queryDependency.Fetch(&hRecDependency))
			{
				// if we found no fullfilling dependency
				if (ERROR_SUCCESS != MsiDBUtils::CheckDependency(hRecDependency, m_hDatabase))
				{
					// get the required id, version and language
					cchReqID = 256;
					cchReqVersion = 256;
					::MsiRecordGetStringW(hRecDependency, 1, szReqID, &cchReqID);
					nReqLanguage = static_cast<short>(::MsiRecordGetInteger(hRecDependency, 2));
					::MsiRecordGetStringW(hRecDependency, 3, szReqVersion, &cchReqVersion);

					// means there is a dependency
					CMsmDependency* pDependency = new CMsmDependency(szReqID, nReqLanguage, szReqVersion);
					if (!pDependency) return E_OUTOFMEMORY;
					m_pDependencies->Add(pDependency);
				}
			}
		}
		catch (CLocalError errLocal)
		{
			errLocal.Log(m_hFileLog);	// log the error
			iResult = errLocal.GetError();
		}
	}
	// else no dependency table no problem

	return iResult;
}	// end of CheckDependencies
	
///////////////////////////////////////////////////////////
// ModuleLanguage
// Pre:	module is open
// Pos:	returns language from module
UINT CMsmMerge::ModuleLanguage(short& rnLanguage)
{
	UINT iResult = ERROR_SUCCESS;		// assume everything will be okay

	// try to get the module language
	try
	{
		CQuery queryModule;
		CheckError(queryModule.Open(m_hModule, TEXT("SELECT Language FROM %ls"), g_wzModuleSignatureTable), 
					  L">> Error: Failed to open view to get langauge of Merge Module's Table.\r\n");
		CheckError(queryModule.Execute(), 
					  L">> Error: Failed to execute view to get langauge of Merge Module's Table.\r\n");

		// get the record from the module with the language
		PMSIHANDLE hRecLang;
		CheckError(queryModule.Fetch(&hRecLang),
					  L">> Error: Failed to fetch Merge Module's language.");

		// get the language
		rnLanguage = static_cast<short>(::MsiRecordGetInteger(hRecLang, 1));

		// if we have a bad language
		if (MSI_NULL_INTEGER == rnLanguage)
		{
			iResult = ERROR_DATATYPE_MISMATCH;
			rnLanguage = 0;

			FormattedLog(L">> Error: Unknown language type in Merge Module.\r\n");
		}
	}
	catch (CLocalError errLocal)
	{
		errLocal.Log(m_hFileLog);	// log the error
		iResult = errLocal.GetError();
	}

	return iResult;
}	// end of ModuleLanguage

///////////////////////////////////////////////////////////
// ExecuteConnect
// Pre:	database is open
//			module is open
//			feature should exist in database
// Pos:	FeatureComponents Table updated
UINT CMsmMerge::ExecuteConnect(LPCWSTR wzFeature)
{
	// if the FeatureComponents Table does not exist in the database create it
	if (!MsiDBUtils::TableExistsW(g_wzFeatureComponentsTable, m_hDatabase))
	{
		// try to create the table
		if (ERROR_SUCCESS != MsiDBUtils::CreateTableW(g_wzFeatureComponentsTable, m_hDatabase, m_hModule))
		{
			FormattedLog(L">> Error: Failed to create FeatureComponents table in Database.\r\n");
			return ERROR_FUNCTION_FAILED;
		}
	}

	UINT iResult = ERROR_SUCCESS;	// assume everything will be okay

	// try to do the connecting now
	try
	{
		FormattedLog(L"Connecting Merge Module Components to Feature: %ls\r\n", wzFeature);

		// create a record for feature and component (then put the feature in)
		PMSIHANDLE hRecFeatureComponent = ::MsiCreateRecord(2);
		::MsiRecordSetStringW(hRecFeatureComponent, 1, wzFeature);

		// open and execute a view to get all module components
		CQuery queryModule;
		CheckError(queryModule.OpenExecute(m_hModule, 0, g_sqlExecuteConnect[0]), 
					  L">> Error: Failed to connect Merge Module to Feature.\r\n");

		// open the view on the database to insert rows
		CQuery queryDatabase;
		CheckError(queryDatabase.Open(m_hDatabase, g_sqlExecuteConnect[1]), 
					  L">> Error: Failed to connect Merge Module to Feature.\r\n");

		// string to hold component name
		WCHAR *wzComponent = new WCHAR[72];
		if (!wzComponent)
			return E_OUTOFMEMORY;
		DWORD cchComponent = 72;

		// loop through all the records to insert
		PMSIHANDLE hRecComponent;
		UINT iStat;
		while (ERROR_SUCCESS == (iStat = queryModule.Fetch(&hRecComponent)))
		{
			// get the component name string
			CheckError(RecordGetString(hRecComponent, 1, &wzComponent, &cchComponent), 
						  L">> Error: Failed to fully connect Merge Module to Feature.\r\n");

			// log progress
			FormattedLog(L"   o Connecting Component: %ls\r\n", wzComponent);

			// throw error if no feature
			if (!wzFeature || !wcslen(wzFeature))
			{

				FormattedLog(L">> Error: Failed to connect component %s. Feature required.\r\n", wzComponent);
				if (m_pErrors)
				{
					CMsmError *pErr = new CMsmError(msmErrorFeatureRequired, NULL, -1);
					if (!pErr) 
					{
						delete[] wzComponent;
						return E_OUTOFMEMORY;
					}
					m_pErrors->Add(pErr);
					pErr->SetModuleTable(L"Component");
					pErr->AddModuleError(wzComponent);
				}
				continue;
			}

			// put the component string in the record
			::MsiRecordSetStringW(hRecFeatureComponent, 2, wzComponent);

			// try to execute the insert
			iStat = queryDatabase.Execute(hRecFeatureComponent);
			if (ERROR_SUCCESS == iStat)
				continue;
			else if (ERROR_FUNCTION_FAILED == iStat)
			{
				// check to see if there error just means the data already exists
				PMSIHANDLE hRecError = ::MsiGetLastErrorRecord();

				// if there is an error
				if (hRecError)
				{
					// get the error code
					UINT iFeatureComponentsError = ::MsiRecordGetInteger(hRecError, 1);

					// if the error code says row already exists print a warning and go on with life
					if (2259 == iFeatureComponentsError)	// !! use the error code here: imsgDbUpdateFailed
						FormattedLog(L"> Warning: Feature: %ls and Component: %ls are already connected together.\r\n", wzFeature, wzComponent);
					else	// some serious error happened
					{
						// log the error
						FormattedLog(L">> Error: #%d, Failed to connect Component: %ls to Feature: %ls.\r\n", iFeatureComponentsError, wzComponent, wzFeature);

						// create a new error item and add it to the list
						if (m_pErrors)
						{
							CMsmError *pErr = new CMsmError(msmErrorTableMerge, NULL, -1);
							if (!pErr) 
							{
								delete[] wzComponent;
								return E_OUTOFMEMORY;
							}
							m_pErrors->Add(pErr);

							pErr->SetDatabaseTable(L"FeatureComponents");
							pErr->AddDatabaseError(wzFeature);
							pErr->AddDatabaseError(wzComponent);
						}
					}
				}
			} 
			else 
			{
				delete[] wzComponent;
				return ERROR_FUNCTION_FAILED;
			}
		}
		delete[] wzComponent;
		if (ERROR_NO_MORE_ITEMS != iStat)
			return ERROR_FUNCTION_FAILED;
	}
	catch (CLocalError errLocal)
	{
		errLocal.Log(m_hFileLog);	// log the error
		iResult = errLocal.GetError();
	}

	// return result
	return iResult;
}	// end of ExecuteConnect

///////////////////////////////////////////////////////////
// ExecuteMerge
// Pre:	database handle is open
//			module handle is open
// Pos:	module contents are merged with database contents
UINT CMsmMerge::ExecuteMerge(LPCWSTR wzFeature, LPCWSTR wzRedirectDir)
{
	// create the internal table for storing configuration results from the authoring tool.
	// The lifetime of this object is the lifetime of the table
	CQuery qConfigData;
	if (m_fModuleConfigurationEnabled)
	{
		if (ERROR_SUCCESS != PrepareModuleSubstitution(qConfigData))
		{
			FormattedLog(L">> Error: Could not prepare module for configuration.\r\n");
			
			// clean up any potentially stale configuration state
			CleanUpModuleSubstitutionState();

			return ERROR_FUNCTION_FAILED;
		}
	}
		
	// try to do the merge signature first
	try
	{
		// merge the merge signature
		CheckError(MergeTable(wzFeature, g_wzModuleSignatureTable),
						L">> Error: Failed to merge Module Signature.\r\n");
	}
	catch (CLocalError err)
	{
		// get the error type
		UINT iError = err.GetError();

		// if there was just a merge conflict
		if (ERROR_MERGE_CONFLICT == iError)
		{
			// log a nice message
			FormattedLog(L">> Error: Failed to merge Merge Module due to a conflicting Merge Module.\r\n");
		}
		else
		{
			// log a not-so-nice message
			FormattedLog(L">> Error: Failed to merge Merge Module.\r\n");
		}

		// clean up any potentially stale configuration state
		CleanUpModuleSubstitutionState();

		return ERROR_FUNCTION_FAILED;	// bail
	};

	UINT iResult = ERROR_SUCCESS;	// assume everything will be okay

	// try to do the merging now
	try
	{
		// Prepare
		CQuery qIgnore;
		if (!PrepareIgnoreTable(qIgnore))
		{
			// clean up any potentially stale configuration state
			CleanUpModuleSubstitutionState();
			return ERROR_FUNCTION_FAILED;
		}
		
		// merge and redirect the directory table as needed
		CSeqActList lstDirActions;
		if (!IgnoreTable(&qIgnore, g_wzDirectoryTable, true))
		{
			iResult = MergeDirectoryTable(wzRedirectDir, lstDirActions);
			if (ERROR_SUCCESS != iResult)
			{
				// clean up any potentially stale configuration state
				CleanUpModuleSubstitutionState();
				return iResult;
			}
		}

		// merge sequence tables
		for (int i=stnFirst; i < stnNext; i++)
			MergeSequenceTable(static_cast<stnSequenceTableNum>(i), lstDirActions, &qIgnore);
			
		// merge and resequence file table as needed.
		if (!IgnoreTable(&qIgnore, g_wzFileTable, true))
		{
			iResult = MergeFileTable(wzFeature);
			if (ERROR_SUCCESS != iResult)
			{
				// clean up any potentially stale configuration state
				CleanUpModuleSubstitutionState();
				return iResult;
			}

		}

		// string to hold table name
		WCHAR *wzTable = NULL;
		DWORD cchTable = 0;

		// get the tables in the Merge Module
		CQuery queryGet;
		CheckError(queryGet.Open(m_hModule,  g_sqlExecuteMerge), 
					  L">> Error: Failed to open view on Merge Module's Tables.\r\n");

		// execute the view
		CheckError(queryGet.Execute(), 
					  L">> Error: Failed to execute to get Merge Module's Tables.\r\n");

		// start fetching
		PMSIHANDLE hRecModuleTable;
		UINT iStat;
		while (ERROR_SUCCESS == (iStat = queryGet.Fetch(&hRecModuleTable)))
		{
			// get the table name from the record
			CheckError(RecordGetString(hRecModuleTable, 1, &wzTable, &cchTable),
				L">> Error: Failed to get Merge Module's tables.\r\n");
			
			// query the ignore table
			if (IgnoreTable(&qIgnore, wzTable))
				continue;

			// ignore any table that is temporary
			if (MSICONDITION_TRUE != ::MsiDatabaseIsTablePersistentW(m_hModule, wzTable))
			{
				FormattedLog(L"Ignoring temporary table: %ls.\r\n", wzTable);
				continue;
			}

			if (ERROR_SUCCESS != (iStat = MergeTable(wzFeature, wzTable)))
			{
				// Only abort the merge if it was a fatal configuration or API error,
				// not if it was just a merge conflict.
				if (ERROR_MERGE_CONFLICT == iStat)
					continue;
				iResult = iStat;
				break;
			}
		}
		if (ERROR_NO_MORE_ITEMS != iStat)
		{
			iResult = ERROR_FUNCTION_FAILED;
			FormattedLog(L">> Error: Failed to fetch tables from Merge Module.\r\n");
		};

		// delete the table name buffer
		delete[] wzTable;
		wzTable = NULL;

		// finally, delete any keys that were orphaned by the configuration of this module
		if ((iResult == ERROR_SUCCESS) && m_fModuleConfigurationEnabled)
		{
			if (ERROR_SUCCESS != (iResult = DeleteOrphanedConfigKeys(lstDirActions)))
			{
				FormattedLog(L">> Error: Failed to delete orphaned keys.\r\n");
				// clean up any potentially stale configuration state
				CleanUpModuleSubstitutionState();
				return iResult;
			}

		}
	}
	catch (CLocalError errLocal)
	{
		errLocal.Log(m_hFileLog);	// log the error
		iResult = errLocal.GetError();
	}
	catch (UINT ui)
	{
		// clean up any potentially stale configuration state
		CleanUpModuleSubstitutionState();

		// re-throw the UINT. Fatal errors must be caught further up the chain or they will be treated as
		// recoverable errors and translated.
		throw ui;
	}

	// clean up any potentially stale configuration state
	CleanUpModuleSubstitutionState();

	return iResult;
}	// end of ExecuteMerge

///////////////////////////////////////////////////////////////////////
// Generates a CQuery for querying from the module and inserting into 
// the database in the correct column order. The query may contain a 
// combination of columns from the module and literal constant NULL 
// values. May add columns to the database if the schema allows it, 
// so database insertion queries should be generated after this 
// function is called.
DWORD CMsmMerge::GenerateModuleQueryForMerge(const WCHAR* wzTable, const WCHAR* wzExtraColumns, const WCHAR* wzWhereClause, CQuery& queryModule) const
{
	// open initial queries
	CQuery queryDatabase;
	CheckError(queryModule.OpenExecute(m_hModule, NULL, TEXT("SELECT * FROM `%ls`"), wzTable), 
				  L">> Error: Failed to get rows from Merge Module's Table.\r\n");
	CheckError(queryDatabase.OpenExecute(m_hDatabase, NULL, TEXT("SELECT * FROM `%ls`"), wzTable), 
				  L">> Error: Failed to get rows from Database's Table.\r\n");

	// grab column information from the database and module to set up query. The order
	// of columns in the database may not be the same as in the module
	PMSIHANDLE hDatabaseColumnTypes;
	PMSIHANDLE hModuleColumnNames;
	if (ERROR_SUCCESS != queryModule.GetColumnInfo(MSICOLINFO_NAMES, &hModuleColumnNames))
		return ERROR_FUNCTION_FAILED;

	PMSIHANDLE hTypeRec;
	if (ERROR_SUCCESS != queryModule.GetColumnInfo(MSICOLINFO_TYPES, &hTypeRec))
		return ERROR_FUNCTION_FAILED;

	// determine how many columns there are in the database table
	if (ERROR_SUCCESS != queryDatabase.GetColumnInfo(MSICOLINFO_TYPES, &hDatabaseColumnTypes))
		return ERROR_FUNCTION_FAILED;

	int iDBColumns = MsiRecordGetFieldCount(hDatabaseColumnTypes);
	int iModuleColumns = MsiRecordGetFieldCount(hModuleColumnNames);

	// determine the primary key count for both database and module. The primary keys must
	// be equal in number, type, and order.
	PMSIHANDLE hKeyRec;
	if (ERROR_SUCCESS != MsiDatabaseGetPrimaryKeysW(m_hDatabase, wzTable, &hKeyRec))
		return ERROR_FUNCTION_FAILED;
	int cDBKeyColumns = MsiRecordGetFieldCount(hKeyRec);
	if (ERROR_SUCCESS != MsiDatabaseGetPrimaryKeysW(m_hModule, wzTable, &hKeyRec))
		return ERROR_FUNCTION_FAILED;
	int cModuleKeyColumns = MsiRecordGetFieldCount(hKeyRec);

	// check for an equal number of primary keys
	if (cDBKeyColumns != cModuleKeyColumns)
	{
		FormattedLog(L">> Error: Could not merge the %ls table because the tables have different numbers of primary keys.\r\n", wzTable);
		return ERROR_FUNCTION_FAILED;
	}

	// check every column in the module. Every column must exist somewhere in the database,
	// although the database can have extra columns if they are nullable.
	PMSIHANDLE hDBColumnRec = MsiCreateRecord(31);
	DWORD dwColumnBits = 0xFFFFFFFF;

	DWORD cchName = 72;
	WCHAR* wzName = NULL;
	PMSIHANDLE hResRec;
	int iTotalDBColumns = iDBColumns;
	int cchColumnQueryLength = 0;
	for (int iColumn=1; iColumn <= iModuleColumns; iColumn++)
	{
		// retrieve the column name for cross-reference with the database
		if (ERROR_SUCCESS != RecordGetString(hModuleColumnNames, iColumn, &wzName, &cchName))
		{
			if (wzName)
				delete[] wzName;
			return ERROR_FUNCTION_FAILED;
		}

		// determine the type of the column
		WCHAR wzType[4];
		DWORD cchType = 4;
		::MsiRecordGetString(hTypeRec, iColumn, wzType, &cchType);

		int iDatabaseColumn = 0;
		DWORD dwResult = GetColumnNumber(m_hDatabase, wzTable, wzName, iDatabaseColumn);
		if (dwResult == ERROR_FUNCTION_FAILED)
		{
			// if it is not in the module either, its a temporary column, if it is in
			// the module, its an unknown column
			int iModuleColumn = 0;
			if (ERROR_SUCCESS == GetColumnNumber(m_hModule, wzTable, wzName, iModuleColumn))
			{
				// if the column is a primary key in the module, the schema conflict is fatal, can't add primary keys
				if (iModuleColumn < cModuleKeyColumns)
				{
					FormattedLog(L">> Error: Could not merge the %ls table because the primary keys of the tables are not the same.\r\n", wzTable);
					delete[] wzName;
					return ERROR_FUNCTION_FAILED;
				}

				// if the column is nullable, it is safe to add it to the database
				if (iswupper(wzType[0]))
				{
					DWORD cchBuffer = 100;
					LPWSTR wzBuffer = new WCHAR[cchBuffer];
					if (!wzBuffer)
					{
						delete[] wzName;
						return ERROR_OUTOFMEMORY;
					}

					// translate the column type into SQL syntax to create an equivalent type in the new database.
					dwResult = MsiDBUtils::GetColumnCreationSQLSyntaxW(hModuleColumnNames, hTypeRec, iColumn, wzBuffer, &cchBuffer);
					if (ERROR_MORE_DATA == dwResult)
					{
						delete[] wzBuffer;
						wzBuffer = new WCHAR[cchBuffer];
						if (!wzBuffer)
						{
							delete[] wzName;
							return ERROR_OUTOFMEMORY;
						}
						dwResult = MsiDBUtils::GetColumnCreationSQLSyntaxW(hModuleColumnNames, hTypeRec, iColumn, wzBuffer, &cchBuffer);
					}
					if (ERROR_SUCCESS != dwResult)
					{
						if (wzBuffer)
							delete[] wzBuffer;
						delete[] wzName;
						return ERROR_FUNCTION_FAILED;
					}
	
					CQuery qColumnAdd;
					dwResult = qColumnAdd.OpenExecute(m_hDatabase, 0, L"ALTER TABLE `%ls` ADD %ls", wzTable, wzBuffer);
					delete[] wzBuffer;
					if (ERROR_SUCCESS != dwResult)
					{
						FormattedLog(L">> Error: Could not add the %ls column to the %ls table of the database.\r\n", wzName, wzTable);
						delete[] wzName;
						return ERROR_FUNCTION_FAILED;
					}
	
					// increment the number of columns in the target table
					iTotalDBColumns++;

					// column has been added. Retrieve the new column number
					dwResult = GetColumnNumber(m_hDatabase, wzTable, wzName, iDatabaseColumn);
					if (dwResult == ERROR_FUNCTION_FAILED)
					{
						delete[] wzName;
						return ERROR_FUNCTION_FAILED;
					}
				}
				else
				{
					FormattedLog(L">> Error: The %ls column in the %ls table does not exist in the database but cannot be added since it is not nullable.\r\n", wzName, wzTable);
					delete[] wzName;
					return ERROR_FUNCTION_FAILED;
				}
			}
			else
			{
				dwResult = ERROR_SUCCESS;
				continue;
			}
		}
		else
		{
			// if the column is a primary key in the module or the database but not both, the schema 
			// conflict is fatal.
			if ((iColumn < cModuleKeyColumns && !(iDatabaseColumn < cDBKeyColumns)) ||
				(!(iColumn < cModuleKeyColumns) && iDatabaseColumn < cDBKeyColumns))
			{
				FormattedLog(L">> Error: Could not merge the %ls table because the primary keys of the tables are not the same.\r\n", wzTable);
				delete[] wzName;
				return ERROR_FUNCTION_FAILED;
			}

			// the column is a primary key in both or neither. If both, the column numbers must be the
			// same. Reordering of primary keys is not allowed due to the complexity associated with 
			// CMSM substitution references (which are identified by delimited key strings)
			// if the column is a primary key in the module, the schema conflict is fatal, can't add primary keys
			if ((iDatabaseColumn < cDBKeyColumns) && (iDatabaseColumn != iColumn))
			{
				FormattedLog(L">> Error: Could not merge the %ls table because the primary keys of the tables have different orders.\r\n", wzTable);
				delete[] wzName;
				return ERROR_FUNCTION_FAILED;
			}

			// column exists in both database and module. Verify that the types are compatible
			// nullable/non-nullable will be checked at insertion time. Just check integer/string/binary
			// and primary-key. Can't check size because some versions of the MSI schema differ by size. 
			WCHAR wzDatabaseType[4];
			DWORD cchDatabaseType = 4;
			::MsiRecordGetString(hDatabaseColumnTypes, iDatabaseColumn, wzDatabaseType, &cchDatabaseType);

			eColumnType ectDatabase = ColumnTypeCharToEnum(wzDatabaseType[0]);
			eColumnType ectModule = ColumnTypeCharToEnum(wzType[0]);
			if (ectDatabase != ectModule)
			{
				FormattedLog(L">> Error: The %ls table can not be merged because the %ls column has conflicting data types.\r\n", wzTable, wzName);
				delete[] wzName;
				return ERROR_FUNCTION_FAILED;
			}
		}


		MsiRecordSetStringW(hDBColumnRec, iDatabaseColumn, wzName);
		dwColumnBits &= ~(1 << iDatabaseColumn);
		cchColumnQueryLength += wcslen(wzName) + 3; // add 3 for ticks and comma
	}

	// ensure all unmatched columns in the database are nullable. If a
	// column is not nullable, the schemas are incompatible.
	for (int iColumn=1; iColumn <= iDBColumns; iColumn++)
	{
		if (dwColumnBits & (1 << iColumn))
		{
			// if the column is a primary key in the module, the schema conflict is fatal, can't add primary keys
			if (iColumn < cDBKeyColumns)
			{
				FormattedLog(L">> Error: Could not merge the %ls table because the primary keys of the tables are not the same.\r\n", wzTable);
				return ERROR_FUNCTION_FAILED;
			}

			DWORD cchType = 5;
			WCHAR wzType[5];
			if (ERROR_SUCCESS != MsiRecordGetString(hDatabaseColumnTypes, iColumn, wzType, &cchType))
			{
				if (wzName)
					delete[] wzName;
				return ERROR_FUNCTION_FAILED;
			}

			// verify that the column is nullable. Nullable columns have uppercase type specifiers.
			// They are always ASCII chars, so iswupper works fine.
			if (!iswupper(wzName[0]))
			{
				FormattedLog(L">> Error: One or more columns in the %s table does not exist in the module and is not nullable.\r\n", wzTable);
				if (wzName)
					delete[] wzName;
				wzName = NULL;
				return ERROR_FUNCTION_FAILED;
			}
			cchColumnQueryLength += 3; // add 3 for '',
		}
	}
	delete[] wzName;
	wzName = NULL;

	queryModule.Close();


	// format the column list record to substitute the column names into the query string.
	// the resulting query could be over 2K in length if all columns use really long names.
	WCHAR* wzQuery = new WCHAR[cchColumnQueryLength+1];
	if (!wzQuery)
		return E_OUTOFMEMORY;
	WCHAR *wzCurQueryPos = wzQuery;
	for (iColumn=1; iColumn <= iTotalDBColumns; iColumn++)
	{
		if (MsiRecordIsNull(hDBColumnRec, iColumn))
		{
			wcscpy(wzCurQueryPos, L"'',");
			wzCurQueryPos += 3;
		}
		else
		{
			*(wzCurQueryPos++) = L'`';

			DWORD cchTemp = static_cast<DWORD>(cchColumnQueryLength - (wzCurQueryPos-wzQuery));
			if (ERROR_SUCCESS != MsiRecordGetString(hDBColumnRec, iColumn, wzCurQueryPos, &cchTemp))
			{
				delete[] wzQuery;
				return ERROR_FUNCTION_FAILED;
			}
			wzCurQueryPos += cchTemp;

			*(wzCurQueryPos++) = L'`';
			*(wzCurQueryPos++) = L',';
		}
	}
	// string includes trailing comma, so terminate one char earlier to remove it.
	*(--wzCurQueryPos) = 0;

	// open the query to fetch values from the module table in the correct order.
	UINT iResult = queryModule.OpenExecute(m_hModule, 0, L"SELECT %ls%ls FROM %ls%ls", wzQuery, wzExtraColumns ? wzExtraColumns : L"", wzTable, wzWhereClause ? wzWhereClause : L"");
	delete[] wzQuery;
	wzQuery = NULL;
	if (ERROR_SUCCESS != iResult)
		return ERROR_FUNCTION_FAILED;


	// load type information for the correctly ordered fetch row
	if (ERROR_SUCCESS != queryModule.GetColumnInfo(MSICOLINFO_TYPES, &hTypeRec))
		return ERROR_FUNCTION_FAILED;

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////
// MergeTable
// Pre:	database handle is open
//			module handle is open
// Pos:	module contents are merged with database contents
UINT CMsmMerge::MergeTable(LPCWSTR wzFeature, LPCWSTR wzTable)
{
	// general result variable
	UINT iResult = ERROR_SUCCESS;		// assume everything will be okay

	// show some log information
	FormattedLog(L"Merging Table: %ls\r\n", wzTable);

	// create the temporary modulesubstitution table
	int cPrimaryKeys = 0;
	CQuery qQuerySub;
	if (m_fModuleConfigurationEnabled)
	{
		if (ERROR_SUCCESS != (iResult = PrepareTableForSubstitution(wzTable, cPrimaryKeys, qQuerySub)))
		{
			FormattedLog(L">> Error: Could not configure the %ls table.\r\n", wzTable);
			return iResult;
		}
	}
	
	// if table does not exist in the database create it
	if (!MsiDBUtils::TableExistsW(wzTable, m_hDatabase))
	{
		if (ERROR_SUCCESS != MsiDBUtils::CreateTableW(wzTable, m_hDatabase, m_hModule))
		{
			FormattedLog(L">> Error: Could not create the %ls table in the database.\r\n", wzTable);
			return ERROR_FUNCTION_FAILED;
		}
	}

	// create queries for merging tables.
	CQuery queryDatabase;
	CQuery queryModule;

	// generate a module query in the appropriate column order for insertion into the database 
	// (the database order may be different from the module order.) Function logs its own failure
	// cases. Immediately fatal error.
	if (ERROR_SUCCESS != (iResult = GenerateModuleQueryForMerge(wzTable, NULL, NULL, queryModule)))
	{
		throw (UINT)E_FAIL;
		return iResult;
	}

	// generating the module query may add more columns to the database, so open the database query 
	// AFTER the module query is generated
	CheckError(queryDatabase.OpenExecute(m_hDatabase, NULL, TEXT("SELECT * FROM `%ls`"), wzTable), 
			  L">> Error: Failed to get rows from Database's Table.\r\n");

	PMSIHANDLE hDatabaseColumnTypes;
	if (ERROR_SUCCESS != queryDatabase.GetColumnInfo(MSICOLINFO_TYPES, &hDatabaseColumnTypes))
	{
		FormattedLog(L">> Error: Could not determine column types for %ls table.\r\n", wzTable);
		return ERROR_FUNCTION_FAILED;
	}

	// loop over all rows, reading from the module in the order of insertion into the database,
	// performing substitution on each row as necessary
	WCHAR *wzRow = NULL;
	DWORD cchRow = 0;
	PMSIHANDLE hRecMergeRow;
	while (ERROR_SUCCESS == queryModule.Fetch(&hRecMergeRow))
	{
		// get the name of the row merging
		CheckError(RecordGetString(hRecMergeRow, 1, &wzRow, &cchRow),
					  L">> Error: Failed to get the name of the row while merging.\r\n");

		// log info
		FormattedLog(L"   o Merging row: %ls\r\n", wzRow);

		// try to merge the row into the database
		try
		{
			// check the module substitution table for substitutions
			if (m_fModuleConfigurationEnabled)
			{
				// use the database type record to ensure that every target column has a valid type.
				// even if it doesn't exist in the module
				if (ERROR_SUCCESS != PerformModuleSubstitutionOnRec(wzTable, cPrimaryKeys, qQuerySub, hDatabaseColumnTypes, hRecMergeRow))
				{
					FormattedLog(L">> Error: Could not configure this %ls table record.\r\n", wzTable);
					
					// this is not the ideal way to handle this situation, but returning failure is not
					// enough to trigger an E_FAIL return code. in the future, pass the error
					// back up cleanly.
					throw (UINT)E_FAIL;
					break;
				}
			}
		
			// do the replacement of feature string (if it is found)
			ReplaceFeature(wzFeature, hRecMergeRow);

			// merge in the new row
			CheckError(queryDatabase.Modify(MSIMODIFY_MERGE, hRecMergeRow),
						  L">> Error: Failed to merge Merge Module into MSI Database.\r\n");
		}
		catch (CLocalError err)
		{
			// if merge failed log it as one of many
			if ((ERROR_FUNCTION_FAILED == err.GetError()) ||
				(ERROR_INVALID_PARAMETER == err.GetError()))
			{
				// show that there was at least one conflict
				iResult = ERROR_MERGE_CONFLICT;

				// create a new error item and add it to the error list
				if (m_pErrors)
				{
					CMsmError *pErr = NULL;
					if (ERROR_FUNCTION_FAILED == err.GetError())
					{
						FormattedLog(L">> Error: Failed to merge Row: %ls into Table: %ls\r\n", wzRow, wzTable);
						pErr = new CMsmError(msmErrorTableMerge, NULL, -1);
					}
					else
					{
						FormattedLog(L">> Error: Failed to merge Row: %ls into Table: %ls. Feature required.\r\n", wzRow, wzTable);
						pErr = new CMsmError(msmErrorFeatureRequired, NULL, -1);
					}
					if (!pErr) return E_OUTOFMEMORY;
					m_pErrors->Add(pErr);

					pErr->SetDatabaseTable(wzTable);
					pErr->SetModuleTable(wzTable);

					// now get the primary keys
					PMSIHANDLE hRecPrimaryKeys;

					CheckError(::MsiDatabaseGetPrimaryKeysW(m_hModule, wzTable, &hRecPrimaryKeys),
								  L">> Error: Failed to get primary keys for Merge Module's Table.\r\n");

					// loop through primary key columns in table
					UINT cKeys = MsiRecordGetFieldCount(hRecPrimaryKeys);
					for (UINT i = 0; i < cKeys; i++)
					{
						// get the primary key data from the first columns (which are primary keys)
						// put it in the global temporary buffer
						CheckError(RecordGetString(hRecMergeRow, i + 1, NULL, NULL),
									  L">> Error: Failed to get a primary key for Merge Module's Table.\r\n");

						// add the key to the error strings
						pErr->AddDatabaseError(m_wzBuffer);
						pErr->AddModuleError(m_wzBuffer);
					}
				}
			}
			else	// unhandled error throw again
			{
				delete[] wzRow;
				throw;
			};
		}
	}

	// clean up temp buffer
	delete[] wzRow;

	return iResult;
}	// end of MergeTable

///////////////////////////////////////////////////////////
// MergeFileTable
// Pre:	database handle is open
//			module handle is open
// Pos:	module file table is added and file sequence numbers are correct
UINT CMsmMerge::MergeFileTable(LPCWSTR wzFeature)
{
	// general result variable
	UINT iResult = ERROR_SUCCESS;

	if (!MsiDBUtils::TableExistsW(g_wzFileTable, m_hModule))
		return ERROR_SUCCESS;

	// if module configuration is enabled, we'll need to do file table
	// configuration as we go along.
	CQuery qQuerySub;
	int cPrimaryKeys = 1;
	if (m_fModuleConfigurationEnabled)
	{
		if (ERROR_SUCCESS != (iResult = PrepareTableForSubstitution(L"File", cPrimaryKeys, qQuerySub)))
		{
			FormattedLog(L">> Error: Could not configure the File table.\r\n");
			return iResult;
		}
	}

	// clear out the list of merged files
	if (m_plstMergedFiles)
		m_plstMergedFiles->Release();
	m_plstMergedFiles = new CMsmStrings;
	if (!m_plstMergedFiles)
		return E_OUTOFMEMORY;
	
	// keeps track of highest file sequence in this module
	unsigned long lModuleHighestFileSequence = 0;

	// show some log information
	FormattedLog(L"Merging Table: File\r\n");

	// if file table does not exist in the database create it
	if (!MsiDBUtils::TableExistsW(L"File", m_hDatabase))
	{
		// try to create the table
		try
		{
			MsiDBUtils::CreateTableW(L"File", m_hDatabase, m_hModule);
		}
		catch(CLocalError err)
		{
			// log the error
			err.Log(m_hFileLog);

			return ERROR_FUNCTION_FAILED;
		}
	}

	UINT iSequence;	// used to resequence files

	// table now exists so attempt to merge tables together
	CQuery queryModule;
	CQuery queryDatabase;
	if (ERROR_SUCCESS != GenerateModuleQueryForMerge(L"File", NULL, NULL, queryModule))
	{
		FormattedLog(L">> Failed to generate merge query for File table.\r\n");
		// fatar error
		throw (UINT)E_FAIL;
		return ERROR_FUNCTION_FAILED;
	}

	// generating module query may add columns to the database, so generate DB query AFTER
	// the module query
	CheckError(queryDatabase.OpenExecute(m_hDatabase, NULL, L"SELECT * FROM `File`"), 
			  L">> Error: Failed to get rows from Database's File Table.\r\n");

	// grab table data for any potential configuration of the file table. Must use the actual
	// module query because the column orders are selected in a different order.
	PMSIHANDLE hTypeRec;
	if (m_fModuleConfigurationEnabled)
	{
		if (ERROR_SUCCESS != queryModule.GetColumnInfo(MSICOLINFO_TYPES, &hTypeRec))
		{
			FormattedLog(L">> Failed to retrieve column types from File table.\r\n");
			return ERROR_FUNCTION_FAILED;
		}
	}

	// loop through all records in table merging
	WCHAR * wzFileRow = NULL;
	DWORD cchFileRow = 0;
	PMSIHANDLE hRecMergeRow;

	int iColumnSequence = 0;
	int iColumnFile = 0;
	if ((ERROR_SUCCESS != GetColumnNumber(m_hDatabase, L"File", L"Sequence", iColumnSequence)) || 
		(ERROR_SUCCESS != GetColumnNumber(m_hDatabase, L"File", L"File", iColumnFile)))
	{
		FormattedLog(L">> Failed to retrieve column number from File table.\r\n");
		return ERROR_FUNCTION_FAILED;
	}

	while (ERROR_SUCCESS == queryModule.Fetch(&hRecMergeRow))
	{
		// get the name of the row merging
		CheckError(RecordGetString(hRecMergeRow, iColumnFile, &wzFileRow, &cchFileRow), 
					  L">> Error: Failed to get the name of the row while merging.");

		// log info
		FormattedLog(L"   o Merging row: %ls\r\n", wzFileRow);

		// get the sequence number of this record
		iSequence = ::MsiRecordGetInteger(hRecMergeRow, iColumnSequence);

		// check the module substitution table for substitutions
		if (m_fModuleConfigurationEnabled)
		{ 
			if (ERROR_SUCCESS != PerformModuleSubstitutionOnRec(L"File", cPrimaryKeys, qQuerySub, hTypeRec, hRecMergeRow))
			{
				FormattedLog(L">> Error: Could not configure this File table record.\r\n");

				// this is not the ideal way to handle this situation, but returning failure is not
				// enough to trigger an E_FAIL return code. in the future, pass the error
				// back up cleanly.
				throw (UINT)E_FAIL;
				break;
			}

			// configuration might have changed the primary keys. 
			if (ERROR_SUCCESS != RecordGetString(hRecMergeRow, iColumnFile, &wzFileRow, &cchFileRow))
			{
				FormattedLog(L">> Error: Failed to get the name of the row while merging.\r\n");
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}
		}

		if (m_lHighestFileSequence > 0)
		{
			FormattedLog(L"     * Changing %ls's Sequence Column from %d to %d.\r\n", wzFileRow, iSequence, iSequence + m_lHighestFileSequence); 

			// set in the new sequence plus the highest sequence number
			CheckError(::MsiRecordSetInteger(hRecMergeRow, iColumnSequence, iSequence + m_lHighestFileSequence),
						  L">> Error: Failed to set in new sequence number to MSI Database's File Table.\r\n");
		}

		// save the sequence number so that at the end of the merge we 
		// can set it as the new m_lHighestFileSequence
		if (iSequence > lModuleHighestFileSequence)
			lModuleHighestFileSequence = iSequence;

		// try to merge the row into the database
		if (ERROR_SUCCESS == (iResult = queryDatabase.Modify(MSIMODIFY_MERGE, hRecMergeRow)))
		{
			// if succeeded, add this primary key to the list of files
			m_plstMergedFiles->Add(wzFileRow);
		}
		else
		{
			// if merge failed log it as one of many
			if (ERROR_FUNCTION_FAILED == iResult)
			{
				// show that there was at least one conflict
				iResult = ERROR_MERGE_CONFLICT;

				// log error
				FormattedLog(L">> Error: Failed to merge Row: %ls into Table: File\r\n", wzFileRow);

				// create a new error item and add it to the error list
				if (m_pErrors)
				{
					CMsmError *pErr = new CMsmError(msmErrorTableMerge, NULL, -1);
					if (!pErr) {
						delete[] wzFileRow;
						return E_OUTOFMEMORY;
					}
					m_pErrors->Add(pErr);

					pErr->SetDatabaseTable(L"File");
					pErr->SetModuleTable(L"File");

					// now do the primary key (it's in the first field of the record)
					// place it into temp buffer
					CheckError(RecordGetString(hRecMergeRow, iColumnFile, NULL, NULL),
						L">> Error: Failed to get a primary key for Merge Module's File Table.\r\n");

					// add the key to the error strings
					pErr->AddDatabaseError(m_wzBuffer);
					pErr->AddModuleError(m_wzBuffer);
				}
			}
			else
			{
				FormattedLog(L">> Error: Failed to merge Merge Module into MSI Database.\r\n");
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}
		}
	}

	// clean up file row buffer
	delete[] wzFileRow;

	// successful merge, bump the highest file sequence up so we don't collide on the next module
	m_lHighestFileSequence += lModuleHighestFileSequence;

	return iResult;
}	// end of MergeFileTable


/////////////////////////////////////////////////////////////////////////////
// WriteDatabaseSequenceTable()
UINT CMsmMerge::WriteDatabaseSequenceTable(enum stnSequenceTableNum stnTable, CSeqActList &lstSequence) const
{
	CQuery qUpdate;
	CQuery qInsert;
	
	bool bConflict = false; // set to true to return ERROR_MERGE_CONFLICT

	// modify existing item
	if ((ERROR_SUCCESS != qUpdate.Open(m_hDatabase, TEXT("UPDATE `%s` SET `Sequence`=? WHERE `Action`=?"), g_rgwzMSISequenceTables[stnTable])) ||
		(ERROR_SUCCESS != qInsert.OpenExecute(m_hDatabase, 0, TEXT("SELECT `Action`, `Sequence`, `Condition` FROM %ls ORDER BY `Sequence`"), g_rgwzMSISequenceTables[stnTable]))) 
	{
		FormattedLog(L">> Error: Failed to open query for action resequencing in %ls table.\r\n", g_rgwzMSISequenceTables[stnTable]);
		return ERROR_FUNCTION_FAILED;
	}

	CSequenceAction* pseqactMerge;
	PMSIHANDLE hRecMerge = ::MsiCreateRecord(3);
	POSITION posMerge = lstSequence.GetHeadPosition();
	while (posMerge)
	{
		// get the action to merge
		pseqactMerge = lstSequence.GetNext(posMerge);

		// if this action already existed in the MSI, we want to update it
		if (pseqactMerge->m_bMSI) 
		{
			::MsiRecordSetInteger(hRecMerge, 1, pseqactMerge->m_iSequence);
			::MsiRecordSetStringW(hRecMerge, 2, pseqactMerge->m_wzAction);
			if (ERROR_SUCCESS != qUpdate.Execute(hRecMerge))
			{
				FormattedLog(L">> Error: Failed to update sequence of existing action %ls.", pseqactMerge->m_wzAction);
				bConflict = true;
			}
		}
		else
		{
			// new action, so we want to insert it
			::MsiRecordSetStringW(hRecMerge, 1, pseqactMerge->m_wzAction);
			::MsiRecordSetInteger(hRecMerge, 2, pseqactMerge->m_iSequence);
			::MsiRecordSetStringW(hRecMerge, 3, pseqactMerge->m_wzCondition);

			// merge in the new row
			if (ERROR_SUCCESS != qInsert.Modify(MSIMODIFY_INSERT, hRecMerge))
			{
				// show that there was at least one conflict
				bConflict = true;
				
				// log error
				FormattedLog(L">> Error: Failed to merge Action: %ls into Table: %ls\r\n", pseqactMerge->m_wzAction, g_rgwzMSISequenceTables[stnTable]);
				
				// create a new error item and add it to the error list
				if (m_pErrors)
				{
					CMsmError *pErr = new CMsmError(msmErrorResequenceMerge, NULL, -1);
					if (!pErr) return E_OUTOFMEMORY;
					m_pErrors->Add(pErr);

					pErr->SetDatabaseTable(g_rgwzMSISequenceTables[stnTable]);
					pErr->AddDatabaseError(pseqactMerge->m_wzAction);
					pErr->SetModuleTable(g_rgwzModuleSequenceTables[stnTable]);
					pErr->AddModuleError(pseqactMerge->m_wzAction);
				}
			}
		}
	}
	return bConflict ? ERROR_MERGE_CONFLICT : ERROR_SUCCESS;
}
/////////////////////////////////////////////////////////////////////////////
// AssignSequenceNumbers()
// now assign sequence numbers to all the items in the provided sequence. 
// We want to maintain existing sequence numbers as much as possible. The more
// "round" a number is, the more important it is to keep it from changing.
// e.g. 1650 would be changed before 1600 would be changed. If we do
// have to move, we shift by the "roundness" factor, even if it isn't strictly
// necessary. e.g 1650 would change to 1660, not 1652.
UINT CMsmMerge::AssignSequenceNumbers(enum stnSequenceTableNum stnTable, CSeqActList &lstSequence) const
{
	CSequenceAction *pPrev = NULL;
	CSequenceAction *pNext = NULL;
	POSITION pos = lstSequence.GetHeadPosition();
	int iSequence = 0;
	int iIncSequence = 0;
	while (pos)
	{
		pPrev = pNext;
		pNext = lstSequence.GetNext(pos);

		// check if this action already has a sequence number
		if (pNext->m_iSequence != CSequenceAction::iNoSequenceNumber)
		{
			// if this sequence number is less than or equal to 0, we can't resequence it because it maps
			// to one of the error dialogs, etc.
			if (pNext->m_iSequence <= 0)
			{
				// if we have assigned sequence numbers to new actions already,
				// this is an error becaue you can't resquence the predefined
				// sequence numbers. In this case generate a sequencing
				// error for everything between this assigned number and the
				// previous valid number.
				if (pPrev != NULL && iSequence > 0)
				{
					POSITION posBack = pos;

					CSequenceAction* pBack = NULL;
					if (pos)
					{
						// posBack points to the NEXT item in the list
						lstSequence.GetPrev(posBack);
						lstSequence.GetPrev(posBack);
						// posBack will now retrieve the previous item
					}
					else
					{
						// if this is the last item in the list, posBack will be NULL
						// and we'll have to search the list to find a valid
						// POSITION value.
						posBack = lstSequence.Find(pPrev);
					}

					while (posBack)
					{
						pBack = lstSequence.GetPrev(posBack);

						// stop reassigning numbers when we hit another MSI
						// action
						if (pBack->m_bMSI)
							break;

						// also stop reassigning numbers when the action
						// is already less than or equal to what we would
						// assign
						if (pBack->m_iSequence <= pNext->m_iSequence)
							break;

						// best we can hope for is to assign the same number
						// to the previous actions
						pBack->m_iSequence = pNext->m_iSequence;

						// create a new error item and add it to the error list
						FormattedLog(L"> Warning: Sequencing of action %ls in %ls table resulted in an invalid sequence number.\r\n", pBack->m_wzAction, g_rgwzModuleSequenceTables[stnTable]);
						if (m_pErrors)
						{
							CMsmError *pErr = new CMsmError(msmErrorResequenceMerge, NULL, -1);
							if (!pErr)
								return E_OUTOFMEMORY;
							
							pErr->SetDatabaseTable(g_rgwzMSISequenceTables[stnTable]);
							pErr->AddDatabaseError(pBack->m_wzAction);
							pErr->SetModuleTable(g_rgwzModuleSequenceTables[stnTable]);
							pErr->AddModuleError(pBack->m_wzAction);
							m_pErrors->Add(pErr);
						}
					}

					iSequence = 0;
				}

				continue;
			}

			// if this action is supposed to have the same sequence number as the previous
			// action, do so
			if (pNext->IsEqual(pPrev))
			{
				pNext->m_iSequence = pPrev->m_iSequence;
				TRACE(TEXT("Using Same Sequence Number: %d for Action %ls. (Actions had same number in MSI.)\r\n"), pNext->m_iSequence, pNext->m_wzAction);
				continue;
			}

			// check if the assigned sequence number works.
			if (pNext->m_iSequence > iSequence)
			{
				// it does so accept the number
				TRACE(TEXT("Using Assigned Sequence Number: %d for Action %ls.\r\n"), pNext->m_iSequence, pNext->m_wzAction);
				iSequence = pNext->m_iSequence;
				iIncSequence = 0;
				continue;
			}
			// assigned sequence number doesn't work, but once
			// we have shifted by our current shift amount, it does
			else if (pNext->m_iSequence + iIncSequence > iSequence)
			{
				iSequence = (pNext->m_iSequence += iIncSequence);
				TRACE(TEXT("Shifting Assigned Sequence Number by %d for Action %ls. (now %d)\r\n"), iIncSequence, 
					pNext->m_wzAction, pNext->m_iSequence);
				continue;
			}
			// assigned sequence number doesn't work at all,
			// time to increment iIncSequence;
			else
			{
				TRACE(TEXT("Sequence failure for action %ls. Want greater than %d. Assigned (w/inc): %d\r\n"), pNext->m_wzAction, iSequence, 
					pNext->m_iSequence + iIncSequence);

				// sequence numbers must be <= 32767, so max round value is 10,000
				// determine the roundness of the sequence number
				int iSeqRoundness = 10000;
				while (pNext->m_iSequence % iSeqRoundness) iSeqRoundness /= 10;

				// determine the roundness of the current shift amount
				int iCurRoundness = 10000;
				if (iIncSequence == 0)
					iCurRoundness = 1;
				else
					while (iIncSequence % iCurRoundness) iCurRoundness /= 10;

				// if we need to increase the roundness, use iSeqRoundness
				if (iSeqRoundness > iCurRoundness)
					iIncSequence = iSeqRoundness * (((iSequence - pNext->m_iSequence) / iSeqRoundness)+1);
				else
					iIncSequence = iCurRoundness * (((iSequence - pNext->m_iSequence) / iCurRoundness)+1);
				TRACE(TEXT("New increment:%d.\r\n"), iIncSequence);

				pNext->m_iSequence += iIncSequence; 
				TRACE(TEXT("Assigning %d to Action %ls.\r\n"), pNext->m_iSequence, 
					pNext->m_wzAction);
				iSequence = pNext->m_iSequence;
			}
		}
		else
		{
			// no number has been assigned. So we can assign one that works by 
			// simply adding 1 to the current sequence. It may cause problems
			// in the future, but thats not our problem right now.
			pNext->m_iSequence = ++iSequence;
			TRACE(TEXT("Assigning new sequence number: %d for Action %ls.\r\n"),
				pNext->m_iSequence, pNext->m_wzAction);
			continue;
		}
	}
	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// ReadModuleSequenceTable()
// reads all actions from the module's sequence tables and adds them to the
// list of all actions and to the action pool. Sets dependencies for 
// each action, and if inserting standard action from module, will break
// existing dependencies to add new one. The table must exist in the module.
UINT CMsmMerge::ReadModuleSequenceTable(enum stnSequenceTableNum stnTable, LPCWSTR wzSourceTable, CSeqActList &lstAllActions, CSeqActList &lstActionPool) const
{
	// set to true if a merge conflict is encountered. Modifies the return value to ERROR_MERGE_CONFLICT
	bool bMergeConflict = false;
	
	// add a marking column to the table
	CQuery qColumn;
	if (ERROR_SUCCESS != qColumn.OpenExecute(m_hModule, 0, TEXT("ALTER TABLE %ls ADD `_Merge` INTEGER TEMPORARY"), wzSourceTable))
	{ 
		FormattedLog(L">> Error: Failed to create temporary column in %ls table.\r\n", g_rgwzModuleSequenceTables[stnTable]);
		return ERROR_FUNCTION_FAILED;
	}

	// prepare marking query
	CQuery qModuleUpdate;
	if (ERROR_SUCCESS != qModuleUpdate.Open(m_hModule, TEXT("UPDATE %ls SET `_Merge`=1 WHERE `BaseAction`=?"), wzSourceTable))
	{ 
		FormattedLog(L">> Error: Failed to create temporary update query in %ls table.\r\n", g_rgwzModuleSequenceTables[stnTable]);
		return ERROR_FUNCTION_FAILED;
	}
				
	// get root actions
	CQuery qModule;
	if (ERROR_SUCCESS != qModule.OpenExecute(m_hModule, 0, TEXT("SELECT `Action`, `Sequence`, `Condition`, `_Merge` FROM %ls WHERE `Sequence` IS NOT NULL AND `BaseAction` IS NULL"), wzSourceTable))
	{ 
		FormattedLog(L">> Error: Failed to retrieve root actions in %ls table.\r\n", g_rgwzModuleSequenceTables[stnTable]);
		return ERROR_FUNCTION_FAILED;
	}

	// prepare marking query
	CQuery qModuleChild;
	if (ERROR_SUCCESS != qModuleChild.Open(m_hModule, TEXT("SELECT `Action`, `Condition`, `BaseAction`, `After`, `_Merge` FROM %ls WHERE `_Merge`=1"), wzSourceTable))
	{ 
		FormattedLog(L">> Error: Failed to retrieve dependant actions in %ls table.\r\n", g_rgwzModuleSequenceTables[stnTable]);
		return ERROR_FUNCTION_FAILED;
	}

	// get all root actions from MSI
	WCHAR *wzAction = NULL;
	DWORD cchAction = 0;
	UINT iStat;
	PMSIHANDLE hAction;
	while (ERROR_SUCCESS == (iStat = qModule.Fetch(&hAction))) 
	{
		// see if the action already exists
		RecordGetString(hAction, 1, &wzAction, &cchAction);
		RecordGetString(hAction, 3, NULL, NULL);
		int iSequence = ::MsiRecordGetInteger(hAction, 2);
		POSITION pos = lstAllActions.GetHeadPosition();
		bool bFound = false;
		while (pos)
		{
 			CSequenceAction *pWalk = lstAllActions.GetNext(pos);
			if (0 == wcscmp(wzAction, pWalk->m_wzAction))
			{
				bFound = true;
				FormattedLog(L"Base Action %ls in %ls table already exists in MSI. Using MSI action.\r\n", pWalk->m_wzAction, g_rgwzMSISequenceTables[stnTable]);
				if (wcscmp(m_wzBuffer, pWalk->m_wzCondition) != 0)
				{
					FormattedLog(L" Actions have different conditions.\r\n");
						
					bMergeConflict = true;

					// create a new error item and add it to the error list
					if (m_pErrors)
					{
						CMsmError *pErr = new CMsmError(msmErrorResequenceMerge, NULL, -1);
						if (!pErr) {
							delete[] wzAction;
							return E_OUTOFMEMORY;
						}
						pErr->SetDatabaseTable(g_rgwzMSISequenceTables[stnTable]);
						pErr->AddDatabaseError(wzAction);
						pErr->SetModuleTable(g_rgwzModuleSequenceTables[stnTable]);
						pErr->AddModuleError(wzAction);
						m_pErrors->Add(pErr);
					}
				}
				break;
			}
		}
		
		if (!bFound)
		{
			// base action doesn't already exist, create a new entry
			CSequenceAction *pNewAction = new CSequenceAction(wzAction, iSequence, m_wzBuffer, false /*bMSI*/);
			if (!pNewAction) 
			{
				delete[] wzAction;
				return E_OUTOFMEMORY;
			}

			lstActionPool.InsertOrderedWithDep(pNewAction);
			lstAllActions.AddTail(pNewAction);
		}

		// set the marking column value of all children to 1 and update
		qModuleUpdate.Execute(hAction);		

		// set the marking column of this record to 2.
		::MsiRecordSetInteger(hAction, 4, 2);
		qModule.Modify(MSIMODIFY_UPDATE, hAction);
	}
	if (ERROR_NO_MORE_ITEMS != iStat) 
	{
		delete[] wzAction;
		return ERROR_FUNCTION_FAILED;
	}


	// now repeatedly get everything marked with a 1 until there are no more items.
	// process them, then set the mark value to 2.
	int cModifiedActions = 0;
	do {
		if (ERROR_SUCCESS != (iStat = qModuleChild.Execute(0)))
		{
			delete[] wzAction;
			return ERROR_FUNCTION_FAILED;
		}

		cModifiedActions=0;
		while (ERROR_SUCCESS == (iStat = qModuleChild.Fetch(&hAction))) 
		{
			cModifiedActions++;

			// get action info
			RecordGetString(hAction, 1, &wzAction, &cchAction);
			RecordGetString(hAction, 2, NULL, NULL);
			CSequenceAction *pNewAction = new CSequenceAction(wzAction, CSequenceAction::iNoSequenceNumber, m_wzBuffer, false /*m_bMsi*/);
			if (!pNewAction) 
			{
				delete[] wzAction;
				return E_OUTOFMEMORY;
			}
			
			// find the base action
			RecordGetString(hAction, 3, &wzAction, &cchAction);
			CSequenceAction *pBase = lstAllActions.FindAction(wzAction);
			if (pBase)
			{
				if (1 != ::MsiRecordGetInteger(hAction, 4))
				{
					// create the ordering between new action and base
					pBase->AddPredecessor(pNewAction);
					FormattedLog(L"Placing action %ls before %ls\r\n", pNewAction->m_wzAction, pBase->m_wzAction);
				}
				else
				{
					pBase->AddSuccessor(pNewAction);					
					FormattedLog(L"Placing action %ls after %ls\r\n", pNewAction->m_wzAction, pBase->m_wzAction);
				}

				// create the ordering between new action and following MSI action
				// this ensures that any new actions will be closely bound to
				// their base.
				CSequenceAction *pAssigned = pBase->FindAssignedSuccessor();
				if (pAssigned) pNewAction->AddSuccessor(pAssigned);

				// create the ordering between new action and previous MSI action
				// this ensures that any new actions will be closely bound to
				// their base.
				pAssigned = pBase->FindAssignedPredecessor();
				if (pAssigned) pNewAction->AddPredecessor(pAssigned);

				lstAllActions.AddTail(pNewAction);
				lstActionPool.AddTail(pNewAction);
			}
			else
			{
				FormattedLog(L"> Warning: Could not find base action %ls\r\n", wzAction);
						
				bMergeConflict = true;

				// create a new error item and add it to the error list
				if (m_pErrors)
				{
					CMsmError *pErr = new CMsmError(msmErrorResequenceMerge, NULL, -1);
					if (!pErr) {
						delete[] wzAction;
						return E_OUTOFMEMORY;
					}
					pErr->SetDatabaseTable(g_rgwzMSISequenceTables[stnTable]);
					pErr->SetModuleTable(g_rgwzModuleSequenceTables[stnTable]);
					pErr->AddModuleError(pNewAction->m_wzAction);
					m_pErrors->Add(pErr);
				}
			}

			// set the marking column value to 2 and update this record
			::MsiRecordSetInteger(hAction, 5, 2);
			qModuleChild.Modify(MSIMODIFY_UPDATE, hAction);

			// set the marking column value of all children to 1 and update
			qModuleUpdate.Execute(hAction);
		}
		if (ERROR_NO_MORE_ITEMS != iStat) 
		{
			delete[] wzAction;
			return ERROR_FUNCTION_FAILED;
		}
	}
	while (cModifiedActions);

	// nuke the action buffer
	delete[] wzAction;

	// now check for any unprocessed records and report them
	CQuery qLeftOver;
	if (ERROR_SUCCESS != qLeftOver.OpenExecute(m_hModule, 0, TEXT("SELECT `Action` FROM %ls WHERE `_Merge`<>2"), wzSourceTable))
	{
		FormattedLog(L">> Error: Failed to query for orphaned actions in %ls table.\r\n", g_rgwzModuleSequenceTables[stnTable]);
		return ERROR_FUNCTION_FAILED;
	}
	while (ERROR_SUCCESS == qLeftOver.Fetch(&hAction)) 
	{
		RecordGetString(hAction, 1, NULL, NULL);
		FormattedLog(L"> Warning: Failed to merge action %ls into %ls table. Action is orphaned in the module.\r\n", m_wzBuffer, g_rgwzMSISequenceTables[stnTable]);

		// create a new error item and add it to the error list
		bMergeConflict = true;

		if (m_pErrors)
		{
			CMsmError *pErr = new CMsmError(msmErrorResequenceMerge, NULL, -1);
			if (!pErr) return E_OUTOFMEMORY;
			pErr->SetModuleTable(g_rgwzModuleSequenceTables[stnTable]);
			pErr->AddModuleError(m_wzBuffer);
			m_pErrors->Add(pErr);
		}
	}
	
	return bMergeConflict ? ERROR_MERGE_CONFLICT : ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// OrderingToSequence()
// turns a partial ordering of sequence actions in lstActionPool into a 
// linear sequence on the end of lstSequence by repeatedly pulling actions
// from the pool that have neither predecessors nor equal actions with 
// predecessors. Actions that cannot be placed in the sequence are left in the pool.
UINT CMsmMerge::OrderingToSequence(CSeqActList &lstActionPool, CSeqActList &lstSequence) const
{
	////
	// turn the partial ordering into a linear sequence by pulling off actions
	// with no predecessors.
	CSequenceAction *pNext = NULL;
	do
	{
		// pull an action off the front of the list
		pNext = lstActionPool.RemoveNoPredecessors();

		if (pNext)
		{
			pNext->RemoveFromOrdering();
			lstSequence.AddTail(pNext);
			
			// add any actions that are supposed to keep the same sequence numbers
			POSITION posSame = pNext->GetEqualHeadPosition();
			while (posSame)
			{
				CSequenceAction *pSame = pNext->GetNextEqual(posSame);
				lstSequence.AddTail(pSame);
				POSITION delPos = lstActionPool.Find(pSame);
				ASSERT(delPos);
				lstActionPool.RemoveAt(delPos);
				pSame->RemoveFromOrdering();
			}
		}
	} while (pNext);
	return ERROR_SUCCESS;
}
	
///////////////////////////////////////////////////////////
// MergeSequenceTable
// Pre:	database handle is open
//			module handle is open
// Pos:	module sequence table is arranged in database sequence tables
UINT CMsmMerge::MergeSequenceTable(enum stnSequenceTableNum stnTable, CSeqActList &lstDirActions, CQuery *qIgnore)
{
	// general result variable
	UINT iResult = ERROR_SUCCESS;		// assume everything will be okay

	// if there are sequence actions generated by the directory table merge, we should
	// continue even if the module is not adding actions. Otherwise, continue only 
	// if there is a merge module table
	BOOL bModuleTable = MsiDBUtils::TableExistsW(g_rgwzModuleSequenceTables[stnTable], m_hModule);

	// don't merge in the directory table actions for the AdvtUISequenceTable
	bool bMergeDirActions = (stnTable != stnAdvtUI);

	// if the table is listed in the ModuleIgnoreTable, pretend the table
	// doesn't exist
	if (bModuleTable)
		bModuleTable = !IgnoreTable(qIgnore, g_rgwzModuleSequenceTables[stnTable], true);

	// if there are no entries in the module sequence table, it doesn't exist as far
	// as we are concerned
	if (bModuleTable)
	{
		CQuery qEmpty;
		PMSIHANDLE hRec = 0;
		bModuleTable = (ERROR_SUCCESS == qEmpty.FetchOnce(m_hModule, NULL, &hRec, TEXT("SELECT * FROM `%ls`"), g_rgwzModuleSequenceTables[stnTable]));
	}

	// decide if we even need to process this table. Skip the table if
	// it doesn't exist in the module (or is empty) AND there are no actions (or we shouldn't merge them)
	if ((!bMergeDirActions || !lstDirActions.GetCount()) && !bModuleTable)
		return ERROR_SUCCESS;
		
	// show some log information
	if (bModuleTable) 
	{
		FormattedLog(L"Merging Sequence Table: %ls into Database Table: %ls\r\n", g_rgwzModuleSequenceTables[stnTable], g_rgwzMSISequenceTables[stnTable]);
	}
	else
	{
		FormattedLog(L"Merging generated Directory actions into Database Table: %ls\r\n", g_rgwzMSISequenceTables[stnTable]);
	}


	const WCHAR wzTempSourceTable[] = L"__MergeTempSequence";
	const WCHAR* wzReadTable = g_rgwzModuleSequenceTables[stnTable];
	
	// if module configuration is enabled, we'll need to do any substitution before
	// we can look around in the sequencetable
	CQuery qSourceLifetime;
	if (bModuleTable && m_fModuleConfigurationEnabled && IsTableConfigured(g_rgwzModuleSequenceTables[stnTable]))
	{
		FormattedLog(L"  Configuring %ls table before merge.\r\n", g_rgwzMSISequenceTables[stnTable]);
		if (ERROR_SUCCESS != SubstituteIntoTempTable(g_rgwzModuleSequenceTables[stnTable], wzTempSourceTable, qSourceLifetime))
		{
			FormattedLog(L">> Error: Unable to prepare %ls table for ModuleConfiguration.\r\n", g_rgwzMSISequenceTables[stnTable]);
			return ERROR_FUNCTION_FAILED;
		}
		wzReadTable = wzTempSourceTable;
	}

	// if MSI sequence table does not exist in the database create it
	if (!MsiDBUtils::TableExistsW(g_rgwzMSISequenceTables[stnTable], m_hDatabase))
	{
		// try to create the table
		try
		{
			MsiDBUtils::CreateTableW(g_rgwzMSISequenceTables[stnTable], m_hDatabase, m_hModule);
		}
		catch(CLocalError err)
		{
			// log the error
			err.Log(m_hFileLog);

			return ERROR_FUNCTION_FAILED;	
		}
	}

	// this list ALWAYS contains all of the different actions. At any point,
	// complete memory cleanup can be done by deleting all items in this list
	CSeqActList lstAllActions;
	
	// lists for temporary storage of the different action types
	CSeqActList lstActionPool;

	CSequenceAction *pPrev = NULL;
	int iPrevSequence = -9999;
	
	////
	// retrieve all actions from the database table
	PMSIHANDLE hAction;

	// get database sequence table
	CQuery qDatabase;
	CheckError(qDatabase.OpenExecute(m_hDatabase, 0, TEXT("SELECT `Action`, `Sequence`, `Condition` FROM %ls ORDER BY `Sequence`"), g_rgwzMSISequenceTables[stnTable]), 
			  L">> Error: Failed to get MSI Database's SequencesTable.\r\n");
	WCHAR *wzAction = new WCHAR[72];
	DWORD cchAction = 72;
	if (!wzAction) return E_OUTOFMEMORY;

	UINT iStat;
	while (ERROR_SUCCESS == (iStat = qDatabase.Fetch(&hAction))) 
	{
		RecordGetString(hAction, 1, &wzAction, &cchAction);
		RecordGetString(hAction, 3, NULL, NULL);
		int iSequence = ::MsiRecordGetInteger(hAction, 2);
		CSequenceAction *pNewAction = new CSequenceAction(wzAction, iSequence, m_wzBuffer, true /*bMSI*/);
		if (!pNewAction) {
			delete[] wzAction;
			while (pNewAction = lstAllActions.RemoveHead()) delete pNewAction;
			return E_OUTOFMEMORY;
		}
		if (iPrevSequence == iSequence)
		{
			// this action has the same sequence number as the previous action
			// pPrev cannot be NULL in this case
			pPrev->AddEqual(pNewAction);
		}
		else if (pPrev)
		{
			// it has a larger sequence number than the previous one
			pPrev->AddSuccessor(pNewAction);
		}
		pPrev = pNewAction;
		iPrevSequence = iSequence;
		lstActionPool.AddTail(pNewAction);
		lstAllActions.AddTail(pNewAction);
	};
	// clean up memory
	delete[] wzAction;

	// check for loop failure
	if (ERROR_NO_MORE_ITEMS != iStat)
	{
		// show some log information
		FormattedLog(L">> Error reading actions from database %ls table.\r\n", g_rgwzMSISequenceTables[stnTable]);
		CSequenceAction *pDel = NULL;
		while (pDel = lstAllActions.RemoveHead()) delete pDel;
		return ERROR_FUNCTION_FAILED;
	}

	////
	// read module's sequence table
	iResult = ERROR_SUCCESS;
	if (bModuleTable)
		iResult = ReadModuleSequenceTable(stnTable, wzReadTable, lstAllActions, lstActionPool);


	////
	// Add any actions to the list that came from the directory table
	if (bMergeDirActions && lstDirActions.GetCount()) 
	{
		CSequenceAction *pNext = NULL;
		POSITION pos = lstDirActions.GetHeadPosition();
		while (pos)
		{
			CDirSequenceAction* pDirAction = static_cast<CDirSequenceAction*>(lstDirActions.GetNext(pos));
			if (!pDirAction)
				break;

			// check to see whether the action is already in the sequence table. If so, don't
			// add another copy to the list.
			if (NULL == lstAllActions.FindAction(pDirAction->m_wzAction))
			{
				pNext = new CSequenceAction(pDirAction);
				if (!pNext) 
				{
					while (pNext = lstAllActions.RemoveHead()) delete pNext;
					return E_OUTOFMEMORY;
				}
				lstActionPool.InsertOrderedWithDep(pNext);
				lstAllActions.AddTail(pNext);

				// mark the directory table list action as new in this sequence table. If the directory 
				// table entry is removed via "no-orphan," this action will also be removed if it
				// was added, otherwise it will be left behind.
				pDirAction->m_dwSequenceTableFlags |= (1 << stnTable);
			}
		}
	}

	// turn the ordering into a sequnce
	CSeqActList lstSequence;
	if ((iResult == ERROR_SUCCESS) || (iResult == ERROR_MERGE_CONFLICT))
	{
		int iLocResult = OrderingToSequence(lstActionPool, lstSequence);
		if (iLocResult != ERROR_SUCCESS) 
			iResult = iLocResult;
	}

	// if there are any actions left over in the pools, we are hosed because the
	// actions don't form a partial ordering. I honestly can't think of any
	// way this could happen except via code bug.
	POSITION pos = lstActionPool.GetHeadPosition();
	ASSERT(!pos);
	while (pos) 
	{
		CSequenceAction *pExtra = lstActionPool.GetNext(pos);

		FormattedLog(L" Action %ls could not be placed in database sequence, no ordering possible.\r\n", pExtra->m_wzAction);			
		iResult = ERROR_MERGE_CONFLICT;

		// create a new error item and add it to the error list
		if (m_pErrors)
		{
			CMsmError *pErr = new CMsmError(msmErrorResequenceMerge, NULL, -1);
			if (!pErr) 
			{
				iResult = E_OUTOFMEMORY;
				break;
			}
			pErr->SetDatabaseTable(g_rgwzMSISequenceTables[stnTable]);
			pErr->SetModuleTable(g_rgwzModuleSequenceTables[stnTable]);
			pErr->AddModuleError(pExtra->m_wzAction);
			m_pErrors->Add(pErr);
		}
	}
	
	// Assign sequence numbers to this ordering. 
	if ((iResult == ERROR_SUCCESS) || (iResult == ERROR_MERGE_CONFLICT))
	{
		int iLocResult = AssignSequenceNumbers(stnTable, lstSequence);
		if (iLocResult != ERROR_SUCCESS) 
			iResult = iLocResult;
	}
	
	// write the sequence tables back out to the MSI. 
	if ((iResult == ERROR_SUCCESS) || (iResult == ERROR_MERGE_CONFLICT))
	{
		int iLocResult = WriteDatabaseSequenceTable(stnTable, lstSequence);
		if (iLocResult != ERROR_SUCCESS) 
			iResult = iLocResult;
	}
	
	// clean up all of the dynamically allocated information
	while (lstAllActions.GetCount()) delete lstAllActions.RemoveHead();

	return iResult;
}	// end of MergeSequenceTable


///////////////////////////////////////////////////////////
// ReplaceFeature
UINT CMsmMerge::ReplaceFeature(LPCWSTR wzFeature, MSIHANDLE hRecord)
{
	UINT iReplaced = 0;			// count of strings replaced
	UINT iResult;					// generic result variable

	// buffer to hold string to check
	WCHAR wzBuffer[g_cchFeatureReplacement];
	DWORD cchBuffer;

	// loop through all the columsn in the record
	UINT iColumns = ::MsiRecordGetFieldCount(hRecord);
	for (UINT i = 0; i < iColumns; i++)
	{
		cchBuffer = g_cchFeatureReplacement;		// always reset the size of the buffer

		// get the string
		iResult = ::MsiRecordGetStringW(hRecord, i + 1, wzBuffer, &cchBuffer);

		// if have a string do a comparison
		if (ERROR_SUCCESS == iResult)
		{
			// if we have an identical match to the replace string do the replace
			if (0 == wcscmp(wzBuffer, g_wzFeatureReplacement))
			{
				// if we are not provided a feature name, throw an error
				if ((!wzFeature) ||
					(wcslen(wzFeature) == 0))
					throw CLocalError(ERROR_INVALID_PARAMETER, 
						  L">> Error: Feature not provided for required replacement.\r\n");

				// set the feature name instead
				CheckError(::MsiRecordSetStringW(hRecord, i + 1, wzFeature), 
							  L">> Error: Failed to set string to do Feature stub replacement.\r\n");

				// increment the count
				iReplaced++;
			}
		}
		else if ((ERROR_MORE_DATA != iResult) &&      // if more than just a buffer over run
				 (ERROR_INVALID_DATATYPE != iResult))  // or a binary column, throw an error
			FormattedLog(L"> Warning: Failed to get string to do a Feature stub replacement.\r\n");
	}

	return iReplaced;
}	// end of ReplaceFeature

///////////////////////////////////////////////////////////
// RedirectDirs
const WCHAR* g_rgwzStandardDirs[] = { 
	L"AppDataFolder",
	L"CommonFilesFolder",
	L"DesktopFolder",
	L"FavoritesFolder",
	L"FontsFolder",
	L"NetHoodFolder",
	L"PersonalFolder",
	L"PrintHoodFolder",
	L"ProgramFilesFolder",
	L"ProgramMenuFolder",
	L"RecentFolder",
	L"SendToFolder",
	L"StartMenuFolder",
	L"StartupFolder",
	L"SystemFolder",
	L"System16Folder",
	L"TempFolder",
	L"TemplateFolder",
	L"WindowsFolder",
	L"WindowsVolume",
	// Darwin 1.1 Folders
	L"CommonAppDataFolder",
	L"LocalAppDataFolder",
	L"MyPicturesFolder",
	L"AdminToolsFolder",
	// Darwin 1.5 Folders
	L"System64Folder",
	L"ProgramFiles64Folder",
	L"CommonFiles64Folder"
};
const g_cwzStandardDirs = sizeof(g_rgwzStandardDirs)/sizeof(WCHAR *);

UINT CMsmMerge::MergeDirectoryTable(LPCWSTR wzDirectory, CSeqActList &lstDirActions)
{
	CQuery qModule;
	CQuery qDatabase;

	// nothing to do if no dir table in module
	if (MSICONDITION_TRUE != ::MsiDatabaseIsTablePersistentW(m_hModule, g_wzDirectoryTable))
		return ERROR_SUCCESS;

	// show some log information
	FormattedLog(L"Merging Table: Directory\r\n");
		
	//  ensure that it exists in the database
	if (MSICONDITION_TRUE != ::MsiDatabaseIsTablePersistentW(m_hDatabase, g_wzDirectoryTable))
		if (ERROR_SUCCESS != MsiDBUtils::CreateTableW(g_wzDirectoryTable, m_hDatabase, m_hModule))
		{
			FormattedLog(L">> Error: Unable to create Directory table in database.\r\n");
			return ERROR_FUNCTION_FAILED;
		}

	const WCHAR wzSourceTable[] = L"Directory";
	const WCHAR wzTempSourceTable[] = L"__MergeDirectory";
	const WCHAR* wzReadTable = wzSourceTable;
	
	// if module configuration is enabled, we'll need to do any substitution before
	// we can look around in the Directory table
	CQuery qSourceLifetime;
	if (m_fModuleConfigurationEnabled && IsTableConfigured(L"Directory"))
	{
		FormattedLog(L"  Configuring Directory table before merge.\r\n");
		if (ERROR_SUCCESS != SubstituteIntoTempTable(wzSourceTable, wzTempSourceTable, qSourceLifetime))
		{
			FormattedLog(L">> Error: Unable to prepare Directory table for ModuleConfiguration.\r\n");
			return ERROR_FUNCTION_FAILED;
		}
		wzReadTable = wzTempSourceTable;
	}

	// Even if no redirection, must create the temporary column so later queries will succeed. Column 
	// disapears when function ends (qTempColumn goes out of scope)
	CQuery qTempColumn;
	qTempColumn.OpenExecute(m_hModule, NULL, TEXT("ALTER TABLE `%ls` ADD `_MergeMark` INT TEMPORARY"), wzReadTable);

	if (m_fModuleConfigurationEnabled && IsTableConfigured(L"Directory"))
	{
		// generate read query from temp table
		qModule.OpenExecute(m_hModule, NULL, TEXT("SELECT * FROM `%ls`"), wzTempSourceTable);
	}
	else
	{
		UINT iResult = 0;

		// not configured into temp table, so generate a module query in the appropriate column order for 
		// insertion into the database (the database order may be different from the module order.) Function
		// logs its own failure cases.
		if (ERROR_SUCCESS != (iResult = GenerateModuleQueryForMerge(L"Directory", L", `_MergeMark`", NULL, qModule)))
		{
			// immediately fatal error
			throw (UINT)E_FAIL;
			return iResult;
		}
	}

	// generate write query
	qDatabase.OpenExecute(m_hDatabase, NULL, TEXT("SELECT * FROM `Directory`"));

	// if we have to do directory redirection, mark everything that needs to be modified. Ideally, this
	// is everything with TARGETDIR as parent, but for not always. 
	if (wzDirectory && wcslen(wzDirectory)) 
	{
		CQuery qRoot;
		CQuery qMark;
		qMark.Open(m_hModule, TEXT("UPDATE `%ls` SET `_MergeMark`=1 WHERE `Directory_Parent`=?"), wzReadTable);
		qRoot.OpenExecute(m_hModule, NULL, TEXT("SELECT `Directory` FROM `%ls` WHERE `Directory_Parent` IS NULL OR `Directory_Parent`=`Directory`"), wzReadTable);

		PMSIHANDLE hRecModule;
		while (ERROR_SUCCESS == qRoot.Fetch(&hRecModule))
			qMark.Execute(hRecModule);
	}
	else
	{
		// we are NOT redirecting, so we should insert the module's TARGETDIR unless one exists already
		CQuery qDB;
		PMSIHANDLE hRecDir;
		qDB.OpenExecute(m_hDatabase, NULL, TEXT("SELECT `Directory` FROM `Directory` WHERE `Directory`='TARGETDIR'"));
		switch (qDB.Fetch(&hRecDir))
		{
		case ERROR_SUCCESS: 
			break; // db already has targetdir. OK
		case ERROR_NO_MORE_ITEMS:
			{
				// db does NOT have a targetdir, copy from the merge module
				CQuery qMod;
				PMSIHANDLE hRec;
				if (ERROR_SUCCESS != GenerateModuleQueryForMerge(wzReadTable, NULL, L" WHERE `Directory`='TARGETDIR'", qMod))
				{
					FormattedLog(L">> Error: Failed query for TARGETDIR in MSM.");
					return ERROR_FUNCTION_FAILED;
				}

				qMod.Execute();
				switch (qMod.Fetch(&hRec))
				{
				case ERROR_SUCCESS:
					if (ERROR_SUCCESS != qDatabase.Modify(MSIMODIFY_INSERT, hRec))
					{
						FormattedLog(L">> Error: Failed to insert TARGETDIR into MSI.");
						return ERROR_FUNCTION_FAILED;
					}
					break;
				case ERROR_NO_MORE_ITEMS:
					FormattedLog(L"No TARGETDIR root in Module or MSI.");
					break;
				default:
					FormattedLog(L">> Error: Failed query for TARGETDIR in MSM.");
					return ERROR_FUNCTION_FAILED;
				}
				break;
			}
		default:
			FormattedLog(L">> Error: Failed query for TARGETDIR in MSI.");
			return ERROR_FUNCTION_FAILED;
		}
	}

	// now do the directory table rows
	WCHAR *wzDir = NULL;
	DWORD cchDir = 0;

	// determine column numbers of interest in the directory table
	int iColumnDirectory = 0;
	int iColumnDirectoryParent = 0;
	int iColumnMark = 0; 
	if ((ERROR_SUCCESS != GetColumnNumber(m_hDatabase, L"Directory", L"Directory", iColumnDirectory)) ||
		(ERROR_SUCCESS != GetColumnNumber(m_hDatabase, L"Directory", L"Directory_Parent", iColumnDirectoryParent)) ||
		(ERROR_SUCCESS != GetColumnNumber(qModule, L"_MergeMark", iColumnMark)))
		return ERROR_FUNCTION_FAILED;

	PMSIHANDLE hRecModule;
	while (ERROR_SUCCESS == qModule.Fetch(&hRecModule))
	{
		bool bStandard = false;
		int nDir = 0;

		DWORD dwResult = 0;
		if (ERROR_SUCCESS != (dwResult = RecordGetString(hRecModule, iColumnDirectory, &wzDir, &cchDir)))
			return dwResult;

		for (nDir=0; nDir < g_cwzStandardDirs; nDir++)
		{
			size_t iStandardLen = wcslen(g_rgwzStandardDirs[nDir]);
			if ((wcslen(wzDir) > iStandardLen) &&
				(0 == wcsncmp(wzDir, g_rgwzStandardDirs[nDir], iStandardLen)))
			{
				bStandard = true;
				break;
			}
		}

		// if this directory needs to be redirectied, modify the parent
		if (!::MsiRecordIsNull(hRecModule, iColumnMark))
			::MsiRecordSetString(hRecModule, iColumnDirectoryParent, wzDirectory);

		// insert the record into the database
		if (ERROR_SUCCESS != qDatabase.Modify(MSIMODIFY_MERGE, hRecModule))
		{
			if (m_pErrors)
			{
				CMsmError *pErr = new CMsmError(msmErrorTableMerge, NULL, -1);
				if (!pErr) 
				{
					delete[] wzDir;
					return E_OUTOFMEMORY;
				}
				m_pErrors->Add(pErr);

				pErr->SetDatabaseTable(g_wzDirectoryTable);
				pErr->SetModuleTable(g_wzDirectoryTable);
				pErr->AddDatabaseError(wzDir);
				pErr->AddModuleError(wzDir);
			}
		}

		// this is a standard directory. We need to create custom actions
		if (bStandard)
		{
			// if the CA table doesn't exist, try to copy it from the module
			if (MSICONDITION_TRUE != ::MsiDatabaseIsTablePersistentW(m_hDatabase, L"CustomAction"))
				if (ERROR_SUCCESS != MsiDBUtils::CreateTableW(L"CustomAction", m_hDatabase, m_hModule))
				{
					delete[] wzDir;
					FormattedLog(L">> Error: Unable to create CustomAction table in database.\r\n");
					return ERROR_FUNCTION_FAILED;
				}

			PMSIHANDLE hCustomRec = ::MsiCreateRecord(4);

			// type 51 custom action with the directory name
			::MsiRecordSetStringW(hCustomRec, 1, wzDir);
			::MsiRecordSetInteger(hCustomRec, 2, 51);
			::MsiRecordSetStringW(hCustomRec, 3, wzDir);
			
			WCHAR *wzTarget = new WCHAR[wcslen(g_rgwzStandardDirs[nDir])+3];
			if (!wzTarget) return E_OUTOFMEMORY;
			swprintf(wzTarget, L"[%s]", g_rgwzStandardDirs[nDir]);
			::MsiRecordSetStringW(hCustomRec, 4, wzTarget);
			delete[] wzTarget;

			CQuery qCAInsert;
			qCAInsert.OpenExecute(m_hDatabase, hCustomRec, TEXT("INSERT INTO `CustomAction` (`Action`, `Type`, `Source`, `Target`) VALUES (?, ?, ?, ?)"));

			// create a new sequenced action. 
			CSequenceAction *pNewAction = new CDirSequenceAction(wzDir, 1, L"", false /* bMSI */);
			if (!pNewAction) 
			{
				delete[] wzDir;
				return E_OUTOFMEMORY;
			}
			lstDirActions.AddTail(pNewAction);
		}
	}
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////
// ExtractFilesCallback 
// callback from FDI API
INT_PTR CMsmMerge::ExtractFilesCallback(FDINOTIFICATIONTYPE iNotification, FDINOTIFICATION *pFDINotify)
{
	ASSERT(pFDINotify->pv);

	// convert the context into a this pointer
	CMsmMerge* pThis = static_cast<CMsmMerge *>(pFDINotify->pv);
	LPCWSTR pszCABFile = NULL;						// pointer to cab name
	LPCSTR pszFileName = NULL;						// pointer to filename after extraction

	// result to return. Is also a handle, so must be INT_PTR
	INT_PTR iResult;
	switch(iNotification)
	{
	case fdintCLOSE_FILE_INFO:
		{
			BOOL bRes = FALSE;

			// set the date and time (this is critical for versioning during install
			// Win32 needs Universal Time Code format to set file.)
			// *************** if this fails, we need to alert the user somehow
			FILETIME ftLocal;       
			if (DosDateTimeToFileTime(pFDINotify->date, pFDINotify->time, &ftLocal))
			{
				FILETIME ftUTC;       
				if (LocalFileTimeToFileTime(&ftLocal, &ftUTC))
					SetFileTime(reinterpret_cast<HANDLE>(pFDINotify->hf),&ftUTC,&ftUTC,&ftUTC);
			}

			// close the file
			::CloseHandle(reinterpret_cast<HANDLE>(pFDINotify->hf));

			// convert UINT to useable variable and log the file names
			pszFileName = reinterpret_cast<LPCSTR>(pFDINotify->psz1);
			pThis->FormattedLog(L"File [%hs] extracted successfully.\r\n", pFDINotify->psz1);

			iResult = TRUE;	// everything looks good, keep going
			break;
		}
	case fdintCOPY_FILE:
		{
			// convert params to useful variables
			pszFileName = reinterpret_cast<LPCSTR>(pFDINotify->psz1);

			// try to get the path to extract this file to
			// create a temporary buffer, because ExtractFilePath works in WCHARs
			WCHAR wzTarget[MAX_PATH] = L"";
			WCHAR wzCabinet[MAX_PATH] = L"";
			size_t cchCabinet = MAX_PATH;

			// the filename provided by FDI is ANSI. Must convert to wide before calling
			// ExtractFilePath. ExtractFilePath is wide so that we can have localized filenames
			// on NT systems.
			AnsiToWide(pszFileName, wzCabinet, &cchCabinet);
			iResult = pThis->ExtractFilePath(wzCabinet, wzTarget);

			// if everything is cool create directory structure for file
			if (ERROR_SUCCESS == iResult)
			{
				// make an ANSI version of the target path on Win9X
				char szTarget[MAX_PATH] = "";
				if (g_fWin9X)
				{
					size_t cchTarget = MAX_PATH;
					WideToAnsi(wzTarget, szTarget, &cchTarget);
				}

				// create the file's directory structure
				if ((g_fWin9X && CreateFilePathA(szTarget)) ||
					(!g_fWin9X && CreateFilePathW(wzTarget)))
				{
					pThis->FormattedLog(L"Extracting file [%ls] from CABinet [%hs]...\r\n", wzTarget, pszFileName);
					
					// we are responsible for creating the file
					// return the file handle as the result to extract the file.
					iResult = reinterpret_cast<INT_PTR>(g_fWin9X ?
						::CreateFileA(szTarget, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, pFDINotify->attribs, NULL) :
						::CreateFileW(wzTarget, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL));

					// if we could not create the file, log a message and skip this file
					if (INVALID_HANDLE_VALUE == reinterpret_cast<void *>(iResult))
					{
						pThis->FormattedLog(L">>Error: Failed to create target file [%ls].\r\n", wzTarget);
						iResult = 0;
					}

					// add to the extracted file list
					if (pThis->m_plstExtractedFiles)
					{
						pThis->m_plstExtractedFiles->Add(wzTarget);
					}

				}
				else	// skip this file because we couldn't create the directory structure for it
				{
					pThis->FormattedLog(L">>Error: Failed to create directory to extract file [%ls] from CABinet [%hs].\r\n", wzTarget, pszFileName);
					if (pThis->m_pErrors)
					{
						CMsmError *pErr = new CMsmError(msmErrorDirCreate, wzTarget, -1);
						if (!pErr) return E_OUTOFMEMORY;
						pThis->m_pErrors->Add(pErr);
						/* should also create a file one so the person knows that the file wasn't created 
						CMsmError *pErr = new CMsmError(msmErrorDirCreate, p*zFilename, -1);
						if (!pErr) return E_OUTOFMEMORY;
						m_pErrors->Add(pErr);*/
					}

					// return 0 to skip the file
					iResult = 0;
				}
			}
			else	// failed to generate a file path
			{
				pThis->FormattedLog(L">> Error: Failed to determine target path for file [%hs]\r\n", pszFileName);

				// return 0 to skip the file
				iResult = 0;
			}

			break;
		}
	case fdintPARTIAL_FILE:
	case fdintNEXT_CABINET:
		// only valid when spanning cabinets, and that is not allowed in the mergemod schema
		pThis->FormattedLog(L">> Error: MergeModule.CABinet is part of a CAB set or contains a partial file.\r\n");
		iResult = -1;
		break;
	case fdintENUMERATE:
	case fdintCABINET_INFO:
		// no action needed for these messages.
		iResult = TRUE;
		break;
	default:
		TRACEA(">> Warning: Unknown FDI notification command [%d] while extracting files from CABinet.\r\n", iNotification);
		iResult = 0;
		break;
	};

	return iResult;
}	// end of ExtractFileCallback()

///////////////////////////////////////////////////////////
// ExtractFilePath
// Pre: szFileKey is a first column in the file table
// Pos: szPath is the path to extract the file to
UINT CMsmMerge::ExtractFilePath(LPCWSTR wzFileKey, LPWSTR wzPath)
{
	ASSERT(wzFileKey);
	ASSERT(wzPath);

	UINT iResult;

	MSIHANDLE hDB = NULL;

	// this is goofy logic, but for backwards compatibility we must keep it
	// for non-ex versions of the object or plain ExtractFiles calls
	if (!m_fExVersion || m_fUseDBForPath == -1)
	{	
		// if database is open use 
		if (m_hDatabase)
			hDB = m_hDatabase;
		else if (m_hModule)	// use the module to extract from
			hDB = m_hModule;
		else	// nothing is open
			return ERROR_INVALID_HANDLE;
	}
	else
	{
		if (m_fUseDBForPath == 1)
			hDB = m_hDatabase;
		else
			hDB = m_hModule;
		if (hDB == 0)
			return ERROR_INVALID_HANDLE;		
	}	
		

	// get the path to the file
	size_t cchPath = MAX_PATH;	// always max path
	iResult = MsiDBUtils::GetFilePathW(hDB, wzFileKey, wzPath, &cchPath, m_fUseLFNExtract);

	// if we've got a path to this file key
	if (ERROR_SUCCESS == iResult)
	{
		WCHAR wzBuffer[MAX_PATH*2];

		// copy base path then all of the path
		wcscpy(wzBuffer, m_pwzBasePath);
		wcscat(wzBuffer, wzPath);

		// copy it back to path (!!! this is wasteful)
		if (wcslen(wzBuffer) > MAX_PATH)
		{
			wzPath[0] = L'\0';
			return ERROR_FILENAME_EXCED_RANGE;
		}
		wcscpy(wzPath, wzBuffer);
	}

	return iResult;
}	// end of ExtractFilePath

///////////////////////////////////////////////////////////
// FormattedLog
// Pre:	formatted string does not exceed 1024 characters
// Pos:	if file is open formatted string is written
HRESULT CMsmMerge::FormattedLog(LPCWSTR wzFormatter, ...) const
{
	// if the log file is not open
	if (INVALID_HANDLE_VALUE == m_hFileLog)
		return S_OK;	// bail everything's okay

	// check for bad args
	if (!wzFormatter) 
		return E_INVALIDARG;

	// buffer to log
	WCHAR wzLogBuffer[1025] = {0};
	size_t cchBuffer = 0;

	// format the log buffer
	va_list listLog;
	va_start(listLog, wzFormatter);
	_vsnwprintf(wzLogBuffer, 1024, wzFormatter, listLog);
	TRACE(wzLogBuffer);

	// get length of buffer
	cchBuffer = wcslen(wzLogBuffer);

	BOOL bResult = TRUE;		// assume write will be okay

	// if there is something to write write it
	if (cchBuffer > 0)
	{
		// write to file
		size_t cchDiscard= 2049;
		char szLogBuffer[2049];
		WideToAnsi(wzLogBuffer, szLogBuffer, &cchDiscard);

		DWORD cchBytesToWrite = static_cast<DWORD>(cchDiscard);
		bResult = WriteFile(m_hFileLog, szLogBuffer, static_cast<DWORD>(cchBuffer), &cchBytesToWrite, NULL);
	}

	// return error status
	return (bResult) ? S_OK : E_FAIL;
}	// end of FormattedLog

///////////////////////////////////////////////////////////////////////
// CheckError
void CMsmMerge::CheckError(UINT iError, LPCWSTR wzLogError) const
{
	if (ERROR_SUCCESS != iError)
		throw CLocalError(iError, wzLogError);
}	// end of CheckError


bool CMsmMerge::PrepareIgnoreTable(CQuery &qIgnore)
{
	// create the private (temporary) ignore table
	CQuery qCreatePrivateIgnore;
	CQuery qInsertIgnore;
	if (ERROR_SUCCESS != qCreatePrivateIgnore.OpenExecute(m_hModule, 0, g_sqlCreateMergeIgnore))
	{	
		FormattedLog(L">> Error: Failed to create temprorary table.");
		return false;
	}
	if (ERROR_SUCCESS != qInsertIgnore.OpenExecute(m_hModule, 0, g_sqlInsertMergeIgnore))
	{	
		FormattedLog(L">> Error: Failed to insert into temporary table.");
		return false;
	}
		
	for (int i=0; i < g_cwzIgnoreTables; i++)
	{
		PMSIHANDLE hInsertRec = ::MsiCreateRecord(2);
		::MsiRecordSetString(hInsertRec, 1, g_rgwzIgnoreTables[i]);
		::MsiRecordSetInteger(hInsertRec, 2, 0);
		qInsertIgnore.Modify(MSIMODIFY_INSERT, hInsertRec);
	}
	
	// see if we have a ModuleIgnoreTable table
 	if (MsiDBUtils::TableExistsW(g_wzModuleIgnoreTable, m_hModule))
	{
		// show some log information
		FormattedLog(L"Processing ModuleIgnoreTable table.\r\n");

		int cPrimaryKeys = 1;
		CQuery qQuerySub;

		if (m_fModuleConfigurationEnabled)
		{
			if (ERROR_SUCCESS != PrepareTableForSubstitution(g_wzModuleIgnoreTable, cPrimaryKeys, qQuerySub))
			{
				FormattedLog(L">> Error: Could not configure the ModuleIgnoreTable.\r\n");
				return false;
			}
		}

		CQuery qReadIgnore;
		// open the view
		if (ERROR_SUCCESS != qReadIgnore.OpenExecute(m_hModule, 0, g_sqlMoveIgnoreTable))
		{	
			FormattedLog(TEXT(">> Error: Failed to open view on ModuleIgnoreTable.\r\n"));
			return false;
		}
			
		PMSIHANDLE hRec;
		PMSIHANDLE hTypeRec;
		qReadIgnore.GetColumnInfo(MSICOLINFO_TYPES, &hTypeRec);
		while (ERROR_SUCCESS == qReadIgnore.Fetch(&hRec))
		{
			if (m_fModuleConfigurationEnabled)
			{
				// Any extra columns in the module are irrelevant, so don't need to check for column resequencing
				if (ERROR_SUCCESS != PerformModuleSubstitutionOnRec(g_wzModuleIgnoreTable, cPrimaryKeys, qQuerySub, hTypeRec, hRec))
				{
					FormattedLog(L">> Error: Could not Configure a record in the ModuleIgnoreTable\r\n");
					// this is not the ideal way to handle this situation, but returning failure is not
					// enough to trigger an E_FAIL return code. in the future, pass the error
					// back up cleanly.
					throw (UINT)E_FAIL;
					break;
				}
			}
			qInsertIgnore.Modify(MSIMODIFY_INSERT, hRec);
		}
	}	

	// query the ignore table
	if (ERROR_SUCCESS != qIgnore.Open(m_hModule, g_sqlQueryMergeIgnore))
		return false;
	return true;
}

///////////////////////////////////////////////////////////////////////
// CheckIgnore
bool CMsmMerge::IgnoreTable(CQuery *qIgnore, LPCWSTR wzTable, bool fOnlyExplicit)
{
	if (!qIgnore) return false;
	PMSIHANDLE hExecRec = ::MsiCreateRecord(1);
	::MsiRecordSetString(hExecRec, 1, wzTable);
	qIgnore->Execute(hExecRec);
	switch (qIgnore->Fetch(&hExecRec))
	{
	case ERROR_SUCCESS:
	{
		// only log if marked to log
		bool fLog = (1 == ::MsiRecordGetInteger(hExecRec, 2));
		if (fLog)
			FormattedLog(L"Explicitly Ignoring Table: %ls.\r\n", wzTable);

		// if fOnlyExplicit, don't ignore if its an unlogged ignore
		return (fOnlyExplicit ? fLog : true);
	}
	case ERROR_NO_MORE_ITEMS:
		return false;
	default:
		FormattedLog(L">> Error: Unable to query IgnoreTable for %ls. Assuming don't ignore.\r\n", wzTable);
		return false;
	}	
	return false;
}

///////////////////////////////////////////////////////////////////////
// ClearErrors
// Pre:	none
// Pos:	errors are removed
void CMsmMerge::ClearErrors()
{
	// if there is an error enumerator
	if (m_pErrors)
	{
		// release the error collection
		m_pErrors->Release();
		m_pErrors = NULL;
	}
}	// end of ClearErrors

///////////////////////////////////////////////////////////////////////
// iterates over everything in the CAB, returning 
HRESULT CMsmMerge::get_ModuleFiles(IMsmStrings** ppFiles)
{
	TRACEA("CMsmMerge::GetModuleFiles called");
	FormattedLog(L"Module file list requested...\r\n");

	if (!ppFiles)
	{
		TRACEA(">> Error: null argument");
		return E_INVALIDARG;
	};

	// init to failure
	*ppFiles = NULL;
	
	// ensure that the module is open
	if (!m_hModule) 
	{
		TRACEA(">> Error: No module open");
		FormattedLog(L">> Error: no module open...\r\n");
		return E_FAIL;
	}

	CMsmStrings *pFileList = new CMsmStrings();

	// first check to see if there is a File table.
	if (MSICONDITION_TRUE != ::MsiDatabaseIsTablePersistentW(m_hModule, L"File")) 
	{
		// if not, create an empty string enumerator. This makes no file table
		// equivalent to an empty file table, namely, "no files"
		*ppFiles = pFileList;
		return S_OK;
	};

	// open a query on all files
	CQuery qFiles;
	qFiles.OpenExecute(m_hModule, NULL, g_sqlAllFiles);
	DWORD cchFilename = 80;
	WCHAR wzFilename[80];
	PMSIHANDLE hFileRec;
	UINT iResult;

	while (ERROR_SUCCESS == (iResult = qFiles.Fetch(&hFileRec))) 
	{
		cchFilename = 80;
		::MsiRecordGetStringW(hFileRec, 1, wzFilename, &cchFilename);

		// add string to the list
		iResult = pFileList->Add(wzFilename);
		if (FAILED(iResult))
		{ 
			delete pFileList;
			return iResult;
		}
		FormattedLog(L"   o Retrieved file [%ls]...\r\n", wzFilename);
	}

	if (ERROR_NO_MORE_ITEMS != iResult) {
		delete pFileList;
		return HRESULT_FROM_WIN32(iResult);
	}

	// don't addref, because we are completely done with the object
	// when caller releases, its free
	*ppFiles = pFileList;

	FormattedLog(L"Module file list complete...\r\n");
	return S_OK;
}	

const WCHAR g_sqlConfigItems[] = L"SELECT `Name`, `Format`, `Type`, `ContextData`, `DefaultValue`, `Attributes`, `DisplayName`, `Description`, `HelpLocation`, `HelpKeyword` FROM `ModuleConfiguration`";
HRESULT CMsmMerge::get_ConfigurableItems(IMsmConfigurableItems** piConfigurableItems)
{
	TRACEA("CMsmMerge::get_ConfigurableItems called");
	FormattedLog(L"Module configurable item list requested...\r\n");

	if (!piConfigurableItems)
	{
		TRACEA(">> Error: null argument");
		return E_INVALIDARG;
	};

	// init to failure
	*piConfigurableItems = NULL;
	
	// ensure that the module is open
	if (!m_hModule) 
	{
		TRACEA(">> Error: No module open");
		FormattedLog(L">> Error: no module open.\r\n");
		return E_FAIL;
	}

	CMsmConfigurableItems* pConfigurableItems = new CMsmConfigurableItems();
	if (!pConfigurableItems)
		return E_OUTOFMEMORY;
	
	// first check to see if there is a ModuleConfiguration table.
	if (MSICONDITION_TRUE != ::MsiDatabaseIsTablePersistentW(m_hModule, L"ModuleConfiguration")) 
	{
		// if not, create an empty string enumerator. This makes no config table
		// equivalent to an empty config table, namely, "no items"
		*piConfigurableItems = pConfigurableItems;
		return S_OK;
	};

	// open a query on all items
	CQuery qItems;
	qItems.OpenExecute(m_hModule, NULL, g_sqlConfigItems);
	PMSIHANDLE hItemRec;
	UINT iResult = 0;

	// declared outside the loop so memory can be reused
	WCHAR *wzName = NULL;
	WCHAR *wzType = NULL;
	WCHAR *wzContext = NULL;
	WCHAR *wzDefaultValue = NULL;
	WCHAR *wzDisplayName = NULL;
	WCHAR *wzDescription = NULL;
	WCHAR *wzHelpLocation = NULL;
	WCHAR *wzHelpKeyword = NULL;
	DWORD cchName = 0;
	DWORD cchType = 0;
	DWORD cchContext = 0;
	DWORD cchDefaultValue = 0;
	DWORD cchDisplayName = 0;
	DWORD cchDescription = 0;
	DWORD cchHelpLocation = 0;
	DWORD cchHelpKeyword = 0;

	while (ERROR_SUCCESS == (iResult = qItems.Fetch(&hItemRec))) 
	{
		short iFormat = 0;
		unsigned int iAttributes = 0;

		// retrieve data from record.
		if(ERROR_SUCCESS != (iResult = RecordGetString(hItemRec, 1, &wzName, &cchName)))
			break;
		iFormat = static_cast<short>(MsiRecordGetInteger(hItemRec, 2));
		if (ERROR_SUCCESS != (iResult = RecordGetString(hItemRec, 3, &wzType, &cchType)))
			break;
		if (ERROR_SUCCESS != (iResult = RecordGetString(hItemRec, 4, &wzContext, &cchContext)))
			break;
		if (ERROR_SUCCESS != (iResult = RecordGetString(hItemRec, 5, &wzDefaultValue, &cchDefaultValue)))
			break;
		iAttributes = MsiRecordGetInteger(hItemRec, 6);
		if (ERROR_SUCCESS != (iResult = RecordGetString(hItemRec, 7, &wzDisplayName, &cchDisplayName)))
			break;
		if (ERROR_SUCCESS != (iResult = RecordGetString(hItemRec, 8, &wzDescription, &cchDescription)))
			break;
		if (ERROR_SUCCESS != (iResult = RecordGetString(hItemRec, 9, &wzHelpLocation, &cchHelpLocation)))
			break;
		if (ERROR_SUCCESS != (iResult = RecordGetString(hItemRec, 10, &wzHelpKeyword, &cchHelpKeyword)))
			break;
		
		CMsmConfigItem *pItem = new CMsmConfigItem;
		if (!pItem || !pItem->Configure(wzName, static_cast<msmConfigurableItemFormat>(iFormat), wzType, wzContext, wzDefaultValue, iAttributes, wzDisplayName, wzDescription, wzHelpLocation, wzHelpKeyword))
		{
			// out of memory while creating and initializing object. 
			if (pItem)
				delete pItem;
				
			// Deleting the collection causes it to release every object that has been added to it already.
    		iResult = E_OUTOFMEMORY;
			break;
		}

		// add the new item to the enumerator
		if (!pConfigurableItems->Add(pItem))
		{
			delete pItem;
    		
			iResult = E_OUTOFMEMORY;
			break;
		}
		
		FormattedLog(L"   o Retrieved item [%ls]...\r\n", wzName);
	}

	if (wzName) delete[] wzName;
	if (wzType) delete[] wzType;
	if (wzContext) delete[] wzContext;
	if (wzDefaultValue) delete[] wzDefaultValue;
	if (wzDisplayName) delete[] wzDisplayName;
	if (wzDescription) delete[] wzDescription;

	if (ERROR_NO_MORE_ITEMS != iResult) 
	{
		delete pConfigurableItems;
		return HRESULT_FROM_WIN32(iResult);
	}

	// don't addref, because we are completely done with the object
	// when caller releases, its free
	*piConfigurableItems = pConfigurableItems;

	FormattedLog(L"Module item list complete...\r\n");
	return S_OK;
}



// RecordGetString()
// retrieves the WCHAR string from a record, placing it into the temp buffer
// or the provided buffer.
UINT CMsmMerge::RecordGetString(MSIHANDLE hRecord, const int iCol, WCHAR** pwzBuffer, DWORD *cchBuffer, DWORD *cchLen) const
{
	WCHAR **pwzDest;
	DWORD *pcchDest;
	DWORD cchTemp = 0;

	// if we are provided a buffer, we use it, otherwise we use the temp buffer
	if (pwzBuffer)
	{
		pwzDest = pwzBuffer;
		pcchDest = (cchBuffer) ? cchBuffer : &cchTemp;
	}
	else
	{
		pwzDest = &m_wzBuffer;
		pcchDest = &m_cchBuffer;
	}

	if (!*pwzDest)
	{
		*pwzDest = new WCHAR[72];
		if (!*pwzDest)
			return E_OUTOFMEMORY;
		*pcchDest = 72;
	}

	cchTemp = *pcchDest;
	UINT iStat = ::MsiRecordGetStringW(hRecord, iCol, *pwzDest, &cchTemp);
	switch (iStat)
	{
	case ERROR_SUCCESS:
		if (cchLen)
			*cchLen = cchTemp;
		return iStat;
	case ERROR_MORE_DATA:
		delete[] *pwzDest;
		*pwzDest = new WCHAR[*pcchDest = ++cchTemp];
		if (!*pwzDest)
			return E_OUTOFMEMORY;
		iStat = ::MsiRecordGetStringW(hRecord, iCol, *pwzDest, &cchTemp);
		if (cchLen)
			*cchLen = cchTemp;
		return iStat;
	default:
		return iStat;
	}
	return ERROR_SUCCESS;
};

/////////////////////////////////////////////////////////////////////////////
// These functions are called by the FDI library.
void *CMsmMerge::FDIAlloc(ULONG size) { return static_cast<void *>(new unsigned char[size]); };

void CMsmMerge::FDIFree(void *mem) { delete[] mem; };

INT_PTR FAR DIAMONDAPI CMsmMerge::FDIOpen(char FAR *pszFile, int oflag, int pmode)
{
	// if FDI asks for some crazy mode (in low memory situation it could ask
	// for a scratch file) fail. 
	if ((oflag != (/*_O_BINARY*/ 0x8000 | /*_O_RDONLY*/ 0x0000)) || (pmode != (_S_IREAD | _S_IWRITE)))
		return -1;
	
	return reinterpret_cast<INT_PTR>(CreateFileA(pszFile,		// file name
				   GENERIC_READ,    // we want to read
				   FILE_SHARE_READ, // we'll let people share this
				   NULL,			// ignore security
				   OPEN_EXISTING,	// must already exist
				   0L,				// don't care about attributes
				   NULL));			// no template file
}

UINT FAR DIAMONDAPI CMsmMerge::FDIRead(INT_PTR hf, void FAR *pv, UINT cb)
{
	DWORD cbRead = 0;
	BOOL bRes = ReadFile(reinterpret_cast<HANDLE>(hf), pv, cb, &cbRead, NULL);
	return bRes ? cbRead : -1;
}

UINT FAR DIAMONDAPI CMsmMerge::FDIWrite(INT_PTR hf, void FAR *pv, UINT cb)
{
	unsigned long cbWritten;
	BOOL bRes;
	bRes = WriteFile(reinterpret_cast<HANDLE>(hf), pv, cb, &cbWritten, NULL);
	return bRes ? cbWritten : -1;
}

int FAR DIAMONDAPI CMsmMerge::FDIClose(INT_PTR hf)
{
	return CloseHandle(reinterpret_cast<HANDLE>(hf)) ? 0 : -1;
}

long FAR DIAMONDAPI CMsmMerge::FDISeek(INT_PTR hf, long dist, int seektype)
{
	DWORD dwMoveMethod;
	switch (seektype)
	{
		case 0 /* SEEK_SET */ :
			dwMoveMethod = FILE_BEGIN;
			break;
		case 1 /* SEEK_CUR */ :
			dwMoveMethod = FILE_CURRENT;
			break;
		case 2 /* SEEK_END */ :
			dwMoveMethod = FILE_END;
			break;
		default :
			return -1;
	}
	// SetFilePointer returns -1 if it fails (this will cause FDI to quit with an
	// FDIERROR_USER_ABORT error. (Unless this happens while working on a cabinet,
	// in which case FDI returns FDIERROR_CORRUPT_CABINET)
	return SetFilePointer(reinterpret_cast<HANDLE>(hf), dist, NULL, dwMoveMethod);
}

/////////////////////////////////////////////////////////////////////////////
// These functions ARE the FDI Library, controlling the load/unload of the 
// DLL at run-time.
static HINSTANCE hCabinetDll;

// pointers to the functions in the DLL
typedef BOOL (FAR DIAMONDAPI *PFNFDIDESTROY)(VOID*);
typedef HFDI (FAR DIAMONDAPI *PFNFDICREATE)(PFNALLOC, PFNFREE, PFNOPEN, PFNREAD, 
											PFNWRITE, PFNCLOSE, PFNSEEK, int, PERF);
typedef BOOL (FAR DIAMONDAPI *PFNFDIISCABINET)(HFDI, INT_PTR, PFDICABINETINFO);
typedef BOOL (FAR DIAMONDAPI *PFNFDICOPY)(HFDI, char *, char *, int, PFNFDINOTIFY, 
										  PFNFDIDECRYPT, void *);
static PFNFDICOPY pfnFDICopy;
static PFNFDIISCABINET pfnFDIIsCabinet;
static PFNFDIDESTROY pfnFDIDestroy;
static PFNFDICREATE pfnFDICreate;

HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf)
{
    HFDI hfdi;

	// always call ANSI LoadLibrary. CABINET.DLL will not be localized, so we're OK on NT.
    hCabinetDll = LoadLibraryA("CABINET");
    if (hCabinetDll == NULL)
		return(NULL);
    
	// retrieve all address functions
	pfnFDICreate = reinterpret_cast<PFNFDICREATE>(GetProcAddress(hCabinetDll,"FDICreate"));
    pfnFDICopy = reinterpret_cast<PFNFDICOPY>(GetProcAddress(hCabinetDll,"FDICopy"));
    pfnFDIIsCabinet = reinterpret_cast<PFNFDIISCABINET>(GetProcAddress(hCabinetDll,"FDIIsCabinet"));
	pfnFDIDestroy = reinterpret_cast<PFNFDIDESTROY>(GetProcAddress(hCabinetDll,"FDIDestroy"));

    if ((pfnFDICreate == NULL) ||
        (pfnFDICopy == NULL) ||
        (pfnFDIIsCabinet == NULL) ||
        (pfnFDIDestroy == NULL))
    {
        FreeLibrary(hCabinetDll);
        return(NULL);
    }

    hfdi = pfnFDICreate(pfnalloc,pfnfree,
            pfnopen,pfnread,pfnwrite,pfnclose,pfnseek,cpuType,perf);

    if (hfdi == NULL)
        FreeLibrary(hCabinetDll);


    return(hfdi);
}

BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 INT_PTR         hf,
                                 PFDICABINETINFO pfdici)
{
    if (pfnFDIIsCabinet == NULL)
        return(FALSE);

    return(pfnFDIIsCabinet(hfdi,hf,pfdici));
}



BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char         *pszCabinet,
                            char         *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void         *pvUser)
{
    if (pfnFDICopy == NULL)
        return(FALSE);

    return(pfnFDICopy(hfdi,pszCabinet,pszCabPath,flags,pfnfdin,pfnfdid,pvUser));
}


BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi)
{
    if (pfnFDIDestroy == NULL)
		return(FALSE);
    
    BOOL rc = pfnFDIDestroy(hfdi);
    if (rc == TRUE)
		FreeLibrary(hCabinetDll);

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mergemod.cpp ===
/////////////////////////////////////////////////////////////////////////////
// mergemod.cpp
//		Implements Dll* functions and class factory
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#include "mergemod.h"
#include "merge.h"
#include "..\common\trace.h"
#include "..\common\regutil.h"
#include "..\common\utils.h"
#include "..\..\common\trace.cpp"

#include "version.h"


///////////////////////////////////////////////////////////
// global variables
HINSTANCE g_hInstance;
bool g_fWin9X;
CRITICAL_SECTION g_csFactory;

long g_cComponents;
long g_cServerLocks;

// structures not in header files
#ifndef DLLVER_PLATFORM_NT
typedef struct _DllVersionInfo
{
        DWORD cbSize;
        DWORD dwMajorVersion;                   // Major version
        DWORD dwMinorVersion;                   // Minor version
        DWORD dwBuildNumber;                    // Build number
        DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT
#endif

// non-exported functions
void CheckWinVersion();

/////////////////////////////////////////////////////////////////////////////
// CClassFactory
class CClassFactory : public IClassFactory
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv);
	virtual ULONG __stdcall AddRef();
	virtual ULONG __stdcall Release();

	// interface IClassFactory
	virtual HRESULT __stdcall CreateInstance(IUnknown* punkOuter, const IID& iid, void** ppv);
	virtual HRESULT __stdcall LockServer(BOOL bLock);
	
	// constructor/destructor
	CClassFactory(REFCLSID rclsid);
	~CClassFactory();

private:
	long m_cRef;		// reference count
	CLSID m_clsid;
};

///////////////////////////////////////////////////////////
// constructor - component
CClassFactory::CClassFactory(REFCLSID rclsid)
{
	TRACEA("CClassFactory::constructor - creating factory for %x.\n", rclsid);

	// initial count
	m_clsid = rclsid;
	m_cRef = 1;

	InterlockedIncrement(&g_cComponents);
}	// end of constructor


///////////////////////////////////////////////////////////
// destructor - component
CClassFactory::~CClassFactory()
{
	TRACEA("CClassFactory::destructor - called.\n");
	ASSERT(0 == m_cRef);

	InterlockedDecrement(&g_cComponents);
}	// end of destructor


///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT __stdcall CClassFactory::QueryInterface(const IID& iid, void** ppv)
{
	TRACEA("CClassFactory::QueryInterface - called, IID: %d.\n", iid);

	// get class factory interface
	if (iid == IID_IUnknown || iid == IID_IClassFactory)
		*ppv = static_cast<IClassFactory*>(this);
	else	// tried to get a non-class factory interface
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface


///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG __stdcall CClassFactory::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef


///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG __stdcall CClassFactory::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


///////////////////////////////////////////////////////////
// CreateInstance - creates a component
HRESULT __stdcall CClassFactory::CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
	TRACEA("CClassFactory::CreateInstance - called, IID: %d.\n", riid);

	// if there is an invalid pointer
	if(ppv == NULL )
		return E_INVALIDARG;
	
	*ppv = NULL;	// be nice and null the pointer

	// no aggregation
	if (punkOuter)
		return CLASS_E_NOAGGREGATION;

	// protect the memory allocation
	EnterCriticalSection(&g_csFactory);

	// try to create the component
	IUnknown* punk = NULL;
	
	if (CLSID_MsmMerge == m_clsid)
	{
		TRACEA("CClassFactory::CreateInstance - created MsmMerge.\n");
		punk = (IMsmMerge*) new CMsmMerge(false);
	}
	else if (CLSID_MsmMerge2 == m_clsid)
	{
		TRACEA("CClassFactory::CreateInstance - created MsmMerge2.\n");
		punk = (IMsmMerge2*) new CMsmMerge(true);
	}
	else
		return E_NOINTERFACE;

	// memory allocation is done
	LeaveCriticalSection(&g_csFactory);

	if (!punk)
		return E_OUTOFMEMORY;

	// get the requested interface
	HRESULT hr = punk->QueryInterface(riid, ppv);

	// release IUnknown
	punk->Release();
	return hr;
}	// end of CreateInstance


///////////////////////////////////////////////////////////
// LockServer - locks or unlocks the server
HRESULT __stdcall CClassFactory::LockServer(BOOL bLock)
{
	// if we're to lock
	if (bLock)
		InterlockedIncrement(&g_cServerLocks);	// up the lock count
	else	// unlock
		InterlockedDecrement(&g_cServerLocks);	// down the lock count

	// if the locks are invalid
	if (g_cServerLocks < 0)
		return S_FALSE;			// show something is wrong

	// else return okay
	return S_OK;
}	// end of LockServer()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Points

///////////////////////////////////////////////////////////
// DllMain - entry point to DLL
BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved)
{
	TRACEA("DllMain - called.\n");

	// if attaching dll
	if (DLL_PROCESS_ATTACH == dwReason)
	{
		TRACEA("Attached to mergemod.dll version %d.%d.%d.%d", rmj, rmm, rup, rin);
		CheckWinVersion();
		g_hInstance = (HMODULE)hModule;
		InitializeCriticalSection(&g_csFactory);
	}
	else if(DLL_PROCESS_DETACH == dwReason) 
	{
		TRACEA("DllMain - being unloaded.\n");
		DeleteCriticalSection(&g_csFactory);
	}

	return TRUE;
}	// DllMain


///////////////////////////////////////////////////////////
// DllCanUnloadNow - returns if dll can unload yet or not
STDAPI DllCanUnloadNow()
{
	TRACEA("DllCanUnloadNow - called.\n");

	// if there are no components loaded and no locks
	if ((0 == g_cComponents) && (0 == g_cServerLocks))
		return S_OK;
	else	// someone is still using it don't let go
		return S_FALSE;
}	// DLLCanUnloadNow


///////////////////////////////////////////////////////////
// DllGetClassObject - get a class factory and interface
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppv)
{
	TRACEA("DllGetClassObject - called, CLSID: %d, IID: %d.\n", rclsid, riid);

	// if this clsid is not supported
	if (CLSID_MsmMerge != rclsid && CLSID_MsmMerge2 != rclsid)
		return CLASS_E_CLASSNOTAVAILABLE;

	// try to create a class factory
	CClassFactory* pFactory = new CClassFactory(rclsid);
	if (!pFactory)
		return E_OUTOFMEMORY;

	// get the requested interface
	HRESULT hr = pFactory->QueryInterface(riid, ppv);
	pFactory->Release();

	return hr;
}	// end of DllGetClassObject


///////////////////////////////////////////////////////////
// DllRegsiterServer - registers component
STDAPI DllRegisterServer()
{

	HRESULT hr = S_OK;		// assume everything will be okay
	HRESULT hrFinal = S_OK;	// assume everything will be okay in the end
	WCHAR wzFilename[MAX_PATH] = L"";
	char szFilename[MAX_PATH] = "";

	if (g_fWin9X) 
	{
		// wint9X
		// get the path to this dll
		if (g_hInstance && ::GetModuleFileNameA(g_hInstance, szFilename, MAX_PATH-1))
		{
			szFilename[MAX_PATH-1] = 0;
			size_t cchFileName = MAX_PATH;
			AnsiToWide(szFilename, wzFilename, &cchFileName);

			// try to register CMsmMerge as InprocServer32
			hr = RegisterCoObject9X(CLSID_MsmMerge,
										 "MSM Merge COM Server",
										 "MSM.Merge", 1,
										 szFilename, NULL);
			hr = RegisterCoObject9X(CLSID_MsmMerge2,
										 "MSM Merge Extended COM Server",
										 "MSM.Merge2", 1,
										 szFilename, NULL);
		}
		else
			hr = E_HANDLE;

	}
	else
	{
		// winnt
		if (g_hInstance && ::GetModuleFileNameW(g_hInstance, wzFilename, MAX_PATH-1))
		{
			wzFilename[MAX_PATH-1] = 0;
			// try to register CMsmMerge as InprocServer32
			hr = RegisterCoObject(CLSID_MsmMerge,
										 L"MSM Merge COM Server",
										 L"MSM.Merge", 1,
										 wzFilename, NULL);
			hr = RegisterCoObject(CLSID_MsmMerge2,
										 L"MSM Merge Extended COM Server",
										 L"MSM.Merge2", 1,
										 wzFilename, NULL);
		}
		else
			hr = E_HANDLE;
	}

	if (FAILED(hr))
	{
			TRACEA("DllRegisterServer - Failed to register COM object for '%ls'\n", wzFilename);
			ERRMSG(hr);
			hrFinal = hr;	// set that something went wrong
	}
	else 
	{
		// register embedded TypeLib
		ITypeLib *pTypeLib = NULL;
		hr =  LoadTypeLib(wzFilename, &pTypeLib);	
		
		if (SUCCEEDED(hr))
		{
			hr = RegisterTypeLib(pTypeLib, wzFilename, NULL);

			if(FAILED(hr)) 
			{
				TRACEA("DllRegisterServer - Failed to register TypeLib for '%ls'\n", wzFilename);
				ERRMSG(hr);
				hrFinal = hr;	// set that something went wrong
			}
		}
		else	// failed to load TypeLib
		{
			TRACEA("DllRegisterServer - Failed to load TypeLib as resource from '%ls'\n", wzFilename);
			ERRMSG(hr);
			hrFinal = hr;	// set that something went wrong
		}

		// if the TypeLib was loaded release it
		if(pTypeLib)
			pTypeLib->Release();
	}


	return hrFinal;
}	// end of DllRegisterServer

///////////////////////////////////////////////////////////
// DllUnregsiterServer - unregisters component
STDAPI DllUnregisterServer()
{
	HRESULT hr = S_OK;		// assume everything will be okay
	HRESULT hrFinal = S_OK;	// assume everything will be okay in the end
	WCHAR wzFilename[MAX_PATH] = L"";
	CHAR szFilename[MAX_PATH] = "";

	// unregister MsmMerge object
	if (g_fWin9X) 
	{
		hr = UnregisterCoObject9X(CLSID_MsmMerge, TRUE);
		hr = UnregisterCoObject9X(CLSID_MsmMerge2, TRUE);
	}
	else
	{
		hr = UnregisterCoObject(CLSID_MsmMerge, TRUE);
		hr = UnregisterCoObject(CLSID_MsmMerge2, TRUE);
	}

	if (FAILED(hr))
	{
		TRACEA("DllUnregisterServer - Failed to unregister CLSID_MsmMerge.\n");
		hrFinal = hr;	// set that something went wrong
	}

	// get the path to this dll
	if (g_fWin9X) {
		// wint9X
		if (g_hInstance && ::GetModuleFileNameA(g_hInstance, szFilename, MAX_PATH-1))
		{
			szFilename[MAX_PATH-1] = 0;
			size_t cchFileName = MAX_PATH;
			AnsiToWide(szFilename, wzFilename, &cchFileName);
		}
	}
	else
	{
		// winnt
		if (g_hInstance)
		{
			::GetModuleFileNameW(g_hInstance, wzFilename, MAX_PATH-1);
			wzFilename[MAX_PATH-1] = 0;
		}
	}

	if (wzFilename[0])
	{
		// unregister embedded TypeLib
		ITypeLib *pTypeLib = NULL;
		hr =  LoadTypeLib(wzFilename, &pTypeLib);	
		if (SUCCEEDED(hr))
		{
			// none of the return codes from UnRegisterTypeLib are useful, as it should
			// not be a failure if the typelib was not registered, etc.
			hr = UnRegisterTypeLib(LIBID_MsmMergeTypeLib, 1, 0, 0, SYS_WIN32);
		}
		else	// failed to load TypeLib
		{
			TRACEA("DllUnregisterServer  - Failed to load TypeLib as resource from '%ls'\n", wzFilename);
			ERRMSG(hr);
			hrFinal = hr;	// set that something went wrong
		}

		// if the TypeLib was loaded release it
		if(pTypeLib)
			pTypeLib->Release();
	}

	return hrFinal;
}

///////////////////////////////////////////////////////////////////////
// checks the OS version to see if we're on Win9X. If we are, we need
// to map system calls to ANSI, because everything internal is unicode.
void CheckWinVersion() {
	OSVERSIONINFOA osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	::GetVersionExA(&osviVersion); // fails only if size set wrong
	if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
		g_fWin9X = true;
}

HRESULT LoadTypeLibFromInstance(ITypeLib** pTypeLib ) 
{
	WCHAR wzFilename[MAX_PATH];
	CHAR szFilename[MAX_PATH];

	// get the path to this dll
	if (g_fWin9X) {
		// win9X
		::GetModuleFileNameA(g_hInstance, szFilename, MAX_PATH-1);
		szFilename[MAX_PATH-1] = 0;
		size_t cchFileName = MAX_PATH;
		AnsiToWide(szFilename, wzFilename, &cchFileName);
	}
	else
	{
		// winnt
		::GetModuleFileNameW(g_hInstance, wzFilename, MAX_PATH-1);
		wzFilename[MAX_PATH-1] = 0;
	}
	return LoadTypeLib(wzFilename, pTypeLib);
}

STDAPI DllGetVersion(DLLVERSIONINFO *pverInfo)
{

	if (pverInfo->cbSize < sizeof(DLLVERSIONINFO))
		return E_FAIL;

	pverInfo->dwMajorVersion = rmj;
	pverInfo->dwMinorVersion = rmm;
	pverInfo->dwBuildNumber = rup;
	pverInfo->dwPlatformID = DLLVER_PLATFORM_WINDOWS;
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmcfgitm.h ===
/////////////////////////////////////////////////////////////////////////////
// mmconfig.h
//		Declares IMsmError interface
//		Copyright (C) Microsoft Corp 2000.  All Rights Reserved.
// 

#ifndef __IENUM_MSM_CONFIGITEM__
#define __IENUM_MSM_CONFIGITEM__

#include "mergemod.h"

class CMsmConfigItem : public IMsmConfigurableItem
{

public:
	CMsmConfigItem();
	~CMsmConfigItem();

	// IUnknown interface
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID& iid, void** ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDispatch methods
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT* pctInfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTI);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
														 LCID lcid, DISPID* rgDispID);
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
											   DISPPARAMS* pDispParams, VARIANT* pVarResult,
												EXCEPINFO* pExcepInfo, UINT* puArgErr);
	HRESULT STDMETHODCALLTYPE InitTypeInfo();

	// IMsmError interface
	HRESULT STDMETHODCALLTYPE get_Name(BSTR* Name);
	HRESULT STDMETHODCALLTYPE get_Format(msmConfigurableItemFormat* Format);
	HRESULT STDMETHODCALLTYPE get_Type(BSTR* Type);
	HRESULT STDMETHODCALLTYPE get_Context(BSTR* Context);
	HRESULT STDMETHODCALLTYPE get_DefaultValue(BSTR* DefaultValue);
	HRESULT STDMETHODCALLTYPE get_Attributes(long* Attributes);
	HRESULT STDMETHODCALLTYPE get_DisplayName(BSTR* DisplayName);
	HRESULT STDMETHODCALLTYPE get_Description(BSTR* Description);
	HRESULT STDMETHODCALLTYPE get_HelpLocation(BSTR* HelpLocation);
	HRESULT STDMETHODCALLTYPE get_HelpKeyword(BSTR* HelpKeyword);

	bool CMsmConfigItem::Configure(LPCWSTR wzName, msmConfigurableItemFormat eFormat, LPCWSTR wzType, LPCWSTR wzContext, 
		LPCWSTR wzDefaultValue, long iAttributes, LPCWSTR wzDisplayName, LPCWSTR wzDescription, LPCWSTR wzHelpLocation, LPCWSTR wzHelpKeyword);

private:
	long m_cRef;
	ITypeInfo* m_pTypeInfo;

	msmConfigurableItemFormat m_eFormat;
	long  m_lAttributes;

	WCHAR *m_wzName;
	WCHAR *m_wzType;
	WCHAR *m_wzContext;
	WCHAR *m_wzDefaultValue;
	WCHAR *m_wzDisplayName;
	WCHAR *m_wzDescription;
	WCHAR *m_wzHelpLocation;
	WCHAR *m_wzHelpKeyword;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmdbutil.cpp ===
#include "..\common\dbutils.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\merge.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       merge.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// merge.h
//		Declares IMsmMerge interface
// 

#ifndef __IMSM_MERGE__
#define __IMSM_MERGE__

#include "ctype.h"
#include "fdi.h"

#include "msiquery.h"
#include "..\common\list.h"

#include "mergemod.h"
#include "mmstrs.h"
#include "enum.h"

// forward class declarations
class CMsmDependency;
class CQuery;
class CSeqActList;
class CMsmError;
class CMsmConfigItem;
typedef CCollectionTemplate<CMsmError, IMsmErrors, IMsmError, IEnumMsmError, &IID_IMsmErrors, &IID_IMsmError, &IID_IEnumMsmError> CMsmErrors;
typedef CCollectionTemplate<CMsmDependency, IMsmDependencies, IMsmDependency, IEnumMsmDependency, &IID_IMsmDependencies, &IID_IMsmDependency, &IID_IEnumMsmDependency> CMsmDependencies;
typedef CCollectionTemplate<CMsmConfigItem, IMsmConfigurableItems, IMsmConfigurableItem, IEnumMsmConfigurableItem, &IID_IMsmConfigurableItems, &IID_IMsmConfigurableItem, &IID_IEnumMsmConfigurableItem> CMsmConfigurableItems;

// for internal use only
#define ERROR_MERGE_CONFLICT ERROR_INSTALL_FAILURE		// make this merge conflict error

enum eColumnType {
	ectString,
	ectInteger,
	ectBinary,
	ectUnknown
};

class CMsmMerge : public IMsmMerge, public IMsmGetFiles, public IMsmMerge2
{

public:
	CMsmMerge(bool fExVersion);
	~CMsmMerge();

	// IUnknown interface
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID& iid, void** ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDispatch methods
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT* pctInfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTI);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
														 LCID lcid, DISPID* rgDispID);
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
											   DISPPARAMS* pDispParams, VARIANT* pVarResult,
												EXCEPINFO* pExcepInfo, UINT* puArgErr);
	HRESULT STDMETHODCALLTYPE InitTypeInfo();

	// IMsmMerge interface
	HRESULT STDMETHODCALLTYPE OpenDatabase(const BSTR Path);
	HRESULT STDMETHODCALLTYPE OpenModule(const BSTR Path, const short Language);
	HRESULT STDMETHODCALLTYPE CloseDatabase(const VARIANT_BOOL Commit);
	HRESULT STDMETHODCALLTYPE CloseModule(void);

	HRESULT STDMETHODCALLTYPE OpenLog(const BSTR Path);
	HRESULT STDMETHODCALLTYPE CloseLog(void);
	HRESULT STDMETHODCALLTYPE Log(const BSTR Message);

	HRESULT STDMETHODCALLTYPE get_Errors(IMsmErrors** Errors);
	HRESULT STDMETHODCALLTYPE get_Dependencies(IMsmDependencies** Dependencies);

	HRESULT STDMETHODCALLTYPE Merge(const BSTR Feature, const BSTR RedirectDir);
	HRESULT STDMETHODCALLTYPE Connect(const BSTR Feature);
	HRESULT STDMETHODCALLTYPE ExtractCAB(const BSTR Path);
	HRESULT STDMETHODCALLTYPE ExtractFiles(const BSTR Path);

	// IMsmFiles interface
	HRESULT STDMETHODCALLTYPE get_ModuleFiles(IMsmStrings** Files);

	// IMsmMerge2 interface
	HRESULT STDMETHODCALLTYPE MergeEx(const BSTR Feature, const LPWSTR RedirectDir, IUnknown* pConfiguration);
	HRESULT STDMETHODCALLTYPE ExtractFilesEx(const BSTR Path, VARIANT_BOOL fLongFileNames, IMsmStrings** pFilePaths);
	HRESULT STDMETHODCALLTYPE get_ConfigurableItems(IMsmConfigurableItems** ConfigurableItems);
	HRESULT STDMETHODCALLTYPE CreateSourceImage(const BSTR Path, VARIANT_BOOL fLongFileNames, IMsmStrings** pFilePaths);

private:
	// non-interface methods
	UINT SetHighestFileSequence();						// sets the member variable containing the highest 
														// file sequence number
														
	UINT CheckExclusionTable();							// checks if Merge Module is allowed to merge in
	UINT CheckDependencies();							// fills up the dependency enumerator
	UINT CheckSummaryInfoPlatform(bool &fAllow);        // check 64bit modules for ability to merge

														
	UINT ModuleLanguage(short& rnLanguage);				// language to be returned
														
	// connect fuctions									
	UINT ExecuteConnect(LPCWSTR wzFeature);				// Feature to connect database to
														
	// merge functions									
	UINT ExecuteMerge(LPCWSTR wzFeature,				// Feature to connect database to
					  LPCWSTR wzRedirectDir);			// redirection directory
	UINT MergeTable(LPCWSTR wzFeature,					// Feature to connect database to
					LPCWSTR wzTable);					// table to merge into database
	UINT MergeFileTable(LPCWSTR wzFeature);				// Feature to connect database to

	UINT ReadModuleSequenceTable(enum stnSequenceTableNum stnTable, LPCWSTR wzSourceTable, CSeqActList &lstAllActions, CSeqActList &lstActionPool) const;
	UINT OrderingToSequence(CSeqActList &lstActionPool, CSeqActList &lstSequence) const;
	UINT AssignSequenceNumbers(enum stnSequenceTableNum stnTable, CSeqActList &lstSequence) const;
	UINT WriteDatabaseSequenceTable(enum stnSequenceTableNum stnTable, CSeqActList &lstSequence) const;


	UINT MergeSequenceTable(enum stnSequenceTableNum stnTable,	// index into global array of sequence tables
							CSeqActList &lstDirActions,         // list of actions generated by the directory table
							CQuery *qIgnore);                   // query to ignore table, or NULL.	
	UINT ReplaceFeature(LPCWSTR wzFeature,              // Feature to replease with g_szFeatureReplacement
						MSIHANDLE hRecord);             // record to search and replace g_szFeatureReplacement

	UINT MergeDirectoryTable(LPCWSTR wzDirectory,		// and redirect to new parent directory
							CSeqActList &lstDirActions);// list of actions generated by the directory table
	
	UINT ExtractFilePath(LPCWSTR szFileKey,				// file key to extract file for
								LPWSTR szPath);			// full path to extract to

	HRESULT ExtractFilesCore(const BSTR Path, VARIANT_BOOL fLFN, IMsmStrings **FilePaths);
	HRESULT ExtractCABCore(const WCHAR* Path);

	// logging and other helpful functions
	HRESULT FormattedLog(LPCWSTR wzFormatter,			// format string
							...) const;						// other parameters to save to log

	void CheckError(UINT iError,						// error found
					LPCWSTR wzLogError) const;			// message to log
	void ClearErrors();
	bool PrepareIgnoreTable(CQuery &qIgnore);
	bool IgnoreTable(CQuery *qIgnore,					// pointer to query on ModuleIgnoreTable, or NULL 
					 LPCWSTR wzTable,					// table to check.
					 bool fExplicitOnly = false);       // if true, only ignore if in ModuleIgnoreTable

	// ModuleSubstitution functions
	UINT SplitConfigStringIntoKeyRec(LPWSTR wzKeys, MSIHANDLE hRec, int &cExpectedKeys, int iFirstField) const;

	UINT PrepareModuleSubstitution(CQuery &qTempTable);
	UINT PrepareTableForSubstitution(LPCWSTR wzTable, int& cPrimaryKeys, CQuery &qQuerySub);
	UINT PerformModuleSubstitutionOnRec(LPCWSTR wzTable, int cPrimaryKeys, CQuery& qQuerySub, MSIHANDLE hColmnTypes, MSIHANDLE hRecord);
	UINT PerformTextFieldSubstitution(LPWSTR wzValueTemplate, LPWSTR* wzResult, DWORD* cchResultString);
	UINT PerformIntegerFieldSubstitution(LPWSTR wzValueTemplate, long &lRetValue);
	UINT SubstituteIntoTempTable(LPCWSTR wzTableName, LPCWSTR wzTempName, CQuery& qTarget);
	UINT GetConfigurableItemValue(LPCWSTR wzItem, LPWSTR *wzValue, DWORD* cchBuffer, DWORD* cchLength,	bool& fIsBitfield, long &lValue, long& lMask);
	UINT DeleteOrphanedConfigKeys(CSeqActList& lstDirActions);
	bool IsTableConfigured(LPCWSTR wzTable) const;
	void CleanUpModuleSubstitutionState();
	DWORD GenerateModuleQueryForMerge(const WCHAR* wzTable, const WCHAR* wzExtraColumns, const WCHAR* wzWhereClause, CQuery& queryModule) const;

	// utility functions
	UINT GetColumnNumber(MSIHANDLE hDB, const WCHAR* wzTable, const WCHAR* wzColumn, int &iOutputColumn) const;
	UINT GetColumnNumber(CQuery& qQuery, const WCHAR* wzColumn, int &iOutputColumn) const;
	eColumnType ColumnTypeCharToEnum(WCHAR chType) const;

	// wrappers around callback interface
	HRESULT ProvideIntegerData(LPCWSTR wzName, long *pData);
	HRESULT ProvideTextData(LPCWSTR wzName, BSTR *pData);
	
	// FDI called functions
	static void * FAR DIAMONDAPI FDIAlloc(ULONG size);
	static void FAR DIAMONDAPI FDIFree(void *mem);
	static INT_PTR FAR DIAMONDAPI FDIOpen(char FAR *pszFile, int oflag, int pmode);
	static UINT FAR DIAMONDAPI FDIRead(INT_PTR hf, void FAR *pv, UINT cb);
	static UINT FAR DIAMONDAPI FDIWrite(INT_PTR hf, void FAR *pv, UINT cb);
	static int FAR DIAMONDAPI FDIClose(INT_PTR hf);
	static long FAR DIAMONDAPI FDISeek(INT_PTR hf, long dist, int seektype);

	// FDI Callback
	static INT_PTR ExtractFilesCallback(FDINOTIFICATIONTYPE iNotification, FDINOTIFICATION *pFDINotify);

	long m_cRef;
	ITypeInfo* m_pTypeInfo;
	bool m_fExVersion;

	// database handles
	MSIHANDLE m_hDatabase;				// handle to database being merged into	
	MSIHANDLE m_hModule;				// handle to merge module merging

	BOOL m_bOwnDatabase;				// flag if COM Server opened database
	ULONG m_lHighestFileSequence;		// highest File sequence number in the database
	CMsmStrings* m_plstMergedFiles;     // list of files extracted during this merge

	// ModuleConfiguration information
	bool m_fModuleConfigurationEnabled; // true if the current merge is using module substitution
	CQuery *m_pqGetItemValue;           // query used on temporary table to get an item value
	
	IMsmConfigureModule *m_piConfig;    // callback interface to configure the module
	IDispatch* m_piConfigDispatch;
	DISPID m_iIntDispId;
	DISPID m_iTxtDispId;

	// log handle
	HANDLE m_hFileLog;					// handle to log file

	WCHAR m_wzModuleFilename[MAX_PATH];

	// temporary variables
	LPWSTR m_pwzBasePath;					// temporary path string (valid only when extracting files)
	bool   m_fUseLFNExtract;                // true for LFN, false for SFN extract (valid only during extraction)
	int    m_fUseDBForPath;                 // 1 if database should be used for path extraction, 0 for module, -1 for backwards compat
	CMsmStrings* m_plstExtractedFiles;      // list of files extracted during this file extraction

	CMsmErrors* m_pErrors;
	CMsmDependencies* m_pDependencies;

	UINT RecordGetString(MSIHANDLE hRecord, const int iCol, WCHAR** pwzBuffer, DWORD *cchBuffer = NULL, DWORD *cchLength = NULL) const;
	mutable WCHAR *m_wzBuffer;						// buffer used for extracting strings from records
	mutable DWORD m_cchBuffer;						// the size changes as needed.
};


///////////////////////////////////////////////////////////////////////
// global constants
enum stnSequenceTableNum {
	stnFirst       = 0,
	stnAdminUI     = 0,
	stnAdminExec   = 1,
	stnAdvtUI      = 2,
	stnAdvtExec    = 3, 
	stnInstallUI   = 4,
	stnInstallExec = 5,
	stnNext        = 6
};

const LPWSTR g_rgwzMSISequenceTables[] = { 
	L"AdminUISequence",
	L"AdminExecuteSequence",
	L"AdvtUISequence",
	L"AdvtExecuteSequence",
	L"InstallUISequence",
	L"InstallExecuteSequence"
};

const LPWSTR g_wzDirectoryTable =			L"Directory"; 

// this is global per DLL instance, set on DllMain. applies to all instances of
// CMsmMerge
extern HINSTANCE g_hInstance;
extern bool g_fWin9X;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmconfig.h ===
/////////////////////////////////////////////////////////////////////////////
// mmconfig.h
//		Declares IMsmError interface
//		Copyright (C) Microsoft Corp 2000.  All Rights Reserved.
// 

#ifndef __IENUM_MSM_CONFIGITEM__
#define __IENUM_MSM_CONFIGITEM__

#include "mergemod.h"

class CMsmConfigItem : public IMsmConfigurableItem
{

public:
	CMsmConfigItem();
	~CMsmConfigItem();

	// IUnknown interface
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID& iid, void** ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDispatch methods
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT* pctInfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTI);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
														 LCID lcid, DISPID* rgDispID);
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
											   DISPPARAMS* pDispParams, VARIANT* pVarResult,
												EXCEPINFO* pExcepInfo, UINT* puArgErr);
	HRESULT STDMETHODCALLTYPE InitTypeInfo();

	// IMsmError interface
	HRESULT STDMETHODCALLTYPE get_Name(BSTR* Name);
	HRESULT STDMETHODCALLTYPE get_Format(short* Format);
	HRESULT STDMETHODCALLTYPE get_Type(BSTR* Type);
	HRESULT STDMETHODCALLTYPE get_Context(BSTR* Context);
	HRESULT STDMETHODCALLTYPE get_DefaultValue(BSTR* DefaultValue);
	HRESULT STDMETHODCALLTYPE get_Attributes(long* Attributes);
	HRESULT STDMETHODCALLTYPE get_DisplayName(BSTR* DisplayName);
	HRESULT STDMETHODCALLTYPE get_Description(BSTR* Description);

	bool CMsmConfigItem::Configure(LPCWSTR wzName, short iFormat, LPCWSTR wzType, LPCWSTR wzContext, 
		LPCWSTR wzDefaultValue, long iAttributes, LPCWSTR wzDisplayName, LPCWSTR wzDescription);

private:
	long m_cRef;
	ITypeInfo* m_pTypeInfo;

	short m_iFormat;
	long  m_lAttributes;

	WCHAR *m_wzName;
	WCHAR *m_wzType;
	WCHAR *m_wzContext;
	WCHAR *m_wzDefaultValue;
	WCHAR *m_wzDisplayName;
	WCHAR *m_wzDescription;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmcfgitm.cpp ===
/////////////////////////////////////////////////////////////////////////////
// mmconfig.cpp
//		Implements IMsmError interface
//		Copyright (C) Microsoft Corp 2000.  All Rights Reserved.
// 

#include "..\common\trace.h"
#include "mmcfgitm.h"
#include "globals.h"
///////////////////////////////////////////////////////////
// constructor	
CMsmConfigItem::CMsmConfigItem() : m_wzName(NULL), m_wzType(NULL), m_wzContext(NULL), 
	m_wzDefaultValue(NULL), m_wzDisplayName(NULL), m_wzDescription(NULL), m_wzHelpLocation(NULL),
	m_wzHelpKeyword(NULL), m_eFormat(msmConfigurableItemText), m_lAttributes(0)
{
	// initial count
	m_cRef = 1;

	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
CMsmConfigItem::~CMsmConfigItem()
{
	if (m_wzName) delete[] m_wzName;
	if (m_wzType) delete[] m_wzType;
	if (m_wzContext) delete[] m_wzContext;
	if (m_wzDefaultValue) delete[] m_wzDefaultValue;
	if (m_wzDisplayName) delete[] m_wzDisplayName;
	if (m_wzDescription) delete[] m_wzDescription;
	if (m_wzHelpLocation) delete[] m_wzHelpLocation;
	if (m_wzHelpKeyword) delete[] m_wzHelpKeyword;
	
	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor

///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT CMsmConfigItem::QueryInterface(const IID& iid, void** ppv)
{
	TRACEA("CMsmConfigItem::QueryInterface - called, IID: %d\n", iid);

	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IMsmConfigurableItem*>(this);
	else if (iid == IID_IDispatch)
		*ppv = static_cast<IMsmConfigurableItem*>(this);
	else if (iid == IID_IMsmConfigurableItem)
		*ppv = static_cast<IMsmConfigurableItem*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CMsmConfigItem::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CMsmConfigItem::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// IDispatch interface

HRESULT CMsmConfigItem::GetTypeInfoCount(UINT* pctInfo)
{
	if(NULL == pctInfo)
		return E_INVALIDARG;

	*pctInfo = 1;	// only one type info supported by this dispatch

	return S_OK;
}

HRESULT CMsmConfigItem::GetTypeInfo(UINT iTInfo, LCID /* lcid */, ITypeInfo** ppTypeInfo)
{
	if (0 != iTInfo)
		return DISP_E_BADINDEX;

	if (NULL == ppTypeInfo)
		return E_INVALIDARG;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	*ppTypeInfo = m_pTypeInfo;
	m_pTypeInfo->AddRef();

	return S_OK;
}

HRESULT CMsmConfigItem::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
						 LCID lcid, DISPID* rgDispID)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID);
}

HRESULT CMsmConfigItem::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
				  DISPPARAMS* pDispParams, VARIANT* pVarResult,
				  EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr = S_OK;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->Invoke((IDispatch*)this, dispIdMember, wFlags, pDispParams, pVarResult,
										pExcepInfo, puArgErr);
}

HRESULT CMsmConfigItem::InitTypeInfo()
{
	HRESULT hr = S_OK;
	ITypeLib* pTypeLib = NULL;

	// if there is no info loaded
	if (NULL == m_pTypeInfo)
	{
		// try to load the Type Library into memory. For SXS support, do not load from registry, rather
		// from launched instance
		hr = LoadTypeLibFromInstance(&pTypeLib);
		if (FAILED(hr))
		{
			TRACEA("CMsmConfigItem::InitTypeInfo - failed to load TypeLib[0x%x]\n", LIBID_MsmMergeTypeLib);
			return hr;
		}

		// try to get the Type Info for this Interface
		hr = pTypeLib->GetTypeInfoOfGuid(IID_IMsmConfigurableItem, &m_pTypeInfo);
		if (FAILED(hr))
		{
			TRACEA("CMsmConfigItem::InitTypeInfo - failed to get inteface[0x%x] from TypeLib[0x%x]\n", IID_IMsmConfigurableItem, LIBID_MsmMergeTypeLib);

			// no type info was loaded
			m_pTypeInfo = NULL;
		}

		pTypeLib->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IMsmConfigurableItem interface

///////////////////////////////////////////////////////////
// get_Type
HRESULT CMsmConfigItem::get_Attributes(long* Attributes)
{
	// error check
	if (!Attributes)
		return E_INVALIDARG;

	*Attributes = m_lAttributes;
	return S_OK;
}	// end of get_Type

///////////////////////////////////////////////////////////
// get_Format
HRESULT CMsmConfigItem::get_Format(msmConfigurableItemFormat* Format)
{
	// error check
	if (!Format)
		return E_INVALIDARG;

	*Format = m_eFormat;
	return S_OK;
}	// end of get_Type

///////////////////////////////////////////////////////////
// get_Name
HRESULT CMsmConfigItem::get_Name(BSTR* Name)
{
	// error check
	if (!Name)
		return E_INVALIDARG;

	// copy over the string
	*Name = ::SysAllocString(m_wzName);
	if (!*Name)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_Name

///////////////////////////////////////////////////////////
// get_Type
HRESULT CMsmConfigItem::get_Type(BSTR* Type)
{
	// error check
	if (!Type)
		return E_INVALIDARG;

	// copy over the string
	*Type = ::SysAllocString(m_wzType);
	if (!*Type)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_Type

///////////////////////////////////////////////////////////
// get_Context
HRESULT CMsmConfigItem::get_Context(BSTR* Context)
{
	// error check
	if (!Context)
		return E_INVALIDARG;

	// copy over the string
	*Context = ::SysAllocString(m_wzContext);
	if (!*Context)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_Context

///////////////////////////////////////////////////////////
// get_DisplayName
HRESULT CMsmConfigItem::get_DisplayName(BSTR* DisplayName)
{
	// error check
	if (!DisplayName)
		return E_INVALIDARG;

	// copy over the string
	*DisplayName = ::SysAllocString(m_wzDisplayName);
	if (!*DisplayName)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_DisplayName

///////////////////////////////////////////////////////////
// get_DefaultValue
HRESULT CMsmConfigItem::get_DefaultValue(BSTR* DefaultValue)
{
	// error check
	if (!DefaultValue)
		return E_INVALIDARG;

	// copy over the string
	*DefaultValue = ::SysAllocString(m_wzDefaultValue);
	if (!*DefaultValue)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_DefaultValue

///////////////////////////////////////////////////////////
// get_Description
HRESULT CMsmConfigItem::get_Description(BSTR* Description)
{
	// error check
	if (!Description)
		return E_INVALIDARG;

	// copy over the string
	*Description = ::SysAllocString(m_wzDescription);
	if (!*Description)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_Description

///////////////////////////////////////////////////////////
// get_HelpLocation
HRESULT CMsmConfigItem::get_HelpLocation(BSTR* HelpLocation)
{
	// error check
	if (!HelpLocation)
		return E_INVALIDARG;

	// copy over the string
	*HelpLocation = ::SysAllocString(m_wzHelpLocation);
	if (!*HelpLocation)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_Description

///////////////////////////////////////////////////////////
// get_Description
HRESULT CMsmConfigItem::get_HelpKeyword(BSTR* HelpKeyword)
{
	// error check
	if (!HelpKeyword)
		return E_INVALIDARG;

	// copy over the string
	*HelpKeyword = ::SysAllocString(m_wzHelpKeyword);
	if (!*HelpKeyword)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_Description


/////////////////////////////////////////////////////////////////////////////
// non-interface methods

bool CMsmConfigItem::Configure(LPCWSTR wzName, msmConfigurableItemFormat eFormat, LPCWSTR wzType, LPCWSTR wzContext, 
	LPCWSTR wzDefaultValue, long lAttributes, LPCWSTR wzDisplayName, LPCWSTR wzDescription, LPCWSTR wzHelpLocation,
	LPCWSTR wzHelpKeyword)
{
	if (wzName)
	{
		size_t cchLen = wcslen(wzName);
		m_wzName = new WCHAR[cchLen+1];
		if (!m_wzName)
			return false;
		wcscpy(m_wzName, wzName);
	}

	m_eFormat = eFormat;

	if (wzType)
	{
		size_t cchLen = wcslen(wzType);
		m_wzType = new WCHAR[cchLen+1];
		if (!m_wzType)
			return false;
		wcscpy(m_wzType, wzType);
	}
	
	if (wzContext)
	{
		size_t cchLen = wcslen(wzContext);
		m_wzContext = new WCHAR[cchLen+1];
		if (!m_wzContext)
			return false;
		wcscpy(m_wzContext, wzContext);
	}

	if (wzDefaultValue)
	{
		size_t cchLen = wcslen(wzDefaultValue);
		m_wzDefaultValue = new WCHAR[cchLen+1];
		if (!m_wzDefaultValue)
			return false;
		wcscpy(m_wzDefaultValue, wzDefaultValue);
	}

	if (wzDisplayName)
	{
		size_t cchLen = wcslen(wzDisplayName);
		m_wzDisplayName = new WCHAR[cchLen+1];
		if (!m_wzDisplayName)
			return false;
		wcscpy(m_wzDisplayName, wzDisplayName);
	}
	
	if (wzDescription)
	{
		size_t cchLen = wcslen(wzDescription);
		m_wzDescription = new WCHAR[cchLen+1];
		if (!m_wzDescription)
			return false;
		wcscpy(m_wzDescription, wzDescription);
	}

	if (wzHelpLocation)
	{
		size_t cchLen = wcslen(wzHelpLocation);
		m_wzHelpLocation = new WCHAR[cchLen+1];
		if (!m_wzHelpLocation)
			return false;
		wcscpy(m_wzHelpLocation, wzHelpLocation);
	}
	
	if (wzHelpKeyword)
	{
		size_t cchLen = wcslen(wzHelpKeyword);
		m_wzHelpKeyword = new WCHAR[cchLen+1];
		if (!m_wzHelpKeyword)
			return false;
		wcscpy(m_wzHelpKeyword, wzHelpKeyword);
	}

	m_lAttributes = lAttributes;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmdep.cpp ===
/////////////////////////////////////////////////////////////////////////////
// dep.cpp
//		Implements IMsmDependency interface
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#include "..\common\trace.h"

#include "mmdep.h"
#include "..\common\utils.h"
#include "globals.h"

///////////////////////////////////////////////////////////
// constructor	
CMsmDependency::CMsmDependency(LPCWSTR wzModule, short nLanguage, LPCWSTR wzVersion)
{
	// initial count
	m_cRef = 1;

	// no type info yet
	m_pTypeInfo = NULL;

	// copy over the strings
	wcsncpy(m_wzModule, wzModule, MAX_MODULEID);
	m_wzModule[MAX_MODULEID] = L'\0';		// be sure it's null terminated
	wcsncpy(m_wzVersion, wzVersion, MAX_VERSION);
	m_wzVersion[MAX_VERSION] = L'\0';		// be sure it's null terminated
	
	m_nLanguage = nLanguage;	// set the language

	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
CMsmDependency::~CMsmDependency()
{
	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor

///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT CMsmDependency::QueryInterface(const IID& iid, void** ppv)
{
	TRACEA("CMsmDependency::QueryInterface - called, IID: %d\n", iid);

	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IMsmDependency*>(this);
	else if (iid == IID_IMsmDependency)
		*ppv = static_cast<IMsmDependency*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CMsmDependency::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CMsmDependency::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// IDispatch interface

HRESULT CMsmDependency::GetTypeInfoCount(UINT* pctInfo)
{
	if(NULL == pctInfo)
		return E_INVALIDARG;

	*pctInfo = 1;	// only one type info supported by this dispatch

	return S_OK;
}

HRESULT CMsmDependency::GetTypeInfo(UINT iTInfo, LCID /* lcid */, ITypeInfo** ppTypeInfo)
{
	if (0 != iTInfo)
		return DISP_E_BADINDEX;

	if (NULL == ppTypeInfo)
		return E_INVALIDARG;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	*ppTypeInfo = m_pTypeInfo;
	m_pTypeInfo->AddRef();

	return S_OK;
}

HRESULT CMsmDependency::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
						 LCID lcid, DISPID* rgDispID)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID);
}

HRESULT CMsmDependency::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
				  DISPPARAMS* pDispParams, VARIANT* pVarResult,
				  EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr = S_OK;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->Invoke((IDispatch*)this, dispIdMember, wFlags, pDispParams, pVarResult,
										pExcepInfo, puArgErr);
}

HRESULT CMsmDependency::InitTypeInfo()
{
	HRESULT hr = S_OK;
	ITypeLib* pTypeLib = NULL;

	// if there is no info loaded
	if (NULL == m_pTypeInfo)
	{
		// try to load the Type Library into memory. For SXS support, do not load from registry, rather
		// from launched instance
		hr = LoadTypeLibFromInstance(&pTypeLib);
		if (FAILED(hr))
		{
			TRACEA("CMsmDependency::InitTypeInfo - failed to load TypeLib[0x%x]\n", LIBID_MsmMergeTypeLib);
			return hr;
		}

		// try to get the Type Info for this Interface
		hr = pTypeLib->GetTypeInfoOfGuid(IID_IMsmDependency, &m_pTypeInfo);
		if (FAILED(hr))
		{
			TRACEA("CMsmDependency::InitTypeInfo - failed to get inteface[0x%x] from TypeLib[0x%x]\n", IID_IMsmDependency, LIBID_MsmMergeTypeLib);

			// no type info was loaded
			m_pTypeInfo = NULL;
		}

		pTypeLib->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IMsmDependency interface

///////////////////////////////////////////////////////////
// get_Module
HRESULT CMsmDependency::get_Module(BSTR* Module)
{
	// error check
	if (!Module)
		return E_INVALIDARG;

	// copy over the string
	*Module = ::SysAllocString(m_wzModule);
	if (!*Module)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_Module

///////////////////////////////////////////////////////////
// get_Language
HRESULT CMsmDependency::get_Language(short* Language)
{
	// error check
	if (!Language)
		return E_INVALIDARG;

	*Language = m_nLanguage;
	return S_OK;
}	// end of get_Language

///////////////////////////////////////////////////////////
// get_Version
HRESULT CMsmDependency::get_Version(BSTR* Version)
{
	// error check
	if (!Version)
		return E_INVALIDARG;

	// copy over the string
	*Version = ::SysAllocString(m_wzVersion);
	if (!*Version)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_Version
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmconfig.cpp ===
/////////////////////////////////////////////////////////////////////////////
// mmconfig.cpp
//		Implements Configurable Merge Modules
//		Copyright (C) Microsoft Corp 2000.  All Rights Reserved.
// 

#include "globals.h"
#include "merge.h"
#include "mmerror.h"
#include "seqact.h"
#include "..\common\query.h"
#include "..\common\dbutils.h"


// maximum number of coulmns in a table. If this changes, PerformModuleSubstitutionOnRec
// will also need to be changed.
const int cMaxColumns = 31;

///////////////////////////////////////////////////////////////////////
// SplitConfigStringIntoKeyRec
// splits a semicolon-delimited string into a record, starting at
// iFirstField and continuing as long as there is room in the 
// record. Will trash wzKeys!
// returns one of ERROR_SUCCESS, ERROR_OUTOFMEMORY, or ERROR_FUNCTION_FAILED
UINT CMsmMerge::SplitConfigStringIntoKeyRec(LPWSTR wzKeys, MSIHANDLE hRec, int& cExpectedKeys, int iFirstField) const
{	
	WCHAR* wzFirstChar = wzKeys;
	WCHAR* wzSourceChar = wzKeys;
	WCHAR* wzDestChar = wzKeys;
	int iDestField = iFirstField;
	bool fBreak = false;
	UINT iResult = ERROR_SUCCESS;

	// if cExpectedKeys is 0, it means we don't know how many keys we're looking for. In that case
	// we just go until we run out of stuff, and then return the number of keys that we actually
	// found in cExpectedKeys
	while (cExpectedKeys == 0 || iDestField-iFirstField <= cExpectedKeys)
	{
		switch (*wzSourceChar)
		{
		case 0:
			// end of the string means that we insert the final field
			// and then exit the loop. 
			*wzDestChar = '\0';
			if (ERROR_SUCCESS != MsiRecordSetString(hRec, iDestField++, wzFirstChar))
				iResult = ERROR_FUNCTION_FAILED;
			
			fBreak = true;
			break;
		case ';':
			// when we've hit a non-escaped semicolon, its time to insert the
			// key into the record. Null terminate the destination string
			// and then insert the string at wzFirstChar into the record
			*wzDestChar = '\0'; 
			if (ERROR_SUCCESS != MsiRecordSetString(hRec, iDestField++, wzFirstChar))
			{
				iResult = ERROR_FUNCTION_FAILED;
				fBreak = true;
				break;
			}
			// after the insert, we reset wzFirstChar, wzSourceChar, and wzDestChar
			// to all point to the character immediately after the last semicolon
			wzFirstChar = ++wzSourceChar;
			wzDestChar = wzSourceChar;

			// if we've run out of space in the table and still have more columns to go, we cram
			// the rest of the keys into the final field as-is. 
			if (iDestField == cMaxColumns)
			{
				if (ERROR_SUCCESS != MsiRecordSetString(hRec, iDestField++, wzFirstChar))
				{
					iResult = ERROR_FUNCTION_FAILED;
					fBreak = true;
					break;
				}

				// rather than point wzSourceChar to the actual string terminator (which would
				// require iterating through the rest of the string to find it), just
				// put a dummy '\0' in there to satisfy the checks after this loop.
				*wzSourceChar='\0';
				fBreak=true;
			}
			break;
		case '\\':
			// a backslash. Escapes the next character
			wzSourceChar++;
			// fall through to perform actual copy
		default:
			if (wzSourceChar != wzDestChar)
				*wzDestChar = *wzSourceChar;
			wzSourceChar++;
			wzDestChar++;
			break;
		}

		if (fBreak)
			break;
	} // while parse string


	if (cExpectedKeys != 0)
	{
		// make sure we had the correct number of primary keys and that there
		// isn't stuff left in the key string. If we had cMaxColumns keys, 
		// iDestField must be cMaxColumns+1
		if (cExpectedKeys+iFirstField > cMaxColumns)
		{
			if (iDestField != cMaxColumns+1)
				return ERROR_FUNCTION_FAILED;
		}
		else
		{
			if (iDestField != cExpectedKeys+iFirstField)
				return ERROR_FUNCTION_FAILED;
		}

		if (*wzSourceChar != '\0')
		{
			return ERROR_FUNCTION_FAILED;
		}
	}
	else
		cExpectedKeys = iDestField-iFirstField;

	return ERROR_SUCCESS;
}	


///////////////////////////////////////////////////////////////////////
// SubstituteIntoTempTable
// copies wzTableName into wzTempName with substitution, returning 
// qTarget as the only query holding the temporary table in memory.
// returns one of ERROR_SUCCESS, ERROR_OUTOFMEMORY, or ERROR_FUNCTION_FAILED
UINT CMsmMerge::SubstituteIntoTempTable(LPCWSTR wzTableName, LPCWSTR wzTempName, CQuery& qTarget)
{
	CQuery qQuerySub;
	int cPrimaryKeys = 1;
	UINT iResult = ERROR_SUCCESS;
	if (ERROR_SUCCESS != (iResult = PrepareTableForSubstitution(wzTableName, cPrimaryKeys, qQuerySub)))
	{
		FormattedLog(L">> Error: Could not configure the %ls table.\r\n", wzTableName);
		return iResult;
	}

	// generate a module query in the appropriate column order for insertion into the database 
	// (the database order may be different from the module order.) Function logs its own failure
	// cases.
	CQuery qSource;
	if (ERROR_SUCCESS != (iResult = GenerateModuleQueryForMerge(wzTableName, NULL, NULL, qSource)))
		return iResult;

	// create a temporary table with the same schema as the destination table. Duplicate from the Database, not the module
	// so that if the database has a different column order than the module, we have a temporary table that contains
	// the appropriate columns created by the GenerateQuery call to match the final database format.
	if (ERROR_SUCCESS != MsiDBUtils::DuplicateTableW(m_hDatabase, wzTableName, m_hModule, wzTempName, /*fTemporary=*/true))
		return ERROR_FUNCTION_FAILED;

	// create queries for merging tables.
    CheckError(qTarget.OpenExecute(m_hModule, NULL, TEXT("SELECT * FROM `%ls`"), wzTempName), 
				  L">> Error: Failed to get rows from Database's Table.\r\n");

	// loop through all records in table merging
	PMSIHANDLE hRecMergeRow;
	PMSIHANDLE hTypeRec;
	
	// hTypeRec and hRecMergeRow must both be in target column order to ensure
	// appropriate type checks.
	if (ERROR_SUCCESS != qTarget.GetColumnInfo(MSICOLINFO_TYPES, &hTypeRec))
		return ERROR_FUNCTION_FAILED;
		
	while (ERROR_SUCCESS == qSource.Fetch(&hRecMergeRow))
	{
		if (ERROR_SUCCESS != (iResult = PerformModuleSubstitutionOnRec(wzTableName, cPrimaryKeys, qQuerySub, hTypeRec, hRecMergeRow)))
		{
			FormattedLog(L">> Error: Could not Configure a record in the %ls table.\r\n", wzTableName);
			return iResult;
		}
		
		if (ERROR_SUCCESS != qTarget.Modify(MSIMODIFY_INSERT, hRecMergeRow))
			return ERROR_FUNCTION_FAILED;
	}	

	// If we "FREE" the table, only qTarget is holding it in memory, which is what
	// we want.
	CQuery qRelease;
	qRelease.OpenExecute(m_hModule, 0, L"ALTER TABLE `%ls` FREE", wzTempName);
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// IsTableConfigured
// returns true if the table is configured by the ModuleConfiguration
// table, false in all other cases (including errors)
bool CMsmMerge::IsTableConfigured(LPCWSTR wzTable) const
{		
	if (!m_fModuleConfigurationEnabled)
		return false;

	// if there's no ModuleConfiguration table, no configuration
	if (MSICONDITION_TRUE != MsiDatabaseIsTablePersistent(m_hModule, L"ModuleConfiguration"))
	{
		return false;
	}

	// if there's no ModuleSubstitution table, no configuration of this table.
	if (MSICONDITION_TRUE != MsiDatabaseIsTablePersistent(m_hModule, L"ModuleSubstitution"))
	{
		return false;
	}

	CQuery qIsConfig;
	PMSIHANDLE hRec;
	return (ERROR_SUCCESS == qIsConfig.FetchOnce(m_hModule, 0, &hRec, L"SELECT 1 FROM ModuleSubstitution WHERE `Table`='%ls'", wzTable));
}

///////////////////////////////////////////////////////////////////////
// PrepareModuleSubstitution
// creates the temporary table used to keep track of values returned
// by the merge tool and populates it with initial data. The lifetime 
// of the qQueryTable object is the lifetime of the table.
// The KeyExists column is '1' if the default key already exists in the 
// database before the merge. If the value is 1 we won't delete the row
// after the merge, even if NoOrphan is set.
// returns one of ERROR_SUCCESS, ERROR_OUTOFMEMORY, or ERROR_FUNCTION_FAILED
LPCWSTR g_sqlKeyQueryTemplate =      L"`[1]`=? { AND `[2]`=? }{ AND `[3]`=? }{ AND `[4]`=? }{ AND `[5]`=? }{ AND `[6]`=?} { AND `[7]`=?} { AND `[8]`=?} { AND `[9]`=? } " \
								L"{AND `[10]`=?{ AND `[11]`=?}{ AND `[12]`=?}{ AND `[13]`=?}{ AND `[14]`=?}{ AND `[15]`=?}{ AND `[16]`=?}{ AND `[17]`=?}{ AND `[18]`=?}{ AND `[19]`=?} " \
								L"{AND `[20]`=?{ AND `[21]`=?}{ AND `[22]`=?}{ AND `[23]`=?}{ AND `[24]`=?}{ AND `[25]`=?}{ AND `[26]`=?}{ AND `[27]`=?}{ AND `[28]`=?}{ AND `[29]`=?} " \
								L"{AND `[30]`=?{ AND `[31]`=?}"; 

const WCHAR g_sqlMergeSubTemplateBase[] = L"SELECT `Keys` FROM `__MergeSubstitute` WHERE `Key01`=?";
// subtract 1 from sizes because they are cch values which do not include null terminators
const int g_cchMergeSubTemplateBase = sizeof(g_sqlMergeSubTemplateBase)/sizeof(WCHAR)-1;
const int g_cchMergeSubTemplateEach = sizeof(L" AND `KeyXX`=?")/sizeof(WCHAR)-1;

const WCHAR g_sqlMergeSubTemplate[] = L" AND `Key02`=? AND `Key03`=? AND `Key04`=? AND `Key05`=? AND `Key06`=? AND `Key07`=? AND `Key08`=? AND `Key09`=? AND `Key10`=? AND " \
									  L"`Key11`=? AND `Key12`=? AND `Key13`=? AND `Key14`=? AND `Key15`=? AND `Key16`=? AND `Key17`=? AND `Key18`=? AND `Key19`=? AND `Key20`=? AND " \
									  L"`Key21`=? AND `Key22`=? AND `Key23`=? AND `Key24`=? AND `Key25`=? AND `Key26`=? AND `Key27`=? AND `Key28`=? AND `Key29`=? AND `Key30`=? AND " \
									  L"`Key31`=?";

void CMsmMerge::CleanUpModuleSubstitutionState()
{
	// clean up any potentially stale state
	if (m_pqGetItemValue)
	{
		delete m_pqGetItemValue;
		m_pqGetItemValue = NULL;
	}
}

UINT CMsmMerge::PrepareModuleSubstitution(CQuery &qTempTable)
{
	CleanUpModuleSubstitutionState();	

	// If there is no ModuleSubstitution table, we can turn off the configuration
	// flag for this merge op.
	if (MSICONDITION_TRUE != MsiDatabaseIsTablePersistent(m_hModule, L"ModuleSubstitution"))
	{
		m_fModuleConfigurationEnabled = false;
		return ERROR_SUCCESS;
	}

	if (ERROR_SUCCESS != qTempTable.OpenExecute(m_hModule, 0, L"CREATE TABLE `__ModuleConfig` (`Name` CHAR(72) NOT NULL TEMPORARY, `Column` INT TEMPORARY, `KeyExists` INT TEMPORARY, `Prompted` INT TEMPORARY, `Value` CHAR(0) TEMPORARY, `Mask` LONG TEMPORARY, `Default` INT TEMPORARY PRIMARY KEY `Name`, `Column`)"))
		return ERROR_FUNCTION_FAILED;

	// if there's no ModuleConfiguration table, an empty __ModuleConfig table is fine.
	if (MSICONDITION_TRUE != MsiDatabaseIsTablePersistent(m_hModule, L"ModuleConfiguration"))
	{
		return ERROR_SUCCESS;
	}

	FormattedLog(L"ModuleConfiguration and ModuleSubstitution table exist. Configuration enabled.\r\n");

	// populate the table with all potential names by querying the ModuleConfiguration table.
	CQuery qFill;
	if (ERROR_SUCCESS != qFill.OpenExecute(m_hModule, 0, L"SELECT `Name`, 1, `ContextData`, 0, `DefaultValue`, `Format`, 1 FROM `ModuleConfiguration`"))
	{
		FormattedLog(L">> Error: Failed to query ModuleConfiguration table.\r\n");
		return ERROR_FUNCTION_FAILED;
	}

	CQuery qInsert;
	if (ERROR_SUCCESS != qInsert.OpenExecute(m_hModule, 0, L"SELECT * FROM `__ModuleConfig`"))
		return ERROR_FUNCTION_FAILED;

	PMSIHANDLE hConfigRec;
	UINT iResult = ERROR_SUCCESS;
	WCHAR *wzContextData = NULL;
	DWORD cchContextData;
	
	while (ERROR_SUCCESS == (iResult = qFill.Fetch(&hConfigRec)))
	{
		// if this is a Key type, the DefalutValue column is actually several concatenated 
		// default values. Read the default value into the global temporary buffer, split
		// it into primary keys, then insert one row for each column.
		if (::MsiRecordGetInteger(hConfigRec, 6) == msmConfigurableItemKey)
		{
			if (ERROR_SUCCESS != (iResult = RecordGetString(hConfigRec, 5, NULL)))
			{
				// iResult is E_F_F or E_O_M, both of which are good return codes for this function
				WCHAR* wzItem = m_wzBuffer;
				if (ERROR_SUCCESS != (iResult = RecordGetString(hConfigRec, 1, NULL)))
					wzItem = L"<error retrieving data>";
				FormattedLog(L">> Error: Failed to retrieve default value of ModuleConfiguration item [%ls].\r\n", wzItem);
				break;
			}
			
			PMSIHANDLE hKeyRec = ::MsiCreateRecord(32);
			int cExpectedKeys = 0;
			if (ERROR_SUCCESS != (iResult = SplitConfigStringIntoKeyRec(m_wzBuffer, hKeyRec, cExpectedKeys, 1)))
			{
				WCHAR* wzItem = m_wzBuffer;
				if (ERROR_SUCCESS != RecordGetString(hConfigRec, 1, NULL))
					wzItem = L"<error retrieving data>";
				FormattedLog(L">> Error: Failed to split DefaultValue for ModuleConfiguration item [%ls] into primary keys.\r\n", wzItem);
				break;
			}

			// set the mask column to 0 for key types
			::MsiRecordSetInteger(hConfigRec, 6, 0);

			// always clear the ContextData column for key types
			::MsiRecordSetInteger(hConfigRec, 3, 0);

			bool fBreak = false;
			for (int cColumn = 1; cColumn <= cExpectedKeys; cColumn++)
			{
				// retrieve the key into the temporary buffer
				if (ERROR_SUCCESS != (iResult = RecordGetString(hKeyRec, cColumn, NULL)))
				{
					// iResult is E_F_F or E_O_M, both of which are good return codes for this function
					WCHAR* wzItem = m_wzBuffer;
					if (ERROR_SUCCESS != RecordGetString(hConfigRec, 1, NULL))
						wzItem = L"<error retrieving data>";
					FormattedLog(L">> Error: Failed to retrieve primary key column %d of DefaultValue for ModuleConfiguration item [%ls].\r\n", cColumn, wzItem);
					fBreak = true;
					break;
				}
				MsiRecordSetInteger(hConfigRec, 2, cColumn);
				MsiRecordSetString(hConfigRec, 5, m_wzBuffer);
				if (ERROR_SUCCESS != qInsert.Modify(MSIMODIFY_INSERT, hConfigRec))
				{
					WCHAR* wzItem = m_wzBuffer;
					if (ERROR_SUCCESS != RecordGetString(hConfigRec, 1, NULL))
						wzItem = L"<error retrieving data>";
					iResult = ERROR_FUNCTION_FAILED;
					FormattedLog(L">> Error: Failed to store DefaultValue for column %d of ModuleConfiguration item [%ls].\r\n", cColumn, wzItem);
					fBreak = true;
					break;
				}
			}
			if (fBreak)
				break;
		}
		else
		{
			// check if this is a bitfield type, if so set the mask column. Otherwise mask column is
			// not used (is set to 0)
			if (::MsiRecordGetInteger(hConfigRec, 6) == msmConfigurableItemBitfield)
			{
				iResult = RecordGetString(hConfigRec, 3, &wzContextData, &cchContextData, NULL);
				if (ERROR_SUCCESS != iResult)
				{
					if (wzContextData)
						delete[] wzContextData;
					return (iResult == ERROR_OUTOFMEMORY) ? ERROR_OUTOFMEMORY : ERROR_FUNCTION_FAILED;
				}
				MsiRecordSetInteger(hConfigRec, 6, _wtol(wzContextData));
			}
			else 
				::MsiRecordSetInteger(hConfigRec, 6, 0);

			// always clear the ContextData column
			::MsiRecordSetInteger(hConfigRec, 3, 0);

			// insert the record 
			if (ERROR_SUCCESS != qInsert.Modify(MSIMODIFY_INSERT, hConfigRec))
			{
				WCHAR* wzItem = m_wzBuffer;
				if (ERROR_SUCCESS != RecordGetString(hConfigRec, 1, NULL))
					wzItem = L"<error retrieving data>";
				FormattedLog(L">> Error: Failed to store DefaultValue for ModuleConfiguration item [%ls].\r\n", wzItem);
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}
		}
	}
	if (wzContextData)
	{
		delete[] wzContextData;
		wzContextData = NULL;
	}

	// if the while loop terminated for a reason other than the query running out
	// of items, something bad has happened.
	if (iResult != ERROR_NO_MORE_ITEMS)
	{
		// can pass E_O_M as return code, all others map to E_F_F
		return (iResult == ERROR_OUTOFMEMORY) ? ERROR_OUTOFMEMORY : ERROR_FUNCTION_FAILED;
	}

	// all items have been added to the moduleConfiguration table, so its time to check the existance
	// of all 'Key' types in the original database and mark the 'KeyExists' column appropriately.
	DWORD cchSQL = 72;
	DWORD cchKeys = 72;
	DWORD cchTable = 72;
	WCHAR* wzTable = NULL;
	WCHAR* wzKeys = NULL;
	WCHAR* wzSQL = new WCHAR[cchSQL];
	if (!wzSQL)
	{
		return ERROR_OUTOFMEMORY;
	}
	
	PMSIHANDLE hTableRec;
	CQuery qTable;
	qTable.OpenExecute(m_hModule, 0, L"SELECT DISTINCT `Type` FROM `ModuleConfiguration`, `_Tables` WHERE (`ModuleConfiguration`.`Format`=1) AND `ModuleConfiguration`.`Type`=`_Tables`.`Name`");
	qFill.Open(m_hModule, L"SELECT `Name`, `DefaultValue` FROM `ModuleConfiguration` WHERE `Format`=1 AND `Type`=?");
	qInsert.Open(m_hModule, L"UPDATE `__ModuleConfig` SET `KeyExists`=1 WHERE `Name`=?");

	// loop through the distinct tables in the ModuleConfiguration table. The join with _Tables causes
	// retrieval of persistent tables only. Check all configuration entries that are Key type to see
	// if the default value already exists in the database. If so, a noOrphan attribute on that item
	// becomes a no-op to prevent removal of pre-existing data.
	while (ERROR_SUCCESS == (iResult = qTable.Fetch(&hTableRec)))
	{
		// retrieve the table name for the query
		if (ERROR_SUCCESS != (iResult = RecordGetString(hTableRec, 1, &wzTable, &cchTable)))
			break;

		// if the table doesn't exist in the database, obviously keys to it don't already exist
		if (MSICONDITION_TRUE != MsiDatabaseIsTablePersistent(m_hDatabase, wzTable))
			continue;

		// retrieve the number of primary keys 
		PMSIHANDLE hKeyRec;
		if (ERROR_SUCCESS != MsiDatabaseGetPrimaryKeysW(m_hDatabase, wzTable, &hKeyRec))
			return ERROR_FUNCTION_FAILED;
		int cPrimaryKeys = static_cast<int>(::MsiRecordGetFieldCount(hKeyRec));
		if (cPrimaryKeys > cMaxColumns || cPrimaryKeys < 1)
			return ERROR_FUNCTION_FAILED;

		// retrieve the number of primary keys in the module, must be the same as in the database
		if (ERROR_SUCCESS != MsiDatabaseGetPrimaryKeysW(m_hModule, wzTable, &hKeyRec))
			return ERROR_FUNCTION_FAILED;
		if (cPrimaryKeys != static_cast<int>(::MsiRecordGetFieldCount(hKeyRec)))
		{
			FormattedLog(L">> Error: [%ls] table in the module has a different number of primary key columns than the database table.", wzTable);
			return ERROR_FUNCTION_FAILED;
		}

		// build up the SQL query to check the primary keys for a match
		MsiRecordSetString(hKeyRec, 0, g_sqlKeyQueryTemplate);

		// on success returns number of chars, so must pass temp buffer to avoid needless
		// reallocations if the buffer is exactly big enough.
		DWORD cchTempSQL = cchSQL;
		if (ERROR_MORE_DATA == (iResult = MsiFormatRecord(NULL, hKeyRec, wzSQL, &cchTempSQL)))
		{
			cchSQL = cchTempSQL+1;
			delete[] wzSQL;
			wzSQL = new WCHAR[cchSQL];
			if (!wzSQL)
			{
				iResult = ERROR_OUTOFMEMORY;
				break;
			}
			iResult = MsiFormatRecord(NULL, hKeyRec, wzSQL, &cchTempSQL);
		}
		if (ERROR_SUCCESS != iResult)
		{
			iResult = ERROR_FUNCTION_FAILED;
			break;
		}

		// open the query for an exact match
		CQuery qCheckKey;
		if (ERROR_SUCCESS != qCheckKey.Open(m_hDatabase, L"SELECT NULL FROM `%s` WHERE %s", wzTable, wzSQL))
		{
			iResult = ERROR_FUNCTION_FAILED;
			break;
		}	

		// loop through every configuration entry that modifies this table, checking the primary keys referenced
		// in the DefaultValue column for an exact match in the existing database table
		qFill.Execute(hTableRec);
		while (ERROR_SUCCESS == (iResult = qFill.Fetch(&hConfigRec)))
		{
			if (ERROR_SUCCESS != (iResult = RecordGetString(hConfigRec, 2, &wzKeys, &cchKeys)))
			{
				break;
			}

			// split the semicolon-delimited list of keys into individual keys
			if (ERROR_SUCCESS != (iResult = SplitConfigStringIntoKeyRec(wzKeys, hKeyRec, cPrimaryKeys, 1)))
			{
				WCHAR *wzTemp = NULL;
				if (ERROR_SUCCESS == RecordGetString(hConfigRec, 2, &wzKeys, &cchKeys))
				{
					wzTemp = wzKeys;
				}
				else
					wzTemp = L"<error retrieving data>";
				FormattedLog(L">> Error: Failed to split ModuleConfiguration default value [%ls] into primary keys for table [%ls].", wzTemp, wzTable);
				break;
			}

			if (ERROR_SUCCESS != qCheckKey.Execute(hKeyRec))
			{
				FormattedLog(L">> Error: Could not query database table [%ls] for existing row.\r\n", wzTable);
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}
			
			PMSIHANDLE hTempRec;
			iResult = qCheckKey.Fetch(&hTempRec);
			if (ERROR_SUCCESS == iResult)			
			{
				// update the __ModuleConfig table with '1' in the KeyExists column if the database
				// has a row matching the default value from the module.
				if (ERROR_SUCCESS != qInsert.Execute(hConfigRec))
				{
					iResult = ERROR_FUNCTION_FAILED;
					break;
				}
			}
			else if (ERROR_NO_MORE_ITEMS != iResult)
				break;
		}
		// if the while loop terminated for a reason other than the query running out
		// of items, something bad has happened.
		if (ERROR_NO_MORE_ITEMS != iResult)
		{
			iResult = (iResult == ERROR_OUTOFMEMORY) ? ERROR_OUTOFMEMORY : ERROR_FUNCTION_FAILED;
			break;
		}
	}

	if (wzTable) delete[] wzTable;
	if (wzSQL) delete[] wzSQL;
	if (wzKeys) delete[] wzKeys;
	
	// if the while loop terminated for a reason other than the query running out
	// of items, something bad has happened.
	if (iResult != ERROR_NO_MORE_ITEMS)
	{
		return (iResult == ERROR_OUTOFMEMORY) ? ERROR_OUTOFMEMORY : ERROR_FUNCTION_FAILED;
	}

	// finally open a query on the __ModuleConfig table to retrieve data items
	m_pqGetItemValue = new CQuery;
	if (!m_pqGetItemValue)
		return ERROR_OUTOFMEMORY;
	if (ERROR_SUCCESS != m_pqGetItemValue->Open(m_hModule, L"SELECT `__ModuleConfig`.`Name`, `__ModuleConfig`.`Column`, `ModuleConfiguration`.`Format`, `__ModuleConfig`.`Prompted`, `__ModuleConfig`.`Value`, `__ModuleConfig`.`Mask` FROM `__ModuleConfig`,`ModuleConfiguration` WHERE `__ModuleConfig`.`Name`=? AND `__ModuleConfig`.`Column`=? AND `__ModuleConfig`.`Name`=`ModuleConfiguration`.`Name`"))
		return ERROR_FUNCTION_FAILED;

	return ERROR_SUCCESS;
}

// constants for the GetItemValueQuery record results
const int iValueTableName     = 1;
const int iValueColumn        = 2;
const int iValueTableFormat   = 3;
const int iValueTablePrompted = 4;
const int iValueTableValue    = 5;
const int iValueTableMask     = 6;


///////////////////////////////////////////////////////////////////////
// PrepareTableForSubstitution
// creates a temporary table containing the un-concatenated primary 
// keys from the ModuleSubstitution table. Used to make queries 
// for changed rows much faster (because it becomes a string id
// comparison and not repeated string parsing).
// returns one of ERROR_SUCCESS, ERROR_OUTOFMEMORY, or ERROR_FUNCTION_FAILED
UINT CMsmMerge::PrepareTableForSubstitution(LPCWSTR wzTable, int& cPrimaryKeys, CQuery &qQuerySub)
{
	// if there is nothing in the database that substitutes into this table, bypass all of this
	// expensive work
	CQuery qModSub;
	PMSIHANDLE hResultRec;
	UINT iResult = qModSub.FetchOnce(m_hModule, 0, &hResultRec, L"SELECT DISTINCT `Row` FROM `ModuleSubstitution` WHERE `Table`='%s'", wzTable);
	if (ERROR_NO_MORE_ITEMS == iResult)
		return ERROR_SUCCESS;

	// if failure, very bad
	if (ERROR_SUCCESS != iResult)
		return ERROR_FUNCTION_FAILED;

	// close so the query can be re-executed later
	qModSub.Close();
	
	// for efficiency, we prepare a table for module substitution by checking 
	// for entries in the ModuleSubstitution table and building a temprorary
	// table with the keys un-parsed. We use one column (primary key in this table)
	// to refer back to the original ModuleSubstitution table by concatenated keys (column is
	// only of use during the actual substitution). A table can have up to 31
	// columns, all of which might be keys, so we unparse at most 29 columns, with the
	// 30th column in this table containing the still-concatenated 30 and 31 from the
	// original table.
	const WCHAR wzBaseCreate[] =   L"CREATE TABLE `__MergeSubstitute` (`Keys` CHAR(0) TEMPORARY";
	const WCHAR wzEndCreate[] =    L" PRIMARY KEY `Keys`)";
	const WCHAR wzColumnCreate[] = L", `Key%02d` CHAR(0) TEMPORARY";
	// subtract one from each cch for the null
	const int cchBaseCreate = (sizeof(wzBaseCreate)/sizeof(WCHAR))-1;
	const int cchEndCreate = (sizeof(wzEndCreate)/sizeof(WCHAR))-1;
	// subtract 3 because %02d is 2 chars after substitution, 1 for null
	const int cchColumnCreate = (sizeof(wzColumnCreate)/sizeof(WCHAR))-3; 

	// determine the number of primary keys in the table
	PMSIHANDLE hKeyRec;
	if (ERROR_SUCCESS != MsiDatabaseGetPrimaryKeysW(m_hModule, wzTable, &hKeyRec))
		return ERROR_FUNCTION_FAILED;
	cPrimaryKeys = ::MsiRecordGetFieldCount(hKeyRec);
	if (cPrimaryKeys > (cMaxColumns) || cPrimaryKeys < 1)
		return ERROR_FUNCTION_FAILED;

	// this query can be no more than wcslen(wzBaseCreate) + 31*wcslen(wzColumnCreate)+wcslen(wzEndCreate);
	WCHAR *wzQuery = new WCHAR[cchBaseCreate + cchEndCreate + cPrimaryKeys*cchColumnCreate + 1];
	int cTableColumns = (cPrimaryKeys < (cMaxColumns-1)) ? cPrimaryKeys + 1 : cMaxColumns;
	
	if (!wzQuery)
		return E_OUTOFMEMORY;
		
	wcscpy(wzQuery, wzBaseCreate);
	WCHAR *wzNext = wzQuery+cchBaseCreate;
	for (int iKey=1; iKey <= cPrimaryKeys; iKey++)
	{
		// create query
		WCHAR wzTemp[cchColumnCreate+1];
		swprintf(wzTemp, wzColumnCreate, iKey);
		wcscpy(wzNext, wzTemp);
		wzNext += cchColumnCreate;
	}
	wcscpy(wzNext, wzEndCreate);

	// run the query to create the table
	CQuery qCreateTable;
	iResult = qCreateTable.OpenExecute(m_hModule, 0, wzQuery);
	delete[] wzQuery;
	wzQuery = NULL;
	if (iResult != ERROR_SUCCESS)
		return ERROR_FUNCTION_FAILED;

	// next loop through every entry in the ModuleSubstitution table that modifies this
	// table and tokenize the primary keys into a temporary table for faster query matching later. 
	CQuery qInsert;
	if (ERROR_SUCCESS != qInsert.OpenExecute(m_hModule, 0, L"SELECT * FROM `__MergeSubstitute`"))
		return ERROR_FUNCTION_FAILED;
			
	WCHAR *wzKeys = NULL;
	DWORD cchKeys = 0;
	qModSub.Execute(0);
	while (ERROR_SUCCESS == (iResult = qModSub.Fetch(&hResultRec)))
	{
		// grab the concatenated keys out of the record
		if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 1, &wzKeys, &cchKeys)))
		{
			if (wzKeys)
				delete[] wzKeys;
			if (iResult == ERROR_OUTOFMEMORY)
				return ERROR_OUTOFMEMORY;
			else
				return ERROR_FUNCTION_FAILED;
		}

		PMSIHANDLE hInsertRec = ::MsiCreateRecord(cTableColumns);
		if (!hInsertRec)
		{
			iResult = ERROR_FUNCTION_FAILED;
			break;
		}

		// cram the concatenated keys into our new table
		if (ERROR_SUCCESS != MsiRecordSetString(hInsertRec, 1, wzKeys))
		{
			if (wzKeys)
				delete[] wzKeys;
			return ERROR_FUNCTION_FAILED;
		}

		if (ERROR_SUCCESS != (iResult = SplitConfigStringIntoKeyRec(wzKeys, hInsertRec, cPrimaryKeys, 2)))
		{
			WCHAR *wzTemp = NULL;
			if (ERROR_SUCCESS == RecordGetString(hResultRec, 1, &wzKeys, &cchKeys))
			{
				wzTemp = wzKeys;
			}
			else
				wzTemp = L"<error retrieving data>";
			FormattedLog(L">> Error: Failed to split ModuleSubstitution row template [%ls] into primary keys for table [%ls].", wzTemp, wzTable);
			iResult = ERROR_FUNCTION_FAILED;
			break;
		}
		
		// insert into the temporary table
		if (ERROR_SUCCESS != qInsert.Modify(MSIMODIFY_INSERT, hInsertRec))
		{
			iResult = ERROR_FUNCTION_FAILED;
			break;
		}
		
	} // while fetch
	
	if (wzKeys)
		delete[] wzKeys; 
	wzKeys = NULL;

	// if the while loop terminated for a reason other than the query running out
	// of items, something bad has happened.
	if (iResult != ERROR_NO_MORE_ITEMS)
	{
		return (iResult == ERROR_OUTOFMEMORY) ? ERROR_OUTOFMEMORY : ERROR_FUNCTION_FAILED;
	}
	
	// build up the SQL query to check the primary keys for a match. First column is implicitly part
	// of the base, and one column is taken by the concatenated keys. Thus there are cColumns-2 that
	// we need to grab out of the template strings
	DWORD cchTemplateLength = (cTableColumns-2)*g_cchMergeSubTemplateEach;
	WCHAR wzQuery2[g_cchMergeSubTemplateBase+sizeof(g_sqlMergeSubTemplate)/sizeof(WCHAR)+1];
	wcscpy(wzQuery2, g_sqlMergeSubTemplateBase);
	wcsncpy(&(wzQuery2[g_cchMergeSubTemplateBase]), g_sqlMergeSubTemplate, cchTemplateLength);
	wzQuery2[g_cchMergeSubTemplateBase+cchTemplateLength] = '\0';
	
	// this query keeps the __MergeSubstitute table alive
	if (ERROR_SUCCESS != qQuerySub.Open(m_hModule, wzQuery2))
		return ERROR_FUNCTION_FAILED;
	
	return ERROR_SUCCESS;
}	// end of PrepareTableForSubstitution

///////////////////////////////////////////////////////////
// PerformModuleSubstitutionOnRec
// performs substitution on a record based on the ModuleSubstitution and
// ModuleConfiguration tables. hColumnTypes contains column types and
// hRecord is the record to be substituted. Both records must be in
// the column order of the TARGET database, NOT the module.
// returns ERROR_OUT_OF_MEMORY, ERROR_SUCCESS, or ERROR_FUNCTION_FAILED
UINT CMsmMerge::PerformModuleSubstitutionOnRec(LPCWSTR wzTable, int cPrimaryKeys, CQuery& qQuerySub, MSIHANDLE hColumnTypes, MSIHANDLE hRecord)
{
	UINT iResult = ERROR_SUCCESS;

	// if the query is not open, we aren't prepared for configuration yet. (most likely this
	// is ModuleSubstitution table or some other table that is merged before Configuration
	// takes place)
	if (!qQuerySub.IsOpen())
		return ERROR_SUCCESS;
		
	// if there are 31 primary keys, we can't just execute the query, because only 30 keys are broken out. We need to
	// concatenate the last two primary keys together in column 31 before executing, and then place the current value
	// in that column back at the end of the substitution
	WCHAR *wzOriginal30 = NULL;
	bool fModified30 = false;
	if (cPrimaryKeys == cMaxColumns)
	{
		DWORD cchOriginalLength = 0;
		// since column 30 is a primary key, it can not be binary.
		if (ERROR_SUCCESS != (iResult = RecordGetString(hRecord, cMaxColumns-1, &wzOriginal30, NULL, &cchOriginalLength)))
		{
			return iResult;
		}

		// get the length of column 31's key for memory allocation size
		DWORD cchColumn31 = 0;
		::MsiRecordGetStringW(hRecord, cMaxColumns, L"", &cchColumn31);

		// our first guess is that we won't need to escape more than 9 characters. We'll reallocate if necessary
		DWORD cchResultBuf = cchColumn31 + cchOriginalLength + 10;
		WCHAR *wzOriginal31 = NULL;
		WCHAR *wzNew30 = new WCHAR[cchResultBuf];
		if (!wzNew30)
		{
			delete[] wzOriginal31;
			return ERROR_OUTOFMEMORY;
		}
		if (ERROR_SUCCESS != (iResult = RecordGetString(hRecord, cMaxColumns, &wzOriginal31, NULL)))
		{
			delete[] wzOriginal31;
			delete[] wzOriginal30;
			return iResult;
		}

		// run through the 30 and 31 primary keys, escaping any embedded semicolons and concatenating
		// them with an un-escaped semicolon
		WCHAR *pchSource = wzOriginal30;
		WCHAR *pchDest = wzNew30;
		DWORD cchDestChars = 0;
		
		bool f31 = true;
		while (f31 || *pchSource)
		{
			if (*pchSource == 0)
			{
				f31 = false;
				pchSource = wzOriginal31;
				*(pchDest++) = L';';
				cchDestChars++;
			}
			else if (*pchSource == L';')
			{
				*(pchDest++) = L'\\';
				*(pchDest++) = *(pchSource++);
				cchDestChars +=2;
			}
			else
			{
				*(pchDest++) = *(pchSource++);
				cchDestChars++;
			}

			// always keep two extra characters in the buffer
			if (cchDestChars+2 >= cchResultBuf)
			{
				DWORD cchNewBuf = cchResultBuf + 20;
				WCHAR *wzTemp = new WCHAR[cchNewBuf];
				if (!wzTemp)
				{
					delete[] wzNew30;
					delete[] wzOriginal30;
					break;
				}

				// wcsncpy pads with nulls
				wcsncpy(wzTemp, wzNew30, cchNewBuf);
				delete[] wzNew30;
				wzNew30 = wzTemp;
				pchDest = wzNew30+cchDestChars;
			}
		}
		*pchDest = L'\0';

		MsiRecordSetString(hRecord, cMaxColumns-1, wzNew30);
		// column 30 now has the concatenated 30 and 31 in place and we can execute the query
		delete[] wzOriginal31;
		delete[] wzNew30;
	}

	// finding matching rows is a two-stage process. First we query the __MergeSubstitute table
	// to get the concatenated keys in a record, then we query the ModuleConfiguration table
	// to find everything matching that row
	PMSIHANDLE hConcatKeys;
	if (ERROR_SUCCESS == (iResult = qQuerySub.Execute(hRecord)) &&
		ERROR_SUCCESS == (iResult = qQuerySub.Fetch(&hConcatKeys)))
	{
		WCHAR *wzValueTemplate = NULL;
		DWORD cchValueTemplate = 0;
		WCHAR *wzResult = NULL;
		DWORD cchResult = 0;
		WCHAR *wzColumn = NULL;
		DWORD cchColumn = 0;
		WCHAR *wzRow = NULL;
		DWORD cchRow = 0;

		PMSIHANDLE hResultRec;
		CQuery qModConfig;
		if (ERROR_SUCCESS != qModConfig.OpenExecute(m_hModule, hConcatKeys, L"SELECT `ModuleSubstitution`.`Table`, `ModuleSubstitution`.`Column`, `ModuleSubstitution`.`Value`, `ModuleSubstitution`.`Row` FROM `ModuleSubstitution` WHERE `ModuleSubstitution`.`Table`='%s' AND `ModuleSubstitution`.`Row`=?", wzTable))
			return ERROR_FUNCTION_FAILED;

		// hResultRec contains Table/Column/Value/Row
		while (ERROR_SUCCESS == (iResult = qModConfig.Fetch(&hResultRec)))
		{
			// this row has a substitution entry. Match the name up with a column number
			CQuery qColumn;
			PMSIHANDLE hColumnRec;

			// because the database might have a different column order than the module, must always use the database (target)
			// column number. The passed in records are always in target format
			if (ERROR_SUCCESS != (qColumn.FetchOnce(m_hDatabase, hResultRec, &hColumnRec, L"Select `Number` From `_Columns` WHERE `Table`=? AND `Name`=?")))
			{				
				// one or more items was not listed in the ModuleConfiguration table. 
				if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 2, &wzColumn, &cchColumn)))
					break;
					
				FormattedLog(L">> Error: ModuleSubstitution entry for table [%ls] references a column [%ls] that does not exist.\r\n", wzTable, wzColumn);
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}

			// grab the column number
			int iDatabaseColumn = MsiRecordGetInteger(hColumnRec, 1);

			// if there are 31 primary key columns and we're modifying column 30, make a note so we don't
			// clobber our newly substituted column
			if (cPrimaryKeys == cMaxColumns && iDatabaseColumn == cMaxColumns-1)
			{
				fModified30 = true;
			}
			
			// get the type of this column.
			WCHAR rgwchColumnType[5];
			DWORD cchColumnType = 5;
			if (ERROR_SUCCESS != MsiRecordGetStringW(hColumnTypes, iDatabaseColumn, rgwchColumnType, &cchColumnType))
			{
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}
			bool fColumnIsNullable = iswupper(rgwchColumnType[0]) != 0;
			
			// perform the actual text substitution
			if (rgwchColumnType[0] == 'L' || rgwchColumnType[0]== 'l' || rgwchColumnType[0] == 'S' || rgwchColumnType[0]== 's' || rgwchColumnType[0] == 'G' || rgwchColumnType[0]== 'g')
			{
				if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 3, &wzValueTemplate, &cchValueTemplate)))
					break;
				
				if (ERROR_SUCCESS != (iResult = PerformTextFieldSubstitution(wzValueTemplate, &wzResult, &cchResult)))
				{					
					if (ERROR_NO_MORE_ITEMS == iResult)
					{						
						// one or more items was not listed in the ModuleConfiguration table. 
						if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 4, &wzRow, &cchRow)))
							break;
			
						if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 2, &wzColumn, &cchColumn)))
							break;
							
						FormattedLog(L">> Error: ModuleSubstitution entry for [%ls].[%ls] in row [%ls] uses a configuration item that does not exist.\r\n", wzTable, wzColumn, wzRow);
						if (m_pErrors)
						{
							CMsmError *pErr = new CMsmError(msmErrorMissingConfigItem, NULL, -1);
							if (!pErr) 
							{
								iResult = ERROR_OUTOFMEMORY;
								break;
							}
							pErr->SetModuleTable(L"ModuleSubstitution");
							// primary keys in this error are Table/Row/Column
							pErr->AddModuleError(wzTable);
							pErr->AddModuleError(wzRow);
							pErr->AddModuleError(wzColumn);
													
							m_pErrors->Add(pErr);
						}
						iResult = ERROR_FUNCTION_FAILED;
					}
					else if (ERROR_NO_DATA == iResult)
					{
						// error object is generated closer to the actual point of failure where the actual
						// item is known. Translate error code.
						iResult = ERROR_FUNCTION_FAILED;
					}
					else if (ERROR_FUNCTION_FAILED == iResult)
					{
						// no-op. Error code is correct.
					}
					else
                    {
                        // unknown error code. This should never happen.
                        ASSERT(0);
                        iResult = ERROR_FUNCTION_FAILED;
                    }

					break;
				}

				// if the column is not nullable but the result is an empty string, this is bad.
				if (!fColumnIsNullable && wzResult[0] == 0)
				{
					if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 4, &wzRow, &cchRow)))
						break;
		
					if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 2, &wzColumn, &cchColumn)))
						break;
						 
					FormattedLog(L">> Error: ModuleSubstitution entry for [%ls].[%ls] in row [%ls] is attempting to place an empty string in a non-nullable column.\r\n", wzTable, wzColumn, wzRow);
					if (m_pErrors)
					{
						CMsmError *pErr = new CMsmError(msmErrorBadNullSubstitution, NULL, -1);
						if (!pErr) 
						{
							iResult = ERROR_OUTOFMEMORY;
							break;
						}
						pErr->SetModuleTable(L"ModuleSubstitution");
						
						// primary keys in this error are Table/Row/Column
						pErr->AddModuleError(wzTable);
						pErr->AddModuleError(wzRow);
						pErr->AddModuleError(wzColumn);
							
						m_pErrors->Add(pErr);
					}
					iResult = ERROR_NO_DATA;
					break;
				}

				// set the result back into the column
				if (ERROR_SUCCESS != MsiRecordSetString(hRecord, iDatabaseColumn, wzResult))
				{
					iResult = ERROR_FUNCTION_FAILED;
					break;
				}
				else if (m_hFileLog != INVALID_HANDLE_VALUE)
				{	
					if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 2, &wzColumn, &cchColumn)))
						break;
						 
					FormattedLog(L"     * Configuring [%ls] column with value [%ls].\r\n", wzColumn, wzResult);
				}

			}
			else if (rgwchColumnType[0] == 'i' || rgwchColumnType[0]== 'I' || rgwchColumnType[0] == 'j' || rgwchColumnType[0]== 'J')
			{
				// integer column
				
				if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 3, &wzValueTemplate, &cchValueTemplate)))
					break;

				long lValue = MsiRecordGetInteger(hRecord, iDatabaseColumn);
					
				if (ERROR_SUCCESS != (iResult = PerformIntegerFieldSubstitution(wzValueTemplate, lValue)))
				{
					// if there was a failure, we're going to need the row and column names for the log
					DWORD iResult2 = ERROR_SUCCESS;
					if (ERROR_SUCCESS != (iResult2 = RecordGetString(hResultRec, 4, &wzRow, &cchRow)))
					{
						iResult = iResult2;
						break;
					}
		
					if (ERROR_SUCCESS != (iResult2 = RecordGetString(hResultRec, 2, &wzColumn, &cchColumn)))
					{
						iResult = iResult2;
						break;
					}
							
					if (ERROR_NO_MORE_ITEMS == iResult)
					{
						// one or more items was not listed in the ModuleConfiguration table. 
						FormattedLog(L">> Error: ModuleSubstitution entry for [%ls].[%ls] in row [%ls] uses a configuration item that does not exist.\r\n", wzTable, wzColumn, wzRow);
						if (m_pErrors)
						{
							CMsmError *pErr = new CMsmError(msmErrorMissingConfigItem, NULL, -1);
							if (!pErr) 
							{
								iResult =  ERROR_OUTOFMEMORY;
								break;
							}
							pErr->SetModuleTable(L"ModuleSubstitution");
							// primary keys in this error are Table/Row/Column
							pErr->AddModuleError(wzTable);
							pErr->AddModuleError(wzRow);
							pErr->AddModuleError(wzColumn);
													
							m_pErrors->Add(pErr);
						}

						iResult = ERROR_FUNCTION_FAILED;
					}
					else if (ERROR_BAD_FORMAT == iResult)
					{
						// resultant string was not an integer
						FormattedLog(L">> Error: ModuleSubstitution entry for [%ls].[%ls] in row [%ls] generated a non-integer string for an integer column.\r\n", wzTable, wzColumn, wzRow);
						if (m_pErrors)
						{
							CMsmError *pErr = new CMsmError(msmErrorBadSubstitutionType, NULL, -1);
							if (!pErr)
							{
								iResult =  ERROR_OUTOFMEMORY;
								break;
							}
							pErr->SetModuleTable(L"ModuleSubstitution");
							// primary keys in this error are Table/Row/Column
							pErr->AddModuleError(wzTable);
							pErr->AddModuleError(wzRow);
							pErr->AddModuleError(wzColumn);
													
							m_pErrors->Add(pErr);
						}

						iResult = ERROR_FUNCTION_FAILED;
					}
					else if (ERROR_NO_DATA == iResult)
					{
						// error object is generated closer to the actual point of failure where the actual
						// failure item is known. Just translate the error code and pass it back up the stack.
						iResult = ERROR_FUNCTION_FAILED;
					}
					else if (ERROR_FUNCTION_FAILED == iResult)
					{
						// no-op. Error code is correct.
					}
					else
                    {
						// unknown error code. This should never happen.
                        ASSERT(0);
                        iResult = ERROR_FUNCTION_FAILED;
                    }
					
					break;
				}
				
				if (ERROR_SUCCESS != MsiRecordSetInteger(hRecord, iDatabaseColumn, lValue))
				{
					iResult = ERROR_FUNCTION_FAILED;
					break;
				}
				else if (m_hFileLog != INVALID_HANDLE_VALUE)
				{	
					if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 2, &wzColumn, &cchColumn)))
						break;
						 
					FormattedLog(L"     * Configuring [%ls] column with value [%d].\r\n", wzColumn, lValue);
				}
			}
			else
			{
				// binary data column
				if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 4, &wzRow, &cchRow)))
					break;

				if (ERROR_SUCCESS != (iResult = RecordGetString(hResultRec, 2, &wzColumn, &cchColumn)))
					break;
					
				FormattedLog(L">> Error: ModuleSubstitution entry for [%ls] table attempted to configure the binary [%ls] column.\r\n", wzTable, wzColumn);
				if (m_pErrors)
				{
					CMsmError *pErr = new CMsmError(msmErrorBadSubstitutionType, NULL, -1);
					if (!pErr)
					{
						iResult =  ERROR_OUTOFMEMORY;
						break;
					}
					pErr->SetModuleTable(L"ModuleSubstitution");
					// primary keys in this error are Table/Row/Column
					pErr->AddModuleError(wzTable);
					pErr->AddModuleError(wzRow);
					pErr->AddModuleError(wzColumn);
											
					m_pErrors->Add(pErr);
				}
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}
		}


		// clean up memory, regardless of succeed or fail
		if (wzValueTemplate)
			delete[] wzValueTemplate;
		if (wzResult)
			delete[] wzResult;
		if (wzColumn)
			delete[] wzColumn;
		if (wzRow)
			delete[] wzRow;
	}

	// if there are 31 primary key columns and column30 was not modified by a substitution,
	// set the original value back into the record
	if (cPrimaryKeys == cMaxColumns && !fModified30)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRecord, cMaxColumns-1, wzOriginal30))
		{
			iResult = ERROR_FUNCTION_FAILED;
		}
	}

	if (wzOriginal30)
		delete[] wzOriginal30;

	// if the while loop terminated for a reason other than the query running out
	// of items, something bad has happened.
	if (iResult != ERROR_NO_MORE_ITEMS)
	{
		return iResult;
	}
	
	return ERROR_SUCCESS;
}	// end of ReplaceFeature


/////////////////////////////////////////////////////////////////////////////
// PerformTextFieldSubstitution
// Given a template value in wzValueTemplate, queries the authoring tool
// for any necessary configurable items, does the substitution, then 
// returns the result of the substitutions in wzResult and cchResult.
// this function might trash wzValueTemplate
UINT CMsmMerge::PerformTextFieldSubstitution(LPWSTR wzValueTemplate, LPWSTR* wzResult, DWORD* cchResult)
{
	// if no initial memory provided, create some.
	if (!*wzResult)
	{
		*cchResult = 72;
		*wzResult = new WCHAR[*cchResult];
		if ( ! *wzResult )
			return ERROR_OUTOFMEMORY;
	}

	WCHAR *wzSourceChar = wzValueTemplate;
	WCHAR *wzDestChar = *wzResult;
	unsigned int cchDest = 0;

	while (*wzSourceChar)
	{
		if (*wzSourceChar == '\\')
		{
			// escaped character
			wzSourceChar++;
		}
		else if ((*wzSourceChar == '[') && (*(wzSourceChar+1)=='='))
		{
			// need to do a item replacement
			WCHAR *wzItem = wzSourceChar+2;
			wzSourceChar = wcschr(wzItem, ']');
			if (!wzSourceChar)
				return ERROR_FUNCTION_FAILED;
			*(wzSourceChar++) = '\0';

			// query the private data table having the value for this property
			DWORD cchValue = 0;
			WCHAR *wzValue = NULL;

			// placeholder variables since we don't care about integer results
			bool fBitfield = false;
			long lValue = 0;
			long lMask = 0;
			
			// memory isn't shared, so length of buffer is irrelevant
			UINT iResult = GetConfigurableItemValue(wzItem, &wzValue, NULL, &cchValue, fBitfield, lValue, lMask);
			if (iResult == ERROR_NO_MORE_ITEMS)
			{
				return ERROR_NO_MORE_ITEMS;
			}
			else if (iResult == ERROR_NO_DATA)
			{
				return ERROR_NO_DATA;
			}
			else if (ERROR_SUCCESS != iResult)
				return ERROR_FUNCTION_FAILED;
				
			// ensure that there is enough memory to tack on the string (+1 for null)
			if (cchDest + cchValue >= *cchResult-1)
			{
				// null terminate to help wcsncpy pad the new buffer
				*wzDestChar = '\0';

				// create enough memory plus a bit more for future data.
				*cchResult = cchDest+cchValue+10;
				WCHAR *wzTemp = new WCHAR[*cchResult];
				if (!wzTemp)
				{
					delete[] wzValue;
					return ERROR_OUTOFMEMORY;
				}
				wcsncpy(wzTemp, *wzResult, *cchResult);
				delete[] *wzResult;
				*wzResult = wzTemp;
				wzDestChar = wzTemp + cchDest;
			}

			// append the value to the string
			wcscpy(wzDestChar, wzValue);
			wzDestChar += cchValue;
			cchDest += cchValue;
			delete[] wzValue;
			continue;
		}
		
		// copy the character
		*(wzDestChar++) = *(wzSourceChar++);
		cchDest++;

		// ensure we have plenty of memory
		if (cchDest == *cchResult-1)
		{
			// null terminate to help wcsncpy pad the new buffer
			*wzDestChar = '\0';

			*cchResult *= 2;
			WCHAR *wzTemp = new WCHAR[*cchResult];
			if (!wzTemp)
				return ERROR_OUTOFMEMORY;
			wcsncpy(wzTemp, *wzResult, *cchResult);
			delete[] *wzResult;
			*wzResult = wzTemp;
			wzDestChar = wzTemp + cchDest;
		}
	}			

	// null terminate the string
	*wzDestChar = '\0';
	return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
// PerformIntegerFieldSubstitution
// Given a template value in wzValueTemplate, queries the authoring tool
// for any necessary configurable items, does the substitution, then 
// returns the result of the substitutions in lResult. If the result
// is not an integer, this returns ERROR_BAD_FORMAT.
// this function might trash wzValueTemplate
UINT CMsmMerge::PerformIntegerFieldSubstitution(LPWSTR wzValueTemplate, long &lRetValue)
{
	DWORD dwResult = ERROR_SUCCESS;
	
	// if no initial memory provided, create some.
	DWORD cchResult = 72;
	WCHAR *wzResult = new WCHAR[cchResult];
	if (!wzResult)
		return ERROR_OUTOFMEMORY;

	// for bitmask fields, keep track of value and total mask
	bool fBitfieldOnly = true;
	ULONG lFinalMask = 0;
	ULONG lFinalValue = 0;

	WCHAR *wzSourceChar = wzValueTemplate;
	WCHAR *wzDestChar = wzResult;
	unsigned int cchDest = 0;

	while (*wzSourceChar)
	{
		if (*wzSourceChar == '\\')
		{
			// escaped character
			wzSourceChar++;
		}
		else if ((*wzSourceChar == '[') && (*(wzSourceChar+1)=='='))
		{
			// need to do a item replacement
			WCHAR *wzItem = wzSourceChar+2;
			wzSourceChar = wcschr(wzItem, ']');
			if (!wzSourceChar)
			{
				dwResult = ERROR_FUNCTION_FAILED;
				break;
			}
			*(wzSourceChar++) = '\0';

			// query the private data table having the value for this property
			DWORD cchValue = 0;
			WCHAR *wzValue = NULL;

			// memory isn't shared, so length of buffer is irrelevant
			bool fItemIsBitfield = false;
			long lValue = 0;
			long lMask = 0;
			UINT iResult = GetConfigurableItemValue(wzItem, &wzValue, NULL, &cchValue, fItemIsBitfield, lValue, lMask);
			if (iResult == ERROR_NO_MORE_ITEMS)
			{
				dwResult = ERROR_NO_MORE_ITEMS;
				break;
			}
			else if (iResult == ERROR_NO_DATA)
			{
				dwResult = ERROR_NO_DATA;
				break;
			}
			else if (ERROR_SUCCESS != iResult)
			{
				dwResult = ERROR_FUNCTION_FAILED;
				break;
			}

			// if this is a bitfield, we have to do some mask things
			if (fItemIsBitfield)
			{
				lFinalMask |= lMask;
				lFinalValue |= (lValue & lMask);
			}
			else
			{
				fBitfieldOnly = false;

				// ensure that there is enough memory to tack on the string (+1 for null)
				if (cchDest + cchValue >= cchResult-1)
				{
					// create enough memory plus a bit more for future data.
					cchResult = cchDest+cchValue+10;
					WCHAR *wzTemp = new WCHAR[cchResult];
					if (!wzTemp)
					{
						delete[] wzValue;
						dwResult = ERROR_OUTOFMEMORY;
						break;
					}
					wcsncpy(wzTemp, wzResult, cchResult);
					delete[] wzResult;
					wzResult = wzTemp;
					wzDestChar = wzTemp + cchDest;
				}

				// append the value to the string
				wcscpy(wzDestChar, wzValue);
				wzDestChar += cchValue;
				cchDest += cchValue;
			}
			
			if (wzValue)
				delete[] wzValue;
			continue;
		}
		
		// any non-property items means this isn't a bitfield
		fBitfieldOnly = false;
		
		// copy the character
		*(wzDestChar++) = *(wzSourceChar++);
		cchDest++;

		// ensure we have plenty of memory
		if (cchDest == cchResult-1)
		{
			cchResult *= 2;
			WCHAR *wzTemp = new WCHAR[cchResult];
			if (!wzTemp)
			{
				dwResult = ERROR_OUTOFMEMORY;
				break;
			}
			wcsncpy(wzTemp, wzResult, cchResult);
			delete[] wzResult;
			wzResult = wzTemp;
		}
	}			

	// on success, convert to integer unless its a bitfield
	if (dwResult == ERROR_SUCCESS)
	{
		// null terminate the string
		*wzDestChar = '\0';

		if (fBitfieldOnly)
		{
			// finished with a bitfield
			lRetValue = (lRetValue & ~lFinalMask) | lFinalValue;
		}
		else
		{
			// scan through the string looking for non-numeric characters.
			WCHAR *wzThisChar = wzResult;
			// The first character can be a + or - as well. 
			if ((*wzThisChar == L'+') || (*wzThisChar == '-'))
				wzThisChar++;
			while (*wzThisChar)
			{
				if (!iswdigit(*wzThisChar))
				{
					// this is logged further up the chain.
					delete[] wzResult;
					return ERROR_BAD_FORMAT;
				}
				wzThisChar++;
			}
			lRetValue = _wtol(wzResult);
		}
	}
	
	delete[] wzResult;	
	return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
// ProvideIntegerData
// calls the callback function via dispatch or direct call depending on
// what the callback supports. In the future, this might also handle
// calling direct C callbacks.
HRESULT CMsmMerge::ProvideIntegerData(LPCWSTR wzName, long *lData)
{
	HRESULT hRes = S_OK;

	// create a variant BSTR for the name
	BSTR bstrName = ::SysAllocString(wzName);
	
	if (m_piConfig)
		hRes = m_piConfig->ProvideIntegerData(bstrName, lData);
	else
	{
		VARIANTARG vArg;
		::VariantInit(&vArg);

		vArg.vt = VT_BSTR;
		vArg.bstrVal = bstrName;
		
		VARIANTARG vRet;

		// create the DISPPARMS structure containing the arguments
		DISPPARAMS args;
		args.rgvarg = &vArg;
		args.rgdispidNamedArgs = NULL;
		args.cArgs = 1;
		args.cNamedArgs = 0;
		hRes = m_piConfigDispatch->Invoke(m_iIntDispId, IID_NULL, GetUserDefaultLCID(), DISPATCH_METHOD, &args, &vRet, NULL, NULL);
		*lData = vRet.lVal;
	}
	::SysFreeString(bstrName);
	return hRes;
}


/////////////////////////////////////////////////////////////////////////////
// ProvideTextData
// calls the callback function via dispatch or direct call depending on
// what the callback supports. In the future, this might also handle
// calling direct C callbacks.
HRESULT CMsmMerge::ProvideTextData(LPCWSTR wzName, BSTR* pBStr)
{
	HRESULT hRes = S_OK; 

	// create a variant BSTR for the name
	BSTR bstrName = ::SysAllocString(wzName);
	
	if (m_piConfig)
		hRes = m_piConfig->ProvideTextData(bstrName, pBStr);
	else
	{
		VARIANTARG vArg;
		::VariantInit(&vArg);

		vArg.vt = VT_BSTR;
		vArg.bstrVal = bstrName;

		VARIANTARG vRet;
	
		// create the DISPPARMS structure containing the arguments
		DISPPARAMS args;
		args.rgvarg = &vArg;
		args.rgdispidNamedArgs = NULL;
		args.cArgs = 1;
		args.cNamedArgs = 0;
		hRes = m_piConfigDispatch->Invoke(m_iTxtDispId, IID_NULL, GetUserDefaultLCID(), DISPATCH_METHOD, &args, &vRet, NULL, NULL);
		*pBStr = vRet.bstrVal;
	}
	::SysFreeString(bstrName);
	return hRes;
}


/////////////////////////////////////////////////////////////////////////////
// GetConfigurableItemValue
// Given an item name in wzItem and (optionally) a memory blob, grabs the 
// value for the item, asking the user if necessary. wzValue might be
// reallocated. Returns one of ERROR_NO_MORE_ITEMS if the item doesn't exist,
// ERROR_NO_DATA if a bad NULL value was returned, ERROR_SUCCESS, E_OUTOFMEMORY, 
// and ERROR_FUNCTION_FAILED for all other failures.
UINT CMsmMerge::GetConfigurableItemValue(LPCWSTR wzItem, LPWSTR *wzValue, DWORD* cchBuffer, DWORD* cchLength,
	bool& fIsBitfield, long &lValue, long& lMask)
{
	UINT iResult = ERROR_SUCCESS;
	
	// if for some reason there is no query, we can't retrieve the item value
	if (!m_pqGetItemValue)
		return ERROR_FUNCTION_FAILED;

	// if wzItem contains a semicolon, this should be a Item;# format for a key, returning
	// a substring of the actual item.
	WCHAR *wzColumn = NULL;
	if (wzColumn = wcschr(wzItem, L';'))
	{
		// null terminate wzItem and set wzColumn to the first character of the column specifier
		*(wzColumn++)='\0';
	}
	
	// create a record for use in executing the query and place the item name in field 1
	PMSIHANDLE hQueryRec = MsiCreateRecord(2);
	if (hQueryRec == 0)
		return ERROR_FUNCTION_FAILED;

	if (ERROR_SUCCESS != ::MsiRecordSetStringW(hQueryRec, 1, wzItem))
		return ERROR_FUNCTION_FAILED;

	int iColumn = wzColumn ? _wtol(wzColumn) : 1;
	if (ERROR_SUCCESS != ::MsiRecordSetInteger(hQueryRec, 2, iColumn))
		return ERROR_FUNCTION_FAILED;

	// execute the query to get the item state
	if (ERROR_SUCCESS != m_pqGetItemValue->Execute(hQueryRec))
		return ERROR_FUNCTION_FAILED;

	PMSIHANDLE hItemRec;
	if (ERROR_SUCCESS != m_pqGetItemValue->Fetch(&hItemRec))
	{
		// item does not exist
		if (wzColumn)
			FormattedLog(L">> Error: Column %d of ModuleConfiguration item [%ls] does not exist .\r\n", iColumn, wzItem);
		else
			FormattedLog(L">> Error: ModuleConfiguration item [%ls] does not exist .\r\n", wzItem);
		return ERROR_NO_MORE_ITEMS;
	}

	// determine if this is a bitfield item
	int iItemFormat = ::MsiRecordGetInteger(hItemRec, iValueTableFormat);
	fIsBitfield = (iItemFormat == msmConfigurableItemBitfield);
	bool fIsKey = (iItemFormat == msmConfigurableItemKey);
	
	// if the item is a bitfield, we'll always need to set the mask, so do that now
	lMask = fIsBitfield ? ::MsiRecordGetInteger(hItemRec, iValueTableMask) : 0;
	lValue = 0;

	// if we've already asked the user for a value, there's no need to ask the user
	// again for the same thing
	if (1 != ::MsiRecordGetInteger(hItemRec, iValueTablePrompted))
	{
		// mark this item as "prompted". Even if something goes wrong, we shouldn't ask again
		CQuery qUpdate;
		if (ERROR_SUCCESS != qUpdate.OpenExecute(m_hModule, hQueryRec, L"UPDATE `__ModuleConfig` SET `Prompted`=1 WHERE `Name`=?"))
		{
			FormattedLog(L">> Error: Unable to save response to ModuleConfiguration item [%ls].\r\n", wzItem);
			iResult = ERROR_FUNCTION_FAILED;
		}
		else
			iResult = ERROR_SUCCESS;


		// need to set prompted value here because the update query will get clobbered by any later updates
		// on this record
		MsiRecordSetInteger(hItemRec, iValueTablePrompted, 1);

		HRESULT hResult = S_OK;
    	BSTR bstrData = NULL;
		long lData;

		if (ERROR_SUCCESS == iResult)
		{
			if (iItemFormat == msmConfigurableItemInteger || iItemFormat == msmConfigurableItemBitfield)
			{
				hResult = ProvideIntegerData(wzItem, &lData);
			}
			else
			{
				hResult = ProvideTextData(wzItem, &bstrData);
				if ((S_OK == hResult) && (!bstrData || !bstrData[0]))
				{
					// if the response was null, we need to check for the non-nullable attribute on this
					// item.
					CQuery qNullable;
					PMSIHANDLE hRes;
					if (ERROR_SUCCESS != qNullable.FetchOnce(m_hModule, hQueryRec, &hRes, L"SELECT `Attributes` FROM `ModuleConfiguration` WHERE `Name`=?"))
					{
						iResult = ERROR_FUNCTION_FAILED;
					}
					else
					{
						DWORD dwAttributes = MsiRecordGetInteger(hRes, 1);
						if (dwAttributes == MSI_NULL_INTEGER)
							dwAttributes = 0;
						if (dwAttributes & 2) // non-nullable attribute
						{
							// returning NULL for a non-nullable item is catastrophic
							iResult = ERROR_NO_DATA;

							FormattedLog(L">> Error: Received NULL for non-nullable ModuleConfiguration Item [%ls].\r\n", wzItem);

							if (m_pErrors)
							{
								CMsmError *pErr = new CMsmError(msmErrorBadNullResponse, NULL, -1);
								if (!pErr) 
								{
									iResult = ERROR_OUTOFMEMORY;
								}
								else
								{
									pErr->SetModuleTable(L"ModuleConfiguration");
									// primary keys in this error are Table/Row/Column
									pErr->AddModuleError(wzItem);
									m_pErrors->Add(pErr);
								}
							}
						}
					}
				}
			}
		}
		if (iResult == ERROR_SUCCESS)
		{
			switch (hResult)
			{
			case S_OK:
				// update the value in the record with the provided value
				if (iItemFormat == msmConfigurableItemInteger || iItemFormat == msmConfigurableItemBitfield)
				{
					if (ERROR_SUCCESS != MsiRecordSetInteger(hItemRec, iValueTableValue, lData))
					{
						iResult = ERROR_FUNCTION_FAILED;
						break;
					}
				
					if (ERROR_SUCCESS != m_pqGetItemValue->Modify(MSIMODIFY_UPDATE, hItemRec))
					{
						FormattedLog(L">> Error: Unable to save response to ModuleConfiguration item [%ls].\r\n", wzItem);
						iResult = ERROR_FUNCTION_FAILED;
						break;
					}
				}
				else
				{
					// if this is a key item, we need to split the result into primary 
					// keys and update multiple records. Otherwise we just need to update the one key
					// (don't need to update anything except the "prompted" value if the answer is S_FALSE, 
					// because the defaults are already the correct value
					if (fIsKey)
					{
						// if the provided value is NULL, we can't split it into primary keys, so we explicitly
						// set all values to "";
						if (!bstrData || bstrData[0] == L'\0')
						{
							// an empty string (or NULL) response is equivalent to an all-null primary key, but since
							// we don't know how many columns are in the target key, we can't compare values explicitly.
							// Thus query for any default value in this key that is NOT null. If there is one, we aren't
							// using the default
							CQuery qIsNotNull;
							int iDefault = 1;
							PMSIHANDLE hUnusedRec;
							if (ERROR_SUCCESS == qIsNotNull.FetchOnce(m_hModule, hQueryRec, &hUnusedRec, L"SELECT NULL FROM `__ModuleConfig` WHERE `Name`=? AND `Value` IS NOT NULL"))
							{
								iDefault = 0;
							}
							
							CQuery qUpdate;
							if (ERROR_SUCCESS != qUpdate.OpenExecute(m_hModule, hQueryRec, L"UPDATE `__ModuleConfig` SET `Value`='', `Default`=%d WHERE `Name`=?", iDefault))
							{
								FormattedLog(L">> Error: Unable to save response to ModuleConfiguration item [%ls].\r\n", wzItem);
								iResult = ERROR_FUNCTION_FAILED;
							}
							else
								iResult = ERROR_SUCCESS;

							// set null into hItemRec for retrieval later
							MsiRecordSetStringW(hItemRec, iValueTableValue, L"");
							break;
						}
					
						// check if the provided response is the same as the default value for this item. If it is,
						// we don't really need to do any value updates. Don't need column two of hQueryRec anymore
						if (ERROR_SUCCESS != (iResult = ::MsiRecordSetString(hQueryRec, 2, bstrData)))
							break;
							
						// Something with primary key "Name" must exist or we wouldn't have created these rows. Thus a failure
						// must mean that the default value wasn't the same. (or catastrophic failure, but oh well)
						{
							CQuery qIsDefault;
							PMSIHANDLE hResRec;
							if (ERROR_SUCCESS != qIsDefault.FetchOnce(m_hModule, hQueryRec, &hResRec, L"SELECT `Name` FROM `ModuleConfiguration` WHERE `Name`=? AND `DefaultValue`=?"))
							{
								CQuery qUpdate;
								if (ERROR_SUCCESS != qUpdate.OpenExecute(m_hModule, hQueryRec, L"UPDATE `__ModuleConfig` SET `Default`=0 WHERE `Name`=?"))
								{
									FormattedLog(L">> Error: Unable to save response to ModuleConfiguration item [%ls].\r\n", wzItem);
									iResult = ERROR_FUNCTION_FAILED;
									break;
								}
								else
									iResult = ERROR_SUCCESS;
							}
							else
							{
								// mark as prompted since the default matches													
								CQuery qUpdate;
								if (ERROR_SUCCESS != qUpdate.OpenExecute(m_hModule, hQueryRec, L"UPDATE `__ModuleConfig` SET `Default`=1 WHERE `Name`=?"))
								{
									FormattedLog(L">> Error: Unable to save response to ModuleConfiguration item [%ls].\r\n", wzItem);
									iResult = ERROR_FUNCTION_FAILED;
								}
								else
									iResult = ERROR_SUCCESS;
								break;
							}

						}
						
						// to null for this item. 
						PMSIHANDLE hKeyRec = ::MsiCreateRecord(32);
						int cExpectedKeys = 0;
						if (ERROR_SUCCESS != SplitConfigStringIntoKeyRec(bstrData, hKeyRec, cExpectedKeys, 1))
						{
							FormattedLog(L">> Error: Failed to split response to ModuleConfiguration item [%ls] into primary keys.", wzItem);
							iResult = ERROR_FUNCTION_FAILED;
							break;
						}
						for (int cColumn = 1; cColumn <= cExpectedKeys; cColumn++)
						{
							if (ERROR_SUCCESS != ::MsiRecordSetInteger(hQueryRec, 2, cColumn))
							{
								// this should never fail.
								return ERROR_FUNCTION_FAILED;
							}

							if (ERROR_SUCCESS != m_pqGetItemValue->Execute(hQueryRec))
							{
								// this should never fail.
								return ERROR_FUNCTION_FAILED;
							}

							if (ERROR_SUCCESS != m_pqGetItemValue->Fetch(&hItemRec))
							{
								// we're lost because one of the primary key items doesn't exist. This
								// is a mismatch between what the default value is, how many keys
								// are in the table, and what the provided value is
								FormattedLog(L">> Error: ModuleConfiguration item [%ls] provided the incorrect number of primary key values.\r\n", wzItem);
								iResult = ERROR_FUNCTION_FAILED;
							}

							// retrieve the key into the temporary buffer
							if (ERROR_SUCCESS != (iResult = RecordGetString(hKeyRec, cColumn, NULL)))
							{
								// iResult is E_F_F or E_O_M, both of which are good return codes for this function
								FormattedLog(L">> Error: Failed to retrieve primary key column %d of response to ModuleConfiguration item [%ls].\r\n", cColumn, wzItem);
								break;
							}
							MsiRecordSetString(hItemRec, iValueTableValue, m_wzBuffer);
							if (ERROR_SUCCESS != m_pqGetItemValue->Modify(MSIMODIFY_UPDATE, hItemRec))
							{
								FormattedLog(L">> Error: Unable to save primary key column %d of response to ModuleConfiguration item [%ls].\r\n", cColumn, wzItem);
								iResult = ERROR_FUNCTION_FAILED;
								break;
							}
						}

						// need to re-execute original query to get the exact column that was requested
						::MsiRecordSetInteger(hQueryRec, 2, iColumn);
						if (ERROR_SUCCESS != m_pqGetItemValue->Execute(hQueryRec))
							return ERROR_FUNCTION_FAILED;
						if (ERROR_SUCCESS != m_pqGetItemValue->Fetch(&hItemRec))
							return ERROR_FUNCTION_FAILED;
					}			
					else
					{
						if (ERROR_SUCCESS != MsiRecordSetStringW(hItemRec, iValueTableValue, bstrData))
						{
							iResult = ERROR_FUNCTION_FAILED;
							break;
						}
						if (ERROR_SUCCESS != m_pqGetItemValue->Modify(MSIMODIFY_UPDATE, hItemRec))
						{
							FormattedLog(L">> Error: Unable to save response to ModuleConfiguration item [%ls].\r\n", wzItem);
							iResult = ERROR_FUNCTION_FAILED;
							break;
						}
					}
				}
				break;
			case S_FALSE:
				{
					// user declined to provide a value, so Prompted is now true and Default remains true.
					iResult = ERROR_SUCCESS;
					break;
				}
			default:
				FormattedLog(L">> Error: Client callback returned error code 0x%8x in response to a request for ModuleConfiguration item [%ls].\r\n", hResult, wzItem);
				if (m_pErrors)
				{
					CMsmError *pErr = new CMsmError(msmErrorDataRequestFailed, NULL, -1);
					if (!pErr) 
					{
						iResult = E_OUTOFMEMORY;
						break;
					}
					pErr->SetModuleTable(L"ModuleConfiguration");
					pErr->AddModuleError(wzItem);
					m_pErrors->Add(pErr);
				}
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}
		}

		// free any BSTR that came back as client data
		if (bstrData)
			::SysFreeString(bstrData);
	}

	// now we've asked the user for the value if necessary. We should retrieve the string from the table 
	// and if it is a key type, un-escape the appropriate item
	if (ERROR_SUCCESS == iResult)
	{
		iResult = RecordGetString(hItemRec, iValueTableValue, wzValue, cchBuffer, cchLength);
		if (iResult == ERROR_SUCCESS && (iItemFormat == msmConfigurableItemInteger || iItemFormat == msmConfigurableItemBitfield))
		{
			lValue = ::MsiRecordGetInteger(hItemRec, iValueTableValue);
		}
	}
		
	return iResult;
}



///////////////////////////////////////////////////////////////////////
// DeleteOrphanedConfigKeys
// after all configuration is done, checks "Key" types for items with
// the "NoOrphan" bit set. If all items that refer to the same row
// were changed from the default value, the default row is deleted
// from the database.
// returns one of ERROR_SUCCESS, ERROR_OUTOFMEMORY, or ERROR_FUNCTION_FAILED
UINT CMsmMerge::DeleteOrphanedConfigKeys(CSeqActList& lstDirActions)
{
	FormattedLog(L"Removing rows orphaned by configuration changes.\r\n");
	CQuery qTable;

	// put DefaultValue first in the query so it can be passed to the DELETE query as a record substitution
	if (ERROR_SUCCESS != qTable.OpenExecute(m_hModule, 0, TEXT("SELECT DISTINCT `DefaultValue`, `Type` FROM `ModuleConfiguration` WHERE `Format`=1")))
	{
		FormattedLog(L">> Error: Failed to query ModuleConfiguration table for tables containing orphaned items.\r\n");
		return ERROR_FUNCTION_FAILED;
	}

	// when querying the __ModuleConfig table, we only worry about column 1. Attributes for all columns should be 
	// the same.
	CQuery qConfigItem;
	if (ERROR_SUCCESS != qConfigItem.Open(m_hModule, TEXT("SELECT `ModuleConfiguration`.`Name`, `Prompted`, `Attributes`, `KeyExists`, `Value`, `Default` FROM `ModuleConfiguration`, `__ModuleConfig` WHERE `ModuleConfiguration`.`Name`=`__ModuleConfig`.`Name` AND `__ModuleConfig`.`Column`=1 AND `ModuleConfiguration`.`DefaultValue`=? AND `ModuleConfiguration`.`Type`=?")))
	{
		FormattedLog(L">> Error: Failed to query ModuleConfiguration table for orphaned item state.\r\n");
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hTableRow;
	UINT iResult = ERROR_SUCCESS;
	WCHAR *wzDefaultValue = NULL;
	DWORD cchDefaultValue = 0;
	WCHAR *wzThisValue = NULL;
	DWORD cchThisValue = 0;
	WCHAR *wzTable = NULL;
	DWORD cchTable = 0;
	WCHAR *wzSQL = NULL;
	DWORD cchSQL = 0;
	while (ERROR_SUCCESS == (iResult = qTable.Fetch(&hTableRow)))
	{
		if (ERROR_SUCCESS != (iResult = RecordGetString(hTableRow, 1, &wzDefaultValue, &cchDefaultValue, NULL)))
		{
			break;
		}

		if (ERROR_SUCCESS != qConfigItem.Execute(hTableRow))
		{
			iResult = ERROR_FUNCTION_FAILED;
			break;
		}

		if (ERROR_SUCCESS != (iResult = RecordGetString(hTableRow, 2, &wzTable, &cchTable)))
		{
			break;
		}
	
		// if the table isn't in the module, the module is technically incorrectly authored, but since
		// there obviously won't be a key to delete, we should not complain too much.
		if (MSICONDITION_TRUE != MsiDatabaseIsTablePersistent(m_hModule, wzTable))
		{
			continue;
		}

		bool fDelete = false;
		bool fDeleteCAs = false;
		bool fBreak = false;
		PMSIHANDLE hItemRec;
		while (ERROR_SUCCESS == (iResult = qConfigItem.Fetch(&hItemRec)))
		{
			// if we never prompted for this one, it was never used in the ModuleSub table
			// these items do not count either way in the deletion decision.
			if (1 != ::MsiRecordGetInteger(hItemRec, 2))
				continue;

			// if this item is not marked No Orphan, we can't delete the row or any CAs
			if (!(::MsiRecordGetInteger(hItemRec, 3) & 1))
			{
				fDelete = false;
				fDeleteCAs = false;
				break;
			}
			
			// we don't delete the row unless at least one reference to it exists
			// and is marked "no-orphan". Otherwise, a row with no prompted 
			// ModuleSubstitution entry would get removed regardless of NoOrphan
			// attribute. Only set this value if we haven't already decided to 
			// delete custom actions. That would mean that we've already explicitly
			// decided not to delete the row, so resetting the delete flag would
			// be wrong.
			if (!fDeleteCAs)
				fDelete = true;

			// if the key pre-existed in the database, we can't delete the row, but we still might delete 
			// any custom actions that were generated by the addition of this row.
			if (1 == ::MsiRecordGetInteger(hItemRec, 4))
			{
				// don't log the fact that the row existed more than once.
				if (fDelete)
				{
					FormattedLog(L"   o Not removing [%ls] from [%ls] table, row existed in database before merge.\r\n", wzDefaultValue, wzTable);
					fDelete = false;
				}

				// if the row pre-existed in the database, we don't want to delete the row itself, but we still might delete
				// custom actions in the sequence table that were indirectly generated.
				fDeleteCAs = true;

				// at this point, we can't break out of this loop because some later row in the Configuration table might
				// turn off both row deletion and CA deletion.
			}

			// if the value is the defaultvalue, we can't delete the row or any generated CAs
			if (1 == ::MsiRecordGetInteger(hItemRec, 6))
			{
				// don't log conflicting reasons. Another row may have already turned off deletion.
				if (fDelete)
					FormattedLog(L"   o Not removing [%ls] from [%ls] table, row is still referenced by item.\r\n", wzDefaultValue, wzTable);

				fDelete = false;
				fDeleteCAs = false;
				break;
			}		
		}

		// if we stopped because there were no more matching NoOrphan bits, everything is OK
		// and we can check the delete state. 
		if (iResult == ERROR_NO_MORE_ITEMS)
			iResult = ERROR_SUCCESS;

		if ((iResult == ERROR_SUCCESS) && fDelete)
		{
			FormattedLog(L"   o Deleting orphaned row [%ls] from [%ls] table.\r\n", wzDefaultValue, wzTable);

			// retrieve the number of primary keys 
			PMSIHANDLE hKeyRec;
			if (ERROR_SUCCESS != MsiDatabaseGetPrimaryKeysW(m_hModule, wzTable, &hKeyRec))
			{
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}
			int cPrimaryKeys = ::MsiRecordGetFieldCount(hKeyRec);
			if (cPrimaryKeys > cMaxColumns || cPrimaryKeys < 1)
			{
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}
				
			if (ERROR_SUCCESS != MsiDatabaseGetPrimaryKeysW(m_hModule, wzTable, &hKeyRec))
			{
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}

			// build up the SQL query to check the primary keys for a match
			MsiRecordSetString(hKeyRec, 0, g_sqlKeyQueryTemplate);
			if (!wzSQL)
			{
				cchSQL = 72;
				wzSQL = new WCHAR[cchSQL];
				if (!wzSQL)
				{
					iResult = ERROR_OUTOFMEMORY;
					break;
				}
			}
			// on success returns number of chars, not number of bytes, so must pass dummy
			// integer to avoid needless reallocations if buffer is the same size.
			DWORD cchTempSQL = cchSQL;
			if (ERROR_MORE_DATA == (iResult = MsiFormatRecord(NULL, hKeyRec, wzSQL, &cchTempSQL)))
			{
				// on failure returns the number chars required
				cchSQL = cchTempSQL+1;
				if (wzSQL)
					delete[] wzSQL;
				wzSQL = new WCHAR[cchSQL];
				if (!wzSQL)
				{
					iResult = ERROR_OUTOFMEMORY;
					break;
				}
				iResult = MsiFormatRecord(NULL, hKeyRec, wzSQL, &cchTempSQL);
			}
			if (ERROR_SUCCESS != iResult)
			{
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}

			// open the query to delete the row
			CQuery qDeleteRow;
			if (ERROR_SUCCESS != qDeleteRow.Open(m_hDatabase, L"DELETE FROM `%ls` WHERE %ls", wzTable, wzSQL))
			{
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}	

			// split the semicolon-delimited list of keys into individual keys
			if (ERROR_SUCCESS != (iResult = SplitConfigStringIntoKeyRec(wzDefaultValue, hKeyRec, cPrimaryKeys, 1)))
			{
				WCHAR *wzTemp = NULL;
				if (ERROR_SUCCESS == RecordGetString(hTableRow, 1, &wzDefaultValue, &cchDefaultValue))
				{
					wzTemp = wzDefaultValue;
				}
				else
					wzTemp = L"<error retrieving data>";
				FormattedLog(L">> Error: Failed to split ModuleConfiguration default value [%ls] into primary keys for table [%ls].", wzTemp, wzTable);
				break;
			}

			if (ERROR_SUCCESS != qDeleteRow.Execute(hKeyRec))
			{
				iResult = ERROR_FUNCTION_FAILED;
				break;
			}
		}

		if ((iResult == ERROR_SUCCESS) && (fDelete || fDeleteCAs))
		{
			// if the no-orphan target is in the directory table, it might be a generated custom action.
			// if so, it needs to be deleted as well. It ALSO needs to be deleted if the directory table
			// row pre-existed but would have been deleted if it hadn't. (Just because the directory table
			// row pre-existed doesn't mean that the action did)
			if (0 == wcscmp(wzTable, g_wzDirectoryTable))
			{
				CDirSequenceAction* pDirAction = static_cast<CDirSequenceAction*>(lstDirActions.FindAction(wzDefaultValue));
				if (!pDirAction)
					continue;
						
				for (int iTable = stnFirst; iTable < stnNext; iTable++)
				{
					// if the action didn't exist and was added, delete it.
					if (pDirAction->m_dwSequenceTableFlags & (1 << iTable))
					{
						// open the query to delete the row
						CQuery qDeleteRow;
						if (ERROR_SUCCESS != qDeleteRow.OpenExecute(m_hDatabase, hTableRow, L"DELETE FROM `%ls` WHERE `Action`=?", g_rgwzMSISequenceTables[iTable]))
						{
							iResult = ERROR_FUNCTION_FAILED;
							break;
						}	
					}
				}
			}
		}

		// if anything in this loop failed but didn't explicitly break, do so now.
		if (ERROR_SUCCESS != iResult)
			break;
	}
	if (wzThisValue)
		delete[] wzThisValue;
	if (wzDefaultValue)
		delete[] wzDefaultValue;
	if (wzSQL)
		delete[] wzSQL;
	if (wzTable)
		delete[] wzTable;

	// if we stopped for any reason other than running out of data, something went wrong
	if (ERROR_NO_MORE_ITEMS == iResult)
		return ERROR_SUCCESS;
		
	return ERROR_FUNCTION_FAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmdep.h ===
/////////////////////////////////////////////////////////////////////////////
// dep.h
//		Declares IMsmDependency interface
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#ifndef __IENUM_MSM_DEP__
#define __IENUM_MSM_DEP__

#include "mergemod.h"

#define MAX_MODULEID 72
#define MAX_VERSION 32

class CMsmDependency : public IMsmDependency
{

public:
	CMsmDependency(LPCWSTR wzModule, short nLanguage, LPCWSTR wzVersion);
	~CMsmDependency();

	// IUnknown interface
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID& iid, void** ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDispatch methods
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT* pctInfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTI);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
														 LCID lcid, DISPID* rgDispID);
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
											   DISPPARAMS* pDispParams, VARIANT* pVarResult,
												EXCEPINFO* pExcepInfo, UINT* puArgErr);
	HRESULT STDMETHODCALLTYPE InitTypeInfo();

	// IMsmDependency interface
	HRESULT STDMETHODCALLTYPE get_Module(BSTR* Module);
	HRESULT STDMETHODCALLTYPE get_Language(short* Language);
	HRESULT STDMETHODCALLTYPE get_Version(BSTR* Version);

private:
	long m_cRef;
	ITypeInfo* m_pTypeInfo;

	// member variables
	WCHAR m_wzModule[MAX_MODULEID + 1];
	short m_nLanguage;
	WCHAR m_wzVersion[MAX_VERSION + 1];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmerror.cpp ===
/////////////////////////////////////////////////////////////////////////////
// error.cpp
//		Implements IMsmError interface
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#include "..\common\trace.h"
#include "mmerror.h"
#include "globals.h"
///////////////////////////////////////////////////////////
// constructor	
CMsmError::CMsmError(msmErrorType metType, LPWSTR wzPath, short nLanguage)
{
	// initial count
	m_cRef = 1;

	// no type info yet
	m_pTypeInfo = NULL;

	// 
	m_metError = metType;
	if (NULL == wzPath)
		m_wzPath[0] = L'\0';
	else	// there is something to copy over
	{
		wcsncpy(m_wzPath, wzPath, MAX_PATH);
		m_wzPath[MAX_PATH] = L'\0';
	}
	m_nLanguage = nLanguage;

	m_wzModuleTable[0] = 0;
	m_wzDatabaseTable[0] = 0;

	// create new string collections
	m_pDatabaseKeys = new CMsmStrings;
	m_pModuleKeys = new CMsmStrings;

	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
CMsmError::~CMsmError()
{
	if (m_pDatabaseKeys)
		m_pDatabaseKeys->Release();

	if (m_pModuleKeys)
		m_pModuleKeys->Release();

	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor

///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT CMsmError::QueryInterface(const IID& iid, void** ppv)
{
	TRACEA("CMsmError::QueryInterface - called, IID: %d\n", iid);

	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IMsmError*>(this);
	else if (iid == IID_IMsmError)
		*ppv = static_cast<IMsmError*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CMsmError::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CMsmError::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// IDispatch interface

HRESULT CMsmError::GetTypeInfoCount(UINT* pctInfo)
{
	if(NULL == pctInfo)
		return E_INVALIDARG;

	*pctInfo = 1;	// only one type info supported by this dispatch

	return S_OK;
}

HRESULT CMsmError::GetTypeInfo(UINT iTInfo, LCID /* lcid */, ITypeInfo** ppTypeInfo)
{
	if (0 != iTInfo)
		return DISP_E_BADINDEX;

	if (NULL == ppTypeInfo)
		return E_INVALIDARG;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	*ppTypeInfo = m_pTypeInfo;
	m_pTypeInfo->AddRef();

	return S_OK;
}

HRESULT CMsmError::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
						 LCID lcid, DISPID* rgDispID)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID);
}

HRESULT CMsmError::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
				  DISPPARAMS* pDispParams, VARIANT* pVarResult,
				  EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr = S_OK;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->Invoke((IDispatch*)this, dispIdMember, wFlags, pDispParams, pVarResult,
										pExcepInfo, puArgErr);
}

HRESULT CMsmError::InitTypeInfo()
{
	HRESULT hr = S_OK;
	ITypeLib* pTypeLib = NULL;

	// if there is no info loaded
	if (NULL == m_pTypeInfo)
	{
		// try to load the Type Library into memory. For SXS support, do not load from registry, rather
		// from launched instance
		hr = LoadTypeLibFromInstance(&pTypeLib);
		if (FAILED(hr))
		{
			TRACEA("CMsmError::InitTypeInfo - failed to load TypeLib[0x%x]\n", LIBID_MsmMergeTypeLib);
			return hr;
		}

		// try to get the Type Info for this Interface
		hr = pTypeLib->GetTypeInfoOfGuid(IID_IMsmError, &m_pTypeInfo);
		if (FAILED(hr))
		{
			TRACEA("CMsmError::InitTypeInfo - failed to get inteface[0x%x] from TypeLib[0x%x]\n", IID_IMsmError, LIBID_MsmMergeTypeLib);

			// no type info was loaded
			m_pTypeInfo = NULL;
		}

		pTypeLib->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IMsmError interface

///////////////////////////////////////////////////////////
// get_Type
HRESULT CMsmError::get_Type(msmErrorType* ErrorType)
{
	// error check
	if (!ErrorType)
		return E_INVALIDARG;

	*ErrorType = m_metError;
	return S_OK;
}	// end of get_Type

///////////////////////////////////////////////////////////
// get_Path
HRESULT CMsmError::get_Path(BSTR* ErrorPath)
{
	// error check
	if (!ErrorPath)
		return E_INVALIDARG;

	// copy over the string
	*ErrorPath = ::SysAllocString(m_wzPath);
	if (!*ErrorPath)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_Path

///////////////////////////////////////////////////////////
// get_Language
HRESULT CMsmError::get_Language(short* ErrorLanguage)
{
	// error check
	if (!ErrorLanguage)
		return E_INVALIDARG;

	*ErrorLanguage = m_nLanguage;
	return S_OK;
}	// end of get_Language

///////////////////////////////////////////////////////////
// get_DatabaseTable
HRESULT CMsmError::get_DatabaseTable(BSTR* ErrorTable)
{
	// error check
	if (!ErrorTable)
		return E_INVALIDARG;

	// copy over the string
	*ErrorTable = ::SysAllocString(m_wzDatabaseTable);
	if (!*ErrorTable)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_DatabaseTable

///////////////////////////////////////////////////////////
// get_DatabaseKeys
HRESULT CMsmError::get_DatabaseKeys(IMsmStrings** ErrorKeys)
{
	// error check
	if (!ErrorKeys)
		return E_INVALIDARG;

	*ErrorKeys = (IMsmStrings*)m_pDatabaseKeys;
	m_pDatabaseKeys->AddRef();
	return S_OK;
}	// end of get_DatabaseKeys

///////////////////////////////////////////////////////////
// get_ModuleTable
HRESULT CMsmError::get_ModuleTable(BSTR* ErrorTable)
{
	// error check
	if (!ErrorTable)
		return E_INVALIDARG;

	// copy over the string
	*ErrorTable = ::SysAllocString(m_wzModuleTable);
	if (!*ErrorTable)
		return E_OUTOFMEMORY;

	return S_OK;
}	// end of get_ModuleTable

///////////////////////////////////////////////////////////
// get_ModuleKeys
HRESULT CMsmError::get_ModuleKeys(IMsmStrings** ErrorKeys)
{
	// error check
	if (!ErrorKeys)
		return E_INVALIDARG;

	*ErrorKeys = (IMsmStrings*)m_pModuleKeys;
	m_pModuleKeys->AddRef();
	return S_OK;
}	// end of get_ModuleKeys


/////////////////////////////////////////////////////////////////////////////
// non-interface methods

///////////////////////////////////////////////////////////
// SetDatabaseTable
void CMsmError::SetDatabaseTable(LPCWSTR wzTable)
{
	ASSERT(wzTable);
	wcsncpy(m_wzDatabaseTable, wzTable, MAX_TABLENAME);
	m_wzDatabaseTable[MAX_TABLENAME] = L'\0';
}	// end of SetDatabaseTable

///////////////////////////////////////////////////////////
// SetModuleTable
void CMsmError::SetModuleTable(LPCWSTR wzTable)
{
	ASSERT(wzTable);
	wcsncpy(m_wzModuleTable, wzTable, MAX_TABLENAME);
	m_wzModuleTable[MAX_TABLENAME] = L'\0';
}	// end of SetModuleTable

///////////////////////////////////////////////////////////
// AddDatabaseError
void CMsmError::AddDatabaseError(LPCWSTR wzError)
{
	ASSERT(wzError);
	m_pDatabaseKeys->Add(wzError);
}	// end of AddDatabaseError

///////////////////////////////////////////////////////////
// AddModuleError
void CMsmError::AddModuleError(LPCWSTR wzError)
{
	ASSERT(wzError);
	m_pModuleKeys->Add(wzError);
}	// end of AddModuleError
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmquery.cpp ===
#include "..\common\query.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmerror.h ===
/////////////////////////////////////////////////////////////////////////////
// error.h
//		Declares IMsmError interface
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#ifndef __IENUM_MSM_ERROR__
#define __IENUM_MSM_ERROR__

#include "mergemod.h"
#include "mmstrs.h"

#define MAX_TABLENAME 32

class CMsmError : public IMsmError
{

public:
	CMsmError(msmErrorType metType, LPWSTR wzPath, short nLanguage);
	~CMsmError();

	// IUnknown interface
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID& iid, void** ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDispatch methods
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT* pctInfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTI);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
														 LCID lcid, DISPID* rgDispID);
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
											   DISPPARAMS* pDispParams, VARIANT* pVarResult,
												EXCEPINFO* pExcepInfo, UINT* puArgErr);
	HRESULT STDMETHODCALLTYPE InitTypeInfo();

	// IMsmError interface
	HRESULT STDMETHODCALLTYPE get_Type(msmErrorType* ErrorType);
	HRESULT STDMETHODCALLTYPE get_Path(BSTR* ErrorPath);
	HRESULT STDMETHODCALLTYPE get_Language(short* ErrorLanguage);

	HRESULT STDMETHODCALLTYPE get_DatabaseTable(BSTR* ErrorTable);
	HRESULT STDMETHODCALLTYPE get_DatabaseKeys(IMsmStrings** ErrorKeys);
	HRESULT STDMETHODCALLTYPE get_ModuleTable(BSTR* ErrorTable);
	HRESULT STDMETHODCALLTYPE get_ModuleKeys(IMsmStrings** ErrorKeys);

	// non-interface methods
	void SetDatabaseTable(LPCWSTR wzTable);
	void SetModuleTable(LPCWSTR wzTable);

	void AddDatabaseError(LPCWSTR wzError);
	void AddModuleError(LPCWSTR wzError);

private:
	long m_cRef;
	ITypeInfo* m_pTypeInfo;

	// member variables
	msmErrorType m_metError;
	WCHAR m_wzPath[MAX_PATH];
	short m_nLanguage;

	WCHAR m_wzDatabaseTable[MAX_TABLENAME + 1];
	CMsmStrings* m_pDatabaseKeys;

	WCHAR m_wzModuleTable[MAX_TABLENAME + 1];
	CMsmStrings* m_pModuleKeys;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmreg.cpp ===
#include "..\common\regutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmstrenm.h ===
/////////////////////////////////////////////////////////////////////////////
// strenum.h
//		Declares IEnumMsmString interface
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#ifndef __IENUM_MSM_STRING__
#define __IENUM_MSM_STRING__

#include "mergemod.h"
#include "..\common\list.h"
#include "..\common\trace.h"

class CEnumMsmString : public IEnumVARIANT,
							  public IEnumMsmString
{
public:
	CEnumMsmString();
	CEnumMsmString(const POSITION& pos, CList<BSTR>* plistData);
	~CEnumMsmString();

	// IUnknown interface
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID& iid, void** ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// Common IEnumVARIANT & IEnum* interfaces
	HRESULT STDMETHODCALLTYPE Skip(ULONG cItem);
	HRESULT STDMETHODCALLTYPE Reset();

	// IEnumVARIANT interface
	HRESULT STDMETHODCALLTYPE Next(ULONG cItem, VARIANT* rgvarRet, ULONG* cItemRet);
	HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT** ppiRet);

	// IEnum* interface
	HRESULT STDMETHODCALLTYPE Next(ULONG cItem, BSTR* rgvarRet, ULONG* cItemRet);
	HRESULT STDMETHODCALLTYPE Clone(IEnumMsmString** ppiRet);

	// non-interface methods
	HRESULT AddTail(LPCWSTR pData, POSITION *pRetData);
	UINT GetCount();

private:
	long m_cRef;

	POSITION m_pos;
	CList<BSTR> m_listData;
};

#endif // #ifndef __IENUM_MSM_STRING__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmstrenm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       mmstrenm.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// strenum.cpp
//		Implements IEnumMsmString interface
// 

#include "mmstrenm.h"
#include "globals.h"

///////////////////////////////////////////////////////////
// constructor	
CEnumMsmString::CEnumMsmString()
{
	// initial count
	m_cRef = 1;

	// set iid and null position
	m_pos = NULL;

	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor

///////////////////////////////////////////////////////////
// constructor	- 2
CEnumMsmString::CEnumMsmString(const POSITION& pos, CList<BSTR>* plistData)
{
	// initial count
	m_cRef = 1;

	// up the component count
	InterlockedIncrement(&g_cComponents);

	// copy over all the data
	BSTR bstrItem;
	m_pos = plistData->GetHeadPosition();
	while (m_pos)
	{
		// get the item
		bstrItem = plistData->GetNext(m_pos);
		m_listData.AddTail(::SysAllocString(bstrItem));		// add alloced string
	}

	// copy over other data
	m_pos = pos;
}	// end of constructor - 2

///////////////////////////////////////////////////////////
// destructor
CEnumMsmString::~CEnumMsmString()
{
	while (m_listData.GetCount())
		::SysFreeString(m_listData.RemoveHead());

	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor

///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT CEnumMsmString::QueryInterface(const IID& iid, void** ppv)
{
	TRACEA("CEnumTemplate::QueryInterface - called, IID: %d\n", iid);

	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IEnumMsmString*>(this);
	else if (iid == IID_IEnumVARIANT)
		*ppv = static_cast<IEnumVARIANT*>(this);
	else if (iid == IID_IEnumMsmString)
		*ppv = static_cast<IEnumMsmString*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CEnumMsmString::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CEnumMsmString::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// Common IEnumVARIANT & IEnum* interfaces

///////////////////////////////////////////////////////////
// Skip
HRESULT CEnumMsmString::Skip(ULONG cItem)
{
	// loop through the count
	while (cItem > 0)
	{
		// if we're out of items quit looping
		if (!m_pos)
			return S_FALSE;

		// increment the position (ignore the data returned)
		m_listData.GetNext(m_pos);

		cItem--;	// decrement the count
	}

	return S_OK;
}	// end of Skip

///////////////////////////////////////////////////////////
// Reset
HRESULT CEnumMsmString::Reset()
{
	// move the position back to the top of the list
	m_pos = m_listData.GetHeadPosition();

	return S_OK;
}	// end of Reset


/////////////////////////////////////////////////////////////////////////////
// IEnumVARIANT interfaces

///////////////////////////////////////////////////////////
// Next
HRESULT CEnumMsmString::Next(ULONG cItem, VARIANT* rgvarRet, ULONG* cItemRet)
{
	// error check
	if (!rgvarRet)
		return E_INVALIDARG;

	// count of items fetched
	ULONG cFetched = 0;
	
	// loop through the count
	BSTR bstrEnum;			// pull out the data as a BSTR
	while (cItem > 0)
	{
		// if we're out of items quit looping
		if (!m_pos)
		{
			// if we need to return how many items are fetched
			if (cItemRet)
				*cItemRet = cFetched;

			return S_FALSE;
		}

		// get the IDispatch interface and increment the position
		bstrEnum = m_listData.GetNext(m_pos);

		// initialize the variant
		::VariantInit((rgvarRet + cFetched));

		// copy over the IDispatch
		(rgvarRet + cFetched)->vt = VT_BSTR;
		(rgvarRet + cFetched)->bstrVal = ::SysAllocString(bstrEnum);
			
		cFetched++;		// increment the count copied
		cItem--;			// decrement the count to loop
	}

	// if we need to return how many items are fetched
	if (cItemRet)
		*cItemRet = cFetched;

	return S_OK;
}	// end of Next

///////////////////////////////////////////////////////////
// Clone
HRESULT CEnumMsmString::Clone(IEnumVARIANT** ppiRet)
{
	//error check
	if (!ppiRet)
		return E_INVALIDARG;

	*ppiRet = NULL;

	// create a new enumerator
	CEnumMsmString* pEnum = new CEnumMsmString(m_pos, &m_listData);
	if (!pEnum)
		return E_OUTOFMEMORY;

	// assing the new enumerator to return value
	*ppiRet = dynamic_cast<IEnumVARIANT*>(pEnum);

	return S_OK;
}	// end of Clone;


/////////////////////////////////////////////////////////////////////////////
// IEnum* interfaces

///////////////////////////////////////////////////////////
// Next
HRESULT CEnumMsmString::Next(ULONG cItem, BSTR* rgvarRet, ULONG* cItemRet)
{
	// error check
	if (!rgvarRet)
		return E_INVALIDARG;

	// count of items fetched
	ULONG cFetched = 0;
	
	*rgvarRet = NULL;		// null out the passed in variable

	// loop through the count
	while (cItem > 0)
	{
		// if we're out of items quit looping
		if (!m_pos)
		{
			// if we need to return how many items are fetched
			if (cItemRet)
				*cItemRet = cFetched;

			return S_FALSE;
		}

		// copy over the item and increment the pos
		*(rgvarRet + cFetched) = ::SysAllocString(m_listData.GetNext(m_pos));
			
		cFetched++;		// increment the count copied
		cItem--;			// decrement the count to loop
	}

	// if we need to return how many items are fetched
	if (cItemRet)
		*cItemRet = cFetched;

	return S_OK;
}	// end of Next

///////////////////////////////////////////////////////////
// Clone
HRESULT CEnumMsmString::Clone(IEnumMsmString** ppiRet)
{
	//error check
	if (!ppiRet)
		return E_INVALIDARG;

	*ppiRet = NULL;

	// create a new enumerator
	CEnumMsmString* pEnum = new CEnumMsmString(m_pos, &m_listData);
	if (!pEnum)
		return E_OUTOFMEMORY;

	// assing the new enumerator to return value
	*ppiRet = (IEnumMsmString*)pEnum;

	return S_OK;
}	// end of Clone;

/////////////////////////////////////////////////////////////////////////////
// non-interface methods

///////////////////////////////////////////////////////////
// AddTail
HRESULT CEnumMsmString::AddTail(LPCWSTR wzData, POSITION *pRetPos)
{
	BSTR bstrAdd = ::SysAllocString(wzData);
	if (!bstrAdd) return E_OUTOFMEMORY;

	POSITION pos = m_listData.AddTail(bstrAdd);

	// if there is no current position put it at the head
	if (!m_pos)
		m_pos = m_listData.GetHeadPosition();

	// return the added position, if we want it
	if (pRetPos)
		*pRetPos = pos;

	return S_OK;
}	// end of AddTail

///////////////////////////////////////////////////////////
// GetCount
UINT CEnumMsmString::GetCount()
{
	return m_listData.GetCount();
}	// end of GetCount
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmutils.cpp ===
#include "..\common\utils.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmstrs.h ===
/////////////////////////////////////////////////////////////////////////////
// strings.h
//		Declares IMsmStrings interface
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#ifndef __IENUM_MSM_STRINGS__
#define __IENUM_MSM_STRINGS__

#include "mergemod.h"
#include "mmstrenm.h"

class CMsmStrings : public IMsmStrings
{

public:
	CMsmStrings();
	~CMsmStrings();

	// IUnknown interface
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID& iid, void** ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDispatch methods
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT* pctInfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTI);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
														 LCID lcid, DISPID* rgDispID);
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
											   DISPPARAMS* pDispParams, VARIANT* pVarResult,
												EXCEPINFO* pExcepInfo, UINT* puArgErr);
	HRESULT STDMETHODCALLTYPE InitTypeInfo();

	// IMsmStrings interface
	HRESULT STDMETHODCALLTYPE get_Item(long Item, BSTR* Return);
	HRESULT STDMETHODCALLTYPE get_Count(long* Count);
	HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown** NewEnum);

	// non-interface methods
	HRESULT Add(LPCWSTR wzAdd);

private:
	long m_cRef;
	ITypeInfo* m_pTypeInfo;

	// enumeration of string interfaces
	CEnumMsmString* m_peString;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\sources.inc ===
TARGETNAME=mergemod
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=DYNLINK
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

NTTARGETFILE0=MERGEMOD_H

DLLENTRY=_DllMainCRTStartup
TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS= $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(BUILD_DIR)\msi.lib

DLLDEF=..\mergemod.def

C_DEFINES=$(C_DEFINES) -D_WIN32_MSM=200

#
# Fusionized
#
#
SXS_ASSEMBLY_NAME=mergemod
SXS_ASSEMBLY_VERSION=2.0
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=mergemod.dll.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1



USE_MSVCRT=1
USE_NATIVE_EH=1
IDL_TYPE=OLE
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_UUIDDIR=$(O)
MIDL_TLBDIR=$(O)

INCLUDES=$(BUILD_COMMONDIR);$(O);$(SDK_INC_PATH);$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\mergemod.idl \
	$(O)\mergemod_i.c \
	..\mergemod.cpp \
	..\merge.cpp \
	..\mmconfig.cpp \
	..\mmcfgitm.cpp \
	..\mmreg.cpp \
	..\mmutils.cpp \
	..\mmerror.cpp \
	..\mmdbutil.cpp \
	..\mmquery.cpp \
	..\mmdep.cpp \
	..\mmstrs.cpp \
	..\mmstrenm.cpp \
	..\mergemod.rc \
        ..\seqact.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\seqact.cpp ===
#include "globals.h"

#include "merge.h"
#include "msidefs.h"
#include "seqact.h"

const int CSequenceAction::iNoSequenceNumber = -99999;

CSequenceAction::CSequenceAction(LPCWSTR wzAction, int iSequence, LPCWSTR wzCondition, bool bMSI)
{
	m_wzAction = NULL;
	m_wzCondition = NULL;

	if (wzAction)
	{
		m_wzAction = new WCHAR[wcslen(wzAction)+1];
		if (m_wzAction)
			wcscpy(m_wzAction, wzAction);
	}
	m_iSequence = iSequence;
	if (wzCondition)
	{
		m_wzCondition = new WCHAR[wcslen(wzCondition)+1];
		if (m_wzCondition)
			wcscpy(m_wzCondition, wzCondition);
	}
	m_bMSI = bMSI;
}

CSequenceAction::CSequenceAction(const CSequenceAction *pSrc)
{
	m_wzAction = NULL;
	m_wzCondition = NULL;
	m_bMSI = FALSE;
	m_iSequence = iNoSequenceNumber;

	if (!pSrc)
		return;

	if (pSrc->m_wzAction)
	{
		m_wzAction = new WCHAR[wcslen(pSrc->m_wzAction)+1];
		if (m_wzAction)
			wcscpy(m_wzAction, pSrc->m_wzAction);
	}
	m_iSequence = pSrc->m_iSequence;
	if (pSrc->m_wzCondition)
	{
		m_wzCondition = new WCHAR[wcslen(pSrc->m_wzCondition)+1];
		if (m_wzCondition)
			wcscpy(m_wzCondition, pSrc->m_wzCondition);
	}
	m_bMSI = pSrc->m_bMSI;
}

CSequenceAction::~CSequenceAction()
{
	if (m_wzAction) delete[] m_wzAction;
	if (m_wzCondition) delete[] m_wzCondition;
}

void CSequenceAction::RemoveFromOrdering()
{
	CSequenceAction *pCur;

	// before
	while (pCur = lstBefore.RemoveHead())
	{
		POSITION del = pCur->lstAfter.Find(this);
		if (del) pCur->lstAfter.RemoveAt(del);
	}
	
	// after
	while (pCur = lstAfter.RemoveHead())
	{
		POSITION del = pCur->lstBefore.Find(this);
		if (del) pCur->lstBefore.RemoveAt(del);
	}

	// equal: is not part of ordering, only used to keep track
	// of equivalent sequence numbers
}

CSequenceAction *CSeqActList::RemoveNoPredecessors()
{
	POSITION pos = GetHeadPosition();
	POSITION old = NULL;
	while (pos)
	{
		old = pos;
		CSequenceAction *cur = GetNext(pos);
		if (cur->PredecessorCount() == 0)
		{
			// we can't pick this action unless everything that
			// must have the same sequence number also has
			// nothing that must come before it.
			POSITION posEqual = cur->GetEqualHeadPosition();
			bool bOK = true;
			while (posEqual)
				if (cur->GetNextEqual(posEqual)->PredecessorCount() != 0)
					bOK = false;
			if (!bOK) 
				continue;

			RemoveAt(old);
			return cur;
		}
	}
	return NULL;
}

CSequenceAction *CSeqActList::FindAction(const LPWSTR wzAction) const
{
	POSITION pos = GetHeadPosition();
	while (pos)
	{
		CSequenceAction *cur = GetNext(pos);
		if (cur->m_wzAction && (wcscmp(wzAction, cur->m_wzAction) == 0))
			return cur;
	}
	return NULL;
}

CSequenceAction *CSeqActList::FindAssigned() const
{
	POSITION pos = GetHeadPosition();
	while (pos)
	{
		CSequenceAction *cur = GetNext(pos);
		if (cur->m_iSequence != CSequenceAction::iNoSequenceNumber)
			return cur;
	}
	return NULL;
}


void CSeqActList::AddList(const CSeqActList *pList) 
{
	POSITION pos = pList->GetHeadPosition();
	while (pos)
	{
		CSequenceAction *pDel = pList->GetNext(pos);
		ASSERT(!Find(pDel));
		AddTail(pDel);
	}
}

void CSeqActList::InsertOrderedWithDep(CSequenceAction *pNewAction)
{
	// search for the sequences on either side
	// note that if one action is equal to another, we consider
	// it as "after", unless BOTH actions are from the MSI
	// or BOTH actions are not. In that case, we consider them
	// equal.
	CSequenceAction *pBefore = NULL;
	CSequenceAction *pAfter = NULL;
	POSITION pos = GetHeadPosition();
	while (pos)
	{
		CSequenceAction *pTemp = GetNext(pos);
		if (pTemp->m_iSequence == CSequenceAction::iNoSequenceNumber)
			continue;

		if ((pTemp->m_iSequence == pNewAction->m_iSequence) &&
			(pTemp->m_bMSI == pNewAction->m_bMSI))
		{
			pTemp->AddEqual(pNewAction);

			// add to this sequence list
			AddTail(pNewAction);
			return;
		};

		if ((pTemp->m_iSequence < pNewAction->m_iSequence) &&
			(!pBefore || (pTemp->m_iSequence > pBefore->m_iSequence)))
			pBefore = pTemp;
		if ((pTemp->m_iSequence >= pNewAction->m_iSequence) &&
			(!pAfter || (pTemp->m_iSequence < pAfter->m_iSequence)))
			pAfter = pTemp;
	}

	// break the existing sequence dependencies. Why? Because we want the added custom
	// actions sequence nubers to be bound by this action and not just existing MSI actions
	// otherwise actions that come before the next action might actually come after it because
	// we have the dependencies wrong
	if (pAfter && pBefore)
	{
		pBefore->lstAfter.Remove(pAfter);
		pos = pBefore->lstEqual.GetHeadPosition();
		while (pos)
		{
			CSequenceAction *pCur = pBefore->lstEqual.GetNext(pos);
			pCur->lstAfter.Remove(pAfter);
		}

		pAfter->lstBefore.Remove(pBefore);
		pos = pAfter->lstEqual.GetHeadPosition();
		while (pos)
		{
			CSequenceAction *pCur = pAfter->lstEqual.GetNext(pos);
			pCur->lstBefore.Remove(pBefore);
		}
	}

	// now insert the new links
	if (pBefore)
	{
		pNewAction->AddPredecessor(pBefore);
	}
	if (pAfter)
	{
		pNewAction->AddSuccessor(pAfter);
	}

	// add to this sequence list
	AddTail(pNewAction);

}

void CSequenceAction::AddPredecessor(CSequenceAction *pBefore)
{
	pBefore->AddSuccessor(this);
}

void CSequenceAction::AddSuccessor(CSequenceAction *pAfter)
{
	pAfter->lstBefore.AddTail(this);
	lstAfter.AddTail(pAfter);
}

void CSequenceAction::AddEqual(CSequenceAction *pEqual)
{
	// for everything in pEqual's Equal list, add this node
	// and every node that we are equal to its equal list,
	// and it and every node that it is equal to to our list
	POSITION pos = lstEqual.GetHeadPosition();
	while (pos)
	{
		CSequenceAction *pTemp = lstEqual.GetNext(pos);
		pTemp->lstEqual.AddTail(pEqual);
		pTemp->lstEqual.AddList(&pEqual->lstEqual);
	}
	pos = pEqual->lstEqual.GetHeadPosition();
	while (pos)
	{
		CSequenceAction *pTemp = pEqual->lstEqual.GetNext(pos);
		pTemp->lstEqual.AddTail(this);
		pTemp->lstEqual.AddList(&lstEqual);
	}

	CSeqActList lstTemp;
	pos = pEqual->lstEqual.GetHeadPosition();
	while (pos)
	{
		lstTemp.AddTail(pEqual->lstEqual.GetNext(pos));
	}

	pEqual->lstEqual.AddTail(this);
	pEqual->lstEqual.AddList(&lstEqual);
	lstEqual.AddTail(pEqual);
	lstEqual.AddList(&lstTemp);
}

bool CSequenceAction::IsEqual(const CSequenceAction *pEqual) const
{
	POSITION pos = lstEqual.GetHeadPosition();
	while (pos)
	{
		if (pEqual == lstEqual.GetNext(pos))
			return true;
	}
	return false;
}

CSequenceAction *CSequenceAction::FindAssignedPredecessor() const { 
	CSequenceAction *pPred = lstBefore.FindAssigned();
	POSITION pos = lstEqual.GetHeadPosition();
	while (!pPred && pos)
	{
		pPred = lstEqual.GetNext(pos);
		pPred = pPred->lstBefore.FindAssigned();
	}
	return pPred;
}

CSequenceAction *CSequenceAction::FindAssignedSuccessor() const {
	CSequenceAction *pPred = lstAfter.FindAssigned();
	POSITION pos = lstEqual.GetHeadPosition();
	while (!pPred && pos)
	{
		pPred = lstEqual.GetNext(pos);
		pPred = pPred->lstAfter.FindAssigned();
	}
	return pPred;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\mmstrs.cpp ===
/////////////////////////////////////////////////////////////////////////////
// strings.cpp
//		Implements IMsmStrings interface
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#include "..\common\trace.h"
#include "..\common\varutil.h"
#include "mmstrs.h"
#include "globals.h"

///////////////////////////////////////////////////////////
// constructor	
CMsmStrings::CMsmStrings()
{
	// initial count
	m_cRef = 1;

	//create string enumerator
	m_peString = new CEnumMsmString;

	// no type info yet
	m_pTypeInfo = NULL;

	// up the component count
	InterlockedIncrement(&g_cComponents);
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
CMsmStrings::~CMsmStrings()
{
	// release the type info
	if (m_pTypeInfo)
		m_pTypeInfo->Release();

	if (m_peString)
		m_peString->Release();

	// down the component count
	InterlockedDecrement(&g_cComponents);
}	// end of destructor

///////////////////////////////////////////////////////////
// QueryInterface - retrieves interface
HRESULT CMsmStrings::QueryInterface(const IID& iid, void** ppv)
{
	TRACEA("CMsmStrings::QueryInterface - called, IID: %d\n", iid);

	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IMsmStrings*>(this);
	else if (iid == IID_IMsmStrings)
		*ppv = static_cast<IMsmStrings*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CMsmStrings::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CMsmStrings::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// IDispatch interface

HRESULT CMsmStrings::GetTypeInfoCount(UINT* pctInfo)
{
	if(NULL == pctInfo)
		return E_INVALIDARG;

	*pctInfo = 1;	// only one type info supported by this dispatch

	return S_OK;
}

HRESULT CMsmStrings::GetTypeInfo(UINT iTInfo, LCID /* lcid */, ITypeInfo** ppTypeInfo)
{
	if (0 != iTInfo)
		return DISP_E_BADINDEX;

	if (NULL == ppTypeInfo)
		return E_INVALIDARG;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	*ppTypeInfo = m_pTypeInfo;
	m_pTypeInfo->AddRef();

	return S_OK;
}

HRESULT CMsmStrings::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
						 LCID lcid, DISPID* rgDispID)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		HRESULT hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID);
}

HRESULT CMsmStrings::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
				  DISPPARAMS* pDispParams, VARIANT* pVarResult,
				  EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr = S_OK;

	// if no type info is loaded
	if (NULL == m_pTypeInfo)
	{
		// load the type info
		hr = InitTypeInfo();
		if (FAILED(hr))
			return hr;
	}

	return m_pTypeInfo->Invoke((IDispatch*)this, dispIdMember, wFlags, pDispParams, pVarResult,
										pExcepInfo, puArgErr);
}

HRESULT CMsmStrings::InitTypeInfo()
{
	HRESULT hr = S_OK;
	ITypeLib* pTypeLib = NULL;

	// if there is no info loaded
	if (NULL == m_pTypeInfo)
	{
		// try to load the Type Library into memory. For SXS support, do not load from registry, rather
		// from launched instance
		hr = LoadTypeLibFromInstance(&pTypeLib);
		if (FAILED(hr))
		{
			TRACEA("CMsmStrings::InitTypeInfo - failed to load TypeLib[0x%x]\n", LIBID_MsmMergeTypeLib);
			return hr;
		}

		// try to get the Type Info for this Interface
		hr = pTypeLib->GetTypeInfoOfGuid(IID_IMsmStrings, &m_pTypeInfo);
		if (FAILED(hr))
		{
			TRACEA("CMsmStrings::InitTypeInfo - failed to get inteface[0x%x] from TypeLib[0x%x]\n", IID_IMsmStrings, LIBID_MsmMergeTypeLib);

			// no type info was loaded
			m_pTypeInfo = NULL;
		}

		pTypeLib->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IMsmStrings interface

///////////////////////////////////////////////////////////
// Item
HRESULT CMsmStrings::get_Item(long lItem, BSTR* Return)
{
	// String check
	if (!Return)
		return E_INVALIDARG;

	HRESULT hr;

	// set the return to empty
	*Return = NULL;

	//if the item is too small
	if (lItem < 1)
		return E_INVALIDARG;

	hr = m_peString->Reset();		// go back to the top
	// if we need to skip any items
	if (lItem > 1)
	{
		hr = m_peString->Skip(lItem - 1);	// skip to the Item
		if (FAILED(hr))
			return E_INVALIDARG;	// failed to find item
	}

	hr = m_peString->Next(1, Return, NULL);
	if (FAILED(hr))
	{
		TRACEA("CMsmStrings::Item - Failed to get string from enumerator.\r\n");
		return E_INVALIDARG;
	}

	return hr;
}	// end of Item

///////////////////////////////////////////////////////////
// Count
HRESULT CMsmStrings::get_Count(long* Count)
{
	// String check
	if (!Count)
		return E_INVALIDARG;

	// get the count in the enumerator
	*Count = m_peString->GetCount();

	return S_OK;
}	// end of Count

///////////////////////////////////////////////////////////
// _NewEnum
HRESULT CMsmStrings::get__NewEnum(IUnknown** NewEnum)
{
	// String check
	if (!NewEnum)
		return E_INVALIDARG;

	HRESULT hr;

	// blank out the passed in variable
	*NewEnum = NULL;

	// return the enumerator as an IUnknown
	IEnumVARIANT* pEnumVARIANT;
	hr = m_peString->Clone(&pEnumVARIANT);

	if (SUCCEEDED(hr))
	{
		pEnumVARIANT->Reset();
		*NewEnum = pEnumVARIANT;
	}

	return hr;
}	// end of _NewEnum


/////////////////////////////////////////////////////////////////////////////
// non-interface methods

HRESULT CMsmStrings::Add(LPCWSTR wzAdd)
{
	ASSERT(wzAdd);
	// add the string to the end of the list
	return m_peString->AddTail(wzAdd, NULL);
}	// end of Add
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\mergemod\seqact.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       seqact.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// seqact.h
//		defines and implements the class that holds the action and it's sequence
// 

#ifndef _SEQUENCE_ACTION_H_
#define _SEQUENCE_ACTION_H_

///////////////////////////////////////////////////////////
// CSequenceAction and CSeqActList
class CSequenceAction;

class CSeqActList : public CList<CSequenceAction *>
{
public:
	CSequenceAction *RemoveNoPredecessors();
	CSequenceAction *FindAction(const LPWSTR wzAction) const;
	CSequenceAction *FindAssigned() const;
	void InsertOrderedWithDep(CSequenceAction *pNewAction);
	void AddList(const CSeqActList *pList);
};

class CSequenceAction
{
public:

	const static int iNoSequenceNumber;

	WCHAR  *m_wzAction;		// name of action
	int		m_iSequence;	// sequence number of action, -1 if none assigned
	WCHAR  *m_wzCondition;	// condition associated with action
	bool	m_bMSI;			// true if this action existed in the MSI

	CSequenceAction(LPCWSTR wzAction, int iSequence, LPCWSTR wzCondition, bool bMSI = false);
	CSequenceAction(const CSequenceAction *pSrc);
	virtual ~CSequenceAction();
	void AddSuccessor(CSequenceAction *pAfter);
	void AddEqual(CSequenceAction *pEqual);
	void AddPredecessor(CSequenceAction *pBefore);
	bool IsEqual(const CSequenceAction *pEqual) const;
	void RemoveFromOrdering();

private:	
	CSeqActList lstBefore;
	CSeqActList lstAfter;
	CSeqActList lstEqual;

	friend void CSeqActList::InsertOrderedWithDep(CSequenceAction *pNewAction);

public:
	int PredecessorCount() const { return lstBefore.GetCount(); };
	CSequenceAction *FindAssignedPredecessor() const;
	CSequenceAction *FindAssignedSuccessor() const;
	POSITION GetEqualHeadPosition() const { return lstEqual.GetHeadPosition(); };
	CSequenceAction *GetNextEqual(POSITION &pos) const { return lstEqual.GetNext(pos); };
	
};	// end of CSequenceAction

class CDirSequenceAction : public CSequenceAction
{
public:
	CDirSequenceAction(LPCWSTR wzAction, int iSequence, LPCWSTR wzCondition, bool bMSI = false) : CSequenceAction(wzAction, iSequence, wzCondition, bMSI), m_dwSequenceTableFlags(0) {};
	DWORD m_dwSequenceTableFlags;
};

#endif	// _SEQUENCE_ACTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msi9xmig\migrate.dll\migrate.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       migrate.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <setupapi.h>
#include <shlwapi.h>

// migration DLL version information
typedef struct {
    CHAR CompanyName[256];
    CHAR SupportNumber[256];
    CHAR SupportUrl[256];
    CHAR InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO; 

const char g_szProductId[] = "Microsoft MSI Migration DLL v2.0";
VENDORINFO g_VendorInfo = { "Microsoft", "", "", "" };

// global flag set if MSI 1.5 is on the system
static bool g_fMSI15 = false;

// global flag if profiles are enabled
static bool g_fProfilesAreEnabled;

// registry keys of note
const char szMSIKeyName[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Installer";
const char szHKCUProductKeyName[] = "Software\\Microsoft\\Installer\\Products";
const char szLocalPackagesSubKeyName[] = "LocalPackages";
const char szCommonUserSubKeyName[] = "CommonUser";
const char szUserDataSubKeyName[] = "UserData";

// store the working directory for use by all child functions
char g_szWorkingDir[MAX_PATH];
WCHAR g_wzWorkingDir[MAX_PATH];

///////////////////////////////////////////////////////////////////////
// called by setup to extract migration DLL version and support
// information. 
LONG CALLBACK QueryVersion(LPCSTR *ProductID, LPUINT DllVersion, LPINT *CodePageArray, 
  LPCSTR *ExeNamesBuf, PVENDORINFO *VendorInfo)
{
	// product ID information
	*ProductID = g_szProductId;
	*DllVersion = 200;

	// DLL is language independent.
	*CodePageArray = NULL;

	// no EXE search is required
	*ExeNamesBuf = NULL;

	// vendor information
	*VendorInfo = &g_VendorInfo;

	// always return ERROR_SUCCESS
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Code stolen from MsiRegMv.exe (MSI 1.1->1.5 migration tool) to recursively
// delete a reg key. Slightly modified to skip one key (at the root) by name.
bool Msi9XMigDeleteRegKeyAndSubKeys(HKEY hKey, const char *szSubKey, const char *szNoDelete)
{
	// open the subkey
	HKEY hSubKey = 0;
	DWORD dwResult = ERROR_SUCCESS;
	dwResult = ::RegOpenKeyExA(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);
	if (ERROR_SUCCESS != dwResult)
	{
		if (dwResult == ERROR_FILE_NOT_FOUND)
			return true;
 		return false;
	}

   	DWORD cchMaxKeyLen = 0;
	DWORD cSubKeys = 0;
    if (ERROR_SUCCESS != (::RegQueryInfoKey(hSubKey, NULL, NULL, 0, 
						  &cSubKeys, &cchMaxKeyLen, NULL, NULL, NULL, NULL, NULL, NULL)))
	{
		::RegCloseKey(hSubKey);
		hSubKey = 0;
		return false;
	}

	if (cSubKeys > 0)
	{
		char *szKey = new char[++cchMaxKeyLen];
		if (!szKey) 
		{
			::RegCloseKey(hSubKey);
			hSubKey = 0;
			return false;
		}

		DWORD dwIndex=0;
		while (1)
		{
			DWORD cchLen = cchMaxKeyLen;
			LONG lResult = ::RegEnumKeyExA(hSubKey, dwIndex++, szKey, 
										&cchLen, 0, NULL, NULL, NULL);
			if (lResult == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else if (lResult != ERROR_SUCCESS)
			{
				::RegCloseKey(hSubKey);
				hSubKey = 0;
				delete[] szKey;
				return false;
			}

			if (szNoDelete && 0 == lstrcmpA(szKey, szNoDelete))
				continue;
	 
			if (!Msi9XMigDeleteRegKeyAndSubKeys(hSubKey, szKey, NULL))
			{
				::RegCloseKey(hSubKey);
				hSubKey = 0;
				delete[] szKey;
				return false;
			}
			else
			{
				// every time we delete a reg key, we're forced to restart the 
				// enumeration or we'll miss keys.
				dwIndex = 0;
			}
		}
		delete[] szKey;
		szKey = NULL;
	}
	::RegCloseKey(hSubKey);
	hSubKey = 0;

	if (!szNoDelete)
		dwResult = ::RegDeleteKeyA(hKey, szSubKey);

	return true;
}

typedef HRESULT (__stdcall *LPDLLGETVERSION)(DLLVERSIONINFO *);

///////////////////////////////////////////////////////////////////////
// Initialization routine on Win9X. Attempts to detect MSI on the 
// system and respond appropriately. Cleans up any earlier failed 
// upgrade migration attempts.
LONG __stdcall Initialize9x(LPCSTR WorkingDirectory, LPCSTR SourceDirectories, LPCSTR MediaDirectory)
{
	LONG lResult = ERROR_NOT_INSTALLED;

	// attempt to load MSI.DLL and grab the version. If this fails, MSI is not
	// installed and there is no need for any further migration
	HMODULE hMSI = ::LoadLibraryA("MSI");
	if (hMSI)
	{
		LPDLLGETVERSION pfVersion = (LPDLLGETVERSION)::GetProcAddress(hMSI, "DllGetVersion");
		if (pfVersion)
		{	
			// MSI detected. Determine version.
			DLLVERSIONINFO VersionInfo;
			VersionInfo.cbSize = sizeof(DLLVERSIONINFO);
			(*pfVersion)(&VersionInfo);
				
			if ((VersionInfo.dwMajorVersion < 1) ||
				((VersionInfo.dwMajorVersion == 1) && (VersionInfo.dwMinorVersion < 50)))
			{
				// less than 1.5, could be 1.0, 1.1, 1.2. They all use the same
				// registry storage format.
				g_fMSI15 = false;
				lResult = ERROR_SUCCESS;
			}
			else
			{
				// >= 1.5, so we assume that the desired data format is equivalent
				// to 1.5. If a newer version of MSI has a different format, it 
				// should supercede this DLL.
				g_fMSI15 = true;
				lResult = ERROR_SUCCESS;
			}
		}
		::FreeLibrary(hMSI);
	}

	// remove any existing MSI CachedPackages key from earlier (aborted) upgrades.
	HKEY hKey = 0;
	if ((ERROR_SUCCESS == ::RegOpenKeyA(HKEY_LOCAL_MACHINE, szMSIKeyName, &hKey)) && hKey)
	{
		// failure here is irrelevant. We can't abort our migration just because
		// we can't delete a key.
		Msi9XMigDeleteRegKeyAndSubKeys(hKey, szLocalPackagesSubKeyName, NULL);
		
		// if 1.5 is not on the machine, delete the entire UserData key. If 1.5 is on the machine,
		// delete everything but the "CommonUser" hive.
		Msi9XMigDeleteRegKeyAndSubKeys(hKey, szUserDataSubKeyName, g_fMSI15 ? szCommonUserSubKeyName : NULL);
		
		::RegCloseKey(hKey);
		hKey = 0;
	}

	// copy the working directory into a temp path. If necessary
	// we'll save off the migration database here.
	lstrcpyA(g_szWorkingDir, WorkingDirectory);

	// return code derived above (telling setup whether to call us again or not)
	return lResult;
}



typedef LONG (__stdcall *LPMIGRATEUSER9X)(HWND, LPCSTR, HKEY, LPCSTR, LPVOID, bool&);
typedef LONG (__stdcall *LPMIGRATESYSTEM9X)(HWND, LPCSTR, LPVOID, LPCSTR, bool);

/////////////////////////////////////////////////////////////////////////////
// most migration code actually lives in Msi9XMig.dll. These migration
// functions are just stubs that call into the the DLL. (They maintain a small
// amount of state that must persist across calls.) This ensures that this root
// migration DLL can always load, regardless of whether MSI is installed or not.
LONG CALLBACK MigrateUser9x(HWND ParentWnd, LPCSTR AnswerFile, HKEY UserRegKey, LPCSTR UserName, LPVOID Reserved)
{
	LONG lResult = ERROR_SUCCESS;

	// grab the function pointers for the 9x portion of MSI
	// migration.
	HMODULE h9XMig = ::LoadLibraryA("MSI9XMIG");
	if (!h9XMig)
	{
		// always return success. Its too late for any meaningful
		// error recovery
		return ERROR_SUCCESS;
	}

	LPMIGRATEUSER9X pfMigrateUser9X = (LPMIGRATEUSER9X)GetProcAddress(h9XMig, "MigrateUser9x");
	if (pfMigrateUser9X)
	{
		// perform actual migration
		bool fProfilesAreEnabled = false;
		lResult = (pfMigrateUser9X)(ParentWnd, AnswerFile, UserRegKey, UserName, Reserved, fProfilesAreEnabled);

		// if the current determination is that profiles are not enabled, this user might have changed our plan
		if (!g_fProfilesAreEnabled)
			g_fProfilesAreEnabled = fProfilesAreEnabled;
	}
        
	FreeLibrary(h9XMig);

	// return the result from the actual migration call
	return lResult;
}


LONG CALLBACK MigrateSystem9x(HWND ParentWnd, LPCSTR AnswerFile, LPVOID Reserved)
{
	LONG lResult = ERROR_SUCCESS;

	// grab the function pointers for the 9x portion of MSI
	// migration.
	HMODULE h9XMig = ::LoadLibraryA("MSI9XMIG");
	if (!h9XMig)
	{
		// always return success. Its too late for any meaningful
		// error recovery
		return ERROR_SUCCESS;
	}

	LPMIGRATESYSTEM9X pfMigrateSystem9X = (LPMIGRATESYSTEM9X)GetProcAddress(h9XMig, "MigrateSystem9x");
	if (pfMigrateSystem9X)
	{
		// perform actual migration
		lResult = (pfMigrateSystem9X)(ParentWnd, AnswerFile, Reserved, g_szWorkingDir, g_fProfilesAreEnabled);
	}
        
	FreeLibrary(h9XMig);

	// return the result from the actual migration call
	return lResult;
}




/////////////////////////////////////////////////////////////////////////////
// most NT migration code actually lives in MsiNTMig.dll. These migration
// functions are just stubs that call into the the DLL. (They maintain a small
// amount of state that must persist across calls.) This ensures that this root
// migration DLL can always load on a barebones machine, even if it uses 
// unicode or MSI APIs. 
typedef DWORD (__stdcall *LPMIGRATEUSERNT)(HINF, HKEY, LPCWSTR, LPVOID, LPCWSTR, bool&);
typedef DWORD (__stdcall *LPMIGRATESYSTEMNT)(HINF, LPVOID, LPCWSTR, bool);
typedef DWORD (__stdcall *LPINITIALIZENT)(LPCWSTR);

bool g_fDeferredMigrationRequired = false;

///////////////////////////////////////////////////////////////////////
// Initialization routine on WinNT. Just stores of the migration
// working directory.
LONG CALLBACK InitializeNT(LPCWSTR WorkingDirectory, LPCWSTR SourceDirectories, LPVOID Reserved)
{
	// copy the working directory into a temp path. The migration database lives there
	lstrcpyW(g_wzWorkingDir, WorkingDirectory);

	LONG lResult = ERROR_SUCCESS;

	// grab the function pointers for the NT portion of MSI
	// migration.
	HMODULE hNTMig = ::LoadLibraryA("MSINTMIG");
	if (!hNTMig)
	{
		// always return success. Its too late for any meaningful
		// error recovery
		return ERROR_SUCCESS;
	}

	LPINITIALIZENT pfInitializeNT = (LPINITIALIZENT)GetProcAddress(hNTMig, "InitializeNT");
	if (pfInitializeNT)
	{
		// perform actual migration
		lResult = (pfInitializeNT)(g_wzWorkingDir);
	}
        
	FreeLibrary(hNTMig);

	// return the result from the actual migration call
	return lResult;
}


///////////////////////////////////////////////////////////////////////
// Called once per migrated profile on NT. Passes work down to
// MsiNtMig. Also stores deferred migration flag for use by system
// migration.
LONG CALLBACK MigrateUserNT(HINF AnswerFileHandle, HKEY UserRegKey, LPCWSTR UserName, LPVOID Reserved)
{
	LONG lResult = ERROR_SUCCESS;

	// grab the function pointers for the NT portion of MSI
	// migration.
	HMODULE hNTMig = ::LoadLibraryA("MSINTMIG");
	if (!hNTMig)
	{
		// always return success. Its too late for any meaningful
		// error recovery
		return ERROR_SUCCESS;
	}

	LPMIGRATEUSERNT pfMigrateUserNT = (LPMIGRATEUSERNT)GetProcAddress(hNTMig, "MigrateUserNT");
	if (pfMigrateUserNT)
	{
		// perform actual migration
		lResult = (pfMigrateUserNT)(AnswerFileHandle, UserRegKey, UserName, Reserved, g_wzWorkingDir, g_fDeferredMigrationRequired);
	}
        
	FreeLibrary(hNTMig);

	// return the result from the actual migration call
	return lResult;
}


///////////////////////////////////////////////////////////////////////
// Called once on NT
LONG CALLBACK MigrateSystemNT(HINF UnattendInfHandle, LPVOID Reserved)
{
	LONG lResult = ERROR_SUCCESS;

	// grab the function pointers for the NT portion of MSI
	// migration.
	HMODULE hNTMig = ::LoadLibraryA("MSINTMIG");
	if (!hNTMig)
	{
		// always return success. Its too late for any meaningful
		// error recovery
		return ERROR_SUCCESS;
	}

	LPMIGRATESYSTEMNT pfMigrateSystemNT = (LPMIGRATESYSTEMNT)GetProcAddress(hNTMig, "MigrateSystemNT");
	if (pfMigrateSystemNT)
	{
		// perform actual migration
		lResult = (pfMigrateSystemNT)(UnattendInfHandle, Reserved, g_wzWorkingDir, g_fDeferredMigrationRequired);
	}
        
	FreeLibrary(hNTMig);

	// return the result from the actual migration call
	return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msi9xmig\msi9xmig.dll\msi9xmig.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msi9xmig.cpp
//
//--------------------------------------------------------------------------

// This must be compiled in the "unicode" manner due to the fact that MSI will
// rearrange the binplace targets for "ansi" builds. However this migration DLL 
// is always ANSI, so we undefine UNICODE and _UNICODE while leaving the rest
// of the unicode environment.
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <msi.h>

// header file must be included with UNICODE not defined
#include "..\..\msiregmv\msiregmv.h"

// global flag set if MSI 1.5 is on the system
static bool g_fMSI15 = false;

// registry keys of note
const char szMSIKeyName[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Installer";
const char szHKCUProductKeyName[] = "Software\\Microsoft\\Installer\\Products";
const char szLocalPackagesSubKeyName[] = "LocalPackages";
const char szCommonUserSubKeyName[] = "CommonUser";
const char szMigrateWin9XToHKLM[] = "MigrateWin9XToHKLM";
const char szUserDataKeyName[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData";

// 1.0/1.1-9X uninstall information
const char szUninstallKeyName[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall";
const char szLocalPackageValueName[] = "LocalPackage";

// profile information
const char szProfilesKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation";
const char szProfilesVal[] = "ProfileDirectory";
const char szStartMenuKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation\\Start Menu";

const char szSystemUserName[] = "S-1-5-18";

// icon/transform cache location
const char szInstallerSubDir[] = "Installer";
const int cchInstallerSubDir = sizeof(szInstallerSubDir)/sizeof(char);
const char szAppDataCacheSubDir[] = "Microsoft\\Installer";
const int cchAppDataCacheSubDir = sizeof(szAppDataCacheSubDir)/sizeof(char);

/////////////////////////////////////////////////////////////////////////////
// if profiles are not on, we're in a strange state where darwin goop goes to 
// HKCU and transforms/icons to AppData but after migration it should be a 
// per-machine install. If profiles are on, per-machine stuff is in HKLM and
// per-user stuff is in HKCU, just as expected.
bool Win9XProfilesAreEnabled(HKEY hUserRoot)
{
	bool fProfilesEnabled = false;

	// open the ProfileReconciliation key
	HKEY hProfilesKey = 0;
	DWORD dwResult = ::RegOpenKeyExA(hUserRoot, szProfilesKey, 0, KEY_ALL_ACCESS, &hProfilesKey);
	if (dwResult == ERROR_SUCCESS && hProfilesKey)
	{
		// the actual path to the profile directory is not relevant, just the fact that 
		// there is a path and it is not NULL.
		char szProfilePath[MAX_PATH];
		DWORD cbProfilePath = MAX_PATH;
		dwResult = RegQueryValueExA(hProfilesKey, szProfilesVal, NULL, NULL, reinterpret_cast<BYTE*>(szProfilePath), &cbProfilePath);
		if ((ERROR_SUCCESS == dwResult && cbProfilePath) || (ERROR_MORE_DATA == dwResult))
		{
			fProfilesEnabled = true;
		}
		RegCloseKey(hProfilesKey);
		hProfilesKey = 0;
	}

	return fProfilesEnabled;
}

///////////////////////////////////////////////////////////////////////
// enumerate everything in the AppData\Microsoft\Installer directory 
// and mark those files to be moved to the Installer cache directory.
// These files consist of cached transforms and cached icons for
// shortcuts. Actual move happens on the NT side.
bool EnumerateSystemAppDataFiles(MSIHANDLE hDatabase, LPCSTR szINFPath)
{
	// create a table in the database to store move information
	PMSIHANDLE hInsertView;
	if (ERROR_SUCCESS != MsiDatabaseOpenViewA(hDatabase, "CREATE TABLE `MoveFiles` (`Source` CHAR(0) NOT NULL, `Destination` CHAR(0) NOT NULL PRIMARY KEY `Source`, `Destination`)", &hInsertView) ||
		ERROR_SUCCESS != MsiViewExecute(hInsertView, 0))
	{
		return false;
	}

	// create an insertion query and a record for the insertion
	if (ERROR_SUCCESS != MsiDatabaseOpenViewA(hDatabase, "SELECT * FROM `MoveFiles`", &hInsertView) ||
		ERROR_SUCCESS != MsiViewExecute(hInsertView, 0))
	{
		return false;
	}
	PMSIHANDLE hInsertRec = MsiCreateRecord(2);

	// create insert query for directories that should be cleaned up on success. Failure
	// is not fatal, we'll just have some orphaned resources
	PMSIHANDLE hCleanUpTable;
	if (ERROR_SUCCESS == MsiDatabaseOpenViewA(hDatabase, "SELECT * FROM `CleanupFile`", &hCleanUpTable))
		MsiViewExecute(hCleanUpTable, 0);
	
	// determine the path to the AppData folder
	char szAppDataPath[MAX_PATH+2];
	if (S_OK != SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_CURRENT, szAppDataPath))
		return false;
	int cchAppDataPath = lstrlenA(szAppDataPath);
	if (szAppDataPath[cchAppDataPath-1] != '\\')
	{
		szAppDataPath[cchAppDataPath] = '\\';
		szAppDataPath[cchAppDataPath+1] = '\0';
	}

	// check for buffer overrun and append appdata cache directory subdir.
	if (cchAppDataPath+cchAppDataCacheSubDir > MAX_PATH)
		return false;
	lstrcatA(szAppDataPath, szAppDataCacheSubDir);
	cchAppDataPath = lstrlenA(szAppDataPath);

	// determine the path to the installer directory.
	char szInstallerDirPath[MAX_PATH+2];
	int cchInstallerDirPath = GetWindowsDirectoryA(szInstallerDirPath, MAX_PATH);
	if (cchInstallerDirPath == 0 || cchInstallerDirPath > MAX_PATH)
		return false;
	if (szInstallerDirPath[cchInstallerDirPath-1] != '\\')
	{
		szInstallerDirPath[cchInstallerDirPath] = '\\';
		szInstallerDirPath[cchInstallerDirPath+1] = '\0';
		cchInstallerDirPath++;
	}
	
	// check for buffer overrun and append installer cache directory subdir
	if (cchInstallerDirPath+cchInstallerSubDir > MAX_PATH)
		return false;
	lstrcatA(szInstallerDirPath, szInstallerSubDir);
	cchInstallerDirPath += cchInstallerSubDir-1;

	// insert the source directory into the list of directories to be cleaned up after
	// migration (assuming that it is empty). Failure is not interesting (it just
	// orphans the directory).
	if (hCleanUpTable)
	{
		MsiRecordSetStringA(hInsertRec, 1, szAppDataPath);
		MsiRecordSetInteger(hInsertRec, 2, 3);
		MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hInsertRec);
	}

	// search string for GUID subdirectories. Escape all ? chars to prevent 
	// interpretation as a trigraph
	const char szGuidSearch[] = "\\{\?\?\?\?\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?\?\?\?\?\?\?\?\?}";
	const int cchGUIDAppend = sizeof(szGuidSearch)-1;

	// append a trailing slash to the target directory to prepare for the GUID subdir
	szInstallerDirPath[cchInstallerDirPath] = '\\';
	szInstallerDirPath[++cchInstallerDirPath] = '\0';

	// the GUIDs also start at the end of the path in the source. The 
	// slash itself is added by the GUID search string.
	cchAppDataPath++;
	
	// determine the length of the paths after the GUID subdir will be appended
	// (+1 for trailing slash). This is where each filename will be placed
	int cchAppDataFileStart = cchAppDataPath + cchGUIDAppend; 
	int cchInstallerFileStart = cchInstallerDirPath + cchGUIDAppend; 
	
	// ensure that we aren't going to run off the end of our buffer before actually appending the GUID
	if ((cchAppDataFileStart > MAX_PATH) || (cchInstallerFileStart > MAX_PATH))
		return false;

	// create the appdata query string
	lstrcatA(szAppDataPath, szGuidSearch);

	// enumerate all GUID subdirectories under the AppData installer dir.
	WIN32_FIND_DATA FileData;
	HANDLE hDirFind = FindFirstFileA(szAppDataPath, &FileData);
	if (hDirFind != INVALID_HANDLE_VALUE)
	{
 		do 
		{
			if (FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				// append the product GUID to the end of the source and target paths
				lstrcpyA(&szAppDataPath[cchAppDataPath], FileData.cFileName);				
				lstrcpyA(&szInstallerDirPath[cchInstallerDirPath], FileData.cFileName);				

				// insert the source directory into the list of directories to be cleaned up after
				// migration (assuming that it is empty). Failure is not interesting, it just
				// orphans the directory.
				if (hCleanUpTable)
				{
					MsiRecordSetStringA(hInsertRec, 1, szAppDataPath);
					MsiRecordSetInteger(hInsertRec, 2, 2);
					MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hInsertRec);
				}

				// append the search template to the source path but just a slash to the target
				lstrcpyA(&szAppDataPath[cchAppDataFileStart-1], "\\*.*");
				szInstallerDirPath[cchInstallerFileStart-1] = '\\';

				// search for all files in this subdirectory
				HANDLE hFileFind = FindFirstFileA(szAppDataPath, &FileData);
				if (hFileFind != INVALID_HANDLE_VALUE)
				{
					do 
					{
						// sub-directories of the GUIDs don't concern us (MSI doesn't create any).
						if (!(FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
						{
							// ensure there is no buffer overrun (including trailing NULL)
							int cchFile = lstrlenA(FileData.cFileName);
							if ((cchAppDataFileStart+cchFile >= MAX_PATH) || (cchInstallerFileStart+cchFile >= MAX_PATH))
								continue;
	
							// append the file on to the end of the path for both
							// original and new path
							lstrcpyA(&szAppDataPath[cchAppDataFileStart], FileData.cFileName);
							lstrcpyA(&szInstallerDirPath[cchInstallerFileStart], FileData.cFileName);
	
							// insert the paths into the table to be moved
							MsiRecordSetStringA(hInsertRec, 1, szAppDataPath);
							MsiRecordSetStringA(hInsertRec, 2, szInstallerDirPath);
							MsiViewModify(hInsertView, MSIMODIFY_MERGE, hInsertRec); 
	
							// and write a migration INF line to tell the system that we are moving the data
							WritePrivateProfileStringA("Moved", szAppDataPath, szInstallerDirPath, szINFPath);
						}
					}
					while (FindNextFileA(hFileFind, &FileData));
				}
			}
		} 
		while (FindNextFileA(hDirFind, &FileData));
	}

	return true;
}


///////////////////////////////////////////////////////////////////////
// MigrateUser9xHelper -  
// checks for a list of installed products and writes fake cached 
// package information to the normal cached package key (which is not
// used on Win9X) so that MsiRegMv has enough information about each
// profile to correctly migrate the applications. When fSystem is true,
// the caller is the MigrateSystem9x function. This is due to the fact
// that when profile is on and the installation is per-machine, the
// product registration goes under HKLM. The cached package information
// needs to be written to the faked "LocalPackages" key location.
LONG MigrateUser9xHelper(HWND, LPCSTR, HKEY UserRegKey, LPCSTR UserName, LPVOID Reserved, bool& fProfilesAreEnabled, bool fSystem)
{
	DWORD dwResult = ERROR_SUCCESS;
	LONG lResult = ERROR_SUCCESS;

	// if profiles are not enabled, applications registered under HKCU should really be 
	// per-machine. That case is handled by system migration. But we stil want further
	// migration to happen for this user on the NT side because it needs to remove the 
	// HKCU data from the profile.
	if(fSystem == true)
	{
		// fProfilesAreEnabled value is ignored by the caller in this case.
		fProfilesAreEnabled = false;
	}
	else
	{
		fProfilesAreEnabled = Win9XProfilesAreEnabled(UserRegKey);
	}

	// open/create the destination localpackages key. If we couldn't create this, there is no 
	// point in doing any further migration for this user.
	HKEY hLocalPackagesKey = 0;
	if (ERROR_SUCCESS != ::RegCreateKeyExA(HKEY_LOCAL_MACHINE, szLocalPackagesKeyName, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hLocalPackagesKey, NULL))
		return ERROR_NOT_INSTALLED;

	// open the subkey of the provided user profile where MSI product registration is stored
	HKEY hProductKey = 0;
	if(fSystem == true)
	{
		// Open the per-machine install key.
		dwResult = ::RegOpenKeyExA(HKEY_LOCAL_MACHINE, szPerMachineInstallKeyName, 0, KEY_ALL_ACCESS, &hProductKey);
	}
	else
	{
		dwResult = ::RegOpenKeyExA(UserRegKey, szHKCUProductKeyName, 0, KEY_ALL_ACCESS, &hProductKey);
	}
	if ((ERROR_SUCCESS == dwResult) && hProductKey)
	{
		char rgchProductCode[cchGUIDPacked+1];
		DWORD dwIndex = 0;
		HKEY hUninstallKey = 0;

		// enumerate through all installed products for the current user
		while (1)
		{
			DWORD cchLen = cchGUIDPacked+1;

			// enumerate all product subkeys. If there is any kind of error,
			// stop migrating for this user.
			LONG lResult = ::RegEnumKeyExA(hProductKey, dwIndex++, rgchProductCode, 
										&cchLen, 0, NULL, NULL, NULL);
			if (lResult != ERROR_SUCCESS)
			{
				break;
			}
			
			char szCachedPackage[MAX_PATH] = "";
			// try to read the localpackages key under the UninstallKey so that the cached
			// package is valid for migration on the NT side. Key may have already been opened
			// in a previous run through this loop.
			if (hUninstallKey || ERROR_SUCCESS == ::RegOpenKeyExA(HKEY_LOCAL_MACHINE, szUninstallKeyName, 0, KEY_READ, &hUninstallKey))
			{
				// GUIDs under the Uninstall key are not packed
				char szProductCode[cchGUID+1];
				if (UnpackGUID(rgchProductCode, szProductCode))
				{
					// open the product-specific uninstall key
					HKEY hProductUninstallKey = 0;
					if (ERROR_SUCCESS == ::RegOpenKeyExA(hUninstallKey, szProductCode, 0, KEY_READ, &hProductUninstallKey) && hProductUninstallKey)
					{
						// query the localpackage path
						DWORD cbPackageKey = sizeof(szCachedPackage);
						if (ERROR_SUCCESS != RegQueryValueExA(hProductUninstallKey, szLocalPackageValueName, 0, NULL, (LPBYTE)szCachedPackage, &cbPackageKey))
						{
							// if querying the package path failed, ensure that the buffer is the empty string.
							szCachedPackage[0] = '\0';
						}
						::RegCloseKey(hProductUninstallKey);
						hProductUninstallKey = 0;
					}
				}
			}

			// a product was found. Open the product-specific localpackages key in the NT format
			HKEY hPackageProductKey = 0;
			if (ERROR_SUCCESS == ::RegCreateKeyExA(hLocalPackagesKey, rgchProductCode, 0, NULL, 0, KEY_SET_VALUE, NULL, &hPackageProductKey, NULL) && hPackageProductKey)
			{
				// and create a "username=path" key 
				::RegSetValueExA(hPackageProductKey, fProfilesAreEnabled ? UserName : szSystemUserName, 0, REG_SZ, (const BYTE *)szCachedPackage, lstrlen(szCachedPackage));
				
				::RegCloseKey(hPackageProductKey);
				hPackageProductKey = 0;
			}
		}

		if (hUninstallKey)
		{
			::RegCloseKey(hUninstallKey);
			hUninstallKey = 0;
		}

		::RegCloseKey(hProductKey);
		hProductKey = 0;
	}
	else
	{
		// if there is no installed products key under HKCU, there is nothing
		// to migrate for this user. Return NOT_INSTALLED to prevent future
		// DLL calls for this user.
		lResult = ERROR_NOT_INSTALLED;
	}
	
	::RegCloseKey(hLocalPackagesKey);
	hLocalPackagesKey = 0;

	return lResult;
}

	
///////////////////////////////////////////////////////////////////////
// MigrateUser9x - Called once per profile on Win9X. 
// checks HKCU for a list of installed products and writes fake cached 
// package information to the normal cached package key (which is not
// used on Win9X) so that MsiRegMv has enough information about each
// profile to correctly migrate the applications.
LONG CALLBACK MigrateUser9x(HWND ParentWnd, LPCSTR AnswerFile, HKEY UserRegKey, LPCSTR UserName, LPVOID Reserved, bool& fProfilesAreEnabled)
{
	return MigrateUser9xHelper(ParentWnd, AnswerFile, UserRegKey, UserName, Reserved, fProfilesAreEnabled, false);
}


///////////////////////////////////////////////////////////////////////
// Called once on Win9X after all users are modified. Actually perfoms
// a large portion of the registry games so that the information
// is available during NT setup. Saves the temporary migration
// database to the migration directory for use in the NT side of
// migration (which migrates cached patches, packages, and transforms)
LONG CALLBACK MigrateSystem9x(HWND ParentWnd, LPCSTR AnswerFile, LPVOID Reserved, LPCTSTR szWorkingDir, bool fProfilesAreEnabled)
{
	bool	   fPlaceHolder = false;  // MigrateUser9xHelper requires this paremeter.
	PMSIHANDLE hDatabase = 0;

	// Write the faked LocalPackages entries for products installed per-machine with profile on. See bug 487742 for more information.
	MigrateUser9xHelper(ParentWnd, AnswerFile, NULL, NULL, NULL, fPlaceHolder, true);

	// the migration database will be <Temp Path>\migrate.msi
	char szPackageFilename[MAX_PATH+13];
	lstrcpyA(szPackageFilename, szWorkingDir);
	int cchPath = lstrlenA(szPackageFilename);
	if (szPackageFilename[cchPath-1] != '\\')
	{
		szPackageFilename[cchPath] = '\\';
		szPackageFilename[cchPath+1] = '\0';
	}
	lstrcatA(szPackageFilename, "migrate.msi");

	// determine the full path to the INF file
	char szINFPath[MAX_PATH+13];
	lstrcpyA(szINFPath, szWorkingDir);
	cchPath = lstrlenA(szINFPath);
	if (szINFPath[cchPath-1] != '\\')
	{
		szINFPath[cchPath] = '\\';
		szINFPath[cchPath+1] = '\0';
	}
	lstrcatA(szINFPath, "migrate.inf");

	// read all user and product information into the database. If profiles are enabled,
	// don't read HKCU (LocalPackages key has all data.) If profiles are not enabled, HKCU
	// is actually per-machine data and must be read as if it were a system install.
	ReadProductRegistrationDataIntoDatabase(szPackageFilename, *&hDatabase, /*fReadHKCUAsSystem=*/!fProfilesAreEnabled);

	// write all of the information back out to the new data location.
	// If setup is cancelled, this will be ignored by Win9X and 
	// overwritten at the next upgrade attempt. Do NOT migrate
	// any cached files, as they would be orphaned on a cancelled
	// install. They are migrated on the NT side. (LocalPackages
	// points to the Win9X copy for all users in the meantime) 
	WriteProductRegistrationDataFromDatabase(hDatabase, /*MigrateSharedDLL=*/false, /*MigratePatches=*/false);

	// if profiles are not enabled, write a UserData trigger value so the NT side knows to 
	// delete the product registration information from the individual user hives.
	if (!fProfilesAreEnabled)
	{
		// open the userdata key. This must have been created by the actual migration code above
		// or there aren't any products to migrate in the first place.
		HKEY hUserDataKey = 0;
		if ((ERROR_SUCCESS == ::RegOpenKeyExA(HKEY_LOCAL_MACHINE, szUserDataKeyName, 0, KEY_ALL_ACCESS, &hUserDataKey)) && hUserDataKey)
		{	
			const DWORD dwHKCUMigrateFlag = 1;
			DWORD cbData = sizeof(dwHKCUMigrateFlag);
			RegSetValueExA(hUserDataKey, szMigrateWin9XToHKLM, 0, REG_DWORD, reinterpret_cast<const BYTE *>(&dwHKCUMigrateFlag), cbData);
			RegCloseKey(hUserDataKey);
			hUserDataKey = 0;
		}

		EnumerateSystemAppDataFiles(hDatabase, szINFPath);
	}
	
	// save the database. It contains cleanup information that is needed by the 
	// NT portion of the migration DLL.
	MsiDatabaseCommit(hDatabase);

	// write a "Handled" string to migrate.inf to turn off the compatibility message
	WritePrivateProfileStringA("Handled", "HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components", "Report", szINFPath);

	return ERROR_SUCCESS;
}

// include the migration code shared between migration DLL and msiregmv.exe
#include "..\..\msiregmv\writecfg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msi9xmig\msi9xmig.dll\msiregmv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msiregmv.cpp
//
//--------------------------------------------------------------------------

// This must be compiled in the "unicode" manner due to the fact that MSI will
// rearrange the binplace targets for "ansi" builds. However this migration DLL 
// is always ANSI, so we undefine UNICODE and _UNICODE while leaving the rest
// of the unicode environment.
#undef UNICODE
#undef _UNICODE

#include <windows.h>

// the shared migration code requires a "debug output" function and a global
// Win9X							  
bool g_fWin9X = false;
void DebugOut(bool fDebugOut, LPCTSTR str, ...) {};

// include the migration code shared between migration DLL and msiregmv.exe
#include "..\..\msiregmv\migutil.cpp"
#include "..\..\msiregmv\migsecur.cpp"
#include "..\..\msiregmv\readcnfg.cpp"
#include "..\..\msiregmv\patch.cpp"
#include "..\..\msiregmv\cleanup.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msicert\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msicert\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msicert\make.inc ===
#
# Copy files from cmdparse
#

$(O)\cmdparse.h    : ..\..\cmdparse\cmdparse.h
    copy $? $@

$(O)\cmdparse.cpp  : ..\..\cmdparse\cmdparse.cpp
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msicert\sources.inc ===
TARGETNAME=MsiCert
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

USE_LIBCMT=1

TARGETLIBS=\
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\crypt32.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(BUILD_COMMONDIR);$(INC_DIR);$(RES_OBJDIR);$(MSI_CMDPARSE_DIR)

SOURCES=..\msicert.cpp \
	..\msicert.rc  \
	$(O)\cmdparse.cpp

NTTARGETFILE0=       \
	$(O)\cmdparse.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msidb\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msicabsz\msicabsz.cpp ===
#define W32
#define MSI


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "MsiQuery.h" // MSI API

//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

const char szHelp[] = "MSICabSz. Syntax: {database} {DDF} [-D NAME=Value ...]";

//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

int __cdecl main(int argc, char* argv[])
{
	char* rgArgs[256][2];

	if (argc < 3)
	{
		printf(szHelp);
		return -1;
	}
	
	for (int i=0; i < 256; i++)
	{
		rgArgs[i][0]=NULL;
		rgArgs[i][1]=NULL;
	}

	int cArgs = 0;
	for (i=3; i < argc; i++)
	{
		if (_strcmpi(argv[i], "-D") ||
			(i+1 >= argc))
		{
			printf(szHelp);
			return -1;
		}
		rgArgs[cArgs][0] = argv[i+1];
		rgArgs[cArgs][1] = argv[i+1];
		while ((*rgArgs[cArgs][1] != 0) && (*rgArgs[cArgs][1] != '='))
			rgArgs[cArgs][1]++;
		if (*rgArgs[cArgs][1] == '=')
			*(rgArgs[cArgs][1]++) = 0;
		cArgs++;
		i++;
	}

	MSIHANDLE hDB = 0;
	MSIHANDLE hView = 0;

	HANDLE DDFFile;

	DDFFile = CreateFileA(argv[2], GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (DDFFile == INVALID_HANDLE_VALUE)
	{
		printf("Open DDF Failed. GetLastError: %d\n", GetLastError());
		return -1;
	}

 	// create buffer for file. Note we fail if its really big. Who wants a DDF file that big?
 	DWORD cbFile;
 	cbFile = GetFileSize(DDFFile, NULL);

 	char *rgchBuf = new char[cbFile+2];

	DWORD cbRead;
 	if (!ReadFile(DDFFile, rgchBuf, cbFile, &cbRead, NULL))
	{
	 	CloseHandle(DDFFile);
		printf("Read DDF Failed. GetLastError: %d\n", GetLastError());
		return -1;
	}
 	
 	CloseHandle(DDFFile);
	rgchBuf[cbRead]='\0';
 	
	printf("Open...");
	if (!MsiOpenDatabaseA(argv[1], (char *)MSIDBOPEN_TRANSACT, &hDB))
	{
//		MSIHANDLE hHashView = 0;
//		MsiDatabaseOpenView(hDB, TEXT("SELECT File_, Options, HashPart1, HashPart2, HashPart3, HashPart4 FROM MsiFileHash WHERE `File_`=?"), &hHashView);

		char *szCurrent = rgchBuf;
		int iSequence = 0;
		while (szCurrent && *szCurrent) 
		{
			// we want to skip any lines that begin with a ';' or 
			// set values.
			if (*szCurrent == ';')
			{
				szCurrent = strchr(szCurrent, '\n');
				szCurrent++;
				continue;
			}
				
			if (0 == strncmp(szCurrent, ".Set", 4))
			{
				szCurrent = strchr(szCurrent, '\n');
				szCurrent++;
				continue;
			}

			// all other lines are in DDF format, which is
			// filename			name in cab
			// which for us is
			// filename			filekey
			// filename can have %arg% in it, which is replaced by the 
			// values given on the command line
			iSequence++;

			// copy the filename, replacing as needed
			char rgchFileName[256];
			rgchFileName[0] = 0;
			char *szFileName = rgchFileName;
			while (!isspace(*szCurrent))
			{
				if (*szCurrent == '%') 
				{
					*szFileName = '\0';
   					bool fContinue = false;
					for (int i=0; i < cArgs; i++)
					{
						int cchName = strlen(rgArgs[i][0]);
						if ((0 == strncmp(szCurrent+1, rgArgs[i][0], cchName)) && (*(szCurrent+cchName+1) == '%'))
						{
							strcat(szFileName, rgArgs[i][1]);
							szCurrent += cchName+2;
							szFileName += strlen(rgArgs[i][1]);
							fContinue = true;
							break;
						} 
					}
					if (fContinue)
						continue; 
				}
				*szFileName++ = *szCurrent++;
			}
			*szFileName = '\0';

			// eat whitespace
			while (*szCurrent && isspace(*szCurrent))
				szCurrent++;

			// the rest of this line is the file key. If no endline, the rest of file is
			char *szFileKey = szCurrent;
			szCurrent = strchr(szCurrent, '\r');
			if (szCurrent != NULL)
			{
				*szCurrent = '\0';
				szCurrent+=2;
			}

			// get the file size, version and language

			HANDLE hFile = CreateFileA(rgchFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			if (hFile == INVALID_HANDLE_VALUE)
			{
				printf("Open File for %s, Failed. GetLastError: %d\n", rgchFileName, GetLastError());
//				if (hHashView)
//					MsiCloseHandle(hHashView);
				MsiCloseHandle(hDB);
				return -1;
			}

			// note that we assume the file is less than 4GB
			DWORD uiFileSize = GetFileSize(hFile, NULL);
			CloseHandle(hFile);

			char rgchFileVersion[50];
			DWORD cchFileVersion = 50;
			char rgchFileLanguage[100];
			DWORD cchFileLanguage = 50;
			UINT iStat = MsiGetFileVersionA(rgchFileName, rgchFileVersion, &cchFileVersion, rgchFileLanguage, &cchFileLanguage);
			if (iStat == ERROR_FILE_INVALID)
			{
				rgchFileVersion[0] = '\0';
				rgchFileLanguage[0] = '\0';
			}
			else if (iStat != ERROR_SUCCESS) 
			{
				printf("Failed to get version info for file %s.\n", rgchFileName);
//				if (hHashView)
//					MsiCloseHandle(hHashView);
				MsiCloseHandle(hDB);
				return -1;
			}

			// build and execute the query
			MSIHANDLE hView;
			char szQuery[500];
			sprintf(szQuery, "UPDATE `File` SET `FileSize`=%d, `Version`='%s', `Language`='%s', `Sequence`=%d WHERE `File`='%s'", uiFileSize, rgchFileVersion, rgchFileLanguage, iSequence, szFileKey);			
			if (ERROR_SUCCESS != MsiDatabaseOpenViewA(hDB, szQuery, &hView) ||
				ERROR_SUCCESS != MsiViewExecute(hView, 0))
			{
				printf("Failed to get version info for file %s.\n", rgchFileName);
				if (hView)
					MsiCloseHandle(hView);
//				if (hHashView)
//					MsiCloseHandle(hHashView);
				MsiCloseHandle(hDB);
				return -1;
			}
			MsiCloseHandle(hView);

			printf("Updated %s. Size: %d, Version %s, Language: %s\n", rgchFileName, uiFileSize, rgchFileVersion, rgchFileLanguage);
/*
			// file hash update
			if (hHashView)
			{
				PMSIHANDLE hQueryRec = MsiCreateRecord(1);
				MsiRecordSetStringA(hQueryRec, 1, szFileKey);
	
				MsiViewExecute(hHashView, hQueryRec);
				PMSIHANDLE hFileRec = 0;
				if (ERROR_SUCCESS == MsiViewFetch(hHashView, &hFileRec))
				{
					MSIFILEHASHINFO HashInfo;
	
					HashInfo.dwFileHashInfoSize = sizeof(MSIFILEHASHINFO);
					if (ERROR_SUCCESS == MsiGetFileHashA(rgchFileName, 0, &HashInfo))
					{
						MsiRecordSetInteger(hFileRec, 2, 0);
						MsiRecordSetInteger(hFileRec, 3, HashInfo.dwData[0]);
						MsiRecordSetInteger(hFileRec, 4, HashInfo.dwData[1]);
						MsiRecordSetInteger(hFileRec, 5, HashInfo.dwData[2]);
						MsiRecordSetInteger(hFileRec, 6, HashInfo.dwData[3]);
						MsiViewModify(hHashView, MSIMODIFY_UPDATE, hFileRec);
	
						printf("Updated %s. Hash1: %d, Hash2: %d, Hash3: %d, Hash4 %d.\n", rgchFileName, HashInfo.dwData[0], HashInfo.dwData[1], HashInfo.dwData[2], HashInfo.dwData[3]);
					}
					else
					{
						printf("Dropped Hash Row for %s.\n", rgchFileName);
						MsiViewModify(hHashView, MSIMODIFY_DELETE, hFileRec);
					}
				}
			}
*/
		}	
//		if (hHashView)
//			MsiCloseHandle(hHashView);
		MsiDatabaseCommit(hDB);
		MsiCloseHandle(hDB);
	}
	else
		printf("Failed to Open Database");

	delete[] rgchBuf;
	printf("Done.\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msi9xmig\msintmig.dll\msintmig.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msintmig.cpp
//
//--------------------------------------------------------------------------

#include <tchar.h>
#include <windows.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <sddl.h>
#include <winwlx.h>
#include <shlobj.h>
#include <userenv.h>
#include <lm.h>
#include "..\..\msiregmv\msiregmv.h"

DWORD GetSecureSecurityDescriptor(char** pSecurityDescriptor);
DWORD GetEveryoneUpdateSecurityDescriptor(char** pSecurityDescriptor);

////
// registry key names, subkeys, and value names
const WCHAR szMicrosoftSubKeyName[] = L"Software\\Microsoft";
const WCHAR szMachineProductRegistraiton[] = L"Software\\Classes\\Installer";
const WCHAR szUserDataKeyName[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData";
const WCHAR szSystemUserDataKeyName[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\S-1-5-18";
const WCHAR szSystemUserName[] = L"S-1-5-18";

const WCHAR szProductsSubKeyName[] = L"Products";
const WCHAR szInstallerSubKeyName[] = L"Installer";
const WCHAR szAssignmentValueName[] = L"Assignment";

const WCHAR szFeatureUsageSubKeyName[] = L"Usage";
const int cchUsage = sizeof(szFeatureUsageSubKeyName)/sizeof(WCHAR);


// initial buffer size when retrieving domains. Buffer will be resized if necessary
const int cchMaxDomain = 30;


// profile migration data registry keys
const WCHAR szMigrateUserName[] = L"MigrateUserName";
const WCHAR szMigrateUserDomain[] = L"MigrateUserDomain";
const WCHAR szMigrateWin9XToHKLM[] = L"MigrateWin9XToHKLM";


// transform path fixup
const WCHAR szInstallerSubDir[] = L"Installer";
const int cchInstallerSubDir = sizeof(szInstallerSubDir)/sizeof(WCHAR);

const WCHAR szAppDataTransformPrefix[] = L"*26*Microsoft\\Installer";
const int cchAppDataTransformPrefix = sizeof(szAppDataTransformPrefix)/sizeof(WCHAR);

////
// registration information for MSI winlogon notification DLL.
struct {
	LPCWSTR szName;
	DWORD   dwType;
	LPCWSTR wzData;
	DWORD   dwData;
}
rgNotifyArgument[] =
{
	{ L"Asynchronous", REG_DWORD,     NULL,             1 },
	{ L"DllName",      REG_EXPAND_SZ, L"MsiNtMig.Dll",  0 },
	{ L"Impersonate",  REG_DWORD,     NULL,             0 },
	{ L"Logon",        REG_SZ,        L"LogonNotify",   0 },
	{ L"Startup",      REG_SZ,        L"StartupNotify", 0 } 
};
const int cNotifyArgument = 5;

const WCHAR szMSINotificationDLLKey[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\MsiNtMig";
const WCHAR szNotificationDLLKey[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify";


///////////////////////////////////////////////////////////////////////
// NT-side initialization routine. Opens the cached package, drops
// the SharedDLL and Component tables, then re-reads component
// information from the registry to pick up component paths that
// have changed during the upgrade (from system to system32).
// then re-writes component data to all UserData keys.
DWORD CALLBACK InitializeNT(LPCWSTR wzWorkingDir)
{
	// the migration database will be <Temp Path>\migrate.msi
	WCHAR wzPackageFilename[MAX_PATH+13];
	lstrcpyW(wzPackageFilename, wzWorkingDir);
	int cchPath = lstrlenW(wzPackageFilename);
	if (wzPackageFilename[cchPath-1] != L'\\')
	{
		wzPackageFilename[cchPath] = L'\\';
		wzPackageFilename[cchPath+1] = L'\0';
	}
	lstrcatW(wzPackageFilename, L"migrate.msi");

	// open the UserData key
	HKEY hUserDataKey = 0;
	DWORD dwResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE, szUserDataKeyName, 0, KEY_ALL_ACCESS, &hUserDataKey);

	// if there is no UserData key, nothing to migrate but not an error.
	if ((ERROR_SUCCESS == dwResult) && hUserDataKey)
	{
		PMSIHANDLE hDatabase = 0;
		// open the database in transact mode to read all product information and cleanup data.
		if (ERROR_SUCCESS == MsiOpenDatabaseW(wzPackageFilename, MSIDBOPEN_TRANSACT, &hDatabase))
		{		
			// drop the component table. The main purpose of this call is to replace existing
			// data, and that won't happen unless the table disappears.
			MSIHANDLE hView = 0;
			if (ERROR_SUCCESS == MsiDatabaseOpenViewW(hDatabase, L"DROP TABLE Component", &hView) &&
				ERROR_SUCCESS == MsiViewExecute(hView, 0))
			{
				MsiViewClose(hView);
				MsiCloseHandle(hView);
				hView = 0;

				// shared DLL data is less critical. If the table can't be deleted and we use
				// stale data, thats OK because any bad side-effects of the stale data can
				// be auto-repaired by MSI (file disappears) or are not fatal (file never disappears).
				if (ERROR_SUCCESS == MsiDatabaseOpenViewW(hDatabase, L"DROP TABLE SharedDLL", &hView))
				{
					MsiViewExecute(hView, 0);
					MsiViewClose(hView);
					MsiCloseHandle(hView);
					hView = 0;
				}

				// re-read all component path data (including permanent status)
				ReadComponentRegistrationDataIntoDatabase(hDatabase);

				// write all component data for each user, and write permanent
				// dummy products in the per-machine hive.
				MigrateUserOnlyComponentData(hDatabase);
			}
			
			// because this DLL is dynamically loaded by the real migration DLL, it gets
			// unloaded between calls. The database must be committed to ensure that
			// the new data is stored.
			MsiDatabaseCommit(hDatabase);
		}
		RegCloseKey(hUserDataKey);
		hUserDataKey = 0;
	}
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// ACL all of the feature usage subkeys to the "everyone update"
// security descriptor. (Admins/System full control, Everyone 
// read, update.) Failure is not fatal. hRoot is UserData\<SID> key.
void ACLAllUsageKeys(HKEY hRoot)
{
	SECURITY_DESCRIPTOR* pSD = NULL;
	if (ERROR_SUCCESS == GetEveryoneUpdateSecurityDescriptor((char **)&pSD))
	{
		// open the <SID>\Products subkey
		HKEY hProductsKey = 0;
		if (ERROR_SUCCESS == ::RegOpenKeyExW(hRoot, szProductsSubKeyName, 0, KEY_READ, &hProductsKey))
		{
			WCHAR rgchProductCode[cchGUIDPacked+1+cchUsage+1];
			DWORD dwIndex = 0;

			// enumerate through all installed products for the current user
			while (1)
			{
				DWORD cchLen = cchGUIDPacked+1;
	
				// enumerate all product subkeys. If there is any kind of error,
				// stop enumerating to ensure we don't end up in a loop.
				LONG lResult = ::RegEnumKeyExW(hProductsKey, dwIndex++, rgchProductCode, 
											&cchLen, 0, NULL, NULL, NULL);
				if (lResult != ERROR_SUCCESS)
				{
					break;
				}
	
				// a product was found. Open the product-specific feature usage key,
				// <SID>\Products\<GUID>\Usage
				HKEY hUsageKey = 0;
				rgchProductCode[cchGUIDPacked] = L'\\';
				lstrcpyW(&(rgchProductCode[cchGUIDPacked+1]), szFeatureUsageSubKeyName);
				if (ERROR_SUCCESS == ::RegOpenKeyExW(hProductsKey, rgchProductCode, 0, WRITE_DAC | WRITE_OWNER, &hUsageKey))
				{
					// set the DACL and owner information. Do not set SACL or Group
					LONG lResult = RegSetKeySecurity(hUsageKey, DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION, pSD);
	
					::RegCloseKey(hUsageKey);
					hUsageKey = 0;
				}
			}

			RegCloseKey(hProductsKey); 
			hProductsKey = 0;
		}
	}
}



///////////////////////////////////////////////////////////////////////
// Looks for REG_EXPAND_SZ "Transforms" values and replaces the 
// *26*Microsoft\Installer path prefix to point to the real 
// per-machine installer directory.
void FixNonSecureTransformPaths(HKEY hRoot)
{
	// determine the path to the installer directory.
	WCHAR szInstallerDirPath[MAX_PATH+2];
	int cchInstallerDirPath = GetWindowsDirectoryW(szInstallerDirPath, MAX_PATH);
	if (cchInstallerDirPath == 0 || cchInstallerDirPath > MAX_PATH)
		return;
	if (szInstallerDirPath[cchInstallerDirPath-1] != L'\\')
	{
		szInstallerDirPath[cchInstallerDirPath] = L'\\';
		szInstallerDirPath[cchInstallerDirPath+1] = L'\0';
		cchInstallerDirPath++;
	}
	
	// check for buffer overrun and append installer cache directory subdir
	if (cchInstallerDirPath+cchInstallerSubDir > MAX_PATH)
		return;
	lstrcatW(szInstallerDirPath, szInstallerSubDir);

	// update length. subtract one for terminating null of substring
	cchInstallerDirPath += cchInstallerSubDir-1;

	// open the <SID>\Products subkey
	HKEY hProductsKey = 0;
	if (ERROR_SUCCESS == ::RegOpenKeyExW(hRoot, szProductsSubKeyName, 0, KEY_READ, &hProductsKey))
	{
		WCHAR rgchProductCode[cchGUIDPacked+1];
		DWORD dwIndex = 0;

		// enumerate through all per-machine installed products
		while (1)
		{
			DWORD cchLen = cchGUIDPacked+1;

			// enumerate all product subkeys. If there is any kind of error,
			// stop enumerating to ensure we don't end up in a loop.
			LONG lResult = ::RegEnumKeyExW(hProductsKey, dwIndex++, rgchProductCode, 
										&cchLen, 0, NULL, NULL, NULL);
			if (lResult != ERROR_SUCCESS)
			{
				break;
			}

			// a product was found. Open the product key to set the value
			HKEY hProductKey = 0;
			if (ERROR_SUCCESS == ::RegOpenKeyExW(hProductsKey, rgchProductCode, 0, KEY_ALL_ACCESS, &hProductKey))
			{
				// read the "Transforms" value.
				DWORD cchData = 0;
				DWORD dwType = 0;
				DWORD dwResult = 0;
				if (ERROR_SUCCESS == (dwResult = RegQueryValueExW(hProductKey, szTransformsValueName, NULL, &dwType, NULL, &cchData)))
				{
					WCHAR* pData = new WCHAR[cchData];
					if (!pData)
					{
						::RegCloseKey(hProductKey);
						hProductKey = 0;
						continue;
					}

					if (ERROR_SUCCESS == RegQueryValueExW(hProductKey, szTransformsValueName, NULL, &dwType, reinterpret_cast<BYTE*>(pData), &cchData))
					{
						// check to see if the transforms are secure. If so, none will be stored in AppData
						if (pData[0] == L'|' || pData[0] == L'@')
						{
							::RegCloseKey(hProductKey);
							hProductKey = 0;
							
							delete[] pData;
							pData = NULL;
							
							continue;
						}

						// counter to keep track of new value length
						DWORD cchBufferSize = MAX_PATH;
						DWORD cchNewValue = 0;
						WCHAR *wzTargetValue = new WCHAR[MAX_PATH];
						if (!wzTargetValue)
						{
							::RegCloseKey(hProductKey);
							hProductKey = 0;
							
							delete[] pData;
							pData = NULL;
							continue;
						}


						// walking pointers
						WCHAR* wzCurrentRead = pData;
						WCHAR* wzCurrentWrite = wzTargetValue;
						WCHAR* wzNextChar = pData;

						// search forward for a semicolon
						while (wzCurrentRead && *wzCurrentRead)
						{
							// scan forward for semicolon or end of string
							while (*wzNextChar && *wzNextChar != L';')
								wzNextChar++;

							// if we didn't hit the end of the string, increment past the semicolon
							if (*wzNextChar)
								*(wzNextChar++)=0;

							// check if the path starts with "*26*\Microsoft\Installer" Subtract 1 from
							// count for terminating null on substring
							if (0 == wcsncmp(wzCurrentRead, szAppDataTransformPrefix, cchAppDataTransformPrefix-1))
							{
								// if so, replace it with the system installer dir
								wcsncpy(wzCurrentWrite, szInstallerDirPath, cchInstallerDirPath);
								wzCurrentWrite += cchInstallerDirPath;
								wzCurrentRead += cchAppDataTransformPrefix-1;
								cchNewValue += cchInstallerDirPath;
							}

							// determine how long the remainder of the transform path is
							DWORD cchThisTransform = lstrlenW(wzCurrentRead);

							// check for buffer overrun
							if (cchNewValue + cchThisTransform + 2 > cchBufferSize)
							{
								// always ensure there is enough space to place another installer dir path
								// plus a delimiter this is easier than resizing the buffer in multiple 
								// locations
								cchBufferSize += cchInstallerDirPath + 1 + MAX_PATH;
								WCHAR* pNew = new WCHAR[cchBufferSize];
								if (!pNew)
								{
									delete[] pData;
									delete[] wzTargetValue;
									wzTargetValue = NULL;
									pData = NULL;
									return;
								}


								// move the data
								*wzCurrentWrite = '\0';
								lstrcpyW(pNew, wzTargetValue);
								delete[] wzTargetValue;
								wzTargetValue = pNew;
								wzCurrentWrite = wzTargetValue+cchNewValue;
							}


							// copy the rest of the path to the target buffer
							wcsncpy(wzCurrentWrite, wzCurrentRead, cchThisTransform);
							wzCurrentWrite += cchThisTransform;
							cchNewValue += cchThisTransform;

							// if there are still more transforms, semicolon delimit, otherwise null terminate
							*(wzCurrentWrite++) = (*wzNextChar) ? ';' : '\0'; 
							cchNewValue++;

							// move to the next transform
							wzCurrentRead = wzNextChar;
						}

						// set the value back into the registry
						RegSetValueExW(hProductKey, szTransformsValueName, 0, REG_EXPAND_SZ, reinterpret_cast<BYTE*>(wzTargetValue), (cchNewValue+1)*sizeof(WCHAR));

						// free memory for target value
						delete[] wzTargetValue;
						wzTargetValue = NULL;
					}

					delete[] pData;
					pData = NULL;
				}

				// close specific product key
				::RegCloseKey(hProductKey);
				hProductKey = 0;
			}
		}

		// close product collection
		RegCloseKey(hProductsKey); 
		hProductsKey = 0;
	}
}



///////////////////////////////////////////////////////////////////////
// Set the "Assignment" bit in each product registration under the
// current key. Failure is not fatal. hRoot is \Installer key.
void SetProductAssignmentValues(HKEY hRoot)
{
	// open the <SID>\Products subkey
	HKEY hProductsKey = 0;
	if (ERROR_SUCCESS == ::RegOpenKeyExW(hRoot, szProductsSubKeyName, 0, KEY_READ, &hProductsKey))
	{
		WCHAR rgchProductCode[cchGUIDPacked+1];
		DWORD dwIndex = 0;

		// enumerate through all installed products for the current user
		while (1)
		{
			DWORD cchLen = cchGUIDPacked+1;

			// enumerate all product subkeys. If there is any kind of error,
			// stop enumerating to ensure we don't end up in a loop.
			LONG lResult = ::RegEnumKeyExW(hProductsKey, dwIndex++, rgchProductCode, 
										&cchLen, 0, NULL, NULL, NULL);
			if (lResult != ERROR_SUCCESS)
			{
				break;
			}

			// a product was found. Open the product key to set the value
			HKEY hProductKey = 0;
			if (ERROR_SUCCESS == ::RegOpenKeyExW(hProductsKey, rgchProductCode, 0, KEY_SET_VALUE, &hProductKey))
			{
				// set Assignment to '1'
				const DWORD dwAssignment = 1;
				LONG lResult = RegSetValueExW(hProductKey, szAssignmentValueName, 0, REG_DWORD, reinterpret_cast<const BYTE*>(&dwAssignment), sizeof(dwAssignment));

				::RegCloseKey(hProductKey);
				hProductKey = 0;
			}
		}

		RegCloseKey(hProductsKey); 
		hProductsKey = 0;
	}
}


// this is the list of Installer advertise subkeys to be moved from HKCU
// to HKLM, as of 1.5 data registration format. Extra keys are not moved,
// but are deleted from the HKCU key.
LPCWSTR rgwzMoveKeys[] = {
	L"Products",
	L"UpgradeCodes",
	L"Features",
	L"Components",
	L"Patches"
};
const int cwzMoveKeys = sizeof(rgwzMoveKeys)/sizeof(LPCWSTR);

///////////////////////////////////////////////////////////////////////
// moves the per-user product registration keys to per-machine. This
// is used when Win9X no-profiles apps are migrated to NT. Migrated
// information includes product info (sourcelist, etc), qualified
// components, upgrade codes, and feature state information.
void MovePerUserAppsToPerMachine(HKEY hUserKey)
{
	DWORD dwResult = 0;

	// get a security descriptor for the new per-machine subkeys (secure SD: Everone read,
	// admin/system full control)
	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = FALSE;

	if (ERROR_SUCCESS != GetSecureSecurityDescriptor((char**)&sa.lpSecurityDescriptor))
	{
		// verify that the call didn't change the pointer on failure
		sa.lpSecurityDescriptor = NULL;
	}
	
	// open HKCU\Software\Microsoft
	HKEY hMicrosoftKey = 0;
	if (ERROR_SUCCESS == (dwResult = RegOpenKeyExW(hUserKey, szMicrosoftSubKeyName, 0, KEY_ALL_ACCESS, &hMicrosoftKey)))
	{	
		// open \Installer seperately so it can be deleted after all key copies.
		HKEY hUserKey = 0;
		if (ERROR_SUCCESS == (dwResult = RegOpenKeyExW(hMicrosoftKey, szInstallerSubKeyName, 0, KEY_ALL_ACCESS, &hUserKey)))
		{	
			// open target key HKLM\Software\Classes\Installer
			HKEY hMachineKey = 0;
			if (ERROR_SUCCESS == (dwResult = RegCreateKeyExW(HKEY_LOCAL_MACHINE, szMachineProductRegistraiton, 0, L"", 0, KEY_ALL_ACCESS, &sa, &hMachineKey, NULL)))
			{
				// loop over the array of keys to migrate. Each subkey will be copied in its entirety to
				// the HKLM registration key
				for (int i=0; i < cwzMoveKeys; i++)
				{
					// create the destination key (secure)
					HKEY hSubKey = 0;
					if (ERROR_SUCCESS == (dwResult = RegCreateKeyExW(hMachineKey, rgwzMoveKeys[i], 0, L"", 0, KEY_ALL_ACCESS, &sa, &hSubKey, NULL)))
					{		

						// copy the entire sbkey to the new SID key. Failure can't be fixed.
						SHCopyKeyW(hUserKey, rgwzMoveKeys[i], hSubKey, 0);
						RegCloseKey(hSubKey);
						hSubKey = 0;
					}
				}

				// mark all per-machine apps as "Assignment=1". Again, failure can't be fixed.
				SetProductAssignmentValues(hMachineKey);

				// fix-up transform paths. Again, failure can't be fixed.
				FixNonSecureTransformPaths(hMachineKey);

				RegCloseKey(hMachineKey);
				hMachineKey = 0;
			}
	
			RegCloseKey(hUserKey);
			hUserKey = 0;
		
			// delete the entire per-user "Installer" key. Even if something earlier failed,
			// we can't leave this data floating around or the machine is in a seriously 
			// broken state.
			dwResult = SHDeleteKeyW(hMicrosoftKey, szInstallerSubKeyName);		
		}
	
		RegCloseKey(hMicrosoftKey);
		hMicrosoftKey = 0;
	}
}

bool MoveAllExplicitlyMigratedCacheFiles(MSIHANDLE hDatabase)
{
	PMSIHANDLE hView = 0;

	// create an insertion query and a record for the insertion
	if (ERROR_SUCCESS != MsiDatabaseOpenViewW(hDatabase, L"SELECT * FROM `MoveFiles`", &hView) ||
		ERROR_SUCCESS != MsiViewExecute(hView, 0))
	{
		return false;
	}

	PMSIHANDLE hRec = 0;
	DWORD dwResult = ERROR_SUCCESS;

	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hView, &hRec)))
	{
		// the source and target paths should never be more than MAX_PATH, so if any strings are
		// longer than that, skip them.
		WCHAR wzSource[MAX_PATH];
		WCHAR wzDest[MAX_PATH];
		DWORD cchSource = MAX_PATH;
		DWORD cchDest = MAX_PATH;
		if (ERROR_SUCCESS != MsiRecordGetStringW(hRec, 1, wzSource, &cchSource) ||
			ERROR_SUCCESS != MsiRecordGetStringW(hRec, 2, wzDest, &cchDest))
			continue;

		MoveFileExW(wzSource, wzDest, MOVEFILE_COPY_ALLOWED);		
	}

	return true;
}

bool MsiMigLookupAccountName(LPCWSTR szDomain, LPCWSTR szUserName, char* &pSID, DWORD &cbSID, SID_NAME_USE &SNU)
{
	DWORD cbDomain = cchMaxDomain;
	WCHAR *pDomain = new WCHAR[cchMaxDomain];
	if (!pDomain)
	{
		return false;
	}

	// lookup the user SID. May need to resize SID buffer or domain.
	BOOL fSuccess = LookupAccountNameW(szDomain, szUserName, pSID, &cbSID, pDomain, &cbDomain, &SNU);

	if (!fSuccess)
	{
		// if the lookup failed, we can handle a buffer size problem
		if (ERROR_MORE_DATA == GetLastError())
		{
			if (cbSID > cbMaxSID)
			{
				delete[] pSID;
				pSID = new char[cbSID];
				if (!pSID)
				{
					delete[] pDomain;
					return false;
				}
			}
			if (cbDomain > cchMaxDomain)
			{
				delete[] pDomain;
				pDomain = new WCHAR[cbDomain];
				if (!pDomain)
				{
					return false;
				}
			}
			fSuccess = LookupAccountNameW(szDomain, szUserName, pSID, &cbSID, pDomain, &cbDomain, &SNU);
		}
	}

	delete[] pDomain;
	return (fSuccess ? true : false);
}

///////////////////////////////////////////////////////////////////////
// given an old username, new username, and domain, attempts to rename
// the /UserData/<username> key to /UserData/<UserSID>. Also ACLs the
// key appropriately. Deletes any delayed migration keys if successful.
// Returns non-ERROR_SUCCESS on failure, as the logon notification
// DLL can try again later.
DWORD RenameUserKeyToSID(HKEY hUserDataKey, LPCWSTR szOldUserName, LPCWSTR szDomain, LPCWSTR szNewUserName)
{
	DWORD dwResult = ERROR_SUCCESS;

	// initial buffers for use when looking up the account name.
	DWORD cbSID = cbMaxSID;
	char *pSID = new char[cbMaxSID];
	if (!pSID)
		return ERROR_OUTOFMEMORY;

	// assume that the SID lookup will use the new user name.
	LPCWSTR wzUseThisUserName = szNewUserName;

	// but in some situations we'll need a special lookup name that
	// is not the real user name
	WCHAR* wzLookupUserName = NULL;

	// obtain the computer name. If the computer name is the same as the user name,
	// special syntax has to be used in LookupAccountName
	WCHAR wzComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD cchComputerName = MAX_COMPUTERNAME_LENGTH + 1;
	if (GetComputerNameW(wzComputerName, &cchComputerName))
	{
		// compare the machine name against the NT-side user name
		if (0 == lstrcmpiW(wzComputerName, szNewUserName))
		{
			// special syntax for this situation is "Name\Name", which
			// prevents the lookup from finding just "Name" as the machine
			// account
			wzLookupUserName = new WCHAR[2*lstrlenW(szNewUserName)+2];
			if (!wzLookupUserName)
			{
				delete[] pSID;
				return ERROR_OUTOFMEMORY;
			}
			lstrcpyW(wzLookupUserName, szNewUserName);
			lstrcatW(wzLookupUserName, L"\\");
			lstrcatW(wzLookupUserName, szNewUserName);
			wzUseThisUserName = wzLookupUserName;
		}
	}

	SID_NAME_USE SNU = SidTypeUnknown;

	// make a first attempt to look up the user name
	bool fSuccess = MsiMigLookupAccountName(szDomain, wzUseThisUserName, pSID, cbSID, SNU);

	// if the user name was the same as the machine name, but the lookup still
	// didn't find the user using the Machine\User syntax, the user account (if
	// it exists at all) must be a domain account of some kind. If no domain
	// was explicitly provided, we'll try to get the machine's domain and start
	// a search from there. The LookupAccountName API has its own search order.
	if ((!fSuccess || (fSuccess && (SNU == SidTypeDomain))) && wzLookupUserName && (!szDomain || !*szDomain))
	{
		WKSTA_INFO_100* wkstaInfo;
		if (NERR_Success == NetWkstaGetInfo(NULL, 100, reinterpret_cast<unsigned char**>(&wkstaInfo)))
		{
			// verify that there is a domain for the machine
			if (wkstaInfo->wki100_langroup && *wkstaInfo->wki100_langroup)
			{
				// since we know that there is a machine name that is the same as the user to look up,
				// try the lookup as <Domain>\<User> in the username to prevent the API from finding
				// the machine account.
				delete[] wzLookupUserName;
				wzLookupUserName = NULL;
				wzLookupUserName = new WCHAR[lstrlenW(wkstaInfo->wki100_langroup)+lstrlenW(szNewUserName)+2];
				if (!wzLookupUserName)
				{
					delete[] pSID;
					NetApiBufferFree(wkstaInfo);
					return ERROR_OUTOFMEMORY;
				}

				lstrcpyW(wzLookupUserName, wkstaInfo->wki100_langroup);
				lstrcatW(wzLookupUserName, L"\\");
				lstrcatW(wzLookupUserName, szNewUserName);
				NetApiBufferFree(wkstaInfo);
	
				fSuccess = MsiMigLookupAccountName(L"", wzLookupUserName, pSID, cbSID, SNU);
			}
		}
		else
		{
			fSuccess = false;
		}
	}

	// clean up special syntax if username is the same as the machine name.
	if (wzLookupUserName)
		delete[] wzLookupUserName;

	if (fSuccess && SNU == SidTypeUser)
	{
		// assume we are going to fail 
		fSuccess = false;

		// convert the binary SID to a string
		//GetStringSIDW((PISID)pSID, szSID);
		WCHAR *szSID = NULL;
		if (ConvertSidToStringSidW(pSID, &szSID) && szSID)
		{			
			HKEY hSIDKey = 0;
			
			// get a security descriptor for the new user SID key (secure SD: Everone read,
			// admin/system full control)
			SECURITY_ATTRIBUTES sa;
			sa.nLength = sizeof(SECURITY_ATTRIBUTES);
			sa.lpSecurityDescriptor = NULL;
			sa.bInheritHandle = FALSE;
			if (ERROR_SUCCESS != GetSecureSecurityDescriptor((char**)&sa.lpSecurityDescriptor))
			{
				// verify that the call didn't change the pointer on failure. Better to rename
				// the key and inherit the installer key ACLs (which should be equivalently 
				// secure) than to fail.
				sa.lpSecurityDescriptor = NULL;
			}

			// create a SID subkey under the UserData key with secure SD
			if (ERROR_SUCCESS == (dwResult = RegCreateKeyExW(hUserDataKey, szSID, 0, L"", 0, KEY_ALL_ACCESS, &sa, &hSIDKey, NULL)))
			{
				// copy the entire UserName key to the new SID key.
				if (ERROR_SUCCESS == SHCopyKeyW(hUserDataKey, szOldUserName, hSIDKey, 0))
				{
					// delete the old "UserName" key. Failure to delete can't be fixed. 
					SHDeleteKeyW(hUserDataKey, szOldUserName);

					// enumerate all products and ACL the Usage key for each one.
					// (Usage keys are only semi-secure). Failure is irrelevant (feature
					// usage info will just be lost).
					ACLAllUsageKeys(hSIDKey);

					fSuccess = true;
				}
				
				// after renaming the key, delete any delayed migration data stored under 
				// this key.
				::RegDeleteValueW(hSIDKey, szMigrateUserName);
				::RegDeleteValueW(hSIDKey, szMigrateUserDomain);

				::RegCloseKey(hSIDKey);
				hSIDKey = 0;
			}
			::LocalFree(szSID);
		}
	}

	if (pSID)
		delete[] pSID;

	return (fSuccess ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED);
}

///////////////////////////////////////////////////////////////////////
// Called once per migrated profile on NT. Move the UserData\<UserName>
// key to UserData\<UserSID>, sets all ACLs on moved keys.
LONG CALLBACK MigrateUserNT(HINF AnswerFileHandle, HKEY UserRegKey, LPCWSTR UserName, LPVOID Reserved, LPCWSTR wzWorkingDir, bool& g_fDeferredMigrationRequired)
{
	// open the Installer\UserData key
	HKEY hUserDataKey = 0;
	DWORD dwResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE, szUserDataKeyName, 0, KEY_ALL_ACCESS, &hUserDataKey);

	// if there is no UserData key, nothing to migrate for this user, but not an error.
	if ((ERROR_SUCCESS == dwResult) && hUserDataKey)
	{
		// check for Win9X HKCU to HKLM Migration Signal. This value is set when profiles are
		// disabled on Win9X. When set, it means that all HKCU registration is invalid and must
		// be deleted. 
		DWORD dwHKCUMigrateFlag = 0;
		DWORD cbData = sizeof(dwHKCUMigrateFlag);
		if (ERROR_SUCCESS != RegQueryValueExW(hUserDataKey, szMigrateWin9XToHKLM, NULL, NULL, reinterpret_cast<BYTE *>(&dwHKCUMigrateFlag), &cbData))
		{
			// confirm error (or a non-dword value) did not change flag
			dwHKCUMigrateFlag = 0;
		}

		// if profiles were not enabled for Win9X, HKCU information must be moved to HKCR
		if (dwHKCUMigrateFlag)
		{
			MovePerUserAppsToPerMachine(UserRegKey);
		}
		else
		{
			// if passed the NULL UserName, there's nothing to migrate.
			if (UserName == NULL)
			{
				RegCloseKey(hUserDataKey);
				hUserDataKey = 0;
				return ERROR_SUCCESS;
			}

			// split the username argument into its constituent parts (MultiSz format,
			// Win9XName\0Domain\0WinNTName)
			LPCWSTR szDomain = UserName+lstrlenW(UserName)+1;
			LPCWSTR szNewUserName = szDomain+lstrlenW(szDomain)+1;
			
			// open the source UserData\<UserName> key. The key name is always the original Win9X
			// UserName, even if the name will be different under NT.
			HKEY hUserKey = 0;
			dwResult = RegOpenKeyExW(hUserDataKey, UserName, 0, KEY_ALL_ACCESS, &hUserKey);
	
			// if there is no key, it simply means nothing to migrate for this user and is
			// not an error.
			if ((ERROR_SUCCESS == dwResult) && hUserKey)
			{
				// open the migration database for use in migrating all cached packages,
				// transforms, and patches. This must be done before renaming the key,
				// because the database was created under Win9X naming convention,
				// not SIDs.
				PMSIHANDLE hDatabase = 0;
	
				// the migration database will be <Temp Path>\migrate.msi
				WCHAR wzPackageFilename[MAX_PATH+13];
				lstrcpyW(wzPackageFilename, wzWorkingDir);
				int cchPath = lstrlenW(wzPackageFilename);
				if (wzPackageFilename[cchPath-1] != L'\\')
				{
					wzPackageFilename[cchPath] = L'\\';
					wzPackageFilename[cchPath+1] = L'\0';
				}
				lstrcatW(wzPackageFilename, L"migrate.msi");
	
				// open the migration database and migrate all cached package and transform
				// information to the new user
				if (ERROR_SUCCESS == MsiOpenDatabaseW(wzPackageFilename, MSIDBOPEN_TRANSACT, &hDatabase))
				{
					// migrate cached patches, packages, and transforms. Adds items to the cleanup 
					// table as necessary.
					MigrateCachedDataFromWin9X(hDatabase, UserRegKey, hUserKey, UserName);
				}
				::RegCloseKey(hUserKey);
				hUserKey = 0;
				
				// finally rename the user name to user SID. If this fails, write the new name and
				// domain to migration values under the existing key for future migration by the
				// WinLogon notification DLL.
				if (ERROR_SUCCESS != RenameUserKeyToSID(hUserDataKey, UserName, szDomain, szNewUserName))
				{
					// reopen the user key and write the "deferred migration" information
					if (ERROR_SUCCESS == RegOpenKeyExW(hUserDataKey, UserName, 0, KEY_ALL_ACCESS, &hUserKey))
					{
						// enable deferred migration (writes notification DLL registration during system
						// migration)
						g_fDeferredMigrationRequired = true;
	
						// set per-user deferred migration information. If this doesn't work for some reason,
						// the user is totally broken.
						RegSetValueExW(hUserKey, szMigrateUserName, 0, REG_SZ, reinterpret_cast<const BYTE*>(szNewUserName), (lstrlenW(szNewUserName)+1)*sizeof(WCHAR));
						RegSetValueExW(hUserKey, szMigrateUserDomain, 0, REG_SZ, reinterpret_cast<const BYTE*>(szDomain), (lstrlenW(szNewUserName)+1)*sizeof(WCHAR));
						RegCloseKey(hUserKey);
						hUserKey = 0;
					}
				}
			}
		}

		::RegCloseKey(hUserDataKey);
		hUserDataKey = 0;
	}

	// always return ERROR_SUCCESS, even on failure. The next user 
	// might have better luck.
	return ERROR_SUCCESS;
}

		   
///////////////////////////////////////////////////////////////////////
// Called once on NT to migrate system portion of MSI. Handles cached
// packages, patches, and transforms for per-machine installs. Also
// performs cleanup for all cached data (for all users) and registers
// the WinLogon notification DLL if a domain account needs to be 
// migrated at first boot/logon.
LONG CALLBACK MigrateSystemNT(HINF UnattendInfHandle, LPVOID Reserved, LPCWSTR wzWorkingDir, bool fDeferredMigrationRequired)
{
	// the migration database will be <Temp Path>\migrate.msi
	PMSIHANDLE hDatabase = 0;
	WCHAR wzPackageFilename[MAX_PATH+13];
	lstrcpyW(wzPackageFilename, wzWorkingDir);
	int cchPath = lstrlenW(wzPackageFilename);
	if (wzPackageFilename[cchPath-1] != L'\\')
	{
		wzPackageFilename[cchPath] = L'\\';
		wzPackageFilename[cchPath+1] = L'\0';
	}
	lstrcatW(wzPackageFilename, L"migrate.msi");

	// open the database in transact mode to read all product information and cleanup data.
	if (ERROR_SUCCESS == MsiOpenDatabaseW(wzPackageFilename, MSIDBOPEN_TRANSACT, &hDatabase))
	{			
		// for per-machine installs. 
		HKEY hUserDataKey = 0;
		DWORD dwResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE, szUserDataKeyName, 0, KEY_ALL_ACCESS, &hUserDataKey);

		// if there is no UserData key, nothing to migrate but not an error.
		if ((ERROR_SUCCESS == dwResult) && hUserDataKey)
		{
			// check for Win9X HKCU to HKLM Migration Signal. This value is set when profiles are
			// disabled on Win9X. When set, it means that all HKCU registration is invalid and must
			// be deleted. 
			DWORD dwHKCUMigrateFlag = 0;
			DWORD cbData = sizeof(dwHKCUMigrateFlag);
			if (ERROR_SUCCESS != RegQueryValueExW(hUserDataKey, szMigrateWin9XToHKLM, NULL, NULL, reinterpret_cast<BYTE *>(&dwHKCUMigrateFlag), &cbData))
			{
				// confirm error (or a non-dword value) did not change flag
				dwHKCUMigrateFlag = 0;
			}

			// if profiles were not enabled for Win9X, HKCU information must be moved to HKCR
			if (dwHKCUMigrateFlag)
			{
				// need to remove all installer information from the Default User hive
				// so new users won't have that information in their HKCU keys.
				WCHAR rgchProfileDir[MAX_PATH+12];
				DWORD cchProfileDir = MAX_PATH;
				if (GetDefaultUserProfileDirectoryW(rgchProfileDir, &cchProfileDir))
				{
					int cchPath = lstrlenW(rgchProfileDir);
					if (rgchProfileDir[cchPath-1] != L'\\')
					{
						rgchProfileDir[cchPath] = L'\\';
						rgchProfileDir[cchPath+1] = L'\0';
					}
					lstrcatW(rgchProfileDir, L"ntuser.dat");
				}

				// since we don't know what other processes (or things in this process) are
				// playing with registry hives, generate a temporary name to mount the Default
				// User hive
				const int cchHiveName = 15;
				int iRegLoopCount = 0;
				WCHAR rgchHiveName[cchHiveName+1] = L"";
				do 
				{
					// generate a temp name 
					for (int i=0; i < cchHiveName; i++)
						rgchHiveName[i] = L'A'+static_cast<WCHAR>(rand()%26);
					rgchHiveName[cchHiveName] = 0;

					// try to open the key to check for a preexisting key.
					HKEY hTestKey = 0;
					dwResult = RegOpenKeyEx(HKEY_USERS, rgchHiveName, 0, KEY_QUERY_VALUE, &hTestKey);
					if (ERROR_SUCCESS == dwResult && hTestKey)
					{
						RegCloseKey(hTestKey);
					}

					// avoid endless loop, stop after 1000 tries
					iRegLoopCount++;

				} while ((iRegLoopCount < 1000) && (ERROR_SUCCESS == dwResult));

				// unless we found an empty spot in the registry, don't delete the keys (this
				// is a nasty failure case).
				if (ERROR_FILE_NOT_FOUND == dwResult)
				{
					// mount the Default User hive.
					if (ERROR_SUCCESS == RegLoadKeyW(HKEY_USERS, rgchHiveName, rgchProfileDir))
					{
						HKEY hDefaultUserKey = 0;
						DWORD dwResult = RegOpenKeyExW(HKEY_USERS, rgchHiveName, 0, KEY_ALL_ACCESS, &hDefaultUserKey);
						if ((ERROR_SUCCESS == dwResult) && hDefaultUserKey)
						{
							// open the \Software\Microsoft subkey
							HKEY hMicrosoftKey = 0;
							dwResult = RegOpenKeyExW(hDefaultUserKey, szMicrosoftSubKeyName, 0, KEY_ALL_ACCESS, &hMicrosoftKey);
							if ((ERROR_SUCCESS == dwResult) && hMicrosoftKey)
							{
								// delete the \Installer subkey containing stale per-user configuration data
								SHDeleteKeyW(hMicrosoftKey, szInstallerSubKeyName);
	
								RegCloseKey(hMicrosoftKey);
								hMicrosoftKey = 0;
							}
	
							RegCloseKey(hDefaultUserKey);
							hDefaultUserKey = 0;
						}
	
						// unload the Default User hive
						RegUnLoadKeyW(HKEY_USERS, rgchHiveName);
					}				
				}
			}

			// remove the profile migration value stored under UserData. 
			::RegDeleteValueW(hUserDataKey, szMigrateWin9XToHKLM);
		
			// open the system userdata key to migrate packages, patches, and transforms 
			// for per-machine installs. 
			HKEY hMachineUserDataKey = 0;
			DWORD dwResult = RegOpenKeyExW(hUserDataKey, szSystemUserName, 0, KEY_ALL_ACCESS, &hMachineUserDataKey);
	
			// if there is no UserData key, nothing to migrate but not an error.
			if ((ERROR_SUCCESS == dwResult) && hMachineUserDataKey)
			{
	
				// migrate cached packages, patches, and transforms for per-machine installs
				MigrateCachedDataFromWin9X(hDatabase, 0, hMachineUserDataKey, szSystemUserName);
	
				// enumerate all products and ACL the Usage key for each one.
				// (Usage keys are not secure).
				ACLAllUsageKeys(hMachineUserDataKey);
	
				::RegCloseKey(hMachineUserDataKey);
				hMachineUserDataKey = 0;
			}

			::RegCloseKey(hUserDataKey);
			hUserDataKey = 0;
		}

		// use data in the migration database to determine the delta for each SharedDLLRefCount
		// value and apply those values to whats in the registry.
		UpdateSharedDLLRefCounts(hDatabase);

		// move anything that the Win9x side of migration decided needed to be moved. Generally this
		// is cached non-secure transforms and cached icons that need to be moved from the system
		// AppData to the Installer dir in non-profile scenarios.
		MoveAllExplicitlyMigratedCacheFiles(hDatabase);

		// on failure, there is no point in reverting back to the old data format because the 
		// new MSI doesn't comprehend it anyway. So always clean up as if we succeded (meaning
		// delete old transforms and so on.)
		CleanupOnSuccess(hDatabase);
	}

	////
	// copy and register the winlogon notification DLL if required
	if (fDeferredMigrationRequired)
	{
		// notification DLL is us, and lives in the migration directory.
		WCHAR wzCurrentFileName[MAX_PATH+14];
		WCHAR wzNewFileName[MAX_PATH+14];
		lstrcpyW(wzCurrentFileName, wzWorkingDir);
		cchPath = lstrlenW(wzCurrentFileName);
		if (wzCurrentFileName[cchPath-1] != L'\\')
		{
			wzCurrentFileName[cchPath] = L'\\';
			wzCurrentFileName[cchPath+1] = L'\0';
		}
		lstrcatW(wzCurrentFileName, L"msintmig.dll");
	
		// target is the system folder.
		if (GetSystemDirectoryW(wzNewFileName, MAX_PATH))
		{
			cchPath = lstrlenW(wzNewFileName);
			if (wzNewFileName[cchPath-1] != L'\\')
			{
				wzNewFileName[cchPath] = L'\\';
				wzNewFileName[cchPath+1] = L'\0';
			}
			lstrcatW(wzNewFileName, L"msintmig.dll");
			
			// copy the file into the system folder for use as a notification DLL
			if (CopyFileExW(wzCurrentFileName, wzNewFileName, NULL, NULL, FALSE, 0))
			{
				// registration for the notification DLL is under the Session Manager key.
				// Data to be written is stored in name/type/value tuples above.
				HKEY hNotifyKey = 0;
				if (ERROR_SUCCESS == RegCreateKeyExW(HKEY_LOCAL_MACHINE, szMSINotificationDLLKey, 0, L"", 0, KEY_ALL_ACCESS, NULL, &hNotifyKey, NULL) && hNotifyKey)
				{
					for (int i=0; i < cNotifyArgument; i++)
					{
						RegSetValueExW(hNotifyKey, rgNotifyArgument[i].szName, 0, rgNotifyArgument[i].dwType, 
							(rgNotifyArgument[i].dwType == REG_DWORD) ? reinterpret_cast<const BYTE*>(&rgNotifyArgument[i].dwData) : reinterpret_cast<const BYTE*>(rgNotifyArgument[i].wzData), 
							(rgNotifyArgument[i].dwType == REG_DWORD) ? sizeof(DWORD) : (lstrlenW(rgNotifyArgument[i].wzData)+1)*sizeof(WCHAR));
					}
					RegCloseKey(hNotifyKey);
					hNotifyKey = 0;
				}
			}
		}
	}
	return ERROR_SUCCESS;
}



///////////////////////////////////////////////////////////////////////
// removes the notification DLL registration and the DLL itself
// (after a reboot). 
void RemoveNotificationDLL()
{
	// open the notifcation DLL key (under Session Manager)
	HKEY hNotifyKey = 0;
	if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_LOCAL_MACHINE, szNotificationDLLKey, 0, KEY_ALL_ACCESS, &hNotifyKey) && hNotifyKey)
	{
		// delete the entire MsiNtMig key. The prevents future calls.
		DWORD dwResult = SHDeleteKeyW(hNotifyKey, L"MsiNtMig");
		RegCloseKey(hNotifyKey);
		hNotifyKey = 0;
	}
	
	// the migration notification DLL is guaranteed to be in use (because its us) so we mark it
	// to be deleted on reboot.
	WCHAR wzMigrationDLL[MAX_PATH+14];
	if (GetSystemDirectoryW(wzMigrationDLL, MAX_PATH))
	{
		DWORD cchPath = lstrlenW(wzMigrationDLL);
		if (wzMigrationDLL[cchPath-1] != L'\\')
		{
			wzMigrationDLL[cchPath] = L'\\';
			wzMigrationDLL[cchPath+1] = L'\0';
		}
		lstrcatW(wzMigrationDLL, L"msintmig.dll");

		// call MoveFileEx will NULL destination to signify a delete
		MoveFileExW(wzMigrationDLL, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
	}
}


///////////////////////////////////////////////////////////////////////
// enumerate all keys under "UserData" looking for migration 
// information. If found, rename the key and delete the migration
// info. Otherwise leave the key alone for future attempts.
void MigrateAllUserDataKeys()
{
	bool fRemoveNotify = true;

	// open the userdata key
	HKEY hUserDataKey = 0;
	DWORD dwResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE, szUserDataKeyName, 0, KEY_ALL_ACCESS, &hUserDataKey);

	// if there is no UserData key, nothing to migrate but not an error.
	if ((ERROR_SUCCESS != dwResult) || !hUserDataKey)
	{
		RemoveNotificationDLL();
		return;
	}

	// query the key to get the maximum subkey length
	DWORD cchMaxKeyLen = 0;
	DWORD cSubKeys = 0;
	if (ERROR_SUCCESS != RegQueryInfoKeyW(hUserDataKey, NULL, NULL, 0, 
										 &cSubKeys, &cchMaxKeyLen, NULL, NULL, NULL, 
										 NULL, NULL, NULL))
	{
		RegCloseKey(hUserDataKey);
		hUserDataKey = 0;
		return;
	}

	// allocate a buffer for the key names
	WCHAR *szUserSID = new WCHAR[++cchMaxKeyLen];
	if (!szUserSID)
	{
		RegCloseKey(hUserDataKey);
		hUserDataKey = 0;
		return;
	}

	// loop through all subkeys of the UserData key
	DWORD dwKeyIndex = 0;
	while (1)
	{
		// enumerate the next key in the list
		DWORD cchKeyName = cchMaxKeyLen;
		LONG lResult = RegEnumKeyExW(hUserDataKey, dwKeyIndex++, szUserSID, &cchKeyName, 0, NULL, NULL, NULL);
		if (lResult != ERROR_SUCCESS)
			break;
	
		// open the user key
		HKEY hUserKey = 0;
		if (ERROR_SUCCESS == (dwResult = RegOpenKeyExW(hUserDataKey, szUserSID, 0, KEY_QUERY_VALUE, &hUserKey)))
		{
			DWORD cbUserName = 20;

			// retrieve the migration username from the user key, resizing the buffer if necessary. 
			// If this doesn't exist, the key is already migrated.. 
			WCHAR *wzNewUserName = new WCHAR[cbUserName/sizeof(WCHAR)];
			if (!wzNewUserName)
			{
				RegCloseKey(hUserKey);
				hUserKey = 0;
				break;
			}

			DWORD dwResult = RegQueryValueExW(hUserKey, szMigrateUserName, 0, NULL, reinterpret_cast<unsigned char*>(wzNewUserName), &cbUserName);
			if (ERROR_MORE_DATA == dwResult)
			{
				delete[] wzNewUserName;
				cbUserName += sizeof(WCHAR);
				wzNewUserName = new WCHAR[cbUserName/sizeof(WCHAR)];
				if (!wzNewUserName)
				{
					RegCloseKey(hUserKey);
					hUserKey = 0;
					break;
				}
				dwResult = RegQueryValueExW(hUserKey, szMigrateUserName, 0, NULL, reinterpret_cast<unsigned char*>(wzNewUserName), &cbUserName);
			}
			if (ERROR_SUCCESS != dwResult)
			{
				RegCloseKey(hUserKey);
				hUserKey = 0;
				delete[] wzNewUserName;
				continue;
			}

			// query the domain value, resizing the buffer if necessary. If this doesn't exist
			// the key is already migrated. 
			WCHAR *wzNewUserDomain = new WCHAR[cbUserName/sizeof(WCHAR)];
			if (!wzNewUserDomain)
			{
				delete[] wzNewUserName;
				RegCloseKey(hUserKey);
				hUserKey = 0;
				break;
			}

			dwResult = RegQueryValueExW(hUserKey, szMigrateUserDomain, 0, NULL, reinterpret_cast<unsigned char*>(wzNewUserDomain), &cbUserName);
			if (ERROR_MORE_DATA == dwResult)
			{
				delete[] wzNewUserDomain;
				cbUserName += sizeof(WCHAR);
				wzNewUserDomain = new WCHAR[cbUserName/sizeof(WCHAR)];
				if (!wzNewUserDomain)
				{
					delete[] wzNewUserName;
					RegCloseKey(hUserKey);
					hUserKey = 0;
					break;
				}
				dwResult = RegQueryValueExW(hUserKey, szMigrateUserDomain, 0, NULL, reinterpret_cast<unsigned char*>(wzNewUserDomain), &cbUserName);
			}
			if (ERROR_SUCCESS != dwResult)
			{
				RegCloseKey(hUserKey);
				hUserKey = 0;
				delete[] wzNewUserName;
				delete[] wzNewUserDomain;
				continue;
			}

			RegCloseKey(hUserKey);
			hUserKey = 0;

			// copy the key from user name to user SID. If this fails, we can't remove the
			// notification DLL.
			if (ERROR_SUCCESS != RenameUserKeyToSID(hUserDataKey, szUserSID, wzNewUserDomain, wzNewUserName))
			{
				fRemoveNotify = false;
			}

			delete[] wzNewUserName;
			delete[] wzNewUserDomain;
		}
	}
	RegCloseKey(hUserDataKey);
	hUserDataKey = 0;

	if (szUserSID)
		delete[] szUserSID;

	// if either all keys are previously migrated or this call successfully migrated
	// all keys, remove the notification DLL so this code won't run on every boot
	// and/or logon.
	if (fRemoveNotify)
	{
		RemoveNotificationDLL();
	}
}



///////////////////////////////////////////////////////////////////////
// logon and startup notification functions. Handle final migration 
// steps that can't happen until after the system is fully set-up
void WINAPI LogonNotify(PWLX_NOTIFICATION_INFO pInfo)
{
	MigrateAllUserDataKeys();
	return;
}

void WINAPI StartupNotify(PWLX_NOTIFICATION_INFO pInfo)
{
	MigrateAllUserDataKeys();
	return;
}

// migration code needs a "debugprint" function and a Win9X variable
bool g_fWin9X = false;
void DebugOut(bool fDebugOut, LPCTSTR str, ...) {};

// all migration code is shared with msiregmv.
#include "..\..\msiregmv\migsecur.cpp"
#include "..\..\msiregmv\migutil.cpp"
#include "..\..\msiregmv\writecfg.cpp"
#include "..\..\msiregmv\patch.cpp"
#include "..\..\msiregmv\cleanup.cpp"
#include "..\..\msiregmv\readcnfg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msidb\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msicert\msicert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000-2001
//
//  File:       msicert.cpp
//
//--------------------------------------------------------------------------

// Required headers
#include <windows.h>
#include "msidefs.h"
#include "msiquery.h"
#include "msi.h"
#include "cmdparse.h"
#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>
#include "strsafe.h"

bool WriteDataToTempFile(TCHAR* szTempFile, BYTE* pbData, DWORD cbData)
{
	// open the temp file
	HANDLE hFile = CreateFile(szTempFile, GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		// open failed
		_tprintf(TEXT("<Error> Failed to open temp file '%s', LastError = %d\n"), szTempFile, GetLastError());
		return false;
	}

	// write out data to temporary file
	DWORD cchWritten = 0;
	if (0 == WriteFile(hFile, (void*)pbData, cbData, &cchWritten, NULL) || cchWritten != cbData)
	{
		// failed to write out data
		_tprintf(TEXT("<Error> Failed to write data to temp file '%s', LastError = %d\n"), szTempFile, GetLastError());
		return false;
	}

	// close temporary file
	CloseHandle(hFile);

	return true;
}

void DisplayHelp()
{
	_tprintf(TEXT("Copyright (c) Microsoft Corporation. All Rights Reserved\n"));
	_tprintf(TEXT("MsiCert will populate the MsiDigitalSignature and MsiDigitalCertificate tables\n"));
	_tprintf(TEXT("for a given Media entry and cabinet\n"));
	_tprintf(TEXT("\n\nSyntax: msicert -d {database} -m {media entry} -c {cabinet} [-H]\n"));
	_tprintf(TEXT("\t -d: the database to update\n"));
	_tprintf(TEXT("\t -m: the media entry in the Media table representing the cabinet\n"));
	_tprintf(TEXT("\t -c: the digitally signed cabinet\n"));
	_tprintf(TEXT("\t -h: (optional) include the hash of the digital signature\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("The default behavior is to populate the MsiDigitalSignature\n"));
	_tprintf(TEXT("and MsiDigitalCertificate tables with the signer certificate\n"));
	_tprintf(TEXT("information from the digitally signed cabinet.  The MsiDigitalSignature\n"));
	_tprintf(TEXT("and MsiDigitalCertificate tables will be created if necessary.\n"));
}


#define MSICERT_OPTION_HELP        '?'
#define MSICERT_OPTION_DATABASE    'd'
#define MSICERT_OPTION_MEDIA       'm'
#define MSICERT_OPTION_CABINET     'c'
#define MSICERT_OPTION_HASH        'h'

const sCmdOption rgCmdOptions[] =
{
	MSICERT_OPTION_HELP,      0,
	MSICERT_OPTION_DATABASE,  OPTION_REQUIRED|ARGUMENT_REQUIRED,
	MSICERT_OPTION_MEDIA,     OPTION_REQUIRED|ARGUMENT_REQUIRED,
	MSICERT_OPTION_CABINET,   OPTION_REQUIRED|ARGUMENT_REQUIRED,
	MSICERT_OPTION_HASH    ,  0,
	0,                        0
};

extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
	const TCHAR *szMsiPackage     = NULL;
	const TCHAR *szCabinetPath    = NULL;
	const TCHAR *szMediaEntry     = NULL;
	bool  bIncludeHashData  = false; // off by default
	int   iMediaEntry       = 0;

	CmdLineOptions cmdLine(rgCmdOptions);

	if(cmdLine.Initialize(argc, argv) == FALSE ||
		cmdLine.OptionPresent(MSICERT_OPTION_HELP))
	{
		DisplayHelp();
		return 1;
	}

	szMsiPackage = cmdLine.OptionArgument(MSICERT_OPTION_DATABASE);
	if(!szMsiPackage || !*szMsiPackage)
	{
		_tprintf(TEXT("Error:  No database specified.\n"));
		DisplayHelp();
		return 1;
	}

	szMediaEntry = cmdLine.OptionArgument(MSICERT_OPTION_MEDIA);
	if (!szMediaEntry || !*szMediaEntry)
	{
		_tprintf(TEXT("Error: No media entry specified.\n"));
		DisplayHelp();
		return 1;
	}
	iMediaEntry = _ttoi(szMediaEntry);
	if (iMediaEntry < 1)
	{
		_tprintf(TEXT("Error: Invalid media entry - %d. Entry must be greater than or equal to 1.\n"), iMediaEntry);
		DisplayHelp();
		return 1;
	}

	szCabinetPath = cmdLine.OptionArgument(MSICERT_OPTION_CABINET);
	if (!szCabinetPath || !*szCabinetPath)
	{
		_tprintf(TEXT("Error: No cabinet specified.\n"));
		DisplayHelp();
		return 1;
	}

	bIncludeHashData = cmdLine.OptionPresent(MSICERT_OPTION_HASH) ? true : false;

	//-----------------------------------------------------------------------------------------------
	// Now we have everything we need -- database, cabinet, and "authoring action"
	//-----------------------------------------------------------------------------------------------

	// open database for modification
	PMSIHANDLE hDatabase = 0;
	UINT uiRet = MsiOpenDatabase(szMsiPackage, MSIDBOPEN_TRANSACT, &hDatabase);
	if (ERROR_SUCCESS != uiRet)
	{
		// failed to open database
		_tprintf(TEXT("<Error> Failed to open database at '%s' for writing. Return Code = %d\n"), szMsiPackage, uiRet);
		return 1;
	}

	// verify cabinet is accessible
	HANDLE hFile = CreateFile(szCabinetPath, GENERIC_READ, FILE_SHARE_READ,	0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		_tprintf(TEXT("<Error> Unable to open cabinet '%s', LastError = %d\n"), szCabinetPath, GetLastError());
		return -1;
	}


	// check for presence of MsiDigitalSignature <table> and create if not there
	if (MSICONDITION_TRUE != MsiDatabaseIsTablePersistent(hDatabase, TEXT("MsiDigitalSignature")))
	{
		// create MsiDigitalSignature <table>
		PMSIHANDLE hViewDgtlSig = 0;
		if (ERROR_SUCCESS != (uiRet = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `MsiDigitalSignature` (`Table` CHAR(32) NOT NULL, `SignObject` CHAR(72) NOT NULL, `DigitalCertificate_` Char(72) NOT NULL, `Hash` OBJECT PRIMARY KEY `Table`, `SignObject`)"), &hViewDgtlSig))
			|| ERROR_SUCCESS != (uiRet = MsiViewExecute(hViewDgtlSig, 0)))
		{
			// failed to create MsiDigitalSignature <table>
			_tprintf(TEXT("<Error> Failed to create MsiDigitalSignature table, LastError = %d\n"), uiRet);
			return 1;
		}
	}

	// check for presence of MsiDigitalCertificate <table> and create if not there
	if (MSICONDITION_TRUE != MsiDatabaseIsTablePersistent(hDatabase, TEXT("MsiDigitalCertificate")))
	{
		// create MsiDigitalCertificate <table>
		PMSIHANDLE hViewDgtlCert = 0;
		if (ERROR_SUCCESS != (uiRet = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `MsiDigitalCertificate` (`DigitalCertificate` CHAR(72) NOT NULL, `CertData` OBJECT NOT NULL PRIMARY KEY `DigitalCertificate`)"), &hViewDgtlCert))
			|| ERROR_SUCCESS != (uiRet = MsiViewExecute(hViewDgtlCert, 0)))
		{
			// failed to create MsiDigitalCertificate <table>
			_tprintf(TEXT("<Error> Failed to create MsiDigitalCertificate table, LastError = %d\n"), uiRet);
			return 1;
		}
	}

	// check for presence of Media <table>
	if (MSICONDITION_TRUE != MsiDatabaseIsTablePersistent(hDatabase, TEXT("Media")))
	{
		// Media <table> is missing
		_tprintf(TEXT("<Error> Media table is missing from the database\n"));
		return 1;
	}

	// verify that the media entry is actually present in the Media table
	PMSIHANDLE hRecMediaExec = MsiCreateRecord(1);
	if (ERROR_SUCCESS != (uiRet = MsiRecordSetInteger(hRecMediaExec, 1, iMediaEntry)))
	{
		// unable to set up execution record
		_tprintf(TEXT("<Error> Failed to set up execution record for Media table, Last Error = %d\n"), uiRet);
		return 1;
	}
	PMSIHANDLE hViewMedia = 0;
	PMSIHANDLE hRecMedia  = 0;
	if (ERROR_SUCCESS != (uiRet = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `DiskId` FROM `Media` WHERE `DiskId`=? AND `Cabinet` IS NOT NULL"), &hViewMedia))
		|| ERROR_SUCCESS != (uiRet = MsiViewExecute(hViewMedia, hRecMediaExec))
		|| ERROR_SUCCESS != (uiRet = MsiViewFetch(hViewMedia, &hRecMedia)))
	{
		// unable to find Media table entry
		_tprintf(TEXT("<Error> Unable to find a Media table entry for a cabinet with DiskId = '%d', Last Error = %d\n"), iMediaEntry, uiRet);
		return 1;
	}

	//-----------------------------------------------------------------------------------------------
	// Now we have the database MsiDigital* table(s) set up and know our Media entry.  
	//  It's time to add in the data
	//-----------------------------------------------------------------------------------------------

	//
	// init variables
	//
	PCCERT_CONTEXT pCertContext = NULL;
	BYTE*          pbHash       = NULL;
	DWORD          cbHash       = 0;
	DWORD          dwFlags      = MSI_INVALID_HASH_IS_FATAL;

	if (bIncludeHashData)
	{
		pbHash = new BYTE[cbHash = 256];
		if (!pbHash)
		{
			// out of memory
			_tprintf(TEXT("<Error> Failed memory allocation\n"));
			return 1;
		}
	}

	HRESULT hr = MsiGetFileSignatureInformation(szCabinetPath, dwFlags, &pCertContext, pbHash, &cbHash);
	if (ERROR_MORE_DATA == HRESULT_CODE(hr))
	{
		// try again
		delete [] pbHash;
		pbHash = new BYTE[cbHash];
		if (!pbHash)
		{
			// out of memory
			_tprintf(TEXT("<Error> Failed memory allocation\n"));
			return 1;
		}
		hr = MsiGetFileSignatureInformation(szCabinetPath, dwFlags, &pCertContext, pbHash, &cbHash);
	}
	if (FAILED(hr))
	{
		// API error
		_tprintf(TEXT("MsiGetFileSignatureInformation failed with 0x%X\n"), hr);
		if (pbHash)
			delete [] pbHash;
		return 1;
	}

	// {cabinet} is validly signed, signature verified
	_tprintf(TEXT("<Info>: Cabinet '%s', is validly signed\n"), szCabinetPath);

	// initialize variables
	TCHAR *szTempFolder = NULL;
	TCHAR szCertKey[73];

	//
	// grab certificate and put it in the MsiDigitalCertificate <table>, saving the primary key name
	//

	//------------------------------------------------------------------------
	// MsiDigitalCertificate <table>
	//		+-----------------------+----------+-------+----------+
	//			Column					Type		Key		Nullable
	//		+-----------------------+----------+-------+----------+
	//			DigitalCertificate		s72			Y		N
	//			CertData				v0			N		N
	//	
	//------------------------------------------------------------------------
	const TCHAR sqlDigitalCertificate[] = TEXT("SELECT `DigitalCertificate`, `CertData` FROM `MsiDigitalCertificate`");
	PMSIHANDLE hViewDgtlCert = 0;
	PMSIHANDLE hRecDgtlCert  = MsiCreateRecord(2);
	if (ERROR_SUCCESS != (uiRet = MsiDatabaseOpenView(hDatabase, sqlDigitalCertificate, &hViewDgtlCert))
		|| ERROR_SUCCESS != (uiRet = MsiViewExecute(hViewDgtlCert, 0)))
	{
		_tprintf(TEXT("<Error> Unable to open view on MsiDigitalCertificate table, Return Code = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		return 1;
	}

	// determine max number of tries needed for figuring out a unique
	// primary key name for the cert.  This should be #entries in MsiDigitalCertificate plus 1
	unsigned int uiMaxTries = 0;
	unsigned int cRows = 0;
	PMSIHANDLE hViewCountCertRows = 0;
	PMSIHANDLE hRecCountCertRows = 0;
	if (ERROR_SUCCESS != (uiRet = MsiDatabaseOpenView(hDatabase, TEXT("SELECT 1 FROM `MsiDigitalCertificate`"), &hViewCountCertRows))
		|| ERROR_SUCCESS != (uiRet = MsiViewExecute(hViewCountCertRows, 0)))
	{
		_tprintf(TEXT("<Error> Unable to count the number of rows in the MsiDigitalCertificate table, return code = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		return 1;
	}
	while (ERROR_SUCCESS == (uiRet = MsiViewFetch(hViewCountCertRows, &hRecCountCertRows)))
		cRows++;
	if (ERROR_NO_MORE_ITEMS != uiRet)
	{
		_tprintf(TEXT("<Error> Unable to count the number of rows in the MsiDigitalCertificate table, return code = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		return 1;
	}

	// max tries = number of rows + 1
	uiMaxTries = cRows + 1;

	// FUTURE: add optimization option to try and reuse existing certificate if matches signer on cabinet

	// generate unique primary key for the cert name -- szCertKey
	static const TCHAR szCertKeyName[] = TEXT("Cert");

	int iSuffix = 0;
	PMSIHANDLE hViewFindCert = 0;
	PMSIHANDLE hRecFindCert = 0;
	PMSIHANDLE hRecFindExec = MsiCreateRecord(1);
	bool bFound = false;
	if (ERROR_SUCCESS != (uiRet = MsiDatabaseOpenView(hDatabase, TEXT("SELECT 1 FROM `MsiDigitalCertificate` WHERE `DigitalCertificate`=?"), &hViewFindCert)))
	{
		_tprintf(TEXT("<Error> Unable to open view on MsiDigitalCertificate table, Return Code = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		return 1;
	}

	for (unsigned int i = 0; i < uiMaxTries; i++, iSuffix++)
	{
		if (FAILED(StringCchPrintf(szCertKey, sizeof(szCertKey)/sizeof(szCertKey[0]), TEXT("%s%d"), szCertKeyName, iSuffix))
			|| ERROR_SUCCESS != MsiRecordSetString(hRecFindExec, 1, szCertKey)
			|| ERROR_SUCCESS != MsiViewExecute(hViewFindCert, hRecFindExec))
		{
			MsiViewClose(hViewFindCert);
			continue; // we'll fail below because bFound will be false
		}

		if (ERROR_NO_MORE_ITEMS == (uiRet = MsiViewFetch(hViewFindCert, &hRecFindCert)))
		{
			bFound = true;
			break; // found unique name
		}

		MsiViewClose(hViewFindCert);
	}

	if (!bFound)
	{
		_tprintf(TEXT("<Error> Unable to generate a unique key name for the certificate\n"));
		if (pbHash)
			delete [] pbHash;
		return 1;
	}

	// force closure
	MsiViewClose(hViewFindCert);
	hRecFindCert = 0;
	hRecFindExec = 0;
	hViewFindCert = 0;

	if (ERROR_SUCCESS != MsiRecordSetString(hRecDgtlCert, 1, szCertKey))
	{
		// unable to set up insertion record
		_tprintf(TEXT("<Error> Unable to set up insertion record for MsiDigitalSignature table, Return Code = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		return 1;
	}

	//
	// unfortunately, we can't write straight byte data into a record via the MSI API
	// therefore, we have to extract the encoded certificate data and write it out to a temp file
	// then use the temp file to get the data into the record
	//

	// certificate byte data is at psCertContext->pbCertEncoded (size = psCertContext->cbCertEncoded)
	DWORD cbCert = pCertContext->cbCertEncoded;

	// allocate memory to hold blob
	BYTE *pbCert = new BYTE[cbCert];
	if (!pbCert)
	{
		_tprintf(TEXT("<Error> Failed Memory Allocation\n"));
		if (pbHash)
			delete [] pbHash;
		return 1;
	}

	// copy encoded cert to byte array
	memcpy((void*)pbCert, pCertContext->pbCertEncoded, cbCert);

	// release cert context
	CertFreeCertificateContext(pCertContext);

	if (!szTempFolder)
	{
		// determine location of %TEMP% folder
		szTempFolder = new TCHAR[MAX_PATH];
		if (!szTempFolder)
		{
			_tprintf(TEXT("<Error> Failed Memory Allocation\n"));
			if (pbHash)
				delete [] pbHash;
			delete [] pbCert;
			return 1;
		}

		DWORD cchPath = GetTempPath(MAX_PATH, szTempFolder);
		if (0 == cchPath || cchPath > MAX_PATH)
		{
			// unable to get location of %TEMP% folder or buffer is too small
			_tprintf(TEXT("<Error> Unable to obtain location of TEMP folder, LastError = %d\n"), GetLastError());
			if (pbHash)
				delete [] pbHash;
			delete [] pbCert;
			delete [] szTempFolder;
			return 1;
		}
	}

	// get temporary file name and open handle
	TCHAR szCertTempFile[2*MAX_PATH];
	if (0 == GetTempFileName(szTempFolder, TEXT("crt"), 0, szCertTempFile))
	{
		// unable to create a temporary file
		_tprintf(TEXT("<Error> Unable to create a temp file, LastError = %d\n"), GetLastError());
		if (pbHash)
			delete [] pbHash;
		delete [] pbCert;
		delete [] szTempFolder;
		return 1;
	}

	if (!WriteDataToTempFile(szCertTempFile, pbCert, cbCert))
	{
		// unable to write data to temp file
		_tprintf(TEXT("<Error> Unable to write data to temp file\n"));
		if (pbHash)
			delete [] pbHash;
		delete [] pbCert;
		delete [] szTempFolder;
		DeleteFile(szCertTempFile);
		return 1;
	}

	// set encoded certificate data into record for insertion
	if (ERROR_SUCCESS != (uiRet = MsiRecordSetStream(hRecDgtlCert, 2, szCertTempFile)))
	{
		// failed to add cert data to record
		_tprintf(TEXT("<Error> Unable to add certificate data to insertion record, LastError = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		delete [] pbCert;
		delete [] szTempFolder;
		DeleteFile(szCertTempFile);
		return 1;
	}

	// insert record
	if (ERROR_SUCCESS != (uiRet = MsiViewModify(hViewDgtlCert, MSIMODIFY_INSERT, hRecDgtlCert)))
	{
		// insert failed
		_tprintf(TEXT("<Error> Insertion of certificate record into MsiDigitalCertificate table failed, LastError = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		delete [] pbCert;
		delete [] szTempFolder;
		DeleteFile(szCertTempFile);
		return 1;
	}

	// force close and release
	hRecDgtlCert = 0;
	MsiViewClose(hViewDgtlCert);
	hViewDgtlCert = 0;

	// delete temporary file
	if (!DeleteFile(szCertTempFile))
	{
		_tprintf(TEXT("<Error> Failed to delete temp file '%s', LastError = %d\n"), szCertTempFile, GetLastError());
		if (pbHash)
			delete [] pbHash;
		delete [] pbCert;
		delete [] szTempFolder;
		return 1;
	}


	//
	// MsiDigitalSignature table is authored in all cases; the options determine how much authoring is used
	//

	//------------------------------------------------------------------------
	// MsiDigitalSignature <table>
	//		+-----------------------+----------+-------+----------+
	//			Column					Type		Key		Nullable
	//		+-----------------------+----------+-------+----------+
	//			Table					s32			Y		N
	//			SignObject				s72			Y		N
	//			DigitalCertificate_		s72			N		N
	//			Hash					v0			N		Y
	//	
	//------------------------------------------------------------------------
	const TCHAR sqlDigitalSignature[] = TEXT("SELECT `Table`, `SignObject`, `DigitalCertificate_`, `Hash` FROM `MsiDigitalSignature`");
	PMSIHANDLE hViewDgtlSig = 0;
	PMSIHANDLE hRecDgtlSig  = MsiCreateRecord(4);
	TCHAR szHashTempFile[2*MAX_PATH];

	if (ERROR_SUCCESS != (uiRet = MsiDatabaseOpenView(hDatabase, sqlDigitalSignature, &hViewDgtlSig))
		|| ERROR_SUCCESS != (uiRet = MsiViewExecute(hViewDgtlSig, 0)))
	{
		// failed to create view on MsiDigitalSignature table
		_tprintf(TEXT("<Error> Failed to create view on MsiDigitalSignature table, LastError = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		delete [] pbCert;
		delete [] szTempFolder;
		return 1;
	}

	// only support for digital signatures is with cabinets, so Media table is only valid table
	if (ERROR_SUCCESS != (uiRet = MsiRecordSetString(hRecDgtlSig, 1, TEXT("Media"))))
	{
		_tprintf(TEXT("<Error> Failed to set up insertion record for MsiDigitalSignature table, LastError = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		delete [] pbCert;
		delete [] szTempFolder;
		return 1;
	}

	// put in the diskId (primary key to Media table)
	if (ERROR_SUCCESS != (uiRet = MsiRecordSetString(hRecDgtlSig, 2, szMediaEntry)))
	{
		_tprintf(TEXT("<Error> Failed to set up insertion record for MsiDigitalSignature table, LastError = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		delete [] pbCert;
		delete [] szTempFolder;
		return 1;
	}

	// see if this row already exists in the MsiDigitalSignature table, and if so, delete it
	PMSIHANDLE hViewDgtlMedia = 0;
	if (ERROR_SUCCESS != (uiRet = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `MsiDigitalSignature` WHERE `Table`=? AND `SignObject`=?"), &hViewDgtlMedia))
		|| ERROR_SUCCESS != (uiRet = MsiViewExecute(hViewDgtlMedia, hRecDgtlSig)))
	{
		_tprintf(TEXT("<Error> Failed to open verification view on MsiDigitalSignature table, LastErorr = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		delete [] pbCert;
		delete [] szTempFolder;
		return 1;
	}
	PMSIHANDLE hRecDgtlMedia = 0;
	if (ERROR_SUCCESS != (uiRet = MsiViewFetch(hViewDgtlMedia, &hRecDgtlMedia)))
	{
		if (ERROR_NO_MORE_ITEMS != uiRet)
		{
			_tprintf(TEXT("<Error> Fetch failed, LastError = %d\n"), uiRet);
			if (pbHash)
				delete [] pbHash;
			delete [] pbCert;
			delete [] szTempFolder;
			return 1;
		}
		// else no entry exists for this record
	}
	else
	{
		// delete this entry
		if (ERROR_SUCCESS != (uiRet = MsiViewModify(hViewDgtlMedia, MSIMODIFY_DELETE, hRecDgtlMedia)))
		{
			_tprintf(TEXT("<Error> Failed to Delete Row Record, LastError = %d\n"), uiRet);
			if (pbHash)
				delete [] pbHash;
			delete [] pbCert;
			delete [] szTempFolder;
			return 1;
		}

		// FUTURE: we could also clean-up the MsiDigitalCertificate table here as well
	}

	// force closure
	MsiViewClose(hViewDgtlMedia);
	hRecDgtlMedia = 0;
	hViewDgtlMedia = 0;

	// add link to MsiDigitalCertificate table
	if (ERROR_SUCCESS != (uiRet = MsiRecordSetString(hRecDgtlSig, 3, szCertKey)))
	{
		_tprintf(TEXT("<Error> Failed to set up insertion record for MsiDigitalSignature table, LastError = %d\n"), uiRet);
		if (pbHash)
			delete [] pbHash;
		delete [] pbCert;
		delete [] szTempFolder;
		return 1;
	}

	if (bIncludeHashData)
	{
		// add hash information

		// get temporary file name and open handle
		if (0 == GetTempFileName(szTempFolder, TEXT("hsh"), 0, szHashTempFile))
		{
			// unable to create a temporary file
			_tprintf(TEXT("<Error> Unable to create a temp file, LastError = %d\n"), GetLastError());
			delete [] pbHash;
			delete [] pbCert;
			delete [] szTempFolder;
			return 1;
		}

		if (!WriteDataToTempFile(szHashTempFile, pbHash, cbHash))
		{
			// unable to write to temp file
			_tprintf(TEXT("<Error> Unable to write to temp file\n"));
			delete [] pbHash;
			delete [] pbCert;
			delete [] szTempFolder;
			DeleteFile(szHashTempFile);
			return 1;
		}

		// set hash data into record for insertion
		if (ERROR_SUCCESS != MsiRecordSetStream(hRecDgtlSig, 4, szHashTempFile))
		{
			// failed to add cert data to record
			_tprintf(TEXT("<Error> Unable to add hash data to insertion record, LastError = %d\n"), uiRet);
			delete [] pbHash;
			delete [] pbCert;
			delete [] szTempFolder;
			DeleteFile(szHashTempFile);
			return 1;
		}
	} // if (bIncludeHashData)

	// insert record
	if (ERROR_SUCCESS != MsiViewModify(hViewDgtlSig, MSIMODIFY_INSERT, hRecDgtlSig))
	{
		// insert failed
		_tprintf(TEXT("<Error> Insertion of signature record into MsiDigitalSignature table failed, LastError = %d\n"), uiRet);
		if (pbHash)
		{
			delete [] pbHash;
			DeleteFile(szHashTempFile);
		}
		delete [] pbCert;
		delete [] szTempFolder;
		return 1;
	}

	// force close and release
	hRecDgtlSig = 0;
	MsiViewClose(hViewDgtlSig);
	hViewDgtlSig = 0;

	delete [] pbCert;
	delete [] szTempFolder;

	// cleanup hash stuff
	if (bIncludeHashData)
	{
		if (pbHash)
			delete [] pbHash;

		if (!DeleteFile(szHashTempFile))
		{
			_tprintf(TEXT("<Error> Failed to delete temp file '%s', LastError = %d\n"), szHashTempFile, GetLastError());
			return 1;
		}
	}

	// commit database
	if (ERROR_SUCCESS != (uiRet = MsiDatabaseCommit(hDatabase)))
	{
		_tprintf(TEXT("<Error> Failed to commit database, LastError = %d\n"), uiRet);
		return 1;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msifiler\make.inc ===
#
# Copy files from cmdparse
#

$(O)\cmdparse.h    : ..\..\cmdparse\cmdparse.h
    copy $? $@

$(O)\cmdparse.cpp  : ..\..\cmdparse\cmdparse.cpp
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msidb\sources.inc ===
TARGETNAME=msidb
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=windows
UMENTRY=$(MSI_WINENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\OLE32.lib \
        $(SDK_LIB_PATH)\comdlg32.lib \
	$(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1
USE_NATIVE_EH=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR);$(BUILD_COMMONDIR)

SOURCES=..\msidb.cpp \
	..\msidb.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msidb\msidb.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msidb.h
//
//--------------------------------------------------------------------------

#include <windows.h>

#define IDS_MissingData       16
#define IDS_TooManyMergeDb    17
#define IDS_TooManyImports    50
#define IDS_TooManyStorages   51
#define IDS_TooManyTransforms 18
#define IDS_TooManyKills      52
#define IDS_TooManyExtracts   53
#define IDS_TooManyTables     19
#define IDS_MissingMode       20
#define IDS_MissingDatabase   21
#define IDS_MissingTables     22
#define IDS_MissingFolder     23
#define IDS_NoDatabase        24
#define IDS_OpenDatabase      25
#define IDS_DatabaseOpenView  26
#define IDS_ViewExecute       27
#define IDS_ViewFetch         28
#define IDS_RecordGetString   29
#define IDS_DatabaseImport    30
#define IDS_DatabaseTransform 31
#define IDS_DatabaseExport    32
#define IDS_DatabaseCommit    33
#define IDS_FileReadOnly      34
#define IDS_UnknownOption     35
#define IDS_UnknownTable      36
#define IDS_DbCreateError     37
#define IDS_IsTablePersistent 38
#define IDS_RecordSetString   39
#define IDS_RecordSetStream   40
#define IDS_ViewInsert        41
#define IDS_RecordReadStream  42
#define IDS_ViewDelete		  43
#define IDS_StorageInsertFail 44
#define IDS_StreamInsertFail  45
#define IDS_ReadOnly		  46
#define IDS_MAX               99

#define IDD_HELP              10
#define IDD_SELECT            11
#define IDD_FOLDER            12

#define IDC_STATUS            70
#define IDC_DATABASE          65
#define IDC_FOLDER            66
#define IDC_TABLES            67
#define IDC_IMPORT            68
#define IDC_EXPORT            69
#define IDC_SELECTALL         61
#define IDC_DBBROWSE          62
#define IDC_DIRBROWSE         63

#define IDC_NOUI              666	// used for modes that cannot have UI
					// NOTE: does not specify a control

#define IDI_MAIN              1
#define IDB_EMPTY             1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msidb\msidb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msidb.cpp
//
//--------------------------------------------------------------------------

#include "msidb.h"
#include <objbase.h>
#include <stdio.h>   // printf/wprintf
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include <commdlg.h>
#include "MsiQuery.h"


const TCHAR szSummaryInfoTableName[] = TEXT("_SummaryInformation");  // name recognized by Import()

const int MaxCmdLineTables = 20;  // maximum number of table names on command line
const int MaxMergeDatabases = 10;
const int MAXIMPORTS = 10;
const int MAXSTORAGES = 10;
const int MaxTransforms = 10;
const int MAXKILLS = 10;
const int MAXEXTRACTS = 10;
const int iStreamBufSize = 4096;

#ifdef UNICODE  // compiler multiplies by charsize when adding to pointer
#define MSIDBOPEN_RAWSTREAMNAMES 8
#else
#define MSIDBOPEN_RAWSTREAMNAMES 16
#endif

enum dbtypeEnum
{
    dbtypeExisting,
    dbtypeCreate,
    dbtypeCreateOld,
    dbtypeMerge,
};

//____________________________________________________________________________
//
// Error handling facility using local exception object
//____________________________________________________________________________

struct CLocalError {   // local exception object for this program
    CLocalError(const TCHAR* szTitle, const TCHAR* szMessage)
        : Title(szTitle),    Message(szMessage) {}
    const TCHAR* Title;
    const TCHAR* Message;
    void Display(HINSTANCE hInst, HANDLE hStdOut);
};

void CLocalError::Display(HINSTANCE hInst, HANDLE hStdOut)
{
    TCHAR szMsgBuf[80];
    const TCHAR** pszMsg;
    if (*(pszMsg = &Message) <= (const TCHAR*)IDS_MAX
     || *(pszMsg = &Title)   <= (const TCHAR*)IDS_MAX)
    {
        ::LoadString(hInst, *(unsigned*)pszMsg, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR));
        *pszMsg = szMsgBuf;
    }
    if (hStdOut)  // output redirected, suppress UI (unless output error)
    {
        TCHAR szOutBuf[160];
        int cbOut = _stprintf(szOutBuf, TEXT("%s: %s\n"), Title, Message);
        // _stprintf returns char count, WriteFile wants byte count
        DWORD cbWritten;
        if (WriteFile(hStdOut, szOutBuf, cbOut*sizeof(TCHAR), &cbWritten, 0))
            return;
    }
    ::MessageBox(0, Message, Title, MB_OK);
}

static void Error(const TCHAR* szTitle, const TCHAR* szMessage)
{
    throw CLocalError(szTitle,szMessage);
}

static inline void ErrorIf(int fError, const TCHAR* szTitle, int iResId)
{
    if (fError)
    Error(szTitle, (TCHAR*)IntToPtr(iResId));
}
static inline void ErrorIf(int fError, int iResId, const TCHAR* szMessage)
{
    if (fError)
    Error((TCHAR*)IntToPtr(iResId), szMessage);
}
static inline void ErrorIf(int fError, const TCHAR* szTitle, const TCHAR* szMessage)
{
    if (fError)
    Error(szTitle,szMessage);
}


//____________________________________________________________________________
//
// Class to manage dialog window
//____________________________________________________________________________

INT_PTR CALLBACK
SelectProc(HWND hDlg, unsigned int msg, WPARAM wParam, LPARAM lParam);

class CTableWindow
{
 public:
    CTableWindow(HINSTANCE hInst);
  ~CTableWindow();
    BOOL SetDatabase(TCHAR* szDatabase, UINT_PTR iMode, dbtypeEnum dbtype);
    BOOL MergeDatabase();
    void AddImport(LPCTSTR szImport);
    void AddStorage(LPCTSTR szStorage);
    void TransformDatabase(TCHAR* szTransform);
    void KillStream(LPCTSTR szItem);
    void KillStorage(LPCTSTR szItem);
    void ExtractStream(LPCTSTR szExtract);
    void ExtractStorage(LPCTSTR szExtract);
    BOOL SetFolder(TCHAR* szFolder);
    UINT_PTR SelectTables(UINT_PTR iMode, TCHAR** rgszTables, int cTables);
    BOOL FillTables();
    BOOL FillFiles();
    void TransferTables();
    BOOL IsInteractive() {return m_fInteractive;}
    void SetTruncate(BOOL fTruncate) {m_fTruncate = fTruncate;}
    BOOL GetTruncate() {return m_fTruncate;}
 protected:
    void CloseDatabase();  // commit
    void CheckMsi(UINT iStat, const TCHAR* szTitle, int iResId); // throws error
    void CheckMsiRecord(UINT iStat, const TCHAR* szTitle, int iResId); // throws error
private:
    HINSTANCE     m_hInst;
    PMSIHANDLE    m_hDatabase;
    PMSIHANDLE    m_hDatabaseMerge;
    BOOL          m_fDbError;
    HWND          m_hWnd;
    BOOL          m_fVisible;
    BOOL          m_fInteractive;
    BOOL          m_fDbReadOnly;
    BOOL          m_fTruncate;
    UINT_PTR      m_idcMode;
    TCHAR         m_szDatabase[MAX_PATH];
    TCHAR         m_szFolder[MAX_PATH];
    TCHAR**       m_rgszCmdTables;
    int           m_cCmdTables;
    int           m_nSelected;
    int*          m_rgiSelected;
   friend INT_PTR CALLBACK SelectProc(HWND, unsigned int msg, WPARAM wParam, LPARAM lParam);
};

#define WM_USERSTAT (WM_USER + 95)

CTableWindow::CTableWindow(HINSTANCE hInst)
    : m_hWnd(0), m_hInst(hInst), m_fVisible(FALSE), m_fInteractive(FALSE), m_fDbReadOnly(FALSE),
      m_idcMode(0), m_rgiSelected(0), m_hDatabase(0), m_hDatabaseMerge(0), m_cCmdTables(0), m_fTruncate(0)
{
    m_szFolder[0] = 0;
    m_szDatabase[0] = 0;
    m_hWnd = ::CreateDialogParam(m_hInst, MAKEINTRESOURCE(IDD_SELECT), 0,
                                                SelectProc, (LPARAM)this);
    ErrorIf(!m_hWnd, TEXT("Could not create table window"), TEXT("Temp for debug"));
}

CTableWindow::~CTableWindow()
{
    if (m_hWnd)
    {
        ::DestroyWindow(m_hWnd);
//      MSG msg;
//      while (::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
//          ::DispatchMessage(&msg);
    }
    if (m_rgiSelected)
        delete [] m_rgiSelected;
    m_rgiSelected = 0;
    CloseDatabase();
}

void CTableWindow::CheckMsi(UINT iStat, const TCHAR* szTitle, int iResId)
{
    if (iStat != ERROR_SUCCESS)
    {
        m_fDbError = TRUE;
        Error(szTitle, (TCHAR*)IntToPtr(iResId));
    }
}

void CTableWindow::CheckMsiRecord(UINT iError, const TCHAR* szTitle, int iResId)
{
    if (iError != ERROR_SUCCESS)
    {
        m_fDbError = TRUE;
        PMSIHANDLE hError = MsiGetLastErrorRecord();
        if (hError)
        {
            if (MsiRecordIsNull(hError, 0))
                MsiRecordSetString(hError, 0, TEXT("Error [1]: [2]{, [3]}{, [4]}{, [5]}"));
            TCHAR rgchBuf[1024];
            DWORD cchBuf = sizeof(rgchBuf)/sizeof(TCHAR);
            MsiFormatRecord(0, hError, rgchBuf, &cchBuf);
            Error(szTitle, rgchBuf);
        }
        else
            Error(szTitle, (TCHAR*)IntToPtr(iResId));
    }
}

void CTableWindow::CloseDatabase()
{
    // if there are no errors and there is a database handle
    if (!m_fDbError && m_hDatabase)
    {
        // commit and close
        CheckMsiRecord(MsiDatabaseCommit(m_hDatabase), m_szDatabase, IDS_DatabaseCommit);
    }
    m_hDatabase = NULL;
}

BOOL CTableWindow::SetDatabase(TCHAR* szDatabase, UINT_PTR iMode, dbtypeEnum dbtype)
{
    if (!szDatabase && dbtype != dbtypeMerge)
    {
		// With Windows 2000, the OPENFILENAME structure increased size to include some
		// additional members.  However, this causes problems for applications on previous
		// operating systems (i.e. downlevel).  This means we must set the IStructSize member
		// to OPENFILENAME_SIZE_VERSION_400 to guarantee that we can run on down-level systems
		// otherwise the call to GetOpenFileName returns error 120 (ERROR_CALL_NOT_IMPLEMENTED)
        OPENFILENAME ofn = { OPENFILENAME_SIZE_VERSION_400 , m_hWnd, m_hInst,
                                    TEXT("InstallerDatabase(*.MSI)\0*.MSI\0"),0,0,0,
                                    m_szDatabase, sizeof(m_szDatabase)/sizeof(TCHAR), 0, 0, 0,
                                    TEXT("MsiTable - Select Database for Import/Export"),
                                    OFN_HIDEREADONLY,
                                    0,0,0,0,0,0 };
        if(!::GetOpenFileName(&ofn))
            return FALSE;
        m_fInteractive = TRUE;
        //!! should we set the fCreate to TRUE if user entered a file name that didn't exist?
    }
    else if (dbtype == dbtypeMerge && !szDatabase)
        ErrorIf(szDatabase  == 0 || *szDatabase == 0, szDatabase, IDS_NoDatabase);
    else
        _tcscpy(m_szDatabase, szDatabase);

    LPCTSTR szPersist;
    if (dbtype == dbtypeCreate)
        szPersist = MSIDBOPEN_CREATE;
    else if (dbtype == dbtypeCreateOld)
        szPersist = MSIDBOPEN_CREATE + MSIDBOPEN_RAWSTREAMNAMES;
    else if (dbtype == dbtypeMerge)
        szPersist = MSIDBOPEN_READONLY;
    else if (iMode == IDC_EXPORT)
        szPersist = MSIDBOPEN_READONLY;
    else
        szPersist = MSIDBOPEN_TRANSACT;

    int cbDatabase = _tcsclen(m_szDatabase);
    TCHAR* pch;
    TCHAR szExtension[3+1];
    for (pch = m_szDatabase + cbDatabase; pch != m_szDatabase && *pch != TEXT('.'); pch--)
        ;
    int cbExtension = 0;
    if (pch != m_szDatabase) // possible file extension present
    {
        TCHAR ch;
        while (cbExtension < 4)
        {
            ch = *(++pch);
            if (ch >= TEXT('A') && ch <= TEXT('Z'))
                ch += (TEXT('a') - TEXT('A'));
            if (ch < TEXT('a') || ch > TEXT('z'))
                break;
            szExtension[cbExtension++] = ch;
        }
    }
    if (cbExtension == 3)  // 3 character extension
    {
        szExtension[3] = 0;
        if (_tcscmp(szExtension, TEXT("mdb")) == 0 && (dbtype == dbtypeCreate || dbtype == dbtypeCreateOld))
        {
            // Create new Access database
            szPersist = MSIDBOPEN_TRANSACT;
            int fAttributes = ::GetFileAttributes(m_szDatabase);
            if (fAttributes == -1)  // file does not exist
            {
                HRSRC   hResInfo;
                HGLOBAL hResData;
                TCHAR*   rgbDatabase;
                DWORD   cbWrite;
                HANDLE  hFile;
                ErrorIf((hResInfo = ::FindResource(m_hInst, MAKEINTRESOURCE(IDB_EMPTY),RT_RCDATA))==0
                      || (hResData = ::LoadResource(m_hInst, hResInfo))==0
                      || (rgbDatabase = (TCHAR*)::LockResource(hResData))==0
                      || (cbWrite = ::SizeofResource(m_hInst, hResInfo))==0
                      || INVALID_HANDLE_VALUE == (hFile = ::CreateFile(m_szDatabase, GENERIC_WRITE,
                                                    0, 0, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0))
                      || ::WriteFile(hFile, rgbDatabase, cbWrite, &cbWrite, 0)==0
                      || ::CloseHandle(hFile)==0, m_szDatabase, IDS_DbCreateError);
                // ::FreeResource(hResData);  // needed for Win95(?)
            }
            else if (fAttributes & FILE_ATTRIBUTE_READONLY)
                    szPersist = MSIDBOPEN_READONLY;
        }
    }
    ::SetDlgItemText(m_hWnd, IDC_DATABASE, m_szDatabase);

    pch = m_szDatabase;
    TCHAR szBuffer[MAX_PATH];
    if (*(++pch) != TEXT(':') && (*pch != TEXT('\\') || *(--pch) != TEXT('\\')) )
    {
        TCHAR szDirectory[MAX_PATH];
        ::GetCurrentDirectory(MAX_PATH, szDirectory);
        _stprintf(szBuffer, TEXT("%s\\%s"), szDirectory, m_szDatabase);
        _tcscpy(m_szDatabase, szBuffer);
    }
    if (dbtype == dbtypeMerge)
    {
        // open merge database read only.
        if (MsiOpenDatabase(m_szDatabase, MSIDBOPEN_READONLY, &m_hDatabaseMerge) != ERROR_SUCCESS)
        {
            m_fDbError = TRUE;
            Error(m_szDatabase, TEXT("Failed to open database"));
        }
    }
    else
    {
        CloseDatabase();  // close any previously opened database
        if (MsiOpenDatabase(m_szDatabase, szPersist, &m_hDatabase) != ERROR_SUCCESS)
        {
            // failed at direct, attempt read-only open (probably read-only database)
            if (MsiOpenDatabase(m_szDatabase, MSIDBOPEN_READONLY, &m_hDatabase) != ERROR_SUCCESS)
            {
                m_fDbError = TRUE;
                Error(m_szDatabase, TEXT("Failed to open database"));
            }
            m_fDbReadOnly = TRUE;
        }
    }
    m_fDbError = FALSE;
    return TRUE;
}

BOOL CTableWindow::MergeDatabase()
{
    if (m_fDbReadOnly) // can't merge into read-only
        Error( m_szDatabase, (TCHAR *)IDS_ReadOnly);

    return MsiDatabaseMerge(m_hDatabase, m_hDatabaseMerge, TEXT("_MergeErrors")) == ERROR_SUCCESS ? TRUE : FALSE;
}

///////////////////////////////////////////////////////////
// AddImport
// Pre: m_szDatabase must be specified
//      szImport is a valid file
// Pos: szImport is added to database as a stream
void CTableWindow::AddImport(LPCTSTR szImport)
{
    // find base name of import file
    const TCHAR* pch = szImport + lstrlen(szImport) - 1;
    TCHAR szBaseName[MAX_PATH];
    TCHAR* pchBaseName = szBaseName;
    while ( *pch != '\\' && (pch != szImport) )
        pch--;
    if ( *pch == '\\' )
        pch++;
    while ( *pch != 0 )
        *pchBaseName++ = *pch++;
    *pchBaseName = 0;

    // if base name is too large bail
    if (lstrlen(szBaseName) > 62)
        Error(TEXT("Error Adding Import File"), TEXT("File name too long to be stream name."));

    if (m_fDbReadOnly) // can't import into read-only
        Error( m_szDatabase, (TCHAR *)IDS_ReadOnly);

    PMSIHANDLE hQuery;
    CheckMsiRecord(::MsiDatabaseOpenView(m_hDatabase, TEXT("SELECT * FROM `_Streams`"), &hQuery), m_szDatabase, IDS_DatabaseOpenView);
    CheckMsiRecord(::MsiViewExecute(hQuery, 0), m_szDatabase, IDS_ViewExecute);
    PMSIHANDLE hNewRec = ::MsiCreateRecord(2);
    CheckMsi(::MsiRecordSetString(hNewRec, 1, szBaseName), szBaseName, IDS_RecordSetString);
    CheckMsi(::MsiRecordSetStream(hNewRec, 2, szImport), szImport, IDS_RecordSetStream);
    CheckMsiRecord(::MsiViewModify(hQuery, MSIMODIFY_INSERT, hNewRec), szImport, IDS_StreamInsertFail);
    ::MsiViewClose(hQuery);
}



///////////////////////////////////////////////////////////
// AddStorage
// Pre: m_szDatabase must be specified
//      szStorage is a valid file
// Pos: szStorage is added to database as a sub-storage
void CTableWindow::AddStorage(LPCTSTR szStorage)
{
    // find base name of import file
    const TCHAR* pch = szStorage + lstrlen(szStorage) - 1;
    TCHAR szBaseName[MAX_PATH];
    TCHAR* pchBaseName = szBaseName;
    while ( *pch != '\\' && (pch != szStorage) )
        pch--;
    if ( *pch == '\\' )
        pch++;
    while ( *pch != 0 )
        *pchBaseName++ = *pch++;
    *pchBaseName = 0;

    // if base name is too large bail
    if (lstrlen(szBaseName) > 62)
        Error(TEXT("Error Adding Import File"), TEXT("File name too long to be Storage name."));

    if (m_fDbReadOnly) // can't import into read-only
        Error( m_szDatabase, (TCHAR *)IDS_ReadOnly);

    PMSIHANDLE hQuery;
    CheckMsiRecord(::MsiDatabaseOpenView(m_hDatabase, TEXT("SELECT * FROM `_Storages`"), &hQuery), m_szDatabase, IDS_DatabaseOpenView);
    CheckMsiRecord(::MsiViewExecute(hQuery, 0), m_szDatabase, IDS_ViewExecute);
    PMSIHANDLE hNewRec = ::MsiCreateRecord(2);
    CheckMsi(::MsiRecordSetString(hNewRec, 1, szBaseName), szBaseName, IDS_RecordSetString);
    CheckMsi(::MsiRecordSetStream(hNewRec, 2, szStorage), szStorage, IDS_RecordSetStream);
    CheckMsiRecord(::MsiViewModify(hQuery, MSIMODIFY_INSERT, hNewRec), szBaseName, IDS_StorageInsertFail);
    ::MsiViewClose(hQuery);

}   // end of AddStorage


void CTableWindow::TransformDatabase(TCHAR* szTransform)
{
    CheckMsiRecord(MsiDatabaseApplyTransform(m_hDatabase, szTransform, 0), szTransform, IDS_DatabaseTransform);
}

///////////////////////////////////////////////////////////
// KillStream
// Pre: database is open
//      szItem is a valid item in databasae
// Pos: szItem is removed from database
// NOTE: This function will close the database if it is already open
void CTableWindow::KillStream(LPCTSTR szItem)
{
    static TCHAR szError[256];        // error string

    // if item name is too large bail
    if (lstrlen(szItem) > 62)
        Error(TEXT("Error Killing File"), TEXT("Kill filename is too long to be stream."));

    if (m_fDbReadOnly) // can't kill read-only
        Error( m_szDatabase, (TCHAR *)IDS_ReadOnly);

    PMSIHANDLE hQuery;
    PMSIHANDLE hSearch = ::MsiCreateRecord(1);
    PMSIHANDLE hResult;
    CheckMsi(::MsiRecordSetString(hSearch, 1, szItem), szItem, IDS_RecordSetString);

    // check stream
    CheckMsiRecord(::MsiDatabaseOpenView(m_hDatabase, TEXT("SELECT * FROM `_Streams` WHERE `Name`=?"), &hQuery), m_szDatabase, IDS_DatabaseOpenView);
    CheckMsiRecord(::MsiViewExecute(hQuery, hSearch), m_szDatabase, IDS_ViewExecute);
    if (ERROR_NO_MORE_ITEMS == ::MsiViewFetch(hQuery, &hResult)) {
        Error(TEXT("Error Killing File"), TEXT("Kill stream not found."));
        return;
    }

    CheckMsiRecord(::MsiViewModify(hQuery, MSIMODIFY_DELETE, hResult), szItem, IDS_ViewDelete);
    ::MsiViewClose(hQuery);
}   // end of KillItem

///////////////////////////////////////////////////////////
// KillStorage
// Pre: database is open
//      szItem is a valid storage in databasae
// Pos: szItem is removed from database
void CTableWindow::KillStorage(LPCTSTR szItem)
{
    static TCHAR szError[256];        // error string

    // if item name is too large bail
    if (lstrlen(szItem) > 62)
        Error(TEXT("Error Killing File"), TEXT("Kill filename is too long to be storage."));

    if (m_fDbReadOnly) // can't kill in read-only
        Error( m_szDatabase, (TCHAR *)IDS_ReadOnly);

    PMSIHANDLE hQuery;
    PMSIHANDLE hSearch = ::MsiCreateRecord(1);
    PMSIHANDLE hResult;
    CheckMsi(::MsiRecordSetString(hSearch, 1, szItem), szItem, IDS_RecordSetString);

    // check storage
    CheckMsiRecord(::MsiDatabaseOpenView(m_hDatabase, TEXT("SELECT * FROM `_Storages` WHERE `Name`=?"), &hQuery), m_szDatabase, IDS_DatabaseOpenView);
    CheckMsiRecord(::MsiViewExecute(hQuery, hSearch), m_szDatabase, IDS_ViewExecute);

    // not a storage
    if (ERROR_NO_MORE_ITEMS == ::MsiViewFetch(hQuery, &hResult))
    {
        Error(TEXT("Error Killing File"), TEXT("Kill filename not found."));
        return;
    }

    CheckMsiRecord(::MsiViewModify(hQuery, MSIMODIFY_DELETE, hResult), szItem, IDS_ViewDelete);
    ::MsiViewClose(hQuery);
}   // end of KillItem

///////////////////////////////////////////////////////////
// ExtractStorage
// Pre: m_szDatabase must be specified
//      szItem is a storage in database
// Pos: szItem is created on local harddrive
// NOTE: This function will close the database if it is already open
void CTableWindow::ExtractStorage(LPCTSTR szExtract)
{
    static TCHAR szError[256];        // error string

    // if the database is open close it
    if(m_hDatabase)
        CloseDatabase();

    ::CoInitialize(NULL);           // initialize COM junk

    // if extract is too large bail
    if (lstrlen(szExtract) > 31)
        Error(TEXT("Error Extracting File"), TEXT("File name too long for OLE Storage function."));

    // storage interface
    IStorage* piStorage;

    // convert the database path into a wide string
    const OLECHAR* szwPath;
#ifndef UNICODE
    OLECHAR rgPathBuf[MAX_PATH];
    int cchWide = ::MultiByteToWideChar(CP_ACP, 0, m_szDatabase, -1, rgPathBuf, MAX_PATH);
    szwPath = rgPathBuf;
#else   // UNICODE
    szwPath = m_szDatabase;
#endif

    // try to open database as a storage
    if (::StgOpenStorage(szwPath, (IStorage*)0, STGM_READ | STGM_SHARE_EXCLUSIVE, (SNB)0, (DWORD)0, &piStorage) != NOERROR)
    {
        _stprintf(szError, TEXT("Could not open %s as a storage file."), m_szDatabase);
        Error(TEXT("Error Extracting File"), szError);
    }

    // convert extract name to unicode
    const OLECHAR* szwExtract;
#ifndef UNICODE
    cchWide = ::MultiByteToWideChar(CP_ACP, 0, (LPCTSTR)szExtract, -1, rgPathBuf, MAX_PATH);
    szwExtract = rgPathBuf;
#else   // UNICODE
    szwExtract = szExtract;
#endif

    // try to open sub storage
    IStorage* piSubStorage;
    if (FAILED(piStorage->OpenStorage(szwExtract, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE, NULL, 0, &piSubStorage)))
    {
        // if the database storage is open release it
        if (piStorage)
            piStorage->Release();

        Error(TEXT("Error Adding StorageFile"), TEXT("Could not find sub-storage in database."));
    }

    // try to create the extract file (will not overwrite files)
    IStorage* piExtract;
    if (FAILED(StgCreateDocfile(szwExtract, STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE | STGM_WRITE, 0, &piExtract)))
    {
        // if the storage is open release it
        if (piStorage)
            piStorage->Release();

        // if the stream is open release it
        if (piSubStorage)
            piSubStorage->Release();

        _stprintf(szError, TEXT("Could not create a new export file: %s - Error: %d\n  Remove any existing files before attempting to export."), szExtract, ::GetLastError());
        Error(TEXT("Error Extracting File"), szError);
    }

    // copy the storage to the new file
    if (FAILED(piSubStorage->CopyTo(NULL, NULL, NULL, piExtract)))
            Error(TEXT("Error Extracting File"), szError);

    // release all storages and storage
    piExtract->Release();
    piSubStorage->Release();
    piStorage->Release();

    // release the COM junk
    ::CoUninitialize();
}   // end of ExtractStorage

///////////////////////////////////////////////////////////
// ExtractStream
// Pre: m_szDatabase must be specified
//      szItem is a stream in database
// Pos: szItem is created on local harddrive
void CTableWindow::ExtractStream(LPCTSTR szExtract)
{
    // if base name is too large bail
    if (lstrlen(szExtract) > 62)
        Error(TEXT("Error Adding Import File"), TEXT("File name too long to be stream name."));

    // get stream
    PMSIHANDLE hQuery;
    PMSIHANDLE hSearch = ::MsiCreateRecord(1);
    PMSIHANDLE hResult;
    CheckMsi(::MsiRecordSetString(hSearch, 1, szExtract), szExtract, IDS_RecordSetString);
    CheckMsiRecord(::MsiDatabaseOpenView(m_hDatabase, TEXT("SELECT * FROM `_Streams` WHERE `Name`=?"), &hQuery), m_szDatabase, IDS_DatabaseOpenView);
    CheckMsiRecord(::MsiViewExecute(hQuery, hSearch), m_szDatabase, IDS_ViewExecute);
    if (ERROR_NO_MORE_ITEMS == ::MsiViewFetch(hQuery, &hResult))
    {
        Error(TEXT("Error Exporting File"), TEXT("Stream not found in database."));
        return;
    }

    // try to create extract file (will not overwrite files)
    HANDLE hExtract = INVALID_HANDLE_VALUE;
    hExtract = ::CreateFile(szExtract, GENERIC_WRITE, 0, (LPSECURITY_ATTRIBUTES)0,
                            CREATE_NEW, FILE_ATTRIBUTE_NORMAL, (HANDLE)0 );

    // if failed to create file
    if (hExtract == INVALID_HANDLE_VALUE)
    {
        TCHAR szError[1024];
        _stprintf(szError, TEXT("Could not create a new export file: %s - Error: %d\n  Remove any existing files before attempting to export."), szExtract, ::GetLastError());
        Error(TEXT("Error Extracting File"), szError);
    }

    // copy from the stream to disk.
    char buffer[4096];
    unsigned long cBytes = 4096;
    unsigned long cbWritten = 0;
    CheckMsi(MsiRecordReadStream(hResult, 2, buffer, &cBytes), szExtract, IDS_RecordReadStream);
    while (cBytes) {
        if (!::WriteFile(hExtract, buffer, cBytes, &cbWritten, (LPOVERLAPPED)0))
        {
            ::CloseHandle(hExtract);
            Error(TEXT("Error Extracting File"), TEXT("Error writing to file on disk."));
        }
        cBytes = 4096;
        CheckMsi(MsiRecordReadStream(hResult, 2, buffer, &cBytes), szExtract, IDS_RecordReadStream);
    }

}   // end of ExtractStream


BOOL CTableWindow::SetFolder(TCHAR* szFolder)
{
    if (!szFolder)
    {
        m_szFolder[0] = TEXT('1');  // set dummy file name for common dialog
        m_szFolder[1] = 0;
		// With Windows 2000, the OPENFILENAME structure increased size to include some
		// additional members.  However, this causes problems for applications on previous
		// operating systems (i.e. downlevel).  This means we must set the IStructSize member
		// to OPENFILENAME_SIZE_VERSION_400 to guarantee that we can run on down-level systems
		// otherwise the call to GetOpenFileName returns error 120 (ERROR_CALL_NOT_IMPLEMENTED)
        OPENFILENAME ofn = { OPENFILENAME_SIZE_VERSION_400, m_hWnd, m_hInst,
                                    0,0,0,0,
                                    m_szFolder, sizeof(m_szFolder)/sizeof(TCHAR), 0, 0, 0,
                                    TEXT("MsiTable - Select Folder containing Text Files"),
                                    OFN_ENABLETEMPLATE | OFN_HIDEREADONLY | OFN_NOTESTFILECREATE,
                                    0,0,0,0,0, MAKEINTRESOURCE(IDD_FOLDER) };
        if (!::GetSaveFileName(&ofn))
            return FALSE;
        *(m_szFolder + _tcsclen(m_szFolder) - 2) = 0;  // remove dummy filename
        m_fInteractive = TRUE;
    }
    else
        _tcscpy(m_szFolder, szFolder);
    ::SetDlgItemText(m_hWnd, IDC_FOLDER, m_szFolder);
    return TRUE;
}

UINT_PTR CTableWindow::SelectTables(UINT_PTR iMode, TCHAR** rgszTables, int cTables)
{
    m_cCmdTables    = cTables;
    m_rgszCmdTables = rgszTables;
    if (iMode == -1)
        iMode = m_idcMode;
    else
        m_idcMode = iMode;
    if (iMode == 0 || cTables == 0)
        m_fInteractive = TRUE;

    if (m_fInteractive)
    {
        ::EnableWindow(m_hWnd, TRUE);
        ::ShowWindow(m_hWnd, SW_SHOW);
        MSG msg;
        while (::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
            ::IsDialogMessage(m_hWnd, &msg);
    }
    switch (iMode)
    {
    case IDC_EXPORT:
        if (FillTables())
            ::SendDlgItemMessage(m_hWnd, IDC_EXPORT, BM_SETCHECK, 1, 0);
        break;
    case IDC_IMPORT:
        if (FillFiles())
            ::SendDlgItemMessage(m_hWnd, IDC_IMPORT, BM_SETCHECK, 1, 0);
        if (m_fDbReadOnly)
            ::EnableWindow(::GetDlgItem(m_hWnd, IDOK), FALSE);
        break;
    default:
        ::SendDlgItemMessage(m_hWnd, IDC_IMPORT, BM_SETCHECK, 0, 0);
        ::SendDlgItemMessage(m_hWnd, IDC_EXPORT, BM_SETCHECK, 0, 0);
        ::EnableWindow(::GetDlgItem(m_hWnd, IDOK), FALSE);
    }

    UINT_PTR stat;
    if (m_fInteractive)
    {
        stat = 0;
        MSG msg;
        while ( !stat && ::GetMessage(&msg, 0, 0, 0))
        {
            if (msg.message == WM_USERSTAT)
                stat = msg.wParam;
            else
                ::IsDialogMessage(m_hWnd, &msg);
        }
    }
    else
        stat = IDOK;

    if (m_rgiSelected)  // check if previously selected
        delete [] m_rgiSelected;
    m_rgiSelected = 0;
    m_nSelected = (int)::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_GETSELCOUNT, 0, 0);
    if (m_nSelected)
    {
        m_rgiSelected = new int[m_nSelected];
        ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_GETSELITEMS,
                                        m_nSelected, (LPARAM)m_rgiSelected);
    }
    return stat;
}

BOOL CTableWindow::FillTables()
{
    PMSIHANDLE hView;
    PMSIHANDLE hRecord;
    TCHAR szTableName[32];
    DWORD cchDataBuf = sizeof(szTableName)/sizeof(TCHAR);
   ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_RESETCONTENT, 0, 0);

    BOOL fODBC = FALSE;
    CheckMsiRecord(MsiDatabaseOpenView(m_hDatabase, TEXT("SELECT `Name` FROM _Tables"), &hView), m_szDatabase, IDS_DatabaseOpenView);
    CheckMsiRecord(MsiViewExecute(hView, 0), m_szDatabase, IDS_ViewExecute);
#if 0 // OLD ODBC
    if (MsiViewExecute(hView, 0) != ERROR_SUCCESS)
    {
        // odbc database
        CheckMsiRecord(MsiDatabaseOpenView(m_hDatabase, TEXT("%t"), &hView), m_szDatabase, IDS_DatabaseOpenView);
        CheckMsiRecord(MsiViewExecute(hView, 0), m_szDatabase, IDS_ViewExecute);
        fODBC = TRUE;
    }
#endif
    for (int cTables = 0; ;cTables++)
    {
        UINT uiRet = MsiViewFetch(hView, &hRecord);
        if (uiRet == ERROR_NO_MORE_ITEMS)
            break;
        CheckMsi(uiRet, m_szDatabase, IDS_ViewFetch);
        if (!hRecord)
            break;
#if 0 // OLD ODBC
        if (fODBC)
            CheckMsi(MsiRecordGetString(hRecord, 3, szTableName, &cchDataBuf), m_szDatabase, IDS_RecordGetString);
        else
#endif
            CheckMsi(MsiRecordGetString(hRecord, 1, szTableName, &cchDataBuf), m_szDatabase, IDS_RecordGetString);
        cchDataBuf = sizeof(szTableName)/sizeof(TCHAR); // reset
        MSICONDITION ice = MsiDatabaseIsTablePersistent(m_hDatabase, szTableName);
        if (ice == MSICONDITION_FALSE || _tcscmp(szTableName, TEXT("_Overflow")) == 0)
            continue;
        CheckMsi(ice != MSICONDITION_TRUE, m_szDatabase, IDS_IsTablePersistent);
        ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_ADDSTRING,
                                    0, (LPARAM)szTableName);
    }
    PMSIHANDLE hSummaryInfo;
    if (MsiGetSummaryInformation(m_hDatabase, 0, 0, &hSummaryInfo) == ERROR_SUCCESS)
    {
        ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_ADDSTRING,
                                        0, (LPARAM)szSummaryInfoTableName);
        cTables++;
    }
    if (!cTables)
    {
        ::EnableWindow(::GetDlgItem(m_hWnd, IDOK), FALSE);
        return FALSE;
    }

    for (int iTable = 0; iTable < m_cCmdTables; iTable++)
    {
        TCHAR* szTable = m_rgszCmdTables[iTable];
        LONG_PTR iList;
        if (_tcscmp(szTable, TEXT("*"))==0)
            iList = -1; // Select all tables
        else
        {
            iList = ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_FINDSTRING,
                                                    0, (LPARAM)szTable);
            if (iList == LB_ERR)
                ErrorIf(!m_fInteractive, IDS_UnknownTable, szTable);
        }
        SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_SETSEL, 1, iList);
    }
    return TRUE;
}

BOOL CTableWindow::FillFiles()
{
    TCHAR szTemp[MAX_PATH];
    _tcscpy(szTemp, m_szFolder);
    _tcscat(szTemp, TEXT("\\*.idt"));
   ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_RESETCONTENT, 0, 0);
    WIN32_FIND_DATA ffd;
    HANDLE hFindFile;
    if ((hFindFile = ::FindFirstFile(szTemp, &ffd)) == INVALID_HANDLE_VALUE)
    {
        ::EnableWindow(::GetDlgItem(m_hWnd, IDOK), FALSE);
        return FALSE;
    }
    do
    {
        if (ffd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            _tcscat(ffd.cFileName, TEXT("\t (R/O)"));
        ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_ADDSTRING,
                                    0, (LPARAM)ffd.cFileName);
    } while (::FindNextFile(hFindFile, &ffd));

    for (int iTable = 0; iTable < m_cCmdTables; iTable++)
    {
        _tcscpy(szTemp, m_szFolder);
        TCHAR* pchTemp = szTemp + _tcsclen(szTemp);
        *pchTemp++ = TEXT('\\');
        TCHAR* pchFile = pchTemp;  // save start of file name
        for (TCHAR* pchTable = m_rgszCmdTables[iTable]; *pchTable != 0 && *pchTable != (TCHAR)'.'; )
            *pchTemp++ = *pchTable++;
        if (*pchTable != (TCHAR)'.')    // check if table name rather than file name
        {
            if (pchTemp > pchFile + 8)  // truncate to 8.3 file name
                 pchTemp = pchFile + 8;
            pchTable = TEXT(".idt");
        }
        _tcscpy(pchTemp, pchTable);
        WIN32_FIND_DATA ffd;
        HANDLE hFindFile;
        if ((hFindFile = ::FindFirstFile(szTemp, &ffd)) == INVALID_HANDLE_VALUE)
        {
            ErrorIf(!m_fInteractive, IDS_UnknownTable, szTemp);
            continue;
        }
        do
        {
            LONG_PTR iList = ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_FINDSTRING,
                                                        0, (LPARAM)ffd.cFileName);
            if (iList != LB_ERR)
                ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_SETSEL, 1, iList);
            else
                ErrorIf(!m_fInteractive, IDS_UnknownTable, ffd.cFileName);
        } while (::FindNextFile(hFindFile, &ffd));
    }
   return TRUE;
}

void CTableWindow::TransferTables()
{
    MSG msg;
    TCHAR szTable[80];
    if (m_idcMode == 0)
        throw IDABORT;  // should never happen
    ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_SETSEL, 0, -1);
    for (int iSelected = 0; iSelected < m_nSelected; iSelected++)
    {
        int iListBox;
//      if (m_fInteractive)
//      {
        iListBox = m_rgiSelected[iSelected];
        ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_SETCARETINDEX, iListBox, 0);
        ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_SETSEL, 1, iListBox);
        while (::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
            ::IsDialogMessage(m_hWnd, &msg);
          ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_GETTEXT, iListBox, (LPARAM)szTable);
//      }

        if (m_idcMode == IDC_EXPORT)
        {
            TCHAR szFileName[80+4];
            _tcscpy(szFileName, szTable);
            int cch = _tcslen(szFileName);
            if (m_fTruncate && cch > 8)
                cch = 8;
            _tcscpy(szFileName + cch, TEXT(".idt"));
            TCHAR szFullPath[MAX_PATH];
            _stprintf(szFullPath, TEXT("%s%c%s"), m_szFolder, TEXT('\\'), szFileName);
            int fAttributes = ::GetFileAttributes(szFullPath);
            ErrorIf(fAttributes != -1 && (fAttributes & FILE_ATTRIBUTE_READONLY), szFileName, IDS_FileReadOnly);
            CheckMsiRecord(MsiDatabaseExport(m_hDatabase, szTable, m_szFolder, szFileName), szTable, IDS_DatabaseExport);
        }
        else // IDC_IMPORT
        {
            if (m_fDbReadOnly) // can't import into read-only
                Error( m_szDatabase, (TCHAR *)IDS_ReadOnly);
            for (TCHAR* pch = szTable; *pch; pch++)  // remove possible "(R/O)"
                if (*pch == TEXT('\t'))
                    *pch = 0;
            CheckMsiRecord(MsiDatabaseImport(m_hDatabase, m_szFolder, szTable), szTable, IDS_DatabaseImport);
        }
        if (m_fInteractive)
        {
            ::SendDlgItemMessage(m_hWnd, IDC_TABLES, LB_SETSEL, 0, iListBox);
//      DWORD dwProcessId;
//      while (!::GetFocus() ||
//              ::GetWindowThreadProcessId(::GetFocus(),&dwProcessId) != ::GetCurrentThreadId())
            if (::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
                ::IsDialogMessage(m_hWnd, &msg);
        }
    }
}

INT_PTR CALLBACK
HelpProc(HWND hDlg, unsigned int msg, WPARAM /*wParam*/, LPARAM /*lParam*/)
{
  if (msg != WM_COMMAND)
    return (msg == WM_INITDIALOG) ? TRUE : FALSE;
  ::EndDialog(hDlg, TRUE);
  return TRUE;
}

INT_PTR CALLBACK
SelectProc(HWND hDlg, unsigned int msg, WPARAM wParam, LPARAM lParam)
{
    static CTableWindow* This;
    if (msg == WM_INITDIALOG)
    {
        This = (CTableWindow*)lParam;
        int tabs = 70;
        ::SendDlgItemMessage(hDlg, IDC_TABLES, LB_SETTABSTOPS, 1, (LPARAM)&tabs);
        return TRUE;
    }
    else if (msg == WM_COMMAND)
    {
        BOOL fFillOk;
        switch (wParam)
        {
        case IDOK:
        case IDCANCEL:
            ::PostMessage(hDlg, WM_USERSTAT, wParam, 0);
            return TRUE;
        case IDC_SELECTALL:
            ::SendDlgItemMessage(hDlg, IDC_TABLES, LB_SETSEL, 1, -1);
            return TRUE;
        case IDC_IMPORT:
            fFillOk = This->FillFiles();
            break;
        case IDC_EXPORT:
            fFillOk = This->FillTables();
            break;
        case IDC_DBBROWSE:
            if (!This->SetDatabase(0, IDC_IMPORT, dbtypeExisting))
                return TRUE;
            if (This->m_idcMode != IDC_EXPORT)
                return TRUE;
            fFillOk = This->FillTables();
            wParam = IDC_EXPORT;
            break;
        case IDC_DIRBROWSE:
            if (!This->SetFolder(0))
                return TRUE;
            if (This->m_idcMode != IDC_IMPORT)
                return TRUE;
            fFillOk = This->FillFiles();
            wParam = IDC_IMPORT;
            break;
        default:
            return FALSE;
        }
        if (fFillOk)
        {
            ::EnableWindow(::GetDlgItem(hDlg, IDOK), !(wParam==IDC_IMPORT && This->m_fDbReadOnly));
            This->m_idcMode = wParam;
            return FALSE;
        }
        else
        {
            ::EnableWindow(::GetDlgItem(hDlg, IDOK), FALSE);
            ::SendDlgItemMessage(This->m_hWnd, (int) wParam, BM_SETCHECK, 0, 0);
            This->m_idcMode = 0;
            return TRUE;
        }
    }
    else if (msg == WM_CLOSE)
    {
        ::PostMessage(hDlg, WM_USERSTAT, IDABORT, 0);
    }
    return FALSE;
}


//______________________________________________________________________________________________
//
// RemoveQuotes function to strip surrounding quotation marks
//     "c:\temp\my files\testdb.msi" becomes c:\temp\my files\testdb.msi
//______________________________________________________________________________________________

void RemoveQuotes(const TCHAR* szOriginal, TCHAR sz[MAX_PATH])
{
    const TCHAR* pch = szOriginal;
    if (*pch == TEXT('"'))
        pch++;
    int iLen = _tcsclen(pch);
    for (int i = 0; i < iLen; i++, pch++)
        sz[i] = *pch;

    pch = szOriginal;
    if (*(pch + iLen) == TEXT('"'))
            sz[iLen-1] = TEXT('\0');
}

//_____________________________________________________________________________________________________
//
// WinMain and command line parsing functions
//_____________________________________________________________________________________________________

TCHAR SkipWhiteSpace(TCHAR*& rpch)
{
    TCHAR ch;
    for (; (ch = *rpch) == TEXT(' ') || ch == TEXT('\t'); rpch++)
        ;
    return ch;
}

BOOL SkipValue(TCHAR*& rpch)
{
	TCHAR ch = *rpch;
	if (ch == 0 || ch == TEXT('/') || ch == TEXT('-'))
		return FALSE;   // no value present

	TCHAR *pchSwitchInUnbalancedQuotes = NULL;

	for (; (ch = *rpch) != TEXT(' ') && ch != TEXT('\t') && ch != 0; rpch++)
	{       
		if (*rpch == TEXT('"'))
		{
			rpch++; // for '"'

			for (; (ch = *rpch) != TEXT('"') && ch != 0; rpch++)
			{
				if ((ch == TEXT('/') || ch == TEXT('-')) && (NULL == pchSwitchInUnbalancedQuotes))
				{
					pchSwitchInUnbalancedQuotes = rpch;
				}
			}
                    ;
            ch = *(++rpch);
            break;
		}
	}
	if (ch != 0)
	{
		*rpch++ = 0;
	}
	else
	{
		if (pchSwitchInUnbalancedQuotes)
			rpch=pchSwitchInUnbalancedQuotes;
	}
	return TRUE;
}

extern "C" int __stdcall _tWinMain(HINSTANCE hInst, HINSTANCE/*hPrev*/, TCHAR* szCmdLine, int/*show*/)
{
    UINT_PTR stat = 0;
    HANDLE hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
    if (hStdOut == INVALID_HANDLE_VALUE || ::GetFileType(hStdOut) == 0)
        hStdOut = 0;  // non-zero if stdout redirected or piped

    try
    {
        // Parse command line
        TCHAR* szDatabase = 0;
        TCHAR* szFolder = 0;
        TCHAR szDb[MAX_PATH];
        memset(szDb, 0, MAX_PATH);
        TCHAR szDirectory[MAX_PATH];
        memset(szDirectory, 0, MAX_PATH);
        TCHAR* rgszMergeDatabases[MaxMergeDatabases];
        TCHAR* rgszImports[MAXIMPORTS];
        TCHAR* rgszStorages[MAXSTORAGES];
        TCHAR* rgszTransforms[MaxTransforms];
        TCHAR* rgszKillStreams[MAXKILLS];
        TCHAR* rgszKillStorages[MAXKILLS];
        TCHAR* rgszExtractStorages[MAXEXTRACTS];
        TCHAR* rgszExtractStreams[MAXEXTRACTS];
        TCHAR* rgszCmdLineTables[MaxCmdLineTables];
        int nMergeDatabases = 0;
        int nImports = 0;
        int nStorages = 0;
        int nTransforms = 0;
        int nKillStreams = 0;
        int nKillStorages = 0;
        int nExtractStreams = 0;
        int nExtractStorages = 0;
        int nCmdLineTables = 0;
        UINT_PTR iMode = 0;
        int i;
        dbtypeEnum dbtype = dbtypeExisting;
        BOOL fTruncate = FALSE;
        TCHAR chCmdNext;
        TCHAR* pchCmdLine = szCmdLine;
        SkipValue(pchCmdLine);   // skip over module name
        while ((chCmdNext = SkipWhiteSpace(pchCmdLine)) != 0)
        {
            if (chCmdNext == TEXT('/') || chCmdNext == TEXT('-'))
            {
                TCHAR szBuffer[MAX_PATH] = {0};
                TCHAR* szCmdOption = pchCmdLine++;  // save for error msg
                TCHAR chOption = (TCHAR)(*pchCmdLine++ | 0x20);
                chCmdNext = SkipWhiteSpace(pchCmdLine);
                TCHAR* szCmdData = pchCmdLine;  // save start of data
                switch(chOption)
                {
                case TEXT('s'):
                    fTruncate = TRUE;
                    break;
                case TEXT('i'):
                    iMode = IDC_IMPORT;     // overrides NOUI if specified
                    break;
                case TEXT('c'):
                    iMode = IDC_IMPORT;     // overrides NOUI if specified
                    dbtype = dbtypeCreate;
                    break;
                case TEXT('o'):
                    iMode = IDC_IMPORT;     // overrides NOUI if specified
                    dbtype = dbtypeCreateOld;
                    break;
                case TEXT('e'):
                    iMode = IDC_EXPORT;     // overrides NOUI if specified
                    break;
                case TEXT('d'):
                    if (!SkipValue(pchCmdLine))
                        Error((TCHAR*)IDS_MissingData, szCmdOption);
                    szDatabase = szCmdData;
                    break;
                case TEXT('f'):
                    if (!SkipValue(pchCmdLine))
                        Error((TCHAR*)IDS_MissingData, szCmdOption);
                    szFolder = szCmdData;
                    break;
                case TEXT('m'):
                    // if there is no mode specified yet
                    if(!iMode)
                        iMode = IDC_NOUI;   // set it to no UI because we can't have a UI when merging

                    if (!SkipValue(pchCmdLine))
                        Error((TCHAR*)IDS_MissingData, szCmdOption);
                    ErrorIf(nMergeDatabases == MaxMergeDatabases, szCmdData, IDS_TooManyMergeDb);
                    RemoveQuotes(szCmdData, szBuffer);
                    _tcscpy(szCmdData, szBuffer);
                    rgszMergeDatabases[nMergeDatabases++] = szCmdData;
                    break;
                case TEXT('a'):                 // add import file flag
                    // if there is no mode specified yet
                    if(!iMode)
                        iMode = IDC_NOUI;   // set it to no UI because we can't have a UI when adding files

                    if (!SkipValue(pchCmdLine))
                        Error((TCHAR*)IDS_MissingData, szCmdOption);
                    ErrorIf(nImports == MAXIMPORTS, szCmdData, IDS_TooManyImports);
                    RemoveQuotes(szCmdData, szBuffer);
                    _tcscpy(szCmdData, szBuffer);
                    rgszImports[nImports++] = szCmdData;
                    break;
                case TEXT('r'):                 // add storage file flag
                    // if there is no mode specified yet
                    if(!iMode)
                        iMode = IDC_NOUI;   // set it to no UI because we can't have a UI when adding storages

                    if (!SkipValue(pchCmdLine))
                        Error((TCHAR*)IDS_MissingData, szCmdOption);
                    ErrorIf(nStorages == MAXSTORAGES, szCmdData, IDS_TooManyStorages);
                    RemoveQuotes(szCmdData, szBuffer);
                    _tcscpy(szCmdData, szBuffer);
                    rgszStorages[nStorages++] = szCmdData;
                    break;
                case TEXT('t'):
                    // if there is no mode specified yet
                    if(!iMode)
                        iMode = IDC_NOUI;   // set it to no UI because we can't have a UI when applying transforms

                    if (!SkipValue(pchCmdLine))
                        Error((TCHAR*)IDS_MissingData, szCmdOption);
                    ErrorIf(nTransforms == MaxTransforms, szCmdData, IDS_TooManyTransforms);
                    RemoveQuotes(szCmdData, szBuffer);
                    _tcscpy(szCmdData, szBuffer);
                    rgszTransforms[nTransforms++] = szCmdData;
                    break;
                case TEXT('k'):                     // kill streams in the databse
                    // if there is no mode specified yet
                    if(!iMode)
                        iMode = IDC_NOUI;   // set it to no UI because we can't have a UI when doing kills

                    if (!SkipValue(pchCmdLine))
                        Error((TCHAR*)IDS_MissingData, szCmdOption);
                    ErrorIf(nKillStreams == MAXKILLS, szCmdData, IDS_TooManyKills);
                    RemoveQuotes(szCmdData, szBuffer);
                    _tcscpy(szCmdData, szBuffer);
                    rgszKillStreams[nKillStreams++] = szCmdData;
                    break;
                case TEXT('j'):                     // kill storage in the databse
                    // if there is no mode specified yet
                    if(!iMode)
                        iMode = IDC_NOUI;   // set it to no UI because we can't have a UI when doing kills

                    if (!SkipValue(pchCmdLine))
                        Error((TCHAR*)IDS_MissingData, szCmdOption);
                    ErrorIf(nKillStorages == MAXKILLS, szCmdData, IDS_TooManyKills);
                    RemoveQuotes(szCmdData, szBuffer);
                    _tcscpy(szCmdData, szBuffer);
                    rgszKillStorages[nKillStorages++] = szCmdData;
                    break;
                case TEXT('x'):                     // extract stream from database
                    // if there is no mode specified yet
                    if(!iMode)
                        iMode = IDC_NOUI;   // set it to no UI because we can't have a UI when doing extracts

                    if (!SkipValue(pchCmdLine))
                        Error((TCHAR*)IDS_MissingData, szCmdOption);
                    ErrorIf(nExtractStreams == MAXEXTRACTS, szCmdData, IDS_TooManyExtracts);
                    RemoveQuotes(szCmdData, szBuffer);
                    _tcscpy(szCmdData, szBuffer);
                    rgszExtractStreams[nExtractStreams++] = szCmdData;
                    break;
                case TEXT('w'):                     // extract storage from database
                    // if there is no mode specified yet
                    if(!iMode)
                        iMode = IDC_NOUI;   // set it to no UI because we can't have a UI when doing extracts

                    if (!SkipValue(pchCmdLine))
                        Error((TCHAR*)IDS_MissingData, szCmdOption);
                    ErrorIf(nExtractStorages == MAXEXTRACTS, szCmdData, IDS_TooManyExtracts);
                    RemoveQuotes(szCmdData, szBuffer);
                    _tcscpy(szCmdData, szBuffer);
                    rgszExtractStorages[nExtractStorages++] = szCmdData;
                    break;
                case TEXT('?'):
                    ::DialogBox(hInst, MAKEINTRESOURCE(IDD_HELP), 0, HelpProc);
                    throw IDOK;
                default:
                    Error((TCHAR*)IDS_UnknownOption, szCmdOption);
                };
            }
            else // assume to be table name
            {
                TCHAR* szCmdData = pchCmdLine;  // save start of data
                ErrorIf(nCmdLineTables == MaxCmdLineTables, szCmdData, IDS_TooManyTables);
                SkipValue(pchCmdLine);         // null terminate end of data
                rgszCmdLineTables[nCmdLineTables++] = szCmdData;
            }
        } // while (command line tokens exist)

        // if redirected stdout then no ui will be provided
        if (hStdOut)
        {
            ErrorIf(!iMode,             IDS_MissingMode,    TEXT("(-e, -i, -c, -m, -a, -r, -t)"));

            // must specifiy a database no matter what
            ErrorIf(!szDatabase,        IDS_MissingDatabase,TEXT("(-d)"));

            // do not need a folder or tables unless doing a UI operation (-e -i -c)
            ErrorIf(!szFolder && (iMode != IDC_NOUI),           IDS_MissingFolder,  TEXT("(-f)"));
            ErrorIf(!nCmdLineTables  && (iMode != IDC_NOUI),    IDS_MissingTables,  TEXT(""));
        }

        CTableWindow Main(hInst);

        // if there is a database path specified
        if (szDatabase)
        {
            // remove quotes from either end of the path
            RemoveQuotes(szDatabase, szDb);
            _tcscpy(szDatabase, szDb);
        }

        // open the database
        if (!Main.SetDatabase(szDatabase, iMode, dbtype))
            throw IDCANCEL;

        // skip over the folder and tables for NOUI operations
        if(iMode != IDC_NOUI)
        {
            // if there is a folder path specified
            if (szFolder)
            {
                // remove quotes from either end of the path
                RemoveQuotes(szFolder, szDirectory);
                _tcscpy(szFolder, szDirectory);
            }

            // set the folder directory
            if (!Main.SetFolder(szFolder))
                throw IDCANCEL;

            do
            {
                stat = Main.SelectTables(iMode, rgszCmdLineTables, nCmdLineTables);
                if (stat == IDABORT)
                    throw IDABORT;
                if (stat != IDOK) // IDCANCEL
                    throw IDCANCEL;
                try
                {
                    Main.SetTruncate(fTruncate);
                    Main.TransferTables();
                    nCmdLineTables = 0;
                    iMode = -1;  // keep same mode
                }
                catch (CLocalError& xcpt)
                {
                    if (!Main.IsInteractive())
                        throw;
                    xcpt.Display(hInst, hStdOut);
                }
            } while (Main.IsInteractive());
        }

        // merge databases now
        for ( i = 0; i < nMergeDatabases; i++ )
        {
            Main.SetDatabase(rgszMergeDatabases[i], iMode, dbtypeMerge);
            ErrorIf(Main.MergeDatabase() != TRUE, TEXT("Merge Conflicts Reported"), TEXT("Check _MergeErrors table in database for merge conflicts."));
        }

        // apply transforms now
        for ( i = 0; i < nTransforms; i++ )
            Main.TransformDatabase(rgszTransforms[i]);

        // add imports now
        for ( i = 0; i < nImports; i++ )
            Main.AddImport(rgszImports[i]);

        // add storages now
        for ( i = 0; i < nStorages; i++ )
            Main.AddStorage(rgszStorages[i]);

        // do extract streams now
        for ( i = 0; i < nExtractStreams; i++ )
            Main.ExtractStream(rgszExtractStreams[i]);

        // do kills now
        for ( i = 0; i < nKillStorages; i++ )
            Main.KillStorage(rgszKillStorages[i]);

        // do kills now
        for ( i = 0; i < nKillStreams; i++ )
            Main.KillStream(rgszKillStreams[i]);

        // do extract storagess now (database will be closed after this)
        for ( i = 0; i < nExtractStorages; i++ )
            Main.ExtractStorage(rgszExtractStorages[i]);

        return 0;
    } // end try
    catch (int i)
    {
        return i==IDABORT ? 1 : 0;
    }
    catch (CLocalError& xcpt)
    {
        xcpt.Display(hInst, hStdOut);
        return 2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msifiler\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msifiler\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiexts\ptr_val.h ===
ULONG64 ValidateDatabasePointer(ULONG64 pInAddress);
ULONG64 ValidateEnginePointer(ULONG64 pInAddress);
ULONG64 ValidateRecordPointer(ULONG64 pInAddress);
ULONG64 ValidateStringPointer(ULONG64 pInAddress);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinfo\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiexts\ptr_val.cpp ===
#define KDEXT_64BIT
#include <tchar.h>
#include <ntverp.h>
#include <windows.h>
#include <winnt.h>
#include <dbghelp.h>
#include <wdbgexts.h>

extern void DumpPrettyPointer(ULONG64 pInAddress);

///////////////////////////////////////////////////////////////////////
// Validate the address as an engine pointer by validating the vtable
// Checks PMsiEngine and IMsiEngine. Returns the actual CMsiEngine*
// when validated.
ULONG64 ValidateMSIPointerType(const char* szType, ULONG64 pInAddress, ULONG64 pQI)
{
	// pFinalObj contains the IMsiX*. If pInAddress is
	// a PMsiX, this is not the same value.
	ULONG64 pFinalObj = 0;
	
	// determine if the address points to an IMsiX* or PMsiX.
	// if the thing in pInAddress is an IMsiX*, the first PTR at that
	// location should be the X vtable, and dereferencing that should
	// be the address of the X::QueryInterface function.

	ULONG64 pPossibleQI = 0;
	ULONG64 pFirstIndirection = 0;
	if (0 == ReadPtr(pInAddress, &pFirstIndirection))
	{
		// if the first dereference retrieves a NULL, this is a PMsiEngine
		// with a NULL record in it. (because the vtable can never be NULL
		if (!pFirstIndirection)
		{
			dprintf("PMsi%s (NULL) at ", szType);
			DumpPrettyPointer(pInAddress);
			dprintf("\n");
			return NULL;;
		}

		// dereference the vtable to get the QI function pointer
		if (0 == ReadPtr(pFirstIndirection, &pPossibleQI))
		{
			if (pPossibleQI == pQI)
			{
				dprintf("IMsi%s at ", szType);
				pFinalObj = pInAddress;
				DumpPrettyPointer(pInAddress);
				dprintf("\n");
			}
		}
	}

	// its not an IMsiX, so check PMsiX (one additional dereference)
	if (!pFinalObj)
	{
		// dereference the vtable to get the QI function pointer
		if (0 == ReadPtr(pPossibleQI, &pPossibleQI))
		{
			if (pPossibleQI == pQI)
			{
				dprintf("PMsi%s (", szType);
				DumpPrettyPointer(pFirstIndirection);
				dprintf(") at ");
				DumpPrettyPointer(pInAddress);
				dprintf("\n");
				pFinalObj = pFirstIndirection;
			}
		}
	}

	// couldn't verify a PMsiX or an IMsiX
	if (!pFinalObj)
	{
		DumpPrettyPointer(pInAddress);
		dprintf(" does not appear to be an IMsi%s or PMsi%s.\n", szType, szType);
		return NULL;
	}
	return pFinalObj;
}

///////////////////////////////////////////////////////////////////////
// Validate the address as an engine pointer by validating the vtable
// Checks PMsiEngine and IMsiEngine. Returns the actual CMsiEngine*
// when validated.
ULONG64 ValidateEnginePointer(ULONG64 pInAddress)
{
	ULONG64 pEngineQI = GetExpression("msi!CMsiEngine__QueryInterface");
	
	return ValidateMSIPointerType("Engine", pInAddress, pEngineQI);
}

///////////////////////////////////////////////////////////////////////
// Validate the address as an engine pointer by validating the vtable
// Checks PMsiDatabase and IMsiDatabase. Returns the actual CMsiDatabase*
// when validated.
ULONG64 ValidateDatabasePointer(ULONG64 pInAddress)
{
	ULONG64 pDatabaseQI = GetExpression("msi!CMsiDatabase__QueryInterface");
	
	return ValidateMSIPointerType("Database", pInAddress, pDatabaseQI);
}

///////////////////////////////////////////////////////////////////////
// Validate the address as a record pointer by validating the vtable
// Checks PMsiRecord and IMsiRecord. Returns the actual CMsiRecord*
// when validated.
ULONG64 ValidateRecordPointer(ULONG64 pInAddress)
{
	ULONG64 pDatabaseQI = GetExpression("msi!CMsiRecord__QueryInterface");
	
	return ValidateMSIPointerType("Record", pInAddress, pDatabaseQI);
}

///////////////////////////////////////////////////////////////////////
// Validate the address as a string pointer by validating the vtable
// Checks MsiString, PMsiString and IMsiString. Returns the actual
// IMsiString* when validated.
ULONG64 ValidateStringPointer(ULONG64 pInAddress)
{
	ULONG64 pDatabaseQI = GetExpression("msi!CMsiStringBase__QueryInterface");
	
	return ValidateMSIPointerType("String", pInAddress, pDatabaseQI);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msifiler\sources.inc ===
TARGETNAME=msifiler
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

USE_LIBCMT=1

TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS=\
        $(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_NOLIBS=1

INCLUDES=$(BUILD_COMMONDIR);$(INC_DIR);$(RES_OBJDIR);$(MSI_CMDPARSE_DIR)

SOURCES=..\msifiler.cpp \
	..\msifiler.rc  \
	$(O)\cmdparse.cpp

NTTARGETFILE0=       \
	$(O)\cmdparse.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msifiler\msifiler.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File:       msifiler.cpp
//
//--------------------------------------------------------------------------

#define W32
#include <Windows.h>
#include <assert.h>
#include <stdio.h>   // printf/wprintf
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h"
#include "msidefs.h"
#include "cmdparse.h"

#define MSI_DLL TEXT("msi.dll")

#ifdef UNICODE
#define MSIAPI_MsiGetFileHash "MsiGetFileHashW"
#define MSIAPI_MsiOpenPackageEx "MsiOpenPackageExW"
#else
#define MSIAPI_MsiGetFileHash "MsiGetFileHashA"
#define MSIAPI_MsiOpenPackageEx "MsiOpenPackageExA"
#endif

typedef UINT (WINAPI *PFnMsiGetFileHash)(LPCTSTR hwnd, DWORD* dwOptions, PMSIFILEHASHINFO pHash);
typedef UINT (WINAPI *PFnMsiOpenPackageEx)(LPCTSTR szPackage, DWORD dwOptions, MSIHANDLE *phPackage);

///////////////////////////////////////////////////////////
// FileExists
// Pre: file name is passed in
// Pos:	TRUE if file exists
//		FALSE if file does not exist
BOOL FileExists(LPCTSTR szPath)
{
	BOOL fExists = TRUE;	// assume the file exists
	// in case path refers to a floppy drive, disable the "insert disk in drive" dialog
	UINT iCurrMode = W32::SetErrorMode( SEM_FAILCRITICALERRORS );

	// if the file is a dircectory or doesn't exist
	if (W32::GetFileAttributes(szPath) & FILE_ATTRIBUTE_DIRECTORY)
		fExists = FALSE;              //either a dir or doesn't exist

	// put the error mode back
	W32::SetErrorMode(iCurrMode);

	return fExists;
}	// end of FileExists


///////////////////////////////////////////////////////////
// FileSize
// Pre: file name is passed in
// Pos: size of file 
//		0xFFFFFFFF if failed
DWORD FileSize(LPCTSTR szPath)
{
	// open the file specified
	HANDLE hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	
	// if failed to open the file bail
	if (hFile == INVALID_HANDLE_VALUE)
		return 0xFFFFFFFF;

	// get the file size and close the file
	DWORD cbFile = W32::GetFileSize(hFile, 0);
	W32::CloseHandle(hFile);

	return cbFile;
}	// end of FileSize


#define MSIFILER_OPTION_HELP       '?'
#define MSIFILER_OPTION_VERBOSE    'v'
#define MSIFILER_OPTION_DATABASE   'd'
#define MSIFILER_OPTION_HASH       'h'
#define MSIFILER_OPTION_SOURCEDIR  's'

const sCmdOption rgCmdOptions[] =
{
	MSIFILER_OPTION_HELP,      0,
	MSIFILER_OPTION_VERBOSE,   0,
	MSIFILER_OPTION_DATABASE,  OPTION_REQUIRED|ARGUMENT_REQUIRED,
	MSIFILER_OPTION_HASH,      0,
	MSIFILER_OPTION_SOURCEDIR, ARGUMENT_REQUIRED,
	0, 0,
};

/////////////////////////////////////////////////////////////////////
// main
// Pre:	file to update
//		-v specifies verbose mode
// Pos:	 0 if no error
//		< 0 if errors
extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
	// flag whether to display changes to database as program executes
	BOOL bVerbose = FALSE;		// assume the user doesn't want to see extra info
	BOOL bSOURCEDIR = FALSE;	// assume we go looking in the regular spot
	BOOL bPopulateFileHash = FALSE;
	const TCHAR* pchSourceArg;
	TCHAR szSyntax[] = TEXT("Copyright (C) Microsoft Corporation.  All rights reserved.\n\nSyntax: msifiler.exe -d database.msi [-v] [-h] [-s SOURCEDIR]\n\t-d: the database to update.\n\t-v: verbose mode.\n\t-h: populate MsiFileHash table (and create table if it doesn't exist).\n\t[-s SOURCEDIR]: specifies an alternative directory to find files.\n\n");
	int iError = 0;
	
	// database to update
	LPCTSTR szDatabase = NULL;

	CmdLineOptions cmdLine(rgCmdOptions);

	if(cmdLine.Initialize(argc, argv) == FALSE ||
		cmdLine.OptionPresent(MSIFILER_OPTION_HELP))
	{
		_tprintf(szSyntax);
		return 0;
	}

	szDatabase = cmdLine.OptionArgument(MSIFILER_OPTION_DATABASE);
	if(!szDatabase || !*szDatabase)
	{
		_tprintf(TEXT("Error:  No database specified.\n"));
		_tprintf(szSyntax);
		return 0;
	}

	if(cmdLine.OptionPresent(MSIFILER_OPTION_SOURCEDIR))
	{
		bSOURCEDIR = TRUE;
		pchSourceArg = cmdLine.OptionArgument(MSIFILER_OPTION_SOURCEDIR);
	}

	bVerbose          = cmdLine.OptionPresent(MSIFILER_OPTION_VERBOSE);
	bPopulateFileHash = cmdLine.OptionPresent(MSIFILER_OPTION_HASH);

	// if verbose display the starting message
	if (bVerbose)
		_tprintf(TEXT("Looking for database: %s\n"), szDatabase);

	// try to open the database for transactions
	PMSIHANDLE hDatabase = 0;
	if (MsiOpenDatabase(szDatabase, MSIDBOPEN_TRANSACT, &hDatabase) != ERROR_SUCCESS)
	{
		_tprintf(TEXT("ERROR: Failed to open database: %s\n"), szDatabase);
		return -2;
	}
	else	// good to go
		if (bVerbose)
			_tprintf(TEXT("Updating database: %s\n"), szDatabase);

	if(bPopulateFileHash)
	{
		// check if MsiFileHash table exists, and if we need to add it
		if(MsiDatabaseIsTablePersistent(hDatabase, TEXT("MsiFileHash")) != MSICONDITION_TRUE)
		{
			// create MsiFileHash table
			PMSIHANDLE hCreateTableView = 0;
			if (MsiDatabaseOpenView(hDatabase, 
									TEXT("CREATE TABLE `MsiFileHash` ( `File_` CHAR(72) NOT NULL, `Options` INTEGER NOT NULL, `HashPart1` LONG NOT NULL, `HashPart2` LONG NOT NULL, `HashPart3` LONG NOT NULL, `HashPart4` LONG NOT NULL PRIMARY KEY `File_` )"), 
									&hCreateTableView) != ERROR_SUCCESS)
			{
				_tprintf(TEXT("ERROR: Failed to open MsiFileHash table creation view.\n"));
				return -11;
			}
			else if (bVerbose)
				_tprintf(TEXT("   Database query for MsiFileHash table creation successful...\n"));

			// now execute the view
			if (MsiViewExecute(hCreateTableView, NULL) != ERROR_SUCCESS)
			{
				_tprintf(TEXT("ERROR: Failed to execute MsiFileHash table creation view.\n"));
				return -12;
			}
			else if (bVerbose)
				_tprintf(TEXT("   MsiFileHash table created successfully...\n"));
		}
	}

	// convert the database into a temporary string format: #address_of_db
	TCHAR szDBBuf[16];
	_stprintf(szDBBuf, TEXT("#%i"), hDatabase);

	HMODULE hMsi = 0;
	hMsi = LoadLibrary(MSI_DLL);
	if(hMsi == 0)
	{
		_tprintf(TEXT("ERROR: Failed to load %s."), MSI_DLL);
		return -14;
	}
	PFnMsiOpenPackageEx pfnMsiOpenPackageEx = 0;
	pfnMsiOpenPackageEx = (PFnMsiOpenPackageEx)GetProcAddress(hMsi, MSIAPI_MsiOpenPackageEx);
	if (pfnMsiOpenPackageEx == 0)
	{
		_tprintf(TEXT("INFO: Unable to bind to MsiOpenPackageEx API in MSI.DLL. Defaulting to MsiOpenPackage. MsiOpenPackageEx requires MSI.DLL version 2.0 or later."));
	}
	
	// set UI level to none
	MsiSetInternalUI(INSTALLUILEVEL_NONE, 0);

	// try to create an engine from the database
	PMSIHANDLE hEngine = 0;
	if (pfnMsiOpenPackageEx && ((*pfnMsiOpenPackageEx)(szDBBuf, MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE, &hEngine) != ERROR_SUCCESS))
	{
		_tprintf(TEXT("ERROR: Failed to create engine.\n"));
		FreeLibrary(hMsi);
		return -16;
	}
	else if (!pfnMsiOpenPackageEx && MsiOpenPackage(szDBBuf, &hEngine) != ERROR_SUCCESS)
	{
		_tprintf(TEXT("ERROR: Failed to create engine.\n"));
		FreeLibrary(hMsi);
		return -3;
	}
	else	// good to go
		if (bVerbose)
			_tprintf(TEXT("   Engine created...\n"));

	// try to do the necessary action to get the files setup
	if (MsiDoAction(hEngine, TEXT("CostInitialize")) != ERROR_SUCCESS)
	{
		_tprintf(TEXT("ERROR: Failed to run the CostInitialize.\n"));
		FreeLibrary(hMsi);
		return -4;
	}

	// View #1: File & Component tables (to find file locations, and update version, language and size)
	enum fvParams
	{
		fvFileKey = 1,
		fvFileName,
		fvDirectory,
		fvFileSize,
		fvVersion,
		fvLanguage
	};
	
	PMSIHANDLE hFileTableView = 0;
	if (MsiDatabaseOpenView(hDatabase, 
							TEXT("SELECT File,FileName,Directory_,FileSize,Version,Language FROM File,Component WHERE Component_=Component"), 
							&hFileTableView) != ERROR_SUCCESS)
	{
		_tprintf(TEXT("ERROR: Failed to open view.\n"));
		FreeLibrary(hMsi);
		return -5;
	}
	else	// good to go
		if (bVerbose)
			_tprintf(TEXT("   Database query successful...\n"));

	// now execute the view
	if (MsiViewExecute(hFileTableView, NULL) != ERROR_SUCCESS)
	{
		_tprintf(TEXT("ERROR: Failed to execute view.\n"));
		FreeLibrary(hMsi);
		return -6;
	}

	// View #2: FileHash table (to update File hash values)
	enum fhvParams
	{
		fhvFileKey = 1,
		fhvHashOptions,
		fhvHashPart1,
		fhvHashPart2,
		fhvHashPart3,
		fhvHashPart4
	};

	PMSIHANDLE hFileHashTableView = 0;
	if(bPopulateFileHash)
	{
		if (MsiDatabaseOpenView(hDatabase, 
								TEXT("SELECT File_, Options, HashPart1, HashPart2, HashPart3, HashPart4 FROM MsiFileHash"), 
								&hFileHashTableView) != ERROR_SUCCESS)
		{
			_tprintf(TEXT("ERROR: Failed to open view on MsiFileHash table.\n"));
			FreeLibrary(hMsi);
			return -13;
		}
		else	// good to go
		{
			if (bVerbose)
				_tprintf(TEXT("   Database query successful on MsiFileHash table...\n"));
		}
	}

	// View #3: File table (to find companion files)
	PMSIHANDLE hFileTableCompanionView = 0;
	if (MsiDatabaseOpenView(hDatabase, 
							TEXT("SELECT File FROM File WHERE File=?"), 
							&hFileTableCompanionView) != ERROR_SUCCESS)
	{
		_tprintf(TEXT("ERROR: Failed to open view.\n"));
		FreeLibrary(hMsi);
		return -16;
	}
	else	// good to go
	{
		if (bVerbose)
			_tprintf(TEXT("   Database query successful...\n"));
	}

	PMSIHANDLE hCompanionFileRec = MsiCreateRecord(1);
	



	// read the PID_WORDCOUNT summary Info value to determine if SFN or LFN should be used.
	PMSIHANDLE hSummaryInfo = 0;
	int iWordCount;
	if (::MsiGetSummaryInformation(hDatabase, NULL, 0, &hSummaryInfo))
	{
		_tprintf(TEXT("ERROR: Failed to get Summary Information stream from package."));
		FreeLibrary(hMsi);
		return -8;
	}
	if (::MsiSummaryInfoGetProperty(hSummaryInfo, PID_WORDCOUNT, NULL, &iWordCount, NULL, NULL, NULL))
	{
		_tprintf(TEXT("ERROR: Failed to retrieve PID_WORDCOUNT value from Summary Information stream."));
		FreeLibrary(hMsi);
		return -9;
	}

	// we use SFN always if bit 1 is set in the summary info stream. 
	// Otherwise we use LFN when they are available, SFN if they aren't.
	BOOL bSFN = iWordCount & msidbSumInfoSourceTypeSFN;

	// now loop through all records in view
	PMSIHANDLE hFileTableRec = 0;

	PFnMsiGetFileHash pfnMsiGetFileHash = 0;
	if(bPopulateFileHash)
	{
		pfnMsiGetFileHash = (PFnMsiGetFileHash)GetProcAddress(hMsi, MSIAPI_MsiGetFileHash);
		if(pfnMsiGetFileHash == 0)
		{
			_tprintf(TEXT("ERROR: Failed to bind to %s API in %s.  MsiFileHash table population requires %s version 2.0 or later."), TEXT(MSIAPI_MsiGetFileHash), MSI_DLL, MSI_DLL);
			FreeLibrary(hMsi);
			return -15;
		}
	}
	
	do
	{

		// fetch the record
		MsiViewFetch(hFileTableView, &hFileTableRec);

		// if there was a record fetched
		if (hFileTableRec)
		{
			BOOL bSkipVersionUpdate = FALSE; // skip update of version information for companion files

			// get the directory key
			TCHAR szDirectory[MAX_PATH + 1];
			DWORD cchDirectory = MAX_PATH + 1;
			MsiRecordGetString(hFileTableRec, fvDirectory, szDirectory, &cchDirectory);

			// get the file name
			TCHAR szFileName[MAX_PATH + 1];
			DWORD cchFileName = MAX_PATH + 1;
			MsiRecordGetString(hFileTableRec, fvFileName, szFileName, &cchFileName);

			// get the file key
			TCHAR szFileKey[MAX_PATH + 1];
			DWORD cchFileKey = MAX_PATH + 1;
			MsiRecordGetString(hFileTableRec, fvFileKey, szFileKey, &cchFileKey);

			// try to get the source path
			TCHAR szSourcePath[MAX_PATH + 1];
			DWORD cchSourcePath = MAX_PATH + 1;
			if (bSOURCEDIR)
				lstrcpy(szSourcePath, pchSourceArg);

			if (!bSOURCEDIR && (MsiGetSourcePath(hEngine, szDirectory, szSourcePath, &cchSourcePath) != ERROR_SUCCESS))
			{
				_tprintf(TEXT("ERROR: Failed to get source path for: %s.\n"), szDirectory);

				// set the source path to empty
				cchSourcePath = 0;

				// fatal error when MsiGetSourcePath fails
				iError = -10;
				goto cleanup;
			}
			else	// tack on the file name to the source path
			{
				// use the SFN or LFN
				TCHAR *szLFN = _tcschr(szFileName, TEXT('|'));
				if (szLFN) 
					*(szLFN++) = TEXT('\0');

				// concat the file name on to the path
				_tcscat(szSourcePath, (!bSFN && szLFN) ? szLFN : szFileName);
				cchSourcePath = _tcslen(szSourcePath);

				// if the file exists
				if (FileExists(szSourcePath))
				{
					// check version column to see if this might be a companion file (where Version column value is a File table key)
					if (FALSE == MsiRecordIsNull(hFileTableRec, fvVersion))
					{
						TCHAR szVersion[MAX_PATH + 1];
						DWORD cchVersion = MAX_PATH + 1;
						MsiRecordGetString(hFileTableRec, fvVersion, szVersion, &cchVersion);
						MsiRecordSetString(hCompanionFileRec, 1, szVersion);

						MsiViewClose(hFileTableCompanionView);

						// now execute the view
						if (ERROR_SUCCESS != MsiViewExecute(hFileTableCompanionView, hCompanionFileRec))
						{
							_tprintf(TEXT("ERROR: Failed to execute view.\n"));
							FreeLibrary(hMsi);
							return -17;
						}

						PMSIHANDLE hFileCompanionFetchRec = 0;
						UINT uiStatus = MsiViewFetch(hFileTableCompanionView, &hFileCompanionFetchRec);
						if (ERROR_SUCCESS == uiStatus)
						{
							// skip this one, this uses a companion file for its version
							if (bVerbose)
								_tprintf(TEXT("   >> Skipping file: %s for version update, uses a companion file for its version\n"), szSourcePath);
							bSkipVersionUpdate = TRUE;
						}
						else if (ERROR_NO_MORE_ITEMS != uiStatus)
						{
							_tprintf(TEXT("ERROR: Failed to fetch from view.\n"));
							FreeLibrary(hMsi);
							return -18;
						}
					}

					if (bVerbose)
						_tprintf(TEXT("   >> Updating file: %s\n"), szSourcePath);

					// get the file size
					DWORD dwFileSize;
					dwFileSize = FileSize(szSourcePath);
					
					// try to get the version into a string
					TCHAR szVersion[64];		// buffer
					DWORD cb = sizeof(szVersion)/sizeof(TCHAR);
					TCHAR szLang[64];		    // buffer
					DWORD cbLang = sizeof(szLang)/sizeof(TCHAR);
					if (MsiGetFileVersion(szSourcePath, szVersion, &cb, szLang, &cbLang) != ERROR_SUCCESS)
					{
						szVersion[0] = 0;
						szLang[0] = 0;
					}

					MSIFILEHASHINFO sHash;
					memset(&sHash, 0, sizeof(sHash));
					BOOL fHashSet = FALSE;

					if(bPopulateFileHash)
					{
						sHash.dwFileHashInfoSize = sizeof(MSIFILEHASHINFO);
						UINT uiRes = (*pfnMsiGetFileHash)(szSourcePath, 0, &sHash);
						if(uiRes != ERROR_SUCCESS)
						{
							_tprintf(TEXT("ERROR: MsiGetFileHash failed\n"));
							memset(&sHash, 0, sizeof(sHash));
						}
						else
						{
							fHashSet = TRUE;
						}
					}

					// display some extra information
					if (bVerbose)
					{
						// get the old size and version of this file
						DWORD dwOldSize;
						TCHAR szOldVersion[64];
						DWORD cchOldVersion = 64;
						TCHAR szOldLang[64];
						DWORD cchOldLang = 64;
						dwOldSize = MsiRecordGetInteger(hFileTableRec, fvFileSize);
						MsiRecordGetString(hFileTableRec, fvVersion, szOldVersion, &cchOldVersion);
						MsiRecordGetString(hFileTableRec, fvLanguage, szOldLang, &cchOldLang);

						_tprintf(TEXT("      Size:    prev: %d\n"), dwOldSize);
						_tprintf(TEXT("                new: %d\n"), dwFileSize);

						if (!bSkipVersionUpdate)
						{
							_tprintf(TEXT("      Version: prev: %s\n"), szOldVersion);
							_tprintf(TEXT("                new: %s\n"), szVersion);
							_tprintf(TEXT("      Lang:    prev: %s\n"), szOldLang);
							_tprintf(TEXT("                new: %s\n"), szLang);
						}
					}

					// set the new data into the record
					MsiRecordSetInteger(hFileTableRec, fvFileSize, dwFileSize);
					if (!bSkipVersionUpdate)
					{
						MsiRecordSetString(hFileTableRec, fvVersion, szVersion);
						MsiRecordSetString(hFileTableRec, fvLanguage, szLang);
					}

					// modify the view
					MsiViewModify(hFileTableView, MSIMODIFY_UPDATE, hFileTableRec);

					// don't enter hashes for versioned files
					if(hFileHashTableView && fHashSet && !*szVersion)
					{
						PMSIHANDLE hFileHashTableRec = 0;
						hFileHashTableRec = MsiCreateRecord(6);
						if (hFileHashTableRec)
						{
							MsiRecordSetString (hFileHashTableRec, fhvFileKey,     szFileKey);
							MsiRecordSetInteger(hFileHashTableRec, fhvHashOptions, 0);
							MsiRecordSetInteger(hFileHashTableRec, fhvHashPart1,   sHash.dwData[0]);
							MsiRecordSetInteger(hFileHashTableRec, fhvHashPart2,   sHash.dwData[1]);
							MsiRecordSetInteger(hFileHashTableRec, fhvHashPart3,   sHash.dwData[2]);
							MsiRecordSetInteger(hFileHashTableRec, fhvHashPart4,   sHash.dwData[3]);

							// modify the view
							MsiViewModify(hFileHashTableView, MSIMODIFY_ASSIGN, hFileHashTableRec);
						}
					}
				}
				else	// source file not found
					_tprintf(TEXT("      Failed to locate file: %s\n"), szSourcePath);
			}
		}
	} while (hFileTableRec);	// something was fetched

	// all done fetching
	if (bVerbose)
		_tprintf(TEXT("   File update complete, commiting database...\n"));

	// try to commit the database
	if (MsiDatabaseCommit(hDatabase) != ERROR_SUCCESS)
	{
		_tprintf(TEXT("ERROR: Failed to commit the database.\n"));
		iError = -7;
		goto cleanup;
	}
	else	// database was committed
		if (bVerbose)
			_tprintf(TEXT("   Database commited.\n"));

	// all done
	if (bVerbose)
		_tprintf(TEXT("\nUpdate complete for database: %s"), szDatabase);

	iError = 0; // just to make sure

cleanup:

	if(hMsi)
		FreeLibrary(hMsi);

	return iError;

}	// end of main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiexts\msiexts.cpp ===
#define KDEXT_64BIT
#include <tchar.h>
#include <ntverp.h>
#include <windows.h>
#include <winnt.h>
#include <dbghelp.h>
#include <wdbgexts.h>
#include <stdlib.h>

#include "ptr_val.h"

const int iidMsiRecord                    = 0xC1003L;
const int iidMsiView                      = 0xC100CL;
const int iidMsiDatabase                  = 0xC100DL;
const int iidMsiEngine                    = 0xC100EL;
const int iMsiNullInteger				  = 0x80000000;

///////////////////////////////////////////////////////////////////////
// globals variables
EXT_API_VERSION         ApiVersion = 
{ 
	(VER_PRODUCTVERSION_W >> 8), 
	(VER_PRODUCTVERSION_W & 0xff), 
	EXT_API_VERSION_NUMBER64, 
	0 
};

WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;


///////////////////////////////////////////////////////////////////////
// standard functions exported by every debugger extension
DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

VOID
CheckVersion(
    VOID
    )
{
    return;
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

///////////////////////////////////////////////////////////////////////
// type and variables names
const char szRecordType[] = "msi!CMsiRecord";
const char szHandleType[] = "msi!CMsiHandle";
const char szFieldDataType[] = "msi!FieldData";
const char szFieldIntegerType[] = "msi!CFieldInteger";
const char szDatabaseType[] = "msi!CMsiDatabase";
const char szTableType[] = "msi!CMsiTable";
const char szEngineType[] = "msi!CMsiEngine";
const char szCacheLinkDataType[] = "msi!MsiCacheLink";
const char szStringBaseType[] = "msi!CMsiStringBase";
const char szStringType[] = "msi!CMsiString";
const char szStreamQI[] = "Msi!CMsiStream__QueryInterface";
const char szFieldDataStaticInteger[] = "Msi!FieldData__s_Integer";
const char szStaticHandleListHead[] = "msi!CMsiHandle__m_Head";
const char szMsiStringNullString[] = "msi!MsiString__s_NullString";


///////////////////////////////////////////////////////////////////////
// dump a pointer to output, prepending with enough 0's for the
// platform pointer size.
void DumpPrettyPointer(ULONG64 pInAddress)
{
	if (IsPtr64())
		dprintf("0x%016I64x", pInAddress);
	else
		dprintf("0x%08x", static_cast<DWORD>(pInAddress));
}

void ErrorReadingMembers(const char *szType, ULONG64 pInAddress)
{
	dprintf("Error reading %s members from object at ", szType);
	DumpPrettyPointer(pInAddress);
	dprintf("\n");
}

///////////////////////////////////////////////////////////////////////
// hash the string the same way the database does, for use in
// searching the string pool.
unsigned int HashString(int iHashBins, const WCHAR* sz, int &iLen)
{
	unsigned int iHash = 0;
	int iHashMask = iHashBins - 1;
	const WCHAR *pchStart = sz;
	
	iLen = 0;
	while (*sz != 0)
	{
		int carry;
		carry = iHash & 0x80000000;	
		iHash <<= 1;
		if (carry)
			iHash |= 1;
		iHash ^= *sz;
		sz++;
	}
	iHash &= iHashMask;
	iLen = (int)(sz - pchStart);
	return iHash;
}

///////////////////////////////////////////////////////////////////////
// return the string at the specified index. Caller is responsible for
// calling delete[] on *wzString if true is returned.
bool RetrieveStringFromIndex(ULONG64 pDatabaseObj, int iIndex, WCHAR** wzString, unsigned int &cchString)
{
	// determine the size of the MsiCacheLink structure
	UINT uiCacheLinkSize = GetTypeSize(szFieldDataType);

	// retrieve the maxmimum string index value
	int iMaxIndex;
	if (0 != (GetFieldData(pDatabaseObj, szDatabaseType, "m_cCacheUsed", sizeof(iMaxIndex), &iMaxIndex)))
	{
		ErrorReadingMembers(szDatabaseType, pDatabaseObj);
		return false;
	}

	// validate that the index is valid
	if ((iIndex > iMaxIndex) || (iIndex < 0))
	{
		dprintf("Index %d is out of range. Current range for database at ", iIndex);
		DumpPrettyPointer(pDatabaseObj);
		dprintf(" is 0..%d.\n", iMaxIndex);
		return false;
	}

	// retrieve base address 
	ULONG64 pLinkTable = 0;
	if (0 != (GetFieldData(pDatabaseObj, szDatabaseType, "m_rgCacheLink", sizeof(pLinkTable), &pLinkTable)))
	{
		ErrorReadingMembers(szDatabaseType, pDatabaseObj);
		return false;
	}

	ULONG64 pCacheLink = pLinkTable + uiCacheLinkSize*iIndex;

	// retrieve the pointer to the string object
	ULONG64 pStringObj = 0;
	if (0 != (GetFieldData(pCacheLink, szCacheLinkDataType, "piString", sizeof(pStringObj), &pStringObj)))
	{
		ErrorReadingMembers(szDatabaseType, pDatabaseObj);
		return false;
	}

	if (!pStringObj)
	{
		dprintf("Index %d is not defined\n", iIndex);
		return false;
	}

	// grab the length of the string (number of characters)
	UINT uiCount = 0;
	if (0 != (GetFieldData(pStringObj, szStringBaseType, "m_cchLen", sizeof(uiCount), &uiCount)))
	{
		ErrorReadingMembers(szStringBaseType, pStringObj);
		return false;
	}
	cchString = uiCount;

	// retrieve pontier to buffer containing actual string
	ULONG ulOffset;
	if (0 != (GetFieldOffset((LPSTR)szStringType, "m_szData", &ulOffset)))
	{
		ErrorReadingMembers(szStringBaseType, pStringObj);
		return false;
	}
				
	// increment for terminating null
	uiCount++;

	// allocate memory for string
	*wzString = new WCHAR[uiCount];
	if (!*wzString)
	{
		dprintf("Unable to allocate memory in debugger extension.\n", pStringObj);
		return false;
	}

	// load the string into the buffer
	ULONG cbRead = 0;
	if (0 == ReadMemory(pStringObj+ulOffset, (PVOID)*wzString, uiCount*sizeof(WCHAR), &cbRead))
	{
		ErrorReadingMembers(szStringBaseType, pStringObj);
		delete[] *wzString;
		*wzString = NULL;
		return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////
// return the string pool index ID of a string. pDatabaseObj should
// be validated already as a valid CMsiDatabase.
bool FindStringIndex(ULONG64 pDatabaseObj, LPCWSTR szString, int &iCacheLink)
{
	// retrieve the hash bin count from the database
	unsigned int uiHashBins;
	if (0 != (GetFieldData(pDatabaseObj, szDatabaseType, "m_cHashBins", sizeof(uiHashBins), &uiHashBins)))
	{
		ErrorReadingMembers(szDatabaseType, pDatabaseObj);
		return false;
	}

	// hash the table name
	int iLen = 0;
	unsigned int iHash = HashString(uiHashBins, szString, iLen);

	// determine the size of the MsiCacheLink structure
	UINT uiCacheLinkSize = GetTypeSize(szFieldDataType);

	// turn the hash index into an initial cache link by indexing into the hash table
	ULONG64 pHashTable = 0;
	ULONG64 pLinkTable = 0;
	if ((0 != (GetFieldData(pDatabaseObj, szDatabaseType, "m_rgHash", sizeof(pHashTable), &pHashTable))) ||
		(0 != (GetFieldData(pDatabaseObj, szDatabaseType, "m_rgCacheLink", sizeof(pLinkTable), &pLinkTable))))
	{
		ErrorReadingMembers(szDatabaseType, pDatabaseObj);
		return false;
	}
	ULONG cbRead = 0;
	ULONG64 pHashValue = pHashTable+(sizeof(int)*iHash);
	if (0 == ReadMemory(pHashValue, (PVOID)&iCacheLink, sizeof(iCacheLink), &cbRead))
	{
		ErrorReadingMembers(szDatabaseType, pDatabaseObj);
		return false;
	}

	while (iCacheLink >= 0)
	{
		WCHAR* strData = NULL;
		unsigned int cchStringLen;

		if (RetrieveStringFromIndex(pDatabaseObj, iCacheLink, &strData, cchStringLen))
		{

			// if the length matches, check the string data itself
			if (iLen == cchStringLen)
			{	
				if (0 == memcmp(strData, szString, cchStringLen*sizeof(WCHAR)))
				{
					delete[] strData;
					return true;
				}
			}
			delete[] strData;
		}

		// optain the next link 
		ULONG64 pCacheLink = pLinkTable + uiCacheLinkSize*iCacheLink;
		if (0 != (GetFieldData(pCacheLink, szCacheLinkDataType, "iNextLink", sizeof(iCacheLink), &iCacheLink)))
		{
			ErrorReadingMembers(szCacheLinkDataType, pCacheLink);
			return false;
		}
	}
	return false;
}

///////////////////////////////////////////////////////////////////////
// search pTable (must be valid) for the row with the primary key
// indicated by the value. The value is directly compare, so integer
// comparisons must be flagged as integers already. Returns
// the address of the matching data identifiers
ULONG64 RetrieveMatchingRowAddressFromTable(ULONG64 pTable, int iKeyValue)
{
	// retrieve the number of columns and rows in the table;
	int cColumns = 0;
	if (0 != (GetFieldData(pTable, szTableType, "m_cWidth", sizeof(cColumns), &cColumns)))
	{
		ErrorReadingMembers(szTableType, pTable);
		return 0;
	}

	if (cColumns == 0)
		return 0;

	int cRows = 0;
	if (0 != (GetFieldData(pTable, szTableType, "m_cRows", sizeof(cRows), &cRows)))
	{
		ErrorReadingMembers(szTableType, pTable);
		return 0;
	}

	if (cRows == 0)
		return 0;

	ULONG64 pRowBase = NULL;
	if (0 != (GetFieldData(pTable, szTableType, "m_rgiData", sizeof(pRowBase), &pRowBase)))
	{
		ErrorReadingMembers(szTableType, pTable);
		return 0;
	}

	// skip over the first value, which is the row attributes.
	pRowBase += sizeof(int);

	int iCurRow = 0;
	ULONG64 pRow = pRowBase;
	while(iCurRow < cRows)
	{
		unsigned int iValue = 0;
		ULONG cbRead = 0;
		if (0 == ReadMemory(pRow, (PVOID)&iValue, sizeof(iValue), &cbRead))
		{
			ErrorReadingMembers(szTableType, pTable);
			return NULL;
		}

		if (iValue == iKeyValue)
		{
			// win returning the row pointer, include the 0th column.
			return pRow-sizeof(int);
		}

		pRow += (sizeof(iValue)*cColumns);
		iCurRow++;
	}
	return NULL;
}

///////////////////////////////////////////////////////////////////////
// search the table catalog of pDatabase (must be valid) for the 
// table of the name wzTable. If found, CMsiTable* is returned.
ULONG64 RetrieveTablePointerFromDatabase(ULONG64 pDatabase, WCHAR* wzTable)
{
	int iIndex = 0;
	if (!FindStringIndex(pDatabase, wzTable, iIndex))
		return NULL;

	ULONG64 pCatalog = NULL;
	if (0 != (GetFieldData(pDatabase, szDatabaseType, "m_piCatalogTables", sizeof(pCatalog), &pCatalog)))
	{
		ErrorReadingMembers(szDatabaseType, pDatabase);
		return false;
	}

	// search the catalog table for the row with this string ID as key
	ULONG64 pTableData = RetrieveMatchingRowAddressFromTable(pCatalog, iIndex);
	if (!pTableData)
	{
		dprintf("$ws table not loaded or missing.");
		return NULL;
	}

	// retrieve the pointer at column 2. Don't forget column 0 is attributes.
	pTableData += 2*sizeof(unsigned int);

	unsigned int iValue = 0;
	ULONG cbRead = 0;
	if (0 == ReadMemory(pTableData, (PVOID)&iValue, sizeof(iValue), &cbRead))
	{
		ErrorReadingMembers(szDatabaseType, pDatabase);
		return NULL;
	}

	if (IsPtr64())
	{
		// on Win64, grabbing the table pointer requires finding the object in the object pool
		// because the table can't store the pointer natively.
		// ****************************************
		return NULL;
	}
	else
	{
		// on Win32, its just the pointer itself
		return iValue;
	}

	return NULL;
}

///////////////////////////////////////////////////////////////////////
// locates a table given a database pointer and table name
void FindMsiTable(ULONG64 pInAddress, LPCWSTR szTable)
{
	// validate that the database pointer is valid.
	ULONG64 pDatabaseObj = ValidateDatabasePointer(pInAddress);
	if (!pDatabaseObj)
		return;

	int iIndex = 0;
	if (!FindStringIndex(pDatabaseObj, szTable, iIndex))
		dprintf("Table Not Found\n");
	else
		dprintf("Table Index %d\n", iIndex);

	return;
}

///////////////////////////////////////////////////////////////////////
// dumps a CMsiString object. pStringObj MUST be a IMsiString* or a 
// CMsiString* (currently does not support CMsiStringNull). Prints
// the string in quotes, no newline.) If fRefCount is true, will dump
// the refcount at the end in parenthesis.
void DumpMsiString(ULONG64 pStringObj, bool fRefCount)
{
	// grab the length (number of characters)
	UINT uiCount = 0;
	if (0 != (GetFieldData(pStringObj, szStringBaseType, "m_cchLen", sizeof(uiCount), &uiCount)))
	{
		ErrorReadingMembers(szStringType, pStringObj);
		return;
	}

	// retrieve pontier to buffer containing actual string
	//!! future - fix to support ANSI chars
	ULONG ulOffset;
	if (0 != (GetFieldOffset((LPSTR)szStringType, "m_szData", &ulOffset)))
	{
		ErrorReadingMembers(szStringType, pStringObj);
		return;
	}
			 
	// increment for terminating null
	uiCount++;

	// allocate memory for string
	WCHAR *strData = new WCHAR[uiCount];
	if (!strData)
	{
		dprintf("Unable to allocate memory in debugger extension.\n", pStringObj);
		return;
	}

	// load the string into the buffer
	ULONG cbRead = 0;
	if (0 == ReadMemory(pStringObj+ulOffset, (PVOID)strData, uiCount*sizeof(WCHAR), &cbRead))
	{
		ErrorReadingMembers(szStringType, pStringObj);
		return;
	}

	// dump the string in quotes
	dprintf("\"%ws\"", strData);
	delete[] strData;

	// if the refcount needs to be dumped, do so in parenthesis
	if (fRefCount)
	{
		DWORD iRefCount = 0;
		if (0 != (GetFieldData(pStringObj, szStringBaseType, "m_iRefCnt", sizeof(iRefCount), &iRefCount)))
		{
			ErrorReadingMembers(szStringType, pStringObj);
			return;
		}
		dprintf(" (%d)", iRefCount);
	}
}


///////////////////////////////////////////////////////////////////////
// dumps a CMsiRecord object. pInAddress MUST be a IMsiRecord* or a 
// PMsiRecord. Prints the record in a multi-line format, provides
// interface pointers and values for strings (but not refcounts)
void DumpMsiRecord(ULONG64 pInAddress)
{
	if (!pInAddress)
	{
		return;
	}

	// pRecordObj contains the IMsiRecord* to dump. If pInAddress is
	// a PMsiRecord, this is not the same.
	ULONG64 pRecordObj = ValidateRecordPointer(pInAddress);
	if (!pRecordObj)
		return;

	// get field count from record object
	UINT uiFields = 0;
	if (0 != (GetFieldData(pRecordObj, szRecordType, "m_cParam", sizeof(uiFields), &uiFields)))
	{
		ErrorReadingMembers(szRecordType, pRecordObj);
		return;
	}

	dprintf(" - %d fields.\n", uiFields);

	ULONG ulDataOffset = 0;
	if (0 != (GetFieldOffset((LPSTR)szRecordType, "m_Field", &ulDataOffset)))
	{
		ErrorReadingMembers(szRecordType, pRecordObj);
		return;
	}

	// obtain static "integer" member for determining if a data pointer is an integer
    ULONG64 pStaticInteger = GetExpression((PCSTR)szFieldDataStaticInteger);
	if (0 != ReadPtr(pStaticInteger, &pStaticInteger))
	{
		ErrorReadingMembers(szRecordType, pRecordObj);
		return;
	}

	// obtain static "CMsiStream::QI" pointer for determining if a data pointer is a stream
    ULONG64 pStreamQI = GetExpression((PCSTR)szStreamQI);
	if (0 != ReadPtr(pStreamQI, &pStreamQI))
	{
		// **************************************
		dprintf("Unable to read MsiStream vtable. Verify symbols.\n");
		return;
	}
		
	// get the size of each FieldData object.
	UINT uiFieldDataSize = GetTypeSize(szFieldDataType);

	// obtain the starting point of the field array by adding the offset of field [0] to the
	// base object pointer
	ULONG64 pDataAddress = pRecordObj+ulDataOffset;

	// loop over all fields. Field 0 is always present and is not part of the field count.
	for (unsigned int iField=0; iField <= uiFields; iField++)
	{
		// print field number
		dprintf("%2d: ", iField);

		// data pointer is null, pointer to static integer, or an IMsiData pointer
		ULONG64 pDataPtr = 0;
		if (0 != (GetFieldData(pDataAddress, szFieldDataType, "m_piData", sizeof(pDataPtr), &pDataPtr)))
		{
			ErrorReadingMembers(szFieldDataType, pDataAddress);
			return;
		}

		if (pDataPtr == 0)
		{
			dprintf("(null)");
		}
		else if (pDataPtr == pStaticInteger)
		{
			// if pointer to static integer, m_iData of the object cast to a FieldInteger type contains the 
			// actual integer
			UINT uiValue;
			if (0 != (GetFieldData(pDataAddress, szFieldIntegerType, "m_iData", sizeof(uiValue), &uiValue)))
			{
				ErrorReadingMembers(szFieldIntegerType, pDataAddress);
				return;
			}
			dprintf("%d", uiValue);
		}
		else
		{
			// print data pointer
			dprintf("(");
			DumpPrettyPointer(pDataPtr);
			dprintf(") \"");
	
			// to determine if this is a string or stream compare the QI pointers in the vtable
			// against CMsiString::QI
			ULONG64 pQIPtr = 0;

			// derefence vtable to get QI pointer
			ReadPtr(pDataPtr, &pQIPtr);

			// dump string or binary stream
			if (pQIPtr != pStreamQI)
				DumpMsiString(pDataPtr, false);
			else
				dprintf("Binary Stream");
			dprintf("\"");
		}
		dprintf("\n", iField);

		// increment address to next data object
		pDataAddress += uiFieldDataSize;
	}
}

///////////////////////////////////////////////////////////////////////
// entry point for raw record dump, given an IMsiRecord* or CMsiRecord*
DECLARE_API( msirec )
{
	if (!args[0])
		return;

	ULONG64 ulAddress = GetExpression(args);
	if (!ulAddress)
		return;

	DumpMsiRecord(ulAddress);
}

///////////////////////////////////////////////////////////////////////
// dumps the list of all open handles, or details on a specific handle.
// the handle must be specified in decimal in the args.
DECLARE_API( msihandle )
{
    ULONG64 pListHead = 0;
	ULONG64 pHandleObj = 0;

	DWORD dwDesiredHandle = 0;

	// if an argument is given, it must be the handle number
	if (args && *args)
	{
		dwDesiredHandle = atoi(args);
	}


	// get the pointer to the list head
    pListHead = GetExpression((PCSTR)szStaticHandleListHead);
	if (!pListHead)
	{
		dprintf("Unable to obtain MSIHANDLE list pointer.");
		return;
	}

	if (0 != ReadPtr(pListHead, &pHandleObj))
	{
		dprintf("Unable to obtain MSIHANDLE list.");
		return;
	}

	// loop through the entire handle list
	while (pHandleObj)
	{
		// retrieve the handle number of this object
		UINT uiHandle = 0;
		if (0 != (GetFieldData(pHandleObj, szHandleType, "m_h", sizeof(uiHandle), &uiHandle)))
		{
			ErrorReadingMembers(szHandleType, pHandleObj);
			return;
		}
		
		// if dumping all handles or if this handle matches the requested handle, provide 
		// detailed information
		if (dwDesiredHandle == 0 || dwDesiredHandle == uiHandle)
		{
			// grab IID of this handle object
			int iid = 0;
			if (0 != GetFieldData(pHandleObj, szHandleType, "m_iid", sizeof(iid), &iid))
			{
				ErrorReadingMembers(szHandleType, pHandleObj);
				return;
			}
	
			// grab IUnknown of this handle object
			ULONG64 pUnk = (ULONG64)0;
			if (0 != GetFieldData(pHandleObj, szHandleType, "m_piunk", sizeof(pUnk), &pUnk))
			{
				ErrorReadingMembers(szHandleType, pHandleObj);
				return;
			}
	
			// determine the UI string of this IID
			PUCHAR szTypeStr = NULL;
			switch (iid)
			{
			case iidMsiRecord:   szTypeStr = (PUCHAR)"Record"; break;
			case iidMsiView:     szTypeStr = (PUCHAR)"View"; break;
			case iidMsiDatabase: szTypeStr = (PUCHAR)"Database"; break;
			case iidMsiEngine:   szTypeStr = (PUCHAR)"Engine"; break;
			default:             szTypeStr = (PUCHAR)"Other"; break;
			}
	
			// dump handle interface information
			dprintf("%d: ", uiHandle);
			DumpPrettyPointer(pUnk);
            dprintf(" (%s)\n",szTypeStr);

			// if this is the handle being queried, dump detailed information
			if (dwDesiredHandle == uiHandle)
			{
				if (iid == iidMsiRecord)
					DumpMsiRecord(pUnk);
				break;
			}
		}

		// move to the next handle object
		if (0 != GetFieldData(pHandleObj, szHandleType, "m_Next", sizeof(ULONG64), (PVOID)&pHandleObj))
		{
			ErrorReadingMembers(szHandleType, pHandleObj);
			return;
		}
	}

	return;
}

///////////////////////////////////////////////////////////////////////
// dumps a msistring, including refcount information. Can smart-dump
// MsiString, PMsiString, and IMsiString
DECLARE_API( msistring )
{
	ULONG64 pInAddress = GetExpression(args);

   	// determine if the address points to an IMsiString, PMsiString, or MsiString
    ULONG64 pStringObj = ValidateStringPointer(pInAddress);
	if (!pStringObj)
		return;

	// now dump the actual string object
	DumpMsiString(pStringObj, true);
	dprintf("\n");
}


///////////////////////////////////////////////////////////////////////
// locates the string index of a string contained in the database
DECLARE_API( msiindextostring )
{
	// parse into database address and index
	ULONG64 pInAddress = GetExpression(args);
	char* pIndex = (char*)args;
	while ((*pIndex) && (*pIndex != ' '))
		pIndex++;

	// verify that the string is not null
	if (!*pIndex)
	{
		dprintf("Usage:\n\tmsiindextostring <database> <index>\n");
		return;
	}

	int iIndex = static_cast<int>(GetExpression(pIndex));
	ULONG64 pDatabase = ValidateDatabasePointer(pInAddress);
	if (!pDatabase)
		return;

	WCHAR *wzString = NULL;
	unsigned int cchString = 0;
	if (RetrieveStringFromIndex(pDatabase, iIndex, &wzString, cchString))
	{
		dprintf("String: %ws\n", wzString);
		delete[] wzString;
	}
}


///////////////////////////////////////////////////////////////////////
// locates the string index of a string contained in the database
DECLARE_API( msistringtoindex )
{
	if (!args || !*args)
	{
		return;
	}

	// parse into database address and string
	ULONG64 pInAddress = GetExpression(args);
	char* pString = (char*)args;
	while ((*pString) && (*pString != ' '))
		pString++;

	while ((*pString) && (*pString == ' '))
		pString++;

	// verify that the string is not null
	if (!*pString)
	{
		dprintf("Usage:\n\tmsistringtoindex <database> <string>\n");
		return;
	}

	// convert the incoming string to unicode
	WCHAR wzString[513];
	int iLen = MultiByteToWideChar(CP_ACP, 0, pString, -1, wzString, 512);
	if (iLen == 0)
	{
		dprintf("Unable to lookup string (failed conversion to unicode or string too long).\n");
		return; 
	}

	// validate that the database pointer is valid.
	ULONG64 pDatabaseObj = ValidateDatabasePointer(pInAddress);
	if (!pDatabaseObj)
		return;

	int iIndex = 0;
	if (!FindStringIndex(pDatabaseObj, wzString, iIndex))
		dprintf("String Not Found\n");
	else
		dprintf("String Index: %d\n", iIndex);

	return;
}


void PrintState(int iCellValue)
{
	switch (iCellValue)
	{
	case 0: dprintf("Absent"); break;
	case 1: dprintf("Local"); break;
	case 2: dprintf("Source"); break;
	case 3: dprintf("Reinstall"); break;
	case 4: dprintf("Advertise"); break;
	case 5: dprintf("Current");	break;
	case 6: dprintf("FileAbsent"); break;
	case 7: dprintf("LocalAll"); break;
	case 8: dprintf("SourceAll"); break;
	case 9: dprintf("ReinstallLocal"); break;
	case 10: dprintf("ReinstallSource"); break;
	case 11: dprintf("HKCRAbsent"); break;
	case 12: dprintf("HKCRFileAbsent"); break;
	case 13: dprintf("Null"); break;
	default: dprintf("<Unknown>"); break;
	}
}


///////////////////////////////////////////////////////////////////////
// displays the component states and actions
DECLARE_API( msicompstate )
{
	if (!args || !*args)
	{
		return;
	}

	ULONG64 pInAddress = GetExpression(args);
	char* pCompName = (char*)args;
	while ((*pCompName) && (*pCompName != ' '))
		pCompName++;

	while ((*pCompName) && (*pCompName == ' '))
		pCompName++;

	// convert the incoming string to unicode
	WCHAR wzCompName[513];
	int iLen = MultiByteToWideChar(CP_ACP, 0, pCompName, -1, wzCompName, 512);
	if (iLen == 0)
	{
		dprintf("Unable to lookup table (failed conversion to unicode or component name too long).\n");
		return; 
	}

	// validate that the database pointer is valid.
	ULONG64 pEngineObj = ValidateEnginePointer(pInAddress);
	if (!pEngineObj)
		return;

	dprintf("\n");

	// data pointer is null, pointer to static integer, or an IMsiData pointer
	ULONG64 pDatabase = 0;
	if (0 != (GetFieldData(pEngineObj, szEngineType, "m_piDatabase", sizeof(pDatabase), &pDatabase)))
	{
		ErrorReadingMembers(szEngineType, pEngineObj);
		return;
	}

	// locate the table pointer
	int iIndex = 0;
	if (!FindStringIndex(pDatabase, wzCompName, iIndex))
	{
		dprintf("%ws not found.\n", wzCompName);
	}

	// retrieve the table pointer from the database
	ULONG64 pTable = RetrieveTablePointerFromDatabase(pDatabase, L"Component");

	if (!pTable)
		return;

	// find the row
	ULONG64 pComponentRow = RetrieveMatchingRowAddressFromTable(pTable, iIndex);
	if (!pComponentRow)
	{
		dprintf("No such component exists.\n");
		return;
	}

	// retrieve column indexes from the engine
	int iColInstalled = 0;
	int iColTrueInstalled = 0;
	int iColLegacy = 0;
	int iColAction = 0;
	int iColRequest = 0;
	int iColID = 0;
	int iColKeyPath = 0;
	if ((0 != (GetFieldData(pEngineObj, szEngineType, "m_colComponentInstalled", sizeof(iColInstalled), &iColInstalled))) ||
		(0 != (GetFieldData(pEngineObj, szEngineType, "m_colComponentActionRequest", sizeof(iColRequest), &iColRequest))) ||
		(0 != (GetFieldData(pEngineObj, szEngineType, "m_colComponentAction", sizeof(iColAction), &iColAction))) ||
		(0 != (GetFieldData(pEngineObj, szEngineType, "m_colComponentLegacyFileExisted", sizeof(iColLegacy), &iColLegacy))) ||
		(0 != (GetFieldData(pEngineObj, szEngineType, "m_colComponentTrueInstallState", sizeof(iColTrueInstalled), &iColTrueInstalled))) ||
		(0 != (GetFieldData(pEngineObj, szEngineType, "m_colComponentID", sizeof(iColID), &iColID))) ||
		(0 != (GetFieldData(pEngineObj, szEngineType, "m_colComponentKeyPath", sizeof(iColKeyPath), &iColKeyPath))))
	{
		ErrorReadingMembers(szEngineType, pEngineObj);
		return;
	}

	// decode the column values and print the results
	int iCellValue=0;
	ULONG cbRead = 0;
	WCHAR* wzString = NULL;
	unsigned int cchString = 0;

	dprintf("Component: %ws\n", wzCompName);

	// ComponentID
	ReadMemory(pComponentRow+(sizeof(int)*iColID), &iCellValue, sizeof(iCellValue), &cbRead);
	if (RetrieveStringFromIndex(pDatabase, iCellValue, &wzString, cchString))
	{
		dprintf("Component ID: %ws\n", wzString);
		delete[] wzString;
	}
	else
	{
		dprintf("Component ID: <unknown>\n");
	}

	// keypath
	ReadMemory(pComponentRow+(sizeof(int)*iColKeyPath), &iCellValue, sizeof(iCellValue), &cbRead);
	if (RetrieveStringFromIndex(pDatabase, iCellValue, &wzString, cchString))
	{
		dprintf("KeyPath: %ws\n", wzString);
		delete[] wzString;
	}
	else
	{
		dprintf("KeyPath: <unknown>\n");
	}

	ReadMemory(pComponentRow+(sizeof(int)*iColInstalled), &iCellValue, sizeof(iCellValue), &cbRead);
	dprintf("Installed: ");
	PrintState(iCellValue & ~iMsiNullInteger);

	ReadMemory(pComponentRow+(sizeof(int)*iColTrueInstalled), &iCellValue, sizeof(iCellValue), &cbRead);
	dprintf("\nTrue Installed: ");
	PrintState(iCellValue & ~iMsiNullInteger);

	ReadMemory(pComponentRow+(sizeof(int)*iColLegacy), &iCellValue, sizeof(iCellValue), &cbRead);
	dprintf("\nLegacy Exist: %s", iCellValue ? "Yes" : "No");

	ReadMemory(pComponentRow+(sizeof(int)*iColRequest), &iCellValue, sizeof(iCellValue), &cbRead);
	dprintf("\nRequest: ");
	PrintState(iCellValue & ~iMsiNullInteger);

	ReadMemory(pComponentRow+(sizeof(int)*iColAction), &iCellValue, sizeof(iCellValue), &cbRead);
	dprintf("\nAction: ");
	PrintState(iCellValue & ~iMsiNullInteger);
	dprintf("\n\n");
}


DECLARE_API( help )
{
    dprintf("help                                   - Displays this list\n" );
    dprintf("msihandle [<handle>]                   - Displays the MSIHANDLE list or a specific MSIHANDLE\n" );
    dprintf("msirec <address>                       - Displays an IMsiRecord or PMsiRecord\n" );
    dprintf("msistring <address>                    - Displays an IMsiString*, PMsiString, or MsiString\n" );
    dprintf("msistringtoindex <database> <string>   - Retrieve the database string index for a specified text string.\n" );
    dprintf("msiindextostring <database> <index>    - Displays the text of a specified database string.\n" );
    dprintf("msicompstate <engine> <componentkey>   - Display the state and actions for the component.\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinfo\sources.inc ===
TARGETNAME=MsiInfo
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

USE_LIBCMT=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\msi.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\OLE32.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_NOLIBS=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msiinfo.cpp \
	..\msiinfo.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinst\debug.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

	debug.h

Abstract:

	Debugging support for msiinst

Author:

	Rahul Thombre (RahulTh)	10/5/2000

Revision History:

	10/5/2000	RahulTh			Created this module.

--*/

#ifndef _DEBUG_H_789DC87B_43BA_44A0_9B8A_9F15F0FE7E4B
#define _DEBUG_H_789DC87B_43BA_44A0_9B8A_9F15F0FE7E4B

// Debug levels
#define DL_NONE		0x00000000
#define DL_VERBOSE	0x00000001

// Global variables
extern DWORD	gDebugLevel;

// Debug support functions
void InitDebugSupport();
void _DebugMsg(IN LPCTSTR szFormat, ...);

// Debug Macros
#if DBG
#define DebugMsg(x)	_DebugMsg x
#else
#define DebugMsg(x) if (gDebugLevel != DL_NONE) _DebugMsg x
#endif

#endif	//_DEBUG_H_789DC87B_43BA_44A0_9B8A_9F15F0FE7E4B
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinfo\msiinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2001
//
//  File:       msiinfo.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include <stdio.h>
#include <wtypes.h> // Needed for OLECHAR definitions
#include <objidl.h> // Needed for IStorage definitions
#include "MsiQuery.h"
#include "MsiDefs.h"
#include "strsafe.h"
#define W32
#define OLE
#define MSI

//!! Need to fix warnings and remove pragma
#pragma warning(disable : 4242) // conversion from int to unsigned short

//TCHAR rgszPropChar[] = TEXT("?ITSAKCLUVEPNWMFX?PR");
//////////////////////////     01234567890123456789

TCHAR rgszCmdOptions[]= TEXT("ictjakoplvesrqgwh?nudb");
//////////////////////////    0123456789012345678901

TCHAR* szHelp =
TEXT("Copyright (C) Microsoft Corporation.  All rights reserved.\n\n++MsiInfo.exe Command Line Syntax++\n\
MsiInfo.exe {database} --> To Display Summary Info Properties\n\
MsiInfo.exe {database} Options.... --> To Set Summary Info Properties\n\
++MsiInfo.exe Options++\n\
PID_DICTIONARY   - /I {value}\n\
PID_CODEPAGE     - /C {value}\n\
PID_TITLE        - /T {value}\n\
PID_SUBJECT      - /J {value}\n\
PID_AUTHOR       - /A {value}\n\
PID_KEYWORDS     - /K {value}\n\
PID_COMMENTS     - /O {value}\n\
PID_TEMPLATE     - /P {value}\n\
PID_LASTAUTHOR   - /L {value}\n\
PID_REVNUMBER    - /V {value}\n\
PID_EDITTIME     - /E {value}\n\
PID_LASTPRINTED  - /S {value}\n\
PID_CREATE_DTM   - /R {value}\n\
PID_LASTSAVE_DTM - /Q {value}\n\
PID_PAGECOUNT    - /G {value}\n\
PID_WORDCOUNT    - /W {value}\n\
PID_CHARCOUNT    - /H {value}\n\
PID_THUMBNAIL    - NOT SUPPORTED\n\
PID_APPNAME      - /N {value}\n\
PID_SECURITY     - /U {value}\n\
Validate String Pool - [/B] /D  (use /B to display the string pool)");

TCHAR* rgszPropName[] = {
/* PID_DICTIONARY    0 */ TEXT("Dictionary"),
/* PID_CODEPAGE      1 */ TEXT("Codepage"),
/* PID_TITLE         2 */ TEXT("Title"),
/* PID_SUBJECT       3 */ TEXT("Subject"),
/* PID_AUTHOR        4 */ TEXT("Author"),
/* PID_KEYWORDS      5 */ TEXT("Keywords"),
/* PID_COMMENTS      6 */ TEXT("Comments"),
/* PID_TEMPLATE      7 */ TEXT("Template(MSI CPU,LangIDs)"),
/* PID_LASTAUTHOR    8 */ TEXT("SavedBy"),
/* PID_REVNUMBER     9 */ TEXT("Revision"),
/* PID_EDITTIME     10 */ TEXT("EditTime"),
/* PID_LASTPRINTED  11 */ TEXT("Printed"),
/* PID_CREATE_DTM   12 */ TEXT("Created"), 
/* PID_LASTSAVE_DTM 13 */ TEXT("LastSaved"),
/* PID_PAGECOUNT    14 */ TEXT("Pages(MSI Version Used)"),
/* PID_WORDCOUNT    15 */ TEXT("Words(MSI Source Type)"),
/* PID_CHARCOUNT    16 */ TEXT("Characters(MSI Transform)"),
/* PID_THUMBNAIL    17 */ TEXT("Thumbnail"), // Not supported
/* PID_APPNAME      18 */ TEXT("Application"),
/* PID_SECURITY     19 */ TEXT("Security")
};
const int cStandardProperties = sizeof(rgszPropName)/sizeof(TCHAR*);

//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

const WCHAR szwStringPool1[]     = L"_StringPool"; 
const WCHAR szwStringData1[]     = L"_StringData";
const WCHAR szwStringPoolX[]     = {0xF040,0xE73F,0xED77,0xEC6c,0xE66A,0xECB2,0xF02F,0};
const WCHAR szwStringDataX[]     = {0xF040,0xE73F,0xED77,0xEC6c,0xE36A,0xEDE4,0xF024,0};
const WCHAR szwStringPool2[]     = {0x4840,0x3F3F,0x4577,0x446C,0x3E6A,0x44B2,0x482F,0};
const WCHAR szwStringData2[]     = {0x4840,0x3F3F,0x4577,0x446C,0x3B6A,0x45E4,0x4824,0};

const TCHAR szTableCatalog[]     = TEXT("_Tables");
const TCHAR szColumnCatalog[]    = TEXT("_Columns");
const TCHAR szSummaryInfo[]      = TEXT("\005SummaryInformation");
const TCHAR szTransformCatalog[] = TEXT("_Transforms");

const int icdShort      = 1 << 10; // 16-bit integer, or string index
const int icdObject     = 1 << 11; // IMsiData pointer for temp. column, stream for persistent column
const int icdNullable   = 1 << 12; // column will accept null values
const int icdPrimaryKey = 1 << 13; // column is component of primary key
const int icdLong     = 0; // !Object && !Short
const int icdString   = icdObject+icdShort;
const int icdTypeMask = icdObject+icdShort;
const int iMsiNullInteger  = 0x80000000L;  // reserved integer value
const int iIntegerDataOffset = iMsiNullInteger;  // integer table data offset

const int ictTable = 1;
const int ictColumn = 2;
const int ictOrder = 3;
const int ictType = 4;

OLECHAR* g_szwStringPool;
OLECHAR* g_szwStringData;
OLECHAR* g_szwSummaryInfo;
OLECHAR* g_szwTableCatalog;
OLECHAR* g_szwColumnCatalog;
int      g_iCodePage;

TCHAR g_rgchBuffer[65535];
BOOL g_fDumpStringPool = FALSE;
#ifdef DEBUG
BOOL g_fDebugDump = FALSE;
#endif

const unsigned int cchMaxGUIDLen = 39;
const int cchMaxStringDisplay = 44;
const int cchMaxStringBuffer = cchMaxStringDisplay + 3 + 1; // string...
const int cchLimitStringBuffer = (cchMaxStringBuffer * 2) / sizeof(TCHAR);

//________________________________________________________________________________
//
// Structures and enums
//________________________________________________________________________________

struct StringEntry
{
        int iRefCnt;
        unsigned char* sz;      // String
        StringEntry() : iRefCnt(0), sz(0) {}
};

enum iceDef
{
        iceNone   = 0,  // No Definition
        iceLong   = 1,  // Long Integer
        iceShort  = 2,  // Short Integer
        iceStream = 3,  // Stream
        iceString = 4   // String
};

struct ColumnEntry
{
        int  nTable;      // Index Into TableEntry Array
        BOOL fPrimaryKey; // Whether Col Is A Primary Key
        BOOL fNullable;   // Whether Col Is Nullable
        char* szName;     // Name Of Col
        iceDef iceType;   // Col Type
        int iPosition;    // column order
        ColumnEntry() : szName(0), nTable(0), iceType(iceNone), fPrimaryKey(FALSE), fNullable(FALSE) {}
};

struct TableEntry
{
        char* szName;          // Name Of Table
        int cColumns;          // Number Of Columns In Table
        int cPrimaryKeys;      // Number Of Primary Keys
        iceDef iceColDefs[32]; // Array of Column Definitions
        TableEntry() : szName(0), cColumns(0), cPrimaryKeys(0) 
                                                {memset(iceColDefs, iceNone, sizeof(iceColDefs));}
};



typedef int (*FCommandProcessor)(const TCHAR* szOption, MSIHANDLE hSummaryInfo, UINT uiProperty, BOOL fRemove);

int SetStringProperty(const TCHAR* szValue, MSIHANDLE hSummaryInfo, UINT uiProperty, BOOL fRemove);
int SetFileTimeProperty(const TCHAR* szValue, MSIHANDLE hSummaryInfo, UINT uiProperty, BOOL fRemove);
int SetIntegerProperty(const TCHAR* szValue, MSIHANDLE hSummaryInfo, UINT uiProperty, BOOL fRemove);
int SetCodePageProperty(const TCHAR* szValue, MSIHANDLE hSummaryInfo, UINT uiProperty, BOOL fRemove);
int DoNothing(const TCHAR* szValue, MSIHANDLE hSummaryInfo, UINT uiProperty, BOOL fRemove);
int ValidateStringPool(const TCHAR* szDatabase, MSIHANDLE hDummy, UINT iDummy, BOOL fDummy);
void AnsiToWide(LPCTSTR sz, OLECHAR*& szw);
void WideToAnsi(const OLECHAR* szw, char*& sz);
void LimitString(const unsigned char* sz, WCHAR* szw);
bool DecodeStringPool(IStorage& riStorage, StringEntry*& rgStrings, int& iMaxStringId, int& cbStringId);
void FillDatabaseCatalogArrays(IStorage& riDatabaseStg, TableEntry*& rgTables, int& cTables,
                                                          ColumnEntry*& rgColumns, int& cColumns, StringEntry* rgStrings, int iMaxStringId, int cbStringId, bool fRawStreamNames);
void Display(LPCTSTR szMessage);
void DisplaySumInfoStr(UINT uiCodePage, LPCTSTR szMessage);
int SetDumpStringPoolOption(const TCHAR*, MSIHANDLE, UINT, BOOL);
void ProcessTableRefCounts(IStorage& riStorage, StringEntry* rgStrings, TableEntry* rgTables,int iMaxStringId, int cTables, int cbStringId, bool fRawStreamNames);
DWORD CheckStringPoolRefCounts(StringEntry* rgStrings, int iMaxStringId);

int rgiProperty[]={
/* PID_DICTIONARY    i */  0,
/* PID_CODEPAGE      c */  1,
/* PID_TITLE         t */  2,
/* PID_SUBJECT       j */  3,
/* PID_AUTHOR        a */  4,
/* PID_KEYWORDS      k */  5,
/* PID_COMMENTS      o */  6,
/* PID_TEMPLATE      p */  7,
/* PID_LASTAUTHOR    l */  8,
/* PID_REVNUMBER     v */  9,
/* PID_EDITTIME      e */ 10,
/* PID_LASTPRINTED   s */ 11,
/* PID_CREATE_DTM    r */ 12, 
/* PID_LASTSAVE_DTM  q */ 13,
/* PID_PAGECOUNT     g */ 14,
/* PID_WORDCOUNT     w */ 15,
/* PID_CHARCOUNT     h */ 16,
/* PID_THUMBNAIL     ? */ 17,
/* PID_APPNAME       n */ 18,
/* PID_SECURITY      u */ 19
};

TCHAR rgchPropertySwitch[] ={TEXT('i'),TEXT('c'),TEXT('t'),TEXT('j'),TEXT('a'),TEXT('k'),TEXT('o'),TEXT('p'),TEXT('l'),TEXT('v'),TEXT('e'),TEXT('s'),TEXT('r'),TEXT('q'),TEXT('g'),TEXT('w'),TEXT('h'),TEXT('?'),TEXT('n'),TEXT('u'), TEXT('d')};

FCommandProcessor rgCommands[] = 
{
/*  0 */ SetStringProperty,
/*  1 */ SetCodePageProperty,
/*  2 */ SetStringProperty,
/*  3 */        SetStringProperty,
/*  4 */        SetStringProperty,
/*  5 */        SetStringProperty,
/*  6 */        SetStringProperty,
/*  7 */        SetStringProperty,
/*  8 */        SetStringProperty,
/*  9 */        SetStringProperty,
/* 10 */        SetFileTimeProperty,
/* 11 */        SetFileTimeProperty,
/* 12 */        SetFileTimeProperty,
/* 13 */        SetFileTimeProperty,
/* 14 */        SetIntegerProperty,
/* 15 */        SetIntegerProperty,
/* 16 */        SetIntegerProperty,
/* 17 */        DoNothing,
/* 18 */        SetStringProperty,
/* 19 */        SetIntegerProperty,
/* 20 */ ValidateStringPool,
/* 21 */ SetDumpStringPoolOption,
};

const int cchDisplayBuf = 4096;
HANDLE g_hStdOut;


//_____________________________________________________________________________________________________
//
// Error handling routines
//_____________________________________________________________________________________________________

void ErrorExit(UINT iError, LPCTSTR szMessage)
{
        if (szMessage)
        {
                int cbOut;
                TCHAR szBuffer[256];  // errors only, not used for display output
                if (iError == 0)
                        cbOut = lstrlen(szMessage);
                else
                {
                        LPCTSTR szTemplate = (iError & 0x80000000L)
                                                                                ? TEXT("Error 0x%X. %s\n")
                                                                                : TEXT("Error %i. %s\n");
                        cbOut = _stprintf(szBuffer, szTemplate, iError, szMessage);
                        szMessage = szBuffer;
                }
                if (g_hStdOut)
                {
#ifdef UNICODE
                        char rgchTemp[cchDisplayBuf];
                        if (W32::GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
                        {
                                W32::WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
                                szMessage = (LPCWSTR)rgchTemp;
                        }
                        else
                                cbOut *= sizeof(TCHAR);   // write Unicode if not console device
#endif // UNICODE
                        DWORD cbWritten;
                        W32::WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
                }
                else
                        W32::MessageBox(0, szMessage, W32::GetCommandLine(), MB_OK);
        }
        MSI::MsiCloseAllHandles();
        OLE::CoUninitialize();
        W32::ExitProcess(iError);
}

void CheckError(UINT iError, LPCTSTR szMessage)
{
        if (iError != ERROR_SUCCESS)
                ErrorExit(iError, szMessage);
}

void AnsiToWide(LPCTSTR sz, OLECHAR*& szw)
{
#ifdef UNICODE
        int cchWide = lstrlen(sz);
        szw = new OLECHAR[cchWide + 1];
        lstrcpy(szw, sz);
#else
        int cchWide = W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, szw, 0);
        szw = new OLECHAR[cchWide];
        W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, szw, cchWide);
#endif // UNICODE
}

void WideToAnsi(const OLECHAR* szw, char*& sz)
{
        int cchAnsi = W32::WideCharToMultiByte(CP_ACP, 0, szw, -1, 0, 0, 0, 0);
        sz = new char[cchAnsi];
        W32::WideCharToMultiByte(CP_ACP, 0, szw, -1, sz, cchAnsi, 0, 0);
}               

void LimitString(const unsigned char* szIn, TCHAR* szOut)  // szOut must be sized: cchLimitStringBuffer
{
        WCHAR rgwBuf[cchMaxStringBuffer * 2];
        if (szIn == 0)
        {
                *szOut = 0;
                return;
        }
        int cb = strlen((const char*)szIn);  //!! strings could have embedded nulls
        if (cb > cchMaxStringBuffer * 2 - 2)  // could be all DBCS chars
                cb = cchMaxStringBuffer * 2 - 2;
        int cchWide = W32::MultiByteToWideChar(g_iCodePage, 0, (const char*)szIn, cb, rgwBuf, cchMaxStringBuffer * 2);
        if (cchWide >= cchMaxStringBuffer)
        {
                memcpy((char*)(rgwBuf + cchMaxStringDisplay), (char*)L"...", 8);
                cchWide = cchMaxStringDisplay + 3;
        }
        else
                *(rgwBuf + cchWide) = 0;
#ifdef UNICODE
        lstrcpy(szOut, rgwBuf);
#else
        W32::WideCharToMultiByte(g_iCodePage, 0, rgwBuf, cchWide + 1, szOut, cchLimitStringBuffer, 0, 0);
#endif
}

int SetDumpStringPoolOption(const TCHAR*, MSIHANDLE, UINT, BOOL)
{
        g_fDumpStringPool = TRUE;
        return ERROR_SUCCESS;
}

UINT DisplaySummaryInformation(TCHAR* szDatabase)
///////////////////////////////////////////////////////////////////////
// DisplaySummaryInformation:
//      enumerates and displays the summary information properties
//      in the provided file
//
//  Arguments:
//      szDatabase -- database, transform, or patch to display
//
//  Returns:
//      - ERROR_SUCCESS on success
//      - ERROR_INVALID_PARAMETER or ERROR_FUNCTION_FAILED on failure
////////////////////////////////////////////////////////////////////////
{
	//
	// validate arguments
	//

	if (!szDatabase || !*szDatabase)
	{
		return ERROR_INVALID_PARAMETER;
	}

	//
	// output CLSID of storage
	//

	bool fOLEInitialized = false;

	HRESULT hrRet = OLE::CoInitialize(0);
	if (SUCCEEDED(hrRet))
		fOLEInitialized = true;
	else if (RPC_E_CHANGED_MODE != hrRet)
	{
		return ERROR_FUNCTION_FAILED;
	}

	IStorage* piStorage = NULL;
	OLECHAR* szwFile = NULL;
	int cchWide = 0;

#ifdef UNICODE
	cchWide = lstrlenW(szDatabase) + 1;
	szwFile = new OLECHAR[cchWide];
	if (!szwFile)
	{
		return ERROR_OUTOFMEMORY;
	}
	ZeroMemory(szwFile, sizeof(szwFile));
	if (FAILED(StringCchCopy(szwFile, cchWide, szDatabase)))
	{
		delete [] szwFile;
		return ERROR_FUNCTION_FAILED;
	}
#else // !UNICODE
	cchWide = W32::MultiByteToWideChar(CP_ACP, 0, szDatabase, -1, NULL, 0);
	szwFile = new OLECHAR[cchWide];
	if (!szwFile)
	{
		return ERROR_OUTOFMEMORY;
	}
	ZeroMemory(szwFile, sizeof(szwFile));
	if (0 == W32::MultiByteToWideChar(CP_ACP, 0, szDatabase, -1, szwFile, cchWide))
	{
		delete [] szwFile;
		return ERROR_FUNCTION_FAILED;
	}
#endif // UNICODE

	HRESULT hRes = OLE::StgOpenStorage(szwFile, (IStorage*)0, STGM_READ|STGM_SHARE_DENY_WRITE, (SNB)0, (DWORD)0, &piStorage);
	if (FAILED(hRes))
	{
		delete [] szwFile;
		ErrorExit(hRes, TEXT("Could not open file as a storage file"));
	}

	if (piStorage)
	{
		STATSTG sStat;
		hRes = piStorage->Stat(&sStat, STATFLAG_NONAME);
		if (FAILED(hRes))
		{
			delete [] szwFile;
			ErrorExit(hRes, TEXT("Stat failed on storage"));
		}
		piStorage->Release();
		piStorage = NULL;

		OLECHAR rgwchGUID[cchMaxGUIDLen] = {0};
		if (0 == OLE::StringFromGUID2(sStat.clsid, rgwchGUID, cchMaxGUIDLen))
		{
			delete [] szwFile;
			return ERROR_FUNCTION_FAILED;
		}

		TCHAR rgchOutputGUID[cchMaxGUIDLen] = {0};
#ifdef UNICODE
		if (FAILED(StringCchCopy(rgchOutputGUID, cchMaxGUIDLen, rgwchGUID)))
		{
			delete [] szwFile;
			return ERROR_FUNCTION_FAILED;
		}
#else // !UNICODE
		if (0 == W32::WideCharToMultiByte(CP_ACP, 0, rgwchGUID, cchMaxGUIDLen, rgchOutputGUID, cchMaxGUIDLen, 0, 0))
		{
			delete [] szwFile;
			return ERROR_FUNCTION_FAILED;
		}
#endif // UNICODE

		// Output Storage CLSID
		TCHAR szOutput[MAX_PATH] = {0};
		if (FAILED(StringCbPrintf(szOutput, sizeof(szOutput), TEXT("\r\nClass Id for the MSI storage is %s\r\n\r\n"), rgchOutputGUID)))
		{
			delete [] szwFile;
			return ERROR_FUNCTION_FAILED;
		}
		Display(szOutput);

	}

	if (szwFile)
	{
		delete [] szwFile;
		szwFile = NULL;
	}

	//
	// read _SummaryInformation stream
	//

	PMSIHANDLE hSummaryInfo = 0;
	CheckError(MSI::MsiGetSummaryInformation(0, szDatabase, /* readOnly */ 0, &hSummaryInfo), TEXT("Could not open SummaryInformation stream"));

	FILETIME ftValue;
	SYSTEMTIME st;
	INT	iValue;
	UINT uiDataType;
	DWORD cchBuf = MAX_PATH;
	TCHAR* szValueBuf = new TCHAR[cchBuf];
	DWORD cchValueBuf = cchBuf;

	UINT uiCodePage = CP_ACP;

	if (!szValueBuf)
		return ERROR_OUTOFMEMORY;

	//
	// do codepage detection to see whether the OS supports the codepage in the _SummaryInformation stream
	//

	OSVERSIONINFO osvi;
	memset(&osvi, 0, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (!W32::GetVersionEx(&osvi))
	{
		delete [] szValueBuf;
		return ERROR_FUNCTION_FAILED;
	}

	if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		if (ERROR_SUCCESS == MSI::MsiSummaryInfoGetProperty(hSummaryInfo, PID_CODEPAGE, &uiDataType, &iValue, &ftValue, szValueBuf, &cchValueBuf)
			&& (VT_I2 == uiDataType || VT_I4 == uiDataType))
		{
			// fail if system does not support this codepage
			if (!W32::IsValidCodePage(iValue) && CP_ACP != iValue)
			{
				delete [] szValueBuf;
				TCHAR szOutput[MAX_PATH] = {0};
				if (FAILED(StringCbPrintf(szOutput, sizeof(szOutput), TEXT("Unable to display summary information. System does not support the codepage of the Summary Information Stream (codepage = '%d')"), iValue)))
					return ERROR_FUNCTION_FAILED;
				ErrorExit(ERROR_FUNCTION_FAILED, szOutput);
			}
			else
			{
				uiCodePage = iValue;
			}
		}
	}

	//
	// enumerate list of summary information properties
	//

	int rgiPIDList[] = {PID_DICTIONARY, PID_CODEPAGE, PID_TITLE, PID_SUBJECT, PID_AUTHOR, PID_KEYWORDS,
						PID_COMMENTS, PID_TEMPLATE, PID_LASTAUTHOR, PID_REVNUMBER, PID_EDITTIME,
						PID_LASTPRINTED, PID_CREATE_DTM, PID_LASTSAVE_DTM, PID_PAGECOUNT, PID_WORDCOUNT,
						PID_CHARCOUNT, PID_THUMBNAIL, PID_APPNAME, PID_SECURITY};
	int cPID = sizeof(rgiPIDList)/sizeof(int);

	for (int iPID = 0; iPID < cPID; iPID++)
	{
		cchValueBuf = cchBuf;
		UINT uiStat = MSI::MsiSummaryInfoGetProperty(hSummaryInfo, iPID, &uiDataType, &iValue, &ftValue, szValueBuf, &cchValueBuf);
		if (ERROR_MORE_DATA == uiStat)
		{
			cchValueBuf++;
			delete [] szValueBuf;
			szValueBuf = new TCHAR[cchValueBuf];
			if (!szValueBuf)
				return ERROR_OUTOFMEMORY;
			cchBuf = cchValueBuf;
			uiStat = MSI::MsiSummaryInfoGetProperty(hSummaryInfo, iPID, &uiDataType, &iValue, &ftValue, szValueBuf, &cchValueBuf);
		}

		if (ERROR_SUCCESS != uiStat)
		{
			delete [] szValueBuf;
			CheckError(uiStat, TEXT("Could not access summary property"));
		}

		// szValueBuf should always be large enough (at least MAX_PATH) to hold the value of
		//  the other non-string data types

		switch(uiDataType)
		{
		case VT_EMPTY: // property does not exist
			continue;
		case VT_I2:
		case VT_I4: // integer properties
			if (FAILED(StringCchPrintf(szValueBuf, cchBuf, TEXT("%d"), iValue)))
			{
				delete [] szValueBuf;
				return ERROR_FUNCTION_FAILED;
			}
			break;
		case VT_LPSTR: // string
			break;
		case VT_FILETIME: // time
			W32::FileTimeToLocalFileTime(&ftValue, &ftValue);
			W32::FileTimeToSystemTime(&ftValue, &st);
			if (FAILED(StringCchPrintf(szValueBuf, cchBuf, TEXT("%d/%02d/%02d %02d:%02d:%02d"),
										st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond)))
			{
				delete [] szValueBuf;
				return ERROR_FUNCTION_FAILED;
			}
			break;
		case VT_CF: // binary
			if (FAILED(StringCchPrintf(szValueBuf, cchBuf, TEXT("(Bitmap"))))
			{
				delete [] szValueBuf;
				return ERROR_FUNCTION_FAILED;
			}
			break;
		default: // unknown
			if (FAILED(StringCchPrintf(szValueBuf, cchBuf, TEXT("Unknown Type: %d"), uiDataType)))
			{
				delete [] szValueBuf;
				return ERROR_FUNCTION_FAILED;
			}
			break;
		}

		TCHAR *szPropName = TEXT("UNKNOWN");
		if (iPID < cStandardProperties)
			szPropName = rgszPropName[iPID];

		TCHAR szOption[MAX_PATH] = {0};
		if (FAILED(StringCchPrintf(szOption, MAX_PATH, TEXT("[%2i][/%c] %s = "), iPID, rgchPropertySwitch[iPID], szPropName)))
		{
			delete [] szValueBuf;
			return ERROR_FUNCTION_FAILED;
		}

		TCHAR szCRLF[] = TEXT("\r\n\r\n");

		int cchDisplay = lstrlen(szOption) + lstrlen(szCRLF) + lstrlen(szValueBuf) + 1;
		TCHAR *szDisplay = new TCHAR[cchDisplay];
		if (!szDisplay)
		{
			delete [] szValueBuf;
			return ERROR_OUTOFMEMORY;
		}

		if (FAILED(StringCchPrintf(szDisplay, cchDisplay, TEXT("%s%s%s"), szOption, szValueBuf, szCRLF)))
		{
			delete [] szValueBuf;
			delete [] szDisplay;
			return ERROR_FUNCTION_FAILED;
		}

		DisplaySumInfoStr(uiCodePage, szDisplay);

		if (szDisplay)
		{
			delete [] szDisplay;
			szDisplay = NULL;
		}
	} // end for
 
	if (szValueBuf)
	{
		delete [] szValueBuf;
		szValueBuf = NULL;
	}

	if (fOLEInitialized)
	{
		OLE::CoUninitialize();
	}

	return ERROR_SUCCESS;
}

//____________________________________________________________________________
//
//  Stream name compression - need to use the code in MSI.DLL instead
//____________________________________________________________________________

const int cchEncode = 64;  // count of set of characters that can be compressed
const int cx = cchEncode;  // character to indicate non-compressible
const int chDoubleCharBase = 0x3800;  // offset for double characters, start of user-area
const int chSingleCharBase = chDoubleCharBase + cchEncode*cchEncode;  // offset for single characters, just after double characters
const int chCatalogStream  = chSingleCharBase + cchEncode; // prefix character for system table streams
const int cchMaxStreamName = 31;  // current OLE docfile limit on stream names

const unsigned char rgEncode[128] =
{ cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,62,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,
  cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,62,cx, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,cx,cx,cx,cx,cx,cx,
//(sp)!  "  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?
  cx,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,cx,cx,cx,cx,63,
// @, A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _ 
  cx,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,cx,cx,cx,cx,cx};
// ` a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~ 0x7F

bool CompressStreamName(const OLECHAR* pchIn, OLECHAR* pchOut, int fSystem)  // pchOut must be cchMaxStreamName characters + 1
{
        unsigned int ch, ch1, ch2;
        unsigned int cchLimit = cchMaxStreamName;
        ch = *pchIn++;    // read ahead to allow conversion in place
        if (fSystem)
        {
                *pchOut++ = chCatalogStream;
                cchLimit--;
        }
        while (ch != 0)
        {
                if (cchLimit-- == 0)  // need check to avoid 32-character stream name bug in OLE32
                        return false;
                if (ch < sizeof(rgEncode) && (ch1 = rgEncode[ch]) != cx) // compressible character
                {
                        ch = ch1 + chSingleCharBase;
                        if ((ch2 = *pchIn) != 0 && ch2 < sizeof(rgEncode) && (ch2 = rgEncode[ch2]) != cx)
                        {
                                pchIn++;  // we'll take it, else let it go through the loop again
                                ch += (ch2 * cchEncode + chDoubleCharBase - chSingleCharBase);
                        }
                }
                ch1 = *pchIn++;   // read before write in case prefix character followed by uncompressed chars
                *pchOut++ = (OLECHAR)ch;
                ch = ch1;
        }
        *pchOut = 0;
        return true;
}

bool DecodeStringPool(IStorage& riStorage, StringEntry*& rgStrings, int& iMaxStringId, int& cbStringId)
{
        // Stream Variables
        IStream* piPoolStream = 0;
        IStream* piDataStream = 0;
        bool fRawStreamNames = false;
        bool fDBCS = false;
        bool f4524Format = false; //!!temp

        // Open Streams
        HRESULT hres;
        if ((hres = riStorage.OpenStream(szwStringPool1, 0, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piPoolStream)) == S_OK
         && (hres = riStorage.OpenStream(szwStringData1, 0, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piDataStream)) == S_OK)
                fRawStreamNames = true;
        else if ((hres = riStorage.OpenStream(szwStringPoolX, 0, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piPoolStream)) == S_OK //!! temp
                        && (hres = riStorage.OpenStream(szwStringDataX, 0, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piDataStream)) == S_OK)//!! temp
                f4524Format = true;  //!!temp
        else if (!((hres = riStorage.OpenStream(szwStringPool2, 0, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piPoolStream)) == S_OK
                        && (hres = riStorage.OpenStream(szwStringData2, 0, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piDataStream)) == S_OK))
                CheckError(hres, TEXT("Error Opening String Pool"));
        
        // Determine Size Of Streams
        STATSTG stat;
        CheckError(piPoolStream->Stat(&stat, STATFLAG_NONAME), TEXT("Error Obtaining Stat"));
        int cbStringPool = stat.cbSize.LowPart;
        CheckError(piDataStream->Stat(&stat, STATFLAG_NONAME), TEXT("Error Obtaining Stat"));
        int cbDataStream = stat.cbSize.LowPart;
        CheckError((cbStringPool % 4) != 0, TEXT("Database Corrupt: String Pool Length Is Not A Multiple Of 4."));
        
        int iHeader = 0; // Header is the string ID size and code page for this stringpool
        CheckError(piPoolStream->Read((void*)(&iHeader), sizeof(int), NULL), TEXT("Error Reading Stream Header"));
        g_iCodePage = iHeader &0xFFFF;
        cbStringId = ((iHeader & 0x80000000) == 0x80000000) ? 3 : 2;
        cbStringPool -= 4;

        _stprintf(g_rgchBuffer, TEXT("String ID size: %d\nCode page: %d\n"), cbStringId, g_iCodePage);
        if (f4524Format) //!!temp
                lstrcat(g_rgchBuffer, TEXT("Invalid stream format from 4524.5 MSI build. Need to convert.\n"));
        Display(g_rgchBuffer);

        // Allocate Array
        int cStringPoolEntries = (cbStringPool / 4) + 1; // save room for the null string
        iMaxStringId = cStringPoolEntries - 1;
        rgStrings = new StringEntry[cStringPoolEntries];
		if(!rgStrings)
			ErrorExit(ERROR_OUTOFMEMORY, TEXT("Error Creating String Entries"));
        int cbStrings = 0;

        // Fill String Pool Entries
        for (int c = 1; c  <= iMaxStringId; c++)
        {
                int iPoolEntry;
                CheckError(piPoolStream->Read((void*)(&iPoolEntry), sizeof(int), NULL), TEXT("Error Reading Stream"));
                rgStrings[c].iRefCnt = (iPoolEntry & 0x7FFF0000) >> 16;
                if (iPoolEntry == 0)
                {
                        rgStrings[c].sz = 0;
                        continue;
                }
                int cbString = iPoolEntry & 0xFFFF;
                fDBCS = (iPoolEntry & 0x80000000) != 0;
                if (cbString == 0)
                {
                        piPoolStream->Read((void*)&cbString, sizeof(int), NULL);
                        iMaxStringId--;
                }
                cbStrings += cbString;
                rgStrings[c].sz = new unsigned char[cbString/sizeof(unsigned char) + 1];
                rgStrings[c].sz[cbString/sizeof(unsigned char)] = 0; // null terminate
                CheckError(piDataStream->Read(rgStrings[c].sz, cbString, NULL), TEXT("Error Reading Stream"));
                for (int i=0; i < cbString; i++)
                {
                        if (!g_iCodePage) 
                        {
                                if (rgStrings[c].sz[i] & 0x80)
                                {
                                        _stprintf(g_rgchBuffer, TEXT("String %d has characters with high-bit set, but codepage is not set.\n"), c);
                                        Display(g_rgchBuffer);
                                        break;
                                }
                        }
                        else if (IsDBCSLeadByteEx(g_iCodePage, (BYTE)rgStrings[c].sz[i])  && !fDBCS)
                        {
                                _stprintf(g_rgchBuffer, TEXT("String %d appears to be DBCS, but DBCS flag is not set.\n"), c);
                                Display(g_rgchBuffer);
                                break;
                        }
                }
        }

        // Add Null String
        int cbNullString = 1;
        rgStrings[0].sz = new unsigned char[cbNullString/sizeof(unsigned char) + 1];
        rgStrings[0].sz[cbNullString/sizeof(unsigned char)] = 0; // null terminate
        strcpy((char *)rgStrings[0].sz, ""); // must be char

        if (cbDataStream != cbStrings)
                ErrorExit(1, TEXT("Database Corrupt:  String Pool Bytes Don't Match"));
        
        if (g_fDumpStringPool)
        {
                _stprintf(g_rgchBuffer, TEXT("\n+++String Pool Entries+++\n"));
                Display(g_rgchBuffer);
                for (int i = 1; i <= iMaxStringId; i++)
                {
                        if (rgStrings[i].iRefCnt)
                        {
                                TCHAR rgchString[cchLimitStringBuffer];
                                LimitString(rgStrings[i].sz, rgchString);
                                _stprintf(g_rgchBuffer, TEXT("Id:%5d  Refcnt:%5d  String: %s\n"), i, rgStrings[i].iRefCnt, rgchString);
                                Display(g_rgchBuffer);
                        }
                }
                Display(TEXT("\n"));
        }

        // Release Streams
        piPoolStream->Release();
        piDataStream->Release();
        return fRawStreamNames;
}


void RemoveQuotes(const TCHAR* szOriginal, TCHAR sz[MAX_PATH])
/*---------------------------------------------------------------------------------------------------
RemoveQuotes -- Removes enclosing quotation marks if any.  For example, "c:\my documents" becomes
        c:\mydocuments

  Arguments:
        szOriginal -- original string
        sz -- buffer for 'stripped' string

  Returns:
        none
-----------------------------------------------------------------------------------------------------*/
{
        const TCHAR* pch = szOriginal;
        if (*pch == TEXT('"'))
                pch++;
        int iLen = lstrlen(pch);
        for (int i = 0; i < iLen; i++, pch++)
                sz[i] = *pch;

        pch = szOriginal;
        if (*(pch + iLen) == TEXT('"'))
                        sz[iLen-1] = TEXT('\0');
        sz[iLen] = TEXT('\0');
}

DWORD CheckStringPoolRefCounts(StringEntry* rgStrings, int iMaxStringId)
{
        int cErrors =0 ;

        for (int i=1; i <= iMaxStringId; i++)
        {
                if (rgStrings[i].iRefCnt != 0)
                {
                        TCHAR szBuf[1024];
                        TCHAR rgchString[cchLimitStringBuffer];
                        LimitString(rgStrings[i].sz, rgchString);
                        const TCHAR* szDir = TEXT("high");
                        int iDiff = rgStrings[i].iRefCnt;
                        if (iDiff < 0)
                        {
                                szDir = TEXT("low");
                                iDiff = -iDiff;
                        }
                        else if (iDiff >= (1<<14))  // likely wrapped negative
                        {
                                szDir = TEXT("low");
                                iDiff = (1<<15) - iDiff;
                        }
                        _stprintf(szBuf, TEXT("String pool refcount for string \"%s\" (String Id: %d) is %d too %s\n"),
                                                rgchString, i, iDiff, szDir);
                        Display(szBuf);
                        cErrors++;
                }
        }
        
        return cErrors ? ERROR_INSTALL_PACKAGE_INVALID : ERROR_SUCCESS;
}

void FillDatabaseCatalogArrays(IStorage& riDatabaseStg, TableEntry*& rgTables, int& cTables, 
                                                          ColumnEntry*& rgColumns, int& cColumns, StringEntry* rgStrings, int iMaxStringId, int cbStringId, bool fRawStreamNames) 
{
        // Convert Ansi Strings To Unicode
        AnsiToWide(szColumnCatalog, g_szwColumnCatalog);
        AnsiToWide(szTableCatalog, g_szwTableCatalog);
        if (!fRawStreamNames)
        {
                CompressStreamName(g_szwColumnCatalog, g_szwColumnCatalog, true);
                CompressStreamName(g_szwTableCatalog, g_szwTableCatalog, true);
        }

        // Stream Variables
        IStream* piColumnStream = 0;
        IStream* piTableStream = 0;

        // Open Streams
        CheckError(riDatabaseStg.OpenStream(g_szwColumnCatalog, 0, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piColumnStream), TEXT("Error Opening Column Catalog"));
        CheckError(riDatabaseStg.OpenStream(g_szwTableCatalog, 0, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piTableStream), TEXT("Error Opening Table Catalog"));

        // Determine Size Of Streams
        STATSTG stat;
        CheckError(piColumnStream->Stat(&stat, STATFLAG_NONAME), TEXT("Error Obtaining Stat"));
        int cbColumnStream = stat.cbSize.LowPart;
        CheckError(piTableStream->Stat(&stat, STATFLAG_NONAME), TEXT("Error Obtaining Stat"));
        int cbTableStream  = stat.cbSize.LowPart;
        
        
#ifdef DEBUG
        if (g_fDebugDump)
        {
                int cb = cbTableStream;
                int c = 0;
                while (cb > 0)
                {
                        c++;
                        int iTable = 0;
                        
                        CheckError(piTableStream->Read((void*)(&iTable), cbStringId, NULL), TEXT("Error Reading Stream"));
                        if (iTable > iMaxStringId)
                        {
                                TCHAR szBuf[400];
                                _stprintf(szBuf, TEXT("String pool index %d for table name is greater than max string id (%d)"), iTable, iMaxStringId);
                                ErrorExit(ERROR_INSTALL_PACKAGE_INVALID, szBuf);
                        }
                        cb -= cbStringId;
                        TCHAR szBuf[400];
                        _stprintf(szBuf, TEXT("Table catalog entry: %hs (#%d)\n"), rgStrings[iTable].sz, c);
                        Display(szBuf);
                }
        }
#endif


        // Determine Number Of Column & Table Entries
        cColumns    = cbColumnStream/((sizeof(short) * 2) + (cbStringId * 2)); 
        cTables     = cbTableStream/cbStringId + 2; 
        rgTables    = new TableEntry[cTables + 2]; // save room for catalog tables
        rgColumns   = new ColumnEntry[cColumns];

        // Fill In Array
        int nCol = 0, nTable = -1, iPrevTable = 0;

        // load table names
        for (int c = 0; (c < cColumns) && cbTableStream; c++, cbColumnStream -= cbStringId)
        {
                int iTableName = 0;
                CheckError(piColumnStream->Read((void*)(&iTableName), cbStringId, NULL), TEXT("Error Reading Stream"));
                if (iTableName > iMaxStringId)
                {
                        TCHAR szBuf[400];
                        _stprintf(szBuf, TEXT("String pool index %d for table name is greater than max string id (%d)"), iTableName, iMaxStringId);
                        ErrorExit(ERROR_INSTALL_PACKAGE_INVALID, szBuf);
                }

                // Update TableEntry Array (If necessary)
                if (iTableName != iPrevTable)
                {
                        nTable++;
#ifdef DEBUG
                        if (g_fDebugDump)
                        {
                                TCHAR szBuf[400];
                                _stprintf(szBuf, TEXT("New table '%hs', #%d\n"), rgStrings[iTableName].sz, nTable+1);
                                Display(szBuf);
                        }
#endif
                        int cbString = strlen((char *)rgStrings[iTableName].sz);

                        if (nTable >= cTables)
                        {
                                TCHAR szBuf[400];
                                _stprintf(szBuf, TEXT("Encountered more tables than expected. Table: %hs"), rgStrings[iTableName].sz);
                                ErrorExit(ERROR_INSTALL_PACKAGE_INVALID, szBuf);
                        }
                        rgTables[nTable].szName = new char[cbString/sizeof(char) + 1];
                        rgTables[nTable].szName[cbString/sizeof(char)] = 0; // null terminate
                        strcpy(rgTables[nTable].szName, (char *)rgStrings[iTableName].sz);
                        iPrevTable = iTableName;
                }
                rgColumns[c].nTable = nTable;
        }

        if (!cbColumnStream)
                ErrorExit(ERROR_INSTALL_PACKAGE_INVALID, TEXT("Columns stream is too small"));

        // get column positions
        for (c = 0; c < cColumns; c++)
        {
                int iPosition = 0;
                CheckError(piColumnStream->Read((void*)(&iPosition), sizeof(short), NULL), TEXT("Error Reading Stream"));
                if (iPosition != 0)
                        iPosition += 0x7FFF8000L;  // translate offset if not null
                rgColumns[c].iPosition = iPosition - iIntegerDataOffset;
        }

        int iColumn;

        // get column names
        for (c = 0; c < cColumns; c++)
        {
                iColumn = 0;
                CheckError(piColumnStream->Read((void*)(&iColumn), cbStringId, NULL), TEXT("Error Reading Stream"));
                if (iColumn > iMaxStringId)
                        ErrorExit(ERROR_INSTALL_PACKAGE_INVALID, TEXT("String Pool Index for column name is greater than max string Id"));

                int cbString = strlen((char *)rgStrings[iColumn].sz);           
                rgColumns[c].szName = new char[cbString/sizeof(char) + 1];
                rgColumns[c].szName[cbString/sizeof(char)] = 0; // null terminate
                strcpy(rgColumns[c].szName, (char *)rgStrings[iColumn].sz);
        }

        // mark string columns as such; record column width
        for (c = 0; c < cColumns; c++)
        {
                unsigned short uiType;
                CheckError(piColumnStream->Read((void*)(&uiType), sizeof(short), NULL), TEXT("Error Reading Stream"));
                int iType = (int)uiType;

                switch (iType & icdTypeMask)
                {
                case icdLong:   rgColumns[nCol].iceType = iceLong;   break;
                case icdShort:  rgColumns[nCol].iceType = iceShort;  break;
                case icdString: rgColumns[nCol].iceType = iceString; break;
                default:               rgColumns[nCol].iceType = iceStream; break;
                };
                if ((iType & icdPrimaryKey) == icdPrimaryKey)
                        rgColumns[nCol].fPrimaryKey = TRUE;
                if ((iType & icdNullable) == icdNullable)
                        rgColumns[nCol].fNullable = TRUE;
                nCol++;
        }

        // Finish Rest of TableEntry Array

        for (int i = 0; i < nCol; i++)
        {
                if (rgColumns[i].fPrimaryKey)
                        rgTables[(rgColumns[i].nTable)].cPrimaryKeys++;
                rgTables[(rgColumns[i].nTable)].cColumns++;
                rgTables[(rgColumns[i].nTable)].iceColDefs[(rgColumns[i].iPosition - 1)] = rgColumns[i].iceType;
        }

        // Add Column Catalog
        nTable++;

#ifdef UNICODE
        WideToAnsi(szColumnCatalog, rgTables[nTable].szName);
#else
        rgTables[nTable].szName = const_cast<char*>(szColumnCatalog);
#endif // UNICODE
        rgTables[nTable].cColumns      = 4; 
        rgTables[nTable].cPrimaryKeys  = 2; 
        rgTables[nTable].iceColDefs[0] = iceString;
        rgTables[nTable].iceColDefs[1] = iceShort;
        rgTables[nTable].iceColDefs[2] = iceString;
        rgTables[nTable].iceColDefs[3] = iceShort;

        // Add Table Catalog
        nTable++;
#ifdef UNICODE
        WideToAnsi(szTableCatalog, rgTables[nTable].szName);
#else
        rgTables[nTable].szName = const_cast<char*>(szTableCatalog);
#endif // UNICODE
        rgTables[nTable].cColumns      = 1; 
        rgTables[nTable].cPrimaryKeys  = 1; 
        rgTables[nTable].iceColDefs[0] = iceString;

        // Set Number Of Tables And Columns
        cTables = nTable + 1;
        cColumns = nCol;

        // Release Streams
        piColumnStream->Release();
        piTableStream->Release();

}

int SetStringProperty(const TCHAR* szValue, MSIHANDLE hSummaryInfo, UINT uiProperty, BOOL fRemove)
/*---------------------------------------------------------------------------------------------------
SetStringProperty -- Sets or removes a string property from the Summary Information stream

  Arguments:
        szValue -- value to set
        hSummaryInfo -- handle to summary information stream
        uiProperty -- property to set
   fRemove -- BOOLean to determine whether to remove property

  Returns:
        0
----------------------------------------------------------------------------------------------------*/
{
        UINT uiDataType = fRemove ? VT_EMPTY : VT_LPSTR;
        TCHAR szBuffer[MAX_PATH];
        RemoveQuotes(szValue, szBuffer);
        CheckError(MSI::MsiSummaryInfoSetProperty(hSummaryInfo, uiProperty, uiDataType, 0, 0, szBuffer), TEXT("Could not set Summary Information property"));
        return 0;
}


BOOL IsLeapYear(int iYear)
/*---------------------------------------------------------------------------------------------------
IsLeapYr -- A year is a leap year if it is evenly divisible by 4 and not by 100 OR it
  is evenly divisible by 4 and 100 and the quotient of the year divided by 100 is evenly
  divisible by 4.

  Returns:
   BOOL TRUE(leap year), FALSE(not a leap year)
-----------------------------------------------------------------------------------------------------*/
{
        if (!(iYear%4) && (iYear%100))
                return TRUE;
        if (!(iYear%4) && !(iYear%100) && !((iYear/100)%4))
                return TRUE;
        return FALSE;
}

BOOL ValidateDate(SYSTEMTIME* pst)
/*-----------------------------------------------------------------------------------------------------
ValidateDate -- Validates the date member of the SYSTEMTIME structure according to the allowed upper
        boundary.  The boundary depends on the month and in the case of February, whether or not the year
        is a leap year.

  Arguments:
        pst -- pointer to SYSTEMTIME structure

  Returns:
        BOOL TRUE(valid) FALSE(invalid)
------------------------------------------------------------------------------------------------------*/
{
        int rgiNormYearDays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        int rgiLeapYearDays[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        /////////////////////// Jan  Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec

        if (IsLeapYear(pst->wYear))
        {
                if (pst->wDay > rgiLeapYearDays[pst->wMonth -1])
                        return FALSE;
        }
        else
        {
                if (pst->wDay > rgiNormYearDays[pst->wMonth -1])
                        return FALSE;
        }

        return TRUE;
}


int GetFileTime(const TCHAR* szValue, FILETIME* pft)
/*-----------------------------------------------------------------------------------------------------
GetFileTime -- Converts a string to the SYSTEMTIME structure format.  And the converts the SYSTEMTIME
        structure to the FILETIME format.  The string is required to be of the format 
        'year/month/day hour:minute:second' -> 'yyyy/mm/dd hh:mm:ss'

  Arguments:
        szValue -- string to convert
        pft -- pointer for FILETIME structure

  Returns:
        0 -- no error
        1 -- invalid or error
------------------------------------------------------------------------------------------------------*/
{
        TCHAR szValueBuf[MAX_PATH];
        RemoveQuotes(szValue, szValueBuf);
        
        int iLen = lstrlen(szValueBuf);
        if (iLen != 19)
                return 1; // invalid format

        SYSTEMTIME st;
        TCHAR* pch = szValueBuf;
        TCHAR szBuf[4];
        int nDex = 0;
        int iValue;
        
        // year
        for(; nDex < 4; nDex++)
                szBuf[nDex] = *pch++;
        szBuf[nDex] = 0;
        iValue = _ttoi(szBuf);
        if (iValue == 0)
                return 1;
        st.wYear = iValue;
        pch++; // for '/'
        
        // month
        for(nDex = 0; nDex < 2; nDex++)
                szBuf[nDex] = *pch++;
        szBuf[nDex] = 0;
        iValue = _ttoi(szBuf);
        if (iValue < 1 || iValue > 12)
                return 1;
        st.wMonth = iValue;
        pch++; // for '/'
        
        // day
        for(nDex = 0; nDex < 2; nDex++)
                szBuf[nDex] = *pch++;
        szBuf[nDex] = 0;
        iValue = _ttoi(szBuf);
        if (iValue < 1 || iValue > 31)
                return 1;
        st.wDay = iValue;
        pch++; // for ' '
        
        // hour
        for(nDex = 0; nDex < 2; nDex++)
                szBuf[nDex] = *pch++;
        szBuf[nDex] = 0;
        iValue = _ttoi(szBuf);
        if (iValue < 0 || iValue > 23)
                return 1;
        st.wHour = iValue;
        pch++; // for ':'
        
        // minutes
        for(nDex = 0; nDex < 2; nDex++)
                szBuf[nDex] = *pch++;
        szBuf[nDex] = 0;
        iValue = _ttoi(szBuf);
        if (iValue < 0 || iValue > 59)
                return 1;
        st.wMinute = iValue;
        pch++; // for ':'
        
        // seconds
        for(nDex = 0; nDex < 2; nDex++)
                szBuf[nDex] = *pch++;
        szBuf[nDex] = 0;
        iValue = _ttoi(szBuf);
        if (iValue < 0 || iValue > 59)
                return 1;
        st.wSecond = iValue;

        // Ensure valid date
        if (!ValidateDate(&st))
                return 1;

        // Convert SystemTime to FileTime
        W32::SystemTimeToFileTime(&st, pft);

        // Convert LocalTime to FileTime
        W32::LocalFileTimeToFileTime(pft, pft);

        return 0;
}


int ValidateStringPool(const TCHAR* szDatabase, MSIHANDLE hDummy, UINT iDummy, BOOL fDummy)
{
        IStorage* piStorage = 0;
        OLECHAR*  szwDatabase = 0;

        // Convert Strings To Unicode
        AnsiToWide(szDatabase, szwDatabase);
        
        // Open Transform Storage
        CheckError(OLE::StgOpenStorage(szwDatabase, (IStorage*)0,
                                STGM_READ | STGM_SHARE_DENY_WRITE, (SNB)0, (DWORD)0, &piStorage),
                                TEXT("Could not open database as a storage file"));

        // Decode String Pool
        StringEntry* rgStrings = 0;
        int iMaxStringId = 0;
        int cbStringId = 0;
        bool fRawStreamNames = DecodeStringPool(*piStorage, rgStrings, iMaxStringId, cbStringId);

        // Fill In Database Catalog Arrays
        TableEntry* rgTables = 0;
        int cTables = 0;
        ColumnEntry* rgColumns = 0;
        int cColumns = 0;
        FillDatabaseCatalogArrays(*piStorage, rgTables, cTables, rgColumns, cColumns, rgStrings, iMaxStringId, cbStringId, fRawStreamNames);
        ProcessTableRefCounts(*piStorage, rgStrings, rgTables, iMaxStringId, cTables, cbStringId, fRawStreamNames);
        CheckError(CheckStringPoolRefCounts(rgStrings, iMaxStringId), 
                                        TEXT("String pool reference counts are incorrect."));
        return 0;
}

void ProcessTableRefCounts(IStorage& riStorage, StringEntry* rgStrings, TableEntry* rgTables,int iMaxStringId, int cTables, int cbStringId, bool fRawStreamNames)
{
        IStream* piTableStream = 0;

        for (int cTable = 0; cTable < cTables; cTable++)
        {
                int cbFileWidth = 0;
                
                OLECHAR szwTable[MAX_PATH + 1];
                memset(szwTable, 0, sizeof(szwTable)/sizeof(OLECHAR));
                int cchWide = W32::MultiByteToWideChar(g_iCodePage, 0, rgTables[cTable].szName, -1, szwTable, MAX_PATH);
                if (!fRawStreamNames)
                        CompressStreamName(szwTable, szwTable, true);

                HRESULT hRes = riStorage.OpenStream(szwTable, 0, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piTableStream);
                if (STG_E_FILENOTFOUND == hRes) // no rows in the table is ok
                        continue;

                CheckError(hRes, TEXT("Error Opening Table Stream"));

                STATSTG stat;
                CheckError(piTableStream->Stat(&stat, STATFLAG_NONAME), TEXT("Error Obtaining Stat"));

                // Calculate file width
                for (int cColumn = 0; cColumn < rgTables[cTable].cColumns; cColumn++)
                {
                        switch (rgTables[cTable].iceColDefs[cColumn])
                        {
                        case iceLong:
                                cbFileWidth += sizeof(int);
                                break;
                        case iceStream:
                        case iceShort:
                                cbFileWidth += sizeof(short);
                                break;
                        case iceString:
                                cbFileWidth += cbStringId;
                                break;
                        case iceNone:
                                break;
                        }
                }
                int cRows = stat.cbSize.LowPart / cbFileWidth;
                int cRow;

                for (cColumn = 0; cColumn < rgTables[cTable].cColumns; cColumn++)
                {
                        int iData = 0;
                        switch (rgTables[cTable].iceColDefs[cColumn])
                        {
                        case iceLong:
                                for (cRow = cRows; cRow; cRow--)
                                        CheckError(piTableStream->Read((void*)(&iData), sizeof(int), NULL), TEXT("Error Reading Table Stream"));
                                break;
                        case iceStream:
                        case iceShort:
                                for (cRow = cRows; cRow; cRow--)
                                        CheckError(piTableStream->Read((void*)(&iData), sizeof(short), NULL), TEXT("Error Reading Table Stream"));
                                break;
                        case iceString:
                                for (cRow = cRows; cRow; cRow--)
                                {
                                        iData = 0;
                                        CheckError(piTableStream->Read((void*)(&iData), cbStringId, NULL), TEXT("Error Reading Table Stream"));
                                        if (iData > iMaxStringId)
                                        {
                                                _stprintf(g_rgchBuffer, TEXT("String Pool Index (%d) for table data is greater than max string Id (%d)"), iData, iMaxStringId);
                                                ErrorExit(ERROR_INSTALL_PACKAGE_INVALID, g_rgchBuffer);
                                        }
#ifdef DEBUG
                                        if (g_fDebugDump)
                                        {
                                                TCHAR rgchBuf[cchMaxStringBuffer * 2 + 64];
                                                TCHAR rgchString[cchLimitStringBuffer];
                                                LimitString(rgStrings[iData].sz, rgchString);
                                                _stprintf(rgchBuf, TEXT("Table: %hs (r%d,c%d), String %d: %s\n"), rgTables[cTable].szName, cRow, cColumn + 1, iData, rgchString);
                                                Display(rgchBuf);
                                        }
#endif
                                        rgStrings[iData].iRefCnt--;

                                }
                                break;
                        }
                }
                piTableStream->Release();
        }
}

int SetFileTimeProperty(const TCHAR* szValue, MSIHANDLE hSummaryInfo, UINT uiProperty, BOOL fRemove)
/*---------------------------------------------------------------------------------------------------
SetFileTimeProperty -- Sets or Removes a FileTime property from the Summary Information stream.

  Arguments:
        szValue -- value string (is converted to FILETIME)
        hSummaryInfo -- handle to summary information stream
        uiProperty -- property to set
        fRemove -- BOOLean to determine whether or not to remove property

  Returns:
        0
----------------------------------------------------------------------------------------------------*/
{
        UINT uiDataType = fRemove ? VT_EMPTY : VT_FILETIME;
        FILETIME ft;
        if (GetFileTime(szValue, &ft))
                ErrorExit(1, TEXT("Error getting file time from string"));
        CheckError(MSI::MsiSummaryInfoSetProperty(hSummaryInfo, uiProperty, uiDataType, 0, &ft, 0), TEXT("Could not set Summary Information property"));
        return 0;
}

int DoNothing(const TCHAR* /*szValue*/, MSIHANDLE /*hSummaryInfo*/, UINT /*uiProperty*/, BOOL /*fRemove*/)
/*---------------------------------------------------------------------------------------------------
DoNothing -- Does Nothing.

  Arguments:
        szValue -- value string (is converted to FILETIME)
        hSummaryInfo -- handle to summary information stream
        uiProperty -- property to set
        fRemove -- BOOLean to determine whether or not to remove property

  Returns:
        0
----------------------------------------------------------------------------------------------------*/
{
        // Stub function to do nothing -- used for PID_THUMBNAIL case
        return 0;
}

int SetIntegerProperty(const TCHAR* szValue, MSIHANDLE hSummaryInfo, UINT uiProperty, BOOL fRemove)
/*---------------------------------------------------------------------------------------------------
SetIntegerProperty -- Sets or Removes an integer property from the Summary Information stream.

  Arguments:
        szValue -- value string (is converted to int)
        hSummaryInfo -- handle to summary information stream
        uiProperty -- property to set
        fRemove -- BOOLean to determine whether or not to remove property

  Returns:
        0
----------------------------------------------------------------------------------------------------*/
{
        UINT uiDataType = fRemove ? VT_EMPTY : VT_I4;
        int iValue = _ttoi(szValue); 
        if ((0 == iValue) && (!_istdigit(*szValue)))
                CheckError(ERROR_INVALID_DATA, TEXT("Bad integer value"));
        CheckError(MSI::MsiSummaryInfoSetProperty(hSummaryInfo, uiProperty, uiDataType, iValue, 0, 0), TEXT("Could not set Summary Information property"));
        return 0;
}

int SetCodePageProperty(const TCHAR* szValue, MSIHANDLE hSummaryInfo, UINT uiProperty, BOOL fRemove)
/*---------------------------------------------------------------------------------------------------
SetCodePageProperty -- Sets or Removes the codepage property from the Summary Information stream.

  Arguments:
        szValue -- value string (is converted to int)
        hSummaryInfo -- handle to summary information stream
        uiProperty -- property to set
        fRemove -- BOOLean to determine whether or not to remove property

  Returns:
        0
----------------------------------------------------------------------------------------------------*/
{
        UINT uiDataType = fRemove ? VT_EMPTY : VT_I4;
        int iValue = _ttoi(szValue); 
        if ((0 == iValue) && (!_istdigit(*szValue)))
                CheckError(ERROR_INVALID_DATA, TEXT("Bad integer value"));
        if (!W32::IsValidCodePage(iValue)  && CP_ACP != iValue)
                CheckError(ERROR_INVALID_DATA, TEXT("Unable to set PID_CODEPAGE property. Unsupported or invalid codepage"));
        CheckError(MSI::MsiSummaryInfoSetProperty(hSummaryInfo, uiProperty, uiDataType, iValue, 0, 0), TEXT("Could not set Summary Information property"));
        return 0;
}

BOOL SkipValue(TCHAR*& rpch)
/*---------------------------------------------------------------------------------------------------
SkipValue -- skips over the value of a switch.  Is smart if value is enclosed in quotes

  Arguments:
        rpch -- pointer to string

  Returns:
        BOOL TRUE(value present), FALSE(no value present)
----------------------------------------------------------------------------------------------------*/
{
	TCHAR ch = *rpch;
	if (ch == 0 || ch == TEXT('/') || ch == TEXT('-'))
		return FALSE;   // no value present

	TCHAR *pchSwitchInUnbalancedQuotes = NULL;

	for (; (ch = *rpch) != TEXT(' ') && ch != TEXT('\t') && ch != 0; rpch++)
	{       
		if (*rpch == TEXT('"'))
		{
			rpch++; // for '"'

			for (; (ch = *rpch) != TEXT('"') && ch != 0; rpch++)
			{
				if ((ch == TEXT('/') || ch == TEXT('-')) && (NULL == pchSwitchInUnbalancedQuotes))
				{
					pchSwitchInUnbalancedQuotes = rpch;
				}
			}
                    ;
            ch = *(++rpch);
            break;
		}
	}
	if (ch != 0)
	{
		*rpch++ = 0;
	}
	else
	{
		if (pchSwitchInUnbalancedQuotes)
			rpch=pchSwitchInUnbalancedQuotes;
	}
	return TRUE;
}

BOOL SkipTimeValue(TCHAR*& rpch)
/*---------------------------------------------------------------------------------------------------
SkipTimeValue -- skips over the value of a time switch.  Is smart if value is enclosed in quotes.
        The value string for a time switch contains '/' and is of the format 
        "year/month/day hour:minute:second"

  Arguments:
        rpch -- pointer to string

  Returns:
        BOOL TRUE(value present), FALSE(no value present)
----------------------------------------------------------------------------------------------------*/
{
        TCHAR ch = *rpch;
        if (ch == 0 || ch == TEXT('/') || ch == TEXT('-') || ch != TEXT('"'))
                return FALSE;   // no value present or incorrect format

        ++rpch; // for '"'
        
        for (; (ch = *rpch) != TEXT('"') && ch!= 0; rpch++)
                ;
        
        if (ch != 0)
                *rpch++ = 0;
        return TRUE;
}

TCHAR SkipWhiteSpace(TCHAR*& rpch)
/*-------------------------------------------------------------------------------------------------------------
SkipWhiteSpace -- Skips over the white space in the string until it finds the next character 
        (non-tab, non-white space)

  Arguments:
        rpch -- string

  Returns:
        next character (non-white space, non-tab)
---------------------------------------------------------------------------------------------------------------*/
{
        TCHAR ch;
        for (; (ch = *rpch) == TEXT(' ') || ch == TEXT('\t'); rpch++)
                ;
        return ch;
}

void ParseCommandLine(TCHAR* szCmdLine)
/*-------------------------------------------------------------------------------------------------------------
ParseCommandLine -- Parses the command line and determines what summary information properties to set.  If a
        property has a value string that includes spaces, the value must be enclosed in quotation marks.

  Arguments:
        szCmdLine -- Command line string

  Returns:
        none
--------------------------------------------------------------------------------------------------------------*/
{
        TCHAR szDatabase[MAX_PATH] = {0};
        //TCHAR* szDatabase = 0;
        TCHAR chCmdNext;
        TCHAR* pchCmdLine = szCmdLine;
        
        SkipValue(pchCmdLine);   // skip over module name
        chCmdNext = SkipWhiteSpace(pchCmdLine); 
        
        TCHAR* szCmdData = pchCmdLine; 
        SkipValue(pchCmdLine);
        RemoveQuotes(szCmdData, szDatabase);
        //szDatabase = szCmdData;

        PMSIHANDLE hDatabase = 0;
        PMSIHANDLE hSummaryInfo;
        
        int nProperties = 0;
        int iRet = 0;
        while ((chCmdNext = SkipWhiteSpace(pchCmdLine)) != 0)
        {
                UINT uiProperty;

                if (chCmdNext == TEXT('/') || chCmdNext == TEXT('-'))
                {
                        TCHAR* szCmdOption = pchCmdLine++;  // save for error msg
                        TCHAR chOption = (TCHAR)(*pchCmdLine++ | 0x20); // lower case flag
                        chCmdNext = SkipWhiteSpace(pchCmdLine);
                        szCmdData = pchCmdLine;
                        uiProperty = 0;
                        for (const TCHAR* pchOptions = rgszCmdOptions; *pchOptions; pchOptions++, uiProperty++)
                        {
                                if (*pchOptions == chOption)
                                        break;
                        }// end for (const TCHAR* pchOptions...)
                        if (*pchOptions) // switch found
                        {
                                const TCHAR chIndex = (TCHAR)(pchOptions-rgszCmdOptions);
                                nProperties++;
                                if (nProperties > cStandardProperties)
                                        ErrorExit(1, TEXT("Over maximum number of properties allowed to be set"));
                                if (uiProperty == 20) // validate string pool
                                {
                                        hDatabase = 0;
                                        hSummaryInfo = 0;
                                        iRet = (*rgCommands[chIndex])(szDatabase, 0, 0, 0);
                                }
                                else if (uiProperty == 21) // set dump string pool option
                                {
                                        iRet = SetDumpStringPoolOption(0,0,0,0);
                                }
                                else
                                {
                                        if (!hDatabase)
                                        {
                                                CheckError(MSI::MsiOpenDatabase(szDatabase, MSIDBOPEN_TRANSACT, &hDatabase), TEXT("Unable to open database"));
                                                CheckError(MSI::MsiGetSummaryInformation(hDatabase, 0, cStandardProperties, &hSummaryInfo),
                                                                TEXT("Could not open SummaryInformation stream"));
                                        }

                                        if (uiProperty <= 13 && uiProperty >= 10) // FileTime property
                                        {
                                                if (!SkipTimeValue(pchCmdLine))
                                                        iRet = (*rgCommands[chIndex])(szCmdData, hSummaryInfo, uiProperty, TRUE);
                                                else
                                                        iRet = (*rgCommands[chIndex])(szCmdData, hSummaryInfo, uiProperty, FALSE);
                                        }
                                        else
                                        {
                                                if (!SkipValue(pchCmdLine))
                                                        iRet = (*rgCommands[chIndex])(szCmdData, hSummaryInfo, uiProperty, TRUE);
                                                else    
                                                        iRet = (*rgCommands[chIndex])(szCmdData, hSummaryInfo, uiProperty, FALSE);
                                        }
                                }
                        }// end if (*pchOptions)
                        else
                        {
                                // Invalid/Unrecognized switch
                                SkipValue(pchCmdLine);
                                continue;
                        }
                }
                else
                        ErrorExit(1, TEXT("Switch missing"));
        }// end while(...)

        if (hDatabase)
        {
                CheckError(MSI::MsiSummaryInfoPersist(hSummaryInfo), TEXT("Unable to commit Summary Information"));
                CheckError(MSI::MsiDatabaseCommit(hDatabase), TEXT("Unable to commit database"));
        }
}

void DisplaySumInfoStr(UINT uiCodePage, LPCTSTR szMessage)
{
	if (szMessage)
	{
		if (g_hStdOut)
		{
			DWORD cbWritten = 0;
#ifdef UNICODE
			if (W32::GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
			{
				int cchBuf = W32::WideCharToMultiByte(uiCodePage, 0, szMessage, -1, 0, 0, 0, 0);
				char *szTemp = new char[cchBuf];
				if (szTemp)
				{
					W32::WideCharToMultiByte(uiCodePage, 0, szMessage, -1, szTemp, cchBuf, 0, 0);
					W32::WriteFile(g_hStdOut, szTemp, cchBuf, &cbWritten, 0);
				}
			}
			else
			{
				// write in UNICODE format
				W32::WriteFile(g_hStdOut, szMessage, _tcsclen(szMessage)*sizeof(TCHAR), &cbWritten, 0);
			}
#else // !UNICODE
			W32::WriteFile(g_hStdOut, szMessage, _tcsclen(szMessage), &cbWritten, 0);
#endif // UNICODE
		}
		else
		{
			W32::MessageBox(0, szMessage, W32::GetCommandLine(), MB_OK);
		}
	}
}

void Display(LPCTSTR szMessage)
{
        if (szMessage)
        {
                int cbOut = _tcsclen(szMessage);;
                if (g_hStdOut)
                {
#ifdef UNICODE
                        char rgchTemp[cchDisplayBuf];
                        if (W32::GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
                        {
                                W32::WideCharToMultiByte(g_iCodePage, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
                                szMessage = (LPCWSTR)rgchTemp;
                        }
                        else
                                cbOut *= sizeof(TCHAR);   // write Unicode if not console device
#endif
                        DWORD cbWritten;
                        W32::WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
                }
                else
                        W32::MessageBox(0, szMessage, W32::GetCommandLine(), MB_OK);
        }
}

//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
#ifdef DEBUG
        if (GetEnvironmentVariable(TEXT("MSIINFO_DEBUG_DUMP"),0,0))
                g_fDebugDump = TRUE;
#endif // DEBUG


        // Determine handle
        g_hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
        if (g_hStdOut == INVALID_HANDLE_VALUE)
                g_hStdOut = 0;  // non-zero if stdout redirected or piped
        
        // Check for enough arguments
        CheckError(argc < 2, TEXT("Must specify database path"));
		TCHAR szDatabase[MAX_PATH] = {0};
		if (FAILED(StringCchCopy(szDatabase, sizeof(szDatabase)/sizeof(szDatabase[0]), argv[1])))
			ErrorExit(ERROR_FUNCTION_FAILED, szHelp);

        if (*szDatabase == TEXT('-') || *szDatabase == TEXT('/'))
        {
                CheckError(szDatabase[1] != TEXT('?'), TEXT("Must specify database first"));
                ErrorExit(0, szHelp);
        }

        // Determine action
        if (argc == 2) // display summary information
                DisplaySummaryInformation(szDatabase);
        else
        {
                TCHAR* szCmdLine = W32::GetCommandLine();
                ParseCommandLine(szCmdLine);
        }
        
        return 0;  // need for compile
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinst\debug.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

    debug.cpp

Abstract:
    Debugging support for msiinst


Author:

    Rahul Thombre (RahulTh) 10/5/2000

Revision History:

    10/5/2000   RahulTh         Created this module.

--*/

#include <windows.h>
#ifndef UNICODE
#include <stdio.h>  // Need this for some of the ansi functions.
#endif
#include "debug.h"
#include <strsafe.h>


//
// Global variable containing the debug level
// Debugging can be enabled even on retail systems through registry settings
//
DWORD gDebugLevel = DL_NONE;

// Registry Debug Information
#define DEBUG_REG_LOCATION  TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\Installer")
#define DEBUG_KEY_NAME      TEXT("Debug")


//+--------------------------------------------------------------------------
//
//  Function:   InitDebugSupport
//
//  Synopsis:   Initialize the global variables that control the level of 
//              debug output.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    10/10/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void InitDebugSupport (void)
{
#if defined(DBG) || ! defined(UNICODE)
    // Always have verbose logging on checked and ANSI builds
    gDebugLevel = DL_VERBOSE;
#else
    DWORD   Status = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    DWORD   Size = 0;
    DWORD   Type = REG_DWORD;
    DWORD   dwDebugLevel = 0;
    
    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                          DEBUG_REG_LOCATION,
                          0,
                          KEY_READ,
                          &hKey
                         );
    if (ERROR_SUCCESS == Status)
    {
        Size = sizeof(dwDebugLevel);
        Status = RegQueryValueEx (hKey, 
                                  DEBUG_KEY_NAME, 
                                  NULL, 
                                  &Type, 
                                  (LPBYTE)&dwDebugLevel,
                                  &Size);

        RegCloseKey (hKey);
    }
    
    if (dwDebugLevel)
        gDebugLevel |= DL_VERBOSE;
#endif
}

//+--------------------------------------------------------------------------
//
//  Function:   _DebugMsg
//
//  Synopsis:   Displays the debug message based on the debug level
//
//  Arguments:  [in] szFormat : Format string.
//              ... - variable # of parameters
//
//  Returns:    nothing.
//
//  History:    10/10/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void _DebugMsg (IN LPCTSTR szFormat, ...)
{
	TCHAR	szDebugBuffer[1024];
	DWORD	dwErrorCode;
	va_list VAList;
	
	//
	// Save the last error code to be restored later
	// so that the debug output doesn't change it
	//
	dwErrorCode = GetLastError();
	
	va_start(VAList, szFormat);
	StringCchVPrintf(szDebugBuffer, sizeof(szDebugBuffer)/sizeof(*szDebugBuffer), szFormat, VAList);
	va_end(VAList);
	
	OutputDebugString (TEXT("MsiInst: "));
	OutputDebugString (szDebugBuffer);
	OutputDebugString (TEXT("\r\n"));
	
	// Restore the saved value of last error.
	SetLastError(dwErrorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinst\migrate.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

	migrate.cpp

Abstract:

	This module contains helper functions for migrating the installer
	binaries during the upgrade of one NT based OS to another. This is required
	if the OS to which we are upgrading has older versions of the binary
	compared to what we already have. e.g. NT4.0 did not come with the Windows
	installer technology but Win2K had installer version 1.1. If someone uses
	our redistributable to install a higher version of the installer on an NT 4
	box, then we need to make sure that if the NT4 box is upgraded to Win2K then
	our bits stay on and don't get overwritten by the older bits from Win2K. 
	We do this by taking advantage of the exception pack mechanism provided in the 
	setup infrastructure.


Author:

	Rahul Thombre (RahulTh)	2/28/2001

Revision History:

	2/28/2001	RahulTh			Created this module.
	2/28/2001	RahulTh			Added NT4 -> Win2K migration.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <objbase.h>
#include <strsafe.h>
extern "C" 
{
#include <excppkg.h>
}
#include "debug.h"
#include "utils.h"
#include "migrate.h"
//
// From the header file automatically generated by the perl script.
// This header file contains an array of strings with the names of the system
// protected files on Win2K and higher (present in msi.inf and mspatcha.inf)
//
extern EXCP_PACK_FILES ProtectedFileList[];
extern EXCP_PACK_DESCRIPTOR excpPacks[];

//
// Function declarations for helper functions.
//
DWORD SetupUpgradeMigration (
	IN const PSETUP_OS_COMPONENT_DATA pCD,
	IN const PSETUP_OS_EXCEPTION_DATA pED
);

//+--------------------------------------------------------------------------
//
//  Function:	HandleNT4Upgrades
//
//  Synopsis:	Make sure that our new bits are not blown away when an NT4
//				machine is upgraded to an OS which contains older bits.
//
//  Arguments:	none.
//
//  Returns:	ERROR_SUCCESS if successful.
//				a Win32 error code otherwise.
//
//  History:	3/6/2001  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD HandleNT4Upgrades (void)
{
#ifndef UNICODE
	return ERROR_CALL_NOT_IMPLEMENTED;
#else	// UNICODE
	SETUP_OS_COMPONENT_DATA ComponentData;
	SETUP_OS_EXCEPTION_DATA ExceptionData;
	size_t				cchTempStore;
	UINT					i;
	GUID					GUIDExcpWinXP;
	DWORD					Status = ERROR_SUCCESS;
	DWORD					dwRStat = ERROR_SUCCESS;
	
	if (g_fWin9X)
		return CO_E_WRONGOSFORAPP;
	
	// Nothing to do for Win2K and above.
	if (5 <= g_osviVersion.dwMajorVersion)
		return ERROR_SUCCESS;
	
	RETURN_IT_IF_FAILED(StringCchLength(g_szTempStore, g_cchMaxPath, &cchTempStore));

	// We must be on NT4 if we are here.
	for (i =0 ; excpPacks[i]._szComponentId[0]; i++)
	{
		if (MAX_PATH <= (cchTempStore + sizeof(excpPacks[i]._szInfName)/sizeof(TCHAR)) ||
			MAX_PATH <= (cchTempStore + sizeof(excpPacks[i]._szCatName)/sizeof(TCHAR))
			)
		{
			//
			// Note: the second part of the addition expression actually is one more
			// than the length of the string since it includes the null terminator too.
			// However, we do not subtract 1 because we need that extra character for
			// the \ separator when we generate the path.
			// 
			DebugMsg ((TEXT("Path to the inf and cat files for \"%s\" is longer than %d characters."), excpPacks[i]._szFriendlyName, MAX_PATH));
			return ERROR_BUFFER_OVERFLOW;
		}

		if (FAILED(IIDFromString (excpPacks[i]._szComponentId, &GUIDExcpWinXP)))
		{
			DebugMsg ((TEXT("Could not convert string to GUID for the exception package for \"%s\"."), excpPacks[i]._szFriendlyName));
			return ERROR_OUTOFMEMORY;	// we just return this error code rather than trying to convert the HRESULT
		}

		// Populate the component data structure
		memset(&ComponentData, 0, sizeof (SETUP_OS_COMPONENT_DATA));
		ComponentData.SizeOfStruct = sizeof (SETUP_OS_COMPONENT_DATA);
		memcpy (&ComponentData.ComponentGuid, &GUIDExcpWinXP, sizeof (GUID));
		RETURN_IT_IF_FAILED(StringCchCopy(ComponentData.FriendlyName,
													 ARRAY_ELEMENTS(ComponentData.FriendlyName),
													 excpPacks[i]._szFriendlyName));
		ComponentData.VersionMajor = excpPacks[i]._dwVerMajor;
		ComponentData.VersionMinor = excpPacks[i]._dwVerMinor;
		ComponentData.BuildNumber = excpPacks[i]._dwVerBuild;
		ComponentData.QFENumber = excpPacks[i]._dwVerQFE;


		// Populate the exception data structure
		memset(&ExceptionData, 0, sizeof (SETUP_OS_EXCEPTION_DATA));
		ExceptionData.SizeOfStruct = sizeof (SETUP_OS_EXCEPTION_DATA);
		// Set up the path to the exception inf.
		RETURN_IT_IF_FAILED(StringCchCopy(ExceptionData.ExceptionInfName,
													 ARRAY_ELEMENTS(ExceptionData.ExceptionInfName),
													 g_szTempStore));
		ExceptionData.ExceptionInfName[cchTempStore] = TEXT('\\');
		RETURN_IT_IF_FAILED(StringCchCopy(&ExceptionData.ExceptionInfName[cchTempStore+1],
													 ARRAY_ELEMENTS(ExceptionData.ExceptionInfName)-cchTempStore-1,
													 excpPacks[i]._szInfName));
		// Setup the path to the catalog file.
		RETURN_IT_IF_FAILED(StringCchCopy(ExceptionData.CatalogFileName,
													 ARRAY_ELEMENTS(ExceptionData.CatalogFileName),
													 g_szTempStore));
		ExceptionData.CatalogFileName[cchTempStore] = TEXT('\\');
		RETURN_IT_IF_FAILED(StringCchCopy(&ExceptionData.CatalogFileName[cchTempStore+1],
													 ARRAY_ELEMENTS(ExceptionData.CatalogFileName)-cchTempStore-1,
													 excpPacks[i]._szCatName));
		dwRStat = SetupUpgradeMigration (&ComponentData, &ExceptionData);
		
		if (ERROR_SUCCESS == dwRStat)
			excpPacks[i]._bInstalled = TRUE;
		//
		// If this function fails for any exception pack, preserve the error code for the
		// first failure and return it from the function.
		//
		if (ERROR_SUCCESS == Status)
			Status = dwRStat;
	}
	
	return Status;
	
	
#endif 	// UNICODE
}

//+--------------------------------------------------------------------------
//
//  Function:	SetupUpgradeMigration
//
//  Synopsis:	Registers the exception package with the OS so that the bits
//				are not replaced by older bits during an upgrade from one
//				downlevel platform to another.
//
//  Arguments:  [in] pCD : pointer to OS_COMPONENT_DATA structure.
//				[in] pED : pointer to OS_EXCEPTION_DATA structure.
//
//  Returns:	ERROR_SUCCESS if succesful.
//				a Win32 error code otherwise.
//
//  History:	3/6/2001  RahulTh  created
//
//  Notes:		This function only handles OS migration for unicode platforms.
//				It is only a helper function and does not do any parameter
//				validation. That is the responsibility of the caller.
//
//---------------------------------------------------------------------------
DWORD SetupUpgradeMigration (
	IN const PSETUP_OS_COMPONENT_DATA pCD,
	IN const PSETUP_OS_EXCEPTION_DATA pED
)
{
#ifndef UNICODE
	return ERROR_CALL_NOT_IMPLEMENTED;
#else	// UNICODE
    SETUP_OS_COMPONENT_DATA ComponentData;
    SETUP_OS_EXCEPTION_DATA ExceptionData;
	DWORD					Status = ERROR_SUCCESS;
	DWORD					VersionToInstall;
	DWORD					RegisteredVersion;
	
	// Don't run this function on Win9X
	if (g_fWin9X)
		return CO_E_WRONGOSFORAPP;
	
    //
    // Unregister any previously registered versions.
    //
    ComponentData.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
    ExceptionData.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
    if (SetupQueryRegisteredOsComponent(
                                &(pCD->ComponentGuid),
                                &ComponentData,
                                &ExceptionData)
		) 
	{
        //
        // Unregister any packages that are superceded by my package
        //
        RegisteredVersion = MAKELONG( 
                                ComponentData.VersionMajor, 
                                ComponentData.VersionMinor );
		VersionToInstall = MAKELONG(
								pCD->VersionMajor,
								pCD->VersionMinor);

        if (RegisteredVersion <= VersionToInstall) 
		{
			if (!SetupUnRegisterOsComponent(&(pCD->ComponentGuid))) 
			{
				Status = GetLastError();
				DebugMsg((TEXT("Failed to unregister previously registered exception package. Error: %d"), Status));
				return Status;
			}        
		}
		else
		{
			DebugMsg ((TEXT("An exception package with a higher version (%d.%d) has already been registered."), ComponentData.VersionMajor, ComponentData.VersionMinor));
			return ERROR_ALREADY_EXISTS;
		}
    }
        
    //
    // Register the package.
    //
    if (!SetupRegisterOsComponent(pCD, pED)) 
	{
		Status = GetLastError();
		DebugMsg((TEXT("Failed to register exception package. Error: %d."), Status));
		return Status;
    }
	
	DebugMsg ((TEXT("Successfully registered the exception package.")));
	return ERROR_SUCCESS;
	
#endif  // UNICODE
}

//+--------------------------------------------------------------------------
//
//  Function:	IsExcpInfoFile
//
//  Synopsis:	Determines if the name of the file matches that of any inf
//				or catalog file that might get registered as an exception inf
//				on the system.
//
//  Arguments:	[in] szFileName : name of the file.
//
//  Returns:	TRUE : if it is.
//				FALSE : otherwise.
//
//  History:	3/8/2001  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL IsExcpInfoFile (IN LPCTSTR szFileName)
{
#ifndef UNICODE
	return FALSE;	// Exception infs cannot not be registered using ansi bits.
#else // UNICODE
	UINT i;
	
	if (g_fWin9X)
		return FALSE;	// Exception infs cannot be registered on Win9X
	
	if (!szFileName || TEXT('\0') == *szFileName)
		return FALSE;
	
	//
	// If we are on NT4 and this is the exception inf or cat file for the
	// WindowsXP bits, return TRUE
	//
	if (g_osviVersion.dwMajorVersion < 5)
	{
		for (i = 0; excpPacks[i]._szComponentId[0]; i++)
		{
			if (0 == lstrcmpi (szFileName, excpPacks[i]._szInfName) ||
				 0 == lstrcmpi (szFileName, excpPacks[i]._szCatName)
				)
			{
				return TRUE;
			}
		}
		//
		// Make sure it is not one of the binaries mentioned in the inf file.
		//
		for (i=0; ProtectedFileList[i]._szFileName[0]; i++)
		{
			if (0 == lstrcmpi(szFileName, ProtectedFileList[i]._szFileName))
				return TRUE;
		}
	}
	
	
	return FALSE;

#endif // UNICODE
}

//+--------------------------------------------------------------------------
//
//  Function:	PurgeNT4MigrationFiles
//
//  Synopsis:	Deletes any inf and cat files that might be used for registering
//				the exception inf for handling upgrades from NT4. Also deletes
//				any protected files listed in the inf.
//
//  Arguments:	none
//
//  Returns:	ERROR_SUCCESS if successful.
//				a win32 error code otherwise.
//
//  History:	3/8/2001  RahulTh  created
//
//  Notes:		We just make our best attempt at cleaning up those files.
//				if we fail. Too bad. 
//
//				The reason these have to be purged independently is because
//				CopyFileTree does not queue up these files for deletion
//				upon reboot.
//
//---------------------------------------------------------------------------
DWORD PurgeNT4MigrationFiles (void)
{
#ifndef UNICODE
	return ERROR_SUCCESS;
#else // UNICODE

	TCHAR	  szPath[MAX_PATH + 1];
	size_t  cchTempStore;
	UINT	  i;
	TCHAR*  szPtr;
	DWORD	Status = ERROR_SUCCESS;

	if (g_fWin9X)
		return ERROR_SUCCESS;
	
	if (g_osviVersion.dwMajorVersion < 5)
	{
		RETURN_IT_IF_FAILED(StringCchLength(g_szTempStore, g_cchMaxPath, &cchTempStore));
		if ( ARRAY_ELEMENTS(szPath) < cchTempStore + 2 )
			return ERROR_BUFFER_OVERFLOW;
		RETURN_IT_IF_FAILED(StringCchCopy(szPath, ARRAY_ELEMENTS(szPath), g_szTempStore));
		szPath[cchTempStore] = TEXT('\\');
		cchTempStore++;
		szPtr = szPath + cchTempStore;

		for (i = 0; excpPacks[i]._szComponentId[0]; i++)
		{
			// Do not purge files for exception packs that have been installed.
			if (excpPacks[i]._bInstalled)
				continue;
			
			if ( SUCCEEDED(StringCchCopy(szPtr,
												  ARRAY_ELEMENTS(szPath) - cchTempStore,
												  excpPacks[i]._szInfName)) )
			{
				if (! DeleteFile (szPath))
				{
					Status = GetLastError();
				}
			}

			if ( SUCCEEDED(StringCchCopy(szPtr,
												  ARRAY_ELEMENTS(szPath) - cchTempStore,
												  excpPacks[i]._szCatName)) )
			{
				if (! DeleteFile (szPath))
				{
					Status = GetLastError();
				}
			}
		}
		
		//
		// Also delete the protected files listed in the inf
		// Note: These will not be in use because the only time we purge
		// this files is when we failed to update darwin. Also note that
		// currently we are doing this only for NT4. On Win2K, we just use
		// MoveFileEx in the CopyFileTree.
		//
		for (i = 0; ProtectedFileList[i]._szFileName[0]; i++)
		{
			// Do not purge files for installed exception packs.
			if (excpPacks[ProtectedFileList[i]._excpIndex]._bInstalled)
				continue;
			
			if ( SUCCEEDED(StringCchCopy(szPtr,
												  ARRAY_ELEMENTS(szPath) - cchTempStore,
												  ProtectedFileList[i]._szFileName)) )
			{
				if (! DeleteFile (szPath))
				{
					Status = GetLastError();
				}
			}
		}
	}
	
	return Status;
	
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinst\migrate.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

	migrate.h

Abstract:

	Header file for InstMsi OS migration support.


Author:

	Rahul Thombre (RahulTh)	3/6/2001

Revision History:

	3/6/2001	RahulTh			Created this module.

--*/

#ifndef __MIGRATE_H_4E61AF26_B20F_4022_BEBD_044579C9DA6C__
#define __MIGRATE_H_4E61AF26_B20F_4022_BEBD_044579C9DA6C__

//
// Info. about the exception package for bits that will ship with
// WindowsXP. This exception package only needs to be installed on NT4
// in order to handle the NT4->Win2K upgrades. It should not be installed
// on Win2K since the only OS that we can upgrade to from Win2K is WindowsXP
// or higher.
//
typedef struct tagEXCP_PACK_DESCRIPTOR {
	LPTSTR _szComponentId;
	LPTSTR _szFriendlyName;
	LPTSTR _szInfName;
	LPTSTR _szCatName;
	WORD   _dwVerMajor;
	WORD   _dwVerMinor;
	WORD   _dwVerBuild;
	WORD   _dwVerQFE;
	BOOL   _bInstalled;
} EXCP_PACK_DESCRIPTOR, *PEXCP_PACK_DESCRIPTOR;

//
// Structure for keeping track of files that have been installed by the inf
// files.
//
typedef struct tagEXCP_PACK_FILES {
	LPTSTR _szFileName;				// Name of the file.
	UINT   _excpIndex;				// index into the EXCP_PACK_DESCRIPTOR structure to indicate which exception pack installed the file
} EXCP_PACK_FILES, *PEXCP_PACK_FILES;

//
// Function declarations
//
DWORD HandleNT4Upgrades		(void);
BOOL  IsExcpInfoFile		(IN LPCTSTR szFileName);
DWORD PurgeNT4MigrationFiles(void);

#endif // __MIGRATE_H_4E61AF26_B20F_4022_BEBD_044579C9DA6C__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinst\sources.inc ===
TARGETNAME=MsiInst
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=windows
UMENTRY=main

USE_LIBCMT=1

!ifndef MAKEDLL
NTTARGETFILE0=ProtectedFileList
!endif

TARGETLIBS=\
        $(SDK_LIB_PATH)\ntdll.lib   \
        $(SDK_LIB_PATH)\shell32.lib \
        $(SDK_LIB_PATH)\ole32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\version.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INCLUDES);$(INC_DIR);$(O)

SOURCES=..\msiinst.rc	\
	..\msiinst.cpp	\
	..\debug.cpp	\
	..\migrate.cpp  \
	..\utils.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinst\prot.inc ===
ProtectedFileList:
!if "$(PASS0ONLY)"=="1"
    @del /F /Q $(O)\prot.h
    @perl ..\protgen.pl ..\..\..\..\data\instmsi\mspatcha.inf ..\..\..\..\data\instmsi\msi.inf> $(O)\prot.h
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinst\ansi\makefile.inc ===
!INCLUDE ..\prot.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinst\msiinst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       msiinst.cpp
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <strsafe.h>

// Use the Windows 2000 version of setupapi
#define _SETUPAPI_VER 0x0500
#include <setupapi.h> 

#include <msi.h>

#include <ole2.h>
#include "utils.h"
#include "migrate.h"
#include "debug.h"

#define CCHSmallBuffer 8 * sizeof(TCHAR)

#include <assert.h>
#include <stdio.h>   // printf/wprintf
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE

#include <prot.h>


// Max. Length of the command line string.
#define MAXCMDLINELEN	1024

DWORD IsUpgradeRequired (OUT BOOL * pfUpgradeRequired);
DWORD IsFileInPackageNewer (IN LPCTSTR szFileName, OUT BOOL * pfIsNewer);
BOOL IsValidPlatform (void);
BOOL IsOnWIN64 (const LPOSVERSIONINFO pOsVer);
BOOL RunProcess(const TCHAR* szCommand, const TCHAR* szAppPath, DWORD & dwReturnStat);
BOOL FindTransform(IStorage* piStorage, LANGID wLanguage);
bool IsAdmin(void);
void QuitMsiInst (IN const UINT uExitCode, IN DWORD dwMsgType, IN DWORD dwStringID = IDS_NONE);
DWORD ModifyCommandLine(IN LPCTSTR szCmdLine, IN const OPMODE opMode, IN const BOOL fRebootRequested, IN DWORD cchSize, OUT LPTSTR szFinalCmdLine);
UINT (CALLBACK SetupApiMsgHandler)(PVOID pvHC, UINT Notification, UINT_PTR Param1, UINT_PTR Param2);

// specific work-arounds for various OS
HRESULT OsSpecificInitialization();

// Global variables
OSVERSIONINFO	g_osviVersion;
BOOL		g_fWin9X = FALSE;
BOOL		g_fQuietMode = FALSE;

typedef struct 
{
	DWORD dwMS;
	DWORD dwLS;
} FILEVER;

typedef struct 
{
	PVOID Context;
	BOOL fRebootNeeded;
} ExceptionInfHandlerContext;

// Function type for CommandLineToArgvW
typedef LPWSTR * (WINAPI *PFNCMDLINETOARGVW)(LPCWSTR, int *);

const TCHAR g_szExecLocal[] =    TEXT("MsiExec.exe");
const TCHAR g_szRegister[] =     TEXT("MsiExec.exe /regserver /qn");
const TCHAR g_szUnregister[] = TEXT("MsiExec.exe /unregserver /qn");
const TCHAR g_szService[] =      TEXT("MsiServer");
// Important: The properties passed in through the command line for the delayed reboot should always be in sync. with the properties in instmsi.sed
const TCHAR g_szDelayedBootCmdLine[] = TEXT("msiexec.exe /i instmsi.msi REBOOT=REALLYSUPPRESS MSIEXECREG=1 /m /qb+!");
const TCHAR g_szDelayedBootCmdLineQuiet[] = TEXT("msiexec.exe /i instmsi.msi REBOOT=REALLYSUPPRESS MSIEXECREG=1 /m /q");
const TCHAR g_szTempStoreCleanupCmdTemplate[] = TEXT("rundll32.exe %s\\advpack.dll,DelNodeRunDLL32 \"%s\"");
const TCHAR g_szReregCmdTemplate[] = TEXT("%s\\msiexec.exe /regserver");
TCHAR		g_szRunOnceRereg[20] = TEXT("");		// The name of the value under the RunOnce key used for registering MSI from the right location.
TCHAR		g_szSystemDir[MAX_PATH] = TEXT("");
TCHAR		g_szWindowsDir[g_cchMaxPath] = TEXT("");
TCHAR		g_szTempStore[g_cchMaxPath] = TEXT(""); 	// The temporary store for the expanded binaries
TCHAR		g_szIExpressStore[g_cchMaxPath] = TEXT("");	// The path where IExpress expands the binaries.

const TCHAR g_szMsiRebootProperty[] =     TEXT("REBOOT");
const TCHAR g_szMsiRebootForce[] =        TEXT("Force");

void main(int argc, char* argv[])
{
	DWORD			dwReturnStat = ERROR_ACCESS_DENIED;  // Default to failure in case we don't even create the process to get a returncode
	DWORD 			dwRStat = ERROR_SUCCESS;
	OPMODE			opMode = opNormal;
	BOOL 			bStat = FALSE;
	UINT			i;
	UINT			iBufSiz;
	TCHAR			szFinalCmd[MAXCMDLINELEN] = TEXT("");
	TCHAR * 		szCommandLine = NULL;
	BOOL			fAdmin = TRUE;
	TCHAR			szReregCmd[MAX_PATH + 50] = TEXT(" "); 	// The commandline used for reregistering MSI from the system dir. upon reboot.
	TCHAR			szTempStoreCleanupCmd[MAX_PATH + 50] = TEXT(" ");	// The commandline for cleaning up the temporary store.
	TCHAR			szRunOnceTempStoreCleanup[20] = TEXT("");	// The name of the value under the RunOnce key used for cleaning up the temp. store.
	BOOL            fUpgradeMsi = FALSE;
	BOOL			bAddRunOnceCleanup = TRUE;
	PFNMOVEFILEEX	pfnMoveFileEx;
	PFNDECRYPTFILE	pfnDecryptFile;
	HMODULE			hKernel32;
	HMODULE			hAdvapi32;

	// Basic initializations
	InitDebugSupport();
#ifdef UNICODE
	DebugMsg((TEXT("UNICODE BUILD")));
#else
	DebugMsg((TEXT("ANSI BUILD")));
#endif

	//
	// First detect if we are supposed to run in quiet mode or not.
	//
	opMode = GetOperationModeA(argc, argv);
	g_fQuietMode = (opNormalQuiet == opMode || opDelayBootQuiet == opMode);
	
	//
	// Ensure that we should be running on this OS
	// Note: this function also sets g_fWin9X, so it must be called before
	// anyone uses g_fWin9X.
	// 
	if (! IsValidPlatform())
	{
		dwReturnStat = CO_E_WRONGOSFORAPP;
		QuitMsiInst(dwReturnStat, flgSystem);
	}
	
	// Parse the commandline
	szCommandLine = GetCommandLine(); // must use this call if Unicode
	if(_tcslen(szCommandLine) > 1024 - _tcslen(g_szMsiRebootProperty) - _tcslen(g_szMsiRebootForce) - 30)
	{
		// Command line too long. Since we append to the end of the user's
		// command line, the actual command line allowed from the user's
		// point of view is less than 1024. Normally, msiinst.exe shouldn't
		// have a long command line anyway.
		QuitMsiInst(ERROR_BAD_ARGUMENTS, flgSystem);
	}

	// Gather basic information about the important folders in system etc.
	
	// Get the windows directory
	dwReturnStat = MyGetWindowsDirectory(g_szWindowsDir, MAX_PATH);
	if (ERROR_SUCCESS != dwReturnStat)
	{
		DebugMsg((TEXT("Could not obtain the path to the windows directory. Error %d."), dwReturnStat));
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst (dwReturnStat, flgNone);
	}
	
	// Get the system directory
	iBufSiz = GetSystemDirectory (g_szSystemDir, MAX_PATH);
	if (0 == iBufSiz)
		dwReturnStat = GetLastError();
	else if (iBufSiz >= MAX_PATH)
		dwReturnStat = ERROR_BUFFER_OVERFLOW;
	
	if (ERROR_SUCCESS != dwReturnStat)
	{
		DebugMsg((TEXT("Could not obtain the system directory. Error %d."), dwReturnStat));
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem); 
		QuitMsiInst (dwReturnStat, flgNone);
	}
	
	// Get the current directory. This is the directory where IExpress expanded its contents.
	iBufSiz = GetCurrentDirectory (MAX_PATH, g_szIExpressStore);
	if (0 == iBufSiz)
		dwReturnStat = GetLastError();
	else if (iBufSiz >= MAX_PATH)
		dwReturnStat = ERROR_BUFFER_OVERFLOW;
	
	if (ERROR_SUCCESS != dwReturnStat)
	{
		DebugMsg((TEXT("Could not obtain the location of the IExpress temporary folder. Error %d."), dwReturnStat));
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst (dwReturnStat, flgNone);   
	}
	
	// Check if an upgrade is necessary
	dwReturnStat = IsUpgradeRequired (&fUpgradeMsi);
	if (ERROR_SUCCESS != dwReturnStat)
	{
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst(dwReturnStat, flgNone);
	}
	
	if (! fUpgradeMsi)
	{
		dwReturnStat = ERROR_SUCCESS;
		ShowErrorMessage(ERROR_SERVICE_EXISTS, flgSystem);
		QuitMsiInst (dwReturnStat, flgNone);
	}

	// Allow only Admins to update MSI
	fAdmin = IsAdmin();
	if (! fAdmin)
	{
		DebugMsg((TEXT("Only system administrators are allowed to update the Windows Installer.")));
		dwReturnStat = ERROR_ACCESS_DENIED;
		QuitMsiInst (dwReturnStat, flgSystem);
	}


	if (ERROR_SUCCESS != (dwReturnStat = OsSpecificInitialization()))
	{
		DebugMsg((TEXT("Could not perform OS Specific initialization.")));
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst(dwReturnStat, flgNone);
	}
	
	// Gather information
	
	
	// Get 2 run once entry names for doing clean up after the reboot.
	
	dwReturnStat = GetRunOnceEntryName (g_szRunOnceRereg, ARRAY_ELEMENTS(g_szRunOnceRereg));
	if (ERROR_SUCCESS == dwReturnStat && g_fWin9X)		// We don't need the cleanup key on NT based systems. (see comments below)
		dwReturnStat = GetRunOnceEntryName (szRunOnceTempStoreCleanup,
														ARRAY_ELEMENTS(szRunOnceTempStoreCleanup));
	if (ERROR_SUCCESS != dwReturnStat)
	{
		// Delete the run once values if there were any created.
		DebugMsg((TEXT("Could not create runonce values. Error %d."), dwReturnStat));
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst (dwReturnStat, flgNone);
	}
	
	// Get a temp. directory to store our binaries for later use
	dwReturnStat = GetTempFolder (g_szTempStore, ARRAY_ELEMENTS(g_szTempStore));
	if (ERROR_SUCCESS != dwReturnStat)
	{
		DebugMsg((TEXT("Could not obtain a temporary folder to store the MSI binaries. Error %d."), dwReturnStat));
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst (dwReturnStat, flgNone);
	}
	
	// Generate the command lines for the run once entries.
	dwReturnStat = StringCchPrintf(szReregCmd, ARRAY_ELEMENTS(szReregCmd),
											 g_szReregCmdTemplate, g_szSystemDir);
	if ( FAILED(dwReturnStat) )
	{
		dwReturnStat = GetWin32ErrFromHResult(dwReturnStat);
		DebugMsg((TEXT("StringCchPrintf on %s failed. Error %d."),
					 g_szReregCmdTemplate, dwReturnStat));
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst (dwReturnStat, flgNone);
	}
	
	//
	// Cleaning up our own temporary folders is done in different ways on Win9x
	// and NT based systems. On NT based systems, we can simply use the 
	// MOVEFILE_DELAY_UNTIL_REBOOT option with MoveFileEx to clean ourselves up 
	// on reboot. However, this option is not supported on Win9x. However, most
	// Win9x clients have advpack.dll in their system folder which has an
	// exported function called DelNodeRunDLL32 for recursively deleting folders
	// and can be invoked via rundll32. Therefore, on Win9x clients, we clean
	// up our temp. folders using a RunOnce value which invokes this function
	// from advpack.dll.
	//
	// The only exception is Win95 Gold which does not have advpack.dll and 
	// Win95 OSR2.5 which has advpack.dll but does not have the DelNodeRunDLL32
	// export. For either of these cases, we should not add anything to the
	// RunOnce entry, otherwise the user will get a pop-up on reboot about
	// a missing advpack.dll or a missing entrypoint DelNodeRunDLL32 in
	// advpack.dll. In these cases, we have no choice but to leave some unneeded
	// files behind.
	//
	if (g_fWin9X)
	{
		if (DelNodeExportFound())
		{
			//
			// advpack.dll containing the export DelNodeRunDLL32 was found in 
			// the system directory.
			//
			dwReturnStat = StringCchPrintf(szTempStoreCleanupCmd,
													 ARRAY_ELEMENTS(szTempStoreCleanupCmd),
													 g_szTempStoreCleanupCmdTemplate,
													 g_szSystemDir, g_szTempStore);
			if ( FAILED(dwReturnStat) )
			{
				dwReturnStat = GetWin32ErrFromHResult(dwReturnStat);
				DebugMsg((TEXT("StringCchPrintf on %s failed. Error %d. ")
							 TEXT("Temporary files will not be cleaned up."),
							 g_szTempStoreCleanupCmdTemplate, dwReturnStat));
				bAddRunOnceCleanup = FALSE;
			}
		}
		else
		{
			// We have no choice but to leave turds behind.
			DebugMsg((TEXT("Temporary files will not be cleaned up. The file advpack.dll is missing from the system folder.")));         
			bAddRunOnceCleanup = FALSE;
		}
	}
	// else : on NT based systems, we use MoveFileEx for cleanup.
	
	//
	// Set the runonce values
	// The rereg command must be set before the cleanup command since the runonce
	// values are processed in the order in which they were added.
	//
	dwReturnStat = SetRunOnceValue(g_szRunOnceRereg, szReregCmd);
	if (ERROR_SUCCESS == dwReturnStat)
	{
		//
		// It is okay to fail here since the only bad effect of this would be
		// that some turds would be left around.
		// Not necessary on NT based systems since we have a different cleanup
		// mechanism there.
		if (g_fWin9X)
		{
			if (bAddRunOnceCleanup)
				SetRunOnceValue(szRunOnceTempStoreCleanup, szTempStoreCleanupCmd);
			else
				DelRunOnceValue (szRunOnceTempStoreCleanup);	// Why leave the value around if it doesn't do anything?
		}
	}
	else
	{
		DebugMsg((TEXT("Could not create a run once value for registering MSI from the system directory upon reboot. Error %d."), dwReturnStat));
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst (dwReturnStat, flgNone);
	}
	
	//
	// Now we have all the necessary RunOnce entries in place and we have all
	// the necessary information about the folders. So we are ready to
	// proceed with our installation
	//
	//
	// First copy over the files from IExpress's temporary store to our own
	// temporary store
	//
	hKernel32 = NULL;
	hAdvapi32 = NULL;
	if (!g_fWin9X)
	{
		pfnMoveFileEx = (PFNMOVEFILEEX) GetProcFromLib (TEXT("kernel32.dll"),
														#ifdef UNICODE
														"MoveFileExW",
														#else
														"MoveFileExA",
														#endif
														&hKernel32);
		
		//
		// Get a pointer to the DecryptFile function. Ignore failures. The
		// most likely reason for this function not being present on the system
		// is that encryption is not supported on that NT platform, so we don't
		// need to decrypt the file anyway since it cannot be encrypted in the
		// first place.
		//
		pfnDecryptFile = (PFNDECRYPTFILE) GetProcFromLib (TEXT("advapi32.dll"),
														  #ifdef UNICODE
														  "DecryptFileW",
														  #else
														  "DecryptFileA",
														  #endif
														  &hAdvapi32);
		if (!pfnMoveFileEx)
		{
			if (hKernel32)
			{
				FreeLibrary(hKernel32);
				hKernel32 = NULL;
			}
			if (hAdvapi32)
			{
				FreeLibrary(hAdvapi32);
				hAdvapi32 = NULL;
			}
			ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
			QuitMsiInst(ERROR_PROC_NOT_FOUND, flgNone);
		}
	}
	dwReturnStat = CopyFileTree (g_szIExpressStore, ARRAY_ELEMENTS(g_szIExpressStore),
										  g_szTempStore, ARRAY_ELEMENTS(g_szTempStore),
										  pfnMoveFileEx, pfnDecryptFile);
	if (hKernel32)
	{
		FreeLibrary(hKernel32);
		hKernel32 = NULL;
		pfnMoveFileEx = NULL;
	}
	if (hAdvapi32)
	{
		FreeLibrary(hAdvapi32);
		hAdvapi32 = NULL;
		pfnDecryptFile = NULL;
	}
	
	if (ERROR_SUCCESS != dwReturnStat)
	{
		DebugMsg((TEXT("Could not copy over all the files to the temporary store. Error %d."), dwReturnStat));
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst(dwReturnStat, flgNone);
	}
	
	// Change the current directory, so that we can operate from our temp. store
	if (! SetCurrentDirectory(g_szTempStore))
	{
		dwReturnStat = GetLastError();
		DebugMsg((TEXT("Could not switch to the temporary store. Error %d."), dwReturnStat));
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst(dwReturnStat, flgNone);
	}
	
	// Register the service from the temp. store
	// We should not proceed if an error occurs during the registration phase.
	// Otherwise we can hose the system pretty badly. In this case, our best
	// bet is to rollback as cleanly as possible and return an error code.
	//
	bStat = RunProcess(g_szExecLocal, g_szRegister, dwRStat);
	if (!bStat && ERROR_SERVICE_MARKED_FOR_DELETE == dwRStat)
	{
		//
		// MsiExec /regserver does a DeleteService followed by a CreateService.
		// Since DeleteService is actually asynchronous, it already has logic
		// to retry the CreateService several times before failing. However, if
		// it still fails with ERROR_SERVICE_MARKED_FOR_DELETE, the most likely
		// cause is that some other process has a handle open to the MSI service.
		// At this point, our best bet at success is to kill the apps. that are
		// most suspect. See comments for the TerminateGfxControllerApps function 
		// to get more information about these.
		//
		// Ignore the error code. We will just make our best attempt.
		//
		TerminateGfxControllerApps();
		
		// Retry the registration. If we still fail, there isn't much we can do.
		bStat = RunProcess (g_szExecLocal, g_szRegister, dwRStat);
	}
	
	if (!bStat || ERROR_SUCCESS != dwRStat)
	{
		// First set an error code that most closely reflects the problem that occurred.
		dwReturnStat = bStat ? dwRStat : GetLastError();
		if (ERROR_SUCCESS == dwReturnStat)	// We know that an error has occurred. Make sure that we don't return a success code by mistake
			dwReturnStat = STG_E_UNKNOWN;
		
		DebugMsg((TEXT("Could not register the Windows Installer from the temporary location. Error %d."), dwReturnStat));
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst (dwReturnStat, flgNone);	// This also tries to rollback the installer registrations as gracefully as possible.
	}
	
	// Run the unpacked version
	BOOL fRebootNeeded = FALSE;

#ifdef UNICODE
	if (!g_fWin9X)
	{
		if (5 <= g_osviVersion.dwMajorVersion)
		{
			// run the Exception INFs
			TCHAR szInfWithPath[MAX_PATH+1] = TEXT("");
			dwReturnStat = ERROR_SUCCESS;
			UINT uiErrorLine = 0;
			BOOL fInstall;
			HINF hinf;
			for (i = 0; excpPacks[i]._szComponentId[0]; i++)
			{
				uiErrorLine = 0;
				if (0 == lstrcmpi (TEXT("mspatcha.inf"), excpPacks[i]._szInfName))
				{
					//
					// For mspatcha.inf, install the exception pack only if the file on the 
					// system is not newer.
					//
					dwReturnStat = IsFileInPackageNewer (TEXT("mspatcha.dll"), &fInstall);
					if (ERROR_SUCCESS != dwReturnStat)
						break;
					if (! fInstall)
						continue;
				}
				DebugMsg((TEXT("Running Exception INF %s to install system bits."), excpPacks[i]._szInfName));
				dwReturnStat = StringCchPrintf(szInfWithPath,
														 ARRAY_ELEMENTS(szInfWithPath),
														 TEXT("%s\\%s"), g_szTempStore,
														 excpPacks[i]._szInfName);
				if ( FAILED(dwReturnStat) )
				{
					dwReturnStat = GetWin32ErrFromHResult(dwReturnStat);
					break;
				}
				hinf = SetupOpenInfFileW(szInfWithPath,NULL,INF_STYLE_WIN4, &uiErrorLine);

				if (hinf && (hinf != INVALID_HANDLE_VALUE))
				{
					ExceptionInfHandlerContext HC = { 0, FALSE };

					HC.Context = SetupInitDefaultQueueCallback(NULL);

					BOOL fSetup = SetupInstallFromInfSectionW(NULL, hinf, TEXT("DefaultInstall"), 
						SPINST_ALL, NULL, NULL, SP_COPY_NEWER_OR_SAME, 
						(PSP_FILE_CALLBACK) &SetupApiMsgHandler, /*Context*/ &HC, NULL, NULL);

					if (!fSetup)
					{
						dwReturnStat = GetLastError();
						DebugMsg((TEXT("Installation of %s failed. Error %d."), excpPacks[i]._szInfName, dwReturnStat));
						break;
					}
					else
					{
						DebugMsg((TEXT("Installation of %s succeeded."), excpPacks[i]._szInfName));
						excpPacks[i]._bInstalled = TRUE;
					}
					
					SetupCloseInfFile(hinf);
					hinf=NULL;
				
				}
				else
				{
					dwReturnStat = GetLastError();
					DebugMsg((TEXT("Cannot open %s."), excpPacks[i]._szInfName));
				}
			}
			
			if (ERROR_SUCCESS != dwReturnStat)
			{
				//
				// If an error occurred in the installation of the files, then
				// we should abort immediately. If we proceed with the installation
				// of instmsi.msi, it WILL run msiregmv.exe as custom action which
				// will migrate the installer data to the new format and all the
				// existing installations will be completely hosed since the darwin
				// bits on the system will still be the older bits which require
				// the data to be in the old format.
				//
				ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
				QuitMsiInst (dwReturnStat, flgNone);	// This also handles the graceful rollback of the installer registrations.
			}
			else
			{
				//
				// On Win2K, explorer will always load msi.dll so we should 
				// go ahead and ask for a reboot. 
				// Note: setupapi will probably never tell us that a reboot is needed
				// because we now use the COPYFLG_REPLACE_BOOT_FILE flag in the 
				// inf. So the only notifications that we get for files are 
				// SPFILENOTIFY_STARTCOPY and SPFILENOTIFY_ENDCOPY
				//
				fRebootNeeded = TRUE;
			}
		}
	}
#endif

	dwReturnStat = ModifyCommandLine (szCommandLine, opMode, fRebootNeeded, (sizeof(szFinalCmd)/sizeof(TCHAR)), szFinalCmd);
	
	if (ERROR_SUCCESS != dwReturnStat)
	{
		ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
		QuitMsiInst (dwReturnStat, flgNone);
	}

	DebugMsg((TEXT("Running upgrade to MSI from temp files at %s. [Final Command: \'%s\']"), g_szTempStore, szFinalCmd));
	bStat = RunProcess(g_szExecLocal, szFinalCmd, dwReturnStat);
	
	if (fRebootNeeded)
	{
		if (ERROR_SUCCESS == dwReturnStat)
		{
			dwReturnStat = ERROR_SUCCESS_REBOOT_REQUIRED;
		}
	}
	
	dwRStat = IsUpgradeRequired (&fUpgradeMsi);
	if (ERROR_SUCCESS != dwRStat)
		fUpgradeMsi = FALSE;
	
	if (!fUpgradeMsi && ERROR_SUCCESS_REBOOT_INITIATED != dwReturnStat)
	{
		//
		// We can start using the MSI in the system folder right away.
		// So we reregister the MSI binaries from the system folder
		// and purge the runonce key for re-registering them upon reboot.
		// This will always happen on NT based systems because NT supports
		// rename and replace operations.So even if any of the msi binaries
		// were in use during installation, they were renamed and now we have
		// the good binaries in the system folder.
		// 
		// Doing this prevents any timing problems that might happen if the
		// service registration is delayed until the next logon using the RunOnce
		// key. It also removes the requirement that an admin. must be the first
		// one to logon after the reboot.
		//
		// However, we exclude the case where the reboot is initiated by the
		// installation of instmsi. In this case, RunProcess won't succeed
		// because new apps. cannot be started when the system is being rebooted.
		// so it is best to leave things the way they are.
		// 
		// On Win9x, neither of these things is an issue, so the RunOnce key
		// is sufficient to achieve what we want.
		//
		if (SetCurrentDirectory(g_szSystemDir))
		{
			dwRStat = ERROR_SUCCESS;
			bStat = RunProcess(g_szExecLocal, g_szRegister, dwRStat);
			if (bStat && ERROR_SUCCESS == dwRStat)
				DelRunOnceValue (g_szRunOnceRereg);
			// Note: Here we do not delete the other run once value because
			// we still need to clean up our temp store.
		}
	}
	
	// We are done. Return the error code.
	DebugMsg((TEXT("Finished install.")));
	QuitMsiInst(dwReturnStat, flgNone, IDS_NONE);
}

UINT (CALLBACK SetupApiMsgHandler)(PVOID pvHC, UINT Notification, UINT_PTR Param1, UINT_PTR Param2)
{
	// no UI
	// only catches in use messages.
	ExceptionInfHandlerContext* pHC = (ExceptionInfHandlerContext*) pvHC;
	if (SPFILENOTIFY_FILEOPDELAYED == Notification)
	{
		DebugMsg((TEXT("Reboot required for complete installation.")));
		pHC->fRebootNeeded = TRUE;
	}

	//return SetupDefaultQueueCallback(pHC->Context, Notification, Param1, Param2);

	return FILEOP_DOIT;
}

BOOL FindTransform(IStorage* piParent, LANGID wLanguage)
{
	IStorage* piStorage = NULL;
	TCHAR szTransform[MAX_PATH];
	if ( FAILED(StringCchPrintf(szTransform, ARRAY_ELEMENTS(szTransform),
										 TEXT("%d.mst"), wLanguage)) )
		return FALSE;
	
	const OLECHAR* szwImport;
#ifndef UNICODE
	OLECHAR rgImportPathBuf[MAX_PATH];
	int cchWide = ::MultiByteToWideChar(CP_ACP, 0, (LPCTSTR)szTransform, -1, rgImportPathBuf, MAX_PATH);
	szwImport = rgImportPathBuf;
#else	// UNICODE
	szwImport = szTransform;
#endif

	HRESULT hResult;
	if (NOERROR == (hResult = piParent->OpenStorage(szwImport, (IStorage*) 0, STGM_READ | STGM_SHARE_EXCLUSIVE, (SNB)0, (DWORD)0, &piStorage)))
	{
		DebugMsg((TEXT("Successfully opened transform %s."), szTransform));
		piStorage->Release();
		return TRUE;
	}
	else 
		return FALSE;
}

// IsAdmin(): return true if current user is an Administrator (or if on Win95)
// See KB Q118626 
const int CCHInfoBuffer = 2048;
bool IsAdmin(void)
{
	if(g_fWin9X)
		return true; // convention: always Admin on Win95
	
	
	PSID psidAdministrators;
	SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

	if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0, 0, 0, 0, 0, 0,
		&psidAdministrators))
	{
		return false;
	}

	bool bIsAdmin = false; // assume not admin

	// on NT5 and greater (Win2K+), use CheckTokenMembership to correctly
	// handle cases where the administrators group might be disabled
	if (g_osviVersion.dwMajorVersion >= 5)
	{
		BOOL bAdminIsMember = FALSE;
		HMODULE hAdvapi32 = NULL;
		PFNCHECKTOKENMEMBERSHIP pfnCheckTokenMembership = (PFNCHECKTOKENMEMBERSHIP) GetProcFromLib (TEXT("advapi32.dll"), "CheckTokenMembership", &hAdvapi32);
		if (pfnCheckTokenMembership && (*pfnCheckTokenMembership)(NULL, psidAdministrators, &bAdminIsMember) && bAdminIsMember)
		{
			bIsAdmin = true;
		}

		if (hAdvapi32)
		{
			FreeLibrary(hAdvapi32);
			hAdvapi32 = NULL;
		}
	}
	else
	{
		HANDLE hAccessToken;
		DWORD dwInfoBufferSize;
		
		bool bSuccess = false;

		if(!OpenProcessToken(GetCurrentProcess(),TOKEN_READ,&hAccessToken))
		{
			return(false);
		}
			
		UCHAR *InfoBuffer = new UCHAR[CCHInfoBuffer];
		if(!InfoBuffer)
		{
			CloseHandle(hAccessToken);
			return false;
		}
		PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)InfoBuffer;
		DWORD cchInfoBuffer = CCHInfoBuffer;
		bSuccess = GetTokenInformation(hAccessToken,TokenGroups,InfoBuffer,
			CCHInfoBuffer, &dwInfoBufferSize) == TRUE;

		if(!bSuccess)
		{
			if(dwInfoBufferSize > cchInfoBuffer)
			{
				delete [] InfoBuffer;
				InfoBuffer = new UCHAR[dwInfoBufferSize];
				if(!InfoBuffer)
				{
					CloseHandle(hAccessToken);
					return false;
				}
				cchInfoBuffer = dwInfoBufferSize;
				ptgGroups = (PTOKEN_GROUPS)InfoBuffer;

				bSuccess = GetTokenInformation(hAccessToken,TokenGroups,InfoBuffer,
					cchInfoBuffer, &dwInfoBufferSize) == TRUE;
			}
		}

		CloseHandle(hAccessToken);

		if(!bSuccess )
		{
			delete [] InfoBuffer;
			return false;
		}
			
		// assume that we don't find the admin SID.
		bSuccess = false;

		for(UINT x=0;x<ptgGroups->GroupCount;x++)
		{
			if( EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid) )
			{
				bSuccess = true;
				break;
			}

		}
		delete [] InfoBuffer;
		bIsAdmin = bSuccess;
	}

	FreeSid(psidAdministrators);
	return bIsAdmin;
}
	
BOOL RunProcess(const TCHAR* szCommand, const TCHAR* szAppPath, DWORD & dwReturnStat)
{
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	si.cb               = sizeof(si);
	si.lpReserved       = NULL;
	si.lpDesktop        = NULL;
	si.lpTitle          = NULL;
	si.dwX              = 0;
	si.dwY              = 0;
	si.dwXSize          = 0;
	si.dwYSize          = 0;
	si.dwXCountChars    = 0;
	si.dwYCountChars    = 0;
	si.dwFillAttribute  = 0;
	si.dwFlags          = STARTF_FORCEONFEEDBACK | STARTF_USESHOWWINDOW;
	si.wShowWindow      = SW_SHOWNORMAL;
	si.cbReserved2      = 0;
	si.lpReserved2      = NULL;

	DebugMsg((TEXT("RunProcess (%s, %s)"), szCommand, szAppPath));

	BOOL fExist = FALSE;
	BOOL fStat = CreateProcess(const_cast<TCHAR*>(szCommand), const_cast<TCHAR*>(szAppPath), (LPSECURITY_ATTRIBUTES)0,
						(LPSECURITY_ATTRIBUTES)0, FALSE, NORMAL_PRIORITY_CLASS, 0, 0,
						(LPSTARTUPINFO)&si, (LPPROCESS_INFORMATION)&pi);

	if (fStat == FALSE)
		return FALSE;

	DWORD dw = WaitForSingleObject(pi.hProcess, INFINITE); // wait for process to complete
	CloseHandle(pi.hThread);
	if (dw == WAIT_FAILED)
	{
		DebugMsg((TEXT("Wait failed for process.")));
		fStat = FALSE;
	}
	else
	{
		fStat = GetExitCodeProcess(pi.hProcess, &dwReturnStat);
		DebugMsg((TEXT("Wait succeeded for process. Return code was: %d."), dwReturnStat));
		if (fStat != FALSE && dwReturnStat != 0)
			fStat = FALSE;
	}
	CloseHandle(pi.hProcess);
	return fStat;
}

HRESULT OsSpecificInitialization()
{
	HRESULT hresult = ERROR_SUCCESS;

#ifdef UNICODE
	if (!g_fWin9X)
	{
		// UNICODE NT (instmsiW)
		HKEY hkey;
		
		// we can't impersonate here, so not much we can do about access denies.
		hresult = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"), &hkey);

		if (ERROR_SUCCESS == hresult)
		{
			// we only need a little data to determine if it is non-blank.
			// if the data is too big, or the value doesn't exist, we're fine.
			// if it's small enough to fit within the CCHSmallBuffer characters, we'd better actually check the contents.

			DWORD dwIndex = 0;

			DWORD cchValueNameMaxSize = 0;
			RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &cchValueNameMaxSize, NULL, NULL, NULL);
			cchValueNameMaxSize++;
		
			TCHAR* pszValueName = (TCHAR*) GlobalAlloc(GMEM_FIXED, cchValueNameMaxSize*sizeof(TCHAR));

			DWORD cbValueName = cchValueNameMaxSize;

			byte pbData[CCHSmallBuffer];
			
			DWORD cbData = CCHSmallBuffer;
			
			DWORD dwType = 0;

			if ( ! pszValueName )
			{
				RegCloseKey(hkey);
				return ERROR_OUTOFMEMORY;
			}
			
			while(ERROR_SUCCESS == 
				(hresult = RegEnumValue(hkey, dwIndex++, pszValueName, &cbValueName, NULL, &dwType, pbData, &cbData)) ||
				ERROR_MORE_DATA == hresult)
			{
				// this will often fail with more data, which is an indicator that value length wasn't long
				// enough.  That's fine, as long as it was the data too big.  
				// That's a non-blank path, and we want to skip over it.


				if ((ERROR_SUCCESS == hresult) && (REG_EXPAND_SZ == dwType))
				{
					if ((cbData <= sizeof(WCHAR)) || (NULL == pbData[0]))
					{
						// completely empty, or one byte is empty. (One byte should be null) ||
						
						// It's possible to set a registry key length longer than the actual
						// data contained.  This captures the string being "blank," but longer
						// than one byte.
						DebugMsg((TEXT("Deleting blank REG_EXPAND_SZ value from HKLM\\CurrentControlSet\\Control\\Session Manager\\Environment.")));
						hresult = RegDeleteValue(hkey, pszValueName);

						dwIndex = 0; // must reset enumerator after deleting a value
					}
				}
				cbValueName = cchValueNameMaxSize;
				cbData = CCHSmallBuffer;
			}

			GlobalFree(pszValueName);
			RegCloseKey(hkey);
		}
	}
#endif

	// don't fail for any of the reasons currently in this function.
	// If any of this goes haywire, keep going and try to finish.

	return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:	GetVersionInfoFromDll
//
//  Synopsis:	This function retrieves the version resource info from a 
//              specified DLL
//
//  Arguments:	[IN]     szDll: DLL to check
//	            [IN OUT] fv: reference to FILEVER struct for most and least 
//                          significant DWORDs of the version.
//
//  Returns:	ERROR_SUCCESS if version info retreived
//				a win32 error code otherwise.
//
//  History:	10/12/2000  MattWe  created
//				12/19/2001  RahulTh changed signature so that function actually
//									returns a meaninful error code instead of a
//									BOOL.
//
//  Notes:
//
//---------------------------------------------------------------------------

DWORD GetVersionInfoFromDll(const TCHAR* szDll, FILEVER& fv)
{
	unsigned int cbUnicodeVer = 0;
	DWORD Status = ERROR_SUCCESS;
	DWORD dwZero = 0;
	char *pbData = NULL;
	VS_FIXEDFILEINFO* ffi = NULL;
	DWORD dwInfoSize = 0;
	
	dwInfoSize = GetFileVersionInfoSize((TCHAR*)szDll, &dwZero);	

	if (0 == dwInfoSize)
	{
		Status = GetLastError();
		//
		// Strange as it may sound, if the file is not present, GetLastError()
		// actually returns ERROR_SUCCESS, at least on Win2000 server. Go figure
		// So here we make sure that if the call above failed, then we at least
		// return an error code instead of a success code.
		//
		if (ERROR_SUCCESS == Status)
			Status = ERROR_FILE_NOT_FOUND;
		goto GetVersionInfoEnd;
	}

	memset(&fv, 0, sizeof(FILEVER));

	pbData = new char[dwInfoSize];
	if (!pbData)
	{
		Status = ERROR_OUTOFMEMORY;
		goto GetVersionInfoEnd;
	}
	
	memset(pbData, 0, dwInfoSize);
   
	if (!GetFileVersionInfo((TCHAR*) szDll, NULL, dwInfoSize, pbData))
	{	
		Status = GetLastError();
	}
	else
	{
		
		if (!VerQueryValue(pbData,
						   TEXT("\\"),
						   (void**)  &ffi,
						   &cbUnicodeVer))
		{
			Status = ERROR_INVALID_PARAMETER;
		}
	}
	
GetVersionInfoEnd:
	if (ERROR_SUCCESS == Status)
	{
		fv.dwMS = ffi->dwFileVersionMS;
		fv.dwLS = ffi->dwFileVersionLS;

		DebugMsg((TEXT("%s : %d.%d.%d.%d"), szDll,
			(ffi->dwFileVersionMS & 0xFFFF0000) >> 16, (ffi->dwFileVersionMS & 0xFFFF),
			(ffi->dwFileVersionLS & 0xFFFF0000) >> 16, (ffi->dwFileVersionLS & 0xFFFF)));
	}
	else
	{
		DebugMsg((TEXT("Unable to get version info for %s. Error %d."), szDll, Status));
	}

	if (pbData)
		delete [] pbData;
	
	return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:	IsValidPlatform
//
//  Synopsis:	This function checks if msiinst should be allowed to run on
//				the current OS.
//
//  Arguments:	none
//
//  Returns:	TRUE : if it is okay to run on the current OS.
//				FALSE : otherwise
//
//  History:	10/5/2000	RahulTh	created
//				1/25/2001	RahulTh	Hardcode the service pack requirement.
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL IsValidPlatform (void)
{
	HKEY	hServicePackKey = NULL;
	DWORD	dwValue = 0;
	DWORD	cbValue = sizeof(dwValue);
	BOOL	bRetVal = FALSE;
		
	g_osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if(!GetVersionEx(&g_osviVersion))
	{
		DebugMsg((TEXT("GetVersionEx failed GetLastError=%d"), GetLastError()));
		bRetVal = FALSE;
		goto IsValidPlatformEnd;
	}
	
	if(g_osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
		g_fWin9X = TRUE;

	if (g_fWin9X)
	{
		DebugMsg((TEXT("Running on Win9X.")));
	}
	else
	{
		DebugMsg((TEXT("Not running on Win9X.")));
	}

	// Don't run on WIN64 machines
	if (IsOnWIN64(&g_osviVersion))
	{
		DebugMsg((TEXT("The Windows installer cannot be updated on 64-bit versions of Windows Operating Systems.")));
		bRetVal = FALSE;
		goto IsValidPlatformEnd;
	}
	
#ifdef UNICODE
	if (g_fWin9X)
	{
		// don't run UNICODE under Win9X
		DebugMsg((TEXT("UNICODE version of the Windows installer is not supported on Microsoft Windows 9X.")));
		bRetVal = FALSE;
		goto IsValidPlatformEnd;
	}
	else
	{
		// For NT4.0 get the service pack info.
		if (4 == g_osviVersion.dwMajorVersion)
		{
			if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
											  TEXT("SYSTEM\\CurrentControlSet\\Control\\Windows"), 
											  0, 
											  KEY_READ, 
											  &hServicePackKey)
				)
			{
				if ((ERROR_SUCCESS != RegQueryValueEx(hServicePackKey, 
													 TEXT("CSDVersion"), 
													 0, 
													 0, 
													 (BYTE*)&dwValue, 
													 &cbValue)) ||
					dwValue < 0x00000600)
				{
					// Allow only service pack 6 or greater on NT 4.
					DebugMsg((TEXT("Must have at least Service Pack 6 installed on NT 4.0.")));
					bRetVal = FALSE;
					goto IsValidPlatformEnd;
				}
			}
			else
			{
				//
				// If we cannot figure out the service pack level on NT4 system, play safe and abort rather than
				// run the risk of hosing the user.
				//
				DebugMsg((TEXT("Could not open the registry key for figuring out the service pack level.")));
				bRetVal = FALSE;
				hServicePackKey = NULL;
				goto IsValidPlatformEnd;
			}
		}

		//
		// Disallow NT versions lower than 4.0 and higher than Windows2000.
		// Service pack level for Windows2000 is immaterial. All levels are allowed.
		//
		if (4 > g_osviVersion.dwMajorVersion ||
			(5 <= g_osviVersion.dwMajorVersion &&
			 (!((5 == g_osviVersion.dwMajorVersion) && (0 == g_osviVersion.dwMinorVersion)))
			)
		   )
		{
			
			DebugMsg((TEXT("This version of the Windows Installer is only supported on Microsoft Windows NT 4.0 with SP6 or higher and Windows 2000.")));
			bRetVal = FALSE;
			goto IsValidPlatformEnd;
		}

	}
#else	// UNICODE
	if (!g_fWin9X)
	{
		// don't run ANSI under NT.
		DebugMsg((TEXT("ANSI version of the Windows installer is not supported on Microsoft Windows NT.")));
		bRetVal = FALSE;
		goto IsValidPlatformEnd;
	}
#endif

	// Whew! We actually made it to this point. We must be on the right OS. :-)
	bRetVal = TRUE;
	
IsValidPlatformEnd:
	if (hServicePackKey)
	{
		RegCloseKey (hServicePackKey);
	}
	
	return bRetVal;
}

//+--------------------------------------------------------------------------
//
//  Function:	IsUpgradeRequired
//
//  Synopsis:	Checks if the existing version of MSI on the system (if any)
//				is greater than or equal to the version that we are trying to 
//				install.
//
//  Arguments:	[out] pfUpgradeRequired : pointer to a bool which gets the
//											a true or false value depending on
//											whether upgrade is required or not.
//
//  Returns:	ERROR_SUCCESS if successful.
//				A win32 error code otherwise.
//
//  History:	10/13/2000  MattWe  added code for version detection.
//				10/16/2000	RahulTh	Created function and moved code here.
//				12/19/2001  RahulTh Moved out code and added checks for more
//									files than just msi.dll. Also changed
//									signature to return a meaningful error code
//									in case of failure.
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD IsUpgradeRequired (OUT BOOL * pfUpgradeRequired)
{
	DWORD Status = ERROR_SUCCESS;
	unsigned int i = 0;
	
	if (!pfUpgradeRequired)
		return ERROR_INVALID_PARAMETER;
	
	*pfUpgradeRequired = FALSE;
	
	for (i = 0; ProtectedFileList[i]._szFileName[0]; i++)
	{
		Status = IsFileInPackageNewer(ProtectedFileList[i]._szFileName, pfUpgradeRequired);
		if (ERROR_SUCCESS != Status || *pfUpgradeRequired)
			break;
	}
	
	return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:	IsFileInPackageNewer
//
//  Synopsis:	Checks if the file that shipped with the package is newer
//				than the one available on the system.
//
//  Arguments:	[in] szFileName : name of the file.
//				[out] pfIsNewer : pointer to a bool which tells if the file
//									that came with instmsi is newer
//
//  Returns:	ERROR_SUCCESS : if no errors were encountered.
//				a Win32 error code otherwise.
//
//  History:	12/19/2001  RahulTh  created (moved code from another function
//												and fixed it)
//
//  Notes:		Even if the function fails, *pfIsNewer might change. Callers
//				of the function should not assume that the value will be
//				preserved if the function fails.
//
//---------------------------------------------------------------------------
DWORD IsFileInPackageNewer (IN LPCTSTR szFileName, OUT BOOL * pfIsNewer)
{
	DWORD	Status = 			ERROR_SUCCESS;
	TCHAR* 	pchWorkingPath	=	NULL;
	TCHAR* 	pchLastSlash	= 	NULL;
	TCHAR   szFileWithPath[MAX_PATH+1] =		TEXT("");
	FILEVER fvInstMsiVer;
	FILEVER fvCurrentVer;
	
	if (! szFileName || !szFileName[0] || !pfIsNewer)
	{
		Status = ERROR_INVALID_PARAMETER;
		goto IsFileInPackageNewerEnd;
	}
	
	*pfIsNewer = FALSE;
	
	Status = StringCchPrintf(szFileWithPath, ARRAY_ELEMENTS(szFileWithPath),
									 TEXT("%s\\%s"), g_szIExpressStore, szFileName);
	if ( FAILED(Status) )
	{
		Status = GetWin32ErrFromHResult(Status);
		goto IsFileInPackageNewerEnd;
	}

	Status = GetVersionInfoFromDll(szFileWithPath, fvInstMsiVer);
	
	if (ERROR_SUCCESS != Status)
	{
		goto IsFileInPackageNewerEnd;
	}
	
	Status = StringCchPrintf(szFileWithPath, ARRAY_ELEMENTS(szFileWithPath),
									 TEXT("%s\\%s"), g_szSystemDir, szFileName);
	if ( FAILED(Status) )
	{
		Status = GetWin32ErrFromHResult(Status);
		goto IsFileInPackageNewerEnd;
	}

	Status = GetVersionInfoFromDll(szFileWithPath, fvCurrentVer);
	
	if (ERROR_SUCCESS != Status)
	{
		if (ERROR_FILE_NOT_FOUND == Status ||
			ERROR_PATH_NOT_FOUND == Status)
		{
			// If system MSI.DLL cannot be found, treat it as success.
			*pfIsNewer = TRUE;
			Status = ERROR_SUCCESS; 
		}
	}
	else if (fvInstMsiVer.dwMS > fvCurrentVer.dwMS)
	{
		// major version greater
		*pfIsNewer = TRUE;
	}
	else if (fvInstMsiVer.dwMS == fvCurrentVer.dwMS)
	{
		if (fvInstMsiVer.dwLS > fvCurrentVer.dwLS)
		{
			// minor upgrade
			*pfIsNewer = TRUE;	
		}
	}
	
IsFileInPackageNewerEnd:

	if (ERROR_SUCCESS == Status)
	{
		DebugMsg((TEXT("InstMsi version of %s is %s than existing."), szFileName, (*pfIsNewer) ? TEXT("newer") : TEXT("older or equal")));
	}
	else
	{
		DebugMsg((TEXT("Unable to determine if instmsi version of %s is newer than the system version. Error %d."), szFileName, Status));
	}
	return Status;
}


//+--------------------------------------------------------------------------
//
//  Function:	IsOnWIN64
//
//  Synopsis:	This function checks if we are on running on an WIN64 machine
//
//  Arguments:	[IN] pOsVer : Pointer to an OSVERSIONINFO structure.
//
//  Returns:	TRUE : if we are running on the WOW64 emulation layer.
//				FALSE : otherwise
//
//  History:	10/5/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL IsOnWIN64(IN const LPOSVERSIONINFO pOsVer)
{
	// This never changes, so cache the results for efficiency
	static int iWow64 = -1;
	
#ifdef _WIN64
	// If we are a 64 bit binary then we must be running a an WIN64 machine
	iWow64 = 1;
#endif

#ifndef UNICODE	// ANSI - Win9X
	iWow64 = 0;
#else
	if (g_fWin9X)
		iWow64 = 0;
	
	// on NT5 or later 32bit build. Check for 64 bit OS
	if (-1 == iWow64)
	{
		iWow64 = 0;
		
		if ((VER_PLATFORM_WIN32_NT == pOsVer->dwPlatformId) &&
			 (pOsVer->dwMajorVersion >= 5))
		{
			// QueryInformation for ProcessWow64Information returns a pointer to the Wow Info.
			// if running native, it returns NULL.
			// Note: NtQueryInformationProcess is not defined on Win9X
			PVOID 	Wow64Info = 0;
			HMODULE hModule = NULL;
			NTSTATUS Status = NO_ERROR;
			BOOL	bRetVal = FALSE;

			typedef NTSTATUS (NTAPI *PFNNTQUERYINFOPROC) (HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);

			PFNNTQUERYINFOPROC pfnNtQueryInfoProc = NULL;
			pfnNtQueryInfoProc = (PFNNTQUERYINFOPROC) GetProcFromLib (TEXT("ntdll.dll"), "NtQueryInformationProcess", &hModule);
			if (! pfnNtQueryInfoProc)
			{
				ShowErrorMessage (STG_E_UNKNOWN, flgSystem);
				QuitMsiInst (ERROR_PROC_NOT_FOUND, flgNone);
			}
			
			Status = (*pfnNtQueryInfoProc)(GetCurrentProcess(), 
							ProcessWow64Information, 
							&Wow64Info, 
							sizeof(Wow64Info), 
							NULL);
			if (hModule)
			{
				FreeLibrary (hModule);
				hModule = NULL;
			}
			
			if (NT_SUCCESS(Status) && Wow64Info != NULL)
			{
				// running 32bit on Wow64.
				iWow64 = 1;
			}
		}
	}
#endif

	return (iWow64 ? TRUE : FALSE);
}

//+--------------------------------------------------------------------------
//
//  Function:	QuitMsiInst
//
//  Synopsis:	Cleans up any globally allocated memory and exits the process
//
//  Arguments:	[IN] uExitCode : The exit code for the process
//				[IN] dwMsgType : A combination of flags indicating the type and level of seriousness of the error.
//				[IN] dwStringID : if the message string is a local resource, this contains the resource ID.
//
//  Returns:	nothing.
//
//  History:	10/6/2000  RahulTh  created
//
//  Notes:		dwStringID is optional. When not specified, it is assumed to
//				be IDS_NONE.
//
//---------------------------------------------------------------------------
void QuitMsiInst (IN const UINT	uExitCode,
				  IN DWORD	dwMsgType,
				  IN DWORD	dwStringID /*= IDS_NONE*/)
{
	DWORD Status = ERROR_SUCCESS;
	
	if (flgNone != dwMsgType)
		ShowErrorMessage (uExitCode, dwMsgType, dwStringID);
	
	//
	// Rollback as gracefully as possible in case of an error.
	// Also, if a reboot was initiated. Then there is not much we can do since
	// we cannot start any new processes anyway. So we just skip this code
	// in that case to avoid ugly pop-ups about being unable to start the 
	// applications because the system is shutting down.
	//
	if (ERROR_SUCCESS != uExitCode &&
		ERROR_SUCCESS_REBOOT_REQUIRED != uExitCode &&
		ERROR_SUCCESS_REBOOT_INITIATED != uExitCode)
	{
		// First unregister the installer from the temp. location.
		if (TEXT('\0') != g_szTempStore && 
			FileExists (TEXT("msiexec.exe"), g_szTempStore, ARRAY_ELEMENTS(g_szTempStore), FALSE) &&
			FileExists (TEXT("msi.dll"), g_szTempStore, ARRAY_ELEMENTS(g_szTempStore), FALSE) &&
			SetCurrentDirectory(g_szTempStore))
		{
			DebugMsg((TEXT("Unregistering the installer from the temporary location.")));
			RunProcess (g_szExecLocal, g_szUnregister, Status);
		}
		// Then reregister the installer from the system folder if possible.
		if (TEXT('\0') != g_szSystemDir &&
			SetCurrentDirectory(g_szSystemDir) &&
			FileExists (TEXT("msiexec.exe"), g_szSystemDir, ARRAY_ELEMENTS(g_szSystemDir), FALSE) &&
			FileExists (TEXT("msi.dll"), g_szSystemDir, ARRAY_ELEMENTS(g_szSystemDir), FALSE))
		{
			DebugMsg((TEXT("Reregistering the installer from the system folder.")));
			RunProcess (g_szExecLocal, g_szRegister, Status);
		}
		
		//
		// The rereg value that we put in the run once key is not required
		// anymore. So get rid of it.
		//
		if (TEXT('\0') != g_szRunOnceRereg[0])
		{
			DebugMsg((TEXT("Deleting the RunOnce value for registering the installer from the temp. folder.")));
			DelRunOnceValue (g_szRunOnceRereg);
		}
		
		//
		// Purge NT4 upgrade migration inf and cat files since they are not
		// queued up for deletion upon reboot. Ignore any errors.
		//
		PurgeNT4MigrationFiles();
	}
	else
	{
		//
		// If we are on NT4, register our exception package on success so that 
		// upgrades to Win2K don't overwrite our new darwin bits with its older bits
		// Ignore errors.
		//
		HandleNT4Upgrades();
	}

	// Exit the process
	DebugMsg((TEXT("Exiting msiinst.exe with error code %d."), uExitCode));
	ExitProcess (uExitCode);
}

//+--------------------------------------------------------------------------
//
//  Function:	ModifyCommandLine
//
//  Synopsis:	Looks at the command line and adds any transform information
//				if necessary. It also generates the command line for suppressing
//				reboots if the "delayreboot" option is chosen.
//
//  Arguments:	[in] szCmdLine : the original command line with which msiinst is invoked.
//				[in] opMode : indicate the operation mode for msiinst: normal, delayed boot with UI or delayed boot without UI
//				[in] fRebootRequested : a reboot is requested is needed due to processing to this point
//				[out] szFinalCmdLine : the processed commandline.
//
//  Returns:	ERROR_SUCCESS if succesful.
//				an error code otherwise.
//
//  History:	10/10/2000  RahulTh  created
//
//  Notes:		This function does not verify the validity of the passed in
//				parameters. That is the responsibility of the caller.
//
//---------------------------------------------------------------------------
DWORD ModifyCommandLine (IN LPCTSTR szCmdLine,
						 IN const OPMODE	opMode,
						 IN const BOOL fRebootRequested,
						 IN DWORD cchSize,
						 OUT LPTSTR szFinalCmdLine
						 )
{
	WIN32_FIND_DATA FindFileData;
	HANDLE			hFind = INVALID_HANDLE_VALUE;
	IStorage*		piStorage = NULL;
	const OLECHAR * szwImport;
	HRESULT			hResult;
	LANGID			wLanguage;
	const TCHAR *	szCommand;
	BOOL fRebootNeeded = FALSE;
	const TCHAR szInstallSDBProperty[] = TEXT(" INSTALLSDB=1");
	
	switch (opMode)
	{
	case opNormal:
		fRebootNeeded = fRebootRequested;
		// reboots not allowed in any of the quiet modes.
	case opNormalQuiet:
		szCommand = szCmdLine;
		break;
	case opDelayBoot:
		szCommand = g_szDelayedBootCmdLine;
		break;
	case opDelayBootQuiet:
		szCommand = g_szDelayedBootCmdLineQuiet;
		break;
	default:
		DebugMsg((TEXT("Invalid operation mode: %d."), opMode));
		break;
	}
	
	// Find the database, and open the storage to look for transforms
	hFind = FindFirstFile(TEXT("*msi.msi"), &FindFileData);
	if (INVALID_HANDLE_VALUE == hFind) 
		return GetLastError();
	FindClose(hFind);

	DebugMsg((TEXT("Found MSI Database: %s"), FindFileData.cFileName));

	// convert base name to unicode
#ifndef UNICODE
	OLECHAR rgImportPathBuf[MAX_PATH];
	int cchWide = ::MultiByteToWideChar(CP_ACP, 0, (LPCTSTR)FindFileData.cFileName, -1, rgImportPathBuf, MAX_PATH);
	szwImport = rgImportPathBuf;
#else	// UNICODE
	szwImport = FindFileData.cFileName;
#endif

	DWORD dwReturn = ERROR_SUCCESS;
	hResult = StgOpenStorage(szwImport, (IStorage*)0, STGM_READ | STGM_SHARE_EXCLUSIVE, (SNB)0, (DWORD)0, &piStorage);
	if (S_OK == hResult)
	{

		// choose the appropriate transform

		// This algorithm is basically MsiLoadString.  It needs to stay in sync with 
		// MsiLoadStrings algorithm
		wLanguage = GetUserDefaultLangID();

		if (wLanguage == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SINGAPORE))   // this one language does not default to base language
			wLanguage  = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
	
		if (!FindTransform(piStorage, wLanguage)   // also tries base language and neutral
		  && (!FindTransform(piStorage, wLanguage = (WORD)GetUserDefaultLangID())) 
		  && (!FindTransform(piStorage, wLanguage = (WORD)GetSystemDefaultLangID())) 
		  && (!FindTransform(piStorage, wLanguage = LANG_ENGLISH)
		  && (!FindTransform(piStorage, wLanguage = LANG_NEUTRAL))))
		{
			// use default
			if (fRebootNeeded)
			{		
				StringCchPrintf(szFinalCmdLine, cchSize, TEXT("%s %s=%s"), szCommand, g_szMsiRebootProperty, g_szMsiRebootForce);
			}
			else
			{
				StringCchCopy(szFinalCmdLine, cchSize, szCommand);
				szFinalCmdLine[cchSize-1] = TEXT('\0');
			}
			DebugMsg((TEXT("No localized transform available.")));
		}
		 else
		{
			// this assumes that there is no REBOOT property set from the instmsi.sed file when fRebootNeeded == FALSE
			TCHAR* pszFormat = (fRebootNeeded) ? TEXT("%s TRANSFORMS=:%d.mst %s=%s") : TEXT("%s TRANSFORMS=:%d.mst");

			// use the transform for the given language.
			StringCchPrintf(szFinalCmdLine, cchSize, pszFormat, szCommand, wLanguage, g_szMsiRebootProperty, g_szMsiRebootForce);
		}

		piStorage->Release();
	}
	else
	{
		return GetWin32ErrFromHResult(hResult);
	}
	
	if ( ShouldInstallSDBFiles() )
	{
		dwReturn = StringCchCat(szFinalCmdLine, cchSize, szInstallSDBProperty);
		if ( FAILED(dwReturn) )
			dwReturn = GetWin32ErrFromHResult(dwReturn);
	}
	
	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinst\unicode\makefile.inc ===
!INCLUDE ..\prot.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinst\utils.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

	utils.cpp

Abstract:

	Helper functions

Author:

	Rahul Thombre (RahulTh)	10/8/2000

Revision History:

	10/8/2000	RahulTh			Created this module.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <strsafe.h>
#include "debug.h"
#include "utils.h"
#include "migrate.h"

#ifndef STRSAFE_NO_DEPRECATE
#define STRSAFE_NO_DEPRECATE
#endif
#include "StrSafe.h"

#ifdef UNICODE
#define stringcmpni _wcsnicmp
#define stringstr	wcsstr
#else
#define stringcmpni _strnicmp
#define stringstr	strstr
#endif

#define MAX_DIRS_ATTEMPTED	9999
#define MAX_REGVALS_ATTEMPTED	999

const TCHAR szRunOnceKeyPath[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");

#define __MSI_NO_LOCALE  (MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT))

//+--------------------------------------------------------------------------
//
//  Function:	TerminateGfxControllerApps
//
//  Synopsis:	Forcibly terminates the applications igfxtray.exe and
//				hkcmd.exe.
//
//  Arguments:	none.
//
//  Returns:	ERROR_SUCCESS if succesful.
//				an error code otherwise.
//
//  History:	7/25/2001  RahulTh  created
//
//  Notes:		It was found that 2 apps. igfxtray.exe and hkcmd.exe, which are
//				installed with the display adapters for Intel(R) 82815 Graphics
//				controller open all the registered services on the system when
//				they start up but do not close the handles when they are done
//				with them. Both of these apps. are launched via the Run key
//				and therefore they run as long as the user is logged on. igfxtray.exe
//				is a tray icon app. which lets the user change the display resolutions
//				colors etc. hkcmd.exe is a hotkey command app. which has similar
//				functions. The fact that these apps. hold on to the MSI service
//				causes problems for instmsi when it tries to register the new
//				binaries from a temp. location. This is because msiexec /regserver
//				does a DeleteService followed by CreateService. Due to the open
//				handles, the DeleteService does not really end up deleting the
//				service. Instead, it just gets marked for deletion. Therefore,
//				the CreateService call fails with ERROR_SERVICE_MARKED_FOR_DELETE
//				and the registration fails. This failure is fatal for instmsi and
//				it quits. This creates problems for several bootstrapped installs
//				which depend on instmsi to update the version of the installer on
//				the system. In order to allow them to succeed, the only recourse
//				was to terminate the 2 apps. which are holding on to the MSI
//				service.
//
//				Note: It isn't really necessary to restart the apps. after we
//				are done, because the fact that the MSI service already exists
//				on the system (which is evident from the fact that the CreateService
//				fails with ERROR_SERVICE_MARKED_FOR_DELETE), means that instmsi will
//				most likely require a reboot. So it is okay to not restart the apps.
//
//				Also note that there is no point on doing this on Win9X because
//				it does not have a concept of a service and therefore this situation
//				should never arise on those systems.
//
//---------------------------------------------------------------------------
DWORD TerminateGfxControllerApps(void)
{
	DWORD	Status = ERROR_SUCCESS;
	PUCHAR	CommonLargeBuffer = NULL;
	ULONG 	CommonLargeBufferSize = 64 * 1024;
	HANDLE	hProcess = NULL;
	HANDLE	hProcess1 = NULL;
	ULONG 	TotalOffset = 0;
	BOOL	bTerminationSuccessful = FALSE;
	
	HMODULE	hModulentdll = NULL;
	PFNNTQUERYSYSINFO	pfnNtQuerySystemInformation = NULL;
	
	PSYSTEM_PROCESS_INFORMATION ProcessInfo = NULL;
	PSYSTEM_PROCESS_INFORMATION PrevProcessInfo = NULL;
	
	// Nothing to do on Win9X
	if (g_fWin9X)
		goto TerminateGfxControllerAppsEnd;
	
	DebugMsg((TEXT("Will now attempt to terminate igfxtray.exe and hkcmd.exe, if they are running.")));
	
	// First get the function pointers for the functions that we are going to use.
	pfnNtQuerySystemInformation = (PFNNTQUERYSYSINFO) GetProcFromLib (TEXT ("ntdll.dll"),
																	  "NtQuerySystemInformation",
																	  &hModulentdll
																	  );
	if (! pfnNtQuerySystemInformation)
	{
		Status = ERROR_PROC_NOT_FOUND;
		goto TerminateGfxControllerAppsEnd;
	}
	
	while (TRUE)
	{
		if (NULL == CommonLargeBuffer)
		{
			CommonLargeBuffer = (PUCHAR) VirtualAlloc (NULL,
													   CommonLargeBufferSize,
													   MEM_COMMIT,
													   PAGE_READWRITE);
			if (NULL == CommonLargeBuffer)
			{
				Status = ERROR_OUTOFMEMORY;
				goto TerminateGfxControllerAppsEnd;
			}
		}

		Status = pfnNtQuerySystemInformation (
						SystemProcessInformation,
						CommonLargeBuffer,
						CommonLargeBufferSize,
						NULL
						);

		if (STATUS_INFO_LENGTH_MISMATCH == Status)
		{
			CommonLargeBufferSize += 8192;
			VirtualFree (CommonLargeBuffer, 0, MEM_RELEASE);
			CommonLargeBuffer = NULL;
		}
		else if (STATUS_SUCCESS != Status)
		{
			// Use a generic Win32 error code rather than returning an NTSTATUS
			Status = STG_E_UNKNOWN;
			goto TerminateGfxControllerAppsEnd;
		}
		else //STATUS_SUCCESS
		{
			break;
		}
	}
	
	// If we are here, we have got the process information.
	ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) CommonLargeBuffer;
	//
	// Note: The NextEntryOffset for the last process is 0. Therefore
	// we track the current process in the structure that we are looking at
	// and the previous process that we had just looked at. If both of them
	// are the same, we know that we have looked at all of them. At each iteration,
	// we move PrevProcessInfo and ProcessInfo ahead by the NextEntryOffset.
	//
	while (PrevProcessInfo != ProcessInfo)
	{
		//
		// Note: We know that this code will never be executed on Win9X, so it
		// is okay to call the unicode versions of lstrcmpi. If this code is ever
		// going to be used on Win9X, then explicit conversion to ANSI will be
		// required before the comparison, since lstrcmpiW is just a stub in
		// Win9X and always returns success, so we will end up killing every
		// process on the system.
		//
		if 
		(
			ProcessInfo->ImageName.Buffer &&
			(
			 CSTR_EQUAL == CompareStringW (__MSI_NO_LOCALE, NORM_IGNORECASE, ProcessInfo->ImageName.Buffer, -1, L"igfxtray.exe", -1) ||
			 CSTR_EQUAL == CompareStringW (__MSI_NO_LOCALE, NORM_IGNORECASE, ProcessInfo->ImageName.Buffer, -1, L"hkcmd.exe", -1)
			)
		)
		{
			// Reset the flag for this process.
			bTerminationSuccessful = FALSE;
			
			hProcess1 = OpenProcess (PROCESS_TERMINATE,
									 FALSE,
									 (DWORD)(DWORD_PTR)ProcessInfo->UniqueProcessId
									 );
			if (hProcess1)
			{
				hProcess = OpenProcess (PROCESS_TERMINATE,
										FALSE,
										(DWORD)(DWORD_PTR)ProcessInfo->UniqueProcessId
										);
				if (NULL != hProcess && TerminateProcess (hProcess, 1))
				{
					bTerminationSuccessful = TRUE;
					DebugMsg((TEXT("Successfully terminated %s."), ProcessInfo->ImageName.Buffer));
				}
				else
				{
					// Track any errors encountered.
					Status = GetLastError();
				}
				
				if (hProcess) 
				{
					CloseHandle (hProcess);
					hProcess = NULL;
				}
				
				CloseHandle (hProcess1);
				hProcess1 = NULL;
			}
			else
			{
				// Track any errors encountered.
				Status = GetLastError();
			}
			
			if (!bTerminationSuccessful)
			{
				DebugMsg((TEXT("Could not terminate %s."), ProcessInfo->ImageName.Buffer));
			}
		}
		
		// Move on to the next process.
		PrevProcessInfo = ProcessInfo;
		TotalOffset += ProcessInfo->NextEntryOffset;
		ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &CommonLargeBuffer[TotalOffset];
	}
	
TerminateGfxControllerAppsEnd:
	// Clean up.
    if (CommonLargeBuffer)
        VirtualFree (CommonLargeBuffer, 0, MEM_RELEASE);
	
	if (hModulentdll)
		FreeLibrary(hModulentdll);
	
	return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:	DelNodeExportFound
//
//  Synopsis:	Check to see if the DelNodeRunDLL32 export can be found in
//				advpack.dll
//
//  Arguments:	none.
//
//  Returns:	TRUE: if the export was found.
//				FALSE: if the export could not be found, or the file was not
//						found or if some other error was encountered.
//
//  History:	12/26/2001  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL DelNodeExportFound (void)
{
	BOOL bStatus = FALSE;
	HMODULE hModule = NULL;
	PFNDELNODERUNDLL32 pfnDelNodeRunDLL32 = NULL;
	
	pfnDelNodeRunDLL32 = (PFNDELNODERUNDLL32) GetProcFromLib (TEXT("advpack.dll"),
															  "DelNodeRunDLL32",
															  &hModule
															  );
	// The required export was successfully found.
	if (pfnDelNodeRunDLL32)
		bStatus = TRUE;
	
	if (hModule)
	{
		FreeLibrary (hModule);
		hModule = NULL;
	}
	
	return bStatus;
}


//+--------------------------------------------------------------------------
//
//  Function:	GetRunOnceEntryName
//
//  Synopsis:	Gets a unique name for a value to be created under the RunOnce
//				key
//
//  Arguments:	[out] pszValueName : A pointer to the string that will hold the
//                                  name of the value
//             [in] cchValueNameBuf : size of pszValueName buffer
//
//  Returns:	ERROR_SUCCESS : if successful in generating a unique name.
//				A failure code otherwise.
//
//  History:	10/8/2000  RahulTh  created
//
//  Notes:		This function will return ERROR_FILE_NOT_FOUND if it cannot
//				generate a unique name owing to the fact that all the possible
//				names that it tries have already been taken -- extremely
//				unlikely.
//
//				It returns ERROR_INVALID_PARAMETER if a NULL parameter is passed.
//				This function does not validate the size of the buffer. It is 
//				the callers responsibility to provide a large enough buffer.
//
//				pszValueName must point to a buffer large enough to hold 10
//				characters since this function can potentially return a name
//				of the form InstMsinnn
//
//				If the function fails, pszValueName will contain an empty
//				string
//
//---------------------------------------------------------------------------
DWORD GetRunOnceEntryName (OUT LPTSTR pszValueName, IN size_t cchValueNameBuf)
{
	static const TCHAR  szPrefix[] = TEXT("InstMsi");
	static const TCHAR	szEmpty[] = TEXT(" ");
	static const LONG	ccbDataSize = 10 * sizeof(TCHAR);
	TCHAR				szData[10];
	DWORD				cbData;
	DWORD				cbSetData;
	DWORD				dwStatus = ERROR_SUCCESS;
	HKEY				hRunOnceKey = NULL;
	
	if (NULL == pszValueName)
	{
		dwStatus = ERROR_INVALID_PARAMETER;
		goto GetRunOnceEntryNameEnd;
	}
	
	dwStatus = RegOpenKey (HKEY_LOCAL_MACHINE, szRunOnceKeyPath, &hRunOnceKey);
	if (ERROR_SUCCESS != dwStatus)
		goto GetRunOnceEntryNameEnd;
	
	for (int i = 0; i <= MAX_REGVALS_ATTEMPTED; i++)
	{
		//
		// Try all names from InstMsi000 to InstMsi999 until a name is found
		// that has not been taken
		//
		dwStatus = StringCchPrintf(pszValueName, cchValueNameBuf,
											TEXT("%s%d"), szPrefix, i);
		if ( FAILED(dwStatus) )
		{
			dwStatus = GetWin32ErrFromHResult(dwStatus);
			goto GetRunOnceEntryNameEnd;
		}
		
		//
		// The szData buffer was randomly chosen to have a length of 10
		// characters. We don't really use that information anyway. It is
		// merely a way of figuring out if a particular value exists or not.
		//
		cbData = ccbDataSize;
		dwStatus = RegQueryValueEx (hRunOnceKey, 
									pszValueName, 
									NULL,			// Reserved.
									NULL,			// Type information not required.      
									(LPBYTE)szData, 
									&cbData);
		
		if (ERROR_SUCCESS == dwStatus || ERROR_MORE_DATA == dwStatus)
		{
			// The value exists. Try the next one
			continue;
		}
		else if (ERROR_FILE_NOT_FOUND == dwStatus)
		{
			//
			// We have found an unused name. Reserve this value for later
			// use by creating the value with an empty string as its data.
			//
			cbSetData = g_fWin9X ? 2 * sizeof(TCHAR) : 1 * sizeof(TCHAR);
			dwStatus = RegSetValueEx (hRunOnceKey, 
									  pszValueName, 
									  NULL,			// Reserved
									  REG_SZ, 
									  (CONST BYTE *) szEmpty, 
									  cbSetData		// The values passed in are different on Win9x and NT
									);
			break;
		}
		else	// Some other error occurred
		{
			break;
		}
	}
	
	// Somehow all of the values are taken -- almost impossible.
	if (i > MAX_REGVALS_ATTEMPTED)
		dwStatus = ERROR_FILE_NOT_FOUND;
	
GetRunOnceEntryNameEnd:
	if (hRunOnceKey)
		RegCloseKey(hRunOnceKey);
	
	if (ERROR_SUCCESS != dwStatus && NULL != pszValueName)
		pszValueName[0] = TEXT('\0');
	
	if (ERROR_SUCCESS == dwStatus)
	{
		DebugMsg((TEXT("Found unused RunOnce entry : %s"), pszValueName));
	}
	
	return dwStatus;
}

//+--------------------------------------------------------------------------
//
//  Function:	SetRunOnceValue
//
//  Synopsis:	Sets a value under the RunOnce key.
//
//  Arguments:	[in] szValueName :  name of the value to set.
//				[in] szValue :		the value
//
//  Returns:	ERROR_SUCCESS if succesful
//				an error code otherwise
//
//  History:	10/8/2000  RahulTh  created
//
//  Notes:		This function returns ERROR_INVALID_PARAMETER if a NULL pointer
//				or an empty string is passed in as a the name of the value.
//
//---------------------------------------------------------------------------
DWORD SetRunOnceValue (IN LPCTSTR szValueName,
					   IN LPCTSTR szValue
					   )
{
	static const TCHAR 	szEmpty[] 	= TEXT(" ");
	HKEY				hRunOnceKey = NULL;
	DWORD				dwStatus	= ERROR_SUCCESS;
	const TCHAR *		szValString;
	DWORD				cbData;
	
	if (NULL == szValueName || TEXT('\0') == szValueName[0])
	{
		dwStatus = ERROR_INVALID_PARAMETER;
		goto SetRunOnceValueEnd;
	}
	
	dwStatus = RegOpenKey (HKEY_LOCAL_MACHINE, szRunOnceKeyPath, &hRunOnceKey);
	if (ERROR_SUCCESS != dwStatus)
		goto SetRunOnceValueEnd;
	
	szValString = (NULL == szValue || TEXT('\0') == szValue[0]) ? szEmpty : szValue;
	
	cbData = g_fWin9X ? sizeof(TCHAR) : 0;
	cbData += (lstrlen(szValString) * sizeof(TCHAR));
	dwStatus = RegSetValueEx (hRunOnceKey,
							  szValueName,
							  NULL,			// Reserved
							  REG_SZ,
							  (CONST BYTE *) szValString,
							  cbData);

SetRunOnceValueEnd:
	if (hRunOnceKey)
		RegCloseKey(hRunOnceKey);
	
	return dwStatus;
}

//+--------------------------------------------------------------------------
//
//  Function:	DelRunOnceValue
//
//  Synopsis:	Deletes a named value under the RunOnce key.
//
//  Arguments:	[in] szValueName :  name of the value.
//
//  Returns:	ERROR_SUCCESS if succesful
//				an error code otherwise
//
//  History:	10/11/2000  RahulTh  created
//
//  Notes:		This function returns ERROR_SUCCESS and is a no-op if a NULL 
//				pointer or an empty string is passed in as a the name of the 
//				value.
//
//---------------------------------------------------------------------------
DWORD DelRunOnceValue (IN LPCTSTR szValueName)
{
	HKEY				hRunOnceKey = NULL;
	DWORD				dwStatus	= ERROR_SUCCESS;
	
	// Nothing to do if no value name is specified.
	if (NULL == szValueName || TEXT('\0') == szValueName[0])
		goto DelRunOnceValueEnd;
	
	dwStatus = RegOpenKey (HKEY_LOCAL_MACHINE, szRunOnceKeyPath, &hRunOnceKey);
	if (ERROR_SUCCESS != dwStatus)
		goto DelRunOnceValueEnd;
	
	dwStatus = RegDeleteValue (hRunOnceKey,
							   szValueName
							   );
		
DelRunOnceValueEnd:
	if (hRunOnceKey)
		RegCloseKey(hRunOnceKey);
	
	return dwStatus;
}

//+--------------------------------------------------------------------------
//
//  Function:	GetTempFolder
//
//  Synopsis:	Creates a unique temporary folder in the user's temp directory
//
//  Arguments:	[out] pszFolder : pointer to the string for storing the path.
//
//  Returns:	ERROR_SUCCESS if successful.
//				an error code otherwise.
//
//  History:	10/9/2000  RahulTh  created
//
//  Notes:		If this functions fails, pszFolder will be an empty string.
//				
//				The function tries to create a temp. folder in the user's temp.
//				directory with the name of the form Msinnnn. It tries all
//				values from 0 to 9999. If it cannot find any, then it fails
//				with ERROR_FILE_NOT_FOUND.
//
//
//				If for some reason the temp. folder name is longer than
//				MAX_PATH, this function will fail with ERROR_BUFFER_OVERFLOW.
//
//				If a NULL buffer is passed in, the function returns
//				INVALID_PARAMETER. Other validity checks are not performed
//				on the buffer. That is the caller's responsibility.
//
//---------------------------------------------------------------------------
DWORD GetTempFolder (OUT LPTSTR pszFolder, IN size_t cchFolder)
{
	TCHAR   pszPath[MAX_PATH];
	TCHAR	pszTempDir[MAX_PATH];
	DWORD	dwStatus = ERROR_SUCCESS;
	BOOL	bStatus;
	size_t	cchLen = 0;
	
	if (! pszFolder)
		return ERROR_INVALID_PARAMETER;
	
	*pszFolder = TEXT('\0');
	
	// Get the path to the installer directory
	dwStatus = GetMsiDirectory (pszTempDir, MAX_PATH);
	if (ERROR_SUCCESS != dwStatus)
		return dwStatus;

	RETURN_IT_IF_FAILED(StringCchLength(pszTempDir,
													ARRAY_ELEMENTS(pszTempDir),
													&cchLen));
	
	//
	// We just use MAX_PATH because Win9x cannot handle paths longer than 
	// that anyway. Usually MAX_PATH should be enough, but if it is not
	// then we just bail out.
	//
	// Note: The actual temp. folder will be of the form 
	// %systemroot%\installer\InstMSInnnn so we need to make sure that the 
	// entire path does not exceed MAX_PATH
	//
	if (cchLen + 13 > MAX_PATH)
		return ERROR_BUFFER_OVERFLOW;
	
	// Try to create the temporary folder. We start with InstMsi0000 to InstMsi9999
	for (int i = 0; i <= MAX_DIRS_ATTEMPTED; i++)
	{
		RETURN_IT_IF_FAILED(StringCchPrintf(pszPath,
														ARRAY_ELEMENTS(pszPath),
														TEXT("%s\\InstMsi%d"), pszTempDir, i));

		bStatus = CreateDirectory (pszPath, NULL);
		if (!bStatus)
		{
			dwStatus = GetLastError();
			if (ERROR_ALREADY_EXISTS != dwStatus)
				return dwStatus;
			
			// Try the next name if this one already exists.
		}
		else
		{
			break;
		}
	}
	
	// All possible names have already been taken. Very unlikely
    if (i > MAX_DIRS_ATTEMPTED)
		return ERROR_FILE_NOT_FOUND;
	
	// If we are here, then we have successfully created a unique temp.
	// folder for ourselves. Update the passed in buffer with this data.
	RETURN_IT_IF_FAILED(StringCchCopy(pszFolder, cchFolder, pszPath));
	
	DebugMsg((TEXT("Temporary store located at : %s"), pszFolder));
	
	return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:	DecryptIfNecessary
//
//  Synopsis:	Decrypts a file if it is encrpyted.
//
//  Arguments:  [in] pszPath : Full path to the file being decrypted.
//				[in] pfnDecryptFile : pointer to the DecryptFile function.
//
//  Returns:	ERROR_SUCCESS : if the decryption was successful.
//				a Win32 error code otherwise.
//
//  History:	12/23/2001  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD DecryptIfNecessary (IN LPCTSTR pszPath,
						  IN const PFNDECRYPTFILE pfnDecryptFile)
{
	DWORD	dwFileAttributes = INVALID_FILE_ATTRIBUTES;
		
	if (!pszPath || 0 == *pszPath)
		return ERROR_INVALID_PARAMETER;
	
	//
	// Need to do this only for NT machines and that too only on Win2K and
	// higher because DecryptFile is supported only on Win2K and higher.
	//
#ifdef UNICODE
	if (!g_fWin9X)
	{
		//
		// If the DecryptFile function could not be found, the most likely reason
		// is that encryption is not supported on the system. So the file cannot
		// be encrypted. Therefore, we treat it as a successful decryption.
		//
		if (!pfnDecryptFile)
			return ERROR_SUCCESS;
		
		// Find out if the file is encrypted.
		dwFileAttributes = GetFileAttributes (pszPath);
		if (INVALID_FILE_ATTRIBUTES == dwFileAttributes)
			return GetLastError();

		// Decrypt the file if it is encrypted.
		if (FILE_ATTRIBUTE_ENCRYPTED & dwFileAttributes)
		{
			if (! ((*pfnDecryptFile)(pszPath, 0)))
				return GetLastError();
		}
	}
#endif

	return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:	CopyFileTree
//
//  Synopsis:	Recursively copies the contents of one folder into another
//
//  Arguments:	[in] pszExistingPath : The location to copy the files from.
//				[in] cchExistingPathBuf : size of pszExistingPath buffer.
//				[in] pszNewPath : The location to copy the files to.
//				[in] cchNewPathBuf : size of pszNewPath buffer.
//				[in] pfnMoveFileEx : pointer to the MoveFileEx function.
//				[in] pfnDecryptFile : pointer to the pfnDecryptFile function.
//
//  Returns:	ERROR_SUCCESS : if the copy was successful.
//				an error code otherwise.
//
//  History:	10/9/2000  RahulTh  created
//
//  Notes:		This function cannot handle paths longer than MAX_PATH.
//				because it needs to run on Win9x too which cannot handle
//				paths longer than that. At any rate, the folder is only
//				one level deep, so we should be fine.
//
//				In the event of a name class, this function clobbers 
//				existing files at the destination.
//
//---------------------------------------------------------------------------
DWORD CopyFileTree(
	IN const TCHAR * pszExistingPath, 
	IN const size_t cchExistingPathBuf,
	IN const TCHAR * pszNewPath,
	IN const size_t cchNewPathBuf,
	IN const PFNMOVEFILEEX pfnMoveFileEx,
	IN const PFNDECRYPTFILE pfnDecryptFile	
	)
{
    HANDLE			hFind;
    WIN32_FIND_DATA	FindData;
    TCHAR			szSource[MAX_PATH+2]; 
								// + 2 for missing trailing slash & '*'
    TCHAR *     	pszSourceEnd = NULL;
    TCHAR			szDest[MAX_PATH+1]; // +1 for possible trailing slash
    TCHAR *     	pszDestEnd = 0;
    DWORD       	FileAttributes;
    DWORD       	Status;
    BOOL        	bStatus;
    size_t      	lenSource;
    size_t      	lenDest;
    size_t      	lenFileName;

    if (! pszExistingPath || ! pszNewPath)
        return ERROR_PATH_NOT_FOUND;

	 RETURN_IT_IF_FAILED(StringCchLength(pszExistingPath, cchExistingPathBuf,
													 &lenSource));
	 RETURN_IT_IF_FAILED(StringCchLength(pszNewPath, cchNewPathBuf,
													 &lenDest));

    if (! lenSource || ! lenDest)
        return ERROR_PATH_NOT_FOUND;
	
	//
	// Bail out for paths longer than MAX_PATH because Win9x cannot handle them
	// anyway
	//
	if (lenSource >= MAX_PATH || lenDest >= MAX_PATH)
		return ERROR_BUFFER_OVERFLOW;

	// Set up the string used to search for files in the source.
    RETURN_IT_IF_FAILED(StringCchCopy(szSource, ARRAY_ELEMENTS(szSource),
												  pszExistingPath));
    pszSourceEnd = szSource + lenSource;
    if ((lenSource > 0) && (TEXT('\\') != pszSourceEnd[-1]))
	{
        lenSource++;
        *pszSourceEnd++ = '\\';
	}
    pszSourceEnd[0] = TEXT('*');
    pszSourceEnd[1] = 0;

	// Set up the destination
    RETURN_IT_IF_FAILED(StringCchCopy(szDest, ARRAY_ELEMENTS(szDest),
												  pszNewPath));
    pszDestEnd = szDest + lenDest;
    if ((lenDest > 0) && (TEXT('\\') != pszDestEnd[-1]))
	{
        lenDest++;
        *pszDestEnd++ = TEXT('\\');
	}
    *pszDestEnd = 0;

    hFind = FindFirstFile( szSource, &FindData );

	// There is nothing to be done. The source folder is empty.
    if ( INVALID_HANDLE_VALUE == hFind )
        return ERROR_SUCCESS;

    Status = ERROR_SUCCESS;
    do
    {
		RETURN_IT_IF_FAILED(StringCchLength(FindData.cFileName,
														ARRAY_ELEMENTS(FindData.cFileName),
														&lenFileName));
		if (lenFileName + lenDest >= MAX_PATH || lenFileName + lenSource >= MAX_PATH)
			return ERROR_BUFFER_OVERFLOW;
		
		RETURN_IT_IF_FAILED(StringCchCopy(pszSourceEnd,
													 ARRAY_ELEMENTS(szSource) - lenSource,
													 FindData.cFileName));
		RETURN_IT_IF_FAILED(StringCchCopy(pszDestEnd,
													 ARRAY_ELEMENTS(szDest) - lenDest,
													 FindData.cFileName));

		if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			// It is a folder, so recursively copy it.
			if ( lstrcmp( FindData.cFileName, TEXT(".") ) == 0 ||
				 lstrcmp( FindData.cFileName, TEXT("..") ) == 0)
				continue;

			bStatus = CreateDirectory (szDest, NULL);
			if (! bStatus)
				Status = GetLastError();
			else
				Status = CopyFileTree (szSource, ARRAY_ELEMENTS(szSource),
											  szDest, ARRAY_ELEMENTS(szDest),
											  pfnMoveFileEx, pfnDecryptFile);
		}
		else
		{
			//
			// If it is a file, always overwrite the destination. There is
			// no reason why there should be a file at the destination because
			// the destination folder was just created by generating a unique
			// temp. folder that didn't exist already. But it doesn't hurt to
			// take the necessary precautions.
			//
			Status = ERROR_SUCCESS;
			bStatus = CopyFile (szSource, szDest, TRUE);
			if (! bStatus)
				Status = GetLastError();
			if ( ERROR_FILE_EXISTS == Status || ERROR_ALREADY_EXISTS == Status)
			{
				//
				// Save off the attribute just in case we need to reset it
				// upon failure.
				//
				FileAttributes = GetFileAttributes( szDest );

				if ( 0xFFFFFFFF != FileAttributes )
				{
					// Make sure the file is writeable and then clobber it.
					Status = ERROR_SUCCESS;
					SetFileAttributes( szDest, FILE_ATTRIBUTE_NORMAL );
					bStatus = CopyFile ( szSource, szDest, FALSE );
					if (!bStatus)
					{
						Status = GetLastError();
						SetFileAttributes( szDest, FileAttributes );
					}
				}
				else
				{
					Status = GetLastError();
				}
			}

			//
			// Note that IExpress expands its contents into the %temp% folder.
			// This folder lies in the user's profile. If this folder is encrypted,
			// then all the binaries will end up being encrypted by the user and therefore
			// when copied to the system folder, they will be unusable by the system.
			// So we must Decrypt the file if necessary after copying.
			//
			if (ERROR_SUCCESS == Status)
				Status = DecryptIfNecessary(szDest, pfnDecryptFile);

			//
			// On NT based systems, set up the file for deletion upon reboot.
			// However, don't delete any inf or catalog files that might get
			// registered as exception packages.
			//
			if (!g_fWin9X && pfnMoveFileEx && !IsExcpInfoFile(FindData.cFileName))
			{
				(*pfnMoveFileEx)(szDest, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
				//
				// Also make sure that the file is writeable otherwise
				// MoveFileEx won't delete it.
				//
				SetFileAttributes (szDest, FILE_ATTRIBUTE_NORMAL);
			}
		}

		if ( Status != ERROR_SUCCESS )
			break;

	} while ( FindNextFile( hFind, &FindData ) );

	FindClose( hFind );
	
	//
	// Set the folder for deletion on reboot on NT based systems.
	// Note: MoveFileEx is not supported on Win9X, therefore it must be
	// #ifdef'ed out.
	// Note: The folder should always be deleted AFTER its contents -- for 
	// obvious reasons.
	//
	if (! g_fWin9X && pfnMoveFileEx)
	{
		(*pfnMoveFileEx)(pszNewPath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
		//
		// Also make sure that the file is writeable otherwise
		// MoveFileEx won't delete it.
		//
		SetFileAttributes (pszNewPath, FILE_ATTRIBUTE_NORMAL);
	}

	return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:	GetOperationModeA
//
//  Synopsis:	This function examines the commandline parameters to determine
//				the operation mode: normal, delayed reboot with UI or delayed
//				reboot without UI.
//
//  Arguments:	[in] argc : # of arguments
//				[in] argv : the array of arguments
//
//  Returns:	one of the OPMODE values depending on the commandline parameters
//
//  History:	10/10/2000  RahulTh	created
//              05/03/2001  RahulTh	changed to ANSI to avoid using CommandLineToArgvW
//					for unicode and to avoid loading shell32.dll	
//
//  Notes:	This function is purely ANSI regardless of whether it is built
//		ANSI or Unicode.
//
//---------------------------------------------------------------------------
OPMODE GetOperationModeA (IN int argc, IN LPSTR * argv)
{
	OPMODE	retOP = opNormal;
	
	if (! argv || 1 == argc)
		return retOP;
	
	for (int i = 0; i < argc; i++)
	{
		if ('/' == argv[i][0] || '-' == argv[i][0])
		{
			if (CSTR_EQUAL == CompareStringA(__MSI_NO_LOCALE, NORM_IGNORECASE, "delayreboot", -1, argv[i]+1, -1))
			{
				return opDelayBoot;	// The moment we see this option, we ignore all others.
			}
			else if (CSTR_EQUAL == CompareStringA(__MSI_NO_LOCALE, NORM_IGNORECASE, "delayrebootq", -1, argv[i]+1, -1))
			{
				return opDelayBootQuiet;	// The moment we see this option, we ignore all others.
			}
			else if ('q' == argv[i][1])
			{
				if ('\0' == argv[i][2] ||
					(CSTR_EQUAL == CompareStringA(__MSI_NO_LOCALE, NORM_IGNORECASE, "n", -1, argv[i]+2, -1))
					)
				{
					retOP = opNormalQuiet;	// The only absolutely quiet modes are /q and /qn (even /qn+ is not totally quiet)
											// We don't return here because the last quiet option wins, so we must go one
											// until we have seen all arguments (unless we get a "delayreboot" option
				}
				else
				{
					retOP = opNormal;
				}
			}
		}
	}
	
	return retOP;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetWin32ErrFromHResult
//
//  Synopsis:   given an HResult, this function tries to extract the
//              corresponding Win 32 error.
//
//  Arguments:  [in] hr : the hresult value
//
//  Returns:    the Win 32 Error code.
//
//  History:    10/10/2000  RahulTh  created
//
//  Notes:      if hr is not S_OK, the return value will be something other
//              than ERROR_SUCCESS;
//
//---------------------------------------------------------------------------
DWORD GetWin32ErrFromHResult (IN HRESULT hr)
{
    DWORD   Status = ERROR_SUCCESS;

    if (S_OK != hr)
    {
        if (FACILITY_WIN32 == HRESULT_FACILITY(hr))
        {
            Status = HRESULT_CODE(hr);
        }
        else
        {
            Status = GetLastError();
            if (ERROR_SUCCESS == Status)
            {
                //an error had occurred but nobody called SetLastError
                //should not be mistaken as a success.
                Status = (DWORD) hr;
            }
        }
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:	FileExists
//
//  Synopsis:	Checks if a file exists.
//
//  Arguments:	[in] szFileName : name of the file. (can be the full path too)
//				[in] szFolder : folder in which the file resides.
//          [in] cchFolder : szFolder buffer's size.
//				[in] bCheckForDir : if true, checks if a directory by that name
//									exists. Otherwise checks for a file.
//
//  Returns:	TRUE : if the file exists.
//				FALSE : otherwise.
//
//  History:	10/12/2000  RahulTh  created
//
//  Notes:		If szFolder is neither NULL nor an empty string, then
//				szFileName cannot be the full path to the file, because this
//				function simply concatenates the two to generate the actual
//				filename.
//
//				The function does not check for the validity of szFileName.
//
//---------------------------------------------------------------------------
BOOL FileExists(IN LPCTSTR szFileName,
				IN LPCTSTR szFolder,
				IN size_t cchFolder,
				IN BOOL bCheckForDir
				)
{
	TCHAR	szEmpty[] = TEXT("");
	TCHAR	szFullPath[MAX_PATH];
	BOOL	fExists = FALSE;
	UINT	iCurrMode;
	size_t	iLen = 0;
	DWORD	dwAttributes;
	
	if (! szFolder)
	{
		szFolder = szEmpty;
		cchFolder = 0;
	}
	
	if (! szFileName)
		szFileName = szEmpty;
	
	HRESULT hRes = StringCchLength(szFolder, cchFolder, &iLen);
	if ( FAILED(hRes) )
	{
		hRes = GetWin32ErrFromHResult(hRes);
		DebugMsg((TEXT("StringCchLength failed in FileExists. Return value: %#X"),
					 hRes));
		return FALSE;
	}
	
	if (iLen && TEXT('\\') == szFolder[iLen - 1])
		StringCchPrintf(szFullPath, sizeof(szFullPath)/sizeof(TCHAR), TEXT("%s%s"), szFolder, szFileName); // ignore return - overflow will result in not found
	else
		StringCchPrintf(szFullPath, sizeof(szFullPath)/sizeof(TCHAR), TEXT("%s\\%s"), szFolder, szFileName); // ignore return - overflow will result in not found
	
	// In case our path refers to a floppy drive, disable the "insert disk in drive" dialog
	iCurrMode = SetErrorMode( SEM_FAILCRITICALERRORS );
	dwAttributes = GetFileAttributes (szFullPath);
	if ((DWORD) -1 != dwAttributes)
	{
		if ((bCheckForDir && (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)) ||
			(!bCheckForDir && !(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)))
		{
			fExists = TRUE;
		}
	}
	SetErrorMode(iCurrMode);
	
	return fExists;
}

//+--------------------------------------------------------------------------
//
//  Function:	GetProcFromLib
//
//  Synopsis:	Gets the address of a procedure from a given library.
//
//  Arguments:	[in] szLib : name of the library
//				[in] szProc : name of the proc
//				[out] phModule : handle to the module.
//
//  Returns:	pointer to the function if it was found.
//				NULL otherwise.
//
//  History:	10/17/2000  RahulTh  created
//
//  Notes:		The called is responsible for freeing up the module. If the
//				function fails, the module is guaranteed to be freed.
//
//---------------------------------------------------------------------------
FARPROC GetProcFromLib (IN	LPCTSTR		szLib,
						IN	LPCSTR		szProc,
						OUT	HMODULE *	phModule
						)
{
	FARPROC		pfnProc = NULL;
	
	if (! phModule)
		goto GetProcFromLibEnd;
	
	*phModule = LoadLibrary (szLib);
	
	if (! (*phModule))
	{
		DebugMsg((TEXT("Could not load module %s. Error: %d."), szLib, GetLastError()));
		goto GetProcFromLibEnd;
	}
	
	pfnProc = GetProcAddress(*phModule, szProc);
	
	if (!pfnProc)
	{
		DebugMsg((TEXT("Could not load the specified procedure from %s."), szLib));
	}
	else
	{
		DebugMsg((TEXT("Successfully loaded the specified procedure from %s."), szLib));
	}
	
GetProcFromLibEnd:
	if (!pfnProc && phModule && *phModule)
	{
		FreeLibrary (*phModule);
		*phModule = NULL;
	}
	
	return pfnProc;
}

//+--------------------------------------------------------------------------
//
//  Function:	MyGetWindowsDirectory
//
//  Synopsis:	Gets the path to the Windows Directory (%windir%)
//
//  Arguments:	[out] lpBuffer	: buffer for the windows directory
//				[in]  uSize		: size of the directory buffer
//
//  Returns:	ERROR_SUCCESS if successful.
//				an error code otherwise.
//
//  History:	3/12/2001  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD MyGetWindowsDirectory (OUT LPTSTR lpBuffer,
							 IN UINT	uSize
							 )
{
	typedef UINT (WINAPI *PFNGETWINDIR) (LPTSTR, UINT);
	
	HMODULE					hKernelModule = NULL;
	PFNGETWINDIR			pfnGetWinDir = NULL;
	DWORD					dwStatus = ERROR_SUCCESS;
	UINT					uRet;
	
	if (!lpBuffer || !uSize)
	{
		dwStatus = ERROR_INVALID_PARAMETER;
		goto MyGetWindowsDirectoryEnd;
	}
	
	//
	// First try to get the function for getting the true windows directory
	// (for multi-user systems)
	//
	if (! g_fWin9X)
	{
		DebugMsg((TEXT("Attempting to get function %s."), TEXT("GetSystemWindowsDirectoryA/W")));
		pfnGetWinDir = (PFNGETWINDIR) GetProcFromLib (TEXT("kernel32.dll"), 
													  #ifdef UNICODE
													  "GetSystemWindowsDirectoryW",
													  #else
													  "GetSystemWindowsDirectoryA",
													  #endif
													  &hKernelModule
													  );
	}
	
	// If not, try the standard Windows directory function
	if (! pfnGetWinDir)
	{
		DebugMsg((TEXT("Attempting to get function %s."), TEXT("GetWindowsDirectoryA/W")));
		hKernelModule = NULL;
		pfnGetWinDir = (PFNGETWINDIR) GetProcFromLib (TEXT("kernel32.dll"), 
													  #ifdef UNICODE
													  "GetWindowsDirectoryW",
													  #else
													  "GetWindowsDirectoryA",
													  #endif
													  &hKernelModule
													  );
	}
	
	if (! pfnGetWinDir)
	{
		dwStatus = ERROR_PROC_NOT_FOUND;
		goto MyGetWindowsDirectoryEnd;
	}
	
	uRet = (*pfnGetWinDir)(lpBuffer, uSize);
	
	// Make sure that the buffer was long enough
	if (uRet >= uSize)
	{
		dwStatus = ERROR_BUFFER_OVERFLOW;
		goto MyGetWindowsDirectoryEnd;		
	}

MyGetWindowsDirectoryEnd:
	if (hKernelModule)
		FreeLibrary (hKernelModule);
	
	return dwStatus;
}

//+--------------------------------------------------------------------------
//
//  Function:	GetMsiDirectory
//
//  Synopsis:	Gets the MSI directory (%windir%\Installer). This is the folder
//				in which we create our temp. folder.
//
//  Arguments:	[in] lpBuffer : buffer for the windows directory.
//				[in] uSize : size of the directory buffer.
//
//  Returns:	ERROR_SUCCESS if successful.
//				an error code otherwise.
//
//  History:	10/17/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD GetMsiDirectory (OUT LPTSTR	lpBuffer,
					   IN UINT		uSize
					   )
{
	typedef UINT (WINAPI *PFNCREATEINSTALLERDIR) (DWORD);
	
	HMODULE					hMsiModule = NULL;
	PFNCREATEINSTALLERDIR 	pfnCreateAndVerifyInstallerDir = NULL;
	DWORD					dwStatus = ERROR_SUCCESS;
	UINT					uRet;
	BOOL					bAddSlash = FALSE;
	BOOL					bStatus;
	TCHAR					szMSI[] = TEXT("Installer");
	
	if (!lpBuffer || !uSize)
	{
		dwStatus = ERROR_INVALID_PARAMETER;
		goto GetMsiDirectoryEnd;
	}
	
	if ( FAILED(dwStatus = StringCchLength(g_szWindowsDir, g_cchMaxPath, &uRet)) ||
		  FAILED(dwStatus = StringCchCopy(lpBuffer, uSize, g_szWindowsDir)) )
	{
		dwStatus = GetWin32ErrFromHResult(dwStatus);
		goto GetMsiDirectoryEnd;
	}
	
	// Check if we need to append a slash to make it slash terminated.
	if (uRet > 0 && TEXT('\\') != lpBuffer[uRet - 1])
	{
		uRet++;
		bAddSlash = TRUE;	// Don't add the slash here since we may not have a large enough buffer.
	}
	
	
	// Check if the buffer is really large enough for the entire folder name
	if (uRet + lstrlen(szMSI) >= uSize)
	{
		dwStatus = ERROR_BUFFER_OVERFLOW;
		goto GetMsiDirectoryEnd;
	}
	
	// If we are here we have a large enough buffer. Generate the name of the folder.
	if (bAddSlash)
	{
		lpBuffer[uRet - 1] = TEXT('\\');
		lpBuffer[uRet] = TEXT('\0');
	}
	
	// Generate the name of the folder.
	if ( FAILED(dwStatus = StringCchCat(lpBuffer, uSize, szMSI)) )
	{
		dwStatus = GetWin32ErrFromHResult(dwStatus);
		goto GetMsiDirectoryEnd;
	}
	
	// We have the buffer. Now make sure that we have directory as well.
	DebugMsg((TEXT("Attempting to create folder %s."), lpBuffer));
	
	//
	// Load msi.dll explicitly to avoid the ugly pop-up on Win9x machines
	// if someone accidentally runs the unicode version on Win9x
	//
	pfnCreateAndVerifyInstallerDir = 
		(PFNCREATEINSTALLERDIR) GetProcFromLib (TEXT("msi.dll"),
												"MsiCreateAndVerifyInstallerDirectory",
												&hMsiModule
												);
	if (! pfnCreateAndVerifyInstallerDir)
	{
		DebugMsg((TEXT("Unable to create the installer folder. Incorrect version of msi.dll. Error %d."), GetLastError()));
		dwStatus = ERROR_PROC_NOT_FOUND;
	}
	else
	{
		dwStatus = (*pfnCreateAndVerifyInstallerDir) (0);
	}
	
GetMsiDirectoryEnd:
	if (hMsiModule)
		FreeLibrary (hMsiModule);
	
	if (ERROR_SUCCESS != dwStatus && lpBuffer)
	{
		DebugMsg((TEXT("Could not get temporary installer directory. Error %d."), dwStatus));
		lpBuffer[0] = TEXT('\0');
	}
	
	return dwStatus;
}

//+--------------------------------------------------------------------------
//
//  Function:	ShowErrorMessage
//
//  Synopsis:	Displays an error in a message box depending on the severity
//				and the type of error message (whether it is a system formatted
//				error or one in the resource string)
//
//  Arguments:	[in] uExitCode : The system error code.
//				[in] dwMsgType : A combination of flags indicating the severity and type of messages.
//				[in] dwStringID : resource ID of string the module's resources.
//
//  Returns:	nothing.
//
//  History:	10/18/2000  RahulTh  created
//
//  Notes:		dwStringID is optional. When not provided it is assumed to be
//				IDS_NONE.
//
//				IMPORTANT: MUST USE ANSI VERSIONS OF THE FUNCTIONS HERE.
//				OTHERWISE NONE OF THE MESSAGE POPUPS WILL WORK IF YOU
//				ACCIDENTALLY RUN THE UNICODE BUILDS ON THE WIN9X
//
//---------------------------------------------------------------------------
void ShowErrorMessage (IN DWORD uExitCode,
					   IN DWORD dwMsgType,
					   IN DWORD	dwStringID /* = IDS_NONE*/)
{
	HMODULE	hModule = GetModuleHandle(NULL);
	char *  pszSystemErr = NULL;
	char 	szResErr[256];
	char	szError[1024];
	BOOL	bDisplayMessage = (dwMsgType != (DWORD)flgNone);
	DWORD	cchStatus;
	UINT	uType;
	
	if (!bDisplayMessage)
		return;
	
	// Show any error messages if required.
	if (dwMsgType & flgSystem)
	{
		cchStatus = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, 
								   0, 
								   uExitCode, 
								   0, 
								   (LPSTR) &(pszSystemErr), 
								   0, 
								   NULL
								   );
		if (! cchStatus)
		{
			bDisplayMessage = FALSE;
		}
	}
    
	szResErr[0] = '\0';
	if (dwMsgType & flgRes)
	{
		if (! LoadStringA (hModule, dwStringID, szResErr, 256))
			bDisplayMessage = FALSE;
	}
	
	szError[0] = '\0';
	if (bDisplayMessage)
	{
		if (dwMsgType & flgRes)
		{
			StringCchCopyA(szError, ARRAY_ELEMENTS(szError), szResErr);
			if (ERROR_SUCCESS != uExitCode && (dwMsgType & flgSystem))
				StringCchCatA(szError, ARRAY_ELEMENTS(szError), "\n\n");
		}
		
        if (ERROR_SUCCESS != uExitCode && (dwMsgType & flgSystem) && pszSystemErr)
			StringCchCatA(szError, sizeof(szError), pszSystemErr);
		
		if ((! g_fQuietMode || (dwMsgType & flgCatastrophic)) &&
			'\0' != szError[0])
		{
			if (ERROR_SUCCESS == uExitCode || ERROR_SUCCESS_REBOOT_REQUIRED == uExitCode)
				uType = MB_OK | MB_ICONINFORMATION;
			else if (dwMsgType & flgCatastrophic)
				uType = MB_OK | MB_ICONERROR;
			else
				uType = MB_OK | MB_ICONWARNING;
				
			// Display messages in quiet mode only if they are catastrophic failures.
			MessageBoxA (NULL, szError, 0, uType);
		}
	}
	
	if (pszSystemErr)
		LocalFree(pszSystemErr);
}

//+--------------------------------------------------------------------------
//
//  Function:	ShouldInstallSDBFiles
//
//  Synopsis:	This function determines whether we should install the .sdb
//				files that came with the package. We cannot let Windows
//				Installer make this decision because the version of the .sdb
//				files can only be obtained by querying a special API. As far as
//				the Windows Installer is concerned, these files are unversioned
//				and it will therefore do only timestamp comparison in order to
//				decide if it should install the file. Therefore we have
//				conditionalized the installation of the sdb file on a property
//				called INSTALLSDB which is passed in through the command line
//				based on the outcome of this function.
//
//  Arguments:	none.
//
//  Returns:	TRUE : if the sdb files should be installed.
//				FALSE: otherwise.
//
//  History:	3/12/2001  RahulTh  created
//
//  Notes:		This function always succeeds. Any failures in querying the
//				version of the existing file are treated as a need to install
//				the files that came with the package.
//
//---------------------------------------------------------------------------
BOOL ShouldInstallSDBFiles (void)
{
	HMODULE hSDBDll = NULL;
	BOOL	bStatus = TRUE;
	DWORD	Status = GetLastError();
	size_t	lenWinDir = 0;
	size_t	lenIExpDir = 0;
	PFNGETSDBVERSION pfnSdbGetDatabaseVersion = NULL;

	DWORD	dwMajorPackagedSDB = 0;
	DWORD	dwMinorPackagedSDB = 0;
	DWORD	dwMajorSystemSDB = 0;
	DWORD	dwMinorSystemSDB = 0;

	TCHAR szPackagedSDB[MAX_PATH] = TEXT("");
	TCHAR szSystemSDB[MAX_PATH] = TEXT("");

	const TCHAR szMainSDB[] = TEXT("msimain.sdb");
	const TCHAR szAppPatchDir[] = TEXT("AppPatch\\");
	const TCHAR szSDBDll[] = 
#ifdef UNICODE
				TEXT("sdbapiu.dll");
#else
				TEXT("sdbapi.dll");
#endif

	bStatus = TRUE;
	if ( FAILED(StringCchLength(g_szIExpressStore, g_cchMaxPath, &lenIExpDir)) ||
		  FAILED(StringCchLength(g_szWindowsDir, g_cchMaxPath, &lenWinDir)) )
		goto ShouldInstallSDBFilesEnd;

	// Make sure we have enough room to store the path.
	if (ARRAY_ELEMENTS(szSystemSDB) < (lenWinDir + sizeof (szAppPatchDir) / sizeof (TCHAR) + sizeof (szMainSDB) / sizeof (TCHAR)) ||
	    ARRAY_ELEMENTS(szPackagedSDB) <= lenIExpDir + sizeof (szMainSDB) / sizeof (TCHAR))
		goto ShouldInstallSDBFilesEnd;

	// Construct the full path to the sdb on the system
	StringCchCopy(szSystemSDB, ARRAY_ELEMENTS(szSystemSDB), g_szWindowsDir); // we've validated destinations, so this one will succeed.
	szSystemSDB[lenWinDir++] = TEXT('\\');
	StringCchCopy(szSystemSDB + lenWinDir,
					  ARRAY_ELEMENTS(szSystemSDB) - lenWinDir, szAppPatchDir); // we've validated destinations, so this one will succeed.
	StringCchCat(szSystemSDB, ARRAY_ELEMENTS(szSystemSDB), szMainSDB); // we've validated destinations, so this one will succeed.

	if ((DWORD)(-1) == GetFileAttributes (szSystemSDB))
	{
		//
		// The file probably does not exist. But even if
		// there's some other failure, we want to replace
		// the file.
		//
		bStatus = TRUE;
		Status = GetLastError();
		if (ERROR_FILE_NOT_FOUND != Status && ERROR_PATH_NOT_FOUND != Status)
		{
			DebugMsg((TEXT("GetFileAttributes on %s failed with %d."), szSystemSDB, Status));
		}
		else
		{
			DebugMsg((TEXT("%s not found."), szSystemSDB));
		}
		goto ShouldInstallSDBFilesEnd;
	}

	//
	// There is an sdb in the system folder. We should compare the
	// versions to see if we need to install it.
	//
	DebugMsg((TEXT("Found %s."), szSystemSDB));

	// Construct the full path to the sdb that came with the package.
	StringCchCopy(szPackagedSDB, ARRAY_ELEMENTS(szPackagedSDB), g_szIExpressStore); // we've validated destinations, so this one will succeed.
	szPackagedSDB[lenIExpDir++] = TEXT('\\');
	StringCchCopy(szPackagedSDB + lenIExpDir,
					  ARRAY_ELEMENTS(szPackagedSDB) - lenIExpDir, szMainSDB); // we've validated destinations, so this one will succeed.

	//
	// Get a pointer to the API that we will use to compare the
	// version numbers.
	//
	pfnSdbGetDatabaseVersion = (PFNGETSDBVERSION) GetProcFromLib (
				szSDBDll,
				"SdbGetDatabaseVersion",
				&hSDBDll
			);

	if (!pfnSdbGetDatabaseVersion)
	{
		bStatus = TRUE;
		goto ShouldInstallSDBFilesEnd;
	}
	
	if (! pfnSdbGetDatabaseVersion (szSystemSDB, &dwMajorSystemSDB, &dwMinorSystemSDB))
	{
		bStatus = TRUE;
		goto ShouldInstallSDBFilesEnd;
	}

	DebugMsg((TEXT("Version of %s in the system folder is %d.%d."), szMainSDB, dwMajorSystemSDB, dwMinorSystemSDB));

	if (! pfnSdbGetDatabaseVersion (szPackagedSDB, &dwMajorPackagedSDB, &dwMinorPackagedSDB))
	{
		bStatus = TRUE;
		goto ShouldInstallSDBFilesEnd;
	}
	
	DebugMsg((TEXT("Version of %s in the package is %d.%d."), szMainSDB, dwMajorPackagedSDB, dwMinorPackagedSDB));

	//
	// At this point we have successfully obtained the version numbers, so we can finally
	// do the comparison and see if the version on the system is newer.
	//
	bStatus = TRUE;		// default.
	if (dwMajorSystemSDB > dwMajorPackagedSDB ||
	    (dwMajorSystemSDB == dwMajorPackagedSDB && dwMinorSystemSDB > dwMinorPackagedSDB)
	   )
	{
		// The version on the system is newer. So we should not slap on our own.
		bStatus = FALSE;
	}


ShouldInstallSDBFilesEnd:
	if (hSDBDll)
	{
		FreeLibrary(hSDBDll);
		hSDBDll = NULL;
	}
	
	DebugMsg((TEXT("%s in the package %s installed."), szMainSDB, bStatus ? TEXT("will be") : TEXT("will not be")));

	return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiinst\utils.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

	utils.h

Abstract:

	Helper functions for msiinst

Author:

	Rahul Thombre (RahulTh)	10/8/2000

Revision History:

	10/8/2000	RahulTh			Created this module.

--*/

#ifndef _UTILS_H_60AF3596_97E8_4E24_89F7_7E9E0865E836
#define _UTILS_H_60AF3596_97E8_4E24_89F7_7E9E0865E836

#define IDS_NONE	0

// Mode of operation of msiinst.exe
typedef enum tagOPMODE
{
	opNormal,			// Normal mode of operation
	opNormalQuiet,		// Normal mode of operation -- No UI.
	opDelayBoot,		// Delay boot and display UI
	opDelayBootQuiet	// Delay boot and don't display UI
} OPMODE;

// Message types for message box pop-ups
typedef enum tagMsgFlags
{
	flgNone = 0x0,		// No message box is required.
	flgSystem = 0x1,	// The error string should be obtained from the system.
	flgRes = 0x2,		// The error string should be obtained from the module's resources.
	flgCatastrophic = 0x10		// The error is catastrophic. Display the message box even in quiet mode.
} MSGFLAGS;

// Function types for various NT only APIS
typedef BOOL (WINAPI *PFNMOVEFILEEX)(LPCTSTR, LPCTSTR, DWORD);
typedef BOOL (WINAPI *PFNDECRYPTFILE)(LPCTSTR, DWORD);
typedef BOOL (STDAPICALLTYPE *PFNGETSDBVERSION)(LPCTSTR, LPDWORD, LPDWORD);
typedef BOOL (WINAPI *PFNCHECKTOKENMEMBERSHIP)(HANDLE, PSID, PBOOL);
typedef NTSTATUS (WINAPI *PFNNTQUERYSYSINFO)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);
typedef HRESULT (WINAPI *PFNDELNODERUNDLL32)(HWND, HINSTANCE, PSTR, INT);

// Globals
extern OSVERSIONINFO	g_osviVersion;
extern BOOL				g_fWin9X;
extern BOOL				g_fQuietMode;
extern TCHAR			g_szTempStore[];
extern TCHAR			g_szWindowsDir[];
const size_t         g_cchMaxPath = MAX_PATH;
extern TCHAR			g_szSystemDir[];
extern TCHAR			g_szIExpressStore[];

// Helper functions
DWORD
TerminateGfxControllerApps
(
	void
);

BOOL
DelNodeExportFound
(
	void
);

// Registry utility functions.

DWORD 
GetRunOnceEntryName 
(
	OUT LPTSTR pszValueName,
	IN size_t  cchValueNameBuf
);

DWORD 
SetRunOnceValue 
(
	IN LPCTSTR szValueName,
	IN LPCTSTR szValue
);

DWORD 
DelRunOnceValue 
(
	IN LPCTSTR szValueName
);


// Filesystem helper functions.

DWORD 
GetTempFolder 
(
	OUT LPTSTR pszFolder,
	IN size_t cchFolder
);

DWORD
DecryptIfNecessary
(
	IN LPCTSTR pszPath,
	IN const PFNDECRYPTFILE pfnDecryptFile
);

DWORD 
CopyFileTree
(
	IN const TCHAR * pszExistingPath,
	IN const size_t cchExistingPathBuf,
	IN const TCHAR * pszNewPath,
	IN const size_t cchNewPathBuf,
IN const PFNMOVEFILEEX pfnMoveFileEx,
	IN const PFNDECRYPTFILE pfnDecryptFile
);

BOOL 
FileExists
(
	IN LPCTSTR	szFileName,
	IN LPCTSTR	szFOlder,
	IN size_t	cchFolderBuf,
	IN BOOL		bCheckForDir
);

DWORD MyGetWindowsDirectory 
(
	OUT LPTSTR lpBuffer,
	IN UINT	uSize
);

DWORD 
GetMsiDirectory 
(
	OUT LPTSTR	lpBuffer,
	IN UINT		uSize
);



// Miscellaneous helper functions

OPMODE 
GetOperationModeA 
(
	IN int argc, 
	IN LPSTR * argv
);

DWORD 
GetWin32ErrFromHResult 
(
	IN HRESULT hr
);

FARPROC 
GetProcFromLib 
(
	IN	LPCTSTR		szLib,
	IN	LPCSTR		szProc,
	OUT	HMODULE *	phModule
);

void 
ShowErrorMessage 
(
	IN DWORD uExitCode,
	IN DWORD dwMsgType,
	IN DWORD dwStringID = IDS_NONE
);

BOOL
ShouldInstallSDBFiles
(
	void
);

#define ARRAY_ELEMENTS(arg)        (sizeof(arg)/sizeof(*arg)) // count of elements of a uni-dimensional array
#define RETURN_IT_IF_FAILED(arg)   {HRESULT hr = arg; if ( FAILED(hr) ) return GetWin32ErrFromHResult(hr);}

#endif	//_UTILS_H_60AF3596_97E8_4E24_89F7_7E9E0865E836
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimerg\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiloc\sources.inc ===
TARGETNAME=MsiLoc
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

USE_LIBCMT=1
USE_NATIVE_EH=1

TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS=\
	$(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\user32.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INCLUDES);$(INC_DIR);$(RES_OBJDIR);$(BUILD_COMMONDIR);

SOURCES=..\msiloc.cpp \
		..\msiloc.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiloc\msiloc.cpp ===
#if 0  // makefile definitions
DESCRIPTION = MSI Localization tool
MODULENAME = msiloc
SUBSYSTEM = console
FILEVERSION = MSI
LINKLIBS = OLE32.lib
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+--------------------------------------------------------------------------------------------------+\\
//                                                                                                    \\
//  Microsoft Windows                                                                                 \\
//                                                                                                    \\
//  Copyright (C) Microsoft Corporation. All rights reserved.                                         \\
//                                                                                                    \\
//  File:       msiloc.cpp                                                                            \\
//                                                                                                    \\
//----------------------------------------------------------------------------------------------------\\ 

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f msiloc.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 Console Application project
//      2. Add msiloc.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

// Required headers
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>

#ifndef RC_INVOKED    // start of source code

///////////////////////////////////////////////////////////////////////////////
// HEADERS
#include "msiquery.h"
#include "msidefs.h"
#include <stdio.h>   // wprintf
#include <stdlib.h>  // strtoul
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include <assert.h>  // assert
#include "strsafe.h"

/////////////////////////////////////////////////////////////////////////////
// CONSTANT STRINGS
/*headers for resource file*/
const TCHAR szWndwHdrFile[]      = TEXT("#include <windows.h>");
const TCHAR szCommCtrlHdrFile[]  = TEXT("#include <commctrl.h>");
/*tabs and carriage returns*/
const TCHAR szCRLF[]             = TEXT("\r\n");
const TCHAR szCommaTab[]         = TEXT(",\t");
const TCHAR szTab[]              = TEXT("\t");
const TCHAR szCurlyBeg[]         = TEXT("{");
const TCHAR szCurlyEnd[]         = TEXT("}");
const TCHAR szQuotes[]           = TEXT("\"");
/*resource types or keywords WINDOWS*/
const TCHAR resDialog[]          = TEXT("DIALOGEX");
const TCHAR resPushButton[]      = TEXT("PUSHBUTTON");
const TCHAR resCheckBox[]        = TEXT("CHECKBOX");
const TCHAR resGroupBox[]        = TEXT("GROUPBOX");
const TCHAR resRadioButton[]     = TEXT("RADIOBUTTON");
const TCHAR resControl[]         = TEXT("CONTROL");
const TCHAR resBitmap[]          = TEXT("BITMAP");
const TCHAR resIcon[]            = TEXT("ICON");
const TCHAR resJPEG[]            = TEXT("JPEG");
const TCHAR resStringTable[]     = TEXT("STRINGTABLE");
const TCHAR tokCaption[]         = TEXT("CAPTION");
const TCHAR resSelTreeClass[]   = TEXT("WC_TREEVIEW");
const TCHAR resButtonClass[]    = TEXT("BUTTON");
const TCHAR resProgBar32Class[] = TEXT("PROGRESS_CLASS");
const TCHAR resListViewClass[]  = TEXT("WC_LISTVIEW");
const TCHAR resStaticClass[]    = TEXT("STATIC");
const TCHAR resComboBoxClass[]  = TEXT("COMBOBOX");
const TCHAR resEditClass[]      = TEXT("EDIT");
const TCHAR resListBoxClass[]   = TEXT("LISTBOX");
const TCHAR resRichEditClass[]  = TEXT("STATIC"); // TEXT("RICHEDIT") not working;
/*control types INSTALLER*/
const TCHAR* szMsiPushbutton =      TEXT("PushButton");
const TCHAR* szMsiBillboard  =      TEXT("Billboard");
const TCHAR* szMsiVolumeCostList =  TEXT("VolumeCostList");
const TCHAR* szMsiScrollableText =  TEXT("ScrollableText");
const TCHAR* szMsiMaskedEdit =      TEXT("MaskedEdit");
const TCHAR* szMsiCheckBox =        TEXT("CheckBox");
const TCHAR* szMsiGroupBox =        TEXT("GroupBox");
const TCHAR* szMsiText =            TEXT("Text");
const TCHAR* szMsiListBox =         TEXT("ListBox");
const TCHAR* szMsiEdit =            TEXT("Edit");
const TCHAR* szMsiPathEdit =        TEXT("PathEdit");
const TCHAR* szMsiProgressBar =     TEXT("ProgressBar");
const TCHAR* szMsiDirList =         TEXT("DirectoryList");
const TCHAR* szMsiList =            TEXT("ListView");
const TCHAR* szMsiComboBox =        TEXT("ComboBox");
const TCHAR* szMsiDirCombo =        TEXT("DirectoryCombo");
const TCHAR* szMsiVolSelCombo =     TEXT("VolumeSelectCombo");
const TCHAR* szMsiRadioButtonGroup =TEXT("RadioButtonGroup");
const TCHAR* szMsiRadioButton =     TEXT("RadioButton");
const TCHAR* szMsiBitmap =          TEXT("Bitmap");
const TCHAR* szMsiSelTree =         TEXT("SelectionTree");
const TCHAR* szMsiIcon =            TEXT("Icon");
const TCHAR* szMsiLine =            TEXT("Line");
/*max sizes*/
const int iMaxResStrLen          = 256;
const TCHAR strOverLimit[]       = TEXT("!! STR OVER LIMIT !!");
////////////////////////////////////////////////////////////////////////
// EXPORT SQL QUERIES
/*particular column of strings from a particular table*/
const TCHAR* sqlStrCol = TEXT("SELECT %s, `%s` FROM `%s`");
const TCHAR sqlCreateStrMap[] = TEXT("CREATE TABLE `_RESStrings` (`Table` CHAR(72) NOT NULL, `Column` CHAR(72) NOT NULL, `Key` CHAR(0), `RCID` SHORT NOT NULL PRIMARY KEY `Table`, `Column`, `Key`)");
const TCHAR* sqlSelMaxStrRcId = TEXT("SELECT `RCID` FROM `_RESStrings` WHERE `Table`='MAX_RESOURCE_ID' AND `Column`='MAX_RESOURCE_ID'");
const TCHAR* sqlStrMark = TEXT("SELECT `Table`,`Column`, `Key`, `RCID` FROM `_RESStrings`");
const TCHAR* sqlInsertStr = TEXT("SELECT `Table`,`Column`,`Key`, `RCID` FROM `_RESStrings`");
const TCHAR* sqlFindStrResId  = TEXT("SELECT `RCID` FROM `_RESStrings` WHERE `Table`='%s' AND `Column`='%s' AND `Key`='%s'");
/*binary table*/
const TCHAR* sqlBinary = TEXT("SELECT `Name`,`Data` FROM `Binary`");
const int ibcName = 1; // these constants must match query above
const int ibcData = 2;
/*dialog table*/
const TCHAR* sqlCreateDlgMap = TEXT("CREATE TABLE `_RESDialogs` (`RCStr` CHAR(72) NOT NULL, `Dialog` CHAR(72) PRIMARY KEY `RCStr`)");
const TCHAR* sqlDlgMap = TEXT("SELECT `RCStr`,`Dialog` FROM `_RESDialogs`");
const TCHAR* sqlDialog = TEXT("SELECT `Dialog`,`HCentering`,`VCentering`,`Width`,`Height`,`Attributes`,`Title` FROM `Dialog`");
const TCHAR* sqlDialogSpecific = TEXT("SELECT `Dialog`,`HCentering`,`VCentering`,`Width`,`Height`,`Attributes`,`Title` FROM `Dialog` WHERE `Dialog`=?");
const int idcName   = 1; // these constants must match query above
const int idcX      = 2;
const int idcY      = 3;
const int idcWd     = 4;
const int idcHt     = 5;
const int idcAttrib = 6;
const int idcTitle  = 7;
/*control table*/
const TCHAR* sqlCreateCtrlMark = TEXT("CREATE TABLE `_RESControls` (`Dialog_` CHAR(72) NOT NULL, `Control_` CHAR(72) NOT NULL, `RCID` INT NOT NULL  PRIMARY KEY `Dialog_`, `Control_`)"); 
const TCHAR* sqlCtrlMark = TEXT("SELECT `Dialog_`,`Control_`,`RCID` FROM `_RESControls`");
const TCHAR* sqlSelMaxRcId = TEXT("SELECT `RCID` FROM `_RESControls` WHERE `Dialog_`='MAX_RESOURCE_ID' AND `Control_`='MAX_RESOURCE_ID'");
const TCHAR* sqlInsertCtrl = TEXT("SELECT `Dialog_`,`Control_`,`RCID` FROM `_RESControls`");
const TCHAR* sqlFindResId  = TEXT("SELECT `RCID` FROM `_RESControls` WHERE `Dialog_`='%s' AND `Control_`='%s'");
const TCHAR* sqlControl = TEXT("SELECT `Control`,`Type`,`X`,`Y`,`Width`,`Height`,`Attributes`,`Text`,`Property` FROM `Control` WHERE `Dialog_`=?");
const int iccName    = 1; // these constants must match query above
const int iccType    = 2;
const int iccX       = 3;
const int iccY       = 4;
const int iccWd      = 5;
const int iccHt      = 6;
const int iccAttrib  = 7;
const int iccText    = 8;
const int iccProperty= 9;
/*radiobutton table*/
const TCHAR* sqlRadioButton = TEXT("SELECT `Order`, `X`, `Y`, `Width`, `Height`, `Text` FROM `RadioButton` WHERE `Property`=?");
const int irbcOrder = 1; // these constants must match query above
const int irbcX     = 2;
const int irbcY     = 3;
const int irbcWd    = 4;
const int irbcHt    = 5;
const int irbcText  = 6;
////////////////////////////////////////////////////////////////////////
// IMPORT SQL QUERIES
/*dialog table*/
const TCHAR* sqlDialogImport = TEXT("SELECT `HCentering`,`VCentering`,`Width`,`Height`,`Title` FROM `Dialog` WHERE `Dialog`=?");
const int idiHCentering = 1; // these constants must match query above
const int idiVCentering = 2;
const int idiWidth      = 3;
const int idiHeight     = 4;
const int idiTitle      = 5;
/*control table*/
const TCHAR* sqlControlImport = TEXT("SELECT `X`,`Y`,`Width`,`Height`,`Text` FROM `Control` WHERE `Dialog_`=? AND `Control`=?");
const int iciX          = 1; // these constants must match query above
const int iciY          = 2;
const int iciWidth      = 3;
const int iciHeight     = 4;
const int iciText       = 5;
/*radiobutton table*/
const TCHAR* sqlRadioButtonImport = TEXT("SELECT `Width`, `Height`, `Text` FROM `RadioButton` WHERE `Property`=? AND `Order`=?");
const int irbiWidth     = 1; // these constants must match query above
const int irbiHeight    = 2;
const int irbiText      = 3;
/*string table*/
const TCHAR* sqlStringImport = TEXT("SELECT `%s` FROM `%s` WHERE ");
const TCHAR* sqlStrTemp      = TEXT("SELECT * FROM `%s`");
/*find Installer name*/
const TCHAR sqlDialogInstallerName[] = TEXT("SELECT `Dialog` FROM `_RESDialogs` WHERE `RCStr`=?");
const TCHAR sqlControlInstallerName[] = TEXT("SELECT `Dialog_`,`Control_` FROM `_RESControls` WHERE `RCID`=?");
const TCHAR sqlStringInstallerName[] = TEXT("SELECT `Table`,`Column`,`Key` FROM `_RESStrings` WHERE `RCID`=? AND `Table`<>'MAX_RESOURCE_ID'");
//////////////////////////////////////////////////////////////////////////
// MISCELLANEOUS - CODEPAGE, etc.
const TCHAR szTokenSeps[] = TEXT(":");
const TCHAR* szCodepageFile = TEXT("codepage.idt");
const TCHAR* szForceCodepage = TEXT("_ForceCodepage");
const TCHAR* szLineFeed = TEXT("\r\n\r\n");
const TCHAR* szCodepageExport = TEXT("_ForceCodepage.idt");
//////////////////////////////////////////////////////////////////////////
// COMMAND LINE PARSING
/*mode*/
const int iEXPORT_MSI     = 1 << 0;
const int iIMPORT_RES     = 1 << 1;
/*data type*/
const int iDIALOGS = 1 << 2;
const int iSTRINGS = 1 << 3;
/*extra options*/
const int iSKIP_BINARY = 1 << 4;
const int iCREATE_NEW_DB = 1 << 5;
/*max values*/
const int MAX_DIALOGS = 32;
const int MAX_STRINGS = 32;
////////////////////////////////////////////////////////////////////////////
// ENUMS
static enum bdtBinaryDataType
{
	bdtBitmap,        // bitmap
	bdtJPEG,          // JPEG
	bdtIcon,          // Icon
	bdtEXE_DLL_SCRIPT // EXE, DLL, or SCRIPT
};
/////////////////////////////////////////////////////////////////////////////
// FUNCTION PROTOTYPES
BOOL __stdcall EnumDialogCallback(HINSTANCE hModule, const TCHAR* szType, TCHAR* szDialogName, long lParam);
BOOL __stdcall EnumStringCallback(HINSTANCE hModule, const TCHAR* szType, TCHAR* szName, long lParam);
BOOL __stdcall EnumLanguageCallback(HINSTANCE hModule, const TCHAR* szType, const TCHAR* szName, WORD wIDLanguage, long lParam);
/////////////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES - IMPORT 
UINT g_uiCodePage;
WORD g_wLangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL); // initialize to language neutral


//__________________________________________________________________________________________
//
// CLASSES
//__________________________________________________________________________________________

/////////////////////////////////////////////////////////////////////////////
// class CGenerateRC -- handles creation of .rc file from .msi database
//
class CGenerateRC
{
public: // constructor and destructor
	CGenerateRC(const TCHAR* szDatabase, const TCHAR* szSavedDatabase) : m_szDatabase(szSavedDatabase), m_szOrigDb(szDatabase),
		m_hFile(0), m_hDatabase(0), m_iCtrlResID(0), m_fError(FALSE), m_cWriteFileErr(0), m_iStrResID(0), m_fWroteBinary(FALSE){};
	~CGenerateRC();
public: // methods
	UINT OutputDialogs(BOOL fBinary);
	UINT OutputDialog(TCHAR* szDialog, BOOL fBinary);
	UINT OutputString(TCHAR* szTable, TCHAR* szColumn);
	BOOL IsInErrorState(){return m_fError;}
private: // methods
	UINT   Initialize();
	UINT   CreateResourceFile();
	BOOL   WriteDialogToRC(TCHAR* szDialog, TCHAR* szTitle, int x, int y, int wd, int ht, int attrib);
	BOOL   PrintDimensions(int x, int y, int wd, int ht);
	BOOL   OutputControls(TCHAR* szDialog);
	UINT   OutputDialogInit(BOOL fBinary);
	UINT   OutputDialogFinalize();
	UINT   OutputStringInit();
	BOOL   WriteBinaries();
	BOOL   WriteRadioButtons(TCHAR* szDialog, TCHAR* szRBGroup, TCHAR* szProperty, int x, int y, int attrib);
	BOOL   WriteControlToRC(TCHAR* szDialog, TCHAR* szCtrlName, TCHAR* szCtrlType, TCHAR* szCtrlText, TCHAR* szCtrlProperty, int x,
							int y, int wd, int ht, int attrib);
	BOOL   WriteStdWinCtrl(int iResId, const TCHAR* resType, TCHAR* szCtrlText, int x, int y, int wd, int ht, int attrib);
	BOOL   WriteWin32Ctrl(int iResId, const TCHAR* szClass, TCHAR* szCtrlText, TCHAR* szAttrib, int x, int y, int wd, int ht, int attrib);
	UINT   VerifyDatabaseCodepage();
	TCHAR* EscapeSlashAndQuoteForRC(TCHAR* szStr);
private: // data
	const TCHAR* m_szDatabase; // name of database to generate from
	const TCHAR* m_szOrigDb;   // name of original database
	HANDLE       m_hFile;      // handle to resource file
	MSIHANDLE    m_hDatabase;  // handle to database
	int          m_iCtrlResID; // current max resource Id used for controls
	int          m_iStrResID;  // current max resource Id used for strings
	BOOL         m_fError;     // store current error state
	BOOL         m_fWroteBinary;// already wrote binary data to rc file
	int          m_cWriteFileErr; // number of write file errors
};

///////////////////////////////////////////////////////////////////////////////
// class CImportRes -- handles import of resource .dll file into .msi database
//
class CImportRes
{
public: // constructor and destructor
	CImportRes(const TCHAR* szDatabase, const TCHAR* szSaveDatabase, const TCHAR* szDLLFile) : m_szDatabase(szSaveDatabase), m_szOrigDb(szDatabase), m_szDLLFile(szDLLFile), m_hDatabase(0), m_fError(FALSE),
				m_hControl(0), m_hDialog(0), m_hRadioButton(0), m_hInst(0), m_fSetCodepage(FALSE), m_fFoundLang(FALSE){};
   ~CImportRes();
public: // methods
	UINT ImportDialogs();
	UINT ImportStrings();
	UINT ImportDialog(TCHAR* szDialog);
	BOOL IsInErrorState(){return m_fError;}
public: // but only for enumeration purposes
	BOOL WasLanguagePreviouslyFound(){return m_fFoundLang;}
	void SetFoundLang(BOOL fValue){ m_fFoundLang = fValue; }
	BOOL LoadDialog(HINSTANCE hModule, const TCHAR* szType, TCHAR* szDialog);
	BOOL LoadString(HINSTANCE hModule, const TCHAR* szType, TCHAR* szString);
	void SetErrorState(BOOL fState) { m_fError = fState; }
	BOOL SetCodePage(WORD wLang);
private: // methods
	UINT ImportDlgInit();
	UINT Initialize();
	UINT VerifyDatabaseCodepage();
private: // data
	const TCHAR* m_szOrigDb;   // orginal database for opening
	const TCHAR* m_szDatabase; // name of database to save to, optional if you want to create a new Db
	const TCHAR* m_szDLLFile;  // name of DLL file to import
	MSIHANDLE    m_hDatabase;  // handle to database
	MSIHANDLE    m_hControl;   // handle to control table
	MSIHANDLE    m_hDialog;    // handle to dialog table
	MSIHANDLE    m_hRadioButton;// handle to radiobutton table
	BOOL         m_fError;     // store current error state
	HINSTANCE    m_hInst;      // DLL (with localized resources)
	BOOL         m_fSetCodepage; // whether codepage of database has been set
	BOOL         m_fFoundLang;  // whether resource has already been found in previous language
};

///////////////////////////////////////////////////////////////////////////////////////
// CDialogStream class -- used for walking DLGTEMPLATEEX and DLGITEMTEMPLATE in memory
//
class CDialogStream  
{
public:  
	unsigned short  __stdcall GetUInt16();
	short  __stdcall GetInt16();
	int    __stdcall GetInt32();
	int    __stdcall GetInt8();
	TCHAR* __stdcall GetStr();
	BOOL   __stdcall Align16();
	BOOL   __stdcall Align32();
	BOOL   __stdcall Undo16();
	BOOL   __stdcall Move(int cbBytes);
public:  // constructor, destructor
	 CDialogStream(HGLOBAL hResource);
	~CDialogStream();
private:
	char*  m_pch;
};

//_______________________________________________________________________________________
//
// CGENERATERC CLASS IMPLEMENTATION
//_______________________________________________________________________________________

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::~CGenerateRC
// --  Handles destruction of necessary objects.
// --  Commits database if no errors
CGenerateRC::~CGenerateRC()
{
	UINT iStat;
	if (m_hFile)
		CloseHandle(m_hFile);
	if (m_hDatabase)
	{
		// commit database for internal tables
		// only commit database if no errors
		if (!m_fError && !m_cWriteFileErr)
		{
			if (ERROR_SUCCESS != (iStat = MsiDatabaseCommit(m_hDatabase)))
				_tprintf(TEXT("!! DATABASE COMMIT FAILED.  Error = %d\n"), iStat);
		}
		else
			_tprintf(TEXT("!! NO CHANGES SAVED TO DATABASE. '%d' WriteFile errors occured. Error state = %s\n"), m_cWriteFileErr, m_fError ? TEXT("ERRORS OCCURED") : TEXT("NO ERRORS"));
		MsiCloseHandle(m_hDatabase);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::CreateResourceFile
// -- Creates .rc file using base name from .msi file
// -- Outputs required header files to .rc file
UINT CGenerateRC::CreateResourceFile()
{
	// assumption of database with ".msi" extension
	// resource file generated from the database we are saving to
	// if m_szDatabase = NULL, then no output database specified, so use m_szOrigDb
	// if m_szDatabase, then output database specified, so use m_szDatabase

	int cchLen = _tcslen(m_szDatabase ? m_szDatabase : m_szOrigDb) + 1;
	TCHAR* szFile = new TCHAR[cchLen];
	if ( !szFile )
		return m_fError = true, ERROR_OUTOFMEMORY;

	// copy database name over
	if (FAILED(StringCchCopy(szFile, cchLen, m_szDatabase ? m_szDatabase : m_szOrigDb)))
	{
		delete [] szFile;
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	}

	// ensure input conforms to {base}.msi format
	//                                12345
	// cchLen must be >= 6 since .msi plus \0 is 5
	if (cchLen < 6
		|| szFile[cchLen-5] != '.'
		|| (szFile[cchLen-4] != 'm' && szFile[cchLen-4] != 'M')
		|| (szFile[cchLen-3] != 's' && szFile[cchLen-3] != 'S')
		|| (szFile[cchLen-2] != 'i' && szFile[cchLen-2] != 'I'))
	{
		delete [] szFile;
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	}

	// remove "msi" and change to "rc"
	szFile[cchLen-4] = 'r';
	szFile[cchLen-3] = 'c';
	szFile[cchLen-2] = '\0';

	if (m_szDatabase)
		_tprintf(TEXT("LOG>> Original Database: %s, Saved Database: %s, Generated RC File: %s\n"), m_szOrigDb, m_szDatabase, szFile);
	else
		_tprintf(TEXT("LOG>> Database: %s, Generated RC file: %s\n"), m_szOrigDb , szFile);

	// attempt to create resource file
	m_hFile = CreateFile(szFile, GENERIC_WRITE, FILE_SHARE_WRITE, 
								0, CREATE_ALWAYS, 0, 0);
	if (!m_hFile)
	{
		_tprintf(TEXT("Unable to create resource file: %s\n"), szFile);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	}

	// write required headers to resource file (needed for successful compilation)
	DWORD dwBytesWritten = 0; 
	// need <windows.h> for most rc requirements
	if (!WriteFile(m_hFile, szWndwHdrFile, sizeof(szWndwHdrFile)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;
	// need <commctrl.h> for listview control
	if (!WriteFile(m_hFile, szCommCtrlHdrFile, sizeof(szCommCtrlHdrFile)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;

	// whitespace output (required)
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;

	// return success 
	return m_cWriteFileErr ? ERROR_FUNCTION_FAILED : ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteBinaries
BOOL CGenerateRC::WriteBinaries()
{
	m_fWroteBinary = TRUE;
	MSICONDITION eCond = MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("Binary"));
	if (eCond == MSICONDITION_ERROR)
	{
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseIsTablePersisent(Binary)\n"));
		return m_fError = TRUE, FALSE; // error - ABORT
	}
	if (eCond != MSICONDITION_TRUE)
	{
		_tprintf(TEXT("LOG>> Binary table does not exist or is not persistent\n"));
		return TRUE;
	}
	
#ifdef DEBUG
	_tprintf(TEXT("LOG>>...BEGIN WRITING BINARY DATA TO RESOURCE FILE...\n"));
#endif

	UINT uiStat = ERROR_SUCCESS;
	PMSIHANDLE hViewBinary = 0;
	if (ERROR_SUCCESS != MsiDatabaseOpenView(m_hDatabase, sqlBinary, &hViewBinary)
		|| ERROR_SUCCESS != MsiViewExecute(hViewBinary, 0))
		return m_fError = TRUE, FALSE; // error - ABORT
	
	PMSIHANDLE hRecBinary = 0;
	bdtBinaryDataType bdt;
	DWORD dwWritten = 0;
	while (ERROR_SUCCESS == (uiStat = MsiViewFetch(hViewBinary, &hRecBinary)))
	{
		TCHAR szFileBuf[2*MAX_PATH+1] = {0};
		TCHAR szPathBuf[MAX_PATH+1] = {0};
		DWORD cchLen = 0;

		if (ERROR_MORE_DATA != MsiRecordGetString(hRecBinary, ibcName, TEXT(""), &cchLen))
			return m_fError = TRUE, FALSE;

		TCHAR* szName = new TCHAR[++cchLen];
		if ( !szName )
			return m_fError = TRUE, FALSE;

		if (ERROR_SUCCESS != (uiStat = MsiRecordGetString(hRecBinary, ibcName, szName, &cchLen)))
		{
			delete [] szName;
			return m_fError = TRUE, FALSE; // error - ABORT
		}

		// find the temp directory to dump out the binary data into temp files
		DWORD cchRet = GetTempPath(sizeof(szPathBuf)/sizeof(szPathBuf[0]), szPathBuf);
		if (0 == cchRet || cchRet > sizeof(szPathBuf)/sizeof(szPathBuf[0]))
		{
			delete [] szName;
			return m_fError = TRUE, FALSE; // error - ABORT
		}

		// generate a temporary file name, prefix with IBD for Installer Binary Data
		if (0 == GetTempFileName(szPathBuf, TEXT("IBD"), 0, szFileBuf))
		{
			delete [] szName;
			return m_fError = TRUE, FALSE; // error - ABORT
		}

		// create the file
		HANDLE hBinFile = CreateFile(szFileBuf, GENERIC_WRITE, FILE_SHARE_WRITE, 0, OPEN_ALWAYS, 0, 0);
		// verify handle
		if (hBinFile == INVALID_HANDLE_VALUE)
		{
			delete [] szName;
			return m_fError = TRUE, FALSE; // error - ABORT
		}

#ifdef DEBUG
	_tprintf(TEXT("LOG>>Binary data temp file created: '%s'\n"), szFileBuf);
#endif

		// read in stream of data and write to file
		char szStream[1024] = {0};
		DWORD cbBuf = sizeof(szStream);
		BOOL fFirstRun = TRUE;
		do 
		{
			if (MsiRecordReadStream(hRecBinary, ibcData, szStream, &cbBuf) != ERROR_SUCCESS)
			{
				delete [] szName;
				return m_fError = TRUE, FALSE;
			}

			if (fFirstRun)
			{
				// binary data prefixed with "BM" in stream

				if (cbBuf >= 2)
				{
					if (szStream[0] == 'B' && szStream[1] == 'M')
						bdt = bdtBitmap;
					else if (szStream[0] == 0xFF && szStream[1] == 0xD8)
						bdt = bdtJPEG;
					else if (szStream[0] == 'M' && szStream[1] == 'Z')
						bdt = bdtEXE_DLL_SCRIPT; // 'MZ prefix with exe's and dll's
					else if (szStream[0] == 0x00 && szStream[1] == 0x00)
						bdt = bdtIcon;
					else
						bdt = bdtEXE_DLL_SCRIPT;
				}
				else
					bdt = bdtEXE_DLL_SCRIPT;
#ifdef DEBUG
				if (fFirstRun && bdt != bdtEXE_DLL_SCRIPT)
					_tprintf(TEXT("LOG>> Writing <%s> '%s'\n"), bdt == bdtIcon ? TEXT("ICON") : ((bdt == bdtJPEG) ? TEXT("JPEG") : TEXT("BITMAP")), szName);
#endif // DEBUG
				fFirstRun = FALSE;
			}

			if (cbBuf && bdt != bdtEXE_DLL_SCRIPT)
			{
				if (!WriteFile(hBinFile, szStream, cbBuf, &dwWritten, 0))
				{
					delete [] szName;
					return m_fError = TRUE, FALSE; // error - ABORT
				}
			}
		}
		while (cbBuf == sizeof(szStream) && bdt != bdtEXE_DLL_SCRIPT);
		
		// close file
		if (!CloseHandle(hBinFile))
		{
			delete [] szName;
			return m_fError = TRUE, FALSE; // error - ABORT
		}

		if (bdt == bdtEXE_DLL_SCRIPT)
		{
			delete [] szName;
			continue; // skip over DLL and EXE binary data, not UI related
		}

		// output to resource file
		// escape chars in str
		TCHAR* szEscTitle = EscapeSlashAndQuoteForRC(szFileBuf);

		if ( !szEscTitle )
		{
			delete [] szName;
			return m_fError = TRUE, FALSE;
		}

		if (_tcslen(szEscTitle) > iMaxResStrLen)
		{
			_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> BITMAP FILE: %s\n"), szName);
			delete [] szName;
			delete [] szEscTitle;
			continue; // can't output this
		}
		/*NAMEID<tab>*/
		if (!WriteFile(m_hFile, szName, _tcslen(szName)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		switch (bdt)
		{
		case bdtBitmap: /*BITMAP*/
			if (!WriteFile(m_hFile, resBitmap, _tcslen(resBitmap)*sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;
			break;
		case bdtJPEG:   /*JPEG*/
			if (!WriteFile(m_hFile, resJPEG, _tcslen(resJPEG)*sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;
			break;
		case bdtIcon: /*ICON*/
			if (!WriteFile(m_hFile, resIcon, _tcslen(resIcon)*sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;
			break;
		default:
			return m_fError = TRUE, FALSE; // error - ABORT
		}
		/*<tab>"filename"*/
		if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!WriteFile(m_hFile, szEscTitle, _tcslen(szEscTitle)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;

		delete [] szEscTitle;

		if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;

		delete [] szName;
	}
	if (ERROR_NO_MORE_ITEMS != uiStat)
		return m_fError = TRUE, FALSE; // error - ABORT

	// whitespace in .rc file for readability
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...END WRITING BINARY DATA TO RESOURCE FILE...\n"));
#endif

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputStringInit
UINT CGenerateRC::OutputStringInit()
{
	/**********************************************************************************
	 create internal table for mapping string IDs to strings
	 TABLE: _RESStrings
	 COLUMNS: RCID (Short, Primary Key), Table (String), Column (String), Key (String) 
	***********************************************************************************/
	UINT iStat;
	// see if _RESStrings table is already there
	MSICONDITION eCondition = MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("_RESStrings"));
	if (eCondition == MSICONDITION_TRUE)
	{
		// table persistent
		// find the last resource Id
		PMSIHANDLE hViewSelMaxRc = 0;
		PMSIHANDLE hRecMaxRc = 0;
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlSelMaxStrRcId, &hViewSelMaxRc))
			|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewSelMaxRc, 0))
			|| ERROR_SUCCESS != (iStat = MsiViewFetch(hViewSelMaxRc, &hRecMaxRc)))
			return m_fError = TRUE, iStat; // error - ABORT
		
		// update resource Id
		m_iStrResID = MsiRecordGetInteger(hRecMaxRc, 1);
#ifdef DEBUG
	_tprintf(TEXT("LOG>> _RESStrings Table is Present. MAX RES ID = %d\n"), m_iStrResID);
#endif
	}
	else if (eCondition == MSICONDITION_FALSE || eCondition == MSICONDITION_ERROR) // error or table temporary
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	else
	{
		// table not exist -- create it
		PMSIHANDLE h_StrMarkingView = 0;
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlCreateStrMap, &h_StrMarkingView))
			|| ERROR_SUCCESS != (iStat = MsiViewExecute(h_StrMarkingView, 0)))
			return m_fError = TRUE, iStat; // error - ABORT
	}
	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputString
UINT CGenerateRC::OutputString(TCHAR* szTable, TCHAR* szColumn)
{
	UINT iStat;
	if (ERROR_SUCCESS != (iStat = Initialize()))
		return m_fError = TRUE, iStat; // error - ABORT
	
	// initialize _RESStrings marking table
	if (ERROR_SUCCESS != (iStat = OutputStringInit()))
		return m_fError = TRUE, iStat; // error - ABORT

	// verify table exists
	MSICONDITION eCond = MsiDatabaseIsTablePersistent(m_hDatabase, szTable);
	switch (eCond)
	{
	case MSICONDITION_FALSE: // table is temporary
	case MSICONDITION_NONE: // table does not exist
		_tprintf(TEXT("LOG_ERROR>> TABLE: %s is temporary or does not exist.\n"), szTable);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	case MSICONDITION_ERROR: // error occured
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseIsTablePersistent\n"));
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	case MSICONDITION_TRUE: // table is persistent
		break; 
	default:
		assert(0);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	}

	// build query to open view on table
	PMSIHANDLE hRecPrimaryKeys = 0;
	if (ERROR_SUCCESS != (iStat = MsiDatabaseGetPrimaryKeys(m_hDatabase, szTable, &hRecPrimaryKeys)))
		return m_fError = TRUE, iStat; // error - ABORT
	int cPrimaryKeys = MsiRecordGetFieldCount(hRecPrimaryKeys);

	// determine length of list of column names for query
	DWORD cchKeyColumns = 0;
	int iCol;
	for (iCol=1; iCol<=cPrimaryKeys; iCol++)
	{
		DWORD cchLen = 0;
		if (ERROR_MORE_DATA != MsiRecordGetString(hRecPrimaryKeys, iCol, TEXT(""), &cchLen))
			return m_fError = TRUE, ERROR_FUNCTION_FAILED;
		cchKeyColumns += cchLen + 3; // extra 3 is for enclosing back ticks '`' and ','
	}

	TCHAR* szKeyCols = new TCHAR[++cchKeyColumns];
	if ( !szKeyCols )
		return m_fError = TRUE, ERROR_OUTOFMEMORY;

	ZeroMemory(szKeyCols, cchKeyColumns*sizeof(TCHAR));
	DWORD cchRemain = cchKeyColumns;
	TCHAR* pchKeyCols = szKeyCols;
	for (iCol=1; iCol<=cPrimaryKeys; iCol++)
	{
		if (iCol != 1)
		{
			*pchKeyCols++ = ',';
			cchRemain--;
		}

		*pchKeyCols++ = '`';
		cchRemain--;

		DWORD cchLen = cchRemain;
		if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecPrimaryKeys, iCol, pchKeyCols, &cchLen)))
		{
			delete [] szKeyCols;
			return m_fError = TRUE, iStat;
		}

		pchKeyCols += cchLen;
		*pchKeyCols++ = '`';
		cchRemain -= (cchLen + 1);
	}

	szKeyCols[cchKeyColumns-1] = '\0'; // ensure null terminated

	DWORD cchSQL = _tcslen(sqlStrCol) + _tcslen(szKeyCols) + _tcslen(szColumn) + _tcslen(szTable) + 1;
	TCHAR* szSQL = new TCHAR[cchSQL];
	if ( !szSQL )
	{
		delete [] szKeyCols;
		return m_fError = TRUE, ERROR_OUTOFMEMORY;
	}

	if (FAILED(StringCchPrintf(szSQL, cchSQL, sqlStrCol, szKeyCols, szColumn, szTable)))
	{
		delete [] szKeyCols;
		delete [] szSQL;
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hViewStrCol = 0;

	// open view
	if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, szSQL, &hViewStrCol)))
	{
		if (ERROR_BAD_QUERY_SYNTAX == iStat)
			_tprintf(TEXT("LOG_ERROR>> Query failed, probably because the column '%s' does not exist in table '%s'\n"), szColumn, szTable);
		else
			_tprintf(TEXT("LOG_ERROR>> MsiDatabaseOpenView(Column=%s, Table=%s)\n"), szColumn, szTable);
		
		delete [] szKeyCols;
		delete [] szSQL;
		return m_fError = TRUE, iStat; // error - ABORT
	}

	delete [] szKeyCols;
	szKeyCols = NULL;
	delete [] szSQL;
	szSQL = NULL;

	if (ERROR_SUCCESS != (iStat = MsiViewExecute(hViewStrCol, 0)))
		return m_fError = TRUE, iStat; // error - ABORT

	// verify column is localizable
	PMSIHANDLE hRecColNames = 0;
	PMSIHANDLE hRecColType = 0;
	if (ERROR_SUCCESS != (iStat = MsiViewGetColumnInfo(hViewStrCol, MSICOLINFO_NAMES, &hRecColNames)))
	{
		return m_fError = TRUE, iStat; // error - ABORT
	}
	int cCols = MsiRecordGetFieldCount(hRecColNames);
	int iStrCol = 0;
	for (int iFindCol = 1; iFindCol <= cCols; iFindCol++)
	{
		TCHAR szColumnName[72] = {0};
		DWORD cchColumnName = sizeof(szColumnName)/sizeof(szColumnName[0]);
		if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecColNames, iFindCol, szColumnName, &cchColumnName)))
			return m_fError = TRUE, iStat; // error - ABORT
		if (_tcscmp(szColumnName, szColumn) == 0)
		{
			iStrCol = iFindCol;
			break;
		}
	}
	if (!iStrCol
		|| ERROR_SUCCESS != (iStat = MsiViewGetColumnInfo(hViewStrCol, MSICOLINFO_TYPES, &hRecColType)))
	{
		_tprintf(TEXT("LOG_ERROR>> MsiViewGetColumnInfo\n"));
		return m_fError = TRUE, iStat; // error - ABORT
	}
	DWORD cchColType = 0;
	if (ERROR_MORE_DATA != MsiRecordGetString(hRecColType, iStrCol, TEXT(""), &cchColType))
		return m_fError = TRUE, iStat;

	TCHAR* szColType = new TCHAR[++cchColType];
	if ( !szColType )
		return m_fError = TRUE, ERROR_OUTOFMEMORY;

	if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecColType, iStrCol, szColType, &cchColType))
		|| cchColType < 2)
	{
		delete [] szColType;
		return m_fError = TRUE, iStat; // error - ABORT
	}

	// for column to be localizable, first char in szColType must be an 'L' or an 'l'
	if (*szColType != 'L' && *szColType != 'l')
	{
		_tprintf(TEXT("LOG_ERROR>> Column '%s' of Table '%s' is not localizable\n"), szColumn, szTable);
		delete [] szColType;
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	}

	delete [] szColType;

	// write whitespace for readability
	// whitespace in .rc file for readability
	DWORD dwWritten = 0;
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	// output STRINGTABLE resource header
	// format is:
	//  STRINGTABLE  [[optional-statements]]  {      stringID string      . . .  }
	/*STRINGTABLE*/
	if (!WriteFile(m_hFile, resStringTable, _tcslen(resStringTable)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>{*/
	if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCurlyBeg, sizeof(szCurlyBeg)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	
	// output all strings
	PMSIHANDLE hRecStr = 0;
	while (ERROR_SUCCESS == (iStat = MsiViewFetch(hViewStrCol, &hRecStr)))
	{
		// string to localize is at cPrimaryKeys+1 in record hRecStr

		// determine length of key identifier
		DWORD cchKeyIdentifier = 0;
		int iKey;
		for (iKey = 1; iKey <= cPrimaryKeys; iKey++)
		{
			DWORD cchLen = 0;
			if (ERROR_MORE_DATA != (iStat = MsiRecordGetString(hRecStr, iKey, TEXT(""), &cchLen)))
				return m_fError = TRUE, iStat;
			cchKeyIdentifier += cchLen + 1; // add extra 1 for ':'
		}

		TCHAR* szKeyIdentifier = new TCHAR[++cchKeyIdentifier];
		if ( !szKeyIdentifier )
			return m_fError = TRUE, ERROR_OUTOFMEMORY;

		ZeroMemory(szKeyIdentifier, cchKeyIdentifier*sizeof(TCHAR));

		DWORD cchKeyRemain = cchKeyIdentifier;
		TCHAR* pchKeyIdentifier = szKeyIdentifier;
		for (iKey=1; iKey<=cPrimaryKeys; iKey++)
		{
			if (iKey != 1)
			{
				*pchKeyIdentifier++ = ':';
				cchKeyRemain--;
			}

			DWORD cchLen = cchKeyRemain;
			if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecStr, iKey, pchKeyIdentifier, &cchLen)))
			{
				delete [] szKeyIdentifier;
				return m_fError = TRUE, iStat;
			}

			pchKeyIdentifier += cchLen;
			cchKeyRemain -= cchLen;
		}

		// ensure null terminated
		szKeyIdentifier[cchKeyIdentifier-1] = '\0';

		int iResId = 0;

		DWORD cchFindSQL = _tcslen(sqlFindStrResId) + _tcslen(szTable) + _tcslen(szColumn) + _tcslen(szKeyIdentifier) + 1;
		TCHAR* szFindSQL = new TCHAR[cchFindSQL];
		if ( !szFindSQL )
		{
			delete [] szKeyIdentifier;
			return m_fError = TRUE, ERROR_OUTOFMEMORY;
		}

		if (FAILED(StringCchPrintf(szFindSQL, cchFindSQL, sqlFindStrResId, szTable, szColumn, szKeyIdentifier)))
		{
			delete [] szKeyIdentifier;
			delete [] szFindSQL;
			return m_fError = TRUE, ERROR_FUNCTION_FAILED;
		}

		PMSIHANDLE hViewFindRes = 0;
		PMSIHANDLE hRecFindRes = 0;
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, szFindSQL, &hViewFindRes)))
		{
			delete [] szKeyIdentifier;
			delete [] szFindSQL;
			return m_fError = TRUE, iStat;
		}

		delete [] szFindSQL;
		szFindSQL = NULL;

		if (ERROR_SUCCESS != (iStat = MsiViewExecute(hViewFindRes, 0)))
		{
			delete [] szKeyIdentifier;
			return m_fError = TRUE, iStat; // error - ABORT
		}
		if (ERROR_SUCCESS == (iStat = MsiViewFetch(hViewFindRes, &hRecFindRes)))
		{
			// grab res id
			iResId = MsiRecordGetInteger(hRecFindRes, 1);
		}
		else if (ERROR_NO_MORE_ITEMS == iStat)
		{
			// use next available resource Id
			iResId = ++m_iStrResID;
		}
		else
		{
			delete [] szKeyIdentifier;
			return m_fError = TRUE, iStat; // error - ABORT
		}

		// output string to resource file
		DWORD cchLenStr = 0;
		if (ERROR_MORE_DATA != (iStat = MsiRecordGetString(hRecStr, cPrimaryKeys+1, TEXT(""), &cchLenStr)))
		{
			delete [] szKeyIdentifier;
			return m_fError = TRUE, iStat;
		}

		TCHAR* szStr = new TCHAR[++cchLenStr];
		if ( !szStr )
		{
			delete [] szKeyIdentifier;
			return m_fError = TRUE, ERROR_OUTOFMEMORY;
		}

		if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecStr, cPrimaryKeys+1, szStr, &cchLenStr)))
		{
			delete [] szKeyIdentifier;
			delete [] szStr;
			return m_fError = TRUE, iStat; // error - ABORT
		}
#ifdef DEBUG
		_tprintf(TEXT("LOG>> WRITING string '%s'. TABLE:%s COLUMN:%s KEY:%s\n"), szStr, szTable, szColumn, szKeyIdentifier);
#endif
		// escape chars in str
		TCHAR* szEscTitle = EscapeSlashAndQuoteForRC(szStr);
		if ( !szEscTitle )
		{
			delete [] szKeyIdentifier;
			delete [] szStr;
			return m_fError = TRUE, ERROR_OUTOFMEMORY;
		}

		if (_tcslen(szEscTitle) > iMaxResStrLen)
		{
			_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> STRING: %s FROM TABLE: %s, COLUMN: %s, KEY: %s\n"), szStr, szTable, szColumn, szKeyIdentifier);
			delete [] szKeyIdentifier;
			delete [] szStr;
			delete [] szEscTitle;
			continue; // can't output this
		}

		delete [] szStr;
		szStr = NULL;

		/*<tab>ID*/
		if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		TCHAR szTempBuf[10] = {0};

		if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%d"), iResId)))
		{
			delete [] szKeyIdentifier;
			return m_fError = TRUE, ERROR_FUNCTION_FAILED;
		}

		if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;

		/*,<tab>"str"*/
		if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!WriteFile(m_hFile, szEscTitle, _tcslen(szEscTitle)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		delete [] szEscTitle;
		if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;

		// update resid in _RESStrings
		PMSIHANDLE hViewRes = 0;
		PMSIHANDLE hRecInsertStr = MsiCreateRecord(4);
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlInsertStr, &hViewRes))
			|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewRes, 0))
			|| ERROR_SUCCESS != (iStat = MsiRecordSetInteger(hRecInsertStr, 4, iResId))
			|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecInsertStr, 1, szTable))
			|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecInsertStr, 2, szColumn))
			|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecInsertStr, 3, szKeyIdentifier))
			|| ERROR_SUCCESS != (iStat = MsiViewModify(hViewRes, MSIMODIFY_ASSIGN, hRecInsertStr)))
		{
			delete [] szKeyIdentifier;
			return m_fError = TRUE, iStat;
		}

		delete [] szKeyIdentifier;
		szKeyIdentifier = NULL;

	}
	if (iStat != ERROR_NO_MORE_ITEMS)
		return m_fError = TRUE, iStat; // error - ABORT

	/*}*/
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCurlyEnd, sizeof(szCurlyEnd)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;


	// update _RESStrings table with MAX_RESOURCE_ID
	PMSIHANDLE hViewStrMark = 0;
	PMSIHANDLE hRecMaxRcId = MsiCreateRecord(4);
	if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlStrMark, &hViewStrMark))
		|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewStrMark, 0))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecMaxRcId, 1, TEXT("MAX_RESOURCE_ID")))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecMaxRcId, 2, TEXT("MAX_RESOURCE_ID")))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecMaxRcId, 3, TEXT("")))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetInteger(hRecMaxRcId, 4, m_iStrResID))
		|| ERROR_SUCCESS != (iStat = MsiViewModify(hViewStrMark, MSIMODIFY_ASSIGN, hRecMaxRcId)))
		return m_fError = TRUE, iStat; // error - ABORT

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::Initialize
UINT CGenerateRC::Initialize()
{
	UINT iStat;
	// open database if not already open
	assert(m_szOrigDb);
	if (!m_hDatabase)
	{
		// if m_szDatabase is specified, then we use it for specifying an output database
		iStat = MsiOpenDatabase(m_szOrigDb, m_szDatabase ? m_szDatabase : MSIDBOPEN_TRANSACT, &m_hDatabase);
		if (ERROR_SUCCESS != iStat)
		{
			_tprintf(TEXT("LOG_ERROR>> Unable to open database %s\n"), m_szOrigDb);
			return m_fError = TRUE, iStat; // error - ABORT
		}
	}

	// verify database codepage is NEUTRAL
	if  (ERROR_SUCCESS != (iStat = VerifyDatabaseCodepage()))
		return m_fError = TRUE, iStat; // error - ABORT

	// create resource file if not already created
	if (!m_hFile && ERROR_SUCCESS != (iStat = CreateResourceFile()))
	{
		_tprintf(TEXT("LOG_ERROR>> Unable to create resource file.\n"));
		return m_fError = TRUE, iStat; // error - ABORT
	}

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputDialogFinalize
UINT CGenerateRC::OutputDialogFinalize()
{
	// update _RESControls table with MAX_RESOURCE_ID
	PMSIHANDLE hViewCtrlMark = 0;
	PMSIHANDLE hRecMaxRcId = MsiCreateRecord(3);
	UINT iStat;
	if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlCtrlMark, &hViewCtrlMark))
		|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewCtrlMark, 0))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecMaxRcId, 1, TEXT("MAX_RESOURCE_ID")))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecMaxRcId, 2, TEXT("MAX_RESOURCE_ID")))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetInteger(hRecMaxRcId, 3, m_iCtrlResID))
		|| ERROR_SUCCESS != (iStat = MsiViewModify(hViewCtrlMark, MSIMODIFY_ASSIGN, hRecMaxRcId)))
		return m_fError = TRUE, iStat; // error - ABORT

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...END WRITING DIALOG DATA TO RESOURCE FILE...\n"));
#endif

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::VerifyDatabaseCodepage
UINT CGenerateRC::VerifyDatabaseCodepage()
{
	UINT iStat;
	
	// only output from language neutral database
	TCHAR szTempPath[MAX_PATH+1] = {0};
	DWORD cchRet = GetTempPath(sizeof(szTempPath)/sizeof(szTempPath[0]), szTempPath);
	if (0 == cchRet || cchRet > sizeof(szTempPath)/sizeof(szTempPath[0]))
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;

	// export _ForceCodepage table so can verify codepage
	if (ERROR_SUCCESS != (iStat = MsiDatabaseExport(m_hDatabase, TEXT("_ForceCodepage"), szTempPath, szCodepageExport)))
	{
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseExport(_ForceCodepage)\n"));
		return m_fError = TRUE, iStat; // error - ABORT
	}
	
	// open _ForceCodepage.idt to read it
	DWORD cchFullPath = _tcslen(szTempPath) + _tcslen(szCodepageExport) + 1;
	TCHAR* szFullPath = new TCHAR[cchFullPath];
	if ( !szFullPath )
		return m_fError = TRUE, ERROR_OUTOFMEMORY;

	if (FAILED(StringCchPrintf(szFullPath, cchFullPath, TEXT("%s%s"), szTempPath, szCodepageExport)))
	{
		delete [] szFullPath;
		return m_fError = TRUE, ERROR_OUTOFMEMORY;
	}

	HANDLE hFile = CreateFile(szFullPath, GENERIC_READ, FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)0, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
	if (hFile == NULL)
	{
		_tprintf(TEXT("LOG_ERROR>> OpenFile(_ForceCodepage.idt)\n"));
		delete [] szFullPath;
		return m_fError = TRUE, iStat; // error - ABORT
	}

	delete [] szFullPath;
	szFullPath = NULL;

	// read file for information
	DWORD dwSize = GetFileSize(hFile, NULL);
	if (0xFFFFFFFF == dwSize)
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

	char* szBuf = new char[dwSize+1];
	if ( !szBuf )
	{
		CloseHandle(hFile);
		return m_fError = TRUE, ERROR_OUTOFMEMORY;
	}

	DWORD dwRead = 0;
	if (!ReadFile(hFile, (LPVOID)szBuf, dwSize, &dwRead, NULL)
		|| 0 == dwRead)
	{
		delete [] szBuf;
		CloseHandle(hFile);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	}
	// parse buffer
	// format should be : blank line, blank line, "codepage<tab>_ForceCodepage"
	char* pch = szBuf;
	int cBlankLines = 0;
	while (dwRead && cBlankLines != 2)
	{
		if (*pch == '\n')
			cBlankLines++;
		pch++;
		dwRead--;
	}
	if (!dwRead || cBlankLines != 2)
	{
		_tprintf(TEXT("LOG_ERROR>> Invalid ForceCodepage idt format\n"));
		delete [] szBuf;
		CloseHandle(hFile);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	}
	// codepage is next
	char* pchCodepage = pch;
	while (dwRead && *pch != ' ' && *pch != '\t')
	{
		pch++;
		dwRead--;
	}
	assert(dwRead);
	*pch = '\0';
	// convert codepage to int
	UINT uiCodepage = strtoul(pchCodepage, NULL, 10);

	delete [] szBuf;
	szBuf = NULL;

	if (uiCodepage != 0) // 0 is language neutral
	{
		_tprintf(TEXT("LOG_ERROR>> DATABASE IS NOT LANGUAGE NEUTRAL. CANNOT EXPORT\n"));
		_tprintf(TEXT("LOG_ERROR>> CURRENT CODEPAGE IS %d\n"), uiCodepage);
		CloseHandle(hFile);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	}
	if (!CloseHandle(hFile))
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputDialogInit
UINT CGenerateRC::OutputDialogInit(BOOL fBinary)
{
	UINT iStat;
	if (ERROR_SUCCESS != (iStat = Initialize()))
		return m_fError = TRUE, iStat; // error - ABORT

	// only output if Dialog table exists
	MSICONDITION eCond = MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("Dialog"));
	if (eCond == MSICONDITION_ERROR)
	{
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseIsTablePersistent(Dialog)\n"));
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	}
	// require PERSISTENT tables
	if (eCond != MSICONDITION_TRUE)
	{
		_tprintf(TEXT("LOG>> Dialog table is not persistent or does not exist\n"));
		return ERROR_SUCCESS;
	}
		
	/**********************************************************************************
	 create internal table for mapping DIALOGS to Dialogs (resource file stores
	 strings IDs in ALL CAPS.  Installer is case-sensitive
	 TABLE: _RESDialogs
	 COLUMNS: RCStr (String, Primary Key), Dialog (String, Primary Key) 
	***********************************************************************************/
	
	// see if _RESDialogs table is already there
	MSICONDITION eCondition = MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("_RESDialogs"));
	if (eCondition == MSICONDITION_TRUE)
	{
		// table persistent
#ifdef DEBUG
		_tprintf(TEXT("LOG>> _RESDialogs Table is Present.\n"));
#endif
	}
	else if (eCondition == MSICONDITION_FALSE || eCondition == MSICONDITION_ERROR) // error or table temporary
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	else
	{
		// table not exist -- create it
		PMSIHANDLE h_DlgMarkingView = 0;
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlCreateDlgMap, &h_DlgMarkingView))
			|| ERROR_SUCCESS != (iStat = MsiViewExecute(h_DlgMarkingView, 0)))
			return m_fError = TRUE, iStat; // error - ABORT
	}

	/**********************************************************************************
	 create internal table for managing resource IDs of controls
	 TABLE: _RESControls
	 COLUMNS: Dialog_ (String, Primary Key), Control_ (String, Primary Key), RCID (Int)  
	***********************************************************************************/

	// see if _RESControls table is already there
	eCondition = MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("_RESControls"));
	if (eCondition == MSICONDITION_TRUE)
	{
		// table persistent
		// find the last resource Id
		PMSIHANDLE hViewSelMaxRc = 0;
		PMSIHANDLE hRecMaxRc = 0;
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlSelMaxRcId, &hViewSelMaxRc))
			|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewSelMaxRc, 0))
			|| ERROR_SUCCESS != (iStat = MsiViewFetch(hViewSelMaxRc, &hRecMaxRc)))
			return m_fError = TRUE, iStat; // error - ABORT
		
		// update resource Id
		m_iCtrlResID = MsiRecordGetInteger(hRecMaxRc, 1);

#ifdef DEBUG
	_tprintf(TEXT("LOG>> _RESControls Table is Present. MAX RES ID = %d\n"), m_iCtrlResID);
#endif

	}
	else if (eCondition == MSICONDITION_ERROR || eCondition == MSICONDITION_FALSE) // error or temporary
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	else
	{
		// table not exist -- create it
		PMSIHANDLE h_CtrlMarkingView = 0;
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlCreateCtrlMark, &h_CtrlMarkingView))
			|| ERROR_SUCCESS != (iStat = MsiViewExecute(h_CtrlMarkingView, 0)))
			return m_fError = TRUE, iStat; // error - ABORT
	}

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...BEGIN WRITING DIALOG DATA TO RESOURCE FILE...\n"));
#endif

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputDialogs
UINT CGenerateRC::OutputDialogs(BOOL fBinary)
{
	// write out each dialog in Dialog table
	// According to MSDN, new applications should use DIALOGEX resource instead of DIALOG

	UINT iStat;
	if (ERROR_SUCCESS != (iStat = OutputDialogInit(fBinary)))
		return m_fError = TRUE, iStat; // error - ABORT

		// write out the bitmaps and icons from the Binary table
#ifdef DEBUG
	if (!fBinary)
		_tprintf(TEXT("LOG>> SKIPPING Binary data export.\n"));
#endif
	if (fBinary && !m_fWroteBinary && !WriteBinaries())
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

	// prepare Dialog strResource --> Dialog mapping table
	PMSIHANDLE hViewDlgMap = 0;
	PMSIHANDLE hRecDlgMap = MsiCreateRecord(2);
	PMSIHANDLE hViewDialog = 0;
	if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlDlgMap, &hViewDlgMap))
		|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewDlgMap, 0))
		|| ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlDialog, &hViewDialog))
		|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewDialog, 0)))
		return m_fError = TRUE, iStat; // error - ABORT

	// fetch all row records of dialogs from Dialog table and output to .rc file
	PMSIHANDLE hRecDialog = 0;
	while (ERROR_NO_MORE_ITEMS != (iStat = MsiViewFetch(hViewDialog, &hRecDialog)))
	{
		if (ERROR_SUCCESS != iStat)
			return m_fError = TRUE, iStat; // error - ABORT

		// use dialog name as nameID
		// Reasoning: guarantees uniqueness since Dialog name is primary key of table
		// Potential caveat:  Dialog strId is stored in ALL CAPS. Installer is case-sensitive
		//   so we must store a mapping between this and original.  Could have case where we
		//   try Action1 and ACTion1 as two different strIds.  RC will fail on this
		
		// 1st call, obtain size needed
		// 2nd call, get string
		DWORD cchDialog = 0;
		if (ERROR_MORE_DATA != (iStat = MsiRecordGetString(hRecDialog, idcName, TEXT(""), &cchDialog)))
			return m_fError = TRUE, iStat;
		TCHAR* szDialog = new TCHAR[++cchDialog];
		if ( !szDialog )
			return m_fError = TRUE, ERROR_OUTOFMEMORY;
		if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecDialog, idcName, szDialog, &cchDialog)))
		{
			delete [] szDialog;
			return m_fError = TRUE, iStat; // error - ABORT
		}

		// update Dialog Mapping table with information
		if (ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecDlgMap, 2, szDialog)))
		{
			delete [] szDialog;
			return m_fError = TRUE, iStat;
		}

		DWORD cchTempDialog = _tcslen(szDialog) + 1;
		TCHAR* szTempDialog = new TCHAR[cchTempDialog];
		if ( !szTempDialog )
		{
			delete [] szDialog;
			return m_fError = TRUE, ERROR_OUTOFMEMORY;
		}

		if (FAILED(StringCchCopy(szTempDialog, cchTempDialog, szDialog)))
		{
			delete [] szDialog;
			delete [] szTempDialog;
			return m_fError = TRUE, ERROR_FUNCTION_FAILED;
		}

		// resource file format -- ALL CAPS
		if (ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecDlgMap, 1, _tcsupr(szTempDialog))))
		{
			delete [] szDialog;
			delete [] szTempDialog;
			return m_fError = TRUE, iStat;
		}
		
		// update _RESDialogs table, note:  we will overwrite pre-existing. Rely on rc.exe to bail 
		if (ERROR_SUCCESS != (iStat = MsiViewModify(hViewDlgMap, MSIMODIFY_ASSIGN, hRecDlgMap)))
		{
			delete [] szDialog;
			delete [] szTempDialog;
			return m_fError = TRUE, iStat; // error - ABORT
		}

		// get x, y, wd, ht, and attrib values
		int x,y,wd,ht,attrib;
		x      = MsiRecordGetInteger(hRecDialog, idcX);
		y      = MsiRecordGetInteger(hRecDialog, idcY);
		wd     = MsiRecordGetInteger(hRecDialog, idcWd);
		ht     = MsiRecordGetInteger(hRecDialog, idcHt);
		attrib = MsiRecordGetInteger(hRecDialog, idcAttrib);


		// obtain title of dialog
		DWORD cchTitle = 0;
		if (ERROR_MORE_DATA != (iStat = MsiRecordGetString(hRecDialog, idcTitle, TEXT(""), &cchTitle)))
		{
			delete [] szDialog;
			delete [] szTempDialog;
			return m_fError = TRUE, iStat;
		}

		TCHAR* szTitle = new TCHAR[++cchTitle];
		if ( !szTitle )
		{
			delete [] szDialog;
			delete [] szTempDialog;
			return m_fError = TRUE, ERROR_OUTOFMEMORY;
		}
		if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecDialog, idcTitle, szTitle, &cchTitle)))
		{
			delete [] szDialog;
			delete [] szTempDialog;
			delete [] szTitle;
			return m_fError = TRUE, iStat; // error - ABORT
		}

		if (!WriteDialogToRC(szDialog, szTitle, x, y, wd, ht, attrib))
		{
			delete [] szDialog;
			delete [] szTempDialog;
			delete [] szTitle;
			return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
		}

		delete [] szDialog;
		szDialog = NULL;
		delete [] szTempDialog;
		szTempDialog = NULL;
		delete [] szTitle;
		szTitle = NULL;
	}

	if (ERROR_SUCCESS != (iStat = OutputDialogFinalize()))
		return m_fError = TRUE, iStat; // error - ABORT


	// return success
	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputDialog
UINT CGenerateRC::OutputDialog(TCHAR* szDialog, BOOL fBinary)
{
	// write out specified dialog in Dialog table
	// According to MSDN, new applications should use DIALOGEX resource instead of DIALOG

	UINT iStat;
	if (ERROR_SUCCESS != (iStat = OutputDialogInit(fBinary)))
		return m_fError = TRUE, iStat; // error - ABORT

	// prepare Dialog strResource --> Dialog mapping table
	PMSIHANDLE hViewDlgMap = 0;
	PMSIHANDLE hViewDialog = 0;
	PMSIHANDLE hRecDlgMap = MsiCreateRecord(2);
	PMSIHANDLE hRecFindDlg = MsiCreateRecord(1);
	if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlDlgMap, &hViewDlgMap))
		|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewDlgMap, 0))
		|| ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlDialogSpecific, &hViewDialog))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecFindDlg, 1, szDialog))
		|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewDialog, hRecFindDlg)))
		return m_fError = TRUE, iStat; // error - ABORT

	// fetch specified Dialog from Dialog table and output to .rc file
	PMSIHANDLE hRecDialog = 0;
	if (ERROR_SUCCESS == (iStat = MsiViewFetch(hViewDialog, &hRecDialog)))
	{
		// write out the bitmaps and icons from the Binary table
#ifdef DEBUG
		if (!fBinary)
			_tprintf(TEXT("LOG>> SKIPPING Binary data export.\n"));
#endif
		if (fBinary && !m_fWroteBinary && !WriteBinaries())
			return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

		// use dialog name as nameID
		// Reasoning: guarantees uniqueness since Dialog name is primary key of table
		// Potential caveat:  Dialog strId is stored in ALL CAPS. Installer is case-sensitive
		//   so we must store a mapping between this and original.  Could have case where we
		//   try Action1 and ACTion1 as two different strIds.  RC will fail on this
		
		// update Dialog Mapping table with information
		if (ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecDlgMap, 2, szDialog)))
			return m_fError = TRUE, iStat;

		DWORD cchTempDialog = _tcslen(szDialog) + 1;
		TCHAR* szTempDialog = new TCHAR[cchTempDialog];
		if ( !szTempDialog )
			return m_fError = TRUE, ERROR_OUTOFMEMORY;

		if (FAILED(StringCchCopy(szTempDialog, cchTempDialog, szDialog)))
		{
			delete [] szTempDialog;
			return m_fError = TRUE, ERROR_FUNCTION_FAILED;
		}

		// resource file format, ALL CAPS
		if (ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecDlgMap, 1, _tcsupr(szTempDialog))))
		{
			delete [] szTempDialog;
			return m_fError = TRUE, iStat;
		}
		
		// update _RESDialogs table, note:  we will overwrite pre-existing. Rely on rc.exe to bail 
		if (ERROR_SUCCESS != (iStat = MsiViewModify(hViewDlgMap, MSIMODIFY_ASSIGN, hRecDlgMap)))
		{
			delete [] szTempDialog;
			return m_fError = TRUE, iStat; // error - ABORT
		}

		// get x, y, wd, ht, and attrib values
		int x,y,wd,ht,attrib;
		x      = MsiRecordGetInteger(hRecDialog, idcX);
		y      = MsiRecordGetInteger(hRecDialog, idcY);
		wd     = MsiRecordGetInteger(hRecDialog, idcWd);
		ht     = MsiRecordGetInteger(hRecDialog, idcHt);
		attrib = MsiRecordGetInteger(hRecDialog, idcAttrib);


		// obtain title of dialog
		DWORD cchTitle = 0;
		if (ERROR_MORE_DATA != (iStat = MsiRecordGetString(hRecDialog, idcTitle, TEXT(""), &cchTitle)))
		{
			delete [] szTempDialog;
			return m_fError = TRUE, iStat;
		}

		TCHAR* szTitle = new TCHAR[++cchTitle];
		if ( !szTitle )
		{
			delete [] szTempDialog;
			return m_fError = TRUE, ERROR_OUTOFMEMORY;
		}

		if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecDialog, idcTitle, szTitle, &cchTitle)))
		{
			delete [] szTempDialog;
			delete [] szTitle;
			return m_fError = TRUE, iStat; // error - ABORT
		}

		if (!WriteDialogToRC(szDialog, szTitle, x, y, wd, ht, attrib))
		{
			delete [] szTempDialog;
			delete [] szTitle;
			return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
		}

		delete [] szTempDialog;
		szTempDialog = NULL;

		delete [] szTitle;
		szTitle = NULL;

	}
	else if (ERROR_NO_MORE_ITEMS == iStat)
	{
		_tprintf(TEXT("LOG_ERROR>> Dialog '%s' not found in Dialog table\n"), szDialog);
		if (ERROR_SUCCESS != (iStat = OutputDialogFinalize()))
			return m_fError = TRUE, iStat;
		return ERROR_SUCCESS; // error, but not fatal...keep processing
	}
	else
	{
		_tprintf(TEXT("LOG_ERROR>> MsiViewFetch(specific dialog)\n"));
		return iStat;
	}

	if (ERROR_SUCCESS != (iStat = OutputDialogFinalize()))
		return m_fError = TRUE, iStat; // error - ABORT

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::EscapeSlashAndQuteForRc
TCHAR* CGenerateRC::EscapeSlashAndQuoteForRC(TCHAR* szStr)
{
	TCHAR* szNewStr = 0;
	
	// check for NULL str
	if (szStr == 0)
		return szNewStr;

	// determine if str contains any esc char
	int cEscChar = 0;
	TCHAR* pch = szStr;
	while (*pch != 0)
	{
		if (*pch == TEXT('\\') || *pch == TEXT('"'))
			cEscChar++;
		pch++;
	}

	if (cEscChar == 0)
	{
		int iLen = _tcslen(szStr) + 1; // for null
		szNewStr = new TCHAR[iLen];
		if ( !szNewStr )
			return NULL;
		if (FAILED(StringCchCopy(szNewStr, iLen, szStr)))
		{
			delete [] szNewStr;
			return NULL;
		}
	}
	else
	{
		int iLen = _tcslen(szStr) + 1 + cEscChar;
		szNewStr = new TCHAR[iLen];
		if ( !szNewStr )
			return NULL;
		pch = szStr;
		TCHAR* pchNew = szNewStr;
		while (*pch != 0)
		{
			if (*pch == TEXT('\\'))
				*pchNew++ = TEXT('\\');
			else if (*pch == TEXT('"'))
				*pchNew++ = TEXT('"');
			*pchNew++ = *pch++;
		}
		*pchNew = TEXT('\0');
	}
	
	return szNewStr;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteDialogToRC
BOOL CGenerateRC::WriteDialogToRC(TCHAR* szDialog, TCHAR* szTitle, int x, int y, int wd, int ht, int attrib)
{
#ifdef DEBUG
	_tprintf(TEXT("LOG>> Writing <%s> Dialog\n"), szDialog);
#endif
	// Format for DIALOGEX is:
	// nameID DIALOGEX x, y, width, height [ , helpID]]  [[ optional-statements]]  {control-statements}

	// write out to file

	DWORD dwWritten;
	/*nameId*/
	if (!WriteFile(m_hFile, szDialog, _tcslen(szDialog)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>DIALOGEX*/
	if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, resDialog, sizeof(resDialog)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*x, y, wd, ht DIMENSIONS*/
	if (!PrintDimensions(x, y, wd, ht))
		return m_fError = TRUE, FALSE; // error - ABORT
	
	// At this point, one could optionally output the HelpId

	/*<tab>CAPTION<tab>"str"*/
	if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, tokCaption, sizeof(tokCaption)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	// escape chars in str
	TCHAR* szEscTitle = EscapeSlashAndQuoteForRC(szTitle);
	if ( !szEscTitle )
		return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY
	if (_tcslen(szEscTitle) > iMaxResStrLen)
	{
		_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> DIALOG: %s\n"), szDialog);
		if (FAILED(StringCchCopy(szEscTitle, _tcslen(szEscTitle) + 1, strOverLimit)))
		{
			delete [] szEscTitle;
			return m_fError = TRUE, FALSE;
		}
	}
	if (!WriteFile(m_hFile, szEscTitle, _tcslen(szEscTitle)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	delete [] szEscTitle;
	
	if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	//attributes are ignored at this time (would require conversion from Installer to Windows and masking of Installer specific)
	/*<tab>{*/
	if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCurlyBeg, sizeof(szCurlyBeg)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	// Select all controls associated with said dialog and output
	if (!OutputControls(szDialog))
		return m_fError = TRUE, FALSE; // error - ABORT
	if (!WriteFile(m_hFile, szCurlyEnd, sizeof(szCurlyEnd)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	// whitespace in .rc file for readability
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;


	// return success
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::PrintDimensions
BOOL CGenerateRC::PrintDimensions(int x, int y, int wd, int ht)
{
	TCHAR szTempBuf[64] = {0};
	DWORD dwWritten;

	/*<tab>x*/
	if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%d"), x)))
		return m_fError = TRUE, FALSE;

	if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*,<tab>y*/
	if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%d"), y)))
		return m_fError = TRUE, FALSE;

	if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*,<tab>wd*/
	if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%d"), wd)))
		return m_fError = TRUE, FALSE;

	if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*,<tab>ht*/
	if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%d"), ht)))
		return m_fError = TRUE, FALSE;
	if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	// return success
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputControls
BOOL CGenerateRC::OutputControls(TCHAR* szDialog)
{
	// It's possible that one could output the controls in the correct tab order.
	// It's fairly easy for export if you remember to output
	// all non tab order controls first.  The Control_Next column of the Control table would be
	// used as well as the Control_First column of the Dialog table.  Control_First is the start
	// of the tab order.  Control_Next is the next control in the tab order.  It is difficult to
	// handle the tab order when importing if you allow the tab order to change between export
	// and import.
	UINT iStat;

	// only have controls to write if Control table exists
	MSICONDITION eCond = MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("Control"));
	if (eCond == MSICONDITION_ERROR)
	{
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseIsTablePersistent(Control)\n"));
		return m_fError = TRUE, FALSE; // error - ABORT
	}
	// require Control table to be persistent
	if (eCond != MSICONDITION_TRUE)
	{
		_tprintf(TEXT("LOG: Control table is not persistent or present\n"));
		return TRUE;
	}

	// open view on Control table
	PMSIHANDLE hViewControl = 0;
	PMSIHANDLE hRec = MsiCreateRecord(1);
	if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlControl, &hViewControl))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRec, 1, szDialog))
		|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewControl, hRec)))
		return m_fError = TRUE, FALSE; // error - ABORT

	// begin fetching rows from Control table
	PMSIHANDLE hRecControl = 0;
	while (ERROR_NO_MORE_ITEMS != (iStat = MsiViewFetch(hViewControl, &hRecControl)))
	{
		if (ERROR_SUCCESS != iStat)
			return m_fError = TRUE, FALSE; // error - ABORT


		/**********************************************
		 obtain all values for control
		***********************************************/
		// control's type determines how control is output to resource file
		// 1st call, obtain size needed
		// 2nd call, get string

		DWORD cchLen = 0;
		if (ERROR_MORE_DATA != (iStat = MsiRecordGetString(hRecControl, iccType, TEXT(""), &cchLen)))
			return m_fError = TRUE, FALSE;
		TCHAR* szCtrlType = new TCHAR[++cchLen];
		if ( !szCtrlType )
			return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY

		if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecControl, iccType, szCtrlType, &cchLen)))
		{
			delete [] szCtrlType;
			return m_fError = TRUE, FALSE; // error - ABORT
		}

		cchLen = 0;
		if (ERROR_MORE_DATA != (iStat = MsiRecordGetString(hRecControl, iccName, TEXT(""), &cchLen)))
		{
			delete [] szCtrlType;
			return m_fError = TRUE, FALSE;
		}
		TCHAR* szCtrlName = new TCHAR[++cchLen];
		if ( !szCtrlName )
		{
			delete [] szCtrlType;
			return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY
		}
		if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecControl, iccName, szCtrlName, &cchLen)))
		{
			delete [] szCtrlType;
			delete [] szCtrlName;
			return m_fError = TRUE, FALSE; // error - ABORT
		}

		cchLen = 0;
		if (ERROR_MORE_DATA != (iStat = MsiRecordGetString(hRecControl, iccText, TEXT(""), &cchLen)))
		{
			delete [] szCtrlType;
			delete [] szCtrlName;
			return m_fError = TRUE, FALSE; // error - ABORT
		}
		TCHAR* szCtrlText = new TCHAR[++cchLen];
		if ( !szCtrlText )
		{
			delete [] szCtrlType;
			delete [] szCtrlName;
			return m_fError = TRUE, FALSE; // error - ABORT
		}
		if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecControl, iccText, szCtrlText, &cchLen)))
		{
			delete [] szCtrlType;
			delete [] szCtrlName;
			delete [] szCtrlText;
			return m_fError = TRUE, FALSE; // error - ABORT
		}

		cchLen = 0;
		if (ERROR_MORE_DATA != (iStat = MsiRecordGetString(hRecControl, iccProperty, TEXT(""), &cchLen)))
		{
			delete [] szCtrlType;
			delete [] szCtrlName;
			delete [] szCtrlText;
			return m_fError = TRUE, FALSE; // error - ABORT
		}
		TCHAR* szCtrlProperty = new TCHAR[++cchLen];
		if ( !szCtrlProperty )
		{
			delete [] szCtrlType;
			delete [] szCtrlName;
			delete [] szCtrlText;
			return m_fError = TRUE, FALSE; // error - ABORT
		}
		if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecControl, iccProperty, szCtrlProperty, &cchLen)))
		{
			delete [] szCtrlType;
			delete [] szCtrlName;
			delete [] szCtrlText;
			delete [] szCtrlProperty;
			return m_fError = TRUE, FALSE; // error - ABORT
		}

		// get x, y, wd, ht, and attrib values
		int x,y,wd,ht,attrib;
		x      = MsiRecordGetInteger(hRecControl, iccX);
		y      = MsiRecordGetInteger(hRecControl, iccY);
		wd     = MsiRecordGetInteger(hRecControl, iccWd);
		ht     = MsiRecordGetInteger(hRecControl, iccHt);
		attrib = MsiRecordGetInteger(hRecControl, iccAttrib);

#ifdef DEBUG
	_tprintf(TEXT("LOG>>\tWriting control <%s>\n"), szCtrlName);
#endif

		if (!WriteControlToRC(szDialog, szCtrlName, szCtrlType, szCtrlText, szCtrlProperty, x, y, wd, ht, attrib))
		{
			delete [] szCtrlType;
			delete [] szCtrlName;
			delete [] szCtrlText;
			delete [] szCtrlProperty;
			return m_fError = TRUE, FALSE; // error - ABORT
		}
	}
	
	// return success
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
// NOTES:
// 1.)Output control to RC file according to control type
// 2.)For simplicity, controls are classified into two types:
//                StdWinCtrl and Win32Ctrl.  
//		StdWinCtrl = PushButtons, RadioButtons, ComboBoxes, and ListBoxes
//		Win32Ctrl  = ListView, ComboBox, etc.
//
// 3.)Some controls used in the installer are simply StdWinCtrls with special
//      attributes set
// 
// 4.)Bitmaps and Icons should be output to prevent improper resizing of dialogs.
//      If a dialog were shrunk, the display area could be reduced to the point where
//      the bitmap or icon would not be shown correctly
///////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteControlToRC
BOOL CGenerateRC::WriteControlToRC(TCHAR* szDialog, TCHAR* szCtrlName, TCHAR* szCtrlType, TCHAR* szCtrlText, TCHAR* szCtrlProperty, int x,
								   int y, int wd, int ht, int attrib)
{
	assert(szCtrlType != NULL);

	int iResId = 0;
	// attempt to find resource ID if previously used
	DWORD cchFindIdSQL = _tcslen(sqlFindResId) + _tcslen(szDialog) + _tcslen(szCtrlName) + 1;
	TCHAR* szFindIdSQL = new TCHAR[cchFindIdSQL];
	if ( !szFindIdSQL )
		return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY

	if (FAILED(StringCchPrintf(szFindIdSQL, cchFindIdSQL, sqlFindResId, szDialog, szCtrlName)))
	{
		delete [] szFindIdSQL;
		return m_fError = TRUE, FALSE;
	}

	PMSIHANDLE hViewFindRes = 0;
	PMSIHANDLE hRecFindRes = 0;
	UINT iStat;
	if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, szFindIdSQL, &hViewFindRes)))
	{
		delete [] szFindIdSQL;
		return m_fError = TRUE, FALSE; // error - ABORT
	}
	
	delete [] szFindIdSQL;
	szFindIdSQL = NULL;

	if (ERROR_SUCCESS != (iStat = MsiViewExecute(hViewFindRes, 0)))
		return m_fError = TRUE, FALSE; // error - ABORT
	if (ERROR_SUCCESS == (iStat = MsiViewFetch(hViewFindRes, &hRecFindRes)))
	{
		// grab res id
		iResId = MsiRecordGetInteger(hRecFindRes, 1);
	}
	else if (ERROR_NO_MORE_ITEMS == iStat)
	{
		// use next available resource Id
		iResId = ++m_iCtrlResID;
	}
	else
		return m_fError = TRUE, FALSE; // error - ABORT


	if (0 == _tcscmp(szCtrlType, szMsiPushbutton))
	{
		// StdWin
		if (!WriteStdWinCtrl(iResId, resPushButton, szCtrlText, x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiText))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resStaticClass, szCtrlText, TEXT("SS_LEFT"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiBillboard))
	{
		// StdWin
		// output GROUPBOX for placeholder for billboard
		// it's possible one could output Billboards here, but you would need to connect changes in 
		// the billboard size back and forth with the dialog dimensions on which it is displayed
		if (!WriteStdWinCtrl(iResId, resGroupBox, szCtrlText, x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE;
	}
	else if (0 == _tcscmp(szCtrlType, szMsiVolumeCostList))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resListViewClass, szCtrlText, TEXT("WS_GROUP"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiCheckBox))
	{
		// StdWin
		if (!WriteStdWinCtrl(iResId, resCheckBox, szCtrlText, x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiGroupBox))
	{
		// StdWin
		if (!WriteStdWinCtrl(iResId, resGroupBox, szCtrlText, x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiRadioButtonGroup))
	{
		// StdWin
		if (!WriteStdWinCtrl(iResId, resGroupBox, szCtrlText, x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
		// write out radiobuttons
		if (!WriteRadioButtons(szDialog, szCtrlName, szCtrlProperty, x, y, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiListBox))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resListBoxClass, szCtrlText, TEXT("LBS_STANDARD"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if ((0 == _tcscmp(szCtrlType, szMsiEdit))
				|| (0 == _tcscmp(szCtrlType, szMsiPathEdit))
				|| (0 == _tcscmp(szCtrlType, szMsiMaskedEdit)))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resEditClass, szCtrlText, TEXT("0x000"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiProgressBar))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resProgBar32Class, szCtrlText, TEXT("0x000"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiDirList))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resListViewClass, szCtrlText, TEXT("WS_BORDER"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiList))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resListViewClass, szCtrlText, TEXT("WS_BORDER"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiComboBox))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resComboBoxClass, szCtrlText, TEXT("CBS_AUTOHSCROLL"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiDirCombo))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resComboBoxClass, szCtrlText, TEXT("WS_VSCROLL"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiVolSelCombo))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resComboBoxClass, szCtrlText, TEXT("WS_VSCROLL"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiBitmap))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resStaticClass, szCtrlText, TEXT("SS_BITMAP | SS_CENTERIMAGE"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiIcon))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resStaticClass, szCtrlText, TEXT("SS_ICON | SS_CENTERIMAGE"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiSelTree))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resSelTreeClass, szCtrlText, TEXT("WS_BORDER"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiLine))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resStaticClass, szCtrlText, TEXT("SS_ETCHEDHORZ | SS_SUNKEN"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiScrollableText))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resRichEditClass, szCtrlText, TEXT("WS_GROUP"), x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE; // error - ABORT
	}
	else
	{
		// unsupported control type
		_tprintf(TEXT("!! >> Control Type: '%s' is unsupported\n"), szCtrlType);
		return m_fError = TRUE, FALSE;
	}

	// update _RESControls table with new info
	PMSIHANDLE hViewRes = 0;
	PMSIHANDLE hRecInsertCtrl = MsiCreateRecord(3);
	if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlInsertCtrl, &hViewRes))
		|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewRes, 0))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecInsertCtrl, 1, szDialog))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecInsertCtrl, 2, szCtrlName))
		|| ERROR_SUCCESS != (iStat = MsiRecordSetInteger(hRecInsertCtrl, 3, iResId))
		|| ERROR_SUCCESS != (iStat = MsiViewModify(hViewRes, MSIMODIFY_ASSIGN, hRecInsertCtrl)))
	{
		_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
		return m_fError = TRUE, FALSE;
	}

	// return success
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteRadioButtons
BOOL CGenerateRC::WriteRadioButtons(TCHAR* szDialog, TCHAR* szRBGroup, TCHAR* szProperty, int x, int y, int attrib)
{
	// Format for RadioButton is
	//  RADIOBUTTON<tab>"str",<tab>RESID,<tab>x,<tab>y,<tab>wd,<tab>ht[[,<tab> STYLE ]]
	// radiobuttons come from the RadioButton table based on the Property of the RBGroup in the Control table
	// radiobutton dimensions (X and Y) are local to the radiobutton group
	// because you can have multiple radiobutton groups with the same property in a dialog, we have to use the following
	// scheme when updating the _RESControls table:
	// Dialog<tab>RadioButtonGroup:Property:Order<tab>RESID

	// make sure radiobutton table exists
	MSICONDITION eCond = MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("RadioButton"));
	switch (eCond)
	{
	case MSICONDITION_ERROR:
	case MSICONDITION_NONE:
	case MSICONDITION_FALSE:
		_tprintf(TEXT("LOG_ERROR>> RadioButton table does not exist, is not persistent, or an error occured.\n"));
		return m_fError = TRUE, FALSE; // error - ABORT
	case MSICONDITION_TRUE:
		break;
	default:
		assert(0);
	}
	int iResId = 0;

	// open view on RadioButton table
	PMSIHANDLE hViewRB = 0;
	PMSIHANDLE hRecExec = MsiCreateRecord(1);
	if (ERROR_SUCCESS != MsiDatabaseOpenView(m_hDatabase, sqlRadioButton, &hViewRB)
		|| ERROR_SUCCESS != MsiRecordSetString(hRecExec, 1, szProperty)
		|| ERROR_SUCCESS != MsiViewExecute(hViewRB, hRecExec))
	{
		return m_fError = TRUE, FALSE; // error - ABORT
	}
	// fetch record
	PMSIHANDLE hRecRB = 0;
	UINT iStat;
	while (ERROR_SUCCESS == (iStat = MsiViewFetch(hViewRB, &hRecRB)))
	{
		DWORD cchLen = 0;
		if (ERROR_MORE_DATA != MsiRecordGetString(hRecRB, irbcText, TEXT(""), &cchLen))
			return m_fError = TRUE, FALSE;
		TCHAR* szRBText = new TCHAR[++cchLen];
		if ( !szRBText )
			return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY
		if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecRB, irbcText, szRBText, &cchLen)))
		{
			_tprintf(TEXT("LOG_ERROR>> MsiRecordGetString(radio button text).  %d\n"), iStat);
			delete [] szRBText;
			return m_fError = TRUE, FALSE; // error - ABORT
		}
		int iRBX = MsiRecordGetInteger(hRecRB, irbcX);
		int iRBY = MsiRecordGetInteger(hRecRB, irbcY);
		int iRBWd = MsiRecordGetInteger(hRecRB, irbcWd);
		int iRBHt = MsiRecordGetInteger(hRecRB, irbcHt);

		// grab order value
		int iOrder = MsiRecordGetInteger(hRecRB, irbcOrder);

		// attempt to find resource ID if previously used
		DWORD cchGeneratedName = _tcslen(szRBGroup) + _tcslen(szProperty) + 25; // 25 = null + 2 ':' + iOrder
		TCHAR* szGeneratedName = new TCHAR[cchGeneratedName];
		if ( !szGeneratedName )
		{
			delete [] szRBText;
			return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY
		}

		if (FAILED(StringCchPrintf(szGeneratedName, cchGeneratedName, TEXT("%s:%s:%d"), szRBGroup, szProperty, iOrder)))
		{
			delete [] szRBText;
			delete [] szGeneratedName;
			return m_fError = TRUE, FALSE;
		}

		DWORD cchSQL = _tcslen(sqlFindResId) + _tcslen(szDialog) + _tcslen(szGeneratedName) + 1;
		TCHAR* szSQL = new TCHAR[cchSQL];
		if ( !szSQL )
		{
			delete [] szRBText;
			delete [] szGeneratedName;
			return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY
		}

		if (FAILED(StringCchPrintf(szSQL, cchSQL, sqlFindResId, szDialog, szGeneratedName)))
		{
			delete [] szRBText;
			delete [] szGeneratedName;
			delete [] szSQL;
			return m_fError = TRUE, FALSE;
		}

		PMSIHANDLE hViewFindRes = 0;
		PMSIHANDLE hRecFindRes = 0;
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, szSQL, &hViewFindRes))
			|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewFindRes, 0)))
		{
			delete [] szRBText;
			delete [] szGeneratedName;
			delete [] szSQL;
			return m_fError = TRUE, FALSE;
		}
		if (ERROR_SUCCESS == (iStat = MsiViewFetch(hViewFindRes, &hRecFindRes)))
		{
			// grab res id
			iResId = MsiRecordGetInteger(hRecFindRes, 1);
		}
		else if (ERROR_NO_MORE_ITEMS == iStat)
		{
			// use next available resource Id
			iResId = ++m_iCtrlResID;
		}
		else
		{
			delete [] szRBText;
			delete [] szGeneratedName;
			delete [] szSQL;
			return m_fError = TRUE, FALSE;
		}

		delete [] szSQL;
		szSQL = NULL;

		TCHAR szTempBuf[64] = {0};
		DWORD dwWritten = 0;
		/*KEYWORD*/
		if (!WriteFile(m_hFile, resRadioButton, _tcslen(resRadioButton)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		/*<tab>"str",*/
		if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		// escape chars in str
		TCHAR* szEscText = EscapeSlashAndQuoteForRC(szRBText);
		if ( !szEscText )
		{
			delete [] szRBText;
			delete [] szGeneratedName;
			return m_fError = TRUE, FALSE;
		}
		if (_tcslen(szEscText) > iMaxResStrLen)
		{
			_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> CONTROL ID: %d\n"), iResId);
			if (FAILED(StringCchCopy(szEscText, _tcslen(szEscText) + 1, strOverLimit)))
			{
				delete [] szEscText;
				delete [] szRBText;
				delete [] szGeneratedName;
				return m_fError = TRUE, FALSE;
			}
		}
		if (!WriteFile(m_hFile, szEscText, _tcslen(szEscText)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		delete [] szEscText;
		if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		/*<tab>RESId,*/
		if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;

		if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%d"), iResId)))
		{
			delete [] szRBText;
			delete [] szGeneratedName;
			return m_fError = TRUE, FALSE;
		}

		if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		/*x, y, wd, ht DIMENSIONS*/
		// for RB, X & Y dimensions are local to group, so must add in group's x and y
		if (!PrintDimensions(x+iRBX, y+iRBY, iRBWd, iRBHt))
		{
			delete [] szRBText;
			delete [] szGeneratedName;
			return m_fError = TRUE, FALSE; // error - ABORT
		}
		//attributes are ignored at this time (would require conversion from Installer to Windows and masking of Installer specific)
		if (attrib & msidbControlAttributesBitmap)
		{
			// control with bitmap picture -- want to prevent localization of picture property names
			/*,<tab>BS_BITMAP*/
			if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;

			if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%s"), TEXT("BS_BITMAP"))))
			{
				delete [] szRBText;
				delete [] szGeneratedName;
				return m_fError = TRUE, FALSE;
			}

			if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten,0))
				m_cWriteFileErr++;
		}
		else if (attrib & msidbControlAttributesIcon)
		{
			// control with icon picture
			/*<tab>BS_ICON*/
			if(!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;

			if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%s"), TEXT("BS_ICON"))))
			{
				delete [] szRBText;
				delete [] szGeneratedName;
				return m_fError = TRUE, FALSE;
			}

			if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten,0))
				m_cWriteFileErr++;
		}
		if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;

		// update _RESControls table with new info
		PMSIHANDLE hViewRes = 0;
		PMSIHANDLE hRecInsertCtrl = MsiCreateRecord(3);
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlInsertCtrl, &hViewRes))
			|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewRes, 0))
			|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecInsertCtrl, 1, szDialog))
			|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecInsertCtrl, 2, szGeneratedName))
			|| ERROR_SUCCESS != (iStat = MsiRecordSetInteger(hRecInsertCtrl, 3, iResId))
			|| ERROR_SUCCESS != (iStat = MsiViewModify(hViewRes, MSIMODIFY_ASSIGN, hRecInsertCtrl)))
		{
			_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
			delete [] szRBText;
			delete [] szGeneratedName;
			return m_fError = TRUE, FALSE;
		}

		delete [] szRBText;
		szRBText = NULL;
		delete [] szGeneratedName;
		szGeneratedName = NULL;
	}
	if (ERROR_NO_MORE_ITEMS != iStat)// doesn't catch where property never in RadioButton table
	{
		_tprintf(TEXT("LOG_ERROR>> MsiViewFetch(RadioButton table)\n"));
		return m_fError = TRUE, FALSE; // error - ABORT
	}

	// return success
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteStdWinCtrl
BOOL CGenerateRC::WriteStdWinCtrl(int iResId, const TCHAR* resType, TCHAR* szCtrlText, int x, int y, int wd, int ht, int attrib)
{
	// Format for StdWinCtrl is
	//   KEYWORD<tab>"str",<tab>RESID,<tab>x,<tab>y,<tab>wd,<tab>ht[[,<tab> STYLE ]]
	// Keyword can be one of PUSHBUTTON, CHECKBOX, GROUPBOX

	TCHAR szTempBuf[64] = {0};
	DWORD dwWritten = 0;
	/*KEYWORD*/
	if (!WriteFile(m_hFile, resType, _tcslen(resType)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>"str",*/
	if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	// escape chars in str
	TCHAR* szEscText = EscapeSlashAndQuoteForRC(szCtrlText);
	if ( !szEscText )
		return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY

	if (_tcslen(szEscText) > iMaxResStrLen)
	{
		_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> CONTROL ID: %d\n"), iResId);
		if (FAILED(StringCchCopy(szEscText, _tcslen(szEscText) + 1, strOverLimit)))
		{
			delete [] szEscText;
			return m_fError = TRUE, FALSE;
		}
	}
	if (!WriteFile(m_hFile, szEscText, _tcslen(szEscText)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	delete [] szEscText;
	szEscText = NULL;

	if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>RESId,*/
	if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%d"), iResId)))
		return m_fError = TRUE, FALSE;

	if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*x, y, wd, ht DIMENSIONS*/
	if (!PrintDimensions(x, y, wd, ht))
		return FALSE; // error - ABORT
	//attributes are ignored at this time (would require conversion from Installer to Windows and masking of Installer specific)
	// valid picture controls are CheckBox, PushButton, and RadioButtons
	if (0 != _tcscmp(resType, szMsiGroupBox))
	{
		if (attrib & msidbControlAttributesBitmap)
		{
			// control with bitmap picture -- want to prevent localization of picture property names
			/*,<tab>BS_BITMAP*/
			if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;

			if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%s"), TEXT("BS_BITMAP"))))
				return m_fError = TRUE, FALSE;

			if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten,0))
				m_cWriteFileErr++;
		}
		else if (attrib & msidbControlAttributesIcon)
		{
			// control with icon picture
			/*<tab>BS_ICON*/
			if(!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;

			if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%s"), TEXT("BS_ICON"))))
				return m_fError = TRUE, FALSE;
			if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten,0))
				m_cWriteFileErr++;
		}
	}
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	// return success
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteWin32Ctrl
BOOL CGenerateRC::WriteWin32Ctrl(int iResId, const TCHAR* szClass, TCHAR* szCtrlText, TCHAR* szAttrib, int x, int y, int wd, int ht, int attrib)
{
	// Format for StdWinCtrl is
	//   CONTROL<tab>"str",<tab>RESID,<tab>class,<tab>attrib,<tab>x,<tab>y,<tab>wd,<tab>ht[[,<tab> STYLE ]]

	TCHAR szTempBuf[64] = {0};
	DWORD dwWritten = 0;
	/*CONTROL*/
	if (!WriteFile(m_hFile, resControl, _tcslen(resControl)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>"str",*/
	if (!WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	// escape chars in str
	TCHAR* szEscText = EscapeSlashAndQuoteForRC(szCtrlText);
	if ( !szEscText )
		return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY

	if (_tcslen(szEscText) > iMaxResStrLen)
	{
		_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> CONTROL ID:%d\n"), iResId);
		if (FAILED(StringCchCopy(szEscText, _tcslen(szEscText) + 1, strOverLimit)))
		{
			delete [] szEscText;
			return m_fError = TRUE, FALSE;
		}
	}
	if (!WriteFile(m_hFile, szEscText, _tcslen(szEscText)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	delete [] szEscText;
	szEscText = NULL;

	if (!WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>RESId,*/
	if (FAILED(StringCchPrintf(szTempBuf, sizeof(szTempBuf)/sizeof(szTempBuf[0]), TEXT("%d"), iResId)))
		return m_fError = TRUE, FALSE;
	if (!WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>class,*/
	if (!WriteFile(m_hFile, szClass, _tcslen(szClass)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>attrib,*/
	if (!WriteFile(m_hFile, szAttrib, _tcslen(szAttrib)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*x, y, wd, ht DIMENSIONS*/
	if (!PrintDimensions(x, y, wd, ht))
		return FALSE; // error - ABORT
	//attributes are ignored at this time (would require conversion from Installer to Windows and masking of Installer specific)
	if (!WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	// return success
	return TRUE;
}


//_______________________________________________________________________________________
//
// CIMPORTRES CLASS IMPLEMENTATION
//_______________________________________________________________________________________



/////////////////////////////////////////////////////////////////////////////
// CImportRes::~CImportRes
// --  Handles destruction of necessary objects.
// --  Commits database if no errors
CImportRes::~CImportRes()
{
	UINT iStat;
	if (m_hDatabase)
	{
		// only commit database if no errors
		if (!m_fError)
		{
			if (ERROR_SUCCESS != (iStat = MsiDatabaseCommit(m_hDatabase)))
				_tprintf(TEXT("!! DATABASE COMMIT FAILED. Error = %d\n"), iStat);
		}
		else
			_tprintf(TEXT("NO CHANGES SAVED TO DATABASE DUE TO ERROR\n"));
		MsiCloseHandle(m_hDatabase);
	}
	if (m_hControl)
		MsiCloseHandle(m_hControl);
	if (m_hDialog)
		MsiCloseHandle(m_hDialog);
	if (m_hRadioButton)
		MsiCloseHandle(m_hRadioButton);
	if (m_hInst)
		FreeLibrary(m_hInst);

}

/////////////////////////////////////////////////////////////////////////////
// Notes:
// 1.)We will only update vcenter, hcenter, width, height and title
//         of Dialog.
//
// 2.)We will only update x, y, width, height, and text of Control.
// 3.)We will only update width, height, and text of RadioButton.
//       RadioButtons can be used multiply in different dialogs and multiple
//       RadioButtonGroups using same properties can be wired on the same dialog
//       Plus, RadioButtons are local to the GroupBox that contains them therefore
//       it would require maintaining state data of the GroupBox's X and Y dimensions

//////////////////////////////////////////////////////////////////////////////
// VerifyDatabaseCodepage
UINT CImportRes::VerifyDatabaseCodepage()
{
	UINT iStat;
	// only output from language neutral database
	TCHAR szTempPath[MAX_PATH+1] = {0};
	DWORD cchRet = GetTempPath(sizeof(szTempPath)/sizeof(szTempPath[0]), szTempPath);
	if (0 == cchRet || cchRet > sizeof(szTempPath)/sizeof(szTempPath[0]))
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;

	// export _ForceCodepage table so can verify codepage
	if (ERROR_SUCCESS != (iStat = MsiDatabaseExport(m_hDatabase, TEXT("_ForceCodepage"), szTempPath, szCodepageExport)))
	{
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseExport(_ForceCodepage)\n"));
		return m_fError = TRUE, iStat; // error - ABORT
	}
	// open _ForceCodepage.idt to read it
	DWORD cchFullPath = _tcslen(szTempPath) + _tcslen(szCodepageExport) + 1;
	TCHAR* szFullPath = new TCHAR[cchFullPath];
	if ( !szFullPath )
		return m_fError = TRUE, ERROR_OUTOFMEMORY;

	if (FAILED(StringCchPrintf(szFullPath, cchFullPath, TEXT("%s%s"), szTempPath, szCodepageExport)))
	{
		delete [] szFullPath;
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	}
	HANDLE hFile = CreateFile(szFullPath, GENERIC_READ, FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)0, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
	if (hFile == NULL)
	{
		_tprintf(TEXT("LOG_ERROR>> OpenFile(_ForceCodepage.idt)\n"));
		delete [] szFullPath;
		return m_fError = TRUE, iStat; // error - ABORT
	}

	delete [] szFullPath;
	szFullPath = NULL;

	// read file for information
	DWORD dwSize = GetFileSize(hFile, NULL);
	if (0xFFFFFFFF == dwSize)
	{
		CloseHandle(hFile);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	}
		
	char* szBuf = new char[dwSize+1];
	if ( !szBuf )
	{
		CloseHandle(hFile);
		return m_fError = TRUE, ERROR_OUTOFMEMORY;
	}

	DWORD dwRead = 0;
	if (!ReadFile(hFile, (LPVOID)szBuf, dwSize, &dwRead, NULL)
		|| 0 == dwRead)
	{
		delete [] szBuf;
		CloseHandle(hFile);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	}
	// parse buffer
	// format should be : blank line, blank line, "codepage<tab>_ForceCodepage"
	char* pch = szBuf;
	int cBlankLines = 0;
	while (dwRead && cBlankLines != 2)
	{
		if (*pch == '\n')
			cBlankLines++;
		pch++;
		dwRead--;
	}
	if (!dwRead || cBlankLines != 2)
	{
		_tprintf(TEXT("LOG_ERROR>> Invalid ForceCodepage idt format\n"));
		delete [] szBuf;
		CloseHandle(hFile);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	}
	// codepage is next
	char* pchCodepage = pch;
	while (dwRead && *pch != ' ' && *pch != '\t')
	{
		pch++;
		dwRead--;
	}
	assert(dwRead);
	*pch = '\0';
	// convert codepage to int
	UINT uiCodepage = strtoul(pchCodepage, NULL, 10);
	delete [] szBuf;
	szBuf = NULL;
	if (uiCodepage != 0 && uiCodepage != g_uiCodePage) // 0 is language neutral
	{
		_tprintf(TEXT("LOG_ERROR>> DATABASE IS NOT LANGUAGE NEUTRAL OR OF SAME CODEPAGE AS RESOURCE STRINGS. CANNOT IMPORT\n"));
		_tprintf(TEXT("LOG_ERROR>> DATABASE CODEPAGE= %d\n"), uiCodepage);
		CloseHandle(hFile);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	}
	if (!CloseHandle(hFile))
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::ImportDialog
UINT CImportRes::ImportDialog(TCHAR* szDialog)
{
	UINT iStat = Initialize();
	if (ERROR_SUCCESS != iStat)
		return m_fError = TRUE, iStat; // error - ABORT

	if (ERROR_SUCCESS != (iStat = ImportDlgInit()))
		return m_fError = TRUE, iStat; // error - ABORT

	// convert dialog name to resource identifier (all upper case)
	_tcsupr(szDialog);

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...BEGIN SEARCH FOR DIALOG <%s>...\n"), szDialog);
#endif

	// load dialog
	if (!LoadDialog(m_hInst, RT_DIALOG, szDialog))
	{
		_tprintf(TEXT("LOG_ERROR>> UNABLE LOAD DIALOG: %s\n"), szDialog);
		return ERROR_FUNCTION_FAILED; // fatal error state set in LoadDialog
	}

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::ImportDlgInit
UINT CImportRes::ImportDlgInit()
{
	// open up view on Dialog table
	UINT iStat;
	if (!m_hDialog)
	{
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlDialogImport, &m_hDialog)))
			return m_fError = TRUE, iStat; // error - ABORT
	}
	// open up view on Control table
	if (!m_hControl)
	{
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlControlImport, &m_hControl)))
		{
			if (ERROR_BAD_QUERY_SYNTAX != iStat)
				return m_fError = TRUE, iStat; // error - ABORT
		}
	}
	// open up view on RadioButton table
	if (!m_hRadioButton)
	{
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlRadioButtonImport, &m_hRadioButton)))
		{
			if (ERROR_BAD_QUERY_SYNTAX != iStat)
				return ERROR_SUCCESS; // they just don't have a radiobutton table
			else
				return m_fError = TRUE, iStat; // error - ABORT
		}
	}

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
// CImportRes::Initialize
UINT CImportRes::Initialize()
{
	// attempt to load the DLL in memory
	if (!m_hInst)
	{
		m_hInst = LoadLibrary(m_szDLLFile);
		if (NULL == m_hInst)
		{
			_tprintf(TEXT("LOG_ERROR>> Unable to load DLL '%s'\n"), m_szDLLFile);
			return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
		}
	}

	// open up database in TRANSACT mode so we can update
	if (!m_hDatabase)
	{
		assert(m_szOrigDb);
		// open up existing database in transacted mode, or specify a new database for creation
		UINT iStat;
		if (ERROR_SUCCESS != (iStat = MsiOpenDatabase(m_szOrigDb, m_szDatabase ? m_szDatabase : MSIDBOPEN_TRANSACT, &m_hDatabase)))
		{
			_tprintf(TEXT("LOG_ERROR>> Unable to open database '%s'\n"), m_szOrigDb);
			return m_fError = TRUE, iStat; // error - ABORT
		}
		_tprintf(TEXT("LOG>> Database opened from-->%s, Database saving to-->%s\n"),m_szOrigDb, m_szDatabase ? m_szDatabase : m_szOrigDb);
	}
	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::ImportStrings
UINT CImportRes::ImportStrings()
{
	UINT iStat = Initialize();
	if (ERROR_SUCCESS != iStat)
		return m_fError = TRUE, iStat; // error - ABORT

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...BEGIN STRING RESOURCE ENUMERATION...\n"));
#endif

	// enumerate through string resources
	BOOL fOK = EnumResourceNames(m_hInst, RT_STRING, EnumStringCallback, (long)this);
	if (!fOK)
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...END STRING RESOURCE ENUMERATION...\n"));
#endif

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::ImportDialogs
UINT CImportRes::ImportDialogs()
{
	UINT iStat = Initialize();
	if (ERROR_SUCCESS != iStat)
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = ImportDlgInit()))
		return m_fError = TRUE, iStat; // error - ABORT

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...BEGIN DIALOG RESOURCE ENUMERATION...\n"));
#endif

	// enumerate through dialog resources
	BOOL fOK = EnumResourceNames(m_hInst, RT_DIALOG, EnumDialogCallback, (long)this);
	if (!fOK)
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...END DIALOG RESOURCE ENUMERATION...\n"));
#endif

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::LoadString
BOOL CImportRes::LoadString(HINSTANCE hModule, const TCHAR* szType, TCHAR* szStringName)
{
	PMSIHANDLE hViewStrId = 0;
	PMSIHANDLE hRecStrId = 0;
	UINT iStat;
	if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlStringInstallerName, &hViewStrId)))
	{
		_tprintf(TEXT("LOG_ERROR>> _RESStrings table is missing from database.\n"));
		return m_fError = TRUE, FALSE;
	}

	int iFirst = (int(szStringName) - 1) * 16;
	TCHAR rgchBuffer[512] = {0}; // 512 should be large enough for any string in resource file
	DWORD cchBuffer = sizeof(rgchBuffer)/sizeof(TCHAR);
	for (int i = 0; i < 16; i++) 
	{
		int cchWritten = ::LoadString(hModule, iFirst + i, rgchBuffer, cchBuffer);
		if (cchWritten == 0)
			continue; // null string

		if (_tcscmp(rgchBuffer, strOverLimit) == 0)
			continue; // string greater than limit, leave alone

		// use id of string to find table, column, and row it belongs to
		PMSIHANDLE hRecExec = MsiCreateRecord(1);
		if (ERROR_SUCCESS != (iStat = MsiRecordSetInteger(hRecExec, 1, iFirst + i))
			|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewStrId, hRecExec))
			|| ERROR_SUCCESS != (iStat = MsiViewFetch(hViewStrId, &hRecStrId)))
			return m_fError = TRUE, FALSE;


		// we now have the table and column and row
		// want to SELECT `column` from `table` WHERE row matches
		DWORD cchLen = 0;
		if (ERROR_MORE_DATA != MsiRecordGetString(hRecStrId, 1, TEXT(""), &cchLen))
			return m_fError = TRUE, FALSE;
		TCHAR* szTable = new TCHAR[++cchLen];
		if ( !szTable )
			return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY
		if (ERROR_SUCCESS != MsiRecordGetString(hRecStrId, 1, szTable, &cchLen))
		{
			delete [] szTable;
			return m_fError = TRUE, FALSE;
		}

		cchLen = 0;
		if (ERROR_MORE_DATA != MsiRecordGetString(hRecStrId, 2, TEXT(""), &cchLen))
		{
			delete [] szTable;
			return m_fError = TRUE, FALSE;
		}
		TCHAR* szColumn = new TCHAR[++cchLen];
		if ( !szColumn )
		{
			delete [] szTable;
			return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY
		}
		if (ERROR_SUCCESS != MsiRecordGetString(hRecStrId, 2, szColumn, &cchLen))
		{
			delete [] szTable;
			delete [] szColumn;
			return m_fError = TRUE, FALSE;
		}

		cchLen = 0;
		if (ERROR_MORE_DATA != MsiRecordGetString(hRecStrId, 3, TEXT(""), &cchLen))
		{
			delete [] szTable;
			delete [] szColumn;
			return m_fError = TRUE, FALSE;
		}
		TCHAR* szKey = new TCHAR[++cchLen];
		if ( !szKey )
		{
			delete [] szTable;
			delete [] szColumn;
			return m_fError = TRUE, FALSE;
		}
		if (ERROR_SUCCESS != MsiRecordGetString(hRecStrId, 3, szKey, &cchLen))
		{
			delete [] szTable;
			delete [] szColumn;
			delete [] szKey;
			return m_fError = TRUE, FALSE;
		}

		// need to determine how big to make WHERE clause, i.e. # of primary keys
		PMSIHANDLE hRecPrimaryKeys = 0;
		if (ERROR_SUCCESS != (iStat = MsiDatabaseGetPrimaryKeys(m_hDatabase, szTable, &hRecPrimaryKeys)))
		{
			delete [] szTable;
			delete [] szColumn;
			delete [] szKey;
			return m_fError = TRUE, FALSE;
		}
		int cKeys = MsiRecordGetFieldCount(hRecPrimaryKeys);

		// determine number of keys in "szKey" by counting # of ':'
		TCHAR* pch = szKey;
		int cKeyFromTable = 1;
		while (pch != 0 && *pch != '\0')
		{
			if (*pch++ == ':')
				cKeyFromTable++;
		}

		if (cKeyFromTable != cKeys)
		{
			delete [] szTable;
			delete [] szColumn;
			delete [] szKey;
			return m_fError = TRUE, FALSE;
		}

		int iKey;

		// determine length of Primary key column names
		DWORD cchColNames = 0;
		for (iKey = 1; iKey <= cKeys; iKey++)
		{
			DWORD cchTemp = 0;
			if (ERROR_MORE_DATA == MsiRecordGetString(hRecPrimaryKeys, iKey, TEXT(""), &cchTemp))
				cchColNames += cchTemp;
		}

		if (0 == cchColNames)
		{
			delete [] szTable;
			delete [] szColumn;
			delete [] szKey;
			return m_fError = TRUE, FALSE;
		}

		// sql query length is sqlStringImport + szColumn + szTable + WHERE clause
		//  where clause is ' AND ' + KeyColumn='KeyColumnValue' at max for each key
		DWORD cchStrSQL = _tcslen(sqlStringImport)
						+ _tcslen(szColumn)
						+ _tcslen(szTable)
						+ cKeys*_tcslen(TEXT(" AND "))
						+ cchColNames
						+ cKeys*2 // for enclosing '' on string columns
						+ _tcslen(szKey)
						+ 1;
		TCHAR* szStrSQL = new TCHAR[cchStrSQL];
		if ( !szStrSQL )
		{
			delete [] szTable;
			delete [] szColumn;
			delete [] szKey;
			return m_fError = TRUE, FALSE;
		}
		if (FAILED(StringCchPrintf(szStrSQL, cchStrSQL, sqlStringImport, szColumn, szTable)))
		{
			delete [] szTable;
			delete [] szColumn;
			delete [] szKey;
			delete [] szStrSQL;
			return m_fError = TRUE, FALSE;
		}

		// need to get column types
		TCHAR sqlTemp[255] = {0};
		if (FAILED(StringCchPrintf(sqlTemp, sizeof(sqlTemp)/sizeof(sqlTemp[0]), sqlStrTemp, szTable)))
		{
			delete [] szTable;
			delete [] szColumn;
			delete [] szKey;
			delete [] szStrSQL;
			return m_fError = TRUE, FALSE;
		}

		PMSIHANDLE hViewTemp = 0;
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, sqlTemp, &hViewTemp))
			|| ERROR_SUCCESS != MsiViewExecute(hViewTemp, 0))
		{
			delete [] szTable;
			delete [] szColumn;
			delete [] szKey;
			delete [] szStrSQL;
			return m_fError = TRUE, FALSE;
		}
		PMSIHANDLE hRecColInfo = 0;
		if (ERROR_SUCCESS != (iStat = MsiViewGetColumnInfo(hViewTemp, MSICOLINFO_TYPES, &hRecColInfo)))
		{
			delete [] szTable;
			delete [] szColumn;
			delete [] szKey;
			delete [] szStrSQL;
			return m_fError = TRUE, FALSE;
		}


		// for each primary key, add to WHERE clause
		TCHAR szColType[10] = {0};
		DWORD cchColType = sizeof(szColType)/sizeof(TCHAR);
		for (iKey = 1; iKey <= cKeys; iKey++)
		{
			DWORD cchKey = 0;
			if (ERROR_MORE_DATA != MsiRecordGetString(hRecPrimaryKeys, iKey, TEXT(""), &cchKey))
			{
				delete [] szTable;
				delete [] szColumn;
				delete [] szKey;
				delete [] szStrSQL;
				return m_fError = TRUE, FALSE;
			}
			TCHAR* szPrimaryKeyCol = new TCHAR[++cchKey];
			if ( !szPrimaryKeyCol )
			{
				delete [] szTable;
				delete [] szColumn;
				delete [] szKey;
				delete [] szStrSQL;
				return m_fError = TRUE, FALSE; // ERROR_OUTOFMEMORY
			}
			if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecPrimaryKeys, iKey, szPrimaryKeyCol, &cchKey)))
			{
				delete [] szTable;
				delete [] szColumn;
				delete [] szKey;
				delete [] szStrSQL;
				delete [] szPrimaryKeyCol;
				return m_fError = TRUE, FALSE;
			}

			if (ERROR_SUCCESS != (iStat = MsiRecordGetString(hRecColInfo, iKey, szColType, &cchColType)))
			{
				delete [] szTable;
				delete [] szColumn;
				delete [] szKey;
				delete [] szStrSQL;
				delete [] szPrimaryKeyCol;
				return m_fError = TRUE, FALSE;
			}

			cchColType = sizeof(szColType)/sizeof(TCHAR); // reset

			TCHAR* szKeyValue = NULL;
			if (iKey == 1)
				szKeyValue = _tcstok(szKey, szTokenSeps);
			else
				szKeyValue = _tcstok(NULL, szTokenSeps);

			if ( !szKeyValue )
			{
				delete [] szTable;
				delete [] szColumn;
				delete [] szKey;
				delete [] szStrSQL;
				delete [] szPrimaryKeyCol;
				return m_fError = TRUE, FALSE;
			}

			if (iKey != 1)
			{
				if (FAILED(StringCchCat(szStrSQL, cchStrSQL, TEXT(" AND "))))
				{
					delete [] szTable;
					delete [] szColumn;
					delete [] szKey;
					delete [] szStrSQL;
					delete [] szPrimaryKeyCol;
					return m_fError = TRUE, FALSE;
				}
			}

			if (FAILED(StringCchCat(szStrSQL, cchStrSQL, szPrimaryKeyCol)))
			{
				delete [] szTable;
				delete [] szColumn;
				delete [] szKey;
				delete [] szStrSQL;
				delete [] szPrimaryKeyCol;
				return m_fError = TRUE, FALSE;
			}

			if ((*szColType | 0x20) == 'i') // integer
			{
				if (FAILED(StringCchCat(szStrSQL, cchStrSQL, TEXT("=")))
					|| FAILED(StringCchCat(szStrSQL, cchStrSQL, szKeyValue)))
				{
					delete [] szTable;
					delete [] szColumn;
					delete [] szKey;
					delete [] szStrSQL;
					delete [] szPrimaryKeyCol;
					return m_fError = TRUE, FALSE;
				}
			}
			else if ((*szColType | 0x20) == 's' || (*szColType | 0x20) == 'l')
			{
				// string constants must be enclosed in 'str'
				if (FAILED(StringCchCat(szStrSQL, cchStrSQL, TEXT("='")))
					|| FAILED(StringCchCat(szStrSQL, cchStrSQL, szKeyValue))
					|| FAILED(StringCchCat(szStrSQL, cchStrSQL, TEXT("'"))))
				{
					delete [] szTable;
					delete [] szColumn;
					delete [] szKey;
					delete [] szStrSQL;
					delete [] szPrimaryKeyCol;
					return m_fError = TRUE, FALSE;
				}
			}
			else
			{
				assert(0); // unexpected column type
				delete [] szTable;
				delete [] szColumn;
				delete [] szKey;
				delete [] szStrSQL;
				delete [] szPrimaryKeyCol;
				return m_fError = TRUE, FALSE;
			}
			delete [] szPrimaryKeyCol;
		}

		// now grab row from table
		PMSIHANDLE hViewRow = 0;
		PMSIHANDLE hRecRow = 0;
		if (ERROR_SUCCESS != (iStat = MsiDatabaseOpenView(m_hDatabase, szStrSQL, &hViewRow))
			|| ERROR_SUCCESS != (iStat = MsiViewExecute(hViewRow, 0))
			|| ERROR_SUCCESS != (iStat = MsiViewFetch(hViewRow, &hRecRow))
			|| ERROR_SUCCESS != (iStat = MsiRecordSetString(hRecRow, 1, rgchBuffer))
			|| ERROR_SUCCESS != (iStat = MsiViewModify(hViewRow, MSIMODIFY_UPDATE, hRecRow)))
		{
			_tprintf(TEXT("LOG_ERROR>> ROW: %s is Missing From Table: %s\n"), szKey, szTable);
			delete [] szTable;
			delete [] szColumn;
			delete [] szKey;
			delete [] szStrSQL;
			return m_fError = TRUE, FALSE;
		}

		// clean-up
		delete [] szStrSQL;
		delete [] szTable;
		delete [] szColumn;
		delete [] szKey;
	}//For block of 16 string table strings

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::LoadDialog
BOOL CImportRes::LoadDialog(HINSTANCE hModule, const TCHAR* szType, TCHAR* szDialog)
{
	// Find dialog resource into memory
	HRSRC hrsrc = FindResource(hModule, szDialog, szType);
	if (hrsrc == NULL)
	{
		_tprintf(TEXT("LOG_ERROR>> DIALOG RESOURCE: %s NOT FOUND!\n"), szDialog);
		// not set error state here we could be attempting to load individual dlg resources and we want to continue
		return FALSE;
	}

	// Load resource
	HGLOBAL hResource = LoadResource(hModule, hrsrc);
	if (hResource == NULL)
		return m_fError = TRUE, FALSE; // error - ABORT

	// Create stream object to read from resource in memory
	CDialogStream DialogRes(LockResource(hResource));

	const unsigned short STANDARD_MARKER = 0xFFFF;

	////////////////////////////////////////////////////////////////
	//                  Dialog Information                        //
	//                                                            //
	// stored as DLGTEMPLATEEX (should not have DLGTEMPLATE)      //
			/*	typedef struct {  
				WORD      dlgVer; 
				WORD      signature; 
				DWORD     helpID; 
				DWORD     exStyle; 
				DWORD     style; 
				WORD      cDlgItems; 
				short     x; 
				short     y; 
				short     cx; 
				short     cy; 
				sz_Or_Ord menu; 
				sz_Or_Ord windowClass; 
				WCHAR     title[titleLen]; 
			// The following members exist only if the style member is 
			// set to DS_SETFONT or DS_SHELLFONT.
				short     pointsize; 
				short     weight; 
				short     italic; 
				WCHAR     typeface[stringLen];  
			} DLGTEMPLATEEX; */
	////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////
	// DLGTEMPLATE structure does not have dlgVer, signature, helpID,
	//             weight, or italic members
	//

	/* dlgVer */
	unsigned short iDlgVer = DialogRes.GetUInt16();
	BOOL fOldVersion = FALSE;
	if (iDlgVer != 1)
	{
		// we have the old style -- DLGTEMPLATE + DLGITEMTEMPLATE
		fOldVersion = TRUE;
		DialogRes.Undo16();
	}
	if (!fOldVersion)
	{
		/* signature */
		DialogRes.GetInt16();
		/* helpID */
		DialogRes.GetInt32();
	}
	/* Extended Style + Style */
	int iDlgStyle = DialogRes.GetInt32() | DialogRes.GetInt32();
	/* Number of Controls on Dialog */
	unsigned short iNumCtrl  = DialogRes.GetUInt16();
	/* X-coord (maps to HCentering value) */
	unsigned short iDlgXDim  = DialogRes.GetUInt16();
	/* Y-coord (maps to VCentering value) */
	unsigned short iDlgYDim  = DialogRes.GetUInt16();
	/* width */
	unsigned short iDlgWdDim = DialogRes.GetUInt16();
	/* height */
	unsigned short iDlgHtDim = DialogRes.GetUInt16();
	/* menu, aligned on WORD boundary */
	DialogRes.Align16();
	unsigned short iDlgMenu = DialogRes.GetUInt16();
	if (iDlgMenu == STANDARD_MARKER)
		DialogRes.GetInt16(); // ordinal menu value
	else if (iDlgMenu != 0x0000)
	{
		TCHAR* szMenu = DialogRes.GetStr();
		if (szMenu)
			delete [] szMenu;
	}
	/* class, aligned on WORD boundary */
	DialogRes.Align16();
	unsigned short iDlgClass = DialogRes.GetUInt16();
	if (iDlgClass == STANDARD_MARKER)
		DialogRes.GetInt16(); // ordinal window class value
	else if (iDlgClass != 0x00)
	{
		TCHAR* szClass = DialogRes.GetStr();
		if (szClass)
			delete [] szClass;
	}
	/* title, aligned on WORD boundary */
	DialogRes.Align16();
	TCHAR* szDlgTitle = DialogRes.GetStr();
	if ( !szDlgTitle )
		return m_fError = TRUE, TRUE;
	/* font */
	if (iDlgStyle & DS_SETFONT)
	{
		/* font point size */
		short iDlgPtSize = DialogRes.GetInt16();
		if (!fOldVersion)
		{
			/* font weight */
			short iDlgFontWt = DialogRes.GetInt16();
			/* font italic */
			short iDlgFontItalic = DialogRes.GetInt16();
		}
		/* font typeface, aligned on WORD boundary */
		DialogRes.Align16();
		TCHAR* szFont = DialogRes.GetStr();
		if (szFont)
			delete [] szFont;
	}

#ifdef DEBUG
	_tprintf(TEXT("LOG>> DIALOG '%s' with '%d' controls at x=%d,y=%d,wd=%d,ht=%d. Title = \"%s\"\n"),
				szDialog,iNumCtrl,iDlgXDim,iDlgYDim,iDlgWdDim,iDlgHtDim,szDlgTitle);
#endif

	/* find dialog in Dialog table, if fail, we ignore */
	//UNSUPPORTED: additional dialogs

	// first find match to dialog in _RESDialogs table
	PMSIHANDLE hViewFindDlgInstlrName = 0;
	PMSIHANDLE hRecDlgInstlrName = 0;
	PMSIHANDLE hRecDlgRESName = MsiCreateRecord(1);
	assert(hRecDlgRESName);
	UINT iStat;
	if (ERROR_SUCCESS != MsiRecordSetString(hRecDlgRESName, 1, szDialog)
		|| ERROR_SUCCESS != MsiDatabaseOpenView(m_hDatabase, sqlDialogInstallerName, &hViewFindDlgInstlrName)
		|| ERROR_SUCCESS != MsiViewExecute(hViewFindDlgInstlrName, hRecDlgRESName)
		|| ERROR_SUCCESS != (iStat = MsiViewFetch(hViewFindDlgInstlrName, &hRecDlgInstlrName))
		|| ERROR_SUCCESS != MsiViewExecute(m_hDialog, hRecDlgInstlrName))
	{
		delete [] szDlgTitle;
		return m_fError = TRUE, TRUE;
	}

	// fetch dialog for update
	PMSIHANDLE hRecDlg = 0;
	if (ERROR_SUCCESS != (iStat = MsiViewFetch(m_hDialog, &hRecDlg)))
	{
		assert(iStat == ERROR_NO_MORE_ITEMS);
		// could be ERROR_NO_MORE_ITEMS -- someone removed the dialog
		_tprintf(TEXT("LOG_ERROR>> Dialog '%s' not found in database '%s'. New Dialogs are not supported.\n"), szDialog, m_szDatabase);
		delete [] szDlgTitle;
		return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue processing
	}

	// update dialog
	if (ERROR_SUCCESS != MsiRecordSetInteger(hRecDlg, idiHCentering, iDlgXDim)
		|| ERROR_SUCCESS != MsiRecordSetInteger(hRecDlg, idiVCentering, iDlgYDim)
		|| ERROR_SUCCESS != MsiRecordSetInteger(hRecDlg, idiWidth, iDlgWdDim)
		|| ERROR_SUCCESS != MsiRecordSetInteger(hRecDlg, idiHeight, iDlgHtDim))
	{
		delete [] szDlgTitle;
		return m_fError = TRUE, TRUE;
	}

	if (_tcscmp(strOverLimit, szDlgTitle) != 0) // don't update if "!! STR OVER LIMIT !!"
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRecDlg, idiTitle, szDlgTitle))
		{
			delete [] szDlgTitle;
			return m_fError = TRUE, TRUE;
		}
	}

	if (ERROR_SUCCESS != (iStat = MsiViewModify(m_hDialog, MSIMODIFY_UPDATE, hRecDlg)))
	{
		_tprintf(TEXT("LOG_ERROR>>Failed to update Dialog '%s'.\n"), szDialog);
		delete [] szDlgTitle;
		return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue with other Dialogs
	}

	delete [] szDlgTitle;
	szDlgTitle = NULL;

	///////////////////////////////////////////////////////////////////////
	//                  Control Information                              //
	//                                                                   //
	// stored as DLGITEMTEMPLATEEX (should not have DLGITEMTEMPLATE)     //
	/*	typedef struct { 
			DWORD  helpID; 
			DWORD  exStyle; 
			DWORD  style; 
			short  x; 
			short  y; 
			short  cx; 
			short  cy; 
			WORD   id; 
			sz_Or_Ord windowClass; 
			sz_Or_Ord title; 
			WORD   extraCount; 
		} DLGITEMTEMPLATEEX; */
	/////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////
	// DLGITEMTEMPLATE does not have helpID
	//
	if (iNumCtrl > 0 && !m_hControl)
	{
		_tprintf(TEXT("LOG_ERROR>> Unable to update controls.  Control table does not exist\n"));
		return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue processing
	}
	PMSIHANDLE hViewCtrlInstallerName = 0;
	PMSIHANDLE hRecCtrl = 0;
	PMSIHANDLE hRecRadioButton = MsiCreateRecord(2);
	PMSIHANDLE hRecCtrlResId = MsiCreateRecord(1);
	assert(hRecCtrlResId);
	if (ERROR_SUCCESS != MsiDatabaseOpenView(m_hDatabase, sqlControlInstallerName, &hViewCtrlInstallerName))
	{
		_tprintf(TEXT("LOG_ERROR>> _RESControls table is missing from database\n"));
		return m_fError = TRUE, TRUE;
	}
	bool fRadioButton = false;
	// cycle through the controls
	for (int i = 1; i <= iNumCtrl; i++)
	{
		/* DLGITEMTEMPLATEEX is aligned on a DWORD boundary */
		DialogRes.Align32(); 

		fRadioButton = false;

		if (!fOldVersion)
		{
			/* helpID */
			DialogRes.GetInt32();
		}
		/* exStyle | style */
		int iCtrlAttrib = DialogRes.GetInt32() | DialogRes.GetInt32();
		/* x */
		unsigned short iCtrlXDim = DialogRes.GetUInt16();
		/* y */
		unsigned short iCtrlYDim = DialogRes.GetUInt16();
		/* cx */
		unsigned short iCtrlWdDim = DialogRes.GetUInt16();
		/* cy */
		unsigned short iCtrlHtDim = DialogRes.GetUInt16();
		/* id */
		unsigned short iCtrlId = DialogRes.GetUInt16();
		/* windowClass -- aligned on word boundary*/
		if (!fOldVersion)
			DialogRes.GetInt16(); //!! don't appear to be aligned on word boundary, instead have extra 16 though ??
		else
			DialogRes.Align16();
		unsigned short iWndwClass = DialogRes.GetUInt16();
		if (iWndwClass == STANDARD_MARKER)
		{
			// pre-defined window class
			unsigned short iCtrlWindowClass = DialogRes.GetUInt16();
			switch (iCtrlWindowClass)
			{
			case 0x0080: // button
				if (iCtrlAttrib & BS_RADIOBUTTON)
					fRadioButton = true;
				break;
			case 0x0081: // edit
				break;
			case 0x0082: // static
				break;
			case 0x0083: // list box
				break;
			case 0x0084: // scroll bar
				break;
			case 0x0085: // combo box
				break;
			default: assert(0);
				break;
			}
		}
		else
		{
			// custom window class, stored as str
			DialogRes.Undo16();
			TCHAR* szCtrlType = DialogRes.GetStr();
			if (szCtrlType)
				delete [] szCtrlType;
		}

		/* title -- aligned on word boundary*/
		DialogRes.Align16();
		TCHAR* szCtrlText = 0;
		if (DialogRes.GetUInt16() == STANDARD_MARKER)
		{
			// ordinal
			DialogRes.GetInt16();
		}
		else
		{
			// str title
			DialogRes.Undo16();
			szCtrlText = DialogRes.GetStr();
		}
		if ( !szCtrlText )
			return m_fError = TRUE, TRUE;

		/* extra count */
		short iCtrlCreationData = DialogRes.GetInt16();
		if (iCtrlCreationData > 0)
		{
			DialogRes.Align16(); // data begins at next WORD boundary
			DialogRes.Move(iCtrlCreationData);
		}

		// find control's real name (for use with Installer)
		if (ERROR_SUCCESS != MsiRecordSetInteger(hRecCtrlResId, 1, iCtrlId)
			|| ERROR_SUCCESS != MsiViewExecute(hViewCtrlInstallerName, hRecCtrlResId))
		{
			delete [] szCtrlText;
			return m_fError = TRUE, TRUE;
		}

		// fetch control's real name
		if (ERROR_SUCCESS != (iStat = MsiViewFetch(hViewCtrlInstallerName, &hRecCtrl)))
		{
			if (ERROR_NO_MORE_ITEMS == iStat)
			{
				// new control, unsupported feature
				_tprintf(TEXT("LOG_ERROR>>\t Control with ID '%d' not found. New Controls are not supported.\n"), iCtrlId);
			}

			delete [] szCtrlText;
			return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue processing
		}

		DWORD dwName = 0;
		if (ERROR_MORE_DATA != MsiRecordGetString(hRecCtrl, 2, TEXT(""), &dwName))
		{
			delete [] szCtrlText;
			return m_fError = TRUE, TRUE;
		}

		TCHAR* szCtrlName = new TCHAR[++dwName];
		if ( !szCtrlName )
		{
			delete [] szCtrlText;
			return m_fError = TRUE, FALSE;
		}

		if (ERROR_SUCCESS != MsiRecordGetString(hRecCtrl, 2, szCtrlName, &dwName))
		{
			delete [] szCtrlText;
			delete [] szCtrlName;
			return m_fError = TRUE, TRUE;
		}
#ifdef DEBUG
		_tprintf(TEXT("LOG>>\tCONTROL '%d' ('%s') at x=%d,y=%d,wd=%d,ht=%d. Text = \"%s\"\n"),
			iCtrlId,szCtrlName,iCtrlXDim,iCtrlYDim,iCtrlWdDim,iCtrlHtDim,szCtrlText);
#endif

		// fetch control's info for update
		// for radiobuttons, we have to get it from the radiobutton table
		// we also have to parse the szCtrlName string to get out the property and order keys used in the radiobutton table
		// assumes that radiobuttons follow group:property:order syntax
		if (fRadioButton && !_tcschr(szCtrlName, ':'))
			fRadioButton = false; // not really a radiobutton, just the group encapsulating them

		PMSIHANDLE hRecRBExec = 0;
		if (fRadioButton)
		{
			if (!m_hRadioButton)
			{
				_tprintf(TEXT("LOG_ERROR>> RadioButtons found, but no RadioButton table exists in the database\n"));
				delete [] szCtrlText;
				delete [] szCtrlName;
				return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue processing
			}
			// parse name RadioButtonGroup:Property:Order
			TCHAR* szRBGroup = _tcstok(szCtrlName, szTokenSeps);
			if ( !szRBGroup )
			{
				delete [] szCtrlText;
				delete [] szCtrlName;
				return m_fError = TRUE, TRUE;
			}
			TCHAR* szRBProperty = _tcstok(NULL, szTokenSeps);
			if ( !szRBProperty )
			{
				delete [] szCtrlText;
				delete [] szCtrlName;
				return m_fError = TRUE, TRUE;
			}
			TCHAR* szRBOrder = _tcstok(NULL, szTokenSeps);
			if ( !szRBOrder )
			{
				delete [] szCtrlText;
				delete [] szCtrlName;
				return m_fError = TRUE, TRUE;
			}
			int iRBOrder = _ttoi(szRBOrder);
#ifdef DEBUG
			_tprintf(TEXT("LOG>> RadioButton belongs to RBGroup: %s, Property: %s, and has Order=%d"), szRBGroup, szRBProperty, iRBOrder);
#endif
			hRecRBExec = MsiCreateRecord(2);
			if (ERROR_SUCCESS != MsiRecordSetString(hRecRBExec, 1, szRBProperty)
				|| ERROR_SUCCESS != MsiRecordSetInteger(hRecRBExec, 2, iRBOrder))
			{
				delete [] szCtrlText;
				delete [] szCtrlName;
				return m_fError = TRUE, TRUE;
			}
		}
		if (ERROR_SUCCESS != MsiViewExecute(fRadioButton ? m_hRadioButton : m_hControl, fRadioButton ? hRecRBExec : hRecCtrl))
		{
			delete [] szCtrlText;
			delete [] szCtrlName;
			return m_fError = TRUE, TRUE;
		}
		PMSIHANDLE hRecCtrlUpdate = 0;
		if (ERROR_SUCCESS != (iStat = MsiViewFetch(fRadioButton ? m_hRadioButton : m_hControl, &hRecCtrlUpdate)))
		{
			if (ERROR_NO_MORE_ITEMS == iStat)
			{
				// control has been removed from database
				_tprintf(TEXT("LOG_ERROR>>\t Control with ID '%d' not found in database.\n"), iCtrlId);
			}

			delete [] szCtrlText;
			delete [] szCtrlName;
			return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue processing
		}

		// update info
		if (!fRadioButton)
		{
			if (ERROR_SUCCESS != MsiRecordSetInteger(hRecCtrlUpdate, iciX, iCtrlXDim)
				|| ERROR_SUCCESS != MsiRecordSetInteger(hRecCtrlUpdate, iciY, iCtrlYDim))
			{
				delete [] szCtrlText;
				delete [] szCtrlName;
				return m_fError = TRUE, TRUE;
			}
		}
		if (ERROR_SUCCESS != MsiRecordSetInteger(hRecCtrlUpdate, fRadioButton ? irbiWidth : iciWidth, iCtrlWdDim)
			|| ERROR_SUCCESS != MsiRecordSetInteger(hRecCtrlUpdate, fRadioButton ? irbiHeight : iciHeight, iCtrlHtDim))
		{
			delete [] szCtrlText;
			delete [] szCtrlName;
			return m_fError = TRUE, TRUE;
		}
		if (0 != _tcscmp(strOverLimit, szCtrlText)) // don't update if "!! STR OVER LIMIT !!"
		{
			if (ERROR_SUCCESS != MsiRecordSetString(hRecCtrlUpdate, fRadioButton ? irbiText : iciText, szCtrlText))
			{
				delete [] szCtrlText;
				delete [] szCtrlName;
				return m_fError = TRUE, TRUE;
			}
		}
		if (ERROR_SUCCESS != (iStat = MsiViewModify(fRadioButton ? m_hRadioButton : m_hControl, MSIMODIFY_UPDATE, hRecCtrlUpdate)))
		{
			_tprintf(TEXT("LOG_ERROR>>Failed to update Control '%d'.\n"), iCtrlId);
			delete [] szCtrlText;
			delete [] szCtrlName;
			return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue with other Dialogs
		}

		delete [] szCtrlText;
		delete [] szCtrlName;
		if (ERROR_SUCCESS != MsiViewClose(hViewCtrlInstallerName)) // for re-execute
			return m_fError = TRUE, TRUE;
	}

	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
// CImportRes::SetCodePage
BOOL CImportRes::SetCodePage(WORD wLang)
{
	// if we have already set the codepage, we don't need to do it again
	if (m_fSetCodepage)
		return TRUE;

	DWORD dwLocale = MAKELCID(wLang, SORT_DEFAULT);
	TCHAR szLocaleBuf[7]; // from MSDN, max # char allowed is 6
	int cch = GetLocaleInfo(dwLocale, LOCALE_IDEFAULTANSICODEPAGE, szLocaleBuf, sizeof(szLocaleBuf)/sizeof(TCHAR));
	if (0 == cch)
		return m_fError = TRUE, FALSE;

	// GetLocaleInfo always returns information in text format
	// Numeric data is written in decimal format
	// Expect numeric data because ask for CodePage...need to convert to int
	TCHAR* szStop;
	g_uiCodePage = _tcstoul(szLocaleBuf, &szStop, 0);

	//verify database's codepage
	// database's codepage must either be language NEUTRAL or match g_uiCodepage
	if (ERROR_SUCCESS != VerifyDatabaseCodepage())
		return m_fError = TRUE, FALSE;

	// verify codepage is available on system
	// A code page is considered valid only if it is installed in the system. 
	if (!IsValidCodePage(g_uiCodePage))
		return m_fError = TRUE, FALSE; // codepage not valid for this system

	// set codepage in database using _ForceCodepage table
	// find temp directory
	TCHAR szTempPath[MAX_PATH+1] = {0};
	DWORD cchRet = GetTempPath(sizeof(szTempPath)/sizeof(szTempPath[0]), szTempPath);
	if (0 == cchRet || cchRet > sizeof(szTempPath)/sizeof(szTempPath[0]))
		return m_fError = TRUE, FALSE;

	// create full path (TEMP directory already has backslash)
	DWORD cchFileFullPath = _tcslen(szTempPath) + _tcslen(szCodepageFile) + 1;
	TCHAR* szFileFullPath = new TCHAR[cchFileFullPath];
	if ( !szFileFullPath )
		return m_fError = TRUE, FALSE;
	if (FAILED(StringCchPrintf(szFileFullPath, cchFileFullPath, TEXT("%s%s"), szTempPath, szCodepageFile)))
	{
		delete [] szFileFullPath;
		return m_fError = TRUE, FALSE;
	}
	DWORD dwWritten = 0;
	HANDLE hFile = CreateFile(szFileFullPath, GENERIC_WRITE, FILE_SHARE_WRITE, 0, CREATE_ALWAYS, 0, 0);
	if (!hFile)
	{
		_tprintf(TEXT("!! Unable to set codepage of database.\n"));
		delete [] szFileFullPath;
		return m_fError = TRUE, FALSE;
	}

	/*********************************
	 FORMAT FOR FORCING CODEPAGE
	**********************************/
	// blank line
	// blank line
	// codepage<tab>_ForceCodepage
	DWORD cchCodepage = _tcslen(szLocaleBuf) + _tcslen(szForceCodepage) + _tcslen(TEXT("\r\n\r\n%s\t%s\r\n")) + 1;
	TCHAR* szCodepage = new TCHAR[cchCodepage];
	if ( !szCodepage )
	{
		delete [] szFileFullPath;
		return m_fError = TRUE, FALSE;
	}

	if (FAILED(StringCchPrintf(szCodepage, cchCodepage, TEXT("\r\n\r\n%s\t%s\r\n"), szLocaleBuf, szForceCodepage)))
	{
		delete [] szFileFullPath;
		delete [] szCodepage;
		return m_fError = TRUE, FALSE;
	}

#ifdef UNICODE
	int cchAnsi = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, szCodepage, -1, NULL, 0, NULL, NULL);
	char* szBuf = new char[cchAnsi];
	if ( !szBuf )
	{
		delete [] szFileFullPath;
		delete [] szCodepage;
		return m_fError = TRUE, FALSE;
	}
	if (0 == WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, szCodepage, -1, szBuf, cchAnsi, NULL, NULL))
	{
		delete [] szFileFullPath;
		delete [] szCodepage;
		delete [] szBuf;
		return m_fError = TRUE, FALSE;
	}
	if (!WriteFile(hFile, szBuf, strlen(szBuf), &dwWritten, 0))
	{
		delete [] szFileFullPath;
		delete [] szCodepage;
		delete [] szBuf;
		return m_fError = TRUE, FALSE;
	}
	delete [] szBuf;
#else
	if (!WriteFile(hFile, szCodepage, cchCodepage-1, &dwWritten, 0))
	{
		delete [] szFileFullPath;
		delete [] szCodepage;
		return m_fError = TRUE, FALSE;
	}
#endif

	delete [] szCodepage;
	
	if (!CloseHandle(hFile))
	{
		delete [] szFileFullPath;
		return m_fError = TRUE, FALSE;
	}

	// set codepage of database
	UINT iStat = MsiDatabaseImport(m_hDatabase, szTempPath, szCodepageFile);
	if (iStat != ERROR_SUCCESS)
	{
		_tprintf(TEXT("!! Unable to set codepage of database. Error = %d\n"), iStat);
		delete [] szFileFullPath;
		return m_fError = TRUE, FALSE;
	}
	
	// attempt to delete the file we created for clean-up
	DeleteFile(szFileFullPath);

	delete [] szFileFullPath;

	// update status flage
	m_fSetCodepage = TRUE;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// EnumDialogCallback 
BOOL __stdcall EnumDialogCallback(HINSTANCE hModule, const TCHAR* szType, TCHAR* szDialogName, long lParam)
{
	// determine codepage required.  steps, enumerate languages in resource file (better be no more than two)
	// possibilities are NEUTRAL (non-localized) + other lang

	if ( !lParam )
		return FALSE;

	((CImportRes*)lParam)->SetFoundLang(FALSE); // init to FALSE
	if (!EnumResourceLanguages(hModule, szType, szDialogName, EnumLanguageCallback, lParam))
		return FALSE;
	
#ifdef DEBUG
	_tprintf(TEXT("LOG>> DIALOG: '%s' FOUND\n"),szDialogName);
#endif

	BOOL fOK = ((CImportRes*)lParam)->LoadDialog(hModule, szType, szDialogName);
	if (!fOK)
	{
		// error occured
		((CImportRes*)lParam)->SetErrorState(TRUE);
		return FALSE;
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// EnumStringCallback
BOOL __stdcall EnumStringCallback(HINSTANCE hModule, const TCHAR* szType, TCHAR* szName, long lParam)
{
	if ( !lParam )
		return FALSE;

	((CImportRes*)lParam)->SetFoundLang(FALSE); // init to FALSE

	// determine codepage required.  steps, enumerate languages in resource file (better be no more than two)
	// possibilities are NEUTRAL (non-localized) + other lang
	if (!EnumResourceLanguages(hModule, szType, szName, EnumLanguageCallback, lParam))
		return FALSE;


	BOOL fOK = ((CImportRes*)lParam)->LoadString(hModule, szType, szName);
	if (!fOK)
	{
		// error occured
		((CImportRes*)lParam)->SetErrorState(TRUE);
		return FALSE;
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// EnumLanguageCallback
BOOL __stdcall EnumLanguageCallback(HINSTANCE hModule, const TCHAR* szType, const TCHAR* szName, WORD wIDLanguage, long lParam)
{
	/*************************************************************************************
	RESTRICTIONS:
	1.) ONLY 1 language per resource
	2.) UP To 2 languages per resource file (but 1 must be LANG_NEUTRAL)
	3.) On Win9x we must be on a system matching the required codepage
	4.) We should only be able to update a language neutral database or
	    a database set with the required code page
	5.) Database can only have one code page (Although _SummaryInformation stream
	    can have a code page different from database as _SummaryInformation is considered
		to be different
	**************************************************************************************/
	
	if ( !lParam )
		return FALSE;

	if (((CImportRes*)lParam)->WasLanguagePreviouslyFound())
	{
		// ERROR -- more than 1 language per dialog
		_tprintf(TEXT("!! STRING RESOURCE IS IN MORE THAN ONE LANGUAGE IN RESOURCE FILE\n"));
		((CImportRes*)lParam)->SetErrorState(TRUE);
		return FALSE;
	}

	// if languages match we are good to go
	if (g_wLangId != wIDLanguage)
	{
		// languages don't match
		// 2 valid scenarios

		// valid SCENARIO 1: g_wLangId is NEUTRAL, wIDLanguage new language
		// valid SCENARIO 2: g_wLangId is language, wIDLanguage is NEUTRAL
		// all other scenarios invalid
		if (g_wLangId == MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
		{
			// set codepage, update g_uiCodePage
			if (!((CImportRes*)lParam)->SetCodePage(wIDLanguage))
				return ((CImportRes*)lParam)->SetErrorState(TRUE), FALSE;
			g_wLangId = wIDLanguage;
		}
		else if (wIDLanguage != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
		{
			// invalid, 2 different languages, neither one NEUTRAL
			_tprintf(TEXT("!! Resource file contains more than one language. Not Supported. Lang1 = %d, Lang2 = %d\n"), g_wLangId, wIDLanguage);
			return ((CImportRes*)lParam)->SetErrorState(TRUE), FALSE;
		}
	}
	
	((CImportRes*)lParam)->SetFoundLang(TRUE); // language found for resource
	return TRUE;
}

//_______________________________________________________________________________________
//
// CDIALOGSTREAM CLASS IMPLEMENTATION
//_______________________________________________________________________________________

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::GetInt16 -- returns a 16 bit integer, moves internal ptr 16
short CDialogStream::GetInt16()
{
	short i = *(short*)m_pch;
	m_pch += sizeof(short);
	return i;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::GetUInt16 -- returns a 16 bit unsigned integer, moves internal ptr 16
unsigned short CDialogStream::GetUInt16()
{
	unsigned short i = *(unsigned short*)m_pch;
	m_pch += sizeof(unsigned short);
	return i;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::GetInt32 -- returns a 32 bit integer, moves internal ptr 32
int CDialogStream::GetInt32()
{
	int i = *(int*)m_pch;
	m_pch += sizeof(int);
	return i;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::GetInt8 -- returns a 8 bit integer, moves internal ptr 8
int CDialogStream::GetInt8()
{
	int i = *(unsigned char*)m_pch;
	m_pch += sizeof(unsigned char);
	return i;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::GetStr -- returns a null terminated str from memory.
//   Handles DBCS, Unicode str storage.  Moves ptr length of str.
//   Resource strings stored as unicode
TCHAR* CDialogStream::GetStr()
{
	TCHAR* sz = NULL;

	int cchwide = lstrlenW((wchar_t*)m_pch);
#ifdef UNICODE
	sz = new TCHAR[cchwide + 1];
	if ( !sz )
		return NULL;
	lstrcpyW(sz, (wchar_t*)m_pch);
#else
	// what codepage to use to translate?
	int cb = WideCharToMultiByte(CP_ACP, 0, (wchar_t*)m_pch, -1, 0, 0, 0, 0);
	sz = new TCHAR[cb+1];
	if ( !sz )
		return NULL;
	BOOL fUsedDefault;
	if (0 == WideCharToMultiByte(CP_ACP, 0, (wchar_t*)m_pch, -1, sz, cb, 0, &fUsedDefault))
	{
		delete [] sz;
		return NULL;
	}
#endif // UNICODE
	
	m_pch += 2*(cchwide+1);
	return sz;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::Align32-- moves pointer to DWORD boundary
BOOL CDialogStream::Align32()
{
	m_pch = (char*)(int(m_pch) + 3 & ~ 3);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::Align16-- moves pointer to WORD boundary
BOOL CDialogStream::Align16()
{
	m_pch = (char*)(int(m_pch) + 1 & ~ 1);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::Undo16 -- moves ptr back 16
BOOL CDialogStream::Undo16()
{
	m_pch -= sizeof(unsigned short);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::Move -- moves pointer cbBytes
BOOL CDialogStream::Move(int cbBytes)
{
	m_pch += cbBytes;
	return TRUE;
}

CDialogStream::CDialogStream(HGLOBAL hResource)
	: m_pch((char*)hResource)
{
	// Constructor
}

CDialogStream::~CDialogStream()
{
	// Destructor
}


//__________________________________________________________________________________________
//
// MAIN + HELPER FUNCTIONS
//__________________________________________________________________________________________

///////////////////////////////////////////////////////////
// usage
void Usage()
{
	_tprintf(
			TEXT("MSILOC.EXE -- Copyright (C) Microsoft Corporation, 2000-2001.  All rights reserved\n")
			TEXT("\t*Generates a resource file from the UI in the installation package\n")
			TEXT("\t*Imports a localized resource DLL into an installation package\n")
			TEXT("\n")
			TEXT("SYNTAX -->EXPORT MSI TO RC (creates a resource file):\n")
			TEXT("  msiloc -e {database} {option 1}{option 2}...\n")
			TEXT("SYNTAX -->IMPORT (RES)DLL TO MSI:\n")
			TEXT("  msiloc -i {database} {resource DLL} {option 1}{option 2}...\n")
			TEXT("OPTIONS:\n")
			TEXT("    -d * all dialogs\n")
			TEXT("    -d {Dialog1} specific dialog\n")
			TEXT("    -s {Table Column} specific column of strings (EXPORT ONLY)\n")
			TEXT("    -s * * all strings (IMPORT ONLY)\n")
			TEXT("    -x option to not export binary data (bitmaps, icons, jpegs) (EXPORT ONLY)\n")
			TEXT("    -c {database} option to save to a new database\n")
			TEXT("\n")
			TEXT("CREATING A .RES FILE:\n")
			TEXT("    rc.exe {resource file}\n")
			TEXT("CREATING A .DLL FILE:\n")
			TEXT("    link.exe /DLL /NOENTRY /NODEFAULTLIB /MACHINE:iX86\n")
			TEXT("         /OUT:{resource DLL} {compiled res file}\n")
			);
}

///////////////////////////////////////////////////////////
// SkipWhiteSpace
TCHAR SkipWhiteSpace(TCHAR*& rpch)
{
	TCHAR ch = 0;
	if (rpch)
	{
		for (; (ch = *rpch) == TEXT(' ') || ch == TEXT('\t'); rpch++)
			;
	}
	return ch;
}

///////////////////////////////////////////////////////////
// SkipValue
BOOL SkipValue(TCHAR*& rpch)
{
	if ( !rpch ) 
		return FALSE;

	TCHAR ch = *rpch;
	if (ch == 0 || ch == TEXT('/') || ch == TEXT('-'))
		return FALSE;   // no value present

	TCHAR *pchSwitchInUnbalancedQuotes = NULL;

	for (; (ch = *rpch) != TEXT(' ') && ch != TEXT('\t') && ch != 0; rpch++)
	{       
		if (*rpch == TEXT('"'))
		{
			rpch++; // for '"'

			for (; (ch = *rpch) != TEXT('"') && ch != 0; rpch = CharNext(rpch))
			{
				if ((ch == TEXT('/') || ch == TEXT('-')) && (NULL == pchSwitchInUnbalancedQuotes))
				{
					pchSwitchInUnbalancedQuotes = rpch;
				}
			}
			rpch = CharNext(rpch);
            ch = *rpch;
            break;
		}
	}
	if (ch != 0)
	{
		*rpch++ = 0;
	}
	else
	{
		if (pchSwitchInUnbalancedQuotes)
			rpch=pchSwitchInUnbalancedQuotes;
	}
	return TRUE;
}

///////////////////////////////////////////////////////////
// Error
void Error(TCHAR* szMsg)
{
	if (szMsg)
		_tprintf(TEXT("MSILOC ERROR: %s\n"), szMsg);
	throw 1;
}

///////////////////////////////////////////////////////////
// ErrorIf
void ErrorIf(BOOL fError, TCHAR* szMsg, BOOL fThrow)
{
	if (fError)
	{
		if (szMsg)
            _tprintf(TEXT("MSILOC ERROR: %s\n"), szMsg);
		if (fThrow)
			throw 1;
	}
}

///////////////////////////////////////////////////////////
// _tmain
extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{	
	// WE WANT UNICODE ON NT/Windows2000
	// ?? ANSI on WIN9x

	try
	{
		TCHAR* szCmdLine = GetCommandLine();
		if ( !szCmdLine )
		{
			Usage();
			throw 1;
		}

		TCHAR* pch = szCmdLine;
		// skip module name
		if ( !SkipValue(pch) )
		{
			Usage();
			throw 1;
		}

		TCHAR chCmdNext;

		TCHAR* rgszTables[MAX_STRINGS];
		TCHAR* rgszColumns[MAX_STRINGS];
		TCHAR* rgszDialogs[MAX_DIALOGS];
		TCHAR* szDb = 0;
		TCHAR* szRESDLL = 0;
		TCHAR* szSaveDatabase = 0;
		int cStr = 0;
		int cDlg = 0;
		int iMode = 0;
		while ((chCmdNext = SkipWhiteSpace(pch)) != 0)
		{
			if (chCmdNext == TEXT('/') || chCmdNext == TEXT('-'))
			{
				TCHAR* szCmdOption = pch++;
				TCHAR chOption = (TCHAR)(*pch++ | 0x20);
				chCmdNext = SkipWhiteSpace(pch);
				TCHAR* szCmdData = pch;
				switch (chOption)
				{
				case TEXT('i'):
					iMode |= iIMPORT_RES;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = I)\n"));
					szDb = szCmdData;
					szCmdData = pch;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = I)\n"));
					szRESDLL = szCmdData;
					break;
				case TEXT('e'):
					iMode |= iEXPORT_MSI;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = E)\n"));
					szDb = szCmdData;
					break;
				case TEXT('d'):
					iMode |= iDIALOGS;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = D)\n"));
					if (cDlg == MAX_DIALOGS)
						Error(TEXT("Too Many Dialogs On Command Line\n"));
					rgszDialogs[cDlg++] = szCmdData;
					break;
				case TEXT('s'):
					iMode |= iSTRINGS;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = S)\n"));
					if (cStr == MAX_STRINGS)
						Error(TEXT("Too Many Table:Column Pairs On Command Line\n"));
					rgszTables[cStr] = szCmdData;
					szCmdData = pch;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = S)\n"));
					rgszColumns[cStr++] = szCmdData;
					break;
				case TEXT('x'):
					iMode |= iSKIP_BINARY;
					break;
				case TEXT('c'):
					iMode |= iCREATE_NEW_DB;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = C)\n"));
					szSaveDatabase = szCmdData;
					break;
				case TEXT('?'):
					Usage();
					return 0;
				default:
					Usage();
					return 1;
				}
			}
			else
			{
				Usage();
				return 1;
			}
		}

		// must specify either EXPORT or IMPORT, but not both
		if (iMode == 0 || (iMode & (iEXPORT_MSI | iIMPORT_RES)) == (iEXPORT_MSI | iIMPORT_RES) ||
			(iMode & ~(iEXPORT_MSI | iIMPORT_RES)) == 0)
		{
			Usage();
			throw 1;
		}

		if ((iMode & iCREATE_NEW_DB) && !szDb)
		{
			Usage();
			throw 1;
		}

		if ((iMode & iEXPORT_MSI) && szDb)
		{
			// export MSI to RESOURCE file
			CGenerateRC genRC(szDb, (iMode & iCREATE_NEW_DB) ? szSaveDatabase : NULL);
			if (iMode & iDIALOGS)
			{
				// export DIALOGS
				BOOL fBinary = (iMode & iSKIP_BINARY) ? FALSE : TRUE;
				if (1 == cDlg && 0 == _tcscmp(TEXT("*"), rgszDialogs[0]))
				{
					// export all dialogs
					ErrorIf(ERROR_SUCCESS != genRC.OutputDialogs(fBinary), TEXT("Failed to Export Dialogs To Resource File"), true);
				}
				else
				{
					// export specified dialogs only
					// we'll try every dialog listed so we won't through the error
					for (int i = 0; i < cDlg; i++)
						ErrorIf(ERROR_SUCCESS != genRC.OutputDialog(rgszDialogs[i], fBinary), TEXT("Failed to Export Dialog To Resource File"), false);
					ErrorIf(genRC.IsInErrorState(), TEXT("EXPORT failed"), true);
				}
			}
			if (iMode & iSTRINGS)
			{
				// export STRINGS
				if (1 == cStr && 0 == _tcscmp(TEXT("*"), rgszTables[0]) && 0 == _tcscmp(TEXT("*"), rgszColumns[0]))
				{
					// export all strings
					// NOT SUPPORTED
					_tprintf(TEXT("EXPORT ALL STRINGS OPTION is not supported\n"));
					Usage();
					throw 1;
				}
				for (int i = 0; i < cStr; i++)
					ErrorIf(ERROR_SUCCESS != genRC.OutputString(rgszTables[i], rgszColumns[i]), TEXT("Failed to Export Strings"), false);
				ErrorIf(genRC.IsInErrorState(), TEXT("EXPORT STRINGS failed"), true);
			}
		}
		else if ((iMode & iIMPORT_RES) && szDb && szRESDLL)
		{
			// import RESOURCE DLL into MSI
			CImportRes importRes(szDb, (iMode & iCREATE_NEW_DB) ? szSaveDatabase  : NULL, szRESDLL);
			if (iMode & iDIALOGS)
			{
				// import DIALOGS
				if (1 == cDlg && 0 == _tcscmp(TEXT("*"), rgszDialogs[0]))
				{
					// import all dialogs
					ErrorIf(ERROR_SUCCESS != importRes.ImportDialogs(), TEXT("Failed to Import Dialogs Into Database"), true);
				}
				else
				{
					// import specified dialogs only
					// we'll try every dialog listed so we won't through the error
					for (int i = 0; i < cDlg; i++)
						ErrorIf(ERROR_SUCCESS != importRes.ImportDialog(rgszDialogs[i]), TEXT("Failed to Import Dialog Into Database"), false);
					ErrorIf(importRes.IsInErrorState(), TEXT("IMPORT failed"), true);
				}
			}
			if (iMode & iSTRINGS)
			{
				// import STRINGS
				if (1 == cStr && 0 == _tcscmp(TEXT("*"), rgszTables[0]) && 0 == _tcscmp(TEXT("*"), rgszColumns[0]))
				{
					// import all strings
					ErrorIf(importRes.ImportStrings(), TEXT("IMPORT STRINGS failed"), true);
				}
				else
				{
					// import specific strings only
					// UNSUPPORTED option
					_tprintf(TEXT("IMPORT SPECIFIC STRINGS option is not supported\n"));
					Usage();
					throw 1;
				}
			}
		}
		else
		{
			Usage();
			throw 1;
		}
		return 0;
	}
	catch (int i)
	{
		i;
		return 1;
	}
	catch (...)
	{
		_tprintf(TEXT("\n MSILOC: unhandled exception.\n"));
		return 2;
	}

}	// end of main

#else // RC_INVOKED, end of source code, start of resources
// resource definition go here
#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimerg\msimerg.cpp ===
#if 0  // makefile definitions
DESCRIPTION = Merge Database Utility
MODULENAME = MsiMerg
SUBSYSTEM = console
FILEVERSION = Msi
LINKLIBS = OLE32.lib
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2001
//
//  File:       msimerg.cpp
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f msimerg.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 Console Application project
//      2. Add msimerg.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

#define W32DOWS_LEAN_AND_MEAN  // faster compile
#define W32
#define MSI

#include <windows.h>
#ifndef RC_INVOKED    // start of source code
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include <stdio.h>
#include "MsiQuery.h" // MSI API

//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

const TCHAR szHelp[] = TEXT("Copyright (C) Microsoft Corporation.  All rights reserved.\nMsi Merge Tool --- Merge Two Databases\n\nMsiMerg(d).exe {base db} {ref db}\n");
const TCHAR szTable[] = TEXT("_MergeErrors");

const int cchDisplayBuf = 4096;										
HANDLE g_hStdOut;
TCHAR g_rgchBuffer[4096];

//________________________________________________________________________________
//
// Function prototypes
//________________________________________________________________________________

void Display(LPCTSTR szMessage);
void ErrorExit(UINT iError, LPCTSTR szMessage);
void CheckError(UINT iError, LPCTSTR szMessage);
void Merge(TCHAR* szBaseDb, TCHAR* szRefDb);

//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
	// Determine handle
	g_hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
	if (g_hStdOut == INVALID_HANDLE_VALUE)
		g_hStdOut = 0;  // non-zero if stdout redirected or piped
	
	if (argc == 2 && ((_tcscmp(argv[1], TEXT("-?")) == 0) || (_tcscmp(argv[1], TEXT("/?")) == 0)))
		ErrorExit( 0, szHelp);

	// Check for enough arguments and valid options
	CheckError(argc != 3, TEXT("msimerg(d).exe {base db} {ref db}"));
	Merge(argv[1], argv[2]);
	ErrorExit(0, TEXT("Done"));
	return 0;
}


//________________________________________________________________________________
//
// Merge function
//    Merge(...);
//________________________________________________________________________________

void Merge(TCHAR* szBaseDb, TCHAR* szRefDb)
{
	PMSIHANDLE hBaseDb = 0;
	PMSIHANDLE hRefDb = 0;

	CheckError(MSI::MsiOpenDatabase(szBaseDb, MSIDBOPEN_TRANSACT, &hBaseDb), TEXT("Error Opening Base Database"));
	CheckError(MSI::MsiOpenDatabase(szRefDb, MSIDBOPEN_READONLY, &hRefDb), TEXT("Error Opening Reference Databaes"));
	UINT uiError = MSI::MsiDatabaseMerge(hBaseDb, hRefDb, szTable);
	CheckError(MSI::MsiDatabaseCommit(hBaseDb), TEXT("Error Saving Database"));
	CheckError(uiError, TEXT("Error Merging Database, Check _MergeErrors Table for Merge conflicts"));
}

//________________________________________________________________________________
//
// Error handling and Display functions:
//    Display(...);
//	   ErrorExit(...);
//    CheckError(...);
//
//________________________________________________________________________________

void Display(LPCTSTR szMessage)
{
	if (szMessage)
	{
		int cbOut = _tcsclen(szMessage);;
		if (g_hStdOut)
		{
#ifdef UNICODE
			char rgchTemp[cchDisplayBuf];
			if (W32::GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
			{
				W32::WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
				szMessage = (LPCWSTR)rgchTemp;
			}
			else
				cbOut *= sizeof(TCHAR);   // write Unicode if not console device
#endif
			DWORD cbWritten;
			W32::WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
		}
		else
			W32::MessageBox(0, szMessage, W32::GetCommandLine(), MB_OK);
	}
}


void ErrorExit(UINT iError, LPCTSTR szMessage)
{
	if (szMessage)
	{
		int cbOut;
		TCHAR szBuffer[256];  // errors only, not used for display output
		if (iError == 0)
			cbOut = lstrlen(szMessage);
		else
		{
			LPCTSTR szTemplate = (iError & 0x80000000L)
										? TEXT("Error 0x%X. %s\n")
										: TEXT("Error %i. %s\n");
			cbOut = _stprintf(szBuffer, szTemplate, iError, szMessage);
			szMessage = szBuffer;
		}
		if (g_hStdOut)
		{
#ifdef UNICODE
			char rgchTemp[cchDisplayBuf];
			if (W32::GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
			{
				W32::WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
				szMessage = (LPCWSTR)rgchTemp;
			}
			else
				cbOut *= sizeof(TCHAR);   // write Unicode if not console device
#endif // UNICODE
			DWORD cbWritten;
			W32::WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
		}
		else
			W32::MessageBox(0, szMessage, W32::GetCommandLine(), MB_OK);
	}
	MSI::MsiCloseAllHandles();
	W32::ExitProcess(szMessage != 0);
}

void CheckError(UINT iError, LPCTSTR szMessage)
{
	if (iError != ERROR_SUCCESS)
		ErrorExit(iError, szMessage);
}

#else // RC_INVOKED, end of source code, start of resources
#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimerg\sources.inc ===
TARGETNAME=MsiMerg
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\OLE32.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msimerg.cpp \
	..\msimerg.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimig\cachpack.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       cachpack.cpp
//
//--------------------------------------------------------------------------

#include "_msimig.h"

#define szMsiLocalPackagesKey       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\LocalPackages")
#define szMsiUninstallProductsKey   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
#define szLocalPackageValueName     TEXT("LocalPackage")

class ChKey
{
 // Class to handle clean up of opened registry keys.

 public:
	ChKey(HKEY hKey) { m_hKey = hKey;}
	~ChKey() { if (m_hKey) RegCloseKey(m_hKey);}
	operator HKEY() { return m_hKey; }
	HKEY* operator &() { return &m_hKey;}
 private:
	operator =(HKEY);
	HKEY m_hKey;
};

DWORD CopyAndRegisterPackage(const TCHAR* szProductKey, const TCHAR* szProductCode, const TCHAR* szUserSID, 
									  const TCHAR* szUserName, const TCHAR* szPackagePath)
{
	// szUserName  = name, or blank for machine

		
	UINT uiResult = ERROR_SUCCESS;
	// first, open writable key to new cached package registration
	ChKey hProductLocalPackagesW(0);

	// if running as local system, and package is on a network path, all we can do is munge
	// the sourcelist, and hope everything works.

	if (g_hInstall && g_fRunningAsLocalSystem && IsNetworkPath(szPackagePath))
	{
		uiResult = (g_pfnMsiSourceListAddSource)(szProductCode, szUserName, 0, szPackagePath);
		return uiResult;
	}

	// otherwise it's someplace we can get to, 
	// check to make sure that it's really the right package.
	MSIHANDLE hSummaryInfo = NULL;
	if (ERROR_SUCCESS == (uiResult = (g_pfnMsiGetSummaryInformation)(NULL, szPackagePath, 0, &hSummaryInfo)))
	{
		UINT uiDataType = 0;
		TCHAR szPackageCode[40] = TEXT("");
		DWORD cchPackageCode = sizeof(szPackageCode);
		int iValue = 0;
		FILETIME ftValue;
		if (ERROR_SUCCESS == (uiResult = (g_pfnMsiSummaryInfoGetProperty)(hSummaryInfo, PID_REVNUMBER, &uiDataType, &iValue, &ftValue, szPackageCode, &cchPackageCode)))
		{
			(g_pfnMsiCloseHandle)(hSummaryInfo);
			TCHAR szSourceProductCode[40] = TEXT("");
			if (ERROR_SUCCESS == (uiResult = (g_pfnMsiGetProductCodeFromPackageCode)(szPackageCode, szSourceProductCode)))
			{
				if (0 == lstrcmpi(szSourceProductCode, szProductCode))
				{
					OutputString(INSTALLMESSAGE_INFO, TEXT("Source package product code matches migration product code.\r\n"));
				}
				else
				{
					OutputString(INSTALLMESSAGE_INFO, TEXT("Source package does not match product code for migration.\r\n\tSource package code: '%s'\r\n"), szSourceProductCode);
					return 1;
				}
			}
			else
			{
				OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot find product code for package code '%s'\r\n"), szPackageCode);
				return uiResult;
			}

		}
		else
		{
			(g_pfnMsiCloseHandle)(hSummaryInfo);
			OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot read package code from summary information for '%s'\r\n"), szPackagePath);
			return uiResult;
		}
	}
	else
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot read package code from package '%s'\r\n"), szPackagePath);
		return (DWORD) uiResult;
	}

	
	// copy and register it into place.
	LONG lRes = W32::RegCreateKey(HKEY_LOCAL_MACHINE,
								  szProductKey,
								  &hProductLocalPackagesW);

	if(lRes != ERROR_SUCCESS)
	{
		DWORD dwError = GetLastError();
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot access configuration data.  Product: %s\r\n\tResult: 0x%X, Error 0x%X\r\n"), szProductCode, lRes, dwError);
		MsiError(INSTALLMESSAGE_ERROR, 1401 /*create key*/, szProductKey, dwError);
		return dwError;
	}

	// now, generate a temporary file name in the %windows%\installer directory
	CAPITempBuffer<TCHAR, MAX_PATH> rgchInstallerDir;
	CAPITempBuffer<TCHAR, MAX_PATH> rgchTempFilePath;
	CAPITempBuffer<TCHAR, MAX_PATH> rgchUrlTempPath;
	
	uiResult = W32::GetWindowsDirectory(rgchInstallerDir, rgchInstallerDir.GetSize());
	if(0 == uiResult)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot GetWindowsDirectory\r\n"));
		return (DWORD)uiResult;
	}
	
	lstrcat(rgchInstallerDir, TEXT("\\"));
	lstrcat(rgchInstallerDir, TEXT("Installer"));
	
	uiResult = MyGetTempFileName(rgchInstallerDir, 0, TEXT("MSI"), rgchTempFilePath);

	if(uiResult != ERROR_SUCCESS)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot create a temporary file name.\r\n"));
		return (DWORD)uiResult;
	}
	
	BOOL fRes = FALSE;
	if (IsURL(szPackagePath))
	{
		bool fURL = false;
		uiResult = DownloadUrlFile(szPackagePath, rgchUrlTempPath, fURL);
		
		if (ERROR_SUCCESS == uiResult)
		{
			fRes = W32::CopyFile(rgchUrlTempPath, rgchTempFilePath, FALSE);
		}
	}
	else
	{
		fRes = W32::CopyFile(szPackagePath, rgchTempFilePath, FALSE);
	}

	if(fRes == FALSE)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Could not copy package to cache.\r\n"));
		return ERROR_INSTALL_FAILURE;
	}

	// now, register new path

	TCHAR szSIDName[cchMaxSID + sizeof(szManagedText) + 1] = TEXT("");
	if (g_fPackageElevated && (0 /*user*/ == g_iAssignmentType))
	{
		wsprintf(szSIDName, TEXT("%s%s"), szUserSID, szManagedText);
		OutputString(INSTALLMESSAGE_INFO, TEXT("Product is per-user managed.\r\n"));
	}
	else
	{
		lstrcpy(szSIDName, szUserSID);
	}

	lRes = W32::RegSetValueEx(hProductLocalPackagesW,
									  szSIDName, 
									  0,
									  REG_SZ,
									  (const BYTE*)(TCHAR*)rgchTempFilePath,
									  (lstrlen(rgchTempFilePath)+1) * sizeof(TCHAR));

	return lRes;

}

DWORD ResolveSourcePackagePath(HINSTANCE hMsiLib, const TCHAR* szProductCode,
							   CAPITempBufferRef<TCHAR>& rgchSourcePackageFullPath)
{
	// attempt to resolve the path for this user/product's source .msi package

	// the sourcepath is determined by calling MsiOpenProduct, then MsiDoAction(ResolveSource)
	// the packagename is retrieved with MsiGetProductInfo
	// the packagecode is then verified ???????

	// cannot be run from inside a custom action
	if(!hMsiLib || g_hInstall)
	{
		return ERROR_INSTALL_FAILURE;
	}

	PFnMsiSetInternalUI pfnMsiSetInternalUI;
	pfnMsiSetInternalUI = (PFnMsiSetInternalUI) W32::GetProcAddress(hMsiLib, MSIAPI_MSISETINTERNALUI);

	PFnMsiOpenProduct pfnMsiOpenProduct;
	pfnMsiOpenProduct = (PFnMsiOpenProduct) W32::GetProcAddress(hMsiLib, MSIAPI_MSIOPENPRODUCT);

	PFnMsiDoAction pfnMsiDoAction;
	pfnMsiDoAction = (PFnMsiDoAction) W32::GetProcAddress(hMsiLib, MSIAPI_MSIDOACTION);

	if (!g_pfnMsiGetProperty)
	g_pfnMsiGetProperty = (PFnMsiGetProperty) W32::GetProcAddress(hMsiLib, MSIAPI_MSIGETPROPERTY);

	if(!pfnMsiSetInternalUI ||
	   !pfnMsiOpenProduct ||
	   !pfnMsiDoAction ||
	   !g_pfnMsiGetProperty ||
	   !g_pfnMsiCloseHandle)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot get entry points from MSI.DLL.\r\n"));
		return ERROR_INSTALL_FAILURE; 
	}
		
	
	MSIHANDLE hProduct = 0;
	CAPITempBuffer<TCHAR, MAX_PATH> rgchSourceDir;
	CAPITempBuffer<TCHAR, MAX_PATH> rgchPackageName;

	UINT uiRes = ERROR_SUCCESS;
	
	INSTALLUILEVEL UILevel = (pfnMsiSetInternalUI)(INSTALLUILEVEL_NONE, 0);
	
	if(uiRes == ERROR_SUCCESS)
	{
		uiRes = (pfnMsiOpenProduct)(szProductCode, &hProduct);
	}
	else
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot open product '%s'.\r\n"), szProductCode);
	}

	if(uiRes == ERROR_SUCCESS)
	{
		uiRes = (pfnMsiDoAction)(hProduct, TEXT("CostInitialize"));
	}

	if(uiRes == ERROR_SUCCESS)
	{
		uiRes = (pfnMsiDoAction)(hProduct, TEXT("ResolveSource"));
	}

	if(uiRes == ERROR_SUCCESS)
	{
		uiRes = MyMsiGetProperty(g_pfnMsiGetProperty, hProduct, TEXT("SourceDir"), rgchSourceDir);
	}

	if(uiRes == ERROR_SUCCESS)
	{
		uiRes = MyMsiGetProductInfo(g_pfnMsiGetProductInfo, szProductCode,
											 TEXT("PackageName") /* no INSTALLPROPERTY_PACKAGENAME in 1.2*/, rgchPackageName);
	}

	if(uiRes == ERROR_SUCCESS)
	{
		int cchSourceDir = lstrlen(rgchSourceDir);
		int cchPackageName = lstrlen(rgchPackageName);

		int cchSourcePackageFullPath = cchSourceDir + cchPackageName + 2;

		if(rgchSourcePackageFullPath.GetSize() < cchSourcePackageFullPath)
			rgchSourcePackageFullPath.SetSize(cchSourcePackageFullPath);

		bool fURL = IsURL(rgchSourceDir);
		TCHAR* szSeparator = (fURL) ? TEXT("/") : TEXT("\\");

		lstrcpy(rgchSourcePackageFullPath, rgchSourceDir);
		if ((!cchSourceDir) || ((*szSeparator) != rgchSourcePackageFullPath[cchSourceDir-1]))
		{
			lstrcpy(&(rgchSourcePackageFullPath[cchSourceDir]), szSeparator);
			cchSourceDir++;
		}
		lstrcpy(&(rgchSourcePackageFullPath[cchSourceDir]), rgchPackageName);
	}

	if(hProduct)
	{
		(g_pfnMsiCloseHandle)(hProduct);
	}

	if(uiRes == ERROR_SUCCESS)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s'\r\n\tSourceDir: '%s'\r\n\tPackageName: '%s'\r\n"),
					szProductCode, (const TCHAR*) rgchSourceDir, (const TCHAR*) rgchPackageName);
	}
	
	(pfnMsiSetInternalUI)(UILevel, 0);

	return uiRes;

}

bool LoadAndCheckMsi(DWORD &dwResult)
// return false if nothing more to do.
// ERROR_SUCCESS == dwResult indicates "success or nothing to do."
{
	dwResult = ERROR_INSTALL_FAILURE;

	if(!g_hLib)
	{
		g_hLib = LoadLibrary(MSI_DLL);
		if (!g_hLib)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Unable to load %s. Migration cannot be performed. Exiting..."), MSI_DLL);
			MsiError(INSTALLMESSAGE_ERROR, 1708 /*install failed*/);
			return false;
		}
	}

	// Specification step 1: if msi.dll is less than version 1.1, don't perform migration
	PFnDllGetVersion pfnDllGetVersion;
	pfnDllGetVersion = (PFnDllGetVersion) W32::GetProcAddress(g_hLib,	MSIAPI_DLLGETVERSION);

	DLLVERSIONINFO verinfo;
	memset(&verinfo,0,sizeof(verinfo));
	verinfo.cbSize = sizeof(DLLVERSIONINFO);

	HRESULT hRes = (pfnDllGetVersion)(&verinfo);

	if(hRes != NOERROR)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Failed to determine version of '%s'.  '%s' call failed with error '0x%X'\r\n"),
				 MSI_DLL, MSIAPI_DLLGETVERSION, hRes);
		MsiError(INSTALLMESSAGE_ERROR, 1708 /*install failed*/);
		return false;
	}

	DebugOutputString(INSTALLMESSAGE_INFO, TEXT("Loaded '%s', version %d.%d.%d\r\n"),
			 MSI_DLL, verinfo.dwMajorVersion, verinfo.dwMinorVersion, verinfo.dwBuildNumber);

	if(verinfo.dwMajorVersion < 1 || (verinfo.dwMajorVersion == 1 && verinfo.dwMinorVersion < 10))
	{
		dwResult = ERROR_SUCCESS;
		OutputString(INSTALLMESSAGE_INFO, TEXT("%s version 1.10 or greater required to perform migration.  Exiting..."), MSI_DLL);
		return false;
	}

	// Specification step 3: if on Win9X, do nothing
	if(g_fWin9X)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("1.0 cached package migration not necessary on Win9X.  Exiting...\r\n"));
		dwResult = ERROR_SUCCESS;
		return false;
	}

	return true;
}


DWORD Migrate10CachedPackages(const TCHAR* szProductCode, const TCHAR* szTargetUser, const TCHAR* szAlternativePackage, const migEnum migOptions)
{
	// TargetUser values:  blank - means current user
	//                     machine
	//                     user name

	DWORD dwResult = ERROR_SUCCESS;
	if (!LoadAndCheckMsi(dwResult))
	{
		return dwResult;
	}

	// Specification step 2: if msi.dll contains migration api, call it.  this must be first because we can't assume
	//         what work should be done (for example: we can't assume this migration never needs
	//         to happen on Win9X)
	PFnMsiMigrate10CachedPackages pfnMsiMigrate10CachedPackages;
	pfnMsiMigrate10CachedPackages = (PFnMsiMigrate10CachedPackages) W32::GetProcAddress(g_hLib,
																						MSIAPI_MSIMIGRATE10CACHEDPACKAGES);

	if(pfnMsiMigrate10CachedPackages)
	{
		return (pfnMsiMigrate10CachedPackages)(szProductCode, szTargetUser, szAlternativePackage, migOptions);
	}
	else
	{
		// else continue, older .msi, perform migration ourselves
		OutputString(INSTALLMESSAGE_INFO, TEXT("This version of %s does not have built-in migration support.\r\n\tMigration will be performed by this tool.\r\n"),
				MSI_DLL);
	}

	if (ERROR_SUCCESS != (g_pfnMsiIsProductElevated)(szProductCode, &g_fPackageElevated))
	{
		// don't trust the return value unless we get success back.
		// unknown product is the same as not being elevated.
		g_fPackageElevated = FALSE;
		OutputString(INSTALLMESSAGE_INFO, TEXT("Could not query elevation state for product.\r\n\tAssuming non-elevated.\r\n"));
	}
	else
	{
		// find out what kind of assignment type
		if (g_fPackageElevated)
		{
			TCHAR szValue[sizeof(DWORD)+1] = TEXT("");  // this should be just an integer.
			DWORD cchValue = sizeof(DWORD);
			if (ERROR_SUCCESS == (g_pfnMsiGetProductInfo)(szProductCode, INSTALLPROPERTY_ASSIGNMENTTYPE, szValue, &cchValue))
			{
				g_iAssignmentType = _ttoi(szValue);
				switch(g_iAssignmentType)
				{
					case AssignmentUser:
						OutputString(INSTALLMESSAGE_INFO, TEXT("Package is user assigned.\r\n"));
						break;
					case AssignmentMachine:
						OutputString(INSTALLMESSAGE_INFO, TEXT("Package is machine assigned.\r\n"));
						break;
					default:
						OutputString(INSTALLMESSAGE_INFO, TEXT("Package is elevated, but with an unknown assignment type.\r\n"));
						g_fPackageElevated = false;
						g_iAssignmentType = 0;
						break;
				}
			}
		}
		else
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Package is not elevated.\r\n"));
		}
	}

	bool fMachine     = false; // re-cache for machine.
	TCHAR szUserName[256] = TEXT("");
	TCHAR rgchSID[cchMaxSID] = TEXT("");

	if (g_fPackageElevated && (AssignmentMachine == g_iAssignmentType))
	{
		fMachine = true;
		wsprintf(szUserName, TEXT("machine"));

		if (szTargetUser && *szTargetUser && (0 != lstrcmpi(TEXT("machine"), szTargetUser)))
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Per-user migration not allowed for per-machine applications.\r\nExiting migration.\r\n"));
			return 1;
		}
		
		lstrcpy(rgchSID, szLocalSystemSID);
	}	

	if (!fMachine)
	{
		if (szTargetUser && (0 == lstrcmpi(TEXT("machine"), szTargetUser)))
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Per-machine migration not allowed for per-user applications.\r\nExiting migration.\r\n"));
			return 1;
		}

		char pbBinarySID[cbMaxSID] = "";
		if (ERROR_SUCCESS != GetUserStringSID(szTargetUser, rgchSID, pbBinarySID))
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Failed to obtain SID for '%s'.  Exiting...\r\n"), szUserName);
			MsiError(INSTALLMESSAGE_ERROR, 2910 /* cannot find SID */);
			return 1;
		}

		TCHAR szCurrentDomain[256];
		DWORD cchCurrentDomain = 256;
		SID_NAME_USE snu;
		if (szTargetUser && *szTargetUser)
		{
			lstrcpy(szUserName, szTargetUser);
		}
		else
		{
			TCHAR szUserPart[256] = TEXT("");
			DWORD cchUserPart = 256;

			BOOL fLookup = LookupAccountSid(NULL, pbBinarySID, szUserPart, &cchUserPart, szCurrentDomain, &cchCurrentDomain, &snu);
			wsprintf(szUserName, TEXT("%s\\%s"), szCurrentDomain, szUserPart);
		}	

	}
	OutputString(INSTALLMESSAGE_INFO, TEXT("Performing migration for:\r\n\tUser: '%s'\r\n\tUser SID: '%s'.\r\n"), szUserName, rgchSID);
	
	// munge the product code variants we'll need.
	TCHAR rgchPackedProductCode[cchGUIDPacked+1];
	if(!PackGUID(szProductCode, rgchPackedProductCode, ipgPacked))
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("User '%s': product code '%s' is invalid.\r\n"), szUserName, szProductCode);
		MsiError(INSTALLMESSAGE_ERROR, 1701 /* invalid product code */, szProductCode, 0);
		return 1;  //!! caller should continue if migrating ALL products, fail if only migrating this product
	}

	OutputString(INSTALLMESSAGE_INFO, TEXT("DEBUG: packed product code: '%s'.\r\n"),
				rgchPackedProductCode);

	// Specification step 4: find 1.0 and 1.1 cached package registration for this product/user
	//         if 1.1 cached package migration exists, do nothing

	// check 1.0 registration
	ChKey hUninstallKeyR = 0;
	TCHAR rgchUninstallKey[sizeof(szMsiLocalPackagesKey) + 1 + cchGUID + 1];
	CAPITempBuffer<TCHAR, MAX_PATH> rgch10RegisteredPackagePath;
	rgch10RegisteredPackagePath[0] = NULL;
	DWORD cch10RegisteredPackagePath = MAX_PATH;

	wsprintf(rgchUninstallKey, TEXT("%s\\%s"), szMsiUninstallProductsKey, szProductCode);
	LONG lRes = W32::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
										rgchUninstallKey,
										0,
										KEY_READ,
										&hUninstallKeyR);

	if (ERROR_SUCCESS == lRes)
	{
	
		// check for appropriate user entry
		// this routine does resizing automagically
		DWORD dwType = 0;
		lRes = MyRegQueryValueEx(hUninstallKeyR,
										 TEXT("LocalPackage"),
										 0,
										 &dwType,
										 rgch10RegisteredPackagePath,
										 &cch10RegisteredPackagePath);
		if (ERROR_SUCCESS == lRes)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Found old 1.0 cached package at: %s\r\n"), rgch10RegisteredPackagePath);
		}
		else
		{
			// nothing to do
			OutputString(INSTALLMESSAGE_INFO, TEXT("Found uninstall key, but no old 1.0 cached package registered.\r\n"));
		}
	}
	else
	{
		// nothing to do
		OutputString(INSTALLMESSAGE_INFO, TEXT("Could not find product registration for this package.\r\n\tNo migration necessary.\r\n"));
		return 0;
	}
	
	// check 1.1 registration
	TCHAR rgchLocalPackagesProductKey[sizeof(szMsiLocalPackagesKey) + 1 + cchGUIDPacked + 1];
	wsprintf(rgchLocalPackagesProductKey, TEXT("%s\\%s"), szMsiLocalPackagesKey, rgchPackedProductCode);

	ChKey hProductLocalPackagesR = 0;
	lRes = W32::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
								  rgchLocalPackagesProductKey,
								  0,
								  KEY_READ,
								  &hProductLocalPackagesR);

	if(lRes == ERROR_SUCCESS)
	{
		CAPITempBuffer<TCHAR, MAX_PATH> rgch11RegisteredPackagePath;
		DWORD cch11RegisteredPackagePath = MAX_PATH;

		// check for appropriate user entry
		// this routine does resizing automagically
		DWORD dwType = 0;

		{
			TCHAR szSIDName[cchMaxSID + sizeof(szManagedText) + 1] = TEXT("");
			if (g_fPackageElevated && (AssignmentUser == g_iAssignmentType))
			{
				wsprintf(szSIDName, TEXT("%s%s"), rgchSID, szManagedText);
				OutputString(INSTALLMESSAGE_INFO, TEXT("Product is per-user managed.\r\n"));
			}
			else
			{
				lstrcpy(szSIDName, rgchSID);
			}

			lRes = MyRegQueryValueEx(hProductLocalPackagesR,
											 szSIDName,
											 0,
											 &dwType,
											 rgch11RegisteredPackagePath,
											 &cch11RegisteredPackagePath);

		}

		if(lRes == ERROR_SUCCESS && dwType == REG_SZ)
		{
			// check if file exists, if not, treat as if package isn't cached
			DWORD dwAttrib = W32::GetFileAttributes(rgch11RegisteredPackagePath);
			if(dwAttrib != 0xFFFFFFFF)
			{
				// file exists
				OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s'\r\n\tCached package registered under new location, and does exist\r\n\t\t('%s').\r\n\tUser '%s': No migration necessary\r\n"),
							szProductCode,
							(const TCHAR*) rgch11RegisteredPackagePath,
							szUserName);
				return ERROR_SUCCESS;
			}
		}
	}

	// if we got here, cached package is either not registered in new location, or does not exist
	// either way, migration is necessary
	OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s', User '%s':\r\n\tCached package missing or not registered in new location.\r\n\tPerforming migration...\r\n"),
				szProductCode,
				szUserName);
	
	// Specification step 7: if "trust old packages" policy is set (or override is set), 
	// and old package exists, register old package
	// This is the most "preferable" step since everything is already on the machine. 

	int iTrustOldPackages = (migOptions & migMsiTrust10PackagePolicyOverride) ? 2 : 0;

	if (0 == iTrustOldPackages)
	{
		ChKey hPolicyKeyR = 0;
		lRes = W32::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
									  TEXT("Software\\Policies\\Microsoft\\Windows\\Installer"),
									  0,
									  KEY_READ,
									  &hPolicyKeyR);

		if (ERROR_SUCCESS != lRes)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot open machine policy key.  Assuming policy not set.\r\n"));
		}
		else
		{
			DWORD dwType = 0;
			DWORD dwValue = 0;
			DWORD cbValue = sizeof(DWORD);

			lRes = W32::RegQueryValueEx(hPolicyKeyR,
									szMsiPolicyTrust10CachedPackages,
									NULL, 
									&dwType,
									(byte*) &dwValue,
									&cbValue);

			if ((ERROR_SUCCESS == lRes) &&
					(REG_DWORD == dwType) &&
					(0 < dwValue))
			{
				//!! Do we need to check the owner of the key to make sure we really trust it?
				if (1 == dwValue)
				{
					if (!g_fPackageElevated)
					{
						OutputString(INSTALLMESSAGE_INFO, TEXT("Policy: trust unmanaged 1.0 packages.\r\n"));
						iTrustOldPackages = 1;
					}
				}
				else if (2 == dwValue)
				{
					OutputString(INSTALLMESSAGE_INFO, TEXT("Policy: trust all old 1.0 packages.\r\n"));
					iTrustOldPackages = 2;
				}
				else
				{
					OutputString(INSTALLMESSAGE_INFO, TEXT("Unknown policy value for Trust10CachedPackages: '%d' - defaulting to untrusted.\r\n"), dwValue);
				}
			}
		}
	}

	DWORD dwRes = ERROR_SUCCESS;
	if (iTrustOldPackages && (!(szAlternativePackage && *szAlternativePackage)) && (*rgch10RegisteredPackagePath))
	{
		// try and find the old one - if available copy and register it.  Otherwise, we'll have to go
		// after other copies.

		if (migOptions & migMsiTrust10PackagePolicyOverride)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Command line settings allow trust of old packages.  Attemping to find one.\r\n"));
		}
		else
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Policy settings allow trust of old packages.  Attempting to find one.\r\n"));
		}

		OutputString(INSTALLMESSAGE_INFO, TEXT("Using 1.0 package to re-cache.\r\n"));
		dwRes = CopyAndRegisterPackage(rgchLocalPackagesProductKey, szProductCode, rgchSID, 
													(fMachine) ? NULL : szUserName, rgch10RegisteredPackagePath);
		if (ERROR_SUCCESS != dwRes)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Failed to migrate from trusted 1.0 cached package.  Trying other options.\r\n\tPackage: '%s'\r\n\tTrying other methods.\r\n"), rgch10RegisteredPackagePath);
		}
		else 
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Successfully re-cached from trusted old package.\r\n"));
			return ERROR_SUCCESS;
		}
	}

	// Specification step 6: if package path passed on cmd line, copy and register that package
	if(szAlternativePackage && *szAlternativePackage)
	{
		// if running as local system *and* the package path is on the network, just register the path.
		// if someplace accessible, copy it in.
		dwRes = CopyAndRegisterPackage(rgchLocalPackagesProductKey, szProductCode, rgchSID, 
													(fMachine) ? NULL : szUserName, szAlternativePackage);

		if(ERROR_SUCCESS == dwRes)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s', User '%s':\r\n\tcached alternative package '%s'\r\n\tMigration successful\r\n"),
						szProductCode, szUserName, szAlternativePackage);
			return ERROR_SUCCESS;
		}
		else
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s', User '%s':\r\n\tcan not be cached from %s.\r\n\tRerun the migration tool with either a new source,\r\n\tor no source specified to automatically locate one.\r\n"),
						szProductCode, szUserName, szAlternativePackage);
			MsiError(INSTALLMESSAGE_ERROR, 1906 /*failed to cache DB*/, szAlternativePackage, 0);
			return 1;
		}
		
	}

	// Specification step 5: resolve source for this product in a non-obtrusive way
	//         if source is available, copy and register package
	//         This is the last resort, and the most expensive.

	CAPITempBuffer<TCHAR, MAX_PATH> rgchSourcePackagePath;
	rgchSourcePackagePath[0] = 0;

	// don't do this from within a custom action.
	if(!g_hInstall)
	{
		// it is redundant to this for the current user - if we could resolve the source
		// path, they wouldn't need to migrate.
		dwRes = ResolveSourcePackagePath(g_hLib, szProductCode, rgchSourcePackagePath);

		if(ERROR_SUCCESS == dwRes)
		{
			dwRes = CopyAndRegisterPackage(rgchLocalPackagesProductKey, szProductCode, rgchSID, 
														(fMachine) ? NULL : szUserName, rgchSourcePackagePath);
		
			if(ERROR_SUCCESS == dwRes)
			{
				OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s'\r\n\tUser '%s':\r\n\tCached source package '%s'\r\n\tMigration successful.\r\n\t"),
							szProductCode, szUserName, (const TCHAR*) rgchSourcePackagePath);
				return ERROR_SUCCESS;
			}
		}
		else
		{
				OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s'\r\n\tUser '%s':\r\n\tCannot locate source.  Error: 0x%x.\r\n\tMigration failed.\r\n\t"),
							szProductCode, szUserName, dwRes);
				MsiError(INSTALLMESSAGE_ERROR, 1906, szProductCode /* no valid source*/, ERROR_FILE_NOT_FOUND);
		}

		// nothing else to try now.
	}


	OutputString(INSTALLMESSAGE_INFO, TEXT("Could not migrate product.\r\n"));
	MsiError(INSTALLMESSAGE_ERROR, 1906, szProductCode /* no valid source*/, ERROR_FILE_NOT_FOUND);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimig\buffer.h ===
//____________________________________________________________________________
//
// CTempBuffer<class T, int C>   // T is array type, C is element count
// 
// Temporary buffer object for variable size stack buffer allocations
// Template arguments are the type and the stack array size.
// The size may be reset at construction or later to any other size.
// If the size is larger that the stack allocation, new will be called.
// When the object goes out of scope or if its size is changed,
// any memory allocated by new will be freed.
// Function arguments may be typed as CTempBufferRef<class T>&
//  to avoid knowledge of the allocated size of the buffer object.
// CTempBuffer<T,C> will be implicitly converted when passed to such a function.
//____________________________________________________________________________

template <class T> class CTempBufferRef;  // for passing CTempBuffer as unsized ref

template <class T, int C> class CTempBuffer
{
 public:
	CTempBuffer() {m_cT = C; m_pT = m_rgT;}
	CTempBuffer(int cT) {m_pT = (m_cT = cT) > C ? new T[cT] : m_rgT;}
  ~CTempBuffer() {if (m_cT > C) delete m_pT;}
	operator T*()  {return  m_pT;}  // returns pointer
	operator T&()  {return *m_pT;}  // returns reference
	int  GetSize() {return  m_cT;}  // returns last requested size
	void SetSize(int cT) {if (m_cT > C) delete[] m_pT; m_pT = (m_cT=cT) > C ? new T[cT] : m_rgT;}
	void Resize(int cT) { 
		T* pT = cT > C ? new T[cT] : m_rgT;
		if(m_pT != pT)
			for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
		if(m_pT != m_rgT) delete[] m_pT; m_pT = pT; m_cT = cT;
	}
	operator CTempBufferRef<T>&() {m_cC = C; return *(CTempBufferRef<T>*)this;}
	T& operator [](int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](unsigned int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#ifdef _WIN64		//--merced: additional operators for int64
	T& operator [](INT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](UINT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#endif
 protected:
	void* operator new(size_t) {return 0;} // restrict use to temporary objects
	T*  m_pT;     // current buffer pointer
	int m_cT;     // reqested buffer size, allocated if > C
	int m_cC;     // size of local buffer, set only by conversion to CTempBufferRef 
	T   m_rgT[C]; // local buffer, must be final member data
};

template <class T> class CTempBufferRef : public CTempBuffer<T,1>
{
 public:
	void SetSize(int cT) {if (m_cT > m_cC) delete[] m_pT; m_pT = (m_cT=cT) > m_cC ? new T[cT] : m_rgT;}
	void Resize(int cT) { 
		T* pT = cT > m_cC ? new T[cT] : m_rgT;
		if(m_pT != pT)
			for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
		if(m_pT != m_rgT) delete[] m_pT; m_pT = pT; m_cT = cT;
	}
 private:
	CTempBufferRef(); // cannot be constructed
	~CTempBufferRef(); // ensure use as a reference
};

//____________________________________________________________________________
//
// CAPITempBuffer class is mirrored on the CTempBuffer except that it uses GlobalAlloca
// and GlobalFree in place of new and delete. We should try combining these 2 in the future
//____________________________________________________________________________


template <class T> class CAPITempBufferRef;

template <class T, int C> class CAPITempBufferStatic
{
 public:
	CAPITempBufferStatic() {m_cT = C; m_pT = m_rgT;}
	CAPITempBufferStatic(int cT) {m_pT = (m_cT = cT) > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;}
	void Destroy() {if (m_cT > C) {GlobalFree(m_pT); m_pT = m_rgT; m_cT = C;}}
	operator T*()  {return  m_pT;}  // returns pointer
	operator T&()  {return *m_pT;}  // returns reference
	int  GetSize() {return  m_cT;}  // returns last requested size
	void SetSize(int cT) {if (m_cT > C) GlobalFree(m_pT); m_pT = (m_cT=cT) > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;}
	void Resize(int cT) { 
		T* pT = cT > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;
		if(m_pT != pT)
			for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
		if(m_pT != m_rgT) GlobalFree(m_pT); m_pT = pT; m_cT = cT;
	}
	operator CAPITempBufferRef<T>&() {m_cC = C; return *(CAPITempBufferRef<T>*)this;}
	T& operator [](int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](unsigned int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#ifdef _WIN64	//--merced: additional operators for int64
	T& operator [](INT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](UINT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#endif
	
 protected:
	void* operator new(size_t) {return 0;} // restrict use to temporary objects
	T*  m_pT;     // current buffer pointer
	int m_cT;     // reqested buffer size, allocated if > C
	int m_cC;     // size of local buffer, set only by conversion to CAPITempBufferRef 
	T   m_rgT[C]; // local buffer, must be final member data
};

template <class T, int C> class CAPITempBuffer
{
 public:
	CAPITempBuffer() {m_cT = C; m_pT = m_rgT;}
	CAPITempBuffer(int cT) {m_pT = (m_cT = cT) > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;}
  ~CAPITempBuffer() {if (m_cT > C) GlobalFree(m_pT);}
	operator T*()  {return  m_pT;}  // returns pointer
	operator T&()  {return *m_pT;}  // returns reference
	int  GetSize() {return  m_cT;}  // returns last requested size
	void SetSize(int cT) {if (m_cT > C) GlobalFree(m_pT); m_pT = (m_cT=cT) > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;}
	void Resize(int cT) { 
		T* pT = cT > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;
		if(m_pT != pT)
			for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
		if(m_pT != m_rgT) GlobalFree(m_pT); m_pT = pT; m_cT = cT;
	}
	operator CAPITempBufferRef<T>&() {m_cC = C; return *(CAPITempBufferRef<T>*)this;}
	T& operator [](int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](unsigned int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#ifdef _WIN64		//--merced: additional operators for int64
	T& operator [](INT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](UINT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#endif
 protected:
	void* operator new(size_t) {return 0;} // restrict use to temporary objects
	T*  m_pT;     // current buffer pointer
	int m_cT;     // reqested buffer size, allocated if > C
	int m_cC;     // size of local buffer, set only by conversion to CAPITempBufferRef 
	T   m_rgT[C]; // local buffer, must be final member data
};

template <class T> class CAPITempBufferRef : public CAPITempBuffer<T,1>
{
 public:
	void SetSize(int cT) {if (m_cT > m_cC) delete[] m_pT; m_pT = (m_cT=cT) > m_cC ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;}
	void Resize(int cT) { 
		T* pT = cT > m_cC ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;
		if(m_pT != pT)
			for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
		if(m_pT != m_rgT) GlobalFree(m_pT); m_pT = pT; m_cT = cT;
	}
 private:
	CAPITempBufferRef(); // cannot be constructed
	~CAPITempBufferRef(); // ensure use as a reference
};



//____________________________________________________________________________
//
// CConvertString -- does appropriate ANSI/UNICODE string conversion for
// function arguments. Wrap string arguments that might require conversion 
// (ANSI->UNICODE) or (UNICODE->ANSI). The compiler will optimize away the 
// case where conversion is not required.
//
// Beware: For efficiency this class does *not* copy the string to be converted.
//____________________________________________________________________________

const int cchConversionBuf = 255;

class CConvertString
{
public:
	CConvertString(const char* szParam);
	CConvertString(const WCHAR* szParam);
	operator const char*()
	{
		if (!m_szw)
			return m_sza;
		else
		{
			int cchParam = lstrlenW(m_szw);
			if (cchParam > cchConversionBuf)
				m_rgchAnsiBuf.SetSize(cchParam+1);

			*m_rgchAnsiBuf = 0;
			int iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, m_rgchAnsiBuf, 
							 		  m_rgchAnsiBuf.GetSize(), 0, 0);
			
			if ((0 == iRet) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
			{
				iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, 0, 0, 0, 0);
				if (iRet)
				{
					m_rgchAnsiBuf.SetSize(iRet);
					*m_rgchAnsiBuf = 0;
					iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, m_rgchAnsiBuf, 
								  m_rgchAnsiBuf.GetSize(), 0, 0);
				}
				//Assert(iRet != 0);
			}

			return m_rgchAnsiBuf;
		}
	}


		
	operator const WCHAR*()
	{
		if (!m_sza)
			return m_szw;
		else
		{
			int cchParam = lstrlenA(m_sza);
			if (cchParam > cchConversionBuf)
				m_rgchWideBuf.SetSize(cchParam+1);

			*m_rgchWideBuf = 0;
			int iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, m_rgchWideBuf, m_rgchWideBuf.GetSize());
			if ((0 == iRet) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
			{
				iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, 0, 0);
				if (iRet)
				{
  					m_rgchWideBuf.SetSize(iRet);
					*m_rgchWideBuf = 0;
					iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, m_rgchWideBuf, m_rgchWideBuf.GetSize());
				}
				//Assert(iRet != 0);
			}


			return m_rgchWideBuf;
		}
	}

protected:
	void* operator new(size_t) {return 0;} // restrict use to temporary objects
	CTempBuffer<char, cchConversionBuf+1> m_rgchAnsiBuf;
	CTempBuffer<WCHAR, cchConversionBuf+1> m_rgchWideBuf;
	const char* m_sza;
	const WCHAR* m_szw;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimig\sources.inc ===
TARGETNAME=MsiMig
!INCLUDE ..\..\..\MsiMake.inc

SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0


TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\OLE32.lib

USE_MSVCRT=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimig\migutil.cpp ===
#include "_msimig.h"
#include "urlmon.h"
#include "wininet.h"
//#include "..\..\inc\vertrust.h"

//____________________________________________________________________________
//
// GUID compression routines
//
//   A SQUID (SQuished UID) is a compacted form of a GUID that takes
//   only 20 characters instead of the usual 38. Only standard ASCII characters
//   are used, to allow use as registry keys. The following are never used:
//     (space)
//     (0x7F)
//     :  (colon, used as delimeter by shell for shortcut information
//     ;  (semicolon)
//     \  (illegal for use in registry key)
//     /  (forward slash)
//     "  (double quote)
//     #  (illegal for registry value as first character)
//     >  (greater than, output redirector)
//     <  (less than, input redirector)
//     |  (pipe)
//____________________________________________________________________________

// GUID <--> SQUID transform helper buffers
const unsigned char rgEncodeSQUID[85+1] = "!$%&'()*+,-.0123456789=?@"
										  "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "[]^_`"
										  "abcdefghijklmnopqrstuvwxyz" "{}~";

const unsigned char rgDecodeSQUID[95] =
{  0,85,85,1,2,3,4,5,6,7,8,9,10,11,85,12,13,14,15,16,17,18,19,20,21,85,85,85,22,85,23,24,
// !  "  # $ % & ' ( ) * + ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?  @
  25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,85,52,53,54,55,
// A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _  `
  56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,85,83,84,85};
// a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~  ^ 0x7F

const unsigned char rgOrderGUID[32] = {8,7,6,5,4,3,2,1, 13,12,11,10, 18,17,16,15,
									   21,20, 23,22, 26,25, 28,27, 30,29, 32,31, 34,33, 36,35}; 

const unsigned char rgOrderDash[4] = {9, 14, 19, 24};

bool PackGUID(const TCHAR* szGUID, TCHAR* szSQUID, ipgEnum ipg)
{ 
	int cchTemp = 0;
	while (cchTemp < cchGUID)		// check if string is atleast cchGUID chars long,
		if (!(szGUID[cchTemp++]))		// can't use lstrlen as string doesn't HAVE to be null-terminated.
			return false;

	if (szGUID[0] != '{' || szGUID[cchGUID-1] != '}')
		return false;
	const unsigned char* pch = rgOrderGUID;
	switch (ipg)
	{
	case ipgFull:
		lstrcpyn(szSQUID, szGUID, cchGUID+1);
		return true;
	case ipgPacked:
		while (pch < rgOrderGUID + sizeof(rgOrderGUID))
			*szSQUID++ = szGUID[*pch++];
		*szSQUID = 0;
		return true;
	case ipgCompressed:
	{
		int cl = 4;
		while (cl--)
		{
			unsigned int iTotal = 0;
			int cch = 8;  // 8 hex chars to 32-bit word
			while (cch--)
			{
				unsigned int ch = szGUID[pch[cch]] - '0'; // go from low order to high
				if (ch > 9)  // hex char (or error)
				{
					ch = (ch - 7) & ~0x20;
					if (ch > 15)
						return false;
				}
				iTotal = iTotal * 16 + ch;
			}
			pch += 8;
			cch = 5;  // 32-bit char to 5 text chars
			while (cch--)
			{
				*szSQUID++ = rgEncodeSQUID[iTotal%85];
				iTotal /= 85;
			}
		}
		*szSQUID = 0;  // null terminate
		return true;
	}
	default:
		return false;
	} // end switch
}

bool UnpackGUID(const TCHAR* szSQUID, TCHAR* szGUID, ipgEnum ipg)
{ 
	const unsigned char* pch;
	switch (ipg)
	{
	case ipgFull:
		lstrcpyn(szGUID, szSQUID, cchGUID+1);
		return true;
	case ipgPacked:
	{
		pch = rgOrderGUID;
		while (pch < rgOrderGUID + sizeof(rgOrderGUID))
			if (*szSQUID)
				szGUID[*pch++] = *szSQUID++;
			else              // unexpected end of string
				return false;
		break;
	}
	case ipgCompressed:
	{
		pch = rgOrderGUID;
#ifdef DEBUG //!! should not be here for performance reasons, onus is on caller to insure buffer is sized properly
		int cchTemp = 0;
		while (cchTemp < cchGUIDCompressed)     // check if string is atleast cchGUIDCompressed chars long,
			if (!(szSQUID[cchTemp++]))          // can't use lstrlen as string doesn't HAVE to be null-terminated.
				return false;
#endif
		for (int il = 0; il < 4; il++)
		{
			int cch = 5;
			unsigned int iTotal = 0;
			while (cch--)
			{
				unsigned int iNew = szSQUID[cch] - '!';
				if (iNew >= sizeof(rgDecodeSQUID) || (iNew = rgDecodeSQUID[iNew]) == 85)
					return false;   // illegal character
				iTotal = iTotal * 85 + iNew;
			}
			szSQUID += 5;
			for (int ich = 0; ich < 8; ich++)
			{
				int ch = (iTotal & 15) + '0';
				if (ch > '9')
					ch += 'A' - ('9' + 1);
				szGUID[*pch++] = (TCHAR)ch;
				iTotal >>= 4;
			}
		}
		break;
	}
	case ipgPartial:
	{
		for (int il = 0; il < 4; il++)
		{
			int cch = 5;
			unsigned int iTotal = 0;
			while (cch--)
			{
				unsigned int iNew = szSQUID[cch] - '!';
				if (iNew >= sizeof(rgDecodeSQUID) || (iNew = rgDecodeSQUID[iNew]) == 85)
					return false;   // illegal character
				iTotal = iTotal * 85 + iNew;
			}
			szSQUID += 5;
			for (int ich = 0; ich < 8; ich++)
			{
				int ch = (iTotal & 15) + '0';
				if (ch > '9')
					ch += 'A' - ('9' + 1);
				*szGUID++ = (TCHAR)ch;
				iTotal >>= 4;
			}
		}
		*szGUID = 0;
		return true;
	}
	default:
		return false;
	} // end switch
	pch = rgOrderDash;
	while (pch < rgOrderDash + sizeof(rgOrderDash))
		szGUID[*pch++] = '-';
	szGUID[0]         = '{';
	szGUID[cchGUID-1] = '}';
	szGUID[cchGUID]   = 0;
	return true;
}


DWORD GetCurrentUserToken(HANDLE &hToken)
/*----------------------------------------------------------------------------
Returns the user's thread token if possible; otherwise obtains the user's
process token.
------------------------------------------------------------------------------*/
{
	DWORD dwRes = ERROR_SUCCESS;

	if (!W32::OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
	{
		// if the thread has no access token then use the process's access token
		dwRes = GetLastError();
		if (ERROR_NO_TOKEN == dwRes)
		{
			dwRes = ERROR_SUCCESS;
			if (!W32::OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
				dwRes = GetLastError();
		}
	}
	return dwRes;
}


#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

void GetStringSID(PISID pSID, TCHAR* szSID)
// Converts a binary SID into its string form (S-n-...). 
// szSID should be of length cchMaxSID
{
	TCHAR Buffer[cchMaxSID];
	
   wsprintf(Buffer, TEXT("S-%u-"), (USHORT)pSID->Revision);

	lstrcpy(szSID, Buffer);

	if (  (pSID->IdentifierAuthority.Value[0] != 0)  ||
			(pSID->IdentifierAuthority.Value[1] != 0)     )
	{
		wsprintf(Buffer, TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
					 (USHORT)pSID->IdentifierAuthority.Value[0],
					 (USHORT)pSID->IdentifierAuthority.Value[1],
                    (USHORT)pSID->IdentifierAuthority.Value[2],
                    (USHORT)pSID->IdentifierAuthority.Value[3],
                    (USHORT)pSID->IdentifierAuthority.Value[4],
                    (USHORT)pSID->IdentifierAuthority.Value[5] );
		lstrcat(szSID, Buffer);

    } else {

        ULONG Tmp = (ULONG)pSID->IdentifierAuthority.Value[5]          +
              (ULONG)(pSID->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(pSID->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(pSID->IdentifierAuthority.Value[2] << 24);
        wsprintf(Buffer, TEXT("%lu"), Tmp);
		lstrcat(szSID, Buffer);
    }

    for (int i=0;i<pSID->SubAuthorityCount ;i++ ) {
        wsprintf(Buffer, TEXT("-%lu"), pSID->SubAuthority[i]);
		lstrcat(szSID, Buffer);
    }
}

DWORD GetCurrentUserBinarySID(char* rgSID)
{
	HANDLE hToken;
	DWORD dwRes = GetCurrentUserToken(hToken);
	if(dwRes != ERROR_SUCCESS)
		return dwRes;

	UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
	ULONG ReturnLength;

	BOOL f = W32::GetTokenInformation(hToken,
												TokenUser,
												TokenInformation,
												sizeof(TokenInformation),
												&ReturnLength);

	if(f == FALSE)
	{
		return GetLastError();
	}

	PISID iSid = (PISID)((PTOKEN_USER)TokenInformation)->User.Sid;
	if (W32::CopySid(cbMaxSID, rgSID, iSid))
		return ERROR_SUCCESS;
	else
		return GetLastError();
}

DWORD GetOtherUserBinarySID(const TCHAR* szUserName, char* rgSID)
{
	TCHAR        szDomain[MAX_PATH+1];
	DWORD        cbDomain = MAX_PATH; 

	DWORD dwSID = cbMaxSID;
	SID_NAME_USE snu;

	BOOL fRes = W32::LookupAccountName(0,
												  szUserName,
												  rgSID,
												  &dwSID,
												  szDomain,
												  &cbDomain,
												  &snu);

	if(fRes == FALSE)
		return GetLastError();
	else
		return ERROR_SUCCESS;
}


DWORD GetUserBinarySID(const TCHAR* szUserName, char* rgSID)
// get the (binary form of the) SID for the specified user
{
	if(szUserName && *szUserName)
	{
		return GetOtherUserBinarySID(szUserName, rgSID);
	}
	else
	{
		return GetCurrentUserBinarySID(rgSID);
	}
}

DWORD GetUserStringSID(const TCHAR* szUser, TCHAR* szSID, char* pbBinarySID)
// get string form of SID for current user
{
	if(g_fWin9X)
	{
		_tprintf(TEXT("GetUserSID called on Win9X\r\n"));
		return ERROR_INVALID_FUNCTION;
	}

	char rgchSID[cbMaxSID];
	char* pchSID = (pbBinarySID) ? pbBinarySID : rgchSID;

	DWORD dwRet = GetUserBinarySID(szUser, pchSID);
	if(dwRet == ERROR_SUCCESS)
	{
		GetStringSID((PISID)pchSID, szSID);
	}
	return dwRet;
}


LONG MyRegQueryValueEx(HKEY hKey,
							  const TCHAR* lpValueName,
							  LPDWORD /*lpReserved*/,
